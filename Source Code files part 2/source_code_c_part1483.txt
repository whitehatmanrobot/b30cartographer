al decode will get width and height.
    Assert(imagestream);

    DecodeImageFromFilename(_filename,
                            imagestream,
                            false,
                            NULL,
                            NULL,
                            NULL,
                            &_width,
                            &_height);

    // Reset the stream back to its start
    LARGE_INTEGER pos;
    pos.LowPart = pos.HighPart = 0;
    HRESULT hr = imagestream->Seek(pos, STREAM_SEEK_SET, NULL);
    
    Assert(hr != E_PENDING && "Storage is asynchronous -- not expected");

    if (SUCCEEDED(hr)) {
        
        SetRect(&_rect, 0,0, _width, _height);

        // Only stash this if we've successfully been able to complete
        // our first pass.
        _imagestream = imagestream;
        
        _resolution = ViewerResolution();

        _membersReady = true;
    }
}

PluginDecoderImageClass::~PluginDecoderImageClass()
{
    if (_heapCreatedOn) {
        if (_filename)
            StoreDeallocate(*_heapCreatedOn, _filename);

        if (_urlPath)
            StoreDeallocate(*_heapCreatedOn, _urlPath);
    }
}


void
PluginDecoderImageClass::InitIntoDDSurface(DDSurface *finalSurface,
                                           ImageDisplayDev *dev)
{
    Assert( finalSurface );
    Assert( finalSurface->IDDSurface() );

    if( FAILED(finalSurface->IDDSurface()->Restore()) ) {
        RaiseException_InternalError("Restore on finalSurface in PluginDecoderImageClass");
    }   
        
    if (!_imagestream) {

        // This means we've already read this file once and closed the
        // stream.  Reopen the stream as a blocking stream (hopefully
        // it will still be in the local cache.)

        HRESULT hr =
            URLOpenBlockingStream(NULL,
                                  _urlPath,
                                  &_imagestream,
                                  0,
                                  NULL);

        if (FAILED(hr)) {
            TraceTag((tagImageDecode,
                      "InitIntoDDSurface - Failed to get an IStream."));
            RaiseException_UserError(hr, IDS_ERR_FILE_NOT_FOUND, _urlPath);
        }
        
    }
    Assert(_imagestream);
    
    // First, see if the surface we've been passed to render into is
    // the same format as the BFID of the image about to be decoded.
    // If so, just pass it directly as the surface to decode into.
    DirectDrawImageDevice *ddDev =
        SAFE_CAST(DirectDrawImageDevice *, dev);
    DirectDrawViewport& viewport = ddDev->_viewport;
        
    // Just go directly into the surface that we're passed.  Any
    // errors will be thrown as exceptions.
    DAComPtr<IDirectDrawSurface> surfToDecodeInto;
    
    bool usingProvidedSurface = 
        DecodeImageFromFilename(_filename,
                                _imagestream,
                                true,
                                &viewport,
                                finalSurface,
                                &surfToDecodeInto,
                                NULL,
                                NULL);

    if (!usingProvidedSurface) {

        PixelFormatConvert(surfToDecodeInto,
                           finalSurface->IDDSurface(),
                           _width,
                           _height,
                           NULL,
                           false);

        // if this was only used for decoding, release it here.
        surfToDecodeInto.Release();
    }

    // Release the stream.  If we need to decode into another surface,
    // we'll reopen the imagestream from the URLpath
    _imagestream.Release();
}

Image *
PluginDecoderImage(char *urlPath,
                   char *cachePath,
                   IStream *imagestream,
                   bool useColorKey,
                   BYTE ckRed,
                   BYTE ckGreen,
                   BYTE ckBlue)
{
    COLORREF colorRef;
    if (useColorKey) {
        colorRef = RGB(ckRed, ckGreen, ckBlue);
    } else {
        colorRef = INVALID_COLORKEY;
    }
    
    PluginDecoderImageClass * pPlugin = NEW PluginDecoderImageClass();

    pPlugin->Init(urlPath, cachePath, imagestream, colorRef);

    return pPlugin;
}

void
InitializeModule_PlugImg()
{
    if (!plugImgCritSect) {
        plugImgCritSect = NEW CritSect;
    }
}

void
DeinitializeModule_PlugImg(bool bShutdown)
{
    if (plugImgCritSect) {
        delete plugImgCritSect;
        plugImgCritSect = NULL;
    }
    
    if (hInstImgUtil) {
        FreeLibrary(hInstImgUtil);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\values\image\urlimage.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/

#include "headers.h"

#include <appelles/hacks.h>

#include <commctrl.h>
#include <ole2.h>
#include <dxhtml.h>

#include <privinc/server.h>
#include <server/view.h>       // GetEventQ()
#include <server/eventq.h>
#include <privinc/viewport.h>
#include <privinc/dddevice.h>
#include <privinc/ddsurf.h>
#include <privinc/ipc.h>
#include <privinc/UrlImage.h>

#include "DXHTML_i.c"  // DXHTML GUIDS


#define  USEDXHTML 1

UrlImage::UrlImage(IDirectXHTML *pDxhtml,
                   AxAString *url) :
         _url(url),
         _isHit(false),
         _downdLoadComplete(false)
{
#if USEDXHTML    
    Assert(pDxhtml);
#endif    

    _pDXHTML = pDxhtml; // addref
    
    DebugCode
    (
        _initialDDSurf = NULL;
    );
    
    if(_resolution < 0) {
        _resolution = NumberToReal(PRIV_ViewerResolution(0));
    }
    _width = _height = 0;
    SetBbox(_width, _height, _resolution);

    if(!SetupDxHtml()) {
        // can't render at all... we're useless.
        _pDXHTML = NULL;
    }

    _lastTime = _curTime = 0;
    
    // not necessary
    //DynamicPtrDeleter<UrlImage> *dltr = new DynamicPtrDeleter<UrlImage>(this);
    //GetHeapOnTopOfStack().RegisterDynamicDeleter(dltr);
}


void UrlImage::InitializeWithDevice(ImageDisplayDev *dev, Real res)
{
    if( !_membersReady) {
        _dev = (DirectDrawImageDevice *)dev;
        SetMembers(_dev->GetViewport()->Width(),
                   _dev->GetViewport()->Height());
        SetBbox(_width, _height, _resolution);
    }
}

bool UrlImage::SetupDxHtml()
{
#if USEDXHTML
    Assert( _pDXHTML );

    HRESULT hr;
    //
    // Setup Callback Interface for DXHTML
    //
    _pDXHTMLCallback = new CDirectXHTMLCallback(this); // ref=1

    if (!_pDXHTMLCallback)
    {
        Assert(0 && "Unable to Create DirectXHTMLCallback Interface!!!");
        return false;
    }

    hr = _pDXHTML->RegisterCallback(_pDXHTMLCallback, DXHTML_CBFLAGS_ALL);
    if (FAILED(hr))  return false;

    hr = _pDXHTML->put_scroll(true);
    if (FAILED(hr))  return false;

    hr = _pDXHTML->put_hyperlinkmode(DXHTML_HYPERLINKMODE_NONE);
    if (FAILED(hr))  return false;

    return true;
#else
    return false;
#endif
}

Bool UrlImage::
DetectHit(PointIntersectCtx& ctx)
{
    Point2Value *lcPt = ctx.GetLcPoint();

    if (!lcPt) return FALSE;    // singular matrix
    
    if (BoundingBox().Contains(Demote(lcPt))) {

        // we're hit, set this flag. render will pass
        // events down when it checks it
        _isHit = true;
        
        //::SubscribeToWindEvents(this);
        
        Point2Value *pts[1];
        pts[0] = lcPt;
        POINT gdiPts;
        _dev->TransformPointsToGDISpace(identityTransform2,
                                        pts,
                                        &gdiPts,
                                        1);

        _lastHitX = gdiPts.x;
        _lastHitY = gdiPts.y;
        
        LRESULT lResult;

        UINT msg = WM_MOUSEMOVE;
        WPARAM wParam = 0;
        LPARAM lParam = MAKELPARAM( gdiPts.x, gdiPts.y );

        #if USEDXHTML
        _pDXHTML->WindowMessage(msg, wParam, lParam, &lResult);
        #endif
    }
    return FALSE;
}

void UrlImage::OnWindowMessage(UINT msg,
                               WPARAM wParam,
                               LPARAM lParam)
{
    Assert(0);
    
    if( _pDXHTML ) {

        //case WM_SIZE:  pass this if we want it to change vp ?

        switch(msg) {
          case WM_LBUTTONUP:
          case WM_LBUTTONDOWN:
          case WM_LBUTTONDBLCLK:
          case WM_RBUTTONUP:
          case WM_RBUTTONDOWN:
          case WM_RBUTTONDBLCLK:
          case WM_MBUTTONUP:
          case WM_MBUTTONDOWN:
          case WM_MBUTTONDBLCLK:
            // lie about mouse pos!
            lParam = MAKELPARAM( _lastHitX, _lastHitY );
            break;
          case WM_KEYDOWN:
          case WM_SYSKEYDOWN:
          case WM_KEYUP:
          case WM_SYSKEYUP:
            break;

            // don't care
          case WM_MOUSEMOVE:
          default:
            return;  // out, we don't send other msgs down!
            break;
        }            

        LRESULT lResult;
        _pDXHTML->WindowMessage(msg, wParam, lParam, &lResult);
    } // if
}

/*
void UrlImage::OnEvent(AXAWindEvent *ev)
{

    Assert(ev);
    if( _pDXHTML ) {

        bool sendEvent = true;
        // send it down baby!

        UINT msg;
        WPARAM wParam = 0;
        LPARAM lParam = 0;

        _pDXHTML->WindowMessage(msg, wParam, lParam, &lResult);
        BYTE winMod = 0;
        if( ev->modifiers & AXAEMOD_SHIFT_MASK ) winMod |= VK_SHIFT;
        if( ev->modifiers & AXAEMOD_CTRL_MASK )  winMod |= VK_CTRL;
        if( ev->modifiers & AXAEMOD_MENU_MASK )  winMod |= VK_MENU;
        if( ev->modifiers & AXAEMOD_ALT_MASK )   winMod |= VK_ALT;
        if( ev->modifiers & AXAEMOD_META_MASK )  winMod |= VK_META;
            
        switch( ev->id ) {
          case AXAE_MOUSE_MOVE:
            // can't use these because we don't know how to map them
            sendEvent = false;
            break;
            
          case AXAE_MOUSE_BUTTON:

            if( ev->data == AXA_MOUSE_BUTTON_LEFT &&
                ev->bState == AXA_STATE_DOWN ) {
                msg = WM_LBUTTONDOWN;
            } else 
            if( ev->data == AXA_MOUSE_BUTTON_LEFT &&
                ev->bState == AXA_STATE_UP ) {
                msg = WM_LBUTTONUP;
            } else
                
            if( ev->data == AXA_MOUSE_BUTTON_RIGHT &&
                ev->bState == AXA_STATE_DOWN ) {
                msg = WM_RBUTTONDOWN;
            } else 
            if( ev->data == AXA_MOUSE_BUTTON_RIGHT &&
                ev->bState == AXA_STATE_UP ) {
                msg = WM_RBUTTONUP;
            } else
                
            if( ev->data == AXA_MOUSE_BUTTON_MIDDLE &&
                ev->bState == AXA_STATE_DOWN ) {
                msg = WM_MBUTTONDOWN;
            } else 
            if( ev->data == AXA_MOUSE_BUTTON_MIDDLE &&
                ev->bState == AXA_STATE_UP ) {
                msg = WM_MBUTTONUP;
            } 
                
            lParam = MAKELPARAM( _lastHitX, _lastHitY );
            break;
            
          case AXAE_KEY:
            char key = (char)ev->data; // which key
            
            if( ev->bState == AXA_STATE_DOWN )
                msg = WM_KEYDOWN;
            else
                msg = WM_KEYUP;

            lParam = 0xc0000000;
            wParam = key;
            break;
            
          case AXAE_FOCUS:
          case AXAE_APP_TRIGGER:
          default:
            sendEvent = false;
        }

        if( sendEvent ) {
            LRESULT lResult;
            _pDXHTML->WindowMessage(msg, wParam, lParam, &lResult);
        }
        
    } // if _pDXHTML
}
*/

#if 0
// for testing...
extern void
MyDoBits16(LPDDRAWSURFACE surf16, LONG width, LONG height);
#endif

void UrlImage::Render(GenericDevice& dev)
{

    if( _isHit ) {
        //
        // Update mshtml with all events since
        //
        EventQ &evQ = GetCurrentView().GetEventQ();

        AXAWindEvent *ev;

        #if USEDXHTML
        if( evQ.Iterate_BeginAtTime(_lastTime) && _pDXHTML) {
        #else
        if( evQ.Iterate_BeginAtTime(_lastTime)) {
        #endif  
        
            LRESULT lResult;
            while( ev = evQ.Iterate_GetCurrentEventBeforeTime(_curTime) ) {

                // put this in when events have window messages in them
                #if 0
        #if USEDXHTML
                if( ev->_msg != WM_MOUSEMOVE ) {
                    _pDXHTML->WindowMessage(ev->_msg,
                                            ev->_wParam,
                                            ev->_lParam,
                                            &lResult);
                }
        #endif
                #endif
            
                //if( ev->_msg == WM_LBUTTONDOWN ) TraceTag((tagError,"------> LButton Down <------"));
                //if( ev->_msg == WM_LBUTTONUP ) TraceTag((tagError,"------> LButton Up <------"));
                                
                evQ.Iterate_Next();
            }
        }
    } // _isHit

    
    #if USEDXHTML

    // to be smarter, just update the invalidates we get in the callback
    if( _pDXHTML && _membersReady && _downdLoadComplete) {
        HRESULT hr = _pDXHTML->UpdateSurfaceRect( GetRectPtr() );
        Assert( SUCCEEDED(hr) );
    }
    
    #else

    DebugCode(
        // paint bogus in the surface
        if( _initialDDSurf ) {
            MyDoBits16(_initialDDSurf->IDDSurface(),
                       _initialDDSurf->Width(),
                       _initialDDSurf->Height());
        }
    );
    
    #endif
    

    DiscreteImage::Render(dev);
}


void UrlImage::
InitIntoDDSurface(DDSurface *ddSurf,
                  ImageDisplayDev *dev)
{
    Assert( ddSurf );

    DebugCode(_initialDDSurf = ddSurf);
    
    //
    // Set up widht, height, rect, and bbox!
    //
    _width = ddSurf->Width();
    _height = ddSurf->Height();
    ::SetRect(&_rect, 0,0, _width, _height);
    SetBbox( GetPixelWidth(),
             GetPixelHeight(),
             GetResolution() );
    _bboxReady = TRUE;
    _membersReady = TRUE;


#if USEDXHTML
    Assert( _pDXHTML );
    HRESULT hr;

    hr = _pDXHTML->put_surface( ddSurf->IDDSurface() );
    Assert( SUCCEEDED(hr) );

    hr = _pDXHTML->put_src( _url->GetStr() );
    Assert( SUCCEEDED(hr) );
#endif    
}


Image *ConstructUrlImage(AxAString *str)
{
    DAComPtr< IDirectXHTML > pDxhtml;

    Image *outImage;
    
#if USEDXHTML
    HRESULT hr = CoCreateInstance(CLSID_CDirectXHTML,
                                  NULL,
                                  CLSCTX_INPROC_SERVER,
                                  IID_IDirectXHTML,
                                  (void **)&pDxhtml);
    if (FAILED(hr))
    {
        TraceTag((tagError, "ContrustUrlImage - Unable to load DXHTML.DLL"));
        outImage = emptyImage;
    } else
#endif
      {
          outImage = NEW UrlImage(pDxhtml, str);
      }
    
    return outImage;
}

Image *UrlImageSetTime(Image *img, AxANumber *t)
{
    Assert(img);
    
    if(img->GetValTypeId() == URLIMAGE_VTYPEID) {
        UrlImage *urlImage = SAFE_CAST(UrlImage *, img);
        urlImage->SetSampleTime( NumberToReal(t) );
    }

    return img;
}
    

//**********************************************************************
// File name: dxhtmlcb.cpp
//
// Functions:
//
// Copyright (c) 1997 Microsoft Corporation. All rights reserved.
//**********************************************************************


//****************************************************************************
//
// CDirectXHTMLCallback::CDirectXHTMLCallback
// CDirectXHTMLCallback::~CDirectXHTMLCallback
// 
// Purpose:
//      Constructor and Destructor members for CDirectXHTMLCallback object.
//
//****************************************************************************

CDirectXHTMLCallback::CDirectXHTMLCallback( UrlImage *urlImage )
{
    _urlImage = urlImage;
    m_cRef  = 0;
}


CDirectXHTMLCallback::~CDirectXHTMLCallback( void )
{
}




//****************************************************************************
//
// CDirectXHTMLCallback::QueryInterface
// CDirectXHTMLCallback::AddRef
// CDirectXHTMLCallback::Release
// 
// Purpose:
//      IUnknown members for CDirectXHTMLCallback object.
//
//****************************************************************************

STDMETHODIMP CDirectXHTMLCallback::QueryInterface( REFIID riid, void **ppv )
{
    // DPF( 4, TEXT("CDirectXHTMLCallback::QueryInterface") );

    *ppv = NULL;

    //
    // BUGBUG - When we have a GUID interface, we should check for it
    //

    if ( NULL != *ppv )
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    //DPGUID( TEXT("CDirectXHTMLCallback::QueryInterface"), riid);

    return E_NOINTERFACE;
}


STDMETHODIMP_(ULONG) CDirectXHTMLCallback::AddRef( void )
{
    // DPF( 0, TEXT("CDirectXHTMLCallback::AddRef [%lu -> %lu]"), m_cRef, (m_cRef + 1) );

    return ++m_cRef;
}


STDMETHODIMP_(ULONG) CDirectXHTMLCallback::Release( void )
{
    // DPF( 0, TEXT("CDirectXHTMLCallback::Release [%lu -> %lu]"), m_cRef, (m_cRef - 1) );

    if ( m_cRef == 0 )
    {
        // DPF( 0, TEXT("CDirectXHTMLCallback::Release - YIKES! Trying to decrement when Ref count is zero!!!") );
        //DBREAK();
        Assert(0 && "Release 0 obj!");
        return m_cRef;
    }

    if ( 0 != --m_cRef )
    {
        return m_cRef;
    }

    // DPF( 0, TEXT("CDirectXHTMLCallback::Release - CDirectXHTMLCallback has been deleted.") );
    delete this;
    return 0;
}




//****************************************************************************
// Function: CDirectXHTMLCallback::OnSetTitleText()
//
// Purpose:
//
// Parameters:
//
// Return Code:
//      HRESULT
//
// Comments:
//      None.
//
//****************************************************************************
STDMETHODIMP CDirectXHTMLCallback::OnSetTitleText( LPCWSTR lpszText )
{
    TCHAR szBuffer[MAX_PATH];
    TCHAR szMsg[MAX_PATH];

    // DPF( 4, TEXT("CDirectXHTMLCallback::OnSetTitleText") );

    /*
    //
    // Set Text
    //
    if ( WideCharToMultiByte( CP_ACP, 0, lpszText, -1, szBuffer, MAX_PATH, NULL, NULL ) )
    {
        wsprintf( szMsg, TEXT("Contain - %s"), szBuffer );
        SendMessage( pApp->m_hWndMain, WM_SETTEXT, 0, (LPARAM)szBuffer );
    }
    */
    return S_OK;
}




//****************************************************************************
// Function: CDirectXHTMLCallback::OnSetProgressText()
//
// Purpose:
//
// Parameters:
//
// Return Code:
//      HRESULT
//
// Comments:
//      None.
//
//****************************************************************************
STDMETHODIMP CDirectXHTMLCallback::OnSetProgressText( LPCWSTR lpszText )
{
    TCHAR szBuffer[MAX_PATH];

    // DPF( 4, TEXT("CDirectXHTMLCallback::OnSetProgressText") );

    /*
    //
    // Set Text
    //    
    if ( WideCharToMultiByte( CP_ACP, 0, lpszText, -1, szBuffer, MAX_PATH, NULL, NULL ) )
    {
        SendMessage( pApp->m_hWndStatusbar, SB_SETTEXT, SB_PROGRESSTEXT, (LPARAM)szBuffer );
    }
    */
    
    return S_OK;
}




//****************************************************************************
// Function: CDirectXHTMLCallback::OnSetStatusText()
//
// Purpose:
//
// Parameters:
//
// Return Code:
//      HRESULT
//
// Comments:
//      None.
//
//****************************************************************************
STDMETHODIMP CDirectXHTMLCallback::OnSetStatusText( LPCWSTR lpszText )
{
    TCHAR szBuffer[MAX_PATH];

    // DPF( 4, TEXT("CDirectXHTMLCallback::OnSetStatusText") );

    /*
    //
    // Set Text
    //    
    if ( WideCharToMultiByte( CP_ACP, 0, lpszText, -1, szBuffer, MAX_PATH, NULL, NULL ) )
    {
        SendMessage( pApp->m_hWndStatusbar, SB_SETTEXT, SB_STATUSTEXT, (LPARAM)szBuffer );
    }
    */
    
    return S_OK;
}


//****************************************************************************
// Function: CDirectXHTMLCallback::OnSetProgressText()
//
// Purpose:
//
// Parameters:
//
// Return Code:
//      HRESULT
//
// Comments:
//      None.
//
//****************************************************************************
STDMETHODIMP CDirectXHTMLCallback::OnSetProgressMax( const DWORD dwMax )
{
    /*
    if (pApp->m_hWndProgress) 
    {
        if ( dwMax == 0 )
        {
            ShowWindow( pApp->m_hWndProgress, SW_HIDE );
        }
        else
        {
            RECT rc;

            SendMessage( pApp->m_hWndStatusbar, SB_GETRECT, SB_PROGRESSMETER, (LPARAM)&rc );
            InflateRect( &rc, -GetSystemMetrics(SM_CXEDGE), -GetSystemMetrics(SM_CYEDGE) );
            SetWindowPos (pApp->m_hWndProgress, NULL, rc.left, rc.top, rc.right-rc.left, rc.bottom-rc.top, SWP_NOZORDER | SWP_NOACTIVATE | SWP_SHOWWINDOW );
            SendMessage( pApp->m_hWndProgress, PBM_SETRANGE32, 0, (LPARAM)dwMax );
            SendMessage( pApp->m_hWndProgress, PBM_SETPOS, 0, 0);
        }
    }
    */
    return S_OK;
}




//****************************************************************************
// Function: CDirectXHTMLCallback::OnSetProgressPos()
//
// Purpose:
//
// Parameters:
//
// Return Code:
//      HRESULT
//
// Comments:
//      None.
//
//****************************************************************************
STDMETHODIMP CDirectXHTMLCallback::OnSetProgressPos( const DWORD dwPos )
{
    /*
    if ( pApp->m_hWndProgress )
    {
        SendMessage( pApp->m_hWndProgress, PBM_SETPOS, (LPARAM)dwPos, 0 );
    }
    */
    return S_OK;
}




//****************************************************************************
// Function: CDirectXHTMLCallback::OnCompletedDownload()
//
// Purpose:
//
// Parameters:
//
// Return Code:
//      HRESULT
//
// Comments:
//      None.
//
//****************************************************************************
STDMETHODIMP CDirectXHTMLCallback::OnCompletedDownload( void )
{
    SIZEL sizeDoc;
    _urlImage->GetDXHTML()->get_docsize( &sizeDoc );
    _urlImage->OnCompletedDownload( &sizeDoc );
    
    TraceTag((tagUrlImage,
              "Document has completed downloading...\n\nSize of Document is %d x %d",
              sizeDoc.cx, sizeDoc.cy ));

    return S_OK;
}




//****************************************************************************
// Function: CDirectXHTMLCallback::OnInvalidate()
//
// Purpose:  Invalidation notification from dxhtml.
//           We should issue a draw in reply.  
//
// Parameters:  lprc - RECT of newly invalidated area in client pixel units
//              fErase - equivalent of ::InvalidateRect()'s fErase param
//
// Return Code:
//      HRESULT
//
// Comments:
//      None.
//
//****************************************************************************
STDMETHODIMP CDirectXHTMLCallback::OnInvalidate( const RECT *lprc, 
                                                 DWORD       dwhRgn,
                                                 VARIANT_BOOL fErase )
{
    // DPF( 4, TEXT("CDirectXHTMLCallback::OnInvalidate") );

    /*
    HRGN hRgn = reinterpret_cast<HRGN>(dwhRgn);
    if( hRgn )
    {
        ::InvalidateRgn( pApp->m_hWndMain, hRgn, !!fErase );
    }
    else
    {
        ::InvalidateRect( pApp->m_hWndMain, lprc, !!fErase );
    }
    */
    return S_OK;
} // CDirectXHTMLCallback::OnInvalidate


//****************************************************************************
//****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\values\misc\4x4xform.cpp ===
/*******************************************************************************
Copyright (c) 1995-1998 Microsoft Corporation.  All rights reserved.

    Transform-generating functions and transform manipulation.
*******************************************************************************/

#include "headers.h"
#include "appelles/common.h"

#include "privinc/matutil.h"
#include "privinc/xformi.h"
#include "privinc/vec3i.h"
#include "privinc/basic.h"
#include "appelles/xform.h"
#include "backend/values.h"

extern const Apu4x4Matrix apuIdentityMatrix;

    // The Xform4x4 class is just a wrapper for the Apu4x4Matrix that also
    // derives from Transform3.  It's apparently done this way so you can
    // operate on the Apu4x4Matrix without bringing along the full Transform3
    // class.

class Xform4x4 : public Transform3
{
  public:
    Apu4x4Matrix matrix;

    Xform4x4 () {}
    Xform4x4 (const Apu4x4Matrix& _matrix) : matrix(_matrix) {}
    virtual const Apu4x4Matrix& Matrix ();

    virtual bool SwitchToNumbers(Transform2::Xform2Type ty,
                                 Real                  *numbers) {

        switch (ty) {
          case Transform2::Translation:
            {
                if (matrix.form != Apu4x4Matrix::TRANSLATE_E) { return false; }
            
                Real x = numbers[0];
                Real y = numbers[1];
                Real z = numbers[2];
                if (matrix.pixelMode) {
                    x = PixelToNum(x);
                    y = PixelYToNum(y);
                    z = PixelToNum(z);
                }

                ApuTranslate(x, y, z, matrix.pixelMode, matrix);
            
            }
            break;

          case Transform2::Rotation:
            {
                // Note that here we're just looking for an upper 3x3,
                // since the matrix algebra here doesn't distinguish
                // those from the more specific rotations.  This means
                // that switching a shear to a rotate will succeed,
                // where one might expect it not to...
                if (matrix.form != Apu4x4Matrix::UPPER_3X3_E) { return false; }
                
                ApuRotate(numbers[0],
                          numbers[1],
                          numbers[2],
                          numbers[3] * degToRad,
                          matrix);
            }
            break;

          case Transform2::Scale:
            {
                // Note that here we're just looking for an upper 3x3,
                // since the matrix algebra here doesn't distinguish
                // those from the more specific scales.  This means
                // that switching a shear to a scale will succeed,
                // where one might expect it not to...
                if (matrix.form != Apu4x4Matrix::UPPER_3X3_E) { return false; }
                
                ApuScale(numbers[0],
                         numbers[1],
                         numbers[2],
                         matrix);
            }
            break;

        }

        return true;
    }
    
};



/*****************************************************************************
The Matrix() member function of a transform just returns the matrix used in
the implementation.
*****************************************************************************/

const Apu4x4Matrix& Xform4x4::Matrix ()
{
    return matrix;
}



/*****************************************************************************
This function converts from a generalized transform to a 4x4 matrix.
*****************************************************************************/

Transform3 *Apu4x4XformImpl (const Apu4x4Matrix& m)
{
    Transform3 *newxf = NEW Xform4x4 (m);

    CHECK_MATRIX(m);

    return newxf;
}



/****************************************************************************/

Transform3 *TranslateWithMode (Real Tx, Real Ty, Real Tz, bool pixelMode)
{
    Xform4x4 *m = NEW Xform4x4 ();
    ApuTranslate (Tx, Ty, Tz, pixelMode, m->matrix);

    CHECK_MATRIX(m->matrix);

    return m;
}

Transform3 *Translate (Real Tx, Real Ty, Real Tz)
{
    return TranslateWithMode(Tx, Ty, Tz, false);
}



/****************************************************************************/

Transform3 *TranslateReal3 (AxANumber *Tx, AxANumber *Ty, AxANumber *Tz)
{
    return Translate (NumberToReal(Tx), NumberToReal(Ty), NumberToReal(Tz));
}



/****************************************************************************/

Transform3 *TranslateVector3 (Vector3Value *delta)
{
    return Translate (delta->x, delta->y, delta->z);
}



/****************************************************************************/

Transform3 *TranslatePoint3 (Point3Value *new_origin)
{
    return Translate (new_origin->x, new_origin->y, new_origin->z);
}



/****************************************************************************/

Transform3 *Scale (Real Sx, Real Sy, Real Sz)
{
    Xform4x4 *m = NEW Xform4x4 ();
    ApuScale (Sx, Sy, Sz, m->matrix);
    CHECK_MATRIX(m->matrix);
    return m;
}



/****************************************************************************/

Transform3 *ScaleReal3 (AxANumber *x, AxANumber *y, AxANumber *z)
{
    return Scale (NumberToReal(x), NumberToReal(y), NumberToReal(z));
}



/****************************************************************************/

Transform3 *ScaleVector3 (Vector3Value *V)
{
    return Scale (V->x, V->y, V->z);
}



/****************************************************************************/

Transform3 *Scale3UniformDouble (Real n)
{
    return Scale (n, n, n);
}

Transform3 *Scale3UniformNumber (AxANumber *s)
{
    return (Scale3UniformDouble(NumberToReal (s)));
}



/*****************************************************************************
This function generates a transform that rotates points around the axis
specified by the three real values.  Since we're working in a left-hand
coordinate system, this means that rotations are clockwise if the vector
going from the origin to point <x,y,z> is poking us in the eye.  The angle
is assumed to be specified in radians.
*****************************************************************************/

Transform3 *RotateXyz (Real radians, Real x, Real y, Real z)
{
    Xform4x4 *m = NEW Xform4x4();
    ApuRotate (radians, x, y, z, m->matrix);

    CHECK_MATRIX(m->matrix);

    return m;
}



/*****************************************************************************
This function generates a rotation just as Rotate(angle,x,y,z), except that
the rotation axis is specified by a Vector3 *parameter.  Again, angles are
assumed to be specified in radians.
*****************************************************************************/

Transform3 *RotateAxis (Vector3Value *axis, Real radians)
{
    Xform4x4 *m = NEW Xform4x4();

    if (axis == xVector3)
        ApuRotateX (radians, m->matrix);
    else if (axis == yVector3)
        ApuRotateY (radians, m->matrix);
    else if (axis == zVector3)
        ApuRotateZ (radians, m->matrix);
    else
        ApuRotate (radians, axis->x,axis->y,axis->z, m->matrix);

    CHECK_MATRIX(m->matrix);

    return m;
}

Transform3 *RotateAxisReal (Vector3Value *axis, AxANumber *radians)
{   Real d = NumberToReal(radians);
    return(RotateAxis(axis,d));
}


/*****************************************************************************
The following three functions generate rotations about the X, Y & Z axes.
*****************************************************************************/

Transform3 *RotateX (Real radians)
{
    Xform4x4 *m = NEW Xform4x4();
    ApuRotateX (radians, m->matrix);
    CHECK_MATRIX(m->matrix);
    return m;
}

Transform3 *RotateY (Real radians)
{
    Xform4x4 *m = NEW Xform4x4();
    ApuRotateY (radians, m->matrix);
    CHECK_MATRIX(m->matrix);
    return m;
}

Transform3 *RotateZ (Real radians)
{
    Xform4x4 *m = NEW Xform4x4();
    ApuRotateZ (radians, m->matrix);
    CHECK_MATRIX(m->matrix);
    return m;
}



/*****************************************************************************
The following functions create shear transforms.  The parameters (a-f)
correspond to the following:
                                   Y
                                   |
    +-          -+                 +-c
    | 1  c  e  0 |                /|     a
    | a  1  f  0 |               d |     |
    | b  d  1  0 |                 +-----+-- X
    | 0  0  0  1 |              f /     /
    +-          -+              |/     b
                                +-e
                               /
                              Z
*****************************************************************************/

Transform3 *XShear3Double (Real a, Real b)
{
    Xform4x4 *m = NEW Xform4x4();
    ApuShear (a,b, 0,0, 0,0, m->matrix);
    CHECK_MATRIX(m->matrix);
    return m;
}

Transform3 *XShear3Number (AxANumber *a, AxANumber *b)
{   return (XShear3Double(NumberToReal(a),NumberToReal(b)));
}

Transform3 *YShear3Double (Real c, Real d)
{
    Xform4x4 *m = NEW Xform4x4();
    ApuShear (0,0, c,d, 0,0, m->matrix);
    CHECK_MATRIX(m->matrix);
    return m;
}

Transform3 *YShear3Number (AxANumber *c, AxANumber *d)
{   return (YShear3Double(NumberToReal(c),NumberToReal(d)));
}


Transform3 *ZShear3Double (Real e, Real f)
{
    Xform4x4 *m = NEW Xform4x4();
    ApuShear (0,0, 0,0, e,f, m->matrix);
    CHECK_MATRIX(m->matrix);
    return m;
}

Transform3 *ZShear3Number (AxANumber *e, AxANumber *f)
{   return (ZShear3Double(NumberToReal(e),NumberToReal(f)));
}


/*****************************************************************************
This function creates a Transform3 from the 16 matrix elements, top to bottom,
left to right.
*****************************************************************************/

Transform3 *Transform3Matrix16 (
    Real m00, Real m01, Real m02, Real m03,
    Real m10, Real m11, Real m12, Real m13,
    Real m20, Real m21, Real m22, Real m23,
    Real m30, Real m31, Real m32, Real m33)
{
    Xform4x4 *xf44 = NEW Xform4x4 ();
    Apu4x4MatrixArray_t &matrix = xf44->matrix.m;

    matrix[0][0]=m00; matrix[0][1]=m01; matrix[0][2]=m02; matrix[0][3]=m03;
    matrix[1][0]=m10; matrix[1][1]=m11; matrix[1][2]=m12; matrix[1][3]=m13;
    matrix[2][0]=m20; matrix[2][1]=m21; matrix[2][2]=m22; matrix[2][3]=m23;
    matrix[3][0]=m30; matrix[3][1]=m31; matrix[3][2]=m32; matrix[3][3]=m33;

    xf44->matrix.SetType();    // Auto-Characterize Matrix Type

    CHECK_MATRIX (xf44->Matrix());

    return xf44;
}



/*****************************************************************************
This function generates a transform from the 4x4 matrix specified in the 16
paramters.  Parameters are specified left to right, then top to bottom.
*****************************************************************************/

Transform3 *PRIVMatrixTransform4x4 (
    AxANumber *a00,   AxANumber *a01,   AxANumber *a02,   AxANumber *a03,
    AxANumber *a10,   AxANumber *a11,   AxANumber *a12,   AxANumber *a13,
    AxANumber *a20,   AxANumber *a21,   AxANumber *a22,   AxANumber *a23,
    AxANumber *a30,   AxANumber *a31,   AxANumber *a32,   AxANumber *a33)
{
    return Transform3Matrix16
           (   NumberToReal(a00), NumberToReal(a01),
               NumberToReal(a02), NumberToReal(a03),

               NumberToReal(a10), NumberToReal(a11),
               NumberToReal(a12), NumberToReal(a13),

               NumberToReal(a20), NumberToReal(a21),
               NumberToReal(a22), NumberToReal(a23),

               NumberToReal(a30), NumberToReal(a31),
               NumberToReal(a32), NumberToReal(a33)
           );
}

Transform3 *MatrixTransform4x4 (AxAArray *a)
{
    if (a->Length() != 16)
        RaiseException_UserError(E_FAIL, IDS_ERR_MATRIX_NUM_ELEMENTS);

    return Transform3Matrix16
           (   ValNumber ((*a)[ 0]), ValNumber ((*a)[ 1]),
               ValNumber ((*a)[ 2]), ValNumber ((*a)[ 3]),

               ValNumber ((*a)[ 4]), ValNumber ((*a)[ 5]),
               ValNumber ((*a)[ 6]), ValNumber ((*a)[ 7]),

               ValNumber ((*a)[ 8]), ValNumber ((*a)[ 9]),
               ValNumber ((*a)[10]), ValNumber ((*a)[11]),

               ValNumber ((*a)[12]), ValNumber ((*a)[13]),
               ValNumber ((*a)[14]), ValNumber ((*a)[15])
           );
}



/*****************************************************************************
This function creates a 4x4 transform from the given basis vectors and origin.
*****************************************************************************/

Transform3 *TransformBasis (
    Point3Value  *origin,
    Vector3Value *basisX,
    Vector3Value *basisY,
    Vector3Value *basisZ)
{
    Xform4x4 *xf44 = NEW Xform4x4 ();
    Apu4x4MatrixArray_t &matrix = xf44->matrix.m;

    matrix[0][0] = basisX->x;
    matrix[1][0] = basisX->y;
    matrix[2][0] = basisX->z;
    matrix[3][0] = 0;

    matrix[0][1] = basisY->x;
    matrix[1][1] = basisY->y;
    matrix[2][1] = basisY->z;
    matrix[3][1] = 0;

    matrix[0][2] = basisZ->x;
    matrix[1][2] = basisZ->y;
    matrix[2][2] = basisZ->z;
    matrix[3][2] = 0;

    matrix[0][3] = origin->x;
    matrix[1][3] = origin->y;
    matrix[2][3] = origin->z;
    matrix[3][3] = 1;

    xf44->matrix.SetType();    // Auto-Characterize Matrix Type

    CHECK_MATRIX (xf44->Matrix());

    return xf44;
}



/*****************************************************************************
This transformation is very useful for the common operation of translate
to origin, apply transformation, translate back.  The 'center' parameter
describes the point that is to be the virtual origin for the 'xform'.
*****************************************************************************/

#if 0   // UNUSED
Transform3 *DisplacedXform (Point3Value *center, Transform3 *xform)
{
    // xlt(center) o xform o xlt(-center)
    return
        TimesXformXform(TranslateVector3(MinusPoint3Point3(center,
                                                           origin3)),
           TimesXformXform(xform,
             TranslateVector3(MinusPoint3Point3(origin3, center))));
}
#endif



/*****************************************************************************
This transform returns the matrix associated with the specified Look-At-From
transform.  The three parameters are the position of the object, the target of
interest, and a vector that orients the "up" direction of the object.  Prior
to applying this transform, the object should be located at the origin, aimed
in the -Z direction, with +Y up.
*****************************************************************************/

Transform3 *LookAtFrom (
    Point3Value  *target,     // Target Point, or Point Of Interest
    Point3Value  *position,   // Position of the Eye/Camera
    Vector3Value *up)         // "Up" Direction of Camera
{
    // The object begins aimed in the -Z direction, and we want to compute the
    // NEW object Z axis (aim).  Keep in mind that since this corresponds to
    // an object pointing in -Z, the aim is actually negated.

    Vector3Value aim = (*position - *target);

    // If the aim is a zero vector, then the target and position points are
    // coincident, so we'll just use [0 0 1] as the aim vector.

    if (aim == *zeroVector3)
        aim = *zVector3;
    else
        aim.Normalize();

    // 'side' is the unit vector pointing off to the object's right.  If the up
    // vector and the aim are parallel, then we'll pick an arbitrary side
    // vector that is perpendicular to the aim.

    Vector3Value side = Cross (*up, aim);

    if (side != *zeroVector3)
        side.Normalize();

    else if (aim.x != 0)
    {   side.Set (aim.y, -aim.x, 0);
        side.Normalize();
    }

    else
    {   side = *xVector3;
    }

    // Calculate 'objup', the object's up vector for this orientation.  We
    // don't need to normalize here because 'aim' and 'side' are both unit
    // perpendicular vectors.

    Vector3Value objup = Cross (aim, side);

    // Given these three orthogonal unit vectors, we now construct the matrix
    // that describes the transformation to the specified camera position and
    // orientation.

    return Transform3Matrix16
           (   side.x, objup.x, aim.x, position->x,
               side.y, objup.y, aim.y, position->y,
               side.z, objup.z, aim.z, position->z,
               0,      0,       0,     1
           );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\values\image\xformclrimg.cpp ===
/*******************************************************************************

Copyright (c) 1995-98 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"

#include "privinc/imagei.h"
#include "privinc/xformi.h"

class TransformColorImage : public AttributedImage {

  public:
    TransformColorImage(Image *image, Transform3 *xf);

    void Render(GenericDevice& dev);

    #if _USE_PRINT
    ostream& Print(ostream& os) {
        return os << "(TransformColorImage @ " << (void *)this << ")";
    }   
    #endif

  private:
    Transform3 *_colorTransform;
};


TransformColorImage::TransformColorImage(
    Image *image, Transform3 *xf) : AttributedImage(image)
{
    _colorTransform = xf;
}


void TransformColorImage::Render(GenericDevice& dev)
{
}


Image *TransformColorRGBImage(Image *image, Transform3 *xf)
{
    return NEW TransformColorImage(image, xf);
}


/*
// FUTURE: 
Image *ConstructXfClrHSLImg(Image *image, Transform3 *hslxf)
{
    // change the hsl color xf to an rgb color xf
    Tranform3 *rgbxf = ConvertHSLTransformToRGBTransform( hslxf );
    return NEW TransformColorImage(image, rgbxf);
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\values\misc\axapair.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Implement pair primitives

*******************************************************************************/


#include "headers.h"
#include "backend/values.h"
#include "privinc/except.h"
#include "appelles/axapair.h"

AxAValue FirstVal (AxAPair * p)
{
    return p->Left () ;
}

AxAValue SecondVal (AxAPair * p)
{
    return p->Right () ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\values\misc\axachstr.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Implementation of the string primitive functions

*******************************************************************************/

#include <headers.h>
#include <string.h>
#include "privinc/except.h"
#include "privinc/storeobj.h"
#include "backend/values.h"
#include "backend/bvr.h"
#include "appelles/axaprims.h"
#include "appelles/axachstr.h"

// *************************************
// * string primitives 
// *************************************

AxAString * Concat(AxAString *s1, AxAString *s2)
{
    int n = lstrlenW(s1->GetStr()) + lstrlenW(s2->GetStr()) + 1;
    WideString str = (WideString) AllocateFromStore(sizeof(WCHAR) * n);

    StrCpyW(str, s1->GetStr());
    StrCatW(str, s2->GetStr());

    return NEW AxAString(str,false);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\values\misc\arith.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Implementation of static arithmetic functions

*******************************************************************************/

#include "headers.h"
#include "appelles/arith.h"
#include "appelles/axaprims.h"

#define ASSOC_OP2(ourFunc, op) \
  AxANumber *ourFunc(AxANumber *a, AxANumber *b) \
  { return RealToNumber(NumberToReal(a) op NumberToReal(b)); }

#define ASSOC_BOOL_OP2(ourFunc, op)                    \
  AxABoolean *ourFunc(AxANumber *a, AxANumber *b) {                 \
     int result = NumberToReal(a) op NumberToReal(b);                            \
     AxABoolean *retval = result ? truePtr : falsePtr;    \
/*     printf("%8.5f %s %8.5f - Result %d, Retval 0x%x\n", *a, "op", *b, result, retval); */\
     return retval;  \
  }

#define ASSOC_FUNC1(ourFunc, mathFunc) \
  AxANumber *ourFunc(AxANumber *v) \
  { return RealToNumber(mathFunc(NumberToReal(v))); }

#define ASSOC_FUNC2(ourFunc, mathFunc) \
  AxANumber *ourFunc(AxANumber *u, AxANumber *v) \
  { return RealToNumber(mathFunc(NumberToReal(u), NumberToReal(v))); }


// Prefix operators
AxANumber *RealNegate(AxANumber *a) { return RealToNumber(- NumberToReal(a)); }
AxANumber *RealPositive(AxANumber *a) { return a; }

// Binary operators
ASSOC_OP2(RealMultiply, *  )
ASSOC_OP2(RealDivide,   /  )
ASSOC_OP2(RealAdd,      +  )
ASSOC_OP2(RealSubtract, -  )

ASSOC_BOOL_OP2(RealLT,       <  )
ASSOC_BOOL_OP2(RealLTE,      <= )
ASSOC_BOOL_OP2(RealGT,       >  )
ASSOC_BOOL_OP2(RealGTE,      >= )
ASSOC_BOOL_OP2(RealEQ,       == )
ASSOC_BOOL_OP2(RealNE,       != )

// Unary functions
ASSOC_FUNC1(RealAbs,      fabs)
ASSOC_FUNC1(RealSqrt,     sqrt)
ASSOC_FUNC1(RealFloor,    floor)
ASSOC_FUNC1(RealCeiling,  ceil)
ASSOC_FUNC1(RealAsin,     asin)
ASSOC_FUNC1(RealAcos,     acos)
ASSOC_FUNC1(RealAtan,     atan)
ASSOC_FUNC1(RealSin,      sin)
ASSOC_FUNC1(RealCos,      cos)
ASSOC_FUNC1(RealTan,      tan)
ASSOC_FUNC1(RealExp,      exp)
ASSOC_FUNC1(RealLn,       log)
ASSOC_FUNC1(RealLog10,    log10)

AxANumber *RealRadToDeg(AxANumber *rad)
{ return RealToNumber(NumberToReal(rad) / degToRad); }
AxANumber *RealDegToRad(AxANumber *deg)
{ return RealToNumber(NumberToReal(deg) * degToRad); }

AxANumber *RealRound(AxANumber *val)
{
    // Round is just floor(x+0.5)
    return RealToNumber(floor(NumberToReal(val) + 0.5));
}

// This special version of fmod works around an occasional floating
// point glitch where an operation like fmod(1840.0, 2.0) returns
// 1.9999999998.  Check for these sorts of epsilons and correct for
// them.   Our threshold is inexact, but better than not dealing with
// the problem.
static double
myFMod(double a, double b)
{
    double result = fmod(a, b);

    if (fabs(result - b) < 0.000000001) {
        result = 0.0;
    }

    return result;
}

// Binary functions
ASSOC_FUNC2(RealPower,   pow)
ASSOC_FUNC2(RealModulus, myFMod)
ASSOC_FUNC2(RealAtan2,   atan2)

// Random number functions.
// TODO: This relies on the constant folding mechanism for this to
// work.  Should really be a behavior.

class RandomSequence : public AxAValueObj {
  public:
    RandomSequence(Real seed);
    Real NextInSequence();
    Real GetRand(Real time);

    virtual DXMTypeInfo GetTypeInfo() { return AxANumberType; }

  protected:
    typedef map< Real, Real, less<Real> > RQueue;
    unsigned long _seed;
    RQueue* _randQ;
};

RandomSequence::RandomSequence(Real realSeed)
{
    // Just take the bit pattern of the input and treat it as an
    // unsigned long seed.
    Assert(sizeof(float) == sizeof(unsigned long));
    float floatSeed = (float)realSeed;
    _seed = *(unsigned long *)&floatSeed;

    // Create an offset to add to the initial seed.  This offset is
    // created once per executable invocation, and its purpose is to
    // prevent the same random number sequences from being generated
    // each time Appelles is started.  It more or less guarantees
    // randomness because the performance counter is a very high
    // resolution clock.
    static unsigned long perExecutableOffset = 0;
    if (perExecutableOffset == 0) {
        LARGE_INTEGER lpc;
        QueryPerformanceCounter(&lpc);
        perExecutableOffset = (unsigned long)lpc.LowPart;
    }

    _seed += perExecutableOffset;

    _randQ = NEW RQueue;

    GetHeapOnTopOfStack().RegisterDynamicDeleter
        (NEW DynamicPtrDeleter<RQueue>(_randQ));

}

Real
RandomSequence::NextInSequence()
{
    // Taken from the C-runtime rand() function distributed as source
    // with MS Visual C++ 4.0.
    _seed = _seed * 214013L + 2531011L;

    const unsigned int MAXVAL = 0x7fff;

    // This is between 0 and MAXVAL
    unsigned int newVal = (_seed >> 16) & MAXVAL;

    // Normalize to 0 to 1.
    return (Real)(newVal) / (Real)(MAXVAL);
}

static const Real CUTOFF = 0.5;

Real
RandomSequence::GetRand(Real time)
{
    // Cut off old random numbers, clean up.
    _randQ->erase(_randQ->begin(), _randQ->lower_bound(time - CUTOFF));

    // See if already there.
    RQueue::iterator i = _randQ->find(time);

    if (i != _randQ->end()) {
        return (*i).second;
    } else {
        Real next = NextInSequence();
        (*_randQ)[time] = next;
        return next;
    }
}

AxAValue RandomNumSequence(double seed)
{ return NEW RandomSequence(seed); }

AxAValue
PRIVRandomNumSequence(AxANumber *s)
{
    Real seed = NumberToReal(s);
    RandomSequence *rs = NEW RandomSequence(seed);
    
    return rs;
}

AxANumber *
PRIVRandomNumSampler(AxAValue seq, AxANumber *localTime)
{
    RandomSequence *randSeq = (RandomSequence *)seq;
    //Real result = randSeq->NextInSequence();
    Real result = randSeq->GetRand(ValNumber(localTime));

    return RealToNumber(result);
}

/*
  Formula from Salim
  The formula is:  f(t,s) = (t - 1)((2t-1)*s*t - 1)
  t is in [0,1]
  s is in [-1, 1] and Colin called it sharpness, 
  at s=0 we get linear rate
  for s in ]0,1] we get increasingly more slow-in-slow-out
  for s in [-1,0[ we get fast-in-fast-out

  to go from point A to point B, the linear formula is:
  C = B + (A-B)*t

  For slow-in-slow-out use C.substituteTime(f(t/duration, s))
  for a given sharpness s.

  f has the property that f(0,s) = 1 [at A], 
  f(1/2,s) = 1/2 [mid way], and 
  f(1,s)=0 [at B]
*/

AxANumber *Interpolate(AxANumber *from,
                       AxANumber *to,
                       AxANumber *duration,
                       AxANumber *time)
{
    Real d = ValNumber(duration);
    Real nTo = ValNumber(to);
    Real t = ValNumber(time);
    Real nFrom = ValNumber(from);

    if (d > 0.0) {
        t = t / d;
        t = CLAMP(t, 0, 1);
        return NEW AxANumber(nFrom + (nTo - nFrom) * t);
    } else
        return NEW AxANumber(t >= 0 ? nTo : nFrom);
}

AxANumber *SlowInSlowOut(AxANumber *from,
                         AxANumber *to,
                         AxANumber *duration,
                         AxANumber *sharpness,
                         AxANumber *time)
{
    Real d = ValNumber(duration);
    Real nTo = ValNumber(to);
    Real t = ValNumber(time);
    Real nFrom = ValNumber(from);

    if (d > 0.0) {
        Real s = ValNumber(sharpness);
        t = t / ValNumber(duration);
        s = CLAMP(s, -1, 1);
        t = CLAMP(t, 0, 1);
        Real f = (t - 1) * (((2 * t) - 1) * s * t - 1);

        return NEW AxANumber(nTo + (nFrom - nTo) * f);
    } else
        return NEW AxANumber(t >= 0 ? nTo : nFrom);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\values\misc\bbox2i.cpp ===
/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

    Definitions of 2D axis-aligned bounding box functions.

*******************************************************************************/

#include "headers.h"
#include "appelles/bbox2.h"
#include "privinc/bbox2i.h"
#include "privinc/vec2i.h"
#include "privinc/xform2i.h"



// This function returns the point at the center of the bounding box.  The origin
// is the center of the universe.  I don't think it makes sense, but as far as
// this function is implemented, the origin is also the center of null.

const Point2 Bbox2::Center(void) const
{
    Real Cx, Cy;

    if ((*this == NullBbox2) || (*this == UniverseBbox2)) {
        Cx = 0.0;
        Cy = 0.0;
    } else {
        Cx = (min.x + max.x) / 2;
        Cy = (min.y + max.y) / 2;
    }

    return Point2(Cx, Cy);
}


/*****************************************************************************
This function returns the intersection of the two bounding boxes.  If the
two boxes don't intersect, this function returns the null box.  Note that
the intersection between a box and the universe box is the original box,
the intersection between the null box and a box is the null box, and the
intersection between the null box and the universe is the null box.
*****************************************************************************/

const Bbox2 IntersectBbox2Bbox2(const Bbox2 &b1, const Bbox2 &b2)
{
    if((b1 == NullBbox2) || (b2 == NullBbox2))
        return NullBbox2;

    if (b1.max.x < b2.min.x || b1.max.y < b2.min.y ||
        b2.max.x < b1.min.x || b2.max.y < b1.min.y)
       return NullBbox2;

    Real xmin = MAX (b1.min.x, b2.min.x);
    Real ymin = MAX (b1.min.y, b2.min.y);
    Real xmax = MIN (b1.max.x, b2.max.x);
    Real ymax = MIN (b1.max.y, b2.max.y);

    return Bbox2(xmin, ymin, xmax, ymax);
}


Bbox2Value* IntersectBbox2Bbox2(Bbox2Value *b1, Bbox2Value *b2)
{
    if((b1 == nullBbox2) || (b2 == nullBbox2))
        return nullBbox2;

    if (b1->max.x < b2->min.x || b1->max.y < b2->min.y ||
        b2->max.x < b1->min.x || b2->max.y < b1->min.y)
       return nullBbox2;

    Real xmin = MAX (b1->min.x, b2->min.x);
    Real ymin = MAX (b1->min.y, b2->min.y);
    Real xmax = MIN (b1->max.x, b2->max.x);
    Real ymax = MIN (b1->max.y, b2->max.y);

    return NEW Bbox2Value(xmin, ymin, xmax, ymax);
}


/*****************************************************************************
This function returns the union of the two bounding boxes.  The union of
any box with null is the original box, and the union of anything with the
universe is the universe.
*****************************************************************************/

const Bbox2 UnionBbox2Bbox2(const Bbox2 &b1, const Bbox2 &b2)
{
    if(b1 == NullBbox2)
        return b2;
    if(b2 == NullBbox2)
        return b1;

    Real xmin = MIN (b1.min.x, b2.min.x);
    Real ymin = MIN (b1.min.y, b2.min.y);
    Real xmax = MAX (b1.max.x, b2.max.x);
    Real ymax = MAX (b1.max.y, b2.max.y);

    return Bbox2(xmin, ymin, xmax, ymax);
}



/*****************************************************************************
Transform the bounding box, and get the NEW axis-aligned bounding box.
*****************************************************************************/

const Bbox2 TransformBbox2(Transform2 *xf, const Bbox2 &box)
{
    // Check fringe cases first

    if ((box == UniverseBbox2) || (box == NullBbox2) || (xf == identityTransform2))
        return box;
    
    // Just transform the points.
    // This will result in a transformed box that
    // is not necessarily axis aligned.

    Point2 ptbl = TransformPoint2(xf, box.min);
    Point2 pttr = TransformPoint2(xf, box.max);

    // optimize: ONLY rotate needs all this work...
    // create the topleft and bottom right points also..
    Point2 pttl = TransformPoint2(xf, Point2(box.min.x, box.max.y));
    Point2 ptbr = TransformPoint2(xf, Point2(box.max.x, box.min.y));
    
    // Find the component mins and maxs of these two points, and these will be
    // put together to form the tightest axis-aligned bbox that surrounds the
    // non-axis aligned one.

    Real xmin = MIN (ptbl.x, MIN(pttr.x, MIN(pttl.x, ptbr.x)));
    Real ymin = MIN (ptbl.y, MIN(pttr.y, MIN(pttl.y, ptbr.y)));
    Real xmax = MAX (ptbl.x, MAX(pttr.x, MAX(pttl.x, ptbr.x)));
    Real ymax = MAX (ptbl.y, MAX(pttr.y, MAX(pttl.y, ptbr.y)));

    return Bbox2(xmin,ymin,xmax,ymax);
}

Bbox2Value* TransformBbox2(Transform2 *xf, Bbox2Value *box)
{
    // Check fringe cases first

    if ((box == universeBbox2) || (box == nullBbox2) || (xf == identityTransform2))
        return box;
    
    // Just transform the points.
    // This will result in a transformed box that
    // is not necessarily axis aligned.

    Point2 ptbl = TransformPoint2(xf, box->min);
    Point2 pttr = TransformPoint2(xf, box->max);

    // optimize: ONLY rotate needs all this work...
    // create the topleft and bottom right points also..
    Point2 pttl = TransformPoint2(xf, Point2(box->min.x, box->max.y));
    Point2 ptbr = TransformPoint2(xf, Point2(box->max.x, box->min.y));
    
    // Find the component mins and maxs of these two points, and these will be
    // put together to form the tightest axis-aligned bbox that surrounds the
    // non-axis aligned one.

    Real xmin = MIN (ptbl.x, MIN(pttr.x, MIN(pttl.x, ptbr.x)));
    Real ymin = MIN (ptbl.y, MIN(pttr.y, MIN(pttl.y, ptbr.y)));
    Real xmax = MAX (ptbl.x, MAX(pttr.x, MAX(pttl.x, ptbr.x)));
    Real ymax = MAX (ptbl.y, MAX(pttr.y, MAX(pttl.y, ptbr.y)));

    return NEW Bbox2Value(xmin,ymin,xmax,ymax);
}



/****************************************************************************/


Point2Value* MaxBbox2(Bbox2Value *box)
{   
    return NEW Point2Value(box->max.x,box->max.y);
}


Point2Value* MinBbox2(Bbox2Value *box)
{   
    return NEW Point2Value(box->min.x,box->min.y);
}


/***************************/
/***  Value Definitions  ***/
/***************************/

Bbox2Value *nullBbox2     = NULL;
Bbox2Value *unitBbox2     = NULL;
Bbox2Value *universeBbox2 = NULL;


/*****************************************************************************
This routine performs the intialization of static Bbox2 values.
*****************************************************************************/

void InitializeModule_Bbox2()
{
    // NOTE:  The following two definitions rely on the HUGE_VAL macro, which
    // effectively returns arbitrary-precision infinity.

    // The universe box goes from -infinity to +infinity.  It contains all
    // points and all other boxes.

    universeBbox2 = NEW Bbox2Value (-HUGE_VAL, -HUGE_VAL,
                                     HUGE_VAL,  HUGE_VAL);

    // The null box can be thought of as the universe turned inside out.  It
    // runs from a minimum of +inifinity to a maximum of -infinity.  It turns
    // out that these definitions for null and universe yield sane answers on
    // all the following operations, so you don't need to test for these values
    // explicitly.

    nullBbox2 = NEW Bbox2Value ( HUGE_VAL,  HUGE_VAL,
                                -HUGE_VAL, -HUGE_VAL);


    // The unit bbox spans (0,0) to (1,1).

    unitBbox2 = NEW Bbox2Value (0,0, 1,1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\values\misc\cloud.cpp ===
/*-------------------------------------

  Copyright (c) 1996 Microsoft Corporation

  Abstract:

  Implements Cloud class which maintains a set of n
  points that tightly bound some target object.
  The whole class is implemented here for now.

  -------------------------------------*/

#include "headers.h"
#include "privinc/cloud.h"
#include "privinc/vec3i.h"
#include "appelles/xform.h"

///////////////////////////////////////////////////
//          C L O U D   C L A S S
///////////////////////////////////////////////////

Cloud::Cloud()
{
    _nullCloud = TRUE;
    _minCurrent = FALSE;
    _maxCurrent = FALSE;
    ResetMax();
    ResetMin();
    _numPts = 0;
}

Point3Value Cloud::FindMinPointCoord()
{
    // optimize later
    //      if(_minCurrent == TRUE)
    //          return _minPt;

    ResetMin();
    Point3Value *p;
    for(int i=0; i<_numPts; i++) {
        p = &(_pointArray[i]);
        if(p->x < _minPt.x) _minPt.x = p->x;
        if(p->y < _minPt.y) _minPt.y = p->y;
        if(p->z < _minPt.z) _minPt.z = p->z;
    }
    _minCurrent = TRUE;
    return _minPt;
}

Point3Value Cloud::FindMaxPointCoord()
{
    // optimize later
    //      if(_maxCurrent == TRUE)
    //          return _maxPt;

    ResetMax();
    Point3Value *p;
    for(int i=0; i<_numPts; i++) {
        p = &(_pointArray[i]);
        if(p->x > _maxPt.x) _maxPt.x = p->x;
        if(p->y > _maxPt.y) _maxPt.y = p->y;
        if(p->z > _maxPt.z) _maxPt.z = p->z;
    }
    _maxCurrent = TRUE;
    return _maxPt;
}

void Cloud::Transform(Transform3 *xform)
{
    for(int i=0; i<_numPts; i++) {
        // copy point3
        _pointArray[i] = *(TransformPoint3(xform, &(_pointArray[i])));
    }
    _minCurrent = FALSE;
    _maxCurrent = FALSE;
}

void Cloud::Augment(Cloud &cloud)
{
    if(_nullCloud == TRUE) {
        // copy incoming cloud
        cloud.CopyInto(this);
    } else {
        // Really do an augment
        FindMinPointCoord();
        FindMaxPointCoord();

        Point3Value min = cloud.FindMinPointCoord();
        Point3Value max = cloud.FindMaxPointCoord();

        if(min.x < _minPt.x) _minPt.x = min.x;
        if(min.y < _minPt.y) _minPt.y = min.y;
        if(min.z < _minPt.z) _minPt.z = min.z;

        if(max.x > _maxPt.x) _maxPt.x = max.x;
        if(max.y > _maxPt.y) _maxPt.y = max.y;
        if(max.z > _maxPt.z) _maxPt.z = max.z;

        ForceEnumerateThesePlease(_minPt, _maxPt);
        _minCurrent = TRUE;
        _maxCurrent = TRUE;
    }
    _nullCloud = FALSE;
}

void Cloud::ForceEnumerateThesePlease(Point3Value &min, Point3Value &max) {
    _numPts = 0;
    EnumerateThesePlease(min.x,min.y,min.z,
                         max.x,max.y,max.z);
}

void Cloud::EnumerateThesePlease(Point3 &min, Point3 &max) {
    EnumerateThesePlease(min.x,min.y,min.z,
                         max.x,max.y,max.z);
}

void Cloud::EnumerateThesePlease(Real minx, Real miny, Real minz,
                                 Real maxx, Real maxy, Real maxz) {
    _nullCloud = FALSE;
    _minCurrent = FALSE;
    _maxCurrent = FALSE;
    AddPoint(*(NEW Point3Value(minx,miny,minz)));
    AddPoint(*(NEW Point3Value(minx,miny,maxz)));
    AddPoint(*(NEW Point3Value(minx,maxy,minz)));
    AddPoint(*(NEW Point3Value(minx,maxy,maxz)));
    AddPoint(*(NEW Point3Value(maxx,miny,minz)));
    AddPoint(*(NEW Point3Value(maxx,miny,maxz)));
    AddPoint(*(NEW Point3Value(maxx,maxy,minz)));
    AddPoint(*(NEW Point3Value(maxx,maxy,maxz)));
}

void Cloud::AddPoint(Point3Value &p) {
    if(_numPts >= GetMaxPts()) {
        Assert(FALSE && "Tried to add too many points to Cloud");
        return;
    }
    _pointArray[_numPts] = p;
    _numPts++;
}

void Cloud::CopyInto(Cloud *target) {
    target->_nullCloud = _nullCloud;
    target->_minCurrent = _minCurrent;
    target->_maxCurrent = _maxCurrent;

    target->_numPts = _numPts;
    target->_minPt = _minPt;
    target->_maxPt = _maxPt;

    for(int i=0; i < _numPts; i++)
        target->_pointArray[i] = _pointArray[i];
}

void Cloud::ResetMax() {
    _maxPt.x = _maxPt.y = _maxPt.z = - HUGE_VAL;
}

void Cloud::ResetMin() {
    _minPt.x = _minPt.y = _minPt.z =   HUGE_VAL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\values\misc\color.cpp ===
/*******************************************************************************
Copyright (c) 1995-96  Microsoft Corporation

    Implementation of Color *values (RGB, HSL).

*******************************************************************************/

#include "headers.h"
#include <math.h>
#include "privinc/colori.h"
#include "privinc/basic.h"

    // Constant definitions

Color *red     = NULL;
Color *green   = NULL;
Color *blue    = NULL;
Color *cyan    = NULL;
Color *magenta = NULL;
Color *yellow  = NULL;
Color *white   = NULL;
Color *black   = NULL;
Color *gray    = NULL;
Color *aqua    = NULL;   
Color *fuchsia = NULL;      
Color *lime    = NULL;    
Color *maroon  = NULL;    
Color *navy    = NULL;    
Color *olive   = NULL;   
Color *purple  = NULL;   
Color *silver  = NULL; 
Color *teal    = NULL;  
Color *emptyColor = NULL;  

    // Local Functions

static void RgbToHsl (Real r, Real g, Real b, Real *h, Real *s, Real *l);
static void HslToRgb (Real H, Real S, Real L, Real &R, Real &G, Real &B);



/*****************************************************************************
This function sets the RGB values of a color.
*****************************************************************************/

void Color::SetRGB (Real r, Real g, Real b)
{   red   = r;
    green = g;
    blue  = b;
}



/*****************************************************************************
Set the color from the D3D color value
*****************************************************************************/

void Color::SetD3D (D3DCOLOR color)
{   red   = RGBA_GETRED (color)   / 255.0;
    green = RGBA_GETGREEN (color) / 255.0;
    blue  = RGBA_GETBLUE (color)  / 255.0;
}



/*****************************************************************************
This function adds the given RGB values to the current values.
*****************************************************************************/

void Color::AddColor (Color &other)
{   red   += other.red;
    green += other.green;
    blue  += other.blue;
}



/*****************************************************************************
This function returns the intensity of the color, based on the standard NTSC
RGB phosphor.  See Foley & VanDam II, p.589 for more information.
*****************************************************************************/

Real Color::Intensity (void)
{
    return (.299 * red) + (.587 * green) + (.114 * blue);
}



/*****************************************************************************
Compare a color with another color.
*****************************************************************************/

bool Color::operator== (const Color &other) const
{
    return (red   == other.red)
        && (green == other.green)
        && (blue  == other.blue);
}



/*****************************************************************************
Construct a color from red, green, and blue levels.
*****************************************************************************/

Color *RgbColorRRR (Real r, Real g, Real b)
{
    return NEW Color (r,g,b);
}

Color *RgbColor (AxANumber *r, AxANumber *g, AxANumber *b)
{
    return RgbColorRRR (NumberToReal(r),NumberToReal(g),NumberToReal(b));
}



/*****************************************************************************
Construct a color from hue, saturation, and luminance.
*****************************************************************************/

Color *HslColorRRR (Real h, Real s, Real l)
{
    Real r, g, b;
    HslToRgb (h, s, l, r, g, b);
    return NEW Color(r,g,b);
}

Color *HslColor (AxANumber *h, AxANumber *s, AxANumber *l)
{
    return HslColorRRR(NumberToReal(h), NumberToReal(s), NumberToReal(l));
}



/*****************************************************************************
This routine prints out the value of the given color.
*****************************************************************************/

#if _USE_PRINT
ostream& operator<< (ostream& os, Color& c)
{
    return os <<"colorRgb(" <<c.red <<"," <<c.green <<"," <<c.blue <<")";
}
#endif


/* Accessors */

AxANumber *RedComponent(Color *c)   { return RealToNumber (c->red);   }
AxANumber *GreenComponent(Color *c) { return RealToNumber (c->green); }
AxANumber *BlueComponent(Color *c)  { return RealToNumber (c->blue);  }

AxANumber *HueComponent (Color *c)
{
    Real h,s,l;
    RgbToHsl (c->red, c->green, c->blue, &h, &s, &l);
    return RealToNumber (h);
}

AxANumber *SaturationComponent (Color *c)
{
    Real h,s,l;
    RgbToHsl(c->red, c->green, c->blue, &h, &s, &l);
    return RealToNumber(s);
}

AxANumber *LuminanceComponent(Color *c)
{
    Real h,s,l;
    RgbToHsl(c->red, c->green, c->blue, &h, &s, &l);
    return RealToNumber(l);
}



/*****************************************************************************
RGB-HSL transforms.  /  Ken Fishkin, Pixar Inc., January 1989.
Given r,g,b on [0 ... 1], return (h,s,l) on [0 ... 1]
*****************************************************************************/

static void RgbToHsl (Real r, Real g, Real b, Real *h, Real *s, Real *l)
{
    Real v;
    Real m;
    Real vm;
    Real r2, g2, b2;

    v = (r > g) ? ((r > b) ? r : b)
                : ((g > b) ? g : b);

    m = (r < g) ? ((r < b) ? r : b)
                : ((g < b) ? g : b);

    // Check to see if we have positive luminance.
    // If not the color is pure black and h, s, l
    // are all zero.
    if ((*l = (m + v) / 2.0) <= 0.0) 
    {
        *h = 0.0;
        *s = 0.0;
        *l = 0.0;
        return;
    }

    // Check to see if we have positive saturation,
    // If not, the color is a pure shade of grey or
    // white, s is zero, and h is undefined.  Set h
    // to zero to prevent us or others from choking
    // on bad nums later.
    if ((*s = vm = v - m) > 0.0)
    {
        *s /= (*l <= 0.5) ? (v + m ) : (2.0 - v - m);
    }
    else
    {
        *s = 0.0;
        *h = 0.0;
        return;
    }


    r2 = (v - r) / vm;
    g2 = (v - g) / vm;
    b2 = (v - b) / vm;

    if (r == v)
        *h = (g == m ? 5.0 + b2 : 1.0 - g2);
    else if (g == v)
        *h = (b == m ? 1.0 + r2 : 3.0 - b2);
    else
        *h = (r == m ? 3.0 + g2 : 5.0 - r2);

    *h /= 6;
}


/*****************************************************************************
"A Fast HSL-to-RGB Transform" by Ken Fishkin from "Graphics Gems", Academic
Press, 1990.  Hue (H) can be any value; only the fractional part will be used
(travelling across the zero boundary is smooth).  Saturation (S) is clamped
to [0,1].  Luminance (L) yields black for L<0, and L>1 yields an overdrive
light.
*****************************************************************************/

static void HslToRgb (Real H, Real S, Real L, Real &R, Real &G, Real &B)
{
    if (H >= 0.0) {             // Modulo to fit into [0,1].
        H = fmod(H, 1.0);         
    } else {
        H = 1.0 + fmod(H, 1.0);
    }
    H = clamp(H, 0.0, 1.0);
    S = clamp(S, 0.0, 1.0);  // Clamp to [0,1].

    // V is the value of the color (a la HSV).

    Real V;
    if (L <= 0.5) {
        V = L * (1.0 + S);
    } else {
        V = L + S - (L * S);
    }

    if (V <= 0)
    {   R = G = B = 0;
        return;
    }

    Real min = 2*L - V;
    S = (V - min) / V;
    H *= 6;
    int sextant = (int) floor(H);
    Real vsf = V * S * (H - sextant);

    Real mid1 = min + vsf;
    Real mid2 = V - vsf;

    switch (sextant)
    {   case 0:  R = V;     G = mid1;  B = min;   break;
        case 1:  R = mid2;  G = V;     B = min;   break;
        case 2:  R = min;   G = V;     B = mid1;  break;
        case 3:  R = min;   G = mid2;  B = V;     break;
        case 4:  R = mid1;  G = min;   B = V;     break;
        case 5:  R = V;     G = min;   B = mid2;  break;
    }
}

void
InitializeModule_Color()
{
    red     = NEW Color (1.00, 0.00, 0.00);
    green   = NEW Color (0.00, 1.00, 0.00);
    blue    = NEW Color (0.00, 0.00, 1.00);
    cyan    = NEW Color (0.00, 1.00, 1.00);
    magenta = NEW Color (1.00, 0.00, 1.00);
    yellow  = NEW Color (1.00, 1.00, 0.00);
    white   = NEW Color (1.00, 1.00, 1.00);
    black   = NEW Color (0.00, 0.00, 0.00);
    gray    = NEW Color (0.50, 0.50, 0.50);
    aqua    = NEW Color (0.00, 1.00, 1.00);   
    fuchsia = NEW Color (1.00, 0.00, 1.00);    
    lime    = NEW Color (0.00, 1.00, 0.00);    
    maroon  = NEW Color (0.50, 0.00, 0.00);    
    navy    = NEW Color (0.00, 0.00, 0.50);    
    olive   = NEW Color (0.50, 0.50, 0.00);   
    purple  = NEW Color (0.50, 0.00, 0.50);   
    silver  = NEW Color (0.75, 0.75, 0.75); 
    teal    = NEW Color (0.00, 0.50, 0.50);  
    emptyColor = NEW Color (0.00, 0.00, 0.00);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\values\misc\linestyl.cpp ===
/*-------------------------------------

Copyright (c) 1996 Microsoft Corporation

Abstract:

    LineStyle, JointStyle, EndStyle, DashStyle implementation

-------------------------------------*/

#include "headers.h"

#include "backend/bvr.h"
#include "privinc/server.h"
#include "privinc/basic.h"
#include <appelles/linestyl.h>
#include <privinc/linei.h>
#include "privinc/basic.h"
#include "dartapi.h"  // for CR_XXX stuff


LineStyle *LineEndStyle( EndStyle *theStyle, LineStyle *ls)
{
    return NEW LineEndStyleClass( theStyle->_style, ls );
}

LineStyle *LineJoinStyle( JoinStyle *theStyle, LineStyle *ls)
{
    return NEW LineJoinStyleClass( theStyle->_style, ls );
}

LineStyle *LineDashStyle( DashStyle *theStyle, LineStyle *ls)
{
    return NEW LineDashStyleClass( theStyle->_style, ls );
}

LineStyle *LineWidthStyle(AxANumber *width, LineStyle *lineStyle)
{
    return NEW LineWidthStyleClass(NumberToReal(width), false, lineStyle);
}

LineStyle *LineDetailStyle(LineStyle *lineStyle)
{
    return NEW LineWidthStyleClass(0.0, true, lineStyle);  
}

LineStyle *LineColor(Color *clr, LineStyle *lineStyle)
{
    return NEW LineColorStyleClass(clr, lineStyle);
}

LineStyle *LineAntiAliasing(AxANumber *aaStyle, LineStyle *ls)
{
    Real style = aaStyle->GetNum();
    if(style > 0.0) {
        return NEW LineAntiAliasedStyleClass(true, ls);
    } else {
        return ls;
    }
}
//////////////////////////////////////////////////////////////////////
//////////   NEWER FUNCTIONS TO CONSTRUCT LINESTYLES     /////////////
//////////////////////////////////////////////////////////////////////
LineStyle *ConstructLineStyleMiterLimit(LineStyle *ls, AxANumber *limit)
{
    return NEW LineMiterLimitClass((float)limit->GetNum(), ls);
}



LineStyle *
ConstructLineStyleDashStyleStatic(LineStyle *ls, AxALong *ds)
{
    DashStyleEnum ds_enum = (DashStyleEnum) (ds->GetLong());

    if( (ds_enum != PS_SOLID) &&
        (ds_enum != PS_DASH) &&
        (ds_enum != PS_DOT) &&
        (ds_enum != PS_DASHDOT) &&
        (ds_enum != PS_DASHDOTDOT) &&
        (ds_enum != PS_NULL) ) {
        RaiseException_UserError( E_INVALIDARG, IDS_ERR_IMG_INVALID_LINESTYLE );
    }
    
    return NEW LineDashStyleClass(ds_enum, ls);
}

Bvr
ConstructLineStyleDashStyle(Bvr lsBvr, DWORD ds_enum)
{
    Bvr ds_enumBvr = UnsharedConstBvr(LongToAxALong(ds_enum));

    // TODO: share valprimop at module initialize
    return PrimApplyBvr(ValPrimOp(::ConstructLineStyleDashStyleStatic,
                                  2,
                                  "ConstructLineStyleDashStyle",
                                  LineStyleType),
                        2, lsBvr, ds_enumBvr);
}


LineStyle *
ConstructLineStyleJoinStyleStatic(LineStyle *ls, AxALong *js)
{
    JoinStyleEnum js_enum = (JoinStyleEnum) (js->GetLong());

    if( (js_enum != js_Round) &&
        (js_enum != js_Bevel) &&
        (js_enum != js_Miter) ) {
        RaiseException_UserError( E_INVALIDARG, IDS_ERR_IMG_INVALID_LINESTYLE );
    }
    
    return NEW LineJoinStyleClass(js_enum, ls);
}

Bvr
ConstructLineStyleJoinStyle(Bvr lsBvr, DWORD js_enum)
{
    Bvr js_enumBvr = UnsharedConstBvr(LongToAxALong(js_enum));

    // TODO: share valprimop at module initialize
    return PrimApplyBvr(ValPrimOp(::ConstructLineStyleJoinStyleStatic,
                                  2,
                                  "ConstructLineStyleJoinStyle",
                                  LineStyleType),
                        2, lsBvr, js_enumBvr);
}

LineStyle *
ConstructLineStyleEndStyleStatic(LineStyle *ls, AxALong *es)
{
    EndStyleEnum es_enum = (EndStyleEnum) (es->GetLong());

    if( (es_enum != es_Round) &&
        (es_enum != es_Square) &&
        (es_enum != es_Flat) ) {

        RaiseException_UserError( E_INVALIDARG, IDS_ERR_IMG_INVALID_LINESTYLE );
    }
    
    return NEW LineEndStyleClass(es_enum, ls);
}

Bvr
ConstructLineStyleEndStyle(Bvr lsBvr, DWORD es_enum)
{
    Bvr es_enumBvr = UnsharedConstBvr(LongToAxALong(es_enum));

    // TODO: share valprimop at module initialize
    return PrimApplyBvr(ValPrimOp(::ConstructLineStyleEndStyleStatic,
                                  2,
                                  "ConstructLineStyleEndStyle",
                                  LineStyleType),
                        2, lsBvr, es_enumBvr);
}

//
// External Constants
//
LineStyle *defaultLineStyle;
LineStyle *emptyLineStyle;

EndStyle *endStyleFlat;
EndStyle *endStyleSquare;
EndStyle *endStyleRound;

JoinStyle *joinStyleBevel;
JoinStyle *joinStyleRound;
JoinStyle *joinStyleMiter;

DashStyle *dashStyleSolid;
DashStyle *dashStyleDashed;

void
InitializeModule_LineStyle()
{
    defaultLineStyle = NEW LineStyle();  // Visible: true
    emptyLineStyle = NEW EmptyLineStyle();   // Visible: false

    endStyleFlat   = NEW EndStyle(es_Flat);
    endStyleSquare = NEW EndStyle(es_Square);
    endStyleRound  = NEW EndStyle(es_Round);

    joinStyleBevel = NEW JoinStyle(js_Bevel);
    joinStyleRound = NEW JoinStyle(js_Round);
    joinStyleMiter = NEW JoinStyle(js_Miter);

    dashStyleSolid  = NEW DashStyle(ds_Solid);
    dashStyleDashed = NEW DashStyle(ds_Dashed);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\values\misc\camera.cpp ===
/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

    In this model, all cameras are expressed as a transformed default camera.
The default camera is located at the origin, with +Y pointing up, and with a
projection point located at <0,0,1>.  The resulting image is defined by the
projection to the projection point onto the Z=0 image plane.

*******************************************************************************/

#include "headers.h"

#include "appelles/common.h"
#include "appelles/camera.h"

#include "privinc/matutil.h"
#include "privinc/xformi.h"
#include "privinc/vec2i.h"
#include "privinc/vec3i.h"
#include "privinc/camerai.h"
#include "privinc/basic.h"
#include "privinc/d3dutil.h"


    // Built-in Cameras.

Camera *baseCamera = NULL;               // Base Perspective  Camera
Camera *baseOrthographicCamera = NULL;   // Base Orthographic Camera

Camera *defaultCamera = NULL;            // Same as Base Perspective  Camera
Camera *orthographicCamera = NULL;       // Same as Base Orthographic Camera



/*****************************************************************************
Construct an initial camera from a camera type.  The basis of such a camera is
the identity matrix, so that an initial camera gazes in the -Z direction, with
+Y pointing up.  The imaging plane is at Z=0, and the projection point
(relevant for perspective cameras) is located at <0, 0, 1>.
*****************************************************************************/

Camera::Camera (CameraType camtype)
    : _heap (GetHeapOnTopOfStack())
{
    _basis    = Apu4x4XformImpl (apuIdentityMatrix);
    _type     = camtype;
    _depth    = HUGE_VAL;
    _depthRes = 0;

    _camToWorld = _worldToCam = NULL;
}



/*****************************************************************************
Construct a camera by transforming another camera.  The new camera inherits
the camera type of the base camera.
*****************************************************************************/

Camera::Camera (Transform3 *xform, Camera *basecam)
    : _heap (GetHeapOnTopOfStack())
{
    Transform3 *newxform = TimesXformXform (xform, basecam->_basis);

    // Ensure that the transformed camera still has a valid basis.  We
    // currently require that the basis is orthogonal and right-handed.  If the
    // new transform does not meet these criteria, then don't apply the
    // transform - treat the transform as a no-op and use the base camera's
    // transform.

    if (!newxform->Matrix().Orthogonal())
    {
        #if _DEBUG
        {
            if (IsTagEnabled(tagMathMatrixInvalid))
            {   F3DebugBreak();
            }

            OutputDebugString ("Bad camera transform (not orthogonal).\n");
        }
        #endif

        _basis = basecam->_basis;
    }
    else if (newxform->Matrix().Determinant() <= 0)
    {
        #if _DEBUG
        {
            if (IsTagEnabled(tagMathMatrixInvalid))
            {   F3DebugBreak();
            }

            OutputDebugString ("Bad camera transform (determinant).\n");
        }
        #endif

        _basis = basecam->_basis;
    }
    else
    {
        _basis = newxform;
    }

    _type     = basecam->_type;
    _depth    = basecam->_depth;
    _depthRes = basecam->_depthRes;

    _camToWorld = _worldToCam = NULL;
}



/*****************************************************************************
Construct a copy of a camera from another camera.
*****************************************************************************/

Camera::Camera (Camera *basecam)
    : _heap (GetHeapOnTopOfStack())
{
    _basis    = basecam->_basis->Copy();
    _type     = basecam->_type;
    _depth    = basecam->_depth;
    _depthRes = basecam->_depthRes;

    _camToWorld = _worldToCam = NULL;
}



/*****************************************************************************
Returns the camera to world transform (created on the Camera's dynamic heap).
As a side-effect, this function also computes the horizontal and vertical
scale factors, and the perspective projection point in world coordinates.
*****************************************************************************/

Transform3 *Camera::CameraToWorld (void)
{
    if (!_camToWorld)
    {
        PushDynamicHeap (_heap);  // Create data on the Camera's dynamic heap.

        Apu4x4Matrix basis = _basis->Matrix();

        // We need to get the transform from world coordinates to camera
        // coordinates.  First get the origin, viewing direction and nominal up
        // vector.  Note that we negate the Ck vector since we're going from
        // right-handed (world) coordinates to left-handed (camera).

        Point3Value Corigin (basis.m[0][3], basis.m[1][3], basis.m[2][3]);

        Vector3Value Ci (basis.m[0][0], basis.m[1][0], basis.m[2][0]);
        Vector3Value Cj (basis.m[0][1], basis.m[1][1], basis.m[2][1]);
        Vector3Value Ck (basis.m[0][2], basis.m[1][2], basis.m[2][2]);

        // Find the projection point from the basis k (Z) vector and the camera
        // origin.  Note that this is in world coordinates.

        _wcProjPoint = Corigin + Ck;

        // The basis Z vector will be flipped if we're not on RM6 (RM3
        // interface), since that camera space needs to be left-handed.

        bool right_handed = (GetD3DRM3() != 0);

        if (!right_handed)
            Ck *= -1;

        Real Sz = (_type == PERSPECTIVE) ? Ck.Length() : 1.0;

        _scale.Set (Ci.Length(), Cj.Length(), Sz);

        // Create the camera-to-world transform from the three normalized
        // basis vectors and the camera location.

        Apu4x4Matrix camera_world;

        camera_world.m[0][0] = Ci.x / _scale.x;  // Normalized Basis X Vector
        camera_world.m[1][0] = Ci.y / _scale.x;
        camera_world.m[2][0] = Ci.z / _scale.x;
        camera_world.m[3][0] = 0;

        camera_world.m[0][1] = Cj.x / _scale.y;  // Normalized Basis Y Vector
        camera_world.m[1][1] = Cj.y / _scale.y;
        camera_world.m[2][1] = Cj.z / _scale.y;
        camera_world.m[3][1] = 0;

        camera_world.m[0][2] = Ck.x / _scale.z;  // Normalized Basis Z Vector
        camera_world.m[1][2] = Ck.y / _scale.z;
        camera_world.m[2][2] = Ck.z / _scale.z;
        camera_world.m[3][2] = 0;

        camera_world.m[0][3] = Corigin.x;  // Load the basis origin.
        camera_world.m[1][3] = Corigin.y;
        camera_world.m[2][3] = Corigin.z;
        camera_world.m[3][3] = 1;

        camera_world.form     = Apu4x4Matrix::AFFINE_E;   // 3x4 Matrix
        camera_world.is_rigid = 1;          // Xformed Lines Have Same Length

        _camToWorld = Apu4x4XformImpl (camera_world);

        PopDynamicHeap();
    }

    return _camToWorld;
}



/*****************************************************************************
Returns the world to camera transform (created on the Camera's dynamic heap).
As a side effect, this function also computes the camera coordinates of the
perspective projection point.
*****************************************************************************/

Transform3 *Camera::WorldToCamera (void)
{
    if (!_worldToCam)
    {
        PushDynamicHeap (_heap);

        _worldToCam = CameraToWorld()->Inverse();
        if (!_worldToCam) {
            DASetLastError (E_FAIL, IDS_ERR_GEO_SINGULAR_CAMERA);
            return NULL;
        }

        PopDynamicHeap ();

        // Calculate the projection point in camera coordinates.

        _ccProjPoint = *TransformPoint3 (_worldToCam, &_wcProjPoint);
    }

    return _worldToCam;
}



/*****************************************************************************
This function returns the near and far clipping planes for a given world-
coordinate viewing volume.  Both near and far are given as positive distances,
regardless of the underlying handedness.  The 'depthpad' value is the padding,
in Z-buffer coordinates, for the near and far clipping planes.  Both Znear and
Zfar will be clipped to the image plane.  Thus, Zfar==0 implies that the
geometry is behind the view and is invisable.  In addition to this, if the
camera has an assigned depth resolution, it will clamp the far plane so that
the given resolution is maintained.  If there is no minimum depth resolution,
then if there is an absolute depth to the camera, then far is clamped to that.
If there are no depth settings, then the far plane is set to the furthest point
of the geometry.
*****************************************************************************/

bool Camera::GetNearFar (
    Bbox3 *wcVolume,   // World-Coordinate Object Volume To View
    Real   depthpad,   // Near/Far Padding in Z-buffer Coordinates
    Real  &Znear,      // Near Clip Plane, Camera Coordinates
    Real  &Zfar)       // Far  Clip Plane, Camera Coordinates
{
    // If the camera viewing depth is zero, then nothing is visible.

    if (_depth <= 0) return false;

    // Find the bounds of the world-coordinate bounding volume in camera
    // coordinates and extract the min and max depth from that.

    Transform3 *xf = WorldToCamera();
    if (!xf) return false;
    
    Bbox3 ccBbox = *TransformBbox3 (xf, wcVolume);

    bool right_handed = (GetD3DRM3() != 0);

    if (right_handed)
    {   Znear = -ccBbox.max.z;
        Zfar  = -ccBbox.min.z;
    }
    else
    {   Znear = ccBbox.min.z;
        Zfar  = ccBbox.max.z;
    }

    // Quit if the geometry is behind us.

    if (Zfar < 0) return false;

    // Offset by the distance from the projection point to the image plane, to
    // get the true hither/yon values.  First clamp values.

    if (Znear < 0)     Znear = 0;
    Assert (Zfar >= Znear);

    Znear += _scale.z;
    Zfar  += _scale.z;

    // If a minimum depth resolution is indicated in the camera, derive the
    // far clip to meet that requirement, and clamp Zfar to that distance.

    if (_depthRes)
    {
        // We compute yon by solving the following equation for yon:
        //
        //         ZMAX - 1   ((yon - depthRes) - hither) yon
        //         -------- = -------------------------------
        //           ZMAX     (yon - hither) (yon - depthRes)
        //
        // This is using the Zbuffer equation:
        //
        //                      (Z - hither) yon
        //         Zbuffer(Z) = ----------------
        //                      (yon - hither) Z

        const Real ZMAX = (1 << 16) - 1;   // Maximum 16-bit Z-buffer Value
        Real hither = Znear;               // Hither From Projection Point
        Real t = hither + _depthRes;       // Temporary Value

        Real yon = 0.5 * (t + sqrt(t*t + 4*hither*_depthRes*(ZMAX-1)));

        if (yon < Zfar)
        {   Zfar = yon;
            depthpad = 0;           // Don't pad yon, do hard clip.
        }
    }

    // If an absolute visible depth is specified, choose the minimum of this
    // depth and the actual furthest point of the geometry we're trying to
    // view.

    else if (_depth)
    {
        if (_depth < (Zfar - Znear))
        {   Zfar = Znear + _depth;
            depthpad = 0;           // Don't pad yon, do hard clip.
        }
    }

    // If the volume is to be depth-padded in Z, move out the near and far
    // planes to 'depthpad' units in Z space.

    if (depthpad > 0)
    {
        double min = Znear;
        double max = Zfar;

        Real s = min * max * (2*depthpad - 1);
        Real t = depthpad * (min + max);

        Znear = s / (t-max);
        Zfar  = s / (t-min);

        if (Znear > min) Znear = min;   // Fix garbage values.
        if (Zfar  < max) Zfar  = max;
    }

    Assert (Znear > 0);

    return true;
}



/*****************************************************************************
Returns the perspective projection point of the camera in world coordinates.
*****************************************************************************/

Point3Value Camera::WCProjPoint (void)
{
    // _wcProjPoint is set as a side-effect of the creation of the camera-
    // to-world transform.

    CameraToWorld();

    return _wcProjPoint;
}



/*****************************************************************************
Return the perspective projection point of the camera in camera coordinates.
*****************************************************************************/

Point3Value Camera::CCProjPoint (void)
{
    // The camera basis scaling factor is computed as a side effect of the
    // camera-to-world transform creation.

    CameraToWorld();

    bool right_handed = (GetD3DRM3() != 0);

    if (right_handed)
        _ccProjPoint.Set (0, 0,  _scale.z);
    else
        _ccProjPoint.Set (0, 0, -_scale.z);

    return _ccProjPoint;
}



/*****************************************************************************
Returns the scale factors of the camera view.  Each of the given addresses
may be nil.
*****************************************************************************/

void Camera::GetScale (Real *x, Real *y, Real *z)
{
    // The camera basis scaling factor is computed as a side effect of the
    // camera-to-world transform creation.

    CameraToWorld();

    if (x) *x = _scale.x;
    if (y) *y = _scale.y;
    if (z) *z = _scale.z;
}



/*****************************************************************************
This function returns a ray from the point on the image plane into the visible
space.  The returned ray originates from the pick point on the image plane,
and is unnormalized.
*****************************************************************************/

Ray3 *Camera::GetPickRay (Point2Value *imagePoint)
{
    // Get the location of the image point in camera coordinates.

    Point3Value pickPt (imagePoint->x, imagePoint->y, 0);
    pickPt.Transform (_basis);     // World Coord Camera Image-Plane Point

    Vector3Value direction;

    // If this is a perspective camera, then the direction of the pick ray is
    // from the world-coordinate projection point to the world-coordinate pick
    // point.  If this is an orthographic camera, then the direction is the
    // direction of the camera's -Z axis.

    if (_type == PERSPECTIVE)
        direction = pickPt - WCProjPoint();
    else
    {   Apu4x4Matrix basis = _basis->Matrix();
        direction = Vector3Value (-basis.m[0][2], -basis.m[1][2], -basis.m[2][2]);
    }

    return NEW Ray3 (pickPt, direction);
}



/*****************************************************************************
This function returns the projection of the world-coordinate point onto the
camera's image plane.
*****************************************************************************/

Point2Value *Camera::Project (Point3Value *world_point)
{
    Transform3 *xf = WorldToCamera();

    // If the transform is null, then the camera basis is non-invertible and
    // hence singular.  Thus, any arbitrary point is valid, and we return the
    // origin.

    if (!xf) return origin2;
    
    Point3Value Q = *TransformPoint3 (xf, world_point);

    if (_type == ORTHOGRAPHIC)
        return NEW Point2Value (Q.x/_scale.x, Q.y/_scale.y);
    else
    {
        Point3Value P = CCProjPoint();

        Real t = P.z / (P.z - Q.z);

        return NEW Point2Value ((P.x + t*(Q.x-P.x)) / _scale.x,
                                (P.y + t*(Q.y-P.y)) / _scale.y);
   }
}

AxAValue
Camera::ExtendedAttrib(char *attrib, VARIANT& val)
{
    return this;
}


/*****************************************************************************
Construct a NEW camera by transforming another camera.  The NEW camera
inherits the camera type of the base camera.
*****************************************************************************/

Camera *TransformCamera (Transform3 *transform, Camera *camera)
{
    return NEW Camera (transform, camera);
}



/*****************************************************************************
This function takes a camera and a number and returns a camera with the depth
clip set to that value.  In other words, the far clip will be set to the near
clip plus the depth.
*****************************************************************************/

Camera *Depth (AxANumber *depth, Camera *cam)
{
    Camera *newcam = NEW Camera (cam);
    newcam->SetDepth (NumberToReal (depth));
    return newcam;
}



/*****************************************************************************
This function takes a camera and a number and returns a camera with the depth
set so that depth is maximized and a minimum depth resolution of the given
units (camera coordinates) is met.  For example, calling this with 1mm will
yield a depth clip so that surfaces 1mm apart are guaranteed to appear at
different depths when rendered.
*****************************************************************************/

Camera *DepthResolution (AxANumber *resolution, Camera *cam)
{
    Camera *newcam = NEW Camera (cam);
    newcam->SetDepthResolution (NumberToReal (resolution));
    return newcam;
}



/*****************************************************************************
This function returns a parallel camera.  The camera is aimed in the -Z
direction, with +Y up, and the near clip plane is set at [0 0 near].
*****************************************************************************/

Camera *ParallelCamera (AxANumber *nearClip)
{
    if (NumberToReal(nearClip) == 0)
        return baseOrthographicCamera;
    else
        return NEW Camera (Translate (0, 0, NumberToReal(nearClip)),
                           baseOrthographicCamera);
}



/*****************************************************************************
The PerspectiveCamera function takes two scalars, 'focalDist' and 'nearClip'
and returns a perspective camera.  The resulting camera is aimed in the -Z
direction, with +Y up.  The near clip plane is located at [0 0 nearClip], the
projection point is located at [0 0 focalDist], and the camera is scaled so
that objects at Z=0 appear actual size.  Thus, the Z=0 plane can be thought of
as the projection plane.
*****************************************************************************/

Camera *PerspectiveCamera (AxANumber *_focalDist, AxANumber *_nearClip)
{
    Real focalDist = NumberToReal (_focalDist);   // Convert To Reals
    Real nearClip  = NumberToReal (_nearClip);

    if (focalDist <= nearClip)
        RaiseException_UserError (E_FAIL, IDS_ERR_GEO_CAMERA_FOCAL_DIST);

    // If the parameters match those of the base perspective camera, then
    // just return that camera without modifying it.

    if ((focalDist == 1) && (nearClip == 0)) return baseCamera;

    Real pNear = focalDist - nearClip;  // Dist Between Near Clip & Proj Point

    // Here we scale the camera so that the projected size of an object at
    // the Z=0 plane is scaled up to actual size.  To do this, scale the
    // camera down to the (smaller) projected unit size, so that the object
    // looks as big as actual size to the camera.

    Real camScale = pNear / focalDist;

    // Size the camera in X & Y by the scale above, scale the Z coordinate to
    // place the projection point (relative to the near clip plane, which is at
    // Z=0 for the base camera), and then translate the whole thing back to the
    // near clip plane.

    return NEW Camera (
        TimesXformXform (
            Translate (0, 0, nearClip),
            Scale (camScale, camScale, pNear)),
        baseCamera
    );
}



/*****************************************************************************
This function returns the projection of a world-coordinate point to image
(camera-plane) coordinates.
*****************************************************************************/

Point2Value *ProjectPoint (Point3Value *P, Camera *camera)
{
    return camera->Project (P);
}



/*****************************************************************************
This routine initializes static camera values.  For now, this is just the
default camera.
*****************************************************************************/

void InitializeModule_Camera (void)
{
    baseCamera             = NEW Camera (Camera::PERSPECTIVE);
    baseOrthographicCamera = NEW Camera (Camera::ORTHOGRAPHIC);

    defaultCamera      = baseCamera;
    orthographicCamera = baseOrthographicCamera;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\values\misc\bbox3i.cpp ===
/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

    3D axis aligned bounding box implementation

*******************************************************************************/

#include "headers.h"
#include <float.h>
#include <d3drmdef.h>
#include "appelles/vec3.h"
#include "privinc/xformi.h"
#include "privinc/vecutil.h"
#include "privinc/matutil.h"
#include "privinc/vec3i.h"
#include "privinc/bbox3i.h"


    /***************************/
    /***  Value Definitions  ***/
    /***************************/

Bbox3 *universeBbox3 = NULL;
Bbox3 *nullBbox3 = NULL;



/*****************************************************************************
Bbox3 Constructors
*****************************************************************************/

Bbox3::Bbox3 (Real xmin, Real ymin, Real zmin, Real xmax, Real ymax, Real zmax)
{   min.Set (xmin, ymin, zmin);
    max.Set (xmax, ymax, zmax);
}

Bbox3::Bbox3 (Point3Value &pmin, Point3Value &pmax)
{   min = pmin;
    max = pmax;
}

Bbox3::Bbox3 (void)
{   min.Set ( HUGE_VAL,  HUGE_VAL,  HUGE_VAL);
    max.Set (-HUGE_VAL, -HUGE_VAL, -HUGE_VAL);
}

Bbox3::Bbox3 (D3DRMBOX &d3dbox)
{
    min.Set (d3dbox.min.x, d3dbox.min.y, d3dbox.min.z);
    max.Set (d3dbox.max.x, d3dbox.max.y, d3dbox.max.z);
}



#if 0 // Currently Unused
/*****************************************************************************
This function returns the intersection of the two bounding boxes.  If the
two boxes don't intersect, this function returns the null box.  Note that
the intersection between a box and the universe box is the original box,
the intersection between the null box and a box is the null box, and the
intersection between the null box and the universe is the null box.
*****************************************************************************/

Bbox3 *Intersection (Bbox3 &b1, Bbox3 &b2)
{
    return NEW Bbox3 (
        MAX (b1.min.x, b2.min.x),
        MAX (b1.min.y, b2.min.y),
        MAX (b1.min.z, b2.min.z),
        MIN (b1.max.x, b2.max.x),
        MIN (b1.max.y, b2.max.y),
        MIN (b1.max.z, b2.max.z)
    );
}
#endif



/*****************************************************************************
This function returns the union of the two bounding boxes.  The union of
any box with null is the original box, and the union of anything with the
universe is the universe.
*****************************************************************************/

Bbox3 *Union (Bbox3 &b1, Bbox3 &b2)
{
    Real xmin = MIN (b1.min.x, b2.min.x);
    Real ymin = MIN (b1.min.y, b2.min.y);
    Real zmin = MIN (b1.min.z, b2.min.z);

    Real xmax = MAX (b1.max.x, b2.max.x);
    Real ymax = MAX (b1.max.y, b2.max.y);
    Real zmax = MAX (b1.max.z, b2.max.z);

    return NEW Bbox3 (xmin,ymin,zmin, xmax,ymax,zmax);
}



/*****************************************************************************
This function returns the bounding box extended to include the given point.
If the bounding box is null, the result is a zero-volume box that contains the
single point P.
*****************************************************************************/

void Bbox3::Augment (Real x, Real y, Real z)
{
    if (x < min.x)  min.x = x;
    if (y < min.y)  min.y = y;
    if (z < min.z)  min.z = z;

    if (x > max.x)  max.x = x;
    if (y > max.y)  max.y = y;
    if (z > max.z)  max.z = z;
}

void Bbox3::Augment (Point3Value &p)
{
    Augment (p.x, p.y, p.z);
}



/*****************************************************************************
This function augments the bounding box to include the second bounding box.
*****************************************************************************/

void Bbox3::Augment (Bbox3 &bbox)
{
    if (bbox.min.x < min.x)  min.x = bbox.min.x;
    if (bbox.min.y < min.y)  min.y = bbox.min.y;
    if (bbox.min.z < min.z)  min.z = bbox.min.z;

    if (bbox.max.x > max.x)  max.x = bbox.max.x;
    if (bbox.max.y > max.y)  max.y = bbox.max.y;
    if (bbox.max.z > max.z)  max.z = bbox.max.z;
}


/*****************************************************************************
This function fills an array of 8 points with the bbox's corners.
*****************************************************************************/

void Bbox3::GetPoints(Point3Value *pts)
{
    pts[0].Set(min.x,min.y,min.z);
    pts[1].Set(min.x,min.y,max.z);
    pts[2].Set(min.x,max.y,min.z);
    pts[3].Set(min.x,max.y,max.z);
    pts[4].Set(max.x,min.y,min.z);
    pts[5].Set(max.x,min.y,max.z);
    pts[6].Set(max.x,max.y,min.z);
    pts[7].Set(max.x,max.y,max.z);

    return;
}


/*****************************************************************************
This function clips the bounding box against a plane.
*****************************************************************************/

ClipCode Bbox3::Clip(Plane3 &plane)
{
    Point3Value points[8];
    GetPoints(points);

    ClipCode clip = points[0].Clip(plane);
    for (int i = 1; i < 8; i++) {
        if (points[i].Clip(plane) != clip) {
            clip = CLIPCODE_STRADDLE;
            break;
        }
    }
     
    return clip;
}


/*****************************************************************************
This routine tests the equality of this bounding box with another.
*****************************************************************************/

bool Bbox3::operator== (Bbox3 &other)
{
    return (min == other.min) && (max == other.max);
}



/*****************************************************************************
Return true if the bounding box is finite in all dimensions.  Note that a null
bbox is not finite.
*****************************************************************************/

bool Bbox3::Finite (void)
{
    return _finite(min.x) && _finite(min.y) && _finite(min.z)
        && _finite(max.x) && _finite(max.y) && _finite(max.z);
}



/*****************************************************************************
Return true if the box is non-negative in all dimensions.  Zero dimensions are
considered positive.
*****************************************************************************/

bool Bbox3::Positive (void)
{
    return (min.x <= max.x) && (min.y <= max.y) && (min.z <= max.z);
}



/*****************************************************************************
This routine transforms the given bounding box, and returns the new axis-
aligned bounding box.  It uses the idea from Graphics Gems I, Jim Arvo, pp
348-350.
*****************************************************************************/

Bbox3 *TransformBbox3 (Transform3 *xform, Bbox3 *box)
{
    // Check fringe cases first

    if ((*box == *universeBbox3) || (*box == *nullBbox3))
        return box;

    // Extract the min and max coords and the transform matrix.

    Real min[3], max[3];

    min[0] = box->min.x;     max[0] = box->max.x;
    min[1] = box->min.y;     max[1] = box->max.y;
    min[2] = box->min.z;     max[2] = box->max.z;

    const Apu4x4Matrix& mat = xform->Matrix();

    // The basic idea behind the following is that each transformed coordinate
    // will have a min and a max.  Since the bounding box is merely the set of
    // vertices of all permutations of min and max for each coordinate, there's
    // a quick shortcut.  Considering a single coordinate, it's the result of
    // the dot product between the corresponding row of the transform matrix
    // and the min/max coordinate values.  To find the minimum possible value
    // for the coordinate, we seek to minimize each term of the dot product.
    // For the max value, maximize each term.  Since all permutations of min/max
    // for each coordinate exist (e.g. <Xmin,Ymax,Zmax> or <Xmax,Ymax,Zmin>),
    // we can just pick and choose for each term, rather than transforming
    // each of all permutations (all bbox vertices).

    Real newmin[3], newmax[3];

    // Loop over each coordinate:  X, Y and Z

    for (int i=0;  i < 3;  ++i)
    {
        Real Bmin = mat[i][3];    // Start with the translation component.
        Real Bmax = Bmin;

        // Loop over each term of the dot product.

        for (int j=0;  j < 3;  ++j)
        {
            Real a = mat[i][j] * min[j]; // Grab the term from the min vector
            Real b = mat[i][j] * max[j]; // Grab the term from the max vector

            // We've calculated both possible values for this term.
            // Select the min & max values to add to the min & max dot
            // dot products.

            if (a < b)
            {   Bmin += a;
                Bmax += b;
            }
            else
            {   Bmin += b;
                Bmax += a;
            }
        }

        // Done for this coordinate.  Set the new bbox min/max vector component.

        newmin[i] = Bmin;
        newmax[i] = Bmax;
    }

    return NEW Bbox3 (newmin[0], newmin[1], newmin[2],
                      newmax[0], newmax[1], newmax[2]);
}



/*****************************************************************************
This routine unabashedly stolen from Graphics Gems I, "Fast Ray-Box
Intersection", pp. 395-396, Andrew Woo.
*****************************************************************************/

static bool HitBoundingBox (
    Real minB[3],    // box
    Real maxB[3],
    Real origin[3],  // ray origin
    Real dir[3],     // ray dir
    Real coord[3])   // output hit point
{
    const int NUMDIM = 3;
    const int RIGHT  = 0;
    const int LEFT   = 1;
    const int MIDDLE = 2;

    char inside = true;
    char quadrant[NUMDIM];
    int i;
    int whichPlane;
    double maxT[NUMDIM];
    double candidatePlane[NUMDIM];

    /* Find candidate planes; this loop can be avoided if
    rays cast all from the eye(assume perpsective view) */

    for (i=0; i<NUMDIM; i++) {
        if(origin[i] < minB[i]) {
            quadrant[i] = LEFT;
            candidatePlane[i] = minB[i];
            inside = false;
        }else if (origin[i] > maxB[i]) {
            quadrant[i] = RIGHT;
            candidatePlane[i] = maxB[i];
            inside = false;
        }else   {
            quadrant[i] = MIDDLE;
        }
    }

    /* Ray origin inside bounding box */
    if(inside) {
        coord[0] = origin[0];
        coord[1] = origin[1];
        coord[2] = origin[2];
        return (true);
    }

    /* Calculate T distances to candidate planes */
    for (i = 0; i < NUMDIM; i++) {
        if (quadrant[i] != MIDDLE && dir[i] !=0.)
            maxT[i] = (candidatePlane[i]-origin[i]) / dir[i];
        else
            maxT[i] = -1.;
    }

    /* Get largest of the maxT's for final choice of intersection */
    whichPlane = 0;
    for (i = 1; i < NUMDIM; i++) {
        if (maxT[whichPlane] < maxT[i])
            whichPlane = i;
    }

    /* Check final candidate actually inside box */
    if (maxT[whichPlane] < 0.) return (false);
    for (i = 0; i < NUMDIM; i++) {
        if (whichPlane != i) {
            coord[i] = origin[i] + maxT[whichPlane] *dir[i];
            if (coord[i] < minB[i] || coord[i] > maxB[i])
                return (false);
        } else {
            coord[i] = candidatePlane[i];
        }
    }

    return (true);                          /* ray hits box */
}       



/*****************************************************************************
Get the intersection of the given ray with the axis-aligned bounding box.  If
the ray does not hit the bounding box, this function returns null, otherwise
it returns the point of intersection.
*****************************************************************************/

Point3Value *Bbox3::Intersection (Ray3 *ray)
{
    Real minB[3], maxB[3], org[3], dir[3], result[3];

    minB[0] = min.x;
    minB[1] = min.y;
    minB[2] = min.z;

    maxB[0] = max.x;
    maxB[1] = max.y;
    maxB[2] = max.z;

    org[0] = ray->Origin().x;
    org[1] = ray->Origin().y;
    org[2] = ray->Origin().z;

    dir[0] = ray->Direction().x;
    dir[1] = ray->Direction().y;
    dir[2] = ray->Direction().z;

    bool hit = HitBoundingBox(minB, maxB, org, dir, result);

    return (hit) ? NEW Point3Value (result[0],result[1],result[2]) : NULL; 
}



/****************************************************************************/

Point3Value* Bbox3::Center (void)
{
    double x = min.x + (max.x - min.x) / 2;
    double y = min.y + (max.y - min.y) / 2;
    double z = min.z + (max.z - min.z) / 2;

    Point3Value* ppt = NEW Point3Value(x,y,z);
    return ppt;
}



/****************************************************************************/

Point3Value *MinBbox3 (Bbox3 *box) { return NEW Point3Value (box->min); }
Point3Value *MaxBbox3 (Bbox3 *box) { return NEW Point3Value (box->max); }



/*****************************************************************************
This routine initializes all of the static Bbox3 values.
*****************************************************************************/

void InitializeModule_Bbox3 (void)
{
    // NOTE:  The following two definitions rely on the HUGE_VAL macro, which
    // effectively returns double-precision infinity.

    // The universe box goes from -infinity to +infinity.  It contains
    // all points and all other boxes.
    universeBbox3 = NEW Bbox3
                    (   -HUGE_VAL, -HUGE_VAL, -HUGE_VAL,
                         HUGE_VAL,  HUGE_VAL,  HUGE_VAL
                    );

    // The null box can be thought of as the universe turned inside out.
    // It runs from a minimum of +inifinity to a maximum of -infinity.  It
    // turns out that these definitions for null and universe yield sane
    // answers on all the following operations, so you don't need to
    // test for these values explicitly.

    nullBbox3 = NEW Bbox3
                (    HUGE_VAL,  HUGE_VAL,  HUGE_VAL,
                    -HUGE_VAL, -HUGE_VAL, -HUGE_VAL
                );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\values\misc\fontstyl.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Implements the font style data type

*******************************************************************************/

#include "headers.h"
#include "appelles/text.h"
#include "appelles/path2.h"
#include "appelles/matte.h"
#include "privinc/texti.h"
#include "privinc/colori.h"
#include "privinc/xform2i.h"

class FontStyle : public AxAValueObj {
  public:

    FontStyle() {
        _bold = false;
        _italic = false;
        _underline = false;
        _strikethrough = false;
        _fixedText = false;
        _col = black;
        _family = serifProportional;
        _antiAliasing = 0;
        _size = DEFAULT_TEXT_POINT_SIZE;
        _weight = (double)(FW_NORMAL) / 1000.0;
        _characterTransform = NULL;
    }

    FontStyle *Bold() {
        FontStyle *fs = NEW FontStyle(this);
        fs->_bold = true;
        return fs;
    }
    
    FontStyle *Underline() {
        FontStyle *fs = NEW FontStyle(this);
        fs->_underline = true;
        return fs;
    }
    
    FontStyle *Strikethrough() {
        FontStyle *fs = NEW FontStyle(this);
        fs->_strikethrough = true;
        return fs;
    }
    
    FontStyle *Italic() {
        FontStyle *fs = NEW FontStyle(this);
        fs->_italic = true;
        return fs;
    }
    
    FontStyle *TheColor(Color *col)  {
        FontStyle *fs = NEW FontStyle(this);
        fs->_col = col;
        return fs;
    }
    
    FontStyle *Face(AxAString *face) {
        FontStyle *fs = NEW FontStyle(this);
        fs->_family = NEW FontFamily(face);
        return fs;
    }
    
    FontStyle *Size(AxANumber *num) {
        FontStyle *fs = NEW FontStyle(this);
        Real sz = num->GetNum();

        // NOTE: if size is <= that means use
        // fixed text mode.  otherwise, use regular
        // text mode.
        if(sz < 0) {
            fs->_size = -sz;
            fs = fs->FixedText(true);
        } else {
            fs->_size = sz;
        }
        
        return fs;
    }

    FontStyle *Weight(AxANumber *num) {
        FontStyle *fs = NEW FontStyle(this);
        fs->_weight = num->GetNum();
        return fs;
    }
    
    FontStyle *AntiAliasing(AxANumber *num) {
        FontStyle *fs = NEW FontStyle(this);
        fs->_antiAliasing = (int)(num->GetNum());
        return fs;
    }

    FontStyle *TransformCharacters(Transform2 *xf) {
        FontStyle *fs = NEW FontStyle(this);
        fs->_characterTransform = xf;
        return fs;
    }
    
    FontStyle *FixedText(bool isFixed) {
        FontStyle *fs = NEW FontStyle(this);
        fs->_fixedText = isFixed;
        return fs;
    }
    
    Image *TextImage(AxAString *str) {
        Text *tx = BuildText(str);
        Image *img = RenderTextToImage(tx);
        Transform2 *xf = BuildScaler();
        img = TransformImage(xf, img);

        return img;
    }

    Path2 *TextPath(AxAString *str) {
        Text *tx = BuildText(str);
        Path2 *pth = OriginalTextPath(tx);
        Transform2 *xf = BuildScaler();
        pth = TransformPath2(xf, pth);

        return pth;
    }
    
    Matte *TextMatte(AxAString *str) {
        Text *tx = BuildText(str);
        Matte *matte = OriginalTextMatte(tx);
        Transform2 *xf = BuildScaler();
        matte = TransformMatte(xf, matte);

        return matte;
    }
    
    virtual DXMTypeInfo GetTypeInfo() { return FontStyleType; }

    virtual void DoKids(GCFuncObj proc) {
        (*proc)(_col);
        (*proc)(_family);
        (*proc)(_characterTransform);
    }
    
  protected:
    FontStyle(FontStyle *fs) {
        _bold = fs->_bold;
        _italic = fs->_italic;
        _col = fs->_col;
        _family = fs->_family;
        _size = fs->_size;
        _strikethrough = fs->_strikethrough;
        _underline = fs->_underline;
        _weight = fs->_weight;
        _antiAliasing = fs->_antiAliasing;
        _fixedText = fs->_fixedText;
        _characterTransform = fs->_characterTransform;
    }

    Text *BuildText(AxAString *str) {
        Text *tx = SimpleText(str);

        if (_bold) { tx = TextBold(tx); }
        if (_italic) { tx = TextItalic(tx); }
        if (_underline) { tx = TextUnderline(tx); }
        if (_strikethrough) { tx = TextStrikethrough(tx); }
        if (_fixedText) { tx = TextFixedText(tx); }
        if (_characterTransform) { tx = TextTransformCharacter(_characterTransform, tx); }
        
        tx = TextColor(_col, tx);
        tx = TextFont(_family, _size, tx);
        tx = TextWeight(_weight, tx);
        tx = TextAntiAliased(_antiAliasing, tx);
        
        return tx;
    }

    Transform2 *BuildScaler() {
        // The size is specified in points, but the underlying
        // renderer wants a factor difference from the default point
        // size, thus we come up with this factor to effect a
        // different point size.
        double scaleFac = _size / DEFAULT_TEXT_POINT_SIZE;
        Transform2 *xf = Scale2(NEW AxANumber(scaleFac));

        return xf;
    }

    boolean     _bold;
    boolean     _italic;
    double      _weight;
    boolean     _underline;
    boolean     _strikethrough;
    boolean     _fixedText;
    Color      *_col;
    FontFamily *_family;
    double      _size;
    int         _antiAliasing;
    Transform2 *_characterTransform;
};

FontStyle *
Font(AxAString *str, AxANumber *size, Color *col)
{
    return defaultFont->Face(str)->Size(size)->TheColor(col);
}

Image *
ImageFromStringAndFontStyle(AxAString *str, FontStyle *fs)
{
    return fs->TextImage(str);
}


// This guy is declared in path2.h, but is dependent upon fontstyle.
Path2 *
TextPath2Constructor(AxAString *str, FontStyle *fs)
{
    return fs->TextPath(str);
}

// This guy is declared in matte.h, but is dependent upon fontstyle.
Matte *
TextMatteConstructor(AxAString *str, FontStyle *fs)
{
    return fs->TextMatte(str);
}


FontStyle *FontStyleBold(FontStyle *fs) { return fs->Bold(); }
FontStyle *FontStyleItalic(FontStyle *fs) { return fs->Italic(); }
FontStyle *FontStyleColor(FontStyle *fs, Color *col) { return fs->TheColor(col); }
FontStyle *FontStyleFace(FontStyle *fs, AxAString *str) { return fs->Face(str); }
FontStyle *FontStyleSize(FontStyle *fs, AxANumber *num) { return fs->Size(num); }

FontStyle *FontStyleAntiAliasing(AxANumber *aaStyle, FontStyle *fs)
{ return fs->AntiAliasing(aaStyle); }

FontStyle *
FontStyleUnderline(FontStyle *fs)
{ return fs->Underline(); }

FontStyle *
FontStyleStrikethrough(FontStyle *fs)
{ return fs->Strikethrough(); }

FontStyle *
FontStyleWeight(FontStyle *fs, AxANumber *weight)
{ return fs->Weight(weight); }

FontStyle *
FontStyleFixedText(FontStyle *fs, bool isFixed)
{ return fs->FixedText(isFixed); }

FontStyle *defaultFont;

////////////////////// IDA2FontStyle methods ////////////////////

FontStyle *
FontStyleTransformCharacters(FontStyle *fs, Transform2 *xf)
{ return fs->TransformCharacters(xf); }


void
InitializeModule_FontStyle()
{
    defaultFont = NEW FontStyle();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\values\misc\matte.cpp ===
/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    2D mattes

*******************************************************************************/

#include "headers.h"
#include "privinc/mattei.h"
#include "privinc/path2i.h"
#include "privinc/except.h"
#include "privinc/xform2i.h"
#include "appelles/bbox2.h"
#include "privinc/bbox2i.h"
#include "privinc/polygon.h"
#include "privinc/texti.h"
#include "privinc/textctx.h"
#include "privinc/server.h"  // getCurrentImageDispdev...


//////////////////

Matte::MatteType
Matte::GenerateHRGN(HDC dc,
                    callBackPtr_t devCallBack,
                    void *devCtxPtr,
                    Transform2 *xform,
                    HRGN *hrgnOut,
                    bool justDoPath)
{
    // assert mutually exclusive
    Assert( (justDoPath  && !hrgnOut)  ||
            (!justDoPath && hrgnOut) );
    
    // Generate an initially empty HRGN
    MatteCtx ctx(dc,
                 devCallBack,
                 devCtxPtr,
                 xform,
                 justDoPath);

    // Accumulate into the context
    Accumulate(ctx);

    // Pull out HRGN and MatteType.
    if( hrgnOut ) {
        *hrgnOut = ctx.GetHRGN();
    }
    
    return ctx.GetMatteType();
}

inline Matte::MatteType   
Matte::GenerateHRGN(MatteCtx &inCtx,
                    HRGN *hrgnOut)
{
    return GenerateHRGN(inCtx._dc,
                        inCtx._devCallBack,
                        inCtx._devCtxPtr,
                        inCtx._xf,
                        hrgnOut,
                        inCtx._justDoPath);
}


//////////////////

class OpaqueMatte : public Matte {
  public:
    void Accumulate(MatteCtx& ctx) {
        // Just don't accum anything in.
    }
    inline const Bbox2 BoundingBox() {
        return NullBbox2;
    }

#if BOUNDINGBOX_TIGHTER
    inline const Bbox2 BoundingBoxTighter(Bbox2Ctx &bbctx) {
        return NullBbox2;
    }
#endif  // BOUNDINGBOX_TIGHTER

#if 0
    Bool BoundingPgon(BoundingPolygon &pgon) {
        //pgon.SetBox(nullBbox2); maybe a fully opaque matte means no bounding pgon ?
        return FALSE;
    }
#endif

};

Matte *opaqueMatte = NULL;

//////////////////

class ClearMatte : public Matte {
  public:
    void Accumulate(MatteCtx& ctx) {

        // shouldn't be here at all if we're just accum path
        Assert( !ctx.JustDoPath() );
        
        // If we hit this, our matte is infinitely clear.
        ctx.AddInfinitelyClearRegion();
    }

    inline const Bbox2 BoundingBox() {
        return UniverseBbox2;
    }

#if BOUNDINGBOX_TIGHTER
    inline const Bbox2 BoundingBoxTighter(Bbox2Ctx &bbctx) {
        return UniverseBbox2;
    }
#endif  // BOUNDINGBOX_TIGHTER

#if 0
    Bool BoundingPgon(BoundingPolygon &pgon) {
        pgon.SetBox(universeBbox2);
    }
#endif

#if _USE_PRINT
    ostream& Print(ostream& os) { return os << "ClearMatte"; }
#endif
};

Matte *clearMatte = NULL;

//////////////////

class HalfMatte : public Matte {
  public:
    void Accumulate(MatteCtx& ctx) {

        // shouldn't be here at all if we're just accum path
        Assert( !ctx.JustDoPath() );

        // If we hit this, our matte is clear on the top, opaque on the bottom
        ctx.AddHalfClearRegion();
    }

    inline const Bbox2 BoundingBox() {
        return Bbox2(-HUGE_VAL, 0, HUGE_VAL, HUGE_VAL);
    }

#if BOUNDINGBOX_TIGHTER
    inline const Bbox2 BoundingBoxTighter(Bbox2Ctx &bbctx) {
        return Bbox2(-HUGE_VAL, 0, HUGE_VAL, HUGE_VAL);
    }
#endif  // BOUNDINGBOX_TIGHTER

#if 0
    void BoundingPgon(BoundingPolygon &pgon) {
        pgon.SetBox(BoundingBox());
    }
#endif

#if _USE_PRINT
    ostream& Print(ostream& os) { return os << "HalfMatte"; }
#endif
};

Matte *halfMatte = NULL;

//////////////////

class UnionedMatte : public Matte {
  public:
    UnionedMatte(Matte *m1, Matte *m2) : _m1(m1), _m2(m2) {}

    void Accumulate(MatteCtx& ctx) {
        // shouldn't be here at all if we're just accum path
        Assert( !ctx.JustDoPath() );

        _m1->Accumulate(ctx);
        _m2->Accumulate(ctx);
    }

    const Bbox2 BoundingBox() {
        return UnionBbox2Bbox2(_m1->BoundingBox(), _m2->BoundingBox());
    }

#if BOUNDINGBOX_TIGHTER
    const Bbox2 BoundingBoxTighter(Bbox2Ctx &bbctx) {
        return UnionBbox2Bbox2(_m1->BoundingBoxTighter(bbctx), _m2->BoundingBoxTighter(bbctx));
    }
#endif  // BOUNDINGBOX_TIGHTER

#if 0
    Bool BoundingPgon(BoundingPolygon &pgon) {
        return FALSE;
    }
#endif

    // TODO: union matte could be constructed in terms of paths.
    // TODO: don't forget the following when trying to implement this:
    //   1.> each underlying matte needs to ACCUMULATE the path.
    //   right now pathbasedmatte, for example, does a begin/end.  in
    //   order to do union right, we need ONE begin at the first union
    //   and ONE end after it, and every path or textpath underneath
    //   just accumulates into the path (moveto, lineto, bezierto,
    //   etc...)
    //   2.> Also take out the assert in Accumulate above
    /*
    bool    IsPathRepresentableMatte() {
        return
            _m1->IsPathRepresentableMatte() &&
            _m2->IsPathRepresentableMatte();
    }
    */            

    virtual void DoKids(GCFuncObj proc) { 
        (*proc)(_m1);
        (*proc)(_m2);
    }
    
#if _USE_PRINT
    ostream& Print(ostream& os) {
        return os << "UnionedMatte(" << _m1 << "," << _m2 << ")";
    }
#endif

  protected:
    Matte *_m1;
    Matte *_m2;
};

Matte *
UnionMatte(Matte *m1, Matte *m2)
{
    if (m1 == opaqueMatte) {
        return m2;
    } else if (m2 == opaqueMatte) {
        return m1;
    } else if (m1 == clearMatte || m2 == clearMatte) {
        return clearMatte;
    } else {
        return NEW UnionedMatte(m1, m2);
    }
}

//////////////////

class SubtractedMatte : public Matte {
  public:
    SubtractedMatte(Matte *m1, Matte *m2) : _m1(m1), _m2(m2) {}

    void Accumulate(MatteCtx& ctx) {

        // shouldn't be here at all if we're just accum path
        Assert( !ctx.JustDoPath() );

        // Use the provided ctx to accumulate m1 in...  This relies on
        // a+(b-c) == (a+b)-c.
        _m1->Accumulate(ctx);

        // Then, get the HRGN for m2, but pass in the current
        // transform as the one to subject m2 to.  This relies on
        // the identity: xf(a - b) == xf(a) - xf(b).
        HRGN m2Rgn;
        MatteType m2Type = _m2->GenerateHRGN(ctx,
                                             &m2Rgn);

        // TODO: Use the type of m2 to optimize.
        
        // Finally, subtract this HRGN from that being accumulated in
        // ctx.  This checks to see if m2Rgn (the region) is valid before
        // doing the subtraction.  This is OK that the region is not always
        // valid since there are instances that the two mattes move away from 
        // each other and the interseting region goes to zero.
        if(m2Rgn) {
            ctx.SubtractHRGN(m2Rgn);
        }

        // region m2Rgn is managed by ctx
    }
    
    const Bbox2 BoundingBox() {
        // TODO: this is an aproximation
        return _m1->BoundingBox();
    }

#if BOUNDINGBOX_TIGHTER
    const Bbox2 BoundingBoxTighter(Bbox2Ctx &bbctx) {
        // TODO: this is an aproximation
        return _m1->BoundingBoxTighter(bbctx);
    }
#endif  // BOUNDINGBOX_TIGHTER

#if 0
    void BoundingPgon(BoundingPolygon &pgon) {
        // TODO: BoundingPolygon on subtracted matte not implemented
    }
#endif

    virtual void DoKids(GCFuncObj proc) { 
        (*proc)(_m1);
        (*proc)(_m2);
    }

#if _USE_PRINT
    ostream& Print(ostream& os) {
        return os << "SubtractedMatte(" << _m1 << "," << _m2 << ")";
    }
#endif

  protected:
    Matte *_m1;
    Matte *_m2;
};

Matte *
SubtractMatte(Matte *m1, Matte *m2)
{
    if (m1 == opaqueMatte || m2 == clearMatte) {
        return opaqueMatte;
    } else if (m2 == opaqueMatte) {
        return m1;
    } else if (m1 == m2) {
        return opaqueMatte;
    } else {
        return NEW SubtractedMatte(m1, m2);
    }
}

//////////////////

class IntersectedMatte : public Matte {
  public:
    IntersectedMatte(Matte *m1, Matte *m2) : _m1(m1), _m2(m2) {}

    void Accumulate(MatteCtx& ctx) {

        // shouldn't be here at all if we're just accum path
        Assert( !ctx.JustDoPath() );

        // Accumulate in an intersection of two regions.  Do so via:
        // a + xf(b isect c)) == a + (xf(b) isect xf(c))

        HRGN m1Rgn, m2Rgn;
        MatteType m1Type = _m1->GenerateHRGN(ctx,
                                             &m1Rgn);
        
        MatteType m2Type = _m2->GenerateHRGN(ctx,
                                             &m2Rgn);

        // TODO: Consider using return types to optimize.
        
        // Identities used in SubtractMatte below should ensure that
        // m1Rgn and m2Rgn are never NULL.
        Assert(m1Rgn && m2Rgn);

        ctx.IntersectAndAddHRGNS(m1Rgn, m2Rgn);

        // the regions are managed by the ctx
    }

    const Bbox2 BoundingBox() {
        return IntersectBbox2Bbox2(_m1->BoundingBox(), _m2->BoundingBox());
    }

#if BOUNDINGBOX_TIGHTER
    const Bbox2 BoundingBoxTighter(Bbox2Ctx &bbctx) {
        return IntersectBbox2Bbox2(_m1->BoundingBoxTighter(bbctx), _m2->BoundingBoxTighter(bbctx));
    }
#endif  // BOUNDINGBOX_TIGHTER

#if 0
    void BoundingPgon(BoundingPolygon &pgon) {
         // TODO: BoundingPolygon on Intersected matte not implemented
        _m1->BoundingPgon(pgon);
        _m2->BoundingPgon(pgon);
    }
#endif

    virtual void DoKids(GCFuncObj proc) { 
        (*proc)(_m1);
        (*proc)(_m2);
    }

#if _USE_PRINT
    ostream& Print(ostream& os) {
        return os << "IntersectedMatte(" << _m1 << "," << _m2 << ")";
    }
#endif

  protected:
    Matte *_m1;
    Matte *_m2;
};

Matte *
IntersectMatte(Matte *m1, Matte *m2)
{
    if (m1 == opaqueMatte || m2 == opaqueMatte) {
        return opaqueMatte;
    } else if (m1 == clearMatte) {
        return m2;
    } else if (m2 == clearMatte) {
        return m1;
    } else if (m1 == m2) {
        return m1;
    } else {
        return NEW IntersectedMatte(m1, m2);
    }
}

//////////////////


class PathBasedMatte : public Matte {
  public:
    PathBasedMatte(Path2 *p) : _path(p) {}
    
    void Accumulate(MatteCtx& ctx) {


        // Accumulate the path into the device context
        _path->AccumPathIntoDC (ctx.GetDC(), ctx.GetTransform(), true);

        if( ctx.JustDoPath() ) {
            // we're done: the path is in the dc like we wanted!
        } else {

            // Convert the DC's current path into a region.
            HRGN rgn;
            TIME_GDI(rgn = PathToRegion(ctx.GetDC()));

            // If the region couldn't be created, bail out.

            if (rgn == 0) {
                return;
            }

            ctx.AddHRGN(rgn, nonTrivialHardMatte);
        
            // TODO: May want to optimize special case where the only
            // region comes from this path, in which case using
            // SelectClipPath *may* produce faster results.
        }

    }
        
    Bool ExtractAsSingleContour(Transform2 *xform,
                                int *numPts,            // out
                                POINT **gdiPts,          // out
                                Bool *isPolyline) {

        return _path->ExtractAsSingleContour(
            xform,
            numPts,
            gdiPts,
            isPolyline);
    }

    const Bbox2 BoundingBox() {
        return _path->BoundingBox();
    }

#if BOUNDINGBOX_TIGHTER
    const Bbox2 BoundingBoxTighter(Bbox2Ctx &bbctx) {
        return _path->BoundingBoxTighter(bbctx);
    }
#endif  // BOUNDINGBOX_TIGHTER

    Path2   *IsPathRepresentableMatte() { return _path; }

    virtual void DoKids(GCFuncObj proc) { (*proc)(_path); }
    
#if _USE_PRINT
    ostream& Print(ostream& os) {
        return os << "PathBasedMatte(" << _path << ")";
    }
#endif

  protected:
    Path2 *_path;
};


Matte *
RegionFromPath(Path2 *p)
{
    return NEW PathBasedMatte(p);
}

//////////////////

class TransformedMatte : public Matte {
  public:
    TransformedMatte(Transform2 *xf, Matte *m) : _xf(xf), _m(m) {}

    // Standard push, accumulate, process, and pop...
    void Accumulate(MatteCtx& ctx) {
        Transform2 *oldXf = ctx.GetTransform();
        ctx.SetTransform(TimesTransform2Transform2(oldXf, _xf));
        _m->Accumulate(ctx);
        ctx.SetTransform(oldXf);
    }

    Bool ExtractAsSingleContour(Transform2 *xform,
                                int *numPts,            // out
                                POINT **gdiPts,          // out
                                Bool *isPolyline) {

        return _m->ExtractAsSingleContour(
            TimesTransform2Transform2(xform, _xf),
            numPts,
            gdiPts,
            isPolyline);
    }

    const Bbox2 BoundingBox() {
        return TransformBbox2(_xf, _m->BoundingBox());
    }

#if BOUNDINGBOX_TIGHTER
    const Bbox2 BoundingBoxTighter(Bbox2Ctx &bbctx) {
        Bbox2Ctx bbctxAccum(bbctx, _xf);
        return _m->BoundingBoxTighter(bbctxAccum);
    }
#endif  // BOUNDINGBOX_TIGHTER

#if 0
    void BoundingPgon(BoundingPolygon &pgon) {
        _m->BoundingPgon(pgon);
        pgon.Transform(_xf);
    }
#endif

    Path2 *IsPathRepresentableMatte() {
        
        Path2 *p = _m->IsPathRepresentableMatte();
        if (p) {
            return TransformPath2(_xf, p);
        } else {
            return NULL;
        }
    }

    virtual void DoKids(GCFuncObj proc) { 
        (*proc)(_xf);
        (*proc)(_m);
    }

#if _USE_PRINT
    ostream& Print(ostream& os) {
        return os << "TransformedMatte(" << _xf << "," << _m << ")";
    }
#endif

  protected:
    Transform2 *_xf;
    Matte      *_m;
};

Matte *
TransformMatte(Transform2 *xf, Matte *r)
{
    if (r == opaqueMatte || r == clearMatte ||
                            xf == identityTransform2) {
        return r;
    } else {
        return NEW TransformedMatte(xf, r);
    }
}

////////////////////////////////////

// TEXT MATTE
class TextMatte : public Matte {
  public:
    TextMatte(Text *text) : _text(text) {}

    void Accumulate(MatteCtx &ctx);
        
    const Bbox2 BoundingBox();

#if BOUNDINGBOX_TIGHTER
    const Bbox2 BoundingBoxTighter(Bbox2Ctx &bbctx);
#endif  // BOUNDINGBOX_TIGHTER

    Path2 *IsPathRepresentableMatte() {
        return OriginalTextPath(_text);
    }

    virtual void DoKids(GCFuncObj proc) { (*proc)(_text); }

#if _USE_PRINT
    ostream& Print(ostream& os) {
        return os << "TextMatte(" << _text << ")";
    }
#endif

  private:
    Text *_text;
};

void TextMatte::
Accumulate(MatteCtx &ctx)
{
    // TODO: when we cleanup matte, let's make the image device part of
    // the matte context, ok ?
    TextCtx textCtx(
        GetImageRendererFromViewport( GetCurrentViewport() ));

    TIME_GDI(BeginPath(ctx.GetDC()));

    textCtx.BeginRendering(TextCtx::renderForPath,
                           ctx.GetDC(),
                           ctx.GetTransform());
    _text->RenderToTextCtx(textCtx);

    textCtx.EndRendering();

    TIME_GDI(EndPath(ctx.GetDC()));

    if( ctx.JustDoPath() ) {
        // we're done
    } else {
        //
        // create a region from the path
        //
        HRGN rgn;
        TIME_GDI(rgn = PathToRegion(ctx.GetDC()));
        if (rgn == 0) {
            RaiseException_InternalError("Couldn't create region for TextMatte");
        }

        ctx.AddHRGN(rgn, nonTrivialHardMatte);
    }
}

const Bbox2 TextMatte::BoundingBox()
{
    TextCtx ctx(
        GetImageRendererFromViewport( GetCurrentViewport() ));
    
    ctx.BeginRendering(TextCtx::renderForBox);
    
    _text->RenderToTextCtx(ctx);
    
    ctx.EndRendering();

    return ctx.GetStashedBbox();
}

#if BOUNDINGBOX_TIGHTER
const Bbox2 TextMatte::BoundingBoxTighter(Bbox2Ctx &bbctx)
{
    Transform2 *xf = bbctx.GetTransform();
    return TransformBbox2(xf, BoundingBox());
}
#endif  // BOUNDINGBOX_TIGHTER

Matte *OriginalTextMatte(Text *text)
{
    return NEW TextMatte(text);
}

////////////////////////////////////
void
InitializeModule_Matte()
{
    opaqueMatte = NEW OpaqueMatte;
    clearMatte = NEW ClearMatte;
    halfMatte =  NEW HalfMatte;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\values\misc\quati.cpp ===
/*++

Module Name:


Abstract:

--*/

#include "headers.h"

#ifdef QUATERNIONS_REMOVED_FOR_NOW

#include <appelles/common.h>
#include "privinc/vecutil.h"
#include "privinc/vec3i.h"
#include <appelles/xform.h>
#include <appelles/vec3.h>
#include <appelles/quat.h>
#include <privinc/quati.h>

const Quaternion *identityQuaternion = Quaternion *(
    new Quaternion(1.0, XyzVector3(0,0,0), 0, XyzVector3(0,0,0)));

// Private functions: not sure what use these are...
Quaternion *Normalize (Quaternion *q);
Real Length (Quaternion *q);
Real Dot (Quaternion *a, Quaternion *b);
Quaternion *operator+ (Quaternion *a, Quaternion *b);
Quaternion *operator* (Real c, Quaternion *q);
Quaternion *operator/ (Quaternion *q, Real c);
//Quaternion *Inverse (Quaternion *q);
//Real       Magnitude (Quaternion *q);

Quaternion *AngleAxisQuaternion(Real theta, Vector3Value *axis)
{
    return Quaternion *( new Quaternion(
        cos(theta/2.0),
        sin(theta/2.0) * Normalize(axis),
        theta,
        axis));
}

#define NEWQUATERNION(theta, axis)  Quaternion *( new Quaternion((theta), (axis)))

    // Rq(p) means rotate p using quaterion q and is defined as: qpq_bar
    //  where q_bar is the Conjugate.  If q=c+u, q_bar = c-u.

    // Composition of two quaternion transformations of p
    // Rqq'(p) = Rq(p) @ Rq'(p)   (where @ = compose)
    //         = Rq(Rq'(p))
    //         = Rq(q'pq'_bar)    (where q'_bar is the Conjugate of q')
    //         = q(q'pq'_bar)q_bar
    //         = (qq')p(q'_bar q_bar)
    //         = Rqq'(p)
// So: multiplication is composition of quaternions that
//     transform a point p in 3space.

Quaternion *operator* (Quaternion *a, Quaternion *b)
{
    Quaternion *q1 = a, *q2 = b;
    Real c1 = q1->C(),
         c2 = q2->C();
    Vector3Value *u1 = q1->U(),
            u2 = q2->U();

    // Multiply two quaternions:
    // qq' = (c + u)(c' + u')
    //     = (cc' - u dot u') + (u X u' + cu' + c'u)

    Real c = ( c1 * c2  -  Dot(u1, u2) );
    Vector3 *u = Cross(u1, u2) + (c1 * u2) + (c2 * u1);

    return NEWQUATERNION(c, u);
}

Quaternion *operator* (Real c, Quaternion *q)
{
    return NEWQUATERNION(c * q->C(), c * q->U());
}

Quaternion *operator- (Quaternion *q)
{
    return NEWQUATERNION(-(q->C()), -(q->U()) );
}

Quaternion *operator+ (Quaternion *a, Quaternion *b)
{
    return NEWQUATERNION(a->C() + b->C(), a->U() + b->U());
}

Quaternion *operator/ (Quaternion *q, Real c)
{
    return NEWQUATERNION(q->C() / c, q->U() / c);
}

Quaternion *Conjugate (Quaternion *q)
{
    return NEWQUATERNION(q->C(), - q->U());
}

Real Magnitude (Quaternion *q)
{
    return (q->C() * q->C()) + LengthSquared(q->U());
}

Real Dot (Quaternion *a, Quaternion *b)
{
    return (a->C() * b->C()) + Dot(a->U(), b->U());
}

Quaternion *Interp (Quaternion *a, Quaternion *b, Real alpha)
{
    // See Gems III, page 96 and gems II page 379
    // This is called a SLERP: Spherical Linear intERPoplation

    Real theta = acos(Dot(a, b)); // Angle between quaternions a and b.
    Real inv_sin_t = 1.0 / sin(theta);
    Real alpha_theta = alpha * theta;

    return (sin(theta - alpha_theta) * inv_sin_t) * a + (sin(alpha_theta) * inv_sin_t) * b;
}

/*
Quaternion *Inverse (Quaternion *q)
{
    return Conjugate(q) / Magnitude(q);
}
*/
Real Length (Quaternion *q)
{
    return sqrt(Magnitude(q));
}

Quaternion *Normalize (Quaternion *q)
{
    return q / Length(q);
}

/*
// Utilities to build Transform3 *matrix from Quaternion *Transform3 *Left(Quaternion *q)
{
    Vector3Value *v = q->U();
    Real c = q->C();
    return MatrixTransform(
                  c,  - ZCoord(v),   YCoord(v), XCoord(v),
          ZCoord(v),            c, - XCoord(v), YCoord(v),
        - YCoord(v),    XCoord(v),           c, ZCoord(v),
        - XCoord(v),  - YCoord(v), - ZCoord(v),        c);
}

Transform3 *Right(Quaternion *q)
{
    Vector3Value *v = q->U();
    Real c = q->C();
    return MatrixTransform(
                  c,    ZCoord(v), - YCoord(v), XCoord(v),
        - ZCoord(v),            c,   XCoord(v), YCoord(v),
          YCoord(v),  - XCoord(v),           c, ZCoord(v),
        - XCoord(v),  - YCoord(v), - ZCoord(v),        c);
}
*/

Transform3 *Rotate(Quaternion *q)
{
// The following explicit calculation (actually: multiplication
// of two special matricies) quarantees that we don't get any roundoff
// error in the bottom row and hence have RL reject the transform.
// - ddalal 09/20/95
    Vector3Value *v = q->U();
    Real c = q->C(), cc = c*c;
    Real x = XCoord(v), y = YCoord(v), z = ZCoord(v);
    Real xx = x*x, yy = y*y, zz = z*z;

    return MatrixTransform(
        (cc - zz - yy + xx),       2*(x*y - c*z),       2*(c*y + x*z), 0,
              2*(c*z + x*y), (cc - zz + yy - xx),       2*(y*z - c*x), 0,
              2*(x*z - c*y),       2*(y*z + c*x), (cc + zz - yy - xx), 0,
                           0,                   0,                   0, 1);
//                           0,                   0,                   0, (cc + zz + yy + xx));
}


// These could be more efficient by stashing theta + vector in quaternion
Vector3Value *AxisComponent(Quaternion *q)
{
    return q->Axis();
}

Real AngleComponent(Quaternion *q)
{
    return q->Angle();
}

#endif QUATERNIONS_REMOVED_FOR_NOW
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\values\misc\matutil.cpp ===
/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

Abstract:
    Transformation matrix utilities.

*******************************************************************************/

#include "headers.h"
#include <float.h>

#include "appelles/common.h"
#include "privinc/matutil.h"
#include "privinc/except.h"
#include "privinc/debug.h"


    /*********************************/
    /*** Local Function Prototypes ***/
    /*********************************/

static void adjoint(const Apu4x4Matrix *in, Apu4x4Matrix *out);
static Real det3x3(Real a1, Real a2, Real a3,
              Real b1, Real b2, Real b3,
              Real c1, Real c2, Real c3);
static bool inverse(const Apu4x4Matrix *in, Apu4x4Matrix *out);
static bool inverse3x3(const Apu4x4Matrix& in, Apu4x4Matrix& out);


    /****************************/
    /*** Constant Definitions ***/
    /****************************/

// Make the SINGULARITY_THRESHOLD constant quite small indeed, so that
// non-singular matrices whose elements themselves are quite small are
// not reported as singular matrices.
const Real SINGULARITY_THRESHOLD = 1.e-80;

const Apu4x4Matrix apuIdentityMatrix =
{
  {
    {1, 0, 0, 0},
    {0, 1, 0, 0},
    {0, 0, 1, 0},
    {0, 0, 0, 1}
  },
  Apu4x4Matrix::IDENTITY_E,
  1
};

    // This is a table of return types for matrix multiplies.  table[a][b] is
    // the type of A * B, where a and b are the types of A and B respectively.

const Apu4x4Matrix::form_e
Apu4x4Matrix::MultiplyReturnTypes[END_OF_FORM_E][END_OF_FORM_E] =
{
    // Uninitialized
    {
        UNINITIALIZED_E,    // uninitialized * uninitialized
        UNINITIALIZED_E,    // uninitialized * identity
        UNINITIALIZED_E,    // uninitialized * translation
        UNINITIALIZED_E,    // uninitialized * upper3x3
        UNINITIALIZED_E,    // uninitialized * affine
        UNINITIALIZED_E     // uninitialized * perspective
    },

    // identity
    {
        UNINITIALIZED_E,    // identity * uninitialized
        IDENTITY_E,         // identity * identity
        TRANSLATE_E,        // identity * translation
        UPPER_3X3_E,        // identity * upper3x3
        AFFINE_E,           // identity * affine
        PERSPECTIVE_E       // identity * perspective
    },

    // translate
    {
        UNINITIALIZED_E,    // translation * uninitialized
        TRANSLATE_E,        // translation * identity
        TRANSLATE_E,        // translation * translation
        AFFINE_E,           // translation * upper3x3
        AFFINE_E,           // translation * affine
        PERSPECTIVE_E       // translation * perspective
    },

    // upper3x3
    {
        UNINITIALIZED_E,    // upper3x3 * uninitialized
        UPPER_3X3_E,        // upper3x3 * identity
        AFFINE_E,           // upper3x3 * translation
        UPPER_3X3_E,        // upper3x3 * upper3x3
        AFFINE_E,           // upper3x3 * affine
        PERSPECTIVE_E       // upper3x3 * perspective
    },

    // affine
    {
        UNINITIALIZED_E,    // affine * uninitialized
        AFFINE_E,           // affine * identity
        AFFINE_E,           // affine * translation
        AFFINE_E,           // affine * upper3x3
        AFFINE_E,           // affine * affine
        PERSPECTIVE_E       // affine * perspective
    },

    // perspective
    {
        UNINITIALIZED_E,    // perspective * uninitialized
        PERSPECTIVE_E,      // perspective * identity
        PERSPECTIVE_E,      // perspective * translation
        PERSPECTIVE_E,      // perspective * upper3x3
        PERSPECTIVE_E,      // perspective * affine
        PERSPECTIVE_E       // perspective * perspective
    }
};


    // This array contains the string versions of the matrix forms.

const char* const Apu4x4Matrix::form_s [END_OF_FORM_E] =
{
    "UNINITIALIZED_E",
    "IDENTITY_E",
    "TRANSLATE_E",
    "UPPER_3X3_E",
    "AFFINE_E",
    "PERSPECTIVE_E"
};



#if _USE_PRINT
/*****************************************************************************
This method prints the text representation of the Apu4x4Matrix to the given
ostream.
*****************************************************************************/

ostream& Apu4x4Matrix::Print (ostream& os) const
{
    os << "Apu4x4Matrix (form=";

    if ((form < 0) || (form >= END_OF_FORM_E))
        os << (int)form;
    else
        os << form_s[form];

    os << ", is_rigid=" << (int)is_rigid;

    os << ",";

    for (int ii=0;  ii < 4;  ++ii)
    {   os << "\n    "
           << m[ii][0] << ", " << m[ii][1] << ", "
           << m[ii][2] << ", " << m[ii][3];
    }

    return os << ")\n" << flush;
}
#endif



/*****************************************************************************
Sets the Apu4x4Matrix to the identity matrix.
*****************************************************************************/

void Apu4x4Matrix::SetIdentity ()
{
    *this = apuIdentityMatrix;
}



/*****************************************************************************
Automatically characterize 4x4 and set the transform type.
*****************************************************************************/

void Apu4x4Matrix::SetType (void)
{
    // We know the matrix is rigid if it's identity or pure translate.
    // If it's upper_3x3 or affine, then we'd have to analyze the matrix.  The
    // brute force method takes 18 multiplies and 6 square roots, and possibly
    // for naught, so we'll just punt by default.  The result is that we take
    // the hard approach if we need to find the inverse.

    is_rigid = false;

    // The matrix is perspective if the bottom row is not [0 0 0 1].

    if ((m[3][0] != 0) || (m[3][1] != 0) || (m[3][2] != 0) || (m[3][3] != 1))
    {
        form = PERSPECTIVE_E;
    }
    else if ((m[0][3] == 0) && (m[1][3] == 0) && (m[2][3] == 0))
    {
        // The translate column is [0 0 0] (no translate).  If the upper
        // 3x3 is also canonical, then it's an identity matrix.

        if (  (m[0][0] == 1) && (m[0][1] == 0) && (m[0][2] == 0)
           && (m[1][0] == 0) && (m[1][1] == 1) && (m[1][2] == 0)
           && (m[2][0] == 0) && (m[2][1] == 0) && (m[2][2] == 1))
        {
            form = IDENTITY_E;      // Special case of upper 3x3.
            is_rigid = true;
        }
        else
        {
            form = UPPER_3X3_E;
        }
    }
    else
    {
        // The matrix has translation components.

        if (  (m[0][0] == 1) && (m[0][1] == 0) && (m[0][2] == 0)
           && (m[1][0] == 0) && (m[1][1] == 1) && (m[1][2] == 0)
           && (m[2][0] == 0) && (m[2][1] == 0) && (m[2][2] == 1))
        {
            form = TRANSLATE_E;     // Special case of affine.
            is_rigid = true;
        }
        else
        {
            form = AFFINE_E;
        }
    }
}



/*****************************************************************************
This function post-concatenates a translation to the Apu4x4Matrix.
*****************************************************************************/

void Apu4x4Matrix::PostTranslate (Real x, Real y, Real z)
{
    Real a03;
    Real a13;
    Real a23;
    Real a33 = 1.0;

    Assert((form != UNINITIALIZED_E) && "Translate of uninitialized matrix.");

    if (x == 0.0 && y == 0.0 && z == 0.0) return;

    switch (form)
    {
        case UNINITIALIZED_E:
            return;

        case IDENTITY_E:
            a03 = x;
            a13 = y;
            a23 = z;
            break;

        case TRANSLATE_E:
            a03 = m[0][3] + x;
            a13 = m[1][3] + y;
            a23 = m[2][3] + z;
            break;

        case UPPER_3X3_E:
            a03 = x * m[0][0] + y * m[0][1] + z * m[0][2];
            a13 = x * m[1][0] + y * m[1][1] + z * m[1][2];
            a23 = x * m[2][0] + y * m[2][1] + z * m[2][2];
            break;

        case AFFINE_E:
            a03 = x * m[0][0] + y * m[0][1] + z * m[0][2] + m[0][3];
            a13 = x * m[1][0] + y * m[1][1] + z * m[1][2] + m[1][3];
            a23 = x * m[2][0] + y * m[2][1] + z * m[2][2] + m[2][3];
            break;

        default:
            Assert((form == PERSPECTIVE_E) && "Unrecognized matrix type.");
            a03 = x * m[0][0] + y * m[0][1] + z * m[0][2] + m[0][3];
            a13 = x * m[1][0] + y * m[1][1] + z * m[1][2] + m[1][3];
            a23 = x * m[2][0] + y * m[2][1] + z * m[2][2] + m[2][3];
            a33 = x * m[3][0] + y * m[3][1] + z * m[3][2] + m[3][3];
            break;
    }

    m[0][3] = a03;
    m[1][3] = a13;
    m[2][3] = a23;
    m[3][3] = a33;

    form = MultiplyReturnTypes [form][TRANSLATE_E];
}



/*****************************************************************************
This function post-concatenates a scaling matrix to the Apu4x4Matrix.
*****************************************************************************/

void Apu4x4Matrix::PostScale (Real x, Real y, Real z)
{
    if ((x == 1) && (y == 1) && (z == 1)) return;

    Assert((form != UNINITIALIZED_E) && "Scaling of uninitialized matrix.");

    switch (form)
    {
        case UNINITIALIZED_E:
            return;

        case IDENTITY_E:
        case TRANSLATE_E:
            m[0][0] = x;
            m[1][1] = y;
            m[2][2] = z;
            break;

        case AFFINE_E:
        case UPPER_3X3_E:
            m[0][0] *= x;   m[0][1] *= y;   m[0][2] *= z;
            m[1][0] *= x;   m[1][1] *= y;   m[1][2] *= z;
            m[2][0] *= x;   m[2][1] *= y;   m[2][2] *= z;
            break;

        default:
            Assert((form == PERSPECTIVE_E) && "Unrecognized matrix type.");
            m[0][0] *= x;   m[0][1] *= y;   m[0][2] *= z;
            m[1][0] *= x;   m[1][1] *= y;   m[1][2] *= z;
            m[2][0] *= x;   m[2][1] *= y;   m[2][2] *= z;
            m[3][0] *= x;   m[3][1] *= y;   m[3][2] *= z;
            break;
    }

    form = MultiplyReturnTypes [form][UPPER_3X3_E];
    is_rigid = 0;
}



/*****************************************************************************
This function takes an Apu4x4Matrix, multiplies the given vector, and then
places the result in the 'result' parameter.  Note that the vector is
treated as a point, in that the translational component is taken into
account.
*****************************************************************************/

void Apu4x4Matrix::ApplyAsPoint(const ApuVector3& xv, ApuVector3& result) const
{
    Real x = xv.xyz[0];
    Real y = xv.xyz[1];
    Real z = xv.xyz[2];
    Real w;

    switch (form)
    {
        case UNINITIALIZED_E:
            result = apuZero3;
            break;

        case IDENTITY_E:
            result = xv;
            break;

        case TRANSLATE_E:
            result.xyz[0] = x + m[0][3];
            result.xyz[1] = y + m[1][3];
            result.xyz[2] = z + m[2][3];
            break;

        case UPPER_3X3_E:
            result.xyz[0] = m[0][0] * x + m[0][1] * y + m[0][2] * z;
            result.xyz[1] = m[1][0] * x + m[1][1] * y + m[1][2] * z;
            result.xyz[2] = m[2][0] * x + m[2][1] * y + m[2][2] * z;
            break;

        case AFFINE_E:
            result.xyz[0] = m[0][0] * x + m[0][1] * y + m[0][2] * z + m[0][3];
            result.xyz[1] = m[1][0] * x + m[1][1] * y + m[1][2] * z + m[1][3];
            result.xyz[2] = m[2][0] * x + m[2][1] * y + m[2][2] * z + m[2][3];
            break;

        case PERSPECTIVE_E:
            result.xyz[0] = m[0][0] * x + m[0][1] * y + m[0][2] * z + m[0][3];
            result.xyz[1] = m[1][0] * x + m[1][1] * y + m[1][2] * z + m[1][3];
            result.xyz[2] = m[2][0] * x + m[2][1] * y + m[2][2] * z + m[2][3];
            w = m[3][0] * x + m[3][1] * y + m[3][2] * z + m[3][3];
            result.xyz[0] /= w;
            result.xyz[1] /= w;
            result.xyz[2] /= w;
            break;

        default:
            // raise exception
            ;
    }
}


/*****************************************************************************
This function takes an Apu4x4Matrix, multiplies the given vector, and then
places the result in the 'result' parameter.  Note that the vector is
treated as a vector in an affine space, in that the translational
component is ignored.
*****************************************************************************/

void Apu4x4Matrix::ApplyAsVector(const ApuVector3& xv,
                                 ApuVector3& result) const
{
    Real x = xv.xyz[0];
    Real y = xv.xyz[1];
    Real z = xv.xyz[2];
    Real w;

    switch (form)
    {
        case UNINITIALIZED_E:
            result = apuZero3;
            break;

        // Ignore translational component.
        case IDENTITY_E:
        case TRANSLATE_E:
            result = xv;
            break;

        case UPPER_3X3_E:
        case AFFINE_E:
            result.xyz[0] = m[0][0] * x + m[0][1] * y + m[0][2] * z;
            result.xyz[1] = m[1][0] * x + m[1][1] * y + m[1][2] * z;
            result.xyz[2] = m[2][0] * x + m[2][1] * y + m[2][2] * z;
            break;

        case PERSPECTIVE_E:
            result.xyz[0] = m[0][0] * x + m[0][1] * y + m[0][2] * z;
            result.xyz[1] = m[1][0] * x + m[1][1] * y + m[1][2] * z;
            result.xyz[2] = m[2][0] * x + m[2][1] * y + m[2][2] * z;
            w = m[3][0] * x + m[3][1] * y + m[3][2] * z;
            result.xyz[0] /= w;
            result.xyz[1] /= w;
            result.xyz[2] /= w;
            break;

        default:
            // raise exception
            ;
    }
}



/*****************************************************************************
This method transforms a plane with the 4x4 matrix.  
*****************************************************************************/

bool Apu4x4Matrix::TransformPlane (
    Real A, Real B, Real C, Real D,   // Plane Equation Parameters
    Real result[4])                   // Resulting Plane Parameters
    const
{
    bool ok = true;
    
    Apu4x4Matrix inverse;

    switch (form)
    {
        case UNINITIALIZED_E:
            Assert (!"Attempt to transform plane by uninitialized matrix.");
            break;

        case IDENTITY_E:
            result[0] = A;
            result[1] = B;
            result[2] = C;
            result[3] = D;
            break;

        case TRANSLATE_E:
            result[0] = A;
            result[1] = B;
            result[2] = C;
            result[3] = D - A*m[0][3] - B*m[1][3] - C*m[2][3];
            break;

        case UPPER_3X3_E:
            ok = ApuInverse (*this, inverse);
            result[0] = A*inverse.m[0][0] + B*inverse.m[1][0] + C*inverse.m[2][0];
            result[1] = A*inverse.m[0][1] + B*inverse.m[1][1] + C*inverse.m[2][1];
            result[2] = A*inverse.m[0][2] + B*inverse.m[1][2] + C*inverse.m[2][2];
            result[3] = D;
            break;

        case AFFINE_E:
            ok = ApuInverse (*this, inverse);
            result[0] = A*inverse.m[0][0] + B*inverse.m[1][0] + C*inverse.m[2][0];
            result[1] = A*inverse.m[0][1] + B*inverse.m[1][1] + C*inverse.m[2][1];
            result[2] = A*inverse.m[0][2] + B*inverse.m[1][2] + C*inverse.m[2][2];
            result[3] = A*inverse.m[0][3] + B*inverse.m[1][3] + C*inverse.m[2][3] + D;
            break;

        case PERSPECTIVE_E:
            ok = ApuInverse (*this, inverse);
            result[0] = A*inverse.m[0][0] + B*inverse.m[1][0] + C*inverse.m[2][0] + D*inverse.m[3][0];
            result[1] = A*inverse.m[0][1] + B*inverse.m[1][1] + C*inverse.m[2][1] + D*inverse.m[3][1];
            result[2] = A*inverse.m[0][2] + B*inverse.m[1][2] + C*inverse.m[2][2] + D*inverse.m[3][2];
            result[3] = A*inverse.m[0][3] + B*inverse.m[1][3] + C*inverse.m[2][3] + D;
            break;
    }

    return ok;
}



/*****************************************************************************
This method returns the full determinant of the matrix.
*****************************************************************************/

Real Apu4x4Matrix::Determinant (void) const
{
    Real result;

    switch (form)
    {
        default:
        case UNINITIALIZED_E:
        {   AssertStr (0, "Determinant called on uninitialized matrix.");
            result = 0;
            break;
        }

        case IDENTITY_E:
        case TRANSLATE_E:
        {   result = 1;
            break;
        }

        case UPPER_3X3_E:
        case AFFINE_E:
        {   result = m[0][0] * (m[1][1]*m[2][2] - m[2][1]*m[1][2])
                   - m[1][0] * (m[0][1]*m[2][2] - m[2][1]*m[0][2])
                   + m[2][0] * (m[0][1]*m[1][2] - m[1][1]*m[0][2]);
            break;
        }

        case PERSPECTIVE_E:
        {
            // Aliases for readability (optimized out)

            const Real
                &m00=m[0][0],  &m01=m[0][1],  &m02=m[0][2],  &m03=m[0][3],
                &m10=m[1][0],  &m11=m[1][1],  &m12=m[1][2],  &m13=m[1][3],
                &m20=m[2][0],  &m21=m[2][1],  &m22=m[2][2],  &m23=m[2][3],
                &m30=m[3][0],  &m31=m[3][1],  &m32=m[3][2],  &m33=m[3][3];

            result = (m00*m11 - m10*m01) * (m22*m33 - m32*m23)
                   + (m20*m01 - m00*m21) * (m12*m33 - m32*m13)
                   + (m00*m31 - m30*m01) * (m12*m23 - m22*m13)
                   + (m10*m21 - m20*m11) * (m02*m33 - m32*m03)
                   + (m30*m11 - m10*m31) * (m02*m23 - m22*m03)
                   + (m20*m31 - m30*m21) * (m02*m13 - m12*m03);

            break;
        }
    }

    return result;
}



/*****************************************************************************
This routine returns true if the matrix is orthogonal (if all three basis
vectors are perpendicular to each other).
*****************************************************************************/

bool Apu4x4Matrix::Orthogonal (void) const
{
    const Real e = 1e-10;

    // X.Y =~ 0?

    if (fabs(m[0][0]*m[0][1] + m[1][0]*m[1][1] + m[2][0]*m[2][1]) > e)
        return false;

    // X.Z =~ 0?

    if (fabs(m[0][0]*m[0][2] + m[1][0]*m[1][2] + m[2][0]*m[2][2]) > e)
        return false;

    // Y.Z =~ 0?

    if (fabs(m[0][1]*m[0][2] + m[1][1]*m[1][2] + m[2][1]*m[2][2]) > e)
        return false;

    return true;
}



/*****************************************************************************
This function generates an Apu4x4Matrix that represents the specified
translation.
*****************************************************************************/

void ApuTranslate (
    Real          x_delta,
    Real          y_delta,
    Real          z_delta,
    bool          pixelMode,
    Apu4x4Matrix& result)
{
    result      = apuIdentityMatrix;
    result.form = Apu4x4Matrix::TRANSLATE_E;

    result.m[0][3] = x_delta;
    result.m[1][3] = y_delta;
    result.m[2][3] = z_delta;

    result.pixelMode = pixelMode;
}



/*****************************************************************************
This function generates an Apu4x4Matrix that represents the given scaling.
*****************************************************************************/

void ApuScale (
    Real          x_scale,
    Real          y_scale,
    Real          z_scale,
    Apu4x4Matrix& result)
{
    result = apuIdentityMatrix;

    if ((x_scale != 1) || (y_scale != 1) || (z_scale != 1))
    {   result.form = Apu4x4Matrix::UPPER_3X3_E;
        result.is_rigid = 0;
        result.m[0][0] = x_scale;
        result.m[1][1] = y_scale;
        result.m[2][2] = z_scale;
    }
}



/*****************************************************************************
This function loads the given result matrix with a general rotation.  The
rotation is counter-clockwise as you look from 'av' to the origin.
*****************************************************************************/

void ApuRotate (
    Real angle,                 // Angle of Rotation (Radians)
    Real Ax, Real Ay, Real Az,  // Coordinates of Axis of Rotation
    Apu4x4Matrix &result)       // Result Matrix
{
    result = apuIdentityMatrix;
    
    Real length = sqrt (Ax*Ax + Ay*Ay + Az*Az);

    // If length of rotation axis == 0, then just return identity. 

    if (length > SINGULARITY_THRESHOLD) {
        
        result.form     = Apu4x4Matrix::UPPER_3X3_E;
        result.is_rigid = 1;

        // Normalize the axis of rotation.
        Ax /= length;
        Ay /= length;
        Az /= length;

        Real sine   = sin (angle);
        Real cosine = cos (angle);

        Real ab = Ax * Ay * (1 - cosine);
        Real bc = Ay * Az * (1 - cosine);
        Real ca = Az * Ax * (1 - cosine);

        Real t = Ax * Ax;

        result.m[0][0] = t + cosine * (1 - t);
        result.m[1][2] = bc - Ax * sine;
        result.m[2][1] = bc + Ax * sine;

        t = Ay * Ay;
        result.m[1][1] = t + cosine * (1 - t);
        result.m[0][2] = ca + Ay * sine;
        result.m[2][0] = ca - Ay * sine;

        t = Az * Az;
        result.m[2][2] = t + cosine * (1 - t);
        result.m[0][1] = ab - Az * sine;
        result.m[1][0] = ab + Az * sine;

    }
}



/*****************************************************************************
The following three functions generate rotation transformations for the X, Y,
and Z axes.
*****************************************************************************/

void ApuRotateX (
    Real          angle,    // Angle of Rotation (Radians)
    Apu4x4Matrix &result)   // Resulting 4x4 Matrix
{
    result          = apuIdentityMatrix;
    result.form     = Apu4x4Matrix::UPPER_3X3_E;
    result.is_rigid = 1;

    result.m[1][1] = result.m[2][2] = cos (angle);
    result.m[1][2] = - (result.m[2][1] = sin (angle));
}


void ApuRotateY (
    Real          angle,    // Angle of Rotation (Radians)
    Apu4x4Matrix &result)   // Resulting 4x4 Matrix
{
    result          = apuIdentityMatrix;
    result.form     = Apu4x4Matrix::UPPER_3X3_E;
    result.is_rigid = 1;

    result.m[0][0] = result.m[2][2] = cos (angle);
    result.m[2][0] = - (result.m[0][2] = sin (angle));
}


void ApuRotateZ (
    Real          angle,    // Angle of Rotation (Radians)
    Apu4x4Matrix &result)   // Resulting 4x4 Matrix
{
    result          = apuIdentityMatrix;
    result.form     = Apu4x4Matrix::UPPER_3X3_E;
    result.is_rigid = 1;

    result.m[0][0] = result.m[1][1] = cos (angle);
    result.m[0][1] = - (result.m[1][0] = sin (angle));
}



/*****************************************************************************
This function loads 'result' with the shearing matrix defined by the six
values passed.
*****************************************************************************/

void ApuShear (
    Real a, Real b,        // Shear X Axis
    Real c, Real d,        // Shear Y Axis
    Real e, Real f,        // Shear Z Axis
    Apu4x4Matrix &result)
{
    result          = apuIdentityMatrix;
    result.form     = Apu4x4Matrix::UPPER_3X3_E;
    result.is_rigid = 0;

    // [ 1  c  e  0 ]
    // [ a  1  f  0 ]
    // [ b  d  1  0 ]
    // [ 0  0  0  1 ]

    result.m[1][0] = a;
    result.m[2][0] = b;

    result.m[0][1] = c;
    result.m[2][1] = d;

    result.m[0][2] = e;
    result.m[1][2] = f;
}



/*****************************************************************************
This function multiplies two Apu4x4Matrix values together and stores the
result into 'result'.
*****************************************************************************/

void ApuMultiply (
    const Apu4x4Matrix& a,
    const Apu4x4Matrix& b,
          Apu4x4Matrix& result)
{
    // Case 1: multiply into B

    if (&result == &b)
    {
        Apu4x4Matrix tmp = b;
        ApuMultiply(a, b, tmp);
        result = tmp;
    }

    // Case 2: multiply into A

    else if (&result == &a)
    {
        Apu4x4Matrix tmp = a;
        ApuMultiply(a, b, tmp);
        result = tmp;
    }

    // Case 3 & 4: Identity transformations

    else if (a.form <= Apu4x4Matrix::IDENTITY_E)
    {
        result = b;
    }
    else if (b.form <= Apu4x4Matrix::IDENTITY_E)
    {
        result = a;
    }

    // Case 5: Translation

    else if (b.form == Apu4x4Matrix::TRANSLATE_E)
    {
        result = a;
        result.PostTranslate(b.m[0][3], b.m[1][3], b.m[2][3]);
    }

    // Case 6: Affine transformation

    else if (   (a.form < Apu4x4Matrix::PERSPECTIVE_E)
             && (b.form < Apu4x4Matrix::PERSPECTIVE_E))
    {
        Real s;

        for (int i = 0; i < 3; i++)
        {
            for (int j = 0; j < 4; j++)
            {
                s = a.m[i][0] * b.m[0][j];
                s += a.m[i][1] * b.m[1][j];
                s += a.m[i][2] * b.m[2][j];
                result.m[i][j] = s;
            }
        }
        result.m[0][3] += a.m[0][3];
        result.m[1][3] += a.m[1][3];
        result.m[2][3] += a.m[2][3];

        result.m[3][0] = 0.0;
        result.m[3][1] = 0.0;
        result.m[3][2] = 0.0;
        result.m[3][3] = 1.0;
        result.form = Apu4x4Matrix::MultiplyReturnTypes[a.form][b.form];
        result.is_rigid = a.is_rigid && b.is_rigid;
    }

    // Default case: fully general perspective transformation

    else
    {
        Real s;

        for (int i = 0; i < 4; i++)
        {
            for (int j = 0; j < 4; j++)
            {
                s = a.m[i][0] * b.m[0][j]
                  + a.m[i][1] * b.m[1][j]
                  + a.m[i][2] * b.m[2][j]
                  + a.m[i][3] * b.m[3][j];
                result.m[i][j] = s;
            }
        }
        result.is_rigid = a.is_rigid && b.is_rigid;
        result.form = Apu4x4Matrix::PERSPECTIVE_E;
    }
}



/*****************************************************************************
*****************************************************************************/

bool ApuInverse (const Apu4x4Matrix& m, Apu4x4Matrix& result)
{
    bool ok = true;
    if (m.form == Apu4x4Matrix::UNINITIALIZED_E)
    {
        result.form = Apu4x4Matrix::UNINITIALIZED_E;
    }
    else if (m.form == Apu4x4Matrix::IDENTITY_E)
    {
        result = apuIdentityMatrix;
    }
    else if (m.form == Apu4x4Matrix::TRANSLATE_E)
    {
        result = apuIdentityMatrix;
        result.m[0][3] = - m.m[0][3];
        result.m[1][3] = - m.m[1][3];
        result.m[2][3] = - m.m[2][3];
    }
    else if (m.form == Apu4x4Matrix::UPPER_3X3_E)
    {
        result = apuIdentityMatrix;
        if (m.is_rigid)
        {
            // special orthogonal: inverse is transpose
            ApuTranspose(m, result, 3);
        }
        else
        {
            // 3x3 inverse
            ok = inverse3x3(m, result);
        }
    }
    else
    {
        ok = inverse(&m, &result);
    }
    result.form = m.form;
    result.is_rigid = m.is_rigid;

    return ok;
}



/*****************************************************************************
*****************************************************************************/

void ApuTranspose (const Apu4x4Matrix& m, Apu4x4Matrix& result, int order)
{
    for (int i = 0; i < order; i++)
    {
        for (int j = 0; j < order; j++)
        {
            result.m[i][j] = m.m[j][i];
        }
    }
}



/*****************************************************************************
*****************************************************************************/

Real ApuDeterminant (const Apu4x4Matrix& m)
{
    return m.Determinant();
}

bool ApuIsSingular (const Apu4x4Matrix& m)
{
    // Calculate the 4x4 determinant.  If the determinant is zero, then the
    // inverse matrix is not unique.

    Real det = m.Determinant();

    return (fabs(det) < SINGULARITY_THRESHOLD);
}

/*****************************************************************************
Matrix Inversion, by Richard Carling, Graphics Gems I

NOTE:  Row reduction is faster in the 4x4 case.  If this becomes a noticeable
bottle neck during profiling, then change.
*****************************************************************************/


static bool
inverse3x3 (const Apu4x4Matrix& in, Apu4x4Matrix& out)
{
    bool ok;
    
    Real a00 = in.m[0][0];
    Real a01 = in.m[0][1];
    Real a02 = in.m[0][2];
    Real a10 = in.m[1][0];
    Real a11 = in.m[1][1];
    Real a12 = in.m[1][2];
    Real a20 = in.m[2][0];
    Real a21 = in.m[2][1];
    Real a22 = in.m[2][2];
    Real det = det3x3 (a00, a01, a02, a10, a11, a12, a20, a21, a22);

    if (fabs(det) < SINGULARITY_THRESHOLD) {

        out = apuIdentityMatrix;
        DASetLastError(E_FAIL, IDS_ERR_INVERT_SINGULAR_MATRIX);
        ok = false;

    } else {

        out.m[0][0] = (- (a12 * a21) + a11 * a22) / det;
        out.m[0][1] = (a02 * a21 - a01 * a22) / det;
        out.m[0][2] = (- (a02 * a11) + a01 * a12) / det;
        out.m[1][0] = (a12 * a20 - a10 * a22) / det;
        out.m[1][1] = (- (a02 * a20) + a00 * a22) / det;
        out.m[1][2] = (a02 * a10 - a00 * a12) / det;
        out.m[2][0] = (- (a11 * a20) + a10 * a21) / det;
        out.m[2][1] = (a01 * a20 - a00 * a21) / det;
        out.m[2][2] = (- (a01 * a10) + a00 * a11) / det;
        ok = true;
    }

    return ok;
}



/*****************************************************************************
inverse (original_matrix, inverse_matrix)

Calculate the inverse of a 4x4 matrix

         -1     1
        A  = -------- adjoint(A)
              det(A)
*****************************************************************************/

static bool
inverse (const Apu4x4Matrix *in, Apu4x4Matrix *out)
{
    int  i, j;
    Real det;
    bool ok = true;
    
    /* calculate the adjoint matrix */

    adjoint (in, out);

    // Calculate the 4x4 determinant.  If the determinant is zero, then the
    // inverse matrix is not unique.

    det = in->Determinant();

    if (fabs(det) < SINGULARITY_THRESHOLD) {
        *out = apuIdentityMatrix;
        DASetLastError(E_FAIL, IDS_ERR_INVERT_SINGULAR_MATRIX);
        ok = false;
    }

    /* scale the adjoint matrix to get the inverse */

    for (i=0; i<4; i++)
        for(j=0; j<4; j++)
            out->m[i][j] = out->m[i][j] / det;

    return ok;
}



/*****************************************************************************
adjoint (original_matrix, inverse_matrix)

Calculate the adjoint of a 4x4 matrix

Let  a   denote the minor determinant of matrix A obtained by deleting the ith
      ij

row and jth column from A.

                    i+j
     Let  b   = (-1)    a
           ij            ji

The matrix B = (b  ) is the adjoint of A.
                 ij
*****************************************************************************/

static void adjoint (const Apu4x4Matrix *in, Apu4x4Matrix *out)
{
    Real a1, a2, a3, a4, b1, b2, b3, b4;
    Real c1, c2, c3, c4, d1, d2, d3, d4;

    // Assign to individual variable names to aid selecting correct values.

    a1 = in->m[0][0]; b1 = in->m[0][1];
    c1 = in->m[0][2]; d1 = in->m[0][3];

    a2 = in->m[1][0]; b2 = in->m[1][1];
    c2 = in->m[1][2]; d2 = in->m[1][3];

    a3 = in->m[2][0]; b3 = in->m[2][1];
    c3 = in->m[2][2]; d3 = in->m[2][3];

    a4 = in->m[3][0]; b4 = in->m[3][1];
    c4 = in->m[3][2]; d4 = in->m[3][3];


    // Row column labeling reversed since we transpose rows & columns.

    out->m[0][0]  =   det3x3(b2, b3, b4, c2, c3, c4, d2, d3, d4);
    out->m[1][0]  = - det3x3(a2, a3, a4, c2, c3, c4, d2, d3, d4);
    out->m[2][0]  =   det3x3(a2, a3, a4, b2, b3, b4, d2, d3, d4);
    out->m[3][0]  = - det3x3(a2, a3, a4, b2, b3, b4, c2, c3, c4);

    out->m[0][1]  = - det3x3(b1, b3, b4, c1, c3, c4, d1, d3, d4);
    out->m[1][1]  =   det3x3(a1, a3, a4, c1, c3, c4, d1, d3, d4);
    out->m[2][1]  = - det3x3(a1, a3, a4, b1, b3, b4, d1, d3, d4);
    out->m[3][1]  =   det3x3(a1, a3, a4, b1, b3, b4, c1, c3, c4);

    out->m[0][2]  =   det3x3(b1, b2, b4, c1, c2, c4, d1, d2, d4);
    out->m[1][2]  = - det3x3(a1, a2, a4, c1, c2, c4, d1, d2, d4);
    out->m[2][2]  =   det3x3(a1, a2, a4, b1, b2, b4, d1, d2, d4);
    out->m[3][2]  = - det3x3(a1, a2, a4, b1, b2, b4, c1, c2, c4);

    out->m[0][3]  = - det3x3(b1, b2, b3, c1, c2, c3, d1, d2, d3);
    out->m[1][3]  =   det3x3(a1, a2, a3, c1, c2, c3, d1, d2, d3);
    out->m[2][3]  = - det3x3(a1, a2, a3, b1, b2, b3, d1, d2, d3);
    out->m[3][3]  =   det3x3(a1, a2, a3, b1, b2, b3, c1, c2, c3);
}



/*****************************************************************************
Real = det3x3( a1, a2, a3, b1, b2, b3, c1, c2, c3)

Calculate the determinant of a 3x3 matrix in the form

     | a1,  b1,  c1 |
     | a2,  b2,  c2 |
     | a3,  b3,  c3 |
*****************************************************************************/

static Real det3x3 (
    Real a1, Real a2, Real a3,
    Real b1, Real b2, Real b3,
    Real c1, Real c2, Real c3)
{
    Real ans;

    ans = a1 * (b2*c3 - b3*c2)
        - b1 * (a2*c3 - a3*c2)
        + c1 * (a2*b3 - a3*b2);

    return ans;
}



/*****************************************************************************
This routine examines the 4x4 matrix to ensure that it's valid (useful for
debug assertions.
*****************************************************************************/

#if _DEBUG

bool Valid (const Apu4x4Matrix& matrix)
{
    // Do an if-test rather than a direct return so we can set a breakpoint
    // on failure.

    if ((matrix.form != Apu4x4Matrix::UNINITIALIZED_E)
        && _finite (matrix.m[0][0])
        && _finite (matrix.m[0][1])
        && _finite (matrix.m[0][2])
        && _finite (matrix.m[0][3])
        && _finite (matrix.m[1][0])
        && _finite (matrix.m[1][1])
        && _finite (matrix.m[1][2])
        && _finite (matrix.m[1][3])
        && _finite (matrix.m[2][0])
        && _finite (matrix.m[2][1])
        && _finite (matrix.m[2][2])
        && _finite (matrix.m[2][3])
        && _finite (matrix.m[3][0])
        && _finite (matrix.m[3][1])
        && _finite (matrix.m[3][2])
        && _finite (matrix.m[3][3]))

    {   return true;
    }
    else
    {   return false;
    }
}


void CheckMatrix (const Apu4x4Matrix& matrix, char *file, int line)
{
    if (!Valid(matrix))
    {
        TraceTag ((tagWarning,
            "!!! Invalid matrix detected at %s[%d].", file, line));

        if (IsTagEnabled(tagMathMatrixInvalid))
        {   F3DebugBreak();
        }
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\values\misc\path2.cpp ===
/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

    Path2 types and accumulation context.

*******************************************************************************/

#include "headers.h"
#include "privinc/path2i.h"
#include "privinc/vec2i.h"
#include "privinc/xform2i.h"
#include "privinc/except.h"
#include "backend/values.h"
#include "privinc/dddevice.h"
#include "privinc/linei.h"
#include "privinc/polygon.h"
#include "privinc/texti.h"
#include "privinc/stlsubst.h"
#include "privinc/curves.h"
#include "privinc/DaGdi.h"
#include "privinc/d3dutil.h"
#include "privinc/tls.h"

// TODO: Note that all of this code is ripe for some media specific
// constant folding optimizations.  In particular, if concatenated
// paths don't change from frame to frame, there is a lot of work
// being repeated every frame.  Need to investigate pushing constant
// folding down further, and whether or not it would _really_ be
// worthwhile.



    // The following class is used when traversing a path hierarchy to find
    // the lengths of the component subpaths.

class PathInfo
{
  public:

    PathInfo (Path2 *path_, Transform2 *xf_, Real length_, Real *sublengths_)
    : path(path_), xform(xf_), length(length_), sublengths(sublengths_)
    {
    }

    PathInfo (void) : path(0), xform(0), length(0), sublengths(0) {}

    ~PathInfo (void)
    {   if (sublengths) DeallocateFromStore(sublengths);
    }

    Path2      *path;         // Pointer to Subpath
    Transform2 *xform;        // Modelling Transform
    Real        length;       // Length of Path
    Real       *sublengths;   // List of Subpath Lengths
};


    // This class accumulates context state for Path2 traversals.

class Path2Ctx
{
  public:
    Path2Ctx (HDC dc, Transform2 *initXform)
    :   _dc          (dc),
        _xf          (initXform),
        _daGdi       (NULL),
        _viewportPixWidth  (-1),
        _viewportPixHeight (-1),
        _viewportRes       (-1),
        _tailPt      (0,0),
        _totalLength (0)
    {
    }

    Path2Ctx (DAGDI *daGdi,
              Transform2 *initXform,
              DWORD w,
              DWORD h,
              Real res)
    :   _dc          (NULL),
        _xf          (initXform),
        _daGdi       (daGdi),
        _viewportPixWidth(w),
        _viewportPixHeight(h),
        _viewportRes(res),
        _tailPt      (0,0),
        _totalLength (0),
        _isClosed(false)
    {
    }

    ~Path2Ctx (void)
    {
        for (vector<PathInfo*>::iterator i = _paths.begin();
             i != _paths.end(); i++) {
            delete (*i);
        }

        // Destructor of vector will do it.
        //_paths.erase (_paths.begin(), _paths.end());
    }

    void        SetTransform(Transform2 *xf) { _xf = xf; }
    Transform2 *GetTransform() { return _xf; }

    DWORD GetViewportPixelWidth() {
        Assert(_viewportPixWidth > 0);
        return _viewportPixWidth;
    }
    DWORD GetViewportPixelHeight() {
        Assert(_viewportPixHeight > 0);
        return _viewportPixHeight;
    }
    Real GetViewportResolution() {
        Assert(_viewportRes > 0);
        return _viewportRes;
    }

    void Closed() { _isClosed = true; }
    bool isClosed() { return _isClosed; }
    
    void GetTailPt(Point2Value& pt) { pt = _tailPt; }
    void SetTailPt(Point2Value& pt) { _tailPt = pt; }

    HDC  GetDC() { return _dc; }

    DAGDI *GetDaGdi() { return _daGdi; }
    
    // This function takes in the information for a particular subpath and adds
    // it to the list of subpath data.  This function is called during the
    // GatherLengths() traversal.

    void SubmitPathInfo (
        Path2 *path, Real length, Real *subLengths)
    {
        PathInfo *info = NEW PathInfo (path, _xf, length, subLengths);
        VECTOR_PUSH_BACK_PTR (_paths, info);
        _totalLength += length;
    }

    // Sample the path chain at the given parameter t.  This function is only
    // valid following a GatherLengths() traversal.  The parameter t is in
    // the range [0,1].

    Point2Value *SamplePath (Real t)
    {
        Real pathdist = t * _totalLength;
        vector<PathInfo*>::iterator pathinfo;

        for (pathinfo=_paths.begin();  pathinfo != _paths.end();  ++pathinfo)
        {
            if (pathdist <= (*pathinfo)->length)
                return (*pathinfo)->path->Sample (**pathinfo, pathdist);

            pathdist -= (*pathinfo)->length;
        }

        // Should have hit one of the subpaths by now; assume roundoff error
        // and get the maximum point of the last path.

        --pathinfo;
        return (*pathinfo)->path->Sample (**pathinfo, (*pathinfo)->length);
    }

    // The following flag is true if we haven't yet processed (or accumulated)
    // the first polyline or polyBezier in a series of one or more.

    Bool _newSeries;

  protected:
    Transform2 *_xf;
    HDC         _dc;
    Point2Value _tailPt;
    Real        _totalLength;
    DAGDI      *_daGdi;
    DWORD       _viewportPixWidth;
    DWORD       _viewportPixHeight;
    Real        _viewportRes;
    bool        _isClosed;

    vector<PathInfo*> _paths;    // List of Subpath Info
};

/*****************************************************************************
Helper functions for code factoring
*****************************************************************************/

const Bbox2 PolygonalPathBbox(int numPts, Point2Value **pts)
{
    Bbox2 bbox;

    for (int i=0;  i < numPts;  ++i)
        bbox.Augment (Demote(*pts[i]));

    return bbox;
}

const Bbox2 PolygonalPathBbox(int numPts, Point2 *pts)
{
    Bbox2 bbox;

    for (int i=0;  i < numPts;  ++i)
        bbox.Augment ( pts[i] );

    return bbox;
}


bool PolygonalTrivialReject( Point2Value *pt,
                             LineStyle *style,
                             const Bbox2 &naiveBox,
                             Transform2 *imgXf )
{
    // TODO: Note, that this won't work properly for sharply mitered
    // lines, where the angle is very acute, and the miter extends
    // very far from the naive bounding box
    
    // XXX: for now, join and end styles not
    // xxx: considered for picking: we assume rounded
    // xxx: ends
    if ( (!pt) ||
         (style->Detail()) ) {
        return true;
    } else {
        // COPY! don't side effect naiveBox
        Bbox2 box = naiveBox;

        Real aug = style->Width(); // way liberal.  could be 1/2 width

        aug *= 0.6;

        // TODO: Figure out the right thing for the width of the
        // line.  Seems like the width is in the local coordinate
        // space, but it's doesn't look like it (try the bezier pick
        // with the visual trace tag turned on).  So this is over
        // liberal, but it's better than no trivial reject.
        /*
        DirectDrawImageDevice *dev =
            GetImageRendererFromViewport( GetCurrentViewport() );
        if( dev ) {
            Real xs, ys;
            // imgXf is the width transform
            dev->DecomposeMatrix( imgXf, &xs, &ys, NULL );
            Real scale = (xs + ys) * 0.5;
            aug *= scale;
        }
        */
        
        box.min.x -= aug;
        box.min.y -= aug;
        box.max.x += aug;
        box.max.y += aug;
        
        if( !box.Contains( pt->x, pt->y )) {
            return true;
        }
    }
    
    return false;
}

/*****************************************************************************
Accumulate the paths into the DC.
*****************************************************************************/

void Path2::AccumPathIntoDC (
    HDC         dc,
    Transform2 *initXf,     // Initial Transform
    bool        forRegion)  // True if for Filled Region
{
    Path2Ctx ctx(dc, initXf);

    if(!BeginPath(dc)) {
        TraceTag((tagError, "Couldn't begin path in AccumPathIntoDC"));
    }

    ctx._newSeries = true;

    Accumulate (ctx);

    // This works around a bug in GDI that causes a bluescreen on some
    // platforms.  If we're accumulating this path for a filled region
    // then we close the figure before calling EndPath.

    if (forRegion)
        CloseFigure (dc);

    if (!EndPath(dc)) {
        TraceTag((tagError, "Couldn't end path in AccumPathIntoDC"));
    }
}

void Path2::RenderToDaGdi (DAGDI *daGdi,
                           Transform2 *initXform,
                           DWORD w,
                           DWORD h,
                           Real res,                       
                           bool forRegion)
{
    Path2Ctx ctx(daGdi, initXform, w, h, res);
    Accumulate(ctx);
}

AxAValue
Path2::ExtendedAttrib(char *attrib, VARIANT& val)
{
    return this;
}


/*****************************************************************************
A transformed 2D path.
*****************************************************************************/

TransformedPath2::TransformedPath2(Transform2 *xf, Path2 *p) :
   _xf(xf), _p(p)
{
}

Point2Value *
TransformedPath2::FirstPoint() {
    //
    // Just take the first point of the underlying path, and
    // transform it.
    //
    return TransformPoint2Value(_xf, _p->FirstPoint());
}

Point2Value *
TransformedPath2::LastPoint() {
    //
    // Just take the last point of the underlying path, and
    // transform it.
    //
    return TransformPoint2Value(_xf, _p->LastPoint());
}

// TODO: suspect this can be used to factor out some more render
// functions in the render layer...
class XformPusher {
  public:
    XformPusher(Path2Ctx& ctx, Transform2 *xf)
    : _ctx(ctx), _oldXf(ctx.GetTransform())
    { _ctx.SetTransform(TimesTransform2Transform2(_oldXf, xf)); }
    ~XformPusher() { _ctx.SetTransform(_oldXf); }
  private:
    Path2Ctx& _ctx;
    Transform2 *_oldXf;
};

void
TransformedPath2::GatherLengths (Path2Ctx &context)
{
    XformPusher xp (context, _xf);
    _p->GatherLengths (context);
}

Point2Value *
TransformedPath2::Sample (PathInfo &pathinfo, Real distance)
{
    Assert (!"Who's calling TransformPath2::Sample()?");
    return origin2;
}

// Standard push, accumulate, process, and pop...
void
TransformedPath2::Accumulate(Path2Ctx& ctx)
{
    XformPusher xp(ctx, _xf);
    _p->Accumulate(ctx);
}

// Just apply the transform...
Bool
TransformedPath2::ExtractAsSingleContour(Transform2 *initXform,
                                         int *numPts,            
                                         POINT **gdiPts,          
                                         Bool *isPolyline)
{

    return _p->ExtractAsSingleContour(
        TimesTransform2Transform2(initXform, _xf),
        numPts,
        gdiPts,
        isPolyline);
}

const Bbox2
TransformedPath2::BoundingBox (void)
{
    return TransformBbox2 (_xf, _p->BoundingBox());
}

#if BOUNDINGBOX_TIGHTER
const Bbox2
TransformedPath2::BoundingBoxTighter (Bbox2Ctx &bbctx)
{
    Bbox2Ctx bbctxAccum(bbctx, _xf);
    return _p->BoundingBoxTighter(bbctxAccum);
}
#endif  // BOUNDINGBOX_TIGHTER

Bool
TransformedPath2::DetectHit(PointIntersectCtx& ctx, LineStyle *style)
{
    Transform2 *stashedXf = ctx.GetTransform();
    ctx.SetTransform( TimesTransform2Transform2(stashedXf, _xf) );
    Bool result = _p->DetectHit(ctx, style);
    ctx.SetTransform(stashedXf);
    return result;
}

void
TransformedPath2::DoKids(GCFuncObj proc)
{
    (*proc)(_xf);
    (*proc)(_p);
}

Bool
TransformedPath2::IsClosed()
{
    return _p->IsClosed();
}


Path2 *
TransformPath2(Transform2 *xf, Path2 *p)
{
    if (xf == identityTransform2) {
        
        return p;
        
    } else {

        // Collapse underlying transforms if possible. 

        TransformedPath2 *underlyingXfdPath =
            p->IsTransformedPath();

        Path2 *pathToUse;
        Transform2 *xfToUse;

        if (underlyingXfdPath) {
            
            pathToUse = underlyingXfdPath->GetPath();
            xfToUse =
                TimesTransform2Transform2(xf,
                                          underlyingXfdPath->GetXf());
            
        } else {
            
            pathToUse = p;
            xfToUse = xf;
            
        }
        
        return NEW TransformedPath2(xfToUse, pathToUse);
    }
}


/*****************************************************************************
The BoundingBoxPath method takes a LineStyle, but this is inappropriate here,
since the linestyle is in image coordinates, while the path components are in
some unknown modeling coordinates.  In addition, some paths are used for
motion, rather than drawing.  Hence, we ignore the LineStyle here and just get
the pure bbox of the path.
*****************************************************************************/

Bbox2Value *BoundingBoxPath (LineStyle *style, Path2 *p)
{
    return Promote(p->BoundingBox());
}


Image *
DrawPath(LineStyle *border, Path2 *p) 
{
    return LineImageConstructor(border, p);
}

Image *
PathFill(LineStyle *border, Image *fill, Path2 *p) 
{
    Image *fillImg,*borderImg;
    fillImg = ClipImage(RegionFromPath(p), fill);
    borderImg = LineImageConstructor(border, p);
    return Overlay(borderImg, fillImg);    
}


/*****************************************************************************
This class concatentates two path objects.
*****************************************************************************/

class ConcatenatedPath2 : public Path2
{
  public:
    ConcatenatedPath2(Path2 *p1, Path2 *p2) {

        _p1 = p1;
        //
        // Pre transform the second path to fit the first
        //
        Transform2 *xlt = GetUntransformedConcatenationXlt(p1, p2);
        _p2 = TransformPath2(xlt, p2);
    }
    Point2Value *FirstPoint() {
        return _p1->FirstPoint();
    }

    Point2Value *LastPoint() {
        return _p2->LastPoint();
    }

    void GatherLengths (Path2Ctx &context)
    {   _p1->GatherLengths (context);
        _p2->GatherLengths (context);
    }

    Point2Value *Sample (PathInfo &pathinfo, Real distance)
    {   Assert (!"Who's calling ConcatenatedPath2::Sample()?");
        return origin2;
    }
    
    void Accumulate(Path2Ctx& ctx) {

        // Do first path in the concatenated path
        _p1->Accumulate(ctx);

        // Do second path.  This involves finding out the first point
        // of the second path, and transforming the second path to
        // align with the last point of the first, then processing this
        // transformed path.  We first need to transform the first
        // point into the world coordinate system being used to hold
        // the last point.

        //
        // Path1 is:  a--->b
        // Path2 is:  c--->d
        // xf_X is point 'X' with all the accumulated transforms
        //

        _p2->Accumulate(ctx);
    }

    const Bbox2 BoundingBox (void) {
        return UnionBbox2Bbox2 (_p1->BoundingBox(), _p2->BoundingBox());
    }

#if BOUNDINGBOX_TIGHTER
    const Bbox2 BoundingBoxTighter (Bbox2Ctx &bbctx) {
        return UnionBbox2Bbox2 (_p1->BoundingBoxTighter(bbctx), _p2->BoundingBoxTighter(bbctx));
    }
#endif  // BOUNDINGBOX_TIGHTER

    Bool DetectHit(PointIntersectCtx& ctx, LineStyle *style) {
        if (_p1->DetectHit(ctx, style)) {
            return TRUE;
        } else {
            return _p2->DetectHit(ctx, style);
        }
    }

    virtual void DoKids(GCFuncObj proc) {
        (*proc)(_p1);
        (*proc)(_p2);
    }

    virtual int Savings(CacheParam& p) { 
        return MAX(_p1->Savings(p), _p2->Savings(p)); 
    }

    virtual bool CanRenderNatively() {
        return _p1->CanRenderNatively() && _p2->CanRenderNatively();
    }


  protected:
    Path2      *_p1;
    Path2      *_p2;

    //
    // For the untransformed path (no xforms applied from parents in the path2 tree)
    // find the last pt of the first, and the first point of the second.
    // Create a translation based on the difference such that when applied to p2,
    // the first point of p2 coincides with last point of p1.
    //
    Transform2 *GetUntransformedConcatenationXlt(Path2 *p1, Path2 *p2) {
        Point2Value *b = p1->LastPoint();
        Point2Value *c = p2->FirstPoint();

        Real x, y;
        x = b->x - c->x;
        y = b->y - c->y;

        //
        // dependency: returned xform copies real values
        // not pointers!
        //
        return TranslateRR(x, y);
    }
};

Path2 *
ConcatenatePath2(Path2 *p1, Path2 *p2)
{
    return NEW ConcatenatedPath2(p1, p2);
}

Path2 *Concat2Array(AxAArray *paths) 
{
    int numPaths = paths->Length();
    if(numPaths < 2)
      RaiseException_UserError(E_FAIL, IDS_ERR_INVALIDARG);

    Path2 *finalPath = (Path2 *)(*paths)[numPaths-1];
    for(int i=numPaths-2; i>=0; i--)
        finalPath = ConcatenatePath2((Path2 *)(*paths)[i], finalPath);
    return finalPath;
}

/*****************************************************************************
This class closes a path.  The original path is saved in _p1, the
NEW path of a line segment from the last point to the first point of the
original path is saved in _p2.
*****************************************************************************/

class ClosedConcatenatedPath2 : public ConcatenatedPath2
{
  public:
    ClosedConcatenatedPath2(Path2 *p1, Path2 *p2) : ConcatenatedPath2(p1, p2) {}

    void Accumulate(Path2Ctx& ctx) {

        if( ctx.GetDC() ) {
            // Do first path in the concatenated path
            _p1->Accumulate(ctx);
            
            // Close the path
            CloseFigure(ctx.GetDC());
        } else {
            ctx.Closed();
            _p1->Accumulate(ctx);
        }
            
    }

  Bool IsClosed() { return true; }

  Bool ExtractAsSingleContour(Transform2 *xf,int *numPts,POINT **gdiPts,Bool *isPolyline)
  { return(_p1->ExtractAsSingleContour(xf,numPts,gdiPts,isPolyline)); }
};

/*****************************************************************************
This class describes a path of connected line segments.
*****************************************************************************/

class PolylinePath2 : public Path2
{
  public:
    // NOTE: This class is expected to free the array of points passed to it.

    // codes are for the flags that go into the GDI PolyDraw
    // function.  If NULL, this is interpeted as a straight polyline.
    // Otherwise, the codes are used to have it be a combination of
    // LineTo's, BezierTo's, and MoveTo's.
    
    PolylinePath2(int numPts, Point2 *pts, double *codes) :
        _myHeap(GetHeapOnTopOfStack()),
            _numPts(numPts),
            _codes(NULL),
            _gdiPts(NULL),
            _dxfPts(NULL),
            _txtPts(NULL),
            _createdCodes(false)
    {
        _ptArray = (Point2 *) StoreAllocate(_myHeap, _numPts * sizeof(Point2));
        memcpy((void *) _ptArray, (void *) pts, _numPts * sizeof(Point2));
        
        if(!codes) {
            CreateDefaultCodes();
        } else {
            CopyDoubleCodes(codes);
        }
    }

    PolylinePath2(int numPts, double *pts, double *codes) :
        _myHeap(GetHeapOnTopOfStack()),
            _numPts(numPts),
            _codes(NULL),
            _gdiPts(NULL),
            _dxfPts(NULL),
            _txtPts(NULL),
            _createdCodes(false)
    {
        _ptArray = (Point2 *) StoreAllocate(_myHeap, _numPts * sizeof(Point2));
        Assert(sizeof(Point2) == (sizeof(double) * 2));
        memcpy((void *) _ptArray, (void *) pts, _numPts * sizeof(Point2));
        
        if(!codes) {
            CreateDefaultCodes();
        } else {
            CopyDoubleCodes(codes);
        }
    }

    PolylinePath2(int numPts, Point2Value **pts, BYTE *codes) :
        _myHeap(GetHeapOnTopOfStack()),
            _numPts(numPts),
            _codes(NULL),
            _gdiPts(NULL),
            _dxfPts(NULL),
            _txtPts(NULL)
    {
        _ptArray = (Point2 *) StoreAllocate(_myHeap, _numPts * sizeof(Point2));
        for (unsigned int i = 0; i < _numPts; i++) {
            _ptArray[i].x = pts[i]->x;
            _ptArray[i].y = pts[i]->y;
        }
        StoreDeallocate(_myHeap, pts);
        
        if(!codes) {
            CreateDefaultCodes();
        } else {
            CopyByteCodes(codes);
        }
    }

    ~PolylinePath2() { 
        if(_gdiPts) StoreDeallocate(_myHeap, _gdiPts);
        StoreDeallocate(_myHeap, _ptArray);
        if(_dxfPts) StoreDeallocate(_myHeap, _dxfPts);
        if(_codes) StoreDeallocate(_myHeap, _codes);
        delete _txtPts;
    }

    Point2Value *FirstPoint() {
        return Promote(_ptArray[0]);
    }

    Point2Value *LastPoint() {
        return Promote(_ptArray[_numPts-1]);
    }

    void GatherLengths (Path2Ctx &context)
    {
        // TODO: Extend this to deal with _codes, dealing with bezier
        // segments and skipping over MOVETO codes.
        
        Real *sublens = (Real*) AllocateFromStore((_numPts-1) * sizeof(Real));

        Transform2 *xf = context.GetTransform();
        Real pathlen = 0;

        int i;
        for (i=0;  i < (_numPts-1);  ++i)
        {
            Point2 P = TransformPoint2(xf, _ptArray[ i ]);
            Point2 Q = TransformPoint2(xf, _ptArray[i+1]);
            sublens[i] = Distance (P, Q);
            pathlen += sublens[i];
        }

        context.SubmitPathInfo (this, pathlen, sublens);
    }

    Point2Value *Sample (PathInfo &pathinfo, Real distance)
    {
        // TODO: Extend this to deal with _codes, dealing with bezier
        // segments and skipping over MOVETO codes.

        // Find the polyline segment that contains the point 'distance' units
        // along the entire polyline.

        int i;
        for (i=0;  i < (_numPts-1);  ++i)
        {
            if (distance <= pathinfo.sublengths[i])
                break;

            distance -= pathinfo.sublengths[i];
        }

        if (i >= (_numPts-1))
            return LastPoint();

        Real t=0;
        if(pathinfo.sublengths[i] > 0)
            t = distance / pathinfo.sublengths[i];

        Point2 P = TransformPoint2 (pathinfo.xform, _ptArray[ i ]);
        Point2 Q = TransformPoint2 (pathinfo.xform, _ptArray[i+1]);
        Point2 R = Lerp(P, Q, t);

        return NEW Point2Value (R.x, R.y);
    }
    
    void Accumulate(Path2Ctx& ctx) {

        // if the transform hasn't changed... <how do we know ?> then
        // we don't need to retransform the points.
        Transform2 *xf = ctx.GetTransform();

        // if there's no codes, you're going thru the slow path man.
        // the right thing to do is make and invariant that polyline
        // path2 will ALWAYS have codes with it.  since no _codes
        // means that it's a polyline why don't we create a
        // polylinepath2 in the first place, eh? eh ?!?
        if( ctx.GetDC() || _createdCodes) {
            
            // TODO: put the relevant device in the context!
            DirectDrawImageDevice *dev =
                GetImageRendererFromViewport( GetCurrentViewport() );

            // assures that _gdiPts exits
            _GenerateGDIPoints(dev, xf);
              
            Assert( _gdiPts );
            
            //
            // Figure out where the last point took us with respect to the
            // previous last point.  We'll use the difference to
            // accumulate into the transformation for appropriate handling
            // of path concatenation.
            //
            Point2Value *tailPt = Promote(TransformPoint2(xf, _ptArray[_numPts-1]));
            ctx.SetTailPt( *(tailPt) );

            if (_createdCodes) {          // regular polyline
            
                // Draw the polyline using GDI.  If the _newSeries flag is set, then
                // this is the first polyline in a series, so first move to the
                // starting point of the current polyline.

                if (ctx._newSeries) {
                    if (0 == MoveToEx (ctx.GetDC(), _gdiPts[0].x, _gdiPts[0].y, NULL)) {
                        TraceTag((tagError, "MoveToEx failed in PolylinePath2"));
                        //RaiseException_InternalError ("MoveToEx failed in PolylinePath2");
                    }

                    ctx._newSeries = false;
                }

                // In specifying the PolylineTo, we needn't specify the first point
                // again.  Either we're starting a NEW path (and henced moved there
                // in the code above), or we're continuing from the previous path
                // segment.  Since we always translate path segments so the first
                // point is coincident with the last point of the previous segment,
                // we skip the first point.  More importantly, if we specify the first
                // point (redundant), a bug in NT GDI causes a bluescreen.

                int result;
                TIME_GDI (result = PolylineTo(ctx.GetDC(), _gdiPts+1, _numPts-1));
                if (0 == result) {
                    
                    // if we failed and we don't have a DC and we created ourr own codes 
                    // Then try other method...
                    if(!ctx.GetDC()) {
                        goto render2DDsurf;
                    }
                    TraceTag((tagError, "PolylineTo failed"));
                
                    //RaiseException_InternalError ("PolylineTo failed");
                    
                }

            } else {                // use polydraw
                dev->GetDaGdi()->PolyDraw_GDIOnly(ctx.GetDC(), _gdiPts, _codes, _numPts);
            }
            
        } else {
render2DDsurf:
            // render into ddsurface
            Assert( ctx.GetDaGdi() );

            PolygonRegion polydrawPolygon;

            if( ctx.GetDaGdi()->DoAntiAliasing() ) {
                
                if(!_dxfPts) _GenerateDxfPoints();
                if(!_txtPts) {
                    // passing in _myHeap as the heap the codes and
                    // pts were created on.  however, it happens to
                    // not matter because we're telling TextPoints NOT
                    // to deallocate the members we set.
                    _txtPts = NEW TextPoints(_myHeap, false);
                    _txtPts->_count = _numPts;
                    _txtPts->_types = _codes;
                    _txtPts->_pts = _dxfPts;

                    DynamicPtrDeleter<TextPoints> *dltr = NEW DynamicPtrDeleter<TextPoints>(_txtPts);
                    _myHeap.RegisterDynamicDeleter(dltr);
                }
                
                polydrawPolygon.Init( _txtPts,
                                      ctx.GetViewportPixelWidth(),
                                      ctx.GetViewportPixelHeight(),
                                      ctx.GetViewportResolution(),
                                      xf );
                
                // We no longer need this since we can now assume that dxtrans
                // will always be on the system that we are.
            } else {
                // TODO: put the relevant device in the context!
                DirectDrawImageDevice *dev =
                    GetImageRendererFromViewport( GetCurrentViewport() );
                 
                _GenerateGDIPoints( dev, GetCurrentViewport()->GetAlreadyOffset(ctx.GetDaGdi()->GetDDSurface())?TimesTransform2Transform2(InverseTransform2(dev->GetOffsetTransform()), xf):xf);
                Assert( _gdiPts );

                polydrawPolygon.Init(_gdiPts, _numPts);
            }

            if(ctx.isClosed()) {
                _codes[_numPts-1] |= PT_CLOSEFIGURE;
            }
            ctx.GetDaGdi()->PolyDraw(&polydrawPolygon, _codes);
        }
    }

    bool CanRenderNatively() { return true; }
    
    Bool ExtractAsSingleContour(Transform2 *xf,
                                int *numPts,            
                                POINT **gdiPts,          
                                Bool *isPolyline) {

        // Don't support polydraw as a single contour.
        if (_codes) {
            return FALSE;
        }

        GetImageRendererFromViewport( GetCurrentViewport() )->
            TransformPointsToGDISpace(
                xf,
                _ptArray,
                _gdiPts,
                _numPts);

        *gdiPts = _gdiPts;
        *numPts = _numPts;
        *isPolyline = TRUE;

        return TRUE;
    }

    const Bbox2 BoundingBox (void);

#if BOUNDINGBOX_TIGHTER
    const Bbox2 BoundingBoxTighter (Bbox2Ctx &bbctx);
#endif  // BOUNDINGBOX_TIGHTER

    Bool DetectHit(PointIntersectCtx& ctx, LineStyle *style);

    virtual int Savings(CacheParam& p) { 
        return (_numPts > 10) ? 3 : 1;
    }

  private:

    void CreateDefaultCodes(void)
    {
        _codes = (BYTE *) StoreAllocate(_myHeap, _numPts * sizeof(BYTE));
        _codes[0] = PT_MOVETO;
        for(int i=1; i < _numPts; i++) {
            _codes[i] = PT_LINETO;
        }
        _createdCodes = true;
    }

    void CopyDoubleCodes(double *codes)
    {
        Assert(_numPts > 0);
        Assert(_codes == NULL);
        Assert(codes != NULL);
        _codes = (BYTE *) StoreAllocate(_myHeap, _numPts * sizeof(BYTE));
        for (int i = 0; i < _numPts; i++) {
            _codes[i] = (BYTE) codes[i];
        }

        // Now, change the code for the first point to be a MoveTo, since
        // there shouldn't be any state retention from previous
        // primitives.  (That is, we don't want to draw a connector from
        // the last point rendered to this first point... there's nothing
        // in the model that would suggest this behavior)
        _codes[0] = PT_MOVETO;
    }

    void CopyByteCodes(BYTE *codes)
    {
        Assert(_numPts > 0);
        Assert(_codes == NULL);
        Assert(codes != NULL);
        _codes = (BYTE *) StoreAllocate(_myHeap, _numPts * sizeof(BYTE));
        memcpy(_codes,codes,_numPts * sizeof(BYTE));

        // Now, change the code for the first point to be a MoveTo, since
        // there shouldn't be any state retention from previous
        // primitives.  (That is, we don't want to draw a connector from
        // the last point rendered to this first point... there's nothing
        // in the model that would suggest this behavior)
        _codes[0] = PT_MOVETO;
    }

    void _GenerateDxfPoints()
    {
        Assert( !_dxfPts );
        _dxfPts = (DXFPOINT *)StoreAllocate(_myHeap, sizeof(DXFPOINT) * _numPts);
        for(int i=0; i<_numPts; i++) {
            _dxfPts[i].x = (float) _ptArray[i].x;
            _dxfPts[i].y = (float) _ptArray[i].y;
        }
    }

    void _GenerateGDIPoints(DirectDrawImageDevice *dev, Transform2 *xf)
    {
        if( !_gdiPts ) {
            _gdiPts = (POINT *)StoreAllocate(_myHeap, _numPts * sizeof(POINT));
        }
       
        dev->TransformPointsToGDISpace(xf, _ptArray, _gdiPts, _numPts);
    }
            
  protected:
    int          _numPts;
    Point2      *_ptArray;
    BYTE        *_codes;
    POINT       *_gdiPts;
    DXFPOINT    *_dxfPts;
    TextPoints *_txtPts;
    DynamicHeap &_myHeap;
    bool        _createdCodes;
};


const Bbox2 PolylinePath2::BoundingBox(void)
{
    // TODO: This can, and should, be cached.
    // TODO; and... if it is, make sure clients don't sideeffect it.
    
    return PolygonalPathBbox(_numPts, _ptArray);
}

#if BOUNDINGBOX_TIGHTER
Bbox2 PolylinePath2::BoundingBoxTighter(Bbox2Ctx &bbctx)
{
    // TODO: This can, and should, be cached.
    
    Bbox2 bbox;
    Transform2 *xf = bbctx.GetTransform();

    for (int i=0;  i < _numPts;  ++i)
        bbox.Augment (TransformPoint2(xf, _ptArray[i]));

    return bbox;
}
#endif  // BOUNDINGBOX_TIGHTER


Bool PolylinePath2::DetectHit (PointIntersectCtx& ctx, LineStyle *style)
{
    // TODO: Take _codes into account
    
    Point2Value *ptValue = ctx.GetLcPoint();

    if( PolygonalTrivialReject( ptValue, style, BoundingBox(), 
                                ctx.GetImageOnlyTransform() ) )
        return false;
    

    int pointCount = _numPts-1;
    Real halfWidth = style->Width() * 0.5;

    Point2 pt = Demote(*ptValue);
    Point2 a, b;
    for(int i=0; i < pointCount; i++)
    {
        a = _ptArray[i];
        b = _ptArray[i+1];
        
        if(a == b) {
            // points are the same, no need to continue...
        }
        else {
            // Seems like this is faster, not sure why!

            Vector2 nw(-(b.y - a.y), (b.x - a.x));
            nw.Normalize();

            Vector2 ap = pt - a;
            Real dist = Dot(ap, nw);
            //printf("Dist = %f, half thickness = %f, d1=%f, w2=%f\n", dist, halfWidth, d1, _thick2);
            if ( fabs(dist) < halfWidth ) {
                Vector2 ab = b - a;
                Vector2 nab = ab;
                nab.Normalize();
                Real len = ab.Length();
                Real dist = Dot(ap, nab);
                return dist > -halfWidth  && dist < (len + halfWidth);
            }
        }
    }

    return FALSE;
}



/*****************************************************************************
The PolyBezierPath2 object creates a 2D path with a cubic Bezier curve.
*****************************************************************************/

class PolyBezierPath2 : public Path2
{
  public:

    // This constructor takes the number of cubic Bezier control points and
    // an array of control points.  

    PolyBezierPath2 (const int numPts, const Point2 pts[]);

    // This constructor takes the number of cubic Bezier control points and
    // an array of control points.  This class will delete the storage for
    // the array of points.

    PolyBezierPath2 (const int numPts, const Point2Value **pts);

    // This constructor takes a set of 'numBsPts'+3 B-spline control points and
    // a set 'numBsPts'+2 knots and constructs a C2 cubic Bezier curve.  This
    // class will delete the storage for the array of points.

    PolyBezierPath2 (const int numBsPts, Point2 bsPts[], Real knots[]);

    // Don't need a CleanUp since there is no system resource to be freed. 

    ~PolyBezierPath2() { 
        DeallocateFromStore (_gdiPts);
        // NOTE: Assumption we are responsible to free the passed in array
        // in the non-bspline case.
        DeallocateFromStore (_ptArray);
    }

    Point2Value *FirstPoint (void) { 
        return Promote(_ptArray[0]); 
    }

    Point2Value *LastPoint  (void) { 
        return Promote(_ptArray[_numPts-1]); 
    }

    // Gather the lengths of the cubic Bezier curves in the path.

    void GatherLengths (Path2Ctx &context) 
    {
        Real *sublens =
            (Real*) AllocateFromStore(sizeof(Real) * ((_numPts-1)/3));

        Transform2 *xf = context.GetTransform();
        Real pathlen = 0;

        // Traverse each cubic Bezier subcurve.  Note that we approximate the
        // length of the Bezier curve by computing the length of the control
        // polygon.  We may choose to improve this in the future.

        int i;
        for (i=0;  i < ((_numPts-1) / 3);  ++i)
        {
            sublens[i] = 0;

            int j;
            for (j=0;  j < 3;  ++j)
            {
                Point2 P = TransformPoint2(xf, _ptArray[3*i +  j ]);
                Point2 Q = TransformPoint2(xf, _ptArray[3*i + j+1]);
                sublens[i] += Distance(P,Q);
            }
            pathlen += sublens[i];
        }

        context.SubmitPathInfo (this, pathlen, sublens);
    }
    
    Point2Value *Sample (PathInfo &pathinfo, Real distance) 
    {
        // Find the polyline segment that contains the point 'distance' units
        // along the entire polyline.

        int numcurves = (_numPts - 1) / 3;

        int i;
        for (i=0;  i < numcurves;  ++i)
        {
            if (distance <= pathinfo.sublengths[i])
                break;

            distance -= pathinfo.sublengths[i];
        }

        if (i >= numcurves)
            return LastPoint();

        Real t = distance / pathinfo.sublengths[i];

        Point2 controlPoints[4];
        controlPoints[0] = TransformPoint2(pathinfo.xform, _ptArray[3*i+0]);
        controlPoints[1] = TransformPoint2(pathinfo.xform, _ptArray[3*i+1]);
        controlPoints[2] = TransformPoint2(pathinfo.xform, _ptArray[3*i+2]);
        controlPoints[3] = TransformPoint2(pathinfo.xform, _ptArray[3*i+3]);

        return Promote(EvaluateBezier (3, controlPoints, t));
    }

    void Accumulate(Path2Ctx& ctx);

    bool CanRenderNatively() const {
        // TODO: implement natively if flash needs this
        return false;
    }
    
    Bool ExtractAsSingleContour(Transform2 *initXform,
                                int *numPts,            
                                POINT **gdiPts,          
                                Bool *isPolyline) const {
        // #error "OK... fill this guy in..."
        return FALSE;
    }
    
    const Bbox2 BoundingBox (void);

#if BOUNDINGBOX_TIGHTER
    const Bbox2 BoundingBoxTighter (Bbox2Ctx &bbctx) const;
#endif  // BOUNDINGBOX_TIGHTER

    Bool DetectHit (PointIntersectCtx& ctx, LineStyle *style);

    virtual int Savings(CacheParam& p) const { 
        return (_numPts > 10) ? 3 : 1;
    }

  protected:
    int      _numPts;          // (_numPts - 1) / 3 Cubic Bezier Curves
    Point2  *_ptArray;             // Array of _numPts Points
    POINT   *_gdiPts;
};



/*****************************************************************************
Constructs a cubic poly Bezier path from a set of 3N+1 control points (where N
is an integer).
*****************************************************************************/

PolyBezierPath2::PolyBezierPath2 (const int numPts, const Point2 *pts)
  : _numPts(numPts), _ptArray(NULL)
{
    _ptArray = (Point2 *) AllocateFromStore(_numPts * sizeof(Point2));
    memcpy((void *) _ptArray, (void *) pts, _numPts * sizeof(Point2));

    // Scratch space for accumulating points into.  We may want to lazily
    // construct these, in case they never get used.

    _gdiPts = (POINT*) AllocateFromStore (numPts * sizeof(POINT));
}

PolyBezierPath2::PolyBezierPath2 (const int numPts, const Point2Value **pts)
  : _numPts(numPts), _ptArray(NULL)
{
    _ptArray = (Point2 *) AllocateFromStore(_numPts * sizeof(Point2));
    for (unsigned int i = 0; i < _numPts; i++) {
        _ptArray[i].x = pts[i]->x;
        _ptArray[i].y = pts[i]->y;
    }
    DeallocateFromStore(pts);

    // Scratch space for accumulating points into.  We may want to lazily
    // construct these, in case they never get used.

    _gdiPts = (POINT*) AllocateFromStore (numPts * sizeof(POINT));
}



/*****************************************************************************
This routine converts a cubic B-spline curve to a cubic Bezier polygon.  Given
L intervals, L cubic Bezier's are returned as 3L+1 control points.  The input
knots Ui must be repeated three times at the ends in order to interpolate the
endpoints of the B-spline polygon.
*****************************************************************************/

static void BSplineToBezier (
    const int     L,    // Number of Intervals
    const Point2  d[],  // B-Spline Control Polygon: [0,L+2]
    const Real    U[],  // Knot Sequence: [0,L+4]
          Point2  b[])  // Output Piecewise Bezier Polygon [0,3L]
{
    Point2 p;    // Pre- and Post- Bezier Point

    p    = Lerp (d[0], d[1], (U[2]-U[0]) / (U[3]-U[0]));
    b[1] = Lerp (d[1], d[2], (U[2]-U[1]) / (U[4]-U[1]));
    b[0] = Lerp (p,    b[1], (U[2]-U[1]) / (U[3]-U[1]));

    int i, i3;
    for (i=1, i3=3;  i < L;  ++i, i3+=3)
    {
        b[i3-1] = Lerp (d[ i ], d[i+1], (U[i+2]-U[ i ]) / (U[i+3]-U[ i ]));
        b[i3+1] = Lerp (d[i+1], d[i+2], (U[i+2]-U[i+1]) / (U[i+4]-U[i+1]));
        b[ i3 ] = Lerp (b[i3-1],b[i3+1],(U[i+2]-U[i+1]) / (U[i+3]-U[i+1]));
    }

    b[i3-1] = Lerp (d[ i ], d[i+1], (U[i+2]-U[ i ]) / (U[i+3]-U[ i ]));
    p       = Lerp (d[i+1], d[i+2], (U[i+2]-U[i+1]) / (U[i+4]-U[i+1]));
    b[ i3 ] = Lerp (b[i3-1],p,      (U[i+2]-U[i+1]) / (U[i+3]-U[i+1]));
}



/*****************************************************************************
The constructor takes L+3 B-spline control points, L+5 knots, and constructs L
cubic Bezier curves (3L+1 Bezier control points).  The knots must be
duplicated three times at each end in order to interpolate the first and last
control points.

NOTE: bsPts and knots will be deleted by this constructor.
*****************************************************************************/

PolyBezierPath2::PolyBezierPath2 (
    const int numBsPts, 
          Point2 bsPts[], 
          Real knots[])
{
    // Special case:  if we are given 3N+1 control points and the given knots
    // are of the form a,a,a, b,b,b, c,c,c, ... N,N,N, then the control polygon
    // for the BSpline is also a control net for a polyBezier.

    bool isPolyBezier = false;

    if (0 == ((numBsPts-1) % 3)) {

        // Test the knot vector to see if it matches the special case.  We use
        // the knowledge that knot values must increase monotonically, so
        // ((U[i+2] - U[i]) == 0)  must mean  U[i]==U[i+1]==U[i+2].  Also, the
        // strict limit below would be (i < (numBsPts+2)), but since i is
        // incremented by 3 these two are equivalent.

        for (int i=0;  (i < numBsPts) && (0 == (knots[i+2]-knots[i]));  i+=3)
            continue;

        // If all knots meet the condition, then just use the control points
        // of the BSpline as the control points for a polyBezier.

        if (i >= numBsPts) {   
            _numPts = numBsPts;
            _ptArray = bsPts;
            isPolyBezier = true;
        }
    }

    // If the BSpline is not of polyBezier form, then we need to convert the
    // cubic BSpline to a cubic polyBezier curve.

    if (!isPolyBezier) {

        _numPts = 3*numBsPts - 8;

        _ptArray = (Point2*) AllocateFromStore (_numPts * sizeof(Point2));

        // Generate the cubic Bezier points from the cubic B-spline curve.

        // Calculate the corresponding cubic Bezier control points and
        // copy them over to the points array.

        BSplineToBezier (numBsPts-3, bsPts, knots, _ptArray);

        // Done with the original BSpline control points

        DeallocateFromStore (bsPts);
    }

    DeallocateFromStore (knots);   // We're done with the knots.

    // Scratch space for accumulating points.

    _gdiPts = (POINT*) AllocateFromStore (_numPts * sizeof(POINT));
}



/*****************************************************************************
This routine lays out the curve using GDI.
*****************************************************************************/

void PolyBezierPath2::Accumulate (Path2Ctx& ctx)
{
    Transform2 *xf = ctx.GetTransform();

    if( ctx.GetDC() ) {

        GetImageRendererFromViewport( GetCurrentViewport() )
            -> TransformPointsToGDISpace (xf, _ptArray, _gdiPts, _numPts);

        // Figure out where the last point took us with respect to the previous
        // last point.  We'll use the difference to accumulate into the
        // transformation for appropriate handling of path concatenation.

        ctx.SetTailPt (*Promote(TransformPoint2(xf, _ptArray[_numPts-1])));

        // Draw the Bezier curve using GDI.  If this is the first in a series, then
        // move to the starting point before drawing, otherwise continue from the
        // end of the last element.

        if (ctx._newSeries) {   
            if (0 == MoveToEx (ctx.GetDC(), _gdiPts[0].x, _gdiPts[0].y, NULL)) {
                TraceTag((tagError, "MoveToEx failed in PolyBezierPath2"));
                //RaiseException_InternalError ("MoveToEx failed in PolyBezierPath2");
            }

            ctx._newSeries = false;
        }

        TIME_GDI( 
            if (0 == PolyBezierTo (ctx.GetDC(), _gdiPts + 1, _numPts - 1)) {
                TraceTag((tagError, "Polybezier failed"));
                //RaiseException_InternalError("Polybezier failed");
            }
        );

    } else {

        Assert( ctx.GetDaGdi() );
        // TODO: use dagdi to draw the bezier

    }
}


/*****************************************************************************
For the bounding box, we just take the convex hull of the bezier's control
points (guaranteed to contain the curve).
*****************************************************************************/

const Bbox2 PolyBezierPath2::BoundingBox (void)
{
    return PolygonalPathBbox(_numPts, _ptArray);
}

#if BOUNDINGBOX_TIGHTER
const Bbox2 PolyBezierPath2::BoundingBoxTighter (Bbox2Ctx &bbctx)
{
    Bbox2 bbox;
    Transform2 *xf = bbctx.GetTransform();

    for (int i=0;  i < _numPts;  ++i) {
        bbox.Augment (TransformPoint2(xf, _ptArray[i]));
    }

    return bbox;
}
#endif  // BOUNDINGBOX_TIGHTER



/*****************************************************************************
BUG:  This code is incorrect: it only tests hits on the control polygon, not
on the actual curve (so you'll rarely get a positive result if you pick on
the curve).
*****************************************************************************/

Bool PolyBezierPath2::DetectHit (PointIntersectCtx& ctx, LineStyle *style)
{
    // TODO: put the relevant device in the context!
    DirectDrawImageDevice *dev = GetImageRendererFromViewport( GetCurrentViewport() );

    // TODO: how to make sure the sound device isn't upon us!


    Point2Value *pt = ctx.GetLcPoint();
    if( PolygonalTrivialReject( pt, style, BoundingBox(), ctx.GetImageOnlyTransform() ) )
        return false;

    return dev->DetectHitOnBezier(this, ctx, style);
}


/*****************************************************************************
*****************************************************************************/


TextPath2::TextPath2(Text *text, bool restartClip)
{
    _text = text;
    _restartClip = restartClip;
}

Point2Value *
TextPath2::FirstPoint()
{
    Assert(!"who's calling TextPath2::FirstPoint");
    return origin2;
}

Point2Value *
TextPath2::LastPoint()
{
    Assert(!"who's calling TextPath2::LastPoint");
    return origin2;
}

void
TextPath2::GatherLengths (Path2Ctx &context)
{
    Assert (!"Somebody's callling TextPath2::GatherLengths()");
    return;
}

Point2Value *
TextPath2::Sample (PathInfo &pathinfo, Real distance)
{
    Assert (!"Who's calling TextPath2::Sample()?");
    return origin2;
}

void
TextPath2::Accumulate(Path2Ctx& ctx)
{
    TextCtx textCtx(GetImageRendererFromViewport( GetCurrentViewport() ));


    textCtx.BeginRendering(TextCtx::renderForPath,
                           ctx.GetDC(),
                           ctx.GetTransform());
    _text->RenderToTextCtx(textCtx);
    textCtx.EndRendering();
}

const Bbox2 TextPath2::BoundingBox (void)
{
    TextCtx ctx(GetImageRendererFromViewport( GetCurrentViewport() ));

    ctx.BeginRendering(TextCtx::renderForBox);

    _text->RenderToTextCtx(ctx);

    ctx.EndRendering();

    return ctx.GetStashedBbox();
}

#if BOUNDINGBOX_TIGHTER
const Bbox2 TextPath2::BoundingBoxTighter (Bbox2Ctx &bbctx)
{
    Transform2 *xf = bbctx.GetTransform();
    return TransformBbox2(xf, BoundingBox());
}
#endif  // BOUNDINGBOX_TIGHTER

Bool TextPath2::DetectHit(PointIntersectCtx& ctx, LineStyle *style)
{
    // Ughhh implemente this...
    return FALSE;
}

void
TextPath2::DoKids(GCFuncObj proc)
{
    (*proc)(_text);
}

class LinePath2 : public Path2
{
  public:
    LinePath2(Path2 *path, LineStyle *ls) {
        _path = path;
        _lineStyle = ls;
    }

    Point2Value *FirstPoint() {
        Assert(!"who's calling LinePath2::FirstPoint");
        return origin2;
    }

    Point2Value *LastPoint() {
        Assert(!"who's calling LinePath2::LastPoint");
        return origin2;
    }

    void GatherLengths (Path2Ctx &context) {
        Assert (!"Somebody's callling LinePath2::GatherLengths()");
        return;
    }

    Point2Value *Sample (PathInfo &pathinfo, Real distance)
    {   Assert (!"Who's calling LinePath2::Sample()?");
        return origin2;
    }

    void Accumulate(Path2Ctx& ctx) {
        // not impl
        return;
/*
  TextCtx textCtx(GetImageRendererFromViewport( GetCurrentViewport() ));
  textCtx.BeginRendering(TextCtx::renderForPath,
  ctx.GetDC(),
  ctx.GetTransform());
  _text->RenderToTextCtx(textCtx);
  textCtx.EndRendering();
  */
    }

    const Bbox2 BoundingBox (void) {
        // TODO: need to augment path with line thickness
        return _path->BoundingBox();
/*
  TextCtx ctx(GetImageRendererFromViewport( GetCurrentViewport() ));
  ctx.BeginRendering(TextCtx::renderForBox);
  _text->RenderToTextCtx(ctx);
  ctx.EndRendering();
  return ctx.GetStashedBbox();
  */
    }

#if BOUNDINGBOX_TIGHTER
    const Bbox2 BoundingBoxTighter (Bbox2Ctx &bbctx) {
        Transform2 *xf = bbctx.GetTransform();
        return TransformBbox2(xf, BoundingBox());
    }
#endif  // BOUNDINGBOX_TIGHTER

    Bool DetectHit(PointIntersectCtx& ctx, LineStyle *style)
    {
        // Ughhh implemente this...
        return FALSE;
    }

    virtual void DoKids(GCFuncObj proc) {
        (*proc)(_path);
        (*proc)(_lineStyle);
    }

    virtual int Savings(CacheParam& p) { return _path->Savings(p); }

  protected:
    Path2 *_path;
    LineStyle *_lineStyle;
};

////////////////////////////////////////////////////////////////
//////// Constructors
////////////////////////////////////////////////////////////////

Path2 *
Line2(const Point2 &p1, const Point2 &p2)
{
    Point2 pts[2];
    pts[0] = p1;
    pts[1] = p2;
    return NEW PolylinePath2(2, pts, NULL);
}

Path2 *
Line2(Point2Value *p1, Point2Value *p2)
{
    Point2 pts[2];
    pts[0] = Demote(*p1);
    pts[1] = Demote(*p2);
    return NEW PolylinePath2(2, pts, NULL);
}

Path2 *
RelativeLine2(Point2Value *pt)
{
    return Line2(origin2, pt);
}

Path2 *
PolyLine2(AxAArray *ptArr)
{
    if(ptArr->Length() <= 0) {
        RaiseException_UserError(E_FAIL, IDS_ERR_IMG_NOT_ENOUGH_PTS_2); 
    }

    int numPts = ptArr->Length() == 1 ? 2 : ptArr->Length();
    Point2Value **pts = (Point2Value **)AllocateFromStore(numPts * sizeof(Point2Value *));
                    
    if(ptArr->Length() == 1){
        // Handle special case of only one point.
                        
        pts[0] = pts[1] = (Point2Value *)(*ptArr)[0];        
    } else {
        
        for (int i = 0; i < numPts; i++) {
            pts[i] = (Point2Value *)(*ptArr)[i];
        }
    }
        
    return NEW PolylinePath2(numPts, pts, NULL);
}

Path2 *NewPolylinePath2(DWORD numPts, Point2Value **pts, BYTE *codes)
{
    return NEW PolylinePath2(numPts, pts, codes);
}
    
Path2 *
PolydrawPath2Double(double *pointdata,
                    unsigned int numPts,
                    double *codedata,
                    unsigned int numCodes)
{
    if (numPts != numCodes) {
        RaiseException_UserError(E_FAIL, IDS_ERR_IMG_ARRAY_MISMATCH);
    }

    return NEW PolylinePath2(numPts, pointdata, codedata);
}

Path2 *
PolydrawPath2(AxAArray *ptArr,
              AxAArray *codeArr)
{
    int numPts = ptArr->Length();
    int numCodes = codeArr->Length();

    if (numPts != numCodes) {
        RaiseException_UserError(E_FAIL, IDS_ERR_IMG_ARRAY_MISMATCH);
    }

    Point2Value **pts = (Point2Value **)AllocateFromStore(numPts * sizeof(Point2Value *));
    BYTE    *codes = (BYTE *)AllocateFromStore(numPts * sizeof(BYTE));

    for (int i = 0; i < numPts; i++) {
        pts[i] = (Point2Value *)(*ptArr)[i];
        codes[i] = (BYTE)(NumberToReal((AxANumber *)(*codeArr)[i]));
    }

    PolylinePath2 *pp = NEW PolylinePath2(numPts, pts, codes);

    DeallocateFromStore(codes);

    return pp;
}

/*****************************************************************************
The B-spline path2 takes a set of 2D control points and knots, and returns a
path from them.  Given N control points, we expect N+2 knots.
*****************************************************************************/

Path2 *CubicBSplinePath (AxAArray *ptArray, AxAArray *knotArray)
{
    int numPts = ptArray->Length();

    // We need at least four control points to do a cubic curve.

    if (numPts < 4)
        RaiseException_UserError (E_FAIL, IDS_ERR_IMG_NOT_ENOUGH_PTS_4);

    // Extract the B-spline control points into an array of Point2*.

    Point2 *pts = (Point2 *) AllocateFromStore (numPts * sizeof(Point2));

    int i;
    for (i=0;  i < numPts;  ++i) {
        pts[i].x = ((Point2Value*) (*ptArray)[i])->x;
        pts[i].y = ((Point2Value*) (*ptArray)[i])->y;
    }

    // We need at least N+2 knots, where N is the number of B-spline control
    // points.

    int numKnots = knotArray->Length();

    if (numKnots != (numPts+2))
    {
        char kn[10];
        char pts[10];
        wsprintf(kn, "%d", numKnots);
        wsprintf(pts, "%d", numPts);
        RaiseException_UserError (E_FAIL, IDS_ERR_SPLINE_KNOT_COUNT, "3", kn, pts);
    }

    Real *knots =
        (Real*) AllocateFromStore (numKnots * sizeof(Real));

    Real lastknot = -HUGE_VAL;

    for (i=0;  i < (numPts+2);  ++i)
    {
        knots[i] = NumberToReal ((AxANumber*)(*knotArray)[i]);

        if (knots[i] < lastknot)
        {
            RaiseException_UserError(E_FAIL, IDS_ERR_SPLINE_KNOT_MONOTONICITY);
        }

        lastknot = knots[i];
    }

    return NEW PolyBezierPath2 (numPts, pts, knots);
}


Path2 *
OriginalTextPath(Text *tx)
{
    bool restartClip;

    // TODO: DDalal, fill in with ExtendAttrib stuff for choosing
    // this. 
    restartClip = false;
    
    return NEW TextPath2(tx, restartClip);
}

    // TextPath2Constructor is defined in fontstyl.

Path2 *
InternalPolyLine2(int numPts, Point2 *pts)
{
    return NEW PolylinePath2(numPts, pts, NULL);
}

////////////////////////////////////////
Path2 *
ConcatenatePath2(Path2 **paths, int numPaths)
{
    if (numPaths <= 0) {
        RaiseException_UserError(E_FAIL, IDS_ERR_ZERO_ELEMENTS_IN_ARRAY);
    }

    Path2 *pReturn = paths[0];

    for (int i = 1; i < numPaths; i++) {
        pReturn = ConcatenatePath2(pReturn, paths[i]);
    }

    return pReturn;
}

////////////////////////////////////////

Path2 *
ClosePath2(Path2 *p)
{
     Path2 *p2 = Line2(p->LastPoint(), p->FirstPoint());
     return NEW ClosedConcatenatedPath2(p, p2);
}

/*****************************************************************************
* This is derived from NT's implementation of Arc.
* Here's a comment block cloned from their source.
*
* Constructs a partial arc of 90 degrees or less using an approximation
* technique by Kirk Olynyk.  The arc is approximated by a cubic Bezier.
*
* Restrictions:
*
*    angle must be within 90 degrees of startAngle.
*
* Steps in constructing the curve:
*
*    1) Construct the conic section at the origin for the unit circle;
*    2) Approximate this conic by a cubic Bezier;
*    3) Scale result.
*
* 1)  Constructing the Conic
*
*       'startAngle' and 'endAngle' determine the end-points of the
*       conic (call them vectors from the origin, A and C).  We need the
*       middle vector B and the sharpness to completely determine the
*       conic.
*
*       For the portion of a circular arc that is 90 degrees or less,
*       conic sharpness is Cos((endAngle - startAngle) / 2).
*
*       B is calculated by the intersection of the two lines that are
*       at the ends of A and C and are perpendicular to A and C,
*       respectively.  That is, since A and C lie on the unit circle, B
*       is the point of intersection of the two lines that are tangent
*       to the unit circle at A and C.
*
*       If A = (a, b), then the equation of the line through (a, b)
*       tangent to the circle is ax + by = 1.  Similarly, for
*       C = (c, d), the equation of the line is cx + dy = 1.  The
*       intersection of these two lines is defined by:
*
*              x = (d - b) / (ad - bc)
*       and    y = (a - c) / (ad - bc).
*
*       Then, B = (x, y).
*
* 2)  Approximating the conic as a Bezier cubic
*
*       For sharpness values 'close' to 1, the conic may be approximated
*       by a cubic Bezier; error is less for sharpnesses closer to 1.
*
*     Error
*
*       Since the largest angle handled by this routine is 90 degrees,
*       sharpness is guaranteed to be between 1 / sqrt(2) = .707 and 1.
*       Error in the approximation for a 90 degree arc is approximately
*       0.2%; it is less for smaller angles.  0.2% is deemed small
*       enough error; thus, a 90 degree circular arc is always
*       approximated by just one Bezier.
*
*       One notable implication of the fact that arcs have less error
*       for smaller angles is that when a partial arc is xor-ed with
*       the corresponding complete ellipse, some of the partial arc
*       will not be completely xor-ed out.  (Too bad.)
*
*       Given a conic section defined by (A, B, C, S), we find the
*       cubic Bezier defined by the four control points (V0, V1, V2, V3)
*       that provides the closest approimxation.  We require that the
*       Bezier be tangent to the triangle at the same endpoints.  That is,
*
*               V1 = (1 - Tau1) A + (Tau1) B
*               V2 = (1 - Tau2) C + (Tau2) B
*
*       Simplify by taking Tau = Tau1 = Tau2, and we get:
*
*               V0 = A
*               V1 = (1 - Tau) A + (Tau) B
*               V2 = (1 - Tau) C + (Tau) B
*               V3 = C
*
*
*       Where Tau = 4 S / (3 (S + 1)), S being the sharpness.
*       S = cos(angle / 2) for an arc of 90 degrees or less.
*       So, for one quadrant of a circle, and since A and B actually
*       extend from the corners of the bound box, and not the center,
*
*         Tau = 1 - (4 * cos(45)) / (3 * (cos(45) + 1)) = 0.44772...
*
*       See Kirk Olynyk's "Conics to Beziers" for more.
*
* 3)    The control points for the bezier curve are scaled to the given radius.
*****************************************************************************/

Path2 *
partialQuadrantArc(Real startAngle, Real angle, Real xRadius, Real yRadius)
{
    // OZG: Line2 & PolyBezierPath2 constructors must take Point2.
    Real endAngle = startAngle + angle;
    Real sharpness = cos(angle/2),
         TAU = (sharpness * 4.0 / 3.0) / (sharpness + 1),
         oneMinusTAU = 1 - TAU;

    Real startX = cos(startAngle),
         startY = sin(startAngle),
         endX   = cos(endAngle),
         endY   = sin(endAngle),
         denom  = startX * endY - startY * endX;
    Vector2 startVec(startX, startY);
    Vector2 endVec(endX, endY);
    Vector2 middleVec(0, 0);

    Point2 startPt(startX, startY);
    Point2 endPt(endX, endY);

    if (denom == 0) {
        // We have zero angle arc.
        return Line2(startPt, endPt);
    }

    middleVec.x = (endY - startY) / denom;
    middleVec.y = (startX - endX) / denom;
    Vector2 ctl2Vec = startVec * oneMinusTAU + middleVec * TAU;
    Vector2 ctl3Vec = endVec * oneMinusTAU + middleVec * TAU;

    // The constructor will delete pts and knots.
    Point2 pts[4];
    pts[0] = startPt;
    pts[1].Set(ctl2Vec.x, ctl2Vec.y);
    pts[2].Set(ctl3Vec.x, ctl3Vec.y);
    pts[3] = endPt;

    PolyBezierPath2 *pReturn = NEW PolyBezierPath2(4, pts);
    Transform2 *xf = ScaleRR(xRadius, yRadius);
    return TransformPath2(xf, pReturn);
}

////////////////////////////////////////
// The path starts at the starting point of the arc and ends at the
// end point of the arc.

Path2 *
ArcValRRRR(Real startAngle, Real endAngle, Real width, Real height)
{
    Real sAngle = startAngle,
         eAngle = endAngle,
         angle = eAngle - sAngle,
         absAngle = fabs(angle);

    // Reduce the angle to less than 4*pi
    if (absAngle > 4*pi) {
        // We want absAngle to be betwwen 2*pi and 4*pi.
        Real quo = absAngle/(2*pi);
        absAngle -= (floor(quo)-1)*2*pi;
        if (angle < 0) {
            angle = -absAngle;
        } else {
            angle = absAngle;
        }
        eAngle = sAngle + angle;
    }

    Real quadAngle = (angle < 0) ? -pi/2 : pi/2,
         xR = width/2.0,
         yR = height/2.0;

    Path2 *pReturn = NULL, *pQuad = NULL;
    bool  bLastArc = false;

    do {
        if (fabs(eAngle - sAngle) <= pi/2) {
            pQuad = partialQuadrantArc(sAngle, eAngle-sAngle, xR, yR);
            bLastArc = true;
        } else {
            pQuad = partialQuadrantArc(sAngle, quadAngle, xR, yR);
            sAngle += quadAngle;
        }

        if (pReturn != NULL) {
            pReturn = ConcatenatePath2(pReturn, pQuad);
        } else {
            pReturn = pQuad;
        }
    } while (bLastArc == false);

    return pReturn;
}

Path2 *
ArcVal(AxANumber *startAngle, AxANumber *endAngle, AxANumber *width, AxANumber *height)
{
    return ArcValRRRR(startAngle->GetNum(),endAngle->GetNum(),
                      width->GetNum(),height->GetNum());
}

////////////////////////////////////////
// The path starts at the 0 degree point, moves counter-clockwise and
// ends at the same point.

Path2 *
OvalValRR(Real width, Real height)
{
    return ClosePath2(ArcValRRRR(0, 2*pi, width, height));
}

Path2 *
OvalVal(AxANumber *width, AxANumber *height)
{
    return OvalValRR(width->GetNum(),height->GetNum());
}

////////////////////////////////////////
// The path starts at the upper right corner of the horizontal line,
// moves counter-clockwise, and ends at the same point it starts.

Path2 *
RectangleValRR(Real width, Real height)
{
    Point2Value **pts = (Point2Value **) AllocateFromStore (4 * sizeof(Point2Value *));
    Real halfWidth = width/2;
    Real halfHeight = height/2;
    pts[0] = NEW Point2Value(halfWidth,  halfHeight);
    pts[1] = NEW Point2Value(-halfWidth, halfHeight);
    pts[2] = NEW Point2Value(-halfWidth, -halfHeight);
    pts[3] = NEW Point2Value(halfWidth,  -halfHeight);
    Path2 *rectPath = NEW PolylinePath2(4, pts, NULL);
    return ClosePath2(rectPath);
}

Path2 *
RectangleVal(AxANumber *width, AxANumber *height)
{
    return RectangleValRR(width->GetNum(),height->GetNum());
}

////////////////////////////////////////
// The path starts at the upper right corner of the horizontal line,
// moves counter-clockwise, and ends at the same point it starts.

Path2 *
RoundRectValRRRR(Real width, Real height, Real arcWidth, Real arcHeight)
{
    Real halfWidth = width/2,
         halfHeight = height/2,
         halfWidthAbs = fabs(halfWidth),
         halfHeightAbs = fabs(halfHeight),
         xR = arcWidth/2,
         yR = arcHeight/2,
         xRAbs = fabs(xR),
         yRAbs = fabs(yR);

    // Clamp arcWidth to width, arcHeight to height.
    if (halfWidthAbs < xRAbs)
        xRAbs = halfWidthAbs;
    if (halfHeightAbs < yRAbs)
        yRAbs = halfHeightAbs;

    Real halfWidthInner = halfWidthAbs - xRAbs,
         halfHeightInner = halfHeightAbs - yRAbs;

    if (halfWidth < 0)
         halfWidthInner = -halfWidthInner;
    if (halfHeight < 0)
         halfHeightInner = -halfHeightInner;

    Real widthInner = halfWidthInner*2,
         heightInner = halfHeightInner*2;

    Path2 **paths = (Path2 **)AllocateFromStore(8 * sizeof(Path2 *));
    paths[0] = Line2(Point2(halfWidthInner, halfHeight),
                     Point2(-halfWidthInner, halfHeight));
    paths[2] = RelativeLine2(NEW Point2Value(0, -heightInner));
    paths[4] = RelativeLine2(NEW Point2Value(widthInner, 0));
    paths[6] = RelativeLine2(NEW Point2Value(0, heightInner));

    // Check the end point of the first line path to decide the angle for the
    // first arc.
    Real beginAngle;
    bool inversed = (xR < 0) || (yR < 0);
    if (-halfWidthInner > 0) {
        if (halfHeight >= 0) {
            // The end point is in the 1st quadrant.
            beginAngle = inversed ? pi*3/2 : 0;
        } else {
            // The end point is in the 4th quadrant.
            beginAngle = inversed ? pi: pi*3/2;
        }
    } else if (-halfWidthInner < 0) {
        if (halfHeight > 0) {
            // The end point is in the 2nd quadrant.
            beginAngle = inversed ? 0 : pi/2;
        } else {
            // The end point is in the 3rd quadrant.
            beginAngle = inversed ? pi/2 : pi;
        }
    } else {
        if (halfHeight >= 0) {
            // The end point is in the 2nd quadrant.
            beginAngle = inversed ? 0 : pi/2;
        } else {
            // The end point is in the 4th quadrant.
            beginAngle = inversed ? pi: pi*3/2;
        }
    }

    // IHammer behavior.  Use the signs of arcWidth/arcHeight to determine the
    // direction of the arcs.
    Real angle;
    if (inversed)
        angle = -pi/2;
    else
        angle = pi/2;

    paths[1] = partialQuadrantArc(beginAngle, angle, xRAbs, yRAbs);
    beginAngle += pi/2;
    paths[3] = partialQuadrantArc(beginAngle, angle, xRAbs, yRAbs);
    beginAngle += pi/2;
    paths[5] = partialQuadrantArc(beginAngle, angle, xRAbs, yRAbs);
    beginAngle += pi/2;
    paths[7] = partialQuadrantArc(beginAngle, angle, xRAbs, yRAbs);

    return ClosePath2(ConcatenatePath2(paths, 8));
}

Path2 *
RoundRectVal(AxANumber *width, AxANumber *height, 
             AxANumber *arcWidth, AxANumber *arcHeight)
{
    return RoundRectValRRRR(width->GetNum(),height->GetNum(),
                            arcWidth->GetNum(),arcHeight->GetNum());
}


////////////////////////////////////////
// The path starts at the origin, moves to the starting point of the
// arc, continues to the end point of the arc, and ends at the origin.

Path2 *PieValRRRR (
    Real startAngle,
    Real endAngle,
    Real width,
    Real height)
{
    Real sAngle = startAngle,
         eAngle = endAngle;

    // Draw an oval if angle >= 2*pi.
    if (fabs(eAngle - sAngle) >= 2*pi) {
        return OvalValRR(width, height);
    }

    Point2 startPt(cos(sAngle),sin(sAngle));

    Path2 *pFirst = Line2(Origin2, startPt),
          *pArc = ArcValRRRR(startAngle, endAngle, 2, 2);

    Path2 *piePath = ConcatenatePath2(pFirst, pArc);
    Transform2 *xf = ScaleRR(width/2, height/2);
    return ClosePath2(TransformPath2(xf, piePath));
}

Path2 *PieVal (
    AxANumber *startAngle,
    AxANumber *endAngle,
    AxANumber *width,
    AxANumber *height)
{
    return PieValRRRR(startAngle->GetNum(),endAngle->GetNum(),
                      width->GetNum(),height->GetNum());
}


/*****************************************************************************
This function gathers information from all subpaths in the path, and maps the
total path length to the range [0,1].  It then uses 'num0to1' to evaluate the
total path, and sample the proper subpath based on the GatherLengths()
traversal.
*****************************************************************************/

Point2Value *Point2AtPath2 (Path2 *path, AxANumber *num0to1)
{
    Path2Ctx ctx (NULL, identityTransform2);

    path->GatherLengths (ctx);

    return ctx.SamplePath (CLAMP(ValNumber(num0to1), 0.0, 1.0));
}



Transform2 *Path2Transform(Path2 *path, AxANumber *num0to1)
{
    return TranslateVector2Value
           (MinusPoint2Point2 (Point2AtPath2(path, num0to1), origin2));
}


#if ONLY_IF_DOING_EXTRUSION

HINSTANCE hInstT3DScene = NULL;
CritSect *path2CritSect = NULL;


static HRESULT
MyExtrudeRegion(IDirect3DRMMeshBuilder3 *builder,
                int totalPts,
                LPPOINT pts,
                LPBYTE codes,
                Real extrusionDepth,
                bool sharedVertices,
                BYTE textureSetting,
                BYTE bevelType,
                Real frontBevelDepth,
                Real backBevelDepth,
                Real frontBevelAmt,
                Real backBevelAmt)
{
    CritSectGrabber csg(*path2CritSect);
    
    typedef HRESULT (WINAPI *ExtruderFuncType)(IDirect3DRMMeshBuilder3 *,
                                               int,
                                               LPPOINT,
                                               LPBYTE,
                                               Real,
                                               bool,
                                               BYTE,
                                               BYTE,
                                               Real,
                                               Real,
                                               Real,
                                               Real);

    static ExtruderFuncType myExtruder = NULL;
  
    if (!myExtruder) {
        hInstT3DScene = LoadLibrary("t3dscene.dll");
        if (!hInstT3DScene) {
            Assert(FALSE && "LoadLibrary of t3dscene.dll failed");
            return E_FAIL;
        }

        FARPROC fptr = GetProcAddress(hInstT3DScene, "ExtrudeRegion");
        if (!fptr) {
            Assert(FALSE && "GetProcAddress in t3dscene.dll failed");
            return E_FAIL;
        }

        myExtruder = (ExtruderFuncType)(fptr);
    }

    return (*myExtruder)(builder,
                         totalPts,
                         pts,
                         codes,
                         extrusionDepth,
                         sharedVertices,
                         textureSetting,
                         bevelType,
                         frontBevelDepth,
                         backBevelDepth,
                         frontBevelAmt,
                         backBevelAmt);
}


Geometry *extrudePath(AxANumber *extrusionDepth,
                      BYTE       textureSetting,
                      BYTE       bevelType,
                      AxANumber *frontBevelDepth,
                      AxANumber *backBevelDepth,
                      AxANumber *frontBevelAmt,
                      AxANumber *backBevelAmt,
                      Path2     *path)
{
    DAComPtr<IDirect3DRMMeshBuilder> builder;
    TD3D(GetD3DRM1()->CreateMeshBuilder(&builder));

    DAComPtr<IDirect3DRMMeshBuilder3> builder3;
    HRESULT hr =
        builder->QueryInterface(IID_IDirect3DRMMeshBuilder3,
                                (void **)&builder3);

    if (FAILED(hr)) {
        RaiseException_UserError(E_FAIL, IDS_ERR_MISCVAL_BAD_EXTRUDE);
    }

    // Get the points and codes from the path.
    HDC dc;
    TIME_GDI(dc = CreateCompatibleDC(NULL));
    
    path->AccumPathIntoDC(dc, identityTransform2, true);

    int totalPts;
    TIME_GDI(totalPts = GetPath(dc, NULL, NULL, 0));

    LPPOINT pts = THROWING_ARRAY_ALLOCATOR(POINT, totalPts);
    LPBYTE  codes = THROWING_ARRAY_ALLOCATOR(BYTE, totalPts);

    int numFilled;
    TIME_GDI(numFilled = GetPath(dc, pts, codes, totalPts));

    TIME_GDI(DeleteDC(dc));

    Assert(numFilled == totalPts);

    if (numFilled == -1) {
        hr = E_FAIL;
    } else {
        hr = MyExtrudeRegion(builder3,
                             totalPts,
                             pts,
                             codes,
                             NumberToReal(extrusionDepth),
                             true,
                             textureSetting,
                             bevelType,
                             NumberToReal(frontBevelDepth),
                             NumberToReal(backBevelDepth),
                             NumberToReal(frontBevelAmt),
                             NumberToReal(backBevelAmt));
    }
    
    delete [] pts;
    delete [] codes;

    if (FAILED(hr)) {
        RaiseException_UserError(E_FAIL, IDS_ERR_MISCVAL_BAD_EXTRUDE);
    }

    D3DRMBOX box;
    TD3D(builder->GetBox(&box));

    Bbox3 *bbx = NEW Bbox3(box.min.x, box.min.y, box.min.z,
                           box.max.x, box.max.y, box.max.z);
    
    Geometry *geo = NEW RM1MeshGeo (builder, bbx, false);

    return geo;
}


void
InitializeModule_Path2()
{
    if (!path2CritSect) {
        path2CritSect = NEW CritSect;
    }
}

void
DeinitializeModule_Path2(bool bShutdown)
{
    if (path2CritSect) {
        delete path2CritSect;
        path2CritSect = NULL;
    }
    
    if (hInstT3DScene) {
        FreeLibrary(hInstT3DScene);
    }
}

#endif ONLY_IF_DOING_EXTRUSION
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\values\misc\vec2.cpp ===
/*++
******************************************************************************
Copyright (c) 1995-96  Microsoft Corporation

Abstract:
    Implementation of 2D vectors and points.

******************************************************************************
--*/

#include "headers.h"
#include "privinc/vec2i.h"
#include "privinc/basic.h"


/*******************/
/***  Constants  ***/
/*******************/

Vector2Value *xVector2    = NULL;
Vector2Value *yVector2    = NULL;
Vector2Value *zeroVector2 = NULL;

Point2Value *origin2      = NULL;


/*****************************************************************************
External Interfaces for Vector Types
*****************************************************************************/

Vector2Value *XyVector2(AxANumber *x, AxANumber *y)
{   return NEW Vector2Value (NumberToReal(x), NumberToReal(y));
}

Vector2Value *XyVector2RR(Real x, Real y)
{   return NEW Vector2Value (x, y);
}

Vector2Value *PolarVector2(AxANumber *angle, AxANumber *radius)
{   Real a = NumberToReal(angle);
    Real r = NumberToReal(radius);

    return NEW Vector2Value(cos(a) * r, sin(a) * r);
}

Vector2Value *PolarVector2RR(Real angle, Real radius)
{   return NEW Vector2Value(cos(angle) * radius, sin(angle) * radius);
}

Vector2Value *NormalVector2(Vector2Value *V)
{   Vector2Value *result = NEW Vector2Value (*V);
    result->Normalize();
    return result;
}

AxANumber *LengthSquaredVector2 (Vector2Value *v)
{   return RealToNumber (v->LengthSquared());
}

AxANumber *LengthVector2 (Vector2Value *v)
{   return RealToNumber (v->Length());
}

Vector2Value *MinusVector2Vector2 (Vector2Value *v1, Vector2Value *v2)
{   return NEW Vector2Value (*v1 - *v2);
}

Vector2Value *PlusVector2Vector2 (Vector2Value *v1, Vector2Value *v2)
{   return NEW Vector2Value (*v1 + *v2);
}

Vector2Value *NegateVector2 (Vector2Value *v)
{   return NEW Vector2Value (-(*v));
}

Vector2Value *ScaleRealVector2R (Real scalar, Vector2Value *v)
{   return NEW Vector2Value (scalar * (*v));
}

Vector2Value *ScaleRealVector2 (AxANumber *scalar, Vector2Value *v)
{   return ScaleRealVector2R (NumberToReal(scalar), v);
}

Vector2Value *ScaleVector2Real(Vector2Value *v, AxANumber *scalar)
{   return ScaleRealVector2R (NumberToReal(scalar), v);
}

Vector2Value *DivideVector2Real(Vector2Value *v, AxANumber *scalar)
{   return NEW Vector2Value (*v / NumberToReal(scalar));
}

Vector2Value *DivideVector2RealR(Vector2Value *v, Real scalar)
{   return NEW Vector2Value (*v / scalar);
}

AxANumber *DotVector2Vector2 (Vector2Value *A, Vector2Value *B)
{   return RealToNumber (Dot(*A,*B));
}

Real RDotVector2Vector2 (Vector2Value *A, Vector2Value *B)
{   return Dot(*A,*B);
}

Real CrossVector2Vector2(Vector2Value *A, Vector2Value *B)
{   return Cross (*A, *B);
}

#if _USE_PRINT
ostream& operator<< (ostream& os, Vector2Value& v)
{   return os << "<" << v.x << ", " << v.y << ">";
}
#endif



/*****************************************************************************
Functions on Points
*****************************************************************************/

Point2Value *XyPoint2 (AxANumber *x, AxANumber *y)
{   return NEW Point2Value (NumberToReal(x), NumberToReal(y));
}

Point2Value *XyPoint2RR (Real x, Real y)
{   return NEW Point2Value (x, y);
}

Point2Value *PolarPoint2 (AxANumber *angle, AxANumber *radius)
{
    Real r = NumberToReal(radius);
    Real a = NumberToReal(angle);
    return NEW Point2Value(cos(a) * r, sin(a) * r);
}

Point2Value *PolarPoint2RR (Real angle, Real radius)
{   return NEW Point2Value(cos(angle) * radius, sin(angle) * radius);
}

Vector2Value *MinusPoint2Point2 (Point2Value *P, Point2Value *Q)
{   return NEW Vector2Value (*P - *Q);
}

Point2Value *PlusPoint2Vector2 (Point2Value *P, Vector2Value *V)
{   return NEW Point2Value (*P + *V);
}

Point2Value *MinusPoint2Vector2 (Point2Value *P, Vector2Value *V)
{   return NEW Point2Value (*P - *V);
}

AxANumber *DistancePoint2Point2 (Point2Value *P, Point2Value *Q)
{   return RealToNumber (Distance (*P, *Q));
}

AxANumber *DistanceSquaredPoint2Point2 (Point2Value *P, Point2Value *Q)
{   return RealToNumber (DistanceSquared (*P, *Q));
}

#if _USE_PRINT
ostream& operator<< (ostream& os, Point2Value& P)
{   return os << "<" << P.x << ", " << P.y << ">";
}
#endif



//////////////  Extractors  ////////////

AxANumber *XCoordVector2(Vector2Value *v) { return RealToNumber(v->x); }
AxANumber *YCoordVector2(Vector2Value *v) { return RealToNumber(v->y); }
AxANumber *RhoCoordVector2(Vector2Value *v) { return LengthVector2(v); }
AxANumber *ThetaCoordVector2(Vector2Value *v) {return RealToNumber(atan2(v->y, v->x));}

AxANumber *XCoordPoint2(Point2Value *p) { return RealToNumber(p->x); }
AxANumber *YCoordPoint2(Point2Value *p) { return RealToNumber(p->y); }
AxANumber *RhoCoordPoint2(Point2Value *p) {return DistancePoint2Point2(origin2, p);}
AxANumber *ThetaCoordPoint2(Point2Value *p) {return RealToNumber(atan2(p->y, p->x));}


void
InitializeModule_Vec2()
{
    xVector2    = NEW Vector2Value (1, 0);
    yVector2    = NEW Vector2Value (0, 1);
    zeroVector2 = NEW Vector2Value (0, 0);
    origin2     = NEW Point2Value (0, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\values\misc\polygon.cpp ===
/*-------------------------------------

Copyright (c) 1996 Microsoft Corporation

Abstract:

    Implements bounding polygon class

-------------------------------------*/

#include "headers.h"

#include <privinc/util.h>
#include <appelles/bbox2.h>
#include <privinc/bbox2i.h>
#include <privinc/vec2i.h>
#include <privinc/polygon.h>
#include <privinc/xform2i.h>


typedef list<Point2Value *> Point2List ;

// consider inlining this ?... nah
BoundingPolygon *NewBoundingPolygon(const Bbox2 &box)
{
    BoundingPolygon *bp = NEW BoundingPolygon;
    bp->PostConstructorInitialize();
    if (box != NullBbox2) {
        bp->SetBox(box);
    }
    return bp;
}

BoundingPolygon::BoundingPolygon() { }

void BoundingPolygon::
PostConstructorInitialize(void)
{
    _vertList   = NEW list<Point2Value *>;
    _vertexCount=0;
    _accumXform = identityTransform2;
    _xfDirty = FALSE;
    GetHeapOnTopOfStack().RegisterDynamicDeleter(NEW DynamicPtrDeleter<list<Point2Value *> >(_vertList));
}

BoundingPolygon::~BoundingPolygon()
{
    delete _vertList;
}

void BoundingPolygon::
Crop(const Bbox2 &box)
{
    Assert((_vertexCount == 0) || (_vertexCount >= 3) &&
           "Bad vertexCount in BoundingPolygon");

    if (_vertexCount == 0) 
        return;

    if (box.Contains(BoundingBox())) {

        // Return if we're already inside by the crop box.
        
        return;

    } else if (_vertexCount > 2) {

        Point2List list1;
        Point2List *fromList, *tempList, *currList;

        Point2List::iterator curr;
        Point2List::iterator prev;
        bool currOut, prevOut;
        //
        // Augment current set of verticies
        //

        Real minx = box.min.x;
        Real maxx = box.max.x;

        Real miny = box.min.y;
        Real maxy = box.max.y;

        fromList = _vertList;
        currList = &list1;

        //--------------------------------------------------
        // L E F T
        //--------------------------------------------------

        // prime
        curr = fromList->begin();
        prev = fromList->begin();
        curr++;

        for(unsigned int i=0; i < fromList->size(); i++) {
            
            currOut = (*curr)->x <= minx;
            prevOut = (*prev)->x <= minx;

            TestAndAdd(minx, 
                       (*prev)->x, (*prev)->y,
                       (*curr)->x, (*curr)->y,
                       prevOut, currOut,
                       TRUE,
                       *curr,
                       currList);

            curr++; prev++;
            if(curr == fromList->end()) {
                // we've gone past the end, last edge
                curr = fromList->begin();
            }
        } // for left
        
        //
        // Switch
        //
        tempList = fromList;

        fromList->erase(fromList->begin(), fromList->end());
        fromList = currList;
        currList = tempList;


        //--------------------------------------------------
        // R I G H T
        //--------------------------------------------------

        // prime
        curr = fromList->begin();
        prev = fromList->begin();
        curr++;

        for(i=0; i < fromList->size(); i++) {
            
            currOut = (*curr)->x >= maxx;
            prevOut = (*prev)->x >= maxx;

            TestAndAdd(maxx,
                       (*prev)->x, (*prev)->y,
                       (*curr)->x, (*curr)->y,
                       prevOut, currOut,
                       TRUE,
                       *curr,
                       currList);

            curr++; prev++;
            if(curr == fromList->end()) {
                // we've gone past the end, last edge
                curr = fromList->begin();
            }
        } // for right

        //
        // Switch
        //
        tempList = fromList;

        fromList->erase(fromList->begin(), fromList->end());
        fromList = currList;
        currList = tempList;

        //--------------------------------------------------
        // B O T T O M
        //--------------------------------------------------

        // prime
        curr = fromList->begin();
        prev = fromList->begin();
        curr++;

        for( i=0; i < fromList->size(); i++) {
            
            currOut = (*curr)->y <= miny;
            prevOut = (*prev)->y <= miny;

            TestAndAdd(miny,
                       (*prev)->y, (*prev)->x,
                       (*curr)->y, (*curr)->x,
                       prevOut, currOut,
                       FALSE,
                       *curr,
                       currList);

            curr++; prev++;
            if(curr == fromList->end()) {
                // we've gone past the end, last edge
                curr = fromList->begin();
            }
        } // for bottom

        //
        // Switch
        //
        tempList = fromList;

        fromList->erase(fromList->begin(), fromList->end());
        fromList = currList;
        currList = tempList;
 
        //--------------------------------------------------
        // T O P 
        //--------------------------------------------------

        // prime
        curr = fromList->begin();
        prev = fromList->begin();
        curr++;

        for(i=0; i < fromList->size(); i++) {
            
            currOut = (*curr)->y >= maxy;
            prevOut = (*prev)->y >= maxy;

            TestAndAdd(maxy,
                       (*prev)->y, (*prev)->x,
                       (*curr)->y, (*curr)->x,
                       prevOut, currOut,
                       FALSE,
                       *curr,
                       currList);

            curr++; prev++;
            if(curr == fromList->end()) {
                // we've gone past the end, last edge
                curr = fromList->begin();
            }
        } // for top

        //
        // update vertexCount
        //
        _vertexCount = _vertList->size();

    } // if vertextCount > 2
}

void BoundingPolygon::
TestAndAdd(Real axis,
           Real ax, Real ay,
           Real bx, Real by,
           Bool aOut,
           Bool bOut,
           Bool XY,
           Point2Value *b,
           Point2List *vertList)
{
    if( !(aOut ^ bOut) ) {
        // both out or both in
        if(aOut) {
            // both out
        } else {
            // both in
            // add curr to list
            vertList->push_back( b );
        }
    } else  {
        // crossing
        // intersection, find it
        Real int_y = ay + (by - ay) * (axis - ax) / (bx - ax);
        Real int_x = axis;
        
        if(!XY) {
            // swap x and y since we've actually just calculated the x intersect
            int_x = int_y;
            int_y = axis;
        }

        vertList->push_back( NEW Point2Value(int_x, int_y) );
        
        if( bOut ) {
            // last is in: already added
        } else {
            // curr is in:  add
            vertList->push_back( b );
        }
    }
}

void BoundingPolygon::
ForceTransform()
{
    Assert(FALSE && "Transform optimization not implemented yet");
    #if 0
    if(_xfDirty) {
        Point2List::iterator j = _vertList->begin();

        for(int i=0; i < _vertexCount; i++, j++) {
            (*j) = TransformPoint2Value(xform, *j );
        }
        _xfDirty = FALSE;
        _accumXform = identityTransform2;
    }
    #endif
}


void BoundingPolygon::
Transform(Transform2 *xform)
{
#if 0
    // do this later if we see the need
    // just accumulate, outside in
    _accumXfrom = 
        TimesTransform2Transform2(xform, _accumXform);
    _xfDirty = TRUE;
#else
    Point2List::iterator j = _vertList->begin();
    
    for(int i=0; i < _vertexCount; i++, j++) {
        (*j) = TransformPoint2Value(xform, *j );
    }
#endif
}

const Bbox2 BoundingPolygon::BoundingBox (void)
{
    Point2List::iterator j = _vertList->begin();

    Bbox2 bbox;
    for (int i=0;  i < _vertexCount;  ++i, ++j) {
       bbox.Augment (Demote(**j));
    }

    return bbox;
}

#if BOUNDINGBOX_TIGHTER
const Bbox2 BoundingPolygon::BoundingBoxTighter (Bbox2Ctx &bbctx)
{
    Point2List::iterator j = _vertList->begin();

    Bbox2 bbox;
    Transform2 *xf = bbctx.GetTransform();

    for (int i=0;  i < _vertexCount;  ++i, ++j) {
       bbox.Augment (*TransformPoint2Value(xf, *j));
    }

    return bbox;
}
#endif  // BOUNDINGBOX_TIGHTER



/*****************************************************************************
This procedure gets the Point2 vertices of the polygon in counter-clockwise
order.  This procedure returns the number of vertices that were successfully
loaded into the vertex array.
*****************************************************************************/

int BoundingPolygon::GetPointArray (
    Point2Value **vertArray,       // Destination Vertex Array
    Bool		 want_clockwise,  // True if Vertices Requested in Clockwise Order.
    bool		*flag_reversed)   // Returns Whether The Vertex Order Was Reversed.
{
    if (_vertexCount < 3) return 0;

    // First determine the vertex order of the polygon.

    const Real   epsilon   = 1e-12;             // Comparison Epsilon
    unsigned int vertsleft = _vertexCount - 1;  // Vertices Left to Examine

    Point2List::iterator vit = _vertList->begin();
    vertArray[0] = *vit;

    Point2Value V0 = *(*vit);   // First Vertex.

    Vector2Value A, B;  // These vectors will be used to form the cross product
                        // that tells us the polygon vertex ordering.

    // Find the first available vertex in the polygon that yields a non-zero
    // vector from the first vertex.

    do {
        -- vertsleft;
        ++ vit;
        A = *(*vit) - V0;

    } while (vertsleft && (A.LengthSquared() < (epsilon*epsilon)));

    if (!vertsleft) return 0;    // Bail out if all poly verts were co-linear.

    // Now that we've got a non-zero vector, iterate through the vertices
    // to generate a second vertex vector that yields a non-zero (within
    // epsilon) cross product.

    Real cross;

    do {
        -- vertsleft;
        ++ vit;
        cross = Cross (A, *(*vit)-V0);

    } while (vertsleft && (fabs(cross) < epsilon));

    // Bail out if we've got no vertices left and we didn't find a good cross
    // product.

    if (fabs(cross) < epsilon)
        return 0;

    // If the orientation asked for and the orientation of the vertex array
    // differ, reverse the vertices.  Note that a positive cross product
    // indicates a counter-clockwise orientation.

    bool reverse = (want_clockwise != (cross < 0));
    if (flag_reversed) *flag_reversed = reverse;

    if (reverse) {

        // [v0 v1 v2 ... vn-1 vn]  reverse->  [v0 vn vn-1 ... v2 v1]

        Point2List::reverse_iterator j = _vertList->rbegin();

        for (int i=1;  i < _vertexCount;  ++i, ++j)
            vertArray[i] = *j;

    } else {

        ++ (vit = _vertList->begin());
        for(int i=1;  i < _vertexCount;  ++i, ++vit)
            vertArray[i] = *vit;
    }
    
    return _vertexCount;
}

void BoundingPolygon::
SetBox(const Bbox2 &box)
{
        Assert((_vertexCount == 0) && "Bad Box in BoundingPolygon");
    if (_vertexCount == 0) {
        //
        // insert box, counterclockwise
        //
        _vertList->push_back(NEW Point2Value(box.min.x, box.min.y));
        _vertList->push_back(NEW Point2Value(box.max.x, box.min.y));
        _vertList->push_back(NEW Point2Value(box.max.x, box.max.y));
        _vertList->push_back(NEW Point2Value(box.min.x, box.max.y));

        _vertexCount = 4;
    } 
}
    
void BoundingPolygon::
AddToPolygon(BoundingPolygon &pgon)
{
    Point2List::iterator j = pgon._vertList->begin();
    for(int i=0; i < pgon._vertexCount; i++, j++) {
        _vertList->push_back(*j);
    }
    _vertexCount += pgon._vertexCount;
}

void BoundingPolygon::
AddToPolygon(int numPts, Point2Value **pts)
{
    for(int i=0; i <numPts; i++) {
        _vertList->push_back(pts[i]);
    }
    _vertexCount += numPts;
}

Bool BoundingPolygon::
PtInPolygon(Point2Value *pt)
{
    Assert((_vertexCount > 2) && "Bad vertex count in PtInPolygon");
    
    //
    // Case a ray from 'pt' in positive x.  if it hits
    // even number of line segments, return FALSE
    // odd number of line segments, return TRUE
    //
    Point2List::iterator j0 = _vertList->begin();
    Point2List::iterator j1 = j0;j1++;
    _vertList->push_back(*j0);
    Point2Value *a = *j0;
    Point2Value *b  = *j1;
    LONG hits = 0;
    for(int i=0; i < _vertexCount; i++, j0++, j1++) {

        a = *j0; b = *j1;
        
        //printf("%d: (%1.1f %1.1f)  (%1.1f, %1.1f)",i, a->x, a->y, b->x, b->y);

        //
        // if at least one point of the segment is to the right
        // of 'pt'.
        //
        Bool ax = (a->x >= pt->x);
        Bool bx = (b->x >= pt->x);
        Bool ay = (a->y >= pt->y);
        Bool by = (b->y >= pt->y);

        //printf(":: %d%d %d%d ",ax,ay,bx,by);
        if( (ax ^ bx) && (ay ^ by) ) {
            // use cross product test

            // If the cross product: a X b  is positive and
            // 'a' is below 'b' then there's a hit.
            // If the cross product is negative and 'a' is
            // above 'b', then there's a hit.
            // So, if  p = cross>0
            // and     q = a is below b
            // then:   hit = pq OR !p!q
            // which is:   = !(p XOR q)
            Real cross = CrossVector2Vector2(
                MinusPoint2Point2(a,pt),
                MinusPoint2Point2(b,pt));
                
            Bool pos = cross > 0.0;
            hits += !(pos ^ by);
            //printf(" crosses: %f %d hit:%d\n", cross, pos, !(pos ^ by));
        } else {
            // check for trivial accept
            if( ax && bx && ((!ay && by) || (ay && !by))) {
                hits++;
                //printf(" trivial accept\n");
            } else {
                //printf("\n");
            }
        }
                
    }

    _vertList->pop_back();

    return IsOdd(hits);
}

void BoundingPolygon::DoKids(GCFuncObj proc)
{
    (*proc)(_accumXform);
    for (list<Point2Value*>::iterator i=_vertList->begin();
         i != _vertList->end(); i++)
        (*proc)(*i);
}

#if _DEBUG
void BoundingPolygon::_debugOnly_Print()
{
    OutputDebugString("--> BoundingPolygon print\n");
    list<Point2Value*>::iterator i=_vertList->begin();
    for (int j=0;  i != _vertList->end(); j++, i++) {
        TraceTag((tagError, "   (%d)  %f, %f\n",
                  j,
                  (*i)->x,
                  (*i)->y));
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\values\sound\dmusic.cpp ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\values\misc\text.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Implementation of the text type

*******************************************************************************/


#include "headers.h"
#include "appelles/text.h"
#include "appelles/axachstr.h"
#include "privinc/textctx.h"
#include "privinc/imagei.h"
#include "privinc/texti.h"
#include "privinc/dddevice.h"
#include "privinc/basic.h"
#include "backend/values.h"



///////////// Text Context
void  TextCtx::
RenderString(WideString str)
{
    DirectDrawImageDevice* idev = _dev;
    if(!idev) {
        idev = GetImageRendererFromViewport( GetCurrentViewport() );
    }

    switch(_forWhat) {
      case renderForBox:

        Assert(idev && "No imgdev avail in textCtx! <derive bbox>");
        
        if( GetFixedText() ) {
            _stashedBbox = idev->DeriveStaticTextBbox(*this, str);
        } else {
            bool bCharXf = GetCharacterTransform() ? true:false;
            _stashedBbox = idev->DeriveDynamicTextBbox(*this, str, bCharXf);
        }

        break;

      case renderForColor:

        _stashedColor = _col;
        break;

      case renderForPath:
        
        Assert(idev && "No imgdev avail in textCtx! <renderForPath>");
        Assert(_dc && "Bad _dc in textCtx! <renderForPath>");
        Assert(_xform && "Bad _xform in textCtx! <renderForPath>");

        if( GetFixedText() ) {
            idev->RenderStaticTextOnDC(*this, str, _dc, _xform);
        } else {
            idev->RenderDynamicTextOnDC(*this, str, _dc, _xform);
        }
        break;

      case renderForReal:
      default:
        Assert(idev && "No imgdev avail in textCtx! <render string>");

        //
        // Ask the image device to render the text.
        // Pass this context along with the string to render.
        //
        idev->RenderText(*this, str, _textImg);
        break;
    }
}   


////////////  Font functionality
FontFamily *serifProportional;
FontFamily *sansSerifProportional;
FontFamily *monospaced;

////////////  Text functionality

////////////  String functionality

AxAString *
NumberString(AxANumber *num, AxANumber *precision)
{
    char numBuffer[256];

    numBuffer[0] = 0;
    numBuffer[ARRAY_SIZE(numBuffer) - 1] = 0;
    int precis = (int)NumberToReal(precision);

    // clamp the precision to avoid bugs and weird errors.
    if (precis > 32) precis = 32;
    if (precis < 0) precis = 0;
    
    // The printf directive %.*f indicates that the precision should
    // be gotten from the argument list, and to format the number as a
    // floating point with the specified precision.
    _snprintf(numBuffer,
              ARRAY_SIZE(numBuffer) - 1,
              "%.*f",
              precis,
              NumberToReal(num));

    return CharPtrToString(numBuffer);
}

////////// Text is defined and implemented in privinc/texti.h


class SimpleTextImpl : public Text {
  public:
    SimpleTextImpl(AxAString * str) : _str(str) {}
    void RenderToTextCtx(TextCtx& ctx) {
        ctx.RenderString(_str->GetStr());
    }
    int GetCharacterCount() {
        // room for some optimization here.
        return lstrlenW(_str->GetStr());
    }
    WideString GetStringPtr() { return _str->GetStr(); }
    virtual void DoKids(GCFuncObj proc) { (*proc)(_str); }
  protected:
    AxAString * _str;
};

Text *SimpleText(AxAString * str)
{ return NEW SimpleTextImpl(str); }

////////////

class CatenatedTextImpl : public Text {
  public:
    CatenatedTextImpl(Text *a, Text *b) : _first(a), _second(b) {}
    void RenderToTextCtx(TextCtx& ctx) {
        _first->RenderToTextCtx(ctx);
        _second->RenderToTextCtx(ctx);
    }
    int GetCharacterCount() {
        Assert(FALSE && "Should not be using Concatinated text");
        return 0;
    }
    WideString GetStringPtr() {
        Assert(FALSE && "GetStringPtr not implemented on CatenatedText");
        return _first->GetStringPtr();
    }

    virtual void DoKids(GCFuncObj proc) {
        (*proc)(_first);
        (*proc)(_second);
    }
  protected:
    Text *_first;
    Text *_second;
};

Text *CatenateText(Text *a, Text *b) { return NEW CatenatedTextImpl(a,b); }

////////////

class ColoredTextImpl : public Text {
  public:
    ColoredTextImpl(Color *c, Text *txt) : _color(c), _txt(txt) {}
    void RenderToTextCtx(TextCtx& ctx) {
        // Overriding attr: If the attr has already been set, this
        // won't do anything.
        ctx.SetColor(_color);
        _txt->RenderToTextCtx(ctx);
        ctx.ResetColor();
    }
    int GetCharacterCount() {
        return _txt->GetCharacterCount();
    }
    WideString GetStringPtr() {
        return _txt->GetStringPtr();
    }

    virtual void DoKids(GCFuncObj proc) {
        (*proc)(_color);
        (*proc)(_txt);
    }

  protected:
    Color *_color;
    Text *_txt;
};

Text *TextColor(Color *c, Text *t) { return NEW ColoredTextImpl(c,t); }

////////////

class FontedTextImpl : public Text {
  public:
    FontedTextImpl(FontFamily *f, int size, Text *txt) : _font(f), _fontSize(size), _txt(txt) {}
    void RenderToTextCtx(TextCtx& ctx) {
        // Overriding attr: If the attr has already been set, this
        // won't do anything.
        ctx.SetFont(_font->GetFontFamily());
        ctx.SetFontFamily(_font->GetFontFamilyName()?_font->GetFontFamilyName()->GetStr():NULL);
        ctx.SetFontSize(_fontSize);
        
        _txt->RenderToTextCtx(ctx);
        ctx.ResetFont();
    }
    int GetCharacterCount() {
        return _txt->GetCharacterCount();
    }
    WideString GetStringPtr() {
        return _txt->GetStringPtr();
    }

    virtual void DoKids(GCFuncObj proc) {
        (*proc)(_font);
        (*proc)(_txt);
    }

  protected:
    FontFamily* _font;
    int  _fontSize;
    Text *_txt;
};

Text *TextFont(FontFamily *font, int size, Text *txt)
{ return NEW FontedTextImpl(font, size, txt); }

//Text *TextFontFromString(AxAString *fontStr, Text *txt)
//{ return NEW FontedTextImpl(NEW FontFamily(fontStr), txt); }


////////////

class AttributedTextImpl : public Text {
  public:

    enum Attr {
        bold,
        italic,
        underline,
        strikethrough,
        weight,
        antialiased,
        fixedText,
        characterTransform
    };

    AttributedTextImpl(Attr a, Text *txt) :
    _a(a), _txt(txt), _characterTransform(NULL) {}

    void RenderToTextCtx(TextCtx& ctx) {

        Real oldWeight;
        Real oldAntiAliased;
        Transform2 *oldCxf;
        switch (_a) {
          case bold:
            ctx.SetBold(TRUE);
            break;

          case italic:
            ctx.SetItalic(TRUE);
            break;

          case underline:
            ctx.SetUnderline(TRUE);
            break;

          case strikethrough:
            ctx.SetStrikethrough(TRUE);
            break;

          case weight:
            oldWeight = ctx.GetWeight();
            ctx.SetWeight(_weight);
            break;

          case antialiased:
            oldAntiAliased = ctx.GetAntiAlias();
            ctx.SetAntiAlias(_antiAlias);
            break;

          case fixedText:
            ctx.SetFixedText(true);
            break;

          case characterTransform:
            oldCxf = ctx.GetCharacterTransform();
            ctx.SetCharacterTransform(_characterTransform);
            break;
        }

        _txt->RenderToTextCtx(ctx);

        switch (_a) {
          case bold:
            ctx.SetBold(FALSE);
            break;

          case italic:
            ctx.SetItalic(FALSE);
            break;

          case underline:
            ctx.SetUnderline(FALSE);
            break;

          case strikethrough:
            ctx.SetStrikethrough(FALSE);
            break;

          case weight:
            ctx.SetWeight(oldWeight);
            break;
            
          case antialiased:
            ctx.SetAntiAlias(oldAntiAliased);
            break;
            
          case fixedText:
            ctx.SetFixedText(false);
            break;

          case characterTransform:
            ctx.SetCharacterTransform( oldCxf );
            break;
        }

    }
    int GetCharacterCount() {
        return _txt->GetCharacterCount();
    }
    WideString GetStringPtr() {
        return _txt->GetStringPtr();
    }
    void SetWeight(Real hs) { _weight = hs; }
    void SetAntiAlias(Real aa) { _antiAlias = aa; }
    void SetCharacterTransform(Transform2 *xf) {
        _characterTransform = xf;
    }
    
    virtual void DoKids(GCFuncObj proc) {
        (*proc)(_txt);
        (*proc)(_characterTransform);
    }

  protected:
    Text *_txt;
    Attr   _a;
    Real   _weight;
    Real   _antiAlias;
    Transform2 *_characterTransform;
};

Text *TextBold(Text *t)
{ return NEW AttributedTextImpl(AttributedTextImpl::bold, t); }

Text *TextItalic(Text *t)
{ return NEW AttributedTextImpl(AttributedTextImpl::italic, t); }

Text *TextStrikethrough(Text *t)
{ return NEW AttributedTextImpl(AttributedTextImpl::strikethrough, t); }

Text *TextUnderline(Text *t)
{ return NEW AttributedTextImpl(AttributedTextImpl::underline, t); }

Text *TextFixedText(Text *t)
{ return NEW AttributedTextImpl(AttributedTextImpl::fixedText, t); }

Text *TextAntiAliased(Real antiAlias, Text *t)
{
    AttributedTextImpl *ti = 
        NEW AttributedTextImpl(AttributedTextImpl::antialiased, t);
    ti->SetAntiAlias(antiAlias);
    return ti;
}

Text *TextWeight(Real weight, Text *t)
{
    AttributedTextImpl *newTxt =
        NEW AttributedTextImpl(AttributedTextImpl::weight, t);

    newTxt->SetWeight(weight);

    return newTxt;
}

Text *TextTransformCharacter(Transform2 *xf, Text *t)
{
    if (xf == identityTransform2) {
        return t;
    }
    
    AttributedTextImpl *newTxt =
        NEW AttributedTextImpl(AttributedTextImpl::characterTransform, t);
    newTxt->SetCharacterTransform(xf);

    return newTxt;
}

void
InitializeModule_Text()
{
    serifProportional = NEW FontFamily(ff_serifProportional);
    sansSerifProportional = NEW FontFamily(ff_sansSerifProportional);
    monospaced = NEW FontFamily(ff_monospaced);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\values\misc\spline.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Implementation of b-spline functions

*******************************************************************************/

#include "headers.h"
#include "privinc/vec2i.h"
#include "privinc/vec3i.h"
#include "privinc/except.h"
#include "privinc/debug.h"
#include "backend/values.h"
#include "include/appelles/bspline.h"
#include "backend/bvr.h"
#include "backend/perf.h"
#include "privinc/server.h"

static const Real EPSLION = 1e-6;

////////////////////  Spline Header  ///////////////////////

class ATL_NO_VTABLE Spline : public AxAValueObj {
  public:
    Spline(int degree,
           int numKnots, Real *knots,
           int numPts, AxAValue *pts,
           // numWeights == 0 indicates non-rational spline
           int numWeights, Real *weights);

    AxAValue Evaluate(Real param);

    // TODO: Not a type in avrtypes.h??
    virtual DXMTypeInfo GetTypeInfo() { return AxATrivialType; }

    virtual void DoKids(GCFuncObj proc) {
        for (int i=0; i<_numPts; i++) {
            if (_pts) (*proc)(_pts[i]);
            if (_spareArray) (*proc)(_spareArray[i]);
        }
    }

  protected:

    // Subclasses fill these in for the appropriate operations on the
    // relevant type of control point.
    virtual AxAValue CreateNewVal() = 0;
    virtual void     Copy(const AxAValue src, AxAValue& dst) = 0;
    virtual void     Add(const AxAValue v1,
                         const AxAValue v2,
                         AxAValue& result) = 0;
    virtual void     Mul(const AxAValue v,
                         const Real scalar,
                         AxAValue& result) = 0;

    void LazyInitialize();
    int  DetermineInterval(Real *param); // output the adjusted param
    
    int       _degree;
    int       _numKnots;
    Real     *_knots;
    int       _numPts;
    AxAValue *_pts;
    Bool      _rational;
    Real     *_weights;

    AxAValue    *_spareArray;         // same len as pts
    Real        *_spareWeights;       // same len as pts, if rational
    AxAValue     _temp;
    DynamicHeap& _heapCreatedOn;

    // data cached from previous evaluations
    int          _lastInterval;
};

////////////////////  Generic Spline Evaluation  ///////////////////////

Spline::Spline(int degree,
               int numKnots, Real *knots,
               int numPts, AxAValue *pts,
               int numWeights, Real *weights)
    
    : _heapCreatedOn(GetHeapOnTopOfStack())
{
    _degree = degree;
    _numKnots = numKnots;
    _knots = knots;
    _numPts = numPts;
    _pts = pts;
    _weights = weights;
    _rational = (numWeights != 0);

    _spareArray = NULL;
    _spareWeights = NULL;
    _lastInterval = 0;

    /////// Validate Input Data //////

    // Valid degree
    if (_degree < 1 || _degree > 3) {
        RaiseException_UserError(E_FAIL, IDS_ERR_SPLINE_BAD_DEGREE);
    }

    // Valid relationship between knots, points, and degree
    if (_numKnots != _numPts + _degree - 1) {
        char deg[4];
        char kn[10];
        char pts[10];
        wsprintf(deg, "%d", _degree);
        wsprintf(kn, "%d", _numKnots);
        wsprintf(pts, "%d", _numPts);
        RaiseException_UserError(E_FAIL, IDS_ERR_SPLINE_KNOT_COUNT, deg, kn, pts);
    }

    // Monotone knot vector
    for (int i = 0; i < _numKnots - 1; i++) {
        if (_knots[i] > _knots[i+1]) {
            RaiseException_UserError(E_FAIL, IDS_ERR_SPLINE_KNOT_MONOTONICITY);
        }
    }

    // Same number of weights as ctrl points.
    if (_rational && (numWeights != _numPts)) {
        RaiseException_UserError(E_FAIL, IDS_ERR_SPLINE_MISMATCHED_WEIGHTS);
    }

}

// Need to do some lazy initialization since virtual methods cannot be
// called from constructors.
void
Spline::LazyInitialize()
{
    PushDynamicHeap(_heapCreatedOn);

    // Just fill in spare array with the appropriate structure.  This
    // will be filled in during evaluation.  
    _spareArray = (AxAValue *)AllocateFromStore((_numPts + 1) * sizeof(AxAValue));
    
    for (int i = 0; i < _numPts+1; i++) {
        _spareArray[i] = CreateNewVal();
    }

    if (_rational) {
        _spareWeights = (Real *)AllocateFromStore((_numPts + 1)* sizeof(Real));
    }

    _temp = CreateNewVal();
    
    PopDynamicHeap();
}

int
Spline::DetermineInterval(Real *pU)
{
    // Heuristic assumes that u is monotonically increasing on
    // consecutive calls, thus we look at the current interval first,
    // and then the following interval.  If u is in neither, then we
    // perform an arbitrary search.

    Real u = *pU;
    
    int i = _lastInterval;
    
    if (_lastInterval != 0 && _knots[i] <= u && u < _knots[i+1]) {
        
        // In the same interval
        return i;
        
    } else if (u < _knots[_degree - 1]) {

        // If parameter less than beginning of range, clamp to
        // beginning of range.
        *pU = _knots[_degree - 1];
        return DetermineInterval(pU);
        
    } else if (u >= _knots[_numKnots - _degree]) {
        
        // If parameter greater than end of range, clamp to
        // end of range.
        *pU = _knots[_numKnots - _degree] - EPSLION;
        return DetermineInterval(pU);

    } else if ((i + 2 < _numKnots) &&
               _knots[i+1] <= u && u < _knots[i+2]) {
        
        // In the next interval
        _lastInterval = i + 1;
        return _lastInterval;

    } else if ((i == _numKnots - 1) &&
               (_knots[0] <= u && u < _knots[1])) {

        // Wrapped around back to the beginning
        _lastInterval = 0;
        return _lastInterval;
        
    } else {

        // Just do a linear search.  Could improve performance by
        // doing a binary search, but the presumption is that the
        // above special cases will pick up the vast majority of the
        // uses. 
        for (int j = 0; j <= _numKnots - 2; j++) {
            if ((_knots[j] <= u) && (u < _knots[j+1])) {
                _lastInterval = j;
                return j;
            }
        }

        // The only known reason we'd get to this point is if we have
        // the same value as the last knot.  Verify this is the case,
        // then search for the first knot with this value.
        Assert(u == _knots[_numKnots-1]);
        for (j = 0; j <= _numKnots - 2; j++) {
            if (_knots[j+1] == u) {
                _lastInterval = j;
                return j;
            }
        }

        Assert(FALSE && "Shouldn't be here");
    }
    
    return 0;
}

AxAValue
Spline::Evaluate(Real u)
{
    if (_spareArray == NULL) {
        LazyInitialize();
    }

    int interval = DetermineInterval(&u);

    // B-spline evaluator below uses the deBoor knot-insertion
    // algorithm, from Farin, Curves and Surfaces for CAGD, 
    // 3rd Ed., Chapter 10.
    
    int j, k;
    Real t1, t2;

    TraceTag((tagSplineEval,
              "Array fill: start = %d, stop = %d",
              interval - _degree + 1,
              interval + 1));
             
    // Re-fill relevant portions of the spare array
    for (j = interval - _degree + 1; j <= interval + 1; j++) {
        Copy(_pts[j], _spareArray[j]);
    }

    if (_rational) {
        for (j = interval - _degree + 1; j <= interval + 1; j++) {
            _spareWeights[j] = _weights[j];
        }
    }

    for (k = 1; k <= _degree; k++) {
        
        int lowerRange = interval - _degree + k + 1;
        
        TraceTag((tagSplineEval,
                  "Ranging j: start = %d, stop = %d",
                  interval + 1,
                  lowerRange));

        for (j = interval + 1; j >= lowerRange; j--) {

            int knotIndex = j + _degree - k;
            t1 = (_knots[knotIndex] - u) /
                 (_knots[knotIndex] - _knots[j - 1]);

            t2 = 1.0 - t1;

            // Following has the effect of
            //  sa[j] = t1 * sa[j-1] + t2 * sa[j];
            Mul(_spareArray[j-1], t1, _temp);
            Mul(_spareArray[j], t2, _spareArray[j]);
            Add(_spareArray[j], _temp, _spareArray[j]);

            if (_rational) {
                _spareWeights[j] = t1 * _spareWeights[j-1] +
                                   t2 * _spareWeights[j];
            }

        }
    }

    // Copy the result into a newly allocated value.
    AxAValue retVal = CreateNewVal();
    Copy(_spareArray[interval + 1], retVal);
    
    if (_rational) {

        // Get w coordinate of result, but if it's zero, avoid a
        // numerical error by making it extremely small.
        Real w = _spareWeights[interval + 1];
        if (w == 0) {
            w = 1e-30;
        }
        
        // Divide by w.
        Mul(retVal, 1.0/w, retVal);
    }
    
    return retVal;
}

////////////////////  Subclasses  ///////////////////////

//////////  Number //////////

class NumSpline : public Spline {
  public:
    NumSpline(int degree,
              int numKnots, Real *knots,
              int numPts, AxAValue *pts,
              int numWeights, Real *weights) :
    Spline(degree, numKnots, knots, numPts, pts, numWeights, weights) {}

  protected:
    AxAValue CreateNewVal() { return NEW AxANumber; }
    
    void Copy(const AxAValue src, AxAValue& dst) {
        ((AxANumber *&)dst)->SetNum(ValNumber(src));
    }
    
    void Add(const AxAValue val1, const AxAValue val2, AxAValue& result) {
        ((AxANumber *&)result)->SetNum(ValNumber(val1) +
                                       ValNumber(val2));
    }
    
    void Mul(const AxAValue val, const Real scalar, AxAValue& result) {
        ((AxANumber *&)result)->SetNum(ValNumber(val) * scalar);
    };
};

//////////  Point2 //////////

class Pt2Spline : public Spline {
  public:
    Pt2Spline(int degree,
              int numKnots, Real *knots,
              int numPts, AxAValue *pts,
              int numWeights, Real *weights) :
    Spline(degree, numKnots, knots, numPts, pts, numWeights, weights) {}
    
  protected:
    AxAValue CreateNewVal() { return NEW Point2Value; }
    
    void Copy(const AxAValue s, AxAValue& d) {
        Point2Value *src = (Point2Value *)s;
        Point2Value *& dst = (Point2Value *&)d;
        dst->x = src->x;
        dst->y = src->y;
    }
    
    void Add(const AxAValue val1, const AxAValue val2, AxAValue& result) {
        Point2Value *p1 = (Point2Value *)val1;
        Point2Value *p2 = (Point2Value *)val2;
        ((Point2Value *&)result)->x = p1->x + p2->x;
        ((Point2Value *&)result)->y = p1->y + p2->y;
    }
    
    void Mul(const AxAValue val, const Real scalar, AxAValue& result) {
        Point2Value *p = (Point2Value *)val;
        ((Point2Value *&)result)->x = p->x * scalar;
        ((Point2Value *&)result)->y = p->y * scalar;
    };
};

//////////  Point3 //////////

class Pt3Spline : public Spline {
  public:
    Pt3Spline(int degree,
              int numKnots, Real *knots,
              int numPts, AxAValue *pts,
              int numWeights, Real *weights) :
    Spline(degree, numKnots, knots, numPts, pts, numWeights, weights) {}
    
  protected:
    AxAValue CreateNewVal() { return NEW Point3Value; }
    
    void Copy(const AxAValue s, AxAValue& d) {
        Point3Value *src = (Point3Value *)s;
        Point3Value *& dst = (Point3Value *&)d;
        dst->x = src->x;
        dst->y = src->y;
        dst->z = src->z;
    }

    void Add(const AxAValue val1, const AxAValue val2, AxAValue& result) {
        Point3Value *p1 = (Point3Value *)val1;
        Point3Value *p2 = (Point3Value *)val2;
        ((Point3Value *&)result)->x = p1->x + p2->x;
        ((Point3Value *&)result)->y = p1->y + p2->y;
        ((Point3Value *&)result)->z = p1->z + p2->z;
    }
    
    void Mul(const AxAValue val, const Real scalar, AxAValue& result) {
        Point3Value *p = (Point3Value *)val;
        ((Point3Value *&)result)->x = p->x * scalar;
        ((Point3Value *&)result)->y = p->y * scalar;
        ((Point3Value *&)result)->z = p->z * scalar;
    };
};

//////////  Vector2 //////////

class Vec2Spline : public Spline {
  public:
    Vec2Spline(int degree,
               int numKnots, Real *knots,
               int numPts, AxAValue *pts,
               int numWeights, Real *weights) :
    Spline(degree, numKnots, knots, numPts, pts, numWeights, weights) {}
    
  protected:
    AxAValue CreateNewVal() { return NEW Vector2Value; }
    
    void Copy(const AxAValue s, AxAValue& d) {
        Vector2Value *src = (Vector2Value *)s;
        Vector2Value *& dst = (Vector2Value *&)d;
        dst->x = src->x;
        dst->y = src->y;
    }

    void Add(const AxAValue val1, const AxAValue val2, AxAValue& result) {
        Vector2Value *p1 = (Vector2Value *)val1;
        Vector2Value *p2 = (Vector2Value *)val2;
        ((Vector2Value *&)result)->x = p1->x + p2->x;
        ((Vector2Value *&)result)->y = p1->y + p2->y;
    }
    
    void Mul(const AxAValue val, const Real scalar, AxAValue& result) {
        Vector2Value *p = (Vector2Value *)val;
        ((Vector2Value *&)result)->x = p->x * scalar;
        ((Vector2Value *&)result)->y = p->y * scalar;
    };
};


//////////  Vector3 //////////

class Vec3Spline : public Spline {
  public:
    Vec3Spline(int degree,
               int numKnots, Real *knots,
               int numPts, AxAValue *pts,
               int numWeights, Real *weights) :
    Spline(degree, numKnots, knots, numPts, pts, numWeights, weights) {}
    
  protected:
    AxAValue CreateNewVal() { return NEW Vector3Value; }
    
    void Copy(const AxAValue s, AxAValue& d) {
        Vector3Value *src = (Vector3Value *)s;
        Vector3Value *& dst = (Vector3Value *&)d;
        dst->x = src->x;
        dst->y = src->y;
        dst->z = src->z;
    }

    void Add(const AxAValue val1, const AxAValue val2, AxAValue& result) {
        Vector3Value *p1 = (Vector3Value *)val1;
        Vector3Value *p2 = (Vector3Value *)val2;
        ((Vector3Value *&)result)->x = p1->x + p2->x;
        ((Vector3Value *&)result)->y = p1->y + p2->y;
        ((Vector3Value *&)result)->z = p1->z + p2->z;
    }
    
    void Mul(const AxAValue val, const Real scalar, AxAValue& result) {
        Vector3Value *p = (Vector3Value *)val;
        ((Vector3Value *&)result)->x = p->x * scalar;
        ((Vector3Value *&)result)->y = p->y * scalar;
        ((Vector3Value *&)result)->z = p->z * scalar;
    };
};

////////////////  Construction Functions  /////////////////


#define DEFINE_SPLINE_CONSTRUCTOR_FUNC(funcName, className) \
    Spline *                                       \
    funcName(int degree,                           \
             int numKnots, Real *knots,            \
             int numPts, AxAValue *pts,               \
             int numWeights, Real *weights)        \
    {                                              \
        return NEW className(degree,               \
                             numKnots, knots,      \
                             numPts, pts,          \
                             numWeights, weights); \
    }


DEFINE_SPLINE_CONSTRUCTOR_FUNC(NumberSpline, NumSpline);
DEFINE_SPLINE_CONSTRUCTOR_FUNC(Point2Spline, Pt2Spline);
DEFINE_SPLINE_CONSTRUCTOR_FUNC(Point3Spline, Pt3Spline);
DEFINE_SPLINE_CONSTRUCTOR_FUNC(Vector2Spline, Vec2Spline);
DEFINE_SPLINE_CONSTRUCTOR_FUNC(Vector3Spline, Vec3Spline);

//////////////  Construction from the untyped backend (calls more
/////////////   appropriately typed functions defined above.

typedef Spline *(*SplineConstructorFuncType)(int,
                                             int, Real *,
                                             int, AxAValue *,
                                             int, Real *);



static Spline *
buildSpline(int degree,
            long numKnots,
            long numPts,
            AxAValue *knotList,
            AxAValue *ptList,
            AxAValue *weightList,
            DXMTypeInfo tinfo)
{
    long i;

    Real *knots = (Real *)AllocateFromStore(numKnots * sizeof(Real));
    AxAValue *pts = (AxAValue *)AllocateFromStore(numPts * sizeof(AxAValue));
    
    for (i = 0; i < numKnots; i++) 
        knots[i] = ValNumber(knotList[i]);

    for (i = 0; i < numPts; i++) 
        pts[i] = ptList[i];

    AxAValue samplePt = pts[0];

    SplineConstructorFuncType constructorFunc;

    if (AxANumberType == tinfo) {
        constructorFunc = NumberSpline;
    } else if (Point2ValueType == tinfo) {
        constructorFunc = Point2Spline;
    } else if (Point3ValueType == tinfo) {
        constructorFunc = Point3Spline;
    } else if (Vector2ValueType == tinfo) {
        constructorFunc = Vector2Spline;
    } else if (Vector3ValueType == tinfo) {
        constructorFunc = Vector3Spline;
    } else {
        Assert(FALSE && "Shouldn't be here!!");
    }

    Spline *sp;
    
    if (weightList && (numPts > 0)) {
        
        int numWeights = numPts;
        Real *weights = (Real *)AllocateFromStore(numWeights * sizeof(Real));
        for (i = 0; i < numWeights; i++) 
            weights[i] = ValNumber(weightList[i]);
        
        sp = (*constructorFunc)(degree,
                                numKnots, knots,
                                numPts, pts,
                                numWeights, weights);

    } else {
        
        sp = (*constructorFunc)(degree,
                                numKnots, knots,
                                numPts, pts,
                                0, NULL);
    }

    return sp;
}

class SplinePerfImpl : public PerfImpl {
  public:
    SplinePerfImpl::SplinePerfImpl(TimeXform tt,
                                   Spline *spl,
                                   Perf evaluator,
                                   DXMTypeInfo tinfo);
    
    SplinePerfImpl::SplinePerfImpl(TimeXform tt,
                                   int degree,
                                   long k,
                                   long numPts,
                                   Perf *knotList,
                                   Perf *pointList,
                                   Perf *weightList,
                                   Perf evaluator,
                                   DXMTypeInfo tinfo);
    
    virtual AxAValue _Sample(Param& p);
    
    virtual void _DoKids(GCFuncObj proc) {
        long i;
        
        Assert(_evaluatorP && _tt && _tinfo);    // should always be there.
        
        (*proc)(_tt);

        (*proc)(_evaluatorP);

        if (_spl) _spl->DoKids(proc);

        if (_knotListP) 
            for (i=0; i<_k; i++)
                (*proc)(_knotListP[i]);

        for (i=0; i<_numPts; i ++) {
            if (_pointListP) (*proc)(_pointListP[i]);
            if (_weightListP) (*proc)(_weightListP[i]);
        }

        (*proc)(_tinfo);
        (*proc)(_spl);
    }

    virtual void CleanUp() {
    }

    virtual ~SplinePerfImpl() {
        CleanUp();
    }
    
#if _USE_PRINT
    virtual ostream& Print(ostream& os) { return os << "splineP"; }
#endif
    
  private:
    TimeXform        _tt;
    DXMTypeInfo _tinfo;
    Perf             *_knotListP;
    Perf             *_pointListP;
    Perf             *_weightListP;
    Perf             _evaluatorP;
    int              _degree;
    long             _k;
    long             _numPts;
    Spline *         _spl;
};

SplinePerfImpl::SplinePerfImpl(TimeXform tt,
                               Spline *spl,
                               Perf evaluator,
                               DXMTypeInfo tinfo)
: _tt(tt), _spl(spl), _evaluatorP(evaluator), _tinfo(tinfo),
  _k(0), _numPts(0), _degree(0),
  _knotListP(NULL), _pointListP(NULL), _weightListP(NULL)
{
}

SplinePerfImpl::SplinePerfImpl(TimeXform tt,
                               int degree,
                               long k,
                               long numPts,
                               Perf *knotList,
                               Perf *pointList,
                               Perf *weightList,
                               Perf evaluator,
                               DXMTypeInfo tinfo)
: _tt(tt), _spl(NULL), _evaluatorP(evaluator), _tinfo(tinfo),
  _degree(degree), _k(k), _numPts(numPts),
  _knotListP(knotList), _pointListP(pointList), _weightListP(weightList)
{
}

AxAValue
SplinePerfImpl::_Sample(Param& p) {

    Spline *splineToSample;

    // If we're constant, use the spline we've already constructed,
    // else create a NEW one from the sampled lists.
    if (_spl) {
        
        splineToSample = _spl;
        
    } else {

        AxAValue *kv =
            (AxAValue*) AllocateFromStore(_k * sizeof(AxAValue));
        AxAValue *pv =
            (AxAValue*) AllocateFromStore(_numPts * sizeof(AxAValue));
        AxAValue *wv = _weightListP ?
            (AxAValue*) AllocateFromStore(_numPts * sizeof(AxAValue))
            : NULL;

        long i;

        for (i=0; i<_k; i++) {
            kv[i] = _knotListP[i]->Sample(p);
            if (!kv[i])
                break;
        }

        for (i=0; i<_numPts; i ++) {
            pv[i] = _pointListP[i]->Sample(p);
            if (wv) wv[i] = _weightListP[i]->Sample(p);
        }

        splineToSample = 
            buildSpline(_degree, _k, _numPts, kv, pv, wv, _tinfo);
        
    }

    AxANumber *evalParam = (AxANumber *)(_evaluatorP->Sample(p));

    Real newT = NumberToReal(evalParam);

    // Finally, pass into spline evaluation.
    return splineToSample->Evaluate(newT);
}
    
//////////////////  Behavior  ////////////////////

class SplineBvrImpl : public BvrImpl {
  public:
    SplineBvrImpl(int degree,
                  long numPts,
                  Bvr *knotList,
                  Bvr *pointList,
                  Bvr *weightList,
                  Bvr evaluator,
                  DXMTypeInfo tinfo)
          : _degree(degree),
            _numPts(numPts),
            _knotList(knotList),
            _pointList(pointList),
            _weightList(weightList),
            _evaluator(evaluator),
            _tinfo(tinfo),
            _splineHeap(NULL) {
                _k = _numPts + _degree - 1;
                _spl = GetSpline();
                GetInfo(true);
    }

    ~SplineBvrImpl() { 
        Assert((!_spl || _splineHeap) &&
               "No spline heap before CleanUp, only CleanUp or Destructor should be called, not both.");
        CleanUp();
    }
    
    virtual void CleanUp() {
        {
            DynamicHeapPusher dph(GetSystemHeap());

            if (_knotList) DeallocateFromStore(_knotList);
            if (_pointList) DeallocateFromStore(_pointList);
            if (_weightList) DeallocateFromStore(_weightList);
        }

        if (_splineHeap) {
            // delete _splineHeap;
            _splineHeap = NULL;
        }
    }

    Spline *GetSpline() {
        Bool isConst = TRUE;

        AxAValue *kv, *pv, *wv;
        
        // Create a heap for data allocated during spline
        // construction.  Will be deleted upon destruction/cleanup. Or
        // if it's not a constant.
        _splineHeap = &TransientHeap("Spline Heap", 250);

        {
            DynamicHeapPusher dhp(*_splineHeap);

            kv = (AxAValue*) AllocateFromStore(_k * sizeof(AxAValue));
            pv = (AxAValue*) AllocateFromStore(_numPts * sizeof(AxAValue));
            wv = _weightList ?
                (AxAValue*) AllocateFromStore(_numPts * sizeof(AxAValue))
                : NULL;
                
            long i;

            for (i=0; i<_k; i++) {
                ConstParam cp;
                kv[i] = _knotList[i]->GetConst(cp);
                if (!kv[i]) {
                    isConst = FALSE;
                    break;
                }
            }

            if (isConst) {
                ConstParam cp;
                for (i=0; i<_numPts; i ++) {
                    pv[i] = _pointList[i]->GetConst(cp);
                    if (!pv[i]) {
                        isConst = FALSE;
                        break;
                    }
                    if (wv) {
                        wv[i] = _weightList[i]->GetConst(cp);
                        if (!wv[i]) {
                            isConst = FALSE;
                            break;
                        }
                    }
                }
            }
        }

        if (isConst) {
            DynamicHeapPusher dhp(*_splineHeap);
            
            return buildSpline(_degree, _k, _numPts, kv, pv, wv, _tinfo);
        } else {
            delete _splineHeap;
            _splineHeap = NULL;
        }

        return NULL;
    }

    virtual DWORD GetInfo(bool recalc) {
        if (recalc) {
            _info = _evaluator->GetInfo(recalc);

            long i;
        
            if (_knotList) {
                for (i=0; i<_k; i++)
                    _info &= _knotList[i]->GetInfo(recalc);
            }
        
            for (i=0; i<_numPts; i++) {
                if (_pointList)
                    _info &= _pointList[i]->GetInfo(recalc);
                if (_weightList)
                    _info &= _weightList[i]->GetInfo(recalc);
            }
        }

        return _info;
    }
    
    virtual Perf _Perform(PerfParam& p) {
        if (_spl)
            return
                NEW SplinePerfImpl(p._tt, _spl,
                                   ::Perform(_evaluator, p),
                                   _tinfo);
        else {
            Perf *kp, *pp, *wp;
            
            {
                DynamicHeapPusher dhp(GetSystemHeap());
                
                kp = (Perf *) AllocateFromStore(_k * sizeof(Perf));
                pp = (Perf *) AllocateFromStore(_numPts * sizeof(Perf));
                wp = _weightList ?
                    (Perf *) AllocateFromStore(_numPts * sizeof(Perf))
                    : NULL;
            }
            
            long i;

            for (i=0; i<_k; i++)
                kp[i] = ::Perform(_knotList[i], p);
            for (i=0; i<_numPts; i ++) {
                pp[i] = ::Perform(_pointList[i], p);
                if (wp)
                    wp[i] = ::Perform(_weightList[i], p);
            }

            return NEW SplinePerfImpl(p._tt, _degree, _k, _numPts,
                                      kp, pp, wp, 
                                      ::Perform(_evaluator, p),
                                      _tinfo);
        }
    }

    virtual void _DoKids(GCFuncObj proc) {
        long i;
        
        if (_knotList) 
            for (i=0; i<_k; i++)
                (*proc)(_knotList[i]);
        
        for (i=0; i<_numPts; i++) {
            if (_pointList) (*proc)(_pointList[i]);
            if (_weightList) (*proc)(_weightList[i]);
        }
        
        if (_evaluator) (*proc)(_evaluator);

        if (_spl) (*proc)(_spl);
        (*proc)(_tinfo);
    }
        
#if _USE_PRINT
    virtual ostream& Print(ostream& os) { return os << "splinebvr"; }
#endif

    virtual DXMTypeInfo GetTypeInfo () { return _tinfo; }

  protected:
    int _degree;
    long _numPts;
    long _k;
    Bvr *_knotList;
    Bvr *_pointList;
    Bvr *_weightList;
    Bvr _evaluator;
    DXMTypeInfo _tinfo;
    Spline          *_spl;
    DynamicHeap     *_splineHeap;
    DWORD _info;
};


Bvr ConstructBSplineBvr(int degree,
                        long numPts,
                        Bvr *knots,
                        Bvr *points,
                        Bvr *weights,
                        Bvr evaluator,
                        DXMTypeInfo tinfo)
{
    return NEW SplineBvrImpl(degree,
                             numPts,
                             knots,
                             points,
                             weights,
                             evaluator,
                             tinfo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\values\misc\vecutil.cpp ===
/*++

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Noninline definitions of vector util functions

--*/

#include "headers.h"
#include "appelles/common.h"
#include "privinc/vecutil.h"
#include <math.h>

const Real BIGNUM = 1.0e10;

ApuVector3 apuXAxis3 = {1.0, 0.0, 0.0};
ApuVector3 apuYAxis3 = {0.0, 1.0, 0.0};
ApuVector3 apuZAxis3 = {0.0, 0.0, 1.0};
ApuVector3 apuZero3 = {0.0, 0.0, 0.0};

ApuBbox3 apuNegativeBbox3 = {{BIGNUM, BIGNUM, BIGNUM},
                             {-BIGNUM, -BIGNUM, -BIGNUM}};
ApuBbox3 apuUnitCubeBbox3 = {{0.0, 0.0, 0.0}, {1.0, 1.0, 1.0}};
ApuBbox3 apuTwoUnitCubeBbox3 = {{-1.0, -1.0, -1.0}, {1.0, 1.0, 1.0}};

static inline void
setmax(Real& current_value, Real new_value)
{
  if (new_value > current_value) current_value = new_value;
}

static inline void
setmin(Real& current_value, Real new_value)
{
  if (new_value < current_value) current_value = new_value;
}

void
ApuBbox3::augment(Real x, Real y, Real z)
{
  setmin(min.xyz[0], x);
  setmin(min.xyz[1], y);
  setmin(min.xyz[2], z);

  setmax(max.xyz[0], x);
  setmax(max.xyz[1], y);
  setmax(max.xyz[2], z);
}

void
ApuBbox3::center(ApuVector3& result) const
{
  result.xyz[0] = (max.xyz[0] - min.xyz[0]) / 2.0;
  result.xyz[1] = (max.xyz[1] - min.xyz[1]) / 2.0;
  result.xyz[2] = (max.xyz[2] - min.xyz[2]) / 2.0;
}

Bool
ApuEpsEq(Real value1, Real value2, Real epsilon)
{
  Real diff = value1 - value2;
  return -epsilon <= diff && diff < epsilon;
}

Real
ApuVector3::Length() const
{
  return sqrt(xyz[0] * xyz[0] + xyz[1] * xyz[1] + xyz[2] * xyz[2]);
}

Real
ApuVector3::LengthSquared() const
{
  return xyz[0] * xyz[0] + xyz[1] * xyz[1] + xyz[2] * xyz[2];
}

void
ApuVector3::Normalize()
{
  Real len =  sqrt(xyz[0] * xyz[0] + xyz[1] * xyz[1] + xyz[2] * xyz[2]);

  if (len == 0.0) return;

  xyz[0] /= len;
  xyz[1] /= len;
  xyz[2] /= len;
}

void
ApuVector3::operator+=(const ApuVector3& rhs)
{
 xyz[0] += rhs.xyz[0];
 xyz[1] += rhs.xyz[1];
 xyz[2] += rhs.xyz[2];
}

void
ApuVector3::operator-=(const ApuVector3& rhs)
{
 xyz[0] -= rhs.xyz[0];
 xyz[1] -= rhs.xyz[1];
 xyz[2] -= rhs.xyz[2];
}

void
ApuVector3::operator*=(Real rhs)
{
 xyz[0] *= rhs;
 xyz[1] *= rhs;
 xyz[2] *= rhs;
}

void
ApuVector3::operator/=(Real rhs)
{
 xyz[0] /= rhs;
 xyz[1] /= rhs;
 xyz[2] /= rhs;
}

void
ApuVector3::Negate()
{
 xyz[0] -= xyz[0];
 xyz[1] -= xyz[1];
 xyz[2] -= xyz[2];
}

void
ApuVector3::Zero()
{
 xyz[0] = - xyz[0];
 xyz[1] = - xyz[1];
 xyz[2] = - xyz[2];
}

Bool
ApuEpsEq(const ApuVector3& v1, const ApuVector3& v2,
         Real epsilon)
{
  return ApuEpsEq(v1.xyz[0], v2.xyz[0], epsilon) &&
         ApuEpsEq(v1.xyz[1], v2.xyz[1], epsilon) &&
         ApuEpsEq(v1.xyz[2], v2.xyz[2], epsilon);
}

Real
ApuDot(const ApuVector3& v1, const ApuVector3& v2)
{
 return v1.xyz[0] * v2.xyz[0] + v1.xyz[1] * v2.xyz[1] + v1.xyz[2] * v2.xyz[2];
}

Real
ApuDistance(const ApuVector3& v1, const ApuVector3& v2)
{
  ApuVector3 tmp = v2;
  tmp -= v1;
  return tmp.Length();
}


Real
ApuDistanceSquared(const ApuVector3& v1, const ApuVector3& v2)
{
  ApuVector3 tmp = v2;
  tmp -= v1;
  return tmp.LengthSquared();
}

void
ApuCross(const ApuVector3& v1, const ApuVector3& v2, ApuVector3& result)
{
  result.xyz[0] = v1.Y() * v2.Z() - v1.Z() * v2.Y();
  result.xyz[1] = v1.Z() * v2.X() - v1.X() * v2.Z();
  result.xyz[2] = v1.X() * v2.Y() - v1.Y() * v2.X();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\values\misc\vec3.cpp ===
/*******************************************************************************
Copyright (c) 1995-1998  Microsoft Corporation

    Implementation of 3D vectors and points.

*******************************************************************************/

#include "headers.h"
#include "appelles/vec3.h"
#include "appelles/xform.h"
#include "privinc/vec3i.h"
#include "privinc/vecutil.h"
#include "privinc/xformi.h"
#include "privinc/basic.h"


    /*******************/
    /***  Constants  ***/
    /*******************/

Vector3Value *xVector3    = NULL;
Vector3Value *yVector3    = NULL;
Vector3Value *zVector3    = NULL;
Vector3Value *zeroVector3 = NULL;

Point3Value *origin3 = NULL;



/*****************************************************************************
Vector Methods
*****************************************************************************/

bool Vector3Value::operator== (Vector3Value &other)
{   return (x==other.x) && (y==other.y) && (z==other.z);
}


Vector3Value& Vector3Value::operator*= (Real s)
{   x *= s;
    y *= s;
    z *= s;
    return *this;
}


Real Vector3Value::LengthSquared (void)
{   return (x*x + y*y + z*z);
}


void Vector3Value::Transform (Transform3 *transform)
{
    const Apu4x4Matrix &matrix = transform->Matrix();
    ApuVector3 vec, result;

    vec.Set (x, y, z);

    matrix.ApplyAsVector (vec, result);

    x = result[0];
    y = result[1];
    z = result[2];
}


Vector3Value& Vector3Value::Normalize (void)
{
    if ((x != 0) || (y != 0) || (z != 0))
        *this *= (1/Length());

    return *this;
}



/*****************************************************************************
Vector3 Operators
*****************************************************************************/

Vector3Value operator+ (Vector3Value &A, Vector3Value &B)
{   return Vector3Value (A.x + B.x, A.y + B.y, A.z + B.z);
}


Vector3Value operator- (Vector3Value &A, Vector3Value &B)
{   return Vector3Value (A.x - B.x, A.y - B.y, A.z - B.z);
}


Vector3Value operator- (Vector3Value &V)
{   return Vector3Value (-V.x, -V.y, -V.z);
}


Vector3Value operator* (Real s, Vector3Value &V)
{   return Vector3Value (s * V.x, s * V.y, s * V.z);
}

Vector3Value operator* (Transform3 &T, Vector3Value &V)
{
    ApuVector3 vec, result;

    vec.Set (V.x, V.y, V.z);

    T.Matrix().ApplyAsVector (vec, result);

    return Vector3Value(result[0], result[1], result[2]);
}


/*****************************************************************************
Point Methods
*****************************************************************************/

bool Point3Value::operator== (Point3Value &other)
{   return (x==other.x) && (y==other.y) && (z==other.z);
}


void Point3Value::Transform (Transform3 *transform)
{
    const Apu4x4Matrix& matrix = transform->Matrix();
    ApuVector3 vec, result;

    vec.Set (x, y, z);

    matrix.ApplyAsPoint (vec, result);

    x = result[0];
    y = result[1];
    z = result[2];
}


ClipCode Point3Value::Clip(Plane3 &plane)
{
    if (Dot(plane.N,*(AsVector(*this))) + plane.d >= 0)
        return CLIPCODE_IN;
    else
        return CLIPCODE_OUT;
}



/*****************************************************************************
Point Operators
*****************************************************************************/


Real DistanceSquared (Point3Value &P, Point3Value &Q)
{
    Real dx = P.x - Q.x,
         dy = P.y - Q.y,
         dz = P.z - Q.z;

    return dx*dx + dy*dy + dz*dz;
}


Point3Value operator* (Transform3 &T, Point3Value &P)
{
    ApuVector3 pt, result;

    pt.Set (P.x, P.y, P.z);

    T.Matrix().ApplyAsPoint (pt, result);

    return Point3Value (result[0], result[1], result[2]);
}



/*****************************************************************************
Point/Vector Operators
*****************************************************************************/

Vector3Value operator- (Point3Value &P, Point3Value &Q)
{   return Vector3Value (P.x - Q.x, P.y - Q.y, P.z - Q.z);
}


Point3Value operator+ (Point3Value &P, Vector3Value &V)
{   return Point3Value (P.x + V.x, P.y + V.y, P.z + V.z);
}


Point3Value operator- (Point3Value &P, Vector3Value &V)
{   return Point3Value (P.x - V.x, P.y - V.y, P.z - V.z);
}



/*****************************************************************************
This routine computes the cross product of the two vectors and stores the
result in the destination vector.  It properly handles the case where one of
the source vectors is also a destination vector.
*****************************************************************************/

void Cross (Vector3Value &dest, Vector3Value &A, Vector3Value &B)
{
    Real x = (A.y * B.z) - (B.y * A.z);
    Real y = (A.z * B.x) - (B.z * A.x);
    Real z = (A.x * B.y) - (B.x * A.y);

    dest.Set (x,y,z);
}



/*****************************************************************************
This function returns the vector result of a cross product.
*****************************************************************************/

Vector3Value Cross (Vector3Value &A, Vector3Value &B)
{
    return Vector3Value ((A.y * B.z) - (A.z * B.y),
                         (A.z * B.x) - (A.x * B.z),
                         (A.x * B.y) - (A.y * B.x));
}



/*****************************************************************************
Return the dot product of the two vectors.
*****************************************************************************/

Real Dot (Vector3Value &A, Vector3Value &B)
{
    return (A.x * B.x) + (A.y * B.y) + (A.z * B.z);
}



/*****************************************************************************
Return the acute angle between two vectors.
*****************************************************************************/

Real AngleBetween (Vector3Value &A, Vector3Value &B)
{   return acos(Dot(A,B) / (A.Length() * B.Length()));
}



/*****************************************************************************
Convert polar coordinates to rectangular coordinates.  The azimuthal angle
begins at the +Z ray, and sweeps counter-clockwise about the +Y axis.  The
elevation angle begins in the XZ plane, and sweeps up toward the +Y axis.
*****************************************************************************/

static void PolarToRectangular (
    Real azimuth,                 // Rotation Around +Y (Radians) From +Z
    Real elevation,               // Rotation Up From XZ Plane Towards +Y
    Real radius,                  // Distance From Origin
    Real &x, Real &y, Real &z)    // Output Rectangular Coordinates
{
    Real XZradius = radius * cos(elevation);

    x = XZradius * sin(azimuth);
    y =   radius * sin(elevation);
    z = XZradius * cos(azimuth);
}



/*****************************************************************************
These functions return the polar coordinates of the given Cartesian
coordinate.
*****************************************************************************/

static Real RadiusCoord (Real x, Real y, Real z)
{   return sqrt (x*x + y*y + z*z);
}

static Real ElevationCoord (Real x, Real y, Real z)
{   return asin (y / RadiusCoord (x,y,z));
}

static Real AzimuthCoord (Real x, Real y, Real z)
{   return atan2 (x, z);
}



/*****************************************************************************
These create Vector3's from Cartesian or polar coordinates.
*****************************************************************************/

Vector3Value *XyzVector3 (AxANumber *x, AxANumber *y, AxANumber *z)
{   return NEW Vector3Value(NumberToReal(x), NumberToReal(y), NumberToReal(z));
}

Vector3Value *XyzVector3RRR (Real x, Real y, Real z)
{   return NEW Vector3Value(x, y, z);
}

Vector3Value *SphericalVector3 (
    AxANumber *azimuth,     // Angle about +Y, starting at +Z
    AxANumber *elevation,   // Angle up from XZ plane towards +Y
    AxANumber *radius)      // Vector Length
{
    return SphericalVector3RRR(NumberToReal(azimuth), NumberToReal(elevation), NumberToReal(radius));
}

Vector3Value *SphericalVector3RRR (
    Real azimuth,     // Angle about +Y, starting at +Z
    Real elevation,   // Angle up from XZ plane towards +Y
    Real radius)      // Vector Length
{
    Real x,y,z;

    PolarToRectangular
    (   azimuth, elevation, radius,
        x, y, z
    );

    return NEW Vector3Value(x, y, z);
}



/*****************************************************************************
These functions return the length and length squared of a vector.
*****************************************************************************/

AxANumber *LengthVector3 (Vector3Value *v)
{   return RealToNumber (v->Length());
}


AxANumber *LengthSquaredVector3 (Vector3Value *v)
{   return RealToNumber (v->LengthSquared());
}



/*****************************************************************************
This procedure returns a unit vector in the same direction as the given one.
*****************************************************************************/

Vector3Value *NormalVector3 (Vector3Value *v)
{   Vector3Value *N = NEW Vector3Value (*v);
    return &(N->Normalize());
}



/*****************************************************************************
Return the dot and cross product of two vectors.
*****************************************************************************/

AxANumber *DotVector3Vector3 (Vector3Value *A, Vector3Value *B)
{   return RealToNumber (Dot(*A,*B));
}


Vector3Value *CrossVector3Vector3 (Vector3Value *A, Vector3Value *B)
{   Vector3Value *V = NEW Vector3Value;
    Cross (*V, *A, *B);
    return V;
}


Vector3Value *NegateVector3 (Vector3Value *v)
{   return NEW Vector3Value (-(*v));
}


Vector3Value *ScaleVector3Real (Vector3Value *V, AxANumber *scalar)
{   return ScaleRealVector3R(NumberToReal(scalar),V);
}


Vector3Value *ScaleRealVector3 (AxANumber *scalar, Vector3Value *V)
{   return ScaleRealVector3R(NumberToReal(scalar),V);
}

Vector3Value *ScaleRealVector3R (Real scalar, Vector3Value *V)
{   return NEW Vector3Value (scalar * (*V));
}

Vector3Value *DivideVector3Real (Vector3Value *V, AxANumber *scalar)
{   return DivideVector3RealR (V, NumberToReal(scalar));
}

Vector3Value *DivideVector3RealR (Vector3Value *V, Real scalar)
{   return NEW Vector3Value ((1/scalar) * (*V));
}

Vector3Value *MinusVector3Vector3 (Vector3Value *A, Vector3Value *B)
{   return NEW Vector3Value (*A - *B);
}


Vector3Value *PlusVector3Vector3 (Vector3Value *A, Vector3Value *B)
{   return NEW Vector3Value (*A + *B);
}


AxANumber *AngleBetween (Vector3Value *A, Vector3Value *B)
{   return RealToNumber (AngleBetween (*A, *B));
}


#if _USE_PRINT
ostream& operator<< (ostream& os, Vector3Value& v)
{   return os << "<" << v.x << ", " << v.y << "," << v.z << ">";
}
#endif



////////  Functions on Points  /////////////

Point3Value* XyzPoint3 (AxANumber *x, AxANumber *y, AxANumber *z)
{   return NEW Point3Value(NumberToReal(x), NumberToReal(y), NumberToReal(z));
}

Point3Value* XyzPoint3RRR (Real x, Real y, Real z)
{   return NEW Point3Value(x, y, z);
}


Point3Value *SphericalPoint3 (
    AxANumber *azimuth,     // Angle About +Y, Starting At +Z
    AxANumber *elevation,   // Angle Up From XZ Plane Towards +Y
    AxANumber *radius)      // Distance From Origin
{
    return SphericalPoint3RRR(NumberToReal(azimuth), NumberToReal(elevation), NumberToReal(radius));
}

Point3Value *SphericalPoint3RRR (
    Real azimuth,     // Angle About +Y, Starting At +Z
    Real elevation,   // Angle Up From XZ Plane Towards +Y
    Real radius)      // Distance From Origin
{
    Real x,y,z;

    PolarToRectangular
    (   azimuth, elevation, radius,
        x, y, z
    );

    return NEW Point3Value (x, y, z);
}


Vector3Value *MinusPoint3Point3 (Point3Value *P, Point3Value *Q)
{   return NEW Vector3Value (*P - *Q);
}


Point3Value *PlusPoint3Vector3 (Point3Value *P, Vector3Value *V)
{   return NEW Point3Value (*P + *V);
}


Point3Value *MinusPoint3Vector3 (Point3Value *P, Vector3Value *V)
{   return NEW Point3Value (*P - *V);
}


AxANumber *DistancePoint3Point3 (Point3Value *P, Point3Value *Q)
{   return RealToNumber (Distance (*P, *Q));
}


Real RDistancePoint3Point3 (Point3Value *P, Point3Value *Q)
{   return Distance (*P, *Q);
}


AxANumber *DistanceSquaredPoint3Point3 (Point3Value *P, Point3Value *Q)
{   return RealToNumber (DistanceSquared (*P, *Q));
}


#if _USE_PRINT
ostream& operator<< (ostream& os, Point3Value& p)
{   return os << "<" << p.x << ", " << p.y << "," << p.z << ">";
}
#endif



/*****************************************************************************
Return a NEW vector that is the transformed given vector.
*****************************************************************************/

Vector3Value *TransformVec3 (Transform3 *transform, Vector3Value *vec)
{
    Vector3Value *result = NEW Vector3Value (*vec);
    result->Transform (transform);
    return result;
}

Point3Value *TransformPoint3 (Transform3 *transform, Point3Value *point)
{
    Point3Value *result = NEW Point3Value (*point);
    result->Transform (transform);
    return result;
}


//////////////  Extractors  ////////////

AxANumber *XCoordVector3(Vector3Value *v) { return RealToNumber(v->x); }
AxANumber *YCoordVector3(Vector3Value *v) { return RealToNumber(v->y); }
AxANumber *ZCoordVector3(Vector3Value *v) { return RealToNumber(v->z); }

AxANumber *XCoordPoint3(Point3Value *p) { return RealToNumber(p->x); }
AxANumber *YCoordPoint3(Point3Value *p) { return RealToNumber(p->y); }
AxANumber *ZCoordPoint3(Point3Value *p) { return RealToNumber(p->z); }

AxANumber *RhoCoordVector3 (Vector3Value *p)
{   return RealToNumber(RadiusCoord(p->x,p->y,p->z));
}

AxANumber *ThetaCoordVector3 (Vector3Value *p)
{   return RealToNumber(AzimuthCoord(p->x,p->y,p->z));
}

AxANumber *PhiCoordVector3 (Vector3Value *p)
{   return RealToNumber(ElevationCoord(p->x,p->y,p->z));
}

AxANumber *RhoCoordPoint3 (Point3Value *p)
{   return RealToNumber(RadiusCoord(p->x,p->y,p->z));
}

AxANumber *ThetaCoordPoint3 (Point3Value *p)
{   return RealToNumber(AzimuthCoord(p->x,p->y,p->z));
}

AxANumber *PhiCoordPoint3 (Point3Value *p)
{   return RealToNumber(ElevationCoord(p->x,p->y,p->z));
}

void
InitializeModule_Vec3()
{
    xVector3    = NEW Vector3Value (1,0,0);
    yVector3    = NEW Vector3Value (0,1,0);
    zVector3    = NEW Vector3Value (0,0,1);
    zeroVector3 = NEW Vector3Value (0,0,0);

    origin3 = NEW Point3Value (0,0,0);
}



/*****************************************************************************
This function transforms the Ray3 object by the given transform.
*****************************************************************************/

void Ray3::Transform (Transform3 *xform)
{
    orig.Transform (xform);
    dir.Transform (xform);
}



/*****************************************************************************
The evaluation function for a ray returns the point at P + tD.
*****************************************************************************/

Point3Value Ray3::Evaluate (Real t)
{
    return orig + (t * dir);
}



/*****************************************************************************
This function transforms a plane by a Transform3.
*****************************************************************************/

Plane3& Plane3::operator*= (Transform3 *T)
{
    Real R[4];   // Resulting Plane

    // To transform a plane, treat the four components as a row-vector, and
    // multiply by the inverse of the transform matrix.

    bool ok =  T->Matrix().TransformPlane (N.x, N.y, N.z, d, R);

    if (!ok) {
        TraceTag ((tagWarning, "Singular transform applied to Plane3 object."));

        // If we can't apply the transform, then ignore it.

        R[0] = N.x;
        R[1] = N.y;
        R[2] = N.z;
        R[3] = d;
    }

    N.x = R[0];
    N.y = R[1];
    N.z = R[2];
    d   = R[3];

    return *this;
}



/*****************************************************************************
This function normalizes the plane so that the normal vector is unit length.
*****************************************************************************/

Plane3& Plane3::Normalize (void)
{
    Real recip_len = 1 / N.Length();
    N *= recip_len;
    d *= recip_len;

    return *this;
}



/*****************************************************************************
This method returns the plane normal vector (arbitrary length).
*****************************************************************************/

Vector3Value Plane3::Normal (void)
{
    return Vector3Value (N);
}



/*****************************************************************************
This method returns the point on the given plane nearest the origin.
*****************************************************************************/

Point3Value Plane3::Point (void)
{
    Real scale = -d / N.LengthSquared();
    return Point3Value (scale*N.x, scale*N.y, scale*N.z);
}



/*****************************************************************************
This function returns the signed distance from the plane to the given point. 
If the sign is positive, then the point lies on the same side of the plane as
the plane normal.  If the distance is zero, the point lies on the plane.
*****************************************************************************/

Real Distance (Plane3 &plane, Point3Value &Q)
{
    Plane3 P (plane);

    P.Normalize();

    return (P.N.x * Q.x) + (P.N.y * Q.y) + (P.N.z * Q.z) + P.d;
}



/*****************************************************************************
This function returns the ray parameter for the intersection between the ray
and a plane.  If the ray is parallel to the plane, then this function returns
infinity.
*****************************************************************************/

Real Intersect (Ray3 &ray, Plane3 &plane)
{
    Real denom = Dot (plane.N, ray.Direction());

    if (fabs(denom) < 1e-6)
        return HUGE_VAL;

    return (-Dot(plane.N, *AsVector(ray.Origin())) - plane.d) / denom;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\values\misc\xform2.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Implementation of 2D transformations

*******************************************************************************/

#include "headers.h"
#include "privinc/vec2i.h"
#include "privinc/xform2i.h"
#include "privinc/xformi.h"
#include "privinc/matutil.h"
#include "privinc/util.h"
#include "privinc/except.h"
#include "privinc/basic.h"
#include "backend/values.h"
#include "privinc/dddevice.h"  // need Real2Pix function for 
                               // TransformPointsToGDISpace


#include <math.h>

#define A00  m[0]
#define A01  m[1]
#define A02  m[2]
#define A10  m[3]
#define A11  m[4]
#define A12  m[5]


bool
Transform2::SwitchToNumbers(Xform2Type typeOfNewNumbers,
                            Real      *numbers)
{
    return false;
}

//--------------------------------------------------
//   Identity
//--------------------------------------------------

class IdentityXform2 : public Transform2 {
  public:
#if _USE_PRINT
    ostream& Print(ostream& os) {
        return os << "identityTransform2";
    }
#endif
    Xform2Type Type() { return Identity;}
    void GetMatrix(Real m[6]) {A00=A11=1.0; A01=A02=A10=A12=0;}

    Transform2 *Copy() { return identityTransform2; }
};

Transform2 *identityTransform2 = NULL;


//--------------------------------------------------
// 2x3 Affine Translation Transformation
//--------------------------------------------------
class TranslationXform2 : public Transform2 {
  public:
    TranslationXform2(Real x, Real y, bool pixelMode) :
        tx(x), ty(y), _pixelMode(pixelMode) {}
    
#if _USE_PRINT
    ostream& Print(ostream& os) {
        os << "TranslationTransform2(";
        return os << tx << "," << ty << "," << _pixelMode << ")";
    }
#endif
    
    Xform2Type Type() { return Translation;}
    void GetMatrix(Real m[6]) {A00=A11=1.0; A01=A10=0; A02=tx; A12=ty;}

    Transform2 *Copy() { return NEW TranslationXform2(tx,ty,_pixelMode); }

    bool SwitchToNumbers(Xform2Type theType,
                         Real      *numbers) {
        
        if (theType != Xform2Type::Translation) { return false; }

        tx = numbers[0];
        ty = numbers[1];
        if (_pixelMode) {
            tx = ::PixelToNum(tx);
            ty = ::PixelYToNum(ty);
        }

        return true;
    }

    Real tx, ty;
    bool _pixelMode;
};

//--------------------------------------------------
// 2x3 Affine Scale Transformation
//--------------------------------------------------
class ScaleXform2 : public Transform2 {
  public:
    ScaleXform2(Real x, Real y) : sx(x), sy(y) {}
#if _USE_PRINT
    ostream& Print(ostream& os) {
        return os << "ScaleTransform2(" << sx << "," << sy << ")";
    }
#endif
    Xform2Type Type() { return Scale;}
    void GetMatrix(Real m[6]) {A00=sx; A11=sy; A01=A10=A02=A12=0;}

    Transform2 *Copy() { return NEW ScaleXform2(sx,sy); }

    bool SwitchToNumbers(Xform2Type ty,
                         Real      *numbers) {
        
        if (ty != Xform2Type::Scale) { return false; }

        sx = numbers[0];
        sy = numbers[1];

        return true;
    }
    
    Real sx, sy;
};


//--------------------------------------------------
// 2x3 Affine Shear Transformation
//--------------------------------------------------
class ShearXform2 : public Transform2 {
  public:
    ShearXform2(Real x, Real y) : shx(x), shy(y) {}
#if _USE_PRINT
    ostream& Print(ostream& os) {
        return os << "ShearTransform2(" << shx << "," << shy << ")";
    }
#endif
    Xform2Type Type() { return Shear;}
    void GetMatrix(Real m[6]) {A00=A11=1.0; A10=shx; A01=shy; A02=A12=0;}

    Transform2 *Copy() { return NEW ShearXform2(shx,shy); }

    Real shx, shy;              // a01, a10
};

//--------------------------------------------------
// 2x3 Affine Rotation Transformation
//--------------------------------------------------
class RotationXform2 : public Transform2 {
  public:
    RotationXform2(Real _a00, Real _a01,
                   Real _a10, Real _a11) :
      a00(_a00), a01(_a01),
      a10(_a10), a11(_a11) {}
#if _USE_PRINT
    ostream& Print(ostream& os) {
        os << "RotationTransform2(";
        return os << a00 << "," << a01 << "," << a10 << "," << a11 << ")";
        }
#endif
    Xform2Type Type() { return Rotation;}
    void GetMatrix(Real m[6]) {A00=a00; A01=a01; A10=a10; A11=a11; A02=A12=0;}

    Transform2 *Copy() {
        return NEW RotationXform2(a00,a01,a10,a11);
    }

    bool SwitchToNumbers(Xform2Type ty,
                         Real      *numbers) {
        
        if (ty != Xform2Type::Rotation) { return false; }

        Real angInRadians = numbers[0] * degToRad;
        Real cost = cos(angInRadians);
        Real sint = sin(angInRadians);
        a00 = cost;
        a01 = -sint;
        a10 = sint;
        a11 = cost;
            
        return true;
    }
    
    Real a00, a01, a10, a11;
};

//--------------------------------------------------
// 2x3 Affine TwoByTwo Transformation
//--------------------------------------------------
class TwoByTwoXform2 : public Transform2 {
  public:
    TwoByTwoXform2(Real _a00, Real _a01,
                   Real _a10, Real _a11) :
      a00(_a00), a01(_a01),
      a10(_a10), a11(_a11) {}
#if _USE_PRINT
    ostream& Print(ostream& os) {
        os << "TwoByTwoTransform2(";
        return os << a00 << "," << a01 << "," << a10 << "," << a11 << ")";
    }
#endif
    Xform2Type Type() { return TwoByTwo;}
    void GetMatrix(Real m[6]) {A00=a00; A01=a01; A10=a10; A11=a11; A02=A12=0;}

    Transform2 *Copy() {
        return NEW TwoByTwoXform2(a00,a01,a10,a11);
    }

    Real a00, a01, a10, a11;
};

//--------------------------------------------------
// 2x3 Affine (Full) Transformation
//--------------------------------------------------
class FullXform2 : public Transform2 {
  public:
    FullXform2(Real _a00, Real _a01, Real _a02,
               Real _a10, Real _a11, Real _a12) :
               a00(_a00), a01(_a01), a02(_a02),
               a10(_a10), a11(_a11), a12(_a12) {}
#if _USE_PRINT
    ostream& Print(ostream& os) {
        os << "FullTransform2(";
        return os << a00 << "," << a01 << "," << a02 << "," 
                  << a10 << "," << a11 << "," << a12 << ")";
    }
#endif
    Xform2Type Type() {return Full;}
    void GetMatrix(Real m[6]) {A00=a00; A01=a01; A02=a02;
                               A10=a10; A11=a11; A12=a12;}

    Transform2 *Copy() {
        return NEW FullXform2(a00,a01,a02,a10,a11,a12);
    }

    Real a00, a01, a02,
         a10, a11, a12;
};

#undef A00
#undef A01
#undef A02
#undef A10
#undef A11
#undef A12

// ------------------------------------------------------------
// Utility Functions
// ------------------------------------------------------------

// This function takes a 3D (non-perspective) transform, and returns a 2D
// transform that mimics an orthographic view using the 3D transform.  In
// other words, it allows one to apply a virtual 3D transform to a 2D object.

Transform2 *ParallelTransform2(Transform3 *xform)
{
    // Extract out the first, second, and fourth columns.  We transform vectors
    // to extract the first and second columns, since vectors are unaffected
    // by translation components of a transform.
    
    Apu4x4Matrix mx = xform->Matrix();   
    // Construct the 2x3 transform2 from the 3D matrix elements.
    return NEW
        FullXform2(mx[0][0], mx[0][1], mx[0][3],
                   mx[1][0], mx[1][1], mx[1][3]);
}

// ------------------------------------------------------------
// Local Utility Functions
// ------------------------------------------------------------
inline Bool IsZero(Real n)
{
#define EPSILON  1.e-80
    return ((-EPSILON < n) && (n < EPSILON) ? TRUE : FALSE);
#undef EPSILON
}

// ------------------------------------------------------------
// External Constructor/Accessor Functions
// ------------------------------------------------------------

Transform2 *TranslateRRWithMode(Real tx, Real ty, bool pixelMode)
{
    if (IsZero(tx) && IsZero(ty)) {
        return identityTransform2;
    }
    
    return NEW TranslationXform2(tx, ty, pixelMode);
}

Transform2 *TranslateRR(Real tx, Real ty)
{ return TranslateRRWithMode(tx, ty, false); }

    // Translation

Transform2 *TranslateRealReal (AxANumber *Tx, AxANumber *Ty)
{
    return TranslateRR(NumberToReal(Tx),NumberToReal(Ty));
}

Transform2 *TranslateVector2Value (Vector2Value *delta)
{
    return TranslateRR(delta->x, delta->y);
}

Transform2 *Translate2PointValue(Point2Value *pos)
{
    return TranslateRR(pos->x, pos->y);
}

Transform2 * ScaleRR(Real x, Real y)
{
    if (IsZero(x - 1.0) && IsZero(y - 1.0)) {
        return identityTransform2;
    }
    
    return NEW ScaleXform2(x, y);
}

    // Scaling

Transform2 *ScaleRealReal (AxANumber *x, AxANumber *y)
{
    return ScaleRR(NumberToReal(x), NumberToReal(y));
}

Transform2 *ScaleVector2Value (Vector2Value *scale_vec)
{
    return ScaleRR(scale_vec->x, scale_vec->y);
}

// Need to disambiguate from Scale(Real) that returns a 3D transform.
Transform2 *Scale2 (AxANumber *uniform_scale)
{
    return ScaleRR(NumberToReal(uniform_scale),
                   NumberToReal(uniform_scale));
}

    // Rotation (around implicit Z)

Transform2 *Rotate2Radians(Real angle)
{
    if (IsZero(angle)) {
        return identityTransform2;
    }
    
    Real cost = cos(angle);
    Real sint = sin(angle);
    return NEW RotationXform2(cost, - sint, sint, cost);
}

Transform2 *RotateReal(AxANumber *angle)
{
    return Rotate2Radians(NumberToReal(angle));
}

Transform2 *RotateRealR(Real angle)
{
    return Rotate2Radians(angle);
}

    // Shear transformation

Transform2 *XShear2R (Real xAmt)
{
    if (IsZero(xAmt)) {
        return identityTransform2;
    }

    return NEW ShearXform2(xAmt, 0);
}

Transform2 *YShear2R (Real yAmt)
{
    if (IsZero(yAmt)) {
        return identityTransform2;
    }

    return NEW ShearXform2(0, yAmt);
}

Transform2 *XShear2 (AxANumber *xAmt)
{
    return XShear2R(NumberToReal(xAmt));
}

Transform2 *YShear2 (AxANumber *yAmt)
{
    return YShear2R(NumberToReal(yAmt));
}

    // 2x3 affine matrix transformation.  This follows the
    // pre-multiply conventions
    // (point is a column vector) in Foley & van Dam, 2nd ed.  This
    // means that (a13,a23) in a 2x3 is the translation component.

Transform2 *MatrixTransform(AxAArray *a)
{
    if (a->Length() != 6)
        RaiseException_UserError(E_FAIL, IDS_ERR_MATRIX_NUM_ELEMENTS);
    
    return NEW
        FullXform2(ValNumber((*a)[0]), ValNumber((*a)[1]), ValNumber((*a)[2]),
                   ValNumber((*a)[3]), ValNumber((*a)[4]), ValNumber((*a)[5]));
}

Transform2 *FullXform(Real a00, Real a01, Real a02,
                      Real a10, Real a11, Real a12)
{
    return NEW FullXform2(a00, a01, a02, a10, a11, a12);
}

#define TRAN(t)  ((TranslationXform2 *)t)
#define SCAL(t)  ((ScaleXform2 *)t)
#define SHR(t)   ((ShearXform2 *)t)
#define ROT(t)   ((RotationXform2 *)t)
#define TWOBY(t) ((TwoByTwoXform2 *)t)
#define FULL(t)  ((FullXform2 *)t)

    // Transform composition (*), and composition with inverse (/)

Transform2 *TimesTransform2Transform2(Transform2 *a, Transform2 *b)
{
    Transform2::Xform2Type
        typeA = a->Type(),
        typeB = b->Type();

    if(typeA == Transform2::Identity)
        return b;

    if(typeB == Transform2::Identity)
        return a;

    unsigned int multType = MAKEWORD(typeA, typeB);
    switch (multType) {

    case MAKEWORD(Transform2::Translation, Transform2::Translation):
        // Just add the corresponding translation components.
      return TranslateRR(TRAN(a)->tx + TRAN(b)->tx,
                         TRAN(a)->ty + TRAN(b)->ty);

    case MAKEWORD(Transform2::Translation, Transform2::Scale):
        // Slap 'em together
        return ( NEW FullXform2(SCAL(b)->sx, 0,           TRAN(a)->tx,
                                0,           SCAL(b)->sy, TRAN(a)->ty));

    case MAKEWORD(Transform2::Translation, Transform2::Shear):
        // Slap 'em together
        return ( NEW FullXform2(1,  SHR(b)->shy, TRAN(a)->tx,
                                SHR(b)->shx, 1,           TRAN(a)->ty));

    case MAKEWORD(Transform2::Translation, Transform2::Rotation):
        // Slap 'em together
        return ( NEW FullXform2(ROT(b)->a00, ROT(b)->a01, TRAN(a)->tx,
                                ROT(b)->a10, ROT(b)->a11, TRAN(a)->ty));

    case MAKEWORD(Transform2::Translation, Transform2::TwoByTwo):
        // Slap 'em together
        return ( NEW FullXform2(TWOBY(b)->a00, TWOBY(b)->a01, TRAN(a)->tx,
                                TWOBY(b)->a10, TWOBY(b)->a11, TRAN(a)->ty));

    case MAKEWORD(Transform2::Translation, Transform2::Full):
        return ( NEW FullXform2(
            FULL(b)->a00,
            FULL(b)->a01,
            TRAN(a)->tx + FULL(b)->a02,
            FULL(b)->a10,
            FULL(b)->a11,
            TRAN(a)->ty + FULL(b)->a12
            ));


    case MAKEWORD(Transform2::Scale, Transform2::Translation):
        // Slap 'em together
        return ( NEW FullXform2(
            SCAL(a)->sx, 0,           SCAL(a)->sx * TRAN(b)->tx,
            0,           SCAL(a)->sy, SCAL(a)->sy * TRAN(b)->ty));

    case MAKEWORD(Transform2::Scale, Transform2::Scale):
        // Mult corresponding componenets.
        return NEW ScaleXform2(SCAL(a)->sx * SCAL(b)->sx,
                               SCAL(a)->sy * SCAL(b)->sy);

    case MAKEWORD(Transform2::Scale, Transform2::Shear):
        return ( NEW TwoByTwoXform2(
            SCAL(a)->sx,               SCAL(a)->sx * SHR(b)->shy,
            SCAL(a)->sy * SHR(b)->shx, SCAL(a)->sy));

    case MAKEWORD(Transform2::Scale, Transform2::Rotation):
        return ( NEW TwoByTwoXform2(
            SCAL(a)->sx * ROT(b)->a00, SCAL(a)->sx * ROT(b)->a01,
            SCAL(a)->sy * ROT(b)->a10, SCAL(a)->sy * ROT(b)->a11));

    case MAKEWORD(Transform2::Scale, Transform2::TwoByTwo):
        return ( NEW TwoByTwoXform2(
            SCAL(a)->sx * TWOBY(b)->a00, SCAL(a)->sx * TWOBY(b)->a01,
            SCAL(a)->sy * TWOBY(b)->a10, SCAL(a)->sy * TWOBY(b)->a11));

    case MAKEWORD(Transform2::Scale, Transform2::Full):
        return ( NEW FullXform2(
            SCAL(a)->sx * FULL(b)->a00, SCAL(a)->sx * FULL(b)->a01, SCAL(a)->sx * FULL(b)->a02,
            SCAL(a)->sy * FULL(b)->a10, SCAL(a)->sy * FULL(b)->a11, SCAL(a)->sy * FULL(b)->a12));

    case MAKEWORD(Transform2::Shear, Transform2::Translation):
        return ( NEW FullXform2(
            1,           SHR(a)->shy, TRAN(b)->tx +  SHR(a)->shy * TRAN(b)->ty,
            SHR(a)->shx, 1,           TRAN(b)->ty +  SHR(a)->shx * TRAN(b)->tx));

    case MAKEWORD(Transform2::Shear, Transform2::Scale):
        return ( NEW TwoByTwoXform2(
            SCAL(b)->sx,               SCAL(b)->sy * SHR(a)->shy,
            SCAL(b)->sx * SHR(a)->shx, SCAL(b)->sy));

    case MAKEWORD(Transform2::Shear, Transform2::Shear):
        return ( NEW TwoByTwoXform2(
            1 + SHR(a)->shy * SHR(b)->shx, SHR(b)->shy + SHR(a)->shy,
                SHR(a)->shx + SHR(b)->shx, 1 + SHR(b)->shy * SHR(a)->shx));

    case MAKEWORD(Transform2::Shear, Transform2::Rotation):
        return ( NEW TwoByTwoXform2(
            ROT(b)->a00 + SHR(a)->shy * ROT(b)->a10,
            ROT(b)->a01 + SHR(a)->shy * ROT(b)->a11,
            ROT(b)->a10 + SHR(a)->shx * ROT(b)->a00,
            ROT(b)->a11 + SHR(a)->shx * ROT(b)->a01));

    case MAKEWORD(Transform2::Shear, Transform2::TwoByTwo):
        return ( NEW TwoByTwoXform2(
            TWOBY(b)->a00 + SHR(a)->shy * TWOBY(b)->a10,
            TWOBY(b)->a01 + SHR(a)->shy * TWOBY(b)->a11,
            TWOBY(b)->a10 + SHR(a)->shx * TWOBY(b)->a00,
            TWOBY(b)->a11 + SHR(a)->shx * TWOBY(b)->a01));

    case MAKEWORD(Transform2::Shear, Transform2::Full):
        return ( NEW FullXform2(
            FULL(b)->a00 + SHR(a)->shy * FULL(b)->a10,
            FULL(b)->a01 + SHR(a)->shy * FULL(b)->a11,
            FULL(b)->a02 + SHR(a)->shy * FULL(b)->a12,

            FULL(b)->a10 + SHR(a)->shx * FULL(b)->a00,
            FULL(b)->a11 + SHR(a)->shx * FULL(b)->a01,
            FULL(b)->a12 + SHR(a)->shx * FULL(b)->a02));


    case MAKEWORD(Transform2::Rotation, Transform2::Translation):
        return ( NEW FullXform2(
            ROT(a)->a00,
            ROT(a)->a01,
            ROT(a)->a00 * TRAN(b)->tx  +  ROT(a)->a01 * TRAN(b)->ty,

            ROT(a)->a10,
            ROT(a)->a11,
            ROT(a)->a10 * TRAN(b)->tx  +  ROT(a)->a11 * TRAN(b)->ty));

    case MAKEWORD(Transform2::Rotation, Transform2::Scale):
        return ( NEW TwoByTwoXform2(
            ROT(a)->a00 * SCAL(b)->sx,   ROT(a)->a01 * SCAL(b)->sy,
            ROT(a)->a10 * SCAL(b)->sx,   ROT(a)->a11 * SCAL(b)->sy));

    case MAKEWORD(Transform2::Rotation, Transform2::Shear):
        return ( NEW TwoByTwoXform2(
            ROT(a)->a00 + SHR(b)->shx * ROT(a)->a01, ROT(a)->a01 + SHR(b)->shy * ROT(a)->a00,
            ROT(a)->a10 + SHR(b)->shx * ROT(a)->a11, ROT(a)->a11 + SHR(b)->shy * ROT(a)->a10));

    case MAKEWORD(Transform2::Rotation, Transform2::Rotation):
        return ( NEW RotationXform2(
            ROT(a)->a00 * ROT(b)->a00 + ROT(a)->a01 * ROT(b)->a10,
            ROT(a)->a00 * ROT(b)->a01 + ROT(a)->a01 * ROT(b)->a11,
            ROT(a)->a10 * ROT(b)->a00 + ROT(a)->a11 * ROT(b)->a10,
            ROT(a)->a10 * ROT(b)->a01 + ROT(a)->a11 * ROT(b)->a11));

    case MAKEWORD(Transform2::Rotation, Transform2::TwoByTwo):
        return ( NEW RotationXform2(
            ROT(a)->a00 * TWOBY(b)->a00 + ROT(a)->a01 * TWOBY(b)->a10,
            ROT(a)->a00 * TWOBY(b)->a01 + ROT(a)->a01 * TWOBY(b)->a11,
            ROT(a)->a10 * TWOBY(b)->a00 + ROT(a)->a11 * TWOBY(b)->a10,
            ROT(a)->a10 * TWOBY(b)->a01 + ROT(a)->a11 * TWOBY(b)->a11));

    case MAKEWORD(Transform2::Rotation, Transform2::Full):
        return ( NEW FullXform2(
            ROT(a)->a00 * FULL(b)->a00 + ROT(a)->a01 * FULL(b)->a10, // 00
            ROT(a)->a00 * FULL(b)->a01 + ROT(a)->a01 * FULL(b)->a11, // 01
            ROT(a)->a00 * FULL(b)->a02 + ROT(a)->a01 * FULL(b)->a12, // 02

            ROT(a)->a10 * FULL(b)->a00 + ROT(a)->a11 * FULL(b)->a10, // 10
            ROT(a)->a10 * FULL(b)->a01 + ROT(a)->a11 * FULL(b)->a11, // 11
            ROT(a)->a10 * FULL(b)->a02 + ROT(a)->a11 * FULL(b)->a12)); // 12



    case MAKEWORD(Transform2::TwoByTwo, Transform2::Translation):
        return ( NEW FullXform2(
            TWOBY(a)->a00,
            TWOBY(a)->a01,
            TWOBY(a)->a00 * TRAN(b)->tx  +  TWOBY(a)->a01 * TRAN(b)->ty,

            TWOBY(a)->a10,
            TWOBY(a)->a11,
            TWOBY(a)->a10 * TRAN(b)->tx  +  TWOBY(a)->a11 * TRAN(b)->ty));

    case MAKEWORD(Transform2::TwoByTwo, Transform2::Scale):
        return ( NEW TwoByTwoXform2(
            TWOBY(a)->a00 * SCAL(b)->sx,   TWOBY(a)->a01 * SCAL(b)->sy,
            TWOBY(a)->a10 * SCAL(b)->sx,   TWOBY(a)->a11 * SCAL(b)->sy));

    case MAKEWORD(Transform2::TwoByTwo, Transform2::Shear):
        return ( NEW TwoByTwoXform2(
            TWOBY(a)->a00 + SHR(b)->shx * TWOBY(a)->a01, TWOBY(a)->a01 + SHR(b)->shy * TWOBY(a)->a00,
            TWOBY(a)->a10 + SHR(b)->shx * TWOBY(a)->a11, TWOBY(a)->a11 + SHR(b)->shy * TWOBY(a)->a10));

    case MAKEWORD(Transform2::TwoByTwo, Transform2::Rotation):
        return ( NEW RotationXform2(
            TWOBY(a)->a00 * ROT(b)->a00 + TWOBY(a)->a01 * ROT(b)->a10,
            TWOBY(a)->a00 * ROT(b)->a01 + TWOBY(a)->a01 * ROT(b)->a11,
            TWOBY(a)->a10 * ROT(b)->a00 + TWOBY(a)->a11 * ROT(b)->a10,
            TWOBY(a)->a10 * ROT(b)->a01 + TWOBY(a)->a11 * ROT(b)->a11));

    case MAKEWORD(Transform2::TwoByTwo, Transform2::TwoByTwo):
        return ( NEW RotationXform2(
            TWOBY(a)->a00 * TWOBY(b)->a00 + TWOBY(a)->a01 * TWOBY(b)->a10,
            TWOBY(a)->a00 * TWOBY(b)->a01 + TWOBY(a)->a01 * TWOBY(b)->a11,
            TWOBY(a)->a10 * TWOBY(b)->a00 + TWOBY(a)->a11 * TWOBY(b)->a10,
            TWOBY(a)->a10 * TWOBY(b)->a01 + TWOBY(a)->a11 * TWOBY(b)->a11));

    case MAKEWORD(Transform2::TwoByTwo, Transform2::Full):
        return ( NEW FullXform2(
            TWOBY(a)->a00 * FULL(b)->a00 + TWOBY(a)->a01 * FULL(b)->a10, // 00
            TWOBY(a)->a00 * FULL(b)->a01 + TWOBY(a)->a01 * FULL(b)->a11, // 01
            TWOBY(a)->a00 * FULL(b)->a02 + TWOBY(a)->a01 * FULL(b)->a12, // 02

            TWOBY(a)->a10 * FULL(b)->a00 + TWOBY(a)->a11 * FULL(b)->a10, // 10
            TWOBY(a)->a10 * FULL(b)->a01 + TWOBY(a)->a11 * FULL(b)->a11, // 11
            TWOBY(a)->a10 * FULL(b)->a02 + TWOBY(a)->a11 * FULL(b)->a12)); // 12


    case MAKEWORD(Transform2::Full, Transform2::Translation):
        return ( NEW FullXform2(
            FULL(a)->a00,
            FULL(a)->a01,
            FULL(a)->a00 * TRAN(b)->tx + FULL(a)->a01 * TRAN(b)->ty + FULL(a)->a02,

            FULL(a)->a10,
            FULL(a)->a11,
            FULL(a)->a10 * TRAN(b)->tx + FULL(a)->a11 * TRAN(b)->ty + FULL(a)->a12));

    case MAKEWORD(Transform2::Full, Transform2::Scale):
        return ( NEW FullXform2(
            FULL(a)->a00 * SCAL(b)->sx,
            FULL(a)->a01 * SCAL(b)->sy,
            FULL(a)->a02, // 02

            FULL(a)->a10 * SCAL(b)->sx,
            FULL(a)->a11 * SCAL(b)->sy,
            FULL(a)->a12)); // 12

    case MAKEWORD(Transform2::Full, Transform2::Shear):
        return ( NEW FullXform2(
            FULL(a)->a00 + FULL(a)->a01 * SHR(b)->shx, // 00
            FULL(a)->a00 * SHR(b)->shy + FULL(a)->a01, // 01
            FULL(a)->a02, // 02

            FULL(a)->a10 + FULL(a)->a11 * SHR(b)->shx, // 00
            FULL(a)->a10 * SHR(b)->shy + FULL(a)->a11, // 01
            FULL(a)->a12)); // 12


    case MAKEWORD(Transform2::Full, Transform2::Rotation):
        return ( NEW FullXform2(
            FULL(a)->a00 * ROT(b)->a00 + FULL(a)->a01 * ROT(b)->a10, // 00
            FULL(a)->a00 * ROT(b)->a01 + FULL(a)->a01 * ROT(b)->a11, // 01
            FULL(a)->a02, // 02

            FULL(a)->a10 * ROT(b)->a00 + FULL(a)->a11 * ROT(b)->a10, // 10
            FULL(a)->a10 * ROT(b)->a01 + FULL(a)->a11 * ROT(b)->a11, // 11
            FULL(a)->a12)); // 12


    case MAKEWORD(Transform2::Full, Transform2::TwoByTwo):
        return ( NEW FullXform2(
            FULL(a)->a00 * TWOBY(b)->a00 + FULL(a)->a01 * TWOBY(b)->a10, // 00
            FULL(a)->a00 * TWOBY(b)->a01 + FULL(a)->a01 * TWOBY(b)->a11, // 01
            FULL(a)->a02, // 02

            FULL(a)->a10 * TWOBY(b)->a00 + FULL(a)->a11 * TWOBY(b)->a10, // 10
            FULL(a)->a10 * TWOBY(b)->a01 + FULL(a)->a11 * TWOBY(b)->a11, // 11
            FULL(a)->a12)); // 12

    case MAKEWORD(Transform2::Full, Transform2::Full):
        return ( NEW FullXform2(
            FULL(a)->a00 * FULL(b)->a00 + FULL(a)->a01 * FULL(b)->a10, // 00
            FULL(a)->a00 * FULL(b)->a01 + FULL(a)->a01 * FULL(b)->a11, // 01
            FULL(a)->a00 * FULL(b)->a02 + FULL(a)->a01 * FULL(b)->a12 + FULL(a)->a02, // 02

            FULL(a)->a10 * FULL(b)->a00 + FULL(a)->a11 * FULL(b)->a10, // 10
            FULL(a)->a10 * FULL(b)->a01 + FULL(a)->a11 * FULL(b)->a11, // 11
            FULL(a)->a10 * FULL(b)->a02 + FULL(a)->a11 * FULL(b)->a12 + FULL(a)->a12)); // 12

    default:
        return a;               // TODO.

    } // switch

}

Transform2 *Compose2Array(AxAArray *xfs)
{
    xfs = PackArray(xfs);
    
    int numXFs = xfs->Length();
    if(numXFs < 2)
       RaiseException_UserError(E_FAIL, IDS_ERR_INVALIDARG);

    Transform2 *finalXF = (Transform2 *)(*xfs)[numXFs-1];
    for(int i=numXFs-2; i>=0; i--)
        finalXF = TimesTransform2Transform2((Transform2 *)(*xfs)[i], finalXF);
    return finalXF;
}

//------------------------------------------------------------------------------

    // Transformation of points and vectors

Point2Value *
TransformPoint2Value(Transform2 *a, Point2Value *pt)
{
    Point2Value *dst = Promote(TransformPoint2(a, Demote(*pt)));
    return dst;
}

Point2
TransformPoint2(Transform2 *a, const Point2& pt)
{
    Real dx, dy;

    switch (a->Type()) {

      case Transform2::Identity:
        dx = pt.x;
        dy = pt.y;
        break;

      case Transform2::TwoByTwo:
        dx = TWOBY(a)->a00 * pt.x + TWOBY(a)->a01 * pt.y;
        dy = TWOBY(a)->a10 * pt.x + TWOBY(a)->a11 * pt.y;
        break;

      case Transform2::Full:
        dx = FULL(a)->a00 * pt.x + FULL(a)->a01 * pt.y + FULL(a)->a02;
        dy = FULL(a)->a10 * pt.x + FULL(a)->a11 * pt.y + FULL(a)->a12;
        break;

      case Transform2::Rotation:
        dx = ROT(a)->a00 * pt.x + ROT(a)->a01 * pt.y;
        dy = ROT(a)->a10 * pt.x + ROT(a)->a11 * pt.y;
        break;

      case Transform2::Translation:
        dx = TRAN(a)->tx + pt.x;
        dy = TRAN(a)->ty + pt.y;
        break;

      case Transform2::Scale:
        dx = SCAL(a)->sx * pt.x;
        dy = SCAL(a)->sy * pt.y;
        break;

      case Transform2::Shear:
        dx = pt.x + SHR(a)->shy * pt.y;
        dy = pt.y + SHR(a)->shx * pt.x;
        break;

      default:
        Assert(FALSE && "Shouldn't be here");
        break;
    }

    return Point2(dx,dy);
}

Vector2Value *
TransformVector2Value(Transform2 *a, Vector2Value *v)
{
    Vector2Value *dst = Promote(TransformVector2(a, Demote(*v)));
    return dst;
}

Vector2
TransformVector2(Transform2 *a, const Vector2& vec)
{
    Real dstx, dsty;

    switch(a->Type()) {

        // Ignore translataional component for vector transformation.
      case Transform2::Identity:
      case Transform2::Translation:
        dstx = vec.x;
        dsty = vec.y;
        break;

      case Transform2::TwoByTwo:
        dstx = TWOBY(a)->a00 * vec.x + TWOBY(a)->a01 * vec.y;
        dsty = TWOBY(a)->a10 * vec.x + TWOBY(a)->a11 * vec.y;
        break;

        // Ignore the translational component for vector transformation.
      case Transform2::Full:
        dstx = FULL(a)->a00 * vec.x + FULL(a)->a01 * vec.y;
        dsty = FULL(a)->a10 * vec.x + FULL(a)->a11 * vec.y;
        break;

      case Transform2::Rotation:
        dstx = ROT(a)->a00 * vec.x + ROT(a)->a01 * vec.y;
        dsty = ROT(a)->a10 * vec.x + ROT(a)->a11 * vec.y;
        break;

      case Transform2::Scale:
        dstx = SCAL(a)->sx * vec.x;
        dsty = SCAL(a)->sy * vec.y;
        break;

      case Transform2::Shear:
        dstx = vec.x + SHR(a)->shy * vec.y;
        dsty = vec.y + SHR(a)->shx * vec.x;
        break;

      default:
        Assert(FALSE && "Shouldn't be here");
        break;

    }

    return Vector2(dstx,dsty);
}

    // Invert transformation

Transform2 *InverseTransform2 (Transform2 *a)
{
    Real coef, div;

    switch(a->Type()) {
    case Transform2::Identity:
        return identityTransform2; // Why not return a ?

    case Transform2::TwoByTwo:
        div = (TWOBY(a)->a00 * TWOBY(a)->a11  -  TWOBY(a)->a01 * TWOBY(a)->a10);
        if (IsZero(div)) return NULL;

        coef = 1.0 / div;
        return (
            NEW TwoByTwoXform2(
                coef * TWOBY(a)->a11, - coef * TWOBY(a)->a01,
              - coef * TWOBY(a)->a10,   coef * TWOBY(a)->a00));

    case Transform2::Full:
      {
        div = (FULL(a)->a00 * FULL(a)->a11  -  FULL(a)->a01 * FULL(a)->a10);

        if (IsZero(div)) return NULL;
        
        coef = 1.0 / div;
        Real aa =   coef * FULL(a)->a11,
             bb = - coef * FULL(a)->a01,
             cc = - coef * FULL(a)->a10,
             dd =   coef * FULL(a)->a00;

        return (
            NEW FullXform2(
                aa, bb, - aa * FULL(a)->a02 - bb * FULL(a)->a12,
                cc, dd, - cc * FULL(a)->a02 - dd * FULL(a)->a12));
       }

    case Transform2::Translation:
        return TranslateRR(- TRAN(a)->tx, - TRAN(a)->ty);

    case Transform2::Rotation:
        // This is basically a transpose.

        return (
            NEW RotationXform2(
                ROT(a)->a00, ROT(a)->a10,
                ROT(a)->a01, ROT(a)->a11));

    case Transform2::Scale:

      if (IsZero(SCAL(a)->sx) || IsZero(SCAL(a)->sy)) {
          return NULL;
      }

        return NEW ScaleXform2(1.0 / SCAL(a)->sx, 1.0 / SCAL(a)->sy);

    case Transform2::Shear:
        if(IsZero(SHR(a)->shy)) {
            // ShearY is 0, compute inversion cheaply!
            return NEW ShearXform2(- SHR(a)->shx, 0);

        } else if(IsZero(SHR(a)->shx)) {
            // ShearX is 0, compute inversion cheaply!
            return NEW ShearXform2(0, - SHR(a)->shy);

        } else {
            div = (1 - SHR(a)->shx * SHR(a)->shy);

            if (IsZero(div)) return NULL;

            // XhearX and ShearY are non-zero.  do a real inverse.
            coef = 1.0 / div;
            return (
                NEW RotationXform2(
                      coef,             - SHR(a)->shy * coef,
                    - SHR(a)->shx * coef, coef           ));
        }

    default:
        return a;  // never executed.
    } // switch
}

Transform2 *ThrowingInverseTransform2 (Transform2 *a)
{
    Transform2 *ret = InverseTransform2(a);

    if (ret==NULL)
        RaiseException_UserError(E_FAIL, IDS_ERR_INVERT_SINGULAR_MATRIX);

    return ret;
}

    // Is Singular

AxABoolean *IsSingularTransform2(Transform2 *a)
{
    Real divisor;

    switch(a->Type()) {
    case Transform2::Identity:
    case Transform2::Translation:
    case Transform2::Rotation:
        return falsePtr;

    case Transform2::TwoByTwo:
        divisor = (TWOBY(a)->a00 * TWOBY(a)->a11  -  TWOBY(a)->a01 * TWOBY(a)->a10);
        return IsZero(divisor) ? truePtr : falsePtr;

    case Transform2::Full:
        divisor = (FULL(a)->a00 * FULL(a)->a11  -  FULL(a)->a01 * FULL(a)->a10);
        return IsZero(divisor) ? truePtr : falsePtr;

    case Transform2::Scale:
        return (IsZero(SCAL(a)->sx) || IsZero(SCAL(a)->sy))  ? truePtr : falsePtr;

    case Transform2::Shear:
        divisor = (1 - SHR(a)->shx * SHR(a)->shy);
        return IsZero(divisor)  ? truePtr : falsePtr;

    default:
        return falsePtr; // never excecuted, needed by compiler
    } // switch
}

/* Specialized fast version of TransformPoints2To GDI space.
   
    Original code was roughly:

    HeapReseter heapReseter(_scratchHeap);
    for(int i=0; i<numPts; i++) {
        destPts[i] = TransformPoint2Value(xform, srcPts[i]);
    }

    for(i=0; i<numPts; i++) {
        gdiPts[i].x = width + Real2Pix(dst.x, resolution);
        gdiPts[i].y = height - Real2Pix(dst.y, resolution);
    }

    It allocated an array destPts[i] to hold the destination points.
    Then it transformed the source points to the destination points
    (this is done in DirectAnimation coordinate space).   Next it mapped
    the destination points to the GDI coordinate space.

    I've made the following changes:
         (1) avoid the intermediate creation of destination points
         (2) inlined TransformPoint2Value and split the loop (loop splitting:
             if the result of a test that is in the middle of a loop
             is independent of the loop, we can create multiple copies 
             of the loop, one per test to avoid doing the test in the
             inner loop.*/

/* Macro to do the specialized loop.   It takes two expressions, xexp and
   yexp, uses them to compute the NEW destination point x and y values
   respectively, and the converts those values to GDI values.  I assume
   that xexp and yexp use the following variables:
          a: the current xform
          x: the source x value
          y: the source y value
          */

#define REAL2PIX(imgCoord, res) (floor((imgCoord) * (res) + 0.5))
#define SPECIALIZED_LOOP(xexp,yexp) \
{                                               \
  int i; \
  for (i=0; i<numPts; i++) \
  { Real x = srcPts[i]->x, y = srcPts[i]->y; \
    gdiPts[i].x = width + REAL2PIX(xexp,resolution); \
    gdiPts[i].y = height - REAL2PIX(yexp,resolution); \
  } \
}

void 
TransformPointsToGDISpace(Transform2 *a,
                          Point2Value **srcPts, 
                          POINT *gdiPts,
                          int numPts,
                          int width,
                          int height,
                          Real resolution)
{ switch (a->Type()) {

      case Transform2::Identity:
        SPECIALIZED_LOOP(x,y)
        break;

      case Transform2::TwoByTwo:
         SPECIALIZED_LOOP(TWOBY(a)->a00 * x + TWOBY(a)->a01 * y,
                          TWOBY(a)->a10 * x + TWOBY(a)->a11 * y)
         break;
      case Transform2::Full:
         SPECIALIZED_LOOP(FULL(a)->a00 * x + FULL(a)->a01 * y + FULL(a)->a02,
                          FULL(a)->a10 * x + FULL(a)->a11 * y + FULL(a)->a12)
          break;

      case Transform2::Rotation:
         SPECIALIZED_LOOP(ROT(a)->a00 * x + ROT(a)->a01 * y,
                          ROT(a)->a10 * x + ROT(a)->a11 * y)
         break;

      case Transform2::Translation:
         SPECIALIZED_LOOP(TRAN(a)->tx + x,TRAN(a)->ty + y)
         break;

      case Transform2::Scale:
         SPECIALIZED_LOOP(SCAL(a)->sx * x,SCAL(a)->sy * y)
         break;

      case Transform2::Shear:
         SPECIALIZED_LOOP(x + SHR(a)->shy * y,y + SHR(a)->shx * x)
         break;

      default:
        Assert(FALSE && "Shouldn't be here");
        break;

    }
}

// TODO: Factor code

#undef SPECIALIZED_LOOP

// TODO: Can probably be made faster by not using indexing, but
// pointer arithmetic.

#define SPECIALIZED_LOOP(xexp,yexp) \
{                                               \
  int i; \
  for (i=0; i<numPts; i++) \
  { Real x = srcPts[i].x, y = srcPts[i].y; \
    gdiPts[i].x = width + REAL2PIX(xexp,resolution); \
    gdiPts[i].y = height - REAL2PIX(yexp,resolution); \
  } \
}

void 
TransformDXPoint2ArrayToGDISpace(Transform2 *a,
                               DXFPOINT *srcPts,
                               POINT *gdiPts,
                               int numPts,
                               int width,
                               int height,
                               Real resolution)
{ switch (a->Type()) {

      case Transform2::Identity:
        SPECIALIZED_LOOP(x,y)
        break;

      case Transform2::TwoByTwo:
         SPECIALIZED_LOOP(TWOBY(a)->a00 * x + TWOBY(a)->a01 * y,
                          TWOBY(a)->a10 * x + TWOBY(a)->a11 * y)
         break;
      case Transform2::Full:
         SPECIALIZED_LOOP(FULL(a)->a00 * x + FULL(a)->a01 * y + FULL(a)->a02,
                          FULL(a)->a10 * x + FULL(a)->a11 * y + FULL(a)->a12)
          break;

      case Transform2::Rotation:
         SPECIALIZED_LOOP(ROT(a)->a00 * x + ROT(a)->a01 * y,
                          ROT(a)->a10 * x + ROT(a)->a11 * y)
         break;

      case Transform2::Translation:
         SPECIALIZED_LOOP(TRAN(a)->tx + x,TRAN(a)->ty + y)
         break;

      case Transform2::Scale:
         SPECIALIZED_LOOP(SCAL(a)->sx * x,SCAL(a)->sy * y)
         break;

      case Transform2::Shear:
         SPECIALIZED_LOOP(x + SHR(a)->shy * y,y + SHR(a)->shx * x)
         break;

      default:
        Assert(FALSE && "Shouldn't be here");
        break;

    }
}


void 
TransformPoint2ArrayToGDISpace(Transform2 *a,
                               Point2 *srcPts,
                               POINT *gdiPts,
                               int numPts,
                               int width,
                               int height,
                               Real resolution)
{ switch (a->Type()) {

      case Transform2::Identity:
        SPECIALIZED_LOOP(x,y)
        break;

      case Transform2::TwoByTwo:
         SPECIALIZED_LOOP(TWOBY(a)->a00 * x + TWOBY(a)->a01 * y,
                          TWOBY(a)->a10 * x + TWOBY(a)->a11 * y)
         break;
      case Transform2::Full:
         SPECIALIZED_LOOP(FULL(a)->a00 * x + FULL(a)->a01 * y + FULL(a)->a02,
                          FULL(a)->a10 * x + FULL(a)->a11 * y + FULL(a)->a12)
          break;

      case Transform2::Rotation:
         SPECIALIZED_LOOP(ROT(a)->a00 * x + ROT(a)->a01 * y,
                          ROT(a)->a10 * x + ROT(a)->a11 * y)
         break;

      case Transform2::Translation:
         SPECIALIZED_LOOP(TRAN(a)->tx + x,TRAN(a)->ty + y)
         break;

      case Transform2::Scale:
         SPECIALIZED_LOOP(SCAL(a)->sx * x,SCAL(a)->sy * y)
         break;

      case Transform2::Shear:
         SPECIALIZED_LOOP(x + SHR(a)->shy * y,y + SHR(a)->shx * x)
         break;

      default:
        Assert(FALSE && "Shouldn't be here");
        break;

    }
}
#undef REAL2PIX

#undef TRAN
#undef SCAL
#undef SHR
#undef ROT
#undef TWOBY
#undef FULL

#if _USE_PRINT
ostream&
operator<<(ostream& os, Transform2 *a)
{
    return os << a->Print(os);
}
#endif


void
InitializeModule_Xform2()
{
    identityTransform2 = NEW IdentityXform2;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\values\sound\geosound.cpp ===
/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

    Support for Geometry constructed from sound.

*******************************************************************************/

#include "headers.h"
#include <privinc/soundi.h>
#include <privinc/geomi.h>
#include <privinc/mici.h>
#include <appelles/vec3.h>
#include <privinc/lighti.h>
#include <privinc/dsdev.h>
#include <privinc/debug.h>
#include "privinc/basic.h"
#include "privinc/helps.h"   // LinearTodB

SoundTraversalContext::SoundTraversalContext() : _currxform(identityTransform3) {};

void
SoundTraversalContext::addSound (Transform3 *transform, Sound *sound)
{
    // Note that the sound data gets copied onto the list, so it's OK
    // to put it on the stack.
    SoundData sdata;
    sdata._transform = transform;
    sdata._sound     = sound;

    _soundlist.push_back(sdata);
}


class SpatializedSound : public Sound {
  public:

    SpatializedSound(Microphone *mic) : microphone(mic) {
        // Allocate a sound context explicitly so that we can
        // deallocate it explicitly via a dynamic deleter.
        context = NEW SoundTraversalContext;
        DynamicPtrDeleter<SoundTraversalContext> *deleter =
            NEW DynamicPtrDeleter<SoundTraversalContext>(context);
        GetHeapOnTopOfStack().RegisterDynamicDeleter(deleter);
    }

    virtual ~SpatializedSound() { CleanUp(); }
    virtual void CleanUp() {
        // TODO: deal with Deleter in general
        // delete context;
    }
    
    virtual void Render(GenericDevice &dev);
#if _USE_PRINT
    ostream& Print(ostream& s) { return s << "(" << "spatial sound" << ")"; }
#endif

    SoundTraversalContext *context;
    Microphone *microphone;
};

int    power  = 1;
double coef   = 0.4;
double constt = 0.4;

void
SpatializedSound::Render(GenericDevice &_dev)
{
    Point3Value *soundPosition;
    double distance;
    double distanceAtten;
    double saveGain;

    vector<SoundData>::iterator i;

    TraceTag((tagSoundRenders, "SpatializedSound:Render()"));

    MetaSoundDevice *metaDev = SAFE_CAST(MetaSoundDevice *, &_dev);
    DirectSoundDev  *dsDev   = (DirectSoundDev *)metaDev->dsDevice;

    Transform3   *micTransform    = microphone->GetTransform();
    Point3Value  *micPosition     = TransformPoint3(micTransform, origin3);
    Vector3Value *micOrientation  = TransformVec3(micTransform, zVector3);

    for (i = context->_soundlist.begin();
         i != context->_soundlist.end(); ++i) {
        soundPosition = TransformPoint3(i->_transform, origin3);
        distance = RDistancePoint3Point3(soundPosition, micPosition);

        // calculate attenuation based on distance
        // XXX eventualy we will want the user to be able to select the factor!
        //distanceAtten = distance ? (1.0/(pow(distance/coef, power))) : 1.0;
        double d = constt+distance*coef;
        distanceAtten = (d>0.0) ? 1/d : 1.0;
        //double dBatten = LinearTodB(distanceAtten);
        
        //printf("distance= %fM, gain=%f\n", distance, distanceAtten);
        
        saveGain = metaDev->GetGain(); // stash current gain value

        // dB space addition yeilds multiplicative accumulation in linear space
        metaDev->SetGain(saveGain * distanceAtten);
        
        i->_sound->Render(_dev); // render sound tree
        
        metaDev->SetGain(saveGain); // restore stashed gain value
    }
}


Sound *RenderSound(Geometry *geo, Microphone *mic)
{
    // Ah, this is where the sublime journey recursively visiting every node
    // in the geometry, searching out for sounds to pass the accumulated
    // geometric transformation and microphone too begins.
    
    SpatializedSound *sSound = NEW SpatializedSound(mic);
    
    geo->CollectSounds(*(sSound->context));
    
    return sSound;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\values\sound\aamidi.cpp ===
/*++

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    MIDI support

--*/

#include "headers.h"
#include <math.h>
#include <stdio.h>
#include "privinc/soundi.h"
#include "privinc/snddev.h"
#include "privinc/util.h"
#include "privinc/path.h"
#include "privinc/storeobj.h"
#include "privinc/debug.h"
#include "privinc/aadev.h"
#include "privinc/except.h"
#include "privinc/aamidi.h"

#include <unknwn.h>
#include <objbase.h> // needed for DEFINE_GUID
#include <msimusic.h>

#error This file needs to be moved off of try/catches before being compiled

myMessageHandler::~myMessageHandler() {}

HRESULT myMessageHandler::OnSongStarted(DWORD, IAASong FAR *pSong, 
    AAFlags flags)
{
//printf("song started\n");
return S_OK;
}


HRESULT myMessageHandler::OnSongEnded(DWORD, IAASong FAR *pSong, 
    AAFlags flags, DWORD lEndTime)
{
//printf("song ended\n");
return S_OK;
}


HRESULT myMessageHandler::OnSectionStarted(DWORD, IAASection FAR *pSection, 
    AAFlags flags)
{
//printf("section started\n");
return S_OK;
}


HRESULT myMessageHandler::OnSectionEnded(DWORD, IAASection FAR *pSection,
     AAFlags flags,
 DWORD lEndTime)
{
//printf("section ended\n");
return S_OK;
}


HRESULT myMessageHandler::OnSectionChanged(DWORD, IAASection FAR *pSection, 
    AAFlags flags)
{
//printf("section changed\n");
return S_OK;
}


HRESULT myMessageHandler::OnNextSection(DWORD, IAASection FAR *pSection, AAFlags flags)
{
//printf("next section\n");
return S_OK;
}


HRESULT myMessageHandler::OnEmbellishment(DWORD, AACommands embellishment, 
    AAFlags flags)
{
//printf("embellishment\n");
return S_OK;
}


HRESULT myMessageHandler::OnGroove(DWORD, AACommands groove, AAFlags flags)
{
//printf("groove\n");
return S_OK;
}


HRESULT myMessageHandler::OnMetronome(DWORD, unsigned short nMeasure, 
    unsigned short nBeat)
{
//printf("netronome\n");
return S_OK;
}


HRESULT myMessageHandler::OnMIDIInput(long lMIDIEvent, long lMusicTime)
{
//printf("MIDI input\n");
return S_OK;
}


HRESULT myMessageHandler::OnMusicStopped(DWORD dwTime)
{
return S_OK;
}


HRESULT myMessageHandler::OnNotePlayed(AAEVENT* pEvent)
{
//printf("note played\n");
return S_OK;
}


HRESULT myMessageHandler::OnMotifEnded(DWORD, IAAMotif *, AAFlags)
{ return S_OK; }


HRESULT myMessageHandler::OnMotifStarted(DWORD, IAAMotif *, AAFlags)
{ return S_OK; }


HRESULT myMessageHandler::OnMotifStoped(DWORD)
{ return S_OK; }


HRESULT myMessageHandler::OnUserEvent(DWORD, DWORD, DWORD)
{ return S_OK; }


myMessageHandler::myMessageHandler():IAANotifySink()
{
    m_cRef          = 0;

    // XXX MFC Stuff?
    //m_pCurrentClass = 0;
    //m_pLastClass    = 0;
}


HRESULT myMessageHandler::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
    HRESULT result = E_NOINTERFACE;
    if( ::IsEqualIID( riid, IID_IAANotifySink ) ||
        ::IsEqualIID( riid, IID_IUnknown ) ) {
        AddRef();
        *ppvObj = this;
        result = S_OK;
    }

    return result;
}


ULONG myMessageHandler::AddRef()
{
    return ++m_cRef;
}


ULONG myMessageHandler::Release()
{
    ULONG cRef;

    cRef = --m_cRef;
    //if( cRef == 0 )  // XXX WHY IS THIS UNSAFE WHEN IT IS CALLED?
        //delete this;

    return cRef;
}


aaMIDIsound::aaMIDIsound()
{
    // initialize
    _started  = FALSE;
    _ended    = FALSE;
    _looping  = FALSE;
    _section  =  NULL;  // section not loaded yet!

}

void aaMIDIsound::Open(char *MIDIfileName)
{

    // stash away a copy of the filename
    fileName = (char *)ThrowIfFailed(malloc(lstrlen(MIDIfileName) + 1)); // grab a long enough hunk
    lstrcpy(fileName, MIDIfileName);
}
aaMIDIsound::~aaMIDIsound()
{
    BufferElement *bufferElement;

    // walk list destroying everything...
    while(!bufferList.empty()) {
        bufferElement = bufferList.front();

        // XXX what all has to be stoped, released, destroyed??

        if(_section)
            _section->Release();


        free(bufferElement->path);
        delete bufferElement;
        bufferList.pop_front();
    }
}


bool aaMIDIsound::RenderAvailable(GenericDevice& _dev)
{
    MetaSoundDevice *metaDev = SAFE_CAST(MetaSoundDevice *, &_dev);
    AudioActiveDev  *aaDev   = metaDev->aaDevice;

    TraceTag((tagSoundRenders, "aaMIDIsound:Render()"));

    return(aaDev->_aactiveAvailable);
}


void aaMIDIsound::RenderStop(MetaSoundDevice *metaDev, 
    BufferElement *bufferElement)
{
    AudioActiveDev  *aaDev   = metaDev->aaDevice;

    if(aaDev->_aaEngine) {
        _ended   = FALSE;
        _started = FALSE;
        aaDev->_aaEngine->Stop(); // stop it
        }
}


void aaMIDIsound::RenderNewBuffer(BufferElement *bufferElement,
              MetaSoundDevice *metaDev)
{
    AudioActiveDev  *aaDev = metaDev->aaDevice;

    bufferElement->firstTime = GetCurrTime(); // need to know time to phase

    if(!aaDev->_aaEngine) {
        try {
            aaDev->_aaEngine = NEW AAengine();
            aaDev->_aaEngine->RegisterSink(this);
        }

#ifdef _DEBUG
        catch(char *errMsg)
#else
        catch(char *)
#endif

#error Remember to remove ALLL 'catch' blocks

        {
            aaDev->_aactiveAvailable = FALSE; // couldn't initialize AA!
            if(aaDev->_aaEngine)
                delete aaDev->_aaEngine;

#ifdef _DEBUG
            // XXX popup message continuing w/o MIDI
            fprintf(stderr, 
                "aaMIDIsound::RenderNewBuffer failed to create AAengine (%s), "),
                 errMsg;
            fprintf(stderr, "continuing w/o MIDI!\n");
#endif
        }
    }

    try {
        // play the midi file
        if(!_section) { // load the section if needed
            aaDev->_aaEngine->LoadSectionFile(fileName, &_section);
        }

        aaDev->_aaEngine->PlaySection(_section);
        _started = TRUE;
    }
#error Remember to remove ALLL 'catch' blocks
    catch(char *errMsg) {
        if(_section)
            _section->Release(); // XXX delete it, too?
        RaiseException_UserError(errMsg);
    }

}
#error Did you do it right ??  Look at code that does it right...


void aaMIDIsound::RenderAttributes(
    MetaSoundDevice *metaDev, BufferElement *bufferElement)
{
    AudioActiveDev  *aaDev   = metaDev->aaDevice;

    aaDev->_aaEngine->SetGain(metaDev->GetGain());       // do Gain
    aaDev->_aaEngine->SetRate(metaDev->GetPitchShift()); // do Rate

    //XXX Note: We would 'setpan' here if we knew how to move all of the
    //          MIDI instruments around!
    //aaDev->_aaEngine->SetPan(metaDev->GetPan()); // do Pan

    if(_ended && _started) { // if what we were playing has stopped
        if(metaDev->GetLooping()) { // looped sound 
            _ended   = FALSE;       // restart the sound
            _started = TRUE;
            aaDev->_aaEngine->PlaySection(_section);
        }
        // else nothing left to do, relinquish, shutdown, etc.
    }
}


void aaMIDIsound::RenderStartAtLocation(MetaSoundDevice *metaDev,
    BufferElement *bufferElement, double phase, Bool looping)
{
// XXX realy should start the MIDI playing, here!
}


Bool aaMIDIsound::RenderPhaseLessThanLength(double phase)
{
//return(phase < (-1*lengthInSecs));
return(1); // XXX since we don't know the play time of a midi sec we return 1
}


void aaMIDIsound::RenderSetMute(
    MetaSoundDevice *metaDev, BufferElement *bufferElement)
{
    AudioActiveDev  *aaDev   = metaDev->aaDevice;

    if(aaDev->_aaEngine)
        aaDev->_aaEngine->SetGain(0.0); // mute sound 
}


// XXX next two methods are temporarialy stubed in!
Bool aaMIDIsound::RenderCheckComplete(
    MetaSoundDevice *metaDev, BufferElement *bufferElement)
{
return FALSE;
}


void aaMIDIsound::RenderCleanupBuffer(
    MetaSoundDevice *metaDev, BufferElement *bufferElement)
{
}


double aaMIDIsound::GetLength()
{
// how do we ask audioActive for the length of the section?
return(9988776655.0); // set a large and identifyable number for now
}


HRESULT aaMIDIsound::OnSectionEnded(DWORD, IAASection FAR *pSection, 
    AAFlags flags, DWORD lEndTime)
{
//printf("section ended\n");
_ended = TRUE;  // notified that the section ended
return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\values\misc\xformi.cpp ===
/*++
********************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

Abstract:
    Lower level transformation implementation.

********************************************************************************
--*/

#include "headers.h"
#include "privinc/basic.h"
#include "appelles/xform.h"
#include "privinc/xformi.h"
#include "privinc/vecutil.h"
#include "privinc/vec3i.h"
#include "privinc/matutil.h"

    // This declaration effectively exists in matutil.cpp, but since static
    // initialization order between modules is not guaranteed (and thus may
    // not have executed before we reach this point), we repeat it here.

static const Apu4x4Matrix identityMatrix =
{
  {
    {1.0, 0.0, 0.0, 0.0},
    {0.0, 1.0, 0.0, 0.0},
    {0.0, 0.0, 1.0, 0.0},
    {0.0, 0.0, 0.0, 1.0}
  },
  Apu4x4Matrix::IDENTITY_E,
  1
};

Transform3 *identityTransform3 = NULL;

#if MATRIX_DEBUG
static void
VerifyMatrixInverse(Apu4x4Matrix mat, Apu4x4Matrix inv)
{
    // Ensure that mat and inv combine to the identity matrix.
    Apu4x4Matrix mul;
    ApuMultiply(mat, inv, mul);
    for (int i = 0; i < 4; i++) {
        for (int j = 0; j < 4; j++) {
            if (i == j) {
                Assert(fabs(mul.m[i][j] - 1) < 0.01);
            } else {
                Assert(fabs(mul.m[i][j]) < 0.01);
            }
        }
    }
}
#endif MATRIX_DEBUG

Transform3 *
Transform3::Inverse()
{
    Apu4x4Matrix tmp;

    bool ok = ApuInverse(Matrix(), tmp);

    if (!ok) return NULL;
    
    #if MATRIX_DEBUG
        VerifyMatrixInverse(Matrix(), tmp);
    #endif MATRIX_DEBUG

    return Apu4x4XformImpl(tmp);
}

Bool
Transform3::IsSingular(void)
{
    return ApuIsSingular(Matrix());
}

Transform3 *
Transform3::Copy()
{
    // Just create a new Transform3* out of the matrix.  This results
    // in the Apu4x4Matrix object being copied into the newly
    // allocated Transform3 object.
    return Apu4x4XformImpl(Matrix());
}

#if _USE_PRINT
ostream&
Transform3::Print(ostream &os)
{
    Apu4x4Matrix m = Matrix();

    os << "[";
    for (int i = 0; i < 4; i++) {
        os << "[";
        for (int j = 0; j < 4; j++) {
            os << m[i][j];
            os << ((j == 3) ? "]" : ",");
        }
    }
    return os << "]";
}
#endif

Transform3 *
CopyTransform3(Transform3 *xf)
{
    return xf->Copy();
}

/*****************************************************************************
Multiplication and concatenation follow "pre-multiply" conventions:
x transformed by (A * B) is the same as A applied to the result of
transforming x by B.
*****************************************************************************/

Transform3 *TimesXformXform (Transform3 *a, Transform3 *b)
{
    const Apu4x4Matrix& ma = a->Matrix();
    const Apu4x4Matrix& mb = b->Matrix();
    Apu4x4Matrix result;

    ApuMultiply(ma, mb, result);

    #if MATRIX_DEBUG
        // Take the inverse and see if it is really the inverse.
        Transform3 *val = Apu4x4XformImpl(result);
        Transform3 *inv = val->Inverse();
        VerifyMatrixInverse(val->Matrix(), inv->Matrix());
    #endif MATRIX_DEBUG

    return Apu4x4XformImpl(result);
}

Transform3 *Compose3Array(AxAArray *xfs)
{
    xfs = PackArray(xfs);
    
    int numXFs = xfs->Length();
    if(numXFs < 2)
       RaiseException_UserError(E_FAIL, IDS_ERR_INVALIDARG);

    Transform3 *finalXF = (Transform3 *)(*xfs)[numXFs-1];
    for(int i=numXFs-2; i>=0; i--)
        finalXF = TimesXformXform((Transform3 *)(*xfs)[i], finalXF);

    return finalXF;
}

Transform3 *InverseTransform3(Transform3 *a)
{
    Transform3 *xfresult = a->Inverse();

    #if _DEBUG
        if (xfresult)
            CHECK_MATRIX (xfresult->Matrix());
    #endif

    return xfresult;
}

Transform3 *ThrowingInverseTransform3 (Transform3 *a)
{
    Transform3 *ret = InverseTransform3(a);

    if (ret==NULL)
        RaiseException_UserError(E_FAIL, IDS_ERR_INVERT_SINGULAR_MATRIX);

    return ret;
}

AxABoolean *IsSingularTransform3(Transform3 *a)
{
    return (a->IsSingular() == TRUE ? truePtr : falsePtr);
}


void
InitializeModule_Xform3()
{
    identityTransform3 = Apu4x4XformImpl(identityMatrix);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\values\sound\dsound.cpp ===
/*******************************************************************************
Copyright (c) 1995-97 Microsoft Corporation

    Specification and implementation of static wave sound

Static wave sounds are pcm sounds loaded completely within a dsound buffer 
and played from there.

*******************************************************************************/

#include "headers.h"
#include "privinc/helpds.h"  //dsound helper routines
#include "privinc/soundi.h"
#include "privinc/snddev.h"
#include "privinc/dsdev.h"
#include "privinc/util.h"
#include "privinc/pcm.h"
#include "privinc/bufferl.h"
#include "backend/sndbvr.h"

class StaticWaveSoundInstance : public SoundInstance {
  public:
    StaticWaveSoundInstance(LeafSound *snd, TimeXform tt,
                            unsigned char *&samples, PCM& pcm)
    : SoundInstance(snd, tt), _dsProxy(NULL),
      _samples(samples), _pcm(pcm), _staticBuffer(NULL), _ownSamples(false) {}

    ~StaticWaveSoundInstance() {
        ReleaseResources();
    }

    void Create(MetaSoundDevice*, SoundContext *);
    void StartAt(MetaSoundDevice*, double);
    void Adjust(MetaSoundDevice*);
    void Mute(bool mute);
    void ReleaseResources();
    bool Done();
    bool GetLength(double&);
    
  protected:
    void CheckResources();
    DSstaticBuffer *_staticBuffer;
    PCM& _pcm;
    unsigned char *& _samples;  // sound owns these, not us, so don't release
    bool _ownSamples;           // determine if we own the samples 
    DirectSoundProxy *_dsProxy;
};


void
StaticWaveSoundInstance::Create(MetaSoundDevice *metaDev, 
    SoundContext *soundContext)
{
    DirectSoundDev  *dsDev = metaDev->dsDevice;

    // 'stud' buffer to 'clone'
    DSstaticBuffer *dsMasterBuffer = dsDev->GetDSMasterBuffer(_snd);

    if(dsMasterBuffer==NULL) {
        // Create one and add a master buffer
        DirectSoundProxy *dsProxyForMaster = CreateProxy(dsDev);

        if(!dsProxyForMaster)
            return;             // nothing else to do...

        if(!_samples) { 
            // no master buffer AND no samples?
            // we must be on 2nd view? Get our own samples (XXX set something
            // so we know we have to release these!)

            // XXX a silent standin until we can get the actual samples again
            //     this should be temporary, we need this code to allow us to
            //     dispose of _samples and still be able to age masterbuffers
            //     for now we won't delete _samples
            int bytes = _pcm.GetNumberBytes();
            _samples = (unsigned char *)StoreAllocate(GetSystemHeap(), bytes);
            _ownSamples = true;  // we own these samples now
            memset(_samples, (_pcm.GetSampleByteWidth()==1)?0x80:0x00, bytes);
        }

        // create a new MasterBuffer + fill it with the sound's samples
        dsMasterBuffer = NEW DSstaticBuffer(dsProxyForMaster, &_pcm, _samples);

        // probably won't create another master buffer with this sound
        // XXX actualy this is no longer true now that we are aging master 
        //     buffers.  We now need to keep _samples around since the code
        //     to regenerate them isn't around for the moment, and may not
        //     be the time/space tradeoff we want to make even then...
        // StoreDeallocate(GetSystemHeap(), _samples);
        // _samples = NULL; // for safety's sake...

        // proxy and buffer gets deleted when the device goes away
        dsDev->AddDSMasterBuffer(_snd, dsMasterBuffer);
    }

    // get a proxy (notify the dsDev if it fails)
    if(!_dsProxy)  // may already be set by a previous Create
        _dsProxy = CreateProxy(dsDev);

    if(!_dsProxy)
        return;                 // nothing else to do...

    // create a new staticBuffer cloned from the masterBuffer    
    if(!_staticBuffer) // may already be set by a previous Create
        _staticBuffer = NEW DSstaticBuffer(_dsProxy, dsMasterBuffer->_dsBuffer);
}


void
StaticWaveSoundInstance::CheckResources()
{
    if((!_staticBuffer) || (!_dsProxy))  {
        Create(GetCurrentSoundDevice(), _soundContext);  // re-create our resources
    _staticBuffer->playing = true; // set this so that SetPtr can restart it
    _done = false;                 // so we can go again
    }
}


void
StaticWaveSoundInstance::StartAt(MetaSoundDevice* metaDev, double localTime)
{
    CheckResources(); // re-creates as needed

    Adjust(metaDev);

    double offset = fmod(localTime, _pcm.GetNumberSeconds());
    if(offset < 0)
        offset += _pcm.GetNumberSeconds();

    int phaseBytes = _pcm.SecondsToBytes(offset); // convert to sample domain
    int phasedLocation = phaseBytes % _pcm.GetNumberBytes(); // for safety/looping
    _staticBuffer->setPtr(phasedLocation);

    _staticBuffer->play(_loop);
}


void
StaticWaveSoundInstance::Adjust(MetaSoundDevice*)
{
    CheckResources(); // re-creates as needed

    _staticBuffer->SetGain(_hit ? _gain : Sound::_maxAttenuation);
    _staticBuffer->SetPan(_pan.GetdBmagnitude(), _pan.GetDirection());

    int newFrequency = (int)(_rate * _pcm.GetFrameRate()); // do PitchShift
    _staticBuffer->setPitchShift(newFrequency);

    if(_seek) {
        double sndLength = 0.0;      // default just in case...
        bool value = GetLength(sndLength);
        Assert(value); // always should know the length of a static sound!

        if((_position >= 0.0) && (_position <= sndLength)) { // if legal
            // convert to sample domain
            int phaseBytes = _pcm.SecondsToBytes(_position);

            // for safety/looping  
            // XXX we realy need to stop a sound seeked off the end of!
            int phasedLocation = phaseBytes % _pcm.GetNumberBytes();

            _staticBuffer->setPtr(phasedLocation);
        }

        _seek = false; // reset
    }
}


void
StaticWaveSoundInstance::Mute(bool mute)
{
    if(_staticBuffer)
        _staticBuffer->SetGain(mute ? Sound::_maxAttenuation : _gain);  
}


bool
StaticWaveSoundInstance::Done()
{
    if(_staticBuffer)
        return(!_staticBuffer->_paused && !_staticBuffer->isPlaying());
    else
        return false;
}


bool
StaticWaveSoundInstance::GetLength(double& leng)
{
    leng = _pcm.GetNumberSeconds();
    return true;
}


void 
StaticWaveSoundInstance::ReleaseResources()
{
    // need to check since optimization deletes stopped sounds early!
    if(_staticBuffer) {
        _staticBuffer->stop();  // stop it
        delete _staticBuffer;
        _staticBuffer = NULL;
    }

    // We usualy don't own _samples to worry about releasing
    if(_ownSamples) {
        _ownSamples = false;
        if(_samples) {
            delete _samples; // these must be samples we filled ourselves
            _samples = NULL;
        }
    }

    if(_dsProxy) {
       delete _dsProxy;
       _dsProxy = NULL;
    }
}


SoundInstance *
StaticWaveSound::CreateSoundInstance(TimeXform tt)
{
    return NEW StaticWaveSoundInstance(this, tt, _samples, _pcm);
}


StaticWaveSound::StaticWaveSound(unsigned char *origSamples, PCM *newPCM)
{
    _pcm.SetPCMformat(newPCM); // clone the pcm passed us
    _samples = origSamples;
}


StaticWaveSound::~StaticWaveSound()
{
    extern SoundBufferCache *GetSoundBufferCache();

    if(_samples) { // free samples if they haven't been used/freed yet
        StoreDeallocate(GetSystemHeap(), _samples);
        _samples = NULL;
    }

    GetSoundBufferCache()->DeleteBuffer(this); // delete entries left on cache

    SoundGoingAway(this);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\values\sound\mic.cpp ===
/*++

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Support for the abstract microphone type.

--*/

#include "headers.h"
#include "privinc/mici.h"
#include "privinc/xformi.h"

////////////////  Default microphone  /////////////////////////

class DefaultMicrophone : public Microphone {
  public:
    Transform3 *GetTransform() const { return identityTransform3; }
#if _USE_PRINT
    ostream& Print(ostream& os) const {
        return os << "defaultMicrophone";
    }
#endif
};

Microphone *defaultMicrophone = NULL;

///////////////// Transformed Microphone ////////////////

class TransformedMic : public Microphone {
  public:

    TransformedMic(Transform3 *newXf, Microphone *mic) {
        xf = TimesXformXform(newXf, mic->GetTransform());
    }

    Transform3 *GetTransform() const { return xf; }

#if _USE_PRINT
    ostream& Print(ostream& os) const {
        // TODO... don't have print funcs for xforms.
        return os << "Apply(SOMEXFORM, defaultMic)";
    }
#endif

    virtual void DoKids(GCFuncObj proc) { (*proc)(xf); }

  protected:
    Transform3 *xf;
};

Microphone *TransformMicrophone(Transform3 *xf, Microphone *mic)
{
    return NEW TransformedMic(xf, mic);
}

#if _USE_PRINT
ostream&
operator<<(ostream& os, const Microphone *mic)
{
    return mic->Print(os);
}
#endif

void
InitializeModule_Mic()
{
    defaultMicrophone = NEW DefaultMicrophone;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\values\sound\qmidi.cpp ===
/*++

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    MIDI support

--*/

#include "headers.h"
#include "privinc/soundi.h"
#include "privinc/debug.h"
#include "privinc/except.h"
#include "privinc/qmidi.h"
#include "backend/sndbvr.h"

// min diff needed to bother setting q's rate
double qMIDIsound::_RATE_EPSILON = 0.01;

qMIDIsound::qMIDIsound() : _filterGraph(NULL)
{
    _filterGraph = NEW QuartzRenderer;
}


void qMIDIsound::Open(char *MIDIfileName)
{
    Assert(_filterGraph);
    _filterGraph->Open(MIDIfileName);
}


qMIDIsound::~qMIDIsound()
{
    if (_filterGraph) {
        _filterGraph->Stop();
        
        delete _filterGraph;
    }
}


bool 
qMIDIsound::RenderAvailable(MetaSoundDevice *metaDev)
{
    // XXX eventually we might want to stop forcing this...
    return(true); // quartz always assumed available
}


double 
qMIDIsound::GetLength()
{
    Assert(_filterGraph);
    return(_filterGraph->GetLength());
}


class MIDISoundInstance : public SoundInstance {
  public:
    MIDISoundInstance(LeafSound *snd, TimeXform tt)
    : SoundInstance(snd, tt) {}

    QuartzRenderer *GetMIDI() {
        qMIDIsound *m = SAFE_CAST(qMIDIsound *, _snd);

        Assert(m && m->GetMIDI());
        
        return m->GetMIDI();
    }

    void ReleaseResources() { }

    ~MIDISoundInstance() { 
        QuartzRenderer *filterGraph = GetMIDI();
        
        if(IsUsingMIDIHardware(_txSnd, filterGraph))
            AcquireMIDIHardware(NULL, NULL);
        else {
            // we don't have the hw, no need to stop
            // filterGraph->Stop();
        }
    }

    // ~MIDISoundInstance() { ReleaseResources(); }
    
    void Create(MetaSoundDevice*, SoundContext *) {}
    
    void StartAt(MetaSoundDevice*, double);
    void Adjust(MetaSoundDevice*);
    void Mute(bool mute);

    void CheckResources() {}
    
    bool Done() { return GetMIDI()->QueryDone(); }
    
    void CheckDone();
    
    bool GetLength(double& len) {
        len = GetMIDI()->GetLength();
        return true;
    }
};


void
MIDISoundInstance::CheckDone() 
{
    QuartzRenderer *filterGraph = GetMIDI();

    // give up if our filtergraph doesn't have the hw
    if(!IsUsingMIDIHardware(_txSnd, filterGraph))
        return;
        
    if(filterGraph->QueryDone()) { 
        if(_loop) { // looped sound 
            filterGraph->Position(0.0);
            filterGraph->Play();
        }
        // else nothing left to do, relinquish, shutdown, etc.
    }
}


void
MIDISoundInstance::Adjust(MetaSoundDevice *metaDev) 
{
    QuartzRenderer *filterGraph = GetMIDI();

    // give up if our filtergraph doesn't have the hw
    if (!IsUsingMIDIHardware(_txSnd, filterGraph))
        return;
        
    if(_seek) {
        filterGraph->Position(_position);
        _seek = false;  // reset
    }

    double rateChange = fabs(_rate - _lastRate);
    if (rateChange > qMIDIsound::_RATE_EPSILON) {
        filterGraph->SetRate(_rate); // do Rate
    }

    // unfortunately we expect these to fail
    __try {
        // do Gain
        filterGraph->SetGain(_hit ? _gain : Sound::_maxAttenuation);
    }
    __except( HANDLE_ANY_DA_EXCEPTION )  {
        //_gainWorks = false; // this is dissabled for good Quartz bvr
    }

    __try { // do Pan
        filterGraph->SetPan(_pan.GetdBmagnitude(), _pan.GetDirection()); 
    }
    __except( HANDLE_ANY_DA_EXCEPTION )  {
        //_panWorks = false;  // this is dissabled for good Quartz bvr
    }

    CheckDone();
}


void
MIDISoundInstance::StartAt(MetaSoundDevice* dev, double phase)
{
    TraceTag((tagSoundReaper1,
              "MIDISoundInstance::RenderStart phase=%f, this=0x%08X",
              phase, this));

    QuartzRenderer *filterGraph = GetMIDI();

    // steal the device for OUR sound!
    AcquireMIDIHardware(_txSnd, filterGraph);
    
    Assert(IsUsingMIDIHardware(_txSnd, filterGraph));
    
    double length = filterGraph->GetLength();
    double offset = fmod(phase, length);
    if(offset < 0)
        offset += length;

    filterGraph->Position(offset);
    filterGraph->Play();

    _lastRate = -1;             // force it to adjust rate
    Adjust(dev);
}


void
MIDISoundInstance::Mute(bool mute)
{
    // unfortunately we expect this to fail
    __try {
        GetMIDI()->SetGain(mute ? -200.0 : _gain); // do Gain
    }
    __except( HANDLE_ANY_DA_EXCEPTION )  {
        //_gainWorks = false;  // this is dissabled for good Quartz bvr
    }
}


SoundInstance *
qMIDIsound::CreateSoundInstance(TimeXform tt)
{
    return NEW MIDISoundInstance(this, tt);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\values\sound\midi.cpp ===
/*++

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    The generic MIDI sound

--*/

#include "headers.h"
#include <math.h>
#include <stdio.h>
#include "privinc/soundi.h"
#include "privinc/snddev.h"
#include "privinc/util.h"
#include "privinc/path.h"
#include "privinc/storeobj.h"
#include "privinc/debug.h"
#include "privinc/except.h"

#include <unknwn.h>
#include <objbase.h> // needed for DEFINE_GUID

#ifdef SOMETIME


MIDIsound::MIDIsound(char *MIDIfileName)
{
// initialize
_started  = FALSE;
_ended    = FALSE;
_looping  = FALSE;
_section  =  NULL;  // section not loaded yet!

// stash away a copy of the filename
fileName = (char *)ThrowIfFailed(malloc(lstrlen(MIDIfileName) + 1)); // grab a long enough hunk
lstrcpy(fileName, MIDIfileName);
}


MIDIsound::~MIDIsound()
{
    TraceTag((tagGCMedia, "~MIDISound %x - NYI", this));
    return;
    
    BufferElement *bufferElement;

    // walk list destroying everything...
    while(!bufferList.empty()) {
        bufferElement = bufferList.front();

        // XXX what all has to be stoped, released, destroyed??

        if(_section)
            _section->Release();


        free(bufferElement->path);
        delete bufferElement;
        bufferList.pop_front();
    }
}


bool MIDIsound::RenderAvailable(MetaSoundDevice *metaDev)
{
    AudioActiveDev  *aaDev   = metaDev->aaDevice;

    TraceTag((tagSoundRenders, "MIDIsound:Render()"));

    return(aaDev->_aactiveAvailable);
}


void MIDIsound::RenderStop(MetaSoundDevice *metaDev, 
    BufferElement *bufferElement)
{
    AudioActiveDev  *aaDev   = metaDev->aaDevice;

    if(aaDev->_aaEngine) {
        _ended   = FALSE;
        _started = FALSE;
        aaDev->_aaEngine->Stop(); // stop it
        }
}


void MIDIsound::RenderNewBuffer(MetaSoundDevice *metaDev)
{
#ifdef RESTORE_WHEN_WE_PUT_AA_BACK_IN
    AudioActiveDev  *aaDev = metaDev->aaDevice;

    bufferElement->firstTime = GetCurrTime(); // need to know time to phase

    if(!aaDev->_aaEngine) {
        __try {
            aaDev->_aaEngine = NEW AAengine();
            aaDev->_aaEngine->RegisterSink(this);
        }
        __except( HANDLE_ANY_DA_EXCEPTION )  {
            aaDev->_aactiveAvailable = FALSE; // couldn't initialize AA!
            if(aaDev->_aaEngine)
                delete aaDev->_aaEngine;

#ifdef _DEBUG
            // XXX popup message continuing w/o MIDI
            fprintf(stderr, "MIDIsound::RenderNewBuffer failed to create AAengine (%s)", errMsg);
            fprintf(stderr, "continuing w/o MIDI!\n");
#endif
        }
    }

    __try {
        // play the midi file
        if(!_section) { // load the section if needed
            aaDev->_aaEngine->LoadSectionFile(fileName, &_section);
        }

        aaDev->_aaEngine->PlaySection(_section);
        _started = TRUE;
    }
    __except( HANDLE_ANY_DA_EXCEPTION ) {
        if(_section)
            _section->Release(); // XXX delete it, too?
        RETHROW;
    }

#endif
}


void MIDIsound::RenderAttributes(MetaSoundDevice *metaDev, 
    BufferElement *bufferElement, double rate, bool doSeek, double seek)
{
    AudioActiveDev  *aaDev   = metaDev->aaDevice;

    aaDev->_aaEngine->SetGain(metaDev->GetGain()); // do Gain
    aaDev->_aaEngine->SetRate(rate);               // do Rate

    //XXX Note: We would 'setpan' here if we knew how to move all of the
    //          MIDI instruments around!
    //aaDev->_aaEngine->SetPan(metaDev->GetPan()); // do Pan

    if(_ended && _started) { // if what we were playing has stopped
        if(metaDev->GetLooping()) { // looped sound 
            _ended   = FALSE;       // restart the sound
            _started = TRUE;
            aaDev->_aaEngine->PlaySection(_section);
        }
        // else nothing left to do, relinquish, shutdown, etc.
    }
}


void MIDIsound::RenderStartAtLocation(MetaSoundDevice *metaDev,
    BufferElement *bufferElement, double phase, Bool looping)
{
// XXX realy should start the MIDI playing, here!
}


Bool MIDIsound::RenderPhaseLessThanLength(double phase)
{
//return(phase < (-1*lengthInSecs));
return(1); // XXX since we don't know the play time of a midi sec we return 1
}


void MIDIsound::RenderSetMute(
    MetaSoundDevice *metaDev, BufferElement *bufferElement)
{
    AudioActiveDev  *aaDev   = metaDev->aaDevice;

    if(aaDev->_aaEngine)
        aaDev->_aaEngine->SetGain(0.0); // mute sound 
}


// XXX next two methods are temporarialy stubed in!
Bool MIDIsound::RenderCheckComplete(
    MetaSoundDevice *metaDev, BufferElement *bufferElement)
{
return FALSE;
}


void MIDIsound::RenderCleanupBuffer(
    MetaSoundDevice *metaDev, BufferElement *bufferElement)
{
}


HRESULT MIDIsound::OnSectionEnded(DWORD, IAASection FAR *pSection, 
    AAFlags flags, DWORD lEndTime)
{
//printf("section ended\n");
_ended = TRUE;  // notified that the section ended
return S_OK;
}

#endif /* SOMETIME */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\values\sound\sattr.cpp ===
/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

    Sound attributers

*******************************************************************************/

#include "headers.h"
#include "privinc/soundi.h"
#include "privinc/snddev.h"
#include "privinc/debug.h"
#include "appelles/axaprims.h"
#include "appelles/arith.h"
#include "privinc/basic.h"
#include "privinc/util.h"
#include "privinc/gendev.h"  // DeviceType

// definition of Sound static members
double Sound::_minAttenuation =     0;  // in dB
double Sound::_maxAttenuation = -1000;  // in dB (order of magnitude overkill)

//////// Looping ////////

class LoopingSound : public Sound {
  public:
    LoopingSound(Sound *snd) : _sound(snd) {}

    virtual void Render(GenericDevice& dev); 

#if _USE_PRINT
    ostream& Print(ostream& s) {
        return s << "Looping(" << _sound << ")";
    }
#endif

    virtual void DoKids(GCFuncObj proc) {
        (*proc)(_sound); 
        Sound::DoKids(proc);
    }

  protected:
    Sound *_sound;
};


void LoopingSound::Render(GenericDevice& _dev) 
{
    if (_dev.GetDeviceType()!=SOUND_DEVICE) {
        _sound->Render(_dev);   // just descend!
    }
    else { // we have a sound device and RENDER_MODE

        MetaSoundDevice *metaDev = SAFE_CAST(MetaSoundDevice *, &_dev);

        TraceTag((tagSoundRenders, "LoopingSound:Render()"));

        if (!metaDev->IsLoopingSet()) {
            metaDev->SetLooping();
            _sound->Render(_dev);    // render it looped
            metaDev->UnsetLooping();
        } else {
            _sound->Render(_dev);    // render it not looped
        }
    }
}


Sound *ApplyLooping(Sound *snd) { return NEW LoopingSound(snd); }

//////// Gain ////////

class GainSound : public Sound {
  public:
    GainSound( Real g, Sound *s ) : _gain( g ), _sound(s) {}

    virtual void Render(GenericDevice& dev);

#if _USE_PRINT
    ostream& Print(ostream& s) {
        return s << "Gain(" << _gain << ")(" << _sound << ")";
    }
#endif

    virtual void DoKids(GCFuncObj proc) {
        (*proc)(_sound); 
        Sound::DoKids(proc);
    }

  protected:
    Real  _gain;
    Sound *_sound;
};


void GainSound::Render(GenericDevice& _dev) 
{
    if(_dev.GetDeviceType()!=SOUND_DEVICE) {
        _sound->Render(_dev);  // just descend
    }
    else {
        MetaSoundDevice *metaDev = SAFE_CAST(MetaSoundDevice *, &_dev);

        TraceTag((tagSoundRenders, "GainSound:Render()"));

        // Gain composes into the context multiplicatively
        double stashed = metaDev->GetGain(); // stash to later restore

        // Gain is accumulates multiplicatively in the linear space (exposed)
        metaDev->SetGain(stashed * _gain);
        _sound->Render(_dev);
        metaDev->SetGain(stashed);
    }
}


Sound *ApplyGain(AxANumber *g, Sound *s)
{ return NEW GainSound(NumberToReal(g), s); }


//////// Pan ////////

class PanSound : public Sound {
  public:
    PanSound(Real pan, Sound *s) : _sound(s), _pan(pan) {}
    virtual void Render(GenericDevice& dev);

#if _USE_PRINT
    ostream& Print(ostream& s) {
        return s << "Pan(" << _pan << ")(" << _sound << ")";
    }
#endif

    virtual void DoKids(GCFuncObj proc) {
        (*proc)(_sound); 
        Sound::DoKids(proc);
    }

  protected:
    Sound    *_sound;
    double    _pan;
};


void PanSound::Render(GenericDevice& _dev) 
{
    if (_dev.GetDeviceType() != SOUND_DEVICE) {
        _sound->Render(_dev); // just descend
    }
    else {
        MetaSoundDevice *metaDev = SAFE_CAST(MetaSoundDevice *, &_dev);

        TraceTag((tagSoundRenders, "PanSound:Render()"));

        double stashed = metaDev->GetPan();

        metaDev->SetPan(_pan + stashed); // additivly apply pan
        _sound->Render(_dev);
        metaDev->SetPan(stashed); // restore the stashed pan value
    }
}


Sound *ApplyPan(AxANumber *g, Sound *s) 
{
    return NEW PanSound(NumberToReal(g), s); 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\values\sound\sound.cpp ===
/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

    Specification and implementation of Sound *subclasses.

*******************************************************************************/

#include "headers.h"
#include "privinc/helpds.h"  //dsound helper routines
#include "privinc/soundi.h"
#include "privinc/snddev.h"
#include "privinc/dsdev.h"
#include "privinc/util.h"
#include "privinc/debug.h"
#include "privinc/miscpref.h"
#include "privinc/bufferl.h" // buffer element stuff
#include "backend/sndbvr.h"

#define THREADED

extern miscPrefType miscPrefs; // registry prefs struct setup in miscpref.cpp

//////////////  Silence Sound ///////////////////
class SilentSound : public Sound {
  public:
    void Render(GenericDevice&)
        { TraceTag((tagSoundRenders, "SilentSound:Render()")); }

#if _USE_PRINT
    ostream& Print(ostream& s) { return s << "silence"; }
#endif
};

Sound *silence = NULL;


//////////////  Mixed Sound  ///////////////
class MixedSound : public Sound {
  public:

    MixedSound(Sound *s1, Sound *s2) : sound1(s1), sound2(s2) {}

    void Render(GenericDevice& _dev) {
        TraceTag((tagSoundRenders, "MixedSound:Render()"));

        // Just render the two component sounds individually
        sound1->Render(_dev);
        sound2->Render(_dev);
    }

#if _USE_PRINT
    ostream& Print(ostream& s) {
        return s << "(" << sound1 << " + " << sound2 << ")";
    }
#endif

    virtual void DoKids(GCFuncObj proc) {
        (*proc)(sound1);
        (*proc)(sound2);
        Sound::DoKids(proc);
    }

  protected:
    Sound *sound1;
    Sound *sound2;
};

Sound *Mix(Sound *snd1, Sound *snd2)
{
    if (snd1 == silence) {
        return snd2;
    } else if (snd2 == silence) {
        return snd1;
    } else {
        return NEW MixedSound(snd1, snd2);
    }
}

Sound *MixArray(AxAArray *snds)
{
    snds = PackArray(snds);
    
    int numSnds = snds->Length();
    
    if (numSnds < 1) {
       RaiseException_UserError(E_FAIL, IDS_ERR_INVALIDARG);
    }

    Sound *finalSnd = (Sound *)(*snds)[numSnds-1];

    if (numSnds > 1) {
        for(int i=numSnds-2; i>=0; i--) {
            finalSnd = Mix((Sound *)(*snds)[i], finalSnd);
        }
    }
    
    return finalSnd;
}


bool LeafDirectSound::RenderAvailable(MetaSoundDevice *metaDev)
{
    return(metaDev->dsDevice->_dsoundAvailable);
}


LeafSound::~LeafSound()
{
    TraceTag((tagSoundReaper1, "LeafSound::~LeafSound sound=0x0%8X", this));
}


double fpMod(double value, double mod)
{
    double remainder;
    double tmp;
    long whole;
    double result;

    Assert(mod > 0.0);

    tmp = value / mod;
    whole = (long)tmp;
    remainder = tmp - whole;
    result = remainder * mod;

    return(result);
}

#ifdef OLD_SOUND_CODE
extern miscPrefType miscPrefs; // registry prefs struct setup in miscpref.cpp
void LeafSound::Render(GenericDevice& _dev)
{
    double localTime1 =   0.0; // this is also phase

    // XXX shouldn't renderAvailable be doing this?  ifdef and verify!
    if(_dev.GetDeviceType() != SOUND_DEVICE)
        return;  // Game over Mon...

    MetaSoundDevice *metaDev = SAFE_CAST(MetaSoundDevice *, &_dev);

    // pull buffer from bufferlist based on path if available
    AVPath path = metaDev->GetPath(); // find Buffer based on SoundPath

    Mode renderMode = _dev.GetRenderMode();
    if(renderMode==STOP_MODE) {
#if _DEBUG
#if _USE_PRINT
        if(IsTagEnabled(tagSoundPath)) {
            TraceTag((tagSoundPath, "Stopping sub-path: <%s>", 
            AVPathPrintString2(path)));
        }
#endif
#endif
        // stop and remove buffers of all leafSounds on this subtree
        // or mute them if runOnce'd 
        metaDev->_bufferListList->DeleteBufferOnSubPath(this, path);

        return; // take the afternoon off...
    }

    if(AVPathContains(path, SNAPSHOT_NODE)) // snapShot'd path?
        return; // snapshot'd sounds are silent!

    if(!RenderAvailable(metaDev)) // should we stub out?
        return;                   // return immediatly!

#if _DEBUG
#if _USE_PRINT
    // Check to avoid AVPathPrintString call
        if (IsTagEnabled(tagSoundPath)) {
            TraceTag((tagSoundPath, "LeafSound::Render path: <%s>",
                      AVPathPrintString2(path)));
        }
#endif
#endif

    BufferElement *bufferElement = 
        metaDev->_bufferListList->GetBuffer(this, path); 
    if(bufferElement && !bufferElement->_valid)
        return; // return immediately on invalid==completed buffers!

    if((renderMode==RENDER_MODE)||(renderMode==RENDER_EVENT_MODE)){
        if(!bufferElement) {
            
            // is the sound run once?
            // yup, check if it is a restarted run once'd sound and relabel
            if(AVPathContains(path, RUNONCE_NODE) &&
               metaDev->_bufferListList->FindRelabel(this, path)) {
            }
            else { // sound not a restarted runonce.  create NEW sound instance
                __try {
                    RenderNewBuffer(metaDev); // creates NEW buffer + stores on device
                }
                __except( HANDLE_ANY_DA_EXCEPTION )  {
                    TraceTag((tagError, 
                        "RenderNewBuffer exception, skipping this sound"));
                    return;  // nothing we can do skip this NEW sound, but we 
                             // should catch it so the render may continue
                }
            }
        bufferElement =  // OK, now get the one we just created...
            metaDev->_bufferListList->GetBuffer(this, path); 
        Assert(bufferElement); // we should have a valid buffer by this point!
        bufferElement->SetRunOnce(AVPathContains(path, RUNONCE_NODE));
        }
    }

    // render attributes
    if(renderMode==RENDER_MODE) {
        double      slope =   1.0;  // set defaults
        double      servo =   0.0;
        double       seek =   0.0;
          bool     doSeek = false;
          bool      newTT = false;

        //class CView; // for CView GetCurrentView();

        // compute, rate, phase, localTime based on timeTransform
          //TimeSubstitution timeTransform = metaDev->GetTimeTransform();
          TimeXform timeTransform = metaDev->GetTimeTransform();
        if(timeTransform && !timeTransform->IsShiftXform()) {
            // XXX NOTE: 1st evaluation of a TT MUST be using the current time!
            double time1 = metaDev->GetCurrentTime();
            localTime1   = EvalLocalTime(timeTransform, time1);

#ifdef DYNAMIC_PHASE
            // determine if the timeTransform changed from last time!
            double lastTTtime = bufferElement->GetLastTTtime(); // last time
            double lastTTeval = bufferElement->GetLastTTeval(); // last eval

            double currentTTeval = EvalLocalTime(timeTransform, lastTTtime);
            if(currentTTeval != lastTTeval)
                newTT = true;
#endif

            double epsilon = GetCurrentView().GetFramePeriod();
            // XXX epsilon must never be zero (would cause a zero run!)
            if(epsilon < 0.01)
                epsilon = 0.01;

            // time2 -> end of time interval (currentTime + Epsilon)
            double time2      = time1 + epsilon;
            double localTime2 = EvalLocalTime(timeTransform, time2);

#ifdef DYNAMIC_PHASE
            // time3 -> used to detect pause transition between t1 and t2!
            double time3      = time2 + epsilon;
            double localTime3 = EvalLocalTime(timeTransform, time3);

            // calculate rate == 1st derivative, slope
            if(localTime2 == localTime3)
                slope = 0; // a hack to detect pause between t1 and t2...
            else
#endif
                slope = (localTime2 - localTime1) / (time2 - time1);

#ifdef DYNAMIC_PHASE
            // cache tt information for next time
            bufferElement->SetLastTTtime(time1);
            bufferElement->SetLastTTeval(localTime1);
#endif

            TraceTag((tagSoundDebug, "slope:%f (%f,%f), (%f,%f) e:%f",
                (float)slope, 
                (float)time1, (float)localTime1,
                (float)time2, (float)localTime2, epsilon));
        }


#ifdef SYNCHONIZE_ME
#define SEEK_THREASHOLD 0.2
        //if(miscPrefs._synchronize) { // play with mediaTime
        if(0) { // play with mediaTime
            double mediaTime;

            if(RenderPosition(metaDev, &mediaTime)) { //implemented?
                // compare it to our sampling time and the instanteneous time
                double globalTime = GetCurrentView().GetCurrentGlobalTime();

                // time transform it as needed
                double localTime;
                if(timeTransform) { // time transform the globalTime...
                    localTime = TimeTransform(timeTransform, globalTime);
                }
                else {
                    localTime = globalTime;
                }

                // watch them drift
                double diff = mediaTime - localTime;

                // servo rate to correct, or phase to jump if too great?
                if(abs(diff) < SEEK_THREASHOLD)
                    servo = -0.1 * diff;  // servo to correct
                else {
                    doSeek = true;
                    seek   = localTime;   // seek to where we ought to be
                    // XXX but what is an appropriate slope?
                    //    (calculated, last, or unit slope?)
                    slope  = 1.0;
                }
#ifdef _DEBUG
                printf("d:%f, s:%f seek:%f\n", diff, servo, seek);
#endif
            }
        }
#endif



        // seek as needed and play at rate slope and attributes on the devContext
        double rate =  slope + servo;
            seek = localTime1;
            doSeek = newTT;

    #ifdef DYNAMIC_PHASE
            // are we seeking off the end of a non-looped sound?
            if(doSeek) {
                double soundLength = GetLength();

                if(metaDev->GetLooping()){
                    seek = fpMod(seek, soundLength);
                }
                else { // not looped
                    // XXX actually if you seek off the front of a non-looped sound
                    //     we really should wait to play it a while...
                    if((seek < 0.0) || (seek >= soundLength)) {
                        // we seeked off the end of the sound
                        metaDev->_bufferListList->RemoveBuffer(this, path); 
                        return; // take the afternoon off...
                    }
                }
            }
    #endif

            rate = fsaturate(0.0, rate, rate); // elliminate non-negative rates!
            RenderAttributes(metaDev, bufferElement, rate, doSeek, seek);
            bufferElement->SetIntendToMute(false);
        }

        if (renderMode==MUTE_MODE) 
            RenderSetMute(metaDev, bufferElement);

        //determine if instantiation should be started, or if it has ended
        if ((renderMode==RENDER_MODE)||
            (renderMode==RENDER_EVENT_MODE)||
            (renderMode==MUTE_MODE)) {
            if(!bufferElement->_playing) { // evaluate starting the buffer
                double currentTime;

                if(bufferElement->SyncStart()) { 
                    DWORD lastTimeStamp, currentTimeStamp;
                    Time foo = 
                       ViewLastSampledTime(lastTimeStamp, currentTimeStamp);
                    DWORD currentSystemTime = GetPerfTickCount();
                    double delta = Tick2Sec(currentSystemTime - currentTimeStamp);
                    currentTime = delta + metaDev->GetCurrentTime();
                }
                else 
                    currentTime = metaDev->GetCurrentTime();  // sample time

                //TimeSubstitution timeTransform = metaDev->GetTimeTransform();
                TimeXform timeTransform = metaDev->GetTimeTransform();
                double localTime = (timeTransform) ? 
                    EvalLocalTime(timeTransform, currentTime) :
                    currentTime;

                if(metaDev->GetLooping()){
                    // looping start now at a phased location
                    RenderStartAtLocation(metaDev, bufferElement, localTime, 
                                          metaDev->GetLooping());
                }
                else {  // not looping -> potentialy delay start for the future
                    if(localTime >  GetLength()) {
                        // sound has already completed
                        bufferElement->_playing = TRUE;
                    }
                    else if(localTime >= 0.0) {
                        DWORD beforeTime, afterTime, deltaTime;
                        beforeTime = GetPerfTickCount();

                        // not looping, start at beggining after proper delay
                        RenderStartAtLocation(metaDev, bufferElement, localTime,
                                                  metaDev->GetLooping());

                        afterTime = GetPerfTickCount();
                        deltaTime = afterTime - beforeTime;
                        }
                    }
                }                           /* not looping */
            else { // playing not runonce, check for sound termination
                bool complete = 
                    RenderCheckComplete(metaDev, bufferElement)?true:false;

                if(complete)
                    TriggerEndEvent();

                if((!AVPathContains(path, RUNONCE_NODE)) && complete) {
                    RenderCleanupBuffer(metaDev, bufferElement);
                    bufferElement->_valid = FALSE;

    #if _DEBUG
    #if _USE_PRINT
                    // Check to avoid AVPathPrintString call
                    if (IsTagEnabled(tagSoundPath)) {
                        TraceTag((tagSoundReaper1,
                                  "LeafSound::Render found <%s> stopped",
                                  AVPathPrintString2(bufferElement->GetPath())));
                    }
    #endif
    #endif

                    // XXX we really should notify the server too, so it can prune
                    //     and process done!
                }
            }
        }

#ifdef THREADED
#else
    // Well, it is like this.  Only synthesizers used this method, and
    // this method is now being called from the other thread.
    if ((renderMode==RENDER_MODE) || (renderMode==MUTE_MODE))
         RenderSamples(metaDev, path);  // xfer samples as needed
#endif /* THREADED */
}
#endif /* OLD_SOUND_CODE */

#if _USE_PRINT
ostream&
operator<<(ostream& s, Sound *sound)
{
    return sound->Print(s);
}
#endif

SoundInstance *
CreateSoundInstance(LeafSound *snd, TimeXform tt)
{
    return snd->CreateSoundInstance(tt);
}

class TxSound : public Sound {
  public:
    TxSound(LeafSound *snd, TimeXform tt) : _snd(snd), _tt(tt) {}

    // NOTE: TxSound always allocated on GCHeap
    ~TxSound() {
        SoundGoingAway(this);
        // ViewGetSoundInstanceList()->Stop(this);
    }

    virtual void Render(GenericDevice& dev) {
        // TODO: this will be gone
        if(dev.GetDeviceType() != SOUND_DEVICE) {
            _snd->Render(dev); // just descend!
        } else { 
            Assert(ViewGetSoundInstanceList());
        
            SoundInstance *s =
                ViewGetSoundInstanceList()->GetSoundInstance(this);

            s->CollectAttributes(SAFE_CAST(MetaSoundDevice *, &dev));
        }
    }

#if _USE_PRINT
    ostream& Print(ostream& s) {
        return s << "(" << _snd << "," << _tt << ")";
    }
#endif

    virtual void DoKids(GCFuncObj proc) {
        Sound::DoKids(proc);
        (*proc)(_snd);
        (*proc)(_tt);
    }

  protected:
    LeafSound *_snd;
    TimeXform _tt;
};

Sound *
NewTxSound(LeafSound *snd, TimeXform tt)
{
    return NEW TxSound(snd, tt);
}

void
InitializeModule_Sound()
{
    silence = NEW SilentSound; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\values\sound\tmpguid.cpp ===
/**********************************************************************
Temp hack to declare these guids 
**********************************************************************/
#include "headers.h"
#include <windows.h>
#include <initguid.h>


// 05589f81-c356-11ce-bf01-00aa0055595a        FORMAT_WaveFormatEx
DEFINE_GUID(FORMAT_WaveFormatEx,
0x05589f81, 0xc356, 0x11ce, 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\values\sound\stream.cpp ===
/*++

Copyright (c) 1995-97 Microsoft Corporation

Abstract:

    Streaming sounds, synth support

--*/

#include "headers.h"
#include "privinc/helpds.h" 
#include "privinc/soundi.h"
#include "privinc/dsdev.h"
#include "privinc/snddev.h"
#include "privinc/util.h"
#include "privinc/sndfile.h"
#include "privinc/bground.h"
#include "privinc/bufferl.h"
#include "backend/sndbvr.h"

#define THREADED // turn on threaded synthesizers

class SinSynth : public LeafDirectSound {
  public:
    SinSynth(double newFreq=1.0);

    virtual SoundInstance *CreateSoundInstance(TimeXform tt);

#if _USE_PRINT
    ostream& Print(ostream& s) {
        return s << "SinSynth";
    }
#endif

  protected:
    double _sinFrequency;
};


class SinSynthSoundInstance : public SoundInstance {
  public:
    SinSynthSoundInstance(LeafSound *snd, TimeXform tt, double sf, PCM& pcm)
    : SoundInstance(snd, tt), _sinFrequency(sf),
      _synthBufferElement(NULL), _pcm(pcm) {}

    void ReleaseResources() {
        if(_synthBufferElement) {
            Assert(_synthBufferElement->GetStreamingBuffer());
            
            if(_synthBufferElement->GetThreaded())
                _synthBufferElement->SetKillFlag(true);
            else {
                _synthBufferElement->GetStreamingBuffer()->stop();
                delete _synthBufferElement;
                _synthBufferElement = NULL;
            }
        }
    }

    ~SinSynthSoundInstance() { ReleaseResources(); }

    void Create(MetaSoundDevice*, SoundContext *);
    void StartAt(MetaSoundDevice*, double);
    void Adjust(MetaSoundDevice*);
    void Mute(bool mute);
    bool Done() { return false; }
    bool GetLength(double&) { return false; }

  protected:
    SynthBufferElement *_synthBufferElement;
    double _sinFrequency;
    PCM& _pcm;

  private:
    void CheckResources();
};


void
SinSynthSoundInstance::Create(MetaSoundDevice *metaDev, SoundContext *)
{
    // XXX we probably don't want to do this everytime, but we can't
    //     do it in the constructor since we don't have the device then...
    // 16bit, mono, primary-buffer==native rate)
    DirectSoundDev  *dsDev = metaDev->dsDevice;

    // get a proxy (notify the dsDev if it fails)
    DirectSoundProxy *dsProxy = CreateProxy(dsDev);
    if(!dsProxy)
        return;                         // nothing else to do...

    _pcm.SetPCMformat(2, 1, dsProxy->GetPrimaryBuffer()->getSampleRate());

    DSstreamingBuffer *sbuffer = NEW DSstreamingBuffer(dsProxy, &_pcm);

    // setup the sin wave synth
    // create NEW element to hold our synth stuff
    _synthBufferElement = 
        NEW SynthBufferElement(sbuffer, dsProxy,
                               _sinFrequency, 0.0, _pcm.GetFrameRate());

#ifdef THREADED 
    dsDev->AddSound(_snd, metaDev, _synthBufferElement);
#endif /* THREADED */
}


void
SinSynthSoundInstance::CheckResources()
{
    if(!_synthBufferElement) {
        Create(GetCurrentSoundDevice(), (SoundContext *)0);  // re-create our resources
        _done = false;                    // so we can go again
    }
}


void
SinSynthSoundInstance::Adjust(MetaSoundDevice *metaDev)
{
    CheckResources();
    DSstreamingBuffer *streamingBuffer =
        _synthBufferElement->GetStreamingBuffer();

    if(_hit)
        streamingBuffer->SetGain(_gain);
    
    streamingBuffer->SetPan(_pan.GetdBmagnitude(), _pan.GetDirection());

    // TODO:
    metaDev->dsDevice->SetParams(_synthBufferElement, _rate, false, 0.0, _loop);
}


void
SinSynthSoundInstance::StartAt(MetaSoundDevice *metaDev, double)
{
    CheckResources();

#ifdef LATERON
    DirectSoundDev  *dsDev = metaDev->dsDevice;

    long sampleOffset =
        (long)(phase * dsDev->primaryBuffer->getSampleRate());
    //(long)(phase * dsDev->primaryBuffer->getSampleRate() / pitchShift);
    sampleOffset %= _soundFile->GetFrameCount();

    value += sampleOffset * delta??
#endif /* LATERON */
        
    _synthBufferElement->_playing = TRUE;
}


void
SynthBufferElement::RenderSamples()
{
    DSstreamingBuffer *streamingBuffer = GetStreamingBuffer();

    int framesFree;
    short buffer[100000]; // XXX set worstcase size == buffer size!

    double pitchShift   = _rate; // do PitchShift
    double currentDelta = _delta * pitchShift;
    double sampleRate   = 
        GetDSproxy()->GetPrimaryBuffer()->getSampleRate();

    if(framesFree = streamingBuffer->framesFree()) {
        double offset = 0.0; //sampleRate / pitchShift;
        //double offset = metaDev->GetPhase() * sampleRate / pitchShift;

        // For now synth, and xfer samples within render 
        for(int x = 0; x < framesFree; x++) {
            buffer[x]= (short)(32767.0 * sin(_value + offset));
            _value += currentDelta;
        }

        streamingBuffer->writeFrames(buffer, framesFree); // write samps!

        if(!streamingBuffer->_paused && !streamingBuffer->isPlaying())
            streamingBuffer->play(TRUE);  // start buffer looping
    }

    // all streamingSound::RenderSamples must update stats!
    streamingBuffer->updateStats();  // keep track of samples consumed
}


void
SinSynthSoundInstance::Mute(bool mute)
{
    CheckResources();
    _synthBufferElement->GetStreamingBuffer()->
        SetGain(mute ? Sound::_maxAttenuation : _gain); 
}


Bvr sinSynth;

void InitializeModule_SinSynth()
{
    sinSynth = SoundBvr(NEW SinSynth());
    //XXX put this back in later... getLeafSoundList()->AddSound(sinSynth);
    // or register dynamic deleater
}

SinSynth::SinSynth(double newFreq): _sinFrequency(newFreq) {}

SoundInstance *
SinSynth::CreateSoundInstance(TimeXform tt)
{
    return NEW SinSynthSoundInstance(this, tt, _sinFrequency, _pcm);
}

#ifdef DONT_DELETE_ME_I_HAVE_SYNC_CODE_EMBEDDED_IN_ME
StreamPCMfile::~StreamPCMfile()
{
    TraceTag((tagGCMedia, "~StreamPCMfile %x - NYI", this));
    return;
    
    BufferElement *bufferElement;

    while(!bufferList.empty()) { // walk bufferList destroying everything
        bufferElement = bufferList.front();

        ASSERT(bufferElement);
        if(bufferElement) {
            if(bufferElement->GetStreamingBuffer()) {
               bufferElement->GetStreamingBuffer()->stop();
               delete bufferElement->GetStreamingBuffer();
            }

            if(bufferElement->path)
                free(bufferElement->path);

            delete bufferElement;
        }
        bufferList.pop_front();
    }

    // destroy everything created in the constructor
    if(_fileName)
       free(_fileName);

    if(_soundFile)
       delete _soundFile;
}


void StreamPCMfile::RenderAttributes(MetaSoundDevice *metaDev, 
    BufferElement *bufferElement, double rate, bool doSeek, double seek)
{
    DirectSoundDev  *dsDev = metaDev->dsDevice;

    int attenuation = linearGainToDsoundDb(metaDev->GetGain()); // do Gain
    bufferElement->GetStreamingBuffer()->setGain(attenuation);

    int pan = linearPanToDsoundDb(metaDev->GetPan());   // do Pan
    bufferElement->GetStreamingBuffer()->setPan(pan);

    int newFrequency = (int)(rate * _sampleRate);
    bufferElement->GetStreamingBuffer()->setPitchShift(newFrequency);

    dsDev->SetParams(bufferElement->path, metaDev->GetPitchShift());

    if(0)
    { // servo
    // all streamingSound::RenderSamples must update stats!
    bufferElement->GetStreamingBuffer()->updateStats();  // keep track of samples consumed

    // get the buffer's media time
    Real mediaTime = bufferElement->GetStreamingBuffer()->getMediaTime();

    // compare it to our sampling time and the instanteneous time 
    Real globalTime = GetCurrentView().GetCurrentGlobalTime();

    // time transform it as needed (guess we will need to pass tt down here)
    // XXX I will after //trango goes back online!
    Bool tt = FALSE;

    Real localTime;
    if(!tt) {
        localTime = globalTime;
    }
    else {
        // time transform the globalTime...
        localTime = globalTime;
    }

    // watch them drift
    Real diff = mediaTime - localTime;

    // servo rate to correct, or phase to jump if too great?
    }
}


bool StreamPCMfile::RenderPosition(MetaSoundDevice *metaDev, 
    BufferElement *bufferElement, double *mediaTime)
{
    // all streamingSound::RenderSamples must update stats!
    bufferElement->GetStreamingBuffer()->updateStats();  // keep track of samples consumed

    // get the buffer's media time
    *mediaTime = bufferElement->GetStreamingBuffer()->getMediaTime();

    return(TRUE); // implemented
}


void StreamPCMfile::RenderStartAtLocation(MetaSoundDevice *metaDev,
    BufferElement *bufferElement, double phase, Bool loop)
{
    DirectSoundDev  *dsDev = metaDev->dsDevice;

    long sampleOffset =
        (long)(phase * dsDev->primaryBuffer->getSampleRate());
        //(long)(phase * dsDev->primaryBuffer->getSampleRate() / pitchShift);
    sampleOffset %= _soundFile->GetFrameCount();

    _soundFile->SeekFrames(sampleOffset, SEEK_SET); 
    bufferElement->playing = TRUE;
}


void StreamPCMfile::RenderSamples(MetaSoundDevice *metaDev, 
    BufferElement *bufferElement)
{
    int framesFree;
    short buffer[100000]; // XXX set worstcase size == buffer size!

    if(framesFree = bufferElement->GetStreamingBuffer()->framesFree()) {
        int actualFramesRead; 

        // For now read, xfer samples within render 
        // (will eventualy be in another thread)
        if(actualFramesRead = _soundFile->ReadFrames(buffer, framesFree)) {
            bufferElement->GetStreamingBuffer()->writeFrames(buffer, actualFramesRead); 

            if(!bufferElement->GetStreamingBuffer()->_paused && 
               !bufferElement->GetStreamingBuffer()->isPlaying())
                // start it (XXX find better way)
                bufferElement->GetStreamingBuffer()->play(TRUE);  // start buffer looping
            }
        else { // actualFramesRead == 0 
            if(metaDev->GetLooping())
                _soundFile->SeekFrames(0, SEEK_SET); // restart the sound!
            else { // non-looping sound ending
                if(!bufferElement->GetStreamingBuffer()->_flushing)
                    bufferElement->GetStreamingBuffer()->_flushing = 1;

                // flush the dsound buffer  (XXX fix dsound!)
                // NOTE: this may/will take a number of tries waiting for the 
                //       last samples to play out!
                framesFree = bufferElement->GetStreamingBuffer()->framesFree();
                bufferElement->GetStreamingBuffer()->writeSilentFrames(framesFree);
                bufferElement->GetStreamingBuffer()->_flushing+= framesFree;

                if(bufferElement->GetStreamingBuffer()->_flushing > 
                   bufferElement->GetStreamingBuffer()->TotalFrames()) {
                    // XXX self terminate sound
                    // XXX close the buffer after it has played out
                }
            }

        }
    }

    // all streamingSound::RenderSamples must update stats!
    bufferElement->GetStreamingBuffer()->updateStats();  // keep track of samples consumed
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\values\sound\stquartz.cpp ===
/*++

Copyright (c) 1995-97 Microsoft Corporation

Abstract:

    Streaming quartz sound

--*/

#include "headers.h"
#include "privinc/soundi.h"
#include <ddraw.h>
#include "privinc/snddev.h"
#include "privinc/util.h"
#include "privinc/debug.h"
#include "privinc/bground.h"
#include "privinc/stquartz.h"
#include "privinc/helpds.h"
#include "backend/sndbvr.h"
#include "privinc/bufferl.h"


#define THREADED // turn on threaded synthesizers
extern SoundBufferCache *GetSoundBufferCache();

StreamQuartzPCM::StreamQuartzPCM(char *fileName)
    : _fileName(NULL), _latency(0.5), _buffer(NULL)
{
    _fileName = (char *)
        StoreAllocate(GetSystemHeap(), strlen(fileName)+1);
    strcpy(_fileName, fileName); // copy fileName

    // XXX only for testing instantiate now (later use RenderNewBuffer!)
    //_quartzStream = NEW QuartzAudioStream(_fileName);
    //pcm.SetPCMformat(&(_quartzStream->pcm)); // set our format the same as theirs
}


StreamQuartzPCM::~StreamQuartzPCM()
{
    GetSoundBufferCache()->DeleteBuffer(this); // delete entries left on cache

    // destroy everything created in the constructor

    if(_fileName)
        StoreDeallocate(GetSystemHeap(), _fileName);

    if(_buffer)
        StoreDeallocate(GetSystemHeap(), _buffer);

    SoundGoingAway(this);
}


class StreamQuartzPCMSoundInstance : public SoundInstance {
  public:
    StreamQuartzPCMSoundInstance(LeafSound *snd, TimeXform tt, PCM& pcm)
    : SoundInstance(snd, tt), _quartzBufferElement(NULL), _pcm(pcm),
      _gotResources(false)
      //, _soundContext(NULL)
    {
        Assert(DYNAMIC_CAST(StreamQuartzPCM*, snd));

        // seems like a fine time to create the _soundContext
        // _soundContext = NEW SoundContext();
    }

    void ReleaseResources() { 
        // can be null if not started
        if(_quartzBufferElement) {
            // save info from the bufferElement in the context!
            // Assert(_soundContext);


            if(_quartzBufferElement->GetThreaded()) {
                _quartzBufferElement->SetKillFlag(true);
            }
            else {
                _quartzBufferElement->GetStreamingBuffer()->stop();
                delete _quartzBufferElement;
            }

            _quartzBufferElement = NULL;
            _gotResources        = false;

        }
    }

    ~StreamQuartzPCMSoundInstance() { ReleaseResources(); }

    StreamQuartzPCM *GetStreamQuartzPCM() {
        return SAFE_CAST(StreamQuartzPCM*, _snd);
    }

    void Create(MetaSoundDevice*, SoundContext *);
    void StartAt(MetaSoundDevice*, double);
    void Adjust(MetaSoundDevice*);
    void Mute(bool mute);
    bool Done();
    bool GetLength(double&);

    virtual void SetTickID(DWORD id) {
        if(_quartzBufferElement) {
            QuartzAudioReader *quartzAudioReader = 
                _quartzBufferElement->GetQuartzAudioReader();

            Assert(quartzAudioReader);

            quartzAudioReader->SetTickID(id);
        }
    }

  protected:
    QuartzBufferElement *_quartzBufferElement;
    PCM& _pcm;
    // SoundContext *_soundContext;

  private:
    void CheckResources();
    bool _gotResources;
};


void
StreamQuartzPCMSoundInstance::CheckResources()
{
    if(!_gotResources) {
        Create(GetCurrentSoundDevice(), _soundContext);  // re-create our resources
        _done   = false;                  // so we can go again
        _status = SND_FETAL;              // so we can go again
    }
}


QuartzAudioStream *
ThrowingNewQuartzAudioStream(char *url)
{ return NEW QuartzAudioStream(url); }


QuartzAudioStream *
NonThrowingNewQuartzAudioStream(char *url)
{
    QuartzAudioStream *result = NULL;
    
    __try {
        result = ThrowingNewQuartzAudioStream(url);
    } __except ( HANDLE_ANY_DA_EXCEPTION ) {
        result = NULL;
    }

    return result;
}


void
StreamQuartzPCMSoundInstance::Create(MetaSoundDevice *metaDev, 
    SoundContext *soundContext)
{   
    DirectSoundDev   *dsDev      = metaDev->dsDevice;
    SoundBufferCache *soundCache = GetSoundBufferCache();
    
    QuartzBufferElement *quartzBufferElement = 
        SAFE_CAST(QuartzBufferElement *, soundCache->GetBuffer(_snd));

    // get a proxy (notify the dsDev if it fails)
    DirectSoundProxy *dsProxy = CreateProxy(dsDev);
    if(!dsProxy)
        return;                         // nothing else to do...

    if(quartzBufferElement) { // did we find one on the cache?
        // ok use this one and its quartz but add the path and dsbuffer...

        // set our format same as theirs
        _pcm.SetPCMformat(&quartzBufferElement->GetQuartzAudioReader()->pcm);
        DSstreamingBuffer *streamingBuffer =
            NEW DSstreamingBuffer(dsProxy, &_pcm);
        quartzBufferElement->SetStreamingBuffer(streamingBuffer);
        quartzBufferElement->SetDSproxy(dsProxy);

        CComPtr<IStream> istream = quartzBufferElement->RemoveFile();

        if(istream.p) { // a valid stream handle?
            // add the streamhandle to the device
            dsDev->AddStreamFile(_snd, istream);
        }

        soundCache->RemoveBuffer(_snd);  // yup, use it + remove it from cache
    } else { //didn't find one, we will have to make out own...
        
        StreamQuartzPCM *p = GetStreamQuartzPCM();
        
        QuartzAudioStream *quartzStream =
            NonThrowingNewQuartzAudioStream(p->GetFileName());

        if(quartzStream==NULL) 
            return;
        
        _pcm.SetPCMformat(&(quartzStream->pcm)); // set our format same as theirs
        DSstreamingBuffer *streamingBuffer =
            NEW DSstreamingBuffer(dsProxy, &_pcm);

        quartzBufferElement = NEW // create new element
            QuartzBufferElement(p, quartzStream, streamingBuffer, dsProxy);
    }

    quartzBufferElement->SetSyncStart(); // synchronize this buffer

#ifdef THREADED 
    dsDev->AddSound(_snd, metaDev, quartzBufferElement);
#endif /* THREADED */

    // do it here just in case of exception above
    _quartzBufferElement = quartzBufferElement;

    // stuff info from soundContext into the bufferElement
    // _quartzBufferElement->Set() = _soundContext->Get();

    _gotResources = true;
}


void
StreamQuartzPCMSoundInstance::Adjust(MetaSoundDevice *metaDev)
{
    CheckResources();
    if(!_quartzBufferElement)  // exception handling
        return;
    
    DSstreamingBuffer *streamingBuffer =
        _quartzBufferElement->GetStreamingBuffer();

    if(_hit)
        streamingBuffer->SetGain(_gain);
    
    streamingBuffer->SetPan(_pan.GetdBmagnitude(), _pan.GetDirection());

    if(0) { // servo
        // all streamingSound::RenderSamples must update stats!
        streamingBuffer->updateStats();  // track sample
    }


    // limit rates to 0-2 (faster rates require infinite resources)
    // XXX eventualy we will use a quartz rate converter filter...
    double rate = fsaturate(0.0, 2.0, _rate); 
    int newFrequency = (int)(rate * _pcm.GetFrameRate());
    streamingBuffer->setPitchShift(newFrequency);

#ifdef THREADED  // communicate changes to the bg thread
    metaDev->dsDevice->SetParams(_quartzBufferElement, 
                                 _rate, _seek, _position, _loop);
    
    _seek = false;              // reset seek field
#else
    if(doSeek)   // do the work immediately if needed
        metaDev->_seek = seek;
    else
        metaDev->_seek = -1.0;  // negative number denotes no-seek
#endif /* THREADED */
}


void
StreamQuartzPCMSoundInstance::StartAt(MetaSoundDevice *metaDev, double phase)
{
    CheckResources();
    if (!_quartzBufferElement)  // exception handling
        return;
    
    QuartzAudioReader *quartzAudioReader = 
        _quartzBufferElement->GetQuartzAudioReader();

    Assert(quartzAudioReader);

    quartzAudioReader->InitializeStream();

    double offset =
        fmod(phase, quartzAudioReader->pcm.GetNumberSeconds());
    
    if(offset < 0)
        offset += quartzAudioReader->pcm.GetNumberSeconds();
    double frameOffset = quartzAudioReader->pcm.SecondsToFrames(offset);

    // XXX shouldn't we know if it is looped and mod the offset?
    //     what happens if we seek off the end?
    quartzAudioReader->SeekFrames(frameOffset);

    if(!quartzAudioReader->QueryPlaying()) 
        quartzAudioReader->Run(); // if filter graph isn't playing, then run it!

    _quartzBufferElement->RenderSamples(); // prime the buffer

    Assert(_quartzBufferElement->GetStreamingBuffer());
    
    _quartzBufferElement->GetStreamingBuffer()->play(TRUE);  
    _quartzBufferElement->_playing = TRUE;
}


bool
StreamQuartzPCMSoundInstance::GetLength(double& len)
{
    len = _pcm.GetNumberSeconds();
    return true;
}


void
QuartzBufferElement::RenderSamples()
{
    DSstreamingBuffer *streamingBuffer = GetStreamingBuffer();
    Assert(streamingBuffer);
    
    QuartzAudioReader *quartzAudioReader = GetQuartzAudioReader();
    Assert(quartzAudioReader);

    long framesFree;
    long framesToTransfer;
    long framesGot;
    long bufferFrameSize =
        streamingBuffer->pcm.SecondsToFrames(_snd->GetLatency());

    if(_snd->GetBuffer()==NULL) {
        _snd->SetBuffer((unsigned char *)StoreAllocate(GetSystemHeap(),
                        _snd->_pcm.FramesToBytes(bufferFrameSize)));
    }

    unsigned char *buffer = _snd->GetBuffer();
    
    framesFree       = streamingBuffer->framesFree();
    framesToTransfer = saturate(0, bufferFrameSize, framesFree);

    if(_doSeek) {
        double frameOffset = quartzAudioReader->pcm.SecondsToFrames(_seek);
        quartzAudioReader->SeekFrames(frameOffset);
        _doSeek = false;
    }

#ifdef OLD_DYNAMIC_PHASE
    // seek quartz as needed (needs to be mutexed)
    if(metaDev->_seek >= 0.0) {
        double frameOffset = quartzAudioReader->pcm.SecondsToFrames(metaDev->_seek);

        // XXX shouldn't we know if it is looped and mod the offset?
        //     what happens if we seek off the end?
        quartzAudioReader->SeekFrames(frameOffset);
    }
#endif OLD_DYNAMIC_PHASE


    // read quartz samples
    framesGot = quartzAudioReader->ReadFrames(framesToTransfer, buffer);

    if(framesGot == -1) { // FALLBACK!  We need to clone a new audio amstream!
        TraceTag((tagAVmodeDebug, "RenderSamples: audio gone FALLBACK!!"));
        quartzAudioReader = FallbackAudio();

        Assert(quartzAudioReader);
        
        // retry the get, now on the new stream
        framesGot = quartzAudioReader->ReadFrames(framesToTransfer, buffer);
    }

    if(framesGot)
        streamingBuffer->writeFrames(buffer, framesGot); // write them to dsound

    if(framesGot < framesToTransfer) { // end of file
        if (_loop) { // (explicitly use the metaDev passed us!)
            quartzAudioReader->SeekFrames(0); // restart the sound!
            framesToTransfer -= framesGot;
            framesGot = quartzAudioReader->ReadFrames(framesToTransfer, buffer);
            if(framesGot)
                streamingBuffer->writeFrames(buffer, framesGot); // write them to dsound
        }
        else {
            // XXX I need to standardize/factor this code!
            if(!streamingBuffer->_flushing)
                streamingBuffer->_flushing = 1;

            // flush the dsound buffer  (XXX fix dsound!)
            // NOTE: this may/will take a number of tries waiting for the
            //       last samples to play out!
            framesFree = streamingBuffer->framesFree();
            if(framesFree) {
                streamingBuffer->writeSilentFrames(framesFree);
                streamingBuffer->_flushing+= framesFree;
            }

            if(streamingBuffer->_flushing >
               streamingBuffer->TotalFrames()) {
                   // XXX self terminate sound
                   // XXX close the buffer after it has played out
            }
        }
    }
}


bool
StreamQuartzPCMSoundInstance::Done()
{
    if(!_quartzBufferElement)  // exception handling
        return false;
    
    DSstreamingBuffer *streamingBuffer =
        _quartzBufferElement->GetStreamingBuffer();

    Assert(streamingBuffer); 
    
    QuartzAudioReader *quartzAudioReader =
        _quartzBufferElement->GetQuartzAudioReader();

    //TraceTag((tagError, "RendercheckComplete:  QuartzAudioReader is %x", quartzAudioReader));

    // XXX: hack: Ken please make sure this is correct!  The problem
    // is that another thread destroys the quartzAudioReader and this
    // guys tries to access it...
    if(!quartzAudioReader) 
        return true;
    
    // XXX eventualy check if the input is exhausted and that the output has
    //     completely played out (initialy we will only check the former!)
    // (or do a prediction based on the number of samples in the buffer)
    return(quartzAudioReader->Completed());
}


void
StreamQuartzPCMSoundInstance::Mute(bool mute)
{
    if(!_quartzBufferElement)  // exception handling
        return;
    
    // mute sound (-100 Db attenuation)

    Assert(_quartzBufferElement->GetStreamingBuffer());
    
    _quartzBufferElement->GetStreamingBuffer()->
        SetGain(mute ? -100.0 : _gain); 
}


SoundInstance *
StreamQuartzPCM::CreateSoundInstance(TimeXform tt)
{
    return NEW StreamQuartzPCMSoundInstance(this, tt, _pcm);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\dalibc\dainit.cpp ===
/*******************************************************************************
Copyright (c) 1995-1998 Microsoft Corporation.  All rights reserved.
*******************************************************************************/


#include "headers.h"
#include "..\apeldbg\debug.h"

extern void STLInit();
extern void STLDeinit();

SysInfo sysInfo;

bool DALibStartup(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH) {
#ifdef _DEBUG
        // init the debug Trace mech.
        InitDebug(hInstance,NULL);

#endif
        STLInit();

        sysInfo.Init();

    } else if (dwReason == DLL_PROCESS_DETACH) {

        STLDeinit();

    }

    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\dalibc\delete.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"

#if !_DEBUGMEM
extern "C" void __cdecl free( void * p );

void operator delete( void * p )
{
    free(p);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\dalibc\daheap.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _DAHEAP_H
#define _DAHEAP_H

extern bool HeapInit();
extern void HeapDeinit();
extern void * DAAlloc(size_t size);
extern void DAFree(void *p);

#endif /* _DAHEAP_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\dalibc\headers.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _HEADERS_H
#define _HEADERS_H

#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <dalibc.h>

#endif /* _HEADERS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\dalibc\malloc.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"
#include "daheap.h"

extern "C" void * __cdecl malloc( size_t size )
{
    return HeapAlloc(hGlobalHeap,0,size);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\dalibc\memmove.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"

extern "C" void *memmove( void *dest, const void *src, size_t count )
{
    MoveMemory(dest,src,count);
    return dest;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\dalibc\new.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"

#if !_DEBUGMEM

extern "C" void * __cdecl malloc( size_t size );

void * operator new( size_t cb )
{
    return malloc(cb);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\dalibc\purevirt.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"

extern "C" int __cdecl _purecall()
{
    DebugBreak();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\dalibc\free.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"
#include "daheap.h"

extern "C" void __cdecl free( void * p )
{
    HeapFree(hGlobalHeap,0,p);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\dalibc\dllmain.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"

extern "C" BOOL WINAPI _DllMainCRTStartup (HINSTANCE hInstance,
                                           DWORD dwReason,
                                           LPVOID lpReserved);

extern "C" BOOL WINAPI
_DADllMainStartup(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH) {
        versionInfo.dwOSVersionInfoSize = sizeof(versionInfo);
        if (!GetVersionEx(&versionInfo)) {
            ZeroMemory(&versionInfo,sizeof(versionInfo));
        }
    }

    return _DllMainCRTStartup(hInstance,dwReason,lpReserved);
}

#if 0
//#ifdef _NO_CRT
//#define WINMAINNAME DllMain
//#else
#define WINMAINNAME _DllMainCRTStartup
//#endif

extern "C" BOOL WINAPI WINMAINNAME (HINSTANCE hInstance,
                                    DWORD dwReason,
                                    LPVOID lpReserved);

HANDLE hGlobalHeap = NULL;

bool HeapInit()
{
    hGlobalHeap = HeapCreate(0,0x1000,0);

    return hGlobalHeap != NULL;
}

void HeapDeinit()
{
    if (hGlobalHeap) {
        HeapDestroy(hGlobalHeap);
        hGlobalHeap = NULL;
    }
}

extern "C" BOOL WINAPI
_DllMainStartup(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    switch (dwReason) {
      case DLL_PROCESS_ATTACH:
        if (!HeapInit())
            return FALSE;

        if (!WINMAINNAME(hInstance,dwReason,lpReserved)) {
            HeapDeinit();
            return FALSE;
        }

        return TRUE;
      case DLL_PROCESS_DETACH:
        {
            BOOL b = WINMAINNAME(hInstance,dwReason,lpReserved);
            HeapDeinit();
            return b;
        }
      default:
        return WINMAINNAME(hInstance,dwReason,lpReserved);
    }

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\dalite\idl\headers.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _HEADERS_H
#define _HEADERS_H

#include "include/headers.h"

#endif /* _HEADERS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\dalibc\realloc.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"
#include "daheap.h"

extern "C" void * __cdecl realloc( void * pv, size_t newsize )
{
    return HeapReAlloc(hGlobalHeap,0,pv,newsize);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\dalibc\xlock.cpp ===
/***
*xlock.cpp - thread lock class
*
*       Copyright (c) 1996, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Define lock class used to make STD C++ Library thread-safe.
*
*Revision History:
*       08-28-96  GJF   Module created, MGHMOM.
*
*******************************************************************************/

#include "headers.h"
#include <xstddef>
    
static CRITICAL_SECTION _CritSec;

void
STLInit()
{
//    InitializeCriticalSection( &_CritSec );
}

void
STLDeinit()
{
//    DeleteCriticalSection( &_CritSec );
}

/*
namespace std {
_Lockit::_Lockit()
{
    EnterCriticalSection( &_CritSec );
}

_Lockit::~_Lockit()
{
    LeaveCriticalSection( &_CritSec );
}

}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\dalite\dll\headers.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _HEADERS_H
#define _HEADERS_H

#include "include/headers.h"
#include "dalite.h"
#include "comutil.h"

#endif /* _HEADERS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\dalibc\strfns.cpp ===
/*******************************************************************************
Copyright (c) 1995-1998 Microsoft Corporation.  All rights reserved.
*******************************************************************************/


#include "headers.h"
#include <malloc.h>

// Copied from ATL

#define USES_CONVERSION int _convert

#define W2A(lpw) (\
        ((LPCWSTR)lpw == NULL) ? NULL : (\
                _convert = (lstrlenW(lpw)+1)*2,\
                W2AHelper((LPSTR) alloca(_convert), lpw, _convert)))

LPSTR W2AHelper(LPSTR lpa, LPCWSTR lpw, int size)
{
    lpa[0] = '\0';
    WideCharToMultiByte(CP_ACP, 0, lpw, -1, lpa, size, NULL, NULL);
    return lpa;
}

// These are all copied from SHLWAPI
//#define OFFSETOF(x)     ((UINT)(x))

/*
 * ChrCmp -  Case sensitive character comparison for DBCS
 * Assumes   w1, wMatch are characters to be compared
 * Return    FALSE if they match, TRUE if no match
 */
__inline BOOL ChrCmpA_inline(WORD w1, WORD wMatch)
{
    /* Most of the time this won't match, so test it first for speed.
    */
    if (LOBYTE(w1) == LOBYTE(wMatch))
    {
        if (IsDBCSLeadByte(LOBYTE(w1)))
        {
            return(w1 != wMatch);
        }
        return FALSE;
    }
    return TRUE;
}


__inline BOOL ChrCmpW_inline(WORD w1, WORD wMatch)
{
    return(!(w1 == wMatch));
}

/*
 * ChrCmpI - Case insensitive character comparison for DBCS
 * Assumes   w1, wMatch are characters to be compared;
 *           HIBYTE of wMatch is 0 if not a DBC
 * Return    FALSE if match, TRUE if not
 */
BOOL ChrCmpIA(WORD w1, WORD wMatch)
{
    char sz1[3], sz2[3];

    if (IsDBCSLeadByte(sz1[0] = LOBYTE(w1)))
    {
        sz1[1] = HIBYTE(w1);
        sz1[2] = '\0';
    }
    else
        sz1[1] = '\0';

    *(WORD FAR *)sz2 = wMatch;
    sz2[2] = '\0';
    return lstrcmpiA(sz1, sz2);
}

BOOL ChrCmpIW(WORD w1, WORD wMatch)
{
    WCHAR sz1[2], sz2[2];

    sz1[0] = w1;
    sz1[1] = '\0';
    sz2[0] = wMatch;
    sz2[1] = '\0';

    return StrCmpIW(sz1, sz2);
}


LPWSTR StrCpyW(LPWSTR psz1, LPCWSTR psz2)
{
    LPWSTR psz = psz1;

    while (*psz1++ = *psz2++)
        ;

    return psz;
}


LPWSTR StrCpyNW(LPWSTR psz1, LPCWSTR psz2, int cchMax)
{
    LPWSTR psz = psz1;

    if (0 < cchMax)
    {
        // Leave room for the null terminator
        while (0 < --cchMax)
        {
            if ( !(*psz1++ = *psz2++) )
                break;
        }

        if (0 == cchMax)
            *psz1 = '\0';
    }

    return psz;
}


LPWSTR StrCatW(LPWSTR psz1, LPCWSTR psz2)
{
    LPWSTR psz = psz1;

    while (0 != *psz1)
        psz1++;

    while (*psz1++ = *psz2++)
        ;

    return psz;
}

/*
 * StrRChr - Find last occurrence of character in string
 * Assumes   lpStart points to start of string
 *           lpEnd   points to end of string (NOT included in search)
 *           wMatch  is the character to match
 * returns ptr to the last occurrence of ch in str, NULL if not found.
 */
LPSTR StrRChrA(LPCSTR lpStart, LPCSTR lpEnd, WORD wMatch)
{
    LPCSTR lpFound = NULL;

    if (!lpEnd)
        lpEnd = lpStart + lstrlenA(lpStart);

    for ( ; lpStart < lpEnd; lpStart = CharNext(lpStart))
    {
        // (ChrCmp returns FALSE when characters match)

        if (!ChrCmpA_inline(*(UNALIGNED WORD FAR *)lpStart, wMatch))
            lpFound = lpStart;
    }
    return ((LPSTR)lpFound);
}

int StrCmpW(LPCWSTR pwsz1, LPCWSTR pwsz2)
{
    if (sysInfo.IsNT())
    {
        return lstrcmpW(pwsz1, pwsz2);
    }
    else
    {
        USES_CONVERSION;
        
        LPSTR psz1 = W2A(pwsz1);
        LPSTR psz2 = W2A(pwsz2);
        return lstrcmpA(psz1, psz2);
    }
}

int 
StrCmpIW(LPCWSTR pwsz1,
         LPCWSTR pwsz2)
{
    int iRet;

    if (sysInfo.IsNT())
    {
        return lstrcmpiW(pwsz1, pwsz2);
    }
    else
    {
        USES_CONVERSION;
        
        LPSTR psz1 = W2A(pwsz1);
        LPSTR psz2 = W2A(pwsz2);
        return lstrcmpiA(psz1, psz2);
    }
}

/*
 * StrCmpN      - Compare n bytes
 *
 * returns   See lstrcmp return values.
 */
int _StrCmpNA(LPCSTR lpStr1, LPCSTR lpStr2, int nChar, BOOL fMBCS)
{
    LPCSTR lpszEnd = lpStr1 + nChar;
    char sz1[4];
    char sz2[4];

    if (fMBCS) {
        for ( ; (lpszEnd > lpStr1) && (*lpStr1 || *lpStr2); lpStr1 = AnsiNext(lpStr1), lpStr2 = AnsiNext(lpStr2)) {
            WORD w1;
            WORD w2;
    
            // If either pointer is at the null terminator already,
            // we want to copy just one byte to make sure we don't read 
            // past the buffer (might be at a page boundary).
    
            w1 = (*lpStr1) ? *(UNALIGNED WORD *)lpStr1 : 0;
            w2 = (*lpStr2) ? *(UNALIGNED WORD *)lpStr2 : 0;
    
            // (ChrCmpA returns FALSE if the characters match)
    
            // Do the characters match?
            if (ChrCmpA_inline(w1, w2)) 
            {
                // No; determine the lexical value of the comparison
                // (since ChrCmp just returns true/false).
    
                // Since the character may be a DBCS character; we
                // copy two bytes into each temporary buffer 
                // (in preparation for the lstrcmp call).
    
                (*(WORD *)sz1) = w1;
                (*(WORD *)sz2) = w2;
    
                // Add null terminators to temp buffers
                *AnsiNext(sz1) = 0;
                *AnsiNext(sz2) = 0;
                return lstrcmpA(sz1, sz2);
            }
        }
    } else {
        for ( ; (lpszEnd > lpStr1) && (*lpStr1 || *lpStr2); lpStr1++, lpStr2++) {
            if (*lpStr1 != *lpStr2) {
                // No; determine the lexical value of the comparison
                // (since ChrCmp just returns true/false).
                sz1[0] = *lpStr1;
                sz2[0] = *lpStr2;
                sz1[1] = sz2[1] = '\0';
                return lstrcmpA(sz1, sz2);
            }
        }
    }

    return 0;
}

int StrCmpNA(LPCSTR lpStr1, LPCSTR lpStr2, int nChar)
{
    CPINFO cpinfo;
    return _StrCmpNA(lpStr1, lpStr2, nChar, GetCPInfo(CP_ACP, &cpinfo) && cpinfo.LeadByte[0]);
}

int StrCmpNW(LPCWSTR lpStr1, LPCWSTR lpStr2, int nChar)
{
    WCHAR sz1[2];
    WCHAR sz2[2];
    int i;
    LPCWSTR lpszEnd = lpStr1 + nChar;

    for ( ; (lpszEnd > lpStr1) && (*lpStr1 || *lpStr2); lpStr1++, lpStr2++) {
        i = ChrCmpW_inline(*lpStr1, *lpStr2);
        if (i) {
            int iRet;

            sz1[0] = *lpStr1;
            sz2[0] = *lpStr2;
            sz1[1] = TEXT('\0');
            sz2[1] = TEXT('\0');
            iRet = StrCmpW(sz1, sz2);
            return iRet;
        }
    }

    return 0;
}

/*
 * StrCmpNI     - Compare n bytes, case insensitive
 *
 * returns   See lstrcmpi return values.
 */
int StrCmpNIA(LPCSTR lpStr1, LPCSTR lpStr2, int nChar)
{
    int i;
    LPCSTR lpszEnd = lpStr1 + nChar;

    for ( ; (lpszEnd > lpStr1) && (*lpStr1 || *lpStr2); (lpStr1 = AnsiNext(lpStr1)), (lpStr2 = AnsiNext(lpStr2))) {
        WORD w1;
        WORD w2;

        // If either pointer is at the null terminator already,
        // we want to copy just one byte to make sure we don't read 
        // past the buffer (might be at a page boundary).

        w1 = (*lpStr1) ? *(UNALIGNED WORD *)lpStr1 : 0;
        w2 = (UINT)(IsDBCSLeadByte(*lpStr2)) ? *(UNALIGNED WORD *)lpStr2 : (WORD)(BYTE)(*lpStr2);

        i = ChrCmpIA(w1, w2);
        if (i)
            return i;
    }
    return 0;
}

int StrCmpNIW(LPCWSTR lpStr1, LPCWSTR lpStr2, int nChar)
{
    int i;
    LPCWSTR lpszEnd = lpStr1 + nChar;

    for ( ; (lpszEnd > lpStr1) && (*lpStr1 || *lpStr2); lpStr1++, lpStr2++) {
        i = ChrCmpIW(*lpStr1, *lpStr2);
        if (i) {
            return i;
        }
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\dalibc\sysinfo.cpp ===
/*******************************************************************************
Copyright (c) 1998 Microsoft Corporation.  All rights reserved.

    This file implements the methods for the SysInfo class, which maintains
    global information about the current runtime system.

*******************************************************************************/

#include "headers.h"
#include "windows.h"


int DeduceD3DLevel (OSVERSIONINFO&);
LARGE_INTEGER GetFileVersion (LPSTR szPath);



/*****************************************************************************
This method initializes the system info object.  It is called on startup in
DALibC.
*****************************************************************************/

void SysInfo::Init (void)
{
    // Load the OS version information.

    _osVersion.dwOSVersionInfoSize = sizeof(_osVersion);

    if (!GetVersionEx(&_osVersion)) {
        ZeroMemory (&_osVersion, sizeof(_osVersion));
    }

    // Initialize Member Variables

    _versionD3D   = -1;
    _versionDDraw = -1;
}



/*****************************************************************************
This method returns true if the current OS is NT-based.
*****************************************************************************/

bool SysInfo::IsNT (void)
{
    return _osVersion.dwPlatformId == VER_PLATFORM_WIN32_NT;
}



/*****************************************************************************
This method returns true if the current OS is windows-based (Win95 or Win98).
*****************************************************************************/

bool SysInfo::IsWin9x (void)
{
    return _osVersion.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS;
}



/*****************************************************************************
This method returns the MAJOR version of the OS.
*****************************************************************************/

DWORD SysInfo::OSVersionMajor (void)
{
    return _osVersion.dwMajorVersion;
}

/*****************************************************************************
This method returns the MINOR version of the OS.
*****************************************************************************/

DWORD SysInfo::OSVersionMinor (void)
{
    return _osVersion.dwMinorVersion;
}

/*****************************************************************************
This method returns the D3D version installed on the system.  Currently it
only returns 0 for earlier than DX3, or 3 for DX3 or later.
*****************************************************************************/

int SysInfo::VersionD3D (void)
{
    // If we've not yet examined the version of D3D on the system, check it now.

    if (_versionD3D < 0)
        _versionD3D = DeduceD3DLevel (_osVersion);

    return _versionD3D;
}



/*****************************************************************************
This method returns the version of DDraw, based on the file version of
DDRAW.DLL.  This method returns 3 for DDraw 3 or earlier, or N for DDRaw N
(N being 5 or later).
*****************************************************************************/

int SysInfo::VersionDDraw (void)
{
    // Only get the version if we haven't already

    if (_versionDDraw < 0) 
    {
        LARGE_INTEGER filever = GetFileVersion ("ddraw.dll");

        int n = LOWORD (filever.HighPart);

        if (n <= 4)
            _versionDDraw = 3;    // DDraw 3 or earlier
        else
            _versionDDraw = n;    // DDraw 5 or later
    }

    return _versionDDraw;
}



/*****************************************************************************
This function deduces the level of D3D on the current system.  It either
returns 0 (for pre-DX3) or 3 (for DX3+).  This is somewhat tricky since DXMini
installs some DX3 components, but leaves D3D at level 2.
*****************************************************************************/

typedef HRESULT (WINAPI *DIRECTINPUTCREATE)
                (HINSTANCE, DWORD, void**, void**);

int DeduceD3DLevel (OSVERSIONINFO &osver)
{
    // The D3D version has not yet been determined.  First look at the OS type.

    if (osver.dwPlatformId == VER_PLATFORM_WIN32_NT)
    {
        // If this is NT3 or less, there's no D3D; if it's NT5, then it's at
        // least DX3.

        if (osver.dwMajorVersion < 4)
        {
            return 0;
        }
        else if (osver.dwMajorVersion > 4)
        {
            return 3;
        }

        // To check for DX3+, we need to check to see if DirectInput is on the
        // system.  If it is, then we're at DX3+.  (Note that both D3Dv3 and
        // DInput are absent from DXMini installs.)

        HINSTANCE diHinst = LoadLibrary ("DINPUT.DLL");

        if (diHinst == 0)
            return 0;

        DIRECTINPUTCREATE diCreate = (DIRECTINPUTCREATE)
            GetProcAddress (diHinst, "DirectInputCreateA");

        FreeLibrary (diHinst);

        if (diCreate == 0)
            return 0;

        return 3;
    }
    else if (osver.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
    {
        // If we're on Win98, then we know we have at least DX5.

        if (osver.dwMinorVersion > 0)
            return 3;

        // We're on Win95.  Get the version of D3DRM.DLL to check the version.

        LARGE_INTEGER rm_filever = GetFileVersion ("d3drm.dll");

        if (rm_filever.HighPart > 0x00040003)
        {
            // Greater than DX2.

            return 3;
        }
        else if (rm_filever.HighPart == 0x00040002)
        {
            // Special DXMini install with DX3 drivers (but not rasterizers)

            return 3;
        }
        else
        {
            // D3D missing or pre DX3.

            return 0;
        }
    }
   
    // Unknown OS

    return 0; 
}



/*****************************************************************************
This function returns the file version of a particular system file.
*****************************************************************************/

LARGE_INTEGER GetFileVersion (LPSTR szPath)
{
    LARGE_INTEGER li;
    int     size;
    DWORD   dw;

    ZeroMemory(&li, sizeof(li));

    if (size = (int)GetFileVersionInfoSize(szPath, &dw)) 
    {
        LPVOID vinfo;

        if (vinfo = (void *)LocalAlloc(LPTR, size)) 
        {
            if (GetFileVersionInfo(szPath, 0, size, vinfo)) 
            {
                VS_FIXEDFILEINFO *ver=NULL;
                UINT              cb = 0;
                LPSTR             lpszValue=NULL;

                if (VerQueryValue(vinfo, "\\", (void**)&ver, &cb))
                {
                    if (ver)
                    {
                        li.HighPart = ver->dwFileVersionMS;
                        li.LowPart  = ver->dwFileVersionLS;
                    }
                }
            }
            LocalFree((HLOCAL)vinfo);
        }
    }
    return li;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\dalite\include\comutil.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _COMUTIL_H
#define _COMUTIL_H

#define SET_NULL(x) {if (x) *(x) = NULL;}

#define CHECK_RETURN_NULL(x) {if (!(x)) return E_POINTER;}
#define CHECK_RETURN_SET_NULL(x) {if (!(x)) { return E_POINTER ;} else {*(x) = NULL;}}

template <class T>
class DAComPtr
{
  public:
    typedef T _PtrClass;
    DAComPtr() { p = NULL; }
    DAComPtr(T* lp, bool baddref = true)
    {
        p = lp;
        if (p != NULL && baddref)
            p->AddRef();
    }
    DAComPtr(const DAComPtr<T>& lp, bool baddref = true)
    {
        p = lp.p;

        if (p != NULL && baddref)
            p->AddRef();
    }
    ~DAComPtr() {
        if (p) p->Release();
    }
    void Release() {
        if (p) p->Release();
        p = NULL;
    }
    operator T*() { return (T*)p; }
    T& operator*() { Assert(p != NULL); return *p; }
    //The assert on operator& usually indicates a bug.  If this is really
    //what is needed, however, take the address of the p member explicitly.
    T** operator&() { Assert(p == NULL); return &p; }
    T* operator->() { Assert(p != NULL); return p; }
    T* operator=(T* lp)
    {
        return Assign(lp);
    }
    T* operator=(const DAComPtr<T>& lp)
    {
        return Assign(lp.p);
    }

    bool operator!() const { return (p == NULL); }
    operator bool() const { return (p != NULL); }

    T* p;
  protected:
    T* Assign(T* lp) {
        if (lp != NULL)
            lp->AddRef();

        if (p)
            p->Release();

        p = lp;

        return lp;
    }
};

#endif /* _COMUTIL_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\dalite\dll\stdafx.cpp ===
/*++

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Ole Object initialization

Revision:

--*/

#include "headers.h"

#undef map
#undef SubclassWindow

// Put this here to initialize all the ATL stuff

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlctl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\dalite\dll\main.cpp ===
/*******************************************************************************
  Copyright (c) 1995-96 Microsoft Corporation

  Abstract:

    Initialization

 *******************************************************************************/

#include "headers.h"
#include "src\factory.h"
#include "dartapi.h"

DeclareTag(tagLockCount,"COM","Lock count");

DAComModule _Module;

BEGIN_OBJECT_MAP(COMObjectMap)
    OBJECT_ENTRY(CLSID_DALFactory, CDALFactory)
END_OBJECT_MAP()

HINSTANCE  hInst;
bool bFailedLoad = false;

extern "C" BOOL WINAPI _DllMainCRTStartup (HINSTANCE hInstance,
                                           DWORD dwReason,
                                           LPVOID lpReserved);

extern "C" BOOL WINAPI
_DALDllMainStartup(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    if (dwReason == DLL_PROCESS_DETACH) {
        // Call the routines in reverse order of initialization
        BOOL r = _DllMainCRTStartup(hInstance,dwReason,lpReserved);
        r = DALibStartup(hInstance,dwReason,lpReserved) && r;

        return r;
    } else {
        // In everything except DLL_PROCESS_DETACH call DALibStartup first
        return (DALibStartup(hInstance,dwReason,lpReserved) &&
                _DllMainCRTStartup(hInstance,dwReason,lpReserved));
    }
}

#define EXCEPTION(t) (GetExceptionCode() == t ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH )

LONG
DAComModule::Lock()
{
    // Can't depend on value return from Lock to be accurate.  Since
    // the CRConnect can be called multiple times w/o a problem simply
    // check the internal variable to see if it is 0.  This should
    // never cause anything except multiple calls to CRConnect
    
    bool bNeedConnect = (GetLockCount() == 0);

    LONG l = CComModule::Lock();

    TraceTag((tagLockCount,
              "DAComModule::Lock - new lockcount - %d, returned - %d",
              _Module.GetLockCount(),
              l));
    
    if (bNeedConnect) {
        __try {
            CRConnect(hInst);
        } __except (  EXCEPTION_EXECUTE_HANDLER ) {
            bFailedLoad = true;
        }
    }

    return l;
}

LONG
DAComModule::Unlock()
{
    LONG l = CComModule::Unlock();

    TraceTag((tagLockCount,
              "DAComModule::Unlock - new lockcount - %d, returned - %d",
              _Module.GetLockCount(),
              l));
    
    if (l) return l;
    if (!bFailedLoad)
        CRDisconnect(hInst);
    return 0;
}

#if DEVELOPER_DEBUG
#include <map>

typedef std::map<void *, const char *> ObjectMap;
ObjectMap *objMap = NULL;

void
DAComModule::AddComPtr(void *ptr, const char * name)
{
    EnterCriticalSection(&m_csObjMap);
    (*objMap)[ptr] = name;
    LeaveCriticalSection(&m_csObjMap) ;
}

void
DAComModule::RemoveComPtr(void *ptr)
{
    EnterCriticalSection(&m_csObjMap);
    objMap->erase(ptr);
    LeaveCriticalSection(&m_csObjMap) ;
}

void
DAComModule::DumpObjectList()
{
    if (objMap) {
        EnterCriticalSection(&m_csObjMap);
        if (objMap->size() > 0 || GetLockCount() > 0) {
            OutputDebugString ("DATxD.DLL: Detected unfreed COM pointers\n");
            OutputDebugString ("Listing pointers and types:\n");
            for (ObjectMap::iterator i = objMap->begin();
                 i != objMap->end();
                 i++) {

                char buf[1024];

                wsprintf(buf, "%#x:", (*i).first);
                OutputDebugString(buf);

                if ((*i).second)
                    OutputDebugString((*i).second);

                OutputDebugString("\n");
            }
        }
             
        LeaveCriticalSection(&m_csObjMap) ;
    }
}

void
DumpCOMObjectList()
{
    _Module.DumpObjectList();
}

#endif
/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point
extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH) {
        hInst = hInstance;

        DisableThreadLibraryCalls(hInstance);

        // For APELDBG
        RESTOREDEFAULTDEBUGSTATE;

        _Module.Init(COMObjectMap, hInstance);

#if DEVELOPER_DEBUG
        objMap = new ObjectMap;
#endif
    } else if (dwReason == DLL_PROCESS_DETACH) {
#if DEVELOPER_DEBUG
        DumpCOMObjectList();
        
        delete objMap;
        objMap = NULL;
#endif
        
        _Module.Term();
        
#if _DEBUG
        char buf[MAX_PATH + 1];
        
        GetModuleFileName(hInst, buf, MAX_PATH);
        
#if _DEBUGMEM
        TraceTag((tagLeaks, "\n[%s] unfreed memory:", buf));
        DUMPMEMORYLEAKS;
#endif

        // de-initialize the debug trace info.
        DeinitDebug();
#endif
    }
    
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    TraceTag((tagLockCount,
              "DllCanUnloadNow - lockcount - %d, com count - %d",
              _Module.GetLockCount(),
              objMap->size()));
    
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

#ifdef _DEBUG
static bool breakDialog = false ;
DeclareTag(tagDebugBreak, "!Debug", "Breakpoint on entry to DLL");
#endif

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _DEBUG
    if (!breakDialog && IsTagEnabled(tagDebugBreak)) {
        char buf[MAX_PATH + 1];
        
        GetModuleFileName(hInst, buf, MAX_PATH);
        
        MessageBox(NULL,buf,"DAL - Creating first COM Object",MB_OK|MB_SETFOREGROUND) ;
        breakDialog = true;
    }
#endif

    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    _Module.UnregisterServer();
    return S_OK;
}


#if _DEBUG
STDAPI_(void)
DoTraceTagDialog(HWND hwndStub,
                 HINSTANCE hAppInstance,
                 LPWSTR lpwszCmdLine,
                 int nCmdShow)
{
    DoTracePointsDialog(true);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\dalite\include\headers.h ===
/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

    Precompiled headers for dalite.dll
*******************************************************************************/

#ifndef DAL_HEADERS_HXX
#define DAL_HEADERS_HXX

/* Standard */
#include <math.h>
#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>
#include <string.h>
#include <malloc.h>
#include <memory.h>
#include <wtypes.h>

// Warning 4786 (identifier was truncated to 255 chars in the browser
// info) can be safely disabled, as it only has to do with generation
// of browsing information.
#pragma warning(disable:4786)

#include "apeldbg/apeldbg.h"

// ATL - needs to be before windows.h
#include "dalatl.h"

/* Windows */
#include <windows.h>
#include <windowsx.h>

/* C++ Replace DLL */
#include "dalibc.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\dalite\include\resource.h ===
/*******************************************************************************

Copyright (c) 1998_98 Microsoft Corporation

Abstract:

    DALite Resources

*******************************************************************************/


#ifndef _RESOURCE_H
#define _RESOURCE_H

#define RESID_TYPELIB           1

#endif /* _RESOURCE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\dalite\rsrc\makefile.inc ===
dalite.rc : $(TARGETPATH)\$(TARGET_DIRECTORY)\dalite.tlb
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\dalite\include\dalatl.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _LMATL_H
#define _LMATL_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define _ATL_NO_DEBUG_CRT 1

#ifdef _DEBUG
#undef _ASSERTE
#endif

#define _ASSERTE(expr) ((void)0)

#define _ATL_STATIC_REGISTRY 1

#ifdef _DEBUG
inline void _cdecl AtlTrace2(LPCTSTR , ...){}
#define ATLTRACE            1 ? (void)0 : AtlTrace2
#endif

#include <atlbase.h>

// We are overriding these methods so we can hook them and do some
// stuff ourselves.
class DAComModule : public CComModule
{
  public:
    LONG Lock();
    LONG Unlock();

#if DEVELOPER_DEBUG
    void AddComPtr(void *ptr, const char * name);
    void RemoveComPtr(void *ptr);

    void DumpObjectList();
#endif
};

//#define _ATL_APARTMENT_THREADED
// THIS MUST BE CALLED _Module - all the ATL header files depend on it
extern DAComModule _Module;

#include <atlcom.h>
#include <atlctl.h>

#if _DEBUG
#include <typeinfo.h>
#endif

// COPIED FROM ATLCOM.H

//Base is the user's class that derives from CComObjectRoot and whatever
//interfaces the user wants to support on the object
class ModuleReleaser
{
  public:
    ModuleReleaser() {
        _Module.Lock();
    }

    ~ModuleReleaser() {
        _Module.Unlock();
    }
};

template <class Base>
class DAComObject 
    : public ModuleReleaser,
      public Base
{
  public:
    typedef Base _BaseClass;
    DAComObject(void* = NULL)
    {
#if DEVELOPER_DEBUG
#if _DEBUG
        _Module.AddComPtr(this, GetName());
#else
        _Module.AddComPtr(this, NULL);
#endif
#endif
    }
    // Set refcount to 1 to protect destruction
    ~DAComObject()
    {
#if DEVELOPER_DEBUG
        _Module.RemoveComPtr(this);
#endif
        m_dwRef = 1L;
        FinalRelease();
    }
    //If InternalAddRef or InteralRelease is undefined then your class
    //doesn't derive from CComObjectRoot
    STDMETHOD_(ULONG, AddRef)() {return InternalAddRef();}
    STDMETHOD_(ULONG, Release)()
    {
        ULONG l = InternalRelease();
        if (l == 0)
            delete this;
        return l;
    }
    //if _InternalQueryInterface is undefined then you forgot BEGIN_COM_MAP
    STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
    {return _InternalQueryInterface(iid, ppvObject);}
    static HRESULT WINAPI CreateInstance(DAComObject<Base>** pp);
};

template <class Base>
HRESULT WINAPI DAComObject<Base>::CreateInstance(DAComObject<Base>** pp)
{
    _ASSERTE(pp != NULL);
    HRESULT hRes = E_OUTOFMEMORY;
    DAComObject<Base>* p = NULL;
    ATLTRY((p = new DAComObject<Base>()));
    if (p != NULL) {
        p->SetVoid(NULL);
        p->InternalFinalConstructAddRef();
        hRes = p->FinalConstruct();
        p->InternalFinalConstructRelease();
        if (hRes != S_OK) {
            delete p;
            p = NULL;
        }
    }
    *pp = p;
    return hRes;
}

#define DA_DECLARE_NOT_AGGREGATABLE(x) public:\
        typedef CComCreator2< CComCreator< DAComObject< x > >, CComFailCreator<CLASS_E_NOAGGREGATION> > _CreatorClass;
#define DA_DECLARE_AGGREGATABLE(x) public:\
        typedef CComCreator2< CComCreator< DAComObject< x > >, CComCreator< CComAggObject< x > > > _CreatorClass;

// END OF COPIED CODE
// Just to make things more uniform
#define RELEASE(x) if (x) { (x)->Release(); (x) = NULL; }

extern bool bFailedLoad;

#endif /* _LMATL_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\dalite\include\util.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _UTIL_H
#define _UTIL_H

template <class T>
class CRPtr
{
  public:
    typedef T _PtrClass;
    CRPtr() { p = NULL; }
    CRPtr(T* lp, bool baddref = true)
    {
        p = lp;
        if (p != NULL && baddref)
            CRAddRefGC(p);
    }
    CRPtr(const CRPtr<T>& lp, bool baddref = true)
    {
        p = lp.p;

        if (p != NULL && baddref)
            CRAddRefGC(p);
    }
    ~CRPtr() {
        CRReleaseGC(p);
    }
    void Release() {
        CRReleaseGC(p);
        p = NULL;
    }
    operator T*() { return (T*)p; }
    T& operator*() { Assert(p != NULL); return *p; }
    T* operator=(T* lp)
    {
        return Assign(lp);
    }
    T* operator=(const CRPtr<T>& lp)
    {
        return Assign(lp.p);
    }

    bool operator!() const { return (p == NULL); }
    operator bool() const { return (p != NULL); }

    T* p;
  protected:
    T* Assign(T* lp) {
        if (lp != NULL)
            CRAddRefGC(lp);

        CRReleaseGC(p);

        p = lp;

        return lp;
    }
};

class CRLockGrabber
{
  public:
    CRLockGrabber() { CRAcquireGCLock(); }
    ~CRLockGrabber() { CRReleaseGCLock(); }
};


class SafeArrayAccessor
{
  public:
    SafeArrayAccessor(VARIANT & v,
                      bool allowNullArray = false);
    ~SafeArrayAccessor();

    unsigned int GetArraySize() { return _ubound - _lbound + 1; }

    IUnknown **GetArray() { return _isVar?_allocArr:_ppUnk; }

    bool IsOK() { return !_failed; }
  protected:
    SAFEARRAY * _s;
    union {
        VARIANT * _pVar;
        IUnknown ** _ppUnk;
        void * _v;
    };
    
    VARTYPE _vt;
    long _lbound;
    long _ubound;
    bool _inited;
    bool _isVar;
    CComVariant _retVar;
    bool _failed;
    IUnknown ** _allocArr;
};

inline WCHAR * CopyString(const WCHAR *str) {
    int len = str?lstrlenW(str)+1:1;
    WCHAR *newstr = new WCHAR [len] ;
    if (newstr) memcpy(newstr,str?str:L"",len * sizeof(WCHAR)) ;
    return newstr ;
}

#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))

#endif /* _UTIL_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\dalite\src\bvr.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _BVR_H
#define _BVR_H

#include "factory.h"

class CDALTrack;
class CDALBehavior;

class CallBackData;
typedef std::list<CallBackData *> CallBackList;

class ATL_NO_VTABLE CDALBehavior
    : public CComObjectRootEx<CComSingleThreadModel>,
      public IDALBehavior
{
  public:
    CDALBehavior();
    ~CDALBehavior();

    static HRESULT WINAPI
        InternalQueryInterface(CDALBehavior* pThis,
                               const _ATL_INTMAP_ENTRY* pEntries,
                               REFIID iid,
                               void** ppvObject);

    HRESULT GetID(long *);
    HRESULT SetID(long);
        
    HRESULT GetDuration(double *);
    HRESULT SetDuration(double);
        
    HRESULT GetRepeat(long *);
    HRESULT SetRepeat(long);
        
    HRESULT GetBounce(VARIANT_BOOL *);
    HRESULT SetBounce(VARIANT_BOOL);
        
    HRESULT GetEventCB(IDALEventCB **);
    HRESULT SetEventCB(IDALEventCB *);
        
    HRESULT GetTotalTime(double *);
    HRESULT SetTotalTime(double);
        
    HRESULT GetEaseIn(float *);
    HRESULT SetEaseIn(float);

    HRESULT GetEaseInStart(float *);
    HRESULT SetEaseInStart(float);

    HRESULT GetEaseOut(float *);
    HRESULT SetEaseOut(float);

    HRESULT GetEaseOutEnd(float *);
    HRESULT SetEaseOutEnd(float);

    virtual HRESULT Error() = 0;

    CRBvrPtr GetBvr() { return m_bvr; }
    long GetID() { return m_id; }
    double GetDuration() { return m_duration; }
    double GetTotalDuration() { return m_totalduration; }
    double GetRepeatDuration() { return m_repduration; }
    long GetRepeat() { return m_repeat; }
    bool GetBounce() { return m_bBounce; }
    IDALEventCB * GetEventCB() { return m_eventcb; }
    float GetEaseIn() { return m_easein; }
    float GetEaseInStart() { return m_easeinstart; }
    float GetEaseOut() { return m_easeout; }
    float GetEaseOutEnd() { return m_easeout; }
    
    virtual CRBvrPtr Start();

    // This will call all the behaviors which are currently running
    // with the given event.  This is used when the track needs to
    // process a specific event like Pause/Resume/Stop/Play.
    
    // gTime is the global time that corresponds to 0 local time of
    // the behavior
    
    bool ProcessEvent(CallBackList & l,
                      double gTime,
                      double time,
                      bool bFirstTick,
                      DAL_EVENT_TYPE et);
    
    virtual bool _ProcessEvent(CallBackList & l,
                               double gTime,
                               double time,
                               bool bFirstTick,
                               DAL_EVENT_TYPE et,
                               bool bNeedsReverse) { return true; }
    
    bool ProcessCB(CallBackList & l,
                   double gTime,
                   double lastTick,
                   double curTime,
                   bool bForward,
                   bool bFirstTick,
                   bool bNeedPlay);

    virtual bool _ProcessCB(CallBackList & l,
                            double gTime,
                            double lastTick,
                            double curTime,
                            bool bForward,
                            bool bFirstTick,
                            bool bNeedPlay,
                            bool bNeedsReverse) { return true; }

    bool EventNotify(CallBackList &l,
                     double gTime,
                     DAL_EVENT_TYPE et);
    
    bool IsStarted();

    virtual void Invalidate();
    
    bool SetParent(CDALBehavior * parent) {
        if (m_parent) return false;
        m_parent = parent;
        return true;
    }

    virtual bool SetTrack(CDALTrack * parent);
    // This takes the current parent and only clears it for those
    // whose parent is the parent passed in (unless it is NULL)
    virtual void ClearTrack(CDALTrack * parent);

    void UpdateTotalDuration() {
        if (m_bBounce) {
            m_repduration = m_duration * 2;
        } else {
            m_repduration = m_duration;
        }
        
        if (m_repeat == 0 || m_duration == HUGE_VAL) {
            m_totalrepduration = HUGE_VAL;
        } else {
            m_totalrepduration = m_repeat * m_repduration;
        }

        if (m_totaltime != -1) {
            m_totalduration = m_totaltime;
        } else {
            m_totalduration = m_totalrepduration;
        }
    }
#if _DEBUG
    virtual void Print(int spaces) = 0;
#endif
  protected:
    long m_id;
    double m_duration;
    double m_totaltime;
    long m_repeat;
    bool m_bBounce;
    DAComPtr<IDALEventCB> m_eventcb;
    float m_easein;
    float m_easeinstart;
    float m_easeout;
    float m_easeoutend;

    // The real duration determine by checking the totaltime and the
    // totalrepduration
    
    double m_totalduration;

    // The duration for a single rep of a behavior
    double m_repduration;

    // Total duration we calculate for a regular behavior 
    double m_totalrepduration; 

    CRPtr<CRBvr> m_bvr;
    CDALTrack * m_track;
    CDALBehavior * m_parent;
    CR_BVR_TYPEID m_typeId;

    // The ease-in/out behavior modifier is applied using timeline
    // substitution.  The substitute timeline consists of three pieces
    // A, B and C, which are the ease-in, constant velocity and ease-out
    // parts respectively.  For B, a linear timeline is substituted; for
    // A and C, a quadratic warping of the input time is required.

    float m_flA0, m_flA1, m_flA2; // coefficients for the A piece
    float m_flB0, m_flB1;         // coefficients for the B piece
    float m_flC0, m_flC1, m_flC2; // coefficients for the C piece

    // These are the times to perform ease in/out
    float m_easeinEnd;
    float m_easeoutStart;
    bool m_bNeedEase;

    void CalculateEaseCoeff();

    // This will take the time behavior and ease it
    CRNumberPtr EaseTime(CRNumberPtr time);

    // This will take the given time and transform it to the correct
    // eased time
    // If the time is outside of our duration (i.e. <0 or >
    // m_duration) this will just return the given time
    double EaseTime(double time);

    virtual bool IsContinuousMediaBvr() { return false; }
};

CDALBehavior * GetBvr(IUnknown *);

class CallBackData
{
  public:
    CallBackData(CDALBehavior * bvr,
                 IDALEventCB * eventcb,
                 long id,
                 double time,
                 DAL_EVENT_TYPE et);
    ~CallBackData();

    HRESULT CallEvent();

  protected:
    DAComPtr<CDALBehavior> m_bvr;
    double m_time;
    DAL_EVENT_TYPE m_et;
    DAComPtr<IDALEventCB> m_eventcb;
    long m_id;
};

#if _DEBUG
inline char * EventString(DAL_EVENT_TYPE et) {
    switch(et) {
      case DAL_PLAY_EVENT:
        return "Play";
      case DAL_STOP_EVENT:
        return "Stop";
      case DAL_PAUSE_EVENT:
        return "Pause";
      case DAL_RESUME_EVENT:
        return "Resume";
      case DAL_REPEAT_EVENT:
        return "Repeat";
      case DAL_BOUNCE_EVENT:
        return "Bounce";
      case DAL_ONLOAD_EVENT:
        return "OnLoad(success)";
      case DAL_ONLOAD_ERROR_EVENT:
        return "OnLoad(failed)";
      default:
        return "Unknown";
    }
}
#endif

#endif /* _BVR_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\dalite\src\factory.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"
#include "bvr.h"
#include "singlebvr.h"
#include "seq.h"
#include "track.h"
#include "factory.h"
#include "import.h"

CDALFactory::CDALFactory()
{
}

CDALFactory::~CDALFactory()
{
}


HRESULT
CDALFactory::FinalConstruct()
{
    if (bFailedLoad)
        return E_FAIL;
    return S_OK;
}

STDMETHODIMP
CDALFactory::CreateSingleBehavior(long id,
                                  double duration,
                                  IDABehavior *bvr,
                                  IDALSingleBehavior **ppOut)
{
    CHECK_RETURN_SET_NULL(ppOut);
    
    HRESULT hr;
    
    DAComObject<CDALSingleBehavior> *pNew;
    DAComObject<CDALSingleBehavior>::CreateInstance(&pNew);

    if (!pNew) {
        THR(hr = E_OUTOFMEMORY);
    } else {
        THR(hr = pNew->Init(id, duration, bvr));
        
        if (SUCCEEDED(hr)) {
            THR(hr = pNew->QueryInterface(IID_IDALSingleBehavior,
                                          (void **)ppOut));
        }
    }

    if (FAILED(hr))
        delete pNew;

    return hr;
}

STDMETHODIMP
CDALFactory::CreateImportBehavior(long id,
                                  IDABehavior *bvr,
                                  IDAImportationResult *impres,
                                  IDABehavior *prebvr,
                                  IDABehavior *postbvr,
                                  IDALImportBehavior **ppOut)
{
    CHECK_RETURN_SET_NULL(ppOut);

    HRESULT hr;

    DAComObject<CDALImportBehavior> *pNew;
    DAComObject<CDALImportBehavior>::CreateInstance(&pNew);

    if (!pNew) {
        THR(hr = E_OUTOFMEMORY);
    } else {
        THR(hr = pNew->Init(id, bvr, impres, prebvr, postbvr));

        if (SUCCEEDED(hr)) {
            THR(hr = pNew->QueryInterface(IID_IDALImportBehavior,
                                          (void **)ppOut));
        }
    }

    if (FAILED(hr))
        delete pNew;

    return hr;
}

STDMETHODIMP
CDALFactory::CreateSequenceBehavior(long id,
                                    VARIANT seqArray,
                                    IDALSequenceBehavior **ppOut)
{
    CHECK_RETURN_SET_NULL(ppOut);

    SafeArrayAccessor sa(seqArray, true);

    if (!sa.IsOK()) return Error();

    HRESULT hr;
    
    DAComObject<CDALSequenceBehavior> *pNew;
    DAComObject<CDALSequenceBehavior>::CreateInstance(&pNew);

    if (!pNew) {
        THR(hr = E_OUTOFMEMORY);
    } else {
        THR(hr = pNew->Init(id, sa.GetArraySize(), sa.GetArray()));
        
        if (SUCCEEDED(hr)) {
            THR(hr = pNew->QueryInterface(IID_IDALSequenceBehavior,
                                          (void **)ppOut));
        }
    }

    if (FAILED(hr))
        delete pNew;

    return hr;
}

STDMETHODIMP
CDALFactory::CreateSequenceBehaviorEx(long id,
                                      long s,
                                      IDALBehavior **seqArray,
                                      IDALSequenceBehavior **ppOut)
{
    CHECK_RETURN_SET_NULL(ppOut);
    
    HRESULT hr;
    
    DAComObject<CDALSequenceBehavior> *pNew;
    DAComObject<CDALSequenceBehavior>::CreateInstance(&pNew);

    if (!pNew) {
        THR(hr = E_OUTOFMEMORY);
    } else {
        THR(hr = pNew->Init(id, s, (IUnknown **) seqArray));
        
        if (SUCCEEDED(hr)) {
            THR(hr = pNew->QueryInterface(IID_IDALSequenceBehavior,
                                          (void **)ppOut));
        }
    }

    if (FAILED(hr))
        delete pNew;

    return hr;
}

STDMETHODIMP
CDALFactory::CreateTrack(IDALBehavior *bvr,
                         IDALTrack **ppOut)
{
    CHECK_RETURN_SET_NULL(ppOut);
    
    HRESULT hr;
    
    DAComObject<CDALTrack> *pNew;
    DAComObject<CDALTrack>::CreateInstance(&pNew);

    if (!pNew) {
        THR(hr = E_OUTOFMEMORY);
    } else {
        THR(hr = pNew->Init(bvr));
        
        if (SUCCEEDED(hr)) {
            THR(hr = pNew->QueryInterface(IID_IDALTrack,
                                          (void **)ppOut));
        }
    }

    if (FAILED(hr))
        delete pNew;

    return hr;
}

HRESULT
CDALFactory::Error()
{
    LPCWSTR str = CRGetLastErrorString();
    HRESULT hr = CRGetLastError();
    
    if (str)
        return CComCoClass<CDALFactory, &CLSID_DALFactory>::Error(str, IID_IDALFactory, hr);
    else
        return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\dalite\src\factory.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _FACTORY_H
#define _FACTORY_H

#define LIBID "DirectAnimationTxD"

class ATL_NO_VTABLE CDALFactory
    : public CComObjectRootEx<CComSingleThreadModel>,
      public CComCoClass<CDALFactory, &CLSID_DALFactory>,
      public IDispatchImpl<IDALFactory, &IID_IDALFactory, &LIBID_DirectAnimationTxD>,
      public IObjectSafetyImpl<CDALFactory>,
      public ISupportErrorInfoImpl<&IID_IDALFactory>
{
  public:
    CDALFactory();
    ~CDALFactory();

    DA_DECLARE_NOT_AGGREGATABLE(CDALFactory);

    HRESULT FinalConstruct();
#if _DEBUG
    const char * GetName() { return "CDALFactory"; }
#endif

    DECLARE_REGISTRY(CLSID_DALFactory,
                     LIBID ".DATXDFactory.1",
                     LIBID ".DATXDFactory",
                     0,
                     THREADFLAGS_BOTH);

    BEGIN_COM_MAP(CDALFactory)
        COM_INTERFACE_ENTRY(IDALFactory)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY_IMPL(IObjectSafety)
    END_COM_MAP();

    STDMETHOD(CreateSingleBehavior)(long id,
                                    double duration,
                                    IDABehavior *bvr,
                                    IDALSingleBehavior **ppOut);
    STDMETHOD(CreateSequenceBehavior)(long id,
                                      VARIANT seqArray,
                                      IDALSequenceBehavior **ppOut);
    STDMETHOD(CreateSequenceBehaviorEx)(long id,
                                        long s,
                                        IDALBehavior **seqArray,
                                        IDALSequenceBehavior **ppOut);
    STDMETHOD(CreateTrack)(IDALBehavior *bvr,
                           IDALTrack **ppOut);

    STDMETHOD(CreateImportBehavior)(long id,
                                    IDABehavior *bvr,
                                    IDAImportationResult *impres,
                                    IDABehavior *prebvr,
                                    IDABehavior *postbvr,
                                    IDALImportBehavior **ppOut);

    HRESULT Error();
};


#endif /* _FACTORY_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\dalite\src\headers.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _HEADERS_H
#define _HEADERS_H

#include "include/headers.h"
#include "dalite.h"
#include "comutil.h"
#include "dartapi.h"
#include "util.h"
#include <list>

#endif /* _HEADERS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\dalite\src\import.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"
#include "import.h"
#include "track.h"

DeclareTag(tagImportBvr, "API", "CDALImportBehavior methods");
extern TAG tagNotify;

CDALImportBehavior::CDALImportBehavior()
: m_importid(-1)
{
    TraceTag((tagImportBvr,
              "CDALImportBehavior(%lx)::CDALImportBehavior()",
              this));
}

CDALImportBehavior::~CDALImportBehavior()
{
    TraceTag((tagImportBvr,
              "CDALImportBehavior(%lx)::~CDALImportBehavior()",
              this));
}

HRESULT
CDALImportBehavior::Init(long id,
                         IDABehavior *bvr,
                         IDAImportationResult *impres,
                         IDABehavior * prebvr,
                         IDABehavior * postbvr)
{
    TraceTag((tagImportBvr,
              "CDALImportBehavior(%lx)::Init(%d, %lx, %lx, %lx, %lx)",
              this,
              id,
              bvr,
              impres,
              prebvr,
              postbvr));
    
    bool ok = false;
    
    m_id = id;
    m_duration = HUGE_VAL;
    
    {
        DAComPtr<IDANumber> danum;
        DAComPtr<IDAEvent> daev;
        HRESULT hr;
        
        if (FAILED(hr = impres->get_Duration(&danum))) {
            CRSetLastError(hr, NULL);
            goto done;
        }
        
        m_durationBvr = (CRNumberPtr) COMToCRBvr(danum.p);
        
        if (!m_durationBvr)
            goto done;

        if (FAILED(hr = impres->get_CompletionEvent(&daev))) {
            CRSetLastError(hr, NULL);
            goto done;
        }
        
        m_completionEvent = (CREventPtr) COMToCRBvr(daev.p);
        
        if (!m_completionEvent)
            goto done;
    }
    
    if (!bvr) {
        CRSetLastError(E_INVALIDARG, NULL);
        goto done;
    }
    
    m_importbvr = COMToCRBvr(bvr);
    
    if (!m_importbvr)
        goto done;

    if (prebvr) {
        m_prebvr = COMToCRBvr(prebvr);
    
        if (!m_prebvr)
            goto done;
    }

    if (postbvr) {
        m_postbvr = COMToCRBvr(postbvr);
    
        if (!m_postbvr)
            goto done;
    }

    m_typeId = CRGetTypeId(m_importbvr);
    
    Assert(m_typeId != CRUNKNOWN_TYPEID &&
           m_typeId != CRINVALID_TYPEID);
    
    if (m_prebvr || m_postbvr)
    {
        CRLockGrabber __gclg;
        
        m_bvr = CRModifiableBvr(m_importbvr, CRContinueTimeline);
        
        if (!m_bvr)
            goto done;
    }
    else
    {
        m_bvr = m_importbvr;
    }

    UpdateTotalDuration();

    ok = true;
  done:    
    return ok?S_OK:CRGetLastError();
}

bool
CDALImportBehavior::SetTrack(CDALTrack * parent)
{
    bool ok = false;
    
    if (!CDALBehavior::SetTrack(parent))
        goto done;

    if (m_track) {
        CRLockGrabber __gclg;
        CRBvrPtr danum;

        if ((danum = (CRBvrPtr) CRCreateNumber(0)) == NULL ||
            (danum = CRUntilNotify(danum,
                                   m_completionEvent,
                                   this)) == NULL ||
            (m_importid = m_track->AddPendingImport(danum)) == -1)
            goto done;
    }

    ok = true;
  done:
    return ok;
}

void
CDALImportBehavior::ClearTrack(CDALTrack * parent)
{
    if (m_track && m_importid != -1) {
        m_track->RemovePendingImport(m_importid);
        m_importid = -1;
    }
    CDALBehavior::ClearTrack(parent);
}

CRSTDAPICB_(CRBvrPtr)
CDALImportBehavior::Notify(CRBvrPtr eventData,
                           CRBvrPtr curRunningBvr,
                           CRViewPtr curView)
{
    if (m_track && m_importid != -1) {
        m_track->RemovePendingImport(m_importid);
        m_importid = -1;
    }

    Assert(CRIsConstantBvr(eventData));

    Assert(CRGetTypeId(eventData) == CRNUMBER_TYPEID);
    
    double d = CRExtract((CRNumberPtr) eventData);
    bool bFailed = (d == -1.0);
    
    if (!bFailed) {
        // Need to update the duration in case they change state
        // during the callback
        
        Assert(CRIsConstantBvr((CRBvrPtr) m_durationBvr.p));
        
        THR(SetDuration(CRExtract(m_durationBvr)));
    }

    // Now we need to update the behavior with the correct duration
    // (since sometimes imports do not always return the accurate
    // duration) and also to add the pre and post behaviors
    
    {
        CRLockGrabber __gclg;

        CRBvrPtr curbvr = m_importbvr;
        
        if (m_prebvr || m_postbvr)
        {
            if (m_prebvr)
            {
                CRBvrPtr b;
                
                b = CRDuration(m_prebvr, 0.00000001);
                
                if (b) {
                    curbvr = CRSequence(b, curbvr);
                }
            }
            
            if (curbvr && m_postbvr)
            {
                curbvr = CRSequence(curbvr, m_postbvr);
            }

            if (curbvr)
            {
                CRSwitchTo(m_bvr, curbvr, false, 0, 0);
            }
        }
    }
    
    if (m_track && m_eventcb) {
        TraceTag((tagNotify,
                  "DAL::Notify(%#x): id = %#x, gTime = %g, lTime = %g, event = %s, data = %g",
                  m_track, m_id, m_track->GetCurrentGlobalTime(), m_track->GetCurrentTime(),
                  EventString(bFailed?DAL_ONLOAD_ERROR_EVENT:DAL_ONLOAD_EVENT),
                  d));

        CallBackData data(this,
                          m_eventcb,
                          m_id,
                          m_track->GetCurrentTime(),
                          bFailed?DAL_ONLOAD_ERROR_EVENT:DAL_ONLOAD_EVENT);
    
        THR(data.CallEvent());

    }

    return curRunningBvr;
}

HRESULT
CDALImportBehavior::Error()
{
    LPCWSTR str = CRGetLastErrorString();
    HRESULT hr = CRGetLastError();
    
    TraceTag((tagError,
              "CDALImportBehavior(%lx)::Error(%hr,%ls)",
              this,
              hr,
              str?str:L"NULL"));

    if (str)
        return CComCoClass<CDALImportBehavior, &__uuidof(CDALImportBehavior)>::Error(str, IID_IDALImportBehavior, hr);
    else
        return hr;
}

#if _DEBUG
void
CDALImportBehavior::Print(int spaces)
{
    char buf[1024];

    sprintf(buf, "%*s[id = %#x, dur = %g, tt = %g, rep = %d, bounce = %d]\r\n",
            spaces,"",
            m_id, m_duration, m_totaltime, m_repeat, m_bBounce);

    OutputDebugString(buf);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\dalite\src\bvr.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"
#include "bvr.h"
#include "track.h"

DeclareTag(tagBvr, "API", "CDALBehavior methods");
DeclareTag(tagNotify, "API", "Notifications");

CDALBehavior::CDALBehavior()
: m_id(0),
  m_duration(-1),
  m_totaltime(-1),
  m_repeat(1),
  m_bBounce(false),
  m_totalduration(0.0),
  m_repduration(0.0),
  m_totalrepduration(0.0),
  m_track(NULL),
  m_parent(NULL),
  m_typeId(CRINVALID_TYPEID),
  m_easein(0.0),
  m_easeinstart(0.0),
  m_easeout(0.0),
  m_easeoutend(0.0)
{
    TraceTag((tagBvr,
              "CDALBehavior(%lx)::CDALBehavior()",
              this));
}

CDALBehavior::~CDALBehavior()
{
    TraceTag((tagBvr,
              "CDALBehavior(%lx)::~CDALBehavior()",
              this));
}

HRESULT
CDALBehavior::GetID(long * pid)
{
    TraceTag((tagBvr,
              "CDALBehavior(%lx)::GetID()",
              this));

    CHECK_RETURN_NULL(pid);

    *pid = m_id;
    return S_OK;
}

HRESULT
CDALBehavior::SetID(long id)
{
    TraceTag((tagBvr,
              "CDALBehavior(%lx)::SetID(%d)",
              this,
              id));

    if (IsStarted()) return E_FAIL;
    
    m_id = id;
    return S_OK;
}
        
HRESULT
CDALBehavior::GetDuration(double * pdur)
{
    TraceTag((tagBvr,
              "CDALBehavior(%lx)::GetDuration()",
              this));

    CHECK_RETURN_NULL(pdur);

    *pdur = m_duration;
    return S_OK;
}

HRESULT
CDALBehavior::SetDuration(double dur)
{
    TraceTag((tagBvr,
              "CDALBehavior(%lx)::SetDuration(%g)",
              this,
              dur));

    if (IsStarted()) return E_FAIL;

    m_duration = dur;

    Invalidate();
    
    return S_OK;
}
        
HRESULT
CDALBehavior::GetTotalTime(double * pdur)
{
    TraceTag((tagBvr,
              "CDALBehavior(%lx)::GetTotalTime()",
              this));

    CHECK_RETURN_NULL(pdur);

    *pdur = m_totaltime;
    return S_OK;
}

HRESULT
CDALBehavior::SetTotalTime(double dur)
{
    TraceTag((tagBvr,
              "CDALBehavior(%lx)::SetTotaltime(%g)",
              this,
              dur));

    if (IsStarted()) return E_FAIL;

    m_totaltime = dur;

    Invalidate();
    
    return S_OK;
}
        
HRESULT
CDALBehavior::GetRepeat(long * prepeat)
{
    TraceTag((tagBvr,
              "CDALBehavior(%lx)::GetRepeat()",
              this));

    CHECK_RETURN_NULL(prepeat);

    *prepeat = m_repeat;
    return S_OK;
}

HRESULT
CDALBehavior::SetRepeat(long repeat)
{
    TraceTag((tagBvr,
              "CDALBehavior(%lx)::SetRepeat(%d)",
              this,
              repeat));

    if (IsStarted()) return E_FAIL;

    m_repeat = repeat;

    Invalidate();
    
    return S_OK;
}
        
HRESULT
CDALBehavior::GetBounce(VARIANT_BOOL * pbounce)
{
    TraceTag((tagBvr,
              "CDALBehavior(%lx)::GetBounce()",
              this));

    CHECK_RETURN_NULL(pbounce);

    *pbounce = m_bBounce;
    return S_OK;
}

HRESULT
CDALBehavior::SetBounce(VARIANT_BOOL bounce)
{
    TraceTag((tagBvr,
              "CDALBehavior(%lx)::SetBounce(%d)",
              this,
              bounce));

    if (IsStarted()) return E_FAIL;

    m_bBounce = bounce?true:false;

    Invalidate();
    
    return S_OK;
}
        
HRESULT
CDALBehavior::GetEventCB(IDALEventCB ** evcb)
{
    TraceTag((tagBvr,
              "CDALBehavior(%lx)::GetEventCB()",
              this));

    CHECK_RETURN_SET_NULL(evcb);

    *evcb = m_eventcb;
    if (m_eventcb) m_eventcb->AddRef();

    return S_OK;
}

HRESULT
CDALBehavior::SetEventCB(IDALEventCB * evcb)
{
    TraceTag((tagBvr,
              "CDALBehavior(%lx)::SetEventCB(%lx)",
              this,
              evcb));

    if (IsStarted()) return E_FAIL;

    m_eventcb = evcb;
    return S_OK;
}
        
HRESULT
CDALBehavior::GetEaseIn(float * pd)
{
    TraceTag((tagBvr,
              "CDALBehavior(%lx)::GetEaseIn()",
              this));

    CHECK_RETURN_NULL(pd);

    *pd = m_easein;
    return S_OK;
}

HRESULT
CDALBehavior::SetEaseIn(float d)
{
    TraceTag((tagBvr,
              "CDALBehavior(%lx)::SetEaseIn(%g)",
              this,
              d));

    if (IsStarted()) return E_FAIL;

    if (d < 0.0 || d > 1.0) return E_INVALIDARG;
    
    m_easein = d;

    Invalidate();
    
    return S_OK;
}
        
HRESULT
CDALBehavior::GetEaseInStart(float * pd)
{
    TraceTag((tagBvr,
              "CDALBehavior(%lx)::GetEaseInStart()",
              this));

    CHECK_RETURN_NULL(pd);

    *pd = m_easeinstart;
    return S_OK;
}

HRESULT
CDALBehavior::SetEaseInStart(float d)
{
    TraceTag((tagBvr,
              "CDALBehavior(%lx)::SetEaseInStart(%g)",
              this,
              d));

    if (IsStarted()) return E_FAIL;

    if (d < 0.0 || d > 1.0) return E_INVALIDARG;

    m_easeinstart = d;

    Invalidate();
    
    return S_OK;
}
        
HRESULT
CDALBehavior::GetEaseOut(float * pd)
{
    TraceTag((tagBvr,
              "CDALBehavior(%lx)::GetEaseOut()",
              this));

    CHECK_RETURN_NULL(pd);

    *pd = m_easeout;
    return S_OK;
}

HRESULT
CDALBehavior::SetEaseOut(float d)
{
    TraceTag((tagBvr,
              "CDALBehavior(%lx)::SetEaseOut(%g)",
              this,
              d));

    if (IsStarted()) return E_FAIL;

    if (d < 0.0 || d > 1.0) return E_INVALIDARG;

    m_easeout = d;

    Invalidate();
    
    return S_OK;
}
        
HRESULT
CDALBehavior::GetEaseOutEnd(float * pd)
{
    TraceTag((tagBvr,
              "CDALBehavior(%lx)::GetEaseOutEnd()",
              this));

    CHECK_RETURN_NULL(pd);

    *pd = m_easeoutend;
    return S_OK;
}

HRESULT
CDALBehavior::SetEaseOutEnd(float d)
{
    TraceTag((tagBvr,
              "CDALBehavior(%lx)::SetEaseOutEnd(%g)",
              this,
              d));

    if (IsStarted()) return E_FAIL;

    if (d < 0.0 || d > 1.0) return E_INVALIDARG;

    m_easeoutend = d;

    Invalidate();
    
    return S_OK;
}
        
void
CDALBehavior::Invalidate()
{
    TraceTag((tagBvr,
              "CDALBehavior(%lx)::Invalidate()",
              this));

    UpdateTotalDuration();
    if (m_track) m_track->Invalidate();
    if (m_parent) m_parent->Invalidate();
}

CRBvrPtr
CDALBehavior::Start()
{
    TraceTag((tagBvr,
              "CDALBehavior(%lx)::Start()",
              this));

    // Do not need to get GC lock since we assume the caller already
    // has
    
    CRBvrPtr newBvr = NULL;

    if (IsStarted()) {
        CRSetLastError(E_FAIL, NULL);
        goto done;
    }

    // Make sure we calculate the ease in/out coeff
    
    CalculateEaseCoeff();
    
    CRBvrPtr curbvr;

    curbvr = m_bvr;

    CRNumberPtr zeroTime;
    CRNumberPtr durationTime;
    
    if (m_bNeedEase) {
        CRNumberPtr time;

        if ((time = EaseTime(CRLocalTime())) == NULL ||
            (curbvr = CRSubstituteTime(curbvr, time)) == NULL)
            goto done;
    }

    if ((zeroTime = CRCreateNumber(0)) == NULL ||
        (durationTime = CRCreateNumber(m_duration)) == NULL)
        goto done;
    
    // For now clamp to the duration as well

    CRNumberPtr timeSub;
    CRBooleanPtr cond;

    if (m_bBounce) {
        CRNumberPtr totalTime;
    
        // Invert time from duration to repduration and clamp to
        // zero
        
        if ((totalTime = CRCreateNumber(m_repduration)) == NULL ||
            (timeSub = CRSub(totalTime, CRLocalTime())) == NULL ||
            (cond = CRLTE(timeSub, zeroTime)) == NULL ||
            (timeSub = (CRNumberPtr) CRCond(cond,
                                            (CRBvrPtr) zeroTime,
                                            (CRBvrPtr) timeSub)) == NULL)
            goto done;
    } else {
        timeSub = durationTime;
    }
    
    // We are localTime until the duration and then we are whatever
    // timeSub is currently set to from above (either clamped for
    // duration time for non-bounce or reversed for the bounce case)

    if ((cond = CRGTE(CRLocalTime(), durationTime)) == NULL ||
        (timeSub = (CRNumberPtr) CRCond(cond,
                                        (CRBvrPtr) timeSub,
                                        (CRBvrPtr) CRLocalTime())) == NULL)
        goto done;

    // Substitute the clock and clamp to the duration
    
    if (IsContinuousMediaBvr())
    {
        if (!(m_repeat == 0 && m_typeId == CRSOUND_TYPEID))
        {
            if ((curbvr = CRDuration(curbvr, m_duration)) == NULL)
                goto done;
        }
    }
    else
    {
        if ((curbvr = CRSubstituteTime(curbvr, timeSub)) == NULL ||
            (curbvr = CRDuration(curbvr, m_repduration)) == NULL)
            goto done;
    }

    if (m_repeat != 1) {
        if (m_repeat == 0) {
            curbvr = CRRepeatForever(curbvr);
        } else {
            curbvr = CRRepeat(curbvr, m_repeat);
        }

        if (curbvr == NULL)
            goto done;
    }

    // We have a total time so add another duration node
    if (m_totaltime != -1) {
        if ((curbvr = CRDuration(curbvr, m_totaltime)) == NULL)
            goto done;
    }
    
    // indicate success
    newBvr = curbvr;
    
  done:
    return newBvr;
}

bool
CDALBehavior::EventNotify(CallBackList &l,
                          double gTime,
                          DAL_EVENT_TYPE et)
{
    TraceTag((tagNotify,
              "DAL::Notify(%#x): id = %#x, gTime = %g, lTime = %g, event = %s",
              m_track,
              m_id,
              gTime,
              gTime - (m_track->GetCurrentGlobalTime() - m_track->GetCurrentTime()),
              EventString(et)));

    if (m_eventcb) {
        CallBackData * data = new CallBackData(this,
                                               m_eventcb,
                                               m_id,
                                               gTime,
                                               et);
    
        if (!data) {
            CRSetLastError(E_OUTOFMEMORY, NULL);
            return false;
        }
        
        l.push_back(data);
    }

    return true;
}

bool
CDALBehavior::ProcessCB(CallBackList & l,
                        double gTime,
                        double lastTick,
                        double curTime,
                        bool bForward,
                        bool bFirstTick,
                        bool bNeedPlay)
{
    TraceTag((tagBvr,
              "CDALBehavior(%lx)::ProcessCB(%g, %g, %g, %d, %d, %d)",
              this,
              gTime,
              lastTick,
              curTime,
              bForward,
              bFirstTick,
              bNeedPlay));

    if (bForward) {
        // See if we already pass this entire bvr last time or if we
        // have not got to it yet
        
        // The equality just needs to match what we checked below when
        // we fired the event the frame before.  We need to use LT for
        // curTime since we need to fire when we are 0
        
        if (lastTick >= m_totalrepduration ||
            (m_totaltime != -1 && lastTick >= m_totaltime) ||
            curTime < 0) {

            // Need to handle boundary case where we start at the end
            // of the animation.  If so then just fire the stop event
            // since the start was done by the start call itself
            
            double maxtime;
            int offset;
            
            // Clamp to total duration
            if (m_totaltime != -1 && m_totaltime < m_totalrepduration)
                maxtime = m_totaltime;
            else
                maxtime = m_totalrepduration;

            if (curTime == maxtime && lastTick == maxtime && bFirstTick) {
                int offset = ceil(curTime / m_duration) - 1;
                if (offset < 0) offset = 0;
                double timeOffset = offset * m_duration;

                if (!_ProcessCB(l,
                                gTime + timeOffset,
                                lastTick - timeOffset,
                                curTime - timeOffset,
                                bForward,
                                bFirstTick,
                                bNeedPlay,
                                m_bBounce && (offset & 0x1)))
                    return false;

                EventNotify(l, gTime + maxtime, DAL_STOP_EVENT);
            }

            return true;
        }
        
        // We now know that the last tick was less than the
        // totalrepduration and the current time is greater than the
        // beginning

        // If the last tick was 0 then we fire the start last time
        // since the check above if for less than
        // So the rule is fire when curTime == 0.0
        
        bool bNeedStart = (lastTick < 0 || bNeedPlay);

        if (bNeedStart) {
            // This means that we just entered

            EventNotify(l, gTime, DAL_PLAY_EVENT);
        }
        
        if (m_duration == HUGE_VAL) {
            // Just always process our children if we are infinite
            
            if (!_ProcessCB(l,
                            gTime,
                            lastTick,
                            curTime,
                            bForward,
                            bFirstTick,
                            bNeedPlay,
                            false))
                return false;
            
        } else {
            // This is the last repeat/bounce boundary we hit
        
            int offset = int(lastTick / m_duration);
            if (offset < 0) offset = 0;
            double timeOffset = offset * m_duration;
            double maxtime;
            
            if (curTime > m_totalduration)
                maxtime = m_totalduration;
            else
                maxtime = curTime;

            while (1) {
                
                // We need to request a reversal of the underlying
                // behavior if we are bouncing and the offset is odd
                
                if (!_ProcessCB(l,
                                gTime + timeOffset,
                                lastTick - timeOffset,
                                maxtime - timeOffset,
                                true,
                                bFirstTick,
                                bNeedStart,
                                m_bBounce && (offset & 0x1)))
                    return false;
                
                offset++;
                timeOffset += m_duration;
                
                // If we have reached the end then notify and break
                
                if (timeOffset > curTime ||
                    timeOffset >= m_totalduration ||
                    timeOffset >= m_totalrepduration) {

                    if (curTime >= m_totalrepduration ||
                        curTime >= m_totalduration) {
                        // This means we were inside last time but not any more -
                        // generate an exit event
                        
                        EventNotify(l, gTime + maxtime, DAL_STOP_EVENT);
                    }
                    
                    break;
                }
                
                // Indicate a repeat or bounce
                // If we are bouncing and the offset is odd then it is
                // a bounce and not a repeat
                
                if (m_bBounce && (offset & 0x1))
                    EventNotify(l, gTime + timeOffset, DAL_BOUNCE_EVENT);
                else
                    EventNotify(l, gTime + timeOffset, DAL_REPEAT_EVENT);
            }
        }
    } else {
        // See if we already pass this entire bvr last time or if we
        // have not got to it yet
        
        double maxtime;

        // Clamp to total duration
        if (m_totaltime != -1 && m_totaltime < m_totalrepduration)
            maxtime = m_totaltime;
        else
            maxtime = m_totalrepduration;
            
        if (curTime > maxtime || lastTick <= 0) {
            
            if (curTime == 0.0 && lastTick == 0.0 && bFirstTick) {
                // Need to handle the boundary case where we start at
                // the beginning going backwards.  The start call
                // itself handles the start event but we need to
                // process the rest of the behaviors to fire the stops

                if (!_ProcessCB(l,
                                gTime,
                                lastTick,
                                curTime,
                                bForward,
                                true,
                                bNeedPlay,
                                false))
                    return false;

                EventNotify(l, gTime, DAL_STOP_EVENT);
            }
            
            return true;
        }
        
        // We now know that the last tick was greater than the beginning
        // and the current time less than the total duration
        
        bool bNeedStart = (lastTick > m_totalduration ||
                           lastTick > m_totalrepduration ||
                           bNeedPlay);

        if (bNeedStart) {
            // This means that we just entered and we cannot have an
            // infinite value

            EventNotify(l, gTime - maxtime, DAL_PLAY_EVENT);
            
        }

        if (m_duration == HUGE_VAL) {
            // Just always process our children if we are infinite
            
            if (!_ProcessCB(l,
                            gTime,
                            lastTick,
                            curTime,
                            bForward,
                            bFirstTick,
                            bNeedPlay,
                            false))
                return false;

            if (curTime <= 0) {
                EventNotify(l, gTime, DAL_STOP_EVENT);
            }
                
        } else {
            // This will be the repeat point to begin with
            int offset;
            double timeOffset;

            // Now clamp to the last tick
            if (lastTick < maxtime)
                maxtime = lastTick;
                
            // This puts us on the last duration boundary greater than
            // the last position

            // It needs to be one greater since our loop decrements
            // first
            offset = int(ceil(maxtime / m_duration));
            timeOffset = offset * m_duration;
            
            while (1) {
                offset--;
                timeOffset -= m_duration;
            
                if (!_ProcessCB(l,
                                gTime - timeOffset,
                                maxtime - timeOffset,
                                curTime - timeOffset,
                                false,
                                bFirstTick,
                                bNeedStart,
                                m_bBounce && (offset & 0x1)))
                    return false;
                
                if (timeOffset < curTime) break;
                
                // If we have reached the end then notify and break
                
                if (offset <= 0) {
                    // This means we were inside last time but not any more -
                    // generate an exit event
                    
                    EventNotify(l, gTime, DAL_STOP_EVENT);
                    
                    break;
                }
                
                // Indicate a repeat or bounce
                // If we are bouncing and the offset is odd then it is
                // a bounce and not a repeat
                
                if (m_bBounce && (offset & 0x1))
                    EventNotify(l, gTime - timeOffset, DAL_BOUNCE_EVENT);
                else
                    EventNotify(l, gTime - timeOffset, DAL_REPEAT_EVENT);
            }
        }
    }
    
    return true;
}

bool
CDALBehavior::ProcessEvent(CallBackList & l,
                           double gTime,
                           double time,
                           bool bFirstTick,
                           DAL_EVENT_TYPE et)
{
    TraceTag((tagBvr,
              "CDALBehavior(%lx)::ProcessEvent(%g, %g, %d, %s)",
              this,
              gTime,
              time,
              bFirstTick,
              EventString(et)));

    // If it is outside of our range then just bail
    
    if (time < 0 || time > m_totalduration || time > m_totalrepduration)
        return true;
    
    // If it is not the first tick and we are on a boundary do not
    // fire the events - they were already fired
    if (!bFirstTick &&
        (time == 0 ||
         time == m_totalduration ||
         time == m_totalrepduration))
        return true;
    
    // Plays and Pauses get called on the way down
    if (et == DAL_PAUSE_EVENT ||
        et == DAL_PLAY_EVENT) {
        EventNotify(l, gTime, et);
    }
    
    if (m_duration == HUGE_VAL) {
        // Just always process our children if we are infinite
        
        if (!_ProcessEvent(l,
                           gTime,
                           time,
                           bFirstTick,
                           et,
                           false))
            return false;
    } else {
        // This is the last repeat/bounce boundary we hit
        int offset = int(time / m_duration);
        
        Assert(offset >= 0);

        // We need to request a reversal of the underlying
        // behavior if we are bouncing and the offset is odd
        
        if (!_ProcessEvent(l,
                           gTime,
                           time - (offset * m_duration),
                           bFirstTick,
                           et,
                           m_bBounce && (offset & 0x1)))
            return false;
    }
    
    // Stops and Resumes get called on the way up
    if (et == DAL_STOP_EVENT ||
        et == DAL_RESUME_EVENT) {
        EventNotify(l, gTime, et);
    }
    
    return true;
}

bool
CDALBehavior::SetTrack(CDALTrack * parent)
{
    if (m_track) return false;
    m_track = parent;
    return true;
}

void
CDALBehavior::ClearTrack(CDALTrack * parent)
{
    if (parent == NULL || parent == m_track) {
        m_track = NULL;
    }
}

bool
CDALBehavior::IsStarted()
{
    return (m_track && m_track->IsStarted());
}

void
CDALBehavior::CalculateEaseCoeff()
{
    Assert(m_easein >= 0 && m_easein <= 1);
    Assert(m_easeout >= 0 && m_easeout <= 1);
    Assert(m_easeinstart >= 0 && m_easeinstart <= 1);
    Assert(m_easeoutend >= 0 && m_easeoutend <= 1);

    // We need to ease the behavior if we are not infinite and either
    // ease in or ease out percentages are non-zero
    
    m_bNeedEase = (m_duration != HUGE_VAL &&
                   (m_easein > 0 || m_easeout > 0) &&
                   (m_easein + m_easeout <= 1));

    if (!m_bNeedEase) return;
    
    float flEaseInDuration = m_easein * m_duration;
    float flEaseOutDuration = m_easeout * m_duration;
    float flMiddleDuration = m_duration - flEaseInDuration - flEaseOutDuration;
    
    // Compute B1, the velocity during segment B.
    float flInvB1 = (0.5f * m_easein * (m_easeinstart - 1) +
                     0.5f * m_easeout * (m_easeoutend - 1) + 1);
    Assert(flInvB1 > 0);
    m_flB1 = 1 / flInvB1;
    
    // Basically for accelerated pieces - t = t0 + v0 * t + 1/2 at^2
    // and a = Vend - Vstart / t

    if (flEaseInDuration != 0) {
        m_flA0 = 0;
        m_flA1 = m_easeinstart * m_flB1;
        m_flA2 = 0.5f * (m_flB1 - m_flA1) / flEaseInDuration;
    } else {
        m_flA0 = m_flA1 = m_flA2 = 0;
    }

    m_flB0 = m_flA0 + m_flA1 * flEaseInDuration + m_flA2 * flEaseInDuration * flEaseInDuration;
    
    if (flEaseOutDuration != 0) {
        m_flC0 = m_flB1 * flMiddleDuration + m_flB0;
        m_flC1 = m_flB1;
        m_flC2 = 0.5f * (m_easeoutend * m_flB1 - m_flC1) / flEaseOutDuration;
    } else {
        m_flC0 = m_flC1 = m_flC2 = 0;
    }

    m_easeinEnd = flEaseInDuration;
    m_easeoutStart = m_duration - flEaseOutDuration;
}

CRNumberPtr
Quadratic(CRNumberPtr time, float flA, float flB, float flC)
{
    // Assume that the GC lock is acquired
    
    // Need to calculate ax^2 + bx + c

    Assert(time != NULL);

    CRNumberPtr ret = NULL;
    CRNumberPtr accum = NULL;

    if (flC != 0.0) {
        if ((accum = CRCreateNumber(flC)) == NULL)
            goto done;
    }

    if (flB != 0.0) {
        CRNumberPtr term;

        if ((term = CRCreateNumber(flB)) == NULL ||
            (term = CRMul(term, time)) == NULL)
            goto done;

        if (accum) {
            if ((term = CRAdd(term, accum)) == NULL)
                goto done;
        }

        accum = term;
    }

    if (flA != 0.0) {
        CRNumberPtr term;

        if ((term = CRCreateNumber(flA)) == NULL ||
            (term = CRMul(term, time)) == NULL ||
            (term = CRMul(term, time)) == NULL)
            goto done;

        if (accum) {
            if ((term = CRAdd(term, accum)) == NULL)
                goto done;
        }

        accum = term;
    }

    // If all the coeff are zero then just return 0
    
    if (accum == NULL) {
        if ((accum = CRCreateNumber(0.0)) == NULL)
            goto done;
    }
    
    ret = accum;
    
  done:
    return ret;
}

CRNumberPtr
AddTerm(CRNumberPtr time,
        CRNumberPtr prevTerm,
        float prevDur,
        float flA, float flB, float flC)
{
    CRNumberPtr ret = NULL;
    CRNumberPtr term;
    
    // Offset the time to be zero since that is what the coeffs are
    // based on
    
    if (prevTerm) {
        CRNumberPtr t;
        
        if ((t = CRCreateNumber(prevDur)) == NULL ||
            (time = CRSub(time, t)) == NULL)
            goto done;
    }

    if ((term = Quadratic(time, flA, flB, flC)) == NULL)
        goto done;
    
    // Now we need to conditional use the new term

    if (prevTerm) {
        CRBooleanPtr cond;
        CRNumberPtr zeroTime;
        
        if ((zeroTime = CRCreateNumber(0)) == NULL ||
            (cond = CRLT(time, zeroTime)) == NULL ||
            (term = (CRNumberPtr) CRCond(cond,
                                         (CRBvrPtr) prevTerm,
                                         (CRBvrPtr) term)) == NULL)
            goto done;
    }

    ret = term;
  done:
    return ret;
}

CRNumberPtr
CDALBehavior::EaseTime(CRNumberPtr time)
{
    CRNumberPtr ret = NULL;
    CRNumberPtr subTime = NULL;
    
    if (!m_bNeedEase) {
        ret = time;
        goto done;
    }
    
    if (m_easein > 0) {
        if ((subTime = AddTerm(time,
                               subTime,
                               0.0,
                               m_flA2, m_flA1, m_flA0)) == NULL)
            goto done;
    }
    
    // If there is space between the end of easing in and the
    // beginning of easing out then we have some constant time
    // interval
    if (m_easeinEnd < m_easeoutStart) {
        if ((subTime = AddTerm(time,
                               subTime,
                               m_easeinEnd,
                               0, m_flB1, m_flB0)) == NULL)
            goto done;
    }

    if (m_easeout > 0) {
        if ((subTime = AddTerm(time,
                               subTime,
                               m_easeoutStart,
                               m_flC2, m_flC1, m_flC0)) == NULL)
            goto done;
    }
    
    ret = subTime;
    
    Assert(ret);
  done:
    return ret;
}

double
Quadratic(double time, float flA, float flB, float flC)
{
    // Need to calculate ax^2 + bx + c
    // Use x * (a * x + b) + c - since it requires 1 less multiply
    
    return (time * (flA * time + flB) + flC);
}

double
CDALBehavior::EaseTime(double time)
{
    if (!m_bNeedEase || time <= 0 || time >= m_duration)
        return time;
    
    if (time <= m_easeinEnd) {
        return Quadratic(time, m_flA2, m_flA1, m_flA0);
    } else if (time < m_easeoutStart) {
        return Quadratic(time - m_easeinEnd, 0, m_flB1, m_flB0);
    } else {
        return Quadratic(time - m_easeoutStart, m_flC2, m_flC1, m_flC0);
    }
}

class __declspec(uuid("D19C5C64-C3A8-11d1-A000-00C04FA32195"))
BvrGuid {};

HRESULT WINAPI
CDALBehavior::InternalQueryInterface(CDALBehavior* pThis,
                                     const _ATL_INTMAP_ENTRY* pEntries,
                                     REFIID iid,
                                     void** ppvObject)
{
    if (InlineIsEqualGUID(iid, __uuidof(BvrGuid))) {
        *ppvObject = pThis;
        return S_OK;
    }
    
    return CComObjectRootEx<CComSingleThreadModel>::InternalQueryInterface((void *)pThis,
                                                                           pEntries,
                                                                           iid,
                                                                           ppvObject);
}
        
CDALBehavior *
GetBvr(IUnknown * pbvr)
{
    CDALBehavior * bvr = NULL;

    if (pbvr) {
        pbvr->QueryInterface(__uuidof(BvrGuid),(void **)&bvr);
    }
    
    if (bvr == NULL) {
        CRSetLastError(E_INVALIDARG, NULL);
    }
                
    return bvr;
}

CallBackData::CallBackData(CDALBehavior * bvr,
                           IDALEventCB * eventcb,
                           long id,
                           double time,
                           DAL_EVENT_TYPE et)
: m_bvr(bvr),
  m_eventcb(eventcb),
  m_time(time),
  m_et(et),
  m_id(id)
{
    Assert(eventcb);
}

CallBackData::~CallBackData()
{
}

HRESULT
CallBackData::CallEvent()
{
    Assert(m_eventcb);
    
    return THR(m_eventcb->OnEvent(m_id,
                                  m_time,
                                  m_bvr,
                                  m_et));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\dalite\src\seq.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _SEQ_H
#define _SEQ_H

#include "bvr.h"
#include <list>

class
__declspec(uuid("445DE916-C3D8-11d1-A001-00C04FA32195")) 
ATL_NO_VTABLE CDALSequenceBehavior
    : public CDALBehavior,
      public CComCoClass<CDALSequenceBehavior, &__uuidof(CDALSequenceBehavior)>,
      public IDispatchImpl<IDALSequenceBehavior, &IID_IDALSequenceBehavior, &LIBID_DirectAnimationTxD>,
      public IObjectSafetyImpl<CDALSequenceBehavior>,
      public ISupportErrorInfoImpl<&IID_IDALSequenceBehavior>
{
  public:
    CDALSequenceBehavior();
    ~CDALSequenceBehavior();

    HRESULT Init(long id, long len, IUnknown ** bvr);
    
#if _DEBUG
    virtual const char * GetName() { return "CDALSequenceBehavior"; }
#endif

    BEGIN_COM_MAP(CDALSequenceBehavior)
        COM_INTERFACE_ENTRY2(IDispatch,IDALSequenceBehavior)
        COM_INTERFACE_ENTRY(IDALSequenceBehavior)
        COM_INTERFACE_ENTRY2(IDALBehavior,IDALSequenceBehavior)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY_IMPL(IObjectSafety)
    END_COM_MAP();

    STDMETHOD(get_ID)(long * pid) { return GetID(pid); }
    STDMETHOD(put_ID)(long id) { return SetID(id); }
        
    STDMETHOD(get_Duration)(double * pd) { return GetDuration(pd); }
    STDMETHOD(put_Duration)(double d) { return E_FAIL; }
        
    STDMETHOD(get_Repeat)(long * pr) { return GetRepeat(pr); }
    STDMETHOD(put_Repeat)(long r) { return SetRepeat(r); }
       
    STDMETHOD(get_Bounce)(VARIANT_BOOL * pr) { return GetBounce(pr); }
    STDMETHOD(put_Bounce)(VARIANT_BOOL r) { return SetBounce(r); }
        
    STDMETHOD(get_EventCB)(IDALEventCB ** ev) { return GetEventCB(ev); }
    STDMETHOD(put_EventCB)(IDALEventCB * ev) { return SetEventCB(ev); }
        
    STDMETHOD(get_TotalTime)(double * pd) { return GetTotalTime(pd); }
    STDMETHOD(put_TotalTime)(double d) { return SetTotalTime(d); }
        
    STDMETHOD(get_EaseIn)(float * pd) { return GetEaseIn(pd); }
    STDMETHOD(put_EaseIn)(float d) { return SetEaseIn(d); }

    STDMETHOD(get_EaseInStart)(float * pd) { return GetEaseInStart(pd); }
    STDMETHOD(put_EaseInStart)(float d) { return SetEaseInStart(d); }

    STDMETHOD(get_EaseOut)(float * pd) { return GetEaseOut(pd); }
    STDMETHOD(put_EaseOut)(float d) { return SetEaseOut(d); }

    STDMETHOD(get_EaseOutEnd)(float * pd) { return GetEaseOutEnd(pd); }
    STDMETHOD(put_EaseOutEnd)(float d) { return SetEaseOutEnd(d); }

    HRESULT Error();
    
    bool SetTrack(CDALTrack * parent);
    void ClearTrack(CDALTrack * parent);

    CRBvrPtr Start();
    bool _ProcessCB(CallBackList & l,
                    double gTime,
                    double lastTick,
                    double curTime,
                    bool bForward,
                    bool bFirstTick,
                    bool bNeedPlay,
                    bool bNeedsReverse);

    bool _ProcessEvent(CallBackList & l,
                       double gTime,
                       double time,
                       bool bFirstTick,
                       DAL_EVENT_TYPE et,
                       bool bNeedsReverse);
    
    virtual void Invalidate();

#if _DEBUG
    virtual void Print(int spaces);
#endif

    STDMETHOD(GetTypeInfoCount)(UINT* pctinfo)
    {*pctinfo = 1; return S_OK;}

    STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
    { return IDispatchImpl<IDALSequenceBehavior,
                           &IID_IDALSequenceBehavior,
                           &LIBID_DirectAnimationTxD>::GetTypeInfo(itinfo, lcid, pptinfo); }

    STDMETHOD(GetIDsOfNames)(REFIID riid, LPOLESTR* rgszNames, UINT cNames,
                             LCID lcid, DISPID* rgdispid)
    { return IDispatchImpl<IDALSequenceBehavior,
                           &IID_IDALSequenceBehavior,
                           &LIBID_DirectAnimationTxD>::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);}

    STDMETHOD(Invoke)(DISPID dispidMember, REFIID riid,
                      LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,
                      EXCEPINFO* pexcepinfo, UINT* puArgErr)
    { return IDispatchImpl<IDALSequenceBehavior,
                           &IID_IDALSequenceBehavior,
                           &LIBID_DirectAnimationTxD>::Invoke(dispidMember, riid, lcid,
                                                               wFlags, pdispparams, pvarResult,
                                                               pexcepinfo, puArgErr); }
  protected:
    void UpdateDuration();
    
    typedef std::list<CDALBehavior *> BvrList;
    BvrList m_list;
};

#endif /* _SEQ_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\dalite\src\singlebvr.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"
#include "singlebvr.h"

DeclareTag(tagSingleBvr, "API", "CDALSingleBehavior methods");

CDALSingleBehavior::CDALSingleBehavior()
{
    TraceTag((tagSingleBvr,
              "CDALSingleBehavior(%lx)::CDALSingleBehavior()",
              this));
}

CDALSingleBehavior::~CDALSingleBehavior()
{
    TraceTag((tagSingleBvr,
              "CDALSingleBehavior(%lx)::~CDALSingleBehavior()",
              this));
}

HRESULT
CDALSingleBehavior::Init(long id, double duration, IDABehavior *bvr)
{
    TraceTag((tagSingleBvr,
              "CDALSingleBehavior(%lx)::Init(%d, %g, %lx)",
              this,
              id,
              duration,
              bvr));
    
    m_id = id;
    m_duration = duration;
    
    if (!bvr) return E_INVALIDARG;
    
    m_bvr = COMToCRBvr(bvr);
    
    if (!m_bvr)
        return CRGetLastError();

    m_typeId = CRGetTypeId(m_bvr);
    
    Assert(m_typeId != CRUNKNOWN_TYPEID &&
           m_typeId != CRINVALID_TYPEID);
    
    UpdateTotalDuration();
    
    return S_OK;
}

STDMETHODIMP
CDALSingleBehavior::get_DABehavior(IDABehavior ** bvr)
{
    TraceTag((tagSingleBvr,
              "CDALSingleBehavior(%lx)::get_DABehavior(%lx)",
              this,
              bvr));

    return GetDABehavior(IID_IDABehavior,
                         (void **)bvr);
}

STDMETHODIMP
CDALSingleBehavior::put_DABehavior(IDABehavior * bvr)
{
    TraceTag((tagSingleBvr,
              "CDALSingleBehavior(%lx)::put_DABehavior(%lx)",
              this,
              bvr));

    if (IsStarted()) return E_FAIL;
    
    if (!bvr) return E_INVALIDARG;
    
    CRBvrPtr b = COMToCRBvr(bvr);
    if (!b)
        return Error();

    m_bvr = b;

    Invalidate();
    
    return S_OK;
}

STDMETHODIMP
CDALSingleBehavior::GetDABehavior(REFIID riid, void ** bvr)
{
    TraceTag((tagSingleBvr,
              "CDALSingleBehavior(%lx)::GetDABehavior()",
              this));

    CHECK_RETURN_SET_NULL(bvr);

    Assert(m_bvr);

    if (!CRBvrToCOM(m_bvr,
                    riid,
                    bvr))
        return Error();
    
    return S_OK;
}

HRESULT
CDALSingleBehavior::Error()
{
    LPCWSTR str = CRGetLastErrorString();
    HRESULT hr = CRGetLastError();
    
    TraceTag((tagError,
              "CDALSingleBehavior(%lx)::Error(%hr,%ls)",
              this,
              hr,
              str?str:L"NULL"));

    if (str)
        return CComCoClass<CDALSingleBehavior, &__uuidof(CDALSingleBehavior)>::Error(str, IID_IDALSingleBehavior, hr);
    else
        return hr;
}

#if _DEBUG
void
CDALSingleBehavior::Print(int spaces)
{
    char buf[1024];

    sprintf(buf, "%*s[id = %#x, dur = %g, tt = %g, rep = %d, bounce = %d]\r\n",
            spaces,"",
            m_id, m_duration, m_totaltime, m_repeat, m_bBounce);

    OutputDebugString(buf);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\dalite\src\import.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _IMPORTBVR_H
#define _IMPORTBVR_H

#include "bvr.h"

class
__declspec(uuid("D2A88CBB-C16D-11d1-A4E0-00C04FC29D46")) 
ATL_NO_VTABLE CDALImportBehavior
    : public CDALBehavior,
      public CComCoClass<CDALImportBehavior, &__uuidof(CDALImportBehavior)>,
      public IDispatchImpl<IDALImportBehavior, &IID_IDALImportBehavior, &LIBID_DirectAnimationTxD>,
      public IObjectSafetyImpl<CDALImportBehavior>,
      public ISupportErrorInfoImpl<&IID_IDALImportBehavior>,
      public CRUntilNotifier
{
  public:
    CDALImportBehavior();
    ~CDALImportBehavior();

    HRESULT Init(long id,
                 IDABehavior * bvr,
                 IDAImportationResult * impres,
                 IDABehavior * prebvr,
                 IDABehavior * postbvr);
    
#if _DEBUG
    virtual const char * GetName() { return "CDALImportBehavior"; }
#endif

    BEGIN_COM_MAP(CDALImportBehavior)
        COM_INTERFACE_ENTRY2(IDispatch, IDALImportBehavior)
        COM_INTERFACE_ENTRY(IDALImportBehavior)
        COM_INTERFACE_ENTRY2(IDALBehavior, IDALImportBehavior)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY_IMPL(IObjectSafety)
    END_COM_MAP();

    STDMETHOD(get_ID)(long * pid) { return GetID(pid); }
    STDMETHOD(put_ID)(long id) { return SetID(id); }
        
    STDMETHOD(get_Duration)(double * pd) { return GetDuration(pd); }
    STDMETHOD(put_Duration)(double d) { return E_FAIL; }
        
    STDMETHOD(get_Repeat)(long * pr) { return GetRepeat(pr); }
    STDMETHOD(put_Repeat)(long r) { return SetRepeat(r); }

    STDMETHOD(get_Bounce)(VARIANT_BOOL * pr) { return GetBounce(pr); }
    STDMETHOD(put_Bounce)(VARIANT_BOOL r) { return SetBounce(r); }
        
    STDMETHOD(get_EventCB)(IDALEventCB ** ev) { return GetEventCB(ev); }
    STDMETHOD(put_EventCB)(IDALEventCB * ev) { return SetEventCB(ev); }
        
    STDMETHOD(get_TotalTime)(double * pd) { return GetTotalTime(pd); }
    // TODO: HACK HACK - do not really set this for now.
    STDMETHOD(put_TotalTime)(double d) { return S_OK; /*return SetTotalTime(d);*/ }
        
    STDMETHOD(get_EaseIn)(float * pd) { return GetEaseIn(pd); }
    STDMETHOD(put_EaseIn)(float d) { return SetEaseIn(d); }

    STDMETHOD(get_EaseInStart)(float * pd) { return GetEaseInStart(pd); }
    STDMETHOD(put_EaseInStart)(float d) { return SetEaseInStart(d); }

    STDMETHOD(get_EaseOut)(float * pd) { return GetEaseOut(pd); }
    STDMETHOD(put_EaseOut)(float d) { return SetEaseOut(d); }

    STDMETHOD(get_EaseOutEnd)(float * pd) { return GetEaseOutEnd(pd); }
    STDMETHOD(put_EaseOutEnd)(float d) { return SetEaseOutEnd(d); }

    HRESULT Error();
    
    bool SetTrack(CDALTrack * parent);
    void ClearTrack(CDALTrack * parent);

#if _DEBUG
    virtual void Print(int spaces);
#endif

    STDMETHOD(GetTypeInfoCount)(UINT* pctinfo)
    {*pctinfo = 1; return S_OK;}

    STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
    { return IDispatchImpl<IDALImportBehavior,
                           &IID_IDALImportBehavior,
                           &LIBID_DirectAnimationTxD>::GetTypeInfo(itinfo, lcid, pptinfo); }

    STDMETHOD(GetIDsOfNames)(REFIID riid, LPOLESTR* rgszNames, UINT cNames,
                             LCID lcid, DISPID* rgdispid)
    { return IDispatchImpl<IDALImportBehavior,
                           &IID_IDALImportBehavior,
                           &LIBID_DirectAnimationTxD>::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);}

    STDMETHOD(Invoke)(DISPID dispidMember, REFIID riid,
                      LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,
                      EXCEPINFO* pexcepinfo, UINT* puArgErr)
    { return IDispatchImpl<IDALImportBehavior,
                           &IID_IDALImportBehavior,
                           &LIBID_DirectAnimationTxD>::Invoke(dispidMember, riid, lcid,
                                                              wFlags, pdispparams, pvarResult,
                                                              pexcepinfo, puArgErr); }
  protected:
    CRPtr<CRNumber> m_durationBvr;
    CRPtr<CREvent> m_completionEvent;
    CRPtr<CRBvr> m_importbvr;
    CRPtr<CRBvr> m_prebvr;
    CRPtr<CRBvr> m_postbvr;
    long m_importid;

    CRSTDAPICB_(CRBvrPtr) Notify(CRBvrPtr eventData,
                                 CRBvrPtr curRunningBvr,
                                 CRViewPtr curView);

    virtual bool IsContinuousMediaBvr() { return true; }
};


#endif /* _IMPORTBVR_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\dalite\src\seq.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"
#include "seq.h"

DeclareTag(tagSequence, "API", "CDALSequenceBehavior methods");

CDALSequenceBehavior::CDALSequenceBehavior()
{
    TraceTag((tagSequence,
              "CDALSequenceBehavior(%lx)::CDALSequenceBehavior()",
              this));
}

CDALSequenceBehavior::~CDALSequenceBehavior()
{
    TraceTag((tagSequence,
              "CDALSequenceBehavior(%lx)::~CDALSequenceBehavior()",
              this));

    for (BvrList::iterator i = m_list.begin();
         i != m_list.end();
         i++)
        (*i)->Release();
}

HRESULT
CDALSequenceBehavior::Init(long id, long len, IUnknown **bvrArray)
{
    TraceTag((tagSequence,
              "CDALSequenceBehavior(%lx)::Init(%ld, %ld, %lx)",
              this,
              id,
              len,
              bvrArray));
    
    m_id = id;
    m_duration = 0;
    
    if (!bvrArray || len <= 0) return E_INVALIDARG;
    
    for (int i = 0;i < len;i++) {
        CDALBehavior * bvr = ::GetBvr(bvrArray[i]);

        if (bvr == NULL)
            return CRGetLastError();

        bvr->AddRef();
        bvr->SetParent(this);
        m_list.push_back(bvr);

        if (m_duration != HUGE_VAL) {
            double d = bvr->GetTotalDuration();
        
            if (d == HUGE_VAL) {
                m_duration = HUGE_VAL;
            } else {
                m_duration +=  d;
            }
        }

        // As soon as we have a valid bvr generate the modifiable
        // version
        
        if (!m_bvr) {
            CRLockGrabber __gclg;
            m_bvr = CRModifiableBvr(bvr->GetBvr(),0);

            if (!m_bvr)
                return CRGetLastError();

            m_typeId = CRGetTypeId(m_bvr);
    
            Assert(m_typeId != CRUNKNOWN_TYPEID &&
                   m_typeId != CRINVALID_TYPEID);
        }
    }

    UpdateTotalDuration();
    
    return S_OK;
}

CRBvrPtr
CDALSequenceBehavior::Start()
{
    TraceTag((tagSequence,
              "CDALSequenceBehavior(%lx)::Start()",
              this));

    // Do not need to get GC lock since we assume the caller already
    // has
    
    CRBvrPtr newBvr = NULL;
    BvrList::iterator i;
    
    if (IsStarted()) {
        CRSetLastError(E_FAIL, NULL);
        goto done;
    }

    // Make sure we calculate the ease in/out coeff
    
    CalculateEaseCoeff();

    CRBvrPtr curbvr;
    curbvr = NULL;
    
    for (i = m_list.begin();
         i != m_list.end();
         i++) {

        CRBvrPtr c;

        if ((c = (*i)->Start()) == NULL)
            goto done;

        if (curbvr == NULL) {
            curbvr = c;
        } else {
            if ((curbvr = CRSequence(curbvr, c)) == NULL)
                goto done;
        }

        Assert (curbvr);

        double curdur;
        curdur = (*i)->GetTotalDuration();

        // See if this was an infinite duration (repeatforever)
        // If so then forget about the rest
        if (curdur == HUGE_VAL) {
            // This means that my duration is also infinite
            Assert(m_duration == HUGE_VAL);
            break;
        }
    }

    CRNumberPtr timeSub;
    CRBooleanPtr cond;

    if (m_bNeedEase) {
        CRNumberPtr time;

        if ((time = EaseTime(CRLocalTime())) == NULL ||
            (curbvr = CRSubstituteTime(curbvr, time)) == NULL)
            goto done;
    }

    // We cannot bounce an infinite sequence so just skip it
    
    if (m_bBounce && m_duration != HUGE_VAL) {
        CRNumberPtr zeroTime;
        CRNumberPtr durationTime;
        CRNumberPtr totalTime;

        if ((zeroTime = CRCreateNumber(0)) == NULL ||
            (totalTime = CRCreateNumber(m_repduration)) == NULL ||
            (durationTime = CRCreateNumber(m_duration)) == NULL ||

            (timeSub = CRSub(totalTime, CRLocalTime())) == NULL ||
            (cond = CRLTE(timeSub, zeroTime)) == NULL ||
            (timeSub = (CRNumberPtr) CRCond(cond,
                                            (CRBvrPtr) zeroTime,
                                            (CRBvrPtr) timeSub)) == NULL ||

            (cond = CRGTE(CRLocalTime(),durationTime)) == NULL ||
            (timeSub = (CRNumberPtr) CRCond(cond,
                                            (CRBvrPtr) timeSub,
                                            (CRBvrPtr) CRLocalTime())) == NULL ||
            (curbvr = CRSubstituteTime(curbvr, timeSub)) == NULL)

            goto done;
    }

    if (m_duration != HUGE_VAL) {
        if ((curbvr = CRDuration(curbvr, m_repduration)) == NULL)
            goto done;
    }
    
    if (m_repeat != 1) {
        if (m_repeat == 0) {
            curbvr = CRRepeatForever(curbvr);
        } else {
            curbvr = CRRepeat(curbvr, m_repeat);
        }

        if (curbvr == NULL)
            goto done;
    }

    // We have a total time so add another duration node
    if (m_totaltime != -1) {
        if ((curbvr = CRDuration(curbvr, m_totaltime)) == NULL)
            goto done;
    }
    
    // indicate success
    newBvr = curbvr;
    
  done:
    return newBvr;
}

bool
CDALSequenceBehavior::_ProcessCB(CallBackList & l,
                                 double gTime,
                                 double lastTick,
                                 double curTime,
                                 bool bForward,
                                 bool bFirstTick,
                                 bool bNeedPlay,
                                 bool bNeedsReverse)
{
    TraceTag((tagSequence,
              "CDALSequenceBehavior(%lx)::_ProcessCB(%g, %g, %g, %d, %d, %d, %d)",
              this,
              gTime,
              lastTick,
              curTime,
              bForward,
              bFirstTick,
              bNeedPlay,
              bNeedsReverse));
    
    // If we need to reverse then invert which direct to process our
    // children and invert times for the current frame not our total
    // duration
    
    if (bNeedsReverse) {
        // Our caller should ensure that they do not call me to
        // reverse myself if I am infinite
        Assert(m_duration != HUGE_VAL);
        
        lastTick = m_duration - lastTick;
        curTime = m_duration - curTime;
        
        bForward = !bForward;
    }
    
    if (bForward) {
        // Do the quick and dirty solution - just call all our
        // children
        // TODO: Optimize to not call children we know don't need to
        // be
        
        double d = 0;
        
        for (BvrList::iterator i = m_list.begin();
             i != m_list.end();
             i++) {
            
            (*i)->ProcessCB(l,
                            gTime + d,
                            EaseTime(lastTick - d),
                            EaseTime(curTime - d),
                            true,
                            bFirstTick,
                            bNeedPlay);

            d += (*i)->GetTotalDuration();
            Assert(d <= m_duration);
        }
        
    } else {
        // Need to do it in the reverse order
        
        // Do the quick and dirty solution - just call all our
        // children
        // TODO: Optimize to not call children we know don't need to
        // be
        
        if (m_duration == HUGE_VAL)
        {
            double d = 0;
            
            BvrList::iterator i = m_list.begin();

            while (i != m_list.end() &&
                   ((*i)->GetTotalDuration() != HUGE_VAL))
            {
                d += (*i)->GetTotalDuration();
                i++;
            }

            // For a sequence we can only have an infinite duration of
            // one of our children did
            
            Assert((*i)->GetTotalDuration() == HUGE_VAL);
            
            while (1)
            {
                Assert(d >= 0);
                
                (*i)->ProcessCB(l,
                                gTime - d,
                                EaseTime(lastTick - d),
                                EaseTime(curTime - d),
                                false,
                                bFirstTick,
                                bNeedPlay);

                if (i == m_list.begin())
                    break;

                i--;
                d -= (*i)->GetTotalDuration();
            }
        }
        else
        {
            double d = m_duration;
            
            for (BvrList::reverse_iterator i = m_list.rbegin();
                 i != m_list.rend();
                 i++) {
                
                Assert((*i)->GetTotalDuration() != HUGE_VAL);
                
                d -= (*i)->GetTotalDuration();
                
                Assert(d >= 0);
                
                (*i)->ProcessCB(l,
                                gTime - d,
                                EaseTime(lastTick - d),
                                EaseTime(curTime - d),
                                false,
                                bFirstTick,
                                bNeedPlay);
            }
        }
    }
    
    return true;
}

bool
CDALSequenceBehavior::_ProcessEvent(CallBackList & l,
                                    double gTime,
                                    double time,
                                    bool bFirstTick,
                                    DAL_EVENT_TYPE et,
                                    bool bNeedsReverse)
{
    TraceTag((tagSequence,
              "CDALSequenceBehavior(%lx)::_ProcessEvent(%g, %g, %d, %s, %d)",
              this,
              gTime,
              time,
              bFirstTick,
              EventString(et),
              bNeedsReverse));
    
    // If we need to reverse then invert which direct to process our
    // children and invert times for the current frame not our total
    // duration
    
    if (bNeedsReverse) {
        // Our caller should ensure that they do not call me to
        // reverse myself if I am infinite
        Assert(m_duration != HUGE_VAL);
        
        time = m_duration - time;
    }
    
    double d = 0;
        
    for (BvrList::iterator i = m_list.begin();
         i != m_list.end() && d <= time;
         i++) {
        
        (*i)->ProcessEvent(l,
                           gTime,
                           EaseTime(time - d),
                           bFirstTick,
                           et);
        
        d += (*i)->GetTotalDuration();
        Assert(d <= m_duration);
    }
        
    return true;
}

void
CDALSequenceBehavior::Invalidate()
{
    TraceTag((tagSequence,
              "CDALSequenceBehavior(%lx)::Invalidate()",
              this));
    
    UpdateDuration();
    CDALBehavior::Invalidate();
}

void
CDALSequenceBehavior::UpdateDuration()
{
    TraceTag((tagSequence,
              "CDALSequenceBehavior(%lx)::UpdateDuration()",
              this));

    m_duration = 0;

    for (BvrList::iterator i = m_list.begin();
         i != m_list.end();
         i++) {

        double d = (*i)->GetTotalDuration();
        
        if (d == HUGE_VAL) {
            m_duration = HUGE_VAL;
            break;
        } else {
            m_duration +=  d;
        }
    }
}

bool
CDALSequenceBehavior::SetTrack(CDALTrack * parent)
{
    if (!CDALBehavior::SetTrack(parent)) return false;

    for (BvrList::iterator i = m_list.begin();
         i != m_list.end();
         i++) {
        if (!(*i)->SetTrack(parent))
            return false;
    }

    return true;
}

void
CDALSequenceBehavior::ClearTrack(CDALTrack * parent)
{
    CDALBehavior::ClearTrack(parent);

    for (BvrList::iterator i = m_list.begin();
         i != m_list.end();
         i++) {
        (*i)->ClearTrack(parent);
    }
}

HRESULT
CDALSequenceBehavior::Error()
{
    LPCWSTR str = CRGetLastErrorString();
    HRESULT hr = CRGetLastError();
    
    TraceTag((tagError,
              "CDALSequenceBehavior(%lx)::Error(%hr,%ls)",
              this,
              hr,
              str?str:L"NULL"));

    if (str)
        return CComCoClass<CDALSequenceBehavior, &__uuidof(CDALSequenceBehavior)>::Error(str, IID_IDALSequenceBehavior, hr);
    else
        return hr;
}

#if _DEBUG
void
CDALSequenceBehavior::Print(int spaces)
{
    char buf[1024];

    sprintf(buf, "%*s{id = %#x, dur = %g, tt = %g, rep = %d, bounce = %d\r\n",
            spaces,"",
            m_id, m_duration, m_totaltime, m_repeat, m_bBounce);

    OutputDebugString(buf);

    for (BvrList::iterator i = m_list.begin();
         i != m_list.end();
         i++) {
        (*i)->Print(spaces + 2);
    }

    sprintf(buf, "%*s}\r\n",
            spaces,"");

    OutputDebugString(buf);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\dalite\src\singlebvr.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _SINGLEBVR_H
#define _SINGLEBVR_H

#include "bvr.h"

class
__declspec(uuid("D2A88CBB-C16D-11d1-A4E0-00C04FC29D46")) 
ATL_NO_VTABLE CDALSingleBehavior
    : public CDALBehavior,
      public CComCoClass<CDALSingleBehavior, &__uuidof(CDALSingleBehavior)>,
      public IDispatchImpl<IDALSingleBehavior, &IID_IDALSingleBehavior, &LIBID_DirectAnimationTxD>,
      public IObjectSafetyImpl<CDALSingleBehavior>,
      public ISupportErrorInfoImpl<&IID_IDALSingleBehavior>
{
  public:
    CDALSingleBehavior();
    ~CDALSingleBehavior();

    HRESULT Init(long id, double duration, IDABehavior * bvr);
    
#if _DEBUG
    virtual const char * GetName() { return "CDALSingleBehavior"; }
#endif

    BEGIN_COM_MAP(CDALSingleBehavior)
        COM_INTERFACE_ENTRY2(IDispatch, IDALSingleBehavior)
        COM_INTERFACE_ENTRY(IDALSingleBehavior)
        COM_INTERFACE_ENTRY2(IDALBehavior, IDALSingleBehavior)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY_IMPL(IObjectSafety)
    END_COM_MAP();

    STDMETHOD(get_ID)(long * pid) { return GetID(pid); }
    STDMETHOD(put_ID)(long id) { return SetID(id); }
        
    STDMETHOD(get_Duration)(double * pd) { return GetDuration(pd); }
    STDMETHOD(put_Duration)(double d) { return SetDuration(d); }
        
    STDMETHOD(get_Repeat)(long * pr) { return GetRepeat(pr); }
    STDMETHOD(put_Repeat)(long r) { return SetRepeat(r); }
       
    STDMETHOD(get_Bounce)(VARIANT_BOOL * pr) { return GetBounce(pr); }
    STDMETHOD(put_Bounce)(VARIANT_BOOL r) { return SetBounce(r); }
        
    STDMETHOD(get_EventCB)(IDALEventCB ** ev) { return GetEventCB(ev); }
    STDMETHOD(put_EventCB)(IDALEventCB * ev) { return SetEventCB(ev); }
        
    STDMETHOD(get_TotalTime)(double * pd) { return GetTotalTime(pd); }
    STDMETHOD(put_TotalTime)(double d) { return SetTotalTime(d); }
        
    STDMETHOD(get_EaseIn)(float * pd) { return GetEaseIn(pd); }
    STDMETHOD(put_EaseIn)(float d) { return SetEaseIn(d); }

    STDMETHOD(get_EaseInStart)(float * pd) { return GetEaseInStart(pd); }
    STDMETHOD(put_EaseInStart)(float d) { return SetEaseInStart(d); }

    STDMETHOD(get_EaseOut)(float * pd) { return GetEaseOut(pd); }
    STDMETHOD(put_EaseOut)(float d) { return SetEaseOut(d); }

    STDMETHOD(get_EaseOutEnd)(float * pd) { return GetEaseOutEnd(pd); }
    STDMETHOD(put_EaseOutEnd)(float d) { return SetEaseOutEnd(d); }

    STDMETHOD(get_DABehavior)(IDABehavior **);
    STDMETHOD(put_DABehavior)(IDABehavior *);

    STDMETHOD(GetDABehavior)(REFIID riid, void **);

    HRESULT Error();
    
#if _DEBUG
    virtual void Print(int spaces);
#endif

    STDMETHOD(GetTypeInfoCount)(UINT* pctinfo)
    {*pctinfo = 1; return S_OK;}

    STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
    { return IDispatchImpl<IDALSingleBehavior,
                           &IID_IDALSingleBehavior,
                           &LIBID_DirectAnimationTxD>::GetTypeInfo(itinfo, lcid, pptinfo); }

    STDMETHOD(GetIDsOfNames)(REFIID riid, LPOLESTR* rgszNames, UINT cNames,
                             LCID lcid, DISPID* rgdispid)
    { return IDispatchImpl<IDALSingleBehavior,
                           &IID_IDALSingleBehavior,
                           &LIBID_DirectAnimationTxD>::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);}

    STDMETHOD(Invoke)(DISPID dispidMember, REFIID riid,
                      LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,
                      EXCEPINFO* pexcepinfo, UINT* puArgErr)
    { return IDispatchImpl<IDALSingleBehavior,
                           &IID_IDALSingleBehavior,
                           &LIBID_DirectAnimationTxD>::Invoke(dispidMember, riid, lcid,
                                                               wFlags, pdispparams, pvarResult,
                                                               pexcepinfo, puArgErr); }
};


#endif /* _SINGLEBVR_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\dalite\src\track.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/

// Suppress new warning about NEW without corresponding DELETE 
// We expect GCs to cleanup values.  Since this could be a useful
// warning, we should disable this on a file by file basis.
#pragma warning(disable:4291)

#include "headers.h"
#include "bvr.h"
#include "track.h"

DeclareTag(tagTrack, "API", "CDALTrack methods");
DeclareTag(tagDetailNotify, "API", "Detailed notify");

CDALTrack::CDALTrack()
: m_state(DAL_STOPPED_STATE),
  m_bForward(true),
  m_bNeedsUpdate(true),
  m_firstTick(true),
  m_curGlobalTime(0.0),
  m_ignoreCB(0),
  m_cimports(0)
{
}

CDALTrack::~CDALTrack()
{
    // Ensure the track will not try to call us since we are going away

    m_trackhook->SetTrack(NULL);

    _Stop(m_curGlobalTime, m_curTick);

    if (m_dalbvr) m_dalbvr->ClearTrack(this);

    Assert(!IsPendingImports());

    // Just to be safe
    ClearPendingImports();
}

HRESULT
CDALTrack::Init(IDALBehavior * bvr)
{
    if (!bvr) return E_INVALIDARG;

    CDALBehavior * cbvr = GetBvr(bvr);
    
    if (!cbvr) return E_INVALIDARG;

    m_dalbvr = cbvr;
    
    if (!m_dalbvr->SetTrack(this))
    {
        TraceTag((tagError,
                  "CDALTrack(%lx)::Init: Failed to set track on behavior in.",
                  this));
                  
        return E_FAIL;
    }
    
    m_trackhook = NEW TrackHook;

    if (!m_trackhook) return E_OUTOFMEMORY;
    
    {
        CRLockGrabber __gclg;
        m_modbvr = CRModifiableBvr(m_dalbvr->GetBvr(), 0);

        if (!m_modbvr)
            return CRGetLastError();

        CRNumberPtr ts;
        
        if (!(m_timeSub = CRModifiableNumber(0.0)))

            return CRGetLastError();
        
        // Place us in a stopped state
        if (!_Start(0, 0) || !_Stop(0, 0))
            return CRGetLastError();
    }

    return S_OK;
}

STDMETHODIMP
CDALTrack::get_Behavior(IDALBehavior ** dalbvr)
{
    CHECK_RETURN_SET_NULL(dalbvr);

    Assert (m_dalbvr);
    
    return m_dalbvr->QueryInterface(IID_IDALBehavior,
                                    (void **) dalbvr);
}

STDMETHODIMP
CDALTrack::put_Behavior(IDALBehavior * dalbvr)
{
    bool ok = false;

    if (IsStarted()) {
        CRSetLastError(E_FAIL, NULL);
        goto done;
    }
    
    if (!dalbvr) {
        CRSetLastError(E_INVALIDARG, NULL);
        goto done;
    }

    CDALBehavior * cbvr;

    cbvr = GetBvr(dalbvr);
    
    if (!cbvr)
        goto done;

    {
        CRLockGrabber __gclg;
        ok = CRSwitchTo(m_modbvr, cbvr->GetBvr(), false, 0, 0);
    }
    
    if (!cbvr->SetTrack(this)) {
        cbvr->ClearTrack(this);
        goto done;
    }

  done:
    if (!ok)
        return Error();

    m_dalbvr->ClearTrack(this);

    Assert(!IsPendingImports());

    // Just to be safe
    ClearPendingImports();

    m_dalbvr = cbvr;

    m_bNeedsUpdate = true;
    
    return S_OK;
}
        
STDMETHODIMP
CDALTrack::GetCurrentValueEx(REFIID riid,
                             void **ppResult)
{
    CHECK_RETURN_SET_NULL(ppResult);
    
    bool ok = false;

    DisableCB(); // Make sure we ignore callbacks
    
    CRLockGrabber __gclg;

    if (!m_dabvr) {
        CRSetLastError(E_FAIL, NULL);
        goto done;
    }

    CRBvrPtr val;

    // If we have not ticked yet then use the non-runonced version and
    // use local time
    // Otherwise use the runonce behavior and the global time

    if (m_firstTick) {
        if ((val = CRSampleAtLocalTime(m_dabvr,
                                       0)) == NULL)
            goto done;
    
    } else {
        if ((val = CRSampleAtLocalTime(m_dabvr_runonce,
                                       m_curGlobalTime)) == NULL)
            goto done;
    }
    
    // This needs to be last so the ppResult is NULL on failure
    
    ok = CRBvrToCOM(val, riid, ppResult);
    
  done:
    EnableCB(); // Reenable callbacks

    return ok?S_OK:Error();
}


STDMETHODIMP
CDALTrack::get_TrackState(DAL_TRACK_STATE * pstate)
{
    CHECK_RETURN_NULL(pstate);
    
    *pstate = m_state;

    return S_OK;
}


STDMETHODIMP
CDALTrack::get_DABehavior(IDABehavior ** ppbvr)
{
    return GetDABehavior(IID_IDABehavior,
                         (void **)ppbvr);
}

STDMETHODIMP
CDALTrack::GetDABehavior(REFIID riid, void ** ppbvr)
{
    CHECK_RETURN_SET_NULL(ppbvr);
    
    Assert(m_modbvr);
    
    if (!CRBvrToCOM(m_modbvr,
                    riid,
                    ppbvr))
        return Error();

    return S_OK;
}

STDMETHODIMP
CDALTrack::get_CurrentTime(double * d)
{
    CHECK_RETURN_NULL(d);

    *d = m_curTick;

    return S_OK;
}

STDMETHODIMP
CDALTrack::get_CurrentGlobalTime(double * d)
{
    CHECK_RETURN_NULL(d);

    *d = m_curGlobalTime;

    return S_OK;
}

STDMETHODIMP
CDALTrack::SetPosition(double gTime, double lTime)
{
    TraceTag((tagTrack,
              "CDALTrack(%lx)::SetPosition(%g, %g)",
              this,
              gTime,
              lTime));

    if (IsStarted())
    {
        TraceTag((tagError,
                  "CDALTrack(%lx)::SetPosition: Behavior already started.",
                  this));

        return E_FAIL;
    }

    // Place us in a stopped state
    if (!_Start(gTime, lTime) || !_Stop(gTime, lTime))
        return Error();
    
    return S_OK;
}

STDMETHODIMP
CDALTrack::SetDirection(VARIANT_BOOL bForward)
{
    TraceTag((tagTrack,
              "CDALTrack(%lx)::SetDirection(%d)",
              this,
              bForward));

    if (IsStarted())
    {
        TraceTag((tagError,
                  "CDALTrack(%lx)::SetDirection: Behavior already started.",
                  this));

        return E_FAIL;
    }

    m_bForward = bForward?true:false;
    return S_OK;
}


STDMETHODIMP
CDALTrack::Play(double gTime, double lTime)
{
    TraceTag((tagTrack,
              "CDALTrack(%lx)::Play(%g, %g)",
              this,
              gTime,
              lTime));

    bool ok = false;
    CallBackList l;

    if (IsPendingImports()) {
        CRSetLastError(E_PENDING, NULL);
        goto done;
    }
        
    if (!IsStopped()) {
        CRSetLastError(E_FAIL, NULL);
        goto done;
    }
        
    if (!_Start(gTime, lTime) ||
        !ProcessEvent(l, gTime, lTime, DAL_PLAY_EVENT) ||
        !ProcessCBList(l))
        goto done;

    ok = true;
  done:
    return ok?S_OK:Error();
}

STDMETHODIMP
CDALTrack::Stop(double gTime, double lTime)
{
    TraceTag((tagTrack,
              "CDALTrack(%lx)::Stop(%g, %g)",
              this,
              gTime,
              lTime));

    bool ok = false;
    CallBackList l;

    if (IsStopped()) {
        ok = true;
        goto done;
    } else if (IsPaused()) {
        if (m_curTick != lTime) {
            TraceTag((tagError,
                      "CDALTrack(%lx)::Stop - Invalid ltime - ltime - %g, m_curTick - %g",
                      this,
                      lTime,
                      m_curTick));

            lTime = m_curTick;
        }
    } else {
        if (m_bForward) {
            if (lTime < m_curTick) {
                TraceTag((tagError,
                          "CDALTrack(%lx)::Stop - Invalid ltime - ltime - %g, m_curTick - %g",
                          this,
                          lTime,
                          m_curTick));

                lTime = m_curTick;
            }
        } else {
            if (lTime > m_curTick) {
                TraceTag((tagError,
                          "CDALTrack(%lx)::Stop - Invalid ltime - ltime - %g, m_curTick - %g",
                          this,
                          lTime,
                          m_curTick));

                lTime = m_curTick;
            }
        }
    }
    
    if (!_Stop(gTime, lTime) ||
        !ProcessCB(l,
                   gTime,
                   lTime) ||
        !ProcessEvent(l, gTime, lTime, DAL_STOP_EVENT) ||
        !ProcessCBList(l))
        goto done;
    
    ok = true;
  done:
    return ok?S_OK:Error();
}

STDMETHODIMP
CDALTrack::Pause(double gTime, double lTime)
{
    TraceTag((tagTrack,
              "CDALTrack(%lx)::Pause(%g, %g)",
              this,
              gTime,
              lTime));

    bool ok = false;
    CallBackList l;

    if (IsPendingImports()) {
        CRSetLastError(E_PENDING, NULL);
        goto done;
    }
        
    if (IsPaused()) {
        ok = true;
        goto done;
    }
    
    if (IsStopped()) {
        if (FAILED(Play(gTime, lTime)))
            goto done;
    }
    
    Assert(IsPlaying());
        
    if (m_bForward) {
        if (lTime < m_curTick) {
            TraceTag((tagError,
                      "CDALTrack(%lx)::Pause - Invalid ltime - ltime - %g, m_curTick - %g",
                      this,
                      lTime,
                      m_curTick));

            CRSetLastError(E_INVALIDARG, NULL);
            goto done;
        }
    } else {
        if (lTime > m_curTick) {
            TraceTag((tagError,
                      "CDALTrack(%lx)::Pause - Invalid ltime - ltime - %g, m_curTick - %g",
                      this,
                      lTime,
                      m_curTick));

            CRSetLastError(E_INVALIDARG, NULL);
            goto done;
        }
    }
        
    if (!_Pause(gTime, lTime) ||
        !ProcessCB(l,
                   gTime,
                   lTime) ||
        !ProcessEvent(l, gTime, lTime, DAL_PAUSE_EVENT) ||
        !ProcessCBList(l))
        goto done;
    
    ok = true;
  done:
    return ok?S_OK:Error();
}

STDMETHODIMP
CDALTrack::Resume(double gTime, double lTime)
{
    TraceTag((tagTrack,
              "CDALTrack(%lx)::Resume(%g, %g)",
              this,
              gTime,
              lTime));

    bool ok = false;
    CallBackList l;

    if (IsPendingImports()) {
        CRSetLastError(E_PENDING, NULL);
        goto done;
    }
        
    if (IsPlaying()) {
        ok = true;
        goto done;
    } else if (IsStopped()) {
        if (FAILED(Play(gTime, lTime)))
            goto done;
    } else {
        Assert(IsPaused());

        if (lTime != m_curTick) {
            TraceTag((tagError,
                      "CDALTrack(%lx)::Resume - Invalid ltime - ltime - %g, m_curTick - %g",
                      this,
                      lTime,
                      m_curTick));

            CRSetLastError(E_INVALIDARG, NULL);
            goto done;
        }
    }
    
    Assert(lTime == m_curTick);
    
    if (!_Resume(gTime, lTime) ||
        !ProcessCB(l,
                   gTime,
                   lTime) ||
        !ProcessEvent(l, gTime, lTime, DAL_RESUME_EVENT) ||
        !ProcessCBList(l))
        goto done;
    
    ok = true;
  done:
    return ok?S_OK:Error();
}

bool
CDALTrack::_Start(double gTime, double lTime)
{
    bool ok = false;
    
    CRLockGrabber __gclg;
    
    if (!UpdateBvr())
        goto done;

    TraceTag((tagError,
              "Track(%#x)::_Start(%g, %g)",
              this,
              gTime,
              lTime));

    CRBvrPtr bvr;

    bvr = m_dabasebvr;
    
    if (IsPendingImports()) {
        Assert(m_daarraybvr);

        CRTuplePtr tuple;
        CRBvrPtr arr[] = { bvr, (CRBvrPtr) m_daarraybvr.p };
        
        if ((tuple = (CRCreateTuple(ARRAY_SIZE(arr), arr))) == NULL ||
            (bvr = CRNth(tuple, 0)) == NULL)
            goto done;
    }
    
    if ((m_dabvr = CRSubstituteTime(bvr, m_timeSub)) == NULL ||
        (m_dabvr_runonce = CRRunOnce(m_dabvr)) == NULL ||
        !CRSwitchTo(m_modbvr, m_dabvr_runonce, true, CRSwitchAtTime, gTime) ||
        !SetTimeSub(lTime, false, gTime))
        goto done;

    m_state = DAL_PLAYING_STATE;
    m_curTick = lTime;
    m_firstTick = true;
    m_curGlobalTime = gTime;
    m_trackhook->SetTrack(this);
    
    ok = true;
  done:
    if (!ok) {
        _Stop(gTime, lTime);
    }

    return ok;
}


bool
CDALTrack::UpdateBvr()
{
    bool ok = false;
    
#if _DEBUG
    TraceTag((tagError,
              "Track(%#x)",
              this));
    m_dalbvr->Print(2);
#endif

    if (m_bNeedsUpdate) {
        CRBvrPtr baseBvr;

        if ((baseBvr = m_dalbvr->Start()) == NULL ||
            (baseBvr = CRHook(baseBvr, m_trackhook)) == NULL)
            goto done;
        
        CRBooleanPtr cond;
        CRNumberPtr zeroTime;
        CRNumberPtr timeSub;
        
        if ((zeroTime = CRCreateNumber(0)) == NULL ||
            (cond = CRLTE(CRLocalTime(), zeroTime)) == NULL ||
            (timeSub = (CRNumberPtr) CRCond(cond,
                                            (CRBvrPtr) zeroTime,
                                            (CRBvrPtr) CRLocalTime())) == NULL)
            goto done;
        
        if (m_dalbvr->GetTotalDuration() != HUGE_VAL) {
            CRNumberPtr maxTime;
            
            if ((maxTime = CRCreateNumber(m_dalbvr->GetTotalDuration())) == NULL ||
                (cond = CRGTE(timeSub, maxTime)) == NULL ||
                (timeSub = (CRNumberPtr) CRCond(cond,
                                                (CRBvrPtr) maxTime,
                                                (CRBvrPtr) timeSub)) == NULL)
                goto done;
            
        }

        if ((baseBvr = CRSubstituteTime(baseBvr, timeSub)) == NULL)
            goto done;

        m_dabasebvr = baseBvr;
        m_bNeedsUpdate = false;
    }

    ok = true;

  done:
    return ok;
}

bool
CDALTrack::_Stop(double gTime, double lTime)
{
    bool ok = true;
    
    m_state = DAL_STOPPED_STATE;
    m_trackhook->SetTrack(NULL);
    
    {
        CRLockGrabber __gclg;
        
        if (!SetTimeSub(lTime, true, gTime))
            ok = false;
    }

  done:
    return ok;
}

bool
CDALTrack::_Pause(double gTime, double lTime)
{
    bool ok = false;
    
    {
        CRLockGrabber __gclg;
        
        if (!SetTimeSub(lTime, true, gTime))
            goto done;
    }
    
    m_state = DAL_PAUSED_STATE;
    
    ok = true;
  done:
    return ok;
}

bool
CDALTrack::_Resume(double gTime, double lTime)
{
    bool ok = false;
    
    {
        CRLockGrabber __gclg;
        
        if (!SetTimeSub(lTime, false, gTime))
            goto done;
    }
    
    m_state = DAL_PLAYING_STATE;
    
    ok = true;
  done:
    return ok;
}

bool
CDALTrack::SetTimeSub(double lTime, bool bPause, double gTime)
{
    bool ok = false;
    
    CRNumberPtr tc;
    
    if ((tc = CRCreateNumber(lTime)) == NULL)
        goto done;

    if (!bPause) {
        if (m_bForward) {
            if ((tc = CRAdd(tc, CRLocalTime())) == NULL)
                goto done;
        } else {
            if ((tc = CRSub(tc, CRLocalTime())) == NULL)
                goto done;
        }
    }
    
    if (!CRSwitchTo((CRBvrPtr) m_timeSub.p,
                    (CRBvrPtr) tc,
                    true,
                    CRSwitchAtTime,
                    gTime))
        goto done;

    ok = true;
  done:
    return ok;
}

HRESULT
CDALTrack::Error()
{
    LPCWSTR str = CRGetLastErrorString();
    HRESULT hr = CRGetLastError();
    
    if (str)
        return CComCoClass<CDALTrack, &__uuidof(CDALTrack)>::Error(str, IID_IDALTrack, hr);
    else
        return hr;
}

bool
CDALTrack::ProcessCB(CallBackList & l,
                     double gTime,
                     double lTime)
{
    TraceTag((tagTrack,
              "CDALTrack(%lx)::ProcessCB(%lx, %g, %g)",
              this,
              &l,
              gTime,
              lTime));

    TraceTag((tagDetailNotify,
              "ProcessCB(%lx): lTime - %g, gTime - %g, m_curTick - %g, m_curGlobalTime - %g, firsttick - %d",
              this,
              lTime,
              gTime,
              m_curTick,
              m_curGlobalTime,
              m_firstTick));
    
    if (lTime != m_curTick || m_firstTick) {
        // See if we are at the end
        bool bIsDone = ((m_bForward && lTime >= GetTotalDuration()) ||
                        (!m_bForward && lTime <= 0));

        double gTimeBase;

        // gTimeBase is the global time it would be at local time 0
        
        if (m_bForward) {
            if (bIsDone) {
                gTimeBase = m_curGlobalTime - m_curTick;
            } else {
                gTimeBase = gTime - lTime;
            }
        } else {
            if (bIsDone) {
                gTimeBase = m_curGlobalTime + m_curTick;
            } else {
                gTimeBase = gTime + lTime;
            }
        }
        
        m_dalbvr->ProcessCB(l,
                            gTimeBase,
                            m_curTick,
                            lTime,
                            m_bForward,
                            m_firstTick,
                            false);

        m_firstTick = false;
        m_curTick = lTime;

        if (bIsDone)
            _Stop(gTime, m_curTick);
    }
    
    // Take the greater of the two since we may have played this
    // behavior during tick but not have tick it yet in the graph.
    
    if (gTime > m_curGlobalTime)
        m_curGlobalTime = gTime;

    return true;
}

bool
CDALTrack::ProcessEvent(CallBackList &l,
                        double gTime,
                        double lTime,
                        DAL_EVENT_TYPE event)
{
    return m_dalbvr->ProcessEvent(l, gTime, lTime, m_firstTick, event);
}

bool
CDALTrack::ProcessCBList(CallBackList &l)
{
    bool ok = true;
    
    for (CallBackList::iterator i = l.begin();
         i != l.end();
         i++) {

        if (FAILED((*i)->CallEvent()))
            ok = false;

        delete (*i);
    }

    l.clear();

    if (!ok)
        CRSetLastError(E_FAIL, NULL);

    return ok;
}

void
CDALTrack::HookCallback(double gTime, double lTime)
{
    TraceTag((tagDetailNotify,
              "HookCallback(%lx): lTime - %g, gTime - %g, m_curTick - %g, m_curGlobalTime - %g, firsttick - %d\n",
              this,
              lTime,
              gTime,
              m_curTick,
              m_curGlobalTime,
              m_firstTick));
    
    if (IsPlaying() && !IsCBDisabled()) {
        CallBackList l;
            
        ProcessCB(l,
                  gTime,
                  lTime);

        ProcessCBList(l);
    }
}

long
CDALTrack::AddPendingImport(CRBvrPtr dabvr)
{
    // Assume the GC Lock is already acquired
    
    long id = -1;
    
    if (!m_daarraybvr) {
        if ((m_daarraybvr = CRCreateArray(1, &dabvr, CR_ARRAY_CHANGEABLE_FLAG)) == NULL)
            goto done;

        id = 0;
    } else {
        long index;
        
        if ((index = CRAddElement(m_daarraybvr, dabvr, 0)) == 0)
            goto done;

        id = index;
    }
    
    m_cimports++;
    
  done:
    return id;
}

void
CDALTrack::RemovePendingImport(long id)
{
    if (m_daarraybvr) {
        CRLockGrabber __gclg;
        bool ok = CRRemoveElement(m_daarraybvr, id);

        if (ok) {
            m_cimports--;
            if (m_cimports == 0)
                m_daarraybvr = NULL;
        }
    }
}

void
CDALTrack::ClearPendingImports()
{
    m_daarraybvr = NULL;
    m_cimports = 0;
}

// While this object is alive we need to keep the DLL from getting
// unloaded

// Start off with a zero refcount
CDALTrack::TrackHook::TrackHook()
: m_cRef(0),
  m_track(NULL)
{
}

CDALTrack::TrackHook::~TrackHook()
{
}

CRSTDAPICB_(CRBvrPtr)
CDALTrack::TrackHook::Notify(long id,
                             bool startingPerformance,
                             double startTime,
                             double gTime,
                             double lTime,
                             CRBvrPtr sampleVal,
                             CRBvrPtr curRunningBvr)
{
    if (m_track && !startingPerformance) {
#if _DEBUG
        if (m_track->IsPlaying()) {
            TraceTag((tagDetailNotify,
                      "Notify(%lx): id - %lx, lTime - %g, gTime - %g",
                      m_track,
                      id,
                      lTime,
                      gTime));
        }
#endif
        m_track->HookCallback(gTime, lTime);
    }
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\dalite\src\util.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"
#include <mshtml.h>

#define DISPID_GETSAFEARRAY -2700

#define IS_VARTYPE(x,vt) ((V_VT(x) & VT_TYPEMASK) == (vt))
#define IS_VARIANT(x) IS_VARTYPE(x,VT_VARIANT)
#define GET_VT(x) (V_VT(x) & VT_TYPEMASK)

SafeArrayAccessor::SafeArrayAccessor(VARIANT & v,
                                     bool canBeNull)
: _inited(false),
  _isVar(false),
  _s(NULL),
  _failed(true),
  _allocArr(NULL)
{
    HRESULT hr;
    VARIANT *pVar;

    // Check if it is a reference to another variant
    
    if (V_ISBYREF(&v) && !V_ISARRAY(&v) && IS_VARIANT(&v))
        pVar = V_VARIANTREF(&v);
    else
        pVar = &v;

    // Check for an array
    if (!V_ISARRAY(pVar)) {
        // For JSCRIPT
        // See if it is a IDispatch and see if we can get a safearray from
        // it
        if (!IS_VARTYPE(pVar,VT_DISPATCH)) {
            if (canBeNull && (IS_VARTYPE(pVar, VT_EMPTY) ||
                              IS_VARTYPE(pVar, VT_NULL))) {

                
                // if we allow empty, then just set the safearray
                // to null.
                _s = NULL;
                _v = NULL;
                _ubound = _lbound = 0;
                _inited = true;
                _failed = false;
                return;
            } else {
                CRSetLastError (DISP_E_TYPEMISMATCH,NULL);
                return;
            }
        }

        IDispatch * pdisp;
        
        if (V_ISBYREF(pVar))
            pdisp = *V_DISPATCHREF(pVar);
        else
            pdisp = V_DISPATCH(pVar);
    
        DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};
        
        // Need to pass in a VARIANT that we own and will free.  Use
        // the internal _retVar parameter
        
        hr = pdisp->Invoke(DISPID_GETSAFEARRAY,
                           IID_NULL,
                           LOCALE_USER_DEFAULT,
                           DISPATCH_METHOD|DISPATCH_PROPERTYGET,
                           &dispparamsNoArgs,
                           &_retVar, NULL, NULL);
        
        if (FAILED(hr)) {
            CRSetLastError (DISP_E_TYPEMISMATCH,NULL);
            return;
        }
        
        // No need to check for a reference since you cannot return
        // VARIANT references
        pVar = &_retVar;
        
        // Check for an array
        if (!V_ISARRAY(pVar)) {
            CRSetLastError (DISP_E_TYPEMISMATCH,NULL);
            return;
        }
    }
    
    // See if it is a variant
    
    if (IS_VARIANT(pVar))
        _isVar = true;
    else if (!IS_VARTYPE(pVar,VT_UNKNOWN) &&
             !IS_VARTYPE(pVar,VT_DISPATCH)) {
        CRSetLastError (DISP_E_TYPEMISMATCH,NULL);
        return;
    }

    if (V_ISBYREF(pVar))
        _s = *V_ARRAYREF(pVar);
    else
        _s = V_ARRAY(pVar);
    
    if (_s == NULL) {
        if (canBeNull) {
            _v = NULL;
            _ubound = _lbound = 0;
            _inited = true;
            _failed = false;
            return;
        } else {
            CRSetLastError (E_INVALIDARG,NULL);
            return;
        }
    }

    if (SafeArrayGetDim(_s) != 1) {
        CRSetLastError (E_INVALIDARG,NULL);
        return;
    }

    hr = SafeArrayGetLBound(_s,1,&_lbound);
        
    if (FAILED(hr)) {
        CRSetLastError (E_INVALIDARG,NULL);
        return;
    }
        
    hr = SafeArrayGetUBound(_s,1,&_ubound);
        
    if (FAILED(hr)) {
        CRSetLastError (E_INVALIDARG,NULL);
        return;
    }
        
    hr = SafeArrayAccessData(_s,(void **)&_v);

    if (FAILED(hr)) {
        CRSetLastError (E_INVALIDARG,NULL);
        return;
    }
        
    _inited = true;

    // If it is a variant see if they are objects or not

    if (_isVar) {
        int size = GetArraySize();
        
        if (size > 0) {
            // Check the first argument to see its type

            VARIANT * pVar = &_pVar[0];

            // Check if it is a reference to another variant
            
            if (V_ISBYREF(pVar) && !V_ISARRAY(pVar) && IS_VARIANT(pVar))
                pVar = V_VARIANTREF(pVar);

            // Check if it is an object
            if (!IS_VARTYPE(pVar,VT_UNKNOWN) &&
                !IS_VARTYPE(pVar,VT_DISPATCH)) {
                CRSetLastError (DISP_E_TYPEMISMATCH,NULL);
                return;
            }

            _allocArr = (IUnknown **) malloc(size * sizeof (IUnknown *));

            if (_allocArr == NULL) {
                CRSetLastError(E_OUTOFMEMORY, NULL);
                return;
            }

            for (int i = 0; i < size; i++) {
                CComVariant var;
                HRESULT hr = var.ChangeType(VT_UNKNOWN, &_pVar[i]);
                
                if (FAILED(hr)) {
                    CRSetLastError(DISP_E_TYPEMISMATCH,NULL);
                    return;
                }
                
                _allocArr[i] = var.punkVal;
            }
        }
    }

    _failed = false;
}

SafeArrayAccessor::~SafeArrayAccessor()
{
    if (_inited && _s)
        SafeArrayUnaccessData(_s);
}

#if 0
HRESULT
CallScript(IOleClientSite * pClient,
           LPWSTR fun,
           IDispatch * disp,
           DWORD dwData)
{
    DISPID dispid;
    DAComPtr<IOleContainer> pRoot;
    DAComPtr<IHTMLDocument> pHTMLDoc;
    DAComPtr<IDispatch> pDispatch;
    CRBvrPtr bvr = NULL;
    DAComPtr<IDABehavior> event;
    DAComPtr<IDABehavior> curBvr;
    CComVariant retVal;
    HRESULT hr = E_INVALIDARG;
        
    if (!pClient) goto done;
    
    {
        CComBSTR bstrfun(fun);
        
        if (FAILED(hr = pClient->GetContainer(&pRoot)) ||
            FAILED(hr = pRoot->QueryInterface(IID_IHTMLDocument, (void **)&pHTMLDoc)) ||
            FAILED(hr = pHTMLDoc->get_Script(&pDispatch)) ||
            FAILED(hr = pDispatch->GetIDsOfNames(IID_NULL, &bstrfun, 1,
                                                 LOCALE_USER_DEFAULT,
                                                 &dispid))) {
            goto done;
        }
    }

        
    // paramters needed to be pushed in reverse order
    VARIANT rgvarg[2];
    rgvarg[1].vt = VT_DISPATCH;
    rgvarg[1].pdispVal = disp;
    rgvarg[0].vt = VT_I4;
    rgvarg[0].lVal = dwData;
    
    DISPPARAMS dp;
    dp.cNamedArgs = 0;
    dp.rgdispidNamedArgs = 0;
    dp.cArgs = 2;
    dp.rgvarg = rgvarg;
    
    hr = pDispatch->Invoke(dispid, IID_NULL,
                           LOCALE_USER_DEFAULT, DISPATCH_METHOD,
                           &dp, &retVal, NULL, NULL);

    if (FAILED(hr)) {
        goto done;
    }

  done:
    return hr;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\dalite\src\track.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _TRACK_H
#define _TRACK_H

class
__declspec(uuid("D2A88CBA-C16D-11d1-A4E0-00C04FC29D46")) 
ATL_NO_VTABLE CDALTrack
    : public CComObjectRootEx<CComSingleThreadModel>,
      public CComCoClass<CDALTrack, &__uuidof(CDALTrack)>,
      public IDispatchImpl<IDALTrack, &IID_IDALTrack, &LIBID_DirectAnimationTxD>,
      public IObjectSafetyImpl<CDALTrack>,
      public ISupportErrorInfoImpl<&IID_IDALTrack>
{
  public:
    CDALTrack();
    ~CDALTrack();

    STDMETHOD_(ULONG,AddRef)(void) = 0;
    STDMETHOD_(ULONG,Release)(void) = 0;
    STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject) = 0;
    
    HRESULT Init(IDALBehavior * bvr);

#if _DEBUG
    const char * GetName() { return "CDALTrack"; }
#endif

    BEGIN_COM_MAP(CDALTrack)
        COM_INTERFACE_ENTRY(IDALTrack)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY_IMPL(IObjectSafety)
    END_COM_MAP();

    STDMETHOD(get_Behavior)(IDALBehavior **);
    STDMETHOD(put_Behavior)(IDALBehavior *);
        
    STDMETHOD(Play)(double gTime, double lTime);
    STDMETHOD(Stop)(double gTime, double lTime);
    STDMETHOD(Pause)(double gTime, double lTime);
    STDMETHOD(Resume)(double gTime, double lTime);
        
    STDMETHOD(SetPosition)(double gTime, double lTime);
    STDMETHOD(SetDirection)(VARIANT_BOOL bForward);
        
    STDMETHOD(GetCurrentValueEx)(REFIID riid,
                                 void **ppResult);
    
    STDMETHOD(get_CurrentValue)(IDABehavior **ppResult)
    { return GetCurrentValueEx(IID_IDABehavior, (void **) ppResult); }
    
    STDMETHOD(get_TrackState)(DAL_TRACK_STATE *);
        
    STDMETHOD(get_DABehavior)(IDABehavior **);

    STDMETHOD(GetDABehavior)(REFIID riid, void **);

    STDMETHOD(get_CurrentTime)(double * d);

    STDMETHOD(get_CurrentGlobalTime)(double * d);
    
    bool IsStopped() { return m_state == DAL_STOPPED_STATE; }
    bool IsStarted() { return m_state != DAL_STOPPED_STATE; }
    bool IsPlaying() { return m_state == DAL_PLAYING_STATE; }
    bool IsPaused() { return m_state == DAL_PAUSED_STATE; }

    void Invalidate() { m_bNeedsUpdate = true; }

    void HookCallback(double gTime, double lTime);

    double GetTotalDuration() { return m_dalbvr->GetTotalDuration(); }

    long AddPendingImport(CRBvrPtr dabvr);
    void RemovePendingImport(long id);
    void ClearPendingImports();
    bool IsPendingImports() { return m_cimports > 0; }
    
    double GetCurrentTime() { return m_curTick; }
    double GetCurrentGlobalTime() { return m_curGlobalTime; }
  protected:
    bool UpdateBvr();
    bool _Start(double gTime, double lTime);
    bool _Stop(double gTime, double lTime);
    bool _Pause(double gTime, double lTime);
    bool _Resume(double gTime, double lTime);

    bool ProcessEvent(CallBackList &l,
                      double gTime,
                      double lTime,
                      DAL_EVENT_TYPE event);
    
    bool ProcessCB(CallBackList & l,
                   double gTime,
                   double lTime);
    
    bool ProcessCBList(CallBackList &l);
    
    bool SetTimeSub(double lTime, bool bPause, double gTime);
    
    HRESULT Error();
    
    DAComPtr<CDALBehavior> m_dalbvr;
    DAL_TRACK_STATE m_state;
    double m_curTick;
    bool m_bForward;
    bool m_bNeedsUpdate;
    bool m_firstTick;
    double m_curGlobalTime;
    long m_ignoreCB;
    
    CRPtr<CRNumber> m_timeSub;
    CRPtr<CRBvr> m_dabvr;
    CRPtr<CRBvr> m_dabasebvr;
    CRPtr<CRBvr> m_dabvr_runonce;
    CRPtr<CRBvr> m_modbvr;
    CRPtr<CRArray> m_daarraybvr;

    int m_cimports;
    
    class TrackHook : public CRBvrHook
    {
      public:
        TrackHook();
        ~TrackHook();
        
        virtual CRSTDAPICB_(ULONG) AddRef() { m_cRef++; return m_cRef; }
        virtual CRSTDAPICB_(ULONG) Release() {
            long r = --m_cRef;

            if (r == 0)
                delete this;

            return r;
        }
        
        CRSTDAPICB_(CRBvrPtr) Notify(long id,
                                     bool startingPerformance,
                                     double startTime,
                                     double gTime,
                                     double lTime,
                                     CRBvrPtr sampleVal,
                                     CRBvrPtr curRunningBvr);

        void SetTrack(CDALTrack * t) { m_track = t; }

      protected:
        // We do not need a refcount since we are single threaded and
        // the track will NULL it out if it goes away

        CDALTrack * m_track;
        long m_cRef;
    };

    DAComPtr<TrackHook> m_trackhook;

    void DisableCB() { m_ignoreCB++; }
    void EnableCB() { m_ignoreCB--; Assert (m_ignoreCB >= 0); }

    bool IsCBDisabled() { return m_ignoreCB > 0; }
};

#endif /* _TRACK_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\purevirt.cpp ===
// purevirt.c
//
// Avoids use of C runtime.
//

#include "..\ihbase\precomp.h"

extern "C" int __cdecl _purecall(void)
{
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\common.inc ===
ROOT=$(DAXCTL_ROOT:\src\daxctl=)

!include $(ROOT)\common.inc

INCLUDES = \
    $(DAXCTL_ROOT)\inc; \
    $(DAXCTL_ROOT)\srcodl\$(O); \
    $(LM_INC_DIRS); \
    $(INCLUDES)

NOT_LEAN_AND_MEAN=1

#daxctl build is not currently setup properly to link with RTTI in debug build, so turn off this flag (setting /GR-)
!undef USE_RTTI

USE_STATIC_ATL=1

#
# !!! TRICKY !!!
#
# The DAXCTL's link against MMUTILSE.DLL to get their CRT for size reasons, so we must
# turn off any CRT link settings that might have been set by the master common.inc which
# was included at the top of this file. (PaulNash, 1/21/99)
#
USE_NOLIBS=1

# Turn off EH for the DAX components
!undef USE_NATIVE_EH

# Target Winnt 4.0/Win95/IE4

SUBSYSTEM_VERSION=4.00

WIN32_WINNT_VERSION=0x0400
WIN32_WIN95_VERSION=0x0400
WIN32_IE_VERSION=0x0400

SOURCES_USED=$(SOURCES_USED) $(DAXCTL_ROOT)\common.inc

#add -DUSELOGGING to see daxctl dbg output
#C_DEFINES=$(C_DEFINES) -DNT_BUILD -DUSELOGGING
C_DEFINES=$(C_DEFINES) -DNT_BUILD

#
# Turn off LIBCMT linking.
#
!undef USE_LIBCMT
!undef USE_MSVCRT

!if $(386)
DAX_EXTRACRTOBJS = $(DAXCTL_ROOT)\lib\$(TARGET_DIRECTORY)\ftol.obj

# add compiler support for inline MMX
USER_C_FLAGS = $(USER_C_FLAGS)  /GM
!endif

MMUTILS_LIB = $(SDKDIR)\mmutilse.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\dll.cpp ===
// dll.cpp
//
// DLL entry points etc.
//


#ifdef _DEBUG
    #pragma message("_DEBUG is defined")
#else
    #pragma message("_DEBUG isn't defined")
#endif

#ifdef _DESIGN
    #pragma message("_DESIGN is defined")
#else
    #pragma message("_DESIGN isn't defined")
#endif

#include "..\ihbase\precomp.h"
#include <locale.h>

#include <initguid.h> // once per build
#include <olectl.h>
#include <daxpress.h>
#include "..\mmctl\inc\ochelp.h"
#include "..\mmctl\inc\mmctlg.h"
#include "..\ihbase\debug.h"

#if defined(INCLUDESEQ) && defined(USE_OLD_SEQUENCER)
#include <itimer.iid>
#endif

// Pick up SGrfx headers
#include "sgrfx\sginit.h"
#include "sgrfx\sgrfx.h"

// Pick up Sprite headers
#include "sprite\sprinit.h"
#include "sprite\sprite.h"

// Pick up Path headers
#include "path\pathinit.h"
#include "path\pathctl.h"

#ifdef INCLUDESOUND
// Pick up Sound headers
#include "sound\sndinit.h"
#include "sound\sndctl.h"
#endif

// Pick up Sequencer headers
#ifdef INCLUDESEQ
#ifdef USE_OLD_SEQUENCER
#include "mmseq\seqinit.h"
#include "mmseq\seqctl.h"
#include "mmseq\seqmgr.h"
#else
#include "seq\seqinit.h"
#include "seq\seqctl.h"
#include "seq\seqmgr.h"
#endif

#ifndef USE_OLD_SEQUENCER
#define CACTION_CLASSDEF_ONLY
#include "seq\action.h"
#endif //!USE_OLD_SEQUENCER
#endif //INCLUDESEQ
//////////////////////////////////////////////////////////////////////////////
// globals
//

// general globals
#ifdef STATIC_OCHELP
extern HINSTANCE       g_hinst;        // DLL instance handle
#else
HINSTANCE       g_hinst = NULL;        // DLL instance handle
#endif

ULONG           g_cLock;        // DLL lock count
ControlInfo     g_ctlinfoSG, g_ctlinfoPath, g_ctlinfoSprite;

#ifdef INCLUDESOUND
ControlInfo     g_ctlinfoSound
#endif // INCLUDESOUND

#ifdef INCLUDESEQ
ControlInfo     g_ctlinfoSeq, g_ctlinfoSeqMgr;      // information about the control
#endif

#ifdef _DEBUG
BOOL			g_fLogDebugOutput; // Controls logging of debug info
#endif

extern "C" DWORD _fltused = (DWORD)(-1);

//////////////////////////////////////////////////////////////////////////////
// DLL Initialization
//

// TODO: Modify the data in this function appropriately


//////////////////////////////////////////////////////////////////////////////
// Standard DLL Entry Points
//

BOOL WINAPI DllMain(HINSTANCE hInst, DWORD dwReason,LPVOID lpreserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        TRACE("DAExpress controls DLL loaded\n"); //TODO: Modify me
        g_hinst = hInst;

#ifdef USE_IHOCHELPLIB
        InitializeStaticOCHelp(hInst);
#endif // USE_IHOCHELPLIB

#if defined(_DEBUG)
#if defined(USELOGGING)
    g_fLogDebugOutput = TRUE;
#else
    g_fLogDebugOutput = FALSE;
#endif
#endif // USELOGGING

        setlocale( LC_ALL, "" );
        DisableThreadLibraryCalls(hInst);
 
        InitSGrfxControlInfo(hInst, &g_ctlinfoSG, AllocSGControl);
        InitPathControlInfo(hInst, &g_ctlinfoPath, AllocPathControl);
#ifdef INCLUDESOUND
        InitSoundControlInfo(hInst, &g_ctlinfoSound, AllocSoundControl);
#endif // INCLUDESOUND
        InitSpriteControlInfo(hInst, &g_ctlinfoSprite, AllocSpriteControl);
#ifdef INCLUDESEQ
	InitSeqControlInfo(hInst, &g_ctlinfoSeq, AllocSeqControl);
	InitSeqMgrControlInfo(hInst, &g_ctlinfoSeqMgr, AllocSequencerManager);
#endif //INCLUDESEQ
        
        g_ctlinfoSG.pNext = &g_ctlinfoPath; 
#ifndef INCLUDESOUND
        g_ctlinfoPath.pNext = &g_ctlinfoSprite; 
#else
        g_ctlinfoPath.pNext = &g_ctlinfoSound; 
        g_ctlinfoSound.pNext = &g_ctlinfoSprite; 
#endif // INCLUDESOUND

#ifdef INCLUDESEQ
        g_ctlinfoSprite.pNext = &g_ctlinfoSeq;
	g_ctlinfoSeq.pNext = &g_ctlinfoSeqMgr;
	g_ctlinfoSeqMgr.pNext = NULL;
#else
	g_ctlinfoSprite.pNext = NULL;
#endif
    }
    else
    if (dwReason == DLL_PROCESS_DETACH)
    {
#ifdef USE_IHOCHELPLIB
        ::UninitializeStaticOCHelp();
#endif
        TRACE("DAExpress controls DLL unloaded\n"); //TODO: Modify me
    }

    return TRUE;
}


STDAPI DllRegisterServer(void)
{
    // Give it the first control and it uses the pNext member to register all controls
    return RegisterControls(&g_ctlinfoSG, RC_REGISTER);
}


STDAPI DllUnregisterServer(void)
{
    // Give it the first control and it uses the pNext member to unregister all controls
	return RegisterControls(&g_ctlinfoSG, RC_UNREGISTER);
}


STDAPI DllCanUnloadNow()
{
    return ((g_cLock == 0) ? S_OK : S_FALSE);
}

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppv)
{
    // Give it the first control and it uses the pNext member instantiate the correct one
    return HelpGetClassObject(rclsid, riid, ppv, &g_ctlinfoSG);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//
#define IDS_STRING1                     1

#define IDB_ICON_SGRFX                  100
#define IDB_ICON_PATH                   101
#define IDB_ICON_SPRITE                 102
#define IDB_ICON_SEQUENCER              103


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\sources.inc ===
!include $(DAXCTL_ROOT)\common.inc

TARGETNAME=daxctle
TARGETPATH=$(SDKDIR_DEST)
TARGETTYPE=DYNLINK
TARGETEXT=ocx

DLLDEF=..\daxctl.def
DLLBASE=0x10000000
DLLENTRY=DllMain

UMTYPE=windows

C_DEFINES = \
    $(C_DEFINES) \
    /DUSE_OLD_SEQUENCER \
    /DINCLUDESEQ \
    /DUSE_IHOCHELPLIB

!undef USE_NATIVE_EH

INCLUDES=$(INCLUDES);$(DAXCTL_ROOT)\controls\ihbase;

SOURCES = \
    resource.rc \
    dll.cpp \
    purevirt.cpp

TARGETLIBS = \
    $(MMUTILS_LIB) \
    $(DAXCTL_ROOT)\srcodl\$(O)\srcodl.lib \
    $(DAXCTL_ROOT)\controls\ihbase\$(O)\ihbase.lib \
    $(DAXCTL_ROOT)\controls\path\$(O)\path.lib \
    $(DAXCTL_ROOT)\controls\sprite\$(O)\sprite.lib \
    $(DAXCTL_ROOT)\controls\sgrfx\$(O)\sgrfx.lib \
    $(DAXCTL_ROOT)\controls\mmseq\$(O)\mmseq.lib \
    $(DAXCTL_ROOT)\controls\mmctl\src\ochelp\$(O)\mmctl.lib \
    $(DAX_EXTRACRTOBJS) \
    $(SDK_LIB_PATH)\user32.lib \
    $(SDK_LIB_PATH)\kernel32.lib \
    $(SDK_LIB_PATH)\gdi32.lib \
    $(SDK_LIB_PATH)\ole32.lib \
    $(SDK_LIB_PATH)\uuid.lib \
    $(SDK_LIB_PATH)\oleaut32.lib \
    $(SDK_LIB_PATH)\winmm.lib \
    $(SDK_LIB_PATH)\advapi32.lib \
    $(SDKDIR)\daguid.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\ihbase\bvrcllbk.h ===
//
// Behaviour driver class
//
#ifndef __BVRCLLBK_H__
#define __BVRCLLBK_H__

#include <windows.h>
#include <daxpress.h>
#include "debug.h"

// Madness to prevent ATL from using CRT
#define _ATL_NO_DEBUG_CRT
#define _ASSERTE(x) ASSERT(x)
#include <atlbase.h>

typedef BOOL (*PFNCONTINUEFUNCTION)(LPVOID);

class CCallbackBehavior : public IDAUntilNotifier
{
public :
    //
    // Constructors and destructors
    //
    CCallbackBehavior();
    ~CCallbackBehavior();

    //
    // Initialization
    //
    HRESULT Init(
        IDAStatics *pStatics, 
        IDAEvent *pEvent, 
        PFNCONTINUEFUNCTION pfnContinueFunction,
		LPVOID pvUserData,
        IDABehavior **ppBehavior);

    BOOL IsActive();
    BOOL SetActive(BOOL fActive);

    // Member variables
private:
    ULONG m_cRef; 
    PFNCONTINUEFUNCTION    m_pfnContinueFunction;
    BOOL                   m_fActive;
    CComPtr<IDAStatics>    m_StaticsPtr;
    CComPtr<IDAEvent>      m_EventPtr;
	LPVOID                 m_pvUserData;

    ///// IDAUntilNotifier 
protected:

    HRESULT STDMETHODCALLTYPE Notify(
        IDABehavior __RPC_FAR *eventData, 
        IDABehavior __RPC_FAR *curRunningBvr,
        IDAView __RPC_FAR *curView,
        IDABehavior __RPC_FAR *__RPC_FAR *ppBvr);

    ///// IUnknown
    public :

    HRESULT STDMETHODCALLTYPE QueryInterface(
        REFIID riid, 
        void __RPC_FAR *__RPC_FAR *ppvObject);

    ULONG STDMETHODCALLTYPE AddRef(void);

    ULONG STDMETHODCALLTYPE Release(void);

    ///// IDispatch implementation
protected:
    STDMETHODIMP GetTypeInfoCount(UINT *pctinfo);

    STDMETHODIMP GetTypeInfo(
        UINT itinfo, 
        LCID lcid, 
        ITypeInfo **pptinfo);

    STDMETHODIMP GetIDsOfNames(
        REFIID riid, 
        LPOLESTR *rgszNames, 
        UINT cNames,
        LCID lcid, 
        DISPID *rgdispid);

    STDMETHODIMP Invoke(
        DISPID dispidMember, 
        REFIID riid, 
        LCID lcid,
        WORD wFlags, 
        DISPPARAMS *pdispparams, 
        VARIANT *pvarResult,
        EXCEPINFO *pexcepinfo, 
        UINT *puArgErr);

};

#endif //__BVRCLLBK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\ihbase\clocker.cpp ===
#include "precomp.h"
#include "debug.h"
#include "utils.h"

#include "clocker.h"

extern HINSTANCE g_hinst;

#define CLOCKER_NOTIFY_CLASS_NAME  "CClockerNotifyWindow"
#define CLOCKER_TIMER_CLASS_NAME   "CClockerTimerWindow"

BOOL CClocker::g_fNotifyClassRegistered = FALSE;
BOOL CClocker::g_fTimerClassRegistered = FALSE;

CClocker::CClocker (void) :
    m_ulRefs(1),
        m_cView(NULL),
        m_cHost(NULL),
        m_cTimer(NULL),
        m_fVisible(TRUE),
        m_dwCookie(0),
        m_fIgnoreAdvises(FALSE),
        m_pClockerSink(NULL),
        m_iTimerInterval(50),
    m_hwnd(NULL),
    m_fToggle(FALSE),
    m_fAsync(FALSE),
    m_iTimerID(0),
    m_CT(CT_ITimer)
{
}

CClocker::~CClocker (void)
{
    KillWindow();

        if ((NULL != (ITimer *)m_cTimer) && (0 != m_dwCookie))
        {
        m_pClockerSink = NULL;
                Stop();
        }
}

HRESULT
CClocker::SetView (IDAView * piView)
{
        // NULL views are permissible ways to 
        // detach a prior view.
        m_cView = piView;
        return S_OK;
}

HRESULT
CClocker::SetHost (IOleClientSite * pocsHost)
{
        // NULL hosts are permissible ways to 
        // detach a prior host.
        m_cHost = pocsHost;
        return FindTimer();
}

HRESULT
CClocker::SetVisible (BOOL fVisible)
{
        m_fVisible = fVisible;
        return S_OK;
}

HRESULT 
CClocker::SetSink(CClockerSink *pClockerSink)
{
    m_pClockerSink = pClockerSink;
        return S_OK;
}

HRESULT 
CClocker::SetInterval(ULONG iInterval)
{
        m_iTimerInterval = iInterval;
        return S_OK;
}

STDMETHODIMP
CClocker::QueryInterface (REFIID riid, LPVOID * ppv)
{
        HRESULT hr = E_POINTER;

        if (NULL != ppv)
        {
                hr = E_NOINTERFACE;
                if (::IsEqualIID(riid, IID_ITimerSink) || (::IsEqualIID(riid, IID_IUnknown)))
                {
                        *ppv = (ITimerSink *)this;
                        AddRef();
                        hr  = S_OK;
                }
        }

        return hr;
}

STDMETHODIMP_(ULONG)
CClocker::AddRef (void)
{
        return ++m_ulRefs;
}

STDMETHODIMP_(ULONG)
CClocker::Release (void)
{
        // We shouldn't ever dip below a refcount of 1.
        ASSERT (1 < m_ulRefs);
        // This object is only used as a timer sink ... we do not 
        // want to delete it after the last external reference 
        // is removed.
        return --m_ulRefs;
}
#define TIMERID 1
STDMETHODIMP 
CClocker::OnTimer (VARIANT varTimeAdvise)
{
        HRESULT hr = S_OK;

        // If we're inactive, we should simply return without doing anything.
        // Ditto if we're still processing another sink call.
        if ((0 != m_dwCookie) && (!m_fIgnoreAdvises))
        {
                m_fIgnoreAdvises = TRUE;

        if (m_fAsync)
        {
            if (m_hwnd)
            {
                int iOffset = 0;
                m_fToggle = !m_fToggle;
                iOffset = m_fToggle ? 1 : -1;

#ifdef MOVEWINDOW
                // Let the post-notification handle the update...
                ::MoveWindow(m_hwnd, iOffset, iOffset, 1, 1, FALSE);
#else
                if (0 == SetTimer(m_hwnd, ++m_iTimerID, 0, NULL))
                    ASSERT(FALSE);
#endif
            }
            else
            {
                        m_fIgnoreAdvises = FALSE;
            }
        }
        else
        {
            // Dispatch Immediately...
            hr = DispatchTimer(timeGetTime());
        }
        }

        return hr;
}

HRESULT
CClocker::FindContainerTimer (void)
{
        HRESULT hr = E_FAIL;
        LPUNKNOWN piUnkSite = NULL;

        IServiceProvider * piServiceProvider = NULL;

        if ((NULL != (IOleClientSite *)m_cHost) && SUCCEEDED(hr = m_cHost->QueryInterface(IID_IServiceProvider, (LPVOID *)&piServiceProvider)))
        {
                ITimerService * piTimerService = NULL;

                if (SUCCEEDED(hr = piServiceProvider->QueryService(IID_ITimerService, IID_ITimerService, (LPVOID *)&piTimerService)))
                {
                        hr = piTimerService->GetNamedTimer(NAMEDTIMER_DRAW, &m_cTimer);
                        ASSERT(NULL != (ITimer *)m_cTimer);
                        piTimerService->Release();
                }
                piServiceProvider->Release();
        }

        return hr;
}

HRESULT
CClocker::FindDefaultTimer (void)
{
        HRESULT hr = E_FAIL;
#if 0
        ITimerService * pITimerService = NULL;

        // Get the timer service.  From this, we can create a timer for ourselves.
        hr = CoCreateInstance(CLSID_TimerService, NULL, CLSCTX_INPROC_SERVER, IID_ITimerService, (LPVOID *)&pITimerService);
        ASSERT(SUCCEEDED(hr) && (NULL != pITimerService));
        if (SUCCEEDED(hr) && (NULL != pITimerService))
        {
                // Create a timer, using no reference timer.
                hr = pITimerService->CreateTimer(NULL, &m_cTimer);
                pITimerService->Release();
        }
#endif

        return hr;
}


HRESULT
CClocker::CreateWindowsTimer (void)
{
    ASSERT (m_hwnd != NULL);

    m_iTimerID = SetTimer(m_hwnd, 1, m_iTimerInterval, NULL);
    
    ASSERT(m_iTimerID != NULL);
    
    return ((m_iTimerID != NULL) ? S_OK : E_FAIL);

}


HRESULT
CClocker::FindTimer (void)
{
        HRESULT hr = E_FAIL;

    if (CT_ITimer == m_CT)
    {
            if (FAILED(hr = FindContainerTimer()))
            {
                    hr = FindDefaultTimer();
            }
    }
    else
    {
        hr = S_OK;
    }

        return hr;
}

HRESULT
CClocker::InitTimer (void)
{
        return FindTimer();
}

HRESULT
CClocker::Start (void)
{
        HRESULT hr = E_FAIL;
    
    if (m_CT == CT_WMTimer) 
    {
      // Create the dummy window now...
        if (0 == m_iTimerID)
        {
            if (FAILED(hr = MakeWindow(g_hinst, TRUE)))
                return hr;

            if (FAILED(hr = CreateWindowsTimer()))
                return hr;
        }
        else
        {
            hr = S_OK;
        }
    }
    else
    {
        if (m_dwCookie == 0)
        {
                ASSERT(NULL != (ITimer *)m_cTimer);
                if (NULL != (ITimer *)m_cTimer)
                {
                        // Set up the constant advise.
                        VARIANT varMin;
                        VARIANT varMax;
                        VARIANT varInterval;
                        DWORD dwNow = 0;

                if (m_fAsync)
                {
                    // Create the dummy window now...
                    if (FAILED(hr = MakeWindow(g_hinst, FALSE)))
                        return hr;
                }

                        VariantInit(&varMin);
                        V_VT(&varMin) = VT_UI4;
                        V_UI4(&varMin) = timeGetTime();
                        VariantInit(&varMax);
                        V_VT(&varMax) = VT_UI4;
                        V_UI4(&varMax) = 0;
                        VariantInit(&varInterval);
                        V_VT(&varInterval) = VT_UI4;
                        V_UI4(&varInterval) = m_iTimerInterval;
                        hr = m_cTimer->Advise(varMin, varMax, varInterval, 0, this, &m_dwCookie);
                        ASSERT(SUCCEEDED(hr));
                }
        }
        else
        {
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT
CClocker::Stop (void)
{
        HRESULT hr = E_FAIL;

    if (m_CT == CT_WMTimer)
    {
        hr = (KillTimer(m_hwnd, 1) ? S_OK : E_FAIL);
        m_iTimerID = 0;
    }
    else
    {
            if ((NULL != (ITimer *)m_cTimer) && (0 != m_dwCookie))
            {
                    hr = m_cTimer->Unadvise(m_dwCookie);
                    m_dwCookie = 0;
            }
    }
        return hr;
}

HRESULT CClocker::DispatchTimer(DWORD dwTime)
{
    HRESULT hr = S_OK;

        // Use the supplied callback function if available
        if (m_pClockerSink)
        {
                m_pClockerSink->OnTimer(dwTime);
        }
        else
        {
        // Use the default behavior...
        if (NULL != (IDAView *)m_cView)
        {
            VARIANT_BOOL vBool = FALSE;
                    double dblCurrentTime = dwTime / 1000.0;

                    if (SUCCEEDED(hr = m_cView->Tick(dblCurrentTime, &vBool)))
                    {
                BOOL fForceRender = VBOOL_TO_BOOL(vBool);

                if (fForceRender)
                {
                            hr = m_cView->Render();
                }
                }
        }
        }

    // Allow more advises...
        m_fIgnoreAdvises = FALSE;

    return hr;
}

HRESULT CClocker::MakeWindow(HINSTANCE hInstance, BOOL fCreateTimerWindow)
{
    HRESULT hr = S_OK;

    if ( (!fCreateTimerWindow && !g_fNotifyClassRegistered) ||
         (fCreateTimerWindow && !g_fTimerClassRegistered))
    {
        WNDCLASS wndclass;
        memset(&wndclass, 0, sizeof(wndclass));
        wndclass.style         = 0;
        wndclass.lpfnWndProc   = fCreateTimerWindow ? CClocker::TimerWndProc : CClocker::WndProc;
        wndclass.hInstance     = hInstance;
        wndclass.hCursor       = NULL;
        wndclass.hbrBackground = NULL;

        if (fCreateTimerWindow)
            wndclass.lpszClassName = CLOCKER_TIMER_CLASS_NAME;
        else
            wndclass.lpszClassName = CLOCKER_NOTIFY_CLASS_NAME;

        ::RegisterClass(&wndclass);

        if (fCreateTimerWindow)
            g_fTimerClassRegistered = TRUE;
        else
            g_fNotifyClassRegistered = TRUE;
    }

    if (!m_hwnd)
    {
        m_hwnd = ::CreateWindowEx(
            (DWORD)0,
            fCreateTimerWindow ? CLOCKER_TIMER_CLASS_NAME : CLOCKER_NOTIFY_CLASS_NAME,
            "CClocker",
            (DWORD)0,
            0, 0, 0, 0,
            NULL,
            NULL,
            hInstance,
            (LPVOID)NULL);
    }

    if (m_hwnd)
    {
        ::SetWindowLongPtr(m_hwnd, GWLP_USERDATA, (LONG_PTR)this);
        hr = S_OK;
    }
    else
        hr = E_FAIL;

    return hr;
}

HRESULT CClocker::KillWindow(void)
{
    HRESULT hr = S_OK;

    if (m_hwnd)
    {
        ::DestroyWindow(m_hwnd);
        m_hwnd = NULL;
    }

    return hr;
}

LRESULT __stdcall CClocker::WndProc(HWND hWnd, UINT uiMessage, WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult = 0;

#ifdef MOVEWINDOW
    if (uiMessage == WM_WINDOWPOSCHANGED)
#else
    if (uiMessage == WM_TIMER)
#endif
    {
        CClocker *pThis = (CClocker *)::GetWindowLongPtr(hWnd, GWLP_USERDATA);

#ifndef MOVEWINDOW
        if (pThis)
        {
            KillTimer(hWnd, pThis->m_iTimerID);
            if (64000 == pThis->m_iTimerID)
                pThis->m_iTimerID = 0;
        }
#endif
        if (pThis)
            pThis->DispatchTimer(timeGetTime());
    }

    lResult = ::DefWindowProc(hWnd, uiMessage, wParam, lParam);

    return lResult;
}

LRESULT __stdcall CClocker::TimerWndProc(HWND hWnd, UINT uiMessage, WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult = 0;

    if (uiMessage == WM_TIMER)
    {
        CClocker *pThis = (CClocker *)::GetWindowLongPtr(hWnd, GWLP_USERDATA);

        if (pThis && !(pThis->m_fIgnoreAdvises))
        {
            pThis->m_fIgnoreAdvises = TRUE;
            pThis->DispatchTimer(timeGetTime());
        }
    }

    lResult = ::DefWindowProc(hWnd, uiMessage, wParam, lParam);

    return lResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\ihbase\bvrcllbk.cpp ===
#include "precomp.h"  // From IHBase
#include "debug.h"    // From IHBase
#include <memlayer.h>
#include "bvrcllbk.h"

extern ULONG g_cLock;

/*==========================================================================*/

CCallbackBehavior::CCallbackBehavior()
{
    m_cRef = 1;
    m_pfnContinueFunction = NULL;
    m_fActive = FALSE;
	m_pvUserData = NULL;
	g_cLock++;
}

/*==========================================================================*/

CCallbackBehavior::~CCallbackBehavior()
{
    ASSERT(m_cRef == 0);
	g_cLock--;
}

/*==========================================================================*/

HRESULT CCallbackBehavior::Init(
    IDAStatics *pStatics, 
    IDAEvent *pEvent, 
    PFNCONTINUEFUNCTION pfnContinueFunction,
	LPVOID pvUserData,
    IDABehavior **ppBehavior)

{
    HRESULT hr = S_OK;

	m_pvUserData = pvUserData;

	if (NULL != pfnContinueFunction)
	{
		m_pfnContinueFunction = pfnContinueFunction;
	}
	else
	{
		hr = E_POINTER;
	}

    // Check IDAStatics pointer ...
    if ((SUCCEEDED(hr)) && (NULL != pStatics))
        m_StaticsPtr = pStatics;
    else
        hr = E_POINTER;

    // Check IDAEvent pointer
    if ((SUCCEEDED(hr)) && (NULL != pEvent))
        m_EventPtr = pEvent;
    else
        hr = E_POINTER;

    // Initialize everything ...
	// The Until Notify needs a dummy behavior
	CComPtr<IDANumber> cDummyBvr;

    if (SUCCEEDED(hr))
    {
		hr = m_StaticsPtr->DANumber(99, &cDummyBvr);
	}

    if (SUCCEEDED(hr))
    {
        IDAUntilNotifier * pThis = this;
        hr = m_StaticsPtr->UntilNotify(cDummyBvr, pEvent, pThis, ppBehavior);
    }
    

    if (FAILED(hr))
    {
        m_StaticsPtr.Release();
        m_pfnContinueFunction = NULL;
        m_EventPtr.Release();
    }

    return hr;
}

/*==========================================================================*/

BOOL CCallbackBehavior::IsActive()
{
    return m_fActive;
}

/*==========================================================================*/

BOOL CCallbackBehavior::SetActive(BOOL fActive)
{
    BOOL fTemp = m_fActive;
    m_fActive = fActive;
    
    return fTemp;
}

/*==========================================================================*/

///// IDAUntilNotifier 
HRESULT STDMETHODCALLTYPE CCallbackBehavior::Notify(
        IDABehavior __RPC_FAR *eventData, 
        IDABehavior __RPC_FAR *curRunningBvr,
        IDAView __RPC_FAR *curView,
        IDABehavior __RPC_FAR *__RPC_FAR *ppBvr)
{
    HRESULT hr = E_POINTER;

	ASSERT(NULL != ppBvr);
	if (NULL != ppBvr)
	{
		hr = S_OK;

		// Create a new dummy behavior.
		CComPtr<IDANumber> cDummyNumber;
		if (SUCCEEDED(hr))
		{
			hr = m_StaticsPtr->DANumber(99, &cDummyNumber);
			ASSERT(SUCCEEDED(hr));
		}

		if (m_pfnContinueFunction(m_pvUserData))
		{
			IDAUntilNotifier *pThis = this;

			hr = m_StaticsPtr->UntilNotify(cDummyNumber, m_EventPtr, this, ppBvr);
			ASSERT(SUCCEEDED(hr));
		}
		else
		{
			// Make sure that the dummy doesn't go away.
			cDummyNumber->AddRef();
			*ppBvr = cDummyNumber;
			hr = S_OK;
		}
	}

    return hr;
}

/*==========================================================================*/

///// IUnknown
HRESULT STDMETHODCALLTYPE CCallbackBehavior::QueryInterface(
    REFIID riid, 
    void __RPC_FAR *__RPC_FAR *ppvObject)
{
    if (NULL == ppvObject)
        return E_POINTER;

    HRESULT hr = E_NOINTERFACE;

    *ppvObject = NULL;

    if (IsEqualGUID(riid, IID_IDAUntilNotifier))
    {
        IDAUntilNotifier *pThis = this;
        
        *ppvObject = (LPVOID) pThis;
        AddRef(); // Since we only provide one interface, we can just AddRef here

        hr = S_OK;
    }

    return hr;
}

/*==========================================================================*/

ULONG STDMETHODCALLTYPE CCallbackBehavior::AddRef(void)
{
	return ::InterlockedIncrement((LONG *)(&m_cRef));
}

/*==========================================================================*/

ULONG STDMETHODCALLTYPE CCallbackBehavior::Release(void)
{
	::InterlockedDecrement((LONG *)(&m_cRef));
    if (m_cRef == 0)
    {
        Delete this;
    }

    return m_cRef;
}

/*==========================================================================*/

///// IDispatch implementation
STDMETHODIMP CCallbackBehavior::GetTypeInfoCount(UINT *pctinfo)
{
    return E_NOTIMPL;
}

/*==========================================================================*/

STDMETHODIMP CCallbackBehavior::GetTypeInfo(
    UINT itinfo, 
    LCID lcid, 
    ITypeInfo **pptinfo)
{
    return E_NOTIMPL;
}

/*==========================================================================*/

STDMETHODIMP CCallbackBehavior::GetIDsOfNames(
    REFIID riid, 
    LPOLESTR *rgszNames, 
    UINT cNames,
    LCID lcid, 
    DISPID *rgdispid)
{
    return E_NOTIMPL;
}

/*==========================================================================*/

STDMETHODIMP CCallbackBehavior::Invoke(
    DISPID dispidMember, 
    REFIID riid, 
    LCID lcid,
    WORD wFlags, 
    DISPPARAMS *pdispparams, 
    VARIANT *pvarResult,
    EXCEPINFO *pexcepinfo, 
    UINT *puArgErr)
{
    return E_NOTIMPL;
}

/*==========================================================================*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\ihbase\debug.h ===
// debug.h
//
// Debugging functions.

#ifndef __IHBASEDEBUG_H__
#define __IHBASEDEBUG_H__
#include "..\..\inc\debug.h"

// <g_hinst> must be defined externally as the app/DLL instance handle
extern HINSTANCE g_hinst;


//////////////////////////////////////////////////////////////////////////////
// TRACE, ASSERT, VERIFY
//
// These are the same as MFC's functions of the same name (but are implemented
// without using MFC).  See "debug.h" for the actual macro definitions.
//

// Debugging support (SimonB)
#ifdef _DEBUG
extern BOOL g_fLogDebugOutput;
#define DEBUGLOG(X) { if (g_fLogDebugOutput) OutputDebugString(X);}
#else
#define DEBUGLOG(X)
#endif

#ifdef _DEBUG

BOOL AssertFailedLine(LPCSTR lpszFileName, int nLine);
void __cdecl Trace(LPCTSTR lpszFormat, ...);

// VanK modification
#ifdef TRACE
#pragma message("TRACE already defined - redefining")
#undef TRACE
#endif

#define TRACE              if (g_fLogDebugOutput) ::Trace

// VanK modification
#ifdef THIS_FILE
#pragma message("THIS_FILE already defined - redefining")
#undef THIS_FILE
#endif

#define THIS_FILE          __FILE__

// SimonB modification
#ifdef ASSERT
#pragma message("ASSERT already defined - redefining")
#undef ASSERT
#endif

#define ASSERT(f) \
    do \
    { \
    if (!(f) && AssertFailedLine(THIS_FILE, __LINE__)) \
        DebugBreak(); \
    } while (0) \

#define VERIFY(f)          ASSERT(f)

#else // #ifndef _DEBUG

#ifdef ASSERT
#pragma message("ASSERT being redefined as NULL statment")
#undef ASSERT
#endif

#define ASSERT(f)          ((void)0)

#define VERIFY(f)          ((void)(f))

inline void __cdecl Trace(LPCTSTR, ...) { }

// VanK modification
#ifdef TRACE
#pragma message("TRACE being redefined as NULL statment")
#undef TRACE
#endif

#define TRACE              1 ? (void)0 : ::Trace

#endif // _DEBUG


/////////////////////////////////////////////////////////////////////////////
// DebugIIDName, DebugCLSIDName
//
// These functions convert an IID or CLSID to a string name for debugging
// purposes (e.g. IID_IUnknown is converted to "IUnknown").
//

#ifdef _DEBUG
LPCSTR DebugIIDName(REFIID riid, LPSTR pchName);
LPCSTR DebugCLSIDName(REFCLSID rclsid, LPSTR pchName);
#endif // _DEBUG

#endif // _IHBASEDEBUG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\ihbase\debug.cpp ===
// debug.cpp
//
// Debugging functions.
//

#include "..\ihbase\precomp.h"
#include <tchar.h>
#include "debug.h"


//////////////////////////////////////////////////////////////////////////////
// TRACE, ASSERT, VERIFY
//
// These are the same as MFC's functions of the same name (but are implemented
// without using MFC).  See "debug.h" for the actual macro definitions.
//

#ifdef _DEBUG

BOOL AssertFailedLine(LPCSTR lpszFileName, int nLine)
{
    // active popup window for the current thread
    HWND hwndParent = GetActiveWindow();
    if (hwndParent != NULL)
        hwndParent = GetLastActivePopup(hwndParent);

    // format message into buffer
    TCHAR atchAppName[_MAX_PATH * 2];
    TCHAR atchMessage[_MAX_PATH * 2];
    if (GetModuleFileName(g_hinst, atchAppName,
            sizeof(atchAppName) / sizeof(TCHAR)) == 0)
        atchAppName[0] = 0;
    wsprintf(atchMessage, _T("%s: File %hs, Line %d"),
        atchAppName, lpszFileName, nLine);

    // display the assert
    int nCode = MessageBox(hwndParent, atchMessage, _T("Assertion Failed!"),
        MB_TASKMODAL | MB_ICONHAND | MB_ABORTRETRYIGNORE | MB_SETFOREGROUND);

    if (nCode == IDIGNORE)
        return FALSE;   // ignore

    if (nCode == IDRETRY)
        return TRUE;    // will cause DebugBreak()

    FatalExit(0);
    return TRUE;        // ...though FatalExit() should not return
}

void __cdecl Trace(LPCTSTR lpszFormat, ...)
{
    // start processing optional arguments
    va_list args;
    va_start(args, lpszFormat);

    // format the output string
    TCHAR atchBuffer[512];
    wvsprintf(atchBuffer, lpszFormat, args);

    // output the string
    OutputDebugString(atchBuffer);

    // end processing optional arguments
    va_end(args);
}

#endif // _DEBUG


/////////////////////////////////////////////////////////////////////////////
// DebugIIDName, DebugCLSIDName
//
// These functions convert an IID or CLSID to a string name for debugging
// purposes (e.g. IID_IUnknown is converted to "IUnknown").
//

#ifdef _DEBUG

LPCSTR DebugGUIDName(REFGUID rguid, LPSTR szKey, LPSTR pchName)
{
    OLECHAR         achIID[100];        // interface ID (e.g. "{nnn-nnn-...}")  
    TCHAR           ach[150];

    // in case of error, clear <pchName>
    pchName[0] = 0;

    // convert <rguid> to a string (e.g. "{nnn-nnn-...}")
    StringFromGUID2(rguid, achIID, sizeof(achIID)/sizeof(achIID[0]));

    wsprintf(ach, TEXT("%hs\\%ls"), szKey, (LPOLESTR) achIID);
    
    // look up <achIID> in the registration database
#ifdef UNICODE
    TCHAR pchNameTemp[300];
    LONG cchNameTemp;
    cchNameTemp = _MAX_PATH;
    if (RegQueryValue(HKEY_CLASSES_ROOT, ach, pchNameTemp, &cchNameTemp)
            != ERROR_SUCCESS)
        // if <achIID> isn't in the registration database, use <achIID> itself
        wsprintf(pchNameTemp, TEXT("%ls"), (LPOLESTR) achIID);

    wcstombs(pchName, pchNameTemp, _MAX_PATH);
#else
    LONG cchNameTemp;
    cchNameTemp = _MAX_PATH;
    if (RegQueryValue(HKEY_CLASSES_ROOT, ach, pchName, &cchNameTemp)
            != ERROR_SUCCESS)
        // if <achIID> isn't in the registration database, use <achIID> itself
        wsprintf(pchName, TEXT("%ls"), (LPOLESTR) achIID);
#endif    
    return pchName;
}

#endif // _DEBUG


/* DebugIIDName

@func   Finds the name of an interface in the system registration database
        given the interface's IID (for debugging purposes only).

@rdesc  Returns a pointer to <p pchName>.

@comm   If the interface name is not found, a hexadecimal string form of
        <p riid> will be returned
        (e.g. "{209D2C80-11D7-101B-BF00-00AA002FC1C2}").

@comm   This function is only available in a debug build.
*/

#ifdef _DEBUG

LPCSTR DebugIIDName(

REFIID riid, /* @parm
        Interface ID to find the name of. */

LPSTR pchName) /* @parm
        Where to store the class ID name string.  This buffer should be
        large enough to hold _MAX_PATH characters. */

{
    return DebugGUIDName(riid, "Interface", pchName);
}

#endif


/* DebugCLSIDName

@func   Finds the name of an interface in the system registration database
        given the interface's CLSID (for debugging purposes only).

@rdesc  Returns a pointer to <p pchName>.

@comm   If the interface name is not found, a hexadecimal string form of
        <p rclsid> will be returned
        (e.g. "{209D2C80-11D7-101B-BF00-00AA002FC1C2}").

@comm   This function is only available in a debug build.
*/

#ifdef _DEBUG

LPCSTR DebugCLSIDName(

REFCLSID rclsid, /* @parm
        Class ID to find the name of. */

LPSTR pchName) /* @parm
        Where to store the class ID name string.  This buffer should be
        large enough to hold _MAX_PATH characters. */

{
    return DebugGUIDName(rclsid, "Clsid", pchName);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\ihbase\onload.cpp ===
/*++

Module: 
        onload.cpp

Author: 
        IHammer Team (SimonB), based on Carrot sample in InetSDK

Created: 
        April 1997

Description:
        Implements an IDispatch which fires the OnLoad and OnUnload members in CIHBase

History:
        04-03-1997      Created

++*/

#include "..\ihbase\precomp.h"
#include <mshtmdid.h>
#undef Delete
#include <mshtml.h>
#define Delete delete
#include "onload.h"
#include "debug.h"

/*
 * CLUDispatch::CLUDispatch
 * CLUDispatch::~CLUDispatch
 *
 * Parameters (Constructor):
 *  pSite           PCSite of the site we're in.
 *  pUnkOuter       LPUNKNOWN to which we delegate.
 */

CLUDispatch::CLUDispatch(CIHBaseOnLoad *pSink, IUnknown *pUnkOuter )
{
        ASSERT (pSink != NULL);

    m_cRef = 0;
    m_pOnLoadSink = pSink;
    m_pUnkOuter = pUnkOuter;
}

CLUDispatch::~CLUDispatch( void )
{
        ASSERT( m_cRef == 0 );
}


/*
 * CLUDispatch::QueryInterface
 * CLUDispatch::AddRef
 * CLUDispatch::Release
 *
 * Purpose:
 *  IUnknown members for CLUDispatch object.
 */

STDMETHODIMP CLUDispatch::QueryInterface( REFIID riid, void **ppv )
{
        if (NULL == ppv)
                return E_POINTER;

    *ppv = NULL;

    if ( IID_IDispatch == riid || DIID_HTMLWindowEvents == riid )
        {
        *ppv = this;
        }
        
        if ( NULL != *ppv )
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return m_pUnkOuter->QueryInterface( riid, ppv );
}


STDMETHODIMP_(ULONG) CLUDispatch::AddRef(void)
{
    ++m_cRef;
    return m_pUnkOuter->AddRef();
}

STDMETHODIMP_(ULONG) CLUDispatch::Release(void)
{
    --m_cRef;
    return m_pUnkOuter->Release();
}


//IDispatch
STDMETHODIMP CLUDispatch::GetTypeInfoCount(UINT* /*pctinfo*/)
{
        return E_NOTIMPL;
}

STDMETHODIMP CLUDispatch::GetTypeInfo(/* [in] */ UINT /*iTInfo*/,
            /* [in] */ LCID /*lcid*/,
            /* [out] */ ITypeInfo** /*ppTInfo*/)
{
        return E_NOTIMPL;
}

STDMETHODIMP CLUDispatch::GetIDsOfNames(
            /* [in] */ REFIID /*riid*/,
            /* [size_is][in] */ LPOLESTR* /*rgszNames*/,
            /* [in] */ UINT /*cNames*/,
            /* [in] */ LCID /*lcid*/,
            /* [size_is][out] */ DISPID* /*rgDispId*/)
{
        return E_NOTIMPL;
}


STDMETHODIMP CLUDispatch::Invoke(
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID /*riid*/,
            /* [in] */ LCID /*lcid*/,
            /* [in] */ WORD /*wFlags*/,
            /* [out][in] */ DISPPARAMS* pDispParams,
            /* [out] */ VARIANT* /*pVarResult*/,
            /* [out] */ EXCEPINFO* /*pExcepInfo*/,
            /* [out] */ UINT* puArgErr)
{
        // Listen for the two events we're interested in, and call back if necessary
#ifdef _DEBUG
        TCHAR rgchDispIdInfo[40];
        wsprintf(rgchDispIdInfo, TEXT("CLUDispatch::Invoke: dispid = %lx\n"), dispIdMember);
        DEBUGLOG(rgchDispIdInfo);
#endif

        switch (dispIdMember)
        {
                case DISPID_EVPROP_ONLOAD:
                case DISPID_EVMETH_ONLOAD:
                {
                        m_pOnLoadSink->OnWindowLoad();
                }
                break;

                case DISPID_EVPROP_ONUNLOAD:
                case DISPID_EVMETH_ONUNLOAD:
                {
                        m_pOnLoadSink->OnWindowUnload();
                }
                break;
        }
        return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\ihbase\onload.h ===
/*++

Module: 
	onload.h

Author: 
	IHammer Team (SimonB), based on Carrot sample in InetSDK

Created: 
	April 1997

Description:
	Implements an IDispatch which fires the OnLoad and OnUnload members in CIHBase

History:
	04-03-1997	Created

++*/

#ifndef __ONLOAD_H__
#define __ONLOAD_H__

class CIHBaseOnLoad
{
public:

	//inline CIHBaseOnLoad() {};
	//virtual ~CIHBaseOnLoad() {};
	
	virtual void OnWindowLoad() = 0;
	virtual void OnWindowUnload() = 0;
};


// Load/Unload Dispatch
class CLUDispatch : public IDispatch
{
	protected:
        ULONG               m_cRef;
        LPUNKNOWN           m_pUnkOuter;
		CIHBaseOnLoad       *m_pOnLoadSink;
		
    public:
        CLUDispatch(CIHBaseOnLoad *pSink, IUnknown * );
        ~CLUDispatch(void);

        STDMETHODIMP QueryInterface(REFIID, void **);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

		//IDispatch
        STDMETHODIMP GetTypeInfoCount(UINT* pctinfo);
        STDMETHODIMP GetTypeInfo(/* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo** ppTInfo);
		STDMETHODIMP GetIDsOfNames(
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
		STDMETHODIMP Invoke(
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS  *pDispParams,
            /* [out] */ VARIANT  *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);

};

#endif //__ONLOAD_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\ihbase\clocker.h ===
#ifndef __CLOCKER_H__
#define __CLOCKER_H__

#include "objbase.h"
// Madness to prevent ATL from using CRT
#define _ATL_NO_DEBUG_CRT
#define _ASSERTE(x) ASSERT(x)
#include <atlbase.h>
#include <servprov.h>
#include <daxpress.h>
#include <ocmm.h>
#include <htmlfilter.h>

class CClockerSink
{
public:
    CClockerSink(void) {}
    virtual ~CClockerSink(void) {}

    virtual void OnTimer(DWORD dwTime)=0;
};

class CClocker : public ITimerSink
{
 public :
    typedef enum {CT_ITimer = 0, CT_WMTimer = 1} CCT;

        
        CClocker (void);
        virtual ~CClocker (void);

        HRESULT SetView (IDAView * piView);
        HRESULT SetHost (IOleClientSite * pocsHost);
        HRESULT SetVisible (BOOL fVisible);
        HRESULT SetSink(CClockerSink *pClockerSink);
        HRESULT SetInterval(ULONG iInterval);
    void SetTimerType(CCT ct) { m_CT = ct; }
    void SetAsync(BOOL fAsync) { m_fAsync = fAsync; }

        HRESULT Start (void);
        HRESULT Stop (void);

        // For the timer sink.
        STDMETHOD(QueryInterface) (REFIID riid, LPVOID * ppv);
        STDMETHOD_(ULONG, AddRef) (void);
        STDMETHOD_(ULONG, Release) (void);
        STDMETHOD(OnTimer) (VARIANT varTimeAdvise);

 protected :

        HRESULT InitTimer (void);
    HRESULT CreateWindowsTimer (void);
        HRESULT FindTimer (void);
        HRESULT FindContainerTimer (void);
        HRESULT FindDefaultTimer (void);
    HRESULT MakeWindow(HINSTANCE hInstance, BOOL fCreateTimerWindow);
    HRESULT KillWindow(void);
    HRESULT DispatchTimer(DWORD dwTime);

    HWND m_hwnd;
    BOOL m_fToggle;
    BOOL m_fAsync;
        ULONG m_ulRefs;
        CComPtr<IDAView> m_cView;
        CComPtr<IOleClientSite> m_cHost;
        CComPtr<ITimer> m_cTimer;
        BOOL m_fVisible;
        BOOL m_fIgnoreAdvises;
        DWORD m_dwCookie;
    CClockerSink *m_pClockerSink;
        ULONG m_iTimerInterval;
    UINT_PTR m_iTimerID; // SetTimer thing
    CCT m_CT;

    static LRESULT __stdcall WndProc(HWND hWnd, UINT uiMessage, WPARAM wParam, LPARAM lParam);
    static LRESULT __stdcall TimerWndProc(HWND hWnd, UINT uiMessage, WPARAM wParam, LPARAM lParam);

    static BOOL g_fNotifyClassRegistered;
    static BOOL g_fTimerClassRegistered;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\ihbase\iids.h ===
/*
	iids.h

	This generated header files contains #defines necessary for the IHBase implementation
	of QueryInterface.  The values below are IID_X.Data1 - not available at compile time.

	To generate this header file, run MakeHdr.  To add more interfaces, modify dmpguids.cpp,
	rebuild dmpguids.exe, and then run MakeHdr.

*/

#ifndef __IIDS_H__
#define __IIDS_H__

#define IID_IViewObject_DATA1 0x10d
#define IID_IViewObject2_DATA1 0x127
#define IID_IViewObjectEx_DATA1 0x3af24292
#define IID_IOleObject_DATA1 0x112
#define IID_IOleInPlaceObjectWindowless_DATA1 0x1c2056cc
#define IID_IOleControl_DATA1 0xb196b288
#define IID_IConnectionPointContainer_DATA1 0xb196b284
#define IID_IOleInPlaceObject_DATA1 0x113
#define IID_IPersistVariantIO_DATA1 0x26f45840
#define IID_IProvideClassInfo_DATA1 0xb196b283
#define IID_IObjectSafety_DATA1 0xcb5bdc81
#define IID_ISpecifyPropertyPages_DATA1 0xb196b28b
#define IID_IUnknown_DATA1 0x0

#endif // __IIDS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\ihbase\ihbase.h ===
/*++

Module:
    ihbase.h

Author:
    IHammer Team (SimonB)

Created:
    October 1996

Description:
    Base class for implementing MMCtl controls

History:
    08-02-1997  Changed the implementation of IOleControl::FreezeEvents.  See the comment in that
                function for details (SimonB)
    07-28-1997  Added m_fInvalidateWhenActivated and supporting code.  This allows controls
                to be invalidated as soon as they are activated. (SimonB)
    04-07-1997  Added support for OnWindowLoad and OnWindowUnload.  This is Trident-specific (SimonB)
    04-03-1997  Modified QI to use a switch statement rather than if ... else blocks.  See the
                QI implementation for details on how to modify it.
    03-13-1997  Changed IOleObject::GetUserType.  Now call the Ole helper directly, rather than rely
                on the caller to do so.
    03-11-1997  Changed IOleObject::GetUserType.  OLE now provides the implementation. (SimonB)
    02-27-1997  Removed CFakeWindowlessClientSite and associated support (SimonB)
    02-18-1997  IOleObject::GetClientSite() implemented (NormB)
    02-17-1997  QI re-ordered for improved performance (NormB)
    01-21-1997  Added support for IObjectSafety (SimonB)
    01-02-1997  Added #ifdef _DESIGN around the property page and parameter page code.  Also
                fixed a bug in IOleObject::GetUserType (SimonB)
    12-30-1996  Added code for property pages. If you want to specify (tell someone else about)
                property pages you must define CONTROL_SPECIFIES_PROPERTY_PAGES and implement
                the ISpecifyPropertyPages interface. (a-rogerw)
    12-23-1996  Added code for parameter pages. If you want to specify (tell ActView about)
                parameter pages you must define CONTROL_SPECIFIES_PARAMETER_PAGES and implement
                the ISpecifyParameterPages interface. (a-rogerw)
    12-18-1996  Added CFakeWindowlessClientSite.  If we can't get a windowless site
                in SetClientSite, an instance of this class is created to handle
                any methods on that site we might need.  Only IUnknown is implemented -
                all other methods return E_FAIL.  This ensures we don't crash in
                containers that don't host windowless controls (like IE 3.0)    (SimonB)
    12-07-1996  Add ResizeControl member function (SimonB)
    11-30-1996  Improve debug output (SimonB)
    11-11-1996  Add caching of bounds in m_rcBounds (SimonB)
    11-10-1996  Add DoVerb code, IOleInPlaceObjectWindowless support (PhaniV)
    11-05-1996  Initialize m_size to something other than 0 (SimonB)
    10-21-1996  Templatized (SimonB)
    10-01-1996  Created (SimonB)

++*/


#ifndef __IHBASE_H__
#define __IHBASE_H__

#include "precomp.h"
#include <ihammer.h>
#include "..\mmctl\inc\ochelp.h"
#include "objsafe.h"
#include "utils.h"
#include "iids.h" // #defines for the .Data1 members of all the IID's we support
#include <minmax.h>

#ifdef SUPPORTONLOAD // Does the control need OnWindowLoad support ?
#include "onload.h"

#ifdef Delete
#define REDEFINE_DELETE_LATER
#undef Delete // remove the definition so <mshtml.h> won't barf
#endif

#include <mshtml.h>

#ifdef REDEFINE_DELETE_LATER
#undef REDEFINE_DELETE_LATER
#define Delete delete
#endif

#endif // SUPPORTONLOAD

#define CX_CONTROL      11      // control natural width (pixels)
#define CY_CONTROL      11      // control natural height (pixels)

/*
// REVIEW: How are we going to deal with this stuff (Simonb)
#define CRGB_CONTROL    8       // how many colors in control's palette
#define RGB_START       RGB(0,200,0)     // start of palette gradient
#define RGB_END         RGB(250,0,0) // end of palette gradient
*/

#ifndef _SYS_GUID_OPERATORS_
#ifndef _OLE32_
inline BOOL  InlineIsEqualGUID(REFGUID rguid1, REFGUID rguid2)
{
   return (
      ((PLONG) &rguid1)[0] == ((PLONG) &rguid2)[0] &&
      ((PLONG) &rguid1)[1] == ((PLONG) &rguid2)[1] &&
      ((PLONG) &rguid1)[2] == ((PLONG) &rguid2)[2] &&
      ((PLONG) &rguid1)[3] == ((PLONG) &rguid2)[3]);
}
#endif // _OLE32_
#endif  _SYS_GUID_OPERATORS_


// Just compare the last 3 elements ...
inline BOOL ShortIsEqualGUID(REFGUID rguid1, REFGUID rguid2)
{
    return (
      ((PLONG) &rguid1)[1] == ((PLONG) &rguid2)[1] &&
      ((PLONG) &rguid1)[2] == ((PLONG) &rguid2)[2] &&
      ((PLONG) &rguid1)[3] == ((PLONG) &rguid2)[3]);
}

#ifndef New
#define New new
#pragma message("NOT Using IHammer New and Delete")
#endif

#ifndef Delete
#define Delete delete
#endif

#define LANGID_USENGLISH MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US)

// control's OLEMISC_ flags
#define CTL_OLEMISC \
        OLEMISC_RECOMPOSEONRESIZE | OLEMISC_CANTLINKINSIDE | \
        OLEMISC_INSIDEOUT | OLEMISC_SETCLIENTSITEFIRST | OLEMISC_ACTIVATEWHENVISIBLE;

// Turn on IObjectSafety support
#define USEOBJECTSAFETY

// globals
extern ControlInfo  g_ctlinfo;      // class information structure

// function that initializes <g_ctlinfo>
void InitControlInfo();

// control implementation

/*
template
    <
    class tempCDerived,            // The derived class
    class tempICustomInterface, // Base class
    const IID * temppCLSID,    // CLSID for the custom class
    const IID * temppIID,        // IID for the custom interface
    const IID * temppLIBID,    // LIBID for the control's typelib
    const IID * temppEventID    // DIID for the event sink
    >

*/
#define TEMPLATE_IHBASE_DEF template < \
    class tempCDerived, class tempICustomInterface, \
    const IID * temppCLSID,    const IID * temppIID,const IID * temppLIBID,const IID * temppEventID \
    >


// TEMPLATE_IHBASE_DEF

template <
    class tempCDerived,
    class tempICustomInterface,
    const IID * temppCLSID,
    const IID * temppIID,
    const IID * temppLIBID,
    const IID * temppEventID
    >
class CIHBaseCtl :
    public INonDelegatingUnknown,
#ifndef NOIVIEWOBJECT
    public IViewObjectEx,
#endif
    public IOleObject,
    public IPersistVariantIO,
    public IOleControl,
    public IConnectionPointContainer,
    public IProvideClassInfo,
    public IOleInPlaceObjectWindowless
#ifdef USEOBJECTSAFETY
    ,public IObjectSafety
#endif // USEOBJECTSAFETY

#ifdef _DESIGN
    ,public ISpecifyPropertyPages        //this is defined even in runtime, Simon.
#endif //_DESIGN

#ifdef SUPPORTONLOAD
    ,public CIHBaseOnLoad
#endif // SUPPORTONLOAD
{
    // Template typedefs
protected:

    typedef tempCDerived control_class;
    typedef tempICustomInterface control_interface;

    // Control state
protected:

    SIZEL m_Size;
    BOOL m_fDirty;
    IUnknown *m_punkPropHelp;
    IDispatch *m_pContainerDispatch; // Point to the container's IDispatch (for ambient property support)
    BOOL m_fDesignMode;
    HelpAdviseInfo m_advise;  // Advise helper

    RECT m_rcBounds;
    RECT m_rcClipRect;
    BOOL m_fControlIsActive; // Keep track of whether we're active or not
    BOOL m_fEventsFrozen;
    long m_cFreezeEvents;
    BOOL m_fInvalidateWhenActivated;

#ifdef SUPPORTONLOAD
private:
    CLUDispatch *m_pcLUDispatch;  // IDispatch for Load/Unload
    DWORD m_dwWindowEventConPtCookie;
    IConnectionPoint *m_pContainerConPt;
#endif
    //
    // construction, destruction
    //
public:

// Add these later
// #pragma optimize("a", on) // Optimization: assume no aliasing
    CIHBaseCtl(IUnknown *punkOuter, HRESULT *phr):
        m_punkPropHelp(NULL),
        m_pTypeInfo(NULL),
        m_pTypeLib(NULL),
        m_pContainerDispatch(NULL),
        m_fDesignMode(FALSE),
        m_fDirty(FALSE),
        m_cRef(1),
        m_pocs(NULL),
        m_poipsw(NULL),
        m_fControlIsActive(FALSE),
        m_fEventsFrozen(FALSE),
        m_cFreezeEvents(0),
        m_fInvalidateWhenActivated(FALSE)
#ifdef SUPPORTONLOAD
        ,m_pcLUDispatch(NULL),
        m_dwWindowEventConPtCookie(0),
        m_pconpt(NULL),
        m_pContainerConPt(NULL)
#endif
    {
        TRACE("CIHBaseCtl 0x%08lx created\n", this);

        // initialize IUnknown state
        m_punkOuter = (punkOuter == NULL ?
            (IUnknown *) (INonDelegatingUnknown *) (tempCDerived *)this : punkOuter);

        // other initialization

        // Initialize the structure for storing the size
        PixelsToHIMETRIC(CX_CONTROL, CY_CONTROL, &m_Size);

        m_fDirty = FALSE;

        // don't allow COM to unload this DLL while an object is alive
        InterlockedIncrement((LONG*)&g_cLock);

        // Initialise helper support for IViewObject::SetAdvise and ::GetAdvise
        InitHelpAdvise(&m_advise);
        *phr = AllocPropertyHelper(m_punkOuter,
                    (tempCDerived *)this,
                    *temppCLSID,
                    0,
                    &m_punkPropHelp);

        // Zero out our bounds and clipping region
        ZeroMemory(&m_rcBounds, sizeof(m_rcBounds));
        ZeroMemory(&m_rcClipRect, sizeof(m_rcClipRect));

        if (FAILED(*phr))
        {
            goto Exit;
        }

    *phr = AllocConnectionPointHelper((IUnknown *) (IDispatch *) (tempCDerived *)this,
        *temppEventID, &m_pconpt);

    if (FAILED(*phr))
    {
        goto Exit;
    }

    Exit:
        ;

    }


    virtual ~CIHBaseCtl()
    {
        TRACE("CIHBaseCtl 0x%08lx destroyed\n", this);

        UninitHelpAdvise(&m_advise);

        // clean up Event helper
        if (NULL != m_pconpt)
            FreeConnectionPointHelper(m_pconpt);

        // Free up the property helper
        SafeRelease((LPUNKNOWN *)&m_punkPropHelp);

        // Free up the typeinfo
        SafeRelease((LPUNKNOWN *)&m_pTypeInfo);

        //Free up the typelib
        SafeRelease((LPUNKNOWN *)&m_pTypeLib);

        // decrement lock count that was incremented in constructor
        InterlockedDecrement((LONG*)&g_cLock);

    }

protected:

    // This member was added to the base class to make life easier
    // for control authors wishing to resize their control.
    // Resizing controls is discussed in the OC96 spec
#ifdef NOTNEEDED
    STDMETHODIMP ResizeControl(long lWidth, long lHeight)
    {
        // CX and CY should be in pixels
        HRESULT hRes;

        // Convert units, and store
        PixelsToHIMETRIC(lWidth, lHeight, &m_Size);

        DEBUGLOG("IHBase: ResizeControl\n");
        if (m_fControlIsActive)
        {
            RECT rcRect;

            DEBUGLOG("IHBase: Control is active, watch for SetObjectRects\n");
            rcRect.top = m_rcBounds.top;
            rcRect.left = m_rcBounds.left;
            rcRect.right = m_Size.cx + m_rcBounds.left;
            rcRect.bottom = m_Size.cy + m_rcBounds.top;

            // ASSERT(m_poipsw != NULL);
            if (m_poipsw)
                hRes = m_poipsw->OnPosRectChange(&rcRect);
            else
                hRes = E_FAIL;

            // ::SetObectRects should be called right after this by the container
        }
        else
        {
            DEBUGLOG("IHBase: Control is inactive, watch for SetExtent\n");

            ASSERT(m_pocs != NULL);
            hRes = m_pocs->RequestNewObjectLayout();
            // GetExtent, and then SetExtent are called
        }

        return hRes;
    }

#endif // NOTNEEDED


///// non-delegating IUnknown implementation
protected:
    ULONG           m_cRef;         // object reference count
    virtual STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, LPVOID *ppv)
    {
        HRESULT hRes = S_OK;
        BOOL fFallThrough = FALSE;

        if (NULL != ppv)
            *ppv = NULL;
        else
            return E_POINTER;


    #ifdef _DEBUG
        char ach[200];
        TRACE("IHBase::QI('%s')\n", DebugIIDName(riid, ach));
    #endif

        //
        // NOTE:    This QI does not handle IDispatch.  This is intentional.  This
        //            function must be overidden in the control's implementation.  See
        //            ihctl\control.cpp for details.
        //

        // NOTE:  A VTune session w/ structured-graphics showed the IViewObject* family,
        // IOleObject, IOleInPlaceObjectWindowless, and IOleControl were the most frequently
        // queried riids.  I've moved them forward and chosen InlineIsEqualGUID for them. (normb)
        // This is no longer necessary now that a switch is used (simonb)

        /*
        To add a GUID to this list:
        1) Modify dmpguid.cpp in the dmpguid subdirectory.  Build, and copy the
           updated binary to the dmpguid directory.
        2) Use the MakeHdr batch file in the dmpguid directory.  This will produce iids.h

        NOTE: If dmpguid mentions a collision, Data1 for two IID's collides.  Therefore, in
              the case for the two IIDs, you will have to determine which is being QI's for

        */
        switch (riid.Data1)
        {
#ifndef NOIVIEWOBJECT
            case IID_IViewObject_DATA1:
                if (!ShortIsEqualGUID(riid, IID_IViewObject))
                    break;
                else
                    fFallThrough = TRUE;
            //Intentional fall-through
            case IID_IViewObject2_DATA1:
                if (!ShortIsEqualGUID(riid, IID_IViewObject2))
                    break;
                else
                    fFallThrough = TRUE;
            //Intentional fall-through
            case IID_IViewObjectEx_DATA1:
            {
                if ((fFallThrough) || (ShortIsEqualGUID(riid, IID_IViewObjectEx)))
                {
                    IViewObjectEx *pThis = this;
                    *ppv = (LPVOID) pThis;
                }
            }
            break;
#endif // NOIVIEWOBJECT

            case IID_IOleObject_DATA1:
            {
                if (ShortIsEqualGUID(riid, IID_IOleObject))
                {
                    IOleObject *pThis = this;
                *ppv = (LPVOID) pThis;
                }
            }
            break;

            case IID_IOleInPlaceObjectWindowless_DATA1:
            {
                if (ShortIsEqualGUID(riid, IID_IOleInPlaceObjectWindowless))
                {
                    IOleInPlaceObjectWindowless *pThis = this;
                    *ppv = (LPVOID) pThis;
                }

            }
            break;

            case IID_IOleControl_DATA1:
            {
                if (ShortIsEqualGUID(riid, IID_IOleControl))
                {
                    IOleControl *pThis = this;
                    *ppv = (LPVOID) pThis;
                }

            }
            break;

            case IID_IConnectionPointContainer_DATA1:
            {
                if (ShortIsEqualGUID(riid, IID_IConnectionPointContainer))
                {
                    IConnectionPointContainer *pThis = this;
                    *ppv = (LPVOID) pThis;
                }
            }
            break;

            case IID_IOleInPlaceObject_DATA1:
            {
                if (ShortIsEqualGUID(riid, IID_IOleInPlaceObject))// Review(SimonB) Is this necessary ?
                {
                    IOleInPlaceObject *pThis = this;
                    *ppv = (LPVOID) pThis;
                }
            }
            break;

            case IID_IPersistVariantIO_DATA1:
            {
                if (ShortIsEqualGUID(riid, IID_IPersistVariantIO))
                {
                    IPersistVariantIO *pThis = this;
                    *ppv = (LPVOID) pThis;
                }

            }
            break;

            case IID_IProvideClassInfo_DATA1:
            {
                if (ShortIsEqualGUID(riid, IID_IProvideClassInfo))
                {
                    IProvideClassInfo *pThis = this;
                    *ppv = (LPVOID) pThis;
                }
            }
            break;

#ifdef USEOBJECTSAFETY
            case IID_IObjectSafety_DATA1:
            {
                if (ShortIsEqualGUID(riid, IID_IObjectSafety))
                {
                    IObjectSafety *pThis = this;
                    *ppv = (LPVOID) pThis;
                }
            }
            break;
#endif // USEOBJECTSAFETY

#ifdef _DESIGN
            case IID_ISpecifyPropertyPages_DATA1:
            {
                if (IsEqualIID(riid, IID_ISpecifyPropertyPages))
                {
                    ISpecifyPropertyPages *pThis = this;
                    *ppv = (LPVOID) pThis;
                }
            }
            break;
#endif //_DESIGN

            case IID_IUnknown_DATA1:
            {
                if (IsEqualIID(riid, IID_IUnknown))
                {
                     IUnknown *pThis = (IUnknown *)(INonDelegatingUnknown *) this;
                    *ppv = (LPVOID) pThis;
                }
            }
            break;
        }

        if (NULL == *ppv)
        {
            ASSERT(m_punkPropHelp != NULL);


#ifdef _DEBUG
            HRESULT hRes = m_punkPropHelp->QueryInterface(riid, ppv);
            if (NULL != *ppv) {
                DEBUGLOG("IHBase: Interface supported in OCHelp\n");
            } else {
                DEBUGLOG("IHBase: Interface not supported !\n");
            }
            return hRes;
#else
            return m_punkPropHelp->QueryInterface(riid, ppv);
#endif
        }

        if (NULL != *ppv)
        {
            DEBUGLOG("IHBase: Interface supported in base class\n");
            ((IUnknown *) *ppv)->AddRef();
        }

        return hRes;
    }


    STDMETHODIMP_(ULONG) NonDelegatingAddRef()
    {
#ifdef _DEBUG //Review(Unicode)
        TCHAR tchDebug[50];
        wsprintf(tchDebug, "IHBase: AddRef: %lu\n", m_cRef + 1);
        DEBUGLOG(tchDebug);
#endif

        return ++m_cRef;
    }


    STDMETHODIMP_(ULONG) NonDelegatingRelease()
    {
#ifdef _DEBUG
        TCHAR tchDebug[50];
        wsprintf(tchDebug, TEXT("IHBase: Releasing with refcount: %lu\n"), m_cRef - 1);
        DEBUGLOG(tchDebug);
#endif
        if (--m_cRef == 0L)
        {
            // free the object
            Delete this;
            return 0;
        }
        else
            return m_cRef;

    }

///// delegating IUnknown implementation
protected:
    LPUNKNOWN       m_punkOuter;    // controlling unknown
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv)
      { return m_punkOuter->QueryInterface(riid, ppv); }
    STDMETHODIMP_(ULONG) AddRef()
      { return m_punkOuter->AddRef(); }
    STDMETHODIMP_(ULONG) Release()
      { return m_punkOuter->Release(); }

///// IViewObject implementation
protected:
    IOleClientSite *m_pocs;         // on client site
    IOleInPlaceSiteWindowless *m_poipsw; // on client site

protected:

#ifndef NOIVIEWOBJECT
    virtual STDMETHODIMP Draw(DWORD dwDrawAspect, LONG lindex, void *pvAspect,
         DVTARGETDEVICE *ptd, HDC hdcTargetDev, HDC hdcDraw,
         LPCRECTL lprcBounds, LPCRECTL lprcWBounds,
         BOOL (__stdcall *pfnContinue)(ULONG_PTR dwContinue), ULONG_PTR dwContinue) = 0; // pure virtual


    STDMETHODIMP GetColorSet(DWORD dwDrawAspect, LONG lindex, void *pvAspect,
         DVTARGETDEVICE *ptd, HDC hicTargetDev, LOGPALETTE **ppColorSet)
    {
        // TODO: replace the contents of this function with real code
        // that returns the control's palette; return E_NOTIMPL if the
        // control uses only the 16 system colors

        return E_NOTIMPL;
    }


    STDMETHODIMP Freeze(DWORD dwDrawAspect, LONG lindex, void *pvAspect,
         DWORD *pdwFreeze)
    {
        return E_NOTIMPL;
    }

    STDMETHODIMP Unfreeze(DWORD dwFreeze)
    {
        return E_NOTIMPL;
    }

    STDMETHODIMP SetAdvise(DWORD dwAspects, DWORD dwAdvf, IAdviseSink *pAdvSink)
    {
        return HelpSetAdvise(dwAspects, dwAdvf, pAdvSink, &m_advise);
    }

    STDMETHODIMP GetAdvise(DWORD *pdwAspects, DWORD *pdwAdvf,
        IAdviseSink **ppAdvSink)
    {
        return HelpGetAdvise(pdwAspects, pdwAdvf, ppAdvSink, &m_advise);
    }

///// IViewObject2 implementation
protected:
    STDMETHODIMP GetExtent(DWORD dwDrawAspect, LONG lindex,
        DVTARGETDEVICE *ptd, LPSIZEL lpsizel)
    {
        DEBUGLOG("IHBase: IViewObject2::GetExtent\n");
        if (lpsizel)
        {
            switch (dwDrawAspect)
            {
                case(DVASPECT_CONTENT):
                // Intentional fallthrough
                case(DVASPECT_OPAQUE):
                // Intentional fallthrough
                case(DVASPECT_TRANSPARENT):
                {
                    lpsizel->cx = m_Size.cx;
                    lpsizel->cy = m_Size.cy;
                    return S_OK;
                }
                break;
                default:
                    return E_FAIL;
            }
        }
        else
        {
            return E_POINTER;
        }

    }


///// IViewObjectEx implementation

    STDMETHODIMP GetRect(DWORD dwAspect, LPRECTL pRect)
    {

        // This is written so that objects are assumed to be transparent
        // Opaque objects or objects which need more control should override
        // this method
        if (NULL != pRect)
        {
            switch (dwAspect)
            {
                case(DVASPECT_CONTENT):
                // Intentional fallthrough
                case(DVASPECT_TRANSPARENT):
                {
                    pRect->left = m_rcBounds.left;
                    pRect->right = m_rcBounds.right;
                    pRect->top = m_rcBounds.top;
                    pRect->bottom = m_rcBounds.bottom;
                    return S_OK;
                }
                break;
                default:
                    return DV_E_DVASPECT;
                break;
            }
        }
        else
        {
            return E_POINTER;
        }
    }

    STDMETHODIMP GetViewStatus(DWORD* pdwStatus)
    {

        if (NULL == pdwStatus)
        {
            return E_POINTER;
        }
        else
        {
            DWORD dwStatus = VIEWSTATUS_DVASPECTTRANSPARENT;

#ifdef USE_VIEWSTATUS_SURFACE
// TODO: hack for now until this makes it into the public Trident
// header files.
#define VIEWSTATUS_SURFACE 0x10
#define VIEWSTATUS_D3DSURFACE 0x20

             dwStatus = VIEWSTATUS_SURFACE | VIEWSTATUS_D3DSURFACE;
#endif // USE_VIEWSTATUS_SURFACE

            // Indicate that we are tranparent
            *pdwStatus = dwStatus;
            return S_OK;
        }
    }


    STDMETHODIMP QueryHitPoint(DWORD dwAspect, LPCRECT prcBounds,
                               POINT ptLoc, LONG lCloseHint, DWORD* pHitResult)
    {
#ifndef NOHITTESTING
        if ((NULL == pHitResult) || (NULL == prcBounds))
            return E_POINTER;

        *pHitResult = HITRESULT_OUTSIDE;

        switch (dwAspect)
        {
        case(DVASPECT_CONTENT):
        case(DVASPECT_TRANSPARENT):
            if (PtInRect(prcBounds, ptLoc))
            {
                // Are we inside ?
                *pHitResult = HITRESULT_HIT;
            }
            else // Are we near ?
            {
                SIZE size;
                RECT rcInflatedBounds = *prcBounds;

                // lCloseHint is in HIMETRIC unit - cnvert to pixels
                HIMETRICToPixels(lCloseHint, lCloseHint, &size);
                // Expand the rect
                InflateRect(&rcInflatedBounds, size.cx, size.cy);

                if (PtInRect(&rcInflatedBounds, ptLoc))
                    *pHitResult = HITRESULT_CLOSE;
            }
            return S_OK;
        default:
            return E_FAIL;
        }
#else // NOHITTESTING
        return E_NOTIMPL;
#endif // NOHITTESTING

    }

    STDMETHODIMP QueryHitRect(DWORD dwAspect, LPCRECT pRectBounds,
                              LPCRECT prcLoc, LONG lCloseHint, DWORD* pHitResult)
    {
#ifndef NOHITTESTING
        if ((pRectBounds == NULL) || (prcLoc == NULL) || (pHitResult == NULL))
            return E_POINTER;

        // For the time being, there is a hit if the object rectangle
        // intersects the container rectangle.

        RECT rcIntersection;

        *pHitResult = ::IntersectRect(&rcIntersection, pRectBounds, prcLoc)
                      ? HITRESULT_HIT
                      : HITRESULT_OUTSIDE;
        return S_OK;
#else // NOHITTESTING
        return E_NOTIMPL;
#endif // NOHITTESTING

    }

    STDMETHODIMP GetNaturalExtent(DWORD dwAspect, LONG lindex,
                                  DVTARGETDEVICE* ptd, HDC hicTargetDev,
                                  DVEXTENTINFO* pExtentInfo, LPSIZEL psizel)
    {
        DEBUGLOG("IHBase: GetNaturalExtent\n");
        return E_NOTIMPL;
    }

#endif // NOIVIEWOBJECT


///// IOleObject implementation
protected:
    STDMETHODIMP SetClientSite(IOleClientSite *pClientSite)
    {
        HRESULT hRes = S_OK;

#ifdef _DEBUG
        DEBUGLOG(TEXT("IHBase: SetClientSite\n"));
#endif

        // release the currently-held site pointers
        SafeRelease((LPUNKNOWN *)&m_pocs);
        SafeRelease((LPUNKNOWN *)&m_poipsw);
        SafeRelease((LPUNKNOWN *)&m_pContainerDispatch);
#ifdef SUPPORTONLOAD
        ReleaseContainerConnectionPoint();
#endif


        // store the new site pointers
        m_pocs = pClientSite;
        if (m_pocs != NULL)
        {
            m_pocs->AddRef();
            hRes = m_pocs->QueryInterface(IID_IOleInPlaceSiteWindowless,
                        (LPVOID *) &m_poipsw);
#ifdef _DEBUG
            // Could we get a windowless site ?
            if (FAILED(hRes))
            {
                ODS("IHBase: SetClientSite unable to get an IOleInPlaceSiteWindowless pointer.  IE 3.0 ?\n");
            }
#endif // _DEBUG

            hRes = m_pocs->QueryInterface(IID_IDispatch,
                                (LPVOID *) &m_pContainerDispatch);

            // if the control is connected to a site that supports IDispatch,
            // retrieve the ambient properties that we care about
            if (SUCCEEDED(hRes))
                OnAmbientPropertyChange(DISPID_UNKNOWN);

#ifdef SUPPORTONLOAD
            ConnectToContainerConnectionPoint();
#endif
        }

        return hRes;
    }



    STDMETHODIMP GetClientSite(IOleClientSite **ppClientSite)
    {
        if( ppClientSite )
        {
            if (m_pocs)
                m_pocs->AddRef();

            *ppClientSite = m_pocs;

            return S_OK;
        }
        return E_POINTER;
    }


    STDMETHODIMP SetHostNames(LPCOLESTR szContainerApp,
        LPCOLESTR szContainerObj)
    {
        return E_NOTIMPL;
    }


    STDMETHODIMP Close(DWORD dwSaveOption)
    {
        DEBUGLOG("IHBase: Close\n");
#ifdef SUPPORTONLOAD
        ReleaseContainerConnectionPoint();
#endif //SUPPORTONLOAD
        return S_OK;
    }


    STDMETHODIMP SetMoniker(DWORD dwWhichMoniker, IMoniker *pmk)
     {
        return E_NOTIMPL;
    }


   STDMETHODIMP GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker,
        IMoniker **ppmk)
    {
        return E_NOTIMPL;
    }


    STDMETHODIMP InitFromData(IDataObject *pDataObject, BOOL fCreation,
        DWORD dwReserved)
    {
        return E_NOTIMPL;
    }


    STDMETHODIMP GetClipboardData(DWORD dwReserved, IDataObject **ppDataObject)
    {
        return E_NOTIMPL;
    }

    // Copied from mmctl\hostlwoc\control.cpp and modified
    // Handle the OLEIVERB_INPLACEACTIVATE case of IOleObject::DoVerb
    STDMETHODIMP OnVerbInPlaceActivate(HWND hwndParent,
                                            LPCRECT lprcPosRect)
    {
        BOOL        fRedraw;
        HRESULT     hrReturn = S_OK;    // return value from this method

        ASSERT (lprcPosRect != NULL); // IE3 does this sometimes...

        // This should never fire, but just in case ...
        ASSERT(NULL != m_poipsw);

        //Review(SimonB): Do you handle the case where the container can't handle
        //Windlowless controls but can handle windowed controls? May be we are not
        //interested in this case. But I wanted to flag this - PhaniV


        // if we can go in-place active, notify container that we're doing so
        if (S_OK == m_poipsw->CanInPlaceActivate())
        {
            m_fControlIsActive = TRUE;
        }
        else
        {
            hrReturn = E_FAIL;
            goto EXIT;
        }

        if (FAILED(hrReturn = m_poipsw->OnInPlaceActivateEx(&fRedraw, ACTIVATE_WINDOWLESS)))
            goto EXIT;

        EXIT:
            return hrReturn;
    }


    STDMETHODIMP DoVerb(LONG iVerb, LPMSG lpmsg, IOleClientSite *pActiveSite,
        LONG lindex, HWND hwndParent, LPCRECT lprcPosRect)
     {
        switch (iVerb)
        {
            // Review(SimonB): Previously none of these is handled. Now at least
            // we handle Inplaceactivate. Investigate if others need be handled
            // - PhaniV

            case OLEIVERB_UIACTIVATE:
            {
                return S_OK;
            }
            break;

            case OLEIVERB_DISCARDUNDOSTATE:
            case OLEIVERB_HIDE:
            case OLEIVERB_SHOW:
            case OLEIVERB_OPEN:
                return E_NOTIMPL;
            break;

            case OLEIVERB_INPLACEACTIVATE:
            {
                HRESULT hRes = S_OK;
                // Some containers (Trident, for example) call this to give us our bounds.
                // Others (like ALX) give us our bounds through SetObjectRects

                // Make sure our site can support windowless objects

                // If make sure we actually have a site, and can activate windowless
                if ((NULL == m_poipsw) || (S_OK != m_poipsw->CanWindowlessActivate()))
                {
#ifdef _DEBUG
                    MessageBox(hwndParent,
                               TEXT("This container does not support windowless controls."),
                               TEXT("Error"),
                               MB_OK);
#endif
                    return E_NOTIMPL;
                }

                // Cache our bounds
                if (lprcPosRect)
                {
                    DEBUGLOG(TEXT("IHBase: caching bounds in DoVerb\n"));
                    CopyMemory(&m_rcBounds, lprcPosRect, sizeof(m_rcBounds));
                }

                if (SUCCEEDED(hRes = OnVerbInPlaceActivate(hwndParent, lprcPosRect)) && m_fInvalidateWhenActivated)
                {
                    ASSERT(NULL != m_poipsw);
                    m_poipsw->InvalidateRect(NULL, FALSE);
                    m_fInvalidateWhenActivated = FALSE;
                }
                return hRes;
            }
            break;

            default:
                return OLEOBJ_S_INVALIDVERB;
        }

        return S_OK;
    }


    STDMETHODIMP EnumVerbs(IEnumOLEVERB **ppEnumOleVerb)
     {
        return E_NOTIMPL;
    }


    STDMETHODIMP Update(void)
     {
        return E_NOTIMPL;
    }


    STDMETHODIMP IsUpToDate(void)
     {
        return E_NOTIMPL;
    }


    STDMETHODIMP GetUserClassID(CLSID *pClsid)
     {
        if (NULL != pClsid)
        {
            *pClsid = *temppCLSID;
        }
        else
        {
            return E_POINTER;
        }

        return S_OK;
    }

    STDMETHODIMP GetUserType(DWORD dwFormOfType, LPOLESTR *pszUserType)
    {
        /*
        Theoretically, this function should be able to just return OLE_S_USEREG and
        the caller should then call OleRegGetUserType.  However, most callers seem to
        be too lazy, so I just do it here for them
        */

        return OleRegGetUserType(*temppCLSID, dwFormOfType, pszUserType);
    }


    STDMETHODIMP SetExtent(DWORD dwDrawAspect,SIZEL *psizel)
    {
        DEBUGLOG("IHBase: IOleObject::SetExtent\n");

        if (NULL == psizel)
            return E_POINTER;

        if (DVASPECT_CONTENT == dwDrawAspect)
        {
            m_Size.cx = psizel->cx;
            m_Size.cy = psizel->cy;
            return S_OK;
        }
        else
        {
            return E_FAIL;
        }
    }

    STDMETHODIMP GetExtent(DWORD dwDrawAspect, SIZEL *psizel)
    {
        DEBUGLOG("IHBase: IOleObject::GetExtent\n");

        if (NULL == psizel)
            return E_POINTER;

        if (DVASPECT_CONTENT == dwDrawAspect)
        {
            psizel->cx = m_Size.cx ;
            psizel->cy = m_Size.cy ;
            return S_OK;
        }
        else
        {
            return E_FAIL;
        }
    }

    STDMETHODIMP Advise(IAdviseSink *pAdvSink, DWORD *pdwConnection)
     {
        DEBUGLOG("IHBase: Advise\n");
        return E_NOTIMPL;
    }


    STDMETHODIMP Unadvise(DWORD dwConnection)
     {
        DEBUGLOG("IHBase: Unadvise\n");
        return E_NOTIMPL;
    }


    STDMETHODIMP EnumAdvise(IEnumSTATDATA **ppenumAdvise)
     {
        DEBUGLOG("IHBase: EnumAdvise\n");
        return E_NOTIMPL;
    }


    STDMETHODIMP GetMiscStatus(DWORD dwAspect, DWORD *pdwStatus)
    {
        DEBUGLOG("IHBase: GetMiscStatus\n");

        if (NULL == pdwStatus)
            return E_POINTER;

        *pdwStatus = CTL_OLEMISC;
        return S_OK;
    }

    STDMETHODIMP SetColorScheme(LOGPALETTE *pLogpal)
     {
        DEBUGLOG("IHBase: SetColorScheme\n");
        return E_NOTIMPL;
    }



///// IPersistVariantIO implementation
protected:
    STDMETHODIMP InitNew()
    {
        DEBUGLOG("IHBase: InitNew\n");
        return S_OK;
    }

    STDMETHODIMP IsDirty()
    {
        DEBUGLOG("IHBase: IsDirty\n");
                // REVIEW pauld - we're currently not properly updating the
                // dirty flag diligently.  When excalibur tries to edit a control's
                // properties, the changes are not properly persisted out to
                // the page as a result (since the private save that excalibur
                // calls clears our dirty flag).  This is currently blocking authoring.
                // This is a workaround until we change the code to update the
                // dirty flag in all of the right places.
                if (!m_fDesignMode)
                {
                        return (m_fDirty) ? S_OK : S_FALSE;
                }
                else
                {
                        return S_OK;
                }
    }

    STDMETHODIMP DoPersist(IVariantIO* pvio, DWORD dwFlags) = 0; // PURE


///// IOleControl implementation
protected:
    STDMETHODIMP GetControlInfo(LPCONTROLINFO pCI)
       {
        DEBUGLOG("IHBase: GetControlInfo\n");
        return E_NOTIMPL;
    }


    STDMETHODIMP OnMnemonic(LPMSG pMsg)
       {
        DEBUGLOG("IHBase: OnMnemonic\n");
        return E_NOTIMPL;
    }


    STDMETHODIMP OnAmbientPropertyChange(DISPID dispid)
    {
        DEBUGLOG("IHBase: OnAmbientPropertyChange\n");
        // can't do anything if the container doesn't support ambient properties
        if (m_pContainerDispatch == NULL)
            return E_FAIL;

        if ((dispid == DISPID_UNKNOWN) || (dispid == DISPID_AMBIENT_USERMODE))
        {
            // assume the user mode (design vs preview/run) changed...
            VARIANT var;
            if (SUCCEEDED(
                    DispatchPropertyGet(m_pContainerDispatch, DISPID_AMBIENT_USERMODE, &var)) &&
                (var.vt == VT_BOOL) &&
                ((V_BOOL(&var) != 0) != !m_fDesignMode))
            {
                // we switched between design and preview/run mode
                m_fDesignMode = (V_BOOL(&var) == 0);
                TRACE("IHBase: m_fDesignMode=%d\n", m_fDesignMode);

                // draw or erase the grab handles
                // CtlInvalidateHandles();
            }
        }

        return S_OK;
    }

    STDMETHODIMP FreezeEvents(BOOL bFreeze)
    {
        // Although the documentation doesn't mention this, Trident seems to assume that
        // FreezeEvents is implemented on a counter system: when the counter gets to 0,
        // events are unfrozen.  ATL implements it this way, so I assume it is correct
        // (SimonB, 08-02-1997)

        if (bFreeze)
        {
            m_fEventsFrozen = TRUE;
            m_cFreezeEvents++;
        }
        else
        {
            // Count should never go below 0 ...
            ASSERT(m_cFreezeEvents > 0);

            if (m_cFreezeEvents > 0)
                m_cFreezeEvents--;

            if (0 == m_cFreezeEvents)
                m_fEventsFrozen = FALSE;
        }

#ifdef _DEBUG
        TCHAR tchString[50];
        wsprintf(tchString, TEXT("IHBase: FreezeEvents (%lu)\n"), m_cFreezeEvents);
        DEBUGLOG(tchString);
#endif

        return S_OK;
    }



///// IConnectionPointContainer implementation
protected:
    IConnectionPointHelper *m_pconpt; // our single connection point
protected:
    STDMETHODIMP EnumConnectionPoints(LPENUMCONNECTIONPOINTS *ppEnum)
    {
        DEBUGLOG("IHBase: EnumConnectionPoints\n");
        ASSERT(m_pconpt != NULL);
        return m_pconpt->EnumConnectionPoints(ppEnum);
    }

    STDMETHODIMP FindConnectionPoint(REFIID riid, LPCONNECTIONPOINT *ppCP)
    {
        DEBUGLOG("IHBase: FindConnectionPoint\n");
        ASSERT(m_pconpt != NULL);
        return m_pconpt->FindConnectionPoint(riid, ppCP);
    }

   //IOleInplaceObjectWindowless implementation
protected:
    STDMETHODIMP GetWindow(HWND    *phwnd)
    {
        DEBUGLOG("IHBase: GetWindow\n");
        // Review(SimonB): If we handle windowed case, we need to return the proper hwnd for that case - PhaniV
        return    E_FAIL;
    }

    STDMETHODIMP ContextSensitiveHelp( BOOL fEnterMode)
    {
        DEBUGLOG("IHBase: ContextSensitiveHelp\n");
        // Who cares about context sensitive help?
        // Review(SimonB): Think about context sensitive help later - PhaniV
        return    E_NOTIMPL;
    }

    STDMETHODIMP InPlaceDeactivate(void)
    {
        DEBUGLOG("IHBase: InPlaceDeactivate\n");

        if (m_poipsw)
            m_fControlIsActive = (!SUCCEEDED(m_poipsw->OnInPlaceDeactivate()));

        return S_OK;
    }

    STDMETHODIMP UIDeactivate(void)
    {
        DEBUGLOG("IHBase: UIDeactivate\n");
        return S_OK;
    }

    STDMETHODIMP SetObjectRects(LPCRECT lprcPosRect, LPCRECT lprcClipRect)
    {
        DEBUGLOG("IHBase: SetObjectRects\n");
        // Some containers (ALX, for example) call this to give us our bounds.
        // Others (like Trident) give us our bounds through DoVerb
        if ((NULL != lprcPosRect) && (NULL != lprcClipRect))
        {
        // Cache our bounds and clipping rectangle
#ifdef _DEBUG //Review(Unicode)
            TCHAR tchDebug[100];
            LPCRECT prc = lprcPosRect;
            wsprintf(tchDebug, "IHBase: lprcPosRect: top: %lu left: %lu bottom: %lu right: %lu\n",
                prc->top,
                prc->left,
                prc->bottom,
                prc->right);
            DEBUGLOG(tchDebug);
            prc = lprcClipRect;
            wsprintf(tchDebug, "IHBase: lprcClipRect: top: %lu left: %lu bottom: %lu right: %lu\n",
                prc->top,
                prc->left,
                prc->bottom,
                prc->right);
            DEBUGLOG(tchDebug);
#endif
            m_rcBounds = *lprcPosRect;
            m_rcClipRect = *lprcClipRect;
            return S_OK;
        }
        else
        {
            return E_POINTER;
        }
    }

    STDMETHODIMP ReactivateAndUndo(void)
    {
        DEBUGLOG("IHBase: ReactivateAndUndo\n");
        return S_OK;
    }

    STDMETHODIMP OnWindowMessage(UINT msg, WPARAM wParam, LPARAM lparam, LRESULT *plResult)
    {
        DEBUGLOG("IHBase: OnWindowMessage\n");
        return S_FALSE; // We did not process the message
    }

    STDMETHODIMP GetDropTarget(IDropTarget **ppDropTarget)
    {
        DEBUGLOG("IHBase: GetDropTarget\n");
        return E_NOTIMPL;
    }


protected:
    LPTYPEINFO m_pTypeInfo;
    LPTYPELIB m_pTypeLib;

    ////// IProvideClassInfo
    STDMETHODIMP GetClassInfo(LPTYPEINFO *ppTI)
    {
        DEBUGLOG("IHBase: GetClassInfo\n");
        // Make sure the typelib is loaded
        if (NULL == m_pTypeLib)
        {
            HRESULT hRes;

            // Load the typelib
            hRes = LoadTypeInfo(&m_pTypeInfo, &m_pTypeLib, *temppIID, *temppLIBID, NULL);

            if (FAILED(hRes))
            {
                DEBUGLOG("IHBase: Unable to load typelib\n");
                m_pTypeInfo = NULL;
                m_pTypeLib = NULL;
            }
        }

        ASSERT(m_pTypeLib != NULL);

        return HelpGetClassInfoFromTypeLib(ppTI, *temppCLSID, m_pTypeLib, NULL, 0);
    }

#ifdef USEOBJECTSAFETY
    //////// IObjectSafety implementation
protected:
    STDMETHODIMP GetInterfaceSafetyOptions(
            /* [in] */ REFIID riid,
            /* [out] */ DWORD __RPC_FAR *pdwSupportedOptions,
            /* [out] */ DWORD __RPC_FAR *pdwEnabledOptions)
    {
#ifdef _DEBUG
        if (g_fLogDebugOutput)
        {
            char ach[200];
            TRACE("IHBase::GetInterfaceSafetyOptions('%s')\n", DebugIIDName(riid, ach));
        }
#endif

        IUnknown *punk = NULL;
        *pdwSupportedOptions = 0;
        *pdwEnabledOptions = 0;

        // Check that we support the interface
        HRESULT hRes = QueryInterface(riid, (LPVOID *) &punk);

        if (SUCCEEDED(hRes))
        {
            // Let go of the object
            punk->Release();

            // We support both options for all interfaces we support
            *pdwSupportedOptions = *pdwEnabledOptions = INTERFACESAFE_FOR_UNTRUSTED_CALLER |
                                                        INTERFACESAFE_FOR_UNTRUSTED_DATA;
            hRes = S_OK;
        }

        return hRes;
    }

    STDMETHODIMP SetInterfaceSafetyOptions(
            /* [in] */ REFIID riid,
            /* [in] */ DWORD dwOptionSetMask,
            /* [in] */ DWORD dwEnabledOptions)
    {
#ifdef _DEBUG
        if (g_fLogDebugOutput)
        {
            char ach[200];
            TRACE("IHBase::SetInterfaceSafetyOptions('%s')\n", DebugIIDName(riid, ach));
        }
#endif

        IUnknown *punk = NULL;
        const dwSupportedBits =    INTERFACESAFE_FOR_UNTRUSTED_CALLER |
                                INTERFACESAFE_FOR_UNTRUSTED_DATA;

        // Check that we support the interface
        HRESULT hRes = QueryInterface(riid, (LPVOID *) &punk);

        if (SUCCEEDED(hRes))
        {
            // Let go of the object
            punk->Release();

            // Since we support all options, we just return S_OK, assuming we support
            // the interface


            // Do we support the bits we are being asked to set ?
            if (!(dwOptionSetMask & ~dwSupportedBits))
            {
                // All the flags we are being asked to set are supported, so
                // now make sure we aren't turning off something we do support

                // Ignore any bits we support which the mask isn't interested in
                dwEnabledOptions &= dwSupportedBits;

                if ((dwEnabledOptions & dwOptionSetMask) == dwOptionSetMask)
                    hRes = S_OK;
                else
                    hRes = E_FAIL;
            }
            else // dwOptionSetMask & ~dwSupportedBits
            {
                // We are being asked to set bits we don't support
                hRes = E_FAIL;
            }

        }

        return hRes;
    }

#endif // USEOBJECTSAFETY
    // ISpecifyPropertyPages implementation

protected:
#ifdef _DESIGN
    STDMETHODIMP GetPages (CAUUID *pPages)
    {
        return E_NOTIMPL;
    }
#endif //_DESIGN

    // CIHBaseOnLoad implementation
#ifdef SUPPORTONLOAD

private:
    void ReleaseContainerConnectionPoint()
    {
        if (m_pcLUDispatch)
        {
            ASSERT(m_pContainerConPt != NULL);
            m_pContainerConPt->Unadvise( m_dwWindowEventConPtCookie );
            SafeRelease((LPUNKNOWN *)&m_pContainerConPt);
            Delete m_pcLUDispatch;
            m_pcLUDispatch = NULL;
        }
    }


    BOOL ConnectToContainerConnectionPoint()
    {
            // Get a connection point to the container
        LPUNKNOWN lpUnk = NULL;
        LPOLECONTAINER pContainer = NULL;
        IConnectionPointContainer* pCPC = NULL;
        IHTMLDocument *pDoc = NULL;
        LPDISPATCH pDisp = NULL;
        BOOL fRet = FALSE;
        HRESULT hRes = S_OK;

        // Get the container
        if (SUCCEEDED(m_pocs->GetContainer(&pContainer)))
        {
            ASSERT (pContainer != NULL);
            // Now get the document
            if (SUCCEEDED(pContainer->QueryInterface(IID_IHTMLDocument, (LPVOID *)&pDoc)))
            {
                // Get the scripting dispatch on the document
                ASSERT (pDoc != NULL);
                hRes = pDoc->get_Script(&pDisp);
                if (SUCCEEDED(hRes))
                {
                    ASSERT (pDisp != NULL);
                    // Now get the connection point container
                    hRes = pDisp->QueryInterface(IID_IConnectionPointContainer, (LPVOID *)&pCPC);
                    if (SUCCEEDED(hRes))
                    {
                        ASSERT (pCPC != NULL);
                        // And get the connection point we want
                        hRes = pCPC->FindConnectionPoint( DIID_HTMLWindowEvents, &m_pContainerConPt );
                        if (SUCCEEDED(hRes))
                        {
                            ASSERT( m_pContainerConPt != NULL );
                            // Now we advise the Connection Point of who to talk to
                            m_pcLUDispatch = New CLUDispatch(this, m_punkOuter);
                            hRes = m_pContainerConPt->Advise( m_pcLUDispatch, &m_dwWindowEventConPtCookie );
                            if (SUCCEEDED(hRes))
                                fRet = TRUE;
                        }
                        pCPC->Release();
                    }
                    pDisp->Release();
                }
                pDoc->Release();
            }
            pContainer->Release();
        }

        return fRet;
    }


public:
    void OnWindowLoad() { return; }
    void OnWindowUnload() { return; }

#endif SUPPORTONLOAD


};

#endif // __IHBASE_H__

// End of File ihbase.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\ihbase\parser.cpp ===
#include "..\ihbase\precomp.h"
#include "..\ihbase\debug.h"
#include "..\mmctl\inc\ochelp.h"
#include <ihammer.h>
#include "strwrap.h"
#include "parser.h"
#include "ctstr.h"
#include <locale.h>

/*==========================================================================*/

BOOL CLineParser::InitLine(BOOL fCompactString)
{
    m_iOffset = 0;
    m_pszLine = m_tstrLine.psz();
    m_tchDelimiter = TEXT(';');

    if (NULL != m_pszLine)
    {
        if (fCompactString)
            CompactString();
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

/*==========================================================================*/

void CLineParser::CompactString()
{
    // Strip spaces, tabs, CR and LF in-place
    int i, j;

    for (i = 0, j = 0; i < m_tstrLine.Len(); i++)
    {
        if (!IsJunkChar(m_pszLine[i]))
            m_pszLine[j++] = m_pszLine[i];
    }

    // Terminate the string
    m_pszLine[j] = TEXT('\0');

    // And get the new length
    m_tstrLine.ResetLength();
}

/*==========================================================================*/

    // Constructors and destructors
CLineParser::CLineParser(LPSTR pszLineA, BOOL fCompactString):
    m_tstrLine(pszLineA)
{
    InitLine(fCompactString);
}

/*==========================================================================*/

CLineParser::CLineParser(LPWSTR pwszLineW, BOOL fCompactString):
    m_tstrLine(pwszLineW)
{
    InitLine(fCompactString);
}

/*==========================================================================*/

CLineParser::CLineParser()
{
    InitLine(FALSE);
}

/*==========================================================================*/

CLineParser::~CLineParser()
{
}

/*==========================================================================*/

BOOL CLineParser::SetNewString(LPSTR pszLineA, BOOL fCompactString)
{
    m_tstrLine.SetString(pszLineA);
    return InitLine(fCompactString);
}

/*==========================================================================*/

BOOL CLineParser::SetNewString(LPWSTR pszLineW, BOOL fCompactString)
{
    m_tstrLine.SetString(pszLineW);
    return InitLine(fCompactString);
}

/*==========================================================================*/

HRESULT CLineParser::GetFieldDouble(double *pdblRes, BOOL fAdvance)
{
    ASSERT (pdblRes != NULL);
    HRESULT hr;

    *pdblRes = 0.0f;
    setlocale(LC_NUMERIC, "English");
    hr = GetField(TEXT("%lf"), pdblRes, fAdvance);
    setlocale(LC_ALL, "");

    return hr;

}

/*==========================================================================*/

HRESULT CLineParser::GetFieldInt(int *piRes, BOOL fAdvance)
{
    ASSERT (piRes != NULL);

    *piRes = 0;
    return GetField(TEXT("%li"), piRes, fAdvance);
}

/*==========================================================================*/

HRESULT CLineParser::GetFieldUInt(unsigned int *piRes, BOOL fAdvance)
{
    ASSERT (piRes != NULL);

    *piRes = 0;
    return GetField(TEXT("%lu"), piRes, fAdvance);
}

/*==========================================================================*/

HRESULT CLineParser::GetFieldString(LPTSTR pszRes, BOOL fAdvance)
{
    ASSERT (pszRes != NULL);

    *pszRes = 0;
    return GetField(TEXT("%s"), pszRes, fAdvance);
}

/*==========================================================================*/

HRESULT CLineParser::GetField(LPCTSTR pszFormat, LPVOID pRes, BOOL fAdvance)
{
    int iRes = 0;

    // Find the next delimiter, and change it to a NULL
    LPTSTR pszToken = &m_pszLine[m_iOffset];
    BOOL fResetDelimiter = FALSE;

    if ( IsEndOfString() )
        return S_FALSE;

    while ( (*pszToken) && (*pszToken != m_tchDelimiter) )
        pszToken++;

    if (*pszToken)
    {
        fResetDelimiter = TRUE;
        *pszToken = 0;
    }

    iRes = CStringWrapper::Sscanf1(&m_pszLine[m_iOffset], pszFormat, pRes);

    if (fResetDelimiter)
        *pszToken = m_tchDelimiter;

    if (fAdvance)
    {
        m_iOffset += (DWORD) (pszToken - &m_pszLine[m_iOffset]);
        
        if (fResetDelimiter)
            m_iOffset++;

    }

    if (1 == iRes)
    {
        if (m_pszLine[m_iOffset] != 0)
            return S_OK;
        else
            return S_FALSE;
    }
    else
    {
        return E_FAIL;
    }
}

/*==========================================================================*/

BOOL CLineParser::SeekTo(int iNewPos)
{
    if (iNewPos < m_tstrLine.Len())
    {
        m_iOffset = iNewPos;
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

/*==========================================================================*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\ihbase\precomp.h ===
// precomp.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently


#include <windows.h>
#include <mmsystem.h> // for timeSetEvent()
#include <tchar.h>
#include <oleidl.h>
#include <olectl.h>
#include "..\mmctl\inc\mmctl.h"

// general globals
extern HINSTANCE    g_hinst;        // DLL instance handle
extern ULONG        g_cLock;        // DLL lock count

#ifdef _DEBUG
#define ODS(X) OutputDebugString(X)
#else
#define ODS(X)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\ihbase\precomp.cpp ===
// precomp.cpp : source file that includes just the standard includes
//  precomp.pch will be the pre-compiled header
//  precomp.obj will contain the pre-compiled type information

#include "..\ihbase\precomp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\ihbase\timemark.h ===
/*++

Module:
	timemark.h

Description:
	Handles parsing of AddTimeMarkerTags

Author:
	IHammer Team (simonb)

Created:
	06-03-1997

--*/

#include "ctstr.h"
#include "drg.h"
#include "memlayer.h"
#include "strwrap.h"

#ifndef __TIMEMARK_H__
#define __TIMEMARK_H__

class CTimeMarker
{
public:
    CTimeMarker* m_pnext;

	double m_dblTime;
	BSTR  m_pwszMarkerName;
    boolean m_bAbsolute;

public:
    void Sort(CTimeMarker** pptm)
    {
        while (*pptm != NULL && (*pptm)->m_dblTime < m_dblTime) {
            pptm = &((*pptm)->m_pnext);
        }

        m_pnext = *pptm;
        *pptm = this;
    }

    CTimeMarker(CTimeMarker** pptm, double dblTime, LPWSTR pwszName, boolean bAbsolute = true):
        m_dblTime(dblTime),
        m_bAbsolute(bAbsolute)
	{
        m_pwszMarkerName = New WCHAR [lstrlenW(pwszName) + 1];
        
        if (m_pwszMarkerName)
            CStringWrapper::WStrcpy(m_pwszMarkerName, pwszName);

        Sort(pptm);
	}

    ~CTimeMarker()
    {
        if (m_pwszMarkerName)
            Delete [] m_pwszMarkerName;
    }

};

#define ISINVALIDTIMEMARKER(X) (NULL != X.m_tstrMarkerName.psz())

typedef CPtrDrg<CTimeMarker> CTimeDrg;

HRESULT ParseTimeMarker(IVariantIO *pvio, int iLine, CTimeMarker **ppTimeMarker, CTimeMarker** ppTMList);
HRESULT WriteTimeMarker(IVariantIO *pvio, int iLine, CTimeMarker *pTimeMarker);

typedef void (*PFNFireMarker)(IConnectionPointHelper* pconpt, CTimeMarker* pmarker, boolean bPlaying);
void FireMarkersBetween(
    IConnectionPointHelper* pconpt,
    CTimeMarker* pmarkerFirst,
    PFNFireMarker pfn,
    double start,
    double end,
    double dblInstanceDuration,
    boolean bPlaying
);


#endif // __TIMEMARK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\ihbase\timemark.cpp ===
/*++

Module:
	timemark.cpp

Description:
	Handles parsing of AddTimeMarkerTags

Author:
	IHammer Team (simonb)

Created:
	06-03-1997

--*/
#include "precomp.h"
#include "..\mmctl\inc\ochelp.h"
#include "debug.h"
#include <ctstr.h>
#include <drg.h>
#include <memlayer.h>
#include "timemark.h"
#include "parser.h"


HRESULT ParseTimeMarker(IVariantIO *pvio, int iLine, CTimeMarker **ppTimeMarker, CTimeMarker** ppTMList)
{
	ASSERT (ppTimeMarker);
	ASSERT (pvio);

	*ppTimeMarker = NULL;
	
	
	char rgchTagName[20]; // Construct tag name in here (ANSI)
	BSTR bstrLine = NULL;
	HRESULT hRes = S_OK;
	
	double dblTime = 0.0f;
	LPTSTR pszMarkerName = NULL;
	CLineParser parser;

	pszMarkerName = NULL;
	

	wsprintf(rgchTagName, "AddTimeMarker%lu", iLine);
	hRes = pvio->Persist(0,
		rgchTagName, VT_BSTR, &bstrLine,
		NULL);

	if (S_OK == hRes) // Read in the tag
	{
		parser.SetNewString(bstrLine);
		SysFreeString (bstrLine);
        parser.SetCharDelimiter(TEXT(','));

		if (parser.IsValid())
		{
			hRes = parser.GetFieldDouble(&dblTime);
			if (S_OK == hRes)
			{
				// Allocate space of at least the remaining length of the tag
				pszMarkerName = New TCHAR [lstrlen(parser.GetStringPointer(TRUE)) + 1];

				if (pszMarkerName)
				{
					// Get the string
					hRes = parser.GetFieldString(pszMarkerName);
					if (SUCCEEDED(hRes))
					{
                        bool fAbsolute = true;
                        // Is there an absolute/relative parameter ?
                        if (S_OK == hRes)
                        {
                            // Initialise to a non-zero value
                            int iTemp = 1;
                            hRes = parser.GetFieldInt(&iTemp);
                            
                            // 0 is the only thing we consider
                            if (SUCCEEDED(hRes) && (0 == iTemp))
                                fAbsolute = false;
                        }

                        // Construct a TimeMarker object
                        if (SUCCEEDED(hRes))
                        {
                            CTStr tstr;
                            tstr.SetStringPointer(pszMarkerName);
                            LPWSTR pszwMarkerName = tstr.pszW();

                            if (pszwMarkerName)
                            {
                                *ppTimeMarker = New CTimeMarker(ppTMList, dblTime, pszwMarkerName, fAbsolute);
                                Delete [] pszwMarkerName;
                            }
                            else
                            {
                                hRes = E_OUTOFMEMORY;
                            }

                            tstr.SetStringPointer(NULL, FALSE);

						    // Test for valid marker
						    if ( (NULL == *ppTimeMarker) || ((*ppTimeMarker)->m_pwszMarkerName == NULL) )
						    {
							    hRes = E_FAIL;
							    if (NULL == *ppTimeMarker)
								    Delete *ppTimeMarker;
						    }
                        }
					}
				}
				else
				{
					// Couldn't allocate memory for the marker name
					hRes = E_OUTOFMEMORY;
				}

				if (!parser.IsEndOfString())
				{
					hRes = E_FAIL;
				}
				else if (S_FALSE == hRes)
				{
					// S_FALSE means we tried to read beyond the end of a string
					hRes = S_OK;
				}

			}

		}
		else
		{
			// Only reason parser isn't valid is if we don't have memory
			hRes = E_OUTOFMEMORY;
		}
		
#ifdef _DEBUG
		if (E_FAIL == hRes)
		{
			TCHAR rgtchErr[100];
			wsprintf(rgtchErr, TEXT("SoundCtl: Error in AddFrameMarker%lu \n"), iLine);
			DEBUGLOG(rgtchErr);
		}
#endif

	}

	// Free up the temporary string
	if (NULL != pszMarkerName)
		Delete [] pszMarkerName;

	return hRes;
}



HRESULT WriteTimeMarker(IVariantIO *pvio, int iLine, CTimeMarker *pTimeMarker)
{
	ASSERT (pTimeMarker);
	ASSERT (pvio);

	if ( (NULL == pvio) || (NULL == pTimeMarker) )
		return E_POINTER;

	HRESULT hRes = S_OK;

	char rgchTagnameA[20]; // Construct tag name in here (ANSI)
	LPTSTR pszValue = NULL;
	
	wsprintfA(rgchTagnameA, "AddTimeMarker%lu", iLine++);

	// Allocate a string the length of the Marker name, + 20 for the time and 
	// possible relative/absolute indicator
	pszValue = New TCHAR[lstrlenW(pTimeMarker->m_pwszMarkerName) + 20];
	if (NULL != pszValue)
	{
        CTStr tstr(pTimeMarker->m_pwszMarkerName);
		
		int iAbsolute = (pTimeMarker->m_bAbsolute) ? 1 : 0;
		CStringWrapper::Sprintf(pszValue, TEXT("%.6lf,%s,%lu"), pTimeMarker->m_dblTime, tstr.psz(), iAbsolute);

#ifdef _UNICODE
		bstrValue = SysAllocString(pszValue);

		if (bstrValue != NULL)
		{
			hRes = pvio->Persist(NULL,
				rgchTagnameA, VT_BSTR, &bstrValue,
				NULL);
		}
		else
		{
			hRes = E_OUTOFMEMORY;
		}
		
		SysFreeString(bstrValue);
#else
		hRes = pvio->Persist(NULL,
			rgchTagnameA, VT_LPSTR, pszValue,
			NULL);
#endif
		Delete [] pszValue;

		// pvio->Persist returns S_FALSE when it has successfully written the property
		// S_OK would imply that the variable we passed in was changed
		if (S_FALSE == hRes)
			hRes = S_OK;
	}
	else
	{
		hRes = E_OUTOFMEMORY;
	}

	return hRes;
}
	
/*==========================================================================*/

void FireMarkersBetween(
    IConnectionPointHelper* pconpt,
    CTimeMarker* pmarkerFirst,
    PFNFireMarker pfnFireMarker,
    double start,
    double end,
    double dblInstanceDuration,
    boolean bPlaying
) {
    if (start >= end)
        return;

    int startIndex = (int)(start / dblInstanceDuration);
    int endIndex   = (int)(  end / dblInstanceDuration);

    double startTime = start - startIndex * dblInstanceDuration;
    double endTime   = end   -   endIndex * dblInstanceDuration;

    CTimeMarker* pmarker;

    if (startIndex == endIndex) {
        pmarker = pmarkerFirst;
        while (pmarker) {
            if (!pmarker->m_bAbsolute) {
                if (   (pmarker->m_dblTime == 0 && startTime == 0)
                    || (pmarker->m_dblTime > startTime && pmarker->m_dblTime <= endTime)
                ) {
                    pfnFireMarker(pconpt, pmarker, bPlaying);
                }
            }
            pmarker = pmarker->m_pnext;
        }
    } else {
        //
        // fire all the events in the first instance
        //

        pmarker = pmarkerFirst;
        while (pmarker) {
            if (!pmarker->m_bAbsolute) {
                if (   (pmarker->m_dblTime == 0 && startTime == 0)
                    || (pmarker->m_dblTime > startTime && pmarker->m_dblTime <= dblInstanceDuration)
                ) {
                    pfnFireMarker(pconpt, pmarker, bPlaying);
                }
            }
            pmarker = pmarker->m_pnext;
        }

        //
        // fire all the events in the middle instances
        //

        for(int index = startIndex + 1; index < endIndex; index++) {
            pmarker = pmarkerFirst;
            while (pmarker) {
                if (!pmarker->m_bAbsolute) {
                    if (pmarker->m_dblTime <= dblInstanceDuration) {
                        pfnFireMarker(pconpt, pmarker, bPlaying);
                    }
                }
                pmarker = pmarker->m_pnext;
            }
        }

        //
        // fire all the events in the last instance
        //

        pmarker = pmarkerFirst;
        while (pmarker) {
            if (!pmarker->m_bAbsolute && pmarker->m_dblTime <= endTime) {
                pfnFireMarker(pconpt, pmarker, bPlaying);
            }

            pmarker = pmarker->m_pnext;
        }
    }

    //
    // handle absolute markers
    //

    pmarker = pmarkerFirst;
    while (pmarker) {
        if (pmarker->m_bAbsolute) {
            if (   (pmarker->m_dblTime == 0 && start == 0)
                || (pmarker->m_dblTime > start && pmarker->m_dblTime <= end)
            ) {
               pfnFireMarker(pconpt, pmarker, bPlaying);
            }
        }
        pmarker = pmarker->m_pnext;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\ihbase\stringid.h ===
/*++

Module:
	stringid.h

Author:
	IHammer Team (SimonB)

Created:
	10-01-1996

Description:
	Resource string ID's for standard (expected) resources

++*/

#ifndef _STRINGID_H_

#define IDS_IHCTL_BASE 1024

#define IDS_IHCTL_GETUSERTYPE (IDS_IHCTL_BASE + 0) // IOleObject::GetUserType


#define _STRINGID_H_
#endif //_STRINGID_H_

// End of File stringid.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\ihbase\parser.h ===
#ifndef __LINEPARSER_H__
#define __LINEPARSER_H__

#include "..\ihbase\precomp.h"
#include "ctstr.h"

inline BOOL IsJunkChar(TCHAR tchChar)
{
    return (tchChar == TEXT(' ')) || (tchChar == TEXT('\t')) || (tchChar == TEXT('\n')) || (tchChar == TEXT('\r'));
}

class CLineParser
{

public:

	// Constructors and destructors
	CLineParser(LPSTR pszLineA, BOOL fCompactString = TRUE);
	CLineParser(LPWSTR pwszLineA, BOOL fCompactString = TRUE);

	CLineParser();

	~CLineParser();

	BOOL SetNewString(LPSTR pszLineA, BOOL fCompactString = TRUE);
	BOOL SetNewString(LPWSTR pszLineW, BOOL fCompactString = TRUE);

	// Access members

	HRESULT GetFieldDouble(double *pdblRes, BOOL fAdvance = TRUE);
	HRESULT GetFieldInt(int *piRes, BOOL fAdvance = TRUE);
	HRESULT GetFieldUInt(unsigned int *piRes, BOOL fAdvance = TRUE);
	HRESULT GetFieldString(LPTSTR pszRes, BOOL fAdvance = TRUE);
	
	LPTSTR GetStringPointer(BOOL fUseOffset = FALSE) 
	{  return m_pszLine ? &m_pszLine[fUseOffset ? m_iOffset : 0] : NULL; }


	BOOL IsEndOfString() { return (m_iOffset == m_tstrLine.Len()); }
	void Reset() {	m_iOffset = 0;	}
	int GetPos() { 	return m_iOffset; }
	BOOL IsValid() { return (NULL != m_pszLine); }
	BOOL SeekTo(int iNewPos);

	void SetCharDelimiter(TCHAR tchDelimiter) { m_tchDelimiter = tchDelimiter; }

private:

	CTStr m_tstrLine;
	LPTSTR m_pszLine;
	int m_iOffset;
	TCHAR m_tchDelimiter;

	void CompactString();
	BOOL InitLine(BOOL fCompactString);

	HRESULT GetField(LPCTSTR pszFormat, LPVOID pRes, BOOL fAdvance);

};

#endif // __LINEPARSER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\ihbase\unreg.cpp ===
/*++

Module: 
	unreg.cpp

Author: 
	IHammer Team (SimonB)

Created: 
	October 1996

Description:
	Unregisters a typelib if the functionality is available.  Fails cleanly if not

History:
	01-18-1997	Added optimization pragmas
	01-11-1997	Changed calling convention for UNREGPROC, bug #169
	10-01-1996	Created

++*/

#include "..\ihbase\precomp.h" 
#include "unreg.h"

// Add these later
// #pragma optimize("a", on) // Optimization: assume no aliasing

typedef HRESULT (__stdcall *UNREGPROC)(REFGUID, WORD, WORD, LCID, SYSKIND);

HRESULT UnRegisterTypeLibEx(REFGUID guid, 
						  WORD wVerMajor, 
						  WORD wVerMinor, 
						  LCID lcid, 
						  SYSKIND syskind)
{
HMODULE hMod;
UNREGPROC procUnReg;
HRESULT hr = S_FALSE;

	hMod = LoadLibrary(TEXT("OLEAUT32.DLL"));
	if (NULL == hMod)
		return S_FALSE;

	procUnReg = (UNREGPROC)GetProcAddress(hMod, TEXT("UnRegisterTypeLib"));
	if (procUnReg)
	{
		hr = procUnReg(guid, wVerMajor, wVerMinor, lcid, syskind);
	}
	else
	{
		//
		// Probably running on standard Win95, no new OLEAUT32.DLL, so the 
		// function isn't available - return, but say that we succeeded 
		// so that the rest of unreg goes cleanly
		//

		hr = S_OK;
	}
	
	FreeLibrary (hMod);
	return hr;
}
	
// Add these later
// #pragma optimize("a", off) // Optimization: assume no aliasing

// End of file (unreg.cpp)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\ihbase\unreg.h ===
/*++

Module: 
	unreg.cpp

Author: 
	IHammer Team (SimonB)

Created: 
	October 1996

Description:
	Header for UnRegisterTypeLibEx 

History:
	10-01-1996	Created

++*/

#ifndef _UNREG_H_

#ifdef __cplusplus
extern "C" {
#endif

HRESULT UnRegisterTypeLibEx(REFGUID guid, 
						  unsigned short wVerMajor, 
						  unsigned short wVerMinor, 
						  LCID lcid, 
						  SYSKIND syskind);

#ifdef __cplusplus
}
#endif

#define _UNREG_H_
#endif

// End of file: unreg.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\ihbase\utils.cpp ===
#include "precomp.h"
#include "debug.h"
#include "utils.h"

// Madness to prevent ATL from using CRT
#define _ATL_NO_DEBUG_CRT
#define _ASSERTE(x) ASSERT(x)
#include <atlbase.h>

/*++

Function:
	BSTRtoWideChar

Description:
	Converts a BSTR to a UNICODE string.  Truncates to fit destination 
	if necessary

Author:
	SimonB

History:
	10/01/1996	Created

++*/

// Add these later
// #pragma optimize("a", on) // Optimization: assume no aliasing

/////////////////////////////////////////////////////////////////////////////
// Smart Pointer helpers

namespace ATL
{

ATLAPI_(IUnknown*) AtlComPtrAssign(IUnknown** pp, IUnknown* lp)
{
	if (lp != NULL)
		lp->AddRef();
	if (*pp)
		(*pp)->Release();
	*pp = lp;
	return lp;
}

ATLAPI_(IUnknown*) AtlComQIPtrAssign(IUnknown** pp, IUnknown* lp, REFIID riid)
{
	IUnknown* pTemp = *pp;
	lp->QueryInterface(riid, (void**)pp);
	if (pTemp)
		pTemp->Release();
	return *pp;
}
};

BOOL BSTRtoWideChar(BSTR bstrSource, LPWSTR pwstrDest, int cchDest)
{

// Copies the BSTR in bstrSource to pwstrDest, truncating to make it
// fit in cchDest characters

	int iNumToCopy, iStrLen;
	
	//
	// Make sure we have been passed a valid string
	//

	if (NULL == bstrSource)
		return TRUE;

	ASSERT(pwstrDest != NULL);

	iStrLen = lstrlenW(bstrSource);
	
	// We have enough room to store the whole string ?
	if(iStrLen < cchDest)
		iNumToCopy = iStrLen;
	else 
		iNumToCopy = (cchDest - 1);

	// Copy the BSTR
	CopyMemory(pwstrDest, bstrSource, iNumToCopy * sizeof(WCHAR));
	
	// Insert a terminating \0
	pwstrDest[iNumToCopy] = L'\x0';

	return TRUE;
}


/*++

Function:
	LoadTypeInfo

Description:
	Loads a typelib, first trying it's registered location, followed by
	a filename

Author:
	SimonB 

History:
	10/19/1996	Added ITypeLib parameter
	10/01/1996	Created (from the Win32 SDK "Hello" sample)

++*/


HRESULT LoadTypeInfo(ITypeInfo** ppTypeInfo, ITypeLib** ppTypeLib, REFCLSID clsid, GUID libid, LPWSTR pwszFilename)
{                          
    HRESULT hr;
    LPTYPELIB ptlib = NULL;
	LPTYPEINFO ptinfo = NULL;
	LCID lcid = 0;

	
	// Make sure we have been given valid pointers
	ASSERT(ppTypeInfo != NULL);
	ASSERT(ppTypeLib != NULL);

	// Initialise pointers
    *ppTypeInfo = NULL;     
	*ppTypeLib = NULL;
    
    //
	// Load Type Library. 
	
	// First get the default LCID and try that
	
	lcid = GetUserDefaultLCID();
	hr = LoadRegTypeLib(libid, 1, 0, lcid, &ptlib);
	
	if (TYPE_E_CANTLOADLIBRARY == hr) // We need to try another LCID
	{
		lcid = GetSystemDefaultLCID(); 	// Try the system default
	    hr = LoadRegTypeLib(libid, 1, 0, lcid, &ptlib);
	}

    if ((FAILED(hr)) && (NULL != pwszFilename)) 
    {   
        // If it wasn't a registered typelib, try to load it from the 
		// path (if a filename was provided).  If this succeeds, it will 
		// have registered the type library for us for the next time.  

        hr = LoadTypeLib(pwszFilename, &ptlib); 
	}

	if(FAILED(hr))        
		return hr;   

    // Get type information for interface of the object.      
    hr = ptlib->GetTypeInfoOfGuid(clsid, &ptinfo);
    if (FAILED(hr))  
    { 
        ptlib->Release();
        return hr;
    }   

    
    *ppTypeInfo = ptinfo;
	*ppTypeLib = ptlib;

	// NOTE:  (SimonB, 10-19-1996)
	// It is unnecessary to call ptlib->Release, since we are copying the 
	// pointer to *ppTypeLib. So rather than AddRef that pointer and Release the pointer 
	// we copy it from, we just eliminate both
	
	return NOERROR;
} 


// Add these later
// #pragma optimize("a", off) // Optimization: assume no aliasing

// End of file (utils.cpp)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\ihbase\dmpguid\dmpguids.cpp ===
// Lists the Data1 member of a variety of GUIDS
#include <windows.h>
#include <initguid.h> // once per build
#include "..\precomp.h"
#include "..\..\mmctl\inc\ochelp.h"
#include "objsafe.h"
#include "docobj.h"
#include <stdio.h>

#define DUMPGUID(I,IID) \
	WriteItem(pfHeader, pfCase, I, IID);\
	rgdwIID[i] = IID.Data1; \
	i++;

void WriteToHeader(FILE *pFile, LPSTR pszInterface, GUID riid)
{
	fprintf(pFile, "#define %s_DATA1 0x%lx\r\n", pszInterface, riid.Data1);
}

void WriteToSwitch(FILE *pFile, LPSTR pszInterface)
{
	TCHAR rgchFormat[] = TEXT("case %s_DATA1:\r\n{\r\nif (IsShortEqualIID(riid,%s))\r\n");
	fprintf(pFile, rgchFormat, pszInterface, pszInterface);
}

void WriteItem(FILE *pHfile, FILE *pSwitchFile, LPSTR pszInterface, GUID riid)
{
	WriteToHeader(pHfile, pszInterface, riid);
	WriteToSwitch(pSwitchFile, pszInterface);
}


void main()
{
	TCHAR rgchHeader[] = TEXT("header.h");
	TCHAR rgchSwitch[] = TEXT("switch.cpp");

	DWORD rgdwIID[14];
	int i = 0;
	int j;
	FILE *pfHeader, *pfCase;

	pfHeader = fopen(rgchHeader, "wb+");
	pfCase = fopen(rgchSwitch, "wb+");

	if ( (pfHeader) && (pfCase) )
	{
		ZeroMemory(rgdwIID, sizeof(rgdwIID));

		DUMPGUID("IID_IViewObject", IID_IViewObject);
		DUMPGUID("IID_IViewObject2", IID_IViewObject2);
		DUMPGUID("IID_IViewObjectEx", IID_IViewObjectEx);
		DUMPGUID("IID_IOleCommandTarget", IID_IOleCommandTarget);
		DUMPGUID("IID_IOleObject", IID_IOleObject);
		DUMPGUID("IID_IOleInPlaceObjectWindowless", IID_IOleInPlaceObjectWindowless);
		DUMPGUID("IID_IOleControl", IID_IOleControl);
		DUMPGUID("IID_IConnectionPointContainer", IID_IConnectionPointContainer);
		DUMPGUID("IID_IOleInPlaceObject", IID_IOleInPlaceObject);
		DUMPGUID("IID_IPersistVariantIO", IID_IPersistVariantIO);
		DUMPGUID("IID_IProvideClassInfo", IID_IProvideClassInfo);
		DUMPGUID("IID_IObjectSafety", IID_IObjectSafety);
		DUMPGUID("IID_ISpecifyPropertyPages", IID_ISpecifyPropertyPages);
		DUMPGUID("IID_IUnknown", IID_IUnknown);

		for (i=0; i < (sizeof(rgdwIID)/sizeof(rgdwIID[0])) - 1; i++)
		{
			for (j = i+1; j < (sizeof(rgdwIID)/sizeof(rgdwIID[0])); j++)
			{
				if (rgdwIID[i] == rgdwIID[j])
					printf("%lu and %lu match !\n", i, j);
			}
		}
	}

	if (pfHeader)
	{
		fprintf(pfHeader, "\r\n");
		fclose(pfHeader);
	}
	
	if (pfCase)
	{
		fprintf(pfHeader, "\r\n");
		fclose(pfCase);
	}

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\ihbase\utils.h ===
/*++

  utils.h

Description:
  Utilities useful to controls

Created:
  Simon Bernstein (SimonB) 30-Sept-1996

++*/

#ifndef _UTILS_H_

#pragma intrinsic(memcpy,memcmp,strcpy,strcmp)

// Convert a VARIANT_BOOL to a regular Win32 BOOL
#define VBOOL_TO_BOOL(X) (VARIANT_TRUE == X)

#define BOOL_TO_VBOOL(X) ((X)?VARIANT_TRUE:VARIANT_FALSE)

// Determine if an optional parameter is empty or not. 
// The OLE docs say the scode should be DISP_E_MEMBERNOTFOUND.  However, according to 
// Doug Franklin, this is wrong.  VBS, JScript and VBA all use DISP_E_PARAMNOTFOUND

#define ISEMPTYARG(x) ((VT_ERROR == V_VT(&x)) && (DISP_E_PARAMNOTFOUND == V_ERROR(&x)))


#define HANDLENULLPOINTER(X) {if (NULL == X) return E_POINTER;}

// Handy functions
BOOL BSTRtoWideChar(BSTR bstrSource, LPWSTR pwstrDest, int cchDest);
HRESULT LoadTypeInfo(ITypeInfo** ppTypeInfo, ITypeLib** ppTypeLib, REFCLSID clsid, GUID libid, LPWSTR pwszFilename);

#define _UTILS_H_
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\mmctl\inc\mmctl.h ===
// mmctl.h
//
// Definitions for "multimedia controls".  Includes OCX96 definitions.
//
// There are two header files for use with "multimedia controls":
//
// "mmctl.h" should be #included in every .cpp file that implements or uses
// multimedia controls.  Alternatively, "mmctl.h" may be #included in a
// precompiled header file (e.g. "precomp.h").
//
// "mmctlg.h" should be #included in every .cpp file that implements or uses
// mutimedia controls, but "mmctlg.h" may NOT be #included in a precompiled
// header file.  Additionally, on ONE .cpp file per project (application/DLL),
// <initguid.h> should be included before "mmctlg.h".
//

#ifndef __MMCTL_H__
#define __MMCTL_H__

#include <olectl.h>


///////////////////////////////////////////////////////////////////////////////
// Constants
//

#define INVALID_FRAME_NUMBER	(0xFFFFFFFF)


///////////////////////////////////////////////////////////////////////////////
// Foward references
//

interface IBitmapSurface;
interface IDirectDrawSurface;
interface IMKBitmap;
interface IRenderSpriteFrameAdviseSink;
interface ISpriteFrameSourceAdviseSink;


///////////////////////////////////////////////////////////////////////////////
// Structures
//

// AnimationInfo -- parameter for IAnimate::SetAnimationInfo
struct AnimationInfo
{
    UINT cbSize;           // Size of this structure.
	DWORD dwTickInterval;  // Interval between calls to IAnimate::Tick.
    DWORD dwFlags;         // Unused.
};


///////////////////////////////////////////////////////////////////////////////
// Interfaces
//

// INonDelegatingUnknown -- helper for implementing aggregatable objects
#ifndef INONDELEGATINGUNKNOWN_DEFINED
#undef  INTERFACE
#define INTERFACE INonDelegatingUnknown
DECLARE_INTERFACE(INonDelegatingUnknown)
{
    STDMETHOD(NonDelegatingQueryInterface) (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG, NonDelegatingAddRef)(THIS) PURE;
    STDMETHOD_(ULONG, NonDelegatingRelease)(THIS) PURE;
};
#define INONDELEGATINGUNKNOWN_DEFINED
#endif

// IAnimate -- animation interface

#ifndef IANIMATE_DEFINED
#undef INTERFACE
#define INTERFACE IAnimate
DECLARE_INTERFACE_(IAnimate, IUnknown)
{
///// IUnknown methods
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS) PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

///// IAnimate methods
    STDMETHOD(Tick) (THIS) PURE;
    STDMETHOD(Rewind) (THIS) PURE;
    STDMETHOD(SetAnimationInfo) (THIS_ AnimationInfo *pAnimationInfo) PURE;
};
#define IANIMATE_DEFINED
#endif

// ISpriteFrameSource - implemented by sprite frame sources
// these flags are returned in the HasIntrinsicData function
#define		grfIntrinsicTransparency		0x1
#define		grfIntrinsicIterations			0x2
#define		grfIntrinsicDurations			0x4
#define		grfIntrinsicFrameCounts			0x8


#ifndef ISPRITEFRAMESOURCE_DEFINED
#undef INTERFACE
#define INTERFACE ISpriteFrameSource
DECLARE_INTERFACE_(ISpriteFrameSource, IUnknown)
{
///// IUnknown methods
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS) PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

///// ISpriteFrameSource methods
    STDMETHOD(GetReadyState) (THIS_ long *readystate) PURE;
    STDMETHOD(GetProgress) (THIS_ long *progress) PURE;
    STDMETHOD(Draw) (THIS_ ULONG ulFrame,  HDC hdc,  IBitmapSurface *pSurface, IDirectDrawSurface *pDDSurface, LPCRECT lprect) PURE;
    STDMETHOD(GetFrameSize) (THIS_ ULONG ulFrame, SIZE *psize) PURE;
    STDMETHOD(DefaultFrameSize) (THIS_ SIZE size) PURE;
    STDMETHOD_(BOOL, HasImage) (THIS_ ULONG ulFrame) PURE;
    STDMETHOD_(BOOL, HasTransparency) (THIS_ ULONG ulFrame) PURE;
    STDMETHOD(SetTransparency) (THIS_ BOOL fTransFlag) PURE;
    STDMETHOD(GetTotalFrames) (THIS_ long *framecnt) PURE;
    STDMETHOD(SetTotalFrames) (THIS_ long framecnt) PURE;
    STDMETHOD(GetURL) (THIS_ long cChar, unsigned char * pch) PURE;
    STDMETHOD(SetURL) (THIS_ const unsigned char * pch) PURE;
    STDMETHOD(GetAcrossFrames) (THIS_ long * plFrames) PURE;
    STDMETHOD(SetAcrossFrames) (THIS_ long lFrames) PURE;
    STDMETHOD(GetDownFrames) (THIS_ long * plFrames) PURE;
    STDMETHOD(SetDownFrames) (THIS_ long lFrames) PURE;
    STDMETHOD(Download) (THIS_ IUnknown * pUnk,  long lPriority) PURE;
    STDMETHOD(SetDownloadPriority) (THIS_ long lPriority) PURE;
    STDMETHOD(GetDownloadPriority) (THIS_ long * plPriority) PURE;
    STDMETHOD(AbortDownload) (THIS) PURE;
    STDMETHOD(GetColorSet) (THIS_ LOGPALETTE** ppColorSet) PURE;
    STDMETHOD(OnPaletteChanged) (THIS_ LOGPALETTE *pColorSet, BOOL fStaticPalette, long lBufferDepth) PURE;
    STDMETHOD(LoadFrame) (THIS) PURE;
    STDMETHOD(PurgeFrame) (THIS_ long iAllExceptThisFrame) PURE;
    STDMETHOD(Advise) (THIS_ ISpriteFrameSourceAdviseSink *pisfsas, DWORD *pdwCookie) PURE;
    STDMETHOD(Unadvise) (THIS_ DWORD dwCookie) PURE;
    STDMETHOD_(BOOL, HasIntrinsicData) (THIS) PURE;
    STDMETHOD(GetIterations) (THIS_ ULONG *pulIterations) PURE;
	STDMETHOD_(ULONG, GetFrameDuration) (THIS_ ULONG iFrame) PURE;
	
};
#define ISPRITEFRAMESOURCE_DEFINED
#endif


// IRenderSpriteFrame - implemented by sprite renderers

#ifndef IRENDERSPRITEFRAME_DEFINED
#undef INTERFACE
#define INTERFACE IRenderSpriteFrame
DECLARE_INTERFACE_(IRenderSpriteFrame, IUnknown)
{
///// IUnknown methods
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS) PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

///// IRenderFrameSource methods
    STDMETHOD(SetObjectRect) (THIS_ LPCRECT lprect) PURE;
    STDMETHOD(GetObjectRect) (THIS_ LPRECT lprect) PURE;
    STDMETHOD_(BOOL, HasImage) (THIS) PURE;
    STDMETHOD_(BOOL, HasTransparency) (THIS) PURE;
    STDMETHOD(Draw) (THIS_ HDC hdcDraw,  IBitmapSurface *pSurface, IDirectDrawSurface *pDDSurface, LPCRECT lprect) PURE;
    STDMETHOD(SetCurrentFrame) (THIS_ ISpriteFrameSource * pisfs,  ULONG ulFrame) PURE;
    STDMETHOD(GetCurrentFrame) (THIS_ ISpriteFrameSource ** ppisfs, ULONG * pulFrame) PURE;
    STDMETHOD(SetAdvise) (THIS_ IRenderSpriteFrameAdviseSink *pirsfas) PURE;
    STDMETHOD(GetAdvise) (THIS_ IRenderSpriteFrameAdviseSink **ppirsfas) PURE;
};
#define IRENDERSPRITEFRAME_DEFINED
#endif

// IMKBitmapFrameSource - implemented by default sprite frame source

#ifndef IMKBITMAPFRAMESOURCE_DEFINED
#undef INTERFACE
#define INTERFACE IMKBitmapFrameSource
DECLARE_INTERFACE_(IMKBitmapFrameSource, IUnknown)
{
///// IUnknown methods
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS) PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

///// IMKBitmapFrameSource methods
    STDMETHOD(GetBitmap) (THIS_ ULONG ulFrame, IMKBitmap ** pMKBitmap) PURE;
    STDMETHOD(FrameToPoint) (THIS_ ULONG ulFrame, POINT *ppt) PURE;
};
#define IMKBITMAPFRAMESOURCE_DEFINED
#endif

// IRenderSpriteFrameAdviseSink - implemented by those that use a sprite renderer

#ifndef IRENDERSPRITEFRAMEADVISESINK_DEFINED
#undef INTERFACE
#define INTERFACE IRenderSpriteFrameAdviseSink
DECLARE_INTERFACE_(IRenderSpriteFrameAdviseSink, IUnknown)
{
///// IUnknown methods
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS) PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

///// IRenderSpriteFrameAdviseSink methods
    STDMETHOD(InvalidateRect) (THIS_ LPCRECT lprect) PURE;
    STDMETHOD(OnPosRectChange) (THIS_ LPCRECT lprcOld, LPCRECT lprcNew) PURE;
};
#define IRENDERSPRITEFRAMEADVISESINK_DEFINED
#endif

// ISpriteFrameSourceAdviseSink - implemented by sprite renderer

#ifndef ISPRITEFRAMESOURCEADVISESINK_DEFINED
#undef INTERFACE
#define INTERFACE ISpriteFrameSourceAdviseSink
DECLARE_INTERFACE_(ISpriteFrameSourceAdviseSink, IUnknown)
{
///// IUnknown methods
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS) PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

///// ISpriteFrameSourceAdviseSink methods
    STDMETHOD(OnSpriteFrameSourceChange) (ISpriteFrameSource *pisfs) PURE;
};
#define ISPRITEFRAMESOURCEADVISESINK_DEFINED
#endif

// IPseudoEventSink - implemented by HostLW and Multimedia Controls clients

#ifndef IPSEUDOEVENTSINK_DEFINED
#undef INTERFACE
#define INTERFACE IPseudoEventSink
DECLARE_INTERFACE_(IPseudoEventSink, IUnknown)
{
///// IUnknown methods
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS) PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

///// IPseudoEventSink methods
    STDMETHOD(OnEvent) (THIS_ SAFEARRAY *psaEventInfo) PURE;
};
#define IPSEUDOEVENTSINK_DEFINED
#endif


#endif // __MMCTL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\mmctl\inc\mmctlver.h ===
#define rmj		3
#define rmm		0
#define rup		403
#define szVerName	""
#define szVerUser	"a-tonyc"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\mmctl\inc\mmtimer.h ===
// MmTimer.h
//
// Definitions for the timer interfaces.
//

#ifndef __MMTIMER_H__
#define __MMTIMER_H__

// IAdvTimerSink interface
#undef INTERFACE
#define INTERFACE IAdvTimerSink
DECLARE_INTERFACE_(IAdvTimerSink, ITimerSink)
{
    STDMETHOD(OnStateChange)(DWORD dwFlags) PURE;
};

// IAdvTimerSink
DEFINE_GUID(IID_IAdvTimerSink, 
    0xb1ac63d3, 0x5857, 0x11d0, 0x8b, 0xbe, 0x0, 0x0, 0xf8, 0x3, 0xa8, 0x3);


// IAdvTimer interface

struct ADVTIMERSTATE
{
    DWORD cbSize;       // Size of structure
    float fltRate;      // Current rate of timer
    DWORD cWraps;       // Number of times the timer has wrapped
};

#define ADVTIMER_RATECHANGE 1
#define ADVTIMER_POSCHANGE 2
#define ADVTIMER_WRAP 4

#undef INTERFACE
#define INTERFACE IAdvTimer
DECLARE_INTERFACE_(IAdvTimer, ITimer)
{
    STDMETHOD(AdviseStateChange)(DWORD dwFlags, IAdvTimerSink * pAdvTimerSink,
        DWORD * pdwCookie) PURE;
    STDMETHOD(GetState)(ADVTIMERSTATE * pState) PURE;
};

// IAdvTimer
DEFINE_GUID(IID_IAdvTimer, 
    0xb1ac63d2, 0x5857, 0x11d0, 0x8b, 0xbe, 0x0, 0x0, 0xf8, 0x3, 0xa8, 0x3);


#endif // __MMTIMER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\mmctl\inc\catid.h ===
// CATID_MMControl -- "Multimedia Control" component category ID
DEFINE_GUID(CATID_MMControl, // {E8558721-9D1F-11cf-92F8-00AA00613BF1}
	0xe8558721, 0x9d1f, 0x11cf, 0x92, 0xf8, 0x0, 0xaa, 0x0, 0x61, 0x3b, 0xf1);

// CATID for Designers
DEFINE_GUID(CATID_Designer,
    0x4eb304d0, 0x7555, 0x11cf, 0xa0, 0xc2, 0x0, 0xaa, 0x0, 0x62, 0xbe, 0x57);

// $Review: The following two CATIDs have the same values as CATID_SafeFor-
// Scripting and CATID_SafeForInitializing as given in the ocx96 spec.
// However, because the latter CATIDs are *declared* in msdev\include\
// objsafe.h but not *defined* in any standard .h or .lib, *and* because
// the definitions in objsafe.h aren't const (as they should be) we'll
// use these two constants instead. (10/1/96, a-swehba)

// CATID_SafeForScripting
DEFINE_GUID(CATID_SafeForScripting2, // 7dd95801-9882-11cf-9fa9-00aa-006c-42c4}
	0x7dd95801, 0x9882, 0x11cf, 0x9f, 0xa9, 0x00, 0xaa, 0x00, 0x6c, 0x42, 0xc4);

// CATID_SafeForInitializing
DEFINE_GUID(CATID_SafeForInitializing2, // {7dd95802-9882-11cf-9fa9-00aa-006c-42c4}
	0x7dd95802, 0x9882, 0x11cf, 0x9f, 0xa9, 0x00, 0xaa, 0x00, 0x6c, 0x42, 0xc4);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\mmctl\inc\mmctlg.h ===
// mmctlg.h
//
// GUID definitions for "multimedia controls".  OCX96 GUIDs are not
// included.  See "mmctl.h" comments for more information.
//

// IAnimate -- animation interface
DEFINE_GUID(IID_IAnimate, // {26BA3E01-C89F-11d0-8B33-00A0C905438D}
	0x26ba3e01, 0xc89f, 0x11d0, 0x8b, 0x33, 0x0, 0xa0, 0xc9, 0x5, 0x43, 0x8d);

// ISpriteFrameSource -- 
DEFINE_GUID(IID_ISpriteFrameSource, // {4592C745-11AF-11d0-BAD9-00A0C9034BE0}
    0x4592c745, 0x11af, 0x11d0, 0xba, 0xd9, 0x0, 0xa0, 0xc9, 0x03, 0x4b, 0xe0);

// IRenderSpriteFrame -- 
DEFINE_GUID(IID_IRenderSpriteFrame, // {4592C751-11AF-11d0-BAD9-00A0C9034BE0}
    0x4592c751, 0x11af, 0x11d0, 0xba, 0xd9, 0x0, 0xa0, 0xc9, 0x03, 0x4b, 0xe0);

// IMKBitmapFrameSource -- 
DEFINE_GUID(IID_IMKBitmapFrameSource, // {4592C752-11AF-11d0-BAD9-00A0C9034BE0}
    0x4592c752, 0x11af, 0x11d0, 0xba, 0xd9, 0x0, 0xa0, 0xc9, 0x03, 0x4b, 0xe0);

// IRenderSpriteFrameAdviseSink -- 
DEFINE_GUID(IID_IRenderSpriteFrameAdviseSink, // {4592C753-11AF-11d0-BAD9-00A0C9034BE0}
    0x4592c753, 0x11af, 0x11d0, 0xba, 0xd9, 0x0, 0xa0, 0xc9, 0x03, 0x4b, 0xe0);

// ISpriteFrameSourceAdviseSink -- 
DEFINE_GUID(IID_ISpriteFrameSourceAdviseSink, // {4592C754-11AF-11d0-BAD9-00A0C9034BE0}
    0x4592c754, 0x11af, 0x11d0, 0xba, 0xd9, 0x0, 0xa0, 0xc9, 0x03, 0x4b, 0xe0);

// IID_IPseudoEventSink --
DEFINE_GUID(IID_IPseudoEventSink, // {1E658741-DC5E-11d0-8B41-00A0C905438D}
	0x1e658741, 0xdc5e, 0x11d0, 0x8b, 0x41, 0x0, 0xa0, 0xc9, 0x5, 0x43, 0x8d);

// SID_IPseudoEventSink service --
#define SID_SPseudoEventSink IID_IPseudoEventSink
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\mmctl\inc\ochelp.h ===
// ochelp.h
//
// Declares functions etc. to help implement a lightweight OLE control.
//

#ifndef __OCHELP_H__
#define __OCHELP_H__


///////////////////////////////////////////////////////////////////////////////
// Constants And Flags
//

// number of HIMETRIC units per inch
#define HIMETRIC_PER_INCH   2540

// flags for ControlInfo.dwFlags
#define CI_INSERTABLE           0x00000001  // register "Insertable" key
#define CI_CONTROL              0x00000002  // register "Control" key
#define CI_MMCONTROL            0x00000004  // register "Multimedia Control" key
#define CI_SAFEFORSCRIPTING     0x00000008  // register "safe-for-scripting"
#define CI_SAFEFORINITIALIZING  0x00000010  // register "safe-for-initializing"
#define CI_NOAPARTMENTTHREADING 0x00000020  // don't register "apartment-aware"
#define CI_DESIGNER             0x00000040  // register "Designer"

// the ControlInfo.dwFlags used by most MM Controls
#define CI_MMSTANDARD  (CI_MMCONTROL | CI_SAFEFORSCRIPTING \
					    | CI_SAFEFORINITIALIZING)

// flags for RegisterControls() <dwAction>
#define RC_REGISTER         0x00000001  // register the control
#define RC_UNREGISTER       0x00000002  // unregister the control

// DVASPECT_MASK: used by HelpQueryHitPoint() -- defined the same as
// DVASPECT_CONTENT except that non-transparent areas of the control are
// drawn black and other parts are either left untouched or draw white
// (cheat: DVASPECT_ICON was overloaded/reused to mean DVASPECT_MASK)
#define DVASPECT_MASK DVASPECT_ICON

// DISPID_BASE is the starting value for DISPIDs assigned by
// CPropertyHelper::GetIDsOfNames (which are IDs for persisted control
// properties).  This base value is used to avoid collisions with
// DISPIDs returned by DispatchHelpGetIDsOfNames (for methods and unpersisted
// control properties).  These latter IDs are assumed < DISPID_BASE.
#define DISPID_BASE         1000

// Palette index TRANSPARENT_COLOR_INDEX is reserved for transparent color.  
#define	TRANSPARENT_COLOR_RGB				RGB('r', 'g', 'b')	// some random 24 bit value
#define TRANSPARENT_COLOR_INDEX				255					// must be 255

// flags for DispatchGetArgs() and DispatchGetArgsList()
#define DGA_EXTRAOK         0x00000001
#define DGA_FEWEROK         0x00000002

// flags for HelpMemAlloc() and HelpMemFree()
#define HM_TASKMEM          0x80000000
#define HM_LEAKDETECT       0x40000000
#define HM_GMEM_MASK        0x0000FFFF  // reserved for GMEM_ values
#define HM_ZEROINIT         GMEM_ZEROINIT

// flags for HelpMemSetFailureMode()
#define HM_FAILNEVER        0x00000001
#define HM_FAILAFTER        0x00000002
#define HM_FAILUNTIL        0x00000004
#define HM_FAILEVERY        0x00000008
#define HM_FAILRANDOMLY     0x00000010

// custom messages sent to PropPageHelperProc
#define WM_PPH_APPLY                    (WM_USER + 1)
#define WM_PPH_HELP                     (WM_USER + 2)
#define WM_PPH_TRANSLATEACCELERATOR     (WM_USER + 3)

// macros that define DrawControlBorder() <piHit> values
#define DCB_HIT_GRAB(x, y)  (((y) << 2) | x)
#define DCB_HIT_EDGE            14
#define DCB_HIT_NONE            15

// Handle values (binary):  Handle values(decimal):
//    0000  0001  0010            0   1   2
//    0100        0110            4       6
//    1000  1001  1010            8   9  10
//

// masks that refer to collections of parts of the control border
#define DCB_EDGE            (1 << DCB_HIT_EDGE)
#define DCB_CORNERHANDLES   0x00000505  // handles at bit positions 0, 2, 8, 10
#define DCB_SIDEHANDLES     0x00000252  // handles at bit positions 1, 4, 6, 9
#define DCB_SIZENS          0x00000202  // handles at bit positions 1, 9
#define DCB_SIZEWE          0x00000050  // handles at bit positions 4, 6
#define DCB_SIZENESW        0x00000104  // handles at bit positions 2, 8
#define DCB_SIZENWSE        0x00000401  // handles at bit positions 0, 10

// other flags
#define DCB_XORED           0x80000000  // draw control border with XOR brush
#define DCB_INFLATE         0x40000000  // inflate <*prc> to include border

// flags for IVariantIO functions
#define VIO_ISLOADING       0x00000001  // VariantIO is in loading mode
#define VIO_ZEROISDEFAULT   0x00000002  // don't save 0 values since these are defaults

// flags for IPersistVariantIO functions
#define PVIO_PROPNAMESONLY  0x80000000  // DoPersist() only needs prop names
#define PVIO_CLEARDIRTY     0x40000000  // control should clear dirty flag
#define PVIO_NOKIDS         0x20000000  // control should not save children
#define PVIO_RUNTIME        0x10000000  // control should save runtime version of itself

// flags for AllocVariantIOToMapDISPID
#define VIOTMD_GETPROP      0x08000000  // get property value
#define VIOTMD_PUTPROP      0x04000000  // set property value

// flags for MsgWndDestroy function
#define MWD_DISPATCHALL     0x00000001  // dispatch all the window's messages 
										//  before destroying the window


///////////////////////////////////////////////////////////////////////////////
// Macros
//

// REG_CLOSE_KEY(hKey)
#define REG_CLOSE_KEY(hKey) \
    if ((hKey) != NULL) \
    { \
        RegCloseKey(hKey); \
        (hKey) = NULL; \
    }


///////////////////////////////////////////////////////////////////////////////
// Types
//

// AllocOCProc -- see RegisterControls()
EXTERN_C typedef LPUNKNOWN (STDAPICALLTYPE AllocOCProc)(LPUNKNOWN punkOuter);

// MsgWndCallback -- See MsgWndSendToCallback()
typedef void (CALLBACK MsgWndCallback) (UINT uiMsg, WPARAM wParam,
    LPARAM lParam);

// PropPageHelperProc -- see AllocPropPageHelper()
struct PropPageHelperInfo; // forward declaration
typedef BOOL (CALLBACK* PropPageHelperProc)(HWND hwnd, UINT uiMsg,
    WPARAM wParam, LPARAM lParam, PropPageHelperInfo *pInfo, HRESULT *phr);

// VERB_ENUM_CALLBACK -- See AllocVerbEnumHelper()
typedef HRESULT (VERB_ENUM_CALLBACK)(OLEVERB* pVerb, void* pOwner);


///////////////////////////////////////////////////////////////////////////////
// Structures
//

// ControlInfo -- parameters for RegisterOneControl() and RegisterControls()
struct ControlInfo
{
    UINT cbSize;
    LPCTSTR tszProgID;
    LPCTSTR tszFriendlyName;
    const CLSID *pclsid;
    HMODULE hmodDLL;
    LPCTSTR tszVersion;
    int iToolboxBitmapID;
    DWORD dwMiscStatusDefault;
    DWORD dwMiscStatusContent;
    const GUID *pguidTypeLib;
    AllocOCProc *pallococ;
    ULONG* pcLock;
    DWORD dwFlags;
    ControlInfo *pNext;
    UINT uiVerbStrID;
};

// HelpAdviseInfo -- see InitHelpAdvise(), HelpSetAdvise(), HelpGetAdvise()
struct HelpAdviseInfo
{
    DWORD           dwAspects;      // current SetAdvise() state
    DWORD           dwAdvf;         // current SetAdvise() state
    IAdviseSink *   pAdvSink;       // current SetAdvise() state
};

// PropPageHelperInfo -- used by AllocPropPageHelper
struct PropPageHelperInfo
{
    // initialized by aggregator
    int             idDialog;       // ID of propery page dialog resource
    int             idTitle;        // page title (ID of string resource)
    HINSTANCE       hinst;          // contains <idDialog> and <idTitle>
    PropPageHelperProc pproc;       // callback function
    IID             iid;            // interface that <ppunk[i]> will point to
    DWORD           dwUser;         // aggregator-specific information

    // initialized by AllocPropPageHelper
    IPropertyPageSite *psite;       // frame's page site object
    LPUNKNOWN *     ppunk;          // controls whose properties are shown
    int             cpunk;          // number of elements in <m_ppunk>
    HWND            hwnd;           // property page window
    BOOL            fDirty;         // TRUE iff changes not yet applied
    BOOL            fLockDirty;     // if TRUE, don't change <m_fDirty>
};

// VariantProperty -- a name/value pair
struct VariantProperty
{
    BSTR bstrPropName;
    VARIANT varValue;
};

// VariantPropertyHeader -- see ReadVariantProperty()
struct VariantPropertyHeader
{
    int iType;
    unsigned int cbData;
};



///////////////////////////////////////////////////////////////////////////////
// Interfaces
//

// IConnectionPointHelper interface
DEFINE_GUID(IID_IConnectionPointHelper, 0xD60E16C0L, 0x8AF2, 0x11CF,
    0xB7, 0x05, 0x00, 0xAA, 0x00, 0xBF, 0x27, 0xFD);
#undef INTERFACE
#define INTERFACE IConnectionPointHelper
DECLARE_INTERFACE_(IConnectionPointHelper, IUnknown)
{
    // IUnknown members
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // IConnectionPointHelper members
    STDMETHOD(FireEventList) (DISPID dispid, va_list args) PURE;
    virtual HRESULT __cdecl FireEvent(DISPID dispid, ...) PURE;
    STDMETHOD(FireOnChanged) (DISPID dispid) PURE;
    STDMETHOD(FireOnRequestEdit) (DISPID dispid) PURE;
    STDMETHOD(EnumConnectionPoints) (LPENUMCONNECTIONPOINTS *ppEnum) PURE;
    STDMETHOD(FindConnectionPoint) (REFIID riid, LPCONNECTIONPOINT *ppCP) PURE;
	STDMETHOD(Close) (void) PURE;
};

// IEnumVariantProperty
DEFINE_GUID(IID_IEnumVariantProperty, 0xD0230A60L, 0x99C8, 0x11CF,
    0xB8, 0xED, 0x00, 0x20, 0xAF, 0x34, 0x4E, 0x0A);
#undef INTERFACE
#define INTERFACE IEnumVariantProperty
DECLARE_INTERFACE_(IEnumVariantProperty, IUnknown)
{
    // IUnknown members
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // IEnumVariantProperty members
    STDMETHOD(Next) (THIS_ unsigned long celt, VariantProperty *rgvp,
        unsigned long *pceltFetched) PURE;
    STDMETHOD(Skip) (THIS_ unsigned long celt) PURE;
    STDMETHOD(Reset) (THIS) PURE;
    STDMETHOD(Clone) (THIS_ IEnumVariantProperty **ppenum) PURE;
    
};

// IVariantIO
DEFINE_GUID(IID_IVariantIO, 0xD07B1240L, 0x99C4, 0x11CF,
    0xB8, 0xED, 0x00, 0x20, 0xAF, 0x34, 0x4E, 0x0A);
#undef INTERFACE
#define INTERFACE IVariantIO
DECLARE_INTERFACE_(IVariantIO, IUnknown)
{
    // IUnknown members
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // IVariantIO members
    STDMETHOD(PersistList) (THIS_ DWORD dwFlags, va_list args) PURE;
    virtual HRESULT __cdecl Persist(THIS_ DWORD dwFlags, ...) PURE;
    STDMETHOD(IsLoading) (THIS) PURE;
};

// IManageVariantIO
DEFINE_GUID(IID_IManageVariantIO, 0x02D937E0L, 0x99C9, 0x11CF,
    0xB8, 0xED, 0x00, 0x20, 0xAF, 0x34, 0x4E, 0x0A);
#undef INTERFACE
#define INTERFACE IManageVariantIO
DECLARE_INTERFACE_(IManageVariantIO, IVariantIO)
{
    // IUnknown members
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // IVariantIO members
    STDMETHOD(PersistList) (THIS_ DWORD dwFlags, va_list args) PURE;
    virtual HRESULT __cdecl Persist(THIS_ DWORD dwFlags, ...) PURE;
    STDMETHOD(IsLoading) (THIS) PURE;

    // IManageVariantIO members
    STDMETHOD(SetMode) (THIS_ DWORD dwFlags) PURE;
    STDMETHOD(GetMode) (THIS_ DWORD *pdwFlags) PURE;
    STDMETHOD(DeleteAllProperties) (THIS) PURE;
};

// IPersistVariantIO
DEFINE_GUID(IID_IPersistVariantIO, 0x26F45840L, 0x9CF2, 0x11CF,
    0xB8, 0xED, 0x00, 0x20, 0xAF, 0x34, 0x4E, 0x0A);
#undef INTERFACE
#define INTERFACE IPersistVariantIO
DECLARE_INTERFACE_(IPersistVariantIO, IUnknown)
{
    // IUnknown members
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // IPersistVariantIO members
    STDMETHOD(InitNew) (THIS) PURE;
    STDMETHOD(IsDirty) (THIS) PURE;
    STDMETHOD(DoPersist) (THIS_ IVariantIO* pvio, DWORD dwFlags) PURE;
};


///////////////////////////////////////////////////////////////////////////////
// Functions
//

// define standard DLL entry point
extern "C" BOOL WINAPI _DllMainCRTStartup(HANDLE  hDllHandle, DWORD dwReason,
    LPVOID lpreserved);

// Implementing An In-Process Control DLL
STDAPI HelpGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppv,
    ControlInfo *pctlinfo);
STDAPI RegisterControls(ControlInfo *pctlinfo, DWORD dwAction);

// Creating Controls
STDAPI CreateControlInstance(LPCSTR szName, LPUNKNOWN punkOuter,
    DWORD dwClsContext, LPUNKNOWN *ppunk, CLSID *pclsid,
    BOOL* pfSafeForScripting, BOOL* pfSafeForInitializing, DWORD dwFlags);

// Implementing Properties And Methods
HRESULT __cdecl DispatchGetArgs(DISPPARAMS *pdp, DWORD dwFlags, ...);
STDAPI DispatchGetArgsList(DISPPARAMS *pdp, DWORD dwFlags, va_list args);
STDAPI DispatchHelpGetIDsOfNames(REFIID riid, LPOLESTR *rgszNames,
    UINT cNames, LCID lcid, DISPID *rgdispid, const char *szList);
STDAPI VariantFromString(VARIANT *pvar, LPCTSTR szSrc);

// Calling Properties And Methods
HRESULT __cdecl DispatchInvoke(IDispatch *pdisp, DISPID dispid,
    WORD wFlags, VARIANT *pvarResult, ...);
STDAPI DispatchInvokeEZ(IDispatch *pdisp, LPWSTR pstr, WORD wFlags,
    VARTYPE vtReturn, LPVOID pvReturn, ...);
STDAPI DispatchInvokeIDEZ(IDispatch *pdisp, DISPID dispid, WORD wFlags,
    VARTYPE vtReturn, LPVOID pvReturn, ...);
STDAPI DispatchInvokeList(IDispatch *pdisp, DISPID dispid,
    WORD wFlags, VARIANT *pvarResult, va_list args);
#define DispatchPropertyGet(pdisp, dispid, pvarResult) \
    (DispatchInvoke((pdisp), (dispid), DISPATCH_PROPERTYGET, (pvarResult), 0))
#define DispatchPropertyPut(pdisp, dispid, vt, value) \
    (DispatchInvoke((pdisp), (dispid), DISPATCH_PROPERTYPUT, NULL, \
        (vt), (value), 0))

// Firing Events
STDAPI AllocConnectionPointHelper(IUnknown *punkParent, REFIID riid,
    IConnectionPointHelper **ppconpt);
STDAPI FreeConnectionPointHelper(IConnectionPointHelper *pconpt);
STDAPI HelpGetClassInfo(LPTYPEINFO *ppti, REFCLSID rclsid, char *szEventList,
    DWORD dwFlags);
STDAPI HelpGetClassInfoFromTypeLib(LPTYPEINFO *ppTI, REFCLSID rclsid,
    ITypeLib *plib, HINSTANCE hinst, DWORD dwFlags);
HRESULT __cdecl FirePseudoEvent(HWND hwnd, LPCOLESTR oszEvName, 
	IDispatch *pctl, ...);
STDAPI FirePseudoEventList(HWND hwnd, LPCOLESTR oszEvName, 
	IDispatch *pctl, va_list args);

// Thread Safety And Popup Menus
STDAPI_(HWND) MsgWndCreate();
STDAPI_(void) MsgWndDestroy(HWND hwnd, DWORD dwFlags);
STDAPI_(LRESULT) MsgWndPostToCallback(HWND hwnd, MsgWndCallback *pproc,
    UINT uiMsg, LPARAM lParam);
STDAPI_(LRESULT) MsgWndSendToCallback(HWND hwnd, MsgWndCallback *pproc,
    UINT uiMsg, LPARAM lParam);
STDAPI_(BOOL) MsgWndTrackPopupMenuEx(HWND hwnd, HMENU hmenu, UINT fuFlags,
    int x, int y, LPTPMPARAMS lptpm, MsgWndCallback *pproc, LPARAM lParam);
STDAPI_(UINT_PTR) MsgWndSetTimer(HWND hwnd, MsgWndCallback *pproc, UINT nIDEvent,
        UINT uElapse, LPARAM lParam);

// Implementing IViewObject
STDAPI InitHelpAdvise(HelpAdviseInfo *pha);
STDAPI HelpSetAdvise(DWORD dwAspects, DWORD dwAdvf, IAdviseSink *pAdvSink,
    HelpAdviseInfo *pha);
STDAPI HelpGetAdvise(DWORD *pdwAspects, DWORD *pdwAdvf,
    IAdviseSink **ppAdvSink, HelpAdviseInfo *pha);
STDAPI_(void) UninitHelpAdvise(HelpAdviseInfo *pha);

// Implementing IViewObjectEx
STDAPI HelpQueryHitPoint(IViewObject *pvo, DWORD dwAspect, LPCRECT prcBounds,
    POINT ptLoc, LONG lCloseHint, DWORD *pHitResult);

// Implementing Persistence and Simple IDispatch
STDAPI AllocChildPropertyBag(IPropertyBag *ppbParent, LPCSTR szPropNamePrefix,
    DWORD dwFlags, IPropertyBag **pppbChild);
STDAPI AllocPropertyBagOnStream(IStream *pstream, DWORD dwFlags,
    IPropertyBag **pppb);
STDAPI AllocPropertyBagOnVariantProperty(VariantProperty *pvp, DWORD dwFlags,
    IPropertyBag **pppb);
STDAPI AllocPropertyHelper(IUnknown *punkOuter, IPersistVariantIO *ppvio,
    REFCLSID rclsid, DWORD dwFlags, IUnknown **ppunk);
STDAPI AllocVariantIO(IManageVariantIO **ppmvio);
STDAPI AllocVariantIOOnPropertyBag(IPropertyBag *ppb,
    IManageVariantIO **ppmvio);
STDAPI AllocVariantIOToMapDISPID(char *pchPropName, DISPID *pdispid,
    VARIANT *pvar, DWORD dwFlags, IVariantIO **ppvio);
STDAPI LoadPropertyBagFromStream(IStream *pstream, IPropertyBag *ppb,
    DWORD dwFlags);
STDAPI PersistChild(IVariantIO *pvio, LPCSTR szCollection,
    int iChild, LPUNKNOWN punkOuter, DWORD dwClsContext, LPUNKNOWN *ppunk,
    CLSID *pclsid, BOOL *pfSafeForScripting, BOOL *pfSafeForInitializing,
    DWORD dwFlags);
STDAPI PersistVariantIO(IPropertyBag *ppb, DWORD dwFlags, ...);
STDAPI PersistVariantIOList(IPropertyBag *ppb, DWORD dwFlags, va_list args);
STDAPI ReadVariantProperty(IStream *pstream, VariantProperty *pvp,
    DWORD dwFlags);
STDAPI_(void) VariantPropertyClear(VariantProperty *pvp);
STDAPI_(void) VariantPropertyInit(VariantProperty *pvp);
STDAPI WriteVariantProperty(IStream *pstream, VariantProperty *pvp,
    DWORD dwFlags);

// Utility Functions
STDAPI_(int) ANSIToUNICODE(LPWSTR pwchDst, LPCSTR pchSrc, int cwchDstMax);
STDAPI_(int) CompareUNICODEStrings(LPCWSTR wsz1, LPCWSTR wsz2);
STDAPI_(char *) FindCharInString(const char *sz, char chFind);
STDAPI_(char *) FindCharInStringRev(const char *sz, char chFind);
STDAPI_(const char *) FindStringByIndex(const char *szList, int iString,
    int *pcch);
STDAPI_(int) FindStringByValue(const char *szList, const char *szFind);
#define HelpDelete(pv) HelpMemFree(HM_ZEROINIT | HM_LEAKDETECT, (pv))
STDAPI_(LPVOID) HelpMemAlloc(DWORD dwFlags, ULONG cb);
STDAPI_(void) HelpMemFree(DWORD dwFlags, LPVOID pv);
#ifdef _DEBUG
STDAPI_(void) HelpMemSetFailureMode(ULONG ulParam, DWORD dwFlags);
#endif
#define HelpNew(cb) HelpMemAlloc(HM_ZEROINIT | HM_LEAKDETECT, (cb))
STDAPI_(void) HIMETRICToPixels(int cx, int cy, SIZE *psize);
STDAPI_(void) PixelsToHIMETRIC(int cx, int cy, LPSIZEL psize);
STDAPI_(ULONG) SafeRelease (LPUNKNOWN *ppunk);
#define TaskMemAlloc(cb) HelpMemAlloc(HM_TASKMEM, (cb))
#define TaskMemFree(pv) HelpMemFree(HM_TASKMEM, (pv))
STDAPI_(TCHAR*) TCHARFromGUID(REFGUID guid, TCHAR* pszGUID, int cchMaxGUIDLen);
STDAPI_(int) UNICODEToANSI(LPSTR pchDst, LPCWSTR pwchSrc, int cchDstMax);
STDAPI_(wchar_t *) UNICODEConcat(wchar_t *wpchDst, const wchar_t *wpchSrc,
    int wcchDstMax);
STDAPI_(wchar_t *) UNICODECopy(wchar_t *wpchDst, const wchar_t *wpchSrc,
    int wcchDstMax);

// Design-Time Functions
STDAPI_(IEnumOLEVERB*) AllocVerbEnumHelper(LPUNKNOWN punkOuter, void* pOwner,
    CLSID clsidOwner, VERB_ENUM_CALLBACK* pCallback);
STDAPI AllocPropPageHelper(LPUNKNOWN punkOuter, PropPageHelperInfo *pInfo,
    UINT cbInfo, LPUNKNOWN *ppunk);
STDAPI_(HBRUSH) CreateBorderBrush();
STDAPI DrawControlBorder(HDC hdc, RECT *prc, POINT *pptPrev, POINT *ppt,
    int *piHit, DWORD dwFlags);

// Miscellaneous Registry Helper Functions
STDAPI_(LONG) RegDeleteTree(HKEY hParentKey, LPCTSTR szKeyName);

// Functions that must be called by a client who uses OCHelp as a static
// library.  These are not called by clients who use the DLL version of OCHelp.
STDAPI_(BOOL) InitializeStaticOCHelp(HINSTANCE hInstance);
STDAPI_(void) UninitializeStaticOCHelp();

// Miscellaneous Functions
HRESULT __cdecl GetObjectSafety(BOOL* pfSafeForScripting, 
    BOOL* pfSafeForInitializing, IUnknown* punk, CLSID* pclsid, ...);

// Malloc spying
#ifdef _DEBUG

#define MALLOCSPY_BREAK_ON_ALLOC	0x00000001
#define MALLOCSPY_BREAK_ON_FREE		0x00000002

#define MALLOCSPY_NO_MSG_BOX		0x00000001
#define MALLOCSPY_NO_BLOCK_LIST		0x00000002

typedef HANDLE HMALLOCSPY;

STDAPI_(HMALLOCSPY) InstallMallocSpy(DWORD dwFlags);
STDAPI UninstallMallocSpy(HMALLOCSPY hSpy);
STDAPI_(void) SetMallocBreakpoint(HMALLOCSPY hSpy, ULONG iAllocNum, 
	SIZE_T cbSize, DWORD dwFlags);
STDAPI_(BOOL) DetectMallocLeaks(HMALLOCSPY hSpy, ULONG* pcUnfreedBlocks, 
	SIZE_T* pcbUnfreedBytes, DWORD dwFlags);

#endif // _DEBUG

// Wrappers for URLMON functions.
// These wrappers are defined so we can run without urlmon.dll existing
// on the target system. This is useful only for the Netscape Plugin.
//
// These definitions depend on symbols defined in urlmon.h (e.g.
// IBindStatusCallback). They aren't needed in places where urlmon.h
// hasn't been included. So rather than include urlmon.h everywhere,
// we use the __urlmon_h__ symbol to conditionally process this section.
#ifdef __urlmon_h__
STDAPI HelpCreateAsyncBindCtx(DWORD reserved, IBindStatusCallback *pBSCb, IEnumFORMATETC *pEFetc, IBindCtx **ppBC);
STDAPI HelpCreateURLMoniker(LPMONIKER pMkCtx, LPCWSTR szURL, LPMONIKER FAR * ppmk);
STDAPI HelpMkParseDisplayNameEx(IBindCtx *pbc, LPCWSTR szDisplayName, ULONG *pchEaten, LPMONIKER *ppmk);
STDAPI HelpRegisterBindStatusCallback(LPBC pBC, IBindStatusCallback *pBSCb, IBindStatusCallback** ppBSCBPrev, DWORD dwReserved);
STDAPI HelpRevokeBindStatusCallback(LPBC pBC, IBindStatusCallback *pBSCb);
STDAPI HelpURLOpenStreamA(LPUNKNOWN punk, LPCSTR szURL, DWORD dwReserved, LPBINDSTATUSCALLBACK pbsc);
STDAPI HelpURLDownloadToCacheFileA(LPUNKNOWN punk, LPCSTR szURL, LPTSTR szFile, DWORD cch, DWORD dwReserved, LPBINDSTATUSCALLBACK pbsc);
#endif	// __urlmon_h__

#endif // __OCHELP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\acpb.cpp ===
// acpb.cpp
//
// Implements AllocChildPropertyBag.
//
// Important: This .cpp file assumes a zero-initializing global "new" operator.
//
// @doc MMCTL
//

#include "precomp.h"
#include "..\..\inc\mmctlg.h" // see comments in "mmctl.h"
#include "..\..\inc\ochelp.h"
#include "debug.h"


/////////////////////////////////////////////////////////////////////////////
// ChildPropertyBag
//

/* @object ChildPropertyBag |

        Implements <i IPropertyBag> that provides a child object (contained
        within a parent object) access to the child's properties, which
        are stored within the parent's property bag.  The name of each child's
        property is prefixed with a given string (e.g. "Controls(7).").

@supint <i IPropertyBag> | The interface through which the child object
        accesses its properties.

@comm   Use <f AllocChildPropertyBag> to create a
        <o ChildPropertyBag> object.
*/


//////////////////////////////////////////////////////////////////////////////
// CChildPropertyBag
//

struct CChildPropertyBag : IPropertyBag
{
///// general object state
    ULONG           m_cRef;         // object reference count
    IPropertyBag *  m_ppbParent;    // parent's property bag
    OLECHAR         m_oachPrefix[_MAX_PATH];

///// construction and destruction
    CChildPropertyBag(IPropertyBag *ppbParent, LPCSTR szPropNamePrefix);
    ~CChildPropertyBag();

///// IUnknown methods
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObj);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

///// IPropertyBag methods
    STDMETHODIMP Read(LPCOLESTR pszPropName, LPVARIANT pVar,
        LPERRORLOG pErrorLog);
    STDMETHODIMP Write(LPCOLESTR pszPropName, LPVARIANT pVar);
};


/////////////////////////////////////////////////////////////////////////////
// ChildPropertyBag Creation & Destruction
//

/* @func HRESULT | AllocChildPropertyBag |

        Creates a <o ChildPropertyBag> object which implements <i IPropertyBag>
        that provides a child object (contained within a parent object) access
        to the child's properties, which are stored within the parent's
        property bag.  The name of each child's property is prefixed with a
        given string (e.g. "Controls(7).").

@rvalue S_OK |
        Success.

@rvalue E_OUTOFMEMORY |
        Out of memory.

@parm   IPropertyBag * | ppbParent | Parent's property bag.

@parm   LPCSTR | szPropNamePrefix | Prefix on the property name of each of the
        child's properties that are stored within the parent's property bag.
        This prefix does not appear on the properties in the returned
        property bag *<p pppbChild>.

@parm   DWORD | dwFlags | Currently unused.  Must be set to 0.

@parm   IPropertyBag * * | pppbChild | Where to store the <i IPropertyBag>
        pointer to the new <o ChildPropertyBag> object.  NULL is stored
        in *<p pppbChild> on error.
*/
STDAPI AllocChildPropertyBag(IPropertyBag *ppbParent, LPCSTR szPropNamePrefix,
    DWORD dwFlags, IPropertyBag **pppbChild)
{
    // create the Windows object
    if ((*pppbChild = (IPropertyBag *)
            New CChildPropertyBag(ppbParent, szPropNamePrefix)) == NULL)
        return E_OUTOFMEMORY;

    return S_OK;
}

CChildPropertyBag::CChildPropertyBag(IPropertyBag *ppbParent,
    LPCSTR szPropNamePrefix)
{
    // initialize IUnknown
    m_cRef = 1;

    // other initialization
    m_ppbParent = ppbParent;
    m_ppbParent->AddRef();
    ANSIToUNICODE(m_oachPrefix, szPropNamePrefix,
        sizeof(m_oachPrefix) / sizeof(*m_oachPrefix));
}

CChildPropertyBag::~CChildPropertyBag()
{
    // cleanup
    m_ppbParent->Release();
}


//////////////////////////////////////////////////////////////////////////////
// IUnknown Implementation
//

STDMETHODIMP CChildPropertyBag::QueryInterface(REFIID riid, LPVOID *ppv)
{
    *ppv = NULL;

#ifdef _DEBUG
    char ach[200];
    TRACE("ChildPropertyBag::QI('%s')\n", DebugIIDName(riid, ach));
#endif

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IVariantIO) ||
        IsEqualIID(riid, IID_IPropertyBag))
        *ppv = (IPropertyBag *) this;
    else
    if (IsEqualIID(riid, IID_IPropertyBag))
        *ppv = (IPropertyBag *) this;
    else
        return E_NOINTERFACE;

    ((IUnknown *) *ppv)->AddRef();
    return S_OK;
}

STDMETHODIMP_(ULONG) CChildPropertyBag::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CChildPropertyBag::Release()
{
    if (--m_cRef == 0L)
    {
        // free the object
        Delete this;
        return 0;
    }
    else
        return m_cRef;
}


/////////////////////////////////////////////////////////////////////////////
// IPropertyBag
//

STDMETHODIMP CChildPropertyBag::Read(LPCOLESTR pszPropName,
    LPVARIANT pVar, LPERRORLOG pErrorLog)
{
    OLECHAR oach[_MAX_PATH];
    UNICODECopy(oach, m_oachPrefix, sizeof(oach) / sizeof(*oach));
    UNICODEConcat(oach, pszPropName, sizeof(oach) / sizeof(*oach));
    return m_ppbParent->Read(oach, pVar, pErrorLog);
}

STDMETHODIMP CChildPropertyBag::Write(LPCOLESTR pszPropName,
    LPVARIANT pVar)
{
    OLECHAR oach[_MAX_PATH];
    UNICODECopy(oach, m_oachPrefix, sizeof(oach) / sizeof(*oach));
    UNICODEConcat(oach, pszPropName, sizeof(oach) / sizeof(*oach));
    return m_ppbParent->Write(oach, pVar);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\mmctl\inc\ocmisc.h ===
// OCMisc.h
//
// Declarations for the OCMisc*.lib static-link library, which
// contains miscellaneous helper functions for implementing and
// using OLE controls.
//

#ifndef __OCMISC_H__
#define __OCMISC_H__

#ifndef __comcat_h__
	#include <comcat.h>
#endif

// parts of OCMisc require MKImage, but this header file can
// get by with only the following definitions:
interface IMKBitmap;


///////////////////////////////////////////////////////////////////////////////
// Constants And Flags
//

// constants for SiteLW
#define SITELW_CLOSEHINT    100     // himetric units that's close enough to hit
#define SITELW_ID_VERB_MIN  1000    // menu ID of first verb of embedded object
#define SITELW_ID_VERB_MAX  1999    // menu ID of last verb of embedded object

// string IDs used by SiteLW
#define SITELW_IDS_NEW              101     // "New..."
#define SITELW_IDS_OPEN             102     // "Open..."
#define SITELW_IDS_CLOSE            103     // "Close"
#define SITELW_IDS_SAVE             104     // "Save"
#define SITELW_IDS_PROPERTIES       105     // "Properties..."

// menu IDs used by SiteLW
#define SITELW_ID_NEW               201     // "New..."
#define SITELW_ID_OPEN              202     // "Open..."
#define SITELW_ID_CLOSE             203     // "Close"
#define SITELW_ID_SAVE              204     // "Save"
#define SITELW_ID_PROPERTIES        205     // "Properties..."

// ISiteLW::SetSiteWindowParameters() <dwFlags> flags
enum
{
    SSWP_OFFSCREEN          = 0x00000001,
    SSWP_HATCHEDBKGND       = 0x00000002,
    SSWP_STRETCHTOWINDOW    = 0x00000004,
    SSWP_ALWAYSSHOWBORDER   = 0x00000008,
    SSWP_CONTEXTNOFILEIO    = 0x00000010,
    SSWP_NOCUSTOMPALETTE    = 0x00000020,
    SSWP_STATICPALETTE      = 0x00000040
};

// flags for PrintableANSIToUNICODE() and UNICODEToPrintableANSI()
#define PA_CSV              0x00000001  // comma-separated variable fmt.
#define PA_HTML             0x00000002  // HTML format

// flags for FindStringInString()
#define FSIS_IGNORECASE     0x00000001  // case-insensitive search

// flags for AllocPropertyBagCompactor()
#define PBC_ISLOADING       0x00000001  // IPropertyBag::Read() will be called

// flags for ISiteLW::NewControl
#define NC_DONTSETSITE      0x00000001  // don't call IOleObject::SetClientSite


///////////////////////////////////////////////////////////////////////////////
// Macros
//

// COUNT_ELEMENTS(array)
#define COUNT_ELEMENTS(array) \
    sizeof(array) / sizeof((array)[0])


///////////////////////////////////////////////////////////////////////////////
// Structures and Types
//

DECLARE_HANDLE(HMRULIST);


///////////////////////////////////////////////////////////////////////////////
// Interfaces
//

// ISiteLW
DEFINE_GUID(IID_ISiteLW, 0xE943E9C0L, 0xEAC6, 0x11CF,
    0xB7, 0x05, 0x00, 0xAA, 0x00, 0xBF, 0x27, 0xFD);
#undef INTERFACE
#define INTERFACE ISiteLW
DECLARE_INTERFACE_(ISiteLW, IUnknown)
{
    // IUnknown members
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // ISiteLW members
    STDMETHOD(SetSiteWindow) (THIS_ HWND hwnd, DWORD dwFlags) PURE;
    STDMETHOD(SetSiteWindowParameters) (THIS_ DWORD dwFlags,
        IMKBitmap *pbmBkgnd) PURE;
    STDMETHOD(SetContainerWindow) (THIS_ HWND hwnd, DWORD dwFlags) PURE;
    STDMETHOD(SetDefaultPalette) (THIS_ HPALETTE hpal) PURE;
    STDMETHOD(GetControlColorSet) (THIS_ LOGPALETTE **pplp) PURE;
    STDMETHOD(SetServiceProvider) (THIS_ IServiceProvider *psp) PURE;
    STDMETHOD(SetAdvise) (THIS_ DWORD dwAspects, DWORD dwAdvf,
        IAdviseSink *pAdvSink) PURE;
    STDMETHOD(GetAdvise) (THIS_ DWORD *pdwAspects, DWORD *pdwAdvf,
        IAdviseSink **ppAdvSink) PURE;
    STDMETHOD(NewControl) (THIS_ IUnknown *punk, DWORD dwFlags) PURE;
    STDMETHOD(CloseControl) (THIS) PURE;
    STDMETHOD(ControlIsLoaded) (THIS) PURE;
    STDMETHOD(ControlQueryInterface) (THIS_ REFIID riid, LPVOID *ppv) PURE;
    STDMETHOD(SetDesignMode) (THIS_ BOOL f) PURE;
    STDMETHOD(GetDesignMode) (THIS) PURE;
    STDMETHOD(CanShowProperties) (THIS) PURE;
    STDMETHOD(ShowProperties) (THIS) PURE;
    STDMETHOD(ShowContextMenu) (THIS_ POINT pt,
        BOOL fIncludeEmbeddedControl) PURE;
    STDMETHOD_(LRESULT, OnSiteWindowResized) (THIS) PURE;
    STDMETHOD_(LRESULT, OnSiteWindowQueryNewPalette) (THIS) PURE;
    STDMETHOD_(LRESULT, OnSiteWindowPaletteChanged) (THIS_ WPARAM wParam) PURE;
    STDMETHOD_(LRESULT, OnSiteWindowPaintRequest) (THIS_ WPARAM wParam) PURE;
	STDMETHOD(OnSiteDraw) (THIS_ HDC hdcDraw, LPCRECTL lprcBounds) PURE;
    STDMETHOD_(LRESULT, OnSiteWindowMouseMessage) (THIS_ UINT uiMsg,
        WPARAM wParam, LPARAM lParam) PURE;
    STDMETHOD_(LRESULT, OnSiteWindowCursorMessage) (THIS_ UINT uiMsg,
        WPARAM wParam, LPARAM lParam) PURE;
    STDMETHOD_(LRESULT, OnSiteWindowKeyboardMessage) (THIS_ UINT uiMsg,
        WPARAM wParam, LPARAM lParam) PURE;
    STDMETHOD_(LRESULT, OnSiteWindowCommand) (THIS_ WPARAM wParam) PURE;
    STDMETHOD_(void, OnSiteWindowTick) (THIS) PURE;
    STDMETHOD_(void, OnSiteWindowRewind) (THIS) PURE;
    STDMETHOD_(void, OnSiteWindowSetAnimationInfo) (THIS_
		AnimationInfo *pAnimationInfo) PURE;
    STDMETHOD(OnSiteInPlaceActivate) (THIS) PURE;
    STDMETHOD(OnSiteInPlaceDeactivate) (THIS) PURE;
    STDMETHOD(OnSiteUIActivate) (THIS_ LPMSG lpMsg) PURE;
    STDMETHOD(OnSiteUIDeactivate) (THIS) PURE;
    STDMETHOD(OnTranslateAccelerator) (THIS_ LPMSG lpMsg) PURE;
    STDMETHOD(OnSiteSetObjectRects) (THIS_ LPCRECT lprcPosRect,
		LPCRECT lprcClipRect) PURE;
};

// IActiveDesigner
DEFINE_GUID(IID_IActiveDesigner,
    0x51aae3e0, 0x7486, 0x11cf, 0xa0, 0xc2, 0x0, 0xaa, 0x0, 0x62, 0xbe, 0x57);

#undef  INTERFACE
#define INTERFACE IActiveDesigner
DECLARE_INTERFACE_(IActiveDesigner, IUnknown)
{
///// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

///// IActiveDesigner methods
	STDMETHOD(GetRuntimeClassID)(THIS_ CLSID *pclsid) PURE;
	STDMETHOD(GetRuntimeMiscStatusFlags)(THIS_ DWORD *pdwMiscFlags) PURE;
	STDMETHOD(QueryPersistenceInterface)(THIS_ REFIID riidPersist) PURE;
	STDMETHOD(SaveRuntimeState)(THIS_ REFIID riidPersist, REFIID riidObjStgMed, void *pObjStgMed) PURE;
	STDMETHOD(GetExtensibilityObject)(THIS_ IDispatch **ppvObjOut) PURE;
};

///////////////////////////////////////////////////////////////////////////////
// Functions
//

STDAPI AllocActiveDesignerHelper(IUnknown *punkOuter, IPersistVariantIO *ppvio,
    REFCLSID rclsidRuntime, DWORD dwRuntimeMiscStatusFlags,
    DWORD dwFlags, IUnknown **ppunk);
STDAPI AllocBindHostService(LPCTSTR szContainerFileName,
    IServiceProvider **ppsp);
STDAPI AllocPropertyBagCompactor(IPropertyBag *ppbCompact, DWORD dwFlags,
    IPropertyBag **pppb);
STDAPI AllocSiteLW(HWND hwnd, HINSTANCE hinst, ISiteLW **);
STDAPI ClearDirtyFlag(IPersistPropertyBag *pppb);
STDAPI CLSIDToFriendlyName(REFCLSID clsid, TCHAR* pszFriendlyName,
    int cchMaxFriendlyNameLen);
STDAPI CLSIDFromTCHAR(const TCHAR* pszCLSID, CLSID* pclsid);
STDAPI CreatePropertyFrame(HWND hwndOwner, UINT x, UINT y, 
    LPCOLESTR lpszCaption, ULONG cObjects, LPUNKNOWN FAR* lplpUnk,
    ULONG cPages, LPCLSID lpPageClsID, LCID lcid, DWORD dwReserved,
    LPVOID lpvReserved);
LPCSTR FindStringInString(LPCSTR szToSearch, LPCSTR szToFind, DWORD dwFlags);
HPALETTE GetHalftonePalette(DWORD dwFlags);
STDAPI GetStreamLengthToEnd(IStream *pstream, ULONG *pcb);
STDAPI LoadFromCSV(IOleClientSite *psite, IStream *pstream,
    LPUNKNOWN punkOuter, DWORD dwClsContext, LPUNKNOWN *ppunk, CLSID *pclsid,
    DWORD dwFlags);
STDAPI LoadFromHTML(IOleClientSite *psite, IStream *pstream,
    LPUNKNOWN punkOuter, DWORD dwClsContext, LPUNKNOWN *ppunk, CLSID *pclsid,
    LPSTR *ppchPage, DWORD dwFlags);
STDAPI LoadFromStream(IOleClientSite *psite, IStream *pstream,
    LPUNKNOWN punkOuter, DWORD dwClsContext, LPUNKNOWN *ppunk, CLSID *pclsid,
    DWORD dwFlags);
STDAPI LoadPropertyBagFromCSV(IStream *pstream, int cch, IPropertyBag *ppb,
    DWORD dwFlags);
STDAPI LoadPropertyBagFromHTML(IStream *pstream, int cch, IPropertyBag *ppb,
    LPSTR * ppchPage, DWORD dwFlags);
HRESULT __cdecl PersistSiteProperties(IVariantIO *pvio, LPCSTR szCollection,
    int iChild, DWORD dwFlags, ...);
STDAPI_(int) PrintableANSIToUNICODE(LPWSTR pwchDst, LPCSTR pchSrc,
    int cwchDstMax, LPCSTR *ppchSrcEnd, DWORD dwFlags);
STDAPI PickClass(HINSTANCE hInstance, UINT residDialogTitle,
    UINT cCategories, const CATID rgCategories[], CLSID* pclsid);
STDAPI ReadHTMLTagToVariantIO(LPCSTR *ppchTag, IManageVariantIO **ppmvio,
    DWORD dwFlags);
STDAPI ReadHTMLToken(LPCSTR pchSrc, LPCSTR *ppchSrcEnd, BSTR *pbstr);
STDAPI ReadStreamToMemory(IStream *pstream, int cch, char **ppchBuf);
STDAPI ReadVariantPropertyFromCSV(LPCSTR pch, VariantProperty *pvp,
    LPCSTR *ppchEnd, DWORD dwFlags);
STDAPI SaveToCSV(IStream *pstream, CLSID *pclsid, IPersistPropertyBag *pppb,
    DWORD dwFlags);
STDAPI SaveToHTML(IStream *pstream, CLSID *pclsid, IPersistPropertyBag *pppb,
    LPCSTR szPage, DWORD dwFlags);
STDAPI SaveToStream(IStream *pstream, CLSID *pclsid, IPersistStream *pps,
    DWORD dwFlags);
STDAPI SaveVariantPropertiesToCSV(IStream *pstream,
    IEnumVariantProperty *pevp, DWORD dwFlags);
STDAPI SaveVariantPropertiesToHTML(IStream *pstream,
    IEnumVariantProperty *pevp, LPCSTR szPage, DWORD dwFlags);
STDAPI_(LPCSTR) SkipWhiteSpace(LPCSTR pch);
STDAPI_(int) UNICODEToPrintableANSI(LPSTR pchDst, LPCWSTR pwchSrc,
    int cchDstMax, int cchSrc, DWORD dwFlags);
STDAPI_(VARTYPE) VariantTypeNameToNumber(char *sz);
STDAPI_(void) VariantTypeNumberToName(VARTYPE vt, char *pch);
STDAPI WriteHTMLTagFromVariantIO(IStream *pstream, IEnumVariantProperty *pevp,
    DWORD dwFlags);
STDAPI WriteHTMLToken(IStream *pstream, LPOLESTR wsz);
STDAPI WriteVariantPropertyToCSV(IStream *pstream, VariantProperty *pvp,
    DWORD dwFlags);
STDAPI WriteVariantPropertyToHTML(IStream *pstream, VariantProperty *pvp,
    DWORD dwFlags);
STDAPI IsSameObject(IUnknown * punk1, IUnknown * punk2);
STDAPI PersistCollectionProperty(IVariantIO * pvio, LPCSTR szCollection, int iIndex,
    DWORD dwFlags, VARTYPE vt, LPVOID pv);
STDAPI DispatchHelpGetFromStringArray(WORD wFlags, DISPPARAMS *pdispparams,
    VARIANT *pvarResult, char *szList);
long StringToLong(const char *nptr);
STDAPI PersistChildRuntime(IVariantIO *pvio, LPCSTR szCollection,
    int iChild, LPUNKNOWN punk, DWORD dwFlags);

// managing an MRU list
STDAPI_(HMRULIST) OpenMRUList(int cMaxEntries, HKEY hKey, 
    LPCTSTR pszSubkey, LPCSTR pszListName);
STDAPI CloseMRUList(HMRULIST hMRUList);
STDAPI GetMRUListInfo(HMRULIST hMRUList, int* pcEntries, 
    int* pcchMaxEntryLen, int* pcMaxEntries);
STDAPI SetMRUListMaxEntries(HMRULIST hMRUList, int cMaxEntries);
STDAPI GetNextMRUListEntry(HMRULIST hMRUList, TCHAR* szEntry, 
    int* pcchEntryLen);
STDAPI GetIthMRUListEntry(HMRULIST hMRUList, int iEntry, TCHAR* szEntry, 
    int* pcchEntryLen);
STDAPI_(BOOL) AtEndOfMRUList(HMRULIST hMRUList);
STDAPI ResetMRUList(HMRULIST hMRUList);
STDAPI AddMRUListEntry(HMRULIST hMRUList, const TCHAR* szEntry);
STDAPI RemoveAllMRUListEntries(HMRULIST hMRUList);
STDAPI RemoveIthMRUListEntry(HMRULIST hMRUList, int iEntry);
STDAPI RemoveMRUListEntry(HMRULIST hMRUList, const TCHAR* szEntry);
STDAPI MapMRUListToMenu(HMRULIST hMRUList, HMENU hMenu, 
    UINT cBaseMenuItems, UINT iItemAfterMRUList, UINT iFirstMRUItem,
    const TCHAR* pszEmptyListMenuItem);


#endif // __OCMISC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\allocspy.h ===
//===========================================================================
// Copyright (c) Microsoft Corporation 1996
//
// File:		AllocSpy.h
//				
// Description:	This module contains the declarations for the classes
//				CSpyList, and CSpyListNode.
//===========================================================================

#ifndef _ALLOCSPY_H_
#define _ALLOCSPY_H_




//---------------------------------------------------------------------------
// Forward Declarations
//---------------------------------------------------------------------------

class CSpyList;
class CSpyListNode;




//---------------------------------------------------------------------------
// Class:		CMallocSpy
//
// Description:	(tbd)
//---------------------------------------------------------------------------

class CMallocSpy : IMallocSpy
{
//
// Friends
//

	// (none)


//
// Class Features
//

	// (none)


//
// Instance Features
//

public:

	// creating

	CMallocSpy(DWORD dwFlags);

	// setting allocation breakpoints

	void SetBreakpoint(ULONG iAllocNum, SIZE_T cbSize, DWORD dwFlags);
		
	// detecting leaks

	BOOL DetectLeaks(ULONG* pcUnfreedBlocks, SIZE_T* pcbUnfreedBytes, 
		DWORD dwFlags);

	// IUnknown methods

	STDMETHODIMP QueryInterface(REFIID riid, void** ppvObject);
	STDMETHODIMP_(ULONG) AddRef();
	STDMETHODIMP_(ULONG) Release();        

	// IMallocSpy methods

	STDMETHODIMP_(SIZE_T) PreAlloc(SIZE_T cbRequest);
	STDMETHODIMP_(void*) PostAlloc(void* pActual);
    STDMETHODIMP_(void*) PreFree(void* pRequest, BOOL fSpyed);
    STDMETHODIMP_(void) PostFree(BOOL fSpyed);
    STDMETHODIMP_(SIZE_T) PreRealloc(void* pRequest, SIZE_T cbRequest, 
    	void** ppNewRequest, BOOL fSpyed);
    STDMETHODIMP_(void*) PostRealloc(void* pActual, BOOL fSpyed);
    STDMETHODIMP_(void*) PreGetSize(void* pRequest, BOOL fSpyed);
    STDMETHODIMP_(SIZE_T) PostGetSize( SIZE_T, BOOL fSpyed);
    STDMETHODIMP_(void*) PreDidAlloc(void* pRequest, BOOL fSpyed);
    STDMETHODIMP_(int) PostDidAlloc(void* pRequest, BOOL fSpyed, int fActual);
    STDMETHODIMP_(void) PreHeapMinimize();
    STDMETHODIMP_(void) PostHeapMinimize();

private:

	// private methods

	~CMallocSpy();

	// private variables -- controlling debug breaks

	BOOL m_fBreakOnAlloc;
		// if TRUE, the malloc spy will cause a debug break on allocations when 
		// the allocation number or size match
	BOOL m_fBreakOnFree;
		// if TRUE, the malloc spy will cause a debug break on frees when the
		// allocation number or size match
	ULONG m_iAllocBreakNum;
		// the allocation number to break on
	SIZE_T m_cbAllocBreakSize;
		// the allocation size to break on
		
	// private variables -- tracking unfreed blocks and bytes

	ULONG m_cUnfreedBlocks;
		// the number of not-yet-freed blocks
	SIZE_T m_cbUnfreedBytes;
		// the number of not-yet-freed bytes
	CSpyList* m_pListUnfreedBlocks;
		// a list of unfreed blocks
	ULONG m_iAllocNum;
		// the sequential allocation number

	// private variables -- passing info between pre's and post's

	SIZE_T m_cbRequest;
		// the number of bytes requested in the last call to PreAlloc(); used
		// to pass information between PreAlloc() and PostAlloc()
	void* m_pRequest;
		// the block currently being freed; used to pass information between
		// PreFree() and PostFree()

	// private variables -- misc

	ULONG m_cRef;
		// reference count

};




//---------------------------------------------------------------------------
// Class:		CSpyList
//
// Description:	A circular-linked, doubly-linked list of CSpyListNodes.  An 
//				empty spy list has a single head node, linked to itself.
//				A spy list contains one node for every as-yes-unfreed OLE
//				allocation.  Add() adds a new node to the front of the list.
//				Remove() removes an existing node (identified by its
//				allocation number) from the list.  GetSize() returns the
//				number of nodes in the list.  StreamTo() writes a textual
//				representation of the list to a string.
//---------------------------------------------------------------------------

class CSpyList
{
//
// Class Features
//

public:

	void*	operator new(size_t stSize);
	void	operator delete(void* pNodeList, size_t stSize);

//
// Instance Features
//

public:

	// creating and destroying

	CSpyList();
	~CSpyList();

	// adding and removing entries

	void	Add(ULONG iAllocNum, SIZE_T cbSize);
	void	Remove(ULONG iAllocNum);

	// counting the number of entries

	ULONG	GetSize();

	// streaming out

	int		StreamTo(LPTSTR psz, ULONG cMaxNodes);

private:

	ULONG m_cNodes;
		// the number of nodes in the list
	CSpyListNode* m_pHead;
		// the head node
};




//---------------------------------------------------------------------------
// Class:		CSpyListNode
//
// Description:	A node in a CSpyList.  Each CSpyListNode represents an
//				as-yet-unfreed OLE allocation.
//---------------------------------------------------------------------------

class CSpyListNode
{
//
// Friends
//

	friend class CSpyList;

//
// Class Features
//

public:

	void*	operator new(size_t stSize);
	void	operator delete(void* pNode, size_t stSize);

//
// Instance Features
//

public:

	CSpyListNode(ULONG iAllocNum, SIZE_T cbSize);
	~CSpyListNode();

private:

	// private variables

	SIZE_T m_cbSize;
		// the size of the allocation
	ULONG m_iAllocNum;
		// the allocation's number
	CSpyListNode* m_pNext;
		// a pointer to the next node in the list
	CSpyListNode* m_pPrev;
		// a pointer to the previous node in the list
};




#endif // _ALLOCSPY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\advise.cpp ===
// advise.cpp
//
// Implements functions to help implement IViewObject::SetAdvise and
// IViewObject::GetAdvise.
//
// @doc MMCTL
//

#include "precomp.h"
#include "..\..\inc\ochelp.h"
#include "debug.h"


/* @func HRESULT | InitHelpAdvise |

        Initializes a <t HelpAdviseInfo> structure, used to help implement
        <om IViewObject.SetAdvise> and <om IViewObject.GetAdvise>.

@parm   HelpAdviseInfo * | pha | Caller-allocated structure that contains
        information used to help implement <om IViewObject.SetAdvise> and
        <om IViewObject.GetAdvise>.

@comm   You must call <f InitHelpAdvise> before calling <f HelpSetAdvise>
        and <f HelpGetAdvise>, and <f UninitHelpAdvise> when the object
        that contains the <t HelpAdviseInfo> structure is deleted.
*/
STDAPI InitHelpAdvise(HelpAdviseInfo *pha)
{
    memset(pha, 0, sizeof(*pha));
    return S_OK;
}


/* @func void | UninitHelpAdvise |

        Peforms final cleanup of a <t HelpAdviseInfo> structure, including
        releasing the <i IAdviseSink> pointer if necessary.

@parm   HelpAdviseInfo * | pha | Caller-allocated structure that was
        previously initialized using <f InitHelpAdvise>.

@comm   You must call <f InitHelpAdvise> before calling <f HelpSetAdvise>
        and <f HelpGetAdvise>, and <f UninitHelpAdvise> when the object
        that contains the <t HelpAdviseInfo> structure is deleted.
*/
STDAPI_(void) UninitHelpAdvise(HelpAdviseInfo *pha)
{
    if (pha->pAdvSink != NULL)
        pha->pAdvSink->Release();
}


/* @func HRESULT | HelpSetAdvise |

        Helps implement <om IViewObject.SetAdvise>.

@parm   DWORD | dwAspects | See <om IViewObject.SetAdvise>.

@parm   DWORD | dwAdvf | See <om IViewObject.SetAdvise>.

@parm   IAdviseSink * | pAdvSink | See <om IViewObject.SetAdvise>.

@parm   HelpAdviseInfo * | pha | Caller-allocated structure that was
        previously initialized using <f InitHelpAdvise>.

@comm   You must call <f InitHelpAdvise> before calling <f HelpSetAdvise>
        and <f HelpGetAdvise>, and <f UninitHelpAdvise> when the object
        that contains the <t HelpAdviseInfo> structure is deleted.

        This function updates *<p pha> with information given by the
        parameters <p dwAspects>, <p dwAdvf>, and <p pAdvSink>.  In particular,
        the <i IAdviseSink> pointer is stored in <p pha>-<gt><p pAdvSink>,
        and you can use this pointer (when non-NULL) to advise the
        view site object of changes in your object's view (e.g. by calling
        <p pha>-<gt><p pAdvSink>-<gt>OnViewChange()).

@ex     The following example shows how to use <f HelpSetAdvise> to help
        implement <om IViewObject.SetAdvise>, assuming <p m_advise> is
        a member variable of type <t HelpAdviseInfo>. |

        STDMETHODIMP CMyControl::SetAdvise(DWORD dwAspects, DWORD dwAdvf,
            IAdviseSink *pAdvSink)
        {
            return HelpSetAdvise(dwAspects, dwAdvf, pAdvSink, &m_advise);
        }

*/
STDAPI HelpSetAdvise(DWORD dwAspects, DWORD dwAdvf, IAdviseSink *pAdvSink,
    HelpAdviseInfo *pha)
{
    pha->dwAspects = dwAspects;
    pha->dwAdvf = dwAdvf;
    if (pha->pAdvSink != NULL)
        pha->pAdvSink->Release();
    pha->pAdvSink = pAdvSink;
    if (pha->pAdvSink != NULL)
        pha->pAdvSink->AddRef();
    return S_OK;
}


/* @func HRESULT | HelpGetAdvise |

        Helps implement <om IViewObject.GetAdvise>.

@parm   DWORD * | pdwAspects | See <om IViewObject.GetAdvise>.

@parm   DWORD * | pdwAdvf | See <om IViewObject.GetAdvise>.

@parm   IAdviseSink * * | ppAdvSink | See <om IViewObject.GetAdvise>.

@parm   HelpAdviseInfo * | pha | Caller-allocated structure that was
        previously initialized using <f InitHelpAdvise>.

@comm   You must call <f InitHelpAdvise> before calling <f HelpGetAdvise>
        and <f HelpGetAdvise>, and <f UninitHelpAdvise> when the object
        that contains the <t HelpAdviseInfo> structure is deleted.

        This function fills in *<p pdwAspects>, *<p pdwAdvf>, and
        *<p ppAdvSink> with information from <p pha>.

@ex     The following example shows how to use <f HelpGetAdvise> to help
        implement <om IViewObject.GetAdvise>, assuming <p m_advise> is
        a member variable of type <t HelpAdviseInfo>. |

        STDMETHODIMP CMyControl::GetAdvise(DWORD *pdwAspects, DWORD *pdwAdvf,
            IAdviseSink **ppAdvSink)
        {
            return HelpGetAdvise(pdwAspects, pdwAdvf, ppAdvSink, &m_advise);
        }
*/
STDAPI HelpGetAdvise(DWORD *pdwAspects, DWORD *pdwAdvf,
    IAdviseSink **ppAdvSink, HelpAdviseInfo *pha)
{
    if (pdwAspects != NULL)
        *pdwAspects = pha->dwAspects;
    if (pdwAdvf != NULL)
        *pdwAdvf = pha->dwAdvf;
    if (ppAdvSink != NULL)
    {
        *ppAdvSink = pha->pAdvSink;
        if (*ppAdvSink != NULL)
            (*ppAdvSink)->AddRef();
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\allocspy.cpp ===
//===========================================================================
// Copyright (c) Microsoft Corporation 1996
//
// File:                AllocSpy.cpp
//                              
// Description: This module contains the implementation of the exported
//                              functions:
//
//                                      InstallMallocSpy
//                                      UninstallMallocSpy
//                                      SetMallocBreakpoint
//                                      DetectMallocLeaks
//
//                              and the exported-classes:
//
//                                      CMallocSpy
//                                      CSpyList
//                                      CSpyListNode
//
// @doc MMCTL
//===========================================================================

//---------------------------------------------------------------------------
// Dependencies
//---------------------------------------------------------------------------

#include "precomp.h"
#ifdef _DEBUG
#include "..\..\inc\ochelp.h"   // CMallocSpy
#include "Globals.h"
#include "debug.h"                              // ASSERT()
#include "allocspy.h"




//---------------------------------------------------------------------------
// Global Variables
//---------------------------------------------------------------------------

#define HMALLOCSPY_NOTOWNER ((HMALLOCSPY)1)
        // the handle used to indicate that the caller of the malloc spy function
        // doesn't actually own the spy
        
struct DebugHeader
{
        DWORD iAllocNum;
        SIZE_T cbAllocSize;
};

CMallocSpy* g_pSpy = NULL;




//===========================================================================
// Non-Member Functions
//===========================================================================

/*---------------------------------------------------------------------------
@func   HMALLOCSPY | InstallMallocSpy |
                Creates a new IMalloc spy and registers it with OLE.  The IMalloc spy
                will monitor calls to <om IMalloc::Alloc> and <om IMalloc::Free>.

@rdesc  Returns a handle to the spy or NULL if the spy couldn't be
                initialized.  The spy handle is used as the first argument to all
                other spy functions.

@comm   If this function succeeds, a matching call to <f UninstallMallocSpy>
                should eventually be made.  Set breakpoints on calls to
                <om IMalloc::Alloc> or <om IMalloc::Free> via <f SetMallocBreakpoint>.
                Detect leaks via <f DetectMallocLeaks>.

                Warning: When an IMalloc spy is installed, system performance may be
                seriously degraded.

@xref   <f UninstallMallocSpy> <f SetMallocBreakpoint> <f DetectMallocLeaks>
*/

STDAPI_(HMALLOCSPY) InstallMallocSpy(
DWORD dwFlags) // @parm [in]
        // Flags controlling the spy.  Presently only one flag is supported:
        // @flag        MALLOCSPY_NO_BLOCK_LIST |
        //                      If set, the spy won't maintain a list of unfreed blocks,
        //                      although it will always keep track of the total number of
        //                      unfreed blocks and bytes.  If this flag is set,
        //                      <f DetectMallocLeaks> will not display a list of unfreed
        //                      blocks.
{
        HMALLOCSPY hSpy;
        HRESULT hr = S_OK;
        IMallocSpy* pISpy;

        ::EnterCriticalSection(&g_criticalSection);

        // If a malloc spy already exists then it has been installed.  Don't
        // bother installing another one.

        if (g_pSpy != NULL)
        {
                hSpy = HMALLOCSPY_NOTOWNER;
                goto Exit;
        }

        // Otherwise, create and register a new malloc spy.

        g_pSpy = new CMallocSpy(dwFlags);
        if (g_pSpy == NULL)
        {
                goto ErrExit;
        }
        if (FAILED(g_pSpy->QueryInterface(IID_IMallocSpy, (void**)&pISpy)))
        {
                goto ErrExit;
        }
        if (FAILED(::CoRegisterMallocSpy(pISpy)))
        {
                goto ErrExit;
        }

        // Set the spy handle to the address of the global spy variable.

        hSpy = (HMALLOCSPY)g_pSpy;

Exit:

        ::LeaveCriticalSection(&g_criticalSection);
        return (hSpy);

ErrExit:
        
        ASSERT(FAILED(hr));
        if (g_pSpy != NULL)
        {
                g_pSpy->Release();
                g_pSpy = NULL;
        }
        hSpy = NULL;
        goto Exit;
}




/*---------------------------------------------------------------------------
@func   HRESULT | UninstallMallocSpy |
                Uninstalls a previously installed IMalloc spy.

@rvalue S_OK |
                The spy was successfully uninstalled.
@rvalue CO_E_OBJNOTREG |
                No spy is currently installed.
@rvalue E_ACCESSDENIED |
                A spy is installed but there are outstanding (i.e., not yet
                freed) allocations made while this spy was active.

@xref   <f InstallMallocSpy> <f SetMallocBreakpoint> <f DetectMallocLeaks>
*/

STDAPI UninstallMallocSpy(
HMALLOCSPY hSpy) // @parm [in]
        // The handle returned by a previous call to <f InstallMallocSpy>
{
        HRESULT hr;

        // If the spy handle doesn't match the global <g_pSpy> variable, the
        // caller doesn't own the spy and shouldn't be deleting it.

        if (hSpy != (HMALLOCSPY)g_pSpy)
        {
                hr = E_ACCESSDENIED;
                goto Exit;
        }

        // Otherwise, tell OLE to revoke the spy and delete the global spy
        // object.
        
        ::EnterCriticalSection(&g_criticalSection);
        hr = ::CoRevokeMallocSpy();
        g_pSpy->Release();
        g_pSpy = NULL;
        ::LeaveCriticalSection(&g_criticalSection);

Exit:

        return (hr);
}




/*---------------------------------------------------------------------------
@func   void | SetMallocBreakpoint |
                Instructs a previously installed IMalloc spy to generate a debug break
                on a particular allocation number or size.

@comm   Once a spy is installed, every call to <om IMalloc::Alloc> is
                monitored and assigned a 0-based "allocation number".  A debug break
                can be triggered based on this allocation number or on an allocation
                size.  The breakpoint can be made to occur either on the call to
                <om IMalloc::Alloc> or <om IMalloc::Free>.

@xref   <f InstallMallocSpy> <f UninstallMallocSpy> <f DetectMallocLeaks>
*/

STDAPI_(void) SetMallocBreakpoint(
HMALLOCSPY hSpy, // @parm [in]
        // The handle returned by a previous call to <f InstallMallocSpy>
ULONG iAllocNum, // @parm [in]
        // The allocation number to break on.  Allocations are numbered from 0.
        // If you want to specify an allocation break by size instead of number,
        // set <p iAllocNum> to -1.
SIZE_T cbAllocSize, // @parm [in]
        // The allocation size to break on.  If you want to specify an allocation
        // break by allocation number instead of size, set <p cbAllocSize> to
        // -1.
DWORD dwFlags) // @parm [in]
        // Whether to break when the block is allocate or freed.  If you don't
        // want to break at all, set <p dwFlags> to 0.  Otherwise, set it to
        // a combination of the following flags:
        // @flag        MALLOCSPY_BREAK_ON_ALLOC |
        //                      Break when the block with the given <p iAllocNum> or
        //                      <p cbAllocSize> is allocated.
        // @flag        MALLOCSPY_BREAK_ON_FREE |
        //                      Break when the block with the given <p iAllocNum> or
        //                      <p cbAllocSize> is allocated.
{
        // Ignore the spy handle, <hSpy>.  Anyone can set a malloc breakpoint so
        // long as the spy has been installed.
        
        if (g_pSpy)
        {
                g_pSpy->SetBreakpoint(iAllocNum, cbAllocSize, dwFlags);
        }
}


/*---------------------------------------------------------------------------
@func   BOOL | DetectMallocLeaks |
                Displays information regarding unfreed IMalloc allocations.

@rdesc  If leaks were detected.  Returns one of the following values:
@flag   TRUE |
                There is at least one as-yet-unfreed IMalloc allocation.
@flag   FALSE |
                There are no unfreed IMalloc allocations.

@comm   Always writes a message to the debug output window.

@xref   <f InstallMallocSpy> <f UninstallMallocSpy> <f SetMallocBreakpoint>
*/

STDAPI_(BOOL) DetectMallocLeaks(
HMALLOCSPY hSpy, // @parm [in]
        // The handle returned by a previous call to <f InstallMallocSpy>
ULONG* pcUnfreedBlocks, // @parm [out]
        // If non-NULL on entry, *<p pcUnfreedBlocks> is set to the number of
        // unfreed blocks allocated by calls to <om IMalloc::Alloc>.
SIZE_T* pcbUnfreedBytes, // @parm [out]
        // If non-NULL on entry, *<p pcbUnfreedBytes> is set to the total number
        // of unfreed bytes allocated by calls to <om IMalloc::Alloc>.
DWORD dwFlags) // @parm [in]
        // Flags controlling how the leak information is displayed.  A combination
        // of the following flags:
        // @flag        MALLOCSPY_NO_BLOCK_LIST |
        //                      Don't display a list of unfreed blocks.  If this flag isn't
        //                      set, the leak message will display up to the first 10
        //                      unfreed blocks, showing the allocation number and size for
        //                      each block.
        // @flag        MALLOCSPY_NO_MSG_BOX |
        //                      Don't display a message box.  If this flag isn't set, a message
        //                      box will be displayed if leaks were detected.
{
        BOOL fResult = FALSE;

        // Ignore the spy handle, <hSpy>.  Anyone can detect leaks so long as
        // the spy has been installed.
        
        if (g_pSpy)
        {
                fResult = g_pSpy->DetectLeaks(pcUnfreedBlocks, pcbUnfreedBytes,
                                                        dwFlags);
        }
        return (fResult);
}




//===========================================================================
// CMallocSpy
//===========================================================================

//---------------------------------------------------------------------------
// Create a new Malloc spy.  The spy has a reference count of 0.  Delete it
// by calling Release().
//---------------------------------------------------------------------------

CMallocSpy::CMallocSpy(
DWORD dwFlags)
{
        BOOL fMaintainUnfreedBlockList = ((dwFlags & MALLOCSPY_NO_BLOCK_LIST) == 0);

        if (fMaintainUnfreedBlockList)
        {
                m_pListUnfreedBlocks = new CSpyList;
        }
        m_fBreakOnAlloc = FALSE;
        m_fBreakOnFree = FALSE;
}


//---------------------------------------------------------------------------
// Destroy an existing Malloc spy.  Don't call this method directly -- use
// Release() instead.
//---------------------------------------------------------------------------

CMallocSpy::~CMallocSpy()
{
        delete m_pListUnfreedBlocks;
}


//---------------------------------------------------------------------------
// Set a breakpoint on an allocation or free.  See ::SetMallocBreakpoint,
// above for more information.
//---------------------------------------------------------------------------

void CMallocSpy::SetBreakpoint(
ULONG iAllocNum,
SIZE_T cbAllocSize,
DWORD dwFlags)
{
        EnterCriticalSection(&g_criticalSection);
        
        m_iAllocBreakNum = iAllocNum;
        m_cbAllocBreakSize = cbAllocSize;
        m_fBreakOnAlloc = ((dwFlags & MALLOCSPY_BREAK_ON_ALLOC) != 0);
        m_fBreakOnFree = ((dwFlags & MALLOCSPY_BREAK_ON_FREE) != 0);

        LeaveCriticalSection(&g_criticalSection);
}


//---------------------------------------------------------------------------
// Detect leaks.  See ::DetectMallocLeaks(), above, for more information.
//---------------------------------------------------------------------------

BOOL CMallocSpy::DetectLeaks(
ULONG* pcUnfreedBlocks,
SIZE_T* pcbUnfreedBytes,
DWORD dwFlags)
{
    char ach[1000];
        char* psz = ach;
        BOOL fShowUnfreedBlocks = ((dwFlags & MALLOCSPY_NO_BLOCK_LIST) == 0);
        BOOL fShowMsgBox = ((dwFlags & MALLOCSPY_NO_MSG_BOX) == 0);
        
    OutputDebugString("IMalloc leak detection: ");
    EnterCriticalSection(&g_criticalSection);

    // Return the number of unfreed blocks and unfreed bytes if the caller
    // wants them.

    if (pcUnfreedBlocks != NULL)
    {
        *pcUnfreedBlocks = m_cUnfreedBlocks;
    }
    if (pcbUnfreedBytes != NULL)
    {
        *pcbUnfreedBytes = m_cbUnfreedBytes;
    }

    // If there was unfreed memory...

    if ((m_cUnfreedBlocks != 0) || (m_cbUnfreedBytes != 0))
    {
        // Form a basic message describing the number of blocks and bytes
        // which were unfreed.

        psz += wsprintf(psz,
                                "%d unreleased blocks, %d unreleased bytes",
                                m_cUnfreedBlocks,
                                m_cbUnfreedBytes);

                // Append a list of the first 10 unfreed blocks to the basic
                // message.

                if (fShowUnfreedBlocks && (m_pListUnfreedBlocks != NULL))
                {
                        psz += wsprintf(psz, "\nUnfreed blocks: ");
                        psz += m_pListUnfreedBlocks->StreamTo(psz, 10);
                }
        LeaveCriticalSection(&g_criticalSection);

                // Display the message.
                
        OutputDebugString(ach);
        if (fShowMsgBox)
        {
                MessageBox(NULL, ach, "IMalloc Leak Detection",
                MB_ICONEXCLAMATION | MB_OK);
        }
    }

    // If there was no unfreed memory...

    else
    {
        LeaveCriticalSection(&g_criticalSection);
        OutputDebugString("(no leaks detected)");
    }

    OutputDebugString("\n");
    return (m_cUnfreedBlocks > 0);
}


//---------------------------------------------------------------------------
// Get an interface on the spy.
//---------------------------------------------------------------------------

STDMETHODIMP
CMallocSpy::QueryInterface(
REFIID riid,
void** ppvObject)
{
        *ppvObject = NULL;
        if (IsEqualIID(riid, IID_IUnknown))
        {
                *ppvObject = (IUnknown*)this;
        }
        else if (IsEqualIID(riid, IID_IMallocSpy))
        {
                *ppvObject = (IMallocSpy*)this;
        }
        else
        {
                return (E_NOINTERFACE);
        }

        AddRef();
        return (S_OK);
}


//---------------------------------------------------------------------------
// Increment a Malloc spy's reference count.
//---------------------------------------------------------------------------

STDMETHODIMP_(ULONG)    
CMallocSpy::AddRef()
{
        return (m_cRef++);
}


//---------------------------------------------------------------------------
// If a Malloc spy's reference count is 0, delete it. Otherwise, decrement
// the reference count, and delete the spy if the count is 0.
//---------------------------------------------------------------------------

STDMETHODIMP_(ULONG)    
CMallocSpy::Release()
{
        if (m_cRef > 0)
        {
                m_cRef--;
        }
        if (m_cRef == 0)
        {
                delete this;
                return (0);
        }
        return (m_cRef);
}


//---------------------------------------------------------------------------
// Called by OLE just before IMalloc::Alloc().
//---------------------------------------------------------------------------

STDMETHODIMP_(SIZE_T)    
CMallocSpy::PreAlloc(
SIZE_T cbRequest)
{
        // Break if we're breaking on allocations and either the allocation
        // number or size match what we're looking for.
        
        if ((m_fBreakOnAlloc) && ((m_iAllocBreakNum == m_iAllocNum) ||
                (m_cbAllocBreakSize == cbRequest)))
        {
                DebugBreak();
        }
        
        // Pass <cbRequest> to PostAlloc() via <m_cbRequest>.

        m_cbRequest = cbRequest;

        // Allocation additional space for the allocation number and size.

        return (cbRequest + sizeof(DebugHeader));
}


//---------------------------------------------------------------------------
// Called by OLE just after IMalloc::Alloc().
//---------------------------------------------------------------------------

STDMETHODIMP_(void*)    
CMallocSpy::PostAlloc(
void* pActual)
{
        DebugHeader* pHeader = (DebugHeader*)pActual;

        // Write the allocation number and size at the start of the block.

        pHeader->iAllocNum = m_iAllocNum;
        pHeader->cbAllocSize = m_cbRequest;

        // Adjust the allocation counters.

        m_cUnfreedBlocks++;
        m_cbUnfreedBytes += m_cbRequest;

        // Add the block to the list of unfreed blocks.

        if (m_pListUnfreedBlocks != NULL)
        {
                m_pListUnfreedBlocks->Add(pHeader->iAllocNum, pHeader->cbAllocSize);
        }

        // Increment the allocation number.

        m_iAllocNum++;
        return (pHeader + 1);
}


//---------------------------------------------------------------------------
// Called by OLE just before IMalloc::Free().
//---------------------------------------------------------------------------

STDMETHODIMP_(void*)    
CMallocSpy::PreFree(
void* pRequest,
BOOL fSpyed)
{
        if (fSpyed)
        {
                DebugHeader* pHeader = (DebugHeader*)pRequest - 1;

                // Break if we're breaking on allocations and either the allocation
                // number or size match what we're looking for.

                if ((m_fBreakOnFree) && ((pHeader->iAllocNum == m_iAllocBreakNum) ||
                        (pHeader->cbAllocSize == m_cbAllocBreakSize)))
                {
                        DebugBreak();
                }

                // Otherwise, decrement the unfreed block count and unfreed byte counts,
                // and remove the block from the list of unfreed blocks.
                
                m_cUnfreedBlocks--;
                m_cbUnfreedBytes -= pHeader->cbAllocSize;
                if (m_pListUnfreedBlocks != NULL)
                {
                        m_pListUnfreedBlocks->Remove(pHeader->iAllocNum);
                }
                return (pHeader);
        }
        return (pRequest);
}


//---------------------------------------------------------------------------
// Called by OLE just after IMalloc::Free().
//---------------------------------------------------------------------------

STDMETHODIMP_(void)             
CMallocSpy::PostFree(
BOOL fSpyed)
{
        // nothing to do
}


//---------------------------------------------------------------------------
// Called by OLE just before IMalloc::Realloc().
//---------------------------------------------------------------------------

STDMETHODIMP_(SIZE_T)    
CMallocSpy::PreRealloc(
void* pRequest,
SIZE_T cbRequest,
void** ppNewRequest,
BOOL fSpyed)
{
        if (fSpyed)
        {
                DebugHeader* pHeader = (DebugHeader*)pRequest - 1;
                PreFree(pRequest, fSpyed);
                PreAlloc(cbRequest);
                *ppNewRequest = pHeader;
                return (cbRequest + sizeof(DebugHeader));
        }
        *ppNewRequest = pRequest;
        return (cbRequest);
}


//---------------------------------------------------------------------------
// Called by OLE just after IMalloc::Realloc().
//---------------------------------------------------------------------------

STDMETHODIMP_(void*)    
CMallocSpy::PostRealloc(
void* pActual,
BOOL fSpyed)
{
        if (fSpyed)
        {
                return (PostAlloc(pActual));
        }
        return (pActual);
}


//---------------------------------------------------------------------------
// Called by OLE just before IMalloc::GetSize().
//---------------------------------------------------------------------------

STDMETHODIMP_(void*)    
CMallocSpy::PreGetSize(
void* pRequest,
BOOL fSpyed)
{
        if (fSpyed)
        {
                DebugHeader* pHeader = (DebugHeader*)pRequest - 1;
                return (pHeader);
        }
        return (pRequest);
}


//---------------------------------------------------------------------------
// Called by OLE just after IMalloc::GetSize().
//---------------------------------------------------------------------------

STDMETHODIMP_(SIZE_T)    
CMallocSpy::PostGetSize(
SIZE_T cbActual,
BOOL fSpyed)
{
        if (fSpyed)
        {
                return (cbActual - sizeof(DebugHeader));
        }
        return (cbActual);
}


//---------------------------------------------------------------------------
// Called by OLE just before IMalloc::DidAlloc().
//---------------------------------------------------------------------------

STDMETHODIMP_(void*)    
CMallocSpy::PreDidAlloc(
void* pRequest,
BOOL fSpyed)
{
        if (fSpyed)
        {
                DebugHeader* pHeader = (DebugHeader*)pRequest - 1;
                return (pHeader);
        }
        return (pRequest);
}


//---------------------------------------------------------------------------
// Called by OLE just after IMalloc::DidAlloc().
//---------------------------------------------------------------------------

STDMETHODIMP_(int)              
CMallocSpy::PostDidAlloc(
void* pRequest,
BOOL fSpyed,
int fActual)
{
        return (fActual);
}


//---------------------------------------------------------------------------
// Called by OLE just before IMalloc::HeapMinimize().
//---------------------------------------------------------------------------

STDMETHODIMP_(void)             
CMallocSpy::PreHeapMinimize()
{
        // nothing to do
}


//---------------------------------------------------------------------------
// Called by OLE just after IMalloc::HeapMinimize().
//---------------------------------------------------------------------------

STDMETHODIMP_(void)             
CMallocSpy::PostHeapMinimize()
{
        // nothing to do
}




//===========================================================================
// CSpyList
//===========================================================================

void* CSpyList::operator new(
size_t stSize)
{
        HGLOBAL h = GlobalAlloc(GHND, stSize);
        return (GlobalLock(h));
}


void CSpyList::operator delete(
void* pNodeList,
size_t stSize)
{
        ASSERT(stSize == sizeof(CSpyList));
    HGLOBAL h = (HGLOBAL)GlobalHandle(pNodeList);
    GlobalUnlock(h);
    GlobalFree(h);
}


CSpyList::CSpyList()
{
        m_pHead = new CSpyListNode(0, 0);
        m_pHead->m_pNext = m_pHead->m_pPrev = m_pHead;
}


CSpyList::~CSpyList()
{
        CSpyListNode* pNode1;
        CSpyListNode* pNode2;

        pNode1 = m_pHead->m_pNext;
        while (pNode1 != m_pHead)
        {
                pNode2 = pNode1->m_pNext;
                delete pNode1;
                pNode1 = pNode2;
        }
        delete m_pHead;
}


void CSpyList::Add(
ULONG iAllocNum,
SIZE_T cbSize)
{
        CSpyListNode* pNode = new CSpyListNode(iAllocNum, cbSize);
        pNode->m_pNext = m_pHead->m_pNext;
        pNode->m_pPrev = m_pHead;
        m_pHead->m_pNext->m_pPrev = pNode;
        m_pHead->m_pNext = pNode;
        m_cNodes++;
}


void CSpyList::Remove(
ULONG iAllocNum)
{
        CSpyListNode* pNode;

        for (pNode = m_pHead->m_pNext;
                 pNode != m_pHead;
                 pNode = pNode->m_pNext)
        {
                if (pNode->m_iAllocNum == iAllocNum)
                {
                        pNode->m_pPrev->m_pNext = pNode->m_pNext;
                        pNode->m_pNext->m_pPrev = pNode->m_pPrev;
                        delete pNode;
                        m_cNodes--;
                        return;
                }
        }
}


ULONG CSpyList::GetSize()
{
        return (m_cNodes);
}


int CSpyList::StreamTo(
LPTSTR psz,
ULONG cMaxNodes)
{
        CSpyListNode* pNode;
        ULONG iNode;
        LPTSTR pszNext = psz;

        for (iNode = 0, pNode = m_pHead->m_pPrev;
                 (iNode < cMaxNodes) && (pNode != m_pHead);
                 iNode++, pNode = pNode->m_pPrev)
        {
                pszNext += wsprintf(pszNext, _T("%s#%lu=%lu"),
                                                        (iNode > 0) ? _T(", ") : _T(""),
                                                        pNode->m_iAllocNum, pNode->m_cbSize);
        }

        if (pNode != m_pHead)
        {
                pszNext += wsprintf(pszNext, _T("%s%s"),
                                        (iNode > 0) ? _T(",") : _T(""),
                                        _T(" ..."));
        }

        return (int) (pszNext - psz);
}




//===========================================================================
// CSpyListNode
//===========================================================================

void* CSpyListNode::operator new(
size_t stSize)
{
        HGLOBAL h = GlobalAlloc(GHND, stSize);
        return (GlobalLock(h));
}


void CSpyListNode::operator delete(
void* pNode,
size_t stSize)
{
        ASSERT(stSize == sizeof(CSpyListNode));
    HGLOBAL h = (HGLOBAL)GlobalHandle(pNode);
    GlobalUnlock(h);
    GlobalFree(h);
}


CSpyListNode::CSpyListNode(
ULONG iAllocNum,
SIZE_T cbSize)
{
        m_iAllocNum = iAllocNum;
        m_cbSize = cbSize;
}


CSpyListNode::~CSpyListNode()
{
        // nothing to do
}
#endif      // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\apbos.cpp ===
// apbos.cpp
//
// Implements AllocPropertyBagOnStream.
//
// Important: This .cpp file assumes a zero-initializing global "new" operator.
//
// @doc MMCTL
//

#include "precomp.h"
#include "..\..\inc\mmctlg.h" // see comments in "mmctl.h"
#include "..\..\inc\ochelp.h"
#include "debug.h"


/////////////////////////////////////////////////////////////////////////////
// PropertyBagOnStream
//

/* @object PropertyBagOnStream |

        Implements <i IPropertyBag> whose properties are contained in
        a given <i IStream>.

@supint <i IPropertyBag> | The interface to use to access the properties
        stored in the given <i IStream>.

@comm   Use <f AllocPropertyBagOnStream> to create a <o PropertyBagOnStream>
        object.

@comm   See <t VariantPropertyHeader> for a description of the format of
        the data in the <i IStream>.
*/


//////////////////////////////////////////////////////////////////////////////
// CPropertyBagOnStream
//

struct CPropertyBagOnStream : IPropertyBag
{
///// general object state
    ULONG           m_cRef;         // object reference count
    IStream *       m_ps;           // parent's property bag
    IStream *       m_psBuf;        // buffer used for reading properties

///// construction and destruction
    CPropertyBagOnStream(IStream *pstream);
    ~CPropertyBagOnStream();

///// IUnknown methods
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObj);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

///// IPropertyBag methods
    STDMETHODIMP Read(LPCOLESTR pszPropName, LPVARIANT pVar,
        LPERRORLOG pErrorLog);
    STDMETHODIMP Write(LPCOLESTR pszPropName, LPVARIANT pVar);
};


/////////////////////////////////////////////////////////////////////////////
// PropertyBagOnStream Creation & Destruction
//

/* @func HRESULT | AllocPropertyBagOnStream |

        Creates a <o PropertyBagOnStream> object which implements
        <i IPropertyBag> whose properties are contained in a given <i IStream>.

@rvalue S_OK |
        Success.

@rvalue E_OUTOFMEMORY |
        Out of memory.

@parm   IStream * | pstream | Stream to read from or write to (depending on
        whether the returned <i IPropertyBag> is used for reading or
        writing).

@parm   DWORD | dwFlags | Currently unused.  Must be set to 0.

@parm   IPropertyBag * * | pppb | Where to store the <i IPropertyBag>
        pointer to the new <o PropertyBagOnStream> object.  NULL is stored
        in *<p pppb> on error.

@comm   The returned <i IPropertyBag> must be used either exclusively for
        reading (i.e. only <om IPropertyBag.Read> is called) or exclusively
        for writing (i.e. only <om IPropertyBag.Write> is called).  The
        properties are read/written starting from the current position of
        <p pstream>.  When reading/writing is complete, the current position
        of <p pstream> will be the end of the properties in the stream.

        See <t VariantPropertyHeader> for a description of the format of
        the data in the <i IStream>.
*/
STDAPI AllocPropertyBagOnStream(IStream *pstream, DWORD dwFlags,
    IPropertyBag **pppb)
{
    // create the Windows object
    if ((*pppb = (IPropertyBag *)
            New CPropertyBagOnStream(pstream)) == NULL)
        return E_OUTOFMEMORY;

    return S_OK;
}

CPropertyBagOnStream::CPropertyBagOnStream(IStream *pstream)
{
    // initialize IUnknown
    m_cRef = 1;

    // other initialization
    m_ps = pstream;
    m_ps->AddRef();
    m_psBuf = NULL;
}

CPropertyBagOnStream::~CPropertyBagOnStream()
{
    // cleanup
    m_ps->Release();
    if (m_psBuf != NULL)
        m_psBuf->Release();
}


//////////////////////////////////////////////////////////////////////////////
// IUnknown Implementation
//

STDMETHODIMP CPropertyBagOnStream::QueryInterface(REFIID riid, LPVOID *ppv)
{
    *ppv = NULL;

#ifdef _DEBUG
    char ach[200];
    TRACE("PropertyBagOnStream::QI('%s')\n", DebugIIDName(riid, ach));
#endif

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IPropertyBag))
        *ppv = (IPropertyBag *) this;
    else
        return E_NOINTERFACE;

    ((IUnknown *) *ppv)->AddRef();
    return S_OK;
}

STDMETHODIMP_(ULONG) CPropertyBagOnStream::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CPropertyBagOnStream::Release()
{
    if (--m_cRef == 0L)
    {
        // free the object
        Delete this;
        return 0;
    }
    else
        return m_cRef;
}


/////////////////////////////////////////////////////////////////////////////
// IPropertyBag
//

STDMETHODIMP CPropertyBagOnStream::Read(LPCOLESTR pszPropName,
    LPVARIANT pVar, LPERRORLOG pErrorLog)
{
    HRESULT         hrReturn = S_OK; // function return code
    VariantProperty vp;             // a property name/value pair in <pmvio>
    LARGE_INTEGER   liZero = {0, 0};

    // ensure correct cleanup
    VariantPropertyInit(&vp);

    if (m_psBuf == NULL)
    {
        // copy the properties from <m_ps> to temporary memory-based stream
        // <m_psBuf> since the caller may read properties in any order...

        // set <m_psBuf> to be a new empty memory-based stream
        if (FAILED(hrReturn = CreateStreamOnHGlobal(NULL, TRUE, &m_psBuf)))
            goto ERR_EXIT;

        // loop once for each property in <m_ps>
        while (TRUE)
        {
            // set <vp> to the next property name/value pair in <m_ps>
            VariantPropertyClear(&vp);
            if (FAILED(hrReturn = ReadVariantProperty(m_ps, &vp, 0)))
                goto ERR_EXIT;
            if (hrReturn == S_FALSE)
            {
                // hit end of sequence of properties
                hrReturn = S_OK;
                break;
            }

            // write <vp> to <m_psBuf>
            if (FAILED(hrReturn = WriteVariantProperty(m_psBuf, &vp, 0)))
                goto ERR_EXIT;
        }
    }

    // seek <m_psBuf> to the beginning
    if (FAILED(hrReturn = m_psBuf->Seek(liZero, SEEK_SET, NULL)))
        goto ERR_EXIT;

    // loop once for each property in <m_psBuf>
    while (TRUE)
    {
        // set <vp> to the next property name/value pair in <m_psBuf>
        VariantPropertyClear(&vp);
        if (FAILED(hrReturn = ReadVariantProperty(m_psBuf, &vp, 0)))
            goto ERR_EXIT;
        if (hrReturn == S_FALSE)
        {
            // hit end of sequence of properties
            break;
        }

        // see if <vp> is the property the caller wants to read
        if (CompareUNICODEStrings(vp.bstrPropName, pszPropName) == 0)
        {
            // it is
            VARTYPE vtRequested = pVar->vt;
            if (vtRequested == VT_EMPTY)
            {
                // caller wants the property value in its default type;
                // hand ownership of <vp.varValue> to the caller
                *pVar = vp.varValue;
                VariantInit(&vp.varValue); // prevent double deallocation
            }
            else
            {
                // coerce <vp> to the requested type
                VariantInit(pVar);
                if (FAILED(hrReturn = VariantChangeType(pVar, &vp.varValue,
                        0, vtRequested)))
                    goto ERR_EXIT;
            }
            goto EXIT;
        }
    }

    // property <pszPropName> not found
    hrReturn = E_INVALIDARG;
    goto ERR_EXIT;

ERR_EXIT:

    // error cleanup
    // (nothing to do)
    goto EXIT;

EXIT:

    // normal cleanup
    VariantPropertyClear(&vp);

    return hrReturn;
}

STDMETHODIMP CPropertyBagOnStream::Write(LPCOLESTR pszPropName,
    LPVARIANT pVar)
{
    VariantProperty vp;
    if ((vp.bstrPropName = SysAllocString(pszPropName)) == NULL)
        return E_OUTOFMEMORY;
    vp.varValue = *pVar;
    HRESULT hr = WriteVariantProperty(m_ps, &vp, 0);
    SysFreeString(vp.bstrPropName);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\apbovp.cpp ===
// apbovp.cpp
//
// Implements AllocPropertyBagOnVariantProperty.
//
// Important: This .cpp file assumes a zero-initializing global "new" operator.
//
// @doc MMCTL
//

#include "precomp.h"
#include "..\..\inc\mmctlg.h" // see comments in "mmctl.h"
#include "..\..\inc\ochelp.h"
#include "debug.h"


/////////////////////////////////////////////////////////////////////////////
// PropertyBagOnVariantProperty
//

/* @object PropertyBagOnVariantProperty |

        Implements <i IPropertyBag> whose only property is contained in
        a given <t VariantProperty>.

@supint <i IPropertyBag> | The interface to use to access the single property
        stored in the given <t VariantProperty>.

@comm   Use <f AllocPropertyBagOnVariantProperty> to create a
        <o PropertyBagOnVariantProperty> object.
*/


//////////////////////////////////////////////////////////////////////////////
// CPropertyBagOnVariantProperty
//

struct CPropertyBagOnVariantProperty : IPropertyBag
{
///// general object state
    ULONG           m_cRef;         // object reference count
    VariantProperty *m_pvp;         // parent-maintained single property

///// construction and destruction
    CPropertyBagOnVariantProperty(VariantProperty *pvp);

///// IUnknown methods
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObj);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

///// IPropertyBag methods
    STDMETHODIMP Read(LPCOLESTR pszPropName, LPVARIANT pVar,
        LPERRORLOG pErrorLog);
    STDMETHODIMP Write(LPCOLESTR pszPropName, LPVARIANT pVar);
};


/////////////////////////////////////////////////////////////////////////////
// PropertyBagOnVariantProperty Creation & Destruction
//

/* @func HRESULT | AllocPropertyBagOnVariantProperty |

        Creates a <o PropertyBagOnVariantProperty> object which implements
        <i IPropertyBag> whose only property is contained in a given
        <t VariantProperty>.

@rvalue S_OK |
        Success.

@rvalue E_OUTOFMEMORY |
        Out of memory.

@parm   VariantProperty * | pvp | Holds the single property that the
        implemented property bag contains.  The caller must allocate *<p pvp>;
        the <t PropertyBagOnVariantProperty> object <y holds onto> *<p pvp>
        for the duration of its lifetime, so the caller is responsible for
        ensuring that *<p pvp> is valid for the lifetime of this object.
        Both <p pvp>-<gt><p bstrPropName> and <p pvp>-<gt><p varValue> must
        be valid; at the very least, <p pvp>-<gt><p varValue> must contain
        an empty VARIANT (initialized using <f VariantInit>).  After the
        allocated object is freed, the caller is responsible for freeing
        the contents of *<p pvp>.

@parm   DWORD | dwFlags | Currently unused.  Must be set to 0.

@parm   IPropertyBag * * | pppb | Where to store the <i IPropertyBag>
        pointer to the new <o PropertyBagOnVariantProperty> object.  NULL is
        stored in *<p pppb> on error.

@comm   If the returned <i IPropertyBag> is written to, all properties are
        ignored except the property named <p pvp>-<gt><p bstrPropName>,
        whose value is saved to <p pvp>-<gt><p varValue>.  If the property bag
        is read from, <om IPropertyBag.Read> will return E_FAIL for all
        properties except <p pvp>-<gt><p bstrPropName>, whose returned value is
        <p pvp>-<gt><p varValue>.

        <o PropertyBagOnVariantProperty> is really only useful in specialized
        applications which want to efficiently set or get a single property
        value from an object.
*/
STDAPI AllocPropertyBagOnVariantProperty(VariantProperty *pvp, DWORD dwFlags,
    IPropertyBag **pppb)
{
    // create the Windows object
    if ((*pppb = (IPropertyBag *)
            New CPropertyBagOnVariantProperty(pvp)) == NULL)
        return E_OUTOFMEMORY;

    return S_OK;
}

CPropertyBagOnVariantProperty::CPropertyBagOnVariantProperty(
    VariantProperty *pvp)
{
    // initialize IUnknown
    m_cRef = 1;

    // other initialization
    m_pvp = pvp;
}


//////////////////////////////////////////////////////////////////////////////
// IUnknown Implementation
//

STDMETHODIMP CPropertyBagOnVariantProperty::QueryInterface(REFIID riid,
    LPVOID *ppv)
{
    *ppv = NULL;

#ifdef _DEBUG
    char ach[200];
    TRACE("PropertyBagOnVariantProperty::QI('%s')\n", DebugIIDName(riid, ach));
#endif

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IPropertyBag))
        *ppv = (IPropertyBag *) this;
    else
        return E_NOINTERFACE;

    ((IUnknown *) *ppv)->AddRef();
    return S_OK;
}

STDMETHODIMP_(ULONG) CPropertyBagOnVariantProperty::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CPropertyBagOnVariantProperty::Release()
{
    if (--m_cRef == 0L)
    {
        // free the object
        Delete this;
        return 0;
    }
    else
        return m_cRef;
}


/////////////////////////////////////////////////////////////////////////////
// IPropertyBag
//

STDMETHODIMP CPropertyBagOnVariantProperty::Read(LPCOLESTR pszPropName,
    LPVARIANT pVar, LPERRORLOG pErrorLog)
{
    if (CompareUNICODEStrings(pszPropName, m_pvp->bstrPropName) == 0)
    {
        VARTYPE vtRequested = pVar->vt;
        VariantInit(pVar);
        if (vtRequested == VT_EMPTY)
        {
            // caller wants property value in its default type
            return VariantCopy(pVar, &m_pvp->varValue);
        }
        else
        {
            // coerce the property value to the requested type
            return VariantChangeType(pVar, &m_pvp->varValue, 0, vtRequested);
        }
    }

    return E_FAIL;
}

STDMETHODIMP CPropertyBagOnVariantProperty::Write(LPCOLESTR pszPropName,
    LPVARIANT pVar)
{
    if (CompareUNICODEStrings(pszPropName, m_pvp->bstrPropName) == 0)
        return VariantCopy(&m_pvp->varValue, pVar);

    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\avio.cpp ===
// avio.cpp
//
// Implements AllocVariantIO.
//
// Important: This .cpp file assumes a zero-initializing global "new" operator.
//
// @doc MMCTL
//

#include "precomp.h"
#include "..\..\inc\mmctlg.h" // see comments in "mmctl.h"
#include "..\..\inc\ochelp.h"
#include "debug.h"


/////////////////////////////////////////////////////////////////////////////
// VariantIO
//


/* @object VariantIO |

        Provides a property bag implementation which supports <i IPropertyBag>
        as well as <i IVariantIO>, <i IManageVariantIO>, and
        <i IEnumVariantProperty>.

@supint <i IPropertyBag> | Allows properties to be read from and written to the
        <o VariantIO> object.

@supint <i IVariantIO> | An alternative to <i IPropertyBag> which allows the
        caller to implement property-based persistence with less code.

@supint <i IManageVariantIO> | Based on <i IVariantIO>.  Allows the caller to
        control how the methods of <i IVariantIO> operate (e.g. whether the
        <i IVariantIO> is in loading mode or saving mode).

@supint <i IEnumVariantProperty> | Allows the caller to enumerate the
        properties that are currently in the <o VariantIO> object.  Note that
        <o VariantIO> does not implement <om IEnumVariantProperty.Clone>.

@comm   Use <f AllocVariantIO> to create a <o VariantIO> object.

*/


/* @interface IVariantIO |

        Allows property name/value pairs to be loaded or saved.  <i IVariantIO>
        is an alternative to <i IPropertyBag> which allows the caller to
        implement property-based persistence with less code.

@meth   HRESULT | PersistList | Loads or saves a list of property name/value
        pairs, specified as a va_list array.

@meth   HRESULT | Persist | Loads or saves a list of property name/value
        pairs, specified as a variable-length list of arguments.

@meth   HRESULT | IsLoading | Return S_OK if the <i IVariantIO> object is
        being used to load properties, S_FALSE if it is being used to save
        properties.
*/


/* @interface IManageVariantIO |

        Based on <i IVariantIO>.  Allows the caller to control how the methods
        of the <i IVariantIO> object operate (e.g. whether the <i IVariantIO>
        object is in loading mode or saving mode).

@meth   HRESULT | SetMode | Sets the mode of the <i IVariantIO> object.

@meth   HRESULT | SetMode | Gets the mode of the <i IVariantIO> object.

@meth   HRESULT | DeleteAllProperties | Removes all property/value pairs from
        the <i VariantIO> object.
*/


/* @struct VariantProperty |

        Contains the name and value of a property.

@field  BSTR | bstrPropName | The name of the property.

@field  VARIANT | varValue | The value of the property.

@comm   <i IEnumVariantProperty> uses this structure.
*/


/* @interface IEnumVariantProperty |

        Allows the properties of an object to be enumerated.

@meth   HRESULT | Next | Retrieves a specified number of items in the
        enumeration sequence.

@meth   HRESULT | Skip | Skips over a specified number of items in the
        enumeration sequence.

@meth   HRESULT | Reset | Resets the enumeration sequence to the beginning.

@meth   HRESULT | Clone | Creates another enumerator that contains the same
        enumeration state as the current one.  Note that <o VariantIO> does
        not implement this method.

@comm   The <o VariantIO> implementation of <i IEnumVariantProperty>
        has these restrictions:

@item       <om .Clone> is not supported.

@item       <om .Reset> is automatically called whenever a property is
            removed from the <o VariantIO> object.
*/


//////////////////////////////////////////////////////////////////////////////
// CVariantIO
//

struct VariantPropertyNode : VariantProperty
{
///// state
    VariantPropertyNode *pnodeNext; // next node in linked list
    VariantPropertyNode *pnodePrev; // previous node in linked list

///// construction and destruction
    VariantPropertyNode(LPCOLESTR oszPropNameX, VARIANT *pvarValueX,
        VariantPropertyNode *pnodeNextX, HRESULT *phr)
    {
        if (oszPropNameX != NULL)
            bstrPropName = SysAllocString(oszPropNameX);
        if (pvarValueX != NULL)
            VariantCopyInd(&varValue, pvarValueX);
        if (pnodeNextX != NULL)
        {
            pnodeNext = pnodeNextX;
            pnodePrev = pnodeNextX->pnodePrev;
            pnodeNext->pnodePrev = this;
            pnodePrev->pnodeNext = this;
        }
        if (phr != NULL)
            *phr = (((bstrPropName != NULL) && (pvarValueX->vt == varValue.vt))
                ? S_OK : E_OUTOFMEMORY);
    }
    ~VariantPropertyNode()
    {
        SysFreeString(bstrPropName);
        VariantClear(&varValue);
        if (pnodeNext != NULL)
            pnodeNext->pnodePrev = pnodePrev;
        if (pnodePrev != NULL)
            pnodePrev->pnodeNext = pnodeNext;
    }
};

struct CVariantIO : IManageVariantIO, IEnumVariantProperty, IPropertyBag
{
///// general object state
    ULONG           m_cRef;         // object reference count
    DWORD           m_dwFlags;      // VIO_ flags (below)
    VariantPropertyNode m_nodeHead; // head of linked list (contains no data)
    VariantPropertyNode *m_pnodeCur; // current node in enumeration

///// helper operations
    VariantPropertyNode *FindProperty(LPCOLESTR pszPropName);

///// construction and destruction
    CVariantIO();
    ~CVariantIO();

///// IUnknown methods
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObj);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

///// IVariantIO methods
    STDMETHODIMP PersistList(DWORD dwFlags, va_list args);
    HRESULT __cdecl Persist(DWORD dwFlags, ...);
    STDMETHODIMP IsLoading();

///// IManageVariantIO members
    STDMETHODIMP SetMode(DWORD dwFlags);
    STDMETHODIMP GetMode(DWORD *pdwFlags);
    STDMETHODIMP DeleteAllProperties();

///// IEnumVariantProperty members
    STDMETHODIMP Next(unsigned long celt, VariantProperty *rgvp,
        unsigned long *pceltFetched);
    STDMETHODIMP Skip(unsigned long celt);
    STDMETHODIMP Reset();
    STDMETHODIMP Clone(IEnumVariantProperty **ppenum);

///// IPropertyBag methods
    STDMETHODIMP Read(LPCOLESTR pszPropName, LPVARIANT pVar,
        LPERRORLOG pErrorLog);
    STDMETHODIMP Write(LPCOLESTR pszPropName, LPVARIANT pVar);
};


/////////////////////////////////////////////////////////////////////////////
// VariantIO Creation & Destruction
//

/* @func HRESULT | AllocVariantIO |

        Creates a <o VariantIO> object which provides a property bag
        implementation which supports <i IPropertyBag> as well as
        <i IVariantIO>, <i IManageVariantIO>, and <i IEnumVariantProperty>.

@rvalue S_OK |
        Success.

@rvalue E_OUTOFMEMORY |
        Out of memory.

@parm   IManageVariantIO * * | ppmvio | Where to store the <i IManageVariantIO>
        pointer to the new <o VariantIO> object.  NULL is stored in *<p ppmvio>
        on error.

@comm   Note that <i IManageVariantIO> is based on <i IVariantIO>, so
        the pointer returned in *<p ppmvio> can be safely cast to
        an <i IVariantIO> pointer.
*/
STDAPI AllocVariantIO(IManageVariantIO **ppmvio)
{
    // create the Windows object
    if ((*ppmvio = (IManageVariantIO *) New CVariantIO()) == NULL)
        return E_OUTOFMEMORY;

    return S_OK;
}

CVariantIO::CVariantIO() :
    m_nodeHead(NULL, NULL, NULL, NULL)
{
    // initialize IUnknown
    m_cRef = 1;

    // initialize the circular doubly-linked list of VariantPropertyNode
    // structures to contain a single "head" item <m_nodeHead> (which is
    // not used to contain any actual data) which initially points to itself
    // (since it's initially the only node in the circular list)
    m_nodeHead.pnodeNext = m_nodeHead.pnodePrev = &m_nodeHead;

    // reset the property enumeration
    Reset();
}

CVariantIO::~CVariantIO()
{
    // cleanup
    DeleteAllProperties();
}


//////////////////////////////////////////////////////////////////////////////
// Helper Operations
//


// pnode = FindProperty(szPropName)
//
// Return a pointer to the node that contains the property named <szPropName>.
// Return NULL if no such node exists.
//
VariantPropertyNode *CVariantIO::FindProperty(LPCOLESTR pszPropName)
{
    // loop once for each property/value pair stored in this object
    for (VariantPropertyNode *pnode = m_nodeHead.pnodeNext;
         pnode != &m_nodeHead;
         pnode = pnode->pnodeNext)
    {
        if (CompareUNICODEStrings(pnode->bstrPropName, pszPropName) == 0)
        {
            // found the desired property
            return pnode;
        }
    }

    // desired property not found
    return NULL;
}


//////////////////////////////////////////////////////////////////////////////
// IUnknown Implementation
//

STDMETHODIMP CVariantIO::QueryInterface(REFIID riid, LPVOID *ppv)
{
    *ppv = NULL;

#if 0
#ifdef _DEBUG
    char ach[200];
    TRACE("VariantIO::QI('%s')\n", DebugIIDName(riid, ach));
#endif
#endif

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IVariantIO) ||
        IsEqualIID(riid, IID_IManageVariantIO))
        *ppv = (IManageVariantIO *) this;
    else
    if (IsEqualIID(riid, IID_IEnumVariantProperty))
        *ppv = (IEnumVariantProperty *) this;
    else
    if (IsEqualIID(riid, IID_IPropertyBag))
        *ppv = (IPropertyBag *) this;
    else
        return E_NOINTERFACE;

    ((IUnknown *) *ppv)->AddRef();
    return S_OK;
}

STDMETHODIMP_(ULONG) CVariantIO::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CVariantIO::Release()
{
    if (--m_cRef == 0L)
    {
        // free the object
        Delete this;
        return 0;
    }
    else
        return m_cRef;
}


/////////////////////////////////////////////////////////////////////////////
// IVariantIO
//


/* @method HRESULT | IVariantIO | PersistList |

        Loads or saves a list of property name/value pairs, specified as a
        va_list array.

@rvalue S_OK | Success.  At least one of the variables listed in
        <p args> was written to, so the control may want to update
        itself accordingly.

@rvalue S_FALSE | None of the variables listed in <p args> were
        written to (either because the <i IVariantIO> object is in
        saving mode or because none of the properties named in
        <p args> exist in the <i IVariantIO> object).

@rvalue DISP_E_BADVARTYPE | One of the VARTYPE values in <p args> is invalid.

@rvalue DISP_E_TYPEMISMATCH | One of the variables in <p args> could not be
        coerced to the type of the corresponding property in the <i IVariantIO>
        object, or vice versa.

@rvalue E_OUTOFMEMORY | Out of memory.

@parm   DWORD | dwFlags | Optional flags.  See <om IManageVariantIO.SetMode> for
		possible values.

@parm   va_list | args | The arguments to pass.  See <om .Persist>
        for information about the organization of these arguments.
*/
STDMETHODIMP CVariantIO::PersistList(DWORD dwFlags, va_list args)
{
    return PersistVariantIOList(this, m_dwFlags, args);
}


/* @method HRESULT | IVariantIO | Persist |

        Loads or saves a list of property name/value pairs, specified as a
        variable-length list of arguments.

@rvalue S_OK | Success.  At least one of the variables listed in
        <p (arguments)> was written to, so the control may want to update
        itself accordingly.

@rvalue S_FALSE | None of the variables listed in <p (arguments)> were
        written to (either because the <i IVariantIO> object is in
        saving mode or because none of the properties named in
        <p (arguments)> exist in the <i IVariantIO> object.

@rvalue DISP_E_BADVARTYPE |
        One of the VARTYPE values in <p (arguments)> is invalid.

@rvalue DISP_E_TYPEMISMATCH |
        One of the variables in <p (arguments)> could not be coerced to the
        type of the corresponding property in the <i IVariantIO> object, or
        vice versa.

@rvalue E_OUTOFMEMORY | Out of memory.

@parm   DWORD | dwFlags | Optional flags.  See <om IManageVariantIO.SetMode> for
		possible values.

@parm   (varying) | (arguments) | The names, types, and pointers to variables
        containing the properties to persist.  These must consist of a series
        of argument triples (sets of 3 arguments) followed by a NULL.
        In each triplet, the first argument is an LPSTR which contains the
        name of the property; the second argument is a VARTYPE value that
        indicates the type of the property; the third argument is a pointer
        to a variable (typically a member variable of the control's C++ class)
        that holds the value of the property.  This variable will be read
        from or written to depending on the mode of the <i VariantIO> object
        (see <om IVariantIO.IsLoading>) -- therefore the variables should
        contain valid values before <om .Persist> is called.  The following
        VARTYPE values are supported:

        @flag   VT_INT | The following argument is an int *.

        @flag   VT_I2 | The following argument is a short *.

        @flag   VT_I4 | The following argument is a long *.

        @flag   VT_BOOL | The following argument is a BOOL * (<y not> a
                VARIANT_BOOL *).  Note that this behavior differs
                slightly from the usual definition of VT_BOOL.

        @flag   VT_BSTR | The following argument is a BSTR *.  If
                <om .Persist> changes the value of this BSTR, the previous
                BSTR is automatically freed using <f SysFreeString>.

        @flag   VT_LPSTR | The following argument is an LPSTR that points
                to a char array capable of holding at least _MAX_PATH
                characters including the terminating NULL.

        @flag   VT_UNKNOWN | The following argument is an LPUNKNOWN *.  If
                <om .Persist> changes the value of this LPUNKNOWN, the previous
                LPUNKNOWN is automatically freed using <f Release>, and the
                new value is automatically <f AddRef>d.

        @flag   VT_DISPATCH | The following argument is an LPDISPATCH *.  If
                <om .Persist> changes the value of this LPDISPATCH, the previous
                LPDISPATCH is automatically freed using <f Release>, and the
                new value is automatically <f AddRef>d.

        @flag   VT_VARIANT | The following arguement is a VARIANT *.
                This allows arbitrary parameters to be passed using this
                function.  Note that this behavior differs from the usual
                definition of VT_VARIANT.  If <om .Persist> changes the value
                of this VARIANT, the previous VARIANT value is automatically
                cleared using <f VariantClear>.

@ex     The following example persists two properties (which in BASIC would
        be a Long and a String, respectively) named "Foo" and "Bar",
        respectively. |

        pvio->Persist(0, "Foo", VT_INT, &m_iFoo, "Bar", VT_LPSTR, &m_achBar,
            NULL);
*/
HRESULT __cdecl CVariantIO::Persist(DWORD dwFlags, ...)
{
    HRESULT         hrReturn = S_OK; // function return code

    // start processing optional arguments
    va_list args;
    va_start(args, dwFlags);

    // fire the event with the specified arguments
    hrReturn = PersistList(dwFlags, args);
    
    // end processing optional arguments
    va_end(args);

    return hrReturn;
}


/* @method HRESULT | IVariantIO | IsLoading |

        Return S_OK if the <i IVariantIO> object is being used to load
        properties, S_FALSE if it is being used to save

@rvalue S_OK | The <i IVariantIO> object is in loading mode, so
        <om IVariantIO.Persist> and <om IVariantIO.PersistList> will
        copy data from properties to variables.

@rvalue S_FALSE | The <i IVariantIO> object is in saving mode, so that
        <om IVariantIO.Persist> and <om IVariantIO.PersistList> will copy
        data from variables to properties.
*/
STDMETHODIMP CVariantIO::IsLoading()
{
    return ((m_dwFlags & VIO_ISLOADING) ? S_OK : S_FALSE);
}


/////////////////////////////////////////////////////////////////////////////
// IManageVariantIO
//


/* @method HRESULT | IManageVariantIO | SetMode |

        Sets the mode of the <i IVariantIO> object.

@rvalue S_OK | Success.

@parm   DWORD | dwFlags | May contain the following flags:

        @flag   VIO_ISLOADING | Set the <i IVariantIO> object to loading
                mode, so that <om IVariantIO.Persist> and
                <om IVariantIO.PersistList> copy data from properties
                to variables.  If this flag is not spacified, then
                the <i IVariantIO> object will be set to saving mode,
                so that <om IVariantIO.Persist> and <om IVariantIO.PersistList>
                copy data from variables to properties.

		@flag	VIO_ZEROISDEFAULT | Inform the <i IVariantIO> object that
				0 is the default values for properties and that 0-valued
				properties should not be saved via <om IVariantIO.Persist> and
				<om IVariantIO.PersistList>.

@comm   When a <o VariantIO> object is created, its initial mode is such that
        none of the flags in <p dwFlags> are specified.
*/
STDMETHODIMP CVariantIO::SetMode(DWORD dwFlags)
{
    m_dwFlags = dwFlags;
    return S_OK;
}


/* @method HRESULT | IManageVariantIO | GetMode |

        Gets the mode of the <i IVariantIO> object.

@rvalue S_OK | Success.

@parm   DWORD * | *pdwFlags | Returns the flag specifying the current mode of
        the <i IVariantIO> object.  See <om .SetMode> for a description of
        these flags.

@comm   When a <o VariantIO> object is created, its initial mode is such that
        none of the flags in <p dwFlags> are specified.
*/
STDMETHODIMP CVariantIO::GetMode(DWORD *pdwFlags)
{
    *pdwFlags = m_dwFlags;
    return S_OK;
}


/* @method HRESULT | IManageVariantIO | DeleteAllProperties |

        Removes all property/value pairs from the <i VariantIO> object.

@rvalue S_OK | Success.

@rvalue E_OUTOFMEMORY | Out of memory.
*/
STDMETHODIMP CVariantIO::DeleteAllProperties()
{
    // delete all nodes
    while (m_nodeHead.pnodeNext != &m_nodeHead)
        Delete m_nodeHead.pnodeNext;

    // reset the property enumeration
    Reset();

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// IEnumVariantProperty
//


/* @method HRESULT | IEnumVariantProperty | Next |

        Retrieves a specified number of items in the enumeration sequence.

@rvalue S_OK | The number of elements returned is <p celt>.

@rvalue S_FALSE | The number of elements returned is not <p celt>.

@parm   unsigned long | celt | The number of elements being requested.

@parm   VariantProperty * | rgvp | Receives an array of size <p celt>
        (or larger) of the elements to be returned.  The caller is responsible
        for calling <f SysFreeString> and <p VariantClear> on the
        <p bstrPropName> and <p varValue> fields, respectively, of each
        element returned in <p rgvp>.  (Alternatively, the caller can simply
        call <f VariantPropertyClear> on each element returned in <p rgvp>.)

@parm   unsigned long * | pceltFetched | On return, contains the number of
        elements actually returned in <p rgelt>.  If <p pceltFetched> is NULL,
        this information is not returned.
*/
STDMETHODIMP CVariantIO::Next(unsigned long celt, VariantProperty *rgvp,
    unsigned long *pceltFetched)
{
    // internal assumption: <rgvp> may be NULL -- if so, it is ignored
    // (this assumption is required by CVariantIO::Skip)

    // initialize the count of fetched elements;
    // make <pceltFetched> point to valid memory
    unsigned long celtFetchedTmp;
    if (pceltFetched == NULL)
        pceltFetched = &celtFetchedTmp;
    *pceltFetched = 0;

    // loop once for each element to skip
    while (celt-- > 0)
    {
        // set <m_pnodeCur> to the next element in the list
        if (m_pnodeCur->pnodeNext == &m_nodeHead)
            return S_FALSE; // hit the end of the list
        m_pnodeCur = m_pnodeCur->pnodeNext;

        // update the count of fetched elements
        *pceltFetched++;

        // return a copy of the current element
        if (rgvp != NULL)
        {
            // copy the current element to <*rgvp>
            rgvp->bstrPropName = SysAllocString(m_pnodeCur->bstrPropName);
            VariantInit(&rgvp->varValue);
            VariantCopy(&rgvp->varValue, &m_pnodeCur->varValue);
            if ((rgvp->bstrPropName == NULL) ||
                (rgvp->varValue.vt != m_pnodeCur->varValue.vt))
                goto EXIT_ERR; // copy operation failed
            rgvp++;
        }
    }

    return S_OK;

EXIT_ERR:

    // an error occurred -- free all the memory we allocated
    while (*pceltFetched-- > 0)
    {
        // note that SysFreeString() and VariantClear() operate correctly
        // on zero-initialized values
        SysFreeString(rgvp->bstrPropName);
        VariantClear(&rgvp->varValue);
        rgvp--;
    }

    return E_OUTOFMEMORY;
}


/* @method HRESULT | IEnumVariantProperty | Skip |

        Skips over a specified number of items in the enumeration sequence.

@rvalue S_OK | The number of elements skipped is <p celt>.

@rvalue S_FALSE | The number of elements skipped is not <p celt>.

@parm   unsigned long | celt | The number of elements that are to be skipped.

*/
STDMETHODIMP CVariantIO::Skip(unsigned long celt)
{
    return Next(celt, NULL, NULL);
}


/* @method HRESULT | IEnumVariantProperty | Reset |

        Resets the enumeration sequence to the beginning.

@rvalue S_OK | Success.

@comm   There is no guarantee that the same set of objects will be enumerated
        after the reset, because it depends on the collection being enumerated.
*/
STDMETHODIMP CVariantIO::Reset()
{
    m_pnodeCur = &m_nodeHead;
    return S_OK;
}


/* @method HRESULT | IEnumVariantProperty | Clone |

        Creates another enumerator that contains the same enumeration state
        as the current one.

@rvalue S_OK | Success.

@rvalue E_OUTOFMEMORY | Out of memory.

@rvalue E_UNEXPECTED | An unexpected error occurred.

@parm   IEnumVariantProperty * * | ppenum | On exit, contains the duplicate
        enumerator.  If the function was unsuccessful, this parameter's value
        is undefined.

@comm   Note that <o VariantIO> does not implement this method.
*/
STDMETHODIMP CVariantIO::Clone(IEnumVariantProperty **ppenum)
{
    return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// IPropertyBag
//

STDMETHODIMP CVariantIO::Read(LPCOLESTR pszPropName, LPVARIANT pVar,
    LPERRORLOG pErrorLog)
{
    // set <pnode> to the node containing the property named <pszPropName>
    VariantPropertyNode *pnode = FindProperty(pszPropName);
    if (pnode == NULL)
        return E_INVALIDARG; // property not found

    // found the desired property
    VARTYPE vtRequested = pVar->vt;
    VariantInit(pVar);
    if (vtRequested == VT_EMPTY)
    {
        // caller wants property value in its default type
        return VariantCopy(pVar, &pnode->varValue);
    }
    else
    {
        // coerce property value to requested type
        return VariantChangeType(pVar, &pnode->varValue, 0, vtRequested);
    }
}

STDMETHODIMP CVariantIO::Write(LPCOLESTR pszPropName, LPVARIANT pVar)
{
    // set <pnode> to the node containing the property named <pszPropName>
    VariantPropertyNode *pnode = FindProperty(pszPropName);
    if (pnode != NULL)
    {
        // found the node -- change its value to <pVar>
        return VariantCopy(&pnode->varValue, pVar);
    }
    else
    {
        // no node named <pszPropName> exists; append a new VariantPropertyNode
        // containing a copy of <pszPropName> and <pVar> to the end of the
        // linked list of nodes
        HRESULT hr;
        pnode = New VariantPropertyNode(pszPropName, pVar,
            &m_nodeHead, &hr);
        if (pnode == NULL)
            return E_OUTOFMEMORY;
        if (FAILED(hr))
        {
            Delete pnode;
            return hr;
        }
        return hr;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\avioopb.cpp ===
// avioopb.cpp
//
// Implements AllocVariantIOOnPropertyBag.
//
// Important: This .cpp file assumes a zero-initializing global "new" operator.
//
// @doc MMCTL
//

#include "precomp.h"
#include "..\..\inc\mmctlg.h" // see comments in "mmctl.h"
#include "..\..\inc\ochelp.h"
#include "debug.h"


/////////////////////////////////////////////////////////////////////////////
// VariantIOOnPropertyBag
//

/* @object VariantIOOnPropertyBag |

        Provides an implementation of <i IVariantIO> (and <i IManageVariantIO>)
        that operates on a given <i IPropertyBag>.

@supint <i IVariantIO> | An alternative to <i IPropertyBag> which allows the
        caller to implement property-based persistence with less code.

@supint <i IManageVariantIO> | Based on <i IVariantIO>.  Allows the caller to
        control how the methods of <i IVariantIO> operate (e.g. whether the
        <i IVariantIO> is in loading mode or saving mode).  Note that
        <o VariantIOOnPropertyBag> does not implement
        <om IManageVariantIO.DeleteAllProperties>.

@supint <i IPropertyBag> | Provides access to the same <i IPropertyBag>
        object that was given to <f AllocVariantIOOnPropertyBag> as
        the <i IPropertyBag> to operate on.

@comm   Use <f AllocVariantIOOnPropertyBag> to create a
        <o VariantIOOnPropertyBag> object.
*/


//////////////////////////////////////////////////////////////////////////////
// CVariantIOOnPropertyBag
//

struct CVariantIOOnPropertyBag : IManageVariantIO, IPropertyBag
{
///// general object state
    ULONG           m_cRef;         // object reference count
    IPropertyBag *  m_ppb;          // property bag that object operates on
    DWORD           m_dwFlags;      // VIO_ flags (below)

///// construction and destruction
    CVariantIOOnPropertyBag(IPropertyBag *);
    ~CVariantIOOnPropertyBag();

///// IUnknown methods
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObj);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

///// IVariantIO methods
    STDMETHODIMP PersistList(DWORD dwFlags, va_list args);
    HRESULT __cdecl Persist(DWORD dwFlags, ...);
    STDMETHODIMP IsLoading();

///// IManageVariantIO members
    STDMETHODIMP SetMode(DWORD dwFlags);
    STDMETHODIMP GetMode(DWORD *pdwFlags);
    STDMETHODIMP DeleteAllProperties();

///// IPropertyBag methods
    STDMETHODIMP Read(LPCOLESTR pszPropName, LPVARIANT pVar,
        LPERRORLOG pErrorLog);
    STDMETHODIMP Write(LPCOLESTR pszPropName, LPVARIANT pVar);
};


/////////////////////////////////////////////////////////////////////////////
// VariantIOOnPropertyBag Creation & Destruction
//

/* @func HRESULT | AllocVariantIOOnPropertyBag |

        Creates a <o VariantIOOnPropertyBag> object which provides an
        implementation of <i IVariantIO> (and <i IManageVariantIO>)
        that operates on a given <i IPropertyBag>.

@rvalue S_OK |
        Success.

@rvalue E_OUTOFMEMORY |
        Out of memory.

@parm   IPropertyBag * | ppb | Property bag that the new object is to
        operate on.

@parm   IManageVariantIO * * | ppmvio | Where to store the <i IManageVariantIO>
        pointer to the new <o VariantIOOnPropertyBag> object.  NULL is stored
        in *<p ppmvio> on error.

@comm   Note that <i IManageVariantIO> is based on <i IVariantIO>, so
        the pointer returned in *<p ppmvio> can be safely cast to
        an <i IVariantIO> pointer.
*/
STDAPI AllocVariantIOOnPropertyBag(IPropertyBag *ppb, IManageVariantIO **ppmvio)
{
    // create the Windows object
    if ((*ppmvio = (IManageVariantIO *) New CVariantIOOnPropertyBag(ppb))
            == NULL)
        return E_OUTOFMEMORY;

    return S_OK;
}

CVariantIOOnPropertyBag::CVariantIOOnPropertyBag(IPropertyBag *ppb)
{
    // initialize IUnknown
    m_cRef = 1;

    // other initialization
    m_ppb = ppb;
    m_ppb->AddRef();
}

CVariantIOOnPropertyBag::~CVariantIOOnPropertyBag()
{
    // cleanup
    m_ppb->Release();
}


//////////////////////////////////////////////////////////////////////////////
// IUnknown Implementation
//

STDMETHODIMP CVariantIOOnPropertyBag::QueryInterface(REFIID riid, LPVOID *ppv)
{
    *ppv = NULL;

#ifdef _DEBUG
    char ach[200];
    TRACE("VariantIOOnPropertyBag::QI('%s')\n", DebugIIDName(riid, ach));
#endif

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IVariantIO) ||
        IsEqualIID(riid, IID_IManageVariantIO))
        *ppv = (IManageVariantIO *) this;
    else
    if (IsEqualIID(riid, IID_IPropertyBag))
        *ppv = (IPropertyBag *) this;
    else
        return E_NOINTERFACE;

    ((IUnknown *) *ppv)->AddRef();
    return S_OK;
}

STDMETHODIMP_(ULONG) CVariantIOOnPropertyBag::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CVariantIOOnPropertyBag::Release()
{
    if (--m_cRef == 0L)
    {
        // free the object
        Delete this;
        return 0;
    }
    else
        return m_cRef;
}


/////////////////////////////////////////////////////////////////////////////
// IVariantIO
//

STDMETHODIMP CVariantIOOnPropertyBag::PersistList(DWORD dwFlags, va_list args)
{
	// $Review: Notice in the following line that <dwFlags> is OR-ed with
	// <m_dwFlags>.  <m_dwFlags> has already been set (via SetMode()) to indicate
	// if we're loading or saving.  <dwFlags> has any additional flags (e.g.,
	// VIO_ZEROISDEFAULT).  I didn't alter <m_dwFlags> because to avoid a 
	// change in mode.  I believe this is the only place where the OR is needed
	// since Persist() calls this function.  Rick, does this seem correct?
	// (6/26/96 a-swehba)
    return PersistVariantIOList(m_ppb, m_dwFlags | dwFlags, args);
}

HRESULT __cdecl CVariantIOOnPropertyBag::Persist(DWORD dwFlags, ...)
{
    HRESULT         hrReturn = S_OK; // function return code

    // start processing optional arguments
    va_list args;
    va_start(args, dwFlags);

    // fire the event with the specified arguments
    hrReturn = PersistList(dwFlags, args);
    
    // end processing optional arguments
    va_end(args);

    return hrReturn;
}

STDMETHODIMP CVariantIOOnPropertyBag::IsLoading()
{
    return ((m_dwFlags & VIO_ISLOADING) ? S_OK : S_FALSE);
}


/////////////////////////////////////////////////////////////////////////////
// IManageVariantIO
//

STDMETHODIMP CVariantIOOnPropertyBag::SetMode(DWORD dwFlags)
{
    m_dwFlags = dwFlags;
    return S_OK;
}

STDMETHODIMP CVariantIOOnPropertyBag::GetMode(DWORD *pdwFlags)
{
    *pdwFlags = m_dwFlags;
    return S_OK;
}

STDMETHODIMP CVariantIOOnPropertyBag::DeleteAllProperties()
{
    return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// IPropertyBag
//

STDMETHODIMP CVariantIOOnPropertyBag::Read(LPCOLESTR pszPropName,
    LPVARIANT pVar, LPERRORLOG pErrorLog)
{
    return m_ppb->Read(pszPropName, pVar, pErrorLog);
}

STDMETHODIMP CVariantIOOnPropertyBag::Write(LPCOLESTR pszPropName,
    LPVARIANT pVar)
{
    return m_ppb->Write(pszPropName, pVar);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\border.cpp ===
// border.cpp
//
// Implements DrawControlBorder.
//
// @doc MMCTL
//

#include "precomp.h"
#include "..\..\inc\mmctlg.h"
#include "..\..\inc\ochelp.h"
#include "debug.h"


// private constants
#define CXY_HANDLE      4       // width of a handle (must be even)
#define CXY_PERIMETER   1       // width of perimeter line (currently must be 1)
#define CXY_INFLATE     (CXY_HANDLE + CXY_PERIMETER) // amt. to inflate rect. by


/* @func HRESULT | DrawControlBorder |

        Draws a border used to drag and resize controls.

@rvalue S_OK | Success.

@rvalue S_FALSE | Success.  Also indicates that *<p ppt> does not fall within
        any portion of the control border.

@parm   HDC | hdc | Device context to draw into.  If <p hdc> is NULL then
        no drawing is performed.

@parm   RECT * | prc | Where to draw border.  The border is drawn <y outside>
        this border.  If both <p ppt> and <p pptNew> are non-NULL, then
        on exit *<p prc> is modified to contain the border rectangle obtained
        after the mouse is dragged from <p ppt> to <p pptNew>.

@parm   POINT * | ppt | Mouse position.  See <p prc> and <p piHit>.

@parm   POINT * | pptNew | New mouse position.  See <p prc> and <p piHit>.
        Note that if <p pptNew> specifies an invalid mouse move (e.g. it
        would cause the right side of *<p prc> to be dragged to the left of
        the left side of *<p prc>) then *<p pptNew> is adjusted so that
        it is valid.

@parm   int * | piHit | If <p pptNew> is NULL, then on exit *<p piHit> contains
        a "hit test code" that indicates which part of the contro border was
        hit by *<p ppt>.  If <p pptNew> is not NULL, then on entry *<p piHit>
        must contain a hit test code (usually returned from a previous call
        to <f DrawControlBorder>) indicating which part of the control border
        the user wants to drag.  The hit test codes are as follows:

        @flag   DCB_HIT_NONE | No part of the border was hit.

        @flag   DCB_HIT_EDGE | The edge of the border was hit, but no
                grab handle was hit.

        @flag   DCB_HIT_GRAB(<p i>, <p j>) | Grab handle (<p i>, <p j>) was hit,
                where <p i> is the horizontal position of the grab handle
                (0=left, 1=middle, 2=right) and <p j> is the vertical position
                of the handle (0=top, 1=middle, 2=bottom).  See Comments below
                for more information about how to interpret *<p piHit>.

@parm   DWORD | dwFlags | May contain the following flags:

        @flag   DCB_CORNERHANDLES | Draw resize grab handles at the corners
                of the border rectangle.

        @flag   DCB_SIDEHANDLES | Draw resize grab handles at the sides
                of the border rectangle.

        @flag   DCB_EDGE | Draw the edge of the border rectangle of the
                border rectangle.

        @flag   DCB_XORED | Draw the border with an exclusive-or brush.

        @flag   DCB_INFLATE | On exit, inflate *<p prc> enough so that it
                encloses the control border.

@comm   You can test if *<p piHit> refers to a specific category of grab
        handle by computing the value (1 <lt><lt> *<p piHit>) and peforming a
        bitwise and (&) with any of the following bit masks:

        @flag   DCB_CORNERHANDLES | *<p piHit> refers to a corner grab handle.

        @flag   DCB_SIDEHANDLES | *<p piHit> refers to a side grab handle.

        @flag   DCB_SIZENS | *<p piHit> refers to a vertical (north-south
                resize grab handle (on the left or right sides).

        @flag   DCB_SIZEWE | *<p piHit> refers to a horizontal (west-east)
                resize grab handle (on the left or right sides).

        @flag   DCB_SIZENESW | *<p piHit> refers to a resize grab handle at
                the north-east or south-west corner.

        @flag   DCB_SIZENWSE | *<p piHit> refers to a resize grab handle at
                the north-west or south-east corner.

@ex     The following example shows how to use <f DrawControlBorder> to
        draw a border around a control (which is at position <p g_rcControl>
        in the client area of a window) and allow the control to be moved
        and resized. |

        // globals
        HINSTANCE       g_hinst;     // application instance handle
        RECT            g_rcControl;// location of simulated control
        RECT            g_rcGhost;  // location of ghost (XOR) image of border
        POINT           g_ptPrev;   // previous mouse location
        int             g_iDrag;    // which part of control border is dragged

        // window procedure of the window that contains the control
        LRESULT CALLBACK AppWndProc(HWND hwnd, UINT uiMsg, WPARAM wParam,
            LPARAM lParam)
        {
            PAINTSTRUCT     ps;
            int             iHit;
            HDC             hdc;
            POINT           ptCursor;
            RECT            rc;
            LPCTSTR         sz;

            switch (uiMsg)
            {

            case WM_PAINT:

                hdc = BeginPaint(hwnd, &ps);

                // draw the control
                ...

                // draw the control border outside <g_rcControl>
                DrawControlBorder(hdc, &g_rcControl, NULL, NULL, NULL,
                    DCB_EDGE | DCB_CORNERHANDLES | DCB_SIDEHANDLES);

                EndPaint(hwnd, &ps);
                return 0;

            case WM_SETCURSOR:

                // set <ptCursor> to the mouse position
                GetCursorPos(&ptCursor);
                ScreenToClient(hwnd, &ptCursor);

                // set <iHit> to a hit code which indicates which part of the
                // control border (if any) <ptCursor> is over
                DrawControlBorder(NULL, &g_rcControl, &ptCursor, NULL, &iHit,
                        DCB_EDGE | DCB_CORNERHANDLES | DCB_SIDEHANDLES);

                // set the cursor based on <iHit>
                if ((1 << iHit) & DCB_SIZENS)
                    sz = IDC_SIZENS;
                else
                if ((1 << iHit) & DCB_SIZEWE)
                    sz = IDC_SIZEWE;
                else
                if ((1 << iHit) & DCB_SIZENESW)
                    sz = IDC_SIZENESW;
                else
                if ((1 << iHit) & DCB_SIZENWSE)
                    sz = IDC_SIZENWSE;
                else
                    sz = IDC_ARROW;
                SetCursor(LoadCursor(NULL, sz));
                return TRUE;

            case WM_LBUTTONDOWN:

                // set <ptCursor> to the mouse position
                ptCursor.x = (short) LOWORD(lParam);
                ptCursor.y = (short) HIWORD(lParam);

                // do nothing if <ptCursor> is not within the control border
                if (DrawControlBorder(NULL, &g_rcControl,
                        &ptCursor, NULL, &g_iDrag,
                        DCB_EDGE | DCB_CORNERHANDLES | DCB_SIDEHANDLES) != S_OK)
                    break;

                // capture the mouse
                SetCapture(hwnd);

                // set the initial position of the border "ghost" (the XOR image
                // of the border) to be the current position of the control
                g_rcGhost = g_rcControl;

                // draw the control border XOR'd
                hdc = GetDC(hwnd);
                DrawControlBorder(hdc, &g_rcGhost, NULL, NULL, NULL,
                    DCB_EDGE | DCB_CORNERHANDLES | DCB_SIDEHANDLES | DCB_XORED);
                ReleaseDC(hwnd, hdc);

                // remember the current cursor position
                g_ptPrev = ptCursor;
                break;

            case WM_MOUSEMOVE:

                // do nothing if we're not dragging
                if (GetCapture() != hwnd)
                    break;

                // set <ptCursor> to the mouse position
                ptCursor.x = (short) LOWORD(lParam);
                ptCursor.y = (short) HIWORD(lParam);

                // move the control XOR image
                hdc = GetDC(hwnd);
                DrawControlBorder(hdc, &g_rcGhost,
                    &g_ptPrev, &ptCursor, &g_iDrag,
                    DCB_EDGE | DCB_CORNERHANDLES | DCB_SIDEHANDLES | DCB_XORED);
                ReleaseDC(hwnd, hdc);

                // remember the current cursor position
                g_ptPrev = ptCursor;
                break;

            case WM_LBUTTONUP:

                // do nothing if we're not dragging
                if (GetCapture() != hwnd)
                    break;

                // erase the control border XOR image
                hdc = GetDC(hwnd);
                DrawControlBorder(hdc, &g_rcGhost, NULL, NULL, NULL,
                    DCB_EDGE | DCB_CORNERHANDLES | DCB_SIDEHANDLES | DCB_XORED);
                ReleaseDC(hwnd, hdc);

                // stop dragging
                ReleaseCapture();

                // move the control to the new location
                rc = g_rcControl;
                DrawControlBorder(NULL, &rc, NULL, NULL, NULL,
                    DCB_EDGE | DCB_CORNERHANDLES | DCB_SIDEHANDLES |
                    DCB_INFLATE);
                InvalidateRect(hwnd, &rc, TRUE);
                g_rcControl = g_rcGhost;
                rc = g_rcControl;
                DrawControlBorder(NULL, &rc, NULL, NULL, NULL,
                    DCB_EDGE | DCB_CORNERHANDLES | DCB_SIDEHANDLES |
                    DCB_INFLATE);
                InvalidateRect(hwnd, &rc, TRUE);
                break;

            ...

            }

            return DefWindowProc(hwnd, uiMsg, wParam, lParam);
        }
*/
STDAPI DrawControlBorder(HDC hdc, RECT *prc, POINT *ppt, POINT *pptNew,
    int *piHit, DWORD dwFlags)
{
    int             r, c;           // grab handle row, column (0=left/top...2)
    HBRUSH          hbr = NULL;     // brush to draw border with
    HBRUSH          hbrPrev = NULL; // previously-selected brush
    int             iHitTmp;        // to make <piHit> be valid
    RECT            rc;
    int             x, y;

    // make sure <piHit> points to a valid integer
    if (piHit == NULL)
        piHit = &iHitTmp;

    // default <*piHit> to "missed"
    if (pptNew == NULL)
        *piHit = DCB_HIT_NONE;

    if (hdc != NULL)
    {
        // save the DC state since we'll be fiddling with the clipping region
        SaveDC(hdc);
        SetBkColor( hdc, RGB(192, 192, 192) );
    }

    if (dwFlags & (DCB_CORNERHANDLES | DCB_SIDEHANDLES))
    {
        // draw the grab handles specified by <dwFlags>
        for (r = 0; r < 3; r++)
        {
            // set <y> to the vertical center of the grab handles on row <r>
            y = (r * (prc->bottom - prc->top + CXY_HANDLE)) / 2
                + prc->top - CXY_HANDLE / 2;
            for (c = 0; c < 3; c++)
            {
                if ((1 << DCB_HIT_GRAB(c, r)) & dwFlags)
                {
                    // set <x> to the horizontal center of the grab handles
                    // on column <c>
                    x = (c * (prc->right - prc->left + CXY_HANDLE)) / 2
                        + prc->left - CXY_HANDLE / 2;

                    // set <rc> to be the rectangle that contains
                    // this grab handle
                    SetRect(&rc, x - CXY_HANDLE / 2, y - CXY_HANDLE / 2,
                        x + CXY_HANDLE / 2, y + CXY_HANDLE / 2);

                    if (hdc != NULL)
                    {
                        // draw the grab handle and then exclude it from the
                        // clipping region so that it won't be erased when
                        // the border is drawn (below)
                        PatBlt(hdc, rc.left, rc.top,
                            rc.right - rc.left, rc.bottom - rc.top,
                            (dwFlags & DCB_XORED ? DSTINVERT : BLACKNESS));
                        ExcludeClipRect(hdc, rc.left, rc.top,
                            rc.right, rc.bottom);
                    }

                    // test if <*ppt> is in a grab handle (if requested)
                    if ((ppt != NULL) && (pptNew == NULL)
                            && PtInRect(&rc, *ppt))
                        *piHit = DCB_HIT_GRAB(c, r);
                }
            }
        }
    }

    if (dwFlags & DCB_EDGE)
    {
        // set <rc> temporarily to be the rectangle that contains the
        // entire border
        rc = *prc;
        InflateRect(&rc, CXY_INFLATE, CXY_INFLATE);

        // test if <*ppt> is in the edge (if requested)
        if ((ppt != NULL) && (pptNew == NULL) && (*piHit == DCB_HIT_NONE))
        {
            if (PtInRect(&rc, *ppt) && !PtInRect(prc, *ppt))
                *piHit = DCB_HIT_EDGE;
        }

        // draw the edge (unless <hdc> is NULL)
        if (hdc != NULL)
        {
            // draw the black perimeter rectangle
            if (dwFlags & DCB_XORED)
                SetROP2(hdc, R2_XORPEN);
            SelectObject(hdc, GetStockObject(BLACK_PEN));
            SelectObject(hdc, GetStockObject(NULL_BRUSH));
            Rectangle(hdc, rc.left, rc.top, rc.right, rc.bottom);

            // draw the border
            if ((hbr = CreateBorderBrush()) != NULL)
            {
                rc = *prc;
                InflateRect(&rc, CXY_HANDLE, CXY_HANDLE);
                ExcludeClipRect(hdc, prc->left, prc->top,
                    prc->right, prc->bottom);
                hbrPrev = (HBRUSH)SelectObject(hdc, hbr);
                PatBlt(hdc, rc.left, rc.top,
                    rc.right - rc.left, rc.bottom  - rc.top,
                    (dwFlags & DCB_XORED ? PATINVERT : PATCOPY));
            }
        }
    }

    // clean up
    if (hbrPrev != NULL)
        SelectObject(hdc, hbrPrev);
    if (hbr != NULL)
        DeleteObject(hbr);
    if (hdc != NULL)
        RestoreDC(hdc, -1);

    if (pptNew != NULL)
    {
        // adjust <*prc> to account for the user dragging the mouse
        // from <*ppt> to <*pptNew>
        if (*piHit == DCB_HIT_EDGE)
        {
            // user is dragging the edge of the border
            OffsetRect(prc, pptNew->x - ppt->x, pptNew->y - ppt->y);
        }
        else
        {
            // user is dragging a grab handle...

            // adjust <*prc> horizontally
            switch (*piHit & DCB_HIT_GRAB(3, 0))
            {

            case DCB_HIT_GRAB(0, 0):

                // user is dragging one of three handles on the left side
                prc->left += pptNew->x - ppt->x;
                if (prc->left > prc->right)
                {
                    pptNew->x += prc->right - prc->left;
                    prc->left = prc->right;
                }
                break;

            case DCB_HIT_GRAB(2, 0):

                // user is dragging one of three handles on the right side
                prc->right += pptNew->x - ppt->x;
                if (prc->right < prc->left)
                {
                    pptNew->x += prc->left - prc->right;
                    prc->right = prc->left;
                }
                break;

            }

            // adjust <*prc> vertically
            switch (*piHit & DCB_HIT_GRAB(0, 3))
            {

            case DCB_HIT_GRAB(0, 0):

                // user is dragging one of three handles on the top side
                prc->top += pptNew->y - ppt->y;
                if (prc->top > prc->bottom)
                {
                    pptNew->y += prc->bottom - prc->top;
                    prc->top = prc->bottom;
                }
                break;

            case DCB_HIT_GRAB(0, 2):

                // user is dragging one of three handles on the bottom side
                prc->bottom += pptNew->y - ppt->y;
                if (prc->bottom < prc->top)
                {
                    pptNew->y += prc->top - prc->bottom;
                    prc->bottom = prc->top;
                }
                break;

            }
        }

        // draw the control border in the new position
        DrawControlBorder(hdc, prc, NULL, NULL, NULL, dwFlags);
    }

    // if requested, inflate <*prc> to include the entire border
    if (dwFlags & DCB_INFLATE)
        InflateRect(prc, CXY_INFLATE, CXY_INFLATE);

    return ((*piHit != DCB_HIT_NONE) ? S_OK : S_FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\aph.cpp ===
// aph.cpp
//
// Implements AllocPropertyHelper.
//
// Important: This .cpp file assumes a zero-initializing global "new" operator.
//
// @doc MMCTL
//

#include "precomp.h"
#include "..\..\inc\mmctlg.h" // see comments in "mmctl.h"
#include "..\..\inc\ochelp.h"
#include "debug.h"


/////////////////////////////////////////////////////////////////////////////
// PropertyHelper
//


/* @object PropertyHelper |

        Provides an implementation of <i Persist>, <i IPersistPropertyBag>,
        <i IPersistStream>, <i IPersistStreamInit>, and a simplified
        implementation of <i IDispatch>, for any object which implements
        <i IPersistVariantIO>.

@supint <i IPersistPropertyBag> | Loads or saves properties from/to a given
        <i IPropertyBag> object.  Used to provide a textual representation of
        the data of the object that implements <i IPersistVariantIO>.

@supint <i IPersistStream> | Loads or saves the data of the object that
        implements <i IPersistVariantIO> as a stream of bytes.

@supint <i IPersistStreamInit> | Like <i IPersistStream>, but with an extra
        method that allows the object to be created in a "newly initialized"
        state.

@supint <i IDispatch> | Provides script engines etc. access to the properties
        exposed by the <i IPersistVariantIO>.  This <i IDispatch>
        implementation isn't particularly fast, but it's an inexpensive way
        for a control to provide a rudimentary <i IDispatch> implementation.

@comm   Use <f AllocPropertyHelper> to create a <o PropertyHelper> object.

*/

/* @interface IPersistVariantIO |

        Loads or saves properties from/to a given <i IVariantIO> object
        (control).  Used by <o PropertyHelper> to help an object implement
        <i IPersistpropertyBag>, <i IPersistStream>, <i IPersistStreamInit>,
        and a simplified implementation of <i IDispatch>, for any object which
        implements <i IPersistVariantIO>.

@meth   HRESULT | InitNew | Informs the control that it has been created
        in a "new" state, so it should initialize its state data (if not
        done already).  If the control is being loaded from a stream,
        <om .DoPersist> will be called instead of <om .InitNew>.

@meth   HRESULT | IsDirty | Returns S_OK if the object has changed since it
        was last saved, S_FALSE otherwise.

@meth   HRESULT | DoPersist | Instructs the object to load or save its
        properties to a gieven <i IVariantIO> object.
*/

/* @method HRESULT | IPersistVariantIO | InitNew |

        Informs the control that it has been created in a "new" state, so it
        should initialize its state data (if not done already).  If the
        control is being loaded from a stream, <om .DoPersist> will be called
        instead of <om .InitNew>.

@rvalue S_OK | Success.

@rvalue E_NOTIMPL | The control does not implement this method.

@comm   The control can safely return E_NOTIMPL from this method if it
        initializes its data when it is created.  In this case, if the control
        needs to be re-initialized, the container will simply destroy and
        re-create it (which is what almost every container does anyway).
*/

/* @method HRESULT | IPersistVariantIO | IsDirty |

        Returns S_OK if the object has changed since it was last saved,
        S_FALSE otherwise.

@rvalue S_OK | The object has changed since it was last saved.

@rvalue S_FALSE | The object has not changed since it was last saved.

@comm   The control should maintain an internal "dirty flag" (e.g. a BOOL
        <p m_fDirty> class member), which should be initialized to FALSE,
        but set to TRUE whenever the control's data changes and set to
        FALSE in <om .DoPersist> when the PVIO_CLEARDIRTY flag is specified.

@ex     The following example shows how a control might implement
        <om .IsDirty> |

        STDMETHODIMP CMyControl::IsDirty()
        {
            return (m_fDirty ? S_OK : S_FALSE);
        }
*/

/* @method HRESULT | IPersistVariantIO | DoPersist |

        Instructs the object to load or save its properties to a gieven
        <i IVariantIO> object.

@parm   IVariantIO * | pvio | <i IVariantIO> object to save to or load from.

@parm   DWORD | dwFlags | May contain the following flags:

        @rdesc  Must return either S_OK or an error code.  Don't return S_FALSE!

        @flag   PVIO_PROPNAMESONLY | The caller is calling <om .DoPersist>
                purely to get a list of the names of properties from the
                control.  The control can safely ignore this flag, unless
                it wishes to use this information for optimization purposes.

        @flag   PVIO_CLEARDIRTY | The control should clear its dirty flag
                (so that the next call to <om .IsDirty> should return S_FALSE).

        @flag   PVIO_NOKIDS | The control need not persist any child controls that
		        it may contain.  For example, this flag is used by the property
				helper object when it calls DoPersist inside its
				IDispatch::GetIDsOfNames and IDispatch::Invoke.

        @flag   PVIO_RUNTIME | The control should save a runtime version of
                itself.  For example, this flag is used by the active designer
                helper object when <om IActiveDesigner.SaveRuntimeState> is
                called on the object.

@ex     The following example shows how a control might implement
        <om .DoPersist>.  Note that DoPersist must return S_OK on success. |

        STDMETHODIMP CMyControl::DoPersist(IVariantIO* pvio, DWORD dwFlags)
        {
            // load or save control properties to/from <info>
            HRESULT hr;
            if (FAILED(hr = pvio->Persist(0,
                    "BorderWidth", VT_INT, &m_iWidth,
                    "BorderColor", VT_INT, &m_rgb,
                    "X1", VT_INT, &m_iX1,
                    "Y1", VT_INT, &m_iY1,
                    "X2", VT_INT, &m_iX2,
                    "Y2", VT_INT, &m_iY2,
                    NULL)))
                return hr;
            if (hr == S_OK)
                ...one or more properties changed, so repaint etc. control...

            // clear the dirty bit if requested
            if (dwFlags & PVIO_CLEARDIRTY)
                m_fDirty = FALSE;

			// Important!  Don't return hr here, which may have been set to
			//             S_FALSE by IVariantIO::Persist.
            return S_OK;
        }

@ex     The following example shows how a control which supports <i IActiveDesigner>
        might implement <om .DoPersist>. |

        STDMETHODIMP CMyControl::DoPersist(IVariantIO* pvio, DWORD dwFlags)
        {
            // load or save runtime properties to/from <info>
            HRESULT hr;
            if (FAILED(hr = pvio->Persist(0,
                    "BorderWidth", VT_INT, &m_iWidth,
                    "BorderColor", VT_INT, &m_rgb,
                    "X1", VT_INT, &m_iX1,
                    "Y1", VT_INT, &m_iY1,
                    "X2", VT_INT, &m_iX2,
                    "Y2", VT_INT, &m_iY2,
                    NULL)))
                return hr;
            if (hr == S_OK)
                ...one or more properties changed, so repaint etc. control...

            // load or save design-time properties to/from <info>
        #ifdef _DESIGN
            if (!(dwFlags & PVIO_RUNTIME))
            {
                if (FAILED(hr = pvio->Persist(0,
                        "SomeDesignValue", VT_INT, &m_iSomeDesignValue,
                        NULL)))
                    return hr;
            }
        #endif

            // clear the dirty bit if requested
            if (dwFlags & PVIO_CLEARDIRTY)
                m_fDirty = FALSE;

			// Important!  Don't return hr here, which may have been set to
			//             S_FALSE by IVariantIO::Persist.
            return S_OK;
        }
*/

struct CPropertyHelper : INonDelegatingUnknown, IPersistStreamInit,
    IPersistPropertyBag, IDispatch
{
///// general object state
    IPersistVariantIO *m_ppvio;     // to access properties of parent
    CLSID           m_clsid;        // the class ID of the parent

///// non-delegating IUnknown implementation
    ULONG           m_cRef;         // object reference count
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) NonDelegatingAddRef();
    STDMETHODIMP_(ULONG) NonDelegatingRelease();

///// delegating IUnknown implementation
    LPUNKNOWN       m_punkOuter;    // controlling unknown
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv)
      { return m_punkOuter->QueryInterface(riid, ppv); }
    STDMETHODIMP_(ULONG) AddRef()
      { return m_punkOuter->AddRef(); }
    STDMETHODIMP_(ULONG) Release()
      { return m_punkOuter->Release(); }

///// IPersist methods
    STDMETHODIMP GetClassID(CLSID* pClassID);

///// IPersistStream methods
    STDMETHODIMP IsDirty();
    STDMETHODIMP Load(IStream* pstream);
    STDMETHODIMP Save(IStream* pstream, BOOL fClearDirty);
    STDMETHODIMP GetSizeMax(ULARGE_INTEGER* pcbSize);

///// IPersistStreamInit methods
    STDMETHODIMP InitNew();

///// IPersistPropertyBag methods
    // STDMETHODIMP InitNew(); // already provided by IPersistStream
    STDMETHODIMP Load(IPropertyBag* ppb, IErrorLog* pErrorLog);
    STDMETHODIMP Save(IPropertyBag* ppb, BOOL fClearDirty,
        BOOL fSaveAllProperties);

///// IDispatch implementation
    STDMETHODIMP GetTypeInfoCount(UINT *pctinfo);
    STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo);
    STDMETHODIMP GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames,
         LCID lcid, DISPID *rgdispid);
    STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid,
        WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult,
        EXCEPINFO *pexcepinfo, UINT *puArgErr);
};


//////////////////////////////////////////////////////////////////////////////
// PropertyHelper Construction
//

/* @func HRESULT | AllocPropertyHelper |

        Allocates a <o PropertyHelper> object which provides an implementation
        of <i IPersist>, <i IPersistPropertyBag>, <i IPersistStream>,
        <i IPersistStreamInit>, and a simplified implementation of
        <i IDispatch>, for any object which implements <i IPersistVariantIO>.

@parm   LPUNKNOWN | punkOuter | The <i IUnknown> of the parent object
        object (presumably the same object that implements
        <i IPersistVariantIO>).  Will be used as the controlling unknown of
        <o PropertyHelper>.

@parm   IPersistVariantIO * | ppvio | The interface used to access the
        properties of the parent object.  Note that this interface is
        <y not> <f AddRef>d by <f AllocPropertyHelper>, since doing so
        would likely cause a circular reference count.  Therefore it is
        the caller's responsibility to ensure that <p ppvio> remain valid
        for the lifetime of the <o PropertyHelper> object.

@parm   REFCLSID | rclsid | The class of the containing object (the object
        which implements <i IPersistVariantIO>).

@parm   DWORD | dwFlags | Currently unused.  Must be set to 0.

@parm   LPUNKNOWN * | ppunk | Where to store a pointer to the non-delegating
        <i IUnknown> of the allocated <o PropertyHelper> object.  NULL is
        stored in *<p ppunk> on error.

@comm   See <o PropertyHelper> for more information.

@ex     The following example shows how a control might use
        <f AllocPropertyHelper>.  This example control is aggregatable, though
        the control need not be aggregatable to use <f AllocPropertyHelper>. |

        // control implementation
        class CMyControl : public INonDelegatingUnknown, public IOleControl,
            public IPersistVariantIO ...
        {

        ///// general control state
        protected:
            BOOL            m_fDirty;       // TRUE iff control needs saving
            IUnknown *      m_punkPropHelp; // aggregated PropertyHelper object
            ...

        ///// construction, destruction
        public:
            CMyControl(IUnknown *punkOuter, HRESULT *phr);
            virtual ~CMyControl();

        ///// non-delegating IUnknown implementation
        protected:
            ULONG           m_cRef;         // object reference count
            STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, LPVOID *ppv);
            STDMETHODIMP_(ULONG) NonDelegatingAddRef();
            STDMETHODIMP_(ULONG) NonDelegatingRelease();

        ///// delegating IUnknown implementation
        protected:
            LPUNKNOWN       m_punkOuter;    // controlling unknown
            STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv)
              { return m_punkOuter->QueryInterface(riid, ppv); }
            STDMETHODIMP_(ULONG) AddRef()
              { return m_punkOuter->AddRef(); }
            STDMETHODIMP_(ULONG) Release()
              { return m_punkOuter->Release(); }

        ///// IOleControl implementation
        protected:
            STDMETHODIMP GetControlInfo(LPCONTROLINFO pCI);
            STDMETHODIMP OnMnemonic(LPMSG pMsg);
            STDMETHODIMP OnAmbientPropertyChange(DISPID dispid);
            STDMETHODIMP FreezeEvents(BOOL bFreeze);

        ///// IPersistVariantIO implementation
        protected:
            STDMETHODIMP InitNew();
            STDMETHODIMP IsDirty();
            STDMETHODIMP DoPersist(IVariantIO* pvio, DWORD dwFlags);

        ...
        };

        CMyControl::CMyControl(IUnknown *punkOuter, HRESULT *phr)
        {
            // initialize IUnknown state
            m_cRef = 1;
            m_punkOuter = (punkOuter == NULL ?
                (IUnknown *) (INonDelegatingUnknown *) this : punkOuter);

            // set the control's default properties
            ...

            // allocate a PropertyHelper object (to be aggregated with this
            // object) to implement persistence and properties
            if (FAILED(*phr = AllocPropertyHelper(m_punkOuter, this,
                    CLSID_CMyControl, 0, &m_punkPropHelp)))
                return;

            // other initialization
            ...

            *phr = S_OK;
        }

        CMyControl::~CMyControl()
        {
            // clean up
            if (m_punkPropHelp != NULL)
                m_punkPropHelp->Release();
            ...
        }

        STDMETHODIMP CMyControl::NonDelegatingQueryInterface(REFIID riid,
            LPVOID *ppv)
        {
            *ppv = NULL;
            if (IsEqualIID(riid, IID_IUnknown))
                *ppv = (IUnknown *) (INonDelegatingUnknown *) this;
            else
            if (IsEqualIID(riid, IID_IOleControl))
                *ppv = (IOleControl *) this;
            else
            ...
            else
                return m_punkPropHelp->QueryInterface(riid, ppv);

            ((IUnknown *) *ppv)->AddRef();
            return S_OK;
        }
*/
STDAPI AllocPropertyHelper(IUnknown *punkOuter, IPersistVariantIO *ppvio,
    REFCLSID rclsid, DWORD dwFlags, IUnknown **ppunk)
{
    HRESULT         hrReturn = S_OK; // function return code
    CPropertyHelper *pthis = NULL;  // allocated object

    // set <pthis> to point to new object instance
    if ((pthis = New CPropertyHelper) == NULL)
        goto ERR_OUTOFMEMORY;
    TRACE("CPropertyHelper 0x%08lx created\n", pthis);

    // initialize IUnknown state
    pthis->m_cRef = 1;
    pthis->m_punkOuter = (punkOuter == NULL ?
        (IUnknown *) (INonDelegatingUnknown *) pthis : punkOuter);

    // other initialization
    pthis->m_ppvio = ppvio; // not AddRef'd -- see above
    pthis->m_clsid = rclsid;

    // return a pointer to the non-delegating IUnknown implementation
    *ppunk = (LPUNKNOWN) (INonDelegatingUnknown *) pthis;
    goto EXIT;

ERR_OUTOFMEMORY:

    hrReturn = E_OUTOFMEMORY;
    goto ERR_EXIT;

ERR_EXIT:

    // error cleanup
    if (pthis != NULL)
        Delete pthis;
    *ppunk = NULL;
    goto EXIT;

EXIT:

    // normal cleanup
    // (nothing to do)

    return hrReturn;
}


//////////////////////////////////////////////////////////////////////////////
// IUnknown Implementation
//

STDMETHODIMP CPropertyHelper::NonDelegatingQueryInterface(REFIID riid,
    LPVOID *ppv)
{
    *ppv = NULL;

#ifdef _DEBUG
    // char ach[200];
    // TRACE("PropertyHelper::QI('%s')\n", DebugIIDName(riid, ach));
#endif

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = (IUnknown *) (INonDelegatingUnknown *) this;
    else
    if (IsEqualIID(riid, IID_IPersist) ||
        IsEqualIID(riid, IID_IPersistPropertyBag))
        *ppv = (IPersistPropertyBag *) this;
    else
    if (IsEqualIID(riid, IID_IPersistStream) ||
        IsEqualIID(riid, IID_IPersistStreamInit))
        *ppv = (IPersistStreamInit *) this;
    else
    if (IsEqualIID(riid, IID_IDispatch))
        *ppv = (IDispatch *) this;
    else
        return E_NOINTERFACE;

    ((IUnknown *) *ppv)->AddRef();
    return S_OK;
}

STDMETHODIMP_(ULONG) CPropertyHelper::NonDelegatingAddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CPropertyHelper::NonDelegatingRelease()
{
    if (--m_cRef == 0L)
    {
        // free the object
        TRACE("CPropertyHelper 0x%08lx destroyed\n", this);
        Delete this;
        return 0;
    }
    else
        return m_cRef;
}


//////////////////////////////////////////////////////////////////////////////
// IPersist Implementation
//
STDMETHODIMP CPropertyHelper::GetClassID(CLSID* pClassID)
{
    *pClassID = m_clsid;
    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
// IPersistStream Implementation
//

STDMETHODIMP CPropertyHelper::IsDirty()
{
    return m_ppvio->IsDirty();
}

STDMETHODIMP CPropertyHelper::Load(IStream* pstream)
{
    HRESULT         hrReturn = S_OK; // function return code
    IPropertyBag *  ppb = NULL;     // acceses the properties in <pstream>

    // allocate <ppb> to read properties from <pstream>
    if (FAILED(hrReturn = AllocPropertyBagOnStream(pstream, 0, &ppb)))
        goto ERR_EXIT;

    // tell the control to read properties from <ppb>
    if (FAILED(hrReturn = Load(ppb, NULL)))
        goto ERR_EXIT;

    goto EXIT;

ERR_EXIT:

    // error cleanup
    // (nothing to do)
    goto EXIT;

EXIT:

    // normal cleanup
    if (ppb!= NULL)
        ppb->Release();

    return hrReturn;
}

STDMETHODIMP CPropertyHelper::Save(IStream* pstream, BOOL fClearDirty)
{
    HRESULT         hrReturn = S_OK; // function return code
    IPropertyBag *  ppb = NULL;     // acceses the properties in <pstream>

    // allocate <ppb> to write properties to <pstream>
    if (FAILED(hrReturn = AllocPropertyBagOnStream(pstream, 0, &ppb)))
        goto ERR_EXIT;

    // tell the control to write properties to <ppb>
    if (FAILED(hrReturn = Save(ppb, fClearDirty, TRUE)))
        goto ERR_EXIT;

 	// write out end of file marker
	if (FAILED(hrReturn = WriteVariantProperty(pstream, NULL, 0)))
		goto ERR_EXIT;

   goto EXIT;

ERR_EXIT:

    // error cleanup
    // (nothing to do)
    goto EXIT;

EXIT:

    // normal cleanup
    if (ppb!= NULL)
        ppb->Release();

    return hrReturn;
}

STDMETHODIMP CPropertyHelper::GetSizeMax(ULARGE_INTEGER* pcbSize)
{
    return E_NOTIMPL;
}


//////////////////////////////////////////////////////////////////////////////
// IPersistStreamInit Implementation
//
STDMETHODIMP CPropertyHelper::InitNew()
{
    return m_ppvio->InitNew();
}


//////////////////////////////////////////////////////////////////////////////
// IPersistPropertyBag Implementation
//

STDMETHODIMP CPropertyHelper::Load(IPropertyBag* ppb,
    IErrorLog* pErrorLog)
{
    HRESULT         hrReturn = S_OK; // function return code
    IManageVariantIO *pmvio = NULL; // to save properties to (to get names)

    if (FAILED(hrReturn = AllocVariantIOOnPropertyBag(ppb, &pmvio)))
        goto ERR_EXIT;

    // instruct the parent object to load its properties from <pmvio>
    if (FAILED(hrReturn = pmvio->SetMode(VIO_ISLOADING)))
        goto ERR_EXIT;
    if (FAILED(hrReturn = m_ppvio->DoPersist(pmvio, PVIO_CLEARDIRTY)))
        goto ERR_EXIT;

    goto EXIT;

ERR_EXIT:

    // error cleanup
    // (nothing to do)
    goto EXIT;

EXIT:

    // normal cleanup
    if (pmvio != NULL)
        pmvio->Release();

    return hrReturn;
}

STDMETHODIMP CPropertyHelper::Save(IPropertyBag* ppb, BOOL fClearDirty,
    BOOL fSaveAllProperties)
{
    HRESULT         hrReturn = S_OK; // function return code
    IManageVariantIO *pmvio = NULL; // to save properties to (to get names)

    if (FAILED(hrReturn = AllocVariantIOOnPropertyBag(ppb, &pmvio)))
        goto ERR_EXIT;

    // instruct the parent object to load its properties from <pmvio>
    ASSERT(pmvio->IsLoading() == S_FALSE);
    if (FAILED(hrReturn = m_ppvio->DoPersist(pmvio,
            (fClearDirty ? PVIO_CLEARDIRTY : 0))))
        goto ERR_EXIT;

    goto EXIT;

ERR_EXIT:

    // error cleanup
    // (nothing to do)
    goto EXIT;

EXIT:

    // normal cleanup
    if (pmvio != NULL)
        pmvio->Release();

    return hrReturn;
}


//////////////////////////////////////////////////////////////////////////////
// IDispatch Implementation
//

STDMETHODIMP CPropertyHelper::GetTypeInfoCount(UINT *pctinfo)
{
    *pctinfo = 0;
    return S_OK;
}

STDMETHODIMP CPropertyHelper::GetTypeInfo(UINT itinfo, LCID lcid,
    ITypeInfo **pptinfo)
{
    return DISP_E_BADINDEX;
}

STDMETHODIMP CPropertyHelper::GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames,
    UINT cNames, LCID lcid, DISPID *rgdispid)
{
    HRESULT         hrReturn = S_OK; // function return code
    IVariantIO *    pvio = NULL;    // used to ask parent to enum. prop. names
    DISPID          dispid;         // ID corresponding to <rgszNames[0]>
    DISPID *        pdispid;        // pointer into <rgdispid>
    UINT            cdispid;        // count of unprocessed <pdispid> items
    char            achPropName[_MAX_PATH]; // ANSI version of <rgszNames[0]>

    // nothing to do if there are no names to convert to IDs
    if (cNames == 0)
        goto EXIT;

    // allocate <pvio> to be a special IVariantIO implementation which
    // doesn't implement persistence at all, but instead sets <dispid>
    // to the ID of the property named <rgszNames[0]> when the parent
    // tries to persist that property using <pvio>
    dispid = -1;
    UNICODEToANSI(achPropName, rgszNames[0], sizeof(achPropName));
    if (FAILED(hrReturn = AllocVariantIOToMapDISPID(achPropName,
            &dispid, NULL, 0, &pvio)))
        goto ERR_EXIT;

    // tell the parent object to "save" its properties to <pvio>;
    // this should set <dispid> as described above; if property
    // <rgszNames[0]> is not found, <dispid> will remain -1
    if (FAILED(hrReturn = m_ppvio->DoPersist(pvio, PVIO_PROPNAMESONLY | PVIO_NOKIDS)))
        goto ERR_EXIT;

    // set rgdispid[0] to the DISPID of the property/method name
    // or to -1 if the name is unknown
    *rgdispid = dispid;

    // fill the other elements of the <rgdispid> array with -1 values,
    // because we don't support named arguments
    for (pdispid = rgdispid + 1, cdispid = cNames - 1;
         cdispid > 0;
         cdispid--, pdispid++)
        *pdispid = -1;

    // if any names were unknown, return DISP_E_UNKNOWNNAME
    if ((*rgdispid == -1) || (cNames > 1))
        goto ERR_UNKNOWNNAME;
    
    goto EXIT;

ERR_UNKNOWNNAME:

    hrReturn = DISP_E_UNKNOWNNAME;
    goto ERR_EXIT;

ERR_EXIT:

    // error cleanup
    // (nothing to do)
    goto EXIT;

EXIT:

    // normal cleanup
    if (pvio != NULL)
        pvio->Release();

    return hrReturn;
}

STDMETHODIMP CPropertyHelper::Invoke(DISPID dispidMember, REFIID riid,
    LCID lcid, WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult,
    EXCEPINFO *pexcepinfo, UINT *puArgErr)
{
    HRESULT         hrReturn = S_OK; // function return code
    IVariantIO *    pvio = NULL;    // used to ask parent to enum. prop. names
    char            achPropName[_MAX_PATH]; // <dispidMember> prop. name
    DWORD           dwFlags;
    VARIANT *       pvar;

    // set <dwFlags> and <pvar> to values to pass to AllocVariantIOToMapDISPID
    if (wFlags & DISPATCH_PROPERTYGET)
    {
        dwFlags = VIOTMD_GETPROP;
        pvar = pvarResult;
    }
    else
    if (wFlags & DISPATCH_PROPERTYPUT)
    {
        dwFlags = VIOTMD_PUTPROP;
        pvar = pdispparams->rgvarg;
    }
    else
        goto ERR_MEMBERNOTFOUND;

    // allocate <pvio> to be a special IVariantIO implementation which
    // gets or sets the value of the property associated with
    // <dispidMember> to/from <var> when the parent tries to persist that
    // property using <pvio>
    achPropName[0] = 0;
    if (FAILED(hrReturn = AllocVariantIOToMapDISPID(achPropName,
            &dispidMember, pvar, dwFlags, &pvio)))
        goto ERR_EXIT;

    // tell the parent object to "save" its properties to <pvio>;
    // this should set <achPropName> as described above; if property
    // <dispidMember> is not found, <achPropName> will remain ""
    if (FAILED(hrReturn = m_ppvio->DoPersist(pvio, PVIO_NOKIDS)))
        goto ERR_EXIT;
    if (achPropName[0] == 0)
        goto ERR_MEMBERNOTFOUND;

    goto EXIT;

ERR_MEMBERNOTFOUND:

    hrReturn = DISP_E_MEMBERNOTFOUND;
    goto ERR_EXIT;

ERR_EXIT:

    // error cleanup
    // (nothing to do)
    goto EXIT;

EXIT:

    // normal cleanup
    if (pvio != NULL)
        pvio->Release();

    return hrReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\aviotmd.cpp ===
// avitmd.cpp
//
// Implements AllocVariantIOToMapDISPID.
//
// Important: This .cpp file assumes a zero-initializing global "new" operator.
//
// @doc MMCTL
//

#include "precomp.h"
#include "..\..\inc\mmctlg.h" // see comments in "mmctl.h"
#include "..\..\inc\ochelp.h"
#include "debug.h"


/////////////////////////////////////////////////////////////////////////////
// VariantIOToMapDISPID
//

/* @object VariantIOToMapDISPID |

        Provides an implementation of <i IVariantIO> which is used to map a
        property name to a DISPID (property number) or vice versa.  Can also
        be used to get or set the value of that property.

@supint <i IVariantIO> | Typically used as a parameter to
        <om IPersistVariantIO.DoPersist>.

@comm   Use <f AllocVariantIOToMapDISPID> to create a
        <o VariantIOToMapDISPID> object.
*/


//////////////////////////////////////////////////////////////////////////////
// CVariantIOToMapDISPID
//

struct CVariantIOToMapDISPID : IVariantIO
{
///// general object state
    ULONG           m_cRef;         // object reference count
    DISPID          m_dispidCounter; // count DISPID of persisted properties
    char *          m_pchPropName;  // owner's given/found prop. name (or "")
    DISPID *        m_pdispid;      // owner's given/found DISPID (or -1)
    VARIANT *       m_pvar;         // property to get/set
    DWORD           m_dwFlags;      // AllocVariantIOToMapDISPID flags

///// construction and destruction
    CVariantIOToMapDISPID(char *pchPropName, DISPID *pdispid,
        VARIANT *pvar, DWORD dwFlags);

///// IUnknown methods
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObj);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

///// IVariantIO methods
    STDMETHODIMP PersistList(DWORD dwFlags, va_list args);
    HRESULT __cdecl Persist(DWORD dwFlags, ...);
    STDMETHODIMP IsLoading();
};


/////////////////////////////////////////////////////////////////////////////
// VariantIOToMapDISPID Creation & Destruction
//

/* @func HRESULT | AllocVariantIOToMapDISPID |

        Creates a <o VariantIOToMapDISPID> object which provides an
        implementation of <i IVariantIO> which is used to map a property name
        to a DISPID (property number) or vice versa.  Can also be used to get
        or set the value of that property.

@rvalue S_OK |
        Success.

@rvalue E_OUTOFMEMORY |
        Out of memory.

@parm   char * | pchPropName | A pointer to a caller-allocated buffer
        containing (on entry) either a property name to search for the DISPID
        of, or "" if it's the property name being searched for (if
        *<p pdispid> contains a non-negative number on entry).
        <p pchPropName> must remain valid for the lifetime of the
        allocated object.  If <p pchPropName> is "" on entry, then it must
        have enough space for _MAX_PATH characters.

@parm   DISPID * | pdispid | A pointer to a caller-allocated DISPID variable
        containing (on entry) either a DISPID to find the property name of,
        or -1 if it's the DISPID that's being searched for (if <p pchPropName>
        is non-empty on entry).  *<p pdispid> must remain valid for the
        lifetime of the allocated object.

@parm   VARIANT * | pvar | A pointer to a caller-allocated VARIANT variable,
        if either VIOTMD_GETPROP or VIOTMD_PUTPROP are specified in
        <p dwFlags> -- see those flags for more information.  If provided,
        *<p pvar> must be initialized by <f VariantInit> on entry and must
        remain valid for the lifetime of the allocated object.

@parm   DWORD | dwFlags | May optionally contain the following flags:

        @flag   VIOTMD_GETPROP | The value of the property (if found) is
                copied to *<p pvar>.  The previous value in *<p pvar>
                is cleared using <f VariantClear>.

        @flag   VIOTMD_PUTPROP | The value of the property (if found) is
                set to *<p pvar>, which must contain a valid valu on entry.

@parm   IVariantIO * * | ppvio | Where to store the <i IVariantIO>
        pointer to the new <o VariantIOToMapDISPID> object.  NULL is stored
        in *<p ppvio> on error.

@comm   DISPIDs assigned by this function start at DISPID_BASE (defined in
        ochelp.h) to avoid colliding with the DISPID values assigned by
        <f DispatchHelpGetIDsOfNames>.

@ex     To find the DISPID of property "Foo" implemented by an object <p ppvio>
        that implements <i IPeristVariantIO>, do the following.  Error checking
        is not shown. |

        char *achPropName = "Foo";
        DISPID dispid = -1;
        IVariantIO *pvio;
        AllocVariantIOToMapDISPID(&szPropName, &dispid, NULL, 0, &pvio);
        ppvio->DoPersist(pvio, PVIO_PROPNAMESONLY);
        if (dispid != -1)
            ... found DISPID <dispid> ...

@ex     To find the property name of a property with DISPID 7 implemented by an
        object <p ppvio> that implements <i IPeristVariantIO>, do the
        following.  Error checking is not shown. |

        char achPropName[_MAX_PATH];
        achPropName[0] = 0;
        DISPID dispid = 7;
        IVariantIO *pvio;
        AllocVariantIOToMapDISPID(&achPropName, &dispid, NULL, 0, &pvio);
        ppvio->DoPersist(pvio, PVIO_PROPNAMESONLY);
        if (achPropName[0] != 0)
            ... found property name <achPropName>...

@ex     To set the value of the property with DISPID 7 to 32-bit integer
        value 42, do the following.  Error checking is not shown. |

        char achPropName[_MAX_PATH];
        achPropName[0] = 0;
        DISPID dispid = 7;
        IVariantIO *pvio;
        VARIANT var;
        var.vt = VT_I2;
        V_I2(&var) = 42;
        AllocVariantIOToMapDISPID(&achPropName, &dispid, &var, VIOTMD_PUTPROP,
            &pvio);
        ppvio->DoPersist(pvio, 0);
        if (achPropName[0] != 0)
            ... successfully set property <dispid> to value <var> ...
*/
STDAPI AllocVariantIOToMapDISPID(char *pchPropName, DISPID *pdispid,
    VARIANT *pvar, DWORD dwFlags, IVariantIO **ppvio)
{
    // create the Windows object
    if ((*ppvio = (IVariantIO *) New CVariantIOToMapDISPID(pchPropName,
            pdispid, pvar, dwFlags)) == NULL)
        return E_OUTOFMEMORY;

    return S_OK;
}

CVariantIOToMapDISPID::CVariantIOToMapDISPID(char *pchPropName,
    DISPID *pdispid, VARIANT *pvar, DWORD dwFlags)
{
    // initialize IUnknown
    m_cRef = 1;

    // other initialization
    m_pchPropName = pchPropName;
    m_pdispid = pdispid;
    m_pvar = pvar;
    m_dwFlags = dwFlags;

    // assign the initial DISPID -- start numbering at DISPID_BASE to avoid
    // colliding with the DISPID values assigned by DispatchHelpGetIDsOfNames
    m_dispidCounter = DISPID_BASE;
}


//////////////////////////////////////////////////////////////////////////////
// IUnknown Implementation
//

STDMETHODIMP CVariantIOToMapDISPID::QueryInterface(REFIID riid, LPVOID *ppv)
{
    *ppv = NULL;

#ifdef _DEBUG
    char ach[200];
    TRACE("VariantIOToMapDISPID::QI('%s')\n", DebugIIDName(riid, ach));
#endif

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IVariantIO))
        *ppv = (IVariantIO *) this;
    else
        return E_NOINTERFACE;

    ((IUnknown *) *ppv)->AddRef();
    return S_OK;
}

STDMETHODIMP_(ULONG) CVariantIOToMapDISPID::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CVariantIOToMapDISPID::Release()
{
    if (--m_cRef == 0L)
    {
        // free the object
        Delete this;
        return 0;
    }
    else
        return m_cRef;
}


/////////////////////////////////////////////////////////////////////////////
// IVariantIO
//

STDMETHODIMP CVariantIOToMapDISPID::PersistList(DWORD dwFlags, va_list args)
{
    HRESULT         hrReturn = S_OK; // function return code
    LPSTR           szArg;          // property name from <args>
    VARTYPE         vtArg;          // variable type from <args>
    LPVOID          pvArg;          // variable pointer from <args>
    IPropertyBag *  ppb = NULL;     // to persist single property to/from
    OLECHAR         oach[MAX_PATH];
    VariantProperty vp;

    // ensure correct cleanup
    VariantPropertyInit(&vp);

    // loop once for each (name, VARTYPE, value) triplet in <args>;
    // for each triplet, increment <m_dispidCounter>, and if the
    // triplet's property name is <m_achPropName> then set
    // <*m_pdispid> to the DISPID of that property
    while ((szArg = va_arg(args, LPSTR)) != NULL)
    {
        // <szArg> is the name of the property in the current triplet;
        // set <vtArg> to the type of the variable pointer, and set
        // <pvArg> to the variable pointer
        vtArg = va_arg(args, VARTYPE);
        pvArg = va_arg(args, LPVOID);

        // <m_dispidCounter> is used to assign each property name
        // a DISPID (1, 2, 3, ...)
        m_dispidCounter++;

        if (*m_pdispid == -1)
        {
            // we're trying to find the DISPID of the property named
            // <m_pchPropName>
            if (lstrcmpi(m_pchPropName, szArg) == 0)
            {
                // this is the property we're looking for
                *m_pdispid = m_dispidCounter;
                goto FOUND_IT;
            }
        }
        else
        if (*m_pchPropName == 0)
        {
            // we're trying to find the property name corresponding to
            // DISPID <*m_pdispid>
            if (*m_pdispid == m_dispidCounter)
            {
                // this is the DISPID we're looking for
                lstrcpy(m_pchPropName, szArg);
                goto FOUND_IT;
            }
        }
        else
        {
            // we already found whatever we're searching for
            break;
        }
    }

    return S_FALSE; // means "no variables were written to"

FOUND_IT:

    // found searched-for DISPID or property name
    if (m_dwFlags & (VIOTMD_GETPROP | VIOTMD_PUTPROP))
    {
        // the caller of AllocVariantIOToMapDISPID() wants the value of the
        // found property to be copied to <m_pvar>, or wants the value of the
        // found property to be set to <m_pvar>

        // set <vp> to be the property to get/put
        ANSIToUNICODE(oach, szArg, sizeof(oach) / sizeof(*oach));
        vp.bstrPropName = SysAllocString(oach);
        if (m_dwFlags & VIOTMD_PUTPROP)
            VariantCopy(&vp.varValue, m_pvar);

        // get/put <vp>
        if (FAILED(hrReturn = AllocPropertyBagOnVariantProperty(&vp, 0, &ppb)))
            goto ERR_EXIT;
        if (FAILED(hrReturn = PersistVariantIO(ppb,
                ((m_dwFlags & VIOTMD_PUTPROP) ? VIO_ISLOADING : 0),
                szArg, vtArg, pvArg, NULL)))
            goto ERR_EXIT;

        // if requested, copy the value of the property to <m_pvar>
        if (m_dwFlags & VIOTMD_GETPROP)
            VariantCopy(m_pvar, &vp.varValue);
    }

    hrReturn = IsLoading();
    goto EXIT;

ERR_EXIT:

    // error cleanup
    // (nothing to do)
    goto EXIT;

EXIT:

    // normal cleanup
    if (ppb != NULL)
        ppb->Release();
    VariantPropertyClear(&vp);

    return hrReturn;
}

HRESULT __cdecl CVariantIOToMapDISPID::Persist(DWORD dwFlags, ...)
{
    HRESULT         hrReturn = S_OK; // function return code

    // Because CVariantIOToMapDISPID::Persist is used for IDispatch rather 
	// than file load/save, we always want to persist all values.  So, we
	// turn off VIO_ZEROISDEFAULT.  If that flag were on, properties with
	// zero values would not be persisted.
	dwFlags = dwFlags & ~VIO_ZEROISDEFAULT;

	// start processing optional arguments
    va_list args;
    va_start(args, dwFlags);

    // fire the event with the specified arguments
    hrReturn = PersistList(dwFlags, args);
    
    // end processing optional arguments
    va_end(args);

    return hrReturn;
}

STDMETHODIMP CVariantIOToMapDISPID::IsLoading()
{
    return (m_dwFlags & VIOTMD_PUTPROP) ? S_OK : S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\brush.cpp ===
// brush.cpp
//
// Implements CreateBorderBrush.
//
// @doc MMCTL
//

#include "precomp.h"
#include "..\..\inc\mmctlg.h"
#include "..\..\inc\ochelp.h"
#include "debug.h"


/* @func HBRUSH | CreateBorderBrush |

        Creates and returns a hatch pattern brush used to draw control
        resize borders and grab handles.

@rdesc  Returns a handle to the created brush.  The caller is responsible
        for freeing the brush using <f DeleteObject>.

@comm   The returned brush is the standard brush for use in drawing
        control borders and grab handles.
*/
STDAPI_(HBRUSH) CreateBorderBrush()
{
    HBRUSH          hbr = NULL;     // created brush
    HBITMAP         hbm = NULL;     // bitmap that contains brush pattern

    // set <awHatchPattern> to be the hatch brush pattern
    WORD awHatchPattern[8];
    WORD wPattern = 0x7777; // 0x1111 (dark), 0x3333 (med.), or 0x7777 (light)
    for (int i = 0; i < 4; i++)
    {
        awHatchPattern[i] = wPattern;
        awHatchPattern[i+4] = wPattern;
        wPattern = (wPattern << 1) | (wPattern >> 15); // rotate left 1 bit
    }

    // set <hbm> to be a bitmap containing the hatch brush pattern
    if ((hbm = CreateBitmap(8, 8, 1, 1, &awHatchPattern)) == NULL)
        goto ERR_EXIT;

    // set <hbr> to be a brush containing the pattern in <hbm>
    if ((hbr = CreatePatternBrush(hbm)) == NULL)
        goto ERR_EXIT;

    goto EXIT;

ERR_EXIT:

    if (hbr != NULL)
        DeleteObject(hbr);
    hbr = NULL;
    goto EXIT;

EXIT:

    if (hbm != NULL)
        DeleteObject(hbm);

    return hbr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\cci.cpp ===
// cci.cpp
//
// Implements CreateControlInstance.
//
// Important: This .cpp file assumes a zero-initializing global "new" operator.
//
// @doc MMCTL
//

#include "precomp.h"
#include "..\..\inc\mmctlg.h" // see comments in "mmctl.h"
#include "..\..\inc\ochelp.h"
#include "debug.h"


/* @func HRESULT | CreateControlInstance |

        Creates a new instance of a control given either a class ID (in
        string form) or a ProgID.

@parm   LPCSTR | szName | The class ID or ProgID of the control to create.

@parm   LPUNKNOWN | punkOuter | The controlling unknown to use for the
        new object.

@parm   DWORD | dwClsContext | Specifies the context in which the executable
        is to be run. The values are taken from the enumeration CLSCTX.
        A typical value is CLSCTX_INPROC_SERVER.

@parm   LPUNKNOWN * | ppunk | Where to store the pointer to the loaded object.
        NULL is stored in *<p ppunk> on error.

@parm   CLSID * | pclsid | Where to store the class ID of the loaded object.
        If <p pclsid> is NULL then this information is not returned.

@parm	BOOL * | pfSafeForScripting | If non-NULL, *<p pfSafeForScripting> is
		set to TRUE or FALSE depending on whether the control is safe-for-scripting.

@parm	BOOL * | pfSafeForInitializing | If non-NULL, *<p pfSafeForInitializing> is
		set to TRUE or FALSE depending on whether the control is safe-for-initializing.

@parm   DWORD | dwFlags | Currently unused.  Must be set to 0.
*/
STDAPI CreateControlInstance(LPCSTR szName, LPUNKNOWN punkOuter,
    DWORD dwClsContext, LPUNKNOWN *ppunk, CLSID *pclsid, 
	BOOL* pfSafeForScripting, BOOL* pfSafeForInitializing, DWORD dwFlags)
{
    HRESULT         hrReturn = S_OK; // function return code
    OLECHAR         aochName[200];  // <szName> converted to UNICODE
    CLSID           clsid;          // class ID of control
    IPersistPropertyBag *pppb = NULL; // interface on control
    IPersistStreamInit *ppsi = NULL; // interface on control

    // ensure correct cleanup
    *ppunk = NULL;

    // find the class ID of the control based on <szName>
    ANSIToUNICODE(aochName, szName, sizeof(aochName) / sizeof(*aochName));
    if (FAILED(CLSIDFromString(aochName, &clsid)) &&
        FAILED(CLSIDFromProgID(aochName, &clsid)))
        goto ERR_FAIL;

    // create an instance of the control, and point <*ppunk> to it
    if (FAILED(hrReturn = CoCreateInstance(clsid, punkOuter,
            dwClsContext, IID_IUnknown, (LPVOID *) ppunk)))
        goto ERR_EXIT;

	// assess the control's safety
	if (pfSafeForScripting != NULL || pfSafeForInitializing != NULL)
		if (FAILED(hrReturn = GetObjectSafety(pfSafeForScripting, 
				pfSafeForInitializing, *ppunk, &clsid, &IID_IPersistPropertyBag,
				&IID_IPersistStream, &IID_IPersistStreamInit, NULL)))
			goto ERR_EXIT;

    // tell the control to initialize itself as a new object
    if (SUCCEEDED((*ppunk)->QueryInterface(IID_IPersistPropertyBag,
            (LPVOID *) &pppb)))
        pppb->InitNew();
    else
    if (SUCCEEDED((*ppunk)->QueryInterface(IID_IPersistStreamInit,
            (LPVOID *) &ppsi)))
        ppsi->InitNew();

    // return the class ID if requested by the caller
    if (pclsid != NULL)
        *pclsid = clsid;
    goto EXIT;

ERR_FAIL:

    hrReturn = E_FAIL;
    goto ERR_EXIT;

ERR_EXIT:

    // error cleanup
    if (*ppunk != NULL)
        (*ppunk)->Release();
    *ppunk = NULL;
    goto EXIT;

EXIT:

    // normal cleanup
    if (pppb != NULL)
        pppb->Release();
    if (ppsi != NULL)
        ppsi->Release();

    return hrReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\cus.cpp ===
// cus.cpp
//
// Implements CompareUNICODEStrings.
//
// Important: This .cpp file assumes a zero-initializing global "new" operator.
//
// @doc MMCTL
//

#include "precomp.h"
#include "..\..\inc\mmctlg.h" // see comments in "mmctl.h"
#include "..\..\inc\ochelp.h"
#include "debug.h"


/* @func int | CompareUNICODEStrings |

        Compares two UNICODE strings.  The comparison is case-insensitive.

@rdesc  Returns the same values as <f lstrcmpi>.

@parm   LPCWSTR | wsz1 | First string.  NULL is interpreted as a zero-length string.

@parm   LPCWSTR | wsz2 | Second string.  NULL is interpreted as a zero-length string.

@comm   Currently, neither <p wsz1> or <p wsz2> can be longer than
        _MAX_PATH characters.
*/
STDAPI_(int) CompareUNICODEStrings(LPCWSTR wsz1, LPCWSTR wsz2)
{
    char            ach1[_MAX_PATH]; // <wsz1> converted to ANSI
    char            ach2[_MAX_PATH]; // <wsz2> converted to ANSI

    UNICODEToANSI(ach1, wsz1, sizeof(ach1));
    UNICODEToANSI(ach2, wsz2, sizeof(ach2));
    return lstrcmpi(ach1, ach2);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\debug.h ===
// debug.h
//
// Debugging functions.


#include "Globals.h"


//////////////////////////////////////////////////////////////////////////////
// TRACE, ASSERT, VERIFY
//
// These are the same as MFC's functions of the same name (but are implemented
// without using MFC).  See "debug.h" for the actual macro definitions.
//

#ifdef _DEBUG

BOOL AssertFailedLine(LPCSTR lpszFileName, int nLine);
void __cdecl Trace(LPCTSTR lpszFormat, ...);
#define TRACE              ::Trace
#define THIS_FILE          __FILE__
#define ASSERT(f) \
    do \
    { \
    if (!(f) && AssertFailedLine(THIS_FILE, __LINE__)) \
        DebugBreak(); \
    } while (0) \

#define VERIFY(f)          ASSERT(f)

#else // #ifndef _DEBUG

#define ASSERT(f)          ((void)0)
#define VERIFY(f)          ((void)(f))
inline void __cdecl Trace(LPCTSTR, ...) { }
#define TRACE              1 ? (void)0 : ::Trace

#endif // _DEBUG


/////////////////////////////////////////////////////////////////////////////
// DebugIIDName, DebugCLSIDName
//
// These functions convert an IID or CLSID to a string name for debugging
// purposes (e.g. IID_IUnknown is converted to "IUnknown").
//

#ifdef _DEBUG
LPCSTR DebugIIDName(REFIID riid, LPSTR pchName);
LPCSTR DebugCLSIDName(REFCLSID rclsid, LPSTR pchName);
#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\connect.cpp ===
// connect.cpp
//
// Implements IConnectionPointContainer, IEnumConnectionPoint,
// IConnectionPoint, IEnumConnections.
//
// Important: This .cpp file assumes a zero-initializing global "new" operator.
//
// @doc MMCTL
//

#include "precomp.h"
#include "..\..\inc\ochelp.h"
#include "debug.h"
#include "unklist.h"
#include "unkenum.h"


//////////////////////////////////////////////////////////////////////////////
// CConnect -- implements IConnectionPoint
//
// Note that CConnect doesn't have a reference count, because its lifetime
// is equal to the lifetime of its parent object (the one that impelements
// IConnectionPointContainer).  Instead, on AddRef we AddRef the parent,
// and likewise for Release.
//
// Important: CConnect assumes a zero-initializeing new() operator.
//

/* @object ConnectionPointHelper |

        Contains functions for implementing the <o ConnectionPointHelper>
        object, which provides a simple implementation of an
        <i IDispatch>-based and an <i IPropertyNotifySink>-based 
		<i IConnectionPoint>. Also contains helper
        functions for implementing <i IConnectionPointContainer> in the
        case where these are the only connections maintained by the connection
        point container.

@supint IConnectionPointHelper | Contains methods for firing events to
        the objects connected to this object via <i IConnectionPoint>.
        Also contains helper functions for implementing
        <i IConnectionPointContainer> in the container object.
*/

/* @interface IConnectionPointHelper |

        Contains functions for implementing the <o ConnectionPointHelper>
        object, which provides a simple implementation of an
        <i IDispatch>-based and an <i IPropertyNotifySink>-based 
		<i IConnectionPoint>.  Also contains helper
        functions for implementing <i IConnectionPointContainer> in the case
		where these are the only connections maintained by the connection
        point container.

@meth   HRESULT | FireEventList |

        Fire a given <i IDispatch>-based event on all objects (e.g. VBS)
        connected to this <o ConnectionPointHelper> object.  Parameters
        for the event are passed as a va_list array.

@meth   HRESULT | FireEvent |

        Fire a given <i IDispatch>-based event on all objects (e.g. VBS)
        connected to this <o ConnectionPointHelper> object.  Parameters
        for the event are passed as a varying argument list.

@meth   HRESULT | FireOnChanged |

        Fire a <i IPropertyNotifySink> event on all objects
        connected to this <o ConnectionPointHelper> object.

@meth   HRESULT | FireOnRequestEdit |

        Fire a <i IPropertyNotifySink> event on all objects 
        connected to this <o ConnectionPointHelper> object. 

@meth   HRESULT | EnumConnectionPoints |

        Helps implement <om IConnectionPointContainer.EnumConnectionPoints>
        in the case where this object implements the only connection maintained
        by the connection point container.

@meth   HRESULT | FindConnectionPoint |

        Helps implement <om IConnectionPointContainer.FindConnectionPoint>
        in the case where this object implements the only connection maintained
        by the connection point container.

@comm   To allocate an <o ConnectionPointHelper> object, call
        <f AllocConnectionPointHelper>.  To free the object, call
        <f FreeConnectionPointHelper> (not <f Release> -- see
        <f AllocConnectionPointHelper> for more information).

*/

struct CConnect : IConnectionPoint
{
///// state
    IUnknown *      m_punkParent;   // parent object
    IID             m_iid;          // outgoing (source) dispinterface
    CUnknownList    m_listConnect;  // list of connections
    int             m_cUnadvise;    // count of Unadvise() operations

///// IUnknown implementation
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

///// IConnectionPoint interface
    STDMETHODIMP GetConnectionInterface(IID *pIID);
    STDMETHODIMP GetConnectionPointContainer(
        IConnectionPointContainer **ppCPC);
    STDMETHODIMP Advise(LPUNKNOWN pUnkSink, DWORD *pdwCookie);
    STDMETHODIMP Unadvise(DWORD dwCookie);
    STDMETHODIMP EnumConnections(LPENUMCONNECTIONS *ppEnum);
};

struct CConnectHelper : IConnectionPointHelper
{
///// state
    IUnknown *      m_punkParent;   // parent object
	CConnect *		m_pconDispatch;
	CConnect *		m_pconPropertyNotify;

///// IUnknown implementation
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

///// IConnectionPointHelper interface
    STDMETHODIMP FireEventList(DISPID dispid, va_list args);
    HRESULT __cdecl FireEvent(DISPID dispid, ...);
    STDMETHODIMP FireOnChanged(DISPID dispid);
    STDMETHODIMP FireOnRequestEdit(DISPID dispid);
    STDMETHODIMP EnumConnectionPoints(LPENUMCONNECTIONPOINTS *ppEnum);
    STDMETHODIMP FindConnectionPoint(REFIID riid, LPCONNECTIONPOINT *ppCP);
	STDMETHODIMP Close(void);
};


//////////////////////////////////////////////////////////////////////////////
// CEnumConnections -- implements IEnumConnections
//

struct CEnumConnections : IEnumConnections
{
///// object state
    ULONG           m_cRef;         // object reference count
    CConnect *      m_pconnect;     // parent object
    CUnknownItem *  m_pitemCur;     // current item in list
    int             m_cUnadvise;    // see WasItemDeleted()

///// construction & destruction
    CEnumConnections(CConnect *pconnect)
    {
        m_cRef = 1;
        m_pconnect = pconnect;
        m_pconnect->AddRef();
        m_pitemCur = m_pconnect->m_listConnect.m_pitemCur;
        m_cUnadvise = m_pconnect->m_cUnadvise;
    }
    ~CEnumConnections()
    {
        m_pconnect->Release();
    }

///// WasItemDeleted() -- if item was deleted, reset <m_pitemCur>
///// to prevent Next() or Skip() from walking off the list
    BOOL WasItemDeleted()
    {
        if (m_cUnadvise != m_pconnect->m_cUnadvise)
        {
            m_cUnadvise = m_pconnect->m_cUnadvise;
            return TRUE;
        }
        else
            return FALSE;
    }

///// IUnknown methods
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
    {
        if (IsEqualIID(riid, IID_IUnknown) ||
            IsEqualIID(riid, IID_IEnumConnections))
        {
            *ppvObj = (IEnumConnections *) this;
            AddRef();
            return NOERROR;
        }
        else
        {
            *ppvObj = NULL;
            return E_NOINTERFACE;
        }
    }
    STDMETHODIMP_(ULONG) AddRef()
    {
        return ++m_cRef;
    }
    STDMETHODIMP_(ULONG) Release()
    {
        if (--m_cRef == 0L)
        {
            Delete this;
            return 0;
        }
        else
            return m_cRef;
    }

///// IEnumConnections Methods
    STDMETHODIMP Next(ULONG celt, LPCONNECTDATA rgelt, ULONG *pceltFetched)
    {
        if (WasItemDeleted())
            Reset();
        if (pceltFetched != NULL)
            (*pceltFetched) = 0;
        while (celt > 0)
        {
            // set <m_pitemCur> to the next item in the list of connections
            if (m_pitemCur->m_pitemNext ==
                    &m_pconnect->m_listConnect.m_itemHead)
                return NULL;
            m_pitemCur = m_pitemCur->m_pitemNext;
            if (rgelt != NULL)
            {
                rgelt->pUnk = m_pitemCur->Contents();
                rgelt->dwCookie = m_pitemCur->m_dwCookie;
                rgelt++;
            }
            celt--;
            if (pceltFetched != NULL)
                (*pceltFetched)++;
        }

        return (celt == 0 ? S_OK : S_FALSE);
    }
    STDMETHODIMP Skip(ULONG celt)
    {
        if (WasItemDeleted())
            Reset();
        return Next(celt, NULL, NULL);
    }
    STDMETHODIMP Reset()
    {
        m_pitemCur = &m_pconnect->m_listConnect.m_itemHead;
        return S_OK;
    }
    STDMETHODIMP Clone(IEnumConnections **ppenum)
    {
        CEnumConnections *penum;
        if ((penum = New CEnumConnections(m_pconnect)) == NULL)
        {
            *ppenum = NULL;
            return E_OUTOFMEMORY;
        }
        else
        {
            *ppenum = penum;
            return S_OK;
        }
    }
};


//////////////////////////////////////////////////////////////////////////////
// CConnect Allocation & Destruction
//


/* @func HRESULT | AllocConnectionPointHelper |

        Allocates a <o ConnectionPointHelper> object, which provides a simple
        implementation of an <i IDispatch>-based and an <i IPropertyNotifySink>-based
		<i IConnectionPoint>. Also contains helper functions for implementing
        <om IConnectionPointContainer.EnumConnectionPoints> in the case where
        these are the only connection maintained by the connection point container.

@rvalue S_OK |
        Success.

@rvalue E_OUTOFMEMORY |
        Out of memory.

@parm   IUnknown * | punkParent | The parent of the connection point, which
        is the object that implements <i IConnectionPointContainer>.

@parm   REFIID | riid | The dispinterface (interface based on <i IDispatch>)
        which is the event set that the parent object fires methods of. If this is
		GUID_NULL, then there will be no <i IDispatch> based connection.

@parm   IConnectionPointHelper * | ppconpt | Where to store the pointer to
        the newly-allocated object.  NULL is stored in *<p ppconpt> on
        error.

@comm   <b Important:> Unlike most COM objects, the parent object needs to
        free the <o ConnectionPointHelper> object by calling
        <f FreeConnectionPointHelper>, not <f Release>.  The reason is that
        the <o ConnectionPointHelper> object doesn't maintain a reference
        count if its own -- it simply forwards <f AddRef> and <f Release>
        calls to <p punkParent>.  Therefore, calling <f Release> on
        the <o ConnectionPointHelper> object will simply cause <f Release>
        to be called on the parent.

        To use the <o ConnectionPointHelper> object, call
        <om IConnectionPointHelper.FireEvent> to fire events to any object
        connected to the <o ConnectionPointHelper> object.
*/
STDAPI AllocConnectionPointHelper(IUnknown *punkParent, REFIID riid,
    IConnectionPointHelper **ppconpt)
{
	SCODE		sc = E_OUTOFMEMORY;
	CConnect	*pconDispatch = NULL, *pconPropertyNotify = NULL;

    // allocate the CConnect object that implements IConnectionPointHelper
    CConnectHelper	*pconhelper = New CConnectHelper;

	if (pconhelper != NULL)
		{
		if (pconPropertyNotify = New CConnect)
			{
			if (IsEqualGUID(riid, GUID_NULL) || (pconDispatch = New CConnect))
				sc = S_OK;
			}
		}

	if (SUCCEEDED(sc))
		{
		if (pconDispatch)
			{
			pconDispatch->m_iid = riid;
			pconDispatch->m_punkParent = punkParent;
			}

		pconPropertyNotify->m_iid = IID_IPropertyNotifySink;
		pconPropertyNotify->m_punkParent = punkParent;

	    // we don't AddRef <m_punkParent> because the connection point's lifetime
		// equals its parent's lifetime (and AddRef would cause the parent
	    // object to never leave memory)
		pconhelper->m_punkParent = punkParent;
		pconhelper->m_pconDispatch = pconDispatch;
		pconhelper->m_pconPropertyNotify = pconPropertyNotify;
		}
	else
		{
		Delete pconhelper;
		pconhelper = NULL;
		Delete pconDispatch;
		Delete pconPropertyNotify;
		}

    *ppconpt = pconhelper;
    return sc;
}


/* @func HRESULT | FreeConnectionPointHelper |

        Frees a <o ConnectionPointHelper> object allocated using
        <f AllocConnectionPointHelper>.

@rvalue S_OK |
        Success.

@comm   See <f AllocConnectionPointHelper> for information about why you
        should not try to free the <o ConnectionPointHelper> object
        using <f Release>.
*/
STDAPI FreeConnectionPointHelper(IConnectionPointHelper *pconpt)
{
	if(pconpt)
		{
		pconpt->Close();
	    Delete pconpt;
		}
    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
// IUnknown interface
//

STDMETHODIMP CConnectHelper::QueryInterface(REFIID riid, LPVOID *ppv)
{
    *ppv = NULL;

#ifdef _DEBUG
    char ach[200];
    TRACE("CConnect::QI('%s')\n", DebugIIDName(riid, ach));
#endif

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IConnectionPointHelper))
        *ppv = (IUnknown *) (IConnectionPointHelper*) this;
    else
        return E_NOINTERFACE;

    ((IUnknown *) *ppv)->AddRef();
    return S_OK;
}

STDMETHODIMP_(ULONG) CConnectHelper::AddRef()
{
    return m_punkParent->AddRef();
}

STDMETHODIMP_(ULONG) CConnectHelper::Release()
{
    return m_punkParent->Release();
}


STDMETHODIMP CConnect::QueryInterface(REFIID riid, LPVOID *ppv)
{
    *ppv = NULL;

#ifdef _DEBUG
    char ach[200];
    TRACE("CConnect::QI('%s')\n", DebugIIDName(riid, ach));
#endif

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IConnectionPoint))
        *ppv = (IUnknown *) (IConnectionPoint*) this;
    else
        return E_NOINTERFACE;

    ((IUnknown *) *ppv)->AddRef();
    return S_OK;
}

STDMETHODIMP_(ULONG) CConnect::AddRef()
{
    return m_punkParent->AddRef();
}

STDMETHODIMP_(ULONG) CConnect::Release()
{
    return m_punkParent->Release();
}


//////////////////////////////////////////////////////////////////////////////
// IConnectionPoint interface
//

STDMETHODIMP CConnect::GetConnectionInterface(IID *pIID)
{
    *pIID = m_iid;
    return S_OK;
}

STDMETHODIMP CConnect::GetConnectionPointContainer(
    IConnectionPointContainer **ppCPC)
{
    return m_punkParent->QueryInterface(IID_IConnectionPointContainer,
        (LPVOID *) ppCPC);
}

STDMETHODIMP CConnect::Advise(LPUNKNOWN punkSink, DWORD *pdwCookie)
{
    if (!m_listConnect.AddItem(punkSink))
        return E_OUTOFMEMORY;

    *pdwCookie = m_listConnect.LastCookieAdded();
    return S_OK;
}

STDMETHODIMP CConnect::Unadvise(DWORD dwCookie)
{
    m_listConnect.DeleteItem(m_listConnect.GetItemFromCookie(dwCookie));
    m_cUnadvise++;
    return S_OK;
}

STDMETHODIMP CConnect::EnumConnections(LPENUMCONNECTIONS *ppEnum)
{
    CEnumConnections *penum = New CEnumConnections(this);
    if (penum == NULL)
    {
        *ppEnum = NULL;
        return E_OUTOFMEMORY;
    }
    else
    {
        penum->Reset();
        *ppEnum = penum;
        return S_OK;
    }
}


//////////////////////////////////////////////////////////////////////////////
// IConnectionPointHelper interface
//


/* @method HRESULT | IConnectionPointHelper | FireEventList |

        Fire a given <i IDispatch>-based event on all objects (e.g. VBS)
        connected to this <o ConnectionPointHelper> object.  Parameters
        for the event are passed as a va_list array.

@rvalue S_OK |
        Success.

@parm   DISPID | dispid | The ID of the event to fire.

@parm   va_list | args | The arguments to pass.  See
        <om IConnectionPointHelper.FireEventList> for information about
        the organization of these arguments.
*/
STDMETHODIMP CConnectHelper::FireEventList(DISPID dispid, va_list args)
{
	// if there is no IDispatch connection point bail out
	if (m_pconDispatch == NULL)
		return E_FAIL;

    CUnknownItem *  pitem;          // an item in <m_listConnect>
                    
    m_pconDispatch->m_listConnect.Reset();
    while((pitem = m_pconDispatch->m_listConnect.GetNextItem()) != NULL)
    {
		IUnknown *punk;
        IDispatch *pdisp;
		HRESULT hr;

        punk = (IUnknown *) pitem->Contents();  // this does an AddRef
		hr = punk->QueryInterface(IID_IDispatch, (LPVOID *)&pdisp);
        punk->Release();

		if (FAILED(hr))
			return E_FAIL;

        DispatchInvokeList(pdisp, dispid, DISPATCH_METHOD, NULL, args);
        pdisp->Release();
    }

    return S_OK;
}


/* @method HRESULT | IConnectionPointHelper | FireEvent |

        Fire a given <i IDispatch>-based event on all objects (e.g. VBS)
        connected to this <o ConnectionPointHelper> object.  Parameters
        for the event are passed as a varying argument list.

@rvalue S_OK |
        Success.

@parm   DISPID | dispid | The ID of the event to fire.

@parm   (varying) | (arguments) | The arguments to pass to the event.
        These must consist of N pairs of arguments followed by a 0
        (zero value).  In each pair, the first argument is a VARTYPE
        value that indicates the type of the second argument.  Only a
        certain subset of VARTYPEs are supported.  See <f DispatchInvoke>
        for more information about the format of these arguments.

@ex     The following example fires the event DISPID_EVENT_BAR, which has
        two parameters (which in BASIC would be a Long and a String) --
        42 and "Hello", respectively, are passed as arguments. |

        pconpt->FireEvent(DISPID_EVENT_BAR, VT_INT, 42, VT_LPSTR, "Hello", 0);
*/
HRESULT __cdecl CConnectHelper::FireEvent(DISPID dispid, ...)
{
    HRESULT         hrReturn = S_OK; // function return code

    // start processing optional arguments
    va_list args;
    va_start(args, dispid);

    // fire the event with the specified arguments
    hrReturn = FireEventList(dispid, args);
    
    // end processing optional arguments
    va_end(args);

    return hrReturn;
}


/* @method HRESULT | IConnectionPointHelper | FireOnChanged |

        Fire a given <om IPropertyNotifySink.OnChanged> event on all objects
        connected to this <o ConnectionPointHelper> object.  

@rvalue S_OK |
        Success.

@parm   DISPID | dispid | The ID of the event to fire.

*/
STDMETHODIMP CConnectHelper::FireOnChanged(DISPID dispid)
{
    CUnknownItem		*pitem;          // an item in <m_listConnect>
                    
    m_pconPropertyNotify->m_listConnect.Reset();
    while((pitem = m_pconPropertyNotify->m_listConnect.GetNextItem()) != NULL)
    {
		IUnknown *punk;
        IPropertyNotifySink *pnotify;
		HRESULT hr;

        punk = (IUnknown *) pitem->Contents();  // this does an AddRef
		hr = punk->QueryInterface(IID_IPropertyNotifySink, (LPVOID *)&pnotify);
        punk->Release();

		if (FAILED(hr))
			return E_FAIL;

		pnotify->OnChanged(dispid);
        pnotify->Release();
    }

    return S_OK;
}

/* @method HRESULT | IConnectionPointHelper | FireOnRequestEdit |

        Fire a given <om IPropertyNotifySink.OnRequestEdit> event on all objects
        connected to this <o ConnectionPointHelper> object.  

@rvalue S_OK |
        Success.

@parm   DISPID | dispid | The ID of the event to fire.

*/
STDMETHODIMP CConnectHelper::FireOnRequestEdit(DISPID dispid)
{
    CUnknownItem		*pitem;          // an item in <m_listConnect>
                    
    m_pconPropertyNotify->m_listConnect.Reset();
    while((pitem = m_pconPropertyNotify->m_listConnect.GetNextItem()) != NULL)
    {
		IUnknown *punk;
        IPropertyNotifySink *pnotify;
		HRESULT hr;

        punk = (IUnknown *) pitem->Contents();  // this does an AddRef
		hr = punk->QueryInterface(IID_IPropertyNotifySink, (LPVOID *)&pnotify);
        punk->Release();

		if (FAILED(hr))
			return E_FAIL;

		pnotify->OnRequestEdit(dispid);
        pnotify->Release();
    }

    return S_OK;
}

/* @method HRESULT | IConnectionPointHelper | EnumConnectionPoints |

        Helps implement <om IConnectionPointContainer.EnumConnectionPoints>
        in the case where this object implements the only connections maintained
        by the connection point container.

@rdesc  Returns the same error codes as
        <om IConnectionPointContainer.EnumConnectionPoints>.

@parm   LPENUMCONNECTIONPOINTS * | ppEnum | See
        <om IConnectionPointContainer.EnumConnectionPoints>.

@ex     In the following example, <c CMyControl> is a class that is based
        on (among other things) <i IConnectionPointContainer>.  This example
        shows how to use this <om .EnumConnectionPoints> function to
        implement <om IConnectionPointContainer.EnumConnectionPoints>. |

        STDMETHODIMP CMyControl::EnumConnectionPoints(
            LPENUMCONNECTIONPOINTS *ppEnum)
        {
            return m_pconpt->EnumConnectionPoints(ppEnum);
        }
*/
STDMETHODIMP CConnectHelper::EnumConnectionPoints(LPENUMCONNECTIONPOINTS *ppEnum)
{
    HRESULT         hrReturn = S_OK; // function return code
    CEnumUnknown *  penum = NULL;   // new enumerator

    // set <penum> to the new enumerator
    if ((penum = New CEnumUnknown(IID_IEnumConnectionPoints)) == NULL)
        goto ERR_OUTOFMEMORY;

    // add the IDispatch connection point to the enumerated list
    if (m_pconDispatch && !penum->AddItem(m_pconDispatch))
        goto ERR_OUTOFMEMORY;

    // add the IPropertyNotifySink connection point to the enumerated list
    if (!penum->AddItem(m_pconPropertyNotify))
        goto ERR_OUTOFMEMORY;

    // return the enumerator
    *ppEnum = (LPENUMCONNECTIONPOINTS) penum;
    goto EXIT;

ERR_OUTOFMEMORY:

    hrReturn = E_OUTOFMEMORY;
    if (penum != NULL)
        penum->Release();
    *ppEnum = NULL;
    goto EXIT;

EXIT:

    return hrReturn;
}


/* @method HRESULT | IConnectionPointHelper | FindConnectionPoint |

        Helps implement <om IConnectionPointContainer.FindConnectionPoint>
        in the case where this object implements the only connections maintained
        by the connection point container.

@rdesc  Returns the same error codes as
        <om IConnectionPointContainer.FindConnectionPoint>.

@parm   LPENUMCONNECTIONPOINTS * | ppFindConnectionPoint | See
        <om IConnectionPointContainer.FindConnectionPoint>.

@ex     In the following example, <c CMyControl> is a class that is based
        on (among other things) <i IConnectionPointContainer>.  This example
        shows how to use this <om .FindConnectionPoint> function to
        implement <om IConnectionPointContainer.FindConnectionPoint>. |

        STDMETHODIMP CMyControl::FindConnectionPoint(REFIID riid,
            LPCONNECTIONPOINT *ppCP)
        {
            return m_pconpt->FindConnectionPoint(riid, ppCP);
        }
*/
STDMETHODIMP CConnectHelper::FindConnectionPoint(REFIID riid, LPCONNECTIONPOINT *ppCP)
{
    // we source a IDispatch-based <m_iid>
    if (IsEqualIID(riid, IID_IPropertyNotifySink))
		*ppCP = m_pconPropertyNotify;
	else if (m_pconDispatch && (IsEqualIID(riid, IID_IDispatch) || IsEqualIID(riid, m_pconDispatch->m_iid)))
		*ppCP = m_pconDispatch;
	else
        return CONNECT_E_NOCONNECTION;

    // return the requested pointer
    (*ppCP)->AddRef();
    return S_OK;
}

/* @method HRESULT | IConnectionPointHelper | Close |

        Empties the helper of all connections.  This is done typically
		just prior to destroying the CConnectHelper object.

@rdesc  S_OK.

*/
STDMETHODIMP CConnectHelper::Close(void)
{
	if (m_pconDispatch)
		{
		m_pconDispatch->m_cUnadvise += m_pconDispatch->m_listConnect.NumItems();
		m_pconDispatch->m_listConnect.EmptyList();
		}

	m_pconPropertyNotify->m_cUnadvise += m_pconPropertyNotify->m_listConnect.NumItems();
	m_pconPropertyNotify->m_listConnect.EmptyList();

	Delete m_pconDispatch;
	Delete m_pconPropertyNotify;

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\debug.cpp ===
// debug.cpp
//
// Debugging functions.
//

#include "precomp.h"
#include <tchar.h>
#include "debug.h"


//////////////////////////////////////////////////////////////////////////////
// TRACE, ASSERT, VERIFY
//
// These are the same as MFC's functions of the same name (but are implemented
// without using MFC).  See "debug.h" for the actual macro definitions.
//

#ifdef _DEBUG

BOOL AssertFailedLine(LPCSTR lpszFileName, int nLine)
{
    // active popup window for the current thread
    HWND hwndParent = GetActiveWindow();
    if (hwndParent != NULL)
        hwndParent = GetLastActivePopup(hwndParent);

    // format message into buffer
    TCHAR atchAppName[_MAX_PATH * 2];
    TCHAR atchMessage[_MAX_PATH * 2];
    if (GetModuleFileName(g_hinst, atchAppName,
            sizeof(atchAppName) / sizeof(TCHAR)) == 0)
        atchAppName[0] = 0;
    wsprintf(atchMessage, _T("%s: File %hs, Line %d"),
        atchAppName, lpszFileName, nLine);

    // display the assert
    int nCode = MessageBox(hwndParent, atchMessage, _T("Assertion Failed!"),
        MB_TASKMODAL | MB_ICONHAND | MB_ABORTRETRYIGNORE | MB_SETFOREGROUND);

    if (nCode == IDIGNORE)
        return FALSE;   // ignore

    if (nCode == IDRETRY)
        return TRUE;    // will cause DebugBreak()

    FatalExit(0);
    return TRUE;        // ...though FatalExit() should not return
}

void __cdecl Trace(LPCTSTR lpszFormat, ...)
{
    // start processing optional arguments
    va_list args;
    va_start(args, lpszFormat);

    // format the output string
    TCHAR atchBuffer[512];
    wvsprintf(atchBuffer, lpszFormat, args);

    // output the string
    OutputDebugString(atchBuffer);

    // end processing optional arguments
    va_end(args);
}

#endif // _DEBUG


/////////////////////////////////////////////////////////////////////////////
// DebugIIDName, DebugCLSIDName
//
// These functions convert an IID or CLSID to a string name for debugging
// purposes (e.g. IID_IUnknown is converted to "IUnknown").
//

#ifdef _DEBUG

LPCSTR DebugGUIDName(REFGUID rguid, LPSTR szKey, LPSTR pchName)
{
    OLECHAR         achIID[100];        // interface ID (e.g. "{nnn-nnn-...}")  
    TCHAR           ach[150];

    // in case of error, clear <pchName>
    pchName[0] = 0;

    // convert <rguid> to a string (e.g. "{nnn-nnn-...}")
    StringFromGUID2(rguid, achIID, sizeof(achIID)/sizeof(achIID[0]));

    wsprintf(ach, TEXT("%hs\\%ls"), szKey, (LPOLESTR) achIID);
    
    // look up <achIID> in the registration database
#ifdef UNICODE
    TCHAR pchNameTemp[300];
    LONG cchNameTemp;
    cchNameTemp = _MAX_PATH;
    if (RegQueryValue(HKEY_CLASSES_ROOT, ach, pchNameTemp, &cchNameTemp)
            != ERROR_SUCCESS)
        // if <achIID> isn't in the registration database, use <achIID> itself
        wsprintf(pchNameTemp, TEXT("%ls"), (LPOLESTR) achIID);

    wcstombs(pchName, pchNameTemp, _MAX_PATH);
#else
    LONG cchNameTemp;
    cchNameTemp = _MAX_PATH;
    if (RegQueryValue(HKEY_CLASSES_ROOT, ach, pchName, &cchNameTemp)
            != ERROR_SUCCESS)
        // if <achIID> isn't in the registration database, use <achIID> itself
        wsprintf(pchName, TEXT("%ls"), (LPOLESTR) achIID);
#endif    
    return pchName;
}

#endif // _DEBUG


/* DebugIIDName

@func   Finds the name of an interface in the system registration database
        given the interface's IID (for debugging purposes only).

@rdesc  Returns a pointer to <p pchName>.

@comm   If the interface name is not found, a hexadecimal string form of
        <p riid> will be returned
        (e.g. "{209D2C80-11D7-101B-BF00-00AA002FC1C2}").

@comm   This function is only available in a debug build.
*/

#ifdef _DEBUG

LPCSTR DebugIIDName(

REFIID riid, /* @parm
        Interface ID to find the name of. */

LPSTR pchName) /* @parm
        Where to store the class ID name string.  This buffer should be
        large enough to hold _MAX_PATH characters. */

{
    return DebugGUIDName(riid, "Interface", pchName);
}

#endif


/* DebugCLSIDName

@func   Finds the name of an interface in the system registration database
        given the interface's CLSID (for debugging purposes only).

@rdesc  Returns a pointer to <p pchName>.

@comm   If the interface name is not found, a hexadecimal string form of
        <p rclsid> will be returned
        (e.g. "{209D2C80-11D7-101B-BF00-00AA002FC1C2}").

@comm   This function is only available in a debug build.
*/

#ifdef _DEBUG

LPCSTR DebugCLSIDName(

REFCLSID rclsid, /* @parm
        Class ID to find the name of. */

LPSTR pchName) /* @parm
        Where to store the class ID name string.  This buffer should be
        large enough to hold _MAX_PATH characters. */

{
    return DebugGUIDName(rclsid, "Clsid", pchName);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\dispiez.cpp ===
// dispiez.cpp
//
// Implements IDispatch helper functions.
//
// Important: This .cpp file assumes a zero-initializing global "new" operator.
//
// @doc MMCTL
//

#include "precomp.h"
#include "..\..\inc\ochelp.h"
#include "debug.h"

// Common code used by DispatchInvokeEZ and DispatchInvokeIDEZ to convert the return
// value from a VARIANT into the requested type.  NOTE: The Variant is cleared by
// this function.
static HRESULT DispatchInvokeListIDEZ(IDispatch *pdisp, DISPID dispid, WORD wFlags,
    VARTYPE vtReturn, LPVOID pvReturn, va_list args)
{
    HRESULT hr;
    VARIANT var;

    // Call the function
    hr = DispatchInvokeList(pdisp, dispid, wFlags, &var, args);

    // Return immediately on error
    if(FAILED(hr))
        goto EXIT;

    // Return the result
    if(vtReturn && pvReturn)
    {
        if (vtReturn == VT_VARIANT)
        {
            *((VARIANT *) pvReturn) = var;
            VariantInit(&var);
        }
        else
        {
            VARTYPE vtTemp;
            HRESULT hrTemp;

            // try to coerce the variant into the correct type.
            if (vtReturn == VT_INT)
                vtTemp = VT_I4;
            else
            if (vtReturn == VT_LPSTR)
                vtTemp = VT_BSTR;
            else
                vtTemp = vtReturn;
            if (FAILED(hrTemp = VariantChangeType(&var, &var, 0, vtTemp)))
            {
                hr = hrTemp;
                goto EXIT;
            }

            switch(vtReturn)
            {
                case VT_I2:
                    *((short *) pvReturn) = var.iVal;
                    break;
                case VT_I4:
                case VT_INT:
                    *((long *) pvReturn) = var.lVal;
                    break;
                case VT_R4:
                    *((float *) pvReturn) = V_R4(&var);
                    break;
                case VT_R8:
                    *((double *) pvReturn) = V_R8(&var);
                    break;
                case VT_BOOL:
                    *((BOOL *) pvReturn) = (V_BOOL(&var) == 0 ? 0 : 1);
                    break;
                case VT_BSTR:
                    *((BSTR *) pvReturn) = var.bstrVal;
                    VariantInit(&var); // prevent VariantClear clearing var.bstrVal
                    break;
                case VT_DISPATCH:
                    *((LPDISPATCH *) pvReturn) = var.pdispVal;
                    VariantInit(&var); // prevent VariantClear clearing var.pdispVal
                    break;
                case VT_UNKNOWN:
                    *((LPUNKNOWN *) pvReturn) = var.punkVal;
                    VariantInit(&var); // prevent VariantClear clearing var.punkVal
                    break;
                case VT_LPSTR:
                    if(var.bstrVal)
					{
						if (UNICODEToANSI(LPSTR(pvReturn), var.bstrVal,
										  _MAX_PATH) == 0)
						{
							// The string couldn't be converted.  One cause is
							// a string that's longer than _MAX_PATH characters,
							// including the NULL.

							hr = DISP_E_OVERFLOW;
							ASSERT(FALSE);
							goto EXIT;
						}
					}
                    else
					{
                        ((LPSTR)pvReturn)[0] = '\0';
					}
                    break;
                default:
                    hr = DISP_E_BADVARTYPE;
                    break;
            }
        }
    }

EXIT:

    VariantClear(&var);

    return hr;
}


/* @func HRESULT | DispatchInvokeIDEZ |

        Calls <om IDispatch.Invoke> on a given <i IDispatch> object, passing
        arguments specified as a variable-length list of arguments.  This function
        is almost identical to <f DispatchInvokeEZ>, except that <f DispatchInvokeIDEZ>
        takes a DISPID rather than a name of a property/method.

@rdesc  Returns the same HRESULT as <om IDispatch.Invoke>.

@parm   IDispatch * | pdisp | The interface to call <om IDispatch.Invoke> on.

@parm   DISPID | dispid | The DISPID of the property or method to invoke.

@parm   WORD | wFlags | May be one of the following values (see
        <om IDispatch.Invoke> for more information):

        @flag   DISPATCH_METHOD | The member <p dispid> is being invoked as a
                method.  If a property has the same name, both this and the
                DISPATCH_PROPERTYGET flag may be set.

        @flag   DISPATCH_PROPERTYGET | The member <p dispid> is being retrieved
                as a property or data member.

        @flag   DISPATCH_PROPERTYPUT | The member <p dispid> is being changed
                as a property or data member.

@parm   VARTYPE | vtReturn | The type of the return value (or NULL if the return
        value should be ignored).  See <f DispatchInvokeEZ> for more details.

@parm   LPVOID | pvReturn | Where to store the return value from the method
        or property-get call.  See <f DispatchInvokeEZ> for more details.

@parm   (varying) | (arguments) | The arguments to pass to the method or
        property.  See <f DispatchInvokeEZ> for more details.

@comm   Named arguments are not supported by this function.

        Don't forget to add a 0 argument to the end of the argument list.

@ex     If a control has a "put" property that looks like this in ODL: |

        [propput, id(DISPID_TABSTOP)]
        HRESULT TabStop([in] float flTabStop)

@ex     then the property can be set with DispatchInvokeIDEZ using the
		following code: |

        DispatchInvokeIDEZ(pdisp, DISPID_TABSTOP, DISPATCH_PROPERTYPUT, NULL, NULL, VT_R4, flTabStop, 0);

@ex		If the ODL for the corresponding "get" property looks like this: |

        [propget, id(DISPID_TABSTOP)]
        HRESULT TabStop([out, retval] float *pflTabStop);

@ex     then the property can be read as follows: |

		float flTabStop;
        DispatchInvokeIDEZ(pdisp, DISPID_TABSTOP, DISPATCH_PROPERTYGET, VT_R4, &flTabStop, 0);

@ex     If the control has a SetText method with this ODL description: |

        [id(DISPID_SETTEXT)]
        HRESULT SetText([in] BSTR bstrText, [in] long lSize, [in] BOOL fBold);

@ex     then the method can be called with the following code: |
        
        DispatchInvokeIDEZ(pdisp, DISPID_SETTEXT, DISPATCH_METHOD, NULL, NULL, VT_LPSTR, "Hello", VT_I4, 12, VT_BOOL, FALSE, 0);

@ex     (Note that DispatchInvokeIDEZ copies the VT_LPSTR parameter to a BSTR
		before passing it to SetText.  You can also pass in a BSTR or an
		OLECHAR* for the first parameter.)

		If a method has an "out" parameter that is marked as "retval" in ODL,
		then DispatchInvokeIDEZ stores that parameter in varResult.  If the
		method looks like this, for example: |

        [id(DISPID_GETROTATION)]
        HRESULT GetRotation([in] long iCell, [out, retval] float *pflRotation);

@ex		then GetRotation should be called like this: |

		float flRotation;
		DispatchInvokeIDEZ(pdisp, DISPID_GETROTATION, DISPATCH_METHOD, VT_R4, &flRotation, VT_I4, iCell, 0);

@ex 	If you need to pass in a type that is not directly supported by
		DispatchInvokeIDEZ, you can use VT_VARIANT.  Let's say the control has
		a GetFormat method that looks like this: |

        [id(DISPID_GETFORMAT)]
        HRESULT GetFormat([out] long *lColor, [out] BOOL *pfBold);
        
@ex 	This takes a pointer-to-long and a pointer-to-BOOL, neither of which
		can be passed directly to DispatchInvokeIDEZ.  You can, however, use
		VARIANTs to call GetFormat: |

		long lColor;
		BOOL fBold;
		VARIANT varColor, varBold;

		VariantInit(&varColor);
		V_VT(&varColor) = VT_I4 | VT_BYREF;
		V_I4REF(&varColor) = &lColor;
		VariantInit(&varBold);
		V_VT(&varBold) = VT_BOOL | VT_BYREF;
		V_BOOLREF(&varBold) = &fBold;

		DispatchInvokeIDEZ(pdisp, DISPID_GETFORMAT, DISPATCH_METHOD, NULL, NULL, VT_VARIANT, varColor, VT_VARIANT, varBold, 0);

*/
HRESULT DispatchInvokeIDEZ(IDispatch *pdisp, DISPID dispid, WORD wFlags,
    VARTYPE vtReturn, LPVOID pvReturn, ...)
{
    HRESULT hr;

    // Call the function
    va_list args;
    va_start(args, pvReturn);
    hr = DispatchInvokeListIDEZ(pdisp, dispid, wFlags, vtReturn, pvReturn, args);
    va_end(args);

    return hr;
}

/* @func HRESULT | DispatchInvokeEZ |

        Calls <om IDispatch.Invoke> on a given <i IDispatch> object, passing
        arguments specified as a variable-length list of arguments.  This function
        is similar to <f DispatchInvoke>, but requires less setup.

@rdesc  Returns the same HRESULT as <om IDispatch.Invoke>.

@parm   IDispatch * | pdisp | The interface to call <om IDispatch.Invoke> on.

@parm   LPWSTR | pstr | The name of the property or method to invoke.

@parm   WORD | wFlags | May be one of the following values (see
        <om IDispatch.Invoke> for more information):

        @flag   DISPATCH_METHOD | The member <p pstr> is being invoked as a
                method.  If a property has the same name, both this and the
                DISPATCH_PROPERTYGET flag may be set.

        @flag   DISPATCH_PROPERTYGET | The member <p pstr> is being retrieved
                as a property or data member.

        @flag   DISPATCH_PROPERTYPUT | The member <p pstr> is being changed
                as a property or data member.

@parm   VARTYPE | vtReturn | The type of the return value (or NULL if the return
        value should be ignored).  The following VARTYPE values are supported:

        @flag   VT_INT | <p pvReturn> is an int *.

        @flag   VT_I2 | <p pvReturn> is a short *.

        @flag   VT_I4 | <p pvReturn> is a long *.

        @flag   VT_R4 | <p pvReturn> is a float *.

        @flag   VT_R8 | <p pvReturn> is a double *.

        @flag   VT_BOOL | <p pvReturn> is a BOOL * (<y not> a
                VARIANT_BOOL *).  Note that this behavior differs
                slightly from the usual definition of VT_BOOL.

        @flag   VT_BSTR | <p pvReturn> is a BSTR *.  If the function
				succeeds, the caller of <f DispatchInvokeEZ> should free this 
				BSTR using <f SysFreeString>.

        @flag   VT_LPSTR | <p pvReturn> is an LPSTR that points
                to a char array capable of holding at least _MAX_PATH
                characters, including the terminating NULL.  (You should
				declare this as "char achReturn[_MAX_PATH]".)  If the string is
				too long for the LPSTR, DISP_E_OVERFLOW is returned.

        @flag   VT_DISPATCH | <p pvReturn> is an LPDISPATCH *.
                The caller of <f DispatchInvokeEZ> must call <f Release>
                on this LPDISPATCH.

        @flag   VT_UNKNOWN | <p pvReturn> is an LPUNKNOWN *.
                The caller of <f DispatchInvokeEZ> must call <f Release>
                on this LPUNKNOWN.

        @flag   VT_VARIANT | <p pvReturn> is a VARIANT *.
                This allows arbitrary parameters to be passed using this
                function.  Note that this behavior differs from the usual
                definition of VT_VARIANT.  The caller of <f DispatchGetArgs>
				should must call VariantClear on this VARIANT.

@parm   LPVOID | pvReturn | Where to store the return value from the method
        or property-get call.  If <p pvReturn> is NULL, the result (if any) is
        discarded.  See the <p vtReturn> property for more infomation.  This value
        is unchanged if <f DispatchInvokeEZ> returns an error code.

@parm   (varying) | (arguments) | The arguments to pass to the method or
        property.  These must consist of N pairs of arguments followed by
        a 0 (zero value).  In each pair, the first argument is a VARTYPE
        value that indicates the type of the second argument.  The following
        VARTYPE values are supported:

        @flag   VT_INT | The following argument is an int.  <f Invoke>
                passes this as VT_I4, so this parameter should be declared
                as a Long in BASIC.

        @flag   VT_I2 | The following argument is a short.  In BASIC
                this parameter should be declared as Integer.

        @flag   VT_I4 | The following argument is a long.  In BASIC
                this parameter should be declared as Long.

        @flag   VT_R4 | The following argument is a float.  In BASIC
                this parameter should be declared as Single.

        @flag   VT_R8 | The following argument is a double.  In BASIC
                this parameter should be declared as Double.

        @flag   VT_BOOL | The following argument is a BOOL (<y not> a
                VARIANT_BOOL).  In BASIC this parameter should be declared
                as Boolean or Integer.  Note that this behavior differs
                slightly from the usual definition of VT_BOOL.

        @flag   VT_BSTR | The following argument is a BSTR or an OLECHAR *.
				In BASIC this parameter should be declared as String.

        @flag   VT_LPSTR | The following argument is an LPSTR.  <f Invoke>
                passes this as a BSTR, so this parameter should be declared
                as a String in BASIC.  Note that this behavior differs
                from the usual definition of VT_LPSTR.

        @flag   VT_DISPATCH | The following argument is an LPDISPATCH.  In
                BASIC this parameter should be declared as an Object.

        @flag   VT_UNKNOWN | The following argument is an LPUNKNOWN.

        @flag   VT_VARIANT | The following arguement is a VARIANT that is
                passed as-is to <f Invoke>.  This allows arbitrary parameters
                to be passed using this function.  Note that this behavior
                differs from the usual definition of VT_VARIANT.

@comm   Named arguments are not supported by this function.

        Don't forget to add a 0 argument to the end of the argument list.

@ex     If a control has a "put" property that looks like this in ODL: |

        [propput, id(DISPID_TABSTOP)]
        HRESULT TabStop([in] float flTabStop)

@ex     then the property can be set with DispatchInvokeEZ using the following
		code: |

        DispatchInvokeEZ(pdisp, L"put_TabStop", DISPATCH_PROPERTYPUT, NULL, NULL, VT_R4, flTabStop, 0);

@ex		If the ODL for the corresponding "get" property looks like this: |

        [propget, id(DISPID_TABSTOP)]
        HRESULT TabStop([out, retval] float *pflTabStop);

@ex     then the property can be read as follows: |

		float flTabStop;
        DispatchInvokeEZ(pdisp, L"get_TabStop", DISPATCH_PROPERTYGET, VT_R4, &flTabStop, 0);

@ex     If the control has a SetText method with this ODL description: |

        [id(DISPID_SETTEXT)]
        HRESULT SetText([in] BSTR bstrText, [in] long lSize, [in] BOOL fBold);

@ex     then the method can be called with the following code: |
        
        DispatchInvokeEZ(pdisp, L"SetText", DISPATCH_METHOD, NULL, NULL, VT_LPSTR, "Hello", VT_I4, 12, VT_BOOL, FALSE, 0);

@ex     (Note that DispatchInvokeEZ copies the VT_LPSTR parameter to a BSTR
		before passing it to SetText.  You can also pass in a BSTR or an
		OLECHAR* for the first parameter.)

		If a method has an "out" parameter that is marked as "retval" in ODL,
		then DispatchInvokeEZ stores that parameter in varResult.  If the
		method looks like this, for example: |

        [id(DISPID_GETROTATION)]
        HRESULT GetRotation([in] long iCell, [out, retval] float *pflRotation);

@ex		then GetRotation should be called like this: |

		float flRotation;
		DispatchInvokeEZ(pdisp, L"GetRotation", DISPATCH_METHOD, VT_R4, &flRotation, VT_I4, iCell, 0);

@ex 	If you need to pass in a type that is not directly supported by
		DispatchInvokeEZ, you can use VT_VARIANT.  Let's say the control has a
		GetFormat method that looks like this: |

        [id(DISPID_GETFORMAT)]
        HRESULT GetFormat([out] long *lColor, [out] BOOL *pfBold);
        
@ex 	This takes a pointer-to-long and a pointer-to-BOOL, neither of which
		can be passed directly to DispatchInvokeEZ.  You can, however, use
		VARIANTs to call GetFormat: |

		long lColor;
		BOOL fBold;
		VARIANT varColor, varBold;

		VariantInit(&varColor);
		V_VT(&varColor) = VT_I4 | VT_BYREF;
		V_I4REF(&varColor) = &lColor;
		VariantInit(&varBold);
		V_VT(&varBold) = VT_BOOL | VT_BYREF;
		V_BOOLREF(&varBold) = &fBold;

		DispatchInvokeEZ(pdisp, L"GetFormat", DISPATCH_METHOD, NULL, NULL, VT_VARIANT, varColor, VT_VARIANT, varBold, 0);

*/
HRESULT DispatchInvokeEZ(IDispatch *pdisp, LPWSTR pstr, WORD wFlags,
    VARTYPE vtReturn, LPVOID pvReturn, ...)
{
    HRESULT hr;
    DISPID dispid;

    // find the dispid
    hr = pdisp->GetIDsOfNames(IID_NULL, &pstr, 1, LOCALE_SYSTEM_DEFAULT, &dispid);
    if(FAILED(hr))
        return hr;

    // Call the function
    va_list args;
    va_start(args, pvReturn);
    hr = DispatchInvokeListIDEZ(pdisp, dispid, wFlags, vtReturn, pvReturn, args);
    va_end(args);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\disphelp.cpp ===
// disphelp.cpp
//
// Implements IDispatch helper functions.
//
// Important: This .cpp file assumes a zero-initializing global "new" operator.
//
// @doc MMCTL
//

#include "precomp.h"
#include "..\..\inc\ochelp.h"
#include "debug.h"


/* @func HRESULT | DispatchInvokeList |

        Calls <om IDispatch.Invoke> on a given <i IDispatch> object, passing
        arguments specified as a va_list array.

@rdesc  Returns the same HRESULT as <om IDispatch.Invoke>.

@parm   IDispatch * | pdisp | The interface to call <om IDispatch.Invoke> on.

@parm   DISPID | dispid | The ID of the property or method to invoke.  See
        <om IDispatch.Invoke> for more information.

@parm   WORD | wFlags | May be one of the following values (see
        <om IDispatch.Invoke> for more information):

        @flag   DISPATCH_METHOD | The member <p dispid> is being invoked as a
                method.  If a property has the same name, both this and the
                DISPATCH_PROPERTYGET flag may be set.

        @flag   DISPATCH_PROPERTYGET | The member <p dispid> is being retrieved
                as a property or data member.

        @flag   DISPATCH_PROPERTYPUT | The member <p dispid> is being changed
                as a property or data member.

@parm   VARIANT * | pvarResult | Where to store the return value from the
        method or property-get call.  If <p pvarResult> is NULL, the result
        (if any) is discarded.  If <p pvarResult> is non-NULL, then it is the
        caller's responsibility to call <f VariantClear>(<p pvarResult>)
        on exit (but the caller doesn't have to call
        <f VariantInit>(<p pvarResult>) on entry).

@parm   va_list | args | The arguments to pass to the method or property.
        See <f DispatchInvoke> for a description of the organization of
        <p args>.

@comm   Named arguments are not supported by this function.
*/
STDAPI DispatchInvokeList(IDispatch *pdisp, DISPID dispid,
    WORD wFlags, VARIANT *pvarResult, va_list args)
{
    HRESULT         hrReturn = S_OK; // function return code
    VARIANTARG      ava[20];        // parameters
    VARIANTARG *    pva;            // pointer into <ava>
    int             cva = 0;        // number of items stored in <ava>
    DISPPARAMS      dp;             // parameters to Invoke
    VARIANT         varResultTmp;   // temporary result storage
    LPSTR           sz;
    OLECHAR         aoch[300];
    VARTYPE         vt;

    // loop once for each (VARTYPE, value) pair in <args>;
    // store arguments in <ava> (last argument first, as required by
    // Invoke()); on exit <pva> points to the last argument and
    // <cva> is the number of arguments
    pva = ava + (sizeof(ava) / sizeof(*ava));
    while (TRUE)
    {
        if ((vt = va_arg(args, VARTYPE)) == 0)
            break;
        if (--pva == ava)
            goto ERR_FAIL; // too many arguments
        cva++;
        pva->vt = vt;
        switch (pva->vt)
        {
        case VT_I2:
            pva->iVal = va_arg(args, short);
            break;
        case VT_I4:
            pva->lVal = va_arg(args, long);
            break;
        case VT_INT:
            pva->vt = VT_I4;
            pva->lVal = va_arg(args, int);
            break;
        case VT_R4:
			// Note that when an argument of type float is passed in a variable
			// argument list, the compiler actually converts the float to a
			// double and pushes the double onto the stack.

            V_R4(pva) = float( va_arg(args, double) );
            break;
        case VT_R8:
            V_R8(pva) = va_arg(args, double);
            break;
        case VT_BOOL:
            V_BOOL(pva) = (va_arg(args, BOOL) == 0 ? 0 : -1);
            break;
        case VT_BSTR:
            if ( (pva->bstrVal = va_arg(args, LPOLESTR)) &&
                 ((pva->bstrVal = SysAllocString(pva->bstrVal)) == NULL) )
                goto ERR_OUTOFMEMORY;
            break;
        case VT_DISPATCH:
			V_DISPATCH(pva) = va_arg(args, LPDISPATCH);
            if (V_DISPATCH(pva) != NULL)
                V_DISPATCH(pva)->AddRef();
            break;
        case VT_UNKNOWN:
			V_UNKNOWN(pva) = va_arg(args, LPUNKNOWN);
            if (V_UNKNOWN(pva) != NULL)
                V_UNKNOWN(pva)->AddRef();
            break;
        case VT_VARIANT:
            VariantInit(pva);
            if (FAILED(hrReturn = VariantCopy(pva, &va_arg(args, VARIANT))))
                goto ERR_EXIT;
            break;
        case VT_LPSTR:
            sz = va_arg(args, LPSTR);
            pva->vt = VT_BSTR;
            MultiByteToWideChar(CP_ACP, 0, sz, -1, aoch,
                sizeof(aoch) / sizeof(*aoch));
            if ((pva->bstrVal = SysAllocString(aoch)) == NULL)
                goto ERR_OUTOFMEMORY;
            break;
        default:
            pva++;
            cva--;
            goto ERR_FAIL;
        }
    }

    // fill in <dp> with information about the arguments
    dp.rgvarg = pva;
    dp.cArgs = cva;

	// If we're setting a property, must initialize named args fields.
	// The Dispatch implementation created by CreateStdDispatch requires this.
	DISPID dispidNamedArgs;
	if (wFlags & DISPATCH_PROPERTYPUT)
	{
		// (Note that this works fine for either a single- or a multiple-
		// parameter property.  DispatchInvokeList can also GET a multiple-
		// parameter property.)

		dp.rgdispidNamedArgs = &dispidNamedArgs;
		dp.rgdispidNamedArgs[0] = DISPID_PROPERTYPUT;
		dp.cNamedArgs = 1;
	}
	else
	{
		dp.rgdispidNamedArgs = NULL;
		dp.cNamedArgs = 0;
	}

    // make <pvarResult> point to a valid VARIANT
    if (pvarResult == NULL)
        pvarResult = &varResultTmp;
    VariantInit(pvarResult);

    // invoke the method
    if (FAILED(hrReturn = pdisp->Invoke(dispid, IID_NULL, LOCALE_SYSTEM_DEFAULT,
            wFlags, &dp, pvarResult, NULL, NULL)))
        goto ERR_EXIT;

    goto EXIT;

ERR_FAIL:

    hrReturn = E_FAIL;
    goto ERR_EXIT;

ERR_OUTOFMEMORY:

    hrReturn = E_OUTOFMEMORY;
    goto ERR_EXIT;

ERR_EXIT:

    // error cleanup
    // (nothing to do)

    goto EXIT;

EXIT:

    // normal cleanup
    while (cva-- > 0)
        VariantClear(pva++);
    if (pvarResult == &varResultTmp)
        VariantClear(pvarResult);

    return hrReturn;
}


/* @func HRESULT | DispatchInvoke |

        Calls <om IDispatch.Invoke> on a given <i IDispatch> object, passing
        arguments specified as a variable-length list of arguments.

@rdesc  Returns the same HRESULT as <om IDispatch.Invoke>.

@parm   IDispatch * | pdisp | The interface to call <om IDispatch.Invoke> on.

@parm   DISPID | dispid | The ID of the property or method to invoke.  See
        <om IDispatch.Invoke> for more information.

@parm   WORD | wFlags | May be one of the following values (see
        <om IDispatch.Invoke> for more information):

        @flag   DISPATCH_METHOD | The member <p dispid> is being invoked as a
                method.  If a property has the same name, both this and the
                DISPATCH_PROPERTYGET flag may be set.

        @flag   DISPATCH_PROPERTYGET | The member <p dispid> is being retrieved
                as a property or data member.

        @flag   DISPATCH_PROPERTYPUT | The member <p dispid> is being changed
                as a property or data member.

@parm   VARIANT * | pvarResult | Where to store the return value from the
        method or property-get call.  If <p pvarResult> is NULL, the result
        (if any) is discarded.  If <p pvarResult> is non-NULL, then it is the
        caller's responsibility to call <f VariantClear>(<p pvarResult>)
        on exit (but the caller doesn't have to call
        <f VariantInit>(<p pvarResult>) on entry).

@parm   (varying) | (arguments) | The arguments to pass to the method or
        property.  These must consist of N pairs of arguments followed by
        a 0 (zero value).  In each pair, the first argument is a VARTYPE
        value that indicates the type of the second argument.  The following
        VARTYPE values are supported:

        @flag   VT_INT | The following argument is an int.  <f Invoke>
                passes this as VT_I4, so this parameter should be declared
                as a Long in BASIC.

        @flag   VT_I2 | The following argument is a short.  In BASIC
                this parameter should be declared as Integer.

        @flag   VT_I4 | The following argument is a long.  In BASIC
                this parameter should be declared as Long.

        @flag   VT_R4 | The following argument is a float.  In BASIC
                this parameter should be declared as Single.

        @flag   VT_R8 | The following argument is a double.  In BASIC
                this parameter should be declared as Double.

        @flag   VT_BOOL | The following argument is a BOOL (<y not> a
                VARIANT_BOOL).  In BASIC this parameter should be declared
                as Boolean or Integer.  Note that this behavior differs
                slightly from the usual definition of VT_BOOL.

        @flag   VT_BSTR | The following argument is a BSTR or an OLECHAR *.
				In BASIC this parameter should be declared as String.

        @flag   VT_LPSTR | The following argument is an LPSTR.  <f Invoke>
                passes this as a BSTR, so this parameter should be declared
                as a String in BASIC.  Note that this behavior differs
                from the usual definition of VT_LPSTR.

        @flag   VT_DISPATCH | The following argument is an LPDISPATCH.  In
                BASIC this parameter should be declared as an Object.

        @flag   VT_UNKNOWN | The following argument is an LPUNKNOWN.

        @flag   VT_VARIANT | The following arguement is a VARIANT that is
                passed as-is to <f Invoke>.  This allows arbitrary parameters
                to be passed using this function.  Note that this behavior
                differs from the usual definition of VT_VARIANT.

@comm   Named arguments are not supported by this function.

        Don't forget to add a 0 argument to the end of the argument list.

@ex     If a control has a "put" property that looks like this in ODL: |

        [propput, id(DISPID_TABSTOP)]
        HRESULT TabStop([in] float flTabStop)

@ex     then the property can be set with DispatchInvoke using the following
		code: |

        DispatchInvoke(pdisp, DISPID_TABSTOP, DISPATCH_PROPERTYPUT, NULL, VT_R4, flTabStop, 0);

@ex		If the ODL for the corresponding "get" property looks like this: |

        [propget, id(DISPID_TABSTOP)]
        HRESULT TabStop([out, retval] float *pflTabStop);

@ex     then the property can be read as follows: |

		VARIANT varResult;
        DispatchInvoke(pdisp, DISPID_TABSTOP, DISPATCH_PROPERTYGET, &varResult, 0);

@ex     The property value is stored as a VT_R4 in varResult.

		If the control has a SetText method with this ODL description: |

        [id(DISPID_SETTEXT)]
        HRESULT SetText([in] BSTR bstrText, [in] long lSize, [in] BOOL fBold);

@ex     then the method can be called with the following code: |
        
        DispatchInvoke(pdisp, DISPID_SETTEXT, DISPATCH_METHOD, NULL, VT_LPSTR, "Hello", VT_I4, 12, VT_BOOL, FALSE, 0);

@ex     (Note that DispatchInvoke copies the VT_LPSTR parameter to a BSTR before
		passing it to SetText.  You can also pass in a BSTR or an OLECHAR* for
		the first parameter.)

		If a method has an "out" parameter that is marked as "retval" in ODL,
		then DispatchInvoke stores that parameter in varResult.  If the method
		looks like this, for example: |

        [id(DISPID_GETROTATION)]
        HRESULT GetRotation([in] long iCell, [out, retval] float *pflRotation);

@ex		then GetRotation should be called like this: |

		VARIANT varResult;
		DispatchInvoke(pdisp, DISPID_GETROTATION, DISPATCH_METHOD, &varResult, VT_I4, iCell, 0);

@ex 	In this example, flRotation gets stored in varResult as a VT_R4.

		If you need to pass in a type that is not directly supported by
		DispatchInvoke, you can use VT_VARIANT.  Let's say the control has a
		GetFormat method that looks like this: |

        [id(DISPID_GETFORMAT)]
        HRESULT GetFormat([out] long *lColor, [out] BOOL *pfBold);
        
@ex 	This takes a pointer-to-long and a pointer-to-BOOL, neither of which
		can be passed directly to DispatchInvoke.  You can, however, use
		VARIANTs to call GetFormat: |

		long lColor;
		BOOL fBold;
		VARIANT varColor, varBold;

		VariantInit(&varColor);
		V_VT(&varColor) = VT_I4 | VT_BYREF;
		V_I4REF(&varColor) = &lColor;
		VariantInit(&varBold);
		V_VT(&varBold) = VT_BOOL | VT_BYREF;
		V_BOOLREF(&varBold) = &fBold;

		DispatchInvoke(pdisp, DISPID_GETFORMAT, DISPATCH_METHOD, NULL, VT_VARIANT, varColor, VT_VARIANT, varBold, 0);

*/
HRESULT __cdecl DispatchInvoke(IDispatch *pdisp, DISPID dispid,
    WORD wFlags, VARIANT *pvarResult, ...)
{
    HRESULT         hrReturn = S_OK; // function return code

    // start processing optional arguments
    va_list args;
    va_start(args, pvarResult);

    hrReturn = DispatchInvokeList(pdisp, dispid, wFlags, pvarResult, args);
    
    // end processing optional arguments
    va_end(args);

    return hrReturn;
}


/* @func HRESULT | DispatchPropertyPut |

        Sets the value of a given property on a given <i IDispatch> object.
        Used to help call <om IDispatch.Invoke>.

@rdesc  Returns the same HRESULT as <om IDispatch.Invoke>.

@parm   IDispatch * | pdisp | The interface to call <om IDispatch.Invoke> on.

@parm   DISPID | dispid | The ID of the property.  See <om IDispatch.Invoke>
        for more information.

@parm   VARTYPE | vt | The type of the <p value> parameter.  The valid values
        for <p vt> are the same as the VT_ values documented in
        <f DispatchInvoke>.

@parm   (varying) | value | The new property value.

@comm   Properties with parameters are not supported -- use
        <f DispatchInvoke> instead.
*/


/* @func HRESULT | DispatchPropertyGet |

        Gets the value of a given property on a given <i IDispatch> object.
        Used to help call <om IDispatch.Invoke>.

@rdesc  Returns the same HRESULT as <om IDispatch.Invoke>.

@parm   IDispatch * | pdisp | The interface to call <om IDispatch.Invoke> on.

@parm   DISPID | dispid | The ID of the property.  See <om IDispatch.Invoke>
        for more information.

@parm   VARIANT * | pvarResult | Where to store the return value from the
        method or property-get call.  It is the caller's responsibility to
        call <f VariantClear>(<p pvarResult>) on exit (but the caller doesn't
        have to call <f VariantInit>(<p pvarResult>) on entry).

@comm   Properties with parameters are not supported -- use
        <f DispatchInvoke> instead.
*/


/* @func HRESULT | DispatchGetArgsList |

        Retrieves arguments from a DISPPARAMS structure passed to
        <om IDispatch.Invoke>.  Arguments are stored in variables that
        are passed to <f DispatchGetArgsList> as a va_list array.
        Used to help implement <om IDispatch.Invoke>.

@rvalue S_OK |
        Success.

@rvalue DISP_E_BADPARAMCOUNT |
        The number of arguments in <p pdp> doesn't match the number of
        arguments specified in <p args>.

@rvalue DISP_E_BADVARTYPE |
        One of the VARTYPE values in <p args> is invalid.

@rvalue DISP_E_TYPEMISMATCH |
        One of the arguements in <p pdp> could not be coerced to the type
        of the corresponding parameter in <p args>.

@parm   DISPPARAMS * | pdp | The structure to retrieve arguments from.

@parm   DWORD | dwFlags | May contain the following flags:

        @flag   DGA_EXTRAOK | Don't return an error code if <p pdp> contains
                more actual arguments than the number of formal parameters
                specified in <p args>.  Instead, just ignore the extra
                arguments in <p pdp>.

        @flag   DGA_FEWEROK | Don't return an error code if <p pdp> contains
                fewer actual arguments than the number of formal parameters
                specified in <p args>.  Instead, ignore the extra parameters.
                In this case, the variables pointed to by elements of <p args>
                should be pre-initialized to default values before this
                function is called.

@parm   va_list | args | A list of pointers to variables which will receive
        the arguments from <p pdp>.  See <f DispatchGetArgs> for a description
        of the organizatin of <p args>.  In the event of an error, all
		BSTR <p args> are freed and the corresponding arguments are set to NULL;
*/
STDAPI DispatchGetArgsList(DISPPARAMS *pdp, DWORD dwFlags, va_list args)
{
    HRESULT         hrReturn = S_OK; // function return code
    VARIANTARG *    pva;            // pointer into <pdp->rgvarg>
    LPVOID          pvArg;          // where to store an argument
    VARTYPE         vtArg;          // the type that <pvArg> points to
    VARIANT         var;
    VARTYPE         vt;
	va_list			args_pre = args;
	va_list			args_post = args;
						// used to pre- and post-traverse the <args> list

    // ensure correct error cleanup
    VariantInit(&var);

	// set all the BSTR arguments to NULL so we can tell what needs to
	// be cleaned up below in the event of an error
	while ((vtArg = va_arg(args_pre, VARTYPE)) != 0)
	{
		pvArg = va_arg(args_pre, LPVOID);
		if (vtArg == VT_BSTR)
		{
			*((BSTR*)pvArg) = NULL;
		}
	}
	va_end(args_pre);

    // loop once for each (VARTYPE, value) pair in <args>;
    // retrieve arguments from <pdp->rgvarg> (last argument first, as
    // required by Invoke()); on exit <pva> should point to the first
    // argument in <pdp->rgvarg>
    pva = pdp->rgvarg + pdp->cArgs;
    while (TRUE)
    {
        // set <pvArg> to point to the variable that is to receive the
        // value of the next element of <rgvarg>, and set <vtArg> to the
        // type of variable that <pvArg> points to
        if ((vtArg = va_arg(args, VARTYPE)) == 0)
        {
            // we ran out of formal parameters (in <args>) -- if we have *not*
            // yet run out of actual arguments (in <pdp>) then we need to
            // return a DISP_E_BADPARAMCOUNT error, unless the caller has
            // asked us to relax this rule
            if ((pva != pdp->rgvarg) && !(dwFlags & DGA_EXTRAOK))
                goto ERR_BADPARAMCOUNT; // more arguments than parameters
            break;
        }
        pvArg = va_arg(args, LPVOID);

        // set <pva> to the next element of <rgvarg>, corresponding to
        // <pvArg> and <vtArg>
        if (pva-- == pdp->rgvarg)
        {
            // we ran out of actual arguments (in <pdp>) before running out
            // of formal parameters (in <args>) -- we need to return a
            // DISP_E_BADPARAMCOUNT error, unless the caller has asked us to
            // relax this rule
            if (dwFlags & DGA_FEWEROK)
                break;
            goto ERR_BADPARAMCOUNT;
        }

        // store the value of <pva> into <pvArg> (correctly coerced to
        // the type of <pvArg>)
        if (vtArg == VT_VARIANT)
            *((VARIANT *) pvArg) = *pva;
        else
        {
            // try to coerce <pva> to the type <vtArg>; store the result
            // into <var>
            VariantClear(&var);
            if (vtArg == VT_INT)
                vt = VT_I4;
            else
            if (vtArg == VT_LPSTR)
                vt = VT_BSTR;
            else
                vt = vtArg;
            if (FAILED(hrReturn = VariantChangeType(&var, pva, 0, vt)))
                goto ERR_EXIT;

            // copy from <var> to <*pvArg>
            switch (vtArg)
            {
            case VT_I2:
                *((short *) pvArg) = var.iVal;
                break;
            case VT_I4:
            case VT_INT:
                *((long *) pvArg) = var.lVal;
                break;
            case VT_R4:
                *((float *) pvArg) = V_R4(&var);
                break;
            case VT_R8:
                *((double *) pvArg) = V_R8(&var);
                break;
            case VT_BOOL:
                *((BOOL *) pvArg) = (V_BOOL(&var) == 0 ? 0 : 1);
                break;
            case VT_BSTR:
                *((BSTR *) pvArg) = var.bstrVal;
                VariantInit(&var); // prevent VariantClear clearing var.bstrVal
                break;
            case VT_DISPATCH:
                *((LPDISPATCH *) pvArg) = var.pdispVal;
                break;
            case VT_UNKNOWN:
                *((LPUNKNOWN *) pvArg) = var.punkVal;
                break;
            case VT_LPSTR:
				if (UNICODEToANSI(LPSTR(pvArg), var.bstrVal, _MAX_PATH) == 0)
				{
					// The string couldn't be converted.  One cause is a string
					// that's longer than _MAX_PATH characters, including the
					// NULL.

					hrReturn = DISP_E_OVERFLOW;
					goto ERR_EXIT;
				}
                break;
            default:
                hrReturn = DISP_E_BADVARTYPE;
                goto ERR_EXIT;
            }
        }
    }

    goto EXIT;

ERR_BADPARAMCOUNT:

    hrReturn = DISP_E_BADPARAMCOUNT;
    goto ERR_EXIT;

ERR_EXIT:

    // Error cleanup: free all BSTRs and set all IDispatch and IUnknown
	// pointers to NULL.  Failure to do the latter could cause problems if the
	// caller has error clean-up code that releases non-NULL pointers.
	while ((vtArg = va_arg(args_post, VARTYPE)) != 0)
	{
		pvArg = va_arg(args_post, LPVOID);
		if (vtArg == VT_BSTR)
		{
			SysFreeString(*((BSTR*)pvArg));
			*((BSTR*)pvArg) = NULL;
		}
		else if (vtArg == VT_DISPATCH)
		{
			*((LPDISPATCH*)pvArg) = NULL;
		}
		else if (vtArg == VT_UNKNOWN)
		{
			*((LPUNKNOWN*)pvArg) = NULL;
		}
	}
	va_end(args_post);
    goto EXIT;

EXIT:

    // normal cleanup
    VariantClear(&var);

    return hrReturn;
}


/* @func HRESULT | DispatchGetArgs |

        Retrieves arguments from a DISPPARAMS structure passed to
        <om IDispatch.Invoke>.  Arguments are stored in variables that
        are passed to <f DispatchGetArgs> as a va_list array.
        Used to help implement <om IDispatch.Invoke>.

@rvalue S_OK |
        Success.

@rvalue DISP_E_BADPARAMCOUNT |
        The number of arguments in <p pdp> doesn't match the number of
        arguments specified in <p (arguments)>.

@rvalue DISP_E_BADVARTYPE |
        One of the VARTYPE values in <p (arguments)> is invalid.

@rvalue DISP_E_TYPEMISMATCH |
        One of the arguements in <p pdp> could not be coerced to the type
        of the corresponding parameter in <p (arguments)>.

@rvalue DISP_E_OVERFLOW |
		A VT_LPSTR argument in <p pdp> is longer than _MAX_PATH characters
		(including the terminating NULL).  The longest VT_LPSTR that can be
		retrieved is _MAX_PATH characters, including the NULL.

@parm   DISPPARAMS * | pdp | The structure to retrieve arguments from.

@parm   DWORD | dwFlags | May contain the following flags:

        @flag   DGA_EXTRAOK | Don't return an error code if <p pdp> contains
                more actual arguments than the number of formal parameters
                specified in <p (arguments)>.  Instead, just ignore the extra
                arguments in <p pdp>.

        @flag   DGA_FEWEROK | Don't return an error code if <p pdp> contains
                fewer actual arguments than the number of formal parameters
                specified in <p (arguments)>.  Instead, ignore the extra
                parameters.  In this case, the variables pointed to by
                elements of <p (arguments)> should be pre-initialized to
                default values before this function is called.

@parm   (varying) | (arguments) | A list of pointers to variables which will
        receive the values of arguments from <p pdp>.  These must consist of N
        pairs of arguments followed by a 0 (zero value).  In each pair, the
        first argument is a VARTYPE value that indicates the type of variable
        that the the second argument points to.  (The actual arguments in
        <p pdp> will be coerced to the types specified in <p (arguments)>,
        if possible.) The following VARTYPE values are supported:

        @flag   VT_INT | The following argument is an int *.

        @flag   VT_I2 | The following argument is a short *.

        @flag   VT_I4 | The following argument is a long *.

        @flag   VT_R4 | The following argument is a float *.

        @flag   VT_R8 | The following argument is a double *.

        @flag   VT_BOOL | The following argument is a BOOL * (<y not> a
                VARIANT_BOOL *).  Note that this behavior differs
                slightly from the usual definition of VT_BOOL.

        @flag   VT_BSTR | The following argument is a BSTR *.  If the function
				succeeds, the caller of <f DispatchGetArgs> should free this 
				BSTR using <f SysFreeString>.  If the function fails, the
				BSTR is automatically freed, and the argument is set to 
				NULL.  <b IMPORTANT:> This behavior has changed:
                previously the caller was <b NOT> supposed to free this BSTR.
                (Note that the caller must free the BSTR because it may
                have been coerced from e.g. an integer.)

        @flag   VT_LPSTR | The following argument is an LPSTR that points
                to a char array capable of holding at least _MAX_PATH
                characters, including the terminating NULL.  (You should
				declare this as "char achArg[_MAX_PATH]".)  If the string in
				<p pdp> is too long for the LPSTR, DISP_E_OVERFLOW is returned.

        @flag   VT_DISPATCH | The following argument is an LPDISPATCH *.
                The caller of <f DispatchGetArgs> should not call <f Release>
                on this LPDISPATCH.

        @flag   VT_UNKNOWN | The following argument is an LPUNKNOWN *.
                The caller of <f DispatchGetArgs> should not call <f Release>
                on this LPUNKNOWN.

        @flag   VT_VARIANT | The following arguement is a VARIANT *.
                This allows arbitrary parameters to be passed using this
                function.  Note that this behavior differs from the usual
                definition of VT_VARIANT.  The caller of <f DispatchGetArgs>
				should not call VariantClear on this VARIANT.

@ex     The following example shows two parameters, an integer and a string,
        being retrieved from <p pdispparams> and stored into <p i> and
        <p ach>. |

        int i;
        char ach[_MAX_PATH];
        DispatchGetArgs(pdispparams, 0, VT_INT, &i, VT_LPSTR, ach, 0);
*/
HRESULT __cdecl DispatchGetArgs(DISPPARAMS *pdp, DWORD dwFlags, ...)
{
    HRESULT         hrReturn = S_OK; // function return code

    // start processing optional arguments
    va_list args;
    va_start(args, dwFlags);

    // copy arguments from <pdp> to <args>
    hrReturn = DispatchGetArgsList(pdp, dwFlags, args);
    
    // end processing optional arguments
    va_end(args);

    return hrReturn;
}


/* @func HRESULT | DispatchHelpGetIDsOfNames |

        Helps implement <om IDispatch.GetIDsOfNames> given a string that
        contains the list of <i IDispatch> member names.

@rdesc  Returns the same return codes as <om IDispatch.GetIDsOfNames>.

@parm   REFIID | riid | As defined for <om IDispatch.GetIDsOfNames>.

@parm   LPOLESTR * | rgszNames | As defined for <om IDispatch.GetIDsOfNames>.

@parm   UINT | cNames | As defined for <om IDispatch.GetIDsOfNames>.

@parm   LCID | lcid | As defined for <om IDispatch.GetIDsOfNames>.

@parm   DISPID * | rgdispid | As defined for <om IDispatch.GetIDsOfNames>.

@parm   char * | szList | The list of member names.  Each name in the list
        must be terminated by a newline.  The first member name is assigned
        DISPID value 0, the second 1, and so on.  For example, if <p szList>
        is "\\nFoo\\nBar\\n", then "Foo" is assigned DISPID value 1 and "Bar"
        is assigned 2 (because, in this example, the first string in <p szList>
        is "").
*/
STDAPI DispatchHelpGetIDsOfNames(REFIID riid, LPOLESTR *rgszNames,
    UINT cNames, LCID lcid, DISPID *rgdispid, const char *szList)
{
    DISPID *        pdispid;        // pointer into <rgdispid>
    UINT            cdispid;        // count of unprocessed <pdispid> items
    char            ach[200];

    // nothing to do if there are no names to convert to IDs
    if (cNames == 0)
        return S_OK;

    // set rgdispid[0] to the DISPID of the property/method name
    // rgszNames[0], or to -1 if the name is unknown
    UNICODEToANSI(ach, *rgszNames, sizeof(ach));
    *rgdispid = FindStringByValue(szList, ach);

    // fill the other elements of the <rgdispid> array with -1 values,
    // because we don't support named arguments
    for (pdispid = rgdispid + 1, cdispid = cNames - 1;
         cdispid > 0;
         cdispid--, pdispid++)
        *pdispid = -1;

    // if any names were unknown, return DISP_E_UNKNOWNNAME
    if ((*rgdispid == -1) || (cNames > 1))
        return DISP_E_UNKNOWNNAME;

    return S_OK;
}


/* @func HRESULT | VariantFromString |

        Initializes a VARIANT to contain the copy of an LPCTSTR string.

@rvalue S_OK | Success.

@rvalue E_OUTOFMEMORY | Out of memory.
@rvalue E_POINTER | One of the input pointers is NULL.

@parm   VARIANT * | pvarDst | A caller-supplied VARIANT structure to
        initialize.  The initial contents of <p pvarDst> are ignored;
        the caller does not need to call <f VariantInit> before
        calling <f VariantFromString>.  Both <p pvarDst>-<gt><p vt> and
        <p pvarDst>-<gt><p bstrVal> are initialized by this function.

@parm   LPCTSTR | szSrc | The string to copy.  Can't be NULL.
*/
STDAPI VariantFromString(VARIANT *pvar, LPCTSTR szSrc)
{
	if (NULL == pvar || szSrc == NULL)
		return E_POINTER;

    int cch = lstrlen(szSrc);
    if ((pvar->bstrVal = SysAllocStringLen(NULL, cch)) == NULL)
        return E_OUTOFMEMORY;
    ANSIToUNICODE(pvar->bstrVal, szSrc, cch + 1);
        // cch + 1 to account for terminal '\0' appended by SysAllocString()
    pvar->vt = VT_BSTR;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\dispid.cpp ===
// dispid.cpp
//
// Implements DispatchNameToID and DispatchIDToName.
//
// Important: This .cpp file assumes a zero-initializing global "new" operator.
//
// @doc MMCTL
//

#include "precomp.h"
#include "..\..\inc\ochelp.h"


/* @func DISPID | DispatchNameToID |

        Look up a <i IDispatch> member name (e.g. the name of a method
        or property) in a list of names and return the DISPID of the
        member name (if found).

@rdesc  Returns the DISPID of <p szName> if <p szName> is found in
        <p szList>.  Returns -1 if <p szName> is not found.

@parm   char * | szList | The list of member names to look up <p szName> in.
        <p szList> consists of the concatenation of each member name,
        where each member name is terminated by a newline character
        (e.g. "Foo\\nBar\\n").

@parm   char * | szName | The member name to look up.

@ex     The following line of code sets <p dispid> to 2. |

        dispid = DispatchNameToID("Foo\\nBar\\n", "bar");
*/
STDAPI_(DISPID) DispatchNameToID(char *szList, char *szName)
{
    for (DISPID dispid = 1; ; dispid++)
    {
        // make <pch> point to the next '\n' in <szList>
        for (char *pch = szList; *pch != '\n'; pch++)
            if (*pch == 0)
                return -1; // <szName> not found in <szList>

        // see if <szName> matches the next name in <szList>
        char ach[200];
        lstrcpyn(ach, szList, (DWORD) (pch - szList + 1));
        if (lstrcmpi(ach, szName) == 0)
            return dispid;

        // go to the next name in <szList>
        szList = pch + 1;
    }
}


/* @func DISPID | DispatchIDToName |

        Look up a DISPID in a list of names of methods and properties and
        return the member name (if found).

@rdesc  Returns a pointer to member number <p dispid> in <p szList> if found,
        or NULL if not found.  Note that the returned string is terminated
        by a newline character, not a null character -- user <p ppch> to
        copy the string (see the example below).

@parm   char * | szList | The list of member names to look up <p szName> in.
        <p szList> consists of the concatenation of each member name,
        where each member name is terminated by a newline character
        (e.g. "Foo\\nBar\\n").

@parm   DISPID | dispid | The member ID to look up.  The first member in
        <p szList> has DISPID 1; the second 2, and so on.

@ex     The following code stores "Bar" in <p ach>. |

        int cch;
        char ach[100];
        char *sz;
        DISPID dispid = 2;
        sz = DispatchIDToName("Foo\nBar\n", dispid, &cch);
        if (sz != NULL)
            lstrcpyn(ach, sz, cch + 1);
*/
STDAPI_(char *) DispatchIDToName(char *szList, DISPID dispid, int *pcch)
{
    if (dispid < 1)
        return NULL;

    while (TRUE)
    {
        // make <pch> point to the next '\n' in <szList>
        for (char *pch = szList; *pch != '\n'; pch++)
            if (*pch == 0)
                return NULL; // <dispid> not found in <szList>

        if (--dispid == 0)
        {
            // this is the member name we're looking for
            *pcch = (DWORD) (pch - szList);
            return szList;
        }

        // go to the next name in <szList>
        szList = pch + 1;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\globals.h ===
// Globals.h
//
// Global declarations.
//
// If you add a declaration here, add a corresponding definition to Globals.cpp.

#ifndef _GLOBALS_H_
#define _GLOBALS_H_


// DLL instance handle.
extern HINSTANCE g_hinst;				

// A critical section used within OCHelp.
extern CRITICAL_SECTION g_criticalSection;		


#endif // _GLOBALS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\globals.cpp ===
// Globals.cpp
//
// Global definitions.
//
// Important: This .cpp file assumes a zero-initializing global "new" operator.
//
// If you add a definition here, add a corresponding declaration to Globals.h.
//

#include "precomp.h"

// Define the GUIDs contained in header files that are not public.  These GUIDs
// must be defined within the OCHelp static library, since a user of the static
// library has no way to define them himself.  Those GUIDs that are contained
// in public header files (mmctlg.h and ochelp.h) get defined by the user of
// the static library in the following manner:
//
// 		#include <initguid.h>
// 		#include "mmctlg.h"
// 		#include "ochelp.h"

#include <initguid.h>
#include "..\..\inc\catid.h"  // This file is not public.


// DLL instance handle.
// HINSTANCE g_hinst;				

// A critical section used within OCHelp.
CRITICAL_SECTION g_criticalSection;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\factory.cpp ===
// factory.cpp
//
// Implements HelpCreateClassObject (and its class factory object).
//
// Important: This .cpp file assumes a zero-initializing global "new" operator.
//
// @doc MMCTL
//

#include "precomp.h"
#include "..\..\inc\ochelp.h"
#include "debug.h"


/////////////////////////////////////////////////////////////////////////////
// CClassFactory -- Implements IClassFactory
//

class CClassFactory : public IClassFactory
{
friend HRESULT _stdcall HelpGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppv,
    ControlInfo *pctlinfo);

///// IUnknown implementation
protected:
    ULONG           m_cRef;         // interface reference count
public:
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv)
    {
        if (IsEqualIID(riid, IID_IUnknown) ||
            IsEqualIID(riid, IID_IClassFactory))
        {
            *ppv = (LPVOID) this;
            AddRef();
            return NOERROR;
        }
        else
        {
            *ppv = NULL;
            return E_NOINTERFACE;
        }
    }
    STDMETHODIMP_(ULONG) AddRef()
    {
		return (++m_cRef);
    }
    STDMETHODIMP_(ULONG) Release()
    {
		ASSERT(m_cRef > 0);
		if (InterlockedDecrement((LONG*)&m_cRef) == 0)
		{
			Delete this;
			return (0);
		}
		return (m_cRef);
    }

///// IClassFactory implementation
protected:
    ControlInfo *m_pctlinfo;        // info. about control to create
public:
    STDMETHODIMP CreateInstance(LPUNKNOWN punkOuter, REFIID riid, LPVOID *ppv)
    {
        LPUNKNOWN punk = (m_pctlinfo->pallococ)(punkOuter);
        if (punk == NULL)
            return E_OUTOFMEMORY;
        HRESULT hr = punk->QueryInterface(riid, ppv);
        punk->Release();
        return hr;
    }
    STDMETHODIMP LockServer(BOOL fLock)
    {
        if (fLock)
			InterlockedIncrement((LONG*)m_pctlinfo->pcLock);
        else
            InterlockedDecrement((LONG*)m_pctlinfo->pcLock);

        return NOERROR;
    }

///// Construction
    CClassFactory(ControlInfo *pci) : m_pctlinfo(pci) {}
};


/* @func HRESULT | HelpGetClassObject |

        Helps implement <f DllGetClassObject> (including the class factory
        object it creates) for any number of controls.

@parm   REFCLSID | rclsid | See <f DllGetClassObject>.

@parm   REFIID | riid | See <f DllGetClassObject>.

@parm   LPVOID * | ppv | See <f DllGetClassObject>.

@parm   ControlInfo * | pci | Information about the control that's
        implemented by the DLL.  See <t ControlInfo> for more information.

@comm   <f HelpGetClassObject> can support one control by making a linked list
        out of your <t ControlInfo> structures -- set each <p pNext>
        field to the next structure, and set the last <p pNext> to NULL.

@ex     The following example shows how to implement <f DllGetClassObject>
        using <f HelpGetClassObject>. |

        STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppv)
        {
            return HelpGetClassObject(rclsid, riid, ppv, &g_ctlinfo);
        }
*/
STDAPI HelpGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppv,
    ControlInfo *pci)
{
    // loop once for each ControlInfo structure in linked list <pci>
    // to find a ControlInfo that can create class <rclsid>
    while(TRUE)
    {
        // check the <cbSize> field (used for version checking)
        if (pci->cbSize != sizeof(*pci))
        {
            TRACE("HelpGetClassobject: incorrect cbSize field\n");
            return E_FAIL;
        }

        // this DLL can only create class factory objects that support
        // IUnknown and IClassFactory
        if (!IsEqualIID(riid, IID_IUnknown) &&
            !IsEqualIID(riid, IID_IClassFactory))
            return E_NOINTERFACE;

        // <pci> implements objects of type <pci->rclsid>
        if (IsEqualCLSID(rclsid, *pci->pclsid))
        {
            // create the class factory object
            CClassFactory *pcf = New CClassFactory(pci);
            if (pcf == NULL)
                return E_OUTOFMEMORY;

            // return AddRef'd interface pointer
            pcf->m_cRef = 1;
            *ppv = (IClassFactory *) pcf;
            return S_OK;
        }

        // go to the next ControlInfo structure in the linked list
        if (pci->pNext == NULL)
            break;
        pci = pci->pNext;
    }

    // no ControlInfo was found that can create an object of class <rclsid>
    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\enumverb.cpp ===
//===========================================================================
// Copyright (c) Microsoft Corporation 1996
//
// File:		enumverb.cpp
//				
// Description:	This module contains the implementation of the CVerbEnum-
//				Helper class and its non-member factory function,
//				AllocVerbEnumHelper.
//
// History:		04/19/96	a-swehba
//					Created.
//				07/29/96	a-swehba
//					Next() -- S_FALSE is now valid return code.  Removed
//						ASSERTs.  NULL <pceltFetched> allowed.
//
// @doc MMCTL
//===========================================================================

//---------------------------------------------------------------------------
// Dependencies
//---------------------------------------------------------------------------

#include "precomp.h"			// precompiled headers
#include "debug.h"				// ASSERT(), etc.
#include "..\..\inc\ochelp.h"		// helper functions
#include "enumverb.h"




//===========================================================================
// Non-Member Functions
//
// Category:	Factory methods
//
// Notes:		(none)
//===========================================================================

//---------------------------------------------------------------------------
// @func	IEnumOLEVERB* | AllocVerbEnumHelper |
//			Allocates and initializes a verb enumeration helper.
//
// @parm	LPUNKNOWN | punkOuter |
//			[in] The controlling unknown.  May be NULL.
//
// @parm	void* | pOwner |
//			[in] The verbs' "owner".  That is, the object to which the verbs
//			refer.  May not be NULL.
//
// @parm	CLSID | clsidOwner |
//			[in] The class ID of <p pOwner>.  When the verb helper is
//			allocated, <p clsidOwner> is passed to <f OleRegEnumVerbs> to
//			get an <i IEnumOLEVERB> interface.
//
// @parm	VERB_ENUM_CALLBACK* | pCallback |
//			[in] This function will be called whenever the verb helper is
//			asked for verbs via its internal <om IEnumOLEVERB.Next> method.
//			<p pCallback> is passed a pointer to each <t OLEVERB>.  May not
//			be NULL.  <t VERB_ENUM_CALLBACK> is defined as follows:
//
//			typedef HRESULT (VERB_ENUM_CALLBACK)(OLEVERB* pVerb, void* pOwner);
//
// @rdesc	The verb enumeration helper's <i IEnumOLEVerb> interface or
//			NULL if out of memory.
//
// @comm	To implement <om IOleObject.EnumVerbs>, make sure that <p pObject>'s
//			class registers its verbs, define a <t VERB_ENUM_CALLBACK> 
//			callback function and implement <om IOleObject.EnumVerbs> by
//			calling <f AllocVerbEnumHelper>.  That's all it takes.
//
//			Typically the <p pCallback> function adjusts the state of
//			the verb's menu item based on the state of the <p pOwner> object.
//
// @ex		The following example shows a typical implementation of
//			<om IOleObject.EnumVerbs>, and the verb helper callback function: |
//
//			STDMETHODIMP CMyControl::EnumVerbs(IEnumOLEVERB** ppEnumOleVerb)
//			{
//				HRESULT hResult;
//				*ppEnumOleVerb = AllocVerbEnumHelper(NULL, CLSID_CMyControl,
//									&VerbEnumCallback, this);
//				hResult = (*ppEnumOleVerb != NULL) ? S_OK : E_OUTOFMEMORY;
//				return (hResult);
//			}
//
//			HRESULT VerbEnumCallback(
//			OLEVERB* pVerb, 
//			void* pOwner)
//			{
//				int flag;
//				CMyControl* pMyControl = (CMyControl*)pOwner;
//
//				switch (pVerb->lVerb)
//				{
//					case 0: // verb 0
//						// if pMyControl indicates that verb 0 should be enabled
//						//		flag = MF_ENABLED;
//						// else
//						//		flag = MF_GRAYED;
//						break;
//					case 1: // verb 1
//						// if pMyControl indicates that verb 1 should be enabled
//						//		flag = MF_ENABLED;
//						// else
//						//		flag = MF_GRAYED;
//						break;
//
//					// etc.
//
//					default:
//						break;
//				}
//				pVerb->fuFlags |= flag;
//				return (S_OK);
//			}
//---------------------------------------------------------------------------

STDAPI_(IEnumOLEVERB*) AllocVerbEnumHelper(
LPUNKNOWN punkOuter,
void* pOwner,
CLSID clsidOwner,
VERB_ENUM_CALLBACK* pCallback)
{
	// Preconditions

	ASSERT(pCallback != NULL);
	ASSERT(pOwner != NULL);

	return (CVerbEnumHelper::AllocVerbEnumHelper(punkOuter, 
												 pOwner,
												 clsidOwner,
												 pCallback, 
												 NULL));
}




//===========================================================================
// Class:			CVerbEnumHelper
//
// Method Level:	[x] class  [ ] instance
//
// Method Category:	factory methods
//
// Notes:			(none)
//===========================================================================

STDMETHODIMP_(IEnumOLEVERB*)
CVerbEnumHelper::AllocVerbEnumHelper(
LPUNKNOWN punkOuter,
void* pOwner,
CLSID clsidOwner,
VERB_ENUM_CALLBACK* pCallback,
CVerbEnumHelper* pEnumToClone)
{
    HRESULT hResult;
	CVerbEnumHelper* pEnum = NULL;

	// Preconditions

	ASSERT(pCallback != NULL);

	// Create a new enumerator.

	pEnum = New CVerbEnumHelper(punkOuter, pOwner, clsidOwner, pCallback, 
								pEnumToClone, &hResult);
	if ((pEnum == NULL) || FAILED(hResult))
	{
		goto Error;
	}
	((IUnknown*)pEnum)->AddRef();

Exit:

	return ((IEnumOLEVERB*)pEnum);

Error:
	
	if (pEnum != NULL)
	{
		Delete pEnum;
		pEnum = NULL;
	}
	goto Exit;
}




//===========================================================================
// Class:			CVerbEnumHelper
//
// Method Level:	[ ] class  [x] instance
//
// Method Category:	creating and destroying
//
// Notes:			(none)
//===========================================================================

CVerbEnumHelper::CVerbEnumHelper(
IUnknown* punkOuter,
void* pOwner,
CLSID clsidOwner,
VERB_ENUM_CALLBACK* pCallback,
CVerbEnumHelper* pEnumToClone,
HRESULT* pHResult)
{
	// Preconditions

	ASSERT(pCallback != NULL);
	ASSERT(pHResult != NULL);

    // Initialize private variables.

	m_pCallback = pCallback;
	m_pOwner = pOwner;
    m_cRef = 0;
    m_punkOuter = (punkOuter == NULL) 
					? (IUnknown*)(INonDelegatingUnknown*)this 
					: punkOuter;

	// Create an enumerator.  Clone it if we're provided an enumerator from
	// which to clone.  Create it fresh otherwise.

	if (pEnumToClone != NULL)
	{
		*pHResult = pEnumToClone->m_pVerbEnum->Clone(&m_pVerbEnum);
	}
	else
	{
		*pHResult = OleRegEnumVerbs(clsidOwner, &m_pVerbEnum);
	}
}




CVerbEnumHelper::~CVerbEnumHelper()
{
	if (m_pVerbEnum != NULL)
	{
		m_pVerbEnum->Release();
	}
}




//===========================================================================
// Class:			CVerbEnumHelper
//
// Method Level:	[ ] class  [x] instance
//
// Method Category:	IUnknown methods
//
// Notes:			(none)
//===========================================================================

STDMETHODIMP			
CVerbEnumHelper::QueryInterface(
REFIID riid, 
LPVOID* ppv)
{ 
	return (m_punkOuter->QueryInterface(riid, ppv));
}




STDMETHODIMP_(ULONG)	
CVerbEnumHelper::AddRef()
{ 
	return (m_punkOuter->AddRef());
}




STDMETHODIMP_(ULONG)	
CVerbEnumHelper::Release()
{ 
	return (m_punkOuter->Release());
}




//===========================================================================
// Class:			CVerbEnumHelper
//
// Method Level:	[ ] class  [x] instance
//
// Method Category:	NonDelegatingUnknown methods
//
// Notes:			(none)
//===========================================================================

STDMETHODIMP 
CVerbEnumHelper::NonDelegatingQueryInterface(
REFIID riid, 
LPVOID* ppv)
{
    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
	{
        *ppv = (IUnknown*)(INonDelegatingUnknown*)this;
	}
	else if (IsEqualIID(riid, IID_IEnumOLEVERB))
	{
        *ppv = (IEnumOLEVERB*)this;
	}
    else
	{
        return (E_NOINTERFACE);
	}

    ((IUnknown*)*ppv)->AddRef();
	return (S_OK);
}




STDMETHODIMP_(ULONG) 
CVerbEnumHelper::NonDelegatingAddRef()
{
	return (++m_cRef);
}




STDMETHODIMP_(ULONG) 
CVerbEnumHelper::NonDelegatingRelease()
{
	m_cRef--;
    if (m_cRef == 0L)
    {
        Delete this;
	}
	return (m_cRef);
}




//===========================================================================
// Class:			CVerbEnumHelper
//
// Method Level:	[ ] class  [x] instance
//
// Method Category:	IEnumOLEVerb methods
//
// Notes:			(none)
//===========================================================================

STDMETHODIMP 
CVerbEnumHelper::Next(
ULONG celt,
OLEVERB* rgVerb,
ULONG* pceltFetched)
{
	HRESULT hr, hrReturn;
	int iVerb;
	ULONG celtFetched;
		// the number of elements actually fetched

	// Preconditions -- According to the OLE spec, <pceltFetched> may be
	// NULL iff <celt> is 1.

	ASSERT(pceltFetched != NULL || celt == 1);

	// Get the next verb(s).

	if (FAILED(hrReturn = m_pVerbEnum->Next(celt, rgVerb, &celtFetched)))
	{
		goto Exit;
	}

	// Iterate through the verbs, and adjust their state depending on
	// the state of the underlying object.

	for (iVerb = 0; iVerb < (int)celtFetched; iVerb++)
	{
		if (FAILED(hr = (*m_pCallback)(rgVerb + iVerb, m_pOwner)))
		{
			hrReturn = hr;
			goto Exit;
		}
	}

Exit:
	
	if (pceltFetched != NULL)
	{
		*pceltFetched = celtFetched;
	}
	return (hrReturn);
}




STDMETHODIMP 
CVerbEnumHelper::Skip(
ULONG celt)
{
	return (m_pVerbEnum->Skip(celt));
}




STDMETHODIMP 
CVerbEnumHelper::Reset()
{
	return (m_pVerbEnum->Reset());
}




STDMETHODIMP 
CVerbEnumHelper::Clone( 
IEnumOLEVERB** ppenum)
{
	HRESULT	hResult = S_OK;

	// Preconditions

	ASSERT(ppenum != NULL);

	// Allocate a new numerator based on this one.

    *ppenum = AllocVerbEnumHelper(m_punkOuter, m_pOwner, m_clsidOwner, 
								  m_pCallback, this);
	if (ppenum == NULL)
	{
		hResult = E_OUTOFMEMORY;
	}

	return (hResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\dll.cpp ===
// dll.cpp
//
// DLL entry points etc.
//
// Important: This .cpp file assumes a zero-initializing global "new" operator.
//

#include "precomp.h"

#ifdef _DEBUG
    #pragma message("_DEBUG is defined.")
#else
    #pragma message("_DEBUG isn't defined.")
#endif
#ifdef _DESIGN
    #pragma message("_DESIGN is defined.")
#else
    #pragma message("_DESIGN isn't defined.")
#endif

// Define the GUIDs contained in public header files.  GUIDs contained in files
// that are not public are defined in Globals.cpp.

#include <initguid.h>
#include "..\..\inc\mmctlg.h" // see comments in "mmctl.h"
#include "..\..\inc\ochelp.h"

#include "debug.h"
#include "ftrace.h"		// FT_xxx macros


//////////////////////////////////////////////////////////////////////////////
// Globals used by the OCHelp DLL but not by the OCHelp static library.
// Globals used by the static library are defined in Globals.cpp.
//

extern "C" int _fltused = 1;
	// indicates we need to manipulate float & double variables without the 
	// C runtime


//////////////////////////////////////////////////////////////////////////////
// Standard DLL Entry Point
//

extern "C" BOOL WINAPI _DllMainCRTStartup(HINSTANCE hInst, DWORD dwReason,
    LPVOID lpreserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
		// Initialize the static library code that gets incorporated into the
		// DLL version of OCHelp.

		if (!InitializeStaticOCHelp(hInst))
			return FALSE;

        TRACE("OCHelp loaded\n");
    }
    else
    if (dwReason == DLL_PROCESS_DETACH)
	{
		UninitializeStaticOCHelp();
        TRACE("OCHelp unloaded\n");
    }

    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// Custom default "new" and "delete" (zero-initializing, non-C-runtime)
// for use within this DLL.
//

#define LEAKFIND 0 // 1 to turn on leak-finding support

void * _cdecl operator new(size_t cb)
{
#if LEAKFIND
    LPVOID pv = HelpNew(cb);
    TRACE("++OCHelp 0x%X %d new\n", pv, cb);
	return pv;
#else
	return HelpNew(cb);
#endif
}

void _cdecl operator delete(void *pv)
{
#if LEAKFIND
    TRACE("++OCHelp 0x%X %d delete\n", pv, -(((int *) pv)[-1]));
#endif
    HelpDelete(pv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\enumverb.h ===
//===========================================================================
// Copyright (c) Microsoft Corporation 1996
//
// File:		enumverb.h
//				
// Description:	(tbd)
//
// History:		04/19/96	a-swehba
//					Created.
//===========================================================================

#ifndef _ENUMVERB_H
#define _ENUMVERB_H

//---------------------------------------------------------------------------
// Dependencies
//---------------------------------------------------------------------------

#include "..\..\inc\mmctl.h"		// INonDelegatingUnknown




//===========================================================================
// Class:		CVerbEnumHelper	
//
// Description:	(tbd)
//===========================================================================

class CVerbEnumHelper : public INonDelegatingUnknown,
					    public IEnumOLEVERB
{
//
// Friends
//

	friend IEnumOLEVERB* _stdcall ::AllocVerbEnumHelper(
										LPUNKNOWN punkOuter,
										void* pOwner,
										CLSID clsidOwner,
										VERB_ENUM_CALLBACK* pCallback);
		// needs access to CVerbEnumHelper::AllocVerbEnumHelper()


//
// Class Features
//

private:

	// factory methods

	static STDMETHODIMP_(IEnumOLEVERB*) AllocVerbEnumHelper(
											LPUNKNOWN punkOuter,
											void* pOwner,
											CLSID clsidOwner,
											VERB_ENUM_CALLBACK* pCallback,
											CVerbEnumHelper* pEnumToClone);


//
// Instance Features
//

protected:

	// NonDelegatingUnknown methods

    STDMETHODIMP			NonDelegatingQueryInterface(
								REFIID riid, 
								LPVOID* ppv);
    STDMETHODIMP_(ULONG)	NonDelegatingAddRef();
    STDMETHODIMP_(ULONG)	NonDelegatingRelease();

	// IUnknown methods

    STDMETHODIMP			QueryInterface(
								REFIID riid, 
								LPVOID* ppv);
    STDMETHODIMP_(ULONG)	AddRef();
    STDMETHODIMP_(ULONG)	Release();

	// IEnumOLEVERB methods

	STDMETHODIMP	Next(	
						ULONG celt, 
						OLEVERB* rgverb, 
						ULONG* pceltFetched); 
	STDMETHODIMP	Skip(
						ULONG celt); 
	STDMETHODIMP	Reset(); 
	STDMETHODIMP	Clone(
						IEnumOLEVERB** ppenum); 

private:
	
	// creating and destroying

	CVerbEnumHelper(
		IUnknown* punkOuter,
		void* pOwner,
		CLSID clsidOwner,
		VERB_ENUM_CALLBACK* pCallback,
		CVerbEnumHelper* pEnumToClone,
		HRESULT* pHResult);
    ~CVerbEnumHelper();

	// private variables

	VERB_ENUM_CALLBACK* m_pCallback;
		// this function is called each time CVerbEnumHelper::Next() is
		// called
	void* m_pOwner;
		// the object which "owns" the verbs associated with this enumerator
	CLSID m_clsidOwner;
		// the class ID of <m_pOwner>
	IEnumOLEVERB* m_pVerbEnum;
		// the enumerator's IEnumOLEVERB interface is implemented by calling
		// this interface which is, ultimately, provided by OleRegEnumVerbs()
    ULONG m_cRef;
		// object reference count; used only if the object isn't aggregated
    LPUNKNOWN  m_punkOuter;    
		// the controlling unknown; possibly NULL
};




#endif // _ENUMVERB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\ftrace.h ===
//================================================================================
// File:		ftrace.h
//
// Description:	This file contains all the declarations for the Function Trace 
//				(FT) package.
//================================================================================

#ifndef _FTRACE_H_
#define _FTRACE_H_




//--------------------------------------------------------------------------------
// Trace Macros
//
// Note:	Code which used function tracing should only use these macros.  The 
//			actual trace *functions* should never be called directly.  This is for 
//			two reasons: (a) all tracing code will be removed automatically if 
//			_FTRACE isn't defined; and, (b) the trace functions aren't designed to 
//			be called directly.
//--------------------------------------------------------------------------------

// Option flags (used by FT_OPTIONS)

#define FTOPT_NO_VARS			0x00000001
#define FTOPT_NO_PRINTS			0x00000002
#define FTOPT_NO_LEAVES			0x00000004
#define FTOPT_NO_INDENTATION	0x00000008
#define FTOPT_NO_BLANK_LINES	0x00000010


#ifdef _FTRACE

	// executing a trace script

	#define FT_RUN_SCRIPT(fileName) \
				FTrace_RunScript(__FILE__, fileName)

	// turning tracing on and off

	#define FT_ON(writeToDebugWindow, logFileName, appendToLogFile) \
				FTrace_On(writeToDebugWindow, logFileName, appendToLogFile)
	#define FT_OFF() \
				FTrace_Off()
	#define FT_IS_ON() \
				FTrace_IsOn()

	// pausing and unpausing tracing

	#define FT_PAUSE() \
				FTrace_Pause()
	#define FT_RESUME() \
				FTrace_Resume()
	#define FT_IS_PAUSED() \
				FTrace_IsPaused()

	// setting options

	#define	FT_OPTIONS(dwOptions) \
				FTrace_Options(dwOptions)

	// including modules

	#define FT_INCLUDE_ALL_MODULES() \
				FTrace_IncludeAllModules()
	#define FT_INCLUDE_MODULES_FROM_FILE(fileName) \
				FTrace_IncludeModulesFromFile(fileName)
	#define FT_INCLUDE_MODULE(moduleName) \
				FTrace_IncludeModule(moduleName)
	#define FT_INCLUDE_THIS_MODULE() \
				FTrace_IncludeModule(__FILE__)
	#define FT_STOP_INCLUDING_MODULE(moduleName) \
				FTrace_StopIncludingModule(moduleName)
	#define FT_STOP_INCLUDING_THIS_MODULE() \
				FTrace_StopIncludingModule(__FILE__)
	#define FT_ALL_MODULES_ARE_INCLUDED() \
				FTrace_AllModulesAreIncluded()
	#define FT_MODULE_IS_INCLUDED(moduleName) \
				FTrace_ModuleIsIncluded(moduleName)
	#define FT_THIS_MODULE_IS_INCLUDED() \
				FTrace_ModuleIsIncluded(__FILE__)

	// excluding modules

	#define FT_EXCLUDE_ALL_MODULES() \
				FTrace_ExcludeAllModules()
	#define FT_EXCLUDE_MODULES_FROM_FILE(fileName) \
				FTrace_ExcludeModulesFromFile(fileName)
	#define FT_EXCLUDE_MODULE(moduleName) \
				FTrace_ExcludeModule(moduleName)
	#define FT_EXCLUDE_THIS_MODULE() \
				FTrace_ExcludeModule(__FILE__)
	#define FT_STOP_EXCLUDING_MODULE(moduleName) \
				FTrace_StopExcludingModule(moduleName)
	#define FT_STOP_EXCLUDING_THIS_MODULE() \
				FTrace_StopExcludingModule(__FILE__)
	#define FT_ALL_MODULES_ARE_EXCLUDED() \
				FTrace_AllModulesAreExcluded()
	#define FT_MODULE_IS_EXCLUDED(moduleName) \
				FTrace_ModuleIsExcluded(moduleName)
	#define FT_THIS_MODULE_IS_EXLCUDED() \
				FTrace_ModuleIsExcluded(__FILE__)

	// tracing function entry and exit points

	#define FT_ENTER(functionName, returnFormat) \
				FTrace_Enter(__FILE__, functionName, returnFormat)
	#define FT_ENTER_VOID(functionName) \
				FTrace_EnterVoid(__FILE__, functionName)
	#define FT_ENTER_OBJ(functionName, returnType) \
				FTrace_EnterObj(__FILE__, functionName, #returnType)

	#define FT_LEAVE(returnValue) \
				{ \
				/* Make sure that return value doesn't have any side effects since */ \
				/* it is evaluated twice -- not once -- by this macro. */ \
				/*ASSERT(returnValue == returnValue);*/ \
				FTrace_Leave(__FILE__, returnValue); \
				return (returnValue); \
				}
	#define	FT_LEAVE_VOID() \
				{ \
				FTrace_LeaveVoid(__FILE__); \
				return; \
				}
	#define FT_LEAVE_OBJ(returnValue) \
				{ \
				FTrace_LeaveObj(__FILE__); \
				return (returnValue); \
				}

	// printing variables and messages

	#define FT_VAR(var, format) \
				FTrace_PrintVar(__FILE__, #var, format, var)
	#define FT_BOOL(var) \
				FTrace_PrintVar(__FILE__, #var, "%s", (var) ? _T("true") : _T("false"))
	#define FT_STR(var, format) \
				if (var != NULL) \
					FTrace_PrintVar(__FILE__, #var, format, var); \
				else \
					FTrace_PrintVar(__FILE__, #var, "(null)")
	#define FT_PTR(ptr, format) \
				{ \
				/* Make sure that the ptr doesn't have any side effects since */ \
				/* it is evaluated twice -- not once -- by this macro. */ \
				/*ASSERT((ptr) == (ptr));*/ \
				if ((ptr) == NULL) \
					FTrace_Print(__FILE__, #ptr" = (null)"); \
				else \
					FTrace_PrintVar(__FILE__, "*"#ptr, format, *ptr); \
				}
	#define FT_PRINT(str) \
				FT_PRINT0(str)
	#define FT_PRINT0(str) \
				FTrace_Print(__FILE__, str)
	#define FT_PRINT1(format, arg) \
				FTrace_Print(__FILE__, format, arg)
	#define FT_PRINT2(format, arg1, arg2) \
				FTrace_Print(__FILE__, format, arg1, arg2)
	#define FT_PRINT3(format, arg1, arg2, arg3) \
				FTrace_Print(__FILE__, format, arg1, arg2, arg3)
	#define FT_PRINT4(format, arg1, arg2, arg3, arg4) \
				FTrace_Print(__FILE__, format, arg1, arg2, arg3, arg4)
	#define FT_PRINT5(format, arg1, arg2, arg3, arg4, arg5) \
				FTrace_Print(__FILE__, format, arg1, arg2, arg3, arg4, arg5)

#else

	// executing a trace script

	#define FT_RUN_SCRIPT(fileName)

	// turning tracing on and off

	#define FT_ON(writeToDebugWindow, logFileName, appendToLogFile)
	#define FT_OFF()		
	#define FT_IS_ON() \
				FALSE

	// pausing and unpausing tracing

	#define FT_PAUSE()		
	#define FT_RESUME()	
	#define FT_IS_PAUSED() \
				TRUE

	// setting options

	#define	FT_OPTIONS(dwOptions)

	// including modules

	#define FT_INCLUDE_THIS_MODULE();
	#define FT_INCLUDE_ALL_MODULES()
	#define FT_INCLUDE_MODULES_FROM_FILE(fileName)
	#define FT_INCLUDE_MODULE(moduleName)
	#define FT_STOP_INCLUDING_MODULE(moduleName)
	#define FT_MODULE_IS_INCLUDED(moduleName) \
				FALSE
	#define FT_ALL_MODULES_ARE_INCLUDED()

	// excluding modules

	#define FT_EXCLUDE_THIS_MODULE();
	#define FT_EXCLUDE_ALL_MODULES()
	#define FT_EXCLUDE_MODULES_FROM_FILE(fileName)
	#define FT_EXCLUDE_MODULE(moduleName)
	#define FT_STOP_EXCLUDING_MODULE(moduleName)
	#define FT_MODULE_IS_EXCLUDED(moduleName) \
				TRUE
	#define FT_ALL_MODULES_ARE_EXCLUDED()

	// tracing function entry and exit points

	#define FT_ENTER(functionName, returnFormat)
	#define FT_ENTER_VOID(functionName)
	#define FT_ENTER_OBJ(functionName, returnType)

	#define FT_LEAVE(returnValue) \
				return (returnValue)
	#define FT_LEAVE_OBJ(returnValue) \
				return (returnValue)
	#define FT_LEAVE_VOID() \
				return

	// printing variables and messages

	#define FT_VAR(var, format)
	#define FT_BOOL(var)
	#define FT_STR(var, format)
	#define FT_PTR(ptr, format)
	#define FT_PRINT(format)
	#define FT_PRINT0(format)
	#define FT_PRINT1(format, arg)
	#define FT_PRINT2(format, arg1, arg2)
	#define FT_PRINT3(format, arg1, arg2, arg3)
	#define FT_PRINT4(format, arg1, arg2, arg3, arg4)
	#define FT_PRINT5(format, arg1, arg2, arg3, arg4, arg5)

#endif // _FTRACE




//--------------------------------------------------------------------------------
// Trace Functions
// 
// Note: Don't use these functions directly -- use the macros (above) instead.
//--------------------------------------------------------------------------------

#define DllExport __declspec(dllexport)

// executing a trace script

DllExport void	FTrace_RunScript(
					const TCHAR* pModuleName,
					const TCHAR* pScriptFileName);

// turning tracing on and off

DllExport void	FTrace_On(
					BOOL writeToDebugWindow,
					const TCHAR* pLogFileName,
					BOOL appendToLogFile);
DllExport void 	FTrace_Off();
DllExport BOOL 	FTrace_IsOn();

// pausing and resuming tracing

DllExport void 	FTrace_Pause();
DllExport void	FTrace_Resume();
DllExport BOOL	FTrace_IsPaused();

// setting options

DllExport void	FTrace_Options(
					DWORD dwOptions);

// including modules

DllExport void	FTrace_IncludeAllModules();
DllExport void	FTrace_IncludeModulesFromFile(
					const TCHAR* pFileName);
DllExport void	FTrace_IncludeModule(
					const TCHAR* pModuleName);
DllExport void	FTrace_StopIncludingModule(
					const TCHAR* pModuleName);
DllExport BOOL	FTrace_AllModulesAreIncluded();
DllExport BOOL	FTrace_ModuleIsIncluded(
					const TCHAR* pModuleName);

// excluding modules

DllExport void	FTrace_ExcludeAllModules();
DllExport void	FTrace_ExcludeModulesFromFile(
					const TCHAR* pFileName);
DllExport void	FTrace_ExcludeModule(
					const TCHAR* pModuleName);
DllExport void	FTrace_StopExcludingModule(
					const TCHAR* pModuleName);
DllExport BOOL	FTrace_AllModulesAreExcluded();
DllExport BOOL	FTrace_ModuleIsExcluded(
					const TCHAR* pModuleName);

// tracing function entry and exit points

DllExport void	FTrace_Enter(
					const TCHAR* pModuleName,
					const TCHAR* pFunctionName,
					const TCHAR* pReturnFormat);
DllExport void	FTrace_EnterObj(
					const TCHAR* pModuleName,
					const TCHAR* pFunctionName,
					const TCHAR* pReturnFormat);
DllExport void	FTrace_EnterVoid(
					const TCHAR* pModuleName,
					const TCHAR* pFunctionName);

DllExport void	FTrace_Leave(
					const TCHAR* pModuleName,
					...);
DllExport void	FTrace_LeaveObj(
					const TCHAR* pModuleName);
DllExport void	FTrace_LeaveVoid(
					const TCHAR* pModuleName);

// printing variables and messages

DllExport void	FTrace_PrintVar(
					const TCHAR* pModuleName,
					const TCHAR* pVarName,
					const TCHAR* pFormat,
					...);
DllExport void	FTrace_Print(
					const TCHAR* pModuleName,
					const TCHAR* pFormat,
					...);



#endif // _FTRACE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\findstr.cpp ===
// findstr.cpp
//
// Implements FindStringByValue and FindStringByIndex.
//
// Important: This .cpp file assumes a zero-initializing global "new" operator.
//
// @doc MMCTL
//

#include "precomp.h"
#include "..\..\inc\ochelp.h"


/* @func char * | FindCharInString |

        Search a string to find a specific character.

@rdesc  Returns a pointer to the first occurence of <p chFind> in
        <p sz>.  Returns NULL if <p chFind> was not found.

@parm   const char * | sz | String to search.

@parm   char | chFind | Character to find.  May be '\\0' to search for
        the end of the string.

@comm   The search is case-sensitive.
*/
STDAPI_(char *) FindCharInString(const char *sz, char chFind)
{
    while (TRUE)
    {
        if (*sz == chFind)
            return (char*)sz;
        if (*sz++ == 0)
            return NULL;
    }
}


/* @func char * | FindCharInStringRev |

        Search a string to find the last occurrence of a specific character.

@rdesc  Returns a pointer to the last occurence of <p chFind> in
        <p sz>.  Returns NULL if <p chFind> was not found.

@parm   const char * | sz | String to search.  If NULL, the function returns NULL.

@parm   char | chFind | Character to find.  May be '\\0' to search for
        the end of the string.

@comm   The search is case-sensitive.
*/
STDAPI_(char *) FindCharInStringRev(const char *sz, char chFind)
{
        const char* pch;

        if (sz == NULL)
                return NULL;

        for (pch = sz + lstrlen(sz); pch >= sz; pch--)
    {
        if (*pch == chFind)
            return (char*)pch;
        }

        return NULL;
}



/* @func int | FindStringByValue |

        Look up string in a list of strings and return the index of the
        string (if found).

@rdesc  Returns the index of <p szFind> if <p szFind> is found in
        <p szList>.  The first string in <p szList> has index 0; the second 1,
        and so on.  Returns -1 if <p szFind> is not found.

@parm   const char * | szList | The list of strings to look up <p szFind> in.
        <p szList> consists of the concatenation of each string in the list,
        where each string is terminated by a newline character (e.g.
        "Foo\\nBar\\n").

@parm   const char * | szFind | The string to look up.

@comm   The search is case-insensitive.

@ex     The following line of code sets <p iString> to12. |

        iString = FindStringByValue("Foo\\nBar\\n", "bar");
*/
STDAPI_(int) FindStringByValue(const char *szList, const char *szFind)
{
    for (int iString = 0; ; iString++)
    {
        // make <pch> point to the next '\n' in <szList>
        const char *pch = FindCharInString(szList, '\n');
        if (pch == NULL)
            return -1; // <szFind> not found in <szList>

        // see if <szFind> matches the next string in <szList>
        char ach[200];
        lstrcpyn(ach, szList, (DWORD) (pch - szList + 1));
        if (lstrcmpi(ach, szFind) == 0)
            return iString;

        // go to the next string in <szList>
        szList = pch + 1;
    }
}


/* @func const char * | FindStringByIndex |

        Find a string with a given index in a list of strings.

@rdesc  Returns a pointer to string number <p iString> in <p szList> if found,
        or NULL if not found.  Note that the returned string is terminated
        by a newline character, not a null character -- user <p ppch> to
        copy the string (see the example below).

@parm   const char * | szList | The list of strings to look up <p iString> in.
        <p szList> consists of the concatenation of each string, where each
        string is terminated by a newline character (e.g. "Foo\\nBar\\n").

@parm   int | iString | The index of the string to find.  The first string in
        <p szList> has index 0; the second 1, and so on.

@ex     The following code stores "Bar" in <p ach>. |

        int cch;
        char ach[100];
        char *sz = FindStringByIndex("Foo\nBar\n", 1, &cch);
        if (sz != NULL)
            lstrcpyn(ach, sz, cch + 1);
*/
STDAPI_(const char *) FindStringByIndex(const char *szList, int iString,
    int *pcch)
{
    if (iString < 0)
        return NULL;

    while (TRUE)
    {
        // make <pch> point to the next '\n' in <szList>
        const char *pch = FindCharInString(szList, '\n');
        if (pch == NULL)
            return NULL; // <iString> not found in <szList>

        if (iString-- == 0)
        {
            // this is the string we're looking for
            *pcch = (DWORD) (pch - szList);
            return szList;
        }

        // go to the next string in <szList>
        szList = pch + 1;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\guid2tch.cpp ===
//===========================================================================
// Copyright (c) Microsoft Corporation 1996
//
// File:		guid2tch.cpp
//				
// Description:	This file contains the implementation of the function,
//				TCHARFromGUID.
//
// History:		04/30/96	a-swehba
//					Created.
//				08/27/96	a-swehba
//					TCHARFromGUID() -- pass #chars to StringFromGUID2 instead
//						of #bytes.
//
// @doc MMCTL
//===========================================================================

//---------------------------------------------------------------------------
// Dependencies
//---------------------------------------------------------------------------

#include "precomp.h"
#include "..\..\inc\mmctlg.h" // see comments in "mmctl.h"
#include "..\..\inc\ochelp.h"
#include "debug.h"




//---------------------------------------------------------------------------
// @func	TCHAR* | TCHARFromGUID |
//			Converts a GUID to a TCHAR-based string representation.
//
// @parm	REFGUID | guid |
//			[in] The GUID to convert.
//
// @parm	TCHAR* | pszGUID |
//			[out] The string form of the <p guid>.  Can't be NULL.
//
// @parm	int | cchMaxGUIDLen |
//			[in] <p szGUID> is, on entry, assumed to point to a buffer of
//			at least <p cchMaxGUIDLen> characters in length.  Must be
//			greater at least 39.
//
// @rdesc	Returns an alias to <p pszGUID>.
//
// @comm	Unlike <f StringFromGUID2> which always returns an OLECHAR form
//			of the GUID string, this function returns a wide or single-byte
//			form of the string depending on the build environment.
//
// @xref	<f CLSIDFromTCHAR>
//---------------------------------------------------------------------------

STDAPI_(TCHAR*) TCHARFromGUID(
REFGUID guid,
TCHAR* pszGUID,
int cchMaxGUIDLen)
{
	const int c_cchMaxGUIDLen = 50;
	OLECHAR aochGUID[c_cchMaxGUIDLen + 1];

	// Preconditions

	ASSERT(pszGUID != NULL);
	ASSERT(cchMaxGUIDLen >= 39);
	
	// Convert the guid to a UNICODE string.

	if (StringFromGUID2(guid, aochGUID, c_cchMaxGUIDLen) == 0)
	{
		return (NULL);
	}

	// Convert or copy the UNICODE string into a TCHAR form.

#ifdef UNICODE
	lstrcpy(pszGUID, aochGUID);
#else
	UNICODEToANSI(pszGUID, aochGUID, cchMaxGUIDLen);
#endif
	return (pszGUID);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\hgci.cpp ===
// hgci.cpp
//
// Implements HelpGetClassInfo.
//
// WARNING: HelpGetClassInfo makes assumptions about the script engine calling
// it.  Currently, this works with VBS, but the VBS group will not guarantee
// that the assumptions made by HelpGetClassInfo will remain valid in the
// future, so use at your own risk!  Consider using HelpGetClassInfoFromTypeLib
// instead.
//
// Important: This .cpp file assumes a zero-initializing global "new" operator.
//
// @doc MMCTL
//

#include "precomp.h"
#include "..\..\inc\mmctlg.h" // see comments in "mmctl.h"
#include "..\..\inc\ochelp.h"
#include "debug.h"


//////////////////////////////////////////////////////////////////////////////
// CType -- Implements ITypeInfo and ITypeLib
//

struct CType : ITypeInfo, ITypeLib
{
///// state
    int             m_iType;
    char *          m_szEventList;
    CLSID           m_clsid;

///// construction, destruction
    CType(int iType, REFCLSID rclsid, char *szEventList, HRESULT *phr);
    ~CType();

///// IUnknown implementation
protected:
    ULONG           m_cRef;         // reference count
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

///// ITypeInfo methods
protected:
    STDMETHODIMP GetTypeAttr(TYPEATTR **pptypeattr);
    STDMETHODIMP GetTypeComp(ITypeComp **pptcomp);
    STDMETHODIMP GetFuncDesc(UINT index, FUNCDESC **pppfuncdesc);
    STDMETHODIMP GetVarDesc(UINT index, VARDESC **ppvardesc);
    STDMETHODIMP GetNames(MEMBERID memid, BSTR *rgbstrNames, UINT cMaxNames,
        UINT *pcNames);
    STDMETHODIMP GetRefTypeOfImplType(UINT index, HREFTYPE *hpreftype);
    STDMETHODIMP GetImplTypeFlags(UINT index, INT *pimpltypeflags);
    STDMETHODIMP GetIDsOfNames(OLECHAR **rglpszNames, UINT cNames,
        MEMBERID *rgmemid);
    STDMETHODIMP Invoke(void *pvInstance, MEMBERID memid, WORD wFlags,
        DISPPARAMS *pdispparams, VARIANT *pvarResult, EXCEPINFO *pexcepinfo,
        UINT *puArgErr);
    STDMETHODIMP GetDocumentation(MEMBERID memid, BSTR *pbstrName,
        BSTR *pbstrDocString, DWORD *pdwHelpContext, BSTR *pbstrHelpFile);
    STDMETHODIMP GetDllEntry(MEMBERID memid, INVOKEKIND invkind,
        BSTR *pbstrDllName, BSTR *pbstrName, WORD *pwOrdinal);
    STDMETHODIMP GetRefTypeInfo(HREFTYPE hreftype, ITypeInfo **pptinfo);
    STDMETHODIMP AddressOfMember(MEMBERID memid, INVOKEKIND invkind,
        void **ppv);
    STDMETHODIMP CreateInstance(IUnknown *puncOuter, REFIID riid,
        void **ppvObj);
    STDMETHODIMP GetMops(MEMBERID memid, BSTR *pbstrMops);
    STDMETHODIMP GetContainingTypeLib(ITypeLib **pptlib, UINT *pindex);
    STDMETHODIMP_(void) ReleaseTypeAttr(TYPEATTR *ptypeattr);
    STDMETHODIMP_(void) ReleaseFuncDesc(FUNCDESC *pfuncdesc);
    STDMETHODIMP_(void) ReleaseVarDesc(VARDESC *pvardesc);

///// ITypeLib methods
protected:
    STDMETHODIMP_(UINT) GetTypeInfoCount(void);
    STDMETHODIMP GetTypeInfo(UINT index, ITypeInfo **ppitinfo);
    STDMETHODIMP GetTypeInfoType(UINT index, TYPEKIND *ptkind);
    STDMETHODIMP GetTypeInfoOfGuid(REFGUID guid, ITypeInfo **pptinfo);
    STDMETHODIMP GetLibAttr(TLIBATTR **pptlibattr);
    // STDMETHODIMP GetTypeComp(ITypeComp **pptcomp); // see ITypeInfo above
    STDMETHODIMP GetDocumentation(INT index, BSTR *pbstrName,
        BSTR *pbstrDocString, DWORD *pdwHelpContext, BSTR *pbstrHelpFile);
    STDMETHODIMP IsName(LPOLESTR szNameBuf, ULONG lHashVal, BOOL *pfName);
    STDMETHODIMP FindName(LPOLESTR szNameBuf, ULONG lHashVal,
        ITypeInfo **rgptinfo, MEMBERID *rgmemid, USHORT *pcFound);
    STDMETHODIMP_(void) ReleaseTLibAttr(TLIBATTR *ptlibattr);
};


//////////////////////////////////////////////////////////////////////////////
// CType Construction & Destruction
//


/* @func HRESULT | HelpGetClassInfo |

        Helps implement <om IProvideClassInfo.GetClassInfo>.  The
        implementation provides very limited class information -- just
        enough to allow firing events to VBS.  <f Warning\:> you should
        probably use <f HelpGetClassInfoFromTypeLib> instead.  See comments
        for more information.

@parm   LPTYPEINFO * | ppti | Where to return the pointer to the
        newly-allocated <i ITypeInfo> interface.  NULL is stored in
        *<p ppti> on error.

@parm   REFCLSID | rclsid | The class ID of the object that is implementing
        <i IProvideClassInfo>.

@parm   char * | szEventList | A list of events that can be fired by the
        parent object that is implementing <i IProvideClassInfo>.  The event
        names are concatenated, and each event name is terminated by a
        newline character.  The first member name is assigned DISPID value 0,
        the second 1, and so on.  For example, if <p szEventList> is
        "\\nFoo\\nBar\\n", then "Foo" is assigned DISPID value 1 and "Bar"
        is assigned 2 (because the first element is "").  (These DISPID values
        are passed to functions such as <om IConnectionPointHelper.FireEvent>
        to invoke events on objects such as VBS scripts connected to the
        parent object.)

@parm   DWORD | dwFlags | Currently unused.  Must be set to 0.

@comm   <b WARNING:> HelpGetClassInfo makes assumptions about the script
        engine calling it.  Currently, this works with VBS, but the VBS group
        will not guarantee that the assumptions made by HelpGetClassInfo will
        remain valid in the future, so use at your own risk!  Consider using
        <f HelpGetClassInfoFromTypeLib> instead.

@ex     In the following example, <c CMyControl> is a class that implements
        (among other things) <i IConnectionPointContainer> and
        <i IProvideClassInfo>.  The first part of this example shows how
        <om IProvideClassInfo.GetClassInfo> is implemented by <c CMyControl>.
        The second part of the example shows how an event is fired,
        assuming <p m_pconpt> is a <i IConnectionPointHelper> object.
        (It's not required that you use <o ConnectionPointHelper>, but
        it's helpful.) |

        // IDispatch IDs for events fired by this object, and the
        // corresponding method/property names (the order MUST MATCH)
        #define DISPID_EVENT_FOO        1
        #define DISPID_EVENT_BAR        2
        #define EVENT_NAMES "\n" \
                            "Foo\n" \
                            "Bar\n"

        STDMETHODIMP CMyControl::GetClassInfo(LPTYPEINFO FAR* ppTI)
        {
            return HelpGetClassInfo(ppTI, CLSID_CMyControl, EVENT_NAMES, 0);
        }

        // fire the "Bar" event (which has 3 parameters, which in BASIC
        // are of these types: Integer, String, Boolean)
        m_pconpt->FireEvent(DISPID_EVENT_BAR, VT_INT, 300 + i,
            VT_LPSTR, ach, VT_BOOL, TRUE, 0);
*/
STDAPI HelpGetClassInfo(LPTYPEINFO *ppti, REFCLSID rclsid, char *szEventList,
    DWORD dwFlags)
{
    TRACE("HelpGetClassInfo\n");
    HRESULT hr;
    if ((*ppti = (LPTYPEINFO) New CType(0, rclsid, szEventList, &hr)) == NULL)
        hr = E_OUTOFMEMORY;
    return hr;
}

CType::CType(int iType, REFCLSID rclsid, char *szEventList, HRESULT *phr)
{
    TRACE("CType(%d) 0x%08lx created\n", iType, this);

    // initialize IUnknown state
    m_cRef = 1;

    // other initialization
    m_iType = iType;
    m_szEventList = New char[lstrlen(szEventList) + 1];
    if (m_szEventList == NULL)
    {
        *phr = E_OUTOFMEMORY;
        return;
    }
    lstrcpy(m_szEventList, szEventList);
    m_clsid = rclsid;

    *phr = S_OK;
}

CType::~CType()
{
    TRACE("CType(%d) 0x%08lx destroyed\n", m_iType, this);
    if (m_szEventList != NULL)
        Delete [] m_szEventList;
}


//////////////////////////////////////////////////////////////////////////////
// IUnknown Implementation
//

STDMETHODIMP CType::QueryInterface(REFIID riid, LPVOID *ppv)
{
    *ppv = NULL;

#ifdef _DEBUG
    char ach[200];
    TRACE("CType(%d)::QI('%s')\n", m_iType, DebugIIDName(riid, ach));
#endif

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITypeInfo))
        *ppv = (IUnknown *) (ITypeInfo *) this;
    else
    if (IsEqualIID(riid, IID_ITypeLib))
        *ppv = (ITypeLib *) this;
    else
        return E_NOINTERFACE;

    ((IUnknown *) *ppv)->AddRef();
    return S_OK;
}

STDMETHODIMP_(ULONG) CType::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CType::Release()
{
    if (--m_cRef == 0L)
    {
        // free the object
        Delete this;
        return 0;
    }
    else
        return m_cRef;
}


//////////////////////////////////////////////////////////////////////////////
// ITypeInfo Implementation
//

STDMETHODIMP CType::GetTypeAttr(TYPEATTR **pptypeattr)
{
    TYPEATTR *      pta = NULL;     // type attributes

    TRACE("CType(%d): ITypeInfo::GetTypeAttr: ", m_iType);

    // set <pta> to an allocated TYPEATTR -- assume a zero-initializing 
    // new() operator
    if ((pta = (TYPEATTR *) TaskMemAlloc(sizeof(TYPEATTR))) == NULL)
        return E_OUTOFMEMORY;
    TRACE("0x%08lx\n", pta);

    switch (m_iType)
    {

    case 0:

        // initialize <*pta>
        pta->guid = m_clsid;
        // pta->lcid;
        // pta->dwReserved;
        pta->memidConstructor = MEMBERID_NIL;
        pta->memidDestructor = MEMBERID_NIL;
        // pta->lpstrSchema;
        // pta->cbSizeInstance;
        pta->typekind = TKIND_COCLASS;
        // pta->cFuncs;
        // pta->cVars;
        pta->cImplTypes = 2;
        // pta->cbSizeVft;
        pta->cbAlignment = 4;
        pta->wTypeFlags = TYPEFLAG_FCONTROL | TYPEFLAG_FCANCREATE;
        // pta->wMajorVerNum;
        // pta->wMinorVerNum;
        // pta->tdescAlias;
        // pta->idldescType;
        break;

    case 1:

        // initialize <*pta>
        pta->guid = IID_IDispatch;
        // pta->lcid;
        // pta->dwReserved;
        pta->memidConstructor = MEMBERID_NIL;
        pta->memidDestructor = MEMBERID_NIL;
        // pta->lpstrSchema;
        // pta->cbSizeInstance;
        pta->typekind = TKIND_DISPATCH;
        pta->cFuncs = 2;
        // pta->cVars;
        pta->cImplTypes = 1;
        // pta->cbSizeVft;
        pta->cbAlignment = 4;
        // pta->wTypeFlags;
        // pta->wMajorVerNum;
        // pta->wMinorVerNum;
        // pta->tdescAlias;
        // pta->idldescType;
        break;

    default:

        TRACE("UNKNOWN m_iType!\n");
        break;

    }

    *pptypeattr = pta;
    return S_OK;
}

STDMETHODIMP CType::GetTypeComp(ITypeComp **pptcomp)
{
    TRACE("CType(%d): ITypeInfo::GetTypeComp: E_NOTIMPL\n", m_iType);
    return E_NOTIMPL;
}

STDMETHODIMP CType::GetFuncDesc(UINT index, FUNCDESC **pppfuncdesc)
{
    TRACE("CType(%d): ITypeInfo::GetFuncDesc(%d)\n", m_iType, index);

    // point <pfd> to a newly-allocated structure describing
    // function number <index> (where index==i for the method with
    // DISPID i+1)
    FUNCDESC *pfd = New FUNCDESC;
    if (pfd == NULL)
        return E_OUTOFMEMORY;

    // initialize and return <pfd>
    pfd->memid = index + 1; // this is the DISPID of the event method
    pfd->funckind = FUNC_DISPATCH;
    pfd->invkind = INVOKE_FUNC;
    pfd->callconv = CC_STDCALL;
    *pppfuncdesc = pfd;

    return S_OK;
}

STDMETHODIMP CType::GetVarDesc(UINT index, VARDESC **ppvardesc)
{
    TRACE("CType(%d): ITypeInfo::GetVarDesc: E_NOTIMPL\n", m_iType);
    return E_NOTIMPL;
}

STDMETHODIMP CType::GetNames(MEMBERID memid, BSTR *rgbstrNames,
    UINT cMaxNames, UINT *pcNames)
{
    TRACE("CType(%d): ITypeInfo::GetNames(%d, %d)\n", m_iType,
        memid, cMaxNames);

    if (cMaxNames == 0)
    {
        *pcNames = 0;
        return S_OK;
    }

    // store the name of the event method <memid> in <aoch>
    int cch;
    OLECHAR aoch[_MAX_PATH];
    const char *sz;
    if ((sz = FindStringByIndex(m_szEventList, memid, &cch)) == NULL)
        return TYPE_E_ELEMENTNOTFOUND;
    MultiByteToWideChar(CP_ACP, 0, sz, cch, aoch,
        sizeof(aoch) / sizeof(*aoch) - 1);
    aoch[cch] = 0; // null-terminate

    // return the method name
    rgbstrNames[0] = SysAllocString(aoch);
    *pcNames = 1;

    return S_OK;
}

STDMETHODIMP CType::GetRefTypeOfImplType(UINT index, HREFTYPE *hpreftype)
{
    TRACE("CType(%d): ITypeInfo::GetRefTypeOfImplType(%d)\n", m_iType, index);
    *hpreftype = index; // could be any value I choose
    return S_OK;
}

STDMETHODIMP CType::GetImplTypeFlags(UINT index, INT *pimpltypeflags)
{
    TRACE("CType(%d): ITypeInfo::GetImplTypeFlags(%d)\n", m_iType, index);
    if (index == 0)
        *pimpltypeflags = IMPLTYPEFLAG_FDEFAULT;
    else
    if (index == 1)
        *pimpltypeflags = IMPLTYPEFLAG_FDEFAULT | IMPLTYPEFLAG_FSOURCE;
    else
        return E_INVALIDARG;

    return S_OK;
}

STDMETHODIMP CType::GetIDsOfNames(OLECHAR **rglpszNames, UINT cNames,
    MEMBERID *rgmemid)
{
    TRACE("CType(%d): ITypeInfo::GetIDsOfNames: E_NOTIMPL\n", m_iType);
    return E_NOTIMPL;
}

STDMETHODIMP CType::Invoke(void *pvInstance, MEMBERID memid, WORD wFlags,
    DISPPARAMS *pdispparams, VARIANT *pvarResult, EXCEPINFO *pexcepinfo,
    UINT *puArgErr)
{
    TRACE("CType(%d): ITypeInfo::Invoke: E_NOTIMPL\n", m_iType);
    return E_NOTIMPL;
}

STDMETHODIMP CType::GetDocumentation(MEMBERID memid, BSTR *pbstrName,
    BSTR *pbstrDocString, DWORD *pdwHelpContext, BSTR *pbstrHelpFile)
{
    TRACE("CType(%d): ITypeInfo::GetDocumentation: E_NOTIMPL\n", m_iType);
    return E_NOTIMPL;
}

STDMETHODIMP CType::GetDllEntry(MEMBERID memid, INVOKEKIND invkind,
    BSTR *pbstrDllName, BSTR *pbstrName, WORD *pwOrdinal)
{
    TRACE("CType(%d): ITypeInfo::GetDllEntry: E_NOTIMPL\n", m_iType);
    return E_NOTIMPL;
}

STDMETHODIMP CType::GetRefTypeInfo(HREFTYPE hreftype, ITypeInfo **pptinfo)
{
    TRACE("CType(%d): ITypeInfo::GetRefTypeInfo(%d)\n", m_iType);
    HRESULT hr;
    if ((*pptinfo = New CType(hreftype, m_clsid, m_szEventList, &hr)) == NULL)
        hr = E_OUTOFMEMORY;
    return hr;
}

STDMETHODIMP CType::AddressOfMember(MEMBERID memid, INVOKEKIND invkind,
    void **ppv)
{
    TRACE("CType(%d): ITypeInfo::AddressOfMember: E_NOTIMPL\n", m_iType);
    return E_NOTIMPL;
}

STDMETHODIMP CType::CreateInstance(IUnknown *puncOuter, REFIID riid,
    void **ppvObj)
{
    TRACE("CType(%d): ITypeInfo::CreateInstance: E_NOTIMPL\n", m_iType);
    return E_NOTIMPL;
}

STDMETHODIMP CType::GetMops(MEMBERID memid, BSTR *pbstrMops)
{
    TRACE("CType(%d): ITypeInfo::GetMops: E_NOTIMPL\n", m_iType);
    return E_NOTIMPL;
}

STDMETHODIMP CType::GetContainingTypeLib(ITypeLib **pptlib, UINT *pindex)
{
    TRACE("CType(%d): ITypeInfo::GetContainingTypeLib\n", m_iType);
    *pptlib = (ITypeLib *) this;
    (*pptlib)->AddRef();
    if (pindex != NULL)
        *pindex = m_iType;
    return S_OK;
}

STDMETHODIMP_(void) CType::ReleaseTypeAttr(TYPEATTR *ptypeattr)
{
    TRACE("CType(%d): ITypeInfo::ReleaseTypeAttr(0x%08lx)\n", m_iType,
        ptypeattr);
    TaskMemFree(ptypeattr);
}

STDMETHODIMP_(void) CType::ReleaseFuncDesc(FUNCDESC *pfuncdesc)
{
    TRACE("CType(%d): ITypeInfo::ReleaseFuncDesc\n", m_iType);
    Delete pfuncdesc;
}

STDMETHODIMP_(void) CType::ReleaseVarDesc(VARDESC *pvardesc)
{
    TRACE("CType(%d): ITypeInfo::ReleaseVarDesc: E_NOTIMPL\n", m_iType);
}

//////////////////////////////////////////////////////////////////////////////
// ITypeLib Implementation
//

STDMETHODIMP_(UINT) CType::GetTypeInfoCount(void)
{
    TRACE("CType(%d): ITypeLib::GetTypeInfoCount: E_NOTIMPL\n", m_iType);
    return 0;
}

STDMETHODIMP CType::GetTypeInfo(UINT index, ITypeInfo **ppitinfo)
{
    TRACE("CType(%d): ITypeLib::GetTypeInfo: E_NOTIMPL\n", m_iType);
    return E_NOTIMPL;
}

STDMETHODIMP CType::GetTypeInfoType(UINT index, TYPEKIND *ptkind)
{
    TRACE("CType(%d): ITypeLib::GetTypeInfoType(%d)\n", m_iType, index);
    if (index == 0)
    {
        *ptkind = TKIND_DISPATCH;
        return S_OK;
    }
    else
        return TYPE_E_ELEMENTNOTFOUND;
}

STDMETHODIMP CType::GetTypeInfoOfGuid(REFGUID guid, ITypeInfo **pptinfo)
{
    TRACE("CType(%d): ITypeLib::GetTypeInfoOfGuid: E_NOTIMPL\n", m_iType);
    return E_NOTIMPL;
}

STDMETHODIMP CType::GetLibAttr(TLIBATTR **pptlibattr)
{
    TRACE("CType(%d): ITypeLib::GetLibAttr: E_NOTIMPL\n", m_iType);
    return E_NOTIMPL;
}

STDMETHODIMP CType::GetDocumentation(INT index, BSTR *pbstrName,
    BSTR *pbstrDocString, DWORD *pdwHelpContext, BSTR *pbstrHelpFile)
{
    TRACE("CType(%d): ITypeLib::GetDocumentation: E_NOTIMPL\n", m_iType);
    return E_NOTIMPL;
}

STDMETHODIMP CType::IsName(LPOLESTR szNameBuf, ULONG lHashVal,
    BOOL *pfName)
{
    TRACE("CType(%d): ITypeLib::IsName: E_NOTIMPL\n", m_iType);
    return E_NOTIMPL;
}

STDMETHODIMP CType::FindName(LPOLESTR szNameBuf, ULONG lHashVal,
    ITypeInfo **rgptinfo, MEMBERID *rgmemid, USHORT *pcFound)
{
    TRACE("CType(%d): ITypeLib::FindName: E_NOTIMPL\n", m_iType);
    return E_NOTIMPL;
}

STDMETHODIMP_(void) CType::ReleaseTLibAttr(TLIBATTR *ptlibattr)
{
    TRACE("CType(%d): ITypeLib::ReleaseTLibAttr: E_NOTIMPL\n", m_iType);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\lib.cpp ===
// StaticLib.cpp
//
// Implements functions for initializing and uninitializing the static version
// of OCHelp.
//
// Important: This .cpp file assumes a zero-initializing global "new" operator.
//
// @doc MMCTL
//

#include "precomp.h"
#include "..\..\inc\ochelp.h"
#include "Globals.h"
#include "debug.h"

void CleanupUrlmonStubs();	// see urlmon.cpp

/*----------------------------------------------------------------------------
	@func BOOL | InitializeStaticOCHelp |
	
	Initialize the static version of OCHelp.

	@comm
	If your control links to the static version of the OCHelp library, you must
	call this function before you call any other OCHelp APIs.  The ideal place
	to do this is within your control's _DllMainCRTStartup implementation.  You
	must also call <f UninitializeStaticOCHelp> when you're done with the
	library.

	@rvalue TRUE | Success.
	@rvalue FALSE | Failure: DLL will not load.

	This isn't required when using the DLL version of OCHelp.

  ----------------------------------------------------------------------------*/

STDAPI_(BOOL)
InitializeStaticOCHelp
(
	HINSTANCE hInstance  // @parm  Application instance.
)
{
	ASSERT(hInstance != NULL);

	g_hinst = hInstance;

	::InitializeCriticalSection(&g_criticalSection);

	return TRUE;
}


/*----------------------------------------------------------------------------
	@func void | UninitializeStaticOCHelp |
	
	Uninitialize the static version of OCHelp.

	@comm
	If your control links to the static version of the OCHelp library, you must
	call this when your control is done using the library.  The ideal place to
	do this is within your control's _DllMainCRTStartup implementation.  You
	must also call <f InitializeStaticOCHelp> before you use the library.

	Do not call any OCHelp APIs after calling this function.

	This isn't required when using the DLL version of OCHelp.

  ----------------------------------------------------------------------------*/

STDAPI_(void)
UninitializeStaticOCHelp()
{
	ASSERT(g_hinst != NULL);

#ifndef _M_ALPHA
	::CleanupUrlmonStubs();
#endif
	::HelpMemDetectLeaks();
	::DeleteCriticalSection(&g_criticalSection);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\helpmem.cpp ===
// helpmem.cpp
//
// Implements HelpMemAlloc, HelpMemFree, and HelpMemDetectLeaks.
// Includes documentation for the macros TaskMemAlloc, TaskMemFree,
// HelpNew, and HelpDelete.
//
// @doc MMCTL
//

#include "precomp.h"
#include "..\..\inc\ochelp.h"
#include "Globals.h"
#include "debug.h"


#define HM_LEAKFIND 0 // 1 to enable memory leak finding


// EricLe: Chris Guzak says we shouldn't be calling OutputDebugString in a
// release build, and we never used this feature anyway, so I disabled it.
// #define HM_ODS // enable OutputDebugString in a release build


// globals
static ULONG _g_cbUnfreedBytes;   
    // the number of unfreed bytes allocated with HM_LEAKDETECT
static ULONG _g_cUnfreedBlocks;    
    // the number of unfreed blocks allocated with HM_LEAKDETECT

#ifdef _DEBUG
static ULONG _g_cCallsToHelpMemAlloc;
    // the number of calls made to HelpMemAlloc() since the last call to
    // HelpMemSetFailureMode()
static ULONG _g_ulFailureParam;
static DWORD _g_dwFailureMode;
    // these values are used to simulate memory allocation failures
#endif // _DEBUG




/* @func LPVOID | HelpMemAlloc |

        Allocates memory using either <f GlobalAlloc> or the task memory
        allocator retrieved using <f CoGetMalloc>.  Optionally
        zero-initializes the memory.  Optionally performs simple memory leak
        detection.

@rdesc  Returns a pointer to the allocated block of memory.  Returns NULL on
        error.

@parm   DWORD | dwFlags | May contain the following flags:

        @flag   HM_TASKMEM | The memory is allocated using <om IMalloc.Alloc>
                (using the task memory allocator retrieved from
                <f CoGetMalloc>).  If HM_TASKMEM is not specified, then
                <f GlobalAlloc> is used to allocate the memory.

        @flag   HM_ZEROINIT | The memory is zero-initialized.

        @flag   HM_LEAKDETECT | This DLL will keep track of the allocated
                memory block using a simple leak detection mechanism.
                <b Important>: If HM_LEAKDETECT is specified, then the
                returned memory pointer cannot be freed directly by
                <f GlobalFree> or <om IMalloc.Free> -- it must be freed
                using <f HelpMemFree>.

@parm   ULONG | cb | The number of bytes of memory to allocate.

@comm   This function allocates a block of <p cb> bytes of memory, using
        the allocation function (and optional zero-initialization) specified
        by <p dwFlags>.

        If HM_LEAKDETECT is specified, then an extra few bytes is allocated
        to keep track of leak detection information, and the returned pointer
        actually points several bytes beyond the beginning of the memory block.
        Therefore, <f HelpMemFree> must be called to free the block of memory.

        If HM_LEAKDETECT is <b not> specified, then <f GlobalFree> or
        <om IMalloc.Free> (depending on <p dwFlags>) can be called directly
        to free the block of memory.  (<f HelpMemFree> may also be used to
        free the memory block).

        If <f HelpMemFree> is called, the HM_TASKMEM and HM_LEAKDETECT flags
        (if any) specified for <f HelpMemAlloc> must also be passed to
        <f HelpMemFree>.

        Leak detection occurs automatically when this DLL unloads in the
		debug build: if an unfreed block is detected, a message box is
		displayed.
*/
STDAPI_(LPVOID) HelpMemAlloc(DWORD dwFlags, ULONG cb)
{
    IMalloc *       pmalloc;        // task allocator object
    ULONG           cbAlloc;        // bytes to actually allocate
    LPVOID          pv;             // allocated memory block

#if HM_LEAKFIND
        {
            EnterCriticalSection(&g_criticalSection);
            static int iAlloc = 0;
            TRACE("++HelpMem(%d) %d\n", ++iAlloc, cb);
            LeaveCriticalSection(&g_criticalSection);
        }
#endif

    // Possibly simulate an allocation failure.
#ifdef _DEBUG
    {
        BOOL fFail = FALSE;
        EnterCriticalSection(&g_criticalSection);

        // Count the call to HelpMemAlloc().
        _g_cCallsToHelpMemAlloc++;

        // Simulate a failure if the conditions are right.
        if (_g_dwFailureMode & HM_FAILAFTER)
        {
            fFail = (_g_cCallsToHelpMemAlloc > _g_ulFailureParam);
        }
        else if (_g_dwFailureMode & HM_FAILUNTIL)
        {
            fFail = (_g_cCallsToHelpMemAlloc <= _g_ulFailureParam);
        }
        else if (_g_dwFailureMode & HM_FAILEVERY)
        {
            fFail = ((_g_cCallsToHelpMemAlloc % _g_ulFailureParam) == 0);
        }
/*
        else if (_g_dwFailureMode & HM_FAILRANDOMLY)
        {
        }
*/
        LeaveCriticalSection(&g_criticalSection);
        if (fFail)
        {
            TRACE("HelpMemAlloc: simulated failure\n");
            return (NULL);
        }
    }
#endif

    // allocate <cb> bytes (plus 4 additional bytes if HM_LEAKDETECT is
    // specified, to store the length of the block for leak detection
    // purposes); point <pv> to the allocated block
    cbAlloc = cb + ((dwFlags & HM_LEAKDETECT) ? sizeof(ULONG) : 0);

    // set <pv> to the allocate memory block
    if (dwFlags & HM_TASKMEM)
    {
        // allocate using the tasks's IMalloc allocator
        if (FAILED(CoGetMalloc(1, &pmalloc)))
            return NULL;
        pv = pmalloc->Alloc(cbAlloc);
        pmalloc->Release();
    }
    else
    {
        // allocate using GlobalAlloc() (the following is copied from
        // <windowsx.h>)
        HGLOBAL h = GlobalAlloc(GMEM_MOVEABLE, cbAlloc);
        pv = GlobalLock(h);
    }

    if (pv != NULL)
    {
        // if HM_LEAKDETECT is specified, store <cb> at the beginning of the
        // block of memory and return a pointer to the byte beyond where <cb>
        // is stored, and keep track of memory allocated and not yet freed
        if (dwFlags & HM_LEAKDETECT)
        {
            *((ULONG *) pv) = cb;
            pv = (LPVOID) (((ULONG *) pv) + 1);
            EnterCriticalSection(&g_criticalSection);
            _g_cbUnfreedBytes += cb;
            _g_cUnfreedBlocks++;
            LeaveCriticalSection(&g_criticalSection);
        }

        // if HM_ZEROINIT is specified, zero-initialize the rest of the
        // memory block
        if (pv != NULL)
            memset(pv, 0, cb);
    }

    return pv;
}




/* @func void | HelpMemFree |

        Frees a block of memory previously allocated using <f HelpMemAlloc>.

@parm   DWORD | dwFlags | May contain the following flags:

        @flag   HM_TASKMEM | The memory was allocated using <om IMalloc.Alloc>
                (using the task memory allocator retrieved from
                <f CoGetMalloc>).  If HM_TASKMEM is not specified, then it
                is assumed that <f GlobalAlloc> is used to allocate the memory.

        @flag   HM_LEAKDETECT | The memory was allocated using <f HelpMemAlloc>
                with the HM_LEAKDETECT flag specified.

@parm   LPVOID | pv | A pointer to the block of memory that was previously
        allocated using <f HelpMemAlloc> or a NULL pointer.

@comm   The HM_TASKMEM and HM_LEAKDETECT flags (if any) specified for
        <f HelpMemAlloc> must also be passed to <f HelpMemFree>.
*/
STDAPI_(void) HelpMemFree(DWORD dwFlags, LPVOID pv)
{
    IMalloc *       pmalloc;        // task allocator object

    if (pv == NULL)
        return;

    // if HM_LEAKDETECT is specified, retrieve the byte count stored
    // just before <pv>, and move <pv> to the true beginning of the block
    // (the start of the byte count), and keep track of memory allocated
    // and not yet freed
    if (dwFlags & HM_LEAKDETECT)
    {
        // keep track of memory allocated and not yet freed
        pv = (LPVOID) (((ULONG *) pv) - 1);
        ULONG cb = *((ULONG *) pv);

#if HM_LEAKFIND
            TRACE("++HelpMem %d\n", -(int) cb);
#endif

        EnterCriticalSection(&g_criticalSection);
        _g_cbUnfreedBytes -= cb;
        _g_cUnfreedBlocks--;
        LeaveCriticalSection(&g_criticalSection);
    }

    if (dwFlags & HM_TASKMEM)
    {
        // memory was allocated using the tasks's IMalloc allocator
        if (FAILED(CoGetMalloc(1, &pmalloc)))
            return;
        pmalloc->Free(pv);
        pmalloc->Release();
    }
    else
    {
        // memory was allocated using GlobalAlloc() (the following is copied
        // from <windowsx.h>)
        HGLOBAL h = (HGLOBAL) GlobalHandle(pv);
        GlobalUnlock(h);
        GlobalFree(h);
    }
}




/* @func void | HelpMemSetFailureMode |

        Sets failure conditions for the memory allocator.  This can be used
        to simulate low-memory conditions and test a system's ability to 
        detect and/or handle these conditions.

@parm   LONG | lParam | 
        Argument used in conjunction with <p dwFlags>.

@parm   DWORD | dwFlags | 
        May contain the following flags (all of which are mutually exclusive):

        @flag   HM_FAILNEVER |
                Never fail memory allocation unless memory is truly exhausted.
                <p ulParam> is ignored.  This is the default failure mode for
                the memory allocator.

        @flag   HM_FAILAFTER |
                Begin failing memory allocation after <p ulParam> allocations have
                been attempted.  If, for example, <p ulParam> is 100, the next
                100 calls to <f HelpMemAlloc> will succeed (memory availability
                permitting), but the 101-st, 102-nd, etc. calls will fail.

        @flag   HM_FAILUNTIL |
                Start failing memory allocation immediately and continue until
                <p ulParam> allocations have been attempted.  If, for example,
                <p ulParam> is 100, the next 100 calls to <f HelpMemAlloc> will fail,
                but the 101-st, 102-nd, etc. calls will succeed (memory availability
                permitting).

        @flag   HM_FAILEVERY |
                Fail every <p ulParam>-th attempted memory allocation.  If,
                for example, <p ulParam> is 3, every third call to <f HelpMemAlloc>
                will fail.

        @flag   HM_FAILRANDOMLY |
                Simulate random memory allocation failure.  (<p ulParam> mod 100) 
                indicates the percentage chance that a given call to 
                <f HelpMemAlloc> will fail.  (Note: This flag currently has the
                same effect as HM_FAILNEVER.)

@comm   This function is only available in DEBUG builds of <l OCHelp>.  (There
        is a stub implementation that does nothing in the release builds.)
        Also, this function resets the allocation counter.  So, <p ulParam> is
        counted relative to the last call to this function.
*/
STDAPI_(void) HelpMemSetFailureMode(ULONG ulParam, DWORD dwFlags)
{   
#ifdef _DEBUG
    EnterCriticalSection(&g_criticalSection);

    // Reset the allocation counter.
    _g_cCallsToHelpMemAlloc = 0;

    // Save the failure settings.
    _g_ulFailureParam = ulParam;
    _g_dwFailureMode = dwFlags;

    LeaveCriticalSection(&g_criticalSection);
#endif // _DEBUG
}




// HelpMemDetectLeaks()
//
// (Called when DLL exits.)  Displays a message box (in debug build)
#ifdef HM_ODS
// or an OutputDebugString() message (in a release build)
#endif
// if any memory leaks were detected.
//
STDAPI_(void) HelpMemDetectLeaks()
{
    char ach[200];

#ifdef HM_ODS
    OutputDebugString("HelpMemDetectLeaks: ");
#endif

    // see if any allocated memory was not yet freed
    EnterCriticalSection(&g_criticalSection);
    if ((_g_cUnfreedBlocks != 0) || (_g_cbUnfreedBytes != 0))
    {
        // warn the user
        wsprintf(ach, "Detected memory leaks: %d unreleased blocks,"
            " %d unreleased bytes\n", _g_cUnfreedBlocks, _g_cbUnfreedBytes);
        LeaveCriticalSection(&g_criticalSection);
#ifdef HM_ODS
        OutputDebugString(ach);
#endif
#ifdef _DEBUG
        MessageBox(NULL, ach, "OCHelp HelpMemDetectLeaks",
            MB_ICONEXCLAMATION | MB_OK);
#endif
    }
    else
    {
        LeaveCriticalSection(&g_criticalSection);
#ifdef HM_ODS
        OutputDebugString("(none detected)");
#endif
    }

#ifdef HM_ODS
    OutputDebugString("\n");
#endif
}




/* @func LPVOID | TaskMemAlloc |

        Allocates memory using the task memory allocator (see <f CoGetMalloc>).
        This is simply a macro that calls <f HelpMemAlloc> with specific flags.

@rdesc  Returns a pointer to the allocated block of memory.  Returns NULL on
        error.

@parm   ULONG | cb | The number of bytes of memory to allocate.

*/


/* @func void | TaskMemFree |

        Frees a block of memory previously allocated using <f TaskMemAlloc>.
        This is simply a macro that calls <f HelpMemFree> with specific flags.

@parm   LPVOID | pv | A pointer to the block of memory to allocate.

*/


/* @func void * | HelpNew |

        Helps implement a version of the "new" operator that doesn't
        use the C runtime.  Zero-initializes the allocated memory.
        This is simply a macro that calls <f HelpMemAlloc> with specific flags.

@rdesc  Returns a pointer to the allocated block of memory.  Returns NULL on
        error.

@parm   size_t | cb | The number of bytes to allocate.

@ex     The following example shows how to use <f HelpNew> and <f HelpDelete>
        to define default "new" and "delete" operators. |

        void * operator new(size_t cb)
        {
            return HelpNew(cb);
        }

        void operator delete(void *pv)
        {
            HelpDelete(pv);
        }
*/


/* @func void | HelpDelete |

        Frees memory allocated by <f HelpNew>.  This is simply a macro that
        calls <f HelpMemFree> with specific flags.

@parm   void * | pv | The pointer to the memory to free.

@comm   See <f HelpNew> for more information.

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\msgwnd.cpp ===
// msgwnd.cpp
//
// Implements the hidden message-passing window.
//
// Important: This .cpp file assumes a zero-initializing global "new" operator.
//
// @doc MMCTL
//

#include "precomp.h"
#include "..\..\inc\ochelp.h"
#include "Globals.h"
#include "debug.h"


// byte offsets of extra window long values
#define WL_MSGWNDCALLBACK   (0 * sizeof(LONG_PTR))  // contains a MsgWndCallback *
#define WL_LPARAM           (1 * sizeof(LONG_PTR))  // contains a LPARAM
#define WL_TIMERCALLBACK    (2 * sizeof(LONG_PTR))  // contains a MsgWndCallback *
#define WL_LPARAMTIMER      (3 * sizeof(LONG_PTR))  // LPARAM for timer functions

#define _WL_COUNT           4                   // count of window longs


// MsgWndProc
//
// This is the window procedure for the hidden message-passing window.
//
LRESULT CALLBACK MsgWndProc(HWND hwnd, UINT uiMsg, WPARAM wParam,
    LPARAM lParam)
{
    if (uiMsg == WM_COMMAND)
    {
        TRACE("MsgWnd 0x%x: WM_COMMAND %d\n", hwnd, LOWORD(wParam));

        // the callback function pointer and parameter have been temporarily
        // stored in window longs -- get them
        MsgWndCallback *pprocCaller = (MsgWndCallback *)
            GetWindowLongPtr(hwnd, WL_MSGWNDCALLBACK);
        LPARAM lParamCaller = (LPARAM) GetWindowLongPtr(hwnd, WL_LPARAM);

        ASSERT(pprocCaller != NULL);
                if (pprocCaller == NULL)
                        return 0;
        pprocCaller(uiMsg, wParam, lParamCaller);

        // clear the window longs
        SetWindowLongPtr(hwnd, WL_MSGWNDCALLBACK, (LONG_PTR) NULL);
        SetWindowLongPtr(hwnd, WL_LPARAM, (LONG_PTR) NULL);
        return 0;
    }

        if (uiMsg == WM_TIMER)
        {
        // TRACE("MsgWnd 0x%x: WM_TIMER\n", hwnd);

        // the callback function pointer has been stored in a window long,
                // as has the caller-supplied LPARAM (which is a parameter to pass
                // back to the callback; this LPARAM is typically used to store a
                // class "this" pointer)
        MsgWndCallback *pprocCaller = (MsgWndCallback *)
            GetWindowLongPtr(hwnd, WL_TIMERCALLBACK);
        LPARAM lParamCaller = (LPARAM) GetWindowLongPtr(hwnd, WL_LPARAMTIMER);
        ASSERT(pprocCaller != NULL);
                if (pprocCaller == NULL)
                        return 0;
        pprocCaller(WM_TIMER, wParam, lParamCaller);
                return 0;
        }
        else
    if ((uiMsg >= WM_USER) && (uiMsg <= 0x7FFF))
    {
        // TRACE("MsgWnd 0x%x: WM_USER+%d\n", hwnd, uiMsg - WM_USER);
        ((MsgWndCallback *) wParam)(uiMsg, 0, lParam);
        return 0;
    }

    switch (uiMsg)
    {
    case WM_CREATE:
        TRACE("MsgWnd 0x%x: WM_CREATE\n", hwnd);
        break;
    case WM_DESTROY:
        TRACE("MsgWnd 0x%x: WM_DESTROY\n", hwnd);
        break;
    }

    return DefWindowProc(hwnd, uiMsg, wParam, lParam);
}


/* @func HWND | MsgWndCreate |

        Creates the hidden message-passing window (if it doesn't exist).
        This window is used by <f MsgWndSendToCallback>,
        <f MsgWndPostToCallback>, and <f MsgWndTrackPopupMenuEx>.

@rdesc  Returns the handle of the message-passing window.  Returns NULL on
        error.

@comm   You should call <f MsgWndCreate> in the constructor of your
        control to ensure that the window gets created on the same thread
        as the thread which created your control.

        You should call <f MsgWndDestroy> in the destructor of your control.
*/
STDAPI_(HWND) MsgWndCreate()
{
    HWND            hwnd = NULL;    // hidden message-passing window

    // create the hidden message-passing window <hwnd>
    WNDCLASS wc;
    memset(&wc, 0, sizeof(wc));
    wc.lpfnWndProc = MsgWndProc; 
    wc.cbWndExtra = _WL_COUNT * sizeof(LONG_PTR);
    wc.hInstance = g_hinst; 
    wc.lpszClassName = "__EricLeMsgWnd__";
    RegisterClass(&wc); // okay if this fails (multiple registration)
    hwnd = CreateWindow(wc.lpszClassName, "", WS_POPUP,
        0, 0, 0, 0, NULL, NULL, g_hinst, NULL);
    if (hwnd != NULL)
    {
        // zero-initialize the window longs
        SetWindowLongPtr(hwnd, WL_MSGWNDCALLBACK, (LONG_PTR) NULL);
        SetWindowLongPtr(hwnd, WL_LPARAM, (LONG_PTR) NULL);
    }

    return hwnd;
}


/* @func LRESULT | MsgWndDestroy |

        Destroys a hidden message-passing window that was previously created
        by calling <f MsgWndCreate>.  If the MWD_DISPATCHALL flag is included in
        dwFlags, all the window's pending messages are dispatched before the window
        is destroyed.

@parm   HWND | hwnd | The hidden message-passing window which was created
        by calling <f MsgWndCreate> (usually in the constructor of the
        control, to ensure that the window is created in the same thread
        that created the control).

@parm   DWORD | dwFlags | May contain the following flag:

        @flag   MWD_DISPATCHALL | Dispatch all the window's messages before
                                                                   destroying the window.  By default, any
                                                                   messages left in the queue are lost.

@parm   <f MsgWndDestroy> is typically called in the destructor of a control.

        <f MsgWndDestroy> should only be called in the thread that called
        <f MsgWndCreate>.
*/
STDAPI_(void) MsgWndDestroy(HWND hwnd, DWORD dwFlags)
{
    TRACE("MsgWndDestroy(0x%x)\n", hwnd);
        ASSERT(0 == dwFlags || MWD_DISPATCHALL == dwFlags);

        if (dwFlags & MWD_DISPATCHALL)
        {
                MSG msg;
                while (PeekMessage(&msg, hwnd, 0, (UINT) -1, PM_REMOVE))
                {
                // TRACE("MsgWnd 0x%x: dispatching message %u\n", hwnd, msg.message);
                DispatchMessage(&msg);
                }
        }

    DestroyWindow(hwnd);
}


/* @func LRESULT | MsgWndSendToCallback |

        Sends a message to the control's hidden message-passing window
        (typically created by calling <f MsgWndCreate> in the control's
        constructor).  When the window receives the message, it calls a given
        callback function.  This can be used to safely pass information
        between threads.

@rdesc  Returns the value returned by <f SendMessage> (-1 on error).

@parm   HWND | hwnd | The hidden message-passing window which was created
        by calling <f MsgWndCreate> (usually in the constructor of the
        control, to ensure that the window is created in the same thread
        that created the control).

@parm   MsgWndCallback * | pproc | The callback function that is to receive
        the message.  This function will be called on whatever thread
        calls <f DispatchMessage>.  The <p wParam> parameter of this function
        should be ignored by the callback function.

@parm   UINT | uiMsg | A message number to pass to <p pproc>.  This is a
        window message number, so it must be in the range WM_USER through
        0x7FFF.

@parm   LPARAM | lParam | A parameter to pass to <p pproc>.

@comm   Message <p uiMsg> is sended (via <f SendMessage>) to the hidden
        message-passing window <p hwnd>.  When the window receives the
        message, it calls <p pproc>(<p uiMsg>, <p lParam>).

        Note that the calling thread blocks until the message is processed
        by the receiving thread.

@ex     The following example declares a callback function and calls it
        via <f MsgWndSendToCallback>.  Note that <p wParam> is for internal
        use by <f MsgWndPostToCallback> and should be ignored by the
        callback function.  |

        void CALLBACK MyMsgWndCallback(UINT uiMsg, WPARAM wParam, LPARAM lParam)
        {
            TRACE("got the callback: uiMsg=%u, lParam=%d\n", uiMsg, lParam);
        }

        ...
        MsgWndSendToCallback(MyMsgWndCallback, WM_USER, 42);
*/
STDAPI_(LRESULT) MsgWndSendToCallback(HWND hwnd, MsgWndCallback *pproc,
    UINT uiMsg, LPARAM lParam)
{
    ASSERT(hwnd != NULL); // if this fails, see new MsgWnd* documentation
    ASSERT(IsWindow(hwnd)); // if this fails, see new MsgWnd* documentation
    return SendMessage(hwnd, uiMsg, (WPARAM) pproc, lParam);
}


/* @func LRESULT | MsgWndPostToCallback |

        Posts a message to the control's hidden message-passing window
        (typically created by calling <f MsgWndCreate> in the control's
        constructor).  When the window receives the message, it calls a given
        callback function.  This can be used to safely pass information
        between threads.

@rdesc  Returns the value returned by <f PostMessage> (-1 on error).

@parm   HWND | hwnd | The hidden message-passing window which was created
        by calling <f MsgWndCreate> (usually in the constructor of the
        control, to ensure that the window is created in the same thread
        that created the control).

@parm   MsgWndCallback * | pproc | The callback function that is to receive
        the message.  This function will be called on whatever thread
        calls <f DispatchMessage>.  The <p wParam> parameter of this function
        should be ignored by the callback function.

@parm   UINT | uiMsg | A message number to pass to <p pproc>.  This is a
        window message number, so it must be in the range WM_USER through
        0x7FFF.

@parm   LPARAM | lParam | A parameter to pass to <p pproc>.

@comm   Message <p uiMsg> is posted (via <f PostMessage>) to the hidden
        message-passing window <p hwnd>.  When the window receives the
        message, it calls <p pproc>(<p uiMsg>, <p lParam>).

@ex     The following example declares a callback function and calls it
        via <f MsgWndPostToCallback>.  Note that <p wParam> is for internal
        use by <f MsgWndPostToCallback> and should be ignored by the
        callback function. |

        void CALLBACK MyMsgWndCallback(UINT uiMsg, WPARAM wParam, LPARAM lParam)
        {
            TRACE("got the callback: uiMsg=%u, lParam=%d\n", uiMsg, lParam);
        }

        ...
        MsgWndPostToCallback(MyMsgWndCallback, WM_USER, 42);
*/
STDAPI_(LRESULT) MsgWndPostToCallback(HWND hwnd, MsgWndCallback *pproc,
    UINT uiMsg, LPARAM lParam)
{
    ASSERT(hwnd != NULL); // if this fails, see new MsgWnd* documentation
    ASSERT(IsWindow(hwnd)); // if this fails, see new MsgWnd* documentation
    return PostMessage(hwnd, uiMsg, (WPARAM) pproc, lParam);
}


/* @func LRESULT | MsgWndTrackPopupMenuEx |

        Calls <f TrackPopupMenuEx> to display a popup menu, and directs
        WM_COMMAND messages to a given callback function.  Can be used by
        a windowless control to display a popup context menu.

@rdesc  Returns the value returned by <f TrackPopupMenuEx> (FALSE on error).
        Returns FALSE if the message window is currently being used for
        another popup menu.

@parm   HWND | hwnd | The hidden message-passing window which was created
        by calling <f MsgWndCreate> (usually in the constructor of the
        control, to ensure that the window is created in the same thread
        that created the control).

@parm   HMENU | hmenu | See <f TrackPopupMenuEx>.

@parm   UINT | fuFlags | See <f TrackPopupMenuEx>.

@parm   int | x | See <f TrackPopupMenuEx>.

@parm   int | y | See <f TrackPopupMenuEx>.

@parm   LPTPMPARAMS | lptpm | See <f TrackPopupMenuEx>.

@parm   MsgWndCallback * | pproc | The callback function that is to receive
        WM_COMMAND messages.  The <p wParam> parameter of this function
        is the <p wParam> of the WM_COMMAND message.  The <p lParam> parameter
        of this function is the <p lParam> of <f MsgWndTrackPopupMenuEx>.

@parm   LPARAM | lParam | A parameter to pass to <p pproc>.

@comm   This function calls <f TrackPopupMenuEx>.  Any WM_COMMAND messages
        from <f TrackPopupMenuEx> are passed to <p pproc>.

        The hidden message-passing window is used to receive WM_COMMAND
        messages; this window is created if it doesn't yet exist.
*/
STDAPI_(BOOL) MsgWndTrackPopupMenuEx(HWND hwnd, HMENU hmenu, UINT fuFlags,
    int x, int y, LPTPMPARAMS lptpm, MsgWndCallback *pproc, LPARAM lParam)
{
    ASSERT(hwnd != NULL); // if this fails, see new MsgWnd* documentation
    ASSERT(IsWindow(hwnd)); // if this fails, see new MsgWnd* documentation
    SetWindowLongPtr(hwnd, WL_MSGWNDCALLBACK, (LONG_PTR) pproc);
    SetWindowLongPtr(hwnd, WL_LPARAM, (LONG_PTR) lParam);
    return TrackPopupMenuEx(hmenu, fuFlags, x, y, hwnd, lptpm);
}


/* @func LRESULT | MsgWndSetTimer |

        Calls <f SetTimer> to cause WM_TIMER messages to be sent to the
                the control's hidden message-passing window (typically created
                by calling <f MsgWndCreate> in the control's constructor).
                When the window receives the message, it calls a given
        callback function.

@rdesc  Returns the value returned by <f SetTimer> (0 on error).

@parm   HWND | hwnd | The hidden message-passing window which was created
        by calling <f MsgWndCreate> (usually in the constructor of the
        control, to ensure that the window is created in the same thread
        that created the control).

@parm   MsgWndCallback * | pproc | The callback function that is called
        when the timer fires.  This function will be called on whatever thread
        calls <f DispatchMessage>.  When <p pproc> receives WM_TIMER, <p wParam>
        is <p nIDEvent> and <p lParam> is the value of <p lParam> passed
        to <f MsgWndSetTimer>.

@parm   UINT | nIDEvent | See WM_TIMER.

@parm   UINT | uElapse | See WM_TIMER.

@parm   LPARAM | lParam | A parameter to pass to <p pproc>.

@comm   Note that only one callback function <p pproc> can be used per
        message-passing HWND.
*/
STDAPI_(UINT_PTR) MsgWndSetTimer(HWND hwnd, MsgWndCallback *pproc, UINT nIDEvent,
        UINT uElapse, LPARAM lParam)
{
    ASSERT(hwnd != NULL); // if this fails, see new MsgWnd* documentation
    ASSERT(IsWindow(hwnd)); // if this fails, see new MsgWnd* documentation
    SetWindowLongPtr(hwnd, WL_TIMERCALLBACK, (LONG_PTR) pproc);
    SetWindowLongPtr(hwnd, WL_LPARAMTIMER, (LONG_PTR) lParam);
    return SetTimer(hwnd, nIDEvent, uElapse, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\himetric.cpp ===
// himetric.cpp
//
// Implements HIMETRIC helper functions.
//
// Important: This .cpp file assumes a zero-initializing global "new" operator.
//
// @doc MMCTL
//

#include "precomp.h"
#include "..\..\inc\ochelp.h"
#include "debug.h"




/* @func void | PixelsToHIMETRIC |

        Converts a width and height from pixels (on the default monitor)
        to HIMETRIC units.

@parm   int | cx | The input width in pixels.

@parm   int | cy | The input height in pixels.

@parm   SIZE * | psize | The output size in HIMETRIC units.

*/
STDAPI_(void) PixelsToHIMETRIC(int cx, int cy, LPSIZEL psize)
{
    HDC hdc = GetDC(NULL);
    psize->cx = (cx * HIMETRIC_PER_INCH) / GetDeviceCaps(hdc, LOGPIXELSX);
    psize->cy = (cy * HIMETRIC_PER_INCH) / GetDeviceCaps(hdc, LOGPIXELSY);
    ReleaseDC(NULL, hdc);
}


/* @func void | HIMETRICToPixels |

        Converts a width and height from HIMETRIC units to pixels
        (on the default monitor).

@parm   int | cx | The input width in HIMETRIC units.

@parm   int | cy | The input height in HIMETRIC units.

@parm   SIZE * | psize | The output size in pixels.

*/
STDAPI_(void) HIMETRICToPixels(int cx, int cy, SIZE *psize)
{
    HDC hdc = GetDC(NULL);
    psize->cx = (cx * GetDeviceCaps(hdc, LOGPIXELSX) + HIMETRIC_PER_INCH - 1)
        / HIMETRIC_PER_INCH;
    psize->cy = (cy * GetDeviceCaps(hdc, LOGPIXELSY) + HIMETRIC_PER_INCH - 1)
        / HIMETRIC_PER_INCH;
    ReleaseDC(NULL, hdc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\objsafe.cpp ===
//===========================================================================
// Copyright (c) Microsoft Corporation 1996
//
// File:		objsafe.cpp
//				
// Description:	This file contains the implementation of the function,
//				GetObjectSafety().
//
// History:		07/12/96	a-swehba
//					Created.
//				07/19/96	a-swehba
//					Changed comment.
//
// @doc MMCTL
//===========================================================================

//---------------------------------------------------------------------------
// Dependencies
//---------------------------------------------------------------------------

#include "precomp.h"
#include <objsafe.h>			// IObjectSafety
#include "..\..\inc\catid.h"	// CATID_SafeForScripting2, etc.
#include "debug.h"				// ASSERT()
#include "..\..\inc\ochelp.h"		// TCHARFromCLSID()




//---------------------------------------------------------------------------
// Local Function Declarations
//---------------------------------------------------------------------------

static void		_GetObjectSafetyViaIObjectSafety(
					IObjectSafety* pObjectSafety,
					va_list iidList,
					BOOL* pfSafeForScripting,
					BOOL* pfSafeForInitializing);
static HRESULT	_GetObjectSafetyViaRegistry(
					CLSID* pclsid,
					BOOL* pfSafeForScripting, 
					BOOL* pfSafeForInitializing);




/*---------------------------------------------------------------------------
@func	HRESULT | GetObjectSafety |
		Determines if an object is safe-for-scripting and/or
		safe-for-initializing vis-a-vis a given set of interfaces.

@parm	BOOL* | pfSafeForScripting |
		[out] If non-NULL, set to TRUE if the object is safe-for-scripting.

@parm	BOOL* | pfSafeForInitializing |
		[out] If non-NULL, set to TRUE if the object is safe-for-initializing

@parm	IUnknown* | punk |
		[in] The object's IUnknown interface.  If non-NULL, an attempt
		will be made to assess the object's safety via its <i IObjectSafety>
		interface.  If NULL, or the the object doesn't support this interface, 
		its safety will be assessed using <p pclsid> and the system registry.

@parm	CLSID* | pclsid |
		[in] The object's class ID.  If <p punk> is NULL or the object
		doesn't support <i IObjectSafety>, then <p pclsid> will be used
		to look up the object's safety in the system registry (as long
		as <p pclsid> is also non-NULL).

@parm	IID* | (interfaces) |
		[in] A variable number of interfaces pointers, the last of which
		must be NULL.  If the object's safety is assessed via 
		<i IObjectSafety> (see <p punk>) then it's safety is assessed 
		vis-a-vis this set of interfaces.  These interfaces are not used 
		if the object's safety is examined via the system registry.

@rvalue	S_OK |
		Success.  The object's safety was assessible and *<p pfSafeForScripting>
		and/or *<p pfSafeForInitializing> have been set accordingly.

@rvalue	E_FAIL |
		Failure.  The object's safety couldn't be assessed.  The values
		of *<p pfSafeForScripting> and *<p pfSafeForInitializing> are
		indeterminate.

@comm	If your code uses OCMisc (i.e., #includes ocmisc.h), it should also
		[#include <lt>objsafe.h<gt>] whereever it #includes <lt>initguid.h<gt>.  This will
		cause IID_IObjectSafety to be defined.

@ex		The following example shows how to test whether an object is 
		safe-for-scripting and safe-for-initializing by checking the system 
		registry only: |

			BOOL fSafeForScripting;
			BOOL fSafeForInitializing;
			GetObjectSafety(&fSafeForScripting, &fSafeForInitializing,
				NULL, &CLSID_MyObject, NULL);

@ex		The following example shows how to test whether an object is
		safe-for-scripting via IDispatch using the object's <i IObjectSafety>
		interface: |

			BOOL fSafeForScripting;
			GetObjectSafety(&fSafeForScripting, NULL, punk, NULL, 
				&IID_IDispatch, NULL);

@ex		The following example shows how to test whether an object is 
		safe-for-initialzing via IPersistStream, IPersistStreamInit, or
		IPersistPropertyBag using the object's <i IObjectSafety> interface
		or, if <i IObjectSafety> is not supported, the registry: |

			BOOL fSafeForInitializing;
			GetObjectSafety(NULL, &safeForInitializing, punk, &CLSID_MyObject, 
				&IID_IPersistStream, &IID_IPersistStreamInit,
				&IID_IPersistPropertyBag, NULL);
---------------------------------------------------------------------------*/

HRESULT __cdecl GetObjectSafety(
BOOL* pfSafeForScripting,
BOOL* pfSafeForInitializing,
IUnknown* punk,
CLSID* pclsid,
...)
{
	IObjectSafety* pObjectSafety = NULL;
		// <punk>'s IObjectSafety interface
    va_list interfaces;
		// optional OLE interface IDs to use when checking safety via
		// IObjectSafety
	HRESULT hr = S_OK;
		// function return value


	// If supplied with an IUnknown pointer to the object, first try to 
	// find the object's safety through IObjectSafety.

	if (punk != NULL)
	{
		hr = punk->QueryInterface(IID_IObjectSafety, (void**)&pObjectSafety);
		if (SUCCEEDED(hr))
		{
			va_start(interfaces, pclsid);
			_GetObjectSafetyViaIObjectSafety(pObjectSafety, 
										     interfaces, 
										     pfSafeForScripting,
										     pfSafeForInitializing);
			va_end(interfaces);
			pObjectSafety->Release();
			goto Exit;
		}
	}

	// If no pointer to the object was supplied, or the object doesn't
	// support IObjectSafety, try to find if the object is safe via
	// the registry.

	hr = _GetObjectSafetyViaRegistry(pclsid,
									 pfSafeForScripting, 
									 pfSafeForInitializing);

Exit:

	return (hr);
}




//---------------------------------------------------------------------------
// Function:	_GetObjectSafetyViaIObjectSafety
//
// Synopsis:	Determine an object's safety via the object's IObjectSafety
//				interface.
//
// Arguments:	[in] pObjectSafety
//					A pointer to the object's IObjectSafety interface.
//				[in] iidList
//					A of IID*'s.  Must end with NULL.
//				[out] pfSafeForScripting
//					If non-NULL, set to TRUE if the object associated with
//					<pObjectSafety> is safe-for-scripting via any of the 
//					interfaces in <iidList>.  Set to FALSE otherwise.
//				[out] pfSafeForInitializing
//					If non-NULL, set to TRUE if the object associated with
//					<pObjectSafety> is safe-for-initializing via any of the
//					interfaces in <iidList>.  Set to FALSE otherwise.
//
// Returns:		(nothing)
//
// Requires:	pObjectSafety != NULL
//
// Ensures:		(nothing)
//
// Notes:		(none)
//---------------------------------------------------------------------------

static void _GetObjectSafetyViaIObjectSafety(
IObjectSafety* pObjectSafety,
va_list iidList,
BOOL* pfSafeForScripting,
BOOL* pfSafeForInitializing)
{
	IID* piid;
	BOOL fSafeForScripting = FALSE;
	BOOL fSafeForInitializing = FALSE;
	DWORD dwOptionsSetMask;
	DWORD dwEnabledOptions;

	// Preconditions

	ASSERT(pObjectSafety != NULL);

	// As long as the object isn't safe

	while ((piid = va_arg(iidList, IID*)) != NULL)
	{
		// Try to make the object safe for scripting via the current
		// interface.

		if (!fSafeForScripting)
		{
			dwOptionsSetMask = INTERFACESAFE_FOR_UNTRUSTED_CALLER;
			dwEnabledOptions = INTERFACESAFE_FOR_UNTRUSTED_CALLER;
			fSafeForScripting = 
				(SUCCEEDED(pObjectSafety->SetInterfaceSafetyOptions(
											*piid,
											dwOptionsSetMask,
											dwEnabledOptions)));
		}

		// Try to make the object safe for initializing via the current
		// interface.

		if (!fSafeForInitializing)
		{
			dwOptionsSetMask = INTERFACESAFE_FOR_UNTRUSTED_DATA;
			dwEnabledOptions = INTERFACESAFE_FOR_UNTRUSTED_DATA;
			fSafeForInitializing = 
				(SUCCEEDED(pObjectSafety->SetInterfaceSafetyOptions(
											*piid,
											dwOptionsSetMask,
											dwEnabledOptions)));
		}
	}

	// Set the return arguments.

	if (pfSafeForScripting != NULL)
	{
		*pfSafeForScripting = fSafeForScripting;
	}
	if (pfSafeForInitializing != NULL)
	{
		*pfSafeForInitializing = fSafeForInitializing;
	}
}




//---------------------------------------------------------------------------
// Function:	_GetObjectSafetyViaRegistry
//
// Synopsis:	Determine an object's safety via the system registry.
//
// Arguments:	[in] pclsid
//					The class ID of the object.  If NULL, the function
//					returns E_FAIL.
//				[out] pfSafeForScripting
//					If non-NULL on entry, set to TRUE if the class/object
//					is registered as safe-for-scripting and FALSE if it 
//					isn't.
//				[out] pfSafeForInitializing
//					If non-NULL on entry, set to TRUE if the class/object
//					is registered as safe-for-initializing and FALSE if it
//					isn't.
//
// Returns:		S_OK
//					Success.  <pclsid> is a registered class ID.  
//					<*pfSafeForScripting> and/or <*pfSafeForInitializing>
//					have been set.
//				E_FAIL
//					Failure.  Either <pclsid> is NULL or there was a problem
//					reading the registry.  In either case, <*pfSafeFor-
//					Scripting> and <*pfSafeForInitializing> aren't altered.
//
// Requires:	(nothing)
//
// Ensures:		(nothing)
//
// Notes:		(none)
//---------------------------------------------------------------------------

static HRESULT _GetObjectSafetyViaRegistry(
CLSID* pclsid,
BOOL* pfSafeForScripting, 
BOOL* pfSafeForInitializing)
{
	const int c_cchMaxCLSIDLen = 100;
		// maximum length (in characters) of a class ID represented as a
		// string
	TCHAR szCLSID[c_cchMaxCLSIDLen + 1];
		// <*pclsid> as a string
	TCHAR szKeyPath[c_cchMaxCLSIDLen + 100];
		// a registry key path
	HKEY hKey1 = NULL;
	HKEY hKey2 = NULL;
	HKEY hKey3 = NULL;
		// registry keys
	HRESULT hr = S_OK;
		// function return value

	// If no class ID was supplied, we can't get very far in the registry.

	if (pclsid == NULL)
	{
		goto ExitFail;
	}

	// hKey1 = HKEY_CLASSES_ROOT\CLSID\<*pclsid>

	lstrcpy(szKeyPath, _T("CLSID\\"));
	lstrcat(szKeyPath, TCHARFromGUID(*pclsid, szCLSID, c_cchMaxCLSIDLen));
	if (RegOpenKey(HKEY_CLASSES_ROOT, szKeyPath, &hKey1) != ERROR_SUCCESS)
	{
		goto ExitFail;
	}

	// hKey2 = HKEY_CLASSES_ROOT\CLSID\<*pclsid>\"Implemented Categories"

	if (RegOpenKey(hKey1, _T("Implemented Categories"), &hKey2) != ERROR_SUCCESS)
	{
		hKey2 = NULL;
	}

	// Look to see if the class is registered as safe-for-scripting.

	if (pfSafeForScripting != NULL)
	{
		if (hKey2 == NULL)
		{
			*pfSafeForScripting = FALSE;
		}
		else
		{
			TCHARFromGUID(CATID_SafeForScripting2, szCLSID, c_cchMaxCLSIDLen);
			*pfSafeForScripting = (RegOpenKey(hKey2, szCLSID, &hKey3) == 
									ERROR_SUCCESS);
		}
	}

	// Look to see if the class is registered as safe-for-initializing.

	REG_CLOSE_KEY(hKey3);
	if (pfSafeForInitializing != NULL)
	{
		if (hKey2 == NULL)
		{
			*pfSafeForInitializing = FALSE;
		}
		else
		{
			TCHARFromGUID(CATID_SafeForInitializing2, szCLSID, c_cchMaxCLSIDLen);
			*pfSafeForInitializing = (RegOpenKey(hKey2, szCLSID, &hKey3) == 
										ERROR_SUCCESS);
		}
	}

Exit:

	REG_CLOSE_KEY(hKey1);
	REG_CLOSE_KEY(hKey2);
	REG_CLOSE_KEY(hKey3);
	return (hr);

ExitFail:

	hr = E_FAIL;
	goto Exit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\lpbfs.cpp ===
// lpbfs.cpp
//
// Implements LoadPropertyBagFromStream.
//
// Important: This .cpp file assumes a zero-initializing global "new" operator.
//
// @doc MMCTL
//

#include "precomp.h"
#include "..\..\inc\mmctlg.h" // see comments in "mmctl.h"
#include "..\..\inc\ochelp.h"
#include "debug.h"


/* @func HRESULT | LoadPropertyBagFromStream |

        Load properties that are stored in an <i IStream> (in the simple
        tagged binary format written by <f WriteVariantProperty>) into an
        <i IPropertyBag> object.

@rvalue S_OK | Success.

@rvalue E_FAIL | I/O error.

@parm   IStream * | pstream | The stream to read from.

@parm   IPropertyBag * | ppb | The property bag to write to.

@parm   DWORD | dwFlags | Currently unused.  Must be set to 0.

@comm   Note that this function does not (cannot, in fact) empty <p ppb>
        prior to loading property name/value pairs from <p pstream>.
*/
STDAPI LoadPropertyBagFromStream(IStream *pstream, IPropertyBag *ppb,
    DWORD dwFlags)
{
    HRESULT         hrReturn = S_OK; // function return code
    VariantProperty vp;             // a property name/value pair in <pmvio>

    // ensure correct cleanup
    VariantPropertyInit(&vp);

    // loop once for each property in the stream
    while (TRUE)
    {
        // set <vp> to the next property name/value pair in <pstream>
        VariantPropertyClear(&vp);
        if (FAILED(hrReturn = ReadVariantProperty(pstream, &vp, 0)))
            goto ERR_EXIT;
        if (hrReturn == S_FALSE)
        {
            // hit end of stream
            hrReturn = S_OK;
            break;
        }

        // wrote <vp> to the property bag
        if (FAILED(hrReturn = ppb->Write(vp.bstrPropName, &vp.varValue)))
            goto ERR_EXIT;
    }

    goto EXIT;

ERR_EXIT:

    // error cleanup
    // (nothing to do)
    goto EXIT;

EXIT:

    // normal cleanup
    VariantPropertyClear(&vp);

    return hrReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\precomp.cpp ===
// precomp.cpp : source file that includes just the standard includes
//  precomp.pch will be the pre-compiled header
//  precomp.obj will contain the pre-compiled type information

#include "precomp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\precomp.h ===
// precomp.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#include <windows.h>
#include <tchar.h>
#include <servprov.h> // for IServiceProvider 
#include "..\..\inc\mmctl.h"
#include "memlayer.h"

/*
// default new and delete operators
void * _cdecl operator new(size_t cb);
void _cdecl operator delete(void *pv);
*/

// memory leak detection
STDAPI_(void) HelpMemDetectLeaks();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\ole.cpp ===
// OLE.cpp
//
// Implements OLE utility functions.
//
// @doc MMCTL
//

#include "precomp.h"
#include "..\..\inc\mmctlg.h"
#include "..\..\inc\ochelp.h"
#include "debug.h"


/* @func ULONG | SafeRelease |

		Releases an interface pointer if the pointer isn't NULL, and sets the
		pointer to NULL.

@rdesc  Value returned by the Release call, or 0 if <p ppunk> is NULL.

@parm   LPUNKNOWN | ppunk | Pointer to a pointer to the interface to release.
		Can be NULL.

@comm	The interface pointer must be cast to an (IUnknown **) before calling
		this function:

@iex	SafeRelease( (LPUNKNOWN *)&pInterface );
*/

STDAPI_(ULONG) SafeRelease (LPUNKNOWN *ppunk)
{
    if (*ppunk != NULL)
	{
		ULONG cRef;

        cRef = (*ppunk)->Release();
        *ppunk = NULL;
        return (cRef);
	}

	return (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\pc.cpp ===
// pc.cpp
//
// Implements PersistChild.
//
// Important: This .cpp file assumes a zero-initializing global "new" operator.
//
// @doc MMCTL
//

#include "precomp.h"
#include "..\..\inc\mmctlg.h" // see comments in "mmctl.h"
#include "..\..\inc\ochelp.h"
#include "debug.h"


/* @func HRESULT | PersistChild |

        Loads or saves a child of a given container object from/to a given.
        <i IVariantIO> object.  Used to help implement persistence in control
        containers.

@rvalue S_OK | Success.

@rvalue S_FALSE | <p pvio> is in loading mode, and collection <p szCollection>
        does not contain a child numbered <p iChild>.  (This typically tells
        the container that it can stop trying to load children.)

@parm   IVariantIO * | pvio | The <i IVariantIO> object to read properties from
        or write properties to.

@parm   LPCSTR | szCollection | The name of the collection that the child
        object belongs to.  See <f PersistSiteProperties> for more information
        about collections.

@parm   int | iChild | The index (into the collection named by <p szCollection>)
        of the child object whose site properties are being persisted by this
        call to <f PersistSiteProperties>.  Conventionally, indices are 1-based
        (i.e. the first child object in the collection is numbered 1, not 0).
        See <f PersistSiteProperties> for more information.

@parm   LPUNKNOWN | punkOuter | The controlling unknown to use for the
        new child object, if the child object is loaded (i.e. if <p pvio>
        is in loading mode and if a child object is successfully loaded).

@parm   DWORD | dwClsContext | Specifies the context in which the executable
        is to be run. The values are taken from the enumeration CLSCTX.
        A typical value is CLSCTX_INPROC_SERVER.  This parameter is ignored
        unless if <p pvio> is in loading mode and a child object is
        successfully loaded.

@parm   LPUNKNOWN * | ppunk | A pointer to an LPUNKNOWN variable that currently
        contains (if <p pvio> is in saving mode) or into which will be stored
        (if <p pvio> is in loading mode) the pointer to the child control.

@parm   CLSID * | pclsid | Where to store the class ID of the child object,
        if <p pvio> is in loading mode.  If <p pclsid> is NULL then this
        information is not returned.  If <p pvio> is in saving mode and
        <p pclsid> is not NULL, then on entry *<p pclsid> is assumed to contain
        the class ID of the child object (useful if the child object does not
        implement <i IPersist>); if not specified, the class ID of the child
        is obtained by calling <i IPersist> on the child.

@parm	BOOL * | pfSafeForScripting | If non-NULL, *<p pfSafeForScripting> is
		set to TRUE or FALSE depending on whether the control is safe-for-scripting.

@parm	BOOL * | pfSafeForInitializing | If non-NULL, *<p pfSafeForInitializing> is
		set to TRUE or FALSE depending on whether the control is safe-for-initializing.

@parm   DWORD | dwFlags | Currently unused.  Must be set to 0.

@ex     See <f PersistSiteProperties> for an example of how <f PersistChild>
        is used. |
*/
STDAPI PersistChild(IVariantIO *pvio, LPCSTR szCollection,
    int iChild, LPUNKNOWN punkOuter, DWORD dwClsContext, LPUNKNOWN *ppunk,
    CLSID *pclsid, BOOL *pfSafeForScripting, BOOL *pfSafeForInitializing,
	DWORD dwFlags)
{
    HRESULT         hrReturn = S_OK; // function return code
    CLSID           clsid;          // class ID of the child
    IPropertyBag *  ppb = NULL;     // interface onto <pvio>
    IPersist *      ppersist = NULL; // interface on child
    IPersistPropertyBag *pppb = NULL; // interface on child
    IPersistStream *pps = NULL;     // interface on child
    IPropertyBag *  ppbChild = NULL; // child's "virtual property bag"
    IStream *       psBuf = NULL;   // memory-based stream containing temp. data
    ULONG           cbBuf;          // no. bytes in <psBuf>
    char            achPropPrefix[_MAX_PATH]; // child property name prefix
    char            achPropName[_MAX_PATH]; // a property name
    LARGE_INTEGER   liZero = {0, 0};
    ULARGE_INTEGER  uliCurPos;
    char            ach[_MAX_PATH];
    OLECHAR         oach[_MAX_PATH];
    VARIANT         var;
    ULONG           cb;

    // ensure correct cleanup
    VariantInit(&var);

	if (pvio->IsLoading() == S_OK)
	{
		*ppunk = NULL;
	}

    // make <ppb> be an IPropertyBag interface onto <pvio>
    if (FAILED(hrReturn = pvio->QueryInterface(IID_IPropertyBag,
            (LPVOID *) &ppb)))
        goto ERR_EXIT;

	// If <iChild> is less then 0, we are not really a collection and we 
	// set <achPropPrefix> to simply the property name (e.g. "Controls.".
    // Otherwise set <achPropPrefix> to the property name prefix for this child
    // (e.g. "Controls(7)." if <szCollection> is "Controls" and <iChild> is 7)
	if(iChild < 0)
		wsprintf(achPropPrefix, "%s.", szCollection);
	else
		wsprintf(achPropPrefix, "%s(%d).", szCollection, iChild);

    // set <achPropName> to the name of the class ID property
    // (class ID of child gets saved as e.g. "Controls(7)._clsid")
    lstrcpy(achPropName, achPropPrefix);
    lstrcat(achPropName, "_clsid");

    // if <pvio> is in loading mode, create the control <*ppunk> based on
    // the control's "_clsid" property stored in <pvio>; if <pvio> is in
    // saving mode, save the control's "_clsid" property to <pvi>
    if (pvio->IsLoading() == S_OK)
    {
        // set <ach> to the string form of the class ID of the child control
        // we need to load
        ach[0] = 0;
        if (FAILED(hrReturn = pvio->Persist(0, achPropName, VT_LPSTR, ach,
                NULL)))
            goto ERR_EXIT;
        if (ach[0] == 0)
        {
            // no more children to load
            hrReturn = S_FALSE;
            goto EXIT;
        }

        // create the requested control
        if (FAILED(hrReturn = CreateControlInstance(ach, punkOuter,
            dwClsContext, ppunk, pclsid, pfSafeForScripting, 
			pfSafeForInitializing, 0)))
            goto ERR_EXIT;
    }
    else
    {
        // set <clsid> to the class ID of the child object
        if (pclsid != NULL)
            clsid = *pclsid;
        else
        if (SUCCEEDED((*ppunk)->QueryInterface(IID_IPersist,
                (LPVOID *) &ppersist)) &&
            SUCCEEDED(ppersist->GetClassID(&clsid)))
            ;
        else
            goto ERR_FAIL; // can't persist if we can't determine class ID

        // convert <clsid> to string form and write as value of
        // property <achPropName>
        if (StringFromGUID2(clsid, oach, sizeof(oach) / sizeof(*oach)) == 0)
            goto ERR_FAIL;
        UNICODEToANSI(ach, oach, sizeof(ach));
        if (FAILED(hrReturn = pvio->Persist(0, achPropName, VT_LPSTR, ach,
                NULL)))
            goto ERR_EXIT;
    }

    // attempt to get persistence interfaces onto the child control
    (*ppunk)->QueryInterface(IID_IPersistPropertyBag, (LPVOID *) &pppb);
    if (FAILED((*ppunk)->QueryInterface(IID_IPersistStream, (LPVOID *) &pps)))
        (*ppunk)->QueryInterface(IID_IPersistStreamInit, (LPVOID *) &pps);

    if (pppb != NULL)
    {
        // set <ppbChild> to be a property bag that the child object can
        // use to read/write its properties (whose names are prefixed by
        // <achPropPrefix>) from/to <ppbParent>
        if (FAILED(hrReturn = AllocChildPropertyBag(ppb, achPropPrefix,
                0, &ppbChild)))
            goto ERR_EXIT;

        // tell the child to persist itself using <ppbChild>
        if (pvio->IsLoading() == S_OK)
        {
            // tell the object to read its properties from the property bag
            // <ppbChild>
            if (FAILED(hrReturn = pppb->Load(ppbChild, NULL)))
                goto ERR_EXIT;
        }
        else
        {
            // tell the object to write its properties to the property bag
            // <ppbChild>
            if (FAILED(hrReturn = pppb->Save(ppbChild, TRUE, TRUE)))
                goto ERR_EXIT;
        }
    }
    else
    if (pps != NULL)
    {
        // set <oach> to be the name of this child's "_data" property
        // (e.g. "Controls(7)._data")
        lstrcpy(ach, achPropPrefix);
        lstrcat(ach, "_data");
        ANSIToUNICODE(oach, ach, sizeof(oach) / sizeof(*oach));

        // set <psbuf> to be a new empty memory-based stream
        if (FAILED(hrReturn = CreateStreamOnHGlobal(NULL, TRUE, &psBuf)))
            goto ERR_EXIT;

        if (pvio->IsLoading() == S_OK)
        {
            // read the child's data (a stream of bytes) from the "_data"
            // property of the parent, then tell the child to load its
            // data from that stream...

            // set <var> to the value of the "_data" property
            VariantClear(&var);
            var.vt = VT_BSTR;
            var.bstrVal = NULL; // some property bags (e.g. IE) need this
            if (FAILED(hrReturn = ppb->Read(oach, &var, NULL)))
            {
                VariantInit(&var);
                goto ERR_EXIT;
            }
            if (var.vt != VT_BSTR)
                goto ERR_FAIL;

            // write the string value of the "_data" property to <psBuf>
            cbBuf = SysStringLen(var.bstrVal) * sizeof(wchar_t);
            if (FAILED(psBuf->Write(var.bstrVal, cbBuf, &cb)) || (cb != cbBuf))
                goto ERR_FAIL;
            // seek the current position of <psBuf> back to the beginning of
            // the stream
            if (FAILED(hrReturn = psBuf->Seek(liZero, SEEK_SET, NULL)))
                return hrReturn;

            // tell the control to read its data from <psBuf>
            if (FAILED(hrReturn = pps->Load(psBuf)))
                goto ERR_EXIT;
        }
        else
        {
            // tell the child to save its data to a stream, and then set the
            // "_data" property for the child to that stream's data...

            // tell the control to write its data to <psBuf>
            if (FAILED(hrReturn = pps->Save(psBuf, TRUE)))
                goto ERR_EXIT;

            // set <cbBuf> to the number of bytes in <psbuf>
            if (FAILED(hrReturn = psBuf->Seek(liZero, SEEK_CUR, &uliCurPos)))
                return hrReturn;
            if (uliCurPos.HighPart != 0)
                goto ERR_FAIL;
            cbBuf = uliCurPos.LowPart;

            // seek the current position of <psBuf> back to the beginning of
            // the stream
            if (FAILED(hrReturn = psBuf->Seek(liZero, SEEK_SET, NULL)))
                return hrReturn;

            // set <var> to be a string containing the bytes from <psBuf>
            VariantClear(&var);
            var.bstrVal = SysAllocStringLen(NULL, (cbBuf + 1) / 2);
            if (var.bstrVal == NULL)
                goto ERR_OUTOFMEMORY;
            var.vt = VT_BSTR;

            // store <var> as the value of the child's "_data" property
            if (FAILED(hrReturn = ppb->Write(oach, &var)))
                goto ERR_EXIT;
        }
    }

    goto EXIT;

ERR_OUTOFMEMORY:

    hrReturn = E_OUTOFMEMORY;
    goto ERR_EXIT;

ERR_FAIL:

    hrReturn = E_FAIL;
    goto ERR_EXIT;

ERR_EXIT:

    // error cleanup
    if (*ppunk != NULL && pvio->IsLoading() == S_OK)
        (*ppunk)->Release();
    *ppunk = NULL;
    goto EXIT;

EXIT:

    // normal cleanup
    if (ppb != NULL)
        ppb->Release();
    if (pppb != NULL)
        pppb->Release();
    if (pps != NULL)
        pps->Release();
    if (ppbChild != NULL)
        ppbChild->Release();
    if (ppersist != NULL)
        ppersist->Release();
    if (psBuf != NULL)
        psBuf->Release();
    VariantClear(&var);

    return hrReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\pviol.cpp ===
// pviol.cpp
//
// Implements PersistVariantIOList.
//
// Important: This .cpp file assumes a zero-initializing global "new" operator.
//
// @doc MMCTL
//

#include "precomp.h"
#include "..\..\inc\mmctlg.h" // see comments in "mmctl.h"
#include "..\..\inc\ochelp.h"
#include "debug.h"


/* @func HRESULT | PersistVariantIOList |

        Loads or saves a list of property name/value pairs, specified as a
        va_list array that's formatted in the same way as
        <om IVariantIO.Persist>, to/from an <i IPropertyBag> object.

@rvalue S_OK | Success.  At least one of the variables listed in
        <p args> was written to, so the control may want to update
        itself accordingly.

@rvalue S_FALSE | None of the variables listed in <p args> were
        written to (either because the <i IVariantIO> object is in
        saving mode or because none of the properties named in
        <p args> exist in the <i IVariantIO> object).

@rvalue DISP_E_BADVARTYPE | One of the VARTYPE values in <p args> is invalid.

@rvalue E_FAIL | A failure occurred while reading from the property bag, other
		than "property doesn't exist."  This can happen if the caller specified
		a type to which the property bag could not coerce the property, for
		example.

@rvalue E_OUTOFMEMORY | Out of memory.

@parm	IPropertyBag * | ppb | The property bag used to load or save the
		specified properties.

@parm   DWORD | dwFlags | May contain the same flags passed to
        <om IManageVariantIO.SetMode> (e.g. VIO_ISLOADING).

@parm   va_list | args | The arguments to pass.  See <om IVariantIO.Persist>
        for information about the organization of these arguments.
*/
STDAPI PersistVariantIOList(IPropertyBag *ppb, DWORD dwFlags, va_list args)
{
    HRESULT         hrReturn = S_OK; // function return code
    LPSTR           szArg;          // property name from <args>
    VARTYPE         vtArg;          // variable type from <args>
    LPVOID          pvArg;          // variable pointer from <args>
    VARIANT         varProp;        // value of the property named <szArg>
    BOOL            fWroteToVar = FALSE; // TRUE if wrote to a var. in <args>
    VARIANT         varArg;         // value of an variable in <args>
    VARTYPE         vtRequested;    // type to coerce property value to
	BOOL			fVarNon0 = TRUE; // TRUE if variant to save is non-zero
    BSTR            bstr = NULL;
    OLECHAR         oach[_MAX_PATH];
    VARIANT         var;
    int             cch;
    HRESULT         hrTemp;

    // invariant: <varProp> and <var> each either contain data that
    // this function must clean up using VariantClear() or contain
    // no data (i.e. have been initialized using VariantInit() or
    // cleared already using VariantClear()) -- but note that this
    // invariant doesn't apply to <varArg> (i.e. <varArg> should
    // not be cleared by this function)
    VariantInit(&varProp);
    VariantInit(&var);

    // loop once for each (name, VARTYPE, value) triplet in <args>
    while ((szArg = va_arg(args, LPSTR)) != NULL)
    {
        // <szArg> is the name of the property in the current triplet;
        // set <vtArg> to the type of the variable pointer, and set
        // <pvArg> to the variable pointer
        vtArg = va_arg(args, VARTYPE);
        pvArg = va_arg(args, LPVOID);

        if (dwFlags & VIO_ISLOADING)
        {
            // we need to copy data from the property named <szArg> to
            // the variable at location <pvArg>...

            // set <vtRequested> to the type to coerce the property value to;
            // set <vtRequested> to VT_EMPTY if the caller wants the property
            // in its default type
            if (vtArg == VT_VARIANT)
                vtRequested = VT_EMPTY;
            else
            if (vtArg == VT_INT)
                vtRequested = VT_I4;
            else
            if (vtArg == VT_LPSTR)
                vtRequested = VT_BSTR;
            else
                vtRequested = vtArg;

            // set <varProp> to a copy of the property named <szArg>
            memset(&varProp, 0, sizeof(varProp)); // clear <vt> and <bstrVal>
            ANSIToUNICODE(oach, szArg, sizeof(oach) / sizeof(*oach) - 1);
            varProp.vt = vtRequested;
            hrTemp = ppb->Read(oach, &varProp, NULL);
            if (E_INVALIDARG == hrTemp)
            {
				// The specified property doesn't exist in the property bag.
				// This isn't an error; the property will just remain at its
				// default value.
                VariantInit(&varProp);
                continue;
            }
			else
            if (FAILED(hrTemp))
            {
				// The property bag was unable to read the specified property.
				// This can happen if the caller specified a type to which the
				// property bag could not coerce the property, for example.
				// This is an error.
                hrReturn = hrTemp;
                goto ERR_EXIT;
            }
            else
            if ((vtRequested != VT_EMPTY) && (varProp.vt != vtRequested))
            {
                VariantClear(&varProp);
                continue;
            }

            // store the value of <varProp> into <pvArg>
            switch (vtArg)
            {
            case VT_VARIANT:
                VariantClear((VARIANT *) pvArg);
                *((VARIANT *) pvArg) = varProp;
                VariantInit(&varProp); // hand over ownership to <pvArg>
                break;
            case VT_I2:
                *((short *) pvArg) = varProp.iVal;
                break;
            case VT_I4:
            case VT_INT:
                *((long *) pvArg) = varProp.lVal;
                break;
            case VT_R4:
                *((float *) pvArg) = V_R4(&varProp);
                break;
            case VT_R8:
                *((double *) pvArg) = V_R8(&varProp);
                break;
            case VT_BOOL:
                *((BOOL *) pvArg) = (V_BOOL(&varProp) == 0 ? 0 : 1);
                break;
            case VT_BSTR:
                SysFreeString(*((BSTR *) pvArg));
                *((BSTR *) pvArg) = varProp.bstrVal;
                VariantInit(&varProp); // hand over ownership to <pvArg>
                break;
            case VT_UNKNOWN:
            case VT_DISPATCH:
                if (*((LPUNKNOWN *) pvArg) != NULL)
                    (*((LPUNKNOWN *) pvArg))->Release();
                *((LPUNKNOWN *) pvArg) = varProp.punkVal;
                if (*((LPUNKNOWN *) pvArg) != NULL)
                    (*((LPUNKNOWN *) pvArg))->AddRef();
                break;
            case VT_LPSTR:
                UNICODEToANSI((LPSTR) pvArg, varProp.bstrVal, _MAX_PATH - 1);
                break;
            default:
                hrReturn = DISP_E_BADVARTYPE;
                goto ERR_EXIT;
            }

            fWroteToVar = TRUE;
        }
        else
        {
            // we need to copy data from the variable at location <pvArg>
            // to the property named <szArg>...

            // make <varArg> contain the data (not a copy of the data) of the
            // variable at location <pvArg>
            if (vtArg == VT_VARIANT)
                varArg = *((VARIANT *) pvArg);
            else
            {
				varArg.vt = vtArg;
				switch (vtArg)
				{
				case VT_I2:
					varArg.iVal = *((short *) pvArg);
					break;
				case VT_I4:
				case VT_INT:
					varArg.lVal = *((long *) pvArg);
					varArg.vt = VT_I4;
					break;
                case VT_R4:
                    V_R4(&varArg) = *((float *) pvArg);
                    break;
               case VT_R8:
                    V_R8(&varArg) = *((double *) pvArg);
                    break;
				case VT_BOOL:
					V_BOOL(&varArg) = (*((BOOL *) pvArg) ? -1 : 0);
					break;
				case VT_BSTR:
					varArg.bstrVal = *((BSTR *) pvArg);
					break;
				case VT_UNKNOWN:
				case VT_DISPATCH:
					varArg.punkVal = *((LPUNKNOWN *) pvArg);
					break;
				case VT_LPSTR:
					SysFreeString(bstr);
					cch = lstrlen((LPSTR) pvArg);
					bstr = SysAllocStringLen(NULL, cch);
					if (bstr == NULL)
						goto ERR_OUTOFMEMORY;
					ANSIToUNICODE(bstr, (LPSTR) pvArg, cch + 1);
					varArg.bstrVal = bstr;
					varArg.vt = VT_BSTR;
					break;
				default:
					hrReturn = DISP_E_BADVARTYPE;
					goto ERR_EXIT;
				}

				// is the value to be saved non-zero?
				switch (vtArg)
				{
				case VT_I2:
					fVarNon0 = varArg.iVal;
					break;
				case VT_I4:
				case VT_INT:
				case VT_R4:
				case VT_BOOL:
				case VT_UNKNOWN:
				case VT_DISPATCH:
				case VT_BSTR:
					fVarNon0 = varArg.lVal;
					break;
				case VT_LPSTR:
					fVarNon0 = cch;
					break;
				case VT_R8:
					fVarNon0 = (varArg.dblVal != 0);
					break;
				default:
					hrReturn = DISP_E_BADVARTYPE;
					goto ERR_EXIT;
				}
            }

			// only save the variant if it's value isn't 0, or if we're saving
			// even 0 default values
			if (fVarNon0 || !(dwFlags & VIO_ZEROISDEFAULT))
			{
				// set the value of the property named <szArg> to be a copy of
				// <varArg>
				ANSIToUNICODE(oach, szArg, sizeof(oach) / sizeof(*oach) - 1);
				if (FAILED(ppb->Write(oach, &varArg)))
					goto ERR_OUTOFMEMORY;
			}
        }
    }

    goto EXIT;

ERR_OUTOFMEMORY:

    hrReturn = E_OUTOFMEMORY;
    goto ERR_EXIT;

ERR_EXIT:

    // error cleanup
    // (nothing to do)

    goto EXIT;

EXIT:

    // normal cleanup
    VariantClear(&varProp);
    VariantClear(&var);
    SysFreeString(bstr);

    if (FAILED(hrReturn))
        return hrReturn;
    return (fWroteToVar ? S_OK : S_FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\prophelp.cpp ===
// prophelp.cpp
//
// Implements AllocPropPageHelper.
//
// @doc MMCTL
//

#include "precomp.h"
#include "..\..\inc\mmctlg.h"
#include "..\..\inc\ochelp.h"
#include "debug.h"


//////////////////////////////////////////////////////////////////////////////
// CPropPageHelper
//


/* @object PropPageHelper |

        Implements <i IPropertyPage>.  Designed to be aggregated by an
        object that wants to provide a specific propery page implementation.

@supint IPropertyPage | Standard OLE property page implementation.  The
        information about the property page is maintained in a
        <t PropPageHelperInfo> structure that's allocated by the
        aggregator and shared with <o PropPageHelper>.

@comm   See <f AllocPropPageHelper> for more information.

*/


/* @struct PropPageHelperInfo |

        Maintains information describing a property page.  Used by
        <o PropPageHelper>, but allocated by the object that aggregates
        <o PropPageHelper>.

@field  int | idDialog | ID of propery page dialog resource.

@field  int | idTitle | ID of a string resource containing the page's title
        (used on the page tab).

@field  HINSTANCE | hinst | The instance of the DLL that contains the
        resources specified by <p idDialog> and <p idTitle>.

@field  PropPageHelperProc | pproc | A callback function that receives property
        page window messages.  <p pproc> is similar to a DLGPROC but has
        extra parameters: a pointer to this structure, and a pointer to
        an HRESULT to be used when responding to the following special
        messages:

        @flag   WM_PPH_APPLY | <p pproc> should apply any property page
                changes to the objects <p ppunk> that the property page
                is operating on.  This is the same as <om IPropertyPage.Apply>.

        @flag   WM_PPH_HELP | Identical to <om IPropertyPage.Help>.
                The WPARAM parameter of <p pproc> contains the
                LPCOLESTR argument of <om IPropertyPage.Help>.

        @flag   WM_PPH_TRANSLATEACCELERATOR | Identical to
                <om IPropertyPage.TranslateAccelerator>.
                The WPARAM parameter of <p pproc> contains the
                LPMSG argument of <om IPropertyPage.TranslateAccelerator>.

@field  IID | iid | The interface that will be used to communicate with
        objects that the property page will operate upon.

@field  DWORD | dwUser | Arbitrary information stored by the caller of
        <f AllocPropPageHelper>.

@field  IPropertyPageSite * | psite | The frame's page site object.

@field  LPUNKNOWN * | ppunk | An array of <p cpunk> pointers to the objects
        that this property page will operate upon.  The interface ID of
        each element of <p ppunk> is actually <p iid>.  If <p cpunk>==0,
        then presumably none of the objects that the property page was
        requested to operate upon supports the interface <p iid>.

@field  int | cpunk | The number of elements in <p ppunk>.

@field  HWND | hwnd | The property page window.

@field  BOOL | fDirty | TRUE if changes to the property page have not yet
        been applied to the objects in <p ppunk>, FALSE otherwise.  (If TRUE,
        the Apply button should be visible.)

@field  BOOL | fLockDirty | If TRUE, <p fDirty> should not be changed.
        <p fLockDirty> is TRUE during initialization of the property page
        (during which time it's inappropriate to be telling the property
        page that it's dirty).

@comm   See <f AllocPropPageHelper> for more information.
*/

struct CPropPageHelper : public INonDelegatingUnknown, public IPropertyPage
{
///// non-delegating IUnknown implementation
    ULONG           m_cRef;         // object reference count
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) NonDelegatingAddRef();
    STDMETHODIMP_(ULONG) NonDelegatingRelease();

///// delegating IUnknown implementation
    LPUNKNOWN       m_punkOuter;    // controlling unknown
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv)
      { return m_punkOuter->QueryInterface(riid, ppv); }
    STDMETHODIMP_(ULONG) AddRef()
      { return m_punkOuter->AddRef(); }
    STDMETHODIMP_(ULONG) Release()
      { return m_punkOuter->Release(); }

///// IPropertyPage implementation
    PropPageHelperInfo *m_pInfo;    // object state (maintained by aggregator)
    STDMETHODIMP SetPageSite(LPPROPERTYPAGESITE pPageSite);
    STDMETHODIMP Activate(HWND hwndParent, LPCRECT lprc, BOOL bModal);
    STDMETHODIMP Deactivate();
    STDMETHODIMP GetPageInfo(LPPROPPAGEINFO pPageInfo);
    STDMETHODIMP SetObjects(ULONG cObjects, LPUNKNOWN FAR* ppunk);
    STDMETHODIMP Show(UINT nCmdShow);
    STDMETHODIMP Move(LPCRECT prect);
    STDMETHODIMP IsPageDirty();
    STDMETHODIMP Apply();
    STDMETHODIMP Help(LPCOLESTR lpszHelpDir);
    STDMETHODIMP TranslateAccelerator(LPMSG lpMsg);
};


//////////////////////////////////////////////////////////////////////////////
// PropPageHelper Construction
//

/* @func HRESULT | AllocPropPageHelper |

        Allocates a <o PropPageHelper> object which helps a control implement
        a property page.

@parm   LPUNKNOWN | punkOuter | The <i IUnknown> of the control's property page
        object.  Will be used as the controlling unknown of <o PropPageHelper>.

@parm   PropPageHelperInfo * | pInfo | Points to a <t PropPageHelperInfo>
        structure allocated within the control's property page object.
        Note that <o PropPageHelper> will hold onto a pointer to this
        structure.  These fields of <p pInfo> must be initialized by the
        caller: <p idDialog>, <p idTitle>, <p hinst>, <p pproc>, <p iid>, and
        <p dwUser>.  The other fields will be initialized by <o PropPageHelper>.

@parm   UINT | cbInfo | The size of the structure pointed to by <p punkOuter>
        (used for version checking).

@parm   LPUNKNOWN * | ppunk | Where to store a pointer to the non-delegating
        <i IUnknown> of the allocatedd <o PropPageHelper> object.  NULL is
        stored in *<p ppunk> on error.
*/
STDAPI AllocPropPageHelper(LPUNKNOWN punkOuter, PropPageHelperInfo *pInfo,
    UINT cbInfo, LPUNKNOWN *ppunk)
{
    HRESULT         hrReturn = S_OK; // function return code
    CPropPageHelper *pthis = NULL;  // allocated object

    // make sure the version of <pInfo> is compatible with this object
    if (cbInfo != sizeof(*pInfo))
        return E_INVALIDARG;

    // set <pthis> to point to new object instance
    if ((pthis = New CPropPageHelper) == NULL)
        goto ERR_OUTOFMEMORY;
    TRACE("CPropPageHelper 0x%08lx created\n", pthis);

    // initialize IUnknown state
    pthis->m_cRef = 1;
    pthis->m_punkOuter = (punkOuter == NULL ?
        (IUnknown *) (INonDelegatingUnknown *) pthis : punkOuter);

    // initialize IPropertyPage state
    pthis->m_pInfo = pInfo;

    // initialize the parts of <*m_pInfo> we are responsible for initializing
    pthis->m_pInfo->psite = NULL;
    pthis->m_pInfo->ppunk = NULL;
    pthis->m_pInfo->cpunk = 0;
    pthis->m_pInfo->hwnd = NULL;
    pthis->m_pInfo->fDirty = FALSE;
    pthis->m_pInfo->fLockDirty = FALSE;

    // return a pointer to the non-delegating IUnknown implementation
    *ppunk = (LPUNKNOWN) (INonDelegatingUnknown *) pthis;
    goto EXIT;

ERR_OUTOFMEMORY:

    hrReturn = E_OUTOFMEMORY;
    goto ERR_EXIT;

ERR_EXIT:

    // error cleanup
    if (pthis != NULL)
        Delete pthis;
    *ppunk = NULL;
    goto EXIT;

EXIT:

    // normal cleanup
    // (nothing to do)

    return hrReturn;
}


//////////////////////////////////////////////////////////////////////////////
// IUnknown Implementation
//

STDMETHODIMP CPropPageHelper::NonDelegatingQueryInterface(REFIID riid,
    LPVOID *ppv)
{
    *ppv = NULL;

#ifdef _DEBUG
    char ach[200];
    TRACE("PropPageHelper::QI('%s')\n", DebugIIDName(riid, ach));
#endif

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = (IUnknown *) (INonDelegatingUnknown *) this;
    else
    if (IsEqualIID(riid, IID_IPropertyPage))
        *ppv = (IPropertyPage *) this;
    else
        return E_NOINTERFACE;

    ((IUnknown *) *ppv)->AddRef();
    return S_OK;
}

STDMETHODIMP_(ULONG) CPropPageHelper::NonDelegatingAddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CPropPageHelper::NonDelegatingRelease()
{
    if (--m_cRef == 0L)
    {
        // free the object
        TRACE("CPropPageHelper 0x%08lx destroyed\n", this);
        SetPageSite(NULL);
        SetObjects(0, NULL);
        Delete this;
        return 0;
    }
    else
        return m_cRef;
}


//////////////////////////////////////////////////////////////////////////////
// Propery Page Dialog Procedure
//

BOOL CALLBACK PropPageHelperDlgProc(HWND hwnd, UINT uiMsg, WPARAM wParam,
    LPARAM lParam)
{
    CPropPageHelper *pthis;         // property page object
    const char *    szPropName = "this"; // property to store <pthis>
    HRESULT         hr;

    // set <pthis> to the property page object
    if ((pthis = (CPropPageHelper *) GetProp(hwnd, szPropName)) == NULL)
    {
        if ((uiMsg == WM_INITDIALOG) && (lParam != 0))
        {
            pthis = (CPropPageHelper *) lParam;
            SetProp(hwnd, szPropName, (HANDLE) pthis);
            pthis->m_pInfo->fLockDirty = TRUE;
            BOOL f = pthis->m_pInfo->pproc(hwnd, WM_INITDIALOG, wParam, lParam,
                pthis->m_pInfo, &hr);
            pthis->m_pInfo->fLockDirty = FALSE;
            return f;
        }
        else
            return FALSE;
    }

    // do nothing if this instance of this property page window
    // was only created to get information about the property page
    // (in which case NULL is passed for the last parameter of
    // CreateDialogParam())
    if (pthis == NULL)
        return FALSE;

    if (uiMsg == WM_DESTROY)
        RemoveProp(hwnd, szPropName);

    return pthis->m_pInfo->pproc(hwnd, uiMsg, wParam, lParam, pthis->m_pInfo,
        &hr);
}


//////////////////////////////////////////////////////////////////////////////
// IPropertyPage Implementation
//

STDMETHODIMP CPropPageHelper::SetPageSite(LPPROPERTYPAGESITE pPageSite)
{
    TRACE("CPropPageHelper::SetPageSite\n");

    // store new site pointer
    if (m_pInfo->psite != NULL)
        m_pInfo->psite->Release();
    m_pInfo->psite = pPageSite;
    if (m_pInfo->psite != NULL)
        m_pInfo->psite->AddRef();
    
    return S_OK;
}

STDMETHODIMP CPropPageHelper::Activate(HWND hwndParent, LPCRECT prc,
    BOOL bModal)
{
    TRACE("CPropPageHelper::Activate\n");

    // create the property page dialog box (if it doesn't exist already)
    if (m_pInfo->hwnd == NULL)
    {
        if ((m_pInfo->hwnd = CreateDialogParam(m_pInfo->hinst,
                MAKEINTRESOURCE(m_pInfo->idDialog), hwndParent,
                (DLGPROC) PropPageHelperDlgProc,
                (LPARAM) this)) == NULL)
            return E_OUTOFMEMORY;
    }

    // set the dialog box position to <prc>
    Move(prc);

    return S_OK;
}

STDMETHODIMP CPropPageHelper::Deactivate()
{
    TRACE("CPropPageHelper::Deactivate\n");
    if (m_pInfo->hwnd != NULL)
    {
        DestroyWindow(m_pInfo->hwnd);
        m_pInfo->hwnd = NULL;
    }
    return S_OK;
}

STDMETHODIMP CPropPageHelper::GetPageInfo(LPPROPPAGEINFO pPageInfo)
{
    TRACE("CPropPageHelper::GetPageInfo\n");

    // default value
    pPageInfo->pszDocString = NULL;
    pPageInfo->pszHelpFile = NULL;
    pPageInfo->dwHelpContext = 0;

    HWND hwnd = NULL;    // page window

    // temporarily create the page window so we can get information from it
    if ((hwnd = CreateDialogParam(m_pInfo->hinst,
            MAKEINTRESOURCE(m_pInfo->idDialog), GetDesktopWindow(),
            (DLGPROC) PropPageHelperDlgProc, 0)) != NULL)
    {
        TCHAR           ach[200];
        RECT            rc;
        int             cch;

        // set the <pPageInfo->size> to the dimensions of the window
        GetWindowRect(hwnd, &rc);
        pPageInfo->size.cx = rc.right - rc.left;
        pPageInfo->size.cy = rc.bottom - rc.top;

        // set the <pPageInfo->pszTitle> to the page title
        if ((cch = LoadString(m_pInfo->hinst, m_pInfo->idTitle, ach, sizeof(ach)))
            == 0)
            ach[0] = 0;
        if ((pPageInfo->pszTitle = (OLECHAR *)
                TaskMemAlloc(sizeof(OLECHAR) * (cch + 1))) != NULL)
            ANSIToUNICODE(pPageInfo->pszTitle, ach, cch + 1);

        DestroyWindow(hwnd);
    }
    else
    {
        // set defaults for <*pPageInfo>

        // random default dimensions of the window
        pPageInfo->size.cx = pPageInfo->size.cy = 300;

        // default page title. MUST be set, assigning to NULL will cause crash!
        static TCHAR szDefault[] = "Control";
        if ((pPageInfo->pszTitle = (OLECHAR *)
                TaskMemAlloc(sizeof(OLECHAR) * (sizeof(szDefault)/sizeof(TCHAR)))) != NULL)
            ANSIToUNICODE(pPageInfo->pszTitle, szDefault, sizeof(szDefault));
    }

    return S_OK;
}

STDMETHODIMP CPropPageHelper::SetObjects(ULONG cObjects, LPUNKNOWN FAR* ppunk)
{
    TRACE("CPropPageHelper::SetObjects\n");

    // release all pointers in <m_pInfo->ppunk>, then release <m_pInfo->ppunk>
    // itself
    if (m_pInfo->ppunk != NULL)
    {
        for (int ipunk = 0; ipunk < m_pInfo->cpunk; ipunk++)
            m_pInfo->ppunk[ipunk]->Release();
        Delete [] m_pInfo->ppunk;
        m_pInfo->ppunk = NULL;
        m_pInfo->cpunk = 0;
    }

    // if the caller just wanted to free the existing pointer, we're done
    if (cObjects == 0)
        return S_OK;

    // set <m_pInfo->ppunk> to an array of pointers to the controls
    // that this property page is operating on
    if ((m_pInfo->ppunk = New LPUNKNOWN [cObjects]) == NULL)
        return E_OUTOFMEMORY;
    for ( ; cObjects > 0; cObjects--, ppunk++)
    {
        if (SUCCEEDED((*ppunk)->QueryInterface(m_pInfo->iid,
            (LPVOID *) (m_pInfo->ppunk + m_pInfo->cpunk))))
            m_pInfo->cpunk++;
    }

    return S_OK;
}

STDMETHODIMP CPropPageHelper::Show(UINT nCmdShow)
{
    TRACE("CPropPageHelper::Show\n");

    if (m_pInfo->hwnd != NULL)
    {
        ShowWindow(m_pInfo->hwnd, nCmdShow);
        if ((nCmdShow == SW_SHOW) || (nCmdShow == SW_SHOWNORMAL))
            SetFocus(m_pInfo->hwnd);
    }

    return S_OK;
}

STDMETHODIMP CPropPageHelper::Move(LPCRECT prc)
{
    TRACE("CPropPageHelper::Move\n");

    if (m_pInfo->hwnd != NULL)
        SetWindowPos(m_pInfo->hwnd, NULL, prc->left, prc->top,
            prc->right - prc->left, prc->bottom - prc->top, SWP_NOZORDER);

    return S_OK;
}

STDMETHODIMP CPropPageHelper::IsPageDirty()
{
    TRACE("CPropPageHelper::IsPageDirty\n");
    return (m_pInfo->fDirty ? S_OK : S_FALSE);
}

STDMETHODIMP CPropPageHelper::Apply()
{
    TRACE("CPropPageHelper::Apply\n");
    HRESULT hr = E_NOTIMPL;
    m_pInfo->pproc(m_pInfo->hwnd, WM_PPH_APPLY, 0, 0, m_pInfo, &hr);
    return hr;
}

STDMETHODIMP CPropPageHelper::Help(LPCOLESTR lpszHelpDir)
{
    TRACE("CPropPageHelper::Help\n");
    HRESULT hr = S_FALSE;
    m_pInfo->pproc(m_pInfo->hwnd, WM_PPH_HELP, (WPARAM) lpszHelpDir, 0,
        m_pInfo, &hr);
    return hr;
}

// helper for TranslateAccelerator(...), it find out the current focused
// child control is at the end of the tab list for the property page.
//
// hwndPage: the window handle of the property page
// nCmd: GW_HWNDPREV or GW_HWNDNEXT, indicates the moving direction for tab.
//
static BOOL IsEndOfTabList(HWND hwndPage, UINT nCmd)
{
        if ((SendMessage(hwndPage, WM_GETDLGCODE, 0, 0) &
                (DLGC_WANTALLKEYS | DLGC_WANTMESSAGE | DLGC_WANTTAB)) == 0)
        {
                HWND hwnd = GetFocus();
                if (IsChild(hwndPage, hwnd))
                {
                        // Get top level child for controls with children, like combo.
                        while (GetParent(hwnd) != hwndPage)
                        {
                                hwnd = GetParent(hwnd);
                                ASSERT(IsWindow(hwnd));
                        }

            // check if at the end of the tab list
                        do
                        {
                                if ((hwnd = GetWindow(hwnd, nCmd)) == NULL)
                                        return TRUE;
                        }
                        while ((GetWindowLong(hwnd, GWL_STYLE) & 
                   (WS_DISABLED | WS_TABSTOP)) != WS_TABSTOP);
                }
        }

        return FALSE;
}

// helper for TranslateAccelerator(...), it processes key board input messages
//
// hwndPage: the window handle of the property page.
// lpMsg: the message to process.
//
static BOOL PreTranslateMessage(HWND hwndPage, LPMSG lpMsg)
{
    // Return key or Escape key.
        if ((lpMsg->message == WM_KEYDOWN) &&
                ((lpMsg->wParam == VK_RETURN) || (lpMsg->wParam == VK_ESCAPE)))
        {
                // Special case: if control with focus is an edit control with
                // ES_WANTRETURN style, let it handle the Return key.

                TCHAR szClass[10];
                HWND hwndFocus = GetFocus();
                if ((lpMsg->wParam == VK_RETURN) &&
                        (hwndFocus != NULL) && IsChild(hwndPage, hwndFocus) &&
                        (GetWindowLong(hwndFocus, GWL_STYLE) & ES_WANTRETURN) &&
                        GetClassName(hwndFocus, szClass, 10) &&
                        (lstrcmpi(szClass, _T("EDIT")) == 0))
                {
                        SendMessage(hwndFocus, WM_CHAR, lpMsg->wParam, lpMsg->lParam);
                        return TRUE;
                }

                return FALSE;
        }

    // don't translate non-input events
        if ((lpMsg->message < WM_KEYFIRST || lpMsg->message > WM_KEYLAST) &&
                (lpMsg->message < WM_MOUSEFIRST || lpMsg->message > WM_MOUSELAST))
                return FALSE;

    BOOL bHandled;

        // If it's a WM_SYSKEYDOWN, temporarily replace the hwnd in the
        // message with the hwnd of our first control, and try to handle
        // the message for ourselves.
        if ((lpMsg->message == WM_SYSKEYDOWN) && !IsChild(hwndPage, lpMsg->hwnd))
        {
                HWND hWndSave = lpMsg->hwnd;
                lpMsg->hwnd = GetWindow(hwndPage, GW_CHILD);
                bHandled = IsDialogMessage(hwndPage, lpMsg);
                lpMsg->hwnd = hWndSave;
        }
        else
        {
                bHandled = IsDialogMessage(hwndPage, lpMsg);
        }

    return bHandled;
}

STDMETHODIMP CPropPageHelper::TranslateAccelerator(LPMSG lpMsg)
{
    TRACE("CPropPageHelper::TranslateAccelerator\n");

    ASSERT(m_pInfo);
    ASSERT(IsWindow(m_pInfo->hwnd));

    HWND hwndPage = m_pInfo->hwnd; // for convience

    // let the dialog proc get a chance to process it first
    {
        HRESULT hr = E_NOTIMPL;
        m_pInfo->pproc(hwndPage, WM_PPH_TRANSLATEACCELERATOR,
            (WPARAM)lpMsg, 0, m_pInfo, &hr);

        if (hr == S_OK)
            return hr;
    }

        if (lpMsg->message == WM_KEYDOWN && lpMsg->wParam == VK_TAB &&
                GetKeyState(VK_CONTROL) >= 0)
        {
                if (IsChild(hwndPage, GetFocus()))
                {
                        // We already have the focus.  Let's determine whether we should
                        // pass focus up to the frame.

                        if (IsEndOfTabList(hwndPage, GetKeyState(VK_SHIFT) < 0 ?
                                GW_HWNDPREV : GW_HWNDNEXT))
                        {
                                // fix for default button border
                                DWORD dwDefID = (DWORD) SendMessage(hwndPage, DM_GETDEFID, 0, 0);
                                if (HIWORD(dwDefID) == DC_HASDEFID)
                                {
                                        HWND hwndDef = GetDlgItem(hwndPage, LOWORD(dwDefID));
                                        if (hwndDef != NULL && IsWindowEnabled(hwndDef))
                        SendMessage(hwndPage, WM_NEXTDLGCTL, (WPARAM)hwndDef, 1L);
                                }

                                // Pass focus to the frame by letting the page site handle
                                // this message.
                                if (m_pInfo->psite
                    && m_pInfo->psite->TranslateAccelerator(lpMsg) == S_OK)
                    return S_OK;
                        }
                }
                else
                {
                        // We don't already have the focus.  The frame is passing the
                        // focus to us.

                        HWND hwnd = GetTopWindow(hwndPage);
                        if (hwnd != NULL)
                        {
                                UINT gwInit;
                                UINT gwMove;

                                if (GetKeyState(VK_SHIFT) >= 0)
                                {
                                        // Set the focus to the first tabstop in the page.
                                        gwInit = GW_HWNDFIRST;
                                        gwMove = GW_HWNDNEXT;
                                }
                                else
                                {
                                        // Set the focus to the last tabstop in the page.
                                        gwInit = GW_HWNDLAST;
                                        gwMove = GW_HWNDPREV;
                                }

                                hwnd = GetWindow(hwnd, gwInit);
                                while (hwnd != NULL)
                                {
                    if ((GetWindowLong(hwnd, GWL_STYLE) & 
                        (WS_DISABLED | WS_TABSTOP)) == WS_TABSTOP)
                                        {
                        SendMessage(hwndPage, WM_NEXTDLGCTL, (WPARAM)hwnd, 1L);
                                                return S_OK;
                                        }
                                        hwnd = GetWindow(hwnd, gwMove);
                                }
                        }
                }
        }

    return PreTranslateMessage(hwndPage, lpMsg) ? S_OK : S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\pseudoev.cpp ===
// pseudoev.cpp
//
// Implements FirePseudoEvent and FirePseudoEventList.
//
// @doc MMCTL

#include "precomp.h"
#include "..\..\inc\mmctlg.h" // see comments in "mmctl.h"
#include "..\..\inc\ochelp.h"
#include "debug.h"

static HRESULT FireViaPseudoEventSinkService(SAFEARRAY *psa, IDispatch *pctl);


/* @func HRESULT | FirePseudoEvent |

		Fires an MM Controls pseudo-event through the SPseudoEventSink service
		if that service is available, or by sending a registered Windows
		message to a specified window.

@parm   HWND | hwnd | Window where the registered message should be sent, if
		the SPseudoEventSink service isn't available through <p pctl>.

@parm   LPCOLESTR | pochEventName | Name of the pseudo-event.  "Click", for
        example.

@parm   IDispatch * | pctl | Pointer to the caller's IDispatch interface.  The
		interface must support a "name" parameter that provides the name of the
		control.  If the interface supports the SPseudoEventSink service, the
		pseudo-event is fired using this service.  Otherwise, a registered
		window message is used.

@parm   (varying) | (arguments) | The arguments of the pseudo-event.  These
		must consist of N pairs of arguments followed by a 0 (zero value).  N
		must be less than or equal to 10.  In each pair, the first argument is
		a VARTYPE value that indicates the type of the second argument.  The
		following VARTYPE values are supported:

        @flag   VT_INT | The following argument is an int.  <f FirePseudoEvent>
                passes this as VT_I4, so this parameter should be declared as a
				Long in BASIC.

        @flag   VT_I2 | The following argument is a short.  In BASIC this
				parameter should be declared as Integer.

        @flag   VT_I4 | The following argument is a long.  In BASIC this
				parameter should be declared as Long.

        @flag   VT_R4 | The following argument is a float.  In BASIC this
				parameter should be declared as Single.

        @flag   VT_R8 | The following argument is a double.  In BASIC this
				parameter should be declared as Double.

        @flag   VT_BOOL | The following argument is a BOOL (<y not> a
				VARIANT_BOOL).  In BASIC this parameter should be declared as
				Boolean or Integer.  Note that this behavior differs slightly
				from the usual definition of VT_BOOL.

        @flag   VT_BSTR | The following argument is a BSTR or an OLECHAR *.  In
				BASIC this parameter should be declared as String.

        @flag   VT_LPSTR | The following argument is an LPSTR.
				<f FirePseudoEvent> passes this as a BSTR, so this parameter
				should be declared as a String in BASIC.  Note that this
				behavior differs from the usual definition of VT_LPSTR.

        @flag   VT_DISPATCH | The following argument is an LPDISPATCH.  In
                BASIC this parameter should be declared as an Object.

        @flag   VT_VARIANT | The following arguement is a VARIANT.  This allows
				arbitrary parameters to be passed using this function.  Note
				that this behavior differs from the usual definition of
				VT_VARIANT.

@ex		The following example fires pseudo-event named "MouseDown" with integer
		parameters 100 and 200: |

		FirePseudoEvent(m_hwndSite, OLESTR("MouseDown"), m_pdispSite,
            VT_INT, 100, VT_INT, 200, 0);
*/
HRESULT __cdecl FirePseudoEvent(HWND hwnd, LPCOLESTR oszEvName, 
	IDispatch *pctl, ...)
{
	ASSERT(IsWindow(hwnd));
	ASSERT(oszEvName != NULL);
	ASSERT(pctl != NULL);

    HRESULT         hrReturn = S_OK; // function return code

    // start processing optional arguments
    va_list args;
    va_start(args, pctl);

    hrReturn = FirePseudoEventList(hwnd, oszEvName, pctl, args);
    
    // end processing optional arguments
    va_end(args);

    return hrReturn;
}


/* @func HRESULT | FirePseudoEventList |

		Fires an MM Controls pseudo-event through the SPseudoEventSink service
		if that service is available, or by sending a registered window message
		to a specified window.

		A control container can receive pseudo-events by either implementing
		the SPseudoEventSink service on the control site, or by processing the
		registered window message.

@parm   HWND | hwnd | Window where the registered message should be sent, if
		the SPseudoEventSink service isn't available through <p pctl>.

@parm   LPCOLESTR | pochEventName | Name of the pseudo-event.  "Click", for
        example.

@parm   IDispatch * | pctl | Pointer to the caller's IDispatch interface.  The
		interface must support a "name" parameter that provides the name of the
		control.  If the interface supports the SPseudoEventSink service, the
		pseudo-event is fired using this service.  Otherwise, a registered
		window message is used.

@parm   va_list | args | The arguments to pass to the method or property.  See
		<f FirePseudoEvent> for a description of the organization of <p args>.
*/
STDAPI FirePseudoEventList(HWND hwnd, LPCOLESTR oszEvName, IDispatch *pctl,
	va_list args)
{
	ASSERT(IsWindow(hwnd));
	ASSERT(oszEvName != NULL);
	ASSERT(pctl != NULL);

    HRESULT         hrReturn = S_OK; // function return code
	SAFEARRAY *		psa = NULL;		// safearray
	const int		MAXELEM = 10;	// maximum no. arguments
	VARIANT *		pvar = NULL;	// pointer into <psa>
	int				cvar;			// number of arguments in <psa>
	SAFEARRAYBOUND	sab;

	// create the SafeArray large enough to hold the max. number of
	// pseudo-event arguments
	sab.lLbound = -1;
	sab.cElements = MAXELEM+2;
	if ((psa = SafeArrayCreate(VT_VARIANT, 1, &sab)) == NULL)
		goto ERR_OUTOFMEMORY;

	// make <pvar> point to the first element of <psa>
	if (FAILED(hrReturn = SafeArrayAccessData(psa, (LPVOID *) &pvar)))
	{
		ASSERT(NULL == pvar);
		goto ERR_EXIT;
	}

    // element -1 of <psa> is <control> argument
    V_VT(pvar) = VT_DISPATCH;
    V_DISPATCH(pvar) = pctl;
    V_DISPATCH(pvar)->AddRef();
    pvar++;

    // element 0 of <psa> is <event> argument
	if ((V_BSTR(pvar) = SysAllocString(oszEvName)) == NULL)
		goto ERR_OUTOFMEMORY;
	V_VT(pvar) = VT_BSTR;
    pvar++;

	// loop once for each optional argument
	for (cvar = 0; cvar < MAXELEM; cvar++, pvar++)
	{
		LPSTR           sz;
		OLECHAR         aoch[300];

        if ((V_VT(pvar) = va_arg(args, VARTYPE)) == 0)
            break;
		switch (pvar->vt)
		{
    		case VT_I2:
				pvar->iVal = va_arg(args, short);
				break;
			case VT_I4:
				pvar->lVal = va_arg(args, long);
				break;
			case VT_INT:
				pvar->vt = VT_I4;
				pvar->lVal = va_arg(args, int);
    			break;
			case VT_R4:
				V_R4(pvar) = va_arg(args, float);
				break;
			case VT_R8:
				V_R8(pvar) = va_arg(args, double);
				break;
			case VT_BOOL:
				V_BOOL(pvar) = (va_arg(args, BOOL) == 0 ? 0 : -1);
				break;
			case VT_BSTR:
				if ( (pvar->bstrVal = va_arg(args, LPOLESTR)) &&
					 ((pvar->bstrVal = SysAllocString(pvar->bstrVal))
															== NULL) )
				{
					goto ERR_OUTOFMEMORY;
				}
				break;
			case VT_DISPATCH:
				pvar->punkVal = va_arg(args, LPUNKNOWN);
				if (pvar->punkVal != NULL)
					pvar->punkVal->AddRef();
				break;
			case VT_VARIANT:
				VariantInit(pvar);
				if (FAILED(VariantCopy(pvar, &va_arg(args, VARIANT))))
				{
					goto ERR_EXIT;
				}
				break;
			case VT_LPSTR:
				sz = va_arg(args, LPSTR);
				pvar->vt = VT_BSTR;
				MultiByteToWideChar(CP_ACP, 0, sz, -1, aoch,
					sizeof(aoch) / sizeof(*aoch));
				if ((pvar->bstrVal = SysAllocString(aoch)) == NULL)
				{
					goto ERR_OUTOFMEMORY;
				}
				break;
			default:
				goto ERR_FAIL;
		}
	}

	// invalidate <pvar>.  (This must be done before the SafeArrayRedim call.)
	SafeArrayUnaccessData(psa);
	pvar = NULL;

	// make <psa> just large enough to hold the <cvar> arguments stored in it
	sab.cElements = cvar+2;
	if (FAILED(hrReturn = SafeArrayRedim(psa, &sab)))
		goto ERR_EXIT;

	// Try to fire the pseudo-event by using the SPseudoEventSink service.

	switch (FireViaPseudoEventSinkService(psa, pctl))
	{
		case S_OK:

			// The service was available and it worked.
			break;

		case S_FALSE:
		{
			// The service wasn't available.  Use a registered window message.

			const UINT uiMsg = RegisterWindowMessage( TEXT("HostLWEvent") );

			ASSERT(uiMsg != 0);

			if (uiMsg)
			   SendMessage( hwnd, uiMsg, (WPARAM) psa, 0 );

			break;
		}

		default:
			goto ERR_FAIL;
	}

	goto EXIT;

ERR_OUTOFMEMORY:

	hrReturn = E_OUTOFMEMORY;
	goto ERR_EXIT;

ERR_FAIL:

	hrReturn = E_FAIL;
	goto ERR_EXIT;

ERR_EXIT:

    // error cleanup
	// (nothing to do)
    goto EXIT;

EXIT:

	// invalidate <pvar> if not already invalidated
	if (pvar != NULL)
		SafeArrayUnaccessData(psa);

    // normal cleanup
	if (psa != NULL)
		SafeArrayDestroy(psa); // cleans up <varArgs> too

    return hrReturn;
}


// Try to fire the pseudo-event by using the SPseudoEventSink service.  If
// successful, S_OK is returned.  If the service isn't available, S_FALSE is
// returned.  If the service is available but a failure occurs, E_FAIL is
// returned.

HRESULT FireViaPseudoEventSinkService
(
	SAFEARRAY *psa,
	IDispatch *pctl
)
{
	ASSERT(psa != NULL);
	ASSERT(pctl != NULL);

	IServiceProvider *pIServiceProvider = NULL;
	IPseudoEventSink *pIPseudoEventSink = NULL;
	HRESULT hrReturn = S_FALSE;

	// Check whether the SPseudoEventSink service is available on the IDispatch
	// interface.

	if (
	    SUCCEEDED( pctl->QueryInterface(IID_IServiceProvider,
										(void**)&pIServiceProvider) )
		&&
		SUCCEEDED( pIServiceProvider->
		 		   QueryService(SID_SPseudoEventSink, IID_IPseudoEventSink,
				   			    (void**)&pIPseudoEventSink) )
	   )
	{
		// It's available.  Fire the pseudo-event.

		hrReturn = pIPseudoEventSink->OnEvent(psa);

		if (hrReturn != S_OK)
		{
			ASSERT(FALSE);
			hrReturn = E_FAIL;
		}
	}

	::SafeRelease( (IUnknown **)&pIServiceProvider );
	::SafeRelease( (IUnknown **)&pIPseudoEventSink );

	return (hrReturn);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\pvio.cpp ===
// pvio.cpp
//
// Implements PersistVariantIO.
//
// Important: This .cpp file assumes a zero-initializing global "new" operator.
//
// @doc MMCTL
//

#include "precomp.h"
#include "..\..\inc\mmctlg.h" // see comments in "mmctl.h"
#include "..\..\inc\ochelp.h"
#include "debug.h"


/* @func HRESULT | PersistVariantIO |

        Loads or saves a list of property name/value pairs, specified as a
        variable-length list of arguments that's formatted in the same way as
		<om IVariantIO.Persist>, to/from an <i IPropertyBag> object.

@rvalue S_OK | Success.  At least one of the variables listed in
        <p (arguments)> was written to, so the control may want to update
        itself accordingly.

@rvalue S_FALSE | None of the variables listed in <p (arguments)> were
        written to (either because the <i IVariantIO> object is in
        saving mode or because none of the properties named in
        <p (arguments)> exist in the <i IVariantIO> object.

@rvalue DISP_E_BADVARTYPE |
        One of the VARTYPE values in <p (arguments)> is invalid.

@rvalue E_FAIL | A failure occurred while reading from the property bag, other
		than "property doesn't exist."  This can happen if the caller specified
		a type to which the property bag could not coerce the property, for
		example.

@rvalue E_OUTOFMEMORY | Out of memory.

@parm	IPropertyBag * | ppb | The property bag used to load or save the
		specified properties.

@parm   DWORD | dwFlags | May contain the same flags passed to
		<om IManageVariantIO.SetMode> (e.g. VIO_ISLOADING).

@parm   (varying) | (arguments) | The names, types, and pointers to variables
        containing the properties to persist.  These must consist of a series
        of argument triples (sets of 3 arguments) followed by a NULL.
		See <om IVariantIO.Persist> for information about the format of
		these arguments.
*/
STDAPI PersistVariantIO(IPropertyBag *ppb, DWORD dwFlags, ...)
{
    HRESULT         hrReturn = S_OK; // function return code

    // start processing optional arguments
    va_list args;
    va_start(args, dwFlags);

    // fire the event with the specified arguments
    hrReturn = PersistVariantIOList(ppb, dwFlags, args);
    
    // end processing optional arguments
    va_end(args);

    return hrReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\queryhit.cpp ===
// queryhit.cpp
//
// Implements HelpQueryHitPoint.
//
// Important: This .cpp file assumes a zero-initializing global "new" operator.
//
// @doc MMCTL
//

#include "precomp.h"
#include "..\..\inc\ochelp.h"
#include "debug.h"


/* @func HRESULT | HelpQueryHitPoint |

        Helps implement <om IViewObjectEx.QueryHitPoint> on a control by
        drawing the control into a small bitmap (centered on the point
        being hit-tested) and checking if any pixels were drawn.

@parm   IViewObject * | pvo | The <i IViewObject> interface on the control
        being hit-tested.

@parm   DWORD | dwAspect | See <om IViewObjectEx.QueryHitPoint>.

@parm   LPCRECT | prcBounds | See <om IViewObjectEx.QueryHitPoint>.

@parm   POINT | ptLoc | See <om IViewObjectEx.QueryHitPoint>.

@parm   LONG | lCloseHint | See <om IViewObjectEx.QueryHitPoint>.

@parm   DWORD * | pHitResult | See <om IViewObjectEx.QueryHitPoint>.

@comm   This function helps implement <om IViewObjectEx.QueryHitPoint>
        for the object <p pvo>, by drawing <p pvo> into a small
        monochrome bitmap centered on <p ptLoc> <p pHitResult> is set to
        HITRESULT_HIT if <p ptLoc> is directly over a non-transparent
        pixel of <p pvo>; HITRESULT_CLOSE if <p ptLoc> is within
        <p lCloseHint> himetric units of a non-transparent pixel of
        <p pvo>; HITRESULT_OUTSIDE otherwise.

        In order for this function to work, <p pvo> must implement
        DVASPECT_MASK (as the first parameter to IViewObject::Draw),
        which is defined to be the same as DVASPECT_CONTENT except
        that non-transparent parts of the object are drawn black, and
        transparent parts are either left untouched or drawn in
        white.
*/
STDAPI HelpQueryHitPoint(IViewObject *pvo, DWORD dwAspect, LPCRECT prcBounds,
    POINT ptLoc, LONG lCloseHint, DWORD *pHitResult)
{
    HRESULT         hrReturn = S_OK; // function return code
    HBITMAP         hbm = NULL;     // bitmap to draw into
    HDC             hdc = NULL;     // DC onto <hbm>
    int             xyCloseHint;    // <lCloseHint> converted to pixels
    WORD *          pwBits = NULL;  // bits (pixels) of <hbm>
    int             cwBits;         // number of WORDs in <pwBits>
    int             cx, cy;         // width and height of test bitmap
    SIZE            size;
    WORD *          pw;
    int             cw;
    COLORREF        rgb;

    // default <pHitResult> to "missed"
    *pHitResult = HITRESULT_OUTSIDE;

    // set <xyCloseHint> to <lCloseHint> converted to pixels
    HIMETRICToPixels(lCloseHint, 0, &size);
    xyCloseHint = size.cx;

    // we're going to get the control to paint itself black into a <cx> by <cy>
    // pixel bitmap (centered over <ptLoc>) that's initially white, then we'll
    // test to see if there are any black pixels in the bitmap; we'll make
    // the width of the test bitmap be a multiple of 16 pixels wide to simplify
    // the GetBitmapBits() call
    if ((cx = ((2 * xyCloseHint + 15) >> 4) << 4) == 0)
        cx = 16;
    if ((cy = 2 * xyCloseHint) == 0)
        cy = 16;

    // create a monochrome bitmap <hbm> to draw the control into; the bitmap
    // only has to be large enough to contain the area within <xyCloseHint>
    // pixels of <ptLoc>
    if ((hbm = CreateBitmap(cx, cy, 1, 1, NULL)) == NULL)
        goto ERR_OUTOFMEMORY;

    // select <hbm> into DC <hdc>
    if ((hdc = CreateCompatibleDC(NULL)) == NULL)
        goto ERR_OUTOFMEMORY;
    if (SelectObject(hdc, hbm) == NULL)
        goto ERR_FAIL;

    // fill the bitmap with white, since the IViewObject::Draw call below
    // will draw the object using black pixels
    if (!(PatBlt(hdc, 0, 0, cx, cy, WHITENESS)))
		goto ERR_FAIL;

    // adjust the origin so that <ptLoc> lines up with the center of
    // the bitmap, and make the clipping rectangle only include
    // the area we want to hit-test
    if (!(SetWindowOrgEx(hdc, ptLoc.x - xyCloseHint, ptLoc.y - xyCloseHint,
																	NULL)))
		goto ERR_FAIL;

    if (ERROR == IntersectClipRect(hdc, ptLoc.x - xyCloseHint,
	    ptLoc.y - xyCloseHint, ptLoc.x + xyCloseHint, ptLoc.y + xyCloseHint))
		goto ERR_FAIL;

    // draw the control into the bitmap
    if (FAILED(hrReturn = pvo->Draw(DVASPECT_MASK, -1, NULL, NULL, NULL, hdc,
            (LPCRECTL) prcBounds, NULL, NULL, 0)))
        goto ERR_EXIT;

#if 0
#ifdef _DEBUG
    // for debugging purposes, draw <hbm> to the top-left corner
    // of the screen
    {
        HDC hdcScreen = GetDC(NULL);
		ASSERT( hdcScreen );
        BitBlt(hdcScreen, 0, 0, cx, cy,
            hdc, ptLoc.x - xyCloseHint, ptLoc.y - xyCloseHint, SRCCOPY);
        ReleaseDC(NULL, hdcScreen);
    }
#endif	// _DEBUG
#endif	// #if 0

    if (CLR_INVALID == (rgb = GetPixel(hdc, ptLoc.x, ptLoc.y)))
	    goto ERR_FAIL;

    if (rgb == RGB(0, 0, 0))
    {
        // <ptLoc> is directly over a non-transparent part
        // of the control
        *pHitResult = HITRESULT_HIT;
        goto EXIT;
    }

    // if the caller only wanted to check for a direct hit, we're done
    if (xyCloseHint == 0)
        goto EXIT;

    // get the pixels of <hbm> and see if they contain any black pixels
    cwBits = (cx >> 4) * cy;
    if ((pwBits = (WORD *) TaskMemAlloc(cwBits * 2)) == NULL)
        goto ERR_OUTOFMEMORY;
    if (GetBitmapBits(hbm, cwBits * 2, pwBits) != cwBits * 2)
        goto ERR_FAIL;
    for (pw = pwBits, cw = cwBits; cw > 0; pw++, cw--)
    {
        if (*pw != 0xFFFF)
        {
            // black pixel found -- <ptLoc> is within <xyCloseHint>
            // pixels of a non-transparent part of the control
            *pHitResult = HITRESULT_CLOSE;
            goto EXIT;
        }
    }

    // <ptLoc> is nowhere near the control
    goto EXIT;

ERR_FAIL:

    hrReturn = E_FAIL;
    goto ERR_EXIT;

ERR_OUTOFMEMORY:

    hrReturn = E_OUTOFMEMORY;
    goto ERR_EXIT;

ERR_EXIT:

    // error cleanup
    // (nothing to do)
	ASSERT(FALSE);
    goto EXIT;

EXIT:

    // normal cleanup
	if (hdc != NULL)
		DeleteDC(hdc);
    if (hbm != NULL)
        DeleteObject(hbm);
    if (pwBits != NULL)
        TaskMemFree(pwBits);

#ifdef _DEBUG
	if (HITRESULT_OUTSIDE == *pHitResult)
	{
		// TRACE( "QueryHitPoint: 'outside'\n" );
	}
#endif	// _DEBUG

    return hrReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//
//#define VERSIONFLAGS                    0

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\reg.cpp ===
// reg.cpp
//
// Implements RegisterControls.
//
// Important: This .cpp file assumes a zero-initializing global "new" operator.
//
// @doc MMCTL
//

#include "precomp.h"
#include <comcat.h>				// ICatRegister, etc.
#include "..\..\inc\ochelp.h"
#include "..\..\inc\mmctlg.h"	// CATID_MMControl
#include "..\..\inc\catid.h"	// CATID_Safe...
#include "debug.h"


//****************************************************************************
//*  Defines
//*
//*  @doc None
//****************************************************************************

#define GUID_CCH  39  // Characters in string form of a GUID, including '\0'.

#define ARRAY_SIZE(Array) \
	( sizeof(Array) / sizeof( Array[0] ) )


//****************************************************************************
//*  Structures
//*
//*  @doc MMCTL
//****************************************************************************

/* @struct ControlInfo |

        Contains information used by <f RegisterControls> to register and
        unregister a control.

@field  UINT | cbSize | The size of this structure (used for version
        control).  Must be set to sizeof(ControlInfo).

@field  LPCTSTR | tszProgID | The ProgID of the object, e.g.
        "MYCTLLIB.TinyCtl.1".

@field  LPCTSTR | tszFriendlyName | The human-readable name of the object
        (at most 40 characters or so), e.g. "My Control".

@field  const CLSID * | pclsid | Points to the class ID of the object.

@field  HMODULE | hmodDLL | The module handle of the DLL implementing the
        object.

@field  LPCTSTR | tszVersion | The version number of the object, e.g. "1.0".

@field  int | iToolboxBitmapID | The resource ID of the toolbox bitmap of
        the object, if the object is a control.  The resource must be located
        in the same DLL specified by <p tszDLLPath> and/or <p hmodDLL>.
        If <p iToolboxBitmapID> is -1, it is ignored.

@field  DWORD | dwMiscStatusDefault | The MiscStatus bits (OLEMISC_XXX)
        to use for all display apsects except DVASPECT_CONTENT.  Typically 0.

@field  DWORD | dwMiscStatusContent | The MiscStatus bits (OLEMISC_XXX)
        to use for display aspect DVASPECT_CONTENT.  See the example below.

@field  GUID * | pguidTypeLib | The object's type library GUID, or NULL if
        the object doesn't have a type library.

@field  AllocOCProc * | pallocproc | Function which can allocate an instance
        of the OLE control and return an <f AddRef>'d <i IUnknown> pointer
        to it.

@field  ULONG * | pcLock | Points to a DLL lock count variable defined as a
        global variable in your DLL.  This global variable maintains a count
        of locks used by <om IClassFactory.LockServer>.  To increment or
		decrement this lock count, use <f InterlockedIncrement> and
		<f InterlockedDecrement> instead of modifying it directly.  This will
		ensure that access to the lock count is synchronized between your
		control's server and the OCHelp-supplied class factory.

@field  DWORD | dwFlags | Zero or more of the following:

        @flag   CI_INSERTABLE | Marks the COM object as "Insertable".  Probably
                should not be used for ActiveX controls.

        @flag   CI_CONTROL | Marks the COM object as a "Control".  Probably
                should not be used for ActiveX controls.

		@flag	CI_MMCONTROL | Marks the COM object as a "Multimedia Control".

		@flag	CI_SAFEFORSCRIPTING | Marks the COM object as "safe-for-scripting"
				meaning that the object promises that, no matter how malicious a
				script is, the object's automation model does not allow any harm
				to the user, either in the form of data corruption or security leaks.
				If a control is not "safe-for-scripting", the user will receive a warning
				dialog whenever the control is inserted on an untrusted page in
				Internet Explorer (IE), asking whether the object should be visible from scripts.
				(This is only at medium security level, at high security, the object
				is never visible to scripts, and at low, always visible.)  If a
				control, C1, can potentially contain another control, C2, which might
				be unsafe, then C1 should probably not declare itself "safe-for-scripting".

		@flag	CI_SAFEFORINITIALIZING | Marks the COM object as "safe-for-initializing"
				meaning that it guarantees to do nothing bad regardless of the data with
				which it is initialized.  From IE, the user will be given a warning
				dialog (described above) if an untrusted page attempts to initialize
				a control that is not "safe-for-initializing".

		@flag	CI_NOAPARTMENTTHREADING | By default, <f RegisterControls> will register
				a control as "apartment-aware".  If this flag is set, the control will
				*not* be registered as apartment-aware.

        @flag   CI_DESIGNER | Marks the COM object as an "Active Designer" (i.e., the
                object supports IActiveDesigner).

@field  ControlInfo* | pNext | A pointer to a <p ControlInfo> struct for the next
        control that <f RegisterControls> should register.  Use this field to
        chain together a linked-list of all the controls that <f RegisterControls>
        should register.  <p pNext> should set to NULL for the last <p ControlInfo>
        struct in the list.

@field  UINT | uiVerbStrID | A string resource ID.  The string is a definition
        of an OLE verb applicable to the control.  The string is assumed to
        have the following format:

            \<verb_number>=\<name>, \<menu_flags>, \<verb_flags>

        See help on <om IOleObject.EnumVerbs> for a description of each field.
        <f RegisterControls> will call <f LoadString> to read all the
        consecutively-numbered string resources beginning with <p uiVerbStrID>
        until either <f LoadString> fails (i.e., the resource doesn't exist) or
        an empty string is returned.  <f RegisterControls> will
        register/unregister each verb string it reads.

@comm   This structure is used by <f RegisterControls> and
        <f HelpCreateClassObject>.

        <y Important\:> The objects pointed to by pointer fields of
        <p ControlInfo> must be defined statically in the DLL, since functions
        that use <p ControlInfo> holds onto this pointer.  This can be
        accomplished by making <p ControlInfo> and all the data it points to
        be global variables/literals in your DLL.
*/


// Information about the component categories that need to be added to the
// registry under the "HKCR\Component Categories" key.

struct CatInfo
{
	const CATID *pCatID;    // Category ID.
	LPCTSTR szDescription;  // Category description.
};

// Information about the component categories that may need to be registered
// for a single control.

struct CatInfoForOneControl
{
	DWORD dwFlagToCheck;  // The CI_ flag to check to determine whether the
						  //  category should be registered for the control.
						  // (CI_CONTROL, for example.)
	const CATID *pCatID;  // The Category ID to register.
};


//****************************************************************************
//*  Prototypes for private helper functions
//*
//*  @doc None
//****************************************************************************

static HRESULT _RegisterOneControl(const ControlInfo *pControlInfo,
								   ICatRegister *pCatRegister);
static BOOL _UnregisterOneControl(const ControlInfo *pControlInfo);
static BOOL _RegisterTypeLib(const ControlInfo *pControlInfo);
static BOOL _UnregisterTypeLib(const ControlInfo *pControlInfo);
static BOOL _LoadTypeLib(const ControlInfo *pControlInfo, ITypeLib **ppTypeLib);
static BOOL _SetComponentCategories(const CatInfoForOneControl
									  *pCatInfoForOneControl,
									int iEntries, ICatRegister *pCatRegister,
									const ControlInfo *pControlInfo);
static BOOL _TCHARFromGUID2(const GUID *pGUID, TCHAR *ptchGUID);
static BOOL _GetUnicodeModuleName(const ControlInfo *pControlInfo,
								  OLECHAR *pochModule);

static TCHAR* _lstrchr(const TCHAR* sz, const TCHAR ch);
static HRESULT _SetRegKey(LPCTSTR tszKey, LPCTSTR tszSubkey, LPCTSTR tszValue);
static HRESULT _SetRegKeyValue(LPCTSTR szKey, LPCTSTR szSubkey,
							   LPCTSTR szValueName, LPCTSTR szValue);
static void _DelRegKeyValue(LPCTSTR szKey, LPCTSTR szSubkey,
							LPCTSTR szValueName);

static BOOL RegDeleteTreeSucceeded(LONG error);
static void UnregisterInterfaces(ITypeLib* pTypeLib);


//****************************************************************************
//*  Public functions
//*
//*  @doc MMCTL
//****************************************************************************

/* @func HRESULT | RegisterControls |

        Registers or unregisters one or more controls.  Helps implement
        <f DllRegisterServer> and <f DllUnregisterServer>.

@rvalue S_OK |
        Success.

@rvalue E_FAIL |
        The operation failed.

@parm   ControlInfo * | pctlinfo | Information about the control that's
        being registered or unregistered.  See <t ControlInfo> for more
        information.

@parm   DWORD | dwAction | Must be one of the following:

        @flag   RC_REGISTER | Registers the control.

        @flag   RC_UNREGISTER | Unregisters the control.

@comm   You can register more than one control by making a linked list
        out of your <t ControlInfo> structures -- set each <p pNext>
        field to the next structure, and set the last <p pNext> to NULL.

		All controls which are registered by this function are registered
		as "safe for scripting" and "safe for initializing".

@ex     The following example shows how to implement <f DllRegisterServer>
        and <f DllUnregisterServer> using <f RegisterControls>. |

        STDAPI DllRegisterServer(void)
        {
            return RegisterControls(&g_ctlinfo, RC_REGISTER);
        }

        STDAPI DllUnregisterServer(void)
        {
            return RegisterControls(&g_ctlinfo, RC_UNREGISTER);
        }
*/


// Information about the component categories that need to be added to the
// registry under the "HKCR\Component Categories" key.

static const CatInfo aCatInfo[] =
{
	{ &CATID_Insertable,		   _T("Insertable") },
	{ &CATID_Control,			   _T("Control") },
	{ &CATID_MMControl,			   _T("MMControl") },
	{ &CATID_SafeForScripting2,    _T("Safe for scripting") },
	{ &CATID_SafeForInitializing2, _T("Safe for initializing") },
};


STDAPI
RegisterControls
(
	ControlInfo *pControlInfo,
	DWORD dwAction
)
{
	ASSERT(pControlInfo != NULL);
	ASSERT(RC_REGISTER == dwAction || RC_UNREGISTER == dwAction);

	HRESULT hr = S_OK;
	ICatRegister *pCatRegister = NULL;
	CATEGORYINFO CategoryInfo;
	const BOOL bRegister = (RC_REGISTER == dwAction);
	int i;

	// Since the function is most likely called directly from a control's
	// DllRegisterServer or DllUnRegisterServer, OLE has probably not been
	// initialized.  Initialize it now.

	::OleInitialize(NULL);

	// Get the component category manager.

	if ( FAILED( ::CoCreateInstance(CLSID_StdComponentCategoriesMgr, NULL,
								    CLSCTX_INPROC_SERVER, IID_ICatRegister,
								    (void**)&pCatRegister) ) )
	{
		ASSERT(FALSE);
		goto ERR_EXIT;
	}

	// Register all the component categories in the aCatInfo array.

	CategoryInfo.lcid = LOCALE_SYSTEM_DEFAULT;

	for (i = 0; i < ARRAY_SIZE(aCatInfo); i++)
	{
		// Fill in the CATEGORYINFO array.

		CategoryInfo.catid = *aCatInfo[i].pCatID;

		#ifdef UNICODE
		::lstrcpy(CategoryInfo.szDescription, aCatInfo[i].szDescription);
		#else
		::ANSIToUNICODE( CategoryInfo.szDescription, aCatInfo[i].szDescription,
					     ARRAY_SIZE(CategoryInfo.szDescription) );
		#endif

		// Register the category.

		if ( FAILED( pCatRegister->RegisterCategories(1, &CategoryInfo) ) )
		{
			ASSERT(FALSE);
			goto ERR_EXIT;
		}
	}

    // Register or unregister each control in the linked list "pControlInfo".

    for ( ; pControlInfo != NULL; pControlInfo = pControlInfo->pNext)
    {
		if (bRegister)
		{
			if ( FAILED( ::_RegisterOneControl(pControlInfo, pCatRegister) ) )
				goto ERR_EXIT;
		}
		else
		{
			if ( !::_UnregisterOneControl(pControlInfo) )
				goto ERR_EXIT;
		}
    }

EXIT:

	::SafeRelease( (IUnknown **)&pCatRegister );
	::OleUninitialize();
    return (hr);

ERR_EXIT:

	hr = E_FAIL;
	goto EXIT;
}


//****************************************************************************
//*  Private helper functions
//*
//*  @doc None
//****************************************************************************

// Information about the component categories that may need to be registered
// for a single control.

static const CatInfoForOneControl aCatInfoForOneControl[] =
{
	{CI_INSERTABLE, 		 &CATID_Insertable},
	{CI_CONTROL, 			 &CATID_Control},
	{CI_MMCONTROL, 			 &CATID_MMControl},
	{CI_DESIGNER, 			 &CATID_Designer},
	{CI_SAFEFORSCRIPTING,    &CATID_SafeForScripting2},
	{CI_SAFEFORINITIALIZING, &CATID_SafeForInitializing2},
};


/*----------------------------------------------------------------------------
	@func BOOL | _RegisterOneControl |
	
	Register a single control.

	@rvalue TRUE | The control was registered.
	@rvalue FALSE | An error occurred.

	@contact Tony Capone
  ----------------------------------------------------------------------------*/

HRESULT
_RegisterOneControl
(
	const ControlInfo *pControlInfo,  // @parm  Information structure for the
									  //         control.
	ICatRegister *pCatRegister		  // @parm  Pointer to the component
									  //		 category manager.
)
{
	ASSERT(pControlInfo != NULL);
	ASSERT(pCatRegister != NULL);

    TCHAR atchCLSID[GUID_CCH];
    TCHAR atchCLSIDKey[100];
    TCHAR atchModule[_MAX_PATH];
    TCHAR atch[400];
    TCHAR atch2[100];
	HRESULT hr = S_OK;


	//***************************************************
	//*  Setup
	//***************************************************

    // Check the cbSize field for the correct version.

    if ( pControlInfo->cbSize != sizeof(*pControlInfo) )
    {
		ASSERT(FALSE);
        goto ERR_EXIT;
    }

	// Convert the CLSID to a Unicode or ANSI string and store it in atchCLSID.
    // Example: {1C0DE070-2430-...}"

	if ( !::_TCHARFromGUID2(pControlInfo->pclsid, atchCLSID) )
    {
		ASSERT(FALSE);
        goto ERR_EXIT;
    }

	// Store "CLSID\<clsid>", in atchCLSIDKey.
    // Example: "CLSID\{1C0DE070-2430-...}"

	::wsprintf(atchCLSIDKey, _T("CLSID\\%s"), atchCLSID);

	// Store the module name in atchModule.
    // Example: "C:\Temp\MyCtl.ocx"

    ASSERT(pControlInfo->hmodDLL != NULL);

    if (NULL == pControlInfo->hmodDLL ||
		::GetModuleFileName( pControlInfo->hmodDLL, atchModule,
							 ARRAY_SIZE(atchModule) ) == 0)
	{
		ASSERT(FALSE);
        goto ERR_EXIT;
	}


	//***************************************************
	//*  ProgID entries
	//***************************************************

    // Set "<tszProgID>=<tszFriendlyName>".
    // Example: "MyCtl.MyCtl.1=My Control"

    if ( FAILED( ::_SetRegKey(pControlInfo->tszProgID, NULL,
						      pControlInfo->tszFriendlyName) ) )
	{
		ASSERT(FALSE);
		goto ERR_EXIT;
	}

    // Set "<tszProgID>\CLSID=<clsid>"
    // Example: "MyCtl.MyCtl.1\CLSID={1C0DE070-2430-...}"

    if ( FAILED( ::_SetRegKey(pControlInfo->tszProgID, _T("\\CLSID"),
						      atchCLSID) ) )
	{
		ASSERT(FALSE);
        goto ERR_EXIT;
	}

    // Set "<tszProgID>\Insertable" so that control shows up in
	// OleUIInsertObject dialog on Trident on Win 95.  Not needed on NT.

    if (pControlInfo->dwFlags & CI_INSERTABLE)
    {
        if ( FAILED( ::_SetRegKey( pControlInfo->tszProgID, _T("\\Insertable"),
							       _T("") ) ) )
	    {
		    ASSERT(FALSE);
            goto ERR_EXIT;
	    }
    }
    else
    {
        /*
            To ensure that control which are marked not insertable do not have an
            Insertable key because they had been marked insertable previously, we
            delete the Insertable subkey if it exists
        */

        TCHAR tchRegKey[256];

        if (pControlInfo->tszProgID && (lstrlen(pControlInfo->tszProgID) > 0))
        {
            ::wsprintf(tchRegKey, _T("%s\\Insertable"), pControlInfo->tszProgID);
#ifdef _DEBUG
            LONG lRet =
#endif // _DEBUG
                ::RegDeleteKey(HKEY_CLASSES_ROOT, tchRegKey);

#ifdef _DEBUG
            ASSERT((ERROR_SUCCESS == lRet) || (ERROR_FILE_NOT_FOUND == lRet));
#endif // _DEBUG
        }
    }


	//***************************************************
	//*  CLSID entries
	//***************************************************

    // Set "CLSID\<clsid>=<tszFriendlyName>".
    // Example: "CLSID\{1C0DE070-2430-...}=My Control"

    if ( FAILED( ::_SetRegKey(_T("CLSID\\"), atchCLSID,
						      pControlInfo->tszFriendlyName) ) )
	{
		ASSERT(FALSE);
		goto ERR_EXIT;
	}

    // Set "CLSID\<clsid>\ProgID=<tszProgID>".
    // Example: "CLSID\{1C0DE070-2430-...}\ProgID=MyCtl.MyCtl.1"

    // Set "CLSID\<clsid>\InprocServer32=<atchModule>".
    // Example "CLSID\{1C0DE070-2430-...}\InprocServer32="C:\Temp\MyCtl.ocx".

    if ( FAILED( ::_SetRegKey(atchCLSIDKey, _T("\\ProgID"),
							  pControlInfo->tszProgID) )
		 ||
    	 FAILED( ::_SetRegKey(atchCLSIDKey, _T("\\InprocServer32"),
		 					  atchModule) ) )
	{
		ASSERT(FALSE);
        goto ERR_EXIT;
	}

	// Add the named value "ThreadingModel=Apartment" under the
	// "InprocServer32" key.

	if (pControlInfo->dwFlags & CI_NOAPARTMENTTHREADING)
	{
		_DelRegKeyValue( atchCLSIDKey, _T("InprocServer32"),
						 _T("ThreadingModel") );
	}
	else if ( FAILED( ::_SetRegKeyValue( atchCLSIDKey, _T("InprocServer32"),
									    _T("ThreadingModel"),
									    _T("Apartment") ) ) )
	{
		ASSERT(FALSE);
		goto ERR_EXIT;
	}

	// Set "CLSID\<clsid>\Version=<tszVersion>".
	// Example: "CLSID\{1C0DE070-2430-...}\Version=1.0"

    if ( pControlInfo->tszVersion != NULL &&
         FAILED( ::_SetRegKey(atchCLSIDKey, _T("\\Version"),
		 				     pControlInfo->tszVersion) ) )
    {
		ASSERT(FALSE);
		goto ERR_EXIT;
    }

    if (pControlInfo->iToolboxBitmapID >= 0)
    {
        // Set "CLSID\<clsid>\ToolboxBitmap32=<atchModule>, <iToolboxBitmapID>".
        // Example:
		//   "CLSID\{1C0DE070-2430-...}\ToolboxBitmap32=C:\Temp\MyCtl.ocx, 1"

        ::wsprintf(atch, "%s, %u", atchModule, pControlInfo->iToolboxBitmapID);

        if ( FAILED( ::_SetRegKey(atchCLSIDKey, _T("\\ToolboxBitmap32"),
								  atch) ) )
		{
			ASSERT(FALSE);
            goto ERR_EXIT;
		}
    }

	if ( (pControlInfo->dwMiscStatusDefault != 0) ||
		 (pControlInfo->dwMiscStatusContent != 0) )
    {
        // Set "CLSID\<clsid>\MiscStatus=<dwMiscStatusDefault>".
        // Example:
		//   "CLSID\{1C0DE070-2430-...}\MiscStatus=<dwMiscStatusDefault>"

        :: wsprintf(atch, "%lu", pControlInfo->dwMiscStatusDefault);

        if ( FAILED( ::_SetRegKey(atchCLSIDKey, _T("\\MiscStatus"), atch) ) )
		{
			ASSERT(FALSE);
			goto ERR_EXIT;
		}
    }

    if (pControlInfo->dwMiscStatusContent != 0)
    {
        // Set "CLSID\<clsid>\MiscStatus\1=<dwMiscStatusContent>".
        // Example: "CLSID\{1C0DE070-2430-...}\MiscStatus\1=132497"

        :: wsprintf(atch, "%lu", pControlInfo->dwMiscStatusContent);

        if ( FAILED( ::_SetRegKey(atchCLSIDKey, _T("\\MiscStatus\\1"), atch) ) )
            goto ERR_EXIT;
    }


	//***************************************************
	//*  Component category entries
	//***************************************************

    if (pControlInfo->dwFlags & CI_INSERTABLE)
    {
        // Set "CLSID\<clsid>\Insertable".
        // Example: "CLSID\{1C0DE070-2430-...}\Insertable"

        if ( FAILED( ::_SetRegKey(atchCLSIDKey, _T("\\Insertable"), "") ) )
		{
			ASSERT(FALSE);
            goto ERR_EXIT;
		}
	}

    if (pControlInfo->dwFlags & CI_CONTROL)
    {
        // Set "CLSID\<clsid>\Control".
        // Example: "CLSID\{1C0DE070-2430-...}\Control"

        if ( FAILED( ::_SetRegKey(atchCLSIDKey, _T("\\Control"), "") ) )
		{
			ASSERT(FALSE);
            goto ERR_EXIT;
		}
    }

	// Make sure that the class is registered "safe-for-scripting" or "safe-
	// for-initializing" only if it declares that it is.

	pCatRegister->
	  UnRegisterClassImplCategories(*pControlInfo->pclsid, 1,
	  								(CATID*)&CATID_SafeForScripting2);
	pCatRegister->
	  UnRegisterClassImplCategories(*pControlInfo->pclsid, 1,
	  							    (CATID*)&CATID_SafeForInitializing2);

	// Set the component categories indicated by pControlInfo->dwFlags.

	if ( !_SetComponentCategories(aCatInfoForOneControl,
								  ARRAY_SIZE(aCatInfoForOneControl),
								  pCatRegister, pControlInfo) )
	{
		ASSERT(FALSE);
		goto ERR_EXIT;
	}


	//***************************************************
	//*  Verb entries
	//***************************************************

    // Form a key of the form, "CLSID\<clsid>\Verb".

    ::lstrcpy(atch, atchCLSIDKey);
    ::lstrcat(atch, _T("\\Verb"));

    // Unregister any verbs currently associated with the control.

    if ( !RegDeleteTreeSucceeded( RegDeleteTree(HKEY_CLASSES_ROOT, atch) ) )
	{
		ASSERT(FALSE);
		goto ERR_EXIT;
	}

    // Register the control's verbs.

    if (pControlInfo->uiVerbStrID != 0)
    {

		// Set "CLSID\<clsid>\Verb".

		if ( FAILED( ::_SetRegKey(atch, NULL, "") ) )
		{
			ASSERT(FALSE);
			goto ERR_EXIT;
		}

        // Iterate through the consecutively numbered string resources
        // corresponding to the control's verbs.

        atch2[0] = _T('\\');

        for (UINT resid = pControlInfo->uiVerbStrID; TRUE; resid++)
        {
            // Load the string.

            if (LoadString(pControlInfo->hmodDLL, resid, atch2 + 1,
                           ARRAY_SIZE(atch2) - 2) == 0)
            {
                break;
            }

            // Parse out the key and value.

            TCHAR* ptchValue = _lstrchr(atch2, _T('='));

            if (ptchValue == NULL)
            {
                break;
            }

            *ptchValue = _T('\0');
            ptchValue++;

            if (*ptchValue == _T('\0'))
            {
                break;
            }

            // Register the key.

            if ( FAILED( ::_SetRegKey(atch, atch2, ptchValue) ) )
			{
				ASSERT(FALSE);
                goto ERR_EXIT;
			}
        }

    }


	//***************************************************
	//*  Type library entries
	//***************************************************

    if ( pControlInfo->pguidTypeLib != NULL)
	{
		TCHAR atchLIBID[GUID_CCH];

		// Convert the LIBID to an ANSI or Unicode string and store it in
		// atchLIBID.
		//
        // Set "CLSID\<clsid>\TypeLib=<*pguidTypeLib>"
        // Example: "CLSID\{1C0DE070-2430-...}\TypeLib={D4DBE870-2695-...}"
		//
		// Register the type library.

		if ( !::_TCHARFromGUID2(pControlInfo->pguidTypeLib, atchLIBID) ||
             FAILED( ::_SetRegKey(atchCLSIDKey, _T("\\TypeLib"), atchLIBID) ) ||
		     !::_RegisterTypeLib(pControlInfo) )
		{
			ASSERT(FALSE);
			goto ERR_EXIT;
		}
	}

EXIT:

    return hr;

ERR_EXIT:

    TRACE("RegisterControls FAILED!\n");
	hr = E_FAIL;
	goto EXIT;
}


/*----------------------------------------------------------------------------
	@func BOOL | _UnregisterOneControl |
	
	Unregister a single control.

	@rvalue TRUE | The control was unregistered.
	@rvalue FALSE | An error occurred.

	@contact Tony Capone
  ----------------------------------------------------------------------------*/

BOOL
_UnregisterOneControl
(
	const ControlInfo *pControlInfo  // @parm  Information structure for the
									 //         control.
)
{
	TCHAR atchCLSID[GUID_CCH];
	TCHAR szKey[_MAX_PATH];
	BOOL bRetVal = TRUE;

	// Convert the CLSID to a Unicode or ANSI string.

	if ( !::_TCHARFromGUID2(pControlInfo->pclsid, atchCLSID) )
	{
		ASSERT(FALSE);
		goto ERR_EXIT;
	}

	// Recursively delete the key "CLSID\<clsid>".
    // Example: "CLSID\{1C0DE070-2430-...}"

	::wsprintf(szKey, _T("CLSID\\%s"), atchCLSID);

    if ( !RegDeleteTreeSucceeded(
	       RegDeleteTree(HKEY_CLASSES_ROOT, szKey) ) )
	{
		ASSERT(FALSE);
		goto ERR_EXIT;
	}

    // Recursively delete the ProgID "<tszProgID>".
    // Example: "MyCtl.MyCtl.1"

	if ( pControlInfo->tszProgID != NULL &&
		 !RegDeleteTreeSucceeded(
		   RegDeleteTree(HKEY_CLASSES_ROOT, (LPTSTR)pControlInfo->tszProgID) ) )
	{
		ASSERT(FALSE);
		goto ERR_EXIT;
	}

	// Unregister the type library, if there is one.

    if ( pControlInfo->pguidTypeLib != NULL &&
		 !::_UnregisterTypeLib(pControlInfo) )
	{
		ASSERT(FALSE);
		goto ERR_EXIT;
	}

EXIT:

	return (bRetVal);

ERR_EXIT:

	bRetVal = FALSE;
	goto EXIT;
}


/*----------------------------------------------------------------------------
	@func BOOL | _RegisterTypeLib |
	
	Register the type library indicated by "pControlInfo".

	@comm
	This will fail if the module indicated by pControlInfo->hmodDLL doesn't
	contain a type library.  You can check for this before calling this
	function by looking at pControlInfo->pguidTypeLib, which should be NULL if
	there is no type library.

	@rvalue TRUE | The type library was registered.
	@rvalue FALSE | An error occurred.

	@contact Tony Capone
  ----------------------------------------------------------------------------*/

BOOL
_RegisterTypeLib
(
	const ControlInfo *pControlInfo  // @parm  Information structure for the
									 //         control.
)
{
	ITypeLib *pTypeLib = NULL;
	OLECHAR aochModule[_MAX_PATH];
	BOOL bRetVal = TRUE;

	// Load and register the type library.

	if ( !::_LoadTypeLib(pControlInfo, &pTypeLib) ||
		 !_GetUnicodeModuleName(pControlInfo, aochModule) ||
		 FAILED( ::RegisterTypeLib(pTypeLib, aochModule, NULL) ) )
	{
		ASSERT(FALSE);
		goto ERR_EXIT;
	}

EXIT:

	::SafeRelease( (IUnknown **)&pTypeLib );
    return (bRetVal);

ERR_EXIT:

	bRetVal = FALSE;
	goto EXIT;
}


/*----------------------------------------------------------------------------
	@func BOOL | _UnregisterTypeLib |
	
	Unregister the type library indicated by "pControlInfo".

	@comm
	This will fail if the module indicated by pControlInfo->hmodDLL doesn't
	contain a type library.  You can check for this before calling this
	function by looking at pControlInfo->pguidTypeLib, which should be NULL if
	there is no type library.

	@rvalue TRUE | The type library was unregistered.
	@rvalue FALSE | An error occurred.

	@contact Tony Capone
  ----------------------------------------------------------------------------*/

BOOL
_UnregisterTypeLib
(
	const ControlInfo *pControlInfo  // @parm  Information structure for the
									 //         control.
)
{
    TCHAR atchLIBID[GUID_CCH];
    TCHAR atchLIBIDKey[100];
	BOOL bRetVal = TRUE;
	ITypeLib *pTypeLib = NULL;

	// There is an UnRegisterTypeLib function in the OleAut32 DLL that
	// complements the RegisterTypeLib function in the same DLL, but there are
	// two problems with it.  First, it only unregisters the version and locale
	// you specify.  That's not good, because we really want to unregister all
	// versions and all locales.  Second, I've heard (but haven't been able to
	// confirm) that the OleAut32 DLL that went out with Win95 is missing this
	// function.
	//
	// To work around this, I've gone the route taken by MFC
	// (AfxOleUnregisterTypeLib in the MFC version delivered with VC 4.2b),
	// which manually deletes the keys it knows that RegisterTypeLib added.

	// Convert the LIBID to an ANSI or Unicode string and store it in atchLIBID.

	if ( !::_TCHARFromGUID2(pControlInfo->pguidTypeLib, atchLIBID) )
    {
		ASSERT(FALSE);
        goto ERR_EXIT;
    }

	// Recursively delete the key "TypeLib\<libid>".
    // Example: "TypeLib\{1C0DE070-2430-...}"

	::wsprintf(atchLIBIDKey, _T("TypeLib\\%s"), atchLIBID);

    if ( !::RegDeleteTreeSucceeded(
	       ::RegDeleteTree(HKEY_CLASSES_ROOT, atchLIBIDKey) ) )
	{
		ASSERT(FALSE);
        goto ERR_EXIT;
	}

	// Load the type library.

	if ( !::_LoadTypeLib(pControlInfo, &pTypeLib) )
	{
		ASSERT(FALSE);
		goto ERR_EXIT;
	}

	// Unregister the interfaces in the library.  (This is an MFC function that
	// doesn't return an error code.)

	::UnregisterInterfaces(pTypeLib);

EXIT:

	::SafeRelease( (IUnknown **)&pTypeLib );
    return (bRetVal);

ERR_EXIT:

	bRetVal = FALSE;
	goto EXIT;
}


/*----------------------------------------------------------------------------
	@func BOOL | _LoadTypeLib |
	
	Load the type library indicated by "pControlInfo".

	@comm
	This will fail if the module indicated by pControlInfo->hmodDLL doesn't
	contain a type library.  You can check for this before calling this
	function by looking at pControlInfo->pguidTypeLib, which should be NULL if
	there is no type library.

	@rvalue TRUE | The type library was loaded.
	@rvalue FALSE | An error occurred.

	@contact Tony Capone
  ----------------------------------------------------------------------------*/

BOOL
_LoadTypeLib
(
	const ControlInfo *pControlInfo,  // @parm  Information structure for the
									  //         control.
	ITypeLib **ppTypeLib			  // @parm  Storage for the type library
									  //	     pointer.  Gets set to NULL on
									  //		 error.
)
{
	ASSERT(pControlInfo != NULL);
	ASSERT(ppTypeLib != NULL);

    OLECHAR aochModule[_MAX_PATH];

	*ppTypeLib = NULL;

	// Get the module name and load the type library.

	if ( !_GetUnicodeModuleName(pControlInfo, aochModule) ||
	     FAILED( ::LoadTypeLib(aochModule, ppTypeLib) ) )
	{
		ASSERT(FALSE);
		return (FALSE);
	}

	return (TRUE);
}


/*----------------------------------------------------------------------------
	@func BOOL | _SetComponentCategories |
	
	Set the component categories for a single control.

	@rvalue TRUE | The categories were registered.
	@rvalue FALSE | An error occurred.

	@contact Tony Capone
  ----------------------------------------------------------------------------*/

BOOL
_SetComponentCategories
(
	// @parm Array of flags and CatIDs.
	const CatInfoForOneControl *pCatInfoForOneControl,

	// @parm  Number of elements in pCatInfoForOneControl.
	int iEntries,

	// Pointer to the component category manager.
	ICatRegister *pCatRegister,

	// @parm  Information structure for the control.
	const ControlInfo *pControlInfo
)
{
	ASSERT(pCatInfoForOneControl != NULL);
	ASSERT(pCatRegister != NULL);
	ASSERT(pControlInfo != NULL);

	int i;

	// Loop through all elements in the array.

	for (i = 0; i < iEntries; i++, pCatInfoForOneControl++)
	{
		// If dwFlags includes dwFlagToCheck, register the category pCatID for
		// the control.

		if ( (pControlInfo->dwFlags & pCatInfoForOneControl->dwFlagToCheck) &&
			 FAILED(pCatRegister->
			   RegisterClassImplCategories(*pControlInfo->pclsid, 1,
			   							   (CATID *)pCatInfoForOneControl->
										     pCatID) ) )
		{
			return (FALSE);
		}
	}

	return (TRUE);
}


/*----------------------------------------------------------------------------
	@func BOOL | _TCHARFromGUID2 |
	
	Convert a GUID to a Unicode or ANSI string.

	@comm
	This converts "pGUID" to either a Unicode or an ANSI string, depending on
	whether Unicode is defined.

	@rvalue TRUE | The GUID was converted.
	@rvalue FALSE | An error occurred.

	@contact Tony Capone
  ----------------------------------------------------------------------------*/

BOOL
_TCHARFromGUID2
(
	const GUID *pGUID,  // @parm  Pointer to the GUID to convert.
    TCHAR *ptchGUID 	// @parm  Storage for the string.  Must be at least
						//         GUID_CCH characters long.  Define as
						//		   TCHAR atchGUID[GUID_CCH].
)
{
	ASSERT(pGUID != NULL);
    ASSERT(ptchGUID != NULL);

	if (::TCHARFromGUID(*pGUID, ptchGUID, GUID_CCH) == NULL)
	{
		ASSERT(FALSE);
		return (FALSE);
	}

	return (TRUE);
}


/*----------------------------------------------------------------------------
	@func BOOL | _GetUnicodeModuleName |
	
	Get the module name, in Unicode.

	@comm
	This gets the module name for "pControlInfo" and stores it at "pochModule"
	in Unicode format.  "pochModule" must be defined as
	OLECHAR pochModule[_MAX_PATH].

	@rvalue TRUE | The GUID was converted.
	@rvalue FALSE | An error occurred.

	@contact Tony Capone
  ----------------------------------------------------------------------------*/

BOOL
_GetUnicodeModuleName
(
	const ControlInfo *pControlInfo,  // @parm  Information structure for the
									  //         control.
	OLECHAR *pochModule				  // @parm  Must be defined as
									  //         OLECHAR pochModule[_MAX_PATH].
)
{
	ASSERT(pControlInfo != NULL);
	ASSERT(pochModule != NULL);

    TCHAR atchModule[_MAX_PATH];
	BOOL bRetVal = TRUE;

    pochModule[0] = 0;

	// Store the module name in atchModule.
    // Example: "C:\Temp\MyCtl.ocx"

    ASSERT(pControlInfo->hmodDLL != NULL);

    if (NULL == pControlInfo->hmodDLL ||
		::GetModuleFileName( pControlInfo->hmodDLL, atchModule,
							 ARRAY_SIZE(atchModule) ) == 0)
	{
		ASSERT(FALSE);
        goto ERR_EXIT;
	}

	// Convert the file name to Unicode.

	#ifdef UNICODE
	::lstrcpy(pochModule, atchModule);
	#else
	::ANSIToUNICODE(pochModule, atchModule, _MAX_PATH);
	#endif

EXIT:

    return (bRetVal);

ERR_EXIT:

	bRetVal = FALSE;
	goto EXIT;
}


TCHAR* _lstrchr(
const TCHAR* sz,
const TCHAR ch)
{
    const TCHAR* pch = NULL;

    if (sz != NULL)
    {
        for (pch = sz; (*pch != _T('\0')) && (*pch != ch); pch++)
        {
            ;
        }
        if (*pch == _T('\0'))
        {
            pch = NULL;
        }
    }

    return (const_cast<TCHAR*>(pch));
}


// hr = _SetRegKey(tszKey, tszSubkey, tszValue)
//
// Set the concatenated registry key name <tszKey><tszSubkey> (within
// HKEY_CLASSES_ROOT) to value <tszValue>.  If <tszSubkey> is NULL,
// it is ignored.

HRESULT _SetRegKey(LPCTSTR tszKey, LPCTSTR tszSubkey, LPCTSTR tszValue)
{
    TCHAR atchKey[500];   // a registry key

    lstrcpy(atchKey, tszKey);
    if (tszSubkey != NULL)
        lstrcat(atchKey, tszSubkey);

    return (RegSetValue(HKEY_CLASSES_ROOT, atchKey, REG_SZ, tszValue,
            lstrlen(tszValue)*sizeof(TCHAR)) == ERROR_SUCCESS) ? S_OK : E_FAIL;
}


// hr = _SetRegKeyValue(szKey, szSubkey, szValueName, szValue)
//
// Set the string value named <tszValueName> to <tszValue> associated
// with the registry key HKEY_CLASSES_ROOT\<szKey>\<szSubkey>
// where <szSubkey> may be NULL.

HRESULT _SetRegKeyValue(
LPCTSTR szKey,
LPCTSTR szSubkey,
LPCTSTR szValueName,
LPCTSTR szValue)
{
	HKEY hKey1 = NULL;
	HKEY hKey2 = NULL;
		// registry keys
	HKEY hKey = NULL;
		// an alias for <hKey1> or <hKey2>
	HRESULT hr = S_OK;
		// function return value

	// hKey = HKEY_CLASSES_ROOT\szKey, or
	//      = HKEY_CLASSES_ROOT\szKey\szSubkey

	if (RegOpenKey(HKEY_CLASSES_ROOT, szKey, &hKey1) != ERROR_SUCCESS)
	{
		goto ERR_EXIT;
	}
	if (szSubkey != NULL)
	{
		if (RegOpenKey(hKey1, szSubkey, &hKey2) != ERROR_SUCCESS)
		{
			goto ERR_EXIT;
		}
		hKey = hKey2;
	}
	else
	{
		hKey = hKey1;
	}

	// Set the value.

	if (RegSetValueEx(hKey, szValueName, 0, REG_SZ, (BYTE*)szValue,
					  lstrlen(szValue) * sizeof(TCHAR)) != ERROR_SUCCESS)
	{
		goto ERR_EXIT;
	}

EXIT:

	if (hKey1 != NULL)
	{
		RegCloseKey(hKey1);
	}
	if (hKey2 != NULL)
	{
		RegCloseKey(hKey2);
	}
	return (hr);

ERR_EXIT:

	hr = E_FAIL;
	goto EXIT;
}


// _DelRegKeyValue(szKey, szSubkey, tszValueName)
//
// Delete the value named <szValueName> associated with the registry
// key, HKEY_CLASSES_ROOT\<szKeyName>\<szSubkeyName> where <szSubkeyName>
// may be NULL.

void _DelRegKeyValue(
LPCTSTR szKey,
LPCTSTR szSubkey,
LPCTSTR szValueName)
{
	HKEY hKey = NULL;
	HKEY hKey1 = NULL;
	HKEY hKey2 = NULL;
		// registry keys

	// hKey = HKEY_CLASSES_ROOT\szKey, or
	//      = HKEY_CLASSES_ROOT\szKey\szSubkey

	if (RegOpenKey(HKEY_CLASSES_ROOT, szKey, &hKey1) != ERROR_SUCCESS)
	{
		goto EXIT;
	}
	if (szSubkey != NULL)
	{
		if (RegOpenKey(hKey1, szSubkey, &hKey2) != ERROR_SUCCESS)
		{
			goto EXIT;
		}
		hKey = hKey2;
	}
	else
	{
		hKey = hKey1;
	}

	// At this point, <hKey> is the registry key that owns the value.
	// Delete the value.
	
	RegDeleteValue(hKey, szValueName);

EXIT:
	if (hKey1 != NULL)
	{
		RegCloseKey(hKey1);
	}
	if (hKey2 != NULL)
	{
		RegCloseKey(hKey2);
	}
}


//****************************************************************************
//*  Functions stolen from MFC
//****************************************************************************

// [I took the code for RegDeleteTree directly from _AfxRecursiveRegDeleteKey
// in MFC from VC 4.2b.  The only changes I made were to remove remove the
// AFXAPI from the return type and add the diagnostics on szKeyName.
// -- Tony Capone]

// Under Win32, a reg key may not be deleted unless it is empty.
// Thus, to delete a tree,  one must recursively enumerate and
// delete all of the sub-keys.

#define ERROR_BADKEY_WIN16  2   // needed when running on Win32s

STDAPI_(LONG)
RegDeleteTree(HKEY hParentKey, LPCTSTR szKeyName)
{
	if ( HKEY_CLASSES_ROOT == hParentKey &&
	    (NULL == szKeyName ||
		::lstrcmpi( szKeyName, _T("") ) == 0 ||
		::lstrcmpi( szKeyName, _T("\\") ) == 0 ||
		::lstrcmpi( szKeyName, _T("CLSID") ) == 0 ||
		::lstrcmpi( szKeyName, _T("CLSID\\") ) == 0) )
	{
		ASSERT(FALSE);
		return (ERROR_BADKEY);
	}

	DWORD   dwIndex = 0L;
	TCHAR   szSubKeyName[256];
	HKEY    hCurrentKey;
	DWORD   dwResult;

	if ((dwResult = RegOpenKey(hParentKey, szKeyName, &hCurrentKey)) ==
		ERROR_SUCCESS)
	{
		// Remove all subkeys of the key to delete
		while ((dwResult = RegEnumKey(hCurrentKey, 0, szSubKeyName, 255)) ==
			ERROR_SUCCESS)
		{
			if ((dwResult = RegDeleteTree(hCurrentKey,
				szSubKeyName)) != ERROR_SUCCESS)
				break;
		}

		// If all went well, we should now be able to delete the requested key
		if ((dwResult == ERROR_NO_MORE_ITEMS) || (dwResult == ERROR_BADKEY) ||
			(dwResult == ERROR_BADKEY_WIN16))
		{
			dwResult = RegDeleteKey(hParentKey, szKeyName);
		}
	}

	RegCloseKey(hCurrentKey);
	return dwResult;
}


// [I took the code for RegDeleteTreeSucceeded directly from
// _AfxRegDeleteKeySucceeded in MFC in VC 4.2b.  // -- Tony Capone]

BOOL RegDeleteTreeSucceeded(LONG error)
{
	return (error == ERROR_SUCCESS) || (error == ERROR_BADKEY) ||
		(error == ERROR_FILE_NOT_FOUND);
}


// [I took the code for UnregisterInterfaces directly from
// _AfxUnregisterInterfaces in MFC in VC 4.2b.  The changes I made are marked
// with my initials.  -- Tony Capone]

void UnregisterInterfaces(ITypeLib* pTypeLib)
{
	TCHAR szKey[128] = _T("Interface\\");
//	_tcscpy(szKey, _T("Interface\\"));
	LPTSTR pszGuid = szKey + (sizeof(_T("Interface\\")) / sizeof(TCHAR));

	int cTypeInfo = pTypeLib->GetTypeInfoCount();

	for (int i = 0; i < cTypeInfo; i++)
	{
		TYPEKIND tk;
		if (SUCCEEDED(pTypeLib->GetTypeInfoType(i, &tk)) &&
			(tk == TKIND_DISPATCH || tk == TKIND_INTERFACE))
		{
			ITypeInfo* pTypeInfo = NULL;
			if (SUCCEEDED(pTypeLib->GetTypeInfo(i, &pTypeInfo)))
			{
				TYPEATTR* pTypeAttr;
				if (SUCCEEDED(pTypeInfo->GetTypeAttr(&pTypeAttr)))
				{
					#if 0  // TC
#ifdef _UNICODE
					StringFromGUID2(pTypeAttr->guid, pszGuid, GUID_CCH);
#else
					WCHAR wszGuid[39];
					StringFromGUID2(pTypeAttr->guid, wszGuid, GUID_CCH);
					_wcstombsz(pszGuid, wszGuid, GUID_CCH);
#endif
					#else  // TC

					VERIFY( ::_TCHARFromGUID2(&pTypeAttr->guid, pszGuid) );

					#endif  // TC

					#if 0  // TC
					_AfxRecursiveRegDeleteKey(HKEY_CLASSES_ROOT, szKey);
					#else  // TC
					RegDeleteTree(HKEY_CLASSES_ROOT, szKey);
					#endif  // TC

					pTypeInfo->ReleaseTypeAttr(pTypeAttr);
				}

				pTypeInfo->Release();
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\typelib.cpp ===
// typelib.cpp
//
// Type information support (events only -- not for properties and methods)
// using type libraries.
//
// @doc MMCTL
//

#include "precomp.h"
#include "..\..\inc\ochelp.h"
#include "debug.h"


/* @func HRESULT | HelpGetClassInfoFromTypeLib |

        Helps implement <om IProvideClassInfo.GetClassInfo> using a
        caller-provided type library.

@parm   LPTYPEINFO * | ppti | Where to return the pointer to the
        newly-allocated <i ITypeInfo> interface.  NULL is stored in
        *<p ppti> on error.

@parm   REFCLSID | rclsid | The class ID of the object that is implementing
        <i IProvideClassInfo>.

@parm   ITypeLib * | plib | The type library containing events.  Should be
        NULL if <p plib> is non-NULL.

@parm   HINSTANCE | hinst | The DLL instance containing a type library
        resource.  Should be NULL if <p plib> is non-NULL.

@parm   DWORD | dwFlags | Currently unused.  Must be set to 0.

@comm   This function accesses type information in the type library specified
        by either <p plib> (if the type library is already loaded) or
        <p hinst> (in which case this function loads the type library).

        It is assumed that the type library contains a "coclass" typeinfo
        and a an outgoing (source) "dispinterface" typeinfo.  The class ID
        of the "coclass" typeinfo should be <p rclsid>.

@ex     In the following example, <c CMyControl> is a class that implements
        (among other things) <i IConnectionPointContainer> and
        <i IProvideClassInfo>.  The first part of this example shows how
        <om IProvideClassInfo.GetClassInfo> is implemented by <c CMyControl>.
        The second part of the example shows how an event is fired,
        assuming <p m_pconpt> is a <i IConnectionPointHelper> object.
        (It's not required that you use <o ConnectionPointHelper>, but
        it's helpful.) |

        // in MyControl.h...

        // IDispatch IDs for events fired by this object
        #define DISPID_EVENT_BAR        1
        #define DISPID_EVENT_LOAD       2

        // class ID
        #define _CLSID_CMyControl 3CE08A80-9440-11CF-B705-00AA00BF27FD
        #ifndef __MKTYPLIB__
        DEFINE_GUID(CLSID_CMyControl, 0x3CE08A80L, 0x9440, 0x11CF,
            0xB7, 0x05, 0x00, 0xAA, 0x00, 0xBF, 0x27, 0xFD);
        #endif

        // dispinterface ID for event set
        #define _DIID_DMyControlEvents 296CC160-9F5A-11CF-B705-00AA00BF27FD
        #ifndef __MKTYPLIB__
        DEFINE_GUID(DIID_DMyControlEvents, 0x296CC160L, 0x9F5A, 0x11CF,
            0xB7, 0x05, 0x00, 0xAA, 0x00, 0xBF, 0x27, 0xFD);
        #endif

        // in the .odl  file...

        #include <olectl.h>
        #includ  "MyControl.h"

        [ uuid(B1179240-9445-11CF-B705-00AA00BF27FD), version(1.0), control ]
        library MyControlLib
        {
            importlib(STDOLE_TLB);
            importlib(STDTYPE_TLB);

            // event dispatch interface for CMyControl
            [ uuid(_DIID_DMyControlEvents) ]
            dispinterface _DMyControlEvents
            {
                properties:
                methods:
                    [id(DISPID_EVENT_BAR)] void Bar(long i, BSTR sz, boolean f);
                    [id(DISPID_EVENT_LOAD)] void Load();
            };

            // class information for CMyControl
            [ uuid(_CLSID_CMyControl), control ]
            coclass MyControl
            {
                [default, source] dispinterface _DMyControlEvents;
            };
        };

        // in some .cpp file...

        STDMETHODIMP CMyControl::GetClassInfo(LPTYPEINFO FAR* ppTI)
        {
            return HelpGetClassInfoFromTypeLib(ppTI, CLSID_CMyControl, NULL,
                g_hinst, 0);
        }

        // in some .cpp file...

        // fire the "Bar" event (which has 3 parameters, which in BASIC
        // are of these types: Integer, String, Boolean)
        m_pconpt->FireEvent(DISPID_EVENT_BAR, VT_INT, 300 + i,
            VT_LPSTR, ach, VT_BOOL, TRUE, 0);
*/
STDAPI HelpGetClassInfoFromTypeLib(LPTYPEINFO *ppTI, REFCLSID rclsid,
    ITypeLib *plib, HINSTANCE hinst, DWORD dwFlags)
{
    TRACE("HelpGetClassInfoFromTypeLib\n");

    if (plib == NULL)
    {
        char ach[_MAX_PATH];
        if (GetModuleFileName(hinst, ach, sizeof(ach)) == 0)
            return E_FAIL;
        HRESULT hr;
        ITypeLib *plib;
        OLECHAR aoch[_MAX_PATH];
        ANSIToUNICODE(aoch, ach, _MAX_PATH);
        if (FAILED(hr = LoadTypeLib(aoch, &plib)))
            return hr;
        hr = plib->GetTypeInfoOfGuid(rclsid, ppTI);
        plib->Release();
        return hr;
    }
    else
        return plib->GetTypeInfoOfGuid(rclsid, ppTI);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\ucat.cpp ===
// ucat.cpp
//
// Implements UNICODEConcat.
//
// Important: This .cpp file assumes a zero-initializing global "new" operator.
//
// @doc MMCTL
//

#include "precomp.h"
#include "..\..\inc\mmctlg.h" // see comments in "mmctl.h"
#include "..\..\inc\ochelp.h"
#include "debug.h"


/* @func wchar_t * | UNICODEConcat |

        Concatenates one UNICODE string to another.

@rdesc  Returns a pointer to the NULL at the end of <p wpchDst>.

@parm   wchar_t * | wpchDst | Where to copy <p wpchSrc> to.

@parm   const wchar_t * | wpchSrc | String to copy.

@parm   int | wcchDstMax | Capacity of <p wpchDst> (in wide characters).
        If <p wcchDstMax> is less than or equal to zero, this function
        does nothing.

@comm   Provided <p wcchDstMax> greater than zero, <p wpchDst> is always
        null-terminated.
*/
STDAPI_(wchar_t *) UNICODEConcat(wchar_t *wpchDst, const wchar_t *wpchSrc,
    int wcchDstMax)
{
    while (*wpchDst != 0)
        wpchDst++, wcchDstMax--;
    return UNICODECopy(wpchDst, wpchSrc, wcchDstMax);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\unkenum.cpp ===
// unkenum.cpp
//
// Defines CEnumUnknown, which implements a simple ordered list of
// LPUNKNOWNs (by being based on CUnknownList) and which is also
// a lightweight unregistered COM object that implements IEnumUnknown
// (useful for implementing any enumerator that enumerates COM
// objects).
//
// Important: This .cpp file assumes a zero-initializing global "new" operator.
//

#include "precomp.h"
#include "unklist.h"
#include "unkenum.h"


//////////////////////////////////////////////////////////////////////////////
// Construction & Destruction
//
// In the constructor, <riid> is the IID that the object will consider its
// own (e.g. this could be IID_IEnumUnknown, IID_IEnumConnectionPoints, etc.).
//

CEnumUnknown::CEnumUnknown(REFIID riid)
{
    m_cRef = 1;
    m_iid = riid;
}

CEnumUnknown::~CEnumUnknown()
{
    EmptyList();
}


//////////////////////////////////////////////////////////////////////////////
// IUnknown Methods
//

STDMETHODIMP CEnumUnknown::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, m_iid))
    {
        *ppvObj = (IEnumUnknown *) this;
        AddRef();
        return NOERROR;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
}

STDMETHODIMP_(ULONG) CEnumUnknown::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CEnumUnknown::Release()
{
    if (--m_cRef == 0L)
    {
        Delete this;
        return 0;
    }
    else
        return m_cRef;
}


//////////////////////////////////////////////////////////////////////////////
// IEnumUnknown Methods
//

STDMETHODIMP CEnumUnknown::Next(ULONG celt, IUnknown **rgelt,
    ULONG *pceltFetched)
{
    return CUnknownList::Next(celt, rgelt, pceltFetched);
}

STDMETHODIMP CEnumUnknown::Skip(ULONG celt)
{
    return CUnknownList::Skip(celt);
}

STDMETHODIMP CEnumUnknown::Reset()
{
    return CUnknownList::Reset();
}

STDMETHODIMP CEnumUnknown::Clone(IEnumUnknown **ppenum)
{
    CEnumUnknown *penum = NULL;

    // make <penum> be a new CEnumUnknown with the same attributes
    // as this object
    if ((penum = New CEnumUnknown(m_iid)) == NULL)
        goto ERR_OUTOFMEMORY;

    // copy the list of LPUNKNOWNs from this object to <penum>
    if (!CopyItems(penum))
        goto ERR_OUTOFMEMORY;

    // return <penum>
    *ppenum = penum;

    return S_OK;

ERR_OUTOFMEMORY:

    if (penum != NULL)
        Delete penum;

    return E_OUTOFMEMORY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\rvp.cpp ===
// rvp.cpp
//
// Implements ReadVariantProperty.
//
// Important: This .cpp file assumes a zero-initializing global "new" operator.
//
// @doc MMCTL
//

#include "precomp.h"
#include "..\..\inc\mmctlg.h" // see comments in "mmctl.h"
#include "..\..\inc\ochelp.h"
#include "debug.h"


/* @struct VariantPropertyHeader |

        The beginning part of a record (in a stream) that contains the
        serialized data of a <t VariantProperty>.

@field  int | iType | The type of the record.  If this value is greater than
        or equal to zero, then it represents a VARTYPE, and the record
        represents a property name/value pair, and the type of the value is
        specified by the VARTYPE.  In this case, the data following the
        <t VariantPropertyHeader> consists of the property name followed by
        the property value (coerced to a string value by <f VariantChangeType>);
        each string is a non-null-terminated Unicode string preceded by an
        unsigned 32-bit integer count of Unicode characters.  <p iType> is
        not a known VARTYPE value, then the record should be skipped when read
        (by skipping the <p cbData> bytes that follow the
        <t VariantPropertyHeader> rather than generating an error.

@field  unsigned int | cbData | The number of bytes of data that follow
        this <t VariantPropertyHeader>.  In other words, the total length
        of the header is <p cbData> + sizeof(<t VariantPropertyHeader>).

@comm   This structure helps define the file format used by
        <f WriteVariantProperty> and <f ReadVariantProperty>.
*/


/* @func HRESULT | ReadVariantProperty |

        Reads a <t VariantProperty> from an <i IStream> in a simple tagged
        binary format.

@rvalue S_OK | Success.

@rvalue S_FALSE | The end-of-stream marker was read in.  (This is the data
        that's written using <f WriteVariantProperty> with NULL <p pvp>.)

@parm   IStream * | pstream | The stream to read from.

@parm   VariantProperty * | pvp | Where to store the property name/value pair
        that's read in.  Any unknown records in <p pstream> are automatically
        skipped.

@parm   DWORD | dwFlags | Currently unused.  Must be set to 0.

@comm   See <t VariantPropertyHeader> for a description of the format of
        the data read from <p pstream> by this function.
*/
STDAPI ReadVariantProperty(IStream *pstream, VariantProperty *pvp,
    DWORD dwFlags)
{
    HRESULT         hrReturn = S_OK; // function return code
    unsigned int    cchPropName;    // no. wide characters in property name
    VARIANT         varValue;       // the property value (as a string)
    unsigned int    cchValue;       // no. wide characters in <varValue>
    VariantPropertyHeader vph;      // header of record
    ULONG           cb;

    // ensure correct cleanup
    VariantInit(&varValue);
    VariantPropertyInit(pvp);

    // skip unknown record types; on loop exit, <vph> contains the record
    // header of a known record type
    while (TRUE)
    {
        // read a VariantPropertyHeader
        if (FAILED(hrReturn = pstream->Read(&vph, sizeof(vph), &cb)))
			goto ERR_EXIT;
        if ((vph.iType == -1) || (cb == 0))
        {
            // hit end-of-stream marker
            hrReturn = S_FALSE;
            goto EXIT;
        }
		if (cb != sizeof(vph))
		{
			hrReturn = E_FAIL;
			goto EXIT;
		}

        // if this record does not specify a property name/value pair, skip it
        if ((vph.iType < 0) || (vph.iType > 0xFFFF))
        {
            LARGE_INTEGER liSeek;
            liSeek.LowPart = vph.cbData;
            liSeek.HighPart = 0;
            if (FAILED(hrReturn = pstream->Seek(liSeek, SEEK_CUR, NULL)))
                goto ERR_EXIT;
        }
        else
            break;
    }

    // read the property name into <pvp->bstrPropName>
    if (FAILED(hrReturn = pstream->Read(&cchPropName, sizeof(cchPropName),
            &cb)) ||
        (cb != sizeof(cchPropName)))
        goto ERR_EXIT;
    if ((pvp->bstrPropName = SysAllocStringLen(NULL, cchPropName)) == NULL)
        goto ERR_OUTOFMEMORY;
    if (FAILED(hrReturn = pstream->Read(pvp->bstrPropName,
            cchPropName * sizeof(OLECHAR), &cb)) ||
        (cb != cchPropName * sizeof(OLECHAR)))
        goto ERR_EXIT;
    pvp->bstrPropName[cchPropName] = 0; // null-terminate

    // read the property value (in string form) into <varValue>
    varValue.vt = VT_BSTR;
    if (FAILED(hrReturn = pstream->Read(&cchValue, sizeof(cchValue),
            &cb)) ||
        (cb != sizeof(cchValue)))
        goto ERR_EXIT;
    if ((varValue.bstrVal = SysAllocStringLen(NULL, cchValue)) == NULL)
        goto ERR_OUTOFMEMORY;
    if (FAILED(hrReturn = pstream->Read(varValue.bstrVal,
            cchValue * sizeof(OLECHAR), &cb)) ||
        (cb != cchValue * sizeof(OLECHAR)))
        goto ERR_EXIT;
    varValue.bstrVal[cchValue] = 0; // null-terminate

    // coerce <varValue> from a string to the VARTYPE specified in <vph> 
    if (FAILED(hrReturn = VariantChangeType(&pvp->varValue, &varValue, 0,
            (VARTYPE) vph.iType)))
        goto ERR_EXIT;

    goto EXIT;

ERR_OUTOFMEMORY:

    hrReturn = E_OUTOFMEMORY;
    goto ERR_EXIT;

ERR_EXIT:

    // error cleanup
    VariantPropertyClear(pvp);
    goto EXIT;

EXIT:

    // normal cleanup
    VariantClear(&varValue);

    return hrReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\ucopy.cpp ===
// ucopy.cpp
//
// Implements UNICODECopy.
//
// Important: This .cpp file assumes a zero-initializing global "new" operator.
//
// @doc MMCTL
//

#include "precomp.h"
#include "..\..\inc\mmctlg.h" // see comments in "mmctl.h"
#include "..\..\inc\ochelp.h"
#include "debug.h"


/* @func wchar_t * | UNICODECopy |

        Copies one UNICODE string to another.

@rdesc  Returns a pointer to the NULL at the end of <p wpchDst>, unless
        <p wpchDstMax> is less than or equal to zero.  In that case, returns
		<p wpchDst>.

@parm   wchar_t * | wpchDst | Where to copy <p wpchSrc> to.

@parm   const wchar_t * | wpchSrc | String to copy.

@parm   int | wcchDstMax | Capacity of <p wpchDst> (in wide characters).
        If <p wcchDstMax> is less than or equal to zero, this function
        does nothing.

@comm   Provided <p wcchDstMax> greater than zero, <p wpchDst> is always
        null-terminated.
*/
STDAPI_(wchar_t *) UNICODECopy(wchar_t *wpchDst, const wchar_t *wpchSrc,
    int wcchDstMax)
{
    if (wcchDstMax <= 0)
        goto EXIT;

    while (*wpchSrc != 0)
    {
        if (--wcchDstMax == 0)
            break;
        *wpchDst++ = *wpchSrc++; 
    }
    *wpchDst = 0;

	EXIT:
		return wpchDst;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\unicode.cpp ===
// unicode.cpp
//
// Implements UNICODE helper functions.
//
// Important: This .cpp file assumes a zero-initializing global "new" operator.
//
// @doc MMCTL
//

#include "precomp.h"
#include "..\..\inc\ochelp.h"
#include "debug.h"


/* @func int | UNICODEToANSI |

        Converts a UNICODE string to ANSI.

@rdesc  Returns the same integer as WideCharToMultiByte.  0 means "failed."

@parm   LPSTR | pchDst | The buffer that will hold the output ANSI string.

@parm   LPCWSTR | pwchSrc | The input UNICODE string.  NULL is interpreted as
        a zero-length string.

@parm   int | cchDstMax | The size of <p pchDst>, in characters.  If <p pchDst>
		is declared as char pchDst[32], for example, <p cchDstMax> should be 32.
		If <p pchDst> isn't large enough to hold the ANSI string (including the
		terminating NULL), <p pchDst> is set to zero length and 0 is returned.
		(In debug versions, an assertion also occurs.)

@comm   If you want to determine the ANSI buffer size required for a given
		UNICODE string pwchSrc, you can call UNICODEToANSI(NULL, pwchSrc, 0).
		This returns the required buffer size in characters, including space
		for the terminating NULL.

@ex		Here is code (without debug checks) that dynamically allocates the ANSI
		buffer and converts the UNICODE string pwchSrc: |

			int cchDst;
			char *pchDst;
			cchDst = UNICODEToANSI(NULL, pwchSrc, 0);
			pchDst = new char [cchDst];
			UNICODEToANSI(pchDst, pwchSrc, cchDst)

*/
STDAPI_(int) UNICODEToANSI(LPSTR pchDst, LPCWSTR pwchSrc, int cchDstMax)
{
	// (We allow the caller to pass a cchDstMax value of 0 and a NULL pchDst to
	// indicate "tell me the buffer size I need, including the NULL.")

	ASSERT(pchDst != NULL || 0 == cchDstMax);
	ASSERT(cchDstMax >= 0);

	#ifdef _DEBUG

	// Make sure we won't exceed the length of the user-supplied buffer,
	// pchDst.  The following call returns the number of characters required to
	// store the converted string, including the terminating NULL.

    if(cchDstMax > 0)
	{
		int iChars;
	
		iChars =
		  	WideCharToMultiByte(CP_ACP, 0, pwchSrc ? pwchSrc : OLESTR(""),
							    -1, NULL, 0, NULL, NULL); 
		ASSERT(iChars <= cchDstMax);
	}

	#endif

	int iReturn;

	iReturn = WideCharToMultiByte(CP_ACP, 0, pwchSrc ? pwchSrc : OLESTR( "" ), 
								  -1, pchDst, cchDstMax, NULL, NULL); 

	if (0 == iReturn)
	{
		// The conversion failed.  Return an empty string.

		if (pchDst != NULL)
			pchDst[0] = 0;

		ASSERT(FALSE);
	}

	return (iReturn);
}


/* @func int | ANSIToUNICODE |

        Converts an ANSI string to UNICODE.

@parm   LPWSTR | pwchDst | The buffer that will hold the output UNICODE string.

@parm   LPCSTR | pchSrc | The input ANSI string.

@parm   int | cwchDstMax | The size of <p pwchDst>, in wide characters.  If
		pwchDst is declared as OLECHAR pwchDst[32], for example, cwchDstMax
		should be 32.

*/
STDAPI_(int) ANSIToUNICODE(LPWSTR pwchDst, LPCSTR pchSrc, int cwchDstMax)
{

	ASSERT( pwchDst );
	ASSERT( pchSrc );

    return MultiByteToWideChar(CP_ACP, 0, pchSrc, -1, pwchDst, cwchDstMax);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\unkenum.h ===
// unkenum.h
//
// Defines CEnumUnknown, which implements a simple ordered list of
// LPUNKNOWNs (by being based on CUnknownList) and which is also
// a lightweight unregistered COM object that implements IEnumUnknown
// (useful for implementing any enumerator that enumerates COM
// objects).
//

struct CEnumUnknown : CUnknownList, IEnumUnknown
{
///// object state
    ULONG           m_cRef;         // object reference count
    IID             m_iid;          // interface ID of this object

///// construction & destruction
    CEnumUnknown(REFIID riid);
    ~CEnumUnknown();

///// IUnknown methods
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR* ppvObj);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

///// IEnumUnknown methods
    STDMETHODIMP Next(ULONG celt, IUnknown **rgelt, ULONG *pceltFetched);
    STDMETHODIMP Skip(ULONG celt);
    STDMETHODIMP Reset();
    STDMETHODIMP Clone(IEnumUnknown **ppenum);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\unklist.h ===
// unklist.h
//
// Defines CUnknownList, which maintains a simple ordered list of LPUNKNOWNs.
//

struct CUnknownItem
{
///// object state
    LPUNKNOWN       m_punk;         // the AddRef'd LPUNKNOWN of this item
    CUnknownItem *  m_pitemNext;    // next item in the list
    CUnknownItem *  m_pitemPrev;    // previous item in the list
    DWORD           m_dwCookie;     // the cookie that will be used for this item
///// object operations
    CUnknownItem(LPUNKNOWN punk, CUnknownItem *pitemNext,
        CUnknownItem *pitemPrev, DWORD dwCookie);
    ~CUnknownItem();
    LPUNKNOWN Contents();
};

struct CUnknownList
{
///// object state
    CUnknownItem     m_itemHead;     // m_itemHead.Next() is first item in list
    CUnknownItem *   m_pitemCur;     // current item in list
    int              m_citem;        // number of items in list
    DWORD            m_dwNextCookie;

///// object operations
    CUnknownList();
    ~CUnknownList();
    int NumItems() { return m_citem; }
    CUnknownItem *LastItemAdded() { return m_itemHead.m_pitemPrev; }
    DWORD LastCookieAdded() { return (m_itemHead.m_pitemPrev)->m_dwCookie; }
    void EmptyList();
    void DeleteItem(CUnknownItem *pitem);
    CUnknownItem *GetItemFromCookie(DWORD dwCookie);
    BOOL AddItem(LPUNKNOWN punk);
    BOOL CopyItems(CUnknownList *plistNew);
    CUnknownList *Clone();
    CUnknownItem *GetNextItem();
    STDMETHODIMP Next(ULONG celt, IUnknown **rgelt, ULONG *pceltFetched);
    STDMETHODIMP Skip(ULONG celt);
    STDMETHODIMP Reset();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\unklist.cpp ===
// unklist.cpp
//
// Defines CUnknownList, which maintains a simple ordered list of LPUNKNOWNs.
//
// Important: This .cpp file assumes a zero-initializing global "new" operator.
//

#include "precomp.h"
#include "unklist.h"

//////////////////////////////////////////////////////////////////////////////
// CUnknownItem -- an item in a CUnknownList
//


// CUnknownItem(punk, pitemNext, pitemPrev)
//
// Construct a CUnknownItem containing <punk> (which is AddRef'd if it's
// not NULL).
//
CUnknownItem::CUnknownItem(LPUNKNOWN punk, CUnknownItem *pitemNext,
    CUnknownItem *pitemPrev, DWORD dwCookie)
{
    if ((m_punk = punk) != NULL)
        m_punk->AddRef();
    m_pitemNext = pitemNext;
    m_pitemPrev = pitemPrev;
    pitemNext->m_pitemPrev = this;
    pitemPrev->m_pitemNext = this;
    m_dwCookie = dwCookie; 
}


// ~CUnknownItem()
//
// Destroy the CUnknownItem, including calling Release() on the LPUNKNOWN it
// holds (if it's not NULL).
//
CUnknownItem::~CUnknownItem()
{
    if (m_punk != NULL)
        m_punk->Release();
    m_pitemPrev->m_pitemNext = m_pitemNext;
    m_pitemNext->m_pitemPrev = m_pitemPrev;
}


// punk = Contents()
//
// Returns the LPUNKNOWN contained in the item.  AddRef() is called on
// this LPUNKNOWN (if it's not NULL) -- the caller is responsible for
// calling Release().
//
LPUNKNOWN CUnknownItem::Contents()
{
    if (m_punk != NULL)
        m_punk->AddRef();
    return m_punk;
}


//////////////////////////////////////////////////////////////////////////////
// CUnknownList -- a list of LPUNKNOWNs
// 


// CUnknownList()
//
// Construct the list to be initially empty.
//
CUnknownList::CUnknownList() :
    m_itemHead(NULL, &m_itemHead, &m_itemHead, 0)

{
    m_citem = 0;
    m_pitemCur = &m_itemHead;
    m_dwNextCookie = 1;
}


// ~CUnknownList()
//
// Destroy the list.  Release() is called on each non-NULL LPUNKNOWN in the
// list.
//
CUnknownList::~CUnknownList()
{
    EmptyList();
}


// EmptyList()
//
// Empty the list.  Release() is called on each non-NULL LPUNKNOWN in the list.
// 
void CUnknownList::EmptyList()
{
    while (NumItems() > 0)
        DeleteItem(m_itemHead.m_pitemNext);
}


// DeleteItem(pitem)
//
// Delete item <pitem> from the list.  Release() is called on its LPUNKNOWN
// (if its not NULL).  The current item is reset so that the next item
// returned by GetNextItem() is the first item in the list (if any).
//
void CUnknownList::DeleteItem(CUnknownItem *pitem)
{
    Delete pitem;
    m_citem--;
    m_pitemCur = &m_itemHead;
}

// takes a cookie and returns the address of the item associated
// with tth cookie.
CUnknownItem *CUnknownList::GetItemFromCookie(DWORD dwCookie)
{
    int i;
    CUnknownItem *pCur;
    if (m_citem > 0)
    {
        pCur = m_itemHead.m_pitemNext;
    }
    for (i = 0; i < m_citem; i++)
    {
        if (pCur->m_dwCookie == dwCookie)
        {
            return pCur;
        }
        pCur = pCur->m_pitemNext;    
    }
    return NULL;
}

// fOK = AddItem(punk)
//
// Add <punk> to the end of the list.  AddRef() is called on <punk> (if it's
// not NULL).  Return TRUE on success, FALSE if out of memory.
//
BOOL CUnknownList::AddItem(LPUNKNOWN punk)
{
    CUnknownItem *pitem = New CUnknownItem(punk, &m_itemHead,
        m_itemHead.m_pitemPrev, m_dwNextCookie);
    m_dwNextCookie++;
    if (pitem == NULL)
        return FALSE;
    m_citem++;
    return TRUE;
}


// fOK = CopyItems(CUnknownList *plistNew)
//
// Copy the items from this list to <plistNew>.  Also, for whichever item is
// the current item in this list (i.e. the item that will be retrieved by
// the next call to GetNextItem()), the duplicate of that item in <plistNew>
// is made the current item in <plistNew>.
//
BOOL CUnknownList::CopyItems(CUnknownList *plistNew)
{
    BOOL            fOK = TRUE;     // function return value
    CUnknownItem *  pitemCur;       // current item in <this>
    LPUNKNOWN       punk;
    CUnknownItem *  pitem;

    // remember what the "current item" (returned by Next() and GetNextItem())
    // is, so we can restore it after we finish walking the list
    pitemCur = m_pitemCur;

    // add each item from this list to <plistNew>
    Reset();
    while (TRUE)
    {
        // get the next item <pitem> from this list, and add it to <plistNew>
        if ((pitem = GetNextItem()) == NULL)
            break;
        punk = pitem->Contents();
        fOK = plistNew->AddItem(punk);
        punk->Release();
        if (!fOK)
            goto EXIT;

        // if <pitem> was the current item in this list before we entered
        // this function, make the newly-created item in <plistNew> be
        // the current item
        if (pitem == pitemCur)
            plistNew->m_pitemCur = plistNew->m_itemHead.m_pitemPrev;
    }

    goto EXIT;

EXIT:

    // restore the previous "current item" pointer
    m_pitemCur = pitemCur;

    return fOK;
}


// plistNew = Clone()
//
// Create and return a duplicate of this list.  Return NULL on out-of-memory.
//
CUnknownList *CUnknownList::Clone()
{
    CUnknownList *  plistNew = NULL; // the clone of this list

    // allocate <plistNew> to be the new list (initially empty)
    if ((plistNew = New CUnknownList) == NULL)
        goto ERR_EXIT;

    // copy items from this list to <plistNew>
    if (!CopyItems(plistNew))
        goto ERR_EXIT;

    goto EXIT;

ERR_EXIT:

    if (plistNew != NULL)
        Delete plistNew;
    plistNew = NULL;
    goto EXIT;

EXIT:

    return plistNew;
}


// pitem = GetNextItem()
//
// Returns a pointer to the next item in the list.  NULL is returned if there
// are no more items in the list.
//
//To retrieve the LPUNKNOWN/ stored in this item, call pitem->Contents().
//
CUnknownItem *CUnknownList::GetNextItem()
{
    if (m_pitemCur->m_pitemNext == &m_itemHead)
        return NULL;
    m_pitemCur = m_pitemCur->m_pitemNext;
    return m_pitemCur;
}


// hr = Next(celt, rgelt, pceltFetched)
//
// Identical to IEnumUnknown::Next().
//
STDMETHODIMP CUnknownList::Next(ULONG celt, LPUNKNOWN *rgelt,
    ULONG *pceltFetched)
{
    if (pceltFetched != NULL)
        *pceltFetched = 0;
    while (celt > 0)
    {
        CUnknownItem *pitem = GetNextItem();
        if (pitem == NULL)
            break;
        if (rgelt != NULL)
            *rgelt++ = pitem->Contents();
        celt--;
        if (pceltFetched != NULL)
            (*pceltFetched)++;
    }

    return (celt == 0 ? S_OK : S_FALSE);
}


// hr = Skip(celt)
//
// Identical to IEnumUnknown::Skip().
//
STDMETHODIMP CUnknownList::Skip(ULONG celt)
{
    return Next(celt, NULL, NULL);
}


// hr = Reset()
//
// Identical to IEnumUnknown::Reset().
//
STDMETHODIMP CUnknownList::Reset()
{
    m_pitemCur = &m_itemHead;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\vpi.cpp ===
// vpi.cpp
//
// Implements VariantPropertyInit.
//
// Important: This .cpp file assumes a zero-initializing global "new" operator.
//
// @doc MMCTL
//

#include "precomp.h"
#include "..\..\inc\mmctlg.h" // see comments in "mmctl.h"
#include "..\..\inc\ochelp.h"
#include "debug.h"


/* @func void | VariantPropertyInit |

        Initializes a <t VariantProperty> structure.

@parm   VariantProperty * | pvp | The structure to initialize.

@comm   Unlike <f VariantPropertyClear>, this function does not assume
        that <p pvp> contained valid data on entry.
*/
STDAPI_(void) VariantPropertyInit(VariantProperty *pvp)
{
    memset(pvp, 0, sizeof(*pvp));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\vpc.cpp ===
// vpc.cpp
//
// Implements VariantPropertyClear.
//
// Important: This .cpp file assumes a zero-initializing global "new" operator.
//
// @doc MMCTL
//

#include "precomp.h"
#include "..\..\inc\mmctlg.h" // see comments in "mmctl.h"
#include "..\..\inc\ochelp.h"
#include "debug.h"


/* @func void | VariantPropertyClear |

        Frees data maintained in a <t VariantProperty> structure.

@parm   VariantProperty * | pvp | The structure to clear.

@comm   This function calls <f SysFreeString> on <p pvp>-<gt><p bstrPropName>
        and <f VariantClear> on <p pvp>-<gt><p varValue>.

        Unlike <f VariantPropertyInit>, this function <b does> assume
        that <p pvp> was correctly initialized before this function
        was called.
*/
STDAPI_(void) VariantPropertyClear(VariantProperty *pvp)
{
    SysFreeString(pvp->bstrPropName);
	pvp->bstrPropName = NULL;
    VariantClear(&pvp->varValue);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\wvp.cpp ===
// wvp.cpp
//
// Implements WriteVariantProperty.
//
// Important: This .cpp file assumes a zero-initializing global "new" operator.
//
// @doc MMCTL
//

#include "precomp.h"
#include "..\..\inc\mmctlg.h" // see comments in "mmctl.h"
#include "..\..\inc\ochelp.h"
#include "debug.h"


/* @func HRESULT | WriteVariantProperty |

        Writes a <t VariantProperty> to an <i IStream> in a simple tagged
        binary format.

@parm   IStream * | pstream | The stream to write to.

@parm   VariantProperty * | pvp | The property name/value pair to write.
        If <p pvp> is NULL, then this function writes a VariantPropertyHeader
        containing <p iType>==-1 and <p cbData>==0 to mark the end of the
        stream.

@parm   DWORD | dwFlags | Currently unused.  Must be set to 0.

@comm   See <t VariantPropertyHeader> for a description of the format of
        the data written to <p pstream> by this function.
*/
STDAPI WriteVariantProperty(IStream *pstream, VariantProperty *pvp,
    DWORD dwFlags)
{
    HRESULT         hrReturn = S_OK; // function return code
    unsigned int    cchPropName;    // no. wide characters in property name
    VARIANT         varValue;       // the property value (as a string)
    unsigned int    cchValue;       // no. wide characters in <varValue>
    VariantPropertyHeader vph;      // header of record to write out

    // ensure correct cleanup
    VariantInit(&varValue);

    // initialize <vbh> to be the header to write out
    if (pvp == NULL)
    {
        vph.iType = -1;
        vph.cbData = 0;
    }
    else
    {
        // set <cchPropName> to the length of the property name
        cchPropName = SysStringLen(pvp->bstrPropName);

        // set <varValue.bstrVal> (and length <cchValue>) the value of <*pvp>
        // coerced to a string
        if (FAILED(hrReturn = VariantChangeType(&varValue, &pvp->varValue, 0,
                VT_BSTR)))
            goto ERR_EXIT;
        cchValue = SysStringLen(varValue.bstrVal);

        // initialize the record header
        vph.iType = pvp->varValue.vt;
        vph.cbData = sizeof(cchPropName) + cchPropName * sizeof(OLECHAR) +
            sizeof(cchValue) + cchValue * sizeof(OLECHAR);
    }

    // write out a VariantPropertyHeader
    if (FAILED(hrReturn = pstream->Write(&vph, sizeof(vph), NULL)))
        goto ERR_EXIT;

    if (pvp != NULL)
    {
        // write out the property name
        if (FAILED(hrReturn = pstream->Write(&cchPropName, sizeof(cchPropName),
                NULL)))
            goto ERR_EXIT;
        if (FAILED(hrReturn = pstream->Write(pvp->bstrPropName,
                cchPropName * sizeof(OLECHAR), NULL)))
            goto ERR_EXIT;

        // write out the property value
        if (FAILED(hrReturn = pstream->Write(&cchValue, sizeof(cchValue),
                NULL)))
            goto ERR_EXIT;
        if (FAILED(hrReturn = pstream->Write(varValue.bstrVal,
                cchValue * sizeof(OLECHAR), NULL)))
            goto ERR_EXIT;
    }

    goto EXIT;

ERR_EXIT:

    // error cleanup
    // (nothing to do)
    goto EXIT;

EXIT:

    // normal cleanup
    VariantClear(&varValue);

    return hrReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\mmctl\src\ochelp\urlmon.cpp ===
/****************************************************************************\
	urlmon.cpp - Wrappers for URLMON functions

	This code is part of ochelp.dll.
	The Netscape plugin runs without urlmon.dll. It implements a subset
	of URLMON's functions. The MM Controls all call through these wrappers
	instead of directly calling into urlmon.dll.
	We need to detect whether we're running in the context of IE or
	Navigator and load urlmon.dll or NPHost.dll accordingly.
	In order to detect the Netscape case, we call the FInitCheck()
	entrypoint in NPHost.dll. If the DLL isn't available or the
	call fails, we know we're not running Navigator.
	Finally, we clean up in _DllMainCrtStartup.

	Copyright (c) 1997 Microsoft Corp. All rights reserved.
\****************************************************************************/

#include "precomp.h"
#include <urlmon.h>			// for IBindHost
#include "..\..\inc\ochelp.h"
#include "debug.h"

HINSTANCE hinstUrlmon = NULL;

typedef HRESULT (STDAPICALLTYPE *PFN_CREATEASYNCBINDCTX)(DWORD, IBindStatusCallback *, IEnumFORMATETC *, IBindCtx **);
typedef HRESULT (STDAPICALLTYPE *PFN_CREATEURLMONIKER)(LPMONIKER, LPCWSTR, LPMONIKER FAR *);
typedef HRESULT (STDAPICALLTYPE *PFN_MKPARSEDISPLAYNAMEEX)(IBindCtx *, LPCWSTR, ULONG *, LPMONIKER *);
typedef HRESULT (STDAPICALLTYPE *PFN_REGISTERBINDSTATUSCALLBACK)(LPBC, IBindStatusCallback *, IBindStatusCallback**, DWORD);
typedef HRESULT (STDAPICALLTYPE *PFN_REVOKEBINDSTATUSCALLBACK)(LPBC, IBindStatusCallback *);
typedef HRESULT (STDAPICALLTYPE *PFN_URLOPENSTREAMA)(LPUNKNOWN,LPCSTR,DWORD,LPBINDSTATUSCALLBACK);
typedef HRESULT (STDAPICALLTYPE *PFN_URLDOWNLOADTOCACHEFILEA)(LPUNKNOWN,LPCSTR,LPTSTR,DWORD,DWORD,LPBINDSTATUSCALLBACK);
typedef BOOL	(STDAPICALLTYPE *PFN_FINITCHECK)();

PFN_CREATEASYNCBINDCTX			pfnCreateAsyncBindCtx;
PFN_CREATEURLMONIKER			pfnCreateURLMoniker;
PFN_MKPARSEDISPLAYNAMEEX		pfnMkParseDisplayNameEx;
PFN_REGISTERBINDSTATUSCALLBACK	pfnRegisterBindStatusCallback;
PFN_REVOKEBINDSTATUSCALLBACK	pfnRevokeBindStatusCallback;
PFN_URLOPENSTREAMA				pfnURLOpenStreamA;
PFN_URLDOWNLOADTOCACHEFILEA		pfnURLDownloadToCacheFileA;
PFN_FINITCHECK					pfnFInitCheck;

// These references must be the same in urlmon.dll and nphost.dll.
// Use strings rather than ordinals just to be safe.
const LPCSTR szCreateAsyncBindCtx =			(LPCSTR)"CreateAsyncBindCtx";		//0x0003;	note collision in NPHost
const LPCSTR szCreateURLMoniker =			(LPCSTR)"CreateURLMoniker";			//0x0006;
const LPCSTR szMkParseDisplayNameEx =		(LPCSTR)"MkParseDisplayNameEx";		//0x0019;
const LPCSTR szRegisterBindStatusCallback =	(LPCSTR)"RegisterBindStatusCallback";//0x001A;
const LPCSTR szRevokeBindStatusCallback =	(LPCSTR)"RevokeBindStatusCallback";	//0x001E;
const LPCSTR szURLDownloadToCacheFileA =	(LPCSTR)"URLDownloadToCacheFileA";	//0x0021;
const LPCSTR szURLOpenStreamA =				(LPCSTR)"URLOpenStreamA";			//0x002A;

// This function is only in nphost.dll.
const LPCSTR szFInitCheck =					(LPCSTR)"FInitCheck";

void CleanupUrlmonStubs()
{
	if (hinstUrlmon)
	{
		FreeLibrary(hinstUrlmon);
		hinstUrlmon = NULL;
	}
}

// Really initialize the function pointers.
BOOL FInitStubs()
{
	if (hinstUrlmon)
	{
		// Error: this means the pointers are NULL but we've already loaded a DLL.
		ASSERT(FALSE);
		return FALSE;
	}

	if ((hinstUrlmon = LoadLibrary("nphost.dll")) != NULL)
	{
		// We found nphost.dll. Make sure it's already been
		// initialized by Netscape.

		pfnFInitCheck = (PFN_FINITCHECK)GetProcAddress(hinstUrlmon, szFInitCheck);
		if (pfnFInitCheck && pfnFInitCheck())
		{
#if defined(_DEBUG) || defined(_DESIGN)
			::OutputDebugString("Using NPHOST.DLL instead of URLMON.DLL\n");
#endif
		}
		else
		{
			FreeLibrary(hinstUrlmon);
			hinstUrlmon = NULL;
		}
	
	}

	if (!hinstUrlmon)
	{
		hinstUrlmon = LoadLibrary("urlmon.dll");
		if (hinstUrlmon == NULL)
		{
			// We already checked this at init time so it should succeed here.
			ASSERT(FALSE);
			return FALSE;
		}
	}

	pfnCreateAsyncBindCtx =			(PFN_CREATEASYNCBINDCTX)		GetProcAddress(hinstUrlmon, szCreateAsyncBindCtx);
	pfnCreateURLMoniker =			(PFN_CREATEURLMONIKER)			GetProcAddress(hinstUrlmon, szCreateURLMoniker);
	pfnMkParseDisplayNameEx =		(PFN_MKPARSEDISPLAYNAMEEX)		GetProcAddress(hinstUrlmon, szMkParseDisplayNameEx );
	pfnRegisterBindStatusCallback =	(PFN_REGISTERBINDSTATUSCALLBACK)GetProcAddress(hinstUrlmon, szRegisterBindStatusCallback);
	pfnRevokeBindStatusCallback =	(PFN_REVOKEBINDSTATUSCALLBACK)	GetProcAddress(hinstUrlmon, szRevokeBindStatusCallback);
	pfnURLOpenStreamA =				(PFN_URLOPENSTREAMA)			GetProcAddress(hinstUrlmon, szURLOpenStreamA);
	pfnURLDownloadToCacheFileA =	(PFN_URLDOWNLOADTOCACHEFILEA)	GetProcAddress(hinstUrlmon, szURLDownloadToCacheFileA);

	if (!pfnCreateAsyncBindCtx			||
		!pfnMkParseDisplayNameEx		||
		!pfnRegisterBindStatusCallback	||
		!pfnRevokeBindStatusCallback	||
		!pfnURLOpenStreamA				||
		!pfnURLDownloadToCacheFileA)
	{
		CleanupUrlmonStubs();
		return FALSE;
	}

	return TRUE;
}


STDAPI HelpCreateAsyncBindCtx(DWORD reserved, IBindStatusCallback *pBSCb, IEnumFORMATETC *pEFetc, IBindCtx **ppBC)
{
	if (!pfnCreateAsyncBindCtx && !FInitStubs())
		return E_UNEXPECTED;

	return pfnCreateAsyncBindCtx(reserved, pBSCb, pEFetc, ppBC);
}

STDAPI HelpCreateURLMoniker(LPMONIKER pMkCtx, LPCWSTR szURL, LPMONIKER FAR * ppmk)
{
	if (!pfnCreateURLMoniker && !FInitStubs())
		return E_UNEXPECTED;

	return pfnCreateURLMoniker(pMkCtx, szURL, ppmk);
}

STDAPI HelpMkParseDisplayNameEx(IBindCtx *pbc, LPCWSTR szDisplayName, ULONG *pchEaten, LPMONIKER *ppmk)
{
	if (!pfnMkParseDisplayNameEx && !FInitStubs())
		return E_UNEXPECTED;

	return pfnMkParseDisplayNameEx(pbc, szDisplayName, pchEaten, ppmk);
}

STDAPI HelpRegisterBindStatusCallback(LPBC pBC, IBindStatusCallback *pBSCb, IBindStatusCallback** ppBSCBPrev, DWORD dwReserved)
{
	if (!pfnRegisterBindStatusCallback && !FInitStubs())
		return E_UNEXPECTED;

	return pfnRegisterBindStatusCallback(pBC, pBSCb, ppBSCBPrev, dwReserved);
}

STDAPI HelpRevokeBindStatusCallback(LPBC pBC, IBindStatusCallback *pBSCb)
{
	if (!pfnRevokeBindStatusCallback && !FInitStubs())
		return E_UNEXPECTED;

	return pfnRevokeBindStatusCallback(pBC, pBSCb);
}

STDAPI HelpURLOpenStreamA(LPUNKNOWN punk, LPCSTR szURL, DWORD dwReserved, LPBINDSTATUSCALLBACK pbsc)
{
	if (!pfnURLOpenStreamA && !FInitStubs())
		return E_UNEXPECTED;

	return pfnURLOpenStreamA(punk, szURL, dwReserved, pbsc);
}

STDAPI HelpURLDownloadToCacheFileA(LPUNKNOWN punk, LPCSTR szURL, LPTSTR szFile, DWORD cch, DWORD dwReserved, LPBINDSTATUSCALLBACK pbsc)
{
	if (!pfnURLDownloadToCacheFileA && !FInitStubs())
		return E_UNEXPECTED;

	return pfnURLDownloadToCacheFileA(punk, szURL, szFile, cch, dwReserved, pbsc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\mmseq\actq.h ===
/*-----------------------------------------------------------------------------
@doc
@module actq.h | Action queue class declarations.
@author 2-18-97 | pauld | Created
-----------------------------------------------------------------------------*/

#ifndef _ACTQ_H__
#define _ACTQ_H__

class CAction;

struct CActionQueueItem
{
	CActionQueueItem (CAction * pcAction, DWORD dwTimeToFire)
		{Proclaim (NULL != pcAction); m_pcAction = pcAction; m_dwTimeToFire = dwTimeToFire;}

	CAction * m_pcAction;
	DWORD m_dwTimeToFire;
};

typedef CPtrDrg<CActionQueueItem> CActionQueueItemDrg;

class CActionQueue
{

 public :

	CActionQueue (void);
	~CActionQueue (void);

	HRESULT Add (CAction * pcAction, DWORD dwNextAdviseTime);
	HRESULT Execute (DWORD dwBaseTime, DWORD dwCurrentTime);

 protected :

	HRESULT AddNewItemToQueue (CActionQueueItem * pcNewQueueItem);
	CActionQueueItemDrg m_cdrgActionsToFire;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\mmseq\actq.cpp ===
/*-----------------------------------------------------------------------------
@doc
@module actq.cpp | Action set class declarations.
@author 12-9-96 | pauld | Autodoc'd
-----------------------------------------------------------------------------*/

#include "..\ihbase\precomp.h"
#include "memlayer.h"
#include "..\ihbase\debug.h"
#include "debug.h"
#include "drg.h"
#include "strwrap.h"
#include "caction.h"
#include "actq.h"

/*-----------------------------------------------------------------------------
@method | CActionQueue | CActionQueue | Constructor
-----------------------------------------------------------------------------*/
CActionQueue::CActionQueue (void)
{
}

/*-----------------------------------------------------------------------------
@method | CActionQueue | ~CActionQueue | Destructor
-----------------------------------------------------------------------------*/
CActionQueue::~CActionQueue (void)
{
}


/*-----------------------------------------------------------------------------
@method | CActionQueue | AddNewItemToQueue | Adds an action to the list, sorted first by time, then by tiebreak.
@rdesc	Success or failure code.
-----------------------------------------------------------------------------*/
HRESULT
CActionQueue::AddNewItemToQueue (CActionQueueItem * pcNewQueueItem)
{
	HRESULT hr = E_FAIL;
	int iCount = m_cdrgActionsToFire.Count();

	Proclaim(NULL != pcNewQueueItem);
	Proclaim(NULL != pcNewQueueItem->m_pcAction);
	if ((NULL != pcNewQueueItem) && (NULL != pcNewQueueItem->m_pcAction))
	{
		CAction * pcNewAction = pcNewQueueItem->m_pcAction;

		for (register int i = 0; i < iCount; i++)
		{
			CActionQueueItem * pcItemInQueue = m_cdrgActionsToFire[i];
			Proclaim(NULL != pcItemInQueue);
			Proclaim(NULL != pcItemInQueue->m_pcAction);
			if ((NULL != pcItemInQueue) && (NULL != pcItemInQueue->m_pcAction))
			{
				CAction * pcActionInQueue = pcItemInQueue->m_pcAction;
				// First sort by time.
				// Next look at tiebreak numbers.
				if ((pcNewQueueItem->m_dwTimeToFire < pcItemInQueue->m_dwTimeToFire) ||
					 (pcNewAction->GetTieBreakNumber() < pcActionInQueue->GetTieBreakNumber()))
				{
					if (m_cdrgActionsToFire.Insert(pcNewQueueItem, i))
					{
						hr = S_OK;
					}
					break;
				}
			}
			else
			{
				break;
			}
		}

		// It goes last in the queue.
		if (iCount == i)
		{
			if (m_cdrgActionsToFire.Insert(pcNewQueueItem))
			{
				hr = S_OK;
			}
		}
	}

	return hr;
}

/*-----------------------------------------------------------------------------
@method | CActionQueue | Add | Adds an action to the list, sorted first by time, then by tiebreak.
@rdesc	Success or failure code.
-----------------------------------------------------------------------------*/
HRESULT 
CActionQueue::Add (CAction * pcAction, DWORD dwTimeToFire)
{
	HRESULT hr = E_FAIL;

	Proclaim(NULL != pcAction);
	if ((NULL != pcAction) && (pcAction->IsValid()))
	{
		CActionQueueItem * pcNewQueueItem = New CActionQueueItem(pcAction, dwTimeToFire);

		Proclaim(NULL != pcNewQueueItem);
		if (NULL != pcNewQueueItem) 
		{
			hr = AddNewItemToQueue(pcNewQueueItem);
		}
	}

	return hr;
}


/*-----------------------------------------------------------------------------
@method | CActionQueue | Execute | Execute all of the actions in the list.
@comm We do not currently report failures from Invoke.  Failure only occurs when the list items are munged.
@rdesc	Success or failure code.  
-----------------------------------------------------------------------------*/
HRESULT 
CActionQueue::Execute (DWORD dwBaseTime, DWORD dwCurrentTime)
{
	HRESULT hr = S_OK;
	int iCount = m_cdrgActionsToFire.Count();

#ifdef DEBUG_TIMER_QUEUE
	TCHAR szBuffer[0x100];
	CStringWrapper::Sprintf(szBuffer, "Firing %d actions\n", iCount);
	::OutputDebugString(szBuffer);
#endif

	for (register int i = 0; i < iCount; i++)
	{
		CActionQueueItem * pcQueueItem = m_cdrgActionsToFire[0];

		// The pointer will be NULL only when the queue is munged.
		// We want to bail out immediately.
		Proclaim(NULL != pcQueueItem);
		Proclaim(NULL != pcQueueItem->m_pcAction);
		if ((NULL != pcQueueItem) && (NULL != pcQueueItem->m_pcAction))
		{
			// We do not report errors on individual action invokes.
			pcQueueItem->m_pcAction->FireMe(dwBaseTime, dwCurrentTime);
			// Remove the item from the queue, and delete the timing wrapper.
			m_cdrgActionsToFire.Remove(0);
			Delete pcQueueItem;
		}
		else
		{
			hr = E_FAIL;
			break;
		}
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\mmseq\caction.h ===
//	IHammer CAction class definition
//	Van Kichline

#ifndef _CACTION_H_
#define _CACTION_H_

#include "utils.h"

interface IHTMLWindow2;
class CActionSet;

//	Represents an automation object and method.
//
class CAction
{
public:
	CAction (BOOL fBindEngine);
	virtual	~CAction ();

    STDMETHODIMP_( void ) Destroy( void );

	STDMETHODIMP_(BOOL) SetScriptletName (BSTR bstrScriptlet);
	STDMETHODIMP_( ULONG ) GetStartTime ( void )				{ return m_nStartTime; }
	STDMETHODIMP_( void	 ) SetStartTime ( ULONG nStartTime );

	STDMETHODIMP_( ULONG ) GetRepeatCount ( void )	{ return m_nRepeatCount; }
	STDMETHODIMP_( void  ) SetRepeatCount ( ULONG nRepeatCount);
	STDMETHODIMP_( ULONG ) GetSamplingRate ( void )	{ return m_nSamplingRate; }
	STDMETHODIMP_( void  ) SetSamplingRate ( ULONG nSamplingRate);

	STDMETHODIMP ResolveActionInfo ( LPOLECONTAINER piocContainer);
	STDMETHODIMP FireMe ( DWORD dwBaseTime, DWORD dwCurrentTime);
	DWORD GetNextTimeDue (DWORD dwBaseTime);
	ULONG GetExecIteration (void);
	ULONG InitExecState (void);
	void SetCountersForTime (DWORD dwBaseTime, DWORD dwNewTimeOffset);
	void AccountForPauseTime (DWORD dwPausedTicks);

	// Is the action fully specified?
	STDMETHODIMP_( BOOL	) IsValid ();

	// Do we have an active advise sink?
	STDMETHODIMP_( BOOL) IsBusy (void);

	STDMETHODIMP IsActive (void);

	STDMETHODIMP_( DWORD) GetTieBreakNumber	( void )		{ return m_dwTieBreakNumber; }
	STDMETHODIMP_( void ) SetTieBreakNumber	( DWORD dwTieBreakNumber ) { m_dwTieBreakNumber = dwTieBreakNumber; }
	STDMETHODIMP_( DWORD) GetDropTolerance	( void )		{ return m_dwDropTolerance; }
	STDMETHODIMP_( void ) SetDropTolerance	( DWORD dwDropTolerance ) { m_dwDropTolerance = dwDropTolerance; }

#ifdef DEBUG_TIMER_RESOLUTION
	void	SampleInvokes (PDWORD pdwInvokeTime, PDWORD pdwNumInvokes)
		{ *pdwInvokeTime = m_dwTotalInInvokes; *pdwNumInvokes = m_dwInvokes; }
#endif // DEBUG_TIMER_RESOLUTION

protected:

	void			CleanUp ( void );
	ULONG			DecrementExecIteration (void);

private:
	HRESULT         GetRootUnknownForObjectModel (LPOLECONTAINER piocContainer, LPUNKNOWN * ppiunkRoot);
	HRESULT         ResolveActionInfoForScript (LPOLECONTAINER piocContainer);
	BOOL MakeScriptletJScript (BSTR bstrScriptlet);
	void Deactivate (void);

	BSTR m_bstrScriptlet;

	BOOL m_fBindEngine;

	IHTMLWindow2 *  m_piHTMLWindow2; // Reference to the window object - we use this to get to the script engine.
	VARIANT m_varLanguage;	// Holds the language string we pump to the script engine.
	IDispatch		*m_pid;				// Pointer to the XObject or the control
	DISPID			m_dispid;			// DISPID of the selected command
	ULONG			m_nStartTime;		// Offset in time to start of action
	ULONG			m_nSamplingRate;	// At what frequency do we repeat?
	ULONG			m_nRepeatCount;		// How many times do we repeat?

	DWORD m_dwLastTimeFired;
	DWORD m_dwNextTimeDue;
	DWORD			m_dwTieBreakNumber;	// Resolves execution collision issues.  When two
										// actions are due to fire at the same time, the higher
										// tiebreak number wins.
	DWORD			m_dwDropTolerance;  // How many milliseconds can we delay executing this action beyond it's
	                                    // proper firing time before we have to drop it?
	ULONG			m_ulExecIteration;	// How many times have we executed this action?

#ifdef DEBUG_TIMER_RESOLUTION
	DWORD m_dwInvokes;
	DWORD m_dwTotalInInvokes;
#endif // DEBUG_TIMER_RESOLUTION

};

#endif _CACTION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\mmseq\dll.cpp ===
// dll.cpp
//
// DLL entry points etc.
//


#ifdef _DEBUG
    #pragma message("_DEBUG is defined")
#else
    #pragma message("_DEBUG isn't defined")
#endif

#ifdef _DESIGN
    #pragma message("_DESIGN is defined")
#else
    #pragma message("_DESIGN isn't defined")
#endif

#include "..\ihbase\precomp.h"

#include <initguid.h> // once per build
#include <olectl.h>
#include <daxpress.h>
#include <itimer.iid>
#include "..\mmctl\inc\ochelp.h"
#include "..\mmctl\inc\mmctlg.h"
#include "..\ihbase\debug.h"
#include "..\ihbase\ihbase.h"
#include "seqctl.h"
#include "seqinit.h"
#include "seqmgr.h"


//////////////////////////////////////////////////////////////////////////////
// globals
//

// general globals
HINSTANCE       g_hinst;        // DLL instance handle
ULONG           g_cLock;        // DLL lock count
ControlInfo     g_ctlinfoSeq, g_ctlinfoSeqMgr;
#ifdef _DEBUG
BOOL			g_fLogDebugOutput; // Controls logging of debug info
#endif

#define USELOGGING
extern "C" DWORD _fltused = (DWORD)(-1);

//////////////////////////////////////////////////////////////////////////////
// DLL Initialization
//

// TODO: Modify the data in this function appropriately


//////////////////////////////////////////////////////////////////////////////
// Standard DLL Entry Points
//

BOOL WINAPI _DllMainCRTStartup(HINSTANCE hInst, DWORD dwReason,LPVOID lpreserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        DisableThreadLibraryCalls(hInst);
        TRACE("SeqCtl DLL loaded\n"); //TODO: Modify me
        g_hinst = hInst;
#ifdef _DEBUG
#ifdef USELOGGING
		g_fLogDebugOutput = TRUE;
#else
		g_fLogDebugOutput = FALSE;
#endif // USELOGGING
#endif // USELOGGING

        InitSeqControlInfo(hInst, &g_ctlinfoSeq, AllocSeqControl);
        InitSeqControlInfo(hInst, &g_ctlinfoSeqMgr, AllocSequencerManager);
	g_ctlinfoSeq.pNext = &g_ctlinfoSeqMgr;
    }
    else
    if (dwReason == DLL_PROCESS_DETACH)
    {
        TRACE("SeqCtl DLL unloaded\n"); //TODO: Modify me
    }

    return TRUE;
}


STDAPI DllRegisterServer(void)
{
    return RegisterControls(&g_ctlinfoSeq, RC_REGISTER);
}


STDAPI DllUnregisterServer(void)
{
	return RegisterControls(&g_ctlinfoSeq, RC_UNREGISTER);
}


STDAPI DllCanUnloadNow()
{
    return ((g_cLock == 0) ? S_OK : S_FALSE);
}

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppv)
{
    return HelpGetClassObject(rclsid, riid, ppv, &g_ctlinfoSeq);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\mmseq\enumobj.h ===
#ifndef __ENUMOBJ_H__
#define __ENUMOBJ_H__

DECLARE_INTERFACE_( ILoadEnum, IUnknown ) 
{
    STDMETHOD( Count   )( THIS_ ULONG * ) PURE;
    STDMETHOD( IsEmpty )( THIS_ BOOL * ) PURE;

    STDMETHOD( Add    )( THIS_ DWORD, IUnknown * ) PURE;
    STDMETHOD( Freeze )( THIS ) PURE;
}; // End ILoadEnum

#define CTRL_MAX 50

class CEnumObjects :
public IEnumDispatch
{
    public:
        CEnumObjects( IEnumControl* );

        // IUnknown methods
        STDMETHODIMP           QueryInterface( REFIID, LPVOID * );
        STDMETHODIMP_( ULONG ) AddRef();
        STDMETHODIMP_( ULONG ) Release();
        
        // IEnumDispatch methods
        STDMETHODIMP Next ( DWORD, IDispatch**, LPDWORD );
	    STDMETHODIMP Skip ( DWORD );
	    STDMETHODIMP Reset( void );
	    STDMETHODIMP Clone( PENUMDISPATCH * );

        // Custom methods
        STDMETHODIMP Init();

        static CEnumObjects * Create( IEnumControl * );

    protected:
        virtual ~CEnumObjects();

        IEnumControl * m_qieoSourceEnum;
        long           m_lRefs;
        IDispatch *    m_aqdspControls[CTRL_MAX];
        ULONG          m_ulNumCtrls;
        ULONG          m_ulCurCtrlIdx;
}; // End Class CEnumObjects

SCODE CreateEnumObjects(IForm * p_qfmSource, IEnumDispatch ** p_qqiedObjects);

#endif // __ENUMOBJ_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\mmseq\cactset.h ===
/*-----------------------------------------------------------------------------
@doc
@module cactset.h | Action set class definition.
@author 12-9-96 | pauld | Autodoc'd
-----------------------------------------------------------------------------*/

#ifndef	_CACTSET_H_
#define _CACTSET_H_

interface ITimer;
interface ITimerSink;
class CActionQueue;
class CMMSeq;

typedef CPtrDrg<CAction> CActionPtrDrg;

class CActionSet :
	public ITimerSink
{
public:
	CActionSet (CMMSeq * pcSeq, BOOL fBindToEngine);
	virtual ~CActionSet ( void );

	STDMETHOD( DeriveDispatches )(LPOLECONTAINER piocContainer);
	// Current Time property.
	HRESULT GetTime (PDWORD pdwCurrentTime);

	HRESULT Seek (DWORD dwCurrentTime);
	// Attach actions dynamically.
	HRESULT At (BSTR bstrScriptlet, double fltStart, int iRepeatCount, double fltSampleRate,
		                  int iTiebreakNumber, double fltDropTol);
	// Play/Pause/Stop the actions.
	STDMETHOD(Play) (ITimer * piTimer, DWORD dwPlayFrom);
	STDMETHOD(Pause) (void);
	STDMETHOD(Resume) (void);
	STDMETHOD(Stop) (void);

	STDMETHOD_(BOOL, IsPaused) (void) const;
	STDMETHOD_(BOOL, IsServicingActions) (void) const;

    // How many actions live in this action set?
    STDMETHOD_( int, CountActions )( void ) const;

	// Return action[n] in the set.
    STDMETHOD_( CAction *, GetAction )( int n ) const;

	// Convenience wrapper for GetAction(n).
    virtual CAction *  operator[](int n ) const
		{  return GetAction(n);  }

	// Do we have any pending actions?
	STDMETHOD_( BOOL, IsBusy ) (void);
	// Revoke any pending advise.
	HRESULT Unadvise (void);
	// Clean out the action set, and destroy all of the actions in it.
	void Clear ( void );

	// For the timer sink.
	STDMETHOD(QueryInterface) (REFIID riid, LPVOID * ppv);
	STDMETHOD_(ULONG, AddRef) (void);
	STDMETHOD_(ULONG, Release) (void);
	STDMETHOD(OnTimer) (VARIANT varTimeAdvise);

protected:

	// Clear the timer variables.  Note : This does not release any valid pointers.  Call ClearTimer for that.
	void InitTimerMembers (void);

	// Add the new action to the action set.
    virtual BOOL AddAction      ( CAction * pcAction );

	// Set or clear the timer.
	STDMETHOD_(void, SetTimer) (ITimer * piTimer);
	STDMETHOD_(void, ClearTimer) (void);

	// The base time is the time all of the actions' start offsets are relative to.
	// We query the timer for it.
	void SetBaseTime (void);
	// Factor a new time offset in with the baseline time.
	void SetNewBase (DWORD dwNewOffset);
	// Request the next advise from the timer.
	HRESULT Advise(DWORD dwNextAdviseTime);
	// Examine the action to see whether it is due to fire, adds it to the action queue if so.  Returns the next time the action
	// is due to fire.
	DWORD EvaluateOneActionForFiring (CAction * pcAction, CActionQueue * pcFireList, DWORD dwCurrentTime);
	// Examine the actions to determine which are due now, and when the next advise should occur.
	HRESULT EvaluateActionsForFiring (CActionQueue * pcFireList, DWORD dwCurrentTime, DWORD * pdwNextAdviseTime);
	// Tell the actions to reset their counters.
	HRESULT InitActionCounters (void);
	// Fast forward the action counter states to the given time offsets.
	void FastForwardActionCounters (DWORD dwNewTimeOffset);
	// Revise the time variables and action counters to reflect a new time offset.
	void ReviseTimeOffset (DWORD dwCurrentTick, DWORD dwNewTimeOffset);
	// Play actions due now, and set up the next timer advise.
	HRESULT PlayNowAndAdviseNext (DWORD dwCurrentTime);
	// Get the current time from the timer service.  Convert from VARIANT.
	HRESULT GetCurrentTickCount (PDWORD pdwCurrentTime);

private:

#ifdef DEBUG_TIMER_RESOLUTION
	void SampleActions (void);
	void ShowSamplingData (void);

	DWORD m_dwIntervals;
	DWORD m_dwTotalIntervals;
	DWORD m_dwLastTime;
	DWORD m_dwTotalInSink;
#endif // DEBUG_TIMER_RESOLUTION

	// The list of actions.
	CActionPtrDrg   m_cdrgActions;
	CMMSeq * m_pcSeq;	
	ITimer * m_piTimer;
	DWORD m_dwBaseTime;
	DWORD m_dwTimerCookie;
	BOOL m_fAdvised;
	BOOL m_fPendingAdvise;
	DWORD m_dwTimePaused;
	BOOL m_fBindToEngine;
	BOOL m_fIgnoreAdvises;
	ULONG m_ulRefs;

};

#endif _CACTSET_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\mmseq\enumseq.h ===
#ifndef __ENUMSEQ_H__
#define __ENUMSEQ_H__

//interface IEnumVARIANT : IUnknown 
//{  
//	virtual HRESULT Next(unsigned long celt, 
//					VARIANT FAR* rgvar, 
//					unsigned long FAR* pceltFetched) = 0;
//	virtual HRESULT Skip(unsigned long celt) = 0;
//	virtual HRESULT Reset() = 0;
//	virtual HRESULT Clone(IEnumVARIANT FAR* FAR* ppenum) = 0;
//};

class CEnumVariant : public IEnumVARIANT
{
protected:
	ULONG m_cRef;
	CMMSeqMgr* m_pCMMSeqMgr;
	DWORD m_dwIndex;
	CListElement<CSeqHashNode>* m_pcListElement;
	BOOL m_fReset;

public:
	CEnumVariant(CMMSeqMgr* pCMMSeqMgr);
	virtual ~CEnumVariant();
	STDMETHOD (QueryInterface)(REFIID refiid, LPVOID* ppvObj);
	STDMETHOD_(ULONG,AddRef)(void);
	STDMETHOD_(ULONG,Release)(void);

	STDMETHOD (Next)(unsigned long celt, VARIANT FAR* rgvar, unsigned long FAR* pceltFetched);
	STDMETHOD (Skip)(unsigned long celt);
	STDMETHOD (Reset)();
	STDMETHOD (Clone)(IEnumVARIANT FAR* FAR* ppenum);
};

#endif //__ENUMSEQ_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\mmseq\enumseq.cpp ===
/*++

Module: 
	enumseq.cpp

Author: 
	ThomasOl

Created: 
	April 1997

Description:
	Implements Sequencer Manager

History:
	4-02-1997	Created

++*/

#include "..\ihbase\precomp.h"
#include "servprov.h"
#include <htmlfilter.h>

#include "..\ihbase\debug.h"
#include "..\ihbase\utils.h"
#include "memlayer.h"

#include "debug.h"
#include "drg.h"
#include "strwrap.h"
#include "seqmgr.h"
#include "enumseq.h"


CEnumVariant::CEnumVariant(CMMSeqMgr* pCMMSeqMgr)
{
	m_pCMMSeqMgr = pCMMSeqMgr;
	if (m_pCMMSeqMgr)
		m_pCMMSeqMgr->AddRef();
	m_cRef = 1;
	Reset();
}

CEnumVariant::~CEnumVariant()
{
	if (m_pCMMSeqMgr)
		m_pCMMSeqMgr->Release();
}

STDMETHODIMP CEnumVariant::QueryInterface(REFIID refiid, LPVOID* ppvObj)
{
	if (!ppvObj)
		return E_INVALIDARG;

	if (IsEqualGUID(refiid, IID_IUnknown) || IsEqualGUID(refiid, IID_IEnumVARIANT))
	{
		*ppvObj = (LPVOID)(IEnumVARIANT*)this;
		AddRef();
	}
	return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CEnumVariant::AddRef(void)
{
	return (ULONG)InterlockedIncrement((LPLONG)&m_cRef);
}

STDMETHODIMP_(ULONG) CEnumVariant::Release(void)
{
	ULONG cRef = (ULONG)InterlockedDecrement((LPLONG)&m_cRef);
	if (!cRef)
	 	delete this;
	return cRef;
}

STDMETHODIMP CEnumVariant::Next(ULONG cElements, VARIANT FAR* pvar,	ULONG FAR* pcElementFetched)
{
	ULONG cCur = 0;
	DWORD dwIndex;
	CListElement<CSeqHashNode>* pcListElement;
	CSeqHashNode* pcSeqHashNode;

	if (pcElementFetched != NULL)
		*pcElementFetched = 0;

	Proclaim(m_pCMMSeqMgr);
	if (!m_pCMMSeqMgr)
		return E_FAIL;

	Proclaim(pvar);
	if (!pvar)
		return E_INVALIDARG;

	//save the current values
	dwIndex = m_pCMMSeqMgr->m_hashTable.m_dwIndex;
    pcListElement = m_pCMMSeqMgr->m_hashTable.m_pcListElement;

	//set to last call
	m_pCMMSeqMgr->m_hashTable.m_dwIndex = m_dwIndex;
    m_pCMMSeqMgr->m_hashTable.m_pcListElement = m_pcListElement;

	while (cCur < cElements)
	{
		pcSeqHashNode = (!m_pcListElement) ?
			m_pCMMSeqMgr->m_hashTable.FindFirst() : 
			m_pCMMSeqMgr->m_hashTable.FindNext();

		if (!pcSeqHashNode)
			break;

		VariantInit(&pvar[cCur]);
		pvar[cCur].vt = VT_DISPATCH;
		pvar[cCur].pdispVal = pcSeqHashNode->m_piMMSeq;
		Proclaim(pcSeqHashNode->m_piMMSeq);
		cCur++;
	}

	// Set count of elements retrieved.
	if (pcElementFetched != NULL)
		*pcElementFetched = cCur;

	//save for next call
	m_dwIndex = m_pCMMSeqMgr->m_hashTable.m_dwIndex;
    m_pcListElement = m_pCMMSeqMgr->m_hashTable.m_pcListElement;

	//restore current values
	m_pCMMSeqMgr->m_hashTable.m_dwIndex = dwIndex;
    m_pCMMSeqMgr->m_hashTable.m_pcListElement = pcListElement;

	return (cCur < cElements) ? ResultFromScode(S_FALSE) : NOERROR;
}

STDMETHODIMP CEnumVariant::Skip(ULONG cElements)
{
	VARIANT var;
	ULONG   cActual = 0;
	HRESULT hr;

	while (cActual < cElements)
	{
		hr = Next(1, &var, NULL);

		if (S_OK != hr)
			break;
		
		cActual++;
	}
	return (cActual < cElements) ? ResultFromScode(S_FALSE) : S_OK;
}

STDMETHODIMP CEnumVariant::Reset()
{
	m_dwIndex = 0;
	m_pcListElement = NULL;
	m_fReset = FALSE;
	return S_OK;
}

STDMETHODIMP CEnumVariant::Clone(IEnumVARIANT FAR* FAR* ppenum)
{
	CEnumVariant* pEV;
	HRESULT hr=E_FAIL;

	Proclaim(ppenum);
	if (!ppenum)
		return E_INVALIDARG;

	pEV = New CEnumVariant(m_pCMMSeqMgr);
	if (pEV)
	{
		hr = pEV->QueryInterface(IID_IEnumVARIANT, (LPVOID*)ppenum);
		pEV->Release();
	}
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\mmseq\purevirt.c ===
// purevirt.c
//
// Avoids use of C runtime.
//

void __cdecl _purecall(void)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\mmseq\caction.cpp ===
//      IHammer CAction class
//      Van Kichline

#include "..\ihbase\precomp.h"
#include <htmlfilter.h>
#include "mbstring.h"
#include "..\ihbase\debug.h"
#include "actdata.h"
#include <itimer.iid>
#undef Delete
#include "mshtml.h"
#define Delete delete
#include "tchar.h"
#include "objbase.h"
#include "IHammer.h"
#include "strwrap.h"
#include "CAction.h"

#define cTagBufferLength            (0x20)
#define cDataBufferDefaultLength    (0x100)

#pragma warning(disable:4355)   // Using 'this' in constructor

CAction::CAction (BOOL fBindEngine)
{
        m_bstrScriptlet = NULL;
        m_fBindEngine = fBindEngine;
        m_piHTMLWindow2 = NULL;
        ::VariantInit(&m_varLanguage);
        m_pid                   = NULL;
        m_dispid                = DISPID_UNKNOWN;       // Non-existant DISPID
        m_nStartTime    = 0;
        m_nSamplingRate = 0;
        m_nRepeatCount  = 1;
        m_dwTieBreakNumber = 0;
        m_dwDropTolerance = g_dwTimeInfinite;
        InitExecState();

#ifdef DEBUG_TIMER_RESOLUTION
        m_dwInvokes = 0;
        m_dwTotalInInvokes = 0;
#endif // DEBUG_TIMER_RESOLUTION

}
#pragma warning(default:4355)   // Using 'this' in constructor

CAction::~CAction ()
{
        CleanUp ();

}

/*-----------------------------------------------------------------------------
@method void | CAction | Destroy | Instead of calling the C++ delete function
        one must call this Destroy member.
@comm   
-----------------------------------------------------------------------------*/
STDMETHODIMP_( void ) CAction::Destroy( void ) 
{
        Delete this;
} // End CAction::Destroy

/*-----------------------------------------------------------------------------
@method ULONG | CAction | InitExecState | Initialize the execution iteration count and next time due.
@rdesc  Returns the number of times we have yet to execute this action.
-----------------------------------------------------------------------------*/
ULONG 
CAction::InitExecState (void)
{
        m_dwNextTimeDue = g_dwTimeInfinite;
        m_dwLastTimeFired = g_dwTimeInfinite;
        m_ulExecIteration = m_nRepeatCount;
        return m_ulExecIteration;
}


/*-----------------------------------------------------------------------------
@method ULONG | CAction | GetExecIteration | Get the execution iteration count.
@rdesc  Returns the number of times we have yet to execute this action.
-----------------------------------------------------------------------------*/
ULONG
CAction::GetExecIteration (void)
{
        return m_ulExecIteration;
}


/*-----------------------------------------------------------------------------
@method ULONG | CAction | DecrementExecIteration | Bump the execution iteration count down.
@comm   We do not decrement past zero, and we do not decrement when we have an infinite repeat count.
@rdesc  Returns the number of times we've called this method.
-----------------------------------------------------------------------------*/
ULONG
CAction::DecrementExecIteration (void)
{
        // Never decrement past zero,
        // and never decrement when we're
        // supposed to execute infinitely.
        if ((0 != m_ulExecIteration) && (g_dwTimeInfinite != m_ulExecIteration))
        {
                --m_ulExecIteration;
        }

        return m_ulExecIteration;
}


/*-----------------------------------------------------------------------------
@method void | CAction | Deactivate | Deactivate this action - it won't happen again.
-----------------------------------------------------------------------------*/
void
CAction::Deactivate (void)
{
        m_ulExecIteration = 0;
        m_dwNextTimeDue = g_dwTimeInfinite;
}


/*-----------------------------------------------------------------------------
@method void | CAction | SetCountersForTime | Bump the execution iteration count up to the value appropriate for the given time.
-----------------------------------------------------------------------------*/
void 
CAction::SetCountersForTime (DWORD dwBaseTime, DWORD dwNewTimeOffset)
{
        m_dwNextTimeDue = dwBaseTime + m_nStartTime;
        while (m_dwNextTimeDue < (dwBaseTime + dwNewTimeOffset))
        {
                m_dwLastTimeFired = m_dwNextTimeDue;
                DecrementExecIteration();
                if (0 < GetExecIteration())
                {
                        m_dwNextTimeDue += m_nSamplingRate;
                }
                else
                {
                        m_dwNextTimeDue = g_dwTimeInfinite;
                }
        }
}


/*-----------------------------------------------------------------------------
@method void | CAction | AccountForPauseTime | Factor pause time into the last fired and next due vars.
-----------------------------------------------------------------------------*/
void 
CAction::AccountForPauseTime (DWORD dwPausedTicks)
{
        if (g_dwTimeInfinite != m_dwLastTimeFired)
        {
                m_dwLastTimeFired += dwPausedTicks;
        }
        if (g_dwTimeInfinite != m_dwNextTimeDue)
        {
                m_dwNextTimeDue += dwPausedTicks;
        }
}

/*-----------------------------------------------------------------------------
@method ULONG | CAction | GetNextTimeDue | Gets the next time this action is due to fire.
@comm   This method factors in the the base time, the current time and the drop tolerance.
@rdesc  Returns the next time we're due to fire, or g_dwTimeInfinite if it will never be due.
-----------------------------------------------------------------------------*/
DWORD
CAction::GetNextTimeDue (DWORD dwBaseTime)
{
        // This won't be initialized the first time through.
        if (g_dwTimeInfinite == m_dwLastTimeFired)
        {
                m_dwNextTimeDue = dwBaseTime + m_nStartTime;
        }

        return m_dwNextTimeDue;
}

CAction::IsValid ( void )
{
        BOOL    fValid  = FALSE;

        // If we're bound to the script engine check for 
        // a reference to the window object.  Otherwise,
        // check the dispatch/dispid.
        if ((m_fBindEngine && (NULL != m_piHTMLWindow2)) ||
                (( NULL != m_pid ) && ( DISPID_UNKNOWN != m_dispid )))
        {
                Proclaim(NULL != m_bstrScriptlet);
                fValid = (NULL != m_bstrScriptlet);
        }
        return fValid;
}


/*-----------------------------------------------------------------------------
@method HRESULT | CAction | GetRootUnknownForObjectModel | Find the root unknown for the trident object model.
@rdesc  Returns success or failure code.
@xref   <m CAction::ResolveActionInfoFromObjectModel>
-----------------------------------------------------------------------------*/
HRESULT
CAction::GetRootUnknownForObjectModel (LPOLECONTAINER piocContainer, LPUNKNOWN * ppiunkRoot)
{
        HRESULT hr = E_FAIL;

        ASSERT(NULL != ppiunkRoot);
        ASSERT(NULL != piocContainer);

        if ((NULL != ppiunkRoot) && (NULL != piocContainer))
        {
                LPUNKNOWN piunkContainer = NULL;

                // Get the container's IUnknown.
                if (SUCCEEDED(hr = piocContainer->QueryInterface(IID_IUnknown, (LPVOID *)&piunkContainer)))
                {
                        // Get the container's HTML Document.
                        IHTMLDocument * piHTMLDoc = NULL;

                        if (SUCCEEDED(hr = piunkContainer->QueryInterface(IID_IHTMLDocument, (LPVOID *)&piHTMLDoc)))
                        {
                                // Ask the HTML document for the window object's dispatch.
                                hr = piHTMLDoc->get_Script((LPDISPATCH *)ppiunkRoot);
                                ASSERT(SUCCEEDED(hr));
                                piHTMLDoc->Release();
                        }
                        piunkContainer->Release();
                }
        }
        else
        {
                hr = E_POINTER;
        }

        return hr;
}


/*-----------------------------------------------------------------------------
@method HRESULT | CAction | ResolveActionInfoForScript | Derive the IDispatch, DISPID,
        and parameter info of this script action, using the trident object model.
@rdesc  Returns success or failure code.
@xref   <m CAction::ResolveActionInfo>
-----------------------------------------------------------------------------*/
HRESULT
CAction::ResolveActionInfoForScript (LPOLECONTAINER piocContainer)
{
        HRESULT hr = E_FAIL;

        if (m_fBindEngine)
        {
                LPUNKNOWN piUnknownRoot = NULL;

                Proclaim(NULL == m_piHTMLWindow2);
                // Get a reference to the root window object.
                if (SUCCEEDED(piocContainer->QueryInterface(IID_IUnknown, (LPVOID *)&piUnknownRoot)))
                {
                        IHTMLDocument * piHTMLDoc = NULL;
                        if (SUCCEEDED(piUnknownRoot->QueryInterface(IID_IHTMLDocument, (LPVOID *)&piHTMLDoc)))
                        {
                                LPDISPATCH piWindowDispatch = NULL;

                                if (SUCCEEDED(hr = piHTMLDoc->get_Script(&piWindowDispatch)))
                                {
                                        if (SUCCEEDED(hr = piWindowDispatch->QueryInterface(IID_IHTMLWindow2, (LPVOID *)&m_piHTMLWindow2)))
                                        {
                                                // Allocate the language string for the setTimeout call.
                                                V_VT(&m_varLanguage) = VT_BSTR;
                                                V_BSTR(&m_varLanguage) = ::SysAllocString(L"JScript");
                                        }
                                        piWindowDispatch->Release();
                                }
                                piHTMLDoc->Release();
                        }
                        piUnknownRoot->Release();
                }
        }
        else
        {
                // Get the container's IUnknown.
                Proclaim(NULL == m_pid);
                Proclaim(DISPID_UNKNOWN == m_dispid);
                if (SUCCEEDED(hr = GetRootUnknownForObjectModel(piocContainer, (LPUNKNOWN *)&m_pid)))
                {
                                OLECHAR * rgwcName[1] = {m_bstrScriptlet};
                                hr = m_pid->GetIDsOfNames( IID_NULL, (OLECHAR **)rgwcName, 1, 409, &m_dispid);
                }
        }

        return hr;
}

/*-----------------------------------------------------------------------------
@method HRESULT | CAction | ResolveActionInfo | Derive the IDispatch, DISPID, and parameter info
        of this action.
@rdesc  Returns E_FAIL if one of the lookups fails, or if we're trying to talk to ourselves.
-----------------------------------------------------------------------------*/
HRESULT
CAction::ResolveActionInfo ( LPOLECONTAINER piocContainer)
{
        HRESULT hr = E_FAIL;

        if ((m_fBindEngine && (NULL == m_piHTMLWindow2)) || 
                ((!m_fBindEngine) && (NULL == m_pid)))
        {
                // Make sure we've got what we need to start with.
                if (NULL != m_bstrScriptlet)
                {
                        hr = ResolveActionInfoForScript(piocContainer);
                }
        }
        else
        {
                // This object has already been initialized!  Just return.
                hr = S_OK;
        }

        return hr;
}


#ifdef DEBUG_TIMER_RESOLUTION
#include "MMSYSTEM.H"
#endif //DEBUG_TIMER_RESOLUTION

HRESULT CAction::FireMe (DWORD dwBaseTime, DWORD dwCurrentTime)
{
        HRESULT hr = E_FAIL;
        DISPID dispIDNamedArgument = DISPID_UNKNOWN;
        BOOL fDropped = ((dwCurrentTime - m_dwNextTimeDue) > m_dwDropTolerance);

#ifdef DEBUG_TIMER
        TCHAR szBuffer[0x100];
        CStringWrapper::Sprintf(szBuffer, "(%u)\n", m_nRepeatCount - GetExecIteration());
        ::OutputDebugString(szBuffer);
#endif

        DecrementExecIteration();
        m_dwLastTimeFired = dwCurrentTime;

        // If we have not exceeded the drop tolerance invoke the action.
        if (!fDropped)
        {

#ifdef DEBUG_TIMER_RESOLUTION
                m_dwInvokes++;
                DWORD dwTimeStart = ::timeGetTime();
#endif // DEBUG_TIMER_RESOLUTION

                if (m_fBindEngine && (NULL != m_piHTMLWindow2))
                {
                        VARIANT varRet;
                        VariantInit(&varRet);
                        hr = m_piHTMLWindow2->execScript(m_bstrScriptlet, V_BSTR(&m_varLanguage), &varRet);
                }
                else if (NULL != m_pid)
                {
                        DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};
                        hr = m_pid->Invoke(m_dispid, IID_NULL, LOCALE_SYSTEM_DEFAULT,
                                                           DISPATCH_METHOD, &dispparamsNoArgs, NULL, NULL, NULL);
                }

#ifdef DEBUG_TIMER_RESOLUTION
                DWORD dwTimeFinish = ::timeGetTime();
                m_dwTotalInInvokes += (dwTimeFinish - dwTimeStart);
#endif // DEBUG_TIMER_RESOLUTION

        }
        // If the action was dropped - then we DO want it to happen again.
        else
        {
                hr = S_OK;
        }

        // Set up the next time due.  It will be g_dwTimeInfinite when we've executed 
        // for the last time.
        if (0 < GetExecIteration())
        {
                // If the action did not succeed, don't let it happen again.
                if (SUCCEEDED(hr))
                {
                        m_dwNextTimeDue += GetSamplingRate();
                }
                else
                {
                        Deactivate();
                }
        }
        else
        {
                m_dwNextTimeDue = g_dwTimeInfinite;
        }

        return hr;
}

BOOL
CAction::MakeScriptletJScript (BSTR bstrScriptlet)
{
        BOOL fRet = FALSE;
        int iLastPos = CStringWrapper::WStrlen(bstrScriptlet) - 1;

        // Make sure to trim any whitespace off of the end of the scriptlet.
        while ((iLastPos > 0) && (CStringWrapper::Iswspace(bstrScriptlet[iLastPos])))
        {
                --iLastPos;
        }

        // We need to have more than zero characters here in order to care.
        if (0 <= iLastPos)
        {
                // We're not passing params, so we need to append parens.
                if ((wchar_t)')' != bstrScriptlet[iLastPos])
                {
                                // Append parens so that we can execute as jscript.
                                OLECHAR * olestrParens = L"()";
                                unsigned int uiLength = CStringWrapper::WStrlen(bstrScriptlet)  + CStringWrapper::WStrlen(olestrParens);
                                m_bstrScriptlet = ::SysAllocStringLen(NULL, uiLength);
                                Proclaim(NULL != m_bstrScriptlet);
                                if (NULL != m_bstrScriptlet)
                                {
                                        CStringWrapper::WStrcpy(m_bstrScriptlet, bstrScriptlet);
                                        CStringWrapper::WStrcat(m_bstrScriptlet, olestrParens);
                                        fRet = TRUE;
                                }
                }
                else
                {
                        m_bstrScriptlet = ::SysAllocString(bstrScriptlet);
                        Proclaim(NULL != m_bstrScriptlet);
                        if (NULL != m_bstrScriptlet)
                        {
                                fRet = TRUE;
                        }
                }
        }
        return fRet;
}

BOOL
CAction::SetScriptletName (BSTR bstrScriptlet)
{
        BOOL fRet = FALSE;

        // Wipe out the prior command name if there is one.
        if (NULL != m_bstrScriptlet)
        {
                ::SysFreeString(m_bstrScriptlet);
                m_bstrScriptlet = NULL;
        }
        // Copy the new name to the command member.
        Proclaim(NULL != bstrScriptlet);
        if (NULL != bstrScriptlet)
        {
                if (m_fBindEngine)
                {
                        // Append parens if necessary, so we can execute this as jscript.
                        fRet = MakeScriptletJScript(bstrScriptlet);
                }
                else
                {
                        m_bstrScriptlet = ::SysAllocString(bstrScriptlet);
                        Proclaim (NULL != m_bstrScriptlet);
                        if (NULL != m_bstrScriptlet)
                        {
                                fRet = TRUE;
                        }
                }
        }

        return fRet;
}


void CAction::CleanUp ( void )
{
        if (NULL != m_bstrScriptlet)
        {
                ::SysFreeString(m_bstrScriptlet);
                m_bstrScriptlet = NULL;
        }

        if (NULL != m_piHTMLWindow2)
        {
                m_piHTMLWindow2->Release();
                m_piHTMLWindow2 = NULL;
        }
        ::VariantClear(&m_varLanguage);
        if ( NULL != m_pid )
        {
                m_pid->Release ();
                m_pid = NULL;
        }
        m_dispid                = DISPID_UNKNOWN;

        m_nStartTime    = 0;

        m_dwTieBreakNumber = 0;
        m_dwDropTolerance = g_dwTimeInfinite;
        InitExecState();

#ifdef DEBUG_TIMER_RESOLUTION
        m_dwInvokes = 0;
        m_dwTotalInInvokes = 0;
#endif // DEBUG_TIMER_RESOLUTION

}

/*-----------------------------------------------------------------------------
@method  void | CAction | SetStartTime | Sets the start time
@comm
@rdesc   Returns nothing
-----------------------------------------------------------------------------*/
STDMETHODIMP_(void)
CAction::SetStartTime(ULONG nStartTime)
{
        m_nStartTime = nStartTime;
}

/*-----------------------------------------------------------------------------
@method  void | CAction | SetRepeatCount | Sets the repeat count
@comm
@rdesc   Returns nothing
-----------------------------------------------------------------------------*/
STDMETHODIMP_(void)
CAction::SetRepeatCount (ULONG nRepeatCount)
{
        m_nRepeatCount = nRepeatCount;
}

/*-----------------------------------------------------------------------------
@method  void | CAction | SetSamplingRate | Sets the sampling rate
@comm
@rdesc   Returns nothing
-----------------------------------------------------------------------------*/
STDMETHODIMP_(void)
CAction::SetSamplingRate ( ULONG nSamplingRate)
{
        m_nSamplingRate = nSamplingRate;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\mmseq\cactset.cpp ===
/*-----------------------------------------------------------------------------
@doc
@module cactset.cpp | Action set class declarations.
@author 12-9-96 | pauld | Autodoc'd
-----------------------------------------------------------------------------*/

#include "..\ihbase\precomp.h"
#include "..\ihbase\debug.h"
#include <ocmm.h>
#include <htmlfilter.h>
#include "tchar.h"
#include "IHammer.h"
#include "drg.h"
#include "strwrap.h"
#include "actdata.h"
#include "actq.h"
#include "ochelp.h"
#include "seqctl.h"
#include "cactset.h"
#include "CAction.h"

#define cDataBufferDefaultLength    (0x100)
#define cMinimumTimerGranularity (20)
static const int	knStreamVersNum	= 0xA1C50001;	// Version number of stream format

/*-----------------------------------------------------------------------------
@method void | CActionSet | CActionSet | Like it's the Ctor.
@comm   We don't add a reference to this IUnknown since it's the IUnknown of
        the sequencer which contains us. If we did ad a ref we'd have a circular
		ref counting problem. MAKE SURE that this IUnknown is the same one you
		get as when you sequencer->QueryInterface( IUnknown )
-----------------------------------------------------------------------------*/
CActionSet::CActionSet (CMMSeq * pcSeq, BOOL fBindToEngine)
{
	m_ulRefs = 1;
	m_fBindToEngine = fBindToEngine;
	// Weak reference to the control that contain this class.
	m_pcSeq = pcSeq;
	InitTimerMembers();
#ifdef DEBUG_TIMER_RESOLUTION
	m_dwTotalIntervals = 0;
	m_dwIntervals = 0;
	m_dwLastTime = 0;
	m_dwTotalInSink = 0;
#endif
}


CActionSet::~CActionSet ( void )
{
	Clear ();
}

STDMETHODIMP
CActionSet::QueryInterface (REFIID riid, LPVOID * ppv)
{
	HRESULT hr = E_POINTER;

	if (NULL != ppv)
	{
		hr = E_NOINTERFACE;
		if (::IsEqualIID(riid, IID_ITimerSink) || (::IsEqualIID(riid, IID_IUnknown)))
		{
			*ppv = (ITimerSink *)this;
			AddRef();
			hr  = S_OK;
		}
	}

	return hr;
}

STDMETHODIMP_(ULONG)
CActionSet::AddRef (void)
{
	return ++m_ulRefs;
}

STDMETHODIMP_(ULONG)
CActionSet::Release (void)
{
	// We shouldn't ever dip below a refcount of 1.
	Proclaim (1 < m_ulRefs);
	// This object is only used as a timer sink ... we do not 
	// want to delete it after the last external reference 
	// is removed.
	return --m_ulRefs;
}

/*-----------------------------------------------------------------------------
@method void | CActionSet | InitTimerMembers | Initialize all timer-related members.
@comm	Use ClearTimer() to release a timer reference.  We merely NULL the pointer here.
-----------------------------------------------------------------------------*/
void
CActionSet::InitTimerMembers (void)
{
	m_piTimer = NULL;
	m_dwBaseTime = 0;
	m_dwTimerCookie = 0;
	m_fAdvised = FALSE;
	m_fPendingAdvise = FALSE;
	m_dwTimePaused = g_dwTimeInfinite;
	m_fIgnoreAdvises  = FALSE;
}

/*-----------------------------------------------------------------------------
@method void | CActionSet | ClearTimer | Clear the timer.
-----------------------------------------------------------------------------*/
STDMETHODIMP_(void)
CActionSet::ClearTimer (void)
{
	// Let go of the timer.
	if (NULL != m_piTimer)
	{
		if (IsBusy())
		{
			Unadvise();
		}
		m_piTimer->Release();
		m_piTimer = NULL;
	}
}


/*-----------------------------------------------------------------------------
@method void | CActionSet | SetTimer | Set the timer.
@comm	The timer value can be NULL.
-----------------------------------------------------------------------------*/
STDMETHODIMP_(void)
CActionSet::SetTimer (ITimer * piTimer)
{
	// Let go of the previous timer.
	ClearTimer();
	m_piTimer = piTimer;
	if (NULL != m_piTimer)
	{
		m_piTimer->AddRef();
	}
}


/*-----------------------------------------------------------------------------
@method DWORD | CActionSet | EvaluateOneActionForFiring | Determine which actions are due now 
                                                          and when to request the next advise.
@rdesc Returns the next time (after now that is) this action is due to fire.
-----------------------------------------------------------------------------*/
DWORD
CActionSet::EvaluateOneActionForFiring (CAction * pcAction, CActionQueue * pcFireList, DWORD dwCurrentTime)
{
	DWORD dwNextAdviseTime = pcAction->GetNextTimeDue(m_dwBaseTime);
	ULONG ulRepeatsLeft = pcAction->GetExecIteration();

	// If this action is due, add it to the firing list.
	while ((0 < ulRepeatsLeft) && (dwNextAdviseTime <= dwCurrentTime))
	{
		pcFireList->Add(pcAction, dwNextAdviseTime);
		// Is this a periodic action with iterations remaining?
		if (1 < ulRepeatsLeft)
		{
			dwNextAdviseTime += pcAction->GetSamplingRate();
			ulRepeatsLeft--;
		}
		else
		{
			dwNextAdviseTime = g_dwTimeInfinite;
		}
	}

	return dwNextAdviseTime;
}


/*-----------------------------------------------------------------------------
@method HRESULT | CActionSet | EvaluateActionsForFiring | Determine which actions are due now 
                                                          and when to request the next advise.
@rdesc Returns success or error value.  An error occurs when the action set is munged.
-----------------------------------------------------------------------------*/
HRESULT
CActionSet::EvaluateActionsForFiring (CActionQueue * pcFireList, DWORD dwCurrentTime, DWORD * pdwNextAdviseTime)
{
	HRESULT hr = S_OK;
	int iNumActions = m_cdrgActions.Count();

	// We assume the pointer is valid as this is called internally.
	*pdwNextAdviseTime = g_dwTimeInfinite;
	for (register int i = 0; i < iNumActions; i++)
	{
		CAction * pcAction = (CAction *)m_cdrgActions[i];

		Proclaim(NULL != pcAction);
		if (NULL != pcAction)
		{
			// Puts the action into the fire list if appropriate.
			DWORD dwLookaheadFireTime = EvaluateOneActionForFiring(pcAction, pcFireList, dwCurrentTime);
			if (dwLookaheadFireTime < (*pdwNextAdviseTime))
			{
				*pdwNextAdviseTime = dwLookaheadFireTime;
			}
		}
		else
		{
			hr = E_FAIL;
			break;
		}
	}

	return hr;
}


/*-----------------------------------------------------------------------------
@method HRESULT | CActionSet | Advise | Set up the next advise.
@rdesc Returns success or failure code.
-----------------------------------------------------------------------------*/
HRESULT
CActionSet::Advise (DWORD dwNextAdviseTime)
{
	HRESULT hr = E_FAIL;

	Proclaim(NULL != m_piTimer);
	if (NULL != m_piTimer)
	{
		VARIANT varTimeAdvise;
		VARIANT varTimeMax;
		VARIANT varTimeInterval;

		VariantInit(&varTimeAdvise);
		V_VT(&varTimeAdvise) = VT_UI4;
		V_UI4(&varTimeAdvise) = dwNextAdviseTime;
		VariantInit(&varTimeMax);
		V_VT(&varTimeMax) = VT_UI4;
		V_UI4(&varTimeMax) = 0;
		VariantInit(&varTimeInterval);
		V_VT(&varTimeInterval) = VT_UI4;
		V_UI4(&varTimeInterval) = 0;

		hr = m_piTimer->Advise(varTimeAdvise, varTimeMax, varTimeInterval, 0, (ITimerSink *)this, &m_dwTimerCookie);
		Proclaim(SUCCEEDED(hr));
		if (SUCCEEDED(hr))
		{
			m_fAdvised = TRUE;
		}

#ifdef DEBUG_TIMER_ADVISE
		TCHAR szBuffer[0x100];
		CStringWrapper::Sprintf(szBuffer, "%p Advising %u (%u)\n", this, dwNextAdviseTime - m_dwBaseTime, hr);
		::OutputDebugString(szBuffer);
#endif
	}

	return hr;
}


/*-----------------------------------------------------------------------------
@method HRESULT | CActionSet | Unadvise | Cancel any pending advises.
@rdesc Returns success or failure code.
-----------------------------------------------------------------------------*/
HRESULT
CActionSet::Unadvise (void)
{
	HRESULT hr = E_FAIL;

	// Short circuit any pending advises.
	m_fPendingAdvise = FALSE;

	// Wipe out the outstanding advise.
	Proclaim(NULL != m_piTimer);
	if (NULL != m_piTimer)
	{
		if (m_fAdvised)
		{
			Proclaim(0 != m_dwTimerCookie);
			hr = m_piTimer->Unadvise(m_dwTimerCookie);
			m_dwTimerCookie = 0;
			m_fAdvised = FALSE;
		}
		else
		{
			hr = S_OK;
		}
	}

	return hr;
}


/*-----------------------------------------------------------------------------
@method HRESULT | CActionSet | GetCurrentTickCount | Get the current time from our timer.
@rdesc Returns success or failure code.
-----------------------------------------------------------------------------*/
HRESULT
CActionSet::GetCurrentTickCount (PDWORD pdwCurrentTime)
{
	HRESULT hr = E_FAIL;
	Proclaim(NULL != pdwCurrentTime);
	if (NULL != pdwCurrentTime)
	{
		Proclaim(NULL != m_piTimer);
		if (NULL != m_piTimer)
		{
			VARIANT varTime;
			VariantInit(&varTime);
			HRESULT hrTimer = m_piTimer->GetTime(&varTime);
			Proclaim(SUCCEEDED(hrTimer) && (VT_UI4 == V_VT(&varTime)));
			if (SUCCEEDED(hrTimer) && (VT_UI4 == V_VT(&varTime)))
			{
				*pdwCurrentTime = V_UI4(&varTime);
				hr = S_OK;
			}
		}
	}
	return hr;
}


/*-----------------------------------------------------------------------------
@method HRESULT | CActionSet | PlayNowAndAdviseNext | Play current actions, set next advise.
@rdesc Returns success or failure code.
-----------------------------------------------------------------------------*/
HRESULT
CActionSet::PlayNowAndAdviseNext (DWORD dwCurrentTime)
{
	HRESULT hr = S_OK;
	DWORD dwNextAdviseTime = g_dwTimeInfinite;
	CActionQueue cFireList;

	// Clear the advised flag.
	m_fAdvised = FALSE;

	// If the action is due to fire, insert it into the fire list, sorted 
	// according to time/tiebreak number.  Find out the next time we
	// need to request an advise.
	hr = EvaluateActionsForFiring(&cFireList, dwCurrentTime, &dwNextAdviseTime);
	Proclaim(SUCCEEDED(hr));

	// What time is it now?
	if (SUCCEEDED(hr))
	{
		Proclaim(NULL != m_piTimer);
		if (NULL != m_piTimer)
		{
			hr = GetCurrentTickCount(&dwCurrentTime);
			Proclaim(SUCCEEDED(hr));
		}
	}

	// Flag the pending advise call.
	if (SUCCEEDED(hr))
	{
		if (g_dwTimeInfinite != dwNextAdviseTime)
		{
			m_fPendingAdvise = TRUE;
		}
	}

	// Fire the current list.
	if (SUCCEEDED(hr))
	{
		hr = cFireList.Execute(m_dwBaseTime, dwCurrentTime);
		Proclaim(SUCCEEDED(hr));
	}

	// Set up the next advise.  If there's something 
	// wrong with the action set, quit playing and return 
	// an error.
	if (SUCCEEDED(hr))
	{
		if (m_fPendingAdvise)
		{
			m_fPendingAdvise = FALSE;
			hr = Advise(dwNextAdviseTime);
			Proclaim(SUCCEEDED(hr));
		}
#ifdef DEBUG_TIMER_RESOLUTION
		else
		{
			ShowSamplingData();
		}
#endif
	}
	else
	{
		Stop();
	}

	// If we don't have another advise pending, tell the control to 
	// fire its stopped event.
	if (!IsBusy())
	{
		Proclaim(NULL != m_pcSeq);
		if (NULL != m_pcSeq)
		{
			m_pcSeq->NotifyStopped();
		}
	}

	return hr;
}


/*-----------------------------------------------------------------------------
@method void | CActionSet | SetBaseTime | Set the baseline time. 
@comm	This is the time at which we last started to play these actions.
@rdesc Returns success or failure code.
-----------------------------------------------------------------------------*/
void
CActionSet::SetBaseTime (void)
{
	// What's the point without a timer?
	Proclaim (NULL != m_piTimer);
	if (NULL != m_piTimer)
	{
		GetCurrentTickCount(&m_dwBaseTime);
	}
}


/*-----------------------------------------------------------------------------
@method void | CActionSet | SetBaseTime | Set the baseline time to account for a new offset. 
@comm	This is the time at which we last started to play these actions, less the new offset.
-----------------------------------------------------------------------------*/
void
CActionSet::SetNewBase (DWORD dwNewOffset)
{
	m_dwBaseTime += dwNewOffset;
}


/*-----------------------------------------------------------------------------
@method HRESULT | CActionSet | InitActionCounters | Tell the actions to initialize their counters.
@rdesc Returns success or failure code.
-----------------------------------------------------------------------------*/
HRESULT
CActionSet::InitActionCounters (void)
{
	HRESULT hr = S_OK;	
	int iNumActions = m_cdrgActions.Count();

	for (register int i = 0; i < iNumActions; i++)
	{
		CAction * pcAction = (CAction *)m_cdrgActions[i];

		Proclaim(NULL != pcAction);
		if (NULL != pcAction)
		{
			pcAction->InitExecState();
		}
		else
		{
			hr = E_FAIL;
		}
	}

	return hr;
}


/*-----------------------------------------------------------------------------
@method HRESULT | CActionSet | FastForwardActionCounters | Forward the action counters to their states at a given time.
-----------------------------------------------------------------------------*/
void
CActionSet::FastForwardActionCounters (DWORD dwNewTimeOffset)
{
	int iCount = CountActions();
	for (register int i = 0; i < iCount; i++)
	{
		CAction * pcAction = (CAction *)m_cdrgActions[i];
		Proclaim(NULL != pcAction);
		if (NULL != pcAction)
		{
			pcAction->SetCountersForTime(m_dwBaseTime, dwNewTimeOffset);
		}
	}
}


/*-----------------------------------------------------------------------------
@method HRESULT | CActionSet | GetTime | Get the current time offset.
@rdesc Returns success or failure code.
-----------------------------------------------------------------------------*/
HRESULT 
CActionSet::GetTime (PDWORD pdwCurrentTime)
{
	HRESULT hr = E_POINTER;

	Proclaim(NULL != pdwCurrentTime);
	if (NULL != pdwCurrentTime)
	{
		*pdwCurrentTime = 0;
		hr = S_OK;

		if (!IsPaused())
		{
			// If the sequencer is stopped, we don't use the
			// current tick ... the time is zero (set above).
			if (NULL != m_piTimer)
			{
				hr = GetCurrentTickCount(pdwCurrentTime);
				Proclaim(SUCCEEDED(hr));
				if (SUCCEEDED(hr))
				{
					// Subtract out the absolute offset for the time 
					// we started playing this sequencer.
					*pdwCurrentTime -= m_dwBaseTime;
				}
			}
		}
		else
		{
			*pdwCurrentTime = m_dwTimePaused - m_dwBaseTime;
		}
	}

	return hr;
}


/*-----------------------------------------------------------------------------
@method HRESULT | CActionSet | ReviseTimeOffset| Set the current time offset.
-----------------------------------------------------------------------------*/
void
CActionSet::ReviseTimeOffset (DWORD dwCurrentTick, DWORD dwNewTimeOffset)
{
	dwCurrentTick = dwCurrentTick - m_dwBaseTime;
	 m_dwBaseTime = m_dwBaseTime - dwNewTimeOffset + dwCurrentTick;
	// Reset the execution counters based on the new offset.
	FastForwardActionCounters(dwNewTimeOffset);
}


/*-----------------------------------------------------------------------------
@method HRESULT | CActionSet | Seek | Set the current time offset, obeying current play state.
@rdesc Returns success or failure code.
-----------------------------------------------------------------------------*/
HRESULT 
CActionSet::Seek (DWORD dwNewTimeOffset)
{
	HRESULT hr = S_OK;
	DWORD dwCurrentTick = 0;
	BOOL fWasPlaying = IsBusy();

	// Unadvise if we have anything pending.
	Unadvise();
	// Clear all of the execution counters - start from scratch..
	InitActionCounters();
	
	// Account for the new time offset in the baseline time.
	if (!IsPaused())
	{
		hr = GetCurrentTickCount(&dwCurrentTick);
		Proclaim(SUCCEEDED(hr));
	}
	else
	{
		dwCurrentTick = m_dwTimePaused;
	}

	if (SUCCEEDED(hr))
	{
		ReviseTimeOffset(dwCurrentTick, dwNewTimeOffset);
		// Resume playing if we were before.
		if (fWasPlaying)
		{
			hr = Advise(m_dwBaseTime);
			Proclaim(SUCCEEDED(hr));
		}
	}

	return hr;
}


/*-----------------------------------------------------------------------------
@method HRESULT | CActionSet | At | Attach actions dynamically.
@rdesc Returns success or failure code.
-----------------------------------------------------------------------------*/
HRESULT 
CActionSet::At (BSTR bstrScriptlet, double dblStart, int iRepeatCount, double dblSampleRate,
		                 int iTiebreakNumber, double dblDropTol)
{
	HRESULT hr = E_FAIL;

	// An infinite repeat count indicator might be a negative value.
	if ((g_dwTimeInfinite == iRepeatCount) || (0 < iRepeatCount))
	{
		// Fix up any wierd incoming data.
		// Negative start time set to zero.
		if (0. > dblStart)
		{
			dblStart = 0.0;
		}
		// Low sampling rates set to minimum granularity.
		if (( (double)(cMinimumTimerGranularity) / 1000.) > dblSampleRate)
		{
			dblSampleRate = (double)(cMinimumTimerGranularity) / 1000.;
		}
		// Negative tiebreaks set to the maximum value - they will occur behind anything else.
		if (-1 > iTiebreakNumber)
		{
			iTiebreakNumber = -1;
		}
		// Negative drop tolerances set to the maximum value - they will never be dropped.
		if (((double)SEQ_DEFAULT_DROPTOL != dblDropTol) && (0. > dblDropTol))
		{
			dblDropTol = SEQ_DEFAULT_DROPTOL;
		}
		CAction* pcAction = New CAction(m_fBindToEngine);
		Proclaim ( NULL != pcAction );
		if ( NULL != pcAction )
		{
			// Set the members of the action.
			pcAction->SetScriptletName(bstrScriptlet);
			pcAction->SetStartTime((ULONG)(dblStart * 1000.));
			pcAction->SetRepeatCount((ULONG)iRepeatCount);
			if ((g_dwTimeInfinite == iRepeatCount) || (1 < iRepeatCount))
			{
				pcAction->SetSamplingRate((ULONG)(dblSampleRate * 1000.));
			}
			pcAction->SetTieBreakNumber((ULONG)iTiebreakNumber);
			pcAction->SetDropTolerance((g_dwTimeInfinite != (DWORD)dblDropTol) ? (DWORD)(dblDropTol * 1000.) : g_dwTimeInfinite);
			hr = AddAction ( pcAction ) ? S_OK : E_FAIL;

			// If we're already underway, we'll want to treat this is if we'd just started playing.
			if (IsBusy())
			{
				hr = Unadvise();
				Proclaim(SUCCEEDED(hr));
				pcAction->InitExecState();
				hr = Advise(m_dwBaseTime);
				Proclaim(SUCCEEDED(hr));
			}
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}
	}
	else
	{
		// Repeat count of zero?  It's okay with us.
		hr = S_OK;
	}

	return hr;
}


/*-----------------------------------------------------------------------------
@method HRESULT | CActionSet | Play | Start the timed actions.
@rdesc Returns success or failure code.
-----------------------------------------------------------------------------*/
STDMETHODIMP
CActionSet::Play (ITimer * piTimer, DWORD dwStartFromTime)
{
	HRESULT hr = E_POINTER;
	
	if (NULL != piTimer)
	{
		if (SUCCEEDED(hr = InitActionCounters()))
		{
			SetTimer(piTimer);
			SetBaseTime();

			// Play from a time other than 0.
			if (0 != dwStartFromTime)
			{
				ReviseTimeOffset(m_dwBaseTime, dwStartFromTime);
			}

			hr = Advise(m_dwBaseTime);
		}

	}

	return hr;
}


/*-----------------------------------------------------------------------------
@method HRESULT | CActionSet | IsPaused | Is the action set paused?
-----------------------------------------------------------------------------*/
BOOL 
CActionSet::IsPaused (void) const
{
	return (g_dwTimeInfinite != m_dwTimePaused);
}


/*-----------------------------------------------------------------------------
@method HRESULT | CActionSet | IsServicingActions | Are we currently processing actions?
-----------------------------------------------------------------------------*/
BOOL 
CActionSet::IsServicingActions (void) const
{
	return m_fIgnoreAdvises;
}


/*-----------------------------------------------------------------------------
@method HRESULT | CActionSet | Pause | Pause the sequencer, preserving the run state.
@rdesc Returns success or failure code.
-----------------------------------------------------------------------------*/
STDMETHODIMP
CActionSet::Pause (void)
{
	HRESULT hr = S_OK;

	// Don't do the work if there's no timer, if we're not currently playing,
	// or if we're already paused.
	if ((NULL != m_piTimer) && (IsBusy()) && (!IsPaused()))
	{
		hr = Unadvise();
		Proclaim(SUCCEEDED(hr));
		if (SUCCEEDED(hr))
		{
			GetCurrentTickCount(&m_dwTimePaused);
		}
	}

	return hr;
}


/*-----------------------------------------------------------------------------
@method HRESULT | CActionSet | Resume | Resume playing after a pause.
@rdesc Returns success or failure code.
-----------------------------------------------------------------------------*/
STDMETHODIMP
CActionSet::Resume (void)
{
	HRESULT hr = E_FAIL;

	if (IsPaused())
	{
		if (NULL != m_piTimer)
		{
			// Reset the base time to account for the pause.
			DWORD dwCurrentTime = g_dwTimeInfinite;

			hr = GetCurrentTickCount(&dwCurrentTime);
			Proclaim(SUCCEEDED(hr));
			if (SUCCEEDED(hr))
			{
				int iNumActions = CountActions();
				DWORD dwPausedTicks = dwCurrentTime - m_dwTimePaused;
				SetNewBase(dwPausedTicks);
				m_dwTimePaused = g_dwTimeInfinite;

				// Account for the paused time in all actions.
				for (int i = 0; i < iNumActions; i++)
				{
					CAction * pcAction = GetAction(i);
					Proclaim(NULL != pcAction);
					if (NULL != pcAction)
					{
						pcAction->AccountForPauseTime(dwPausedTicks);
					}
					else
					{
						// If our action drg is messed up we should bail out.
						hr = E_FAIL;
						break;
					}
				}

				if (SUCCEEDED(hr))
				{
					hr = Advise(dwCurrentTime);
					Proclaim(SUCCEEDED(hr));
				}
			}
		}
	}
	else
	{
		// Don't care.
		hr = S_OK;
	}

	return hr;
}

#ifdef DEBUG_TIMER_RESOLUTION
/*-----------------------------------------------------------------------------
@method | SCODE | CActionSet | ShowSamplingData | Echo sampling data.
@comm Should only be called from #ifdef'd code!!
@author 11-27-96 | pauld | wrote it
@xref   <m CActionSet::Stop>
-----------------------------------------------------------------------------*/
void
CActionSet::ShowSamplingData (void)
{
	// Calculate the average overhead associated with getting the time.
	DWORD dwSecond = 0;
	DWORD dwFirst = ::timeGetTime();
	for (register int i = 0; i < 100; i++)
	{
		dwSecond = ::timeGetTime();
	}
	float fltAvgOverhead = ((float)dwSecond - (float)dwFirst) / (float)100.0;

	// Find out how long the average invoke took in this action set.
	int iCount = CountActions();
	DWORD dwTotalInvokeTime = 0;
	DWORD dwOneActionInvokeTime = 0;
	DWORD dwTotalInvokes = 0;
	DWORD dwOneActionInvokes = 0;

	// Total the amount of time spent inside of invoke.
	for (i = 0; i < iCount; i++)
	{
		CAction * pcAction = (CAction *)m_cdrgActions[i];
		pcAction->SampleInvokes(&dwOneActionInvokeTime, &dwOneActionInvokes);
		dwTotalInvokeTime += dwOneActionInvokeTime;
		dwTotalInvokes += dwOneActionInvokes;
	}

	// There are two calls to ::timeGetTime per invoke sample.
	float fltAverageInvokeTime = ((float)dwTotalInvokeTime - (fltAvgOverhead * (float)	2.0 * (float)dwTotalInvokes))/ (float)dwTotalInvokes;
	float fltAvgInterval = ((float)m_dwTotalIntervals -  (fltAvgOverhead * (float)m_dwIntervals))/ (float)m_dwIntervals;
	float fltAvgInSink = (float)m_dwTotalInSink / ((float)m_dwIntervals + (float)1.0);

	TCHAR szBuffer[0x200];
	CStringWrapper::Sprintf(szBuffer, "average invoke time %8.2f ms\naverage interval %8.2f ms\naverge time in sink %8.2f ms (Timing overhead averaged %8.2f ms per call)\n", 
		fltAverageInvokeTime, fltAvgInterval, fltAvgInSink, fltAvgOverhead);
	::OutputDebugString(szBuffer);
	::MessageBox(NULL, szBuffer, "Interval Data", MB_OK);
}

#endif // DEBUG_TIMER_RESOLUTION


/*-----------------------------------------------------------------------------
@method HRESULT | CActionSet | Stop | Stop all timed actions.
@rdesc Returns success or failure code.
-----------------------------------------------------------------------------*/
STDMETHODIMP
CActionSet::Stop (void)
{
	HRESULT hr = S_OK;
	
	if (NULL != m_piTimer)
	{
		ClearTimer();
		InitTimerMembers();
	}

#ifdef DEBUG_TIMER_RESOLUTION
	ShowSamplingData();
#endif // DEBUG_TIMER_RESOLUTION

	return hr;
}


/*-----------------------------------------------------------------------------
@method HRESULT | CActionSet | OnTimer | The timer sink has been called.
@rdesc Returns success or failure code.
-----------------------------------------------------------------------------*/
STDMETHODIMP 
CActionSet::OnTimer (VARIANT varTimeAdvise)
{
	HRESULT hr = E_FAIL;

#ifdef DEBUG_TIMER_RESOLUTION
	DWORD m_dwThisTime = ::timeGetTime();
	if (0 < m_dwLastTime)
	{
		DWORD dwThisInterval = m_dwThisTime - m_dwLastTime;
		m_dwIntervals++;
		m_dwTotalIntervals += dwThisInterval;
	}
	m_dwLastTime = m_dwThisTime;
#endif // DEBUG_TIMER_RESOLUTION

	// Protect against sink re-entrancy.
	if (!m_fIgnoreAdvises)
	{
		m_fIgnoreAdvises = TRUE;
		Proclaim (VT_UI4 == V_VT(&varTimeAdvise));
		if (VT_UI4 == V_VT(&varTimeAdvise))
		{
			DWORD dwCurrentTime = V_UI4(&varTimeAdvise);

			hr = PlayNowAndAdviseNext(dwCurrentTime);
			Proclaim(SUCCEEDED(hr));
		}
		m_fIgnoreAdvises = FALSE;
	}
	else
	{
		// We're currently lodged in an advise sink.
		hr = S_OK;
	}

#ifdef DEBUG_TIMER_RESOLUTION
	DWORD m_dwEndTime = ::timeGetTime();
	DWORD dwInSink = m_dwEndTime - m_dwThisTime;
	m_dwTotalInSink += dwInSink;
#endif // DEBUG_TIMER_RESOLUTION

	return hr;
}

/*-----------------------------------------------------------------------------
@method HRESULT | CActionSet | Clear | Clear out the action set and destroy any actions.
-----------------------------------------------------------------------------*/
void CActionSet::Clear ( void )
{
	CAction * pcAction = NULL;
	int nActions = m_cdrgActions.Count();

	for ( int i = 0; i < nActions; i++ )
	{
		pcAction = m_cdrgActions[0];
		m_cdrgActions.Remove(0);
		pcAction->Destroy ();
	}

	m_fBindToEngine = FALSE;
	ClearTimer();
	InitTimerMembers();
}


/*-----------------------------------------------------------------------------
@method HRESULT | CActionSet | AddAction | Add this action to the action set.
@rdesc  Returns one of the following:
@flag       TRUE          | We successfully added the action.
@flag       FALSE         | We could not insert the action into the set. 
                            This is likely a memory problem.
-----------------------------------------------------------------------------*/
BOOL CActionSet::AddAction(CAction * pAction )
{
	BOOL fAdded = FALSE;
	int nActions = m_cdrgActions.Count() + 1;

	if (m_cdrgActions.Insert(pAction, DRG_APPEND))
	{
		// If we're already underway, we'll want to hook this action up.
		if (IsBusy() || IsPaused())
		{
			LPOLECONTAINER piContainer = NULL;
			if (SUCCEEDED(m_pcSeq->GetSiteContainer(&piContainer)))
			{
				pAction->ResolveActionInfo(piContainer);
				piContainer->Release();
				fAdded = TRUE;
			}
		}
		else
		{
			fAdded = TRUE;
		}
	}

	return fAdded;
}


/*-----------------------------------------------------------------------------
@method HRESULT | CActionSet | CountActions | How many actions are in the action set?
@comm   We do not validate actions here.  We count both valid and invalid ones.
@rdesc  Returns the action count.
-----------------------------------------------------------------------------*/
int CActionSet::CountActions( void ) const
{
	return m_cdrgActions.Count();
}


/*-----------------------------------------------------------------------------
@method CAction *| CActionSet | GetAction | Return the nth action in the set.
@comm   We do not validate actions here.  The returned action might be invalid.
@rdesc  Returns a CAction pointer, or NULL if n exceeds the number in the set.
-----------------------------------------------------------------------------*/
CAction* CActionSet::GetAction ( int n ) const
{
	CAction * pcAction = NULL;

	if ( n < m_cdrgActions.Count())
	{
		pcAction = m_cdrgActions[n];
	}

	return pcAction;
}


/*-----------------------------------------------------------------------------
@method HRESULT | CActionSet | DeriveDispatches| Derive the dispatches, dispids, and param info
                                                 for each action in the set.
@rdesc  Always returns S_OK.
-----------------------------------------------------------------------------*/
HRESULT CActionSet::DeriveDispatches ( LPOLECONTAINER piocContainer)
{
	HRESULT hr = S_OK;
	int nActions = m_cdrgActions.Count();
	CAction * pcAction = NULL;

	for (int i = 0; i < nActions; i++)
	{
		pcAction = m_cdrgActions[i];
		Proclaim(NULL != pcAction);
		if (NULL != pcAction)
		{
			pcAction->ResolveActionInfo(piocContainer);
		}
	}

	return hr;
}

/*-----------------------------------------------------------------------------
@method  BOOL | CActionSet | IsBusy | Do we have actions pending?
@rdesc   Returns TRUE if there are actions pending
-----------------------------------------------------------------------------*/
STDMETHODIMP_( BOOL) 
CActionSet::IsBusy (void)
{
	return (m_fAdvised || m_fPendingAdvise);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\mmseq\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//
#define IDS_STRING1                     1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\mmseq\seqctl.h ===
/*++

Module: 
	seqctl.h

Author: 
	IHammer Team (SimonB)

Created: 
	October 1996

Description:
	Defines the control's class

History:
	10-21-1996	Templatized (SimonB)
	10-01-1996	Created

++*/
#ifndef __SEQCTL_H__
#define __SEQCTL_H__

#include "precomp.h"
#include "ihammer.h"
#include "ihbase.h"
#include <daxpress.h>

#define SEQ_DEFAULT_REPEAT_COUNT 1
#define SEQ_DEFAULT_SAMPLING_RATE 0
#define SEQ_DEFAULT_TIEBREAK -1
#define SEQ_DEFAULT_DROPTOL -1

#define SEQ_BASECLASS	\
	CIHBaseCtl <	\
	CMMSeq,			\
	IMMSeq,			\
	&CLSID_MMSeq,	\
	&IID_IMMSeq,	\
	&LIBID_DAExpressLib,	\
	&DIID_IMMSeqEvents>

class CActionSet;

class CMMSeq:
	public IMMSeq,
	public SEQ_BASECLASS
	
{
friend LPUNKNOWN __stdcall AllocSeqControl(LPUNKNOWN punkOuter);

// Template stuff
	typedef SEQ_BASECLASS CMyIHBaseCtl;

public:

	// Callback for the action set.
	void NotifyStopped (void);
	HRESULT GetSiteContainer (LPOLECONTAINER * ppiContainer);

protected:

	// 
	// Constructor and destructor
	// 
	CMMSeq(IUnknown *punkOuter, HRESULT *phr);

    ~CMMSeq();

	// Overrides
	STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, LPVOID *ppv);
	
	STDMETHODIMP DoPersist(IVariantIO* pvio, DWORD dwFlags);
	
	///// IDispatch implementation
	protected:
    STDMETHODIMP GetTypeInfoCount(UINT *pctinfo);
    STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo);
    STDMETHODIMP GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames,
         LCID lcid, DISPID *rgdispid);
    STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid,
        WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult,
        EXCEPINFO *pexcepinfo, UINT *puArgErr);
   

	///// delegating IUnknown implementation
	protected:
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv)
      { return m_punkOuter->QueryInterface(riid, ppv); }
    STDMETHODIMP_(ULONG) AddRef()
      { return m_punkOuter->AddRef(); }
    STDMETHODIMP_(ULONG) Release()
      { return m_punkOuter->Release(); }

	
	//
	// IMMSeq methods 
	//
	protected:
    STDMETHODIMP get_Time (THIS_ double FAR* pdblCurrentTime);
    STDMETHODIMP put_Time (THIS_ double dblCurrentTime);
	STDMETHODIMP get_PlayState (THIS_ int FAR * piPlayState);
    STDMETHOD(put__Cookie)(THIS_ long lCookie) 
		{m_lCookie=lCookie;return S_OK;}
    STDMETHOD(get__Cookie)(THIS_ long FAR* plCookie) 
		{if (!plCookie) return E_POINTER; *plCookie = m_lCookie;return S_OK;}

	STDMETHODIMP Play (void);
	STDMETHODIMP Pause (void);
	STDMETHODIMP Stop (void);
    STDMETHODIMP At (VARIANT varStartTime, BSTR bstrScriptlet, VARIANT varRepeatCount, VARIANT varSampleRate, VARIANT varTiebreakNumber, VARIANT varDropTolerance);
	STDMETHODIMP Clear (void);
    STDMETHODIMP Seek(double dblSeekTime);


	protected:

	enum 
	{
		SEQ_STOPPED = 0,
		SEQ_PLAYING = 1,
		SEQ_PAUSED = 2,
	} PlayState;

	BOOL InitActionSet (BOOL fBindToEngine);
	void Shutdown (void);
	HRESULT DeriveDispatches (void);
	BOOL IsBusy (void);
	HRESULT FindContainerTimer (ITimer ** ppiTimer);
	HRESULT FindDefaultTimer (ITimer ** ppiTimer);
	HRESULT FindTimer (ITimer ** ppiTimer);
	BOOL FurnishDefaultAtParameters (VARIANT * pvarStartTime, VARIANT * pvarRepeatCount, VARIANT * pvarSampleRate, 
			                                              VARIANT * pvarTiebreakNumber, VARIANT * pvarDropTolerance);
	void FireStoppedEvent (void);

	CActionSet * m_pActionSet;
	unsigned long m_ulRef;

	long m_lCookie;
    BOOL m_fSeekFiring;
	DWORD m_dwPlayFrom;

};

#endif // __SEQCTL_H__

// end of file seqctl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\mmseq\seqinit.h ===
/*++

Module: 
	seqinit.h

Author: 
	IHammer Team (SimonB)

Created: 
	May 1997

Description:
	Header for control-specific initialisation

History:
	05-27-1997	Created (SimonB)

++*/
#include "..\mmctl\inc\ochelp.h" // for ControlInfo

#ifndef __SEQINIT_H__
#define __SEQINIT_H__

void InitSeqControlInfo(HINSTANCE hInst, ControlInfo *pCtlInfo, AllocOCProc pAlloc);
void InitSeqMgrControlInfo(HINSTANCE hInst, ControlInfo *pCtlInfo, AllocOCProc pAlloc);

#endif // __SEQINIT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\mmseq\seqinit.cpp ===
/*++

Module: 
	seqinit.cpp

Author: 
	IHammer Team (SimonB)

Created: 
	May 1997

Description:
	Performs control-specific initialisation

History:
	05-26-1997	Created (SimonB)

++*/

#include "..\ihbase\ihbase.h"
#include "..\mmctl\inc\ochelp.h" // for ControlInfo
#include "seqinit.h"
#include "..\resource.h"
#include <daxpress.h>

extern ULONG g_cLock;


void InitSeqControlInfo(HINSTANCE hInst, ControlInfo *pCtlInfo, AllocOCProc pAlloc)
{
    // for some reason I can't statically initalize <g_ctlinfo>, so do it here
    memset(pCtlInfo, 0, sizeof(ControlInfo));
    pCtlInfo->cbSize = sizeof(ControlInfo);
    pCtlInfo->tszProgID = TEXT("DirectAnimation.Sequence");
    pCtlInfo->tszFriendlyName = TEXT("Microsoft DirectAnimation Sequence");
    pCtlInfo->pclsid = &CLSID_MMSeq;
    pCtlInfo->hmodDLL = hInst;
    pCtlInfo->tszVersion = "1.0";
    pCtlInfo->iToolboxBitmapID = -1;
    pCtlInfo->dwMiscStatusContent = CTL_OLEMISC;
    pCtlInfo->pallococ = pAlloc;
    pCtlInfo->pcLock = &g_cLock;
    pCtlInfo->dwFlags = CI_SAFEFORSCRIPTING | 
                        CI_SAFEFORINITIALIZING;

    pCtlInfo->pguidTypeLib = &LIBID_DAExpressLib; // TODO: Change as appropriate
}


void InitSeqMgrControlInfo(HINSTANCE hInst, ControlInfo *pCtlInfo, AllocOCProc pAlloc)
{
    // for some reason I can't statically initalize <g_ctlinfo>, so do it here
    memset(pCtlInfo, 0, sizeof(ControlInfo));
    pCtlInfo->cbSize = sizeof(ControlInfo);
    pCtlInfo->tszProgID = TEXT("DirectAnimation.SequencerControl");
    pCtlInfo->tszFriendlyName = TEXT("Microsoft DirectAnimation Sequencer");
    pCtlInfo->pclsid = &CLSID_SequencerControl;
    pCtlInfo->hmodDLL = hInst;
    pCtlInfo->tszVersion = "1.0";
    pCtlInfo->iToolboxBitmapID = IDB_ICON_SEQUENCER;
    pCtlInfo->dwMiscStatusContent = CTL_OLEMISC;
    pCtlInfo->pallococ = pAlloc;
    pCtlInfo->pcLock = &g_cLock;
    pCtlInfo->dwFlags = CI_CONTROL | CI_SAFEFORSCRIPTING | 
                        CI_SAFEFORINITIALIZING | CI_MMCONTROL;

    pCtlInfo->pguidTypeLib = &LIBID_DAExpressLib; // TODO: Change as appropriate
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\mmseq\seqevent.h ===
/*++

Module: 
	events.h

Author: 
	IHammer Team (SimonB)

Created: 
	October 1996

Description:
	Macros to make firing events easier and safer.  Each macro can be customised for 
	the particular event.  However, the general form should be:

	#define FIRE_EVENTNAME(pConnectionPoint, param1, param2) \
		PConnectionPoint->FireEvent(DISPID_EVENT_EVENTNAME, \
			<VT for param1>, param1, \
			<VT for param2>, param2, \
			0) 
	
	NOTE: The terminating 0 is extremly important !!!

History:
	10-21-1996	Created

++*/

#include "dispids.h"

#ifndef _EVENTS_H_
#define _EVENTS_H_


#define FIRE_SEQLOAD(pConnectionPoint) \
	pConnectionPoint->FireEvent(DISPID_SEQLOAD_EVENT, 0)


#endif // This header file not included

// End of file events.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\mmseq\seqmgr.h ===
/*++

Module: 
        seqmgr.h

Author: 
        ThomasOl

Created: 
        April 2

Description:
        Defines the Sequencer Manager class

History:
        4-02-1997       Created

++*/

#ifndef __SEQMGR_H__
#define __SEQMGR_H__

#include <ihammer.h>
#include "precomp.h"
#include "ihbase.h"
#include <ctype.h>
#include <hash.h>
#include <unknown.h>
#include "daxpress.h"
#include "dispids.h"

struct CookieList {
    long cookie;
    void * pnode;
};

/*
***************************************************************************************************************
*
*
*
*
*
*
***************************************************************************************************************
*/

class CSeqHashNode
{
public:
        TCHAR m_rgchName[CCH_ID];
        IMMSeq* m_piMMSeq;
        IConnectionPoint* m_piConnectionPoint;
        DWORD m_dwUnadviseCookie;

        CSeqHashNode() 
                {m_rgchName[0]=NULL;m_piMMSeq=NULL;m_dwUnadviseCookie=0;m_piConnectionPoint=NULL;}
        CSeqHashNode(TCHAR* prgchName, IMMSeq* piMMSeq) 
        {
                Proclaim(prgchName);
                m_rgchName[0] = 0;
                if (prgchName)
                        lstrcpy(m_rgchName, prgchName);
                m_piMMSeq = piMMSeq;
                if (m_piMMSeq)
                        m_piMMSeq->AddRef();
                m_dwUnadviseCookie=0;
                m_piConnectionPoint=NULL;
        }
        virtual ~CSeqHashNode()
        {
                if (m_piMMSeq)
                        m_piMMSeq->Release();
                if (m_piConnectionPoint)
                {
                        if (m_dwUnadviseCookie)
                                m_piConnectionPoint->Unadvise(m_dwUnadviseCookie);
                        m_piConnectionPoint->Release();
                }
        }
    int operator==(const CSeqHashNode& node) const
    {
                return (lstrcmpi(m_rgchName, node.m_rgchName) == 0);
    }
        CSeqHashNode& operator=(const CSeqHashNode& node)
        {
                lstrcpy(m_rgchName, node.m_rgchName);
                if (m_piMMSeq)
                        m_piMMSeq->Release();
                m_piMMSeq = node.m_piMMSeq;
                if (m_piMMSeq)
                        m_piMMSeq->AddRef();
                m_dwUnadviseCookie = node.m_dwUnadviseCookie;
                return *this;
        }
};

/*
***************************************************************************************************************
*
*
*
*
*
*
***************************************************************************************************************
*/
#define RotBitsLeft(lVal, cBits) (lVal << cBits | lVal >> (32 - cBits))

class CSeqHashTable : public CHashTable<CSeqHashNode>
{
        friend class CEnumVariant;
protected:
    DWORD Hash(CSeqHashNode* pnode)
    {
            DWORD dwVal=0;
    
                if (pnode)
                {
                for (int i = 0; i < 5 && pnode->m_rgchName[i]; i++)
                        dwVal = (DWORD)(_toupper(pnode->m_rgchName[i])) + RotBitsLeft(dwVal, 5);
                }
            return (dwVal % NUM_HASH_BUCKETS);
    }
};


/*
***************************************************************************************************************
*
*
*
*
*
*
***************************************************************************************************************
*/

class CEventHandler : public IDispatch
{
protected:
        IMMSeqMgr* m_pSeqMgr;
        ULONG m_cRef;

public:
        CEventHandler(IMMSeqMgr* pSeqMgr)
                {m_pSeqMgr=pSeqMgr;if (m_pSeqMgr) m_pSeqMgr->AddRef();m_cRef=1;}
        virtual ~CEventHandler() {if (m_pSeqMgr) m_pSeqMgr->Release();}

public:
        /* Overrides*/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj)
        {
                if (!ppvObj) return E_POINTER;
                if (IsEqualGUID(riid, IID_IUnknown) || IsEqualGUID(riid, IID_IDispatch))
                {
                        *ppvObj = (LPVOID)(IDispatch*)this;
                        AddRef();
                        return S_OK;
                }
                return E_NOINTERFACE;
        }
        STDMETHOD_(ULONG,AddRef)  (THIS)
                {return InterlockedIncrement((LPLONG)&m_cRef);}
    STDMETHOD_(ULONG,Release) (THIS)
                {
                        ULONG cRef = InterlockedDecrement((LPLONG)&m_cRef);
                        if (!cRef)
                                delete this;
                        return cRef;
                }

        //IDispatch methods
protected:
    STDMETHODIMP GetTypeInfoCount(UINT *pctinfo) {return E_NOTIMPL;}
    STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo) {return E_NOTIMPL;}
    STDMETHODIMP GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames,
         LCID lcid, DISPID *rgdispid) {return E_NOTIMPL;}
    STDMETHODIMP Invoke(DISPID dispid, REFIID riid, LCID lcid,
        WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult,
        EXCEPINFO *pexcepinfo, UINT *puArgErr)
        {
                if (m_pSeqMgr)
                {
                        //      typedef struct FARSTRUCT tagDISPPARAMS{
                        //              VARIANTARG FAR* rgvarg;                 // Array of arguments.
                        //              DISPID FAR* rgdispidNamedArgs;  // Dispatch IDs of named arguments.
                        //              unsigned int cArgs;                             // Number of arguments.
                        //              unsigned int cNamedArgs;                // Number of named arguments.
                        //      } DISPPARAMS;

                        switch(dispid)
                        {
                                case DISPID_SEQ_EVENT_ONPLAY:
                                case DISPID_SEQ_EVENT_ONSTOP:
                                case DISPID_SEQ_EVENT_ONPAUSE:
                {
                                        Proclaim(pdispparams);
                                        Proclaim(pdispparams->rgvarg);
                                        Proclaim(1==pdispparams->cArgs);
                                        Proclaim(VT_I4 == pdispparams->rgvarg[0].vt);

                                        if (pdispparams && pdispparams->rgvarg && 
                                                1==pdispparams->cArgs &&
                                                VT_I4 == pdispparams->rgvarg[0].vt )
                                        {
                                                m_pSeqMgr->RelayEvent(dispid, pdispparams->rgvarg[0].lVal, 0.0f);
                                        }
                }
                                break;

                case DISPID_SEQ_EVENT_ONSEEK:
                {
                                        Proclaim(pdispparams);
                                        Proclaim(pdispparams->rgvarg);
                                        Proclaim(2==pdispparams->cArgs);
                    Proclaim(VT_R8 == pdispparams->rgvarg[0].vt);
                                        Proclaim(VT_I4 == pdispparams->rgvarg[1].vt);

                                        if (pdispparams && pdispparams->rgvarg && 
                                                2==pdispparams->cArgs &&
                                                VT_I4 == pdispparams->rgvarg[1].vt &&
                        VT_R8 == pdispparams->rgvarg[0].vt)
                                        {
                                                m_pSeqMgr->RelayEvent(dispid, pdispparams->rgvarg[1].lVal, pdispparams->rgvarg[0].dblVal);
                                        }

                }
                break;

                        }
                }
                return S_OK;
        }
};


/*
***************************************************************************************************************
*
*
*
*
*
*
***************************************************************************************************************
*/

#undef BASECLASS
#define BASECLASS       \
        CIHBaseCtl <    \
        CMMSeqMgr,              \
        IMMSeqMgr,              \
        &CLSID_SequencerControl,\
        &IID_IMMSeqMgr, \
        &LIBID_DAExpressLib,    \
        &DIID_IMMSeqMgrEvents>

class CEnumVariant;


class CMMSeqMgr:
        public IMMSeqMgr,
        public BASECLASS
        
{
        friend LPUNKNOWN __stdcall AllocSequencerManager(LPUNKNOWN punkOuter);
        friend class CEnumVariant;
        typedef BASECLASS CMyIHBaseCtl;

protected:

        void FireInit (void);

        BOOL m_fLoadFired;
        BOOL m_fInited;
        long m_fCurCookie;
        CookieList *m_PointerList;
        unsigned long m_ulRef;
        CSeqHashTable m_hashTable;
        IDispatch* m_pidispEventHandler;
        bool m_bUnloaded;
        bool m_bUnloadedStarted;
        // 
        // Constructor and destructor
        // 
public:
        CMMSeqMgr(IUnknown *punkOuter, HRESULT *phr);
    virtual ~CMMSeqMgr();

        // Overrides
        STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, LPVOID *ppv);
        
        STDMETHODIMP DoPersist(IVariantIO* pvio, DWORD dwFlags);
        
    STDMETHODIMP SetClientSite(IOleClientSite *pClientSite);

    STDMETHODIMP Draw(DWORD dwDrawAspect, LONG lindex, void *pvAspect,
         DVTARGETDEVICE *ptd, HDC hdcTargetDev, HDC hdcDraw,
         LPCRECTL lprcBounds, LPCRECTL lprcWBounds,
         BOOL (__stdcall *pfnContinue)(ULONG_PTR dwContinue), ULONG_PTR dwContinue);

        ///// IDispatch implementation
public:
    STDMETHODIMP GetTypeInfoCount(UINT *pctinfo);
    STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo);
    STDMETHODIMP GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames,
         LCID lcid, DISPID *rgdispid);
    STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid,
        WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult,
        EXCEPINFO *pexcepinfo, UINT *puArgErr);
   
    STDMETHOD(get_Item)(THIS_ VARIANT variant, IDispatch ** ppdispatch);
        STDMETHOD(get__NewEnum)(THIS_ IUnknown * FAR* pUnk);
    STDMETHOD(get_Count)(THIS_ long FAR* plCount);
    
        STDMETHOD(RelayEvent)(long dispid, long lCookie, double dblSeekTime);

        // IOleObject overrides
        STDMETHOD (Close)(DWORD dwSaveOption);

        ///// delegating IUnknown implementation
public:
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv)
      { return m_punkOuter->QueryInterface(riid, ppv); }
    STDMETHODIMP_(ULONG) AddRef()
      { return m_punkOuter->AddRef(); }
    STDMETHODIMP_(ULONG) Release()
      { return m_punkOuter->Release(); }

#ifdef SUPPORTONLOAD
        void OnWindowLoad();
        void OnWindowUnload();
#endif //SUPPORTONLOAD

};



#endif // __SEQMGR_H__

// end of file SEQMGR.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\mmseq\seqmgr.cpp ===
/*++

Module: 
        seqmgr.cpp

Author: 
        ThomasOl

Created: 
        April 1997

Description:
        Implements Sequencer Manager

History:
        4-02-1997       Created

++*/

#include "..\ihbase\precomp.h"
#include "servprov.h"
#include <htmlfilter.h>
#include <string.h>
#include "..\ihbase\debug.h"
#include "..\ihbase\utils.h"
#include "memlayer.h"
#include "debug.h"
#include "drg.h"
#include "strwrap.h"
#include "seqmgr.h"
#include "enumseq.h"
#include "dispids.h"

// function that create's an IEnumDispatch object from the given ole container.
//
// CMMSeqMgr Creation/Destruction
//

extern ControlInfo     g_ctlinfoSeq, g_ctlinfoSeqMgr;

LPUNKNOWN __stdcall AllocSequencerManager(LPUNKNOWN punkOuter)
{
    // Allocate object
    HRESULT hr = S_OK;
    CMMSeqMgr *pthis = New CMMSeqMgr(punkOuter, &hr);
    DEBUGLOG("AllocSequencerManager : Allocating object\n");
    if (pthis == NULL)
        return NULL;
    if (FAILED(hr))
    {
        Delete pthis;
        return NULL;
    }

    // return an IUnknown pointer to the object
    return (LPUNKNOWN) (INonDelegatingUnknown *) pthis;
}

//
// Beginning of class implementation
// 

CMMSeqMgr::CMMSeqMgr(IUnknown *punkOuter, HRESULT *phr):
        CMyIHBaseCtl(punkOuter, phr),
        m_fLoadFired(FALSE),
        m_fInited(FALSE),
        m_pidispEventHandler(NULL),
        m_ulRef(1),
        m_fCurCookie(0),
        m_PointerList(NULL),
        m_bUnloaded(false),
        m_bUnloadedStarted(false)
{       
        DEBUGLOG("MMSeqMgr: Allocating object\n");
        if (NULL != phr)
        {
                ::InterlockedIncrement((long *)&(g_ctlinfoSeqMgr.pcLock));
                *phr = S_OK;
        }
}

        
CMMSeqMgr::~CMMSeqMgr()
{
        DEBUGLOG("MMSeqMgr: Destroying object\n");

        if (m_pidispEventHandler)
                m_pidispEventHandler->Release();

    Delete [] m_PointerList;
    m_PointerList=NULL;
    
    ::InterlockedDecrement((long *)&(g_ctlinfoSeqMgr.pcLock));
}


STDMETHODIMP CMMSeqMgr::NonDelegatingQueryInterface(REFIID riid, LPVOID *ppv)
{
        //              Add support for any custom interfaces

        HRESULT hRes = S_OK;
        BOOL fMustAddRef = FALSE;

    *ppv = NULL;

#ifdef _DEBUG
    char ach[200];
    TRACE("MMSeqMgr::QI('%s')\n", DebugIIDName(riid, ach));
#endif
    
        if ((IsEqualIID(riid, IID_IMMSeqMgr)) || (IsEqualIID(riid, IID_IDispatch)))
        {
                if (NULL == m_pTypeInfo)
                {
                        HRESULT hRes = S_OK;
                        
                        // Load the typelib
                        hRes = LoadTypeInfo(&m_pTypeInfo, &m_pTypeLib, IID_IMMSeqMgr, LIBID_DAExpressLib, NULL); 

                        if (FAILED(hRes))
                        {
                                ODS("Unable to load typelib\n");
                                m_pTypeInfo = NULL;
                        }
                        else    
                                *ppv = (IMMSeqMgr *) this;

                }
                else
                        *ppv = (IMMSeqMgr *) this;
                    
        }
    else // Call into the base class
        {
                DEBUGLOG(TEXT("Delegating QI to CIHBaseCtl\n"));
        return CMyIHBaseCtl::NonDelegatingQueryInterface(riid, ppv);

        }

    if (NULL != *ppv)
        {
                DEBUGLOG("MMSeqMgr: Interface supported in control class\n");
                ((IUnknown *) *ppv)->AddRef();
        }

    return hRes;
}


STDMETHODIMP CMMSeqMgr::DoPersist(IVariantIO* pvio, DWORD dwFlags)
{
        if (!m_fInited)
        {
                FireInit();
        }
        return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
// IDispatch Implementation
//

STDMETHODIMP CMMSeqMgr::GetTypeInfoCount(UINT *pctinfo)
{
    *pctinfo = 1;
    return S_OK;
}

STDMETHODIMP CMMSeqMgr::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)
{
        HRESULT hr = E_POINTER;

        if (NULL != pptinfo)
        {
                *pptinfo = NULL;
     
                if(itinfo == 0)
                {
                        m_pTypeInfo->AddRef(); 
                        *pptinfo = m_pTypeInfo;
                        hr = S_OK;
                }
                else
                {
                        hr = DISP_E_BADINDEX;
                }
    }

    return hr;
}

STDMETHODIMP CMMSeqMgr::GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames,
    UINT cNames, LCID lcid, DISPID *rgdispid)
{

        return ::DispGetIDsOfNames(m_pTypeInfo, rgszNames, cNames, rgdispid);
}


STDMETHODIMP CMMSeqMgr::Invoke(DISPID dispidMember, REFIID riid, LCID lcid,
    WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult,
    EXCEPINFO *pexcepinfo, UINT *puArgErr)
{
        return ::DispInvoke((IMMSeqMgr *)this, 
                m_pTypeInfo,
                dispidMember, wFlags, pdispparams,
                pvarResult, pexcepinfo, puArgErr); 
}


STDMETHODIMP CMMSeqMgr::SetClientSite(IOleClientSite *pClientSite)
{
    HRESULT hr = CMyIHBaseCtl::SetClientSite(pClientSite);

    // Now we enumerate through all the sequencers to set their client sites too

    IOleObject *pObject = NULL;
    CSeqHashNode *pNode = m_hashTable.FindFirst();

    while (pNode)
    {
        if (pNode->m_piMMSeq)
        {
            if (SUCCEEDED(pNode->m_piMMSeq->QueryInterface(IID_IOleObject, (LPVOID *) &pObject)))
            {
                if (pObject)
                {
                    pObject->SetClientSite(pClientSite);
                    SafeRelease((LPUNKNOWN *)&pObject);
                }
            }
        }

        pNode = m_hashTable.FindNext();
    }

    return hr;
}


STDMETHODIMP CMMSeqMgr::Draw(DWORD dwDrawAspect, LONG lindex, void *pvAspect,
     DVTARGETDEVICE *ptd, HDC hdcTargetDev, HDC hdcDraw,
     LPCRECTL lprcBounds, LPCRECTL lprcWBounds,
     BOOL (__stdcall *pfnContinue)(ULONG_PTR dwContinue), ULONG_PTR dwContinue)
{
        // The sequencer has no runtime drawing code.
        if (m_fDesignMode)
        {
            // draw an ellipse using palette entry <m_ipeCur> in the palette
                HBRUSH          hbr;            // brush to draw with
                HBRUSH          hbrPrev;        // previously-selected brush
                HPEN            hpenPrev;       // previously-selected pen

                if ((hbr = (HBRUSH)GetStockObject(WHITE_BRUSH)) != NULL)
                {
                        TCHAR strComment[] = TEXT("Sequencer Control");
                        HFONT hfontPrev = (HFONT)SelectObject(hdcDraw, GetStockObject(SYSTEM_FONT));
                        
                        hbrPrev = (HBRUSH)SelectObject(hdcDraw, hbr);
                        hpenPrev = (HPEN)SelectObject(hdcDraw, GetStockObject(BLACK_PEN));
                        Rectangle(hdcDraw, m_rcBounds.left, m_rcBounds.top,
                                m_rcBounds.right, m_rcBounds.bottom);

                        TextOut(hdcDraw, m_rcBounds.left + 1, m_rcBounds.top + 1,
                                strComment, lstrlen(strComment));

                        SelectObject(hdcDraw, hbrPrev);
                        SelectObject(hdcDraw, hpenPrev);
                        SelectObject(hdcDraw, hfontPrev);
                        DeleteObject(hbr);
                }

        } 
    return S_OK;
}


//
// IMMSeqMgr implementation
//

/*==========================================================================*/


STDMETHODIMP CMMSeqMgr::get_Count(THIS_ long FAR* plCount)
{
        if (!plCount)
                return E_INVALIDARG;
        *plCount = m_hashTable.Count();
        return S_OK;
}

/*==========================================================================*/


STDMETHODIMP CMMSeqMgr::get__NewEnum(IUnknown FAR* FAR* ppunkEnum)
{
        CEnumVariant* pEV;
        HRESULT hr=E_FAIL;

        if (!ppunkEnum)
                return E_INVALIDARG;
        pEV = New CEnumVariant(this);
        if (pEV)
        {
                hr = pEV->QueryInterface(IID_IEnumVARIANT, (LPVOID*)ppunkEnum);
                pEV->Release();
        }
        return hr;
}


/*==========================================================================*/


STDMETHODIMP CMMSeqMgr::get_Item(THIS_ VARIANT variant, IDispatch * FAR* ppdispatch)
{
        HRESULT hr;
        IMMSeq* piMMSeq=NULL;                                   
        VARIANT *pvarVariant = &variant;
        IConnectionPointContainer* piConnectionPointContainer;
        
        if (!ppdispatch)
                return E_POINTER;

        *ppdispatch = NULL;

        if (m_bUnloaded)
        {
            return E_FAIL;                                    
        }

        // If we haven't yet fired the init event - do so now.
        if (!m_fInited)
        {
                FireInit();
        }

    if (V_VT(pvarVariant) & VT_VARIANT)
        {
                if (V_VT(pvarVariant) & VT_BYREF)
                        pvarVariant = V_VARIANTREF(pvarVariant);
        }

    //Seq("button_onclick"). dereference using string
    if ( (pvarVariant->vt & VT_BSTR) == VT_BSTR )
    {
        TCHAR rgchName[CCH_ID];
        BSTR  *pbstrName = NULL;

        // We have to deal with BYREFs
        if (pvarVariant->vt & VT_BYREF)
            pbstrName = pvarVariant->pbstrVal;
        else
            pbstrName = &pvarVariant->bstrVal;

                Proclaim(pbstrName);

        // BUGBUG: should use lstrlenW, not SysStringLen.  SysStringLen just returns the size
        // of the allocated memory block, not the length of the string.

                if (pbstrName && (0 < ::SysStringLen(*pbstrName)))              //did they pass a valid BSTR?
                {                                                       
                                                                        //our hash class is MBCS
                        if (WideCharToMultiByte(CP_OEMCP, NULL, *pbstrName, -1, rgchName, sizeof(rgchName),NULL,NULL))
                        {
                                CSeqHashNode node(rgchName, NULL);              //construct a temp node
                                CSeqHashNode *pnode = m_hashTable.Find(&node);  //is it in the hash table already?
                                
                                if (pnode)                                              //yup, just addref and return
                                {
                                        *ppdispatch = pnode->m_piMMSeq;
                                        Proclaim(*ppdispatch);
                                        (*ppdispatch)->AddRef();
                                        return S_OK;
                                }
                                
                                //if the unload has started then fail here
                                //so that no new nodes are created.
                                if (m_bUnloadedStarted)
                                {
                                    return E_FAIL;
                                }

                                if (!m_pidispEventHandler)                              //have we allocated an event handler?
                                {
                                        CEventHandler* pcEventHandler = New CEventHandler((IMMSeqMgr*)this);

                                        if (pcEventHandler)
                                        {
                                                hr = pcEventHandler->QueryInterface(IID_IDispatch, (LPVOID*)&m_pidispEventHandler);
                                                pcEventHandler->Release();
                                        }

                                        if (!m_pidispEventHandler)                      //something is messed up.
                                                return E_OUTOFMEMORY;
                                }
                                                                                                                
                                //create a new sequencer.
                                hr = CoCreateInstance(CLSID_MMSeq, NULL, CLSCTX_INPROC_SERVER, IID_IMMSeq, (LPVOID*)&piMMSeq);

                                if (SUCCEEDED(hr))      
                                {
                                        CSeqHashNode node(rgchName, piMMSeq); //construct a temp node
                                                                                                                //okay, now insert into hash table
                                        hr = (TRUE == m_hashTable.Insert(&node)) ? S_OK : E_FAIL;
                                }
                                Proclaim(SUCCEEDED(hr));  //this is either OOM or duplicate insertion--check Find
                                pnode = m_hashTable.Find(&node);        //is it in the hash table already?
                                Proclaim(pnode);

                                if (SUCCEEDED(hr))              //no need to addref--CoCreate did it.
                                {
                                        *ppdispatch = piMMSeq;
                                        IOleObject* piOleObject;

                                        m_fCurCookie++;
                                        piMMSeq->put__Cookie(m_fCurCookie); //give the sequencer a cookie!
                                        //store the pointer in a table of cookies.

                                        int CurCount = m_hashTable.Count();

                                        // we allocate an entirely new structure with one additional element.
                                        // since nodes are small and hopefully not too numerous, this should
                                        // be ok. 

                                        CookieList *tempPointerList = New CookieList[m_fCurCookie];

                                        if(tempPointerList==NULL)
                                            return E_OUTOFMEMORY;

                                        if(m_PointerList!=NULL) {
                                            memcpy(tempPointerList, m_PointerList, sizeof(CookieList) * (m_fCurCookie - 1));
                                            Delete [] m_PointerList;
                                        }

                                        //should never have more nodes in hashtable than cookies
                                        ASSERT(CurCount<=m_fCurCookie);

                                        tempPointerList[m_fCurCookie-1].cookie = m_fCurCookie;
                                        tempPointerList[m_fCurCookie-1].pnode = (void *)pnode;

                                        m_PointerList = tempPointerList;

                                        if (SUCCEEDED(piMMSeq->QueryInterface(IID_IOleObject, (LPVOID*)&piOleObject)))
                                        {
                                                Proclaim(piOleObject);
                                                piOleObject->SetClientSite(m_pocs);
                                                piOleObject->Release();
                                        }

                                        Proclaim(m_pidispEventHandler);

                                        if (!pnode->m_dwUnadviseCookie && 
                                                m_pidispEventHandler &&
                                                SUCCEEDED(piMMSeq->QueryInterface(IID_IConnectionPointContainer, (LPVOID*)&piConnectionPointContainer)))
                                        {
                                                if (SUCCEEDED(piConnectionPointContainer->FindConnectionPoint(DIID_IMMSeqEvents, &pnode->m_piConnectionPoint)))
                                                {
                                                        if (!SUCCEEDED(pnode->m_piConnectionPoint->Advise(m_pidispEventHandler, &pnode->m_dwUnadviseCookie)))
                                                        {
                                                                Proclaim(FALSE);
                                                        }
                                                }
                                                piConnectionPointContainer->Release();
                                        }
                                }

                                return hr;
                        }
                        return DISP_E_MEMBERNOTFOUND; // S_FALSE
                }
        else // NULL string
        {
            return E_INVALIDARG;
        }

    }
    else // Anything other than a BSTR
    {
        return DISP_E_TYPEMISMATCH;
    }
}

STDMETHODIMP CMMSeqMgr::Close(DWORD dwSaveOption)
{
        CSeqHashNode* pnode = m_hashTable.FindFirst();

        if (pnode)
        {
                do
                {
                        if (pnode->m_piConnectionPoint)                                         //release the connection point
                        {
                                if (pnode->m_dwUnadviseCookie)
                                {
                                        pnode->m_piConnectionPoint->Unadvise(pnode->m_dwUnadviseCookie);
                                        pnode->m_dwUnadviseCookie = 0;
                                }
                                pnode->m_piConnectionPoint->Release();
                                pnode->m_piConnectionPoint = NULL;
                        }
                        
                        Proclaim(pnode->m_piMMSeq);
                        if (pnode->m_piMMSeq)
                        {
                                IOleObject* piOleObject;
                                                                
                                if (SUCCEEDED(pnode->m_piMMSeq->QueryInterface(IID_IOleObject,
                                        (LPVOID*)&piOleObject)))
                                {
                                        piOleObject->Close(OLECLOSE_NOSAVE);
                    piOleObject->SetClientSite(NULL);
                                        piOleObject->Release();
                                }

                                pnode->m_piMMSeq->Clear();
                                pnode->m_piMMSeq->Release();
                                pnode->m_piMMSeq = NULL;
                        }
                        m_hashTable.Remove(pnode);
                }
                while ((pnode = m_hashTable.FindNext()));
        }

        if (m_pidispEventHandler)
        {
                m_pidispEventHandler->Release();
                m_pidispEventHandler = NULL;
        }
        
        return CMyIHBaseCtl::Close(dwSaveOption);
}

STDMETHODIMP CMMSeqMgr::RelayEvent(long dispid, long lCookie, double dblSeekTime)
{
        if (lCookie && m_pconpt)
        {
                CSeqHashNode* pnode = (CSeqHashNode*)m_PointerList[lCookie-1].pnode;
                WCHAR rgwchName[CCH_ID];

#ifdef _DEBUG
                ASSERT(pnode!=NULL && "Internal error: Sequencer Pointer Structure contains a null ptr");

                if(!pnode)
                    return E_POINTER;
#endif
                
                if (MultiByteToWideChar(CP_ACP,MB_PRECOMPOSED,pnode->m_rgchName,-1,rgwchName,sizeof(rgwchName)))
                {
                        switch(dispid)
                        {       
                                case DISPID_SEQMGR_EVENT_ONPLAY:
                                case DISPID_SEQMGR_EVENT_ONPAUSE:
                                case DISPID_SEQMGR_EVENT_ONSTOP:
                                case DISPID_SEQMGR_EVENT_ONSEEK:
                                {
                                        BSTR bstrName = SysAllocString(rgwchName);

                                        if (DISPID_SEQMGR_EVENT_ONSEEK != dispid)
                                                m_pconpt->FireEvent(dispid, VT_BSTR, bstrName, 0.0f);
                                        else
                                                m_pconpt->FireEvent(dispid, VT_BSTR, bstrName, VT_R8, dblSeekTime, NULL);
                                    
                                        SysFreeString(bstrName);
                                }
                                break;
                        }
                }
        }
        return S_OK;
}


void
CMMSeqMgr::FireInit (void)
{
        if (m_pconpt)
        {
                m_fInited = TRUE;
                m_pconpt->FireEvent(DISPID_SEQMGR_EVENT_INIT, NULL, NULL);
        }
}

#ifdef SUPPORTONLOAD
void CMMSeqMgr::OnWindowLoad() 
{
        if (!m_fInited)
        {
                FireInit();
        }
        return;
}

void CMMSeqMgr::OnWindowUnload() 
{ 
        CSeqHashNode* pnode = m_hashTable.FindFirst();

        m_bUnloadedStarted = true;

        m_fInited = FALSE;
        if (pnode)
        {
                do
                {
                        Proclaim(pnode->m_piMMSeq);
                        if (pnode->m_piMMSeq)
                        {
                                // Only stop an action set that is playing or is paused.
                                int iPlayState = 0;
                                HRESULT hr = pnode->m_piMMSeq->get_PlayState(&iPlayState);

                                ASSERT(SUCCEEDED(hr));
                                if (SUCCEEDED(hr))
                                {
                                        if (0 != iPlayState)
                                        {
                                                pnode->m_piMMSeq->Stop();
                                        }
                                        pnode->m_piMMSeq->Clear();
                                }
                        }
                }
                while ((pnode = m_hashTable.FindNext()));
        }
        m_bUnloaded = true;
        return; 
}
#endif //SUPPORTONLOAD

// End of file: seqmgr.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\path\purevirt.cpp ===
// purevirt.c
//
// Avoids use of C runtime.
//

#include "..\ihbase\precomp.h"

extern "C" int __cdecl _purecall(void)
{
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\path\dll.cpp ===
// dll.cpp
//
// DLL entry points etc.
//


#ifdef _DEBUG
    #pragma message("_DEBUG is defined")
#else
    #pragma message("_DEBUG isn't defined")
#endif

#ifdef _DESIGN
    #pragma message("_DESIGN is defined")
#else
    #pragma message("_DESIGN isn't defined")
#endif

#include "..\ihbase\precomp.h"

#include <initguid.h> // once per build
#include <olectl.h>
#include <daxpress.h>
#include "..\mmctl\inc\ochelp.h"
#include "..\mmctl\inc\mmctlg.h"
#include "..\ihbase\debug.h"
#include "pathctl.h"
#include "pathinit.h"


//////////////////////////////////////////////////////////////////////////////
// globals
//

// general globals
HINSTANCE       g_hinst;        // DLL instance handle
ULONG           g_cLock;        // DLL lock count
ControlInfo     g_ctlinfo;      // information about the control

#ifdef _DEBUG
BOOL			g_fLogDebugOutput; // Controls logging of debug info
#endif

//#define USELOGGING
extern "C" DWORD _fltused = (DWORD)(-1);

//////////////////////////////////////////////////////////////////////////////
// DLL Initialization
//

// TODO: Modify the data in this function appropriately


//////////////////////////////////////////////////////////////////////////////
// Standard DLL Entry Points
//

BOOL WINAPI _DllMainCRTStartup(HINSTANCE hInst, DWORD dwReason,LPVOID lpreserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        TRACE("PathCtl DLL loaded\n"); //TODO: Modify me
        g_hinst = hInst;
#ifdef _DEBUG
#ifdef USELOGGING
		g_fLogDebugOutput = TRUE;
#else
		g_fLogDebugOutput = FALSE;
#endif // USELOGGING
#endif // USELOGGING

        InitPathControlInfo(hInst, &g_ctlinfo, AllocPathControl);
    }
    else
    if (dwReason == DLL_PROCESS_DETACH)
    {
        TRACE("PathCtl DLL unloaded\n"); //TODO: Modify me
    }

    return TRUE;
}


STDAPI DllRegisterServer(void)
{
    return RegisterControls(&g_ctlinfo, RC_REGISTER);
}


STDAPI DllUnregisterServer(void)
{
	return RegisterControls(&g_ctlinfo, RC_UNREGISTER);
}


STDAPI DllCanUnloadNow()
{
    return ((g_cLock == 0) ? S_OK : S_FALSE);
}

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppv)
{
    return HelpGetClassObject(rclsid, riid, ppv, &g_ctlinfo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\mmseq\seqctl.cpp ===
/*++

Module:
	control.cpp

Author:
	IHammer Team (SimonB)
	pauld

Created:
	March 1997

Description:
	Implements any control-specific members, as well as the control's interface

History:
	3-15-97 Used template for new sequencer
	12-03-1996	Fixed painting code
	10-01-1996	Created

++*/

#include "..\ihbase\precomp.h"
#include "servprov.h"
#include <ocmm.h>
#include <htmlfilter.h>

#include "..\ihbase\debug.h"
#include "..\ihbase\utils.h"
#include "memlayer.h"
#include "debug.h"
#include "drg.h"
#include <actclass.iid>
#include <itimer.iid>
#include "strwrap.h"
#include "caction.h"
#include "cactset.h"
#include "seqctl.h"
#include "winver.h"
#include "seqevent.h"

extern ControlInfo     g_ctlinfoSeq, g_ctlinfoSeqMgr;

//
// CMMSeq Creation/Destruction
//

LPUNKNOWN __stdcall AllocSeqControl(LPUNKNOWN punkOuter)
{
    // Allocate object
    HRESULT hr = S_OK;
    CMMSeq *pthis = New CMMSeq(punkOuter, &hr);
    DEBUGLOG("AllocControl : Allocating object\n");
    if (pthis == NULL)
        return NULL;
    if (FAILED(hr))
    {
        Delete pthis;
        return NULL;
    }

    // return an IUnknown pointer to the object
    return (LPUNKNOWN) (INonDelegatingUnknown *) pthis;
}

//
// Beginning of class implementation
//

CMMSeq::CMMSeq(IUnknown *punkOuter, HRESULT *phr):
	CMyIHBaseCtl(punkOuter, phr),
	m_pActionSet(NULL),
	m_ulRef(1),
	m_fSeekFiring(FALSE),
	m_dwPlayFrom(0)
{
	DEBUGLOG("MMSeq: Allocating object\n");
	if (NULL != phr)
	{
		// We used to query against the version 
		// number of mshtml.dll to determine whether
		// or not to bind directly to the script 
		// engine.  Since this was a pre-PP2 
		// restriction it seems reasonable to 
		// rely on script engine binding now.
		if (InitActionSet(TRUE))
		{
			::InterlockedIncrement((long *)&(g_ctlinfoSeq.pcLock));
			*phr = S_OK;
		}
		else
		{
			*phr = E_FAIL;
		}
	}
}


CMMSeq::~CMMSeq()
{
	DEBUGLOG("MMSeq: Destroying object\n");
	Shutdown();
	::InterlockedDecrement((long *)&(g_ctlinfoSeq.pcLock));
}


void
CMMSeq::Shutdown (void)
{
	// Kill any pending actions.
	if (IsBusy())
	{
		ASSERT(NULL != m_pActionSet);
		if (NULL != m_pActionSet)
		{
			m_pActionSet->Unadvise();
		}
	}

	if (NULL != m_pActionSet)
	{
		Delete m_pActionSet;
		m_pActionSet = NULL;
	}
}

STDMETHODIMP CMMSeq::NonDelegatingQueryInterface(REFIID riid, LPVOID *ppv)
{
	//		Add support for any custom interfaces

	HRESULT hRes = S_OK;
	BOOL fMustAddRef = FALSE;

    *ppv = NULL;

#ifdef _DEBUG
    char ach[200];
    TRACE("MMSeq::QI('%s')\n", DebugIIDName(riid, ach));
#endif

	if ((IsEqualIID(riid, IID_IMMSeq)) || (IsEqualIID(riid, IID_IDispatch)))
	{
		if (NULL == m_pTypeInfo)
		{
			HRESULT hRes = S_OK;

			// Load the typelib
			hRes = LoadTypeInfo(&m_pTypeInfo, &m_pTypeLib, IID_IMMSeq, LIBID_DAExpressLib, NULL);

			if (FAILED(hRes))
			{
				ODS("Unable to load typelib\n");
				m_pTypeInfo = NULL;
			}
			else
				*ppv = (IMMSeq *) this;

		}
		else
			*ppv = (IMMSeq *) this;

	}
    else // Call into the base class
	{
		DEBUGLOG(TEXT("Delegating QI to CIHBaseCtl\n"));
        return CMyIHBaseCtl::NonDelegatingQueryInterface(riid, ppv);

	}

    if (NULL != *ppv)
	{
		DEBUGLOG("MMSeq: Interface supported in control class\n");
		((IUnknown *) *ppv)->AddRef();
	}

    return hRes;
}


BOOL
CMMSeq::InitActionSet (BOOL fBindToEngine)
{
	BOOL fRet = FALSE;

	ASSERT(NULL == m_pActionSet);
	if (NULL == m_pActionSet)
	{
		m_pActionSet = New CActionSet(this, fBindToEngine);
		ASSERT(NULL != m_pActionSet);
		if (NULL != m_pActionSet)
		{
			fRet = TRUE;
		}
	}

	return fRet;
}

STDMETHODIMP CMMSeq::DoPersist(IVariantIO* pvio, DWORD dwFlags)
{
    // clear the dirty bit if requested
    if (dwFlags & PVIO_CLEARDIRTY)
        m_fDirty = FALSE;

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
// IDispatch Implementation
//

STDMETHODIMP CMMSeq::GetTypeInfoCount(UINT *pctinfo)
{
    *pctinfo = 1;
    return S_OK;
}

STDMETHODIMP CMMSeq::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)
{
	HRESULT hr = E_POINTER;

	if (NULL != pptinfo)
	{
		*pptinfo = NULL;

		if(itinfo == 0)
		{
			m_pTypeInfo->AddRef();
			*pptinfo = m_pTypeInfo;
			hr = S_OK;
		}
		else
		{
			hr = DISP_E_BADINDEX;
		}
    }

    return hr;
}

STDMETHODIMP CMMSeq::GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames,
    UINT cNames, LCID lcid, DISPID *rgdispid)
{

	return ::DispGetIDsOfNames(m_pTypeInfo, rgszNames, cNames, rgdispid);
}


STDMETHODIMP CMMSeq::Invoke(DISPID dispidMember, REFIID riid, LCID lcid,
    WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult,
    EXCEPINFO *pexcepinfo, UINT *puArgErr)
{
	return ::DispInvoke((IMMSeq *)this,
		m_pTypeInfo,
		dispidMember, wFlags, pdispparams,
		pvarResult, pexcepinfo, puArgErr);
}


//
// IMMSeq implementation
//

STDMETHODIMP
CMMSeq::get_Time (THIS_ double FAR* pdblCurrentTime)
{
	HRESULT hr = E_POINTER;

	ASSERT(NULL != pdblCurrentTime);
	if (NULL != pdblCurrentTime)
	{
		hr = E_FAIL;

		ASSERT(NULL != m_pActionSet);
		if (NULL != m_pActionSet)
		{

			if (IsBusy() || m_pActionSet->IsPaused() || m_pActionSet->IsServicingActions())
			{
				DWORD dwCurrentMS = 0;
				hr = m_pActionSet->GetTime(&dwCurrentMS);
				*pdblCurrentTime = (double)dwCurrentMS;
			}
			else
			{
				*pdblCurrentTime = (double)m_dwPlayFrom;
				hr = S_OK;
			}
			(*pdblCurrentTime) /= 1000.0;
		}
	}

	return hr;
}

STDMETHODIMP
CMMSeq::put_Time (THIS_ double dblCurrentTime)
{
	ASSERT(NULL != m_pActionSet);
	if (NULL != m_pActionSet)
	{
		m_pActionSet->Seek((DWORD)(dblCurrentTime * 1000.0));
	}
	return S_OK;
}


STDMETHODIMP 
CMMSeq::get_PlayState (THIS_ int FAR * piPlayState)
{
	HRESULT hr = E_FAIL;

	ASSERT(NULL != m_pActionSet);
	if (NULL != m_pActionSet)
	{
		ASSERT(NULL != piPlayState);
		if (NULL != piPlayState)
		{
			if (m_pActionSet->IsBusy())
			{
				*piPlayState = (int)SEQ_PLAYING;
			}
			else if (m_pActionSet->IsPaused())
			{
				*piPlayState = (int)SEQ_PAUSED;
			}
			else
			{
				*piPlayState = (int)SEQ_STOPPED;
			}
			hr = S_OK;
		}
		else
		{
			hr = E_POINTER;
		}
	}

	return hr;
}

STDMETHODIMP
CMMSeq::Play (void)
{
	HRESULT hr = E_FAIL;
	BOOL fPlayed = FALSE;

	ASSERT(NULL != m_pActionSet);
	if (NULL != m_pActionSet)
	{
		// If we're already playing, leave things be.
		if (!IsBusy() && (!m_pActionSet->IsPaused()))
		{
			ITimer * piTimer = NULL;

			if (SUCCEEDED(FindTimer(&piTimer)))
			{
				DeriveDispatches();
				hr = m_pActionSet->Play(piTimer, m_dwPlayFrom);
				piTimer->Release();
				m_dwPlayFrom = 0;
				fPlayed = TRUE;
			}
		}
		// If we're paused, resume playing.
		else if (m_pActionSet->IsPaused())
		{
			hr = m_pActionSet->Resume();
			fPlayed = TRUE;
		}
		// Already playing.
		else
		{
			hr = S_OK;
		}
	}

	if (SUCCEEDED(hr) && m_pconpt && fPlayed)
	{
	 	m_pconpt->FireEvent(DISPID_SEQ_EVENT_ONPLAY, VT_I4, m_lCookie, NULL);
	}

	return hr;
}


STDMETHODIMP
CMMSeq::Pause (void)
{
	HRESULT hr = E_FAIL;
	BOOL fWasPlaying = IsBusy();

	ASSERT(NULL != m_pActionSet);
	if (NULL != m_pActionSet)
	{
		hr = m_pActionSet->Pause();
	}

	if (SUCCEEDED(hr) && m_pconpt && fWasPlaying)
	{
	 	m_pconpt->FireEvent(DISPID_SEQ_EVENT_ONPAUSE, VT_I4, m_lCookie, NULL);
	}
	return hr;
}


STDMETHODIMP
CMMSeq::Stop (void)
{
	HRESULT hr = E_FAIL;
	BOOL fStopped = FALSE;

	ASSERT(NULL != m_pActionSet);
	if (NULL != m_pActionSet)
	{
		if (IsBusy() || (m_pActionSet->IsPaused()))
		{
			hr = m_pActionSet->Stop();
			fStopped = TRUE;
		}
		else
		{
			// Already stopped.
			hr = S_OK;
		}
	}

	if (SUCCEEDED(hr) && fStopped)
	{
		FireStoppedEvent();
	}
	return hr;
}


void
CMMSeq::FireStoppedEvent (void)
{
	if (NULL != m_pconpt)
	{
	 	m_pconpt->FireEvent(DISPID_SEQ_EVENT_ONSTOP, VT_I4, m_lCookie, NULL);
	}
}


void
CMMSeq::NotifyStopped (void)
{
	FireStoppedEvent();
}


HRESULT 
CMMSeq::GetSiteContainer (LPOLECONTAINER * ppiContainer)
{
	HRESULT hr = E_FAIL;
	
	if ((NULL != m_pocs) && (NULL != ppiContainer))
	{
		hr = m_pocs->GetContainer(ppiContainer);
	}

	return hr;
}


BOOL
CMMSeq::FurnishDefaultAtParameters (VARIANT * pvarStartTime, VARIANT * pvarRepeatCount, VARIANT * pvarSampleRate,
                                                            VARIANT * pvarTiebreakNumber, VARIANT * pvarDropTolerance)
{
	BOOL fValid = TRUE;

	// Supply plausible default values or convert any 
	// incoming variant types to types we expect.

	if (VT_R8 != V_VT(pvarStartTime))
	{
		fValid = SUCCEEDED(VariantChangeType(pvarStartTime, pvarStartTime, 0, VT_R8));
		ASSERT(fValid);
	}

	if (fValid)
	{
		if (VT_ERROR == V_VT(pvarRepeatCount))
		{
			VariantClear(pvarRepeatCount);
			V_VT(pvarRepeatCount) = VT_I4;
			V_I4(pvarRepeatCount) = SEQ_DEFAULT_REPEAT_COUNT;
		}
		else if (VT_I4 != V_VT(pvarRepeatCount))
		{
			fValid = SUCCEEDED(VariantChangeType(pvarRepeatCount, pvarRepeatCount, 0, VT_I4));
			ASSERT(fValid);
		}
	}

	if (fValid)
	{
		if (VT_ERROR == V_VT(pvarSampleRate))
		{
			VariantClear(pvarSampleRate);
			V_VT(pvarSampleRate) = VT_R8;
			V_R8(pvarSampleRate) = (double)SEQ_DEFAULT_SAMPLING_RATE;
		}
		else if (VT_R8 != V_VT(pvarSampleRate))
		{
			fValid = SUCCEEDED(VariantChangeType(pvarSampleRate, pvarSampleRate, 0, VT_R8));
			ASSERT(fValid);
		}
	}

	if (fValid)
	{
		if (VT_ERROR == V_VT(pvarTiebreakNumber))
		{
			VariantClear(pvarTiebreakNumber);
			V_VT(pvarTiebreakNumber) = VT_I4;
			V_I4(pvarTiebreakNumber) = SEQ_DEFAULT_TIEBREAK;
		}
		else if (VT_I4 != V_VT(pvarTiebreakNumber))
		{
			fValid = SUCCEEDED(VariantChangeType(pvarTiebreakNumber, pvarTiebreakNumber, 0, VT_I4));
			ASSERT(fValid);
		}
	}

	if (fValid)
	{
		if (VT_ERROR == V_VT(pvarDropTolerance))
		{
			VariantClear(pvarDropTolerance);
			V_VT(pvarDropTolerance) = VT_R8;
			V_R8(pvarDropTolerance) = (double)SEQ_DEFAULT_DROPTOL;
		}
		else if (VT_R8 != V_VT(pvarDropTolerance))
		{
			fValid = SUCCEEDED(VariantChangeType(pvarDropTolerance, pvarDropTolerance, 0, VT_R8));
			ASSERT(fValid);
		}
	}

	return fValid;
}


STDMETHODIMP
CMMSeq::At (VARIANT varStartTime, BSTR bstrScriptlet,
			         VARIANT varRepeatCount, VARIANT varSampleRate,
					 VARIANT varTiebreakNumber, VARIANT varDropTolerance)
{
	HRESULT hr = DISP_E_TYPEMISMATCH;

	if (VT_ERROR != V_VT(&varStartTime) &&
		FurnishDefaultAtParameters(&varStartTime, &varRepeatCount, &varSampleRate, &varTiebreakNumber, &varDropTolerance))
	{
		Proclaim(NULL != m_pActionSet);
		if (NULL != m_pActionSet)
		{
			hr = m_pActionSet->At(bstrScriptlet, V_R8(&varStartTime), V_I4(&varRepeatCount), V_R8(&varSampleRate),
											   V_I4(&varTiebreakNumber), V_R8(&varDropTolerance));
		}
	}

	return hr;
}


STDMETHODIMP 
CMMSeq::Clear (void)
{
	ASSERT(NULL != m_pActionSet);
	if (NULL != m_pActionSet)
	{
		m_pActionSet->Clear();
	}
	return S_OK;
}


STDMETHODIMP 
CMMSeq::Seek(double dblSeekTime)
{
	HRESULT hr = DISP_E_OVERFLOW;

	if (0.0 <= dblSeekTime)
	{
		if (NULL != m_pActionSet)
		{
			if (IsBusy() || m_pActionSet->IsPaused())
			{
				hr = put_Time(dblSeekTime);
			}
			else
			{
				m_dwPlayFrom = (DWORD)(dblSeekTime * 1000);
				hr = S_OK;
			}
		}
		else
		{
			hr = E_FAIL;
		}
	}

    if (SUCCEEDED(hr) && !m_fSeekFiring && (NULL != m_pconpt))
    {
        m_fSeekFiring = TRUE;
        m_pconpt->FireEvent(DISPID_SEQ_EVENT_ONSEEK, VT_I4, m_lCookie, VT_R8, dblSeekTime, NULL);
        m_fSeekFiring = FALSE;
    }

    return hr;
}

/*-----------------------------------------------------------------------------
@method | SCODE | CMMSeq | DeriveDispatches | Resolve all of the actions in the sequencer.
-----------------------------------------------------------------------------*/
HRESULT
CMMSeq::DeriveDispatches (void)
{
	HRESULT hr = E_FAIL;
	LPOLECONTAINER piocContainer = NULL;

	ASSERT(NULL != m_pocs);
	ASSERT(NULL != m_pActionSet);

	if ((NULL != m_pocs) && (NULL != m_pActionSet) &&
		(SUCCEEDED( m_pocs->GetContainer(&piocContainer))))
	{
		hr = m_pActionSet->DeriveDispatches(piocContainer);
		piocContainer->Release();
	}

	return hr;
}


/*-----------------------------------------------------------------------------
@method HRESULT | CMMSeq | FindTimer | Finds a timer provided by the container.
@rdesc	Returns success or failure code.
@xref	<m CMMSeq::FindTimer>
-----------------------------------------------------------------------------*/
HRESULT
CMMSeq::FindContainerTimer (ITimer ** ppiTimer)
{
	HRESULT hr = E_FAIL;
	LPUNKNOWN piUnkSite = NULL;

	IServiceProvider * piServiceProvider = NULL;

	ASSERT(NULL != m_pocs);
	if ((NULL != m_pocs) && SUCCEEDED(hr = m_pocs->QueryInterface(IID_IServiceProvider, (LPVOID *)&piServiceProvider)))
	{
		ITimerService * piTimerService = NULL;

		if (SUCCEEDED(hr = piServiceProvider->QueryService(IID_ITimerService, IID_ITimerService, (LPVOID *)&piTimerService)))
		{
			hr = piTimerService->CreateTimer(NULL, ppiTimer);
			ASSERT(NULL != ppiTimer);
			piTimerService->Release();
		}
		piServiceProvider->Release();
	}

	return hr;
}


/*-----------------------------------------------------------------------------
@method HRESULT | CMMSeq | FindTimer | Finds a timer provided by a registered server.
@rdesc	Returns success or failure code.
@xref	<m CMMSeq::FindTimer>
-----------------------------------------------------------------------------*/
HRESULT
CMMSeq::FindDefaultTimer (ITimer ** ppiTimer)
{
	HRESULT hr = E_FAIL;
	ITimerService * pITimerService = NULL;

	// Get the timer service.  From this, we can create a timer for ourselves.
	hr = CoCreateInstance(CLSID_TimerService, NULL, CLSCTX_INPROC_SERVER, IID_ITimerService, (LPVOID *)&pITimerService);
	ASSERT(SUCCEEDED(hr) && (NULL != pITimerService));
	if (SUCCEEDED(hr) && (NULL != pITimerService))
	{
		// Create a timer, using no reference timer.
		hr = pITimerService->CreateTimer(NULL, ppiTimer);
		pITimerService->Release();
	}

	return hr;
}


/*-----------------------------------------------------------------------------
@method HRESULT | CMMSeq | FindTimer | Finds a timer provided either by the container or from a registered server.
@rdesc	Returns success or failure code.
-----------------------------------------------------------------------------*/
HRESULT
CMMSeq::FindTimer (ITimer ** ppiTimer)
{
	HRESULT hr = E_FAIL;

	if (FAILED(hr = FindContainerTimer(ppiTimer)))
	{
		hr = FindDefaultTimer(ppiTimer);
	}

	ASSERT(NULL != (*ppiTimer));

	return hr;
}


//
// IMMSeq methods
//

BOOL
CMMSeq::IsBusy (void)
{
	BOOL fBusy = FALSE;

	if (NULL != m_pActionSet)
	{
		fBusy = m_pActionSet->IsBusy();
	}

	return fBusy;
}

// End of file: control.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\path\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//
#define IDS_STRING1                     1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\path\pathevnt.h ===
/*++

Module: 
    pathevnt.h

Author: 
    IHammer Team (SimonB)

Created: 
    May 1997

Description:
    Macros to make firing events easier and safer.  Each macro can be customised for 
    the particular event.  However, the general form should be:

    #define FIRE_EVENTNAME(pConnectionPoint, param1, param2) \
        pConnectionPoint->FireEvent(DISPID_PATH_EVENT_EVENTNAME, \
            <VT for param1>, param1, \
            <VT for param2>, param2, \
            0) 

    NOTE: The terminating 0 is extremly important !!!

History:
    05-24-1997  Created (SimonB)

++*/

#include <dispids.h>

#ifndef __PATHEVNT_H__
#define __PATHEVNT_H__

#define FIRE_ONSTOP(pConnectionPoint) \
    if (m_fOnWindowLoadFired && !m_fOnStopFiring) \
    { \
        m_fOnStopFiring = true; \
        pConnectionPoint->FireEvent(DISPID_PATH_EVENT_ONSTOP, 0); \
        m_fOnStopFiring = false; \
    }

#define FIRE_ONPLAY(pConnectionPoint) \
    if (m_fOnWindowLoadFired && !m_fOnPlayFiring) \
    { \
        m_fOnPlayFiring = true; \
        pConnectionPoint->FireEvent(DISPID_PATH_EVENT_ONPLAY, 0); \
        m_fOnPlayFiring = false; \
    }


#define FIRE_ONPAUSE(pConnectionPoint) \
    if (m_fOnWindowLoadFired && !m_fOnPauseFiring) \
    { \
        m_fOnPauseFiring = true; \
        pConnectionPoint->FireEvent(DISPID_PATH_EVENT_ONPAUSE, 0); \
        m_fOnPauseFiring = false; \
    }

#define FIRE_ONSEEK(pConnectionPoint, SeekTime) \
    if (m_fOnWindowLoadFired && !m_fOnSeekFiring) \
    { \
        m_fOnSeekFiring = true; \
        pConnectionPoint->FireEvent(DISPID_PATH_EVENT_ONSEEK, VT_R8, SeekTime, 0); \
        m_fOnSeekFiring = false; \
    }


#endif // __PATHEVNT_H__

// End of file pathevnt.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\path\pathctl.h ===
/*==========================================================================*\

    Module: 
            pathctl.h

    Author: 
            IHammer Team (SimonB)

    Created: 
            May 1997

    Description:
            Defines the control's class

    History:
            05-24-1997  Created

\*==========================================================================*/

#ifndef __PATHCTL_H__
#define __PATHCTL_H__

const double pi = 3.14159265359;

#include "..\ihbase\precomp.h"
#include "..\ihbase\ihbase.h"
#include "..\ihbase\timemark.h"
#include <daxpress.h>
#include "..\ihbase\clocker.h"
#undef Delete
#include <mshtml.h>
#define Delete delete

class CSeriesMarker
{
public:
    UINT m_iTickNumber;
    UINT m_iPosition;

    CSeriesMarker(UINT iTickNumber = 0, UINT iPosition = 0)
    {
        m_iTickNumber = iTickNumber; 
        m_iPosition = iPosition;
    }

    ~CSeriesMarker() {}
};

typedef CPtrDrg<CSeriesMarker> CSeriesMarkerDrg;


// Madness to prevent ATL from using CRT
#define _ATL_NO_DEBUG_CRT
#define _ASSERTE(x) ASSERT(x)
#include <atlbase.h>

/*==========================================================================*/

/*
CIHBaseCtl <    
        CPathCtl,                       //Name of the derived class
        IIHCtl,                         //Name of interface defining methods and properties
        &CLSID_IHCtl,           //CLSID of the control  Get this from ihctl.h
        &IID_IIHCtl,            //IID of the interface above.  Get this from ihctl.h
        &LIBID_IHCtl,           //LIBID of the typelib.  Get this from ihctl.h
        &DIID_IHCtlEvents > //IID of the event interface.  Get this from ihctl.h

*/

#define PATH_BASECLASS      \
CIHBaseCtl <                \
    CPathCtl,               \
    IPathCtl,               \
    &CLSID_PathControl,         \
    &IID_IPathCtl,          \
    &LIBID_DAExpressLib,    \
    &DIID_IPathCtlEvents>

/*==========================================================================*/

// EdgeAction enumeration
typedef enum {eaStop = 0, eaReverse, eaWrap, eaInvalid} EA;

class CPathCtl:         
    public IPathCtl,
    public PATH_BASECLASS,
    public CClockerSink
{
friend LPUNKNOWN __stdcall AllocPathControl(LPUNKNOWN punkOuter);

// Template stuff
    typedef PATH_BASECLASS CMyIHBaseCtl;

private:
    BOOL    m_fAutoStart;
    BOOL    m_fBounce;
    double  m_dblDuration;
    EA      m_ea;
    long    m_lRepeat;
    BSTR    m_bstrTarget;
    BSTR    m_bstrLanguage;
    double* m_pdblPoints;
    UINT    m_iNumPoints;
    UINT    m_iShapeType;
    double  m_dblTimerInterval;
    bool    m_fOnSeekFiring;
    boolean m_fOnWindowLoadFired;
    bool    m_fOnStopFiring;
    bool    m_fOnPlayFiring;
    bool    m_fOnPauseFiring;

    PlayStateConstant      m_enumPlayState;
    DirectionConstant      m_enumDirection;
    CPtrDrg<CTimeMarker>   m_drgTimeMarkers;
    CTimeMarker*           m_ptmFirst;
    CSeriesMarkerDrg       m_drgXSeries;
    CSeriesMarkerDrg       m_drgYSeries;

    CComPtr<IDAStatics>    m_StaticsPtr;
    CComPtr<IDAView>       m_ViewPtr;
    CComPtr<IDABehavior>   m_OffsetPtr;
    CComPtr<IDAPoint2>     m_keyFramePoint;
    CComPtr<IDAPath2>      m_PathPtr;
    CComPtr<IDABehavior>   m_BehaviorPtr;
    CComPtr<IDABehavior>   m_SwitcherPtr;

    BOOL                   m_fAlreadyStartedDA;

    BOOL                   m_fStarted;
    long                   m_lBehaviorID;
    CClocker               m_clocker;
        double                 m_dblBaseTime;
        double                 m_dblCurrentTick;
        double                 m_dblTimePaused;

    double                 m_dblTimeOffset;
    double                 m_dblTickBaseTime;

    double                 m_dblInstanceDuration;
    double                 m_dblTotalDuration;
    double                 m_dblPreviousTime;

    boolean                m_bRelative;
    POINT                  m_pointRelative;

    bool                   m_fTargetValidated;

    // key frame members

    BOOL   m_isKeyFramePath;
    double m_dblKeyFrameDuration;

protected:

        // 
        // Constructor and destructor
        // 
    CPathCtl(IUnknown *punkOuter, HRESULT *phr);

    ~CPathCtl();

        // Overides
        STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, LPVOID *ppv);
        
        STDMETHODIMP DoPersist(IVariantIO* pvio, DWORD dwFlags);
    STDMETHODIMP GetMiscStatus(DWORD dwAspect, DWORD *pdwStatus);

    STDMETHODIMP Draw(DWORD dwDrawAspect, LONG lindex, void *pvAspect,
         DVTARGETDEVICE *ptd, HDC hdcTargetDev, HDC hdcDraw,
         LPCRECTL lprcBounds, LPCRECTL lprcWBounds,
         BOOL (__stdcall *pfnContinue)(ULONG_PTR dwContinue), ULONG_PTR dwContinue);
        
        ///// IDispatch implementation
        protected:
    STDMETHODIMP GetTypeInfoCount(UINT *pctinfo);
    STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo);
    STDMETHODIMP GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames,
         LCID lcid, DISPID *rgdispid);
    STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid,
        WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult,
        EXCEPINFO *pexcepinfo, UINT *puArgErr);
   
    ///// IOleObject implementation
    protected:
    STDMETHODIMP SetClientSite(IOleClientSite *pClientSite);

        ///// delegating IUnknown implementation
        protected:
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv)
      { return m_punkOuter->QueryInterface(riid, ppv); }
    STDMETHODIMP_(ULONG) AddRef()
      { return m_punkOuter->AddRef(); }
    STDMETHODIMP_(ULONG) Release()
      { return m_punkOuter->Release(); }

        private:

    HRESULT AddTimeMarkerElement(CTimeMarker **ppNewMarker);
    HRESULT PersistTimeMarkers(IVariantIO* pvio, BOOL fLoading);
    HRESULT ParseSeriesSegment(LPTSTR pszSegment, CSeriesMarker **ppMarker);
    HRESULT PersistSeries(IVariantIO* pvio, BOOL fLoading, LPSTR pszSeriesName, CSeriesMarkerDrg *pSeriesDrg);

        //
        // IPathCtl methods 
        //
        
protected:

    HRESULT STDMETHODCALLTYPE get_Target(BSTR __RPC_FAR *bstrTarget);
    HRESULT STDMETHODCALLTYPE put_Target(BSTR bstrTarget);
    HRESULT STDMETHODCALLTYPE get_Duration(double __RPC_FAR *dblDuration);
    HRESULT STDMETHODCALLTYPE put_Duration(double dblDuration);
    HRESULT STDMETHODCALLTYPE get_TimerInterval(double __RPC_FAR *pdblTimerInterval);
    HRESULT STDMETHODCALLTYPE put_TimerInterval(double dblTimerInterval);
    HRESULT STDMETHODCALLTYPE get_Library(IDAStatics __RPC_FAR *__RPC_FAR *ppLibrary);
    HRESULT STDMETHODCALLTYPE get_Repeat(long __RPC_FAR *iRepeat);
    HRESULT STDMETHODCALLTYPE put_Repeat(long iRepeat);
    HRESULT STDMETHODCALLTYPE get_Relative(VARIANT_BOOL __RPC_FAR *bRelative);
    HRESULT STDMETHODCALLTYPE put_Relative(VARIANT_BOOL bRelative);
    HRESULT STDMETHODCALLTYPE get_Bounce(VARIANT_BOOL __RPC_FAR *fBounce);
    HRESULT STDMETHODCALLTYPE put_Bounce(VARIANT_BOOL fBounce);
    HRESULT STDMETHODCALLTYPE get_AutoStart(VARIANT_BOOL __RPC_FAR *fAutoStart); 
    HRESULT STDMETHODCALLTYPE put_AutoStart(VARIANT_BOOL fAutoStart); 
    HRESULT STDMETHODCALLTYPE get_PlayState(PlayStateConstant __RPC_FAR *State);
    HRESULT STDMETHODCALLTYPE get_Time(double __RPC_FAR *pdblTime);
    HRESULT STDMETHODCALLTYPE get_Direction(DirectionConstant __RPC_FAR *Dir);
    HRESULT STDMETHODCALLTYPE put_Direction(DirectionConstant Dir);
    HRESULT STDMETHODCALLTYPE get_Path(IDAPath2 __RPC_FAR **ppPath);
    HRESULT STDMETHODCALLTYPE put_Path(IDAPath2 __RPC_FAR *pPath);
    HRESULT STDMETHODCALLTYPE Seek(double dblTime);
    HRESULT STDMETHODCALLTYPE Stop(void);
    HRESULT STDMETHODCALLTYPE Pause(void);
    HRESULT STDMETHODCALLTYPE Play(void);
    HRESULT STDMETHODCALLTYPE Oval(double StartX, double StartY, double Width, double Height);
    HRESULT STDMETHODCALLTYPE Rect(double StartX, double StartY, double Width, double Height);
    HRESULT STDMETHODCALLTYPE Polyline(long nPoints, VARIANT Points);
    HRESULT STDMETHODCALLTYPE Polygon(long nPoints,VARIANT Points);
    HRESULT STDMETHODCALLTYPE AddTimeMarker(double dblTime,BSTR bstrMarker, VARIANT varAbsolute);
    HRESULT STDMETHODCALLTYPE KeyFrame(unsigned int iNumPoints, VARIANT varPoints, VARIANT varTimePoints);
    HRESULT STDMETHODCALLTYPE Spline(unsigned int iNumPoints, VARIANT varPoints);

#ifdef SUPPORTONLOAD
        void OnWindowLoad (void);
        void OnWindowUnload (void);
#endif //SUPPORTONLOAD

private:
    HRESULT GetPointArray(long iNumPoints, VARIANT vPoints, double **ppPoints);
    HRESULT PersistShape(IVariantIO *pvio, BOOL fLoading);
    HRESULT ConstructSafeArray(double *pPoints, UINT iNumPoints, VARTYPE vtDest, VARIANT *pvarDest);
    HRESULT ConvertStringToArray(LPTSTR pszLine, UINT iValuesPerPoint, BOOL fExpectPointCount, double **ppPoints, UINT *piNumPoints, BOOL fNeedPointCount);
    HRESULT UpdatePath(IDAPath2 *pPath);
    HRESULT CreatePath();
    HRESULT BuildInterpolant(IDANumber **ppInterpolant, double dlbDuration);
    HRESULT AnimateControl(IDAPoint2 *pointToAnimateBy);
    HRESULT StartModel(void);
    HRESULT StopModel(void);
    HRESULT SetTimeOffset(double offset);

    void DoPause();
    void DoStop();
    void DoSeek(double);
    void DoResume();

    HRESULT GetOffsetPoint(IHTMLElement* pelem, POINT& point);
    HRESULT HTMLElementFromName(BSTR bstrElementName, IHTMLElement** ppElement);
    HRESULT GetPoint(POINT& point);

    // Timing info:
    DWORD GetCurrTimeInMillis(void);
    double GetCurrTime() { return (double)(GetCurrTimeInMillis()) / 1000.0; }

public:
    virtual void OnTimer(DWORD dwTime);
};

/*==========================================================================*/

#endif // __PATHCTL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\path\pathinit.cpp ===
/*++

Module: 
	pathinit.cpp

Author: 
	IHammer Team (SimonB)

Created: 
	May 1997

Description:
	Performs control-specific initialisation

History:
	05-24-1997	Created (SimonB)

++*/

#include "..\ihbase\ihbase.h"
#include "..\mmctl\inc\ochelp.h" // for ControlInfo
#include "pathinit.h"
#include "..\resource.h"
#include <daxpress.h>

extern ULONG g_cLock;


void InitPathControlInfo(HINSTANCE hInst, ControlInfo *pCtlInfo, AllocOCProc pAlloc)
{
    // for some reason I can't statically initalize <g_ctlinfo>, so do it here
    memset(pCtlInfo, 0, sizeof(ControlInfo));
    pCtlInfo->cbSize = sizeof(ControlInfo);
    pCtlInfo->tszProgID = TEXT("DirectAnimation.PathControl");
    pCtlInfo->tszFriendlyName = TEXT("Microsoft DirectAnimation Path");
    pCtlInfo->pclsid = &CLSID_PathControl;
    pCtlInfo->hmodDLL = hInst;
    pCtlInfo->tszVersion = TEXT("1.0");
    pCtlInfo->iToolboxBitmapID = IDB_ICON_PATH;
    pCtlInfo->dwMiscStatusContent = CTL_OLEMISC;
    pCtlInfo->pallococ = pAlloc;
    pCtlInfo->pcLock = &g_cLock;
    pCtlInfo->dwFlags = CI_CONTROL | CI_SAFEFORSCRIPTING | 
                        CI_SAFEFORINITIALIZING | CI_MMCONTROL;

    pCtlInfo->pguidTypeLib = &LIBID_DAExpressLib; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\path\pathctl.cpp ===
/*==========================================================================*\

    Module:
            pathctl.cpp

    Author:
            IHammer Team (SimonB)

    Created:
            May 1997

    Description:
            Implements any control-specific members, as well as the control's interface

    History:

\*==========================================================================*/

#include "..\ihbase\precomp.h"
#include "..\ihbase\debug.h"
#include "..\ihbase\utils.h"
#include "pathctl.h"
#include "pathevnt.h"
#include "ctstr.h"
#include <parser.h>
#include <strwrap.h>

/*==========================================================================*/

// NOTE:
//
// The following DISPID comes from the Scripting group (ShonK specifically).
// It's not part of any header files at this point, so we define it locally.
//
// SimonB, 06-11-1997
//

#define DISPID_GETSAFEARRAY   -2700

// Define the number of characters per point for Shape persistence
#define CHARSPERNUMBER 16

/*==========================================================================*/
//
// CPathCtl Creation/Destruction
//

#define NUMSHAPES               6

#define SHAPE_INVALID         (-1)
#define SHAPE_OVAL              0
#define SHAPE_RECT              1
#define SHAPE_POLYLINE          2
#define SHAPE_POLYGON           3
#define SHAPE_SPLINE            4
#define SHAPE_POLYSPLINETIME    5

typedef struct tagShapeInfo
{
    TCHAR  rgchShapeName[11];   // The string representation
    BOOL   fIncludesPointCount; // Is the first param the point count ?
    int    iParamsPerPoint;     // How many parameters are expected (per element or in total)
} ShapeInfo;

const ShapeInfo g_ShapeInfoTable[NUMSHAPES] = 
{
    { TEXT("OVAL"),       FALSE, 4 },
    { TEXT("RECT"),       FALSE, 4 },
    { TEXT("POLYLINE"),   TRUE,  2 }, 
    { TEXT("POLYGON"),    TRUE,  2 },
    { TEXT("SPLINE"),     TRUE,  2 },
    { TEXT("KEYFRAME"),   TRUE,  3 }
};

LPUNKNOWN __stdcall AllocPathControl(LPUNKNOWN punkOuter)
{
    // Allocate object
    HRESULT hr;

    CPathCtl *pthis = New CPathCtl(punkOuter, &hr);

    if (pthis == NULL)
        return NULL;

    if (FAILED(hr))
    {
        delete pthis;
        return NULL;
    }

    // return an IUnknown pointer to the object
    return (LPUNKNOWN) (INonDelegatingUnknown *) pthis;
}

/*==========================================================================*/
//
// Beginning of class implementation
//

CPathCtl::CPathCtl(IUnknown *punkOuter, HRESULT *phr):
        CMyIHBaseCtl(punkOuter, phr),
    m_ptmFirst(NULL),
    m_fOnWindowLoadFired(false)
{
    // Initialise members
    m_bRelative = false;
    m_pointRelative.x = 0;
    m_pointRelative.y = 0;

    m_dblDuration = 0.0f;
    m_enumPlayState = Stopped;
    m_enumDirection = Forward;
    m_lRepeat = 1;
    m_fBounce = FALSE;
    m_bstrTarget = NULL;
    m_fStarted = FALSE;
    m_fAlreadyStartedDA = FALSE;
    m_lBehaviorID = 0;
    m_fAutoStart = FALSE;
    m_ea = eaInvalid;
    m_pdblPoints = NULL;
    m_iNumPoints = 0;
    m_iShapeType = -1; // Invalid shape
    m_dblTimerInterval = 0.1; // Default Timer Interval
    m_fOnSeekFiring = false;
    m_fTargetValidated = false;
    m_fOnStopFiring = false;
    m_fOnPlayFiring = false;
    m_fOnPauseFiring = false;

    // Tie into the DANIM DLL now...
    if (phr)
    {
        if (SUCCEEDED(*phr))
        {
            *phr = CoCreateInstance(
                CLSID_DAView,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IDAView,
                (void **) &m_ViewPtr);
        }

        if (SUCCEEDED(*phr))
        {
            *phr = ::CoCreateInstance(
                CLSID_DAStatics,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IDAStatics,
                (void **) &m_StaticsPtr);
        }

        if (SUCCEEDED(*phr))
        {
            m_bstrLanguage = SysAllocString(L"VBScript");

            //
            // setup all the time stuff
            //

            DoStop();
        }

        m_clocker.SetSink((CClockerSink *)this);
//        m_clocker.SetTimerType(CClocker::CT_WMTimer);
    }
}
        
/*==========================================================================*/

CPathCtl::~CPathCtl()
{
    StopModel();

    //if (m_fStarted && m_ViewPtr) {
    if (m_ViewPtr)
    {
        if (m_fStarted)
        {
            m_ViewPtr->RemoveRunningBvr(m_lBehaviorID);
        }

        //always need to call StopModel on the view.
        m_ViewPtr->StopModel();
    }

    if (m_bstrTarget)
    {
        SysFreeString(m_bstrTarget);
        m_bstrTarget = NULL;
    }

    if (m_bstrLanguage)
    {
        SysFreeString(m_bstrLanguage);
        m_bstrLanguage = NULL;
    }

    m_drgXSeries.MakeNullAndDelete();
    m_drgYSeries.MakeNullAndDelete();

    if (NULL != m_pdblPoints)
        Delete [] m_pdblPoints;
}

/*==========================================================================*/

STDMETHODIMP CPathCtl::NonDelegatingQueryInterface(REFIID riid, LPVOID *ppv)
{
        HRESULT hRes = S_OK;
        BOOL fMustAddRef = FALSE;

    if (ppv)
        *ppv = NULL;
    else
        return E_POINTER;

#ifdef _DEBUG
    char ach[200];
    TRACE("PathCtl::QI('%s')\n", DebugIIDName(riid, ach));
#endif

        if ((IsEqualIID(riid, IID_IPathCtl)) || (IsEqualIID(riid, IID_IDispatch)))
        {
                if (NULL == m_pTypeInfo)
                {
                        HRESULT hRes;
                        
                        // Load the typelib
                        hRes = LoadTypeInfo(&m_pTypeInfo, &m_pTypeLib, IID_IPathCtl, LIBID_DAExpressLib, NULL);

                        if (FAILED(hRes))
                        {
                                m_pTypeInfo = NULL;
                        }
                        else    
                                *ppv = (IPathCtl *) this;

                }
                else
                        *ppv = (IPathCtl *) this;
                
        }
    else // Call into the base class
        {
                DEBUGLOG(TEXT("Delegating QI to CIHBaseCtl\n"));
        return CMyIHBaseCtl::NonDelegatingQueryInterface(riid, ppv);

        }

    if (NULL != *ppv)
        {
                DEBUGLOG("PathCtl: Interface supported in control class\n");
                ((IUnknown *) *ppv)->AddRef();
        }

    return hRes;
}

/*==========================================================================*/

STDMETHODIMP CPathCtl::DoPersist(IVariantIO* pvio, DWORD dwFlags)
{
        HRESULT hr = S_OK;
    UINT iDirection = (UINT) m_enumDirection;

        BOOL fIsLoading = (S_OK == pvio->IsLoading());
    BOOL fRelative = m_bRelative;

    if (fIsLoading)
    {
        if (m_bstrTarget)
        {
            SysFreeString(m_bstrTarget);
            m_bstrTarget = NULL;
        }
    }

    if (FAILED(hr = pvio->Persist(0,
        "Autostart",     VT_BOOL, &m_fAutoStart,
        "Bounce",        VT_BOOL, &m_fBounce,
        "Direction",     VT_I4,   &iDirection,
        "Duration",      VT_R8,   &m_dblDuration,
        "Repeat",        VT_I4,   &m_lRepeat,
        "Target",        VT_BSTR, &m_bstrTarget,
        "Relative",      VT_BOOL, &fRelative,
        NULL)))
        return hr;


    if (fIsLoading)
    {
        m_fTargetValidated = false;

        m_bRelative = (boolean) fRelative;
        if (FAILED(hr = pvio->Persist(0,
            "TimerInterval", VT_R8,   &m_dblTimerInterval,
            NULL)))
            return hr;

        if (S_OK != hr)
        {
            int iTickInterval = 0;

            if (FAILED(hr = pvio->Persist(0,
                "TickInterval", VT_I4, &iTickInterval,
                NULL)))
                return hr;
            else if (S_OK == hr)
                m_dblTimerInterval = ((double)iTickInterval) / 1000;
        }

        // Do range checking and conversions, using defaults where invalid values are specified
        if ( (iDirection == 0) || (iDirection == 1) )
            m_enumDirection = (DirectionConstant) iDirection;
        else
            m_enumDirection = Forward; 
        
        if (m_lRepeat < -1)
            m_lRepeat = -1 * m_lRepeat;

        if (FAILED(hr = pvio->Persist(0,
            "EdgeAction", VT_I2, &m_ea,
            NULL)))
            return hr;

        switch (m_ea)
        {
            case eaStop:
            {
                m_lRepeat = 1;
                m_fBounce = FALSE;
            }
            break;

            case eaReverse:
            {
                m_lRepeat = -1;
                m_fBounce = TRUE;
            }
            break;

            case eaWrap:
            {
                m_lRepeat = -1;
                m_fBounce = FALSE;
            }
            break;
        }
    }
    else // Saving
    {
        // EdgeAction
        if (m_ea != eaInvalid)
            pvio->Persist(0,
                "EdgeAction", VT_I4, &m_ea,
                 NULL);

        if (FAILED(hr = pvio->Persist(0,
             "TimerInterval", VT_R8,   &m_dblTimerInterval,
             NULL)))
             return hr;
    }


    if (FAILED(PersistTimeMarkers(pvio, fIsLoading)))
        {} // Ignore failure

    if (FAILED(PersistSeries(pvio, fIsLoading, "XSeries", &m_drgXSeries)))
        {} // Ignore failure

    if (FAILED(PersistSeries(pvio, fIsLoading, "YSeries", &m_drgYSeries)))
        {} // Ignore failure

    if (FAILED(PersistShape(pvio, fIsLoading)))
        {} // Ignore failure

    // clear the dirty bit if requested
    if (dwFlags & PVIO_CLEARDIRTY)
        m_fDirty = FALSE;

    return hr;
}

/*==========================================================================*/

STDMETHODIMP CPathCtl::GetMiscStatus(DWORD dwAspect, DWORD *pdwStatus)
{
    HRESULT hr = S_OK;
    
    if (FAILED(hr = CMyIHBaseCtl::GetMiscStatus(dwAspect, pdwStatus)))
        return hr;
    
    *pdwStatus |= OLEMISC_INVISIBLEATRUNTIME;

    return S_OK;
}

/*==========================================================================*/

STDMETHODIMP CPathCtl::Draw(DWORD dwDrawAspect, LONG lindex, void *pvAspect,
     DVTARGETDEVICE *ptd, HDC hdcTargetDev, HDC hdcDraw,
     LPCRECTL lprcBounds, LPCRECTL lprcWBounds,
     BOOL (__stdcall *pfnContinue)(ULONG_PTR dwContinue), ULONG_PTR dwContinue)
{

    HBRUSH          hbr;            // brush to draw with
    HBRUSH          hbrPrev;        // previously-selected brush
    HPEN            hpenPrev;       // previously-selected pen

    if (m_fDesignMode)
    {
        if ((hbr = (HBRUSH) GetStockObject(WHITE_BRUSH)) != NULL)
        {

            hbrPrev = (HBRUSH) SelectObject(hdcDraw, hbr);
            hpenPrev = (HPEN) SelectObject(hdcDraw, GetStockObject(BLACK_PEN));
            Rectangle(hdcDraw, 
                m_rcBounds.left, m_rcBounds.top,
                m_rcBounds.right, m_rcBounds.bottom);

            SelectObject(hdcDraw, hbrPrev);
            SelectObject(hdcDraw, hpenPrev);
            DeleteObject(hbr);
        }
    }
    return S_OK;
}

/*==========================================================================*/
//
// IDispatch Implementation
//

STDMETHODIMP CPathCtl::GetTypeInfoCount(UINT *pctinfo)
{
    *pctinfo = 1;
    return S_OK;
}

/*==========================================================================*/

STDMETHODIMP CPathCtl::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)
{
        
        *pptinfo = NULL;

    if(itinfo != 0)
        return ResultFromScode(DISP_E_BADINDEX);

    m_pTypeInfo->AddRef();
    *pptinfo = m_pTypeInfo;

    return NOERROR;
}

/*==========================================================================*/

STDMETHODIMP CPathCtl::GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames,
    UINT cNames, LCID lcid, DISPID *rgdispid)
{

        return DispGetIDsOfNames(m_pTypeInfo, rgszNames, cNames, rgdispid);
}

/*==========================================================================*/

STDMETHODIMP CPathCtl::Invoke(DISPID dispidMember, REFIID riid, LCID lcid,
    WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult,
    EXCEPINFO *pexcepinfo, UINT *puArgErr)
{
        HRESULT hr;

        hr = DispInvoke((IPathCtl *)this,
                m_pTypeInfo,
                dispidMember, wFlags, pdispparams,
                pvarResult, pexcepinfo, puArgErr);

        return hr;
}

/*==========================================================================*/

STDMETHODIMP CPathCtl::SetClientSite(IOleClientSite *pClientSite)
{
    HRESULT hr = CMyIHBaseCtl::SetClientSite(pClientSite);

    if (m_ViewPtr)
    {
        m_ViewPtr->put_ClientSite(pClientSite);
    }
    m_clocker.SetHost(pClientSite);
    m_ViewPtr->put_ClientSite(pClientSite);
    m_StaticsPtr->put_ClientSite(pClientSite);

    if (!pClientSite)
        StopModel();

    return hr;
}

/*==========================================================================*/

HRESULT CPathCtl::AddTimeMarkerElement(CTimeMarker **ppNewMarker)
{
        HRESULT hRes = S_OK;

        if ( (*ppNewMarker) && (NULL != (*ppNewMarker)->m_pwszMarkerName) )
        {
                m_drgTimeMarkers.Insert(*ppNewMarker);
        }
        else
        {
                if (NULL != *ppNewMarker)
                {
                        Delete *ppNewMarker;
                        *ppNewMarker = NULL;
                }

                hRes = E_OUTOFMEMORY;
        }

        return hRes;
}

/*==========================================================================*/

HRESULT CPathCtl::PersistTimeMarkers(IVariantIO* pvio, BOOL fLoading)
{
        HRESULT hRes = S_OK;

        if (fLoading)
        {
                int iLine = 1;

                // Poor design - We have two references to 
                // the first time marker in the list.  We need
                // to NULL this pointer out, and defer the 
                // actual deletion to the 
                // m_drgTimeMarkers.MakeNullAndDelete call.
                if (NULL != m_ptmFirst)
                {
                        m_ptmFirst = NULL;
                }
                m_drgTimeMarkers.MakeNullAndDelete();
                CTimeMarker *pTimeMarker;

                while (S_OK == hRes)
                {
            hRes = ParseTimeMarker(pvio, iLine++, &pTimeMarker, &m_ptmFirst);
                        if (S_OK == hRes)
                        {
                                hRes = AddTimeMarkerElement(&pTimeMarker);
                        }
                }
        }
        else // Saving
        {
                int iLine = 1;
                int iNumItems = m_drgTimeMarkers.Count();

                while ( (iLine <= iNumItems) && (S_OK == hRes) )
                {
                        hRes = WriteTimeMarker(pvio, iLine, m_drgTimeMarkers[iLine - 1]);
                        iLine++;
                }

        }
        return hRes;
}

/*==========================================================================*/

HRESULT CPathCtl::ParseSeriesSegment(LPTSTR pszSegment, CSeriesMarker **ppMarker)
{
    HRESULT hr = S_OK;

    if (ppMarker == NULL)
        return E_POINTER;

    *ppMarker = NULL;
    
    CLineParser SegmentParser(pszSegment, FALSE);
    
    if (SegmentParser.IsValid())
    {
        int iTick = 0, iPosition = 0;
        HRESULT hrLine = S_OK;

        SegmentParser.SetCharDelimiter(TEXT(','));

        if (S_OK != (hrLine = SegmentParser.GetFieldInt(&iTick, TRUE)))
        {
            hr = E_FAIL;
        }
        else
        {
            if (S_FALSE != (hrLine = SegmentParser.GetFieldInt(&iPosition, TRUE)))
            {
                hr = E_FAIL;
            }
            else
            {
                // Got both field successfully
                *ppMarker = New CSeriesMarker(iTick, iPosition);
                if (NULL == *ppMarker)
                {
                    hr = E_OUTOFMEMORY;
                }
            }
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;

}

/*==========================================================================*/

HRESULT CPathCtl::PersistSeries(IVariantIO* pvio, BOOL fLoading, LPSTR pszSeriesName, CSeriesMarkerDrg *pSeriesDrg)
{
    HRESULT hr = S_OK;

    if (fLoading)
    {
        pSeriesDrg->MakeNullAndDelete();
        BSTR bstrLine = NULL;
        
        hr = pvio->Persist(0,
            pszSeriesName, VT_BSTR, &bstrLine,
            NULL);
        
        if ((S_OK != hr) || (NULL == bstrLine))
        {
            if (S_FALSE == hr)
                hr = S_OK;

            return hr;
        }

        // Got the string, now parse it out ...
        CLineParser LineParser(bstrLine);
        CTStr tstrSegment(lstrlenW(bstrLine));
        LPTSTR pszSegment = tstrSegment.psz();
        CSeriesMarker *pMarker = NULL;

        SysFreeString(bstrLine);

        if ( (!LineParser.IsValid()) || (NULL == pszSegment) )
        {
            hr = E_OUTOFMEMORY;
            return hr;
        }
        
        LineParser.SetCharDelimiter(TEXT(';'));

        while (S_OK == hr)
        {
            HRESULT hrLine = S_OK;
            
            hr = LineParser.GetFieldString(pszSegment, TRUE);
            if (SUCCEEDED(hr))
            {
                if (SUCCEEDED(hrLine = ParseSeriesSegment(pszSegment, &pMarker)))
                {
                    if (!pSeriesDrg->Insert(pMarker))
                        hr = E_FAIL;
                }
            }
            
            if (FAILED(hrLine))
                hr = hrLine;
        }
    }
    else // Save
    {
        int iCount = pSeriesDrg->Count();

        if (0 == iCount)
            return S_OK;

        CTStr tstrLine(iCount * 50); // Allocate 50 chars per entry
        LPTSTR pszLine = tstrLine.psz();

        CTStr tstrSegment(50);
        LPSTR pszSegment = tstrSegment.psz();

        if ( (NULL == pszLine) || (NULL == pszSegment) )
            hr = E_OUTOFMEMORY;
        else
        {
            int i = 0, iFmt = 0;
            CSeriesMarker *pMarker = NULL;
            TCHAR tchFormat[][10] = { TEXT("%lu,%lu"), TEXT(";%lu,%lu")};

            while (i < iCount)
            {
                pMarker = (*pSeriesDrg)[i];
                
                wsprintf(pszSegment, tchFormat[iFmt], pMarker->m_iTickNumber, pMarker->m_iPosition);
                
                iFmt = (i > 0 ? 1 : 0);

                CStringWrapper::Strcat(pszLine, pszSegment);
                
                i++;
            }

            BSTR bstrLine = tstrSegment.SysAllocString();
            hr = pvio->Persist(0,
                pszSeriesName, VT_BSTR, &bstrLine,
                NULL);

            SysFreeString(bstrLine);
        }
    }

    return hr;
}


/*==========================================================================*/
//
// IPathCtl implementation
//

HRESULT STDMETHODCALLTYPE CPathCtl::get_Target(BSTR __RPC_FAR *bstrTarget)
{
    HANDLENULLPOINTER(bstrTarget);

    if (m_bstrTarget)
    {
        // Give back a copy of our current target name...
        *bstrTarget = SysAllocString(m_bstrTarget);
    }

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CPathCtl::put_Target(BSTR bstrTarget)
{
    HRESULT hr = S_OK;

    if (m_bstrTarget)
    {
        SysFreeString(m_bstrTarget);
        m_bstrTarget = NULL;
    }

    m_bstrTarget = SysAllocString(bstrTarget);

    hr = (m_bstrTarget != NULL) ? S_OK : E_POINTER;
    
    if (SUCCEEDED(hr))
        m_fTargetValidated = false;

    
    return hr;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CPathCtl::get_Duration(double __RPC_FAR *dblDuration)
{
    HANDLENULLPOINTER(dblDuration);

    *dblDuration = m_dblDuration;

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CPathCtl::put_Duration(double dblDuration)
{
    m_dblDuration = dblDuration;
    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CPathCtl::get_TimerInterval(double __RPC_FAR *pdblTimerInterval)
{
    HANDLENULLPOINTER(pdblTimerInterval);

    *pdblTimerInterval = m_dblTimerInterval;

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CPathCtl::put_TimerInterval(double dblTimerInterval)
{
    m_dblTimerInterval = dblTimerInterval;

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CPathCtl::get_Library(IDAStatics __RPC_FAR **ppLibrary)
{
    HANDLENULLPOINTER(ppLibrary);

        if (!m_fDesignMode)
        {
                if (m_StaticsPtr)
                {
                        // AddRef since this is really a Query...
                        m_StaticsPtr.p->AddRef();

                        // Set the return value...
                        *ppLibrary = m_StaticsPtr.p;
                }
        }
        else
        {
                return CTL_E_GETNOTSUPPORTED;
        }

    return S_OK;
}



/*==========================================================================*/

// Yanked largely (and modified) from DirectAnimation, server\cbvr.cpp.

#define IS_VARTYPE(x,vt) ((V_VT(x) & VT_TYPEMASK) == (vt))
#define IS_VARIANT(x) IS_VARTYPE(x,VT_VARIANT)

class CSafeArrayOfDoublesAccessor
{
  public:
    CSafeArrayOfDoublesAccessor(VARIANT v, HRESULT *phr);
    ~CSafeArrayOfDoublesAccessor();

    unsigned int GetArraySize() { return _ubound - _lbound + 1; }

    HRESULT ToDoubleArray(unsigned int size, double *array);

    bool IsNullArray() {
                return (_s == NULL);
    }
    
  protected:
    SAFEARRAY * _s;
    union {
        VARIANT * _pVar;
        double * _pDbl;
        IUnknown ** _ppUnk;
        void *_v;
    };
    
    long _lbound;
    long _ubound;
    bool _inited;
    bool _isVar;
    unsigned int _numObjects;
    CComVariant _retVar;
};

CSafeArrayOfDoublesAccessor::CSafeArrayOfDoublesAccessor(VARIANT v,
                                                                                                                 HRESULT *phr)
: _inited(false),
  _isVar(false),
  _s(NULL)
{
    HRESULT hr;
    VARIANT *pVar;

    // Check if it is a reference to another variant
    
    if (V_ISBYREF(&v) && !V_ISARRAY(&v) && IS_VARIANT(&v))
        pVar = V_VARIANTREF(&v);
    else
        pVar = &v;

    // Check for an array
    if (!V_ISARRAY(pVar)) {
        // For JSCRIPT
        // See if it is a IDispatch and see if we can get a safearray from
        // it
        if (!IS_VARTYPE(pVar,VT_DISPATCH)) {
                        *phr = DISP_E_TYPEMISMATCH;
                        return;
                }

        IDispatch * pdisp;
        
        if (V_ISBYREF(pVar))
            pdisp = *V_DISPATCHREF(pVar);
        else
            pdisp = V_DISPATCH(pVar);
    
        DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};
        
        // Need to pass in a VARIANT that we own and will free.  Use
        // the internal _retVar parameter
        
        hr = pdisp->Invoke(DISPID_GETSAFEARRAY,
                           IID_NULL,
                           LOCALE_USER_DEFAULT,
                           DISPATCH_METHOD|DISPATCH_PROPERTYGET,
                           &dispparamsNoArgs,
                           &_retVar, NULL, NULL);
        
        if (FAILED(hr)) {
                        *phr = DISP_E_TYPEMISMATCH;
                        return;
                }
        
        // No need to check for a reference since you cannot return
        // VARIANT references
        pVar = &_retVar;
        
        // Check for an array
        if (!V_ISARRAY(pVar)) {
                        *phr = DISP_E_TYPEMISMATCH;
                        return;
                }
    }
    
    // If it is an object then we know how to handle it
    if (!IS_VARTYPE(pVar,VT_UNKNOWN) &&
        !IS_VARTYPE(pVar,VT_DISPATCH)) {
                
        // If it is a variant then just delay the check
        if (IS_VARIANT(pVar)) {
            _isVar = true;
                        // Check the type to see if it is one of the options
                } else if (IS_VARTYPE(pVar, VT_R8)) {
                        _isVar = false;
                } else {
                        *phr = DISP_E_TYPEMISMATCH;
                        return;
                }
    }

    if (V_ISBYREF(pVar))
        _s = *V_ARRAYREF(pVar);
    else
        _s = V_ARRAY(pVar);
    
    if (NULL == _s) {
                *phr = DISP_E_TYPEMISMATCH;
                return;
    }

    if (SafeArrayGetDim(_s) != 1) {
                *phr = DISP_E_TYPEMISMATCH;
                return;
        }

    hr = SafeArrayGetLBound(_s,1,&_lbound);
        
    if (FAILED(hr)) {
                *phr = DISP_E_TYPEMISMATCH;
                return;
        }
        
    hr = SafeArrayGetUBound(_s,1,&_ubound);
        
    if (FAILED(hr)) {
                *phr = DISP_E_TYPEMISMATCH;
                return;
        }
        
    hr = SafeArrayAccessData(_s,(void **)&_v);

    if (FAILED(hr)) {
                *phr = DISP_E_TYPEMISMATCH;
                return;
        }
        
    _inited = true;

    // If it is a variant see if they are objects or not

    if (_isVar) {
        if (GetArraySize() > 0) {
            // Check the first argument to see its type
            // If it is not an object then we assume we will need to
            // use the alternative type.

            VARIANT * pVar = &_pVar[0];

            // Check if it is a reference to another variant
            
            if (V_ISBYREF(pVar) && !V_ISARRAY(pVar) && IS_VARIANT(pVar))
                pVar = V_VARIANTREF(pVar);

        }
    }

    _numObjects = GetArraySize();
}

CSafeArrayOfDoublesAccessor::~CSafeArrayOfDoublesAccessor()
{
    if (_inited && !IsNullArray())
        SafeArrayUnaccessData(_s);
}

HRESULT
CSafeArrayOfDoublesAccessor::ToDoubleArray(unsigned int size, double *array)
{
        HRESULT hr;

        if (size > _numObjects) {
                return E_INVALIDARG;
        }
        
    if (IsNullArray()) {
                return S_OK;
    }

        for (unsigned int i = 0; i < size; i++) {
                
                double dbl;
                
                if (_isVar) {
                        CComVariant num;
                    
                        hr = ::VariantChangeTypeEx(&num, &_pVar[i], LANGID_USENGLISH, 0, VT_R8);
                    
                        if (FAILED(hr)) {
                                return DISP_E_TYPEMISMATCH;
                        }

                        dbl = num.dblVal;
                } else {
                        dbl = _pDbl[i];
                }

                array[i] = dbl;
        }

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CPathCtl::KeyFrame(unsigned int numPoints,
                                                                                         VARIANT varPoints,
                                                                                         VARIANT varTimePoints)
{
        CComPtr<IDANumber> finalTimeBvr;
        CComPtr<IDANumber> interpolator;
        CComPtr<IDAPoint2> splinePoint;
        CComPtr<IDAPath2>  polyline;
        double             accumulation = 0;
    HRESULT            hr = S_OK;
        int                iNumPoints = numPoints;

    if (numPoints < 2) {
        return E_INVALIDARG;
    }

        // Need to go through the points and convert them to an array of
        // Point2's.
        CSafeArrayOfDoublesAccessor safePts(varPoints, &hr);
        if (FAILED(hr)) return hr;
        
        CSafeArrayOfDoublesAccessor safeTimes(varTimePoints, &hr);
        if (FAILED(hr)) return hr;

        int i;
        
        double *safePtsDoubles = New double[iNumPoints * 2];
        double *safeTimesDoubles = New double[iNumPoints - 1];

        typedef IDAPoint2 *IDAPoint2Ptr;
        typedef IDANumber *IDANumberPtr;
        IDAPoint2 **pts = New IDAPoint2Ptr[iNumPoints];
        IDANumber **knots = New IDANumberPtr[iNumPoints];
        
        if (!pts || !knots || !safePtsDoubles || !safeTimesDoubles) {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
        }

        if (FAILED(hr = safePts.ToDoubleArray(iNumPoints*2,
                                                                                  safePtsDoubles)) ||
                FAILED(hr = safeTimes.ToDoubleArray(iNumPoints - 1,
                                                                                        safeTimesDoubles))) {
                hr = E_FAIL;
                goto Cleanup;
        }
        
        // Null out so we can always free exactly what's been allocated
        for (i = 0; i < iNumPoints; i++) {
                pts[i] = NULL;
                knots[i] = NULL;
        }

        // Fill in the points
        double x, y;
        for (i = 0; i < iNumPoints; i++) {
                x = safePtsDoubles[2*i+0];
                y = safePtsDoubles[2*i+1];
                if (FAILED(hr = m_StaticsPtr->Point2(x, y, &pts[i]))) {
                        hr = E_FAIL;
                        goto Cleanup;
                }
        }
        
        // First knot is zero.
        if (FAILED(hr = m_StaticsPtr->DANumber(0, &knots[0]))) {
                goto Cleanup;
        }

        for (i = 1; i < iNumPoints; i++) {
                double interval = safeTimesDoubles[i-1];
                accumulation += interval;
                if (FAILED(hr = m_StaticsPtr->DANumber(accumulation,
                                                                                           &knots[i]))) {
                        goto Cleanup;
                }

        }

        // Release any m_keyFramePoint we may have previously been holding
        // onto.
        m_keyFramePoint.Release();

    m_dblKeyFrameDuration = accumulation;

        if (
           FAILED(hr = m_StaticsPtr->get_LocalTime(&interpolator))
        || FAILED(hr = m_StaticsPtr->Point2BSplineEx(1, iNumPoints, knots, iNumPoints, pts, 0, NULL, interpolator, &m_keyFramePoint))
        || FAILED(hr = m_StaticsPtr->PolylineEx(iNumPoints, pts, &polyline))
       ) {
                goto Cleanup;
        }

        // Although we're going to animate through m_keyFramePoint,
        // provide a polyline that traverses the path so that getPath
        // works correctly.
        hr = UpdatePath(polyline);
    m_isKeyFramePath = true;

Cleanup:
        for (i = 0; i < iNumPoints; i++) {
                if (pts[i]) pts[i]->Release();
                if (knots[i]) knots[i]->Release();
        }

        Delete [] safePtsDoubles;
        Delete [] safeTimesDoubles;
        Delete [] pts;
        Delete [] knots;

        return hr;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CPathCtl::Spline(unsigned int iNumPoints, VARIANT varPoints)
{
    HRESULT hr = E_FAIL;

    if (iNumPoints >= 3) {
        VARIANT varKnots;
        double *pArray = NULL;
        SAFEARRAY *psa = NULL;

        psa = SafeArrayCreateVector(VT_R8, 0, iNumPoints + 2);

        if (NULL == psa)
            return E_OUTOFMEMORY;

        // Try and get a pointer to the data
        if (SUCCEEDED(SafeArrayAccessData(psa, (LPVOID *)&pArray)))
        {
            for(unsigned int index = 2; index < iNumPoints; index++) {
                pArray[index] = index;
            }

            pArray[0] = pArray[1] = pArray[2];
            pArray[iNumPoints + 1] = pArray[iNumPoints] = pArray[iNumPoints - 1];

            hr = SafeArrayUnaccessData(psa);
            ASSERT(SUCCEEDED(hr));

            // Our variant is going to be an array of VT_R8s
            VariantInit(&varKnots);
            varKnots.vt = VT_ARRAY | VT_R8;
            varKnots.parray = psa;

            CComPtr<IDAPath2> PathPtr;
            if (SUCCEEDED(hr = m_StaticsPtr->CubicBSplinePath(varPoints, varKnots, &PathPtr))) {

                hr = UpdatePath(PathPtr);
            }
        }

        if (NULL != psa)
        {
            SafeArrayDestroy(psa);
        }

    }

    return hr;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CPathCtl::get_Repeat(long __RPC_FAR *lRepeat)
{
    HANDLENULLPOINTER(lRepeat);

    *lRepeat = m_lRepeat;

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CPathCtl::put_Repeat(long lRepeat)
{
    m_lRepeat = lRepeat;
    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CPathCtl::get_Bounce(VARIANT_BOOL __RPC_FAR *fBounce)
{
    HANDLENULLPOINTER(fBounce);

    *fBounce = BOOL_TO_VBOOL(m_fBounce);
    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CPathCtl::put_Bounce(VARIANT_BOOL fBounce)
{
    m_fBounce = VBOOL_TO_BOOL(fBounce);
    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CPathCtl::get_AutoStart(VARIANT_BOOL __RPC_FAR *fAutoStart)
{
    HANDLENULLPOINTER(fAutoStart);

    if (m_fDesignMode)
    {
        *fAutoStart = BOOL_TO_VBOOL(m_fAutoStart);
        return S_OK;
    }
    else
    {
        return CTL_E_GETNOTSUPPORTEDATRUNTIME;
    }
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CPathCtl::put_AutoStart(VARIANT_BOOL fAutoStart)
{
    if (m_fDesignMode)
    {
        m_fAutoStart = VBOOL_TO_BOOL(fAutoStart);
        return S_OK;
    }
    else
    {
        return CTL_E_SETNOTSUPPORTEDATRUNTIME;
    }
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CPathCtl::get_Relative(VARIANT_BOOL __RPC_FAR *bRelative)
{
    HANDLENULLPOINTER(bRelative);

    *bRelative = BOOL_TO_VBOOL(m_bRelative);
    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CPathCtl::put_Relative(VARIANT_BOOL bRelative)
{
    m_bRelative = VBOOL_TO_BOOL(bRelative);
    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CPathCtl::get_PlayState(PlayStateConstant __RPC_FAR *State)
{
    HANDLENULLPOINTER(State);

    *State = (PlayStateConstant) 0;

    // This property is only available at run-time
    if (m_fDesignMode)
        return CTL_E_GETNOTSUPPORTED;

    *State = m_enumPlayState;

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CPathCtl::get_Time(double __RPC_FAR *pdblTime)
{
    HANDLENULLPOINTER(pdblTime);

    // This property is only available at run-time
    if (m_fDesignMode)
        return CTL_E_GETNOTSUPPORTED;

        DWORD dwTick = (DWORD)((m_dblCurrentTick - m_dblBaseTime + 0.0005) * 1000);
    *pdblTime = (double)dwTick / 1000.;

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CPathCtl::get_Direction(DirectionConstant __RPC_FAR *Dir)
{
    HANDLENULLPOINTER(Dir);

    *Dir = m_enumDirection;

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CPathCtl::put_Direction(DirectionConstant Dir)
{
    if (Dir == 1) {
        m_enumDirection = Backward;
    } else {
        m_enumDirection = Forward;
    }

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CPathCtl::get_Path(IDAPath2 __RPC_FAR **ppPath)
{
    HANDLENULLPOINTER(ppPath);

    if (ppPath)
    {
        IDAPath2 *pPath = m_PathPtr;

        if (pPath)
        {
            // AddRef since this is really a Query...
            pPath->AddRef();

            // Set the return value...
            *ppPath = pPath;
        }
    }

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CPathCtl::put_Path(IDAPath2 __RPC_FAR *pPath)
{
    HRESULT hr = S_OK;

    HANDLENULLPOINTER(pPath);

    if (pPath)
    {
        hr = UpdatePath(pPath);
    }

    return hr;
}

/*==========================================================================*/

void FirePathMarker(IConnectionPointHelper* pconpt, CTimeMarker* pmarker, boolean bPlaying)
{
    BSTR bstrName = SysAllocString(pmarker->m_pwszMarkerName);
    if (bPlaying) {
        pconpt->FireEvent(DISPID_PATH_EVENT_ONPLAYMARKER, VT_BSTR, bstrName, 0);
    }

    pconpt->FireEvent(DISPID_PATH_EVENT_ONMARKER, VT_BSTR, bstrName, 0);

    SysFreeString(bstrName);
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CPathCtl::AddTimeMarker(double dblTime, BSTR bstrMarker, VARIANT varAbsolute)
{
    HANDLENULLPOINTER(bstrMarker);

    BOOL fAbsolute = TRUE;

    if (!ISEMPTYARG(varAbsolute))
    {
        VARIANT varTarget;
        VariantInit(&varTarget);

        if (SUCCEEDED(VariantChangeTypeEx(&varTarget, &varAbsolute, LANGID_USENGLISH, 0, VT_BOOL)))
            fAbsolute = VBOOL_TO_BOOL(V_BOOL(&varTarget));
        else
            return DISP_E_TYPEMISMATCH;
    }

    if (dblTime < 0) {
        return E_FAIL;
    }

    CTimeMarker *pNewMarker = New CTimeMarker(&m_ptmFirst, dblTime, bstrMarker, (boolean) fAbsolute);

        return AddTimeMarkerElement(&pNewMarker);
}

/*==========================================================================*/

void CPathCtl::DoPause(void)
{
     m_dblCurrentTick =
      m_dblTimePaused = GetCurrTime();
}

/*==========================================================================*/

void CPathCtl::DoSeek(double dblTime)
{
    double dblDelta = dblTime - m_dblPreviousTime;

    if (dblTime > m_dblPreviousTime) {
        if (m_fOnWindowLoadFired) {
            FireMarkersBetween(
                m_pconpt,
                m_ptmFirst,
                FirePathMarker,
                m_dblPreviousTime,
                dblTime,
                m_dblInstanceDuration,
                Playing == m_enumPlayState
            );
        }
    }

    SetTimeOffset(m_dblTimeOffset - dblDelta);

    m_dblBaseTime = m_dblCurrentTick - dblTime;

    m_dblPreviousTime = dblTime;
}

/*==========================================================================*/

void CPathCtl::DoResume()
{
    double dblDelta = GetCurrTime() - m_dblTimePaused;

    m_dblTickBaseTime += dblDelta;
    m_dblBaseTime     += dblDelta;
    m_dblCurrentTick  += dblDelta;
}

/*==========================================================================*/

void CPathCtl::DoStop()
{
    m_dblTickBaseTime =
        m_dblBaseTime =
        m_dblTimePaused =
        m_dblCurrentTick = GetCurrTime();

    m_dblPreviousTime = 0;
    SetTimeOffset(0);
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CPathCtl::Stop(void)
{
    HRESULT hr = S_OK;

    if (m_enumPlayState != Stopped) {
        if (m_enumPlayState == Playing) {
                    if (FAILED(hr = m_clocker.Stop())) return hr;
        }

        if (FAILED(hr = StopModel())) return hr;

        DoStop();

        m_enumPlayState = Stopped;

        FIRE_ONSTOP(m_pconpt);
    }

    return hr;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CPathCtl::Pause(void)
{
        HRESULT hr = S_OK;

    if (Playing == m_enumPlayState)
    {
                // Stop the clock from ticking.
                hr = m_clocker.Stop();
                ASSERT(SUCCEEDED(hr));

                if (SUCCEEDED(hr))
                {
            DoPause();
                        m_enumPlayState = Paused;
                }

        FIRE_ONPAUSE(m_pconpt);
    }

    return hr;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE 
CPathCtl::Seek(double dblTime)
{
        if (dblTime < 0) {
        return E_INVALIDARG;

        }

    DoSeek(dblTime);

        FIRE_ONSEEK(m_pconpt, dblTime);

        return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CPathCtl::Play(void)
{
    HRESULT hr = S_OK;

    if (Playing != m_enumPlayState) 
    {
        if (Paused != m_enumPlayState) 
        {
            if (m_bRelative) 
            {
                if (FAILED(GetPoint(m_pointRelative))) return hr;
            } 
            else 
            {
                if (!m_fTargetValidated)
                {
                    IHTMLElement *pElement = NULL;

                    // First make sure the target exists by checking in the object model
                    hr = HTMLElementFromName(m_bstrTarget, &pElement);

                    if ((NULL == pElement) || FAILED(hr))
                        return hr;
                    else
                        SafeRelease((LPUNKNOWN *)&pElement);

                }
                m_pointRelative.x = 0;
                m_pointRelative.y = 0;
            }

            m_fTargetValidated = true;

            if (FAILED(hr = StartModel())) return hr;

            VARIANT_BOOL vBool;
            if (FAILED(hr = m_ViewPtr->Tick(0.0001, &vBool))) return hr;
        }

        DoResume();

        m_clocker.SetInterval((int)(m_dblTimerInterval * 1000));
        if (FAILED(hr = m_clocker.Start())) return hr;

        m_enumPlayState = Playing;

        FIRE_ONPLAY(m_pconpt);
    }

    return hr;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CPathCtl::Oval(
    double StartX,
    double StartY,
    double Width,
    double Height)
{
    HRESULT hr;

    CComPtr<IDATransform2> translate;
    CComPtr<IDATransform2> rotate;
    CComPtr<IDATransform2> xf1;
    CComPtr<IDATransform2> xf;
    CComPtr<IDAPath2> PathPtr;
    CComPtr<IDAPath2> TransformedPathPtr;

    if (FAILED(hr = m_StaticsPtr->Rotate2(-pi / 2, &rotate))) return hr;
    if (FAILED(hr = m_StaticsPtr->Translate2(StartX + Width / 2, StartY + Height / 2, &translate))) return hr;

    if (FAILED(hr = m_StaticsPtr->Compose2(translate, rotate, &xf))) return hr;

    if (FAILED(hr = m_StaticsPtr->Oval(Height, Width, &PathPtr))) return hr;
    if (FAILED(hr = PathPtr->Transform(xf, &TransformedPathPtr))) return hr;

    return UpdatePath(TransformedPathPtr);
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CPathCtl::Rect(
    double StartX,
    double StartY,
    double Width,
    double Height)
{
    HRESULT hr;

    CComPtr<IDATransform2> translate;
    CComPtr<IDATransform2> rotate;
    CComPtr<IDATransform2> xf;
    CComPtr<IDAPath2> PathPtr;
    CComPtr<IDAPath2> TransformedPathPtr;

    if (FAILED(hr = m_StaticsPtr->Rotate2(pi, &rotate))) return hr;
    if (FAILED(hr = m_StaticsPtr->Translate2(StartX + Width / 2, StartY + Height / 2, &translate))) return hr;

    if (FAILED(hr = m_StaticsPtr->Compose2(translate, rotate, &xf))) return hr;

    if (FAILED(hr = m_StaticsPtr->Rect(Width, Height, &PathPtr))) return hr;
    if (FAILED(hr = PathPtr->Transform(xf, &TransformedPathPtr))) return hr;

    return UpdatePath(TransformedPathPtr);
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CPathCtl::Polyline(long nPoints, VARIANT Points)
{
    HRESULT hr = S_FALSE;

    CComPtr<IDAPath2> PathPtr;

    if (SUCCEEDED(hr = m_StaticsPtr->Polyline(Points, &PathPtr)))
    {
        hr = UpdatePath(PathPtr);
    }

    return hr;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CPathCtl::Polygon(long nPoints, VARIANT Points)
{
    HRESULT hr = S_FALSE;

    CComPtr<IDAPath2> PathPtr;
    CComPtr<IDAPath2> ClosedPathPtr;

    if (SUCCEEDED(hr = m_StaticsPtr->Polyline(Points, &PathPtr)) &&
        SUCCEEDED(hr = PathPtr->Close(&ClosedPathPtr)))
    {
        hr = UpdatePath(ClosedPathPtr);
    }

    return hr;
}

/*==========================================================================*/

HRESULT CPathCtl::GetPointArray(long iNumPoints, VARIANT vPoints, double **ppPoints)
{
#ifdef NEEDGETPOINTARRAY
    HRESULT hr = E_POINTER;

    if (ppPoints)
    {
        ASSERT(V_ISARRAY(&vPoints));

        SAFEARRAY *psaPoints;
                
        if (V_VT(&vPoints) & VT_BYREF)
                    psaPoints = *(vPoints.pparray);
            else
                    psaPoints = vPoints.parray;
            
            // Now we check that it's a 1D array
            if (1 != SafeArrayGetDim(psaPoints))
                    return DISP_E_TYPEMISMATCH;

            //
            // Now we make sure it's something we can use
            //

        switch (V_VT(&vPoints) & VT_TYPEMASK)
        {
            // If it's a variant, try and coerce it to something we can use
            case VT_VARIANT:
            {
                        long ix = 0;
                        VARIANTARG vaDest, vaSrc;

                        VariantInit(&vaDest);
                        VariantInit(&vaSrc);
                        // Set the type up
                        SafeArrayGetElement(psaPoints, &ix, &vaSrc);
                        if (FAILED(VariantChangeTypeEx(&vaDest, &vaSrc, LANGID_USENGLISH, 0, VT_R8)))
                                // Couldn't convert
                                return  DISP_E_TYPEMISMATCH;
            }
            break;

            case VT_I2:
            case VT_I4:
            case VT_R4:
            case VT_R8:
            {
                // We support all these types
            }
            break;

            default:
            {
                return DISP_E_TYPEMISMATCH;
            }
        }

            //
        // Do we have the correct number of elements ?
        // 

            long iLBound = 0, iUBound = 0;

            if ( FAILED(SafeArrayGetLBound(psaPoints, 1, &iLBound)) || FAILED(SafeArrayGetUBound(psaPoints, 1, &iUBound)) )
                    return E_FAIL;

            //
        // Check that we have the correct number of data points
        // (3 == number of entries in the array per data point)
        //

            if (((iUBound - iLBound) + 1) / 3 != iNumPoints)
                    return DISP_E_TYPEMISMATCH;

            //
        // Data looks OK: Allocate an array 
        // 

        *ppPoints = New double[iNumPoints * 3];

            if (NULL == *ppPoints)
                    return E_OUTOFMEMORY;

            //
        // And now (finally!) we can on with building the array
        //

        switch (V_VT(&vPoints) & VT_TYPEMASK)
        {
            // If it's a variant, try and coerce it to something we can use
            case VT_VARIANT:
            {
                        VARIANTARG vaDest;
                        VARIANT *pvaPoints = NULL;
                        int i;

                        hr = SafeArrayAccessData(psaPoints, (void **) &pvaPoints);
                        if (SUCCEEDED(hr))
                        {
                    int iNumElements = iNumPoints * 3;

                                VariantInit (&vaDest);

                                for (i = 0; i < iNumElements; i++)
                                {
                                        hr = VariantChangeTypeEx(&vaDest, &pvaPoints[i], LANGID_USENGLISH, 0, VT_R8);
                                        if (SUCCEEDED(hr))
                                                (*ppPoints)[i] = V_R8(&vaDest);
                                        else
                                                break;

                                        VariantClear(&vaDest);
                                }
                        
                                // Don't want to lose the HRESULT
                                if (SUCCEEDED(hr))
                                        hr = SafeArrayUnaccessData(psaPoints);
                                else
                                        SafeArrayUnaccessData(psaPoints);
                        }
            }
            break;

            case VT_I2:
            case VT_I4:
            {
                int i;

                        // We have to deal with VT_I2 and VT_I4 separately
                        if ((V_VT(&vPoints) & VT_TYPEMASK) == VT_I2)
                        {
                                int *piPoints2 = NULL;

                                hr = SafeArrayAccessData(psaPoints, (void **)&piPoints2);
                                if (SUCCEEDED(hr))
                                {
                                        for (i = 0; i < (iUBound - iLBound); i++)
                                                *ppPoints[i] = (double) (piPoints2[i + iLBound]);
                                }
                        }
                        else // iIntSize == 4
                        {
                                int *piPoints4 = NULL;

                                hr = SafeArrayAccessData(psaPoints, (void **)&piPoints4);
                                if (SUCCEEDED(hr))
                                {
                                        for (i = 0; i < (iUBound - iLBound); i++)
                                                *ppPoints[i] = (double) (piPoints4[i + iLBound]);
                                }
                        }

                        hr = SafeArrayUnaccessData(psaPoints);

            }
            break;

            case VT_R4:
            case VT_R8:
            {
                if ((V_VT(&vPoints) & VT_TYPEMASK) == VT_R4)
                        {
                    // floats
                                float *piPoints = NULL;

                                hr = SafeArrayAccessData(psaPoints, (void **)&piPoints);
                                if (SUCCEEDED(hr))
                                {
                                        for (int i = 0; i < (iUBound - iLBound); i++)
                                                *ppPoints[i] = (double) (piPoints[i + iLBound]);
                                }
                        }
                        else 
                        {
                    // We can optimize the VT_R8 case ...
                                double *piPoints = NULL;

                                hr = SafeArrayAccessData(psaPoints, (void **)&piPoints);
                                if (SUCCEEDED(hr))
                                {
                        CopyMemory(*ppPoints, piPoints, (iUBound - iLBound) * sizeof(double));
                                }
                        }

                        hr = SafeArrayUnaccessData(psaPoints);
            }
            break;

            default:
            {
                // We should never get here, but just in case ...
                return DISP_E_TYPEMISMATCH;
            }
        }

            if ((FAILED(hr)) && (*ppPoints))
            {
                    Delete [] *ppPoints;
            *ppPoints = NULL;
            }
            
    }
    else
    {
        hr = E_POINTER;
    }

    return hr;
#else
    return E_FAIL;
#endif // NEEDGETPOINTARRAY
}

/*==========================================================================*/

HRESULT CPathCtl::SetTimeOffset(double offset)
{
    HRESULT hr;

    if (m_OffsetPtr != NULL) {
        CComPtr<IDANumber> NumberPtr;

        if (FAILED(hr = m_StaticsPtr->DANumber(offset, &NumberPtr))) return hr;
        if (FAILED(hr = m_OffsetPtr->SwitchTo(NumberPtr))) return hr;
    }

    m_dblTimeOffset = offset;

    return S_OK;
}

/*==========================================================================*/

HRESULT CPathCtl::BuildInterpolant(IDANumber **ppInterpolant, double dblDuration)
{
    //
    // Create the path interpolant
    //

    HRESULT hr;
    
    //
    // zero = 0;
    // one = 1;
    // two = 2;
    // time = localTime;
    //

    CComPtr<IDANumber> ZeroPtr;
    if (FAILED(hr = m_StaticsPtr->DANumber(0, &ZeroPtr))) return hr;

    CComPtr<IDANumber> OnePtr;
    if (FAILED(hr = m_StaticsPtr->DANumber(1, &OnePtr))) return hr;

    CComPtr<IDANumber> TwoPtr;
    if (FAILED(hr = m_StaticsPtr->DANumber(2, &TwoPtr))) return hr;

    CComPtr<IDANumber> TimePtr;
    if (FAILED(hr = m_StaticsPtr->get_GlobalTime(&TimePtr))) return hr;

    //
    // offset
    //

    if (m_OffsetPtr == NULL) {
        CComPtr<IDANumber> NumberPtr;
        if (FAILED(hr = m_StaticsPtr->DANumber(m_dblTimeOffset, &NumberPtr))) return hr;
        if (FAILED(hr = m_StaticsPtr->ModifiableBehavior(NumberPtr, &m_OffsetPtr))) return hr;
    }

    CComQIPtr<IDANumber, &IID_IDANumber> OffsetPtr(m_OffsetPtr);

    //
    // FakeTime = localTime - Offset
    //

    CComPtr<IDANumber> FakeTimePtr;
    if (FAILED(hr = m_StaticsPtr->Sub(TimePtr, OffsetPtr, &FakeTimePtr))) return hr;

    //
    // DTime = FakeTime / duration;
    //

    CComPtr<IDANumber> DurationPtr;
    CComPtr<IDANumber> DTimePtr;

    if (FAILED(hr = m_StaticsPtr->DANumber(dblDuration, &DurationPtr))) return hr;
    if (FAILED(hr = m_StaticsPtr->Div(FakeTimePtr, DurationPtr, &DTimePtr))) return hr;

    //
    // Forward = mod(dtime, 1)
    //

    CComPtr<IDANumber> ForwardPtr;
    if (FAILED(hr = m_StaticsPtr->Mod(DTimePtr, OnePtr, &ForwardPtr))) return hr;

    //
    // Backward = 1 - Forward
    //

    CComPtr<IDANumber> BackwardPtr;
    if (FAILED(hr = m_StaticsPtr->Sub(OnePtr, ForwardPtr, &BackwardPtr))) return hr;

    //
    // if (m_enumDirection == Backward) switch forward and backward
    // lastValue = if (m_enumDirection == Forward) then 1 else 0
    //

    CComPtr<IDANumber> lastValuePtr;

    if (m_enumDirection == Forward) {
        if (m_fBounce) {
            lastValuePtr = ZeroPtr;
        } else {
            lastValuePtr = OnePtr;
        }
    } else {
        if (m_fBounce) {
            lastValuePtr = OnePtr;
        } else {
            lastValuePtr = ZeroPtr;
        }

        CComPtr<IDANumber> TempPtr = ForwardPtr;
        ForwardPtr = BackwardPtr;
        BackwardPtr = TempPtr;
    }

    //
    // Seek =
    //      if (m_fBounce) {
    //          if (mod(dtime, 2) < 1) forward else backward;
    //      } else {
    //          forward
    //      }
    //

    CComPtr<IDABehavior> SeekPtr;

    if (m_fBounce) {
        CComPtr<IDANumber>   APtr;
        CComPtr<IDABoolean>  BPtr;

        if (FAILED(hr = m_StaticsPtr->Mod(DTimePtr, TwoPtr, &APtr))) return hr;
        if (FAILED(hr = m_StaticsPtr->LT(APtr, OnePtr, &BPtr))) return hr;
        if (FAILED(hr = m_StaticsPtr->Cond(BPtr, ForwardPtr, BackwardPtr, &SeekPtr))) return hr;
    } else {
        SeekPtr = ForwardPtr;
    }

    //
    // calculate the duration
    //

    if (m_fBounce) {
        m_dblInstanceDuration = dblDuration * 2;
    } else {
        m_dblInstanceDuration = dblDuration;
    }

    switch (m_lRepeat) {
        case  0: m_dblTotalDuration = 0; break;
        case  1: m_dblTotalDuration = m_dblInstanceDuration; break;
        case -1: m_dblTotalDuration = -1; break;
        default: m_dblTotalDuration = m_dblInstanceDuration * m_lRepeat; break;
    }

    //
    // dseek = if (fakeTime >= totalduration) then 1 else seek
    //

    CComPtr<IDABehavior> DSeekPtr;

    if (m_dblTotalDuration == -1) {
        DSeekPtr = SeekPtr;
    } else {
        CComPtr<IDANumber>   TotalDurationPtr;
        CComPtr<IDABoolean>  GreaterPtr;

        if (FAILED(hr = m_StaticsPtr->DANumber(m_dblTotalDuration, &TotalDurationPtr))) return hr;
        if (FAILED(hr = m_StaticsPtr->GTE(FakeTimePtr, TotalDurationPtr, &GreaterPtr))) return hr;
        if (FAILED(hr = m_StaticsPtr->Cond(GreaterPtr, lastValuePtr, SeekPtr, &DSeekPtr))) return hr;
    }

    //
    // cast to a Number
    //

    CComQIPtr<IDANumber, &IID_IDANumber> InterpolatePtr(DSeekPtr);
    if (!InterpolatePtr) return E_FAIL;

    //
    // Fill in and addref (since we're returning)
    //

    *ppInterpolant = InterpolatePtr;
    (*ppInterpolant)->AddRef();
    
    return S_OK;
}

/*==========================================================================*/

HRESULT CPathCtl::UpdatePath(IDAPath2 *pPath)
{
    m_PathPtr = pPath;
    m_isKeyFramePath = false;
    return S_OK;
}

/*==========================================================================*/


// Update path takes either a point or a path, and uses whichever is
// non-null as the animator for the path, adding the appropriate
// interpolater on top.
HRESULT CPathCtl::CreatePath()
{
    HRESULT hr = S_OK;

    CComPtr<IDAPoint2> AnimatedPointPtr;

        if (m_isKeyFramePath) {
                ASSERT(m_keyFramePoint.p); // should be set by this point.

        CComPtr<IDANumber> NumberPtr;
        CComPtr<IDANumber> KeyInterpolatePtr;
        CComPtr<IDABehavior> SubPtr;
        CComPtr<IDANumber> InterpolatePtr;
        if (FAILED(hr = BuildInterpolant(&InterpolatePtr, m_dblKeyFrameDuration))) return hr;


        if (FAILED(hr = m_StaticsPtr->DANumber(m_dblKeyFrameDuration, &NumberPtr))) return hr;
        if (FAILED(hr = m_StaticsPtr->Mul(InterpolatePtr, NumberPtr, &KeyInterpolatePtr))) return hr;
        if (FAILED(hr = m_keyFramePoint->SubstituteTime(KeyInterpolatePtr, &SubPtr))) return hr;
        if (FAILED(hr = SubPtr->QueryInterface(IID_IDAPoint2, (void**)&AnimatedPointPtr))) return hr;
        } else {
        CComPtr<IDANumber> InterpolatePtr;
        if (FAILED(hr = BuildInterpolant(&InterpolatePtr, m_dblDuration))) return hr;

                //
                // get a transform from the path and the interpolant
                //

                CComPtr<IDATransform2> TransformPtr;
                if (FAILED(hr = m_StaticsPtr->FollowPathAnim(m_PathPtr, InterpolatePtr, &TransformPtr))) return hr;

                //
                // Get an animated point from the transform
                //

                CComPtr<IDAPoint2> PointPtr;

                if (FAILED(hr = m_StaticsPtr->get_Origin2(&PointPtr))) return hr;
                if (FAILED(hr = PointPtr->Transform(TransformPtr, &AnimatedPointPtr))) return hr;
        }

    //
    // offset the animated point by point offset
    //

    CComPtr<IDAVector2> PointOffsetPtr;
    if (FAILED(hr = m_StaticsPtr->Vector2(m_pointRelative.x, m_pointRelative.y, &PointOffsetPtr))) return hr;

    CComPtr<IDAPoint2> PreFinalPointPtr;
    if (FAILED(hr = m_StaticsPtr->AddPoint2Vector(AnimatedPointPtr, PointOffsetPtr, &PreFinalPointPtr))) return hr;

    //
    // create the final animated behavior
    //

        CComPtr<IDAPoint2> FinalPointPtr;

        if (m_bstrTarget && m_bstrLanguage) {
                if (FAILED(
                        hr = PreFinalPointPtr->AnimateControlPosition(
                                m_bstrTarget,
                                m_bstrLanguage,
                                0,
                                0.000000001,
                                &FinalPointPtr)
                        )) return hr;
        } else {
                if (FAILED(hr = m_StaticsPtr->get_Origin2(&FinalPointPtr))) return hr;
        }
    m_BehaviorPtr = FinalPointPtr;

    return hr;
}

/*==========================================================================*/

HRESULT CPathCtl::StartModel(void)
{
    HRESULT hr;

    if (!m_fStarted)
    {
        CComPtr<IDASound> SoundPtr;
        CComPtr<IDAPoint2> PointPtr;
        CComPtr<IDAImage> ImagePtr;

        if (FAILED(hr = CreatePath()))
            return hr;

        if (FAILED(hr = m_ViewPtr->put_DC(NULL)))
            return hr;

        if (FAILED(hr = m_StaticsPtr->get_Silence(&SoundPtr)))
            return hr;

        if (FAILED(hr = m_StaticsPtr->get_EmptyImage(&ImagePtr)))
            return hr;

        // If DA view already started, don't restart it, just restart
        // by switching into m_BehaviorPtr again.   This would avoid
        // the overhead of start the view on every path start.
        if (!m_fAlreadyStartedDA) {
            if (FAILED(hr =
                       m_StaticsPtr->ModifiableBehavior(m_BehaviorPtr,
                                                        &m_SwitcherPtr)))
                return hr;

            if (FAILED(hr = m_ViewPtr->AddBvrToRun(m_SwitcherPtr, &m_lBehaviorID)))
                return hr;

            if (FAILED(hr = m_ViewPtr->StartModel(ImagePtr, SoundPtr, 0)))
                return hr;

            m_fAlreadyStartedDA = TRUE;
        } else {
            m_SwitcherPtr->SwitchTo(m_BehaviorPtr);
        }

        m_fStarted = TRUE;
    }

    return S_OK;
}

/*==========================================================================*/

HRESULT CPathCtl::StopModel(void)
{
    //HRESULT hr;

    // Stop any currently running model...
    if (m_fStarted) {
        //if (FAILED(hr = m_ViewPtr->RemoveRunningBvr(m_lBehaviorID))) return hr;

        //m_BehaviorPtr = NULL;
        //m_lBehaviorID = 0;

        //if (FAILED(hr = m_ViewPtr->StopModel())) return hr;

        m_fStarted = FALSE;
    }

    return S_OK;
}

/*==========================================================================*/

DWORD CPathCtl::GetCurrTimeInMillis()
{
    return timeGetTime();
}

/*==========================================================================*/

HRESULT CPathCtl::PersistShape(IVariantIO *pvio, BOOL fLoading)
{
    HRESULT hr = S_OK;

    if (fLoading)
    {
        BSTR bstrLine = NULL;

        if (FAILED(hr = pvio->Persist(0,
            "Shape", VT_BSTR, &bstrLine,
            NULL)))
            return hr;

        if (NULL != bstrLine)
        {
            CTStr tstrLine;
            int i = 0;

#ifdef _UNICODE
            tstrLine.SetStringPointer(bstrLine);
#else
            tstrLine.SetString(bstrLine);
#endif
            LPTSTR pszLine = tstrLine.psz();

            // First move past any leading junk
            while (IsJunkChar(*pszLine))
                pszLine++;
            
            // Locate the left paren
            while ((pszLine[i]) && (pszLine[i] != TEXT('(')))
                i++;

            // There are no strings longer than 15 chars, so a 15 char buffer is allocated below.  
            // Make sure that the string is going to fit.  If not, it's obviously wrong.

            if ((pszLine[i]) && (i < 14)) 
            {
                TCHAR tchNameUpper[15];
                
                // Make a copy of the string, and uppercase it
                memcpy(tchNameUpper, pszLine, i);
                tchNameUpper[i] = TEXT('\0');
                CharUpper(tchNameUpper);
                
                int j = 0;

                // Try and locate the token
                while ((j < NUMSHAPES) && (0 != lstrcmp(g_ShapeInfoTable[j].rgchShapeName, tchNameUpper)))
                    j++;

                if (j < NUMSHAPES)
                {
                    if (SUCCEEDED(hr = ConvertStringToArray(
                        &pszLine[i+1], 
                        g_ShapeInfoTable[j].iParamsPerPoint, 
                        g_ShapeInfoTable[j].fIncludesPointCount, 
                        &m_pdblPoints, 
                        &m_iNumPoints, 
                        TRUE)))
                        m_iShapeType = j;
                
                    if ((S_OK == hr) && (!m_fDesignMode))
                    {
                        switch (j)
                        {
                            case SHAPE_OVAL:
                            {
                                hr = Oval(
                                    m_pdblPoints[0], 
                                    m_pdblPoints[1], 
                                    m_pdblPoints[2], 
                                    m_pdblPoints[3]);
                            }
                            break;

                            case SHAPE_RECT:
                            {
                                hr = Rect(
                                    m_pdblPoints[0], 
                                    m_pdblPoints[1], 
                                    m_pdblPoints[2], 
                                    m_pdblPoints[3]);
                            }
                            break;

                            case SHAPE_POLYLINE:
                            case SHAPE_POLYGON:
                            case SHAPE_SPLINE:
                            {
                                VARIANT varArray;
                                VariantInit(&varArray);

                                hr = ConstructSafeArray(
                                    m_pdblPoints, 
                                    m_iNumPoints * g_ShapeInfoTable[j].iParamsPerPoint, 
                                    VT_R8, 
                                    &varArray);
                                
                                switch (j)
                                {
                                    case SHAPE_POLYLINE:
                                    {
                                        if (SUCCEEDED(hr))
                                            hr = Polyline(m_iNumPoints, varArray);
                                    }
                                    break;

                                    case SHAPE_POLYGON:
                                    {
                                        if (SUCCEEDED(hr))
                                            hr = Polygon(m_iNumPoints, varArray);
                                    }
                                    break;


                                    case SHAPE_SPLINE:
                                    {
                                        if (SUCCEEDED(hr))
                                            hr = Spline(m_iNumPoints, varArray);

                                    }
                                    break;
                                }

                                SafeArrayDestroy(varArray.parray);

                            }
                            break;

                            case SHAPE_POLYSPLINETIME:
                            {
                                VARIANT varPtArray, varTimeArray;
                                int iTimeOffset = m_iNumPoints * 2;

                                VariantInit(&varPtArray);
                                VariantInit(&varTimeArray);

                                hr = ConstructSafeArray(
                                    m_pdblPoints, 
                                    iTimeOffset, 
                                    VT_R8, 
                                    &varPtArray);

                                if (SUCCEEDED(hr))
                                    hr = ConstructSafeArray(
                                    &m_pdblPoints[iTimeOffset], 
                                    m_iNumPoints, 
                                    VT_R8, 
                                    &varTimeArray);

                                if (SUCCEEDED(hr))
                                    hr = KeyFrame(m_iNumPoints,
                                                                                                  varPtArray,
                                                                                                  varTimeArray);

                                if (NULL != varPtArray.parray)
                                    SafeArrayDestroy(varPtArray.parray);

                                if (NULL != varTimeArray.parray)
                                    SafeArrayDestroy(varTimeArray.parray);

                            }
                            break;
                        }

                    }
                }
                else
                {
                    // Couldn't convert the string correctly
                    DEBUGLOG(TEXT("CPathCtl::PersistShape - bad Shape parameter specified"));
                    if (!m_fDesignMode)
                        hr = E_FAIL;
                }
            }
            else
            {
                // User specified a bad string
                DEBUGLOG(TEXT("CPathCtl::PersistShape - bad Shape parameter specified"));
                hr = E_FAIL;
            }

#ifdef _UNICODE
            tstrLine.SetStringPointer(NULL, FALSE);
#endif
        }
        SysFreeString(bstrLine);
    }
    else
    {
        if (NULL != m_pdblPoints)
        {
            int iNumElements = 0;

            // Compute the number of elements
            if (g_ShapeInfoTable[m_iShapeType].fIncludesPointCount)
            {
                iNumElements = m_iNumPoints * g_ShapeInfoTable[m_iShapeType].iParamsPerPoint;
            }
            else
            {
                iNumElements = m_iNumPoints;

                ASSERT(iNumElements == g_ShapeInfoTable[m_iShapeType].iParamsPerPoint);
            }

            int cchBufferSize = lstrlen(g_ShapeInfoTable[m_iShapeType].rgchShapeName) + // Length of the shape name
                                1 +  // beginning Parens
                                1 +  // Comma
                                11 + // lstrlen(MAXINT)
                                (iNumElements * (CHARSPERNUMBER + 1)) + // CHARSPERNUMBER chars per point, plus a comma
                                1 + // Closing Parens
                                1  // Null terminator(paranoia)
                                ;

            CTStr tstrLine(cchBufferSize); // Allocate a buffer
            LPTSTR pszLine = tstrLine.psz(); // Get a pointer to the buffer
            
            if (NULL != pszLine)
            {

                // Point to the end of the buffer
                LPTSTR pchLineMac = pszLine + cchBufferSize;
        
                if (g_ShapeInfoTable[m_iShapeType].fIncludesPointCount)
                {
                    wsprintf(pszLine, TEXT("%s(%lu,"), g_ShapeInfoTable[m_iShapeType].rgchShapeName, m_iNumPoints);
                }
                else
                {
                    wsprintf(pszLine, TEXT("%s("), g_ShapeInfoTable[m_iShapeType].rgchShapeName);
                }

                TCHAR rgtchPoint[CHARSPERNUMBER];
                int cchPointLength = 0;

                pszLine += lstrlen(pszLine);

                // Concatenate all the points
                for (int i = 0; i < iNumElements; i++)
                {
                    // Concatenate a comma if necessary
                    if (i > 0)
                    {
                        CStringWrapper::Strcpy(pszLine, TEXT(","));
                        pszLine++;  
                    }

                    // We are using the DA Pixel library, so there is no point in saving
                    // any fractional data.  Truncation is appropriate.
                    wsprintf(rgtchPoint, TEXT("%li"), (int)m_pdblPoints[i]);
                
                    cchPointLength = lstrlen(rgtchPoint);

                    // Make sure we don't overflow the buffer
                    if ((pszLine + cchPointLength + 1) >= pchLineMac)
                    {
                        // We are about to overflow our buffer - don't !
                        ASSERT(0); 
                        hr = E_FAIL;
                        break;
                    }
                
                    // Concatenate the point
                    CStringWrapper::Strcpy(pszLine, rgtchPoint);

                    // Move the pointer along
                    pszLine += cchPointLength;

                }

                if (SUCCEEDED(hr))
                {
                    // Now add the closing bracket if it's safe.  Look both ways before crossing.
                    if (pszLine < (pchLineMac - 2)) // 1 for paren, 1 for NULL
                    {
                        CStringWrapper::Strcpy(pszLine, TEXT(")"));

                        BSTR bstrLine = tstrLine.SysAllocString();

                        hr = pvio->Persist(0,
                            "Shape", VT_BSTR, &bstrLine,
                            NULL);

                        SysFreeString(bstrLine);
                    }
                    else
                    {
                        hr = E_FAIL;
                    }
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    return hr;
}

/*==========================================================================*/

HRESULT CPathCtl::ConstructSafeArray(double *pPoints, UINT iNumPoints, VARTYPE vtDest, VARIANT *pvarDest)
{
    HRESULT hr = S_OK;
    double *pArray = NULL;
    int iBytesPerElement = 0;

    ASSERT(pvarDest != NULL);
    HANDLENULLPOINTER(pvarDest);

    SAFEARRAY *psa = NULL;

    switch (vtDest)
    {
        case VT_I2:
        {
            iBytesPerElement = sizeof(short);
        }
        break;

        case VT_I4:
        {
            iBytesPerElement = sizeof(long);
        }
        break;

        case VT_R4:
        {
            iBytesPerElement = sizeof(float);
        }
        break;

        case VT_R8:
        {
            iBytesPerElement = sizeof(double);
        }
        break;
    }

    if (iBytesPerElement == 0)
        return E_FAIL;

    psa = SafeArrayCreateVector(vtDest, 0, iNumPoints);

    if (NULL == psa)
        return E_OUTOFMEMORY;

    if (FAILED(hr = SafeArrayAccessData(psa, (LPVOID *)&pArray)))
        return hr;

    // memcpy will be faster than iterating

    memcpy(pArray, pPoints, iNumPoints * iBytesPerElement);

    hr = SafeArrayUnaccessData(psa);

    // Our variant is going to be an array of VT_R8s
    pvarDest->vt = VT_ARRAY | vtDest;
    pvarDest->parray = psa;

    return hr;
}

/*==========================================================================*/

HRESULT CPathCtl::ConvertStringToArray(LPTSTR pszLine, UINT iValuesPerPoint, BOOL fExpectPointCount, double **ppPoints, UINT *piNumPoints, BOOL fNeedPointCount)
{
    HRESULT hr = S_OK;
    UINT iNumPoints = 0;

    if ((NULL == ppPoints) || (NULL == pszLine) || (NULL == piNumPoints))
        return E_POINTER;

    *ppPoints = NULL;

    // fNeedPointCount means that the string is preceded with the point count, and
    // *piNumPoints should be set
    if (fNeedPointCount)
        *piNumPoints = 0;
    else
        iNumPoints = *piNumPoints;

    // Truncate the string to remove the trailing paren if necessary
    if (pszLine[lstrlen(pszLine) - 1] == TEXT(')'))
        pszLine[lstrlen(pszLine) - 1] = TEXT('\0');

    // Give the parser the string starting from the 2nd char if necessary, 
    // to eliminate the leading paren
    if (pszLine[0] == TEXT('('))
        pszLine++;
    
    // Create and initialise the string parser.  Copy is required, to compact
    CLineParser parser(pszLine);
    parser.SetCharDelimiter(TEXT(','));

    if (!parser.IsValid())
        return E_OUTOFMEMORY;
    
    if (fNeedPointCount)
    {
        // Get the number of points from the string if necessary
        if (fExpectPointCount)
        {
            if (FAILED(hr = parser.GetFieldUInt(&iNumPoints)))
                return hr;

            *piNumPoints = iNumPoints;
        }
        else
        {
            // If no point count is included in the string, expect iValuesPerPoint entries
            *piNumPoints = iValuesPerPoint;
            iNumPoints = iValuesPerPoint;
        }
    }

    // Allocate the array 
    if (fExpectPointCount)
        *ppPoints = New double[iNumPoints * iValuesPerPoint];
    else
        *ppPoints = New double[iNumPoints];

    if (NULL == *ppPoints)
        return E_OUTOFMEMORY;

    double dblValue = 0.0f; 
    UINT i = 0, iNumElements = iNumPoints * (fExpectPointCount ? iValuesPerPoint : 1);

    while (SUCCEEDED(hr) && (i < iNumElements))
    {
        // Get the data
        hr = parser.GetFieldDouble(&(*ppPoints)[i]);
        i++;
    }

#ifdef _DEBUG
    if (S_OK == hr)
        DEBUGLOG(TEXT("CPathCtl::ConvertStringToArray - incorrect number of points in array\n"));
#endif

    // Unless we got the exact number of points specified, fail and delete the array
    if ( (i < iNumElements) || (S_FALSE != hr) )
    {
        Delete [] *ppPoints;
        *ppPoints = NULL;
        *piNumPoints = 0;

        // Means there was more data available.  Not good.
        if (S_OK == hr)
            hr = E_FAIL;
    }
    else
    {
        // If we don't do this, hr == S_FALSE
        hr = S_OK;
    }

    return hr;
}


/*==========================================================================*/

void CPathCtl::OnTimer(DWORD dwTime)
{
    VARIANT_BOOL vBool;

        m_dblCurrentTick = dwTime / 1000.0;

    double time = m_dblCurrentTick - m_dblBaseTime;
    double tickTime = m_dblCurrentTick - m_dblTickBaseTime;

    HRESULT hr = m_ViewPtr->Tick(tickTime, &vBool);
    ASSERT(SUCCEEDED(hr));

    if (m_fOnWindowLoadFired) {
        FireMarkersBetween(
            m_pconpt,
            m_ptmFirst,
            FirePathMarker,
            m_dblPreviousTime,
            m_dblTotalDuration != -1 && time > m_dblTotalDuration ?
                m_dblTotalDuration : time,
            m_dblInstanceDuration,
            true
        );
    }

    m_dblPreviousTime = time;

    if (m_dblTotalDuration != -1 && time >= m_dblTotalDuration) {
        Stop();
    }
}

/*==========================================================================*/

#ifdef SUPPORTONLOAD
void 
CPathCtl::OnWindowLoad (void) 
{
    m_fOnWindowLoadFired = TRUE;
        if (m_fAutoStart)
        {
                Play();
        }
}

/*==========================================================================*/

void 
CPathCtl::OnWindowUnload (void) 
{
    m_fOnWindowLoadFired = FALSE;
        StopModel();
}

/*==========================================================================*/

#endif //SUPPORTONLOAD

/*==========================================================================*/

HRESULT CPathCtl::GetOffsetPoint(IHTMLElement* pelem, POINT& point)
{
    if(FAILED(pelem->get_offsetLeft(&(point.x)))) return(E_FAIL);
    if(FAILED(pelem->get_offsetTop(&(point.y)))) return(E_FAIL);
    return S_OK;

    /*
    IHTMLElement* pelemNext;
    HRESULT hr = pelem->get_offsetParent(&pelemNext);

    while (SUCCEEDED(hr) && pelemNext) {
        pelem = pelemNext;

        POINT pnt;
        if(FAILED(pelem->get_offsetLeft(&(pnt.x)))) return(E_FAIL);
        if(FAILED(pelem->get_offsetTop(&(pnt.y)))) return(E_FAIL);
        point.x += pnt.x;
        point.y += pnt.y;

        hr = pelem->get_offsetParent(&pelemNext);
        SafeRelease((IUnknown**)&pelem);
    }

    return hr;
    */
}

/*==========================================================================*/

HRESULT CPathCtl::HTMLElementFromName(BSTR bstrElementName, IHTMLElement** ppElement)
{
    HRESULT hr;
    IHTMLElementCollection* pihtmlElementCollection = NULL;
    IHTMLElement*           pihtmlElement = NULL;
    IHTMLDocument2*         pHTMLDoc = NULL;
    IOleContainer*          pContainer = NULL;
    VARIANT    varName;
    VARIANT    varEmpty;
    IDispatch* pidispElement = NULL;

    HANDLENULLPOINTER(ppElement);
    *ppElement = NULL;
    
    ASSERT(m_pocs != NULL);

    // Can't do anything without a client site - fail gracefully (BUG 11315)
    if (NULL == m_pocs)
        return E_FAIL; 

    if (FAILED(hr = m_pocs->GetContainer(&pContainer)))
        return hr;

    // Get the HTML doc.
    hr = pContainer->QueryInterface(IID_IHTMLDocument2, (LPVOID*)&pHTMLDoc);
    SafeRelease((IUnknown**)&pContainer);
    
    if (FAILED(hr))
    {
        return hr;
    }
    
    // Get the element collection
    hr = pHTMLDoc->get_all(&pihtmlElementCollection);
    SafeRelease((IUnknown**)&pHTMLDoc);

    if (FAILED(hr)) 
    {
        // Couldn't get the collection - this shouldn't happen

        ASSERT(FALSE);
        return E_FAIL;
    }

    ASSERT(pihtmlElementCollection);

    VariantInit(&varName);
    varName.vt = VT_BSTR;
    varName.bstrVal = bstrElementName;

    VariantInit(&varEmpty);
    
    // Now get the item with the name we specified
    if (SUCCEEDED(hr = pihtmlElementCollection->item(varName, varEmpty, &pidispElement)) && (NULL != pidispElement))
    {
        if (SUCCEEDED(hr = pidispElement->QueryInterface(IID_IHTMLElement, (LPVOID *)&pihtmlElement)))
        {
            hr = S_OK;
            *ppElement = pihtmlElement;
        }
        SafeRelease((IUnknown**)&pidispElement);
    }
    else if (SUCCEEDED(hr))
    {
        hr = E_FAIL;
    }


    SafeRelease((IUnknown**)&pihtmlElementCollection);

    return hr;
}

/*==========================================================================*/

HRESULT CPathCtl::GetPoint(POINT& point)
{
    IHTMLElement* pihtmlElement = NULL;
    HRESULT hr = S_OK;
    
    if (SUCCEEDED(hr = HTMLElementFromName(m_bstrTarget, &pihtmlElement)))
    {
        hr = GetOffsetPoint(pihtmlElement, point);
        SafeRelease((IUnknown**)&pihtmlElement);
    }

    return hr;
}

/*==========================================================================*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\sgrfx\purevirt.cpp ===
// purevirt.c
//
// Avoids use of C runtime.
//

#include "..\ihbase\precomp.h"

extern "C" int __cdecl _purecall(void)
{
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\sgrfx\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//
#define IDS_STRING1                     1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\path\pathinit.h ===
/*++

Module: 
	pathinit.h

Author: 
	IHammer Team (SimonB)

Created: 
	May 1997

Description:
	Header for control-specific initialisation

History:
	05-24-1997	Created (SimonB)

++*/
#include "..\mmctl\inc\ochelp.h" // for ControlInfo

#ifndef __PATHINIT_H__
#define __PATHINIT_H__

void InitPathControlInfo(HINSTANCE hInst, ControlInfo *pCtlInfo, AllocOCProc pAlloc);

#endif // __PATHINIT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\sgrfx\dll.cpp ===
// dll.cpp
//
// DLL entry points etc.
//


#ifdef _DEBUG
    #pragma message("_DEBUG is defined")
#else
    #pragma message("_DEBUG isn't defined")
#endif

#ifdef _DESIGN
    #pragma message("_DESIGN is defined")
#else
    #pragma message("_DESIGN isn't defined")
#endif

#include "..\ihbase\precomp.h"

#include <initguid.h> // once per build
#include <olectl.h>
#include <daxpress.h>
#include "..\mmctl\inc\ochelp.h"
#include "..\mmctl\inc\mmctlg.h"
#include "..\ihbase\debug.h"
#include "sgrfx.h"
#include "sginit.h"


//////////////////////////////////////////////////////////////////////////////
// globals
//

// general globals
HINSTANCE       g_hinst;        // DLL instance handle
ULONG           g_cLock;        // DLL lock count
ControlInfo     g_ctlinfo;      // information about the control

//#define USELOGGING

#ifdef _DEBUG
BOOL			g_fLogDebugOutput=FALSE; // Controls logging of debug info
#endif

extern "C" DWORD _fltused = (DWORD)(-1);

//////////////////////////////////////////////////////////////////////////////
// DLL Initialization
//

// TODO: Modify the data in this function appropriately


//////////////////////////////////////////////////////////////////////////////
// Standard DLL Entry Points
//

BOOL WINAPI _DllMainCRTStartup(HINSTANCE hInst, DWORD dwReason,LPVOID lpreserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        TRACE("Sgrfx DLL loaded\n"); //TODO: Modify me
        g_hinst = hInst;
#ifdef _DEBUG
#ifdef USELOGGING
		g_fLogDebugOutput = TRUE;
#else
		g_fLogDebugOutput = FALSE;
#endif // USELOGGING
#endif // _DEBUG

        InitSGrfxControlInfo(hInst, &g_ctlinfo, AllocSGControl);
    }
    else
    if (dwReason == DLL_PROCESS_DETACH)
    {
        TRACE("Sgrfx DLL unloaded\n"); //TODO: Modify me
    }

    return TRUE;
}


STDAPI DllRegisterServer(void)
{
    return RegisterControls(&g_ctlinfo, RC_REGISTER);
}


STDAPI DllUnregisterServer(void)
{
	return RegisterControls(&g_ctlinfo, RC_UNREGISTER);
}


STDAPI DllCanUnloadNow()
{
    return ((g_cLock == 0) ? S_OK : S_FALSE);
}

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppv)
{
    return HelpGetClassObject(rclsid, riid, ppv, &g_ctlinfo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\sgrfx\parser.h ===
/*==========================================================================*\

Module:
    parser.h

Author:
    IHammer Team (MByrd)

Created:
    November 1996

Description:
    CParser Class Definition

History:
    11-07-1996  Created

\*==========================================================================*/

#ifndef __PARSER_H__
#define __PARSER_H__

#include "ihammer.h"
#include "drg.h"
#include "strwrap.h"
#include "grobj.h"

/*==========================================================================*/

// This should be consistent with MAX_STRING_LENGTH defined in grobj.h
#define MAX_PARAM_LENGTH 65536L
#define MAX_PARSE_NAME       32
#define SRC_BUFFER_SIZE     512

#define START_PARAM  _T('(')
#define END_PARAM    _T(')')
#define PARAM_SEP    _T(',')
#define START_STRING _T('\'')
#define END_STRING   _T('\'')
#define LITERAL      _T('\\')

/*==========================================================================*/

typedef CGraphicObject *(* CREATEGRAPHICPROC)(BOOL fFilled);

/*==========================================================================*/

class CParser
{
private:
    typedef struct PARSERLOOKUP_tag
    {
        TCHAR             rgtchName[MAX_PARSE_NAME];
        WORD              wObjectType;
        BOOL              fFilled;
        CREATEGRAPHICPROC pCreateGraphicProc;
    } PARSERLOOKUP;

protected:
    CDrg m_cdrgObjectInfo;
    IVariantIO *m_pvio;
    HFILE m_hfileSource;
	LPTSTR m_pszParam;
    int m_iParamLineIndex;
    int m_iParamIndex;
    int m_iCurrentParamIndex;
    LPTSTR m_lptstrCurrentParam;

private:
    static CGraphicObject * CreateArc(BOOL fFilled);
    static CGraphicObject * CreateOval(BOOL fFilled);
    static CGraphicObject * CreatePolygon(BOOL fFilled);
    static CGraphicObject * CreatePolyBez(BOOL fFilled);
    static CGraphicObject * CreateRect(BOOL fFilled);
    static CGraphicObject * CreateRoundRect(BOOL fFilled);
    static CGraphicObject * CreateString(BOOL fFilled);
    static CGraphicObject * CreateFillColor(BOOL fFilled);
    static CGraphicObject * CreateFillStyle(BOOL fFilled);
    static CGraphicObject * CreateGradientFill(BOOL fFilled);
    static CGraphicObject * CreateGradientShape(BOOL fFilled);
    static CGraphicObject * CreateLineColor(BOOL fFilled);
    static CGraphicObject * CreateLineStyle(BOOL fFilled);
    static CGraphicObject * CreateHatchFill(BOOL fFilled);
    static CGraphicObject * CreateFont(BOOL fFilled);
    static CGraphicObject * CreateTextureFill(BOOL fFilled);

    static PARSERLOOKUP s_parserlookupTable[];

    CGraphicObject *InstantiateObject(LPTSTR lptstrParam);
    BOOL ReadSourceLine(LPTSTR lptstrParam);
    BOOL WriteSourceLine(LPTSTR lptstrParam);

    void AppendCharToParam(TCHAR ch)
    {
        TCHAR rgtchTemp[4];

        rgtchTemp[0] = ch;
        rgtchTemp[1] = 0;
        rgtchTemp[2] = 0;

		CStringWrapper::Strcat(m_pszParam, rgtchTemp);
    }

public:
    //
    // Constructor and destructor
    //
    CParser();
    ~CParser();

    void Cleanup();

	HRESULT AddPrimitive(LPTSTR pszLine);
    HRESULT LoadObjectInfo(IVariantIO *pvio, BSTR bstrSourceURL, 
                           IUnknown * punkContainer = NULL, BOOL fCleanFirst = TRUE );

    BOOL AnimatesOverTime(void);

    BOOL InsertObject(CGraphicObject *pGraphicObject);

    HRESULT SaveObjectInfo(IVariantIO *pvio);
    HRESULT PlaybackObjectInfo(IDADrawingSurface *pIDADrawingSurface, IDAStatics *pIDAStatics, BOOL fFlipCoord);

    BOOL GetParam(int iParamIndex, LPTSTR *lplptstrParam);
    BOOL GetIntegerParam(int iParamIndex, int *piValue);
    BOOL GetLongParam(int iParamIndex, long *plValue) { return GetIntegerParam(iParamIndex, (int *)plValue); }
    BOOL GetByteParam(int iParamIndex, BYTE *pbValue)
    {
        BOOL fResult = FALSE;
        int iValue = 0;

        fResult = GetIntegerParam(iParamIndex, &iValue);

        if (fResult)
        {
            *pbValue = (BYTE)iValue;
        }

        return fResult;
    }

    BOOL GetFloatParam(int iParamIndex, float *pfValue);
    BOOL GetStringParam(int iParamIndex, LPTSTR lptstrValue);

    BOOL PutIntegerParam(int iValue);
    BOOL PutLongParam(long lValue) { return PutIntegerParam((int)lValue); }
    BOOL PutByteParam(BYTE bValue) { return PutIntegerParam((int)bValue); }
    BOOL PutFloatParam(float fValue);
    BOOL PutStringParam(LPTSTR lptstrValue);
};


#endif // __PARSER_H__

/*==========================================================================*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\sgrfx\sginit.h ===
/*++

Module: 
	sginit.h

Author: 
	IHammer Team (SimonB)

Created: 
	May 1997

Description:
	Header for control-specific initialisation

History:
	05-28-1997	Created (SimonB)

++*/
#include "..\mmctl\inc\ochelp.h" // for ControlInfo

#ifndef __SGINIT_H__
#define __SGINIT_H__

void InitSGrfxControlInfo(HINSTANCE hInst, ControlInfo *pCtlInfo, AllocOCProc pAlloc);

#endif // __SGINIT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\sgrfx\sginit.cpp ===
/*++

Module: 
	sginit.cpp

Author: 
	IHammer Team (SimonB)

Created: 
	May 1997

Description:
	Performs control-specific initialisation

History:
	05-28-1997	Created (SimonB)

++*/

#include "..\ihbase\ihbase.h"
#include "..\mmctl\inc\ochelp.h" // for ControlInfo
#include "sginit.h"
#include "..\resource.h"
#include <daxpress.h>

extern ULONG g_cLock;


void InitSGrfxControlInfo(HINSTANCE hInst, ControlInfo *pCtlInfo, AllocOCProc pAlloc)
{
    // for some reason I can't statically initalize <g_ctlinfo>, so do it here
    memset(pCtlInfo, 0, sizeof(ControlInfo));
    pCtlInfo->cbSize = sizeof(ControlInfo);
    pCtlInfo->tszProgID = TEXT("DirectAnimation.StructuredGraphicsControl");
    pCtlInfo->tszFriendlyName = TEXT("Microsoft DirectAnimation Structured Graphics");
    pCtlInfo->pclsid = &CLSID_StructuredGraphicsControl;
    pCtlInfo->hmodDLL = hInst;
    pCtlInfo->tszVersion = TEXT("1.0");
    pCtlInfo->iToolboxBitmapID = IDB_ICON_SGRFX;
    pCtlInfo->dwMiscStatusContent = CTL_OLEMISC;
    pCtlInfo->pallococ = pAlloc;
    pCtlInfo->pcLock = &g_cLock;
    pCtlInfo->dwFlags = CI_CONTROL | CI_SAFEFORSCRIPTING | 
                        CI_SAFEFORINITIALIZING | CI_MMCONTROL;

    pCtlInfo->pguidTypeLib = &LIBID_DAExpressLib; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\sgrfx\sgevent.h ===
/*++

Module: 
	sgevent.h

Author: 
	IHammer Team (SimonB)

Created: 
	May 1997

Description:
	Macros to make firing events easier and safer.  Each macro can be customised for 
	the particular event.  However, the general form should be:

	#define FIRE_EVENTNAME(pConnectionPoint, param1, param2) \
		pConnectionPoint->FireEvent(DISPID_SG_EVENT_EVENTNAME, \
			<VT for param1>, param1, \
			<VT for param2>, param2, \
			0) 
	
	NOTE: The terminating 0 is extremly important !!!

History:
	05-28-1997	Created (SimonB)

++*/

#include <dispids.h>

#ifndef __SGEVENT_H__
#define __SGEVENT_H__

// Shift/Ctrl/Alt, and mouse button states for events
#define KEYSTATE_SHIFT  1
#define KEYSTATE_CTRL   2
#define KEYSTATE_ALT    4

#define MOUSEBUTTON_LEFT     1
#define MOUSEBUTTON_RIGHT    2
#define MOUSEBUTTON_MIDDLE   4

// Event firing macros

#define FIRE_MOUSEMOVE(pConnectionPoint, BUTTON, SHIFT, X, Y) \
    if (m_fOnWindowLoadFired) \
	    pConnectionPoint->FireEvent(DISPID_SG_EVENT_MOUSEMOVE, \
	    	VT_I4, BUTTON, \
	    	VT_I4, SHIFT, \
	    	VT_I4, X, \
	    	VT_I4, Y, \
	    	0)

#define FIRE_MOUSEDOWN(pConnectionPoint, BUTTON, SHIFT, X, Y) \
    if (m_fOnWindowLoadFired) \
	    pConnectionPoint->FireEvent(DISPID_SG_EVENT_MOUSEDOWN, \
	    	VT_I4, BUTTON, \
	    	VT_I4, SHIFT, \
	    	VT_I4, X, \
	    	VT_I4, Y, \
	    	0)

#define FIRE_MOUSEUP(pConnectionPoint, BUTTON, SHIFT, X, Y) \
    if (m_fOnWindowLoadFired) \
	    pConnectionPoint->FireEvent(DISPID_SG_EVENT_MOUSEUP, \
	    	VT_I4, BUTTON, \
	    	VT_I4, SHIFT, \
	    	VT_I4, X, \
	    	VT_I4, Y, \
	    	0)

#define FIRE_DBLCLICK(pConnectionPoint) \
    if (m_fOnWindowLoadFired) \
	    pConnectionPoint->FireEvent(DISPID_SG_EVENT_DBLCLICK, 0)


#define FIRE_CLICK(pConnectionPoint) \
    if (m_fOnWindowLoadFired) \
	    pConnectionPoint->FireEvent(DISPID_SG_EVENT_CLICK, 0)

#endif // __SGEVENT_H__

// End of file sgevent.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\sgrfx\grobj.cpp ===
/*==========================================================================*\

Module:
    grobj.cpp

Author:
    IHammer Team (MByrd)

Created:
    November 1996

Description:
    CGraphicObject derived Class Implementations

History:
    11-07-1996  Created

\*==========================================================================*/

#include "..\ihbase\precomp.h"
#include "..\ihbase\debug.h"
#include "..\ihbase\utils.h"
#include "utils.h"
#include "strwrap.h"
#include "sgrfx.h"
#include "parser.h"

/*==========================================================================*/

static BOOL SetColor(int iR, int iG, int iB, COLORREF *clrrefColor)
{
    if ((iR >= 0 && iR <= 255) &&
        (iG >= 0 && iG <= 255) &&
        (iB >= 0 && iB <= 255))
    {
        *clrrefColor = RGB(iR, iG, iB);
        return TRUE;
    }
	else
	{
		return FALSE;
	}
}

/*==========================================================================*/

static double FlipY(BOOL fFlipCoord, double dblYIn)
{
    double dblResult = dblYIn;

    // Due to changes in the handed-ness of the DAnim pixel mode
    // coordinate system (bug 8349), we reverse the polarity of the
    // test here to make everything work out right.
    if (!fFlipCoord)
        dblResult *= -1.0;

    return dblResult;
}

/*==========================================================================*/

static double PixelsToPoints(int iPixels, IDAStatics *pIDAStatics)
{
    double dblResult = (double)iPixels;

    if (pIDAStatics)
    {
        CComPtr<IDANumber> PixelPtr;
        double dblPixel = 0.0;

        //
        // NOTE : The Pixel behavior is currently constant!
        // This will break if this changes! (REVIEW : MBYRD,KGALLO)
        //

        if (SUCCEEDED(pIDAStatics->get_Pixel(&PixelPtr)) &&
            SUCCEEDED(PixelPtr->Extract(&dblPixel)))
        {
            double dblFactor = (72.0 * 39.370);

            dblResult = (dblPixel * dblFactor) * dblResult;
        }
    }

    return dblResult;
}

/*==========================================================================*/

static BOOL CreateDAColor(COLORREF clrrefColor, IDAStatics *pIDAStatics, IDAColor **ppColor)
{
    BOOL fResult = FALSE;

    if (ppColor && pIDAStatics)
    {
        fResult = SUCCEEDED(pIDAStatics->ColorRgb255(
            GetRValue(clrrefColor),
            GetGValue(clrrefColor),
            GetBValue(clrrefColor),
            ppColor));
    }

    return fResult;
}

/*==========================================================================*\
    CGraphicObject Class Implementation:
\*==========================================================================*/

CGraphicObject::CGraphicObject()
{
    m_iXPosition = 0;
    m_iYPosition = 0;
    m_iCenterX = 0;
    m_iCenterY = 0;
    m_fltRotation = 0.0f;
}

/*==========================================================================*/

CGraphicObject::~CGraphicObject()
{
}

/*==========================================================================*/

BOOL CGraphicObject::WriteData(int iSizeData, LPVOID lpvData)
{
    return FALSE;
}

/*==========================================================================*/

BOOL CGraphicObject::ReadData(int iSizeData, LPVOID lpvData)
{
    return FALSE;
}

/*==========================================================================*/

BOOL CGraphicObject::ApplyRotation(IDADrawingSurface *pIDADrawingSurface, IDAStatics *pIDAStatics, BOOL fFlipCoord)
{
    BOOL fResult = TRUE;

    if (m_fltRotation != 0.0)
    {
        CComPtr<IDATransform2> RotateTransformPtr;
        CComPtr<IDATransform2> TranslateTransformPtr;
        CComPtr<IDATransform2> InvTranslateTransformPtr;
        double dblRotation = (double)m_fltRotation;

        if (fFlipCoord)
            dblRotation *= -1.0;

        if (SUCCEEDED(pIDAStatics->Rotate2Degrees(dblRotation, &RotateTransformPtr)) &&
            SUCCEEDED(pIDAStatics->Translate2(m_iCenterX, FlipY(fFlipCoord, m_iCenterY), &TranslateTransformPtr)) &&
            SUCCEEDED(pIDAStatics->Translate2(-m_iCenterX, -FlipY(fFlipCoord, m_iCenterY), &InvTranslateTransformPtr)) &&
            SUCCEEDED(pIDADrawingSurface->SaveGraphicsState()) &&
            SUCCEEDED(pIDADrawingSurface->Transform(TranslateTransformPtr)) &&
            SUCCEEDED(pIDADrawingSurface->Transform(RotateTransformPtr)) &&
            SUCCEEDED(pIDADrawingSurface->Transform(InvTranslateTransformPtr)))
        {
            fResult = TRUE;
        }
        else
        {
            fResult = FALSE;
        }
    }

    return fResult;
}

/*==========================================================================*/

BOOL CGraphicObject::RemoveRotation(IDADrawingSurface *pIDADrawingSurface, IDAStatics *pIDAStatics)
{
    BOOL fResult = TRUE;

    if (m_fltRotation != 0.0)
        fResult = SUCCEEDED(pIDADrawingSurface->RestoreGraphicsState());

    return fResult;
}

/*==========================================================================*\
    CGraphicArc Class Implementation:
\*==========================================================================*/

CGraphicArc::CGraphicArc(BOOL fFilled)
    : CGraphicObject()
{
    m_iWidth = 0;
    m_iHeight = 0;
    m_fStartAngle = 0.0f;
    m_fArcAngle = 0.0f;
    m_fFilled = fFilled;
}

/*==========================================================================*/

CGraphicArc::~CGraphicArc()
{
}

/*==========================================================================*/

BOOL CGraphicArc::Execute(IDADrawingSurface *pIDADrawingSurface, IDAStatics *pIDAStatics, BOOL fFlipCoord)
{
    BOOL fResult = FALSE;

    if (pIDADrawingSurface)
    {
        fResult = ApplyRotation(pIDADrawingSurface, pIDAStatics, fFlipCoord);

        if (fResult)
        {
            if (m_fFilled)
            {
                fResult = SUCCEEDED(pIDADrawingSurface->PieDegrees(
                    (double)m_iXPosition,
                    FlipY(fFlipCoord, (double)m_iYPosition),
                    (double)m_fStartAngle,
                    (double)m_fStartAngle+m_fArcAngle,
                    (double)m_iWidth,
                    FlipY(fFlipCoord, (double)m_iHeight)));
            }
            else
            {
                fResult = SUCCEEDED(pIDADrawingSurface->ArcDegrees(
                    (double)m_iXPosition,
                    FlipY(fFlipCoord, (double)m_iYPosition),
                    (double)m_fStartAngle,
                    (double)m_fStartAngle+m_fArcAngle,
                    (double)m_iWidth,
                    FlipY(fFlipCoord, (double)m_iHeight)));
            }
        }

        if (fResult)
            RemoveRotation(pIDADrawingSurface, pIDAStatics);
    }

    return fResult;
}

/*==========================================================================*/

BOOL CGraphicArc::ValidateObject()
{
	return (m_fArcAngle != 0.0f);
}

/*==========================================================================*/

BOOL CGraphicArc::LoadObject(CParser &parser)
{
    BOOL fResult = FALSE;

    if (parser.GetIntegerParam(0, &m_iXPosition) &&
        parser.GetIntegerParam(1, &m_iYPosition) &&
        parser.GetIntegerParam(2, &m_iWidth) &&
        parser.GetIntegerParam(3, &m_iHeight) &&
        parser.GetFloatParam(4, &m_fStartAngle) &&
        parser.GetFloatParam(5, &m_fArcAngle))
    {
        fResult = ValidateObject();

        if (fResult)
        {
            m_fltRotation = 0.0f;
            parser.GetFloatParam(6, &m_fltRotation);

            m_iCenterX = m_iXPosition + m_iWidth/2;
            m_iCenterY = m_iYPosition + m_iHeight/2;
        }
	}

    return fResult;
}

/*==========================================================================*/

BOOL CGraphicArc::SaveObject(CParser &parser)
{
    BOOL fResult = FALSE;

    if (parser.PutIntegerParam(m_iXPosition) &&
        parser.PutIntegerParam(m_iYPosition) &&
        parser.PutIntegerParam(m_iWidth) &&
        parser.PutIntegerParam(m_iHeight) &&
        parser.PutFloatParam(m_fStartAngle) &&
        parser.PutFloatParam(m_fArcAngle))
    {
        fResult = TRUE;

        if (m_fltRotation != 0.0f)
            fResult = parser.PutFloatParam(m_fltRotation);
    }

    return fResult;
}

/*==========================================================================*\
    CGraphicOval Class Implementation:
\*==========================================================================*/

CGraphicOval::CGraphicOval(BOOL fFilled)
    : CGraphicObject()
{
    m_iWidth = 0;
    m_iHeight = 0;
    m_fFilled = fFilled;
}

/*==========================================================================*/

CGraphicOval::~CGraphicOval()
{
}

/*==========================================================================*/

BOOL CGraphicOval::Execute(IDADrawingSurface *pIDADrawingSurface, IDAStatics *pIDAStatics, BOOL fFlipCoord)
{
    BOOL fResult = FALSE;

    if (pIDADrawingSurface)
    {
        fResult = ApplyRotation(pIDADrawingSurface, pIDAStatics, fFlipCoord);

        if (fResult)
        {
            fResult = SUCCEEDED(pIDADrawingSurface->Oval(
                (double)m_iXPosition,
                FlipY(fFlipCoord, (double)m_iYPosition),
                (double)m_iWidth,
                FlipY(fFlipCoord, (double)m_iHeight)));
        }

        if (fResult)
            RemoveRotation(pIDADrawingSurface, pIDAStatics);
    }

    return fResult;
}

/*==========================================================================*/

BOOL CGraphicOval::LoadObject(CParser &parser)
{
    BOOL fResult = FALSE;

    if (parser.GetIntegerParam(0, &m_iXPosition) &&
        parser.GetIntegerParam(1, &m_iYPosition) &&
        parser.GetIntegerParam(2, &m_iWidth) &&
        parser.GetIntegerParam(3, &m_iHeight))
    {
        fResult = TRUE;

        m_fltRotation = 0.0f;
        parser.GetFloatParam(4, &m_fltRotation);

        m_iCenterX = m_iXPosition + m_iWidth/2;
        m_iCenterY = m_iYPosition + m_iHeight/2;
    }

    return fResult;
}

/*==========================================================================*/

BOOL CGraphicOval::SaveObject(CParser &parser)
{
    BOOL fResult = FALSE;

    if (parser.PutIntegerParam(m_iXPosition) &&
        parser.PutIntegerParam(m_iYPosition) &&
        parser.PutIntegerParam(m_iWidth) &&
        parser.PutIntegerParam(m_iHeight))
    {
        fResult = TRUE;

        if (m_fltRotation != 0.0f)
            fResult = parser.PutFloatParam(m_fltRotation);
    }

    return fResult;
}

/*==========================================================================*\
    CGraphicPolygon Class Implementation:
\*==========================================================================*/

CGraphicPolygon::CGraphicPolygon(BOOL fFilled)
    : CGraphicObject()
{
    m_fFilled = fFilled;
    m_lpPolyPoints  = (LPPOINT)NULL;
    m_iPointCount = 0;
}

/*==========================================================================*/

CGraphicPolygon::~CGraphicPolygon()
{
    if (m_lpPolyPoints)
    {
        Delete [] m_lpPolyPoints;
        m_lpPolyPoints = (LPPOINT)NULL;
        m_iPointCount = 0;
    }
}

/*==========================================================================*/

BOOL CGraphicPolygon::Execute(IDADrawingSurface *pIDADrawingSurface, IDAStatics *pIDAStatics, BOOL fFlipCoord)
{
    BOOL fResult = FALSE;

    if (pIDADrawingSurface && m_iPointCount >= 2)
    {
        SAFEARRAY * s = SafeArrayCreateVector(VT_R8, 0, m_iPointCount * 2);

        if (s)
        {
            VARIANT v;
            VariantInit(&v);
    
            V_ARRAY(&v) = s;
            v.vt = VT_ARRAY | VT_R8;

            // There is no reason to worry about locking the data
            // since we just created it.  So just grab the data
            // pointer and setup the double array
    
            double * pDbl = (double *) s->pvData;
    
            for (int i = 0;i < m_iPointCount;i++)
            {
                pDbl[i * 2]     = (double)m_lpPolyPoints[i].x;
                pDbl[i * 2 + 1] = FlipY(fFlipCoord, (double)m_lpPolyPoints[i].y);
            }
    
            fResult = ApplyRotation(pIDADrawingSurface, pIDAStatics, fFlipCoord);

            if (fResult)
            {
                if (m_fFilled)
                {
                    fResult = SUCCEEDED(pIDADrawingSurface->Polygon(v));
                }
                else
                {
                    fResult = SUCCEEDED(pIDADrawingSurface->Polyline(v));
                }
            }

            if (fResult)
                fResult = RemoveRotation(pIDADrawingSurface, pIDAStatics);

            // Perhaps we should check the return value but for now
            // just ignore it
            SafeArrayDestroy(s);
        }
    }

    return fResult;
}

/*==========================================================================*/

BOOL CGraphicPolygon::LoadObject(CParser &parser)
{
    BOOL fResult = FALSE;

    // Clear the point array...
    if (m_lpPolyPoints)
    {
        Delete [] m_lpPolyPoints;
        m_lpPolyPoints = NULL;
        m_iPointCount = 0;
    }

    if (parser.GetIntegerParam(0, &m_iPointCount) && m_iPointCount >= 2)
    {
        int iPointIndex = 0;
        int iParamIndex = 1;

        m_lpPolyPoints = New POINT [m_iPointCount];

        if (m_lpPolyPoints)
        {
            int iMinX = 32000;
            int iMaxX = -32000;
            int iMinY = 32000;
            int iMaxY = -32000;

            fResult = TRUE;

            for(iPointIndex=0;iPointIndex<m_iPointCount;iPointIndex++)
            {
                int iValue1 = 0;
                int iValue2 = 0;

                if (parser.GetIntegerParam(iParamIndex,   &iValue1) &&
                    parser.GetIntegerParam(iParamIndex+1, &iValue2))
                {
                    m_lpPolyPoints[iPointIndex].x = iValue1;
                    m_lpPolyPoints[iPointIndex].y = iValue2;

                    if (iValue1 < iMinX)
                        iMinX = iValue1;
                    if (iValue1 > iMaxX)
                        iMaxX = iValue1;
                    if (iValue2 < iMinY)
                        iMinY = iValue2;
                    if (iValue2 > iMaxY)
                        iMaxY = iValue2;
                }
                else
                {
                    fResult = FALSE;
                    break;
                }

                iParamIndex += 2;
            }

            m_iCenterX = (iMaxX + iMinX) / 2;
            m_iCenterY = (iMaxY + iMinY) / 2;
        }

        if (!fResult)
        {
            m_iPointCount = 0;

            if (m_lpPolyPoints)
            {
                Delete [] m_lpPolyPoints;
                m_lpPolyPoints = (LPPOINT)NULL;
            }
        }
        else
        {
            m_fltRotation = 0.0f;
            parser.GetFloatParam(iParamIndex, &m_fltRotation);
        }
    }

    return fResult;
}

/*==========================================================================*/

BOOL CGraphicPolygon::SaveObject(CParser &parser)
{
    BOOL fResult = FALSE;

    if (parser.PutIntegerParam(m_iPointCount))
    {
        int iPointIndex = 0;

        fResult = TRUE;

        for(iPointIndex=0;iPointIndex<m_iPointCount;iPointIndex++)
        {
            if (!parser.PutIntegerParam(m_lpPolyPoints[iPointIndex].x) ||
                !parser.PutIntegerParam(m_lpPolyPoints[iPointIndex].y))
            {
                fResult = FALSE;
                break;
            }
        }

        if (fResult && m_fltRotation != 0.0f)
            fResult = parser.PutFloatParam(m_fltRotation);
    }

    return fResult;
}

/*==========================================================================*\
    CGraphicPolyBez Class Implementation:
\*==========================================================================*/

CGraphicPolyBez::CGraphicPolyBez(BOOL fFilled)
    : CGraphicObject()
{
    m_fFilled = fFilled;

    m_iPointCount  = 0;
    m_lpPolyPoints = (LPPOLYBEZPOINT)NULL;
    m_lpPointArray = (LPPOINT)NULL;
    m_lpByteArray  = (LPBYTE)NULL;
}

/*==========================================================================*/

CGraphicPolyBez::~CGraphicPolyBez()
{
    if (m_iPointCount)
    {
        if (m_lpPolyPoints)
        {
            Delete [] m_lpPolyPoints;
            m_lpPolyPoints = (LPPOLYBEZPOINT)NULL;
        }

        if (m_lpPointArray)
        {
            Delete [] m_lpPointArray;
            m_lpPointArray = (LPPOINT)NULL;
        }

        if (m_lpByteArray)
        {
            Delete [] m_lpByteArray;
            m_lpByteArray = (LPBYTE)NULL;
        }

        m_iPointCount = 0;
    }
}

/*==========================================================================*/

BOOL CGraphicPolyBez::Execute(IDADrawingSurface *pIDADrawingSurface, IDAStatics *pIDAStatics, BOOL fFlipCoord)
{
    BOOL fResult = FALSE;

    if (pIDADrawingSurface && m_iPointCount)
    {
        SAFEARRAY * saPoints = SafeArrayCreateVector(VT_R8, 0, m_iPointCount * 2);
        SAFEARRAY * saCodes  = SafeArrayCreateVector(VT_R8, 0, m_iPointCount);

        if (saPoints && saCodes)
        {
            VARIANT varPoints;
            VARIANT varCodes;
            double *pdblPoints;
            double *pdblCodes;

            VariantInit(&varPoints);
            VariantInit(&varCodes);

            V_ARRAY(&varPoints) = saPoints;
            varPoints.vt = VT_ARRAY | VT_R8;

            V_ARRAY(&varCodes) = saCodes;
            varCodes.vt = VT_ARRAY | VT_R8;

            pdblPoints = (double *)saPoints->pvData;
            pdblCodes = (double *)saCodes->pvData;

            for(int i=0;i<m_iPointCount;i++)
            {
                pdblPoints[(i*2)  ] = (double)m_lpPointArray[i].x;
                pdblPoints[(i*2)+1] = FlipY(fFlipCoord, (double)m_lpPointArray[i].y);

                pdblCodes[i] = (double)ConvertFlags(m_lpByteArray[i]);
            }

            fResult = ApplyRotation(pIDADrawingSurface, pIDAStatics, fFlipCoord);

            if (fResult)
            {
                CComPtr<IDAPath2> PathPtr;

                fResult = SUCCEEDED(pIDAStatics->PolydrawPath(varPoints, varCodes, &PathPtr));

                if (fResult)
                {
                    if (m_fFilled)
                    {
                        fResult = SUCCEEDED(pIDADrawingSurface->FillPath(PathPtr));
                    }
                    else
                    {
                        fResult = SUCCEEDED(pIDADrawingSurface->DrawPath(PathPtr));
                    }
                }
            }

            if (fResult)
                fResult = RemoveRotation(pIDADrawingSurface, pIDAStatics);
        }

        if (saPoints)
        {
            SafeArrayDestroy(saPoints);
        }

        if (saCodes)
        {
            SafeArrayDestroy(saCodes);
        }
    }

    return fResult;
}

/*==========================================================================*/

BOOL CGraphicPolyBez::LoadObject(CParser &parser)
{
    BOOL fResult = FALSE;
	LPPOLYBEZPOINT pPolyPoints = NULL;
	int iPointCount = 0;
    int iPointIndex = 0;

    // Clear the point array...
    if (m_lpPolyPoints)
    {
        Delete [] m_lpPolyPoints;
        m_lpPolyPoints = NULL;
        m_iPointCount = 0;
    }

    if (parser.GetIntegerParam(0, &iPointCount))
    {
        int iParamIndex = 1;

        if (iPointCount >= 2)
        {
            pPolyPoints = New POLYBEZPOINT [iPointCount];

            if (pPolyPoints)
            {
                fResult = TRUE;

                for(iPointIndex = 0;iPointIndex < iPointCount;iPointIndex++)
                {
                    BYTE bValue = 0;
                    int iValue1 = 0;
                    int iValue2 = 0;

                    if (parser.GetByteParam(iParamIndex, &bValue) &&
                        parser.GetIntegerParam(iParamIndex+1, &iValue1) &&
                        parser.GetIntegerParam(iParamIndex+2, &iValue2))
                    {
                        pPolyPoints[iPointIndex].iFlags = bValue;
                        pPolyPoints[iPointIndex].iX     = iValue1;
                        pPolyPoints[iPointIndex].iY     = iValue2;
                    }
                    else
                    {
                        fResult = FALSE;
                        break;
                    }

                    iParamIndex += 3;
                }

            }
        }

        if (!fResult)
        {
            if (pPolyPoints)
            {
                Delete [] pPolyPoints;
                pPolyPoints = (LPPOLYBEZPOINT)NULL;
            }

            m_iPointCount = 0;
        }
        else
        {
            m_fltRotation = 0.0f;
            parser.GetFloatParam(iParamIndex, &m_fltRotation);
        }
    }

    // Go ahead and create the arrays for PolyDraw...
    if (fResult)
    {
	    // Cast the array of longs to an array of POLYBEZPOINTS
	    m_lpPolyPoints = (LPPOLYBEZPOINT)pPolyPoints;
	    m_iPointCount = iPointCount;

	    // Copy all the points across
        m_lpPointArray = New POINT [m_iPointCount];
        m_lpByteArray  = New BYTE [m_iPointCount];

        if (m_lpPointArray && m_lpByteArray)
        {
            int iMinX = 32000;
            int iMaxX = -32000;
            int iMinY = 32000;
            int iMaxY = -32000;

            for(iPointIndex = 0;iPointIndex < m_iPointCount; iPointIndex++)
            {
                m_lpPointArray[iPointIndex].x = m_lpPolyPoints[iPointIndex].iX;
                m_lpPointArray[iPointIndex].y = m_lpPolyPoints[iPointIndex].iY;
                m_lpByteArray[iPointIndex]    = (BYTE)m_lpPolyPoints[iPointIndex].iFlags;

                if (m_lpPointArray[iPointIndex].x < iMinX)
                    iMinX = m_lpPointArray[iPointIndex].x;
                if (m_lpPointArray[iPointIndex].x > iMaxX)
                    iMaxX = m_lpPointArray[iPointIndex].x;
                if (m_lpPointArray[iPointIndex].y < iMinY)
                    iMinY = m_lpPointArray[iPointIndex].y;
                if (m_lpPointArray[iPointIndex].y > iMaxY)
                    iMaxY = m_lpPointArray[iPointIndex].y;

            }

            m_iCenterX = (iMaxX + iMinX) / 2;
            m_iCenterY = (iMaxY + iMinY) / 2;
        }
        else
        {
            m_iPointCount = 0;

            if (m_lpPolyPoints)
            {
                Delete [] m_lpPolyPoints;
                m_lpPolyPoints = (LPPOLYBEZPOINT)NULL;
            }

            if (m_lpPointArray)
            {
                Delete [] m_lpPointArray;
                m_lpPointArray = (LPPOINT)NULL;
            }

            if (m_lpByteArray)
            {
                Delete [] m_lpByteArray;
                m_lpByteArray = (LPBYTE)NULL;
            }

            fResult = FALSE;
        }
	}

    return fResult;
}

/*==========================================================================*/

BOOL CGraphicPolyBez::SaveObject(CParser &parser)
{
    BOOL fResult = FALSE;

    if (parser.PutIntegerParam(m_iPointCount))
    {
        int iPointIndex = 0;

        fResult = TRUE;

        for(iPointIndex=0;iPointIndex<m_iPointCount;iPointIndex++)
        {
            if (!parser.PutByteParam((BYTE)(m_lpPolyPoints[iPointIndex].iFlags)) ||
                !parser.PutIntegerParam(m_lpPolyPoints[iPointIndex].iX) ||
                !parser.PutIntegerParam(m_lpPolyPoints[iPointIndex].iY))
            {
                fResult = FALSE;
                break;
            }
        }

        if (fResult && m_fltRotation != 0.0f)
            fResult = parser.PutFloatParam(m_fltRotation);
    }

    return fResult;
}

/*==========================================================================*\
    CGraphicRect Class Implementation:
\*==========================================================================*/

CGraphicRect::CGraphicRect(BOOL fFilled)
    : CGraphicObject()
{
    m_iWidth = 0;
    m_iHeight = 0;
    m_fFilled = fFilled;
}

/*==========================================================================*/

CGraphicRect::~CGraphicRect()
{
}

/*==========================================================================*/

BOOL CGraphicRect::Execute(IDADrawingSurface *pIDADrawingSurface, IDAStatics *pIDAStatics, BOOL fFlipCoord)
{
    BOOL fResult = FALSE;

    if (pIDADrawingSurface)
    {
        fResult = ApplyRotation(pIDADrawingSurface, pIDAStatics, fFlipCoord);

        if (fResult)
        {
            fResult = SUCCEEDED(pIDADrawingSurface->Rect(
                (double)m_iXPosition,
                FlipY(fFlipCoord, (double)m_iYPosition),
                (double)m_iWidth,
                FlipY(fFlipCoord, (double)m_iHeight)));
        }

        if (fResult)
        {
            fResult = RemoveRotation(pIDADrawingSurface, pIDAStatics);
        }
    }

    return fResult;
}

/*==========================================================================*/

BOOL CGraphicRect::LoadObject(CParser &parser)
{
    BOOL fResult = FALSE;

    if (parser.GetIntegerParam(0, &m_iXPosition) &&
        parser.GetIntegerParam(1, &m_iYPosition) &&
        parser.GetIntegerParam(2, &m_iWidth) &&
        parser.GetIntegerParam(3, &m_iHeight))
    {
        fResult = TRUE;

        m_fltRotation = 0.0f;
        parser.GetFloatParam(4, &m_fltRotation);

        m_iCenterX = m_iXPosition + m_iWidth / 2;
        m_iCenterY = m_iYPosition + m_iHeight / 2;
    }

    return fResult;
}

/*==========================================================================*/

BOOL CGraphicRect::SaveObject(CParser &parser)
{
    BOOL fResult = FALSE;

    if (parser.PutIntegerParam(m_iXPosition) &&
        parser.PutIntegerParam(m_iYPosition) &&
        parser.PutIntegerParam(m_iWidth) &&
        parser.PutIntegerParam(m_iHeight))
    {
        fResult = TRUE;

        if (m_fltRotation != 0.0f)
            fResult = parser.PutFloatParam(m_fltRotation);
    }

    return fResult;
}

/*==========================================================================*\
    CGraphicRoundRect Class Implementation:
\*==========================================================================*/

CGraphicRoundRect::CGraphicRoundRect(BOOL fFilled)
    : CGraphicObject()
{
    m_iWidth = 0;
    m_iHeight = 0;
    m_iArcWidth = 0;
    m_iArcHeight = 0;
    m_fFilled = fFilled;
}

/*==========================================================================*/

CGraphicRoundRect::~CGraphicRoundRect()
{
}

/*==========================================================================*/

BOOL CGraphicRoundRect::Execute(IDADrawingSurface *pIDADrawingSurface, IDAStatics *pIDAStatics, BOOL fFlipCoord)
{
    BOOL fResult = FALSE;

    if (pIDADrawingSurface)
    {
        fResult = ApplyRotation(pIDADrawingSurface, pIDAStatics, fFlipCoord);

        if (fResult)
        {
            fResult = SUCCEEDED(pIDADrawingSurface->RoundRect(
                (double)m_iXPosition,
                FlipY(fFlipCoord, (double)m_iYPosition),
                (double)m_iWidth,
                FlipY(fFlipCoord, (double)m_iHeight),
                (double)m_iArcWidth,
                (double)m_iArcHeight));
        }

        if (fResult)
            RemoveRotation(pIDADrawingSurface, pIDAStatics);
    }

    return fResult;
}

/*==========================================================================*/

BOOL CGraphicRoundRect::LoadObject(CParser &parser)
{
    BOOL fResult = FALSE;

    if (parser.GetIntegerParam(0, &m_iXPosition) &&
        parser.GetIntegerParam(1, &m_iYPosition) &&
        parser.GetIntegerParam(2, &m_iWidth) &&
        parser.GetIntegerParam(3, &m_iHeight) &&
        parser.GetIntegerParam(4, &m_iArcWidth) &&
        parser.GetIntegerParam(5, &m_iArcHeight))
    {

#if 0 // Allow The DrawingSurface to handle these cases...
        if (m_iArcWidth > 0)
        {
            if (m_iArcWidth > m_iWidth)
                m_iArcWidth = m_iWidth;
        }
        else
        {
            if (m_iArcWidth < -m_iWidth)
                m_iArcWidth = -m_iWidth;
        }

        if (m_iArcHeight > 0)
        {
            if (m_iArcHeight > m_iHeight)
                m_iArcHeight = m_iHeight;
        }
        else
        {
            if (m_iArcHeight < -m_iHeight)
                m_iArcHeight = -m_iHeight;
        }
#endif // 0

        fResult = TRUE;

        m_fltRotation = 0.0f;
        parser.GetFloatParam(6, &m_fltRotation);

        m_iCenterX = m_iXPosition + m_iWidth / 2;
        m_iCenterY = m_iYPosition + m_iHeight / 2;
    }

    return fResult;
}

/*==========================================================================*/

BOOL CGraphicRoundRect::SaveObject(CParser &parser)
{
    BOOL fResult = FALSE;

    if (parser.PutIntegerParam(m_iXPosition) &&
        parser.PutIntegerParam(m_iYPosition) &&
        parser.PutIntegerParam(m_iWidth) &&
        parser.PutIntegerParam(m_iHeight) &&
        parser.PutIntegerParam(m_iArcWidth) &&
        parser.PutIntegerParam(m_iArcHeight))
    {
        fResult = TRUE;

        if (m_fltRotation != 0.0f)
            fResult = parser.PutFloatParam(m_fltRotation);
    }

    return fResult;
}

/*==========================================================================*\
    CGraphicString Class Implementation:
\*==========================================================================*/

CGraphicString::CGraphicString()
    : CGraphicObject()
{
	m_pszString      = NULL;
    m_iPointCount    = 0;
    m_lpPointArray   = (LPPOINT)NULL;
    m_lpByteArray    = (LPBYTE)NULL;
}

/*==========================================================================*/

CGraphicString::~CGraphicString()
{
    if (m_iPointCount)
    {
        if (m_lpPointArray)
        {
            Delete [] m_lpPointArray;
            m_lpPointArray = (LPPOINT)NULL;
        }

        if (m_lpByteArray)
        {
            Delete [] m_lpByteArray;
            m_lpByteArray = (LPBYTE)NULL;
        }

        m_iPointCount = 0;
    }

	if (m_pszString)
		Delete [] m_pszString;
}

/*==========================================================================*/

BOOL CGraphicString::Execute(IDADrawingSurface *pIDADrawingSurface, IDAStatics *pIDAStatics, BOOL fFlipCoord)
{
    BOOL fResult = FALSE;

    if (pIDADrawingSurface)
    {
        WCHAR *pwchText = New WCHAR [MAX_STRING_LENGTH];

        if (pwchText)
        {
            BSTR bstrText = NULL;
#ifdef UNICODE
            CStringWrapper::Strcpy(pwchText, m_pszString);
            fResult = TRUE;
#else // !UNICODE
            CStringWrapper::Mbstowcs(pwchText, m_pszString, CStringWrapper::Strlen(m_pszString));
#endif // !UNICODE

            fResult = ApplyRotation(pIDADrawingSurface, pIDAStatics, fFlipCoord);

            if (fResult)
            {
                bstrText = SysAllocString(pwchText);

                if (bstrText)
                {
                    fResult = SUCCEEDED(pIDADrawingSurface->Text(
                        bstrText,
                        (double)m_iXPosition,
                        FlipY(fFlipCoord, (double)m_iYPosition)));

                    SysFreeString(bstrText);
                }
            }

            if (fResult)
            {
                fResult = RemoveRotation(pIDADrawingSurface, pIDAStatics);
            }

            Delete [] pwchText;
        }
    }

    return fResult;
}

/*==========================================================================*/

BOOL CGraphicString::LoadObject(CParser &parser)
{
    BOOL fResult = FALSE;

    // Because of a possible bug in the Alpha compiler, the temporary array 
    // will have to be dynamically allocated, rather than statically.  Bleh.
    LPTSTR pszTempString = New TCHAR[MAX_STRING_LENGTH*2];

    if (NULL != pszTempString)
    {
        pszTempString[0] = 0;

        if (parser.GetStringParam(0, pszTempString) &&
            parser.GetIntegerParam(1, &m_iXPosition) &&
            parser.GetIntegerParam(2, &m_iYPosition))
        {
            m_pszString = New TCHAR[lstrlen(pszTempString) + 1];

            if (NULL != m_pszString)
            {
                fResult = TRUE;
                CStringWrapper::Strncpy(m_pszString, pszTempString, lstrlen(pszTempString) + 1);
                m_fltRotation = 0.0f;
                parser.GetFloatParam(3, &m_fltRotation);
                m_iCenterX = m_iXPosition;
                m_iCenterY = m_iYPosition;
            }
        }

        Delete pszTempString;
    }

    return fResult;
}

/*==========================================================================*/

BOOL CGraphicString::SaveObject(CParser &parser)
{
    BOOL fResult = FALSE;

    if (parser.PutStringParam(m_pszString) &&
        parser.PutIntegerParam(m_iXPosition) &&
        parser.PutIntegerParam(m_iYPosition))
    {
        fResult = TRUE;

        if (m_fltRotation != 0.0f)
            fResult = parser.PutFloatParam(m_fltRotation);
    }

    return fResult;
}

/*==========================================================================*\
    CGraphicFont Class Implementation:
\*==========================================================================*/

CGraphicFont::CGraphicFont()
    : CGraphicObject()
{
    CStringWrapper::Memset(&m_logfont, 0, sizeof(LOGFONT));
}

/*==========================================================================*/

CGraphicFont::~CGraphicFont()
{
}

/*==========================================================================*/

BOOL CGraphicFont::Execute(IDADrawingSurface *pIDADrawingSurface, IDAStatics *pIDAStatics, BOOL fFlipCoord)
{
    BOOL fResult = FALSE;

    if (pIDADrawingSurface)
    {
        WCHAR *pwchFont = New WCHAR [MAX_STRING_LENGTH];

        if (pwchFont)
        {
            BSTR bstrFontFace = NULL;
#ifdef UNICODE
            CStringWrapper::Strcpy(pwchFont, m_logfont.lfFaceName);
            fResult = TRUE;
#else // !UNICODE
            CStringWrapper::Mbstowcs(pwchFont, m_logfont.lfFaceName, CStringWrapper::Strlen(m_logfont.lfFaceName));
#endif // !UNICODE

            bstrFontFace = SysAllocString(pwchFont);

            if (bstrFontFace)
            {
                fResult = SUCCEEDED(pIDADrawingSurface->Font(
                    bstrFontFace,
                    (int)PixelsToPoints(m_logfont.lfHeight, pIDAStatics),
                    m_logfont.lfWeight > 500,
                    m_logfont.lfItalic,
                    m_logfont.lfUnderline,
                    m_logfont.lfStrikeOut));

                SysFreeString(bstrFontFace);
            }

            Delete [] pwchFont;
        }
    }

    return fResult;
}
   
/*==========================================================================*/

BOOL CGraphicFont::LoadObject(CParser &parser)
{
    BOOL fResult = FALSE;
    TCHAR *ptchFont = New TCHAR [MAX_STRING_LENGTH];

    if (ptchFont)
    {
        // Zero out the logfont structure...
        CStringWrapper::Memset(&m_logfont, 0, sizeof(LOGFONT));

        if (parser.GetStringParam(0, ptchFont) &&
            parser.GetLongParam(1, &m_logfont.lfHeight))
        {
            CStringWrapper::Strncpy(m_logfont.lfFaceName, ptchFont, sizeof(m_logfont.lfFaceName));
            fResult = TRUE;
        }

        if (fResult)
        {
            // Read in the optional parameters...
            parser.GetLongParam(2, &m_logfont.lfWeight);
            parser.GetByteParam(3, &m_logfont.lfItalic);
            parser.GetByteParam(4, &m_logfont.lfUnderline);
            parser.GetByteParam(5, &m_logfont.lfStrikeOut);
        }

        Delete [] ptchFont;
    }

    return fResult;
}

/*==========================================================================*/

BOOL CGraphicFont::SaveObject(CParser &parser)
{
    BOOL fResult = FALSE;

    if (parser.PutStringParam(m_logfont.lfFaceName) &&
        parser.PutLongParam(m_logfont.lfHeight) &&
        parser.PutLongParam(m_logfont.lfWeight) &&
        parser.PutByteParam(m_logfont.lfItalic) &&
        parser.PutByteParam(m_logfont.lfUnderline) &&
        parser.PutByteParam(m_logfont.lfStrikeOut))
    {
        fResult = TRUE;
    }

    return fResult;
}

/*==========================================================================*\
    CGraphicTextureFill Class Implementation:
\*==========================================================================*/

CGraphicTextureFill::CGraphicTextureFill()
    : CGraphicObject()
{
    m_pszTexture = (LPTSTR)NULL;
    m_fltStartX = 0.0;
    m_fltStartY = 0.0;
    m_iStyle = 0;
}

/*==========================================================================*/

CGraphicTextureFill::~CGraphicTextureFill()
{
    if (m_pszTexture)
    {
        Delete [] m_pszTexture;
        m_pszTexture = (LPTSTR)NULL;
    }
}

/*==========================================================================*/

BOOL CGraphicTextureFill::Execute(IDADrawingSurface *pIDADrawingSurface, IDAStatics *pIDAStatics, BOOL fFlipCoord)
{
    BOOL fResult = FALSE;

    if (pIDADrawingSurface)
    {
        WCHAR *pwchTextureFill = New WCHAR [MAX_STRING_LENGTH];

        if (pwchTextureFill)
        {
            BSTR bstrTextureFill = NULL;
#ifdef UNICODE
            CStringWrapper::Strcpy(pwchTextureFill, m_pszTexture);
            fResult = TRUE;
#else // !UNICODE
            CStringWrapper::Mbstowcs(pwchTextureFill, m_pszTexture, CStringWrapper::Strlen(m_pszTexture));
#endif // !UNICODE

            bstrTextureFill = SysAllocString(pwchTextureFill);

            if (bstrTextureFill)
            {
                CComPtr<IDAImage> TexturePtr;
                CComPtr<IDAImage> TranslatedTexturePtr;
                CComPtr<IDAImage> EmptyImagePtr;
                CComPtr<IDATransform2> TransformPtr;
                CComPtr<IDAImportationResult> ImportationResultPtr;

                fResult =
                    SUCCEEDED(pIDAStatics->get_EmptyImage(&EmptyImagePtr)) &&
                    SUCCEEDED(pIDAStatics->ImportImageAsync(bstrTextureFill, EmptyImagePtr, &ImportationResultPtr)) &&
                    SUCCEEDED(ImportationResultPtr->get_Image(&TexturePtr)) &&
                    SUCCEEDED(pIDAStatics->Translate2(m_fltStartX, m_fltStartY, &TransformPtr)) &&
                    SUCCEEDED(TexturePtr->Transform(TransformPtr, &TranslatedTexturePtr));

                if (fResult)
                {
                    if (m_iStyle == 0)
                    {
                        fResult =
                            SUCCEEDED(pIDADrawingSurface->AutoSizeFillScale()) &&
                            SUCCEEDED(pIDADrawingSurface->FillImage(TranslatedTexturePtr));
                    }
                    else
                    {
                        fResult =
                            SUCCEEDED(pIDADrawingSurface->FixedFillScale()) &&
                            SUCCEEDED(pIDADrawingSurface->FillTexture(TranslatedTexturePtr));
                    }
                }

                SysFreeString(bstrTextureFill);
            }

            Delete [] pwchTextureFill;
        }
    }

    return fResult;
}
   
/*==========================================================================*/

BOOL CGraphicTextureFill::LoadObject(CParser &parser)
{
    BOOL fResult = FALSE;
    TCHAR *ptchTextureFill = New TCHAR [MAX_STRING_LENGTH];

    if (ptchTextureFill)
    {
        if (parser.GetFloatParam(0, &m_fltStartX) &&
            parser.GetFloatParam(1, &m_fltStartY) &&
            parser.GetStringParam(2, ptchTextureFill) &&
            parser.GetIntegerParam(3, &m_iStyle))
        {
            m_pszTexture = New TCHAR[CStringWrapper::Strlen(ptchTextureFill)];

            if (m_pszTexture)
            {
                CStringWrapper::Strncpy(m_pszTexture, ptchTextureFill, CStringWrapper::Strlen(ptchTextureFill));
                fResult = TRUE;
            }
        }

        Delete [] ptchTextureFill;
    }

    return fResult;
}

/*==========================================================================*/

BOOL CGraphicTextureFill::SaveObject(CParser &parser)
{
    BOOL fResult = FALSE;

    if (parser.PutFloatParam(m_fltStartX) &&
        parser.PutFloatParam(m_fltStartY) &&
        parser.PutStringParam(m_pszTexture) &&
        parser.PutIntegerParam(m_iStyle))
    {
        fResult = TRUE;
    }

    return fResult;
}

/*==========================================================================*\
    CGraphicFillColor Class Implementation:
\*==========================================================================*/

CGraphicFillColor::CGraphicFillColor()
    : CGraphicObject()
{
    m_clrrefFillFG = RGB(0, 0, 0);
    m_clrrefFillBG = RGB(255, 255, 255);
}

/*==========================================================================*/

CGraphicFillColor::~CGraphicFillColor()
{
}

/*==========================================================================*/

BOOL CGraphicFillColor::Execute(IDADrawingSurface *pIDADrawingSurface, IDAStatics *pIDAStatics, BOOL fFlipCoord)
{
    BOOL fResult = FALSE;

    if (pIDADrawingSurface && pIDAStatics)
    {
        CComPtr<IDAColor> FGColorPtr;
        CComPtr<IDAColor> BGColorPtr;

        if (CreateDAColor(m_clrrefFillFG, pIDAStatics, &FGColorPtr) &&
            CreateDAColor(m_clrrefFillBG, pIDAStatics, &BGColorPtr))
        {
            fResult =
                SUCCEEDED(pIDADrawingSurface->FillColor(FGColorPtr)) &&
                SUCCEEDED(pIDADrawingSurface->SecondaryFillColor(BGColorPtr));
        }
    }

    return fResult;
}

/*==========================================================================*/

BOOL CGraphicFillColor::LoadObject(CParser &parser)
{
    BOOL fResult = FALSE;
    int iValueR = 0;
    int iValueG = 0;
    int iValueB = 0;

    if (parser.GetIntegerParam(0, &iValueR) &&
        parser.GetIntegerParam(1, &iValueG) &&
        parser.GetIntegerParam(2, &iValueB))
    {
        if (SetColor(iValueR, iValueG, iValueB, &m_clrrefFillFG))
        {
            m_clrrefFillBG = m_clrrefFillFG;
            fResult = TRUE;
        }
    }

    if (fResult)
    {
        // Handle the optional BG color...
        if (parser.GetIntegerParam(3, &iValueR) &&
            parser.GetIntegerParam(4, &iValueG) &&
            parser.GetIntegerParam(5, &iValueB))
        {
			SetColor(iValueR, iValueG, iValueB, &m_clrrefFillBG);
        }
    }

    return fResult;
}

/*==========================================================================*/

BOOL CGraphicFillColor::SaveObject(CParser &parser)
{
    BOOL fResult = FALSE;

    if (parser.PutIntegerParam(GetRValue(m_clrrefFillFG)) &&
        parser.PutIntegerParam(GetGValue(m_clrrefFillFG)) &&
        parser.PutIntegerParam(GetBValue(m_clrrefFillFG)) &&
        parser.PutIntegerParam(GetRValue(m_clrrefFillBG)) &&
        parser.PutIntegerParam(GetGValue(m_clrrefFillBG)) &&
        parser.PutIntegerParam(GetBValue(m_clrrefFillBG)))
    {
        fResult = TRUE;
    }

    return fResult;
}

/*==========================================================================*\
    CGraphicFillStyle Class Implementation:
\*==========================================================================*/

CGraphicFillStyle::CGraphicFillStyle()
    : CGraphicObject()
{
    m_lFillStyle = 0;
}

/*==========================================================================*/

CGraphicFillStyle::~CGraphicFillStyle()
{
}

/*==========================================================================*/

BOOL CGraphicFillStyle::Execute(IDADrawingSurface *pIDADrawingSurface, IDAStatics *pIDAStatics, BOOL fFlipCoord)
{
    BOOL fResult = FALSE;

    if (pIDADrawingSurface)
    {
        fResult = SUCCEEDED(pIDADrawingSurface->FillStyle(m_lFillStyle));
    }

    return fResult;
}

/*==========================================================================*/

BOOL CGraphicFillStyle::LoadObject(CParser &parser)
{
    BOOL fResult = FALSE;
    int iStyle = 0;

    if (parser.GetIntegerParam(0, &iStyle))
    {
        fResult = TRUE;

        m_lFillStyle = iStyle;
    }

    return fResult;
}

/*==========================================================================*/

BOOL CGraphicFillStyle::SaveObject(CParser &parser)
{
    BOOL fResult = FALSE;

    fResult = parser.PutLongParam(m_lFillStyle);

    return fResult;
}

/*==========================================================================*\
    CGraphicFillStyle Class Implementation:
\*==========================================================================*/

CGraphicGradientFill::CGraphicGradientFill()
    : CGraphicObject()
{
    m_lxStart = 0;
    m_lyStart = 0;
    m_lxEnd = 0;
    m_lyEnd = 0;
    m_fltRolloff = 1.0f;
}

/*==========================================================================*/

CGraphicGradientFill::~CGraphicGradientFill()
{
}

/*==========================================================================*/

BOOL CGraphicGradientFill::Execute(IDADrawingSurface *pIDADrawingSurface, IDAStatics *pIDAStatics, BOOL fFlipCoord)
{
    BOOL fResult = FALSE;

    if (pIDADrawingSurface)
    {
        fResult =
            SUCCEEDED(pIDADrawingSurface->GradientExtent((double)m_lxStart, FlipY(fFlipCoord, (double)m_lyStart), (double)m_lxEnd, FlipY(fFlipCoord, (double)m_lyEnd))) &&
            SUCCEEDED(pIDADrawingSurface->GradientRolloffPower((double)m_fltRolloff));
    }

    return fResult;
}

/*==========================================================================*/

BOOL CGraphicGradientFill::LoadObject(CParser &parser)
{
    BOOL fResult = FALSE;

    if (parser.GetLongParam(0, &m_lxStart) &&
        parser.GetLongParam(1, &m_lyStart) &&
        parser.GetLongParam(2, &m_lxEnd) &&
        parser.GetLongParam(3, &m_lyEnd))
    {
        fResult = TRUE;
    }

    if (fResult)
    {
        float fTemp = 0.0f;

        m_fltRolloff = 1.0f;

        if (parser.GetFloatParam(4, &fTemp))
        {
            if (fTemp > 0.0f)
            {
                m_fltRolloff = fTemp;
            }
            else
            {
                // Invalid negative parameter!
                fResult = FALSE;
            }
        }
    }

    return fResult;
}

/*==========================================================================*/

BOOL CGraphicGradientFill::SaveObject(CParser &parser)
{
    BOOL fResult = FALSE;

    if (parser.PutLongParam(m_lxStart) &&
        parser.PutLongParam(m_lyStart) &&
        parser.PutLongParam(m_lxEnd) &&
        parser.PutLongParam(m_lyEnd) &&
        parser.PutFloatParam(m_fltRolloff))
    {
        fResult = TRUE;
    }

    return fResult;
}

/*==========================================================================*\
    CGraphicGradientShape Class Implementation:
\*==========================================================================*/

CGraphicGradientShape::CGraphicGradientShape()
    : CGraphicObject()
{
    m_lpPolyPoints  = (LPPOINT)NULL;
    m_iPointCount = 0;
}

/*==========================================================================*/

CGraphicGradientShape::~CGraphicGradientShape()
{
    if (m_lpPolyPoints)
    {
        Delete [] m_lpPolyPoints;
        m_lpPolyPoints = (LPPOINT)NULL;
        m_iPointCount = 0;
    }
}

/*==========================================================================*/

BOOL CGraphicGradientShape::Execute(IDADrawingSurface *pIDADrawingSurface, IDAStatics *pIDAStatics, BOOL fFlipCoord)
{
    BOOL fResult = FALSE;

    if (pIDADrawingSurface && m_iPointCount >= 2)
    {
        VARIANT varPoints;
#ifdef _DEBUG
        HRESULT hr;
#endif
        double *pArray = NULL;
        SAFEARRAY *psa = NULL;

        psa = SafeArrayCreateVector(VT_R8, 0, m_iPointCount << 1);

        if (NULL == psa)
            return E_OUTOFMEMORY;

        // Try and get a pointer to the data
        if (SUCCEEDED(SafeArrayAccessData(psa, (LPVOID *)&pArray)))
        {
            for(int iPointIndex=0;iPointIndex<m_iPointCount;iPointIndex++)
            {
                pArray[(iPointIndex<<1)]   = (double)m_lpPolyPoints[iPointIndex].x;
                pArray[(iPointIndex<<1)+1] = FlipY(fFlipCoord, (double)m_lpPolyPoints[iPointIndex].y);
            }
#ifdef _DEBUG
            hr = 
#endif
                SafeArrayUnaccessData(psa);
            ASSERT(SUCCEEDED(hr));

            // Our variant is going to be an array of VT_R8s
            VariantInit(&varPoints);
            varPoints.vt = VT_ARRAY | VT_R8;
            varPoints.parray = psa;

            fResult = SUCCEEDED(pIDADrawingSurface->GradientShape(varPoints));
        }

        if (NULL != psa)
        {
            SafeArrayDestroy(psa);
        }

    }

    return fResult;
}

/*==========================================================================*/

BOOL CGraphicGradientShape::LoadObject(CParser &parser)
{
    BOOL fResult = FALSE;

    // Clear the point array...
    if (m_lpPolyPoints)
    {
        Delete [] m_lpPolyPoints;
        m_lpPolyPoints = NULL;
        m_iPointCount = 0;
    }

    if (parser.GetIntegerParam(0, &m_iPointCount) && m_iPointCount >= 2)
    {
        int iPointIndex = 0;
        int iParamIndex = 1;

        m_lpPolyPoints = New POINT [m_iPointCount];

        if (m_lpPolyPoints)
        {
            fResult = TRUE;

            for(iPointIndex=0;iPointIndex<m_iPointCount;iPointIndex++)
            {
                int iValue1 = 0;
                int iValue2 = 0;

                if (parser.GetIntegerParam(iParamIndex,   &iValue1) &&
                    parser.GetIntegerParam(iParamIndex+1, &iValue2))
                {
                    m_lpPolyPoints[iPointIndex].x = iValue1;
                    m_lpPolyPoints[iPointIndex].y = iValue2;
                }
                else
                {
                    fResult = FALSE;
                    break;
                }

                iParamIndex += 2;
            }
        }
    }

    return fResult;
}

/*==========================================================================*/

BOOL CGraphicGradientShape::SaveObject(CParser &parser)
{
    BOOL fResult = FALSE;

    if (parser.PutIntegerParam(m_iPointCount))
    {
        int iPointIndex = 0;

        fResult = TRUE;

        for(iPointIndex=0;iPointIndex<m_iPointCount;iPointIndex++)
        {
            if (!parser.PutIntegerParam(m_lpPolyPoints[iPointIndex].x) ||
                !parser.PutIntegerParam(m_lpPolyPoints[iPointIndex].y))
            {
                fResult = FALSE;
                break;
            }
        }
    }

    return fResult;
}

/*==========================================================================*\
    CGraphicLineColor Class Implementation:
\*==========================================================================*/

CGraphicLineColor::CGraphicLineColor()
    : CGraphicObject()
{
    m_clrrefLine = RGB(0, 0, 0);
}

/*==========================================================================*/

CGraphicLineColor::~CGraphicLineColor()
{
}

/*==========================================================================*/

BOOL CGraphicLineColor::Execute(IDADrawingSurface *pIDADrawingSurface, IDAStatics *pIDAStatics, BOOL fFlipCoord)
{
    BOOL fResult = FALSE;

    if (pIDADrawingSurface)
    {
        CComPtr<IDAColor> LineColorPtr;

        if (CreateDAColor(m_clrrefLine, pIDAStatics, &LineColorPtr))
        {
            fResult = 
                SUCCEEDED(pIDADrawingSurface->LineColor(LineColorPtr)) &&
                SUCCEEDED(pIDADrawingSurface->BorderColor(LineColorPtr));
        }
    }

    return fResult;
}

/*==========================================================================*/

BOOL CGraphicLineColor::LoadObject(CParser &parser)
{
    BOOL fResult = FALSE;
    int iValueR = 0;
    int iValueG = 0;
    int iValueB = 0;

    if (parser.GetIntegerParam(0, &iValueR) &&
        parser.GetIntegerParam(1, &iValueG) &&
        parser.GetIntegerParam(2, &iValueB))
    {
        fResult = SetColor(iValueR, iValueG, iValueB, &m_clrrefLine);
    }

    return fResult;
}

/*==========================================================================*/

BOOL CGraphicLineColor::SaveObject(CParser &parser)
{
    BOOL fResult = FALSE;

    if (parser.PutIntegerParam(GetRValue(m_clrrefLine)) &&
        parser.PutIntegerParam(GetGValue(m_clrrefLine)) &&
        parser.PutIntegerParam(GetBValue(m_clrrefLine)))
    {
        fResult = TRUE;
    }

    return fResult;
}

/*==========================================================================*\
    CGraphicLineStyle Class Implementation:
\*==========================================================================*/

CGraphicLineStyle::CGraphicLineStyle()
    : CGraphicObject()
{
    m_lLineStyle = 0;
    m_lLineWidth = 0;
}

/*==========================================================================*/

CGraphicLineStyle::~CGraphicLineStyle()
{
}

/*==========================================================================*/

BOOL CGraphicLineStyle::Execute(IDADrawingSurface *pIDADrawingSurface, IDAStatics *pIDAStatics, BOOL fFlipCoord)
{
    BOOL fResult = FALSE;

    if (pIDADrawingSurface && pIDAStatics)
    {
        DA_DASH_STYLE daDashStyle = DAEmpty;

        switch(m_lLineStyle)
        {
            case 0 : daDashStyle = DAEmpty; break;
            case 1 : daDashStyle = DASolid; break;
            case 2 : daDashStyle = DADash; break;
            case 6 : daDashStyle = DASolid; break;

            default : daDashStyle = DASolid; break;
        }

        fResult =
            SUCCEEDED(pIDADrawingSurface->LineDashStyle(daDashStyle)) &&
            SUCCEEDED(pIDADrawingSurface->LineWidth(PixelsToPoints(m_lLineWidth, pIDAStatics))) &&
            SUCCEEDED(pIDADrawingSurface->LineJoinStyle(DAJoinRound)) &&
            SUCCEEDED(pIDADrawingSurface->LineEndStyle(DAEndRound)) &&
            SUCCEEDED(pIDADrawingSurface->BorderDashStyle(daDashStyle)) &&
            SUCCEEDED(pIDADrawingSurface->BorderJoinStyle(DAJoinRound)) &&
            SUCCEEDED(pIDADrawingSurface->BorderEndStyle(DAEndRound)) &&
            SUCCEEDED(pIDADrawingSurface->BorderWidth(PixelsToPoints(m_lLineWidth, pIDAStatics)));
    }

    return fResult;
}

/*==========================================================================*/

BOOL CGraphicLineStyle::LoadObject(CParser &parser)
{
    BOOL fResult = FALSE;
    int iStyle = 0;
    int iWidth = 0;

    if (parser.GetIntegerParam(0, &iStyle))
    {
        fResult = TRUE;

        // We don't care if this wasn't really set...
        if (!parser.GetIntegerParam(1, &iWidth))
            iWidth = 0;

        if (iWidth < 0)
            iWidth = 0;

        m_lLineStyle = iStyle;
        m_lLineWidth = iWidth;
    }

    return fResult;
}

/*==========================================================================*/

BOOL CGraphicLineStyle::SaveObject(CParser &parser)
{
    BOOL fResult = FALSE;

    fResult =
        parser.PutLongParam(m_lLineStyle) &&
        parser.PutLongParam(m_lLineWidth);

    return fResult;
}

/*==========================================================================*\
    CGraphicHatchFill Class Implementation:
\*==========================================================================*/

CGraphicHatchFill::CGraphicHatchFill()
    : CGraphicObject()
{
    m_fHatchFill = 1;
}

/*==========================================================================*/

CGraphicHatchFill::~CGraphicHatchFill()
{
}

/*==========================================================================*/

BOOL CGraphicHatchFill::Execute(IDADrawingSurface *pIDADrawingSurface, IDAStatics *pIDAStatics, BOOL fFlipCoord)
{
    BOOL fResult = FALSE;

    if (pIDADrawingSurface)
    {
        VARIANT_BOOL vBool = BOOL_TO_VBOOL(!m_fHatchFill);

        fResult = SUCCEEDED(pIDADrawingSurface->put_HatchFillTransparent(vBool));
    }

    return fResult;
}

/*==========================================================================*/

BOOL CGraphicHatchFill::LoadObject(CParser &parser)
{
    BOOL fResult = FALSE;
    int iStyle = 0;

    if (parser.GetIntegerParam(0, &iStyle))
    {
        fResult = TRUE;

        m_fHatchFill = (iStyle != 0) ? TRUE : FALSE;
    }

    return fResult;
}

/*==========================================================================*/

BOOL CGraphicHatchFill::SaveObject(CParser &parser)
{
    BOOL fResult = FALSE;
    int iStyle = m_fHatchFill ? 1 : 0;

    fResult = parser.PutLongParam(iStyle);

    return fResult;
}

/*==========================================================================*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\sprite\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//
#define IDS_STRING1                     1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\sprite\purevirt.cpp ===
// purevirt.c
//
// Avoids use of C runtime.
//

#include "..\ihbase\precomp.h"

extern "C" int __cdecl _purecall(void)
{
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\sgrfx\grobj.h ===
/*==========================================================================*\

Module:
    grobj.h

Author:
    IHammer Team (MByrd)

Created:
    November 1996

Description:
    CGraphicObject derived Class Definitions

History:
    11-07-1996  Created

\*==========================================================================*/

#ifndef __GROBJ_H__
#define __GROBJ_H__

#include "ihammer.h"
#include <daxpress.h> // Needed for IDADrawingSurface definition

/*==========================================================================*/

#define GR_UNKNOWN     (WORD)0x0000
#define GR_ARC         (WORD)0x0001
#define GR_OVAL        (WORD)0x0002
#define GR_POLYGON     (WORD)0x0003
#define GR_POLYBEZ     (WORD)0x0004
#define GR_RECT        (WORD)0x0005
#define GR_ROUNDRECT   (WORD)0x0006
#define GR_STRING      (WORD)0x0007
#define GR_FILLCOLOR   (WORD)0x0008
#define GR_FILLSTYLE   (WORD)0x0009
#define GR_LINECOLOR   (WORD)0x000A
#define GR_LINESTYLE   (WORD)0x000B
#define GR_FONT        (WORD)0x000C
#define GR_GRADFILL    (WORD)0x000D
#define GR_HATCHFILL   (WORD)0x000E
#define GR_GRADSHAPE   (WORD)0x000F
#define GR_TEXTUREFILL (WORD)0x0010

// This should be consistent with MAX_PARAM_LENGTH defined in parser.h
#define MAX_STRING_LENGTH 65536L

/*==========================================================================*/

#define FS_SOLID            0
#define FS_NULL             1
#define FS_PATTERN_DIB      2
#define FS_HATCH_HORZ       3
#define FS_HATCH_VERT       4
#define FS_HATCH_FDIAG      5
#define FS_HATCH_BDIAG      6
#define FS_HATCH_CROSS      7
#define FS_HATCH_DIAGCROSS  8
#define FS_GRADIENT_HORZ    9
#define FS_GRADIENT_VERT    10
#define FS_GRADIENT_RADIAL  11
#define FS_GRADIENT_LINE    12
#define FS_GRADIENT_RECT    13
#define FS_GRADIENT_SHAPE   14

/*==========================================================================*/

class CParser;

/*==========================================================================*/

class CGraphicObject
{
protected:
    int m_iXPosition;
    int m_iYPosition;
    int m_iCenterX;
    int m_iCenterY;
    float m_fltRotation;

public:
    CGraphicObject();
    virtual ~CGraphicObject();

    virtual BOOL WriteData(int iSizeData, LPVOID lpvData);
    virtual BOOL ReadData(int iSizeData, LPVOID lpvData);

    virtual BOOL Execute(IDADrawingSurface *pIDADrawingSurface, IDAStatics *pIDAStatics, BOOL fFlipCoord)=0;
    virtual BOOL LoadObject(CParser &parser)=0;
    virtual BOOL SaveObject(CParser &parser)=0;
    virtual WORD GetObjectType(void)=0;
    virtual int  GetDataSize(void)=0;
    virtual BOOL IsFilled(void) { return FALSE; }
    virtual BOOL AnimatesOverTime(void) { return FALSE; }

protected:
    BOOL ApplyRotation(IDADrawingSurface *pIDADrawingSurface, IDAStatics *pIDAStatics, BOOL fFlipCoord);
    BOOL RemoveRotation(IDADrawingSurface *pIDADrawingSurface, IDAStatics *pIDAStatics);
};

/*==========================================================================*/

class CGraphicArc : public CGraphicObject
{
private:
    int m_iWidth;
    int m_iHeight;
    float m_fStartAngle;
    float m_fArcAngle;
    BOOL m_fFilled;

public:
    CGraphicArc(BOOL fFilled);
    virtual ~CGraphicArc();
    virtual BOOL Execute(IDADrawingSurface *pIDADrawingSurface, IDAStatics *pIDAStatics, BOOL fFlipCoords);
	virtual BOOL ValidateObject();
	virtual BOOL LoadObject(CParser &parser);
    virtual BOOL SaveObject(CParser &parser);
    virtual WORD GetObjectType(void) { return GR_ARC; }
    virtual int  GetDataSize(void) { return sizeof(CGraphicArc); }
    virtual BOOL IsFilled(void) { return m_fFilled; }
};

/*==========================================================================*/

class CGraphicOval : public CGraphicObject
{
private:
    int m_iWidth;
    int m_iHeight;
    BOOL m_fFilled;

public:
    CGraphicOval(BOOL fFilled);
    virtual ~CGraphicOval();
    virtual BOOL Execute(IDADrawingSurface *pIDADrawingSurface, IDAStatics *pIDAStatics, BOOL fFlipCoords);
    virtual BOOL LoadObject(CParser &parser);
    virtual BOOL SaveObject(CParser &parser);
    virtual WORD GetObjectType(void) { return GR_OVAL; }
    virtual int  GetDataSize(void) { return sizeof(CGraphicOval); }
    virtual BOOL IsFilled(void) { return m_fFilled; }
};

/*==========================================================================*/

class CGraphicPolygon : public CGraphicObject
{
private:
    BOOL    m_fFilled;
    LPPOINT m_lpPolyPoints;
    int     m_iPointCount;

public:
    CGraphicPolygon(BOOL fFilled);
    virtual ~CGraphicPolygon();
    virtual BOOL Execute(IDADrawingSurface *pIDADrawingSurface, IDAStatics *pIDAStatics, BOOL fFlipCoords);
    virtual BOOL LoadObject(CParser &parser);
    virtual BOOL SaveObject(CParser &parser);
    virtual WORD GetObjectType(void) { return GR_POLYGON; }
    virtual int  GetDataSize(void) { return sizeof(CGraphicPolygon) + (m_iPointCount * sizeof(POINT)); }
    virtual BOOL IsFilled(void) { return m_fFilled; }
};

/*==========================================================================*/

class CGraphicPolyBez : public CGraphicObject
{
typedef struct POLYBEZPOINT_tag
{
    long iFlags;
    long iX;
    long iY;
} POLYBEZPOINT, FAR *LPPOLYBEZPOINT;

private:
    BOOL    m_fFilled;
    LPPOLYBEZPOINT m_lpPolyPoints;
    LPPOINT m_lpPointArray;
    LPBYTE  m_lpByteArray;
    int     m_iPointCount;

    BYTE ConvertFlags(BYTE bFlagsIn)
    {
        BYTE bResult = PT_MOVETO;

        switch(bFlagsIn)
        {
            case 0 : bResult = PT_MOVETO; break;
            case 1 : bResult = PT_LINETO; break;
            case 2 : bResult = PT_BEZIERTO; break;
            case 3 : bResult = PT_LINETO   | PT_CLOSEFIGURE; break;
            case 4 : bResult = PT_BEZIERTO | PT_CLOSEFIGURE; break;

            default : bResult = PT_MOVETO; break;
        }

        return bResult;
    }

public:
    CGraphicPolyBez(BOOL fFilled);
    virtual ~CGraphicPolyBez();
    virtual BOOL Execute(IDADrawingSurface *pIDADrawingSurface, IDAStatics *pIDAStatics, BOOL fFlipCoords);
    virtual BOOL LoadObject(CParser &parser);
    virtual BOOL SaveObject(CParser &parser);
    virtual WORD GetObjectType(void) { return GR_POLYBEZ; }
    virtual int  GetDataSize(void) { return sizeof(CGraphicPolyBez) + (m_iPointCount * sizeof(POLYBEZPOINT)); }
    virtual BOOL IsFilled(void) { return m_fFilled; }
};

/*==========================================================================*/

class CGraphicRect : public CGraphicObject
{
private:
    int m_iWidth;
    int m_iHeight;
    BOOL m_fFilled;

public:
    CGraphicRect(BOOL fFilled);
    virtual ~CGraphicRect();
    virtual BOOL Execute(IDADrawingSurface *pIDADrawingSurface, IDAStatics *pIDAStatics, BOOL fFlipCoords);
    virtual BOOL LoadObject(CParser &parser);
    virtual BOOL SaveObject(CParser &parser);
    virtual WORD GetObjectType(void) { return GR_RECT; }
    virtual int  GetDataSize(void) { return sizeof(CGraphicRect); }
    virtual BOOL IsFilled(void) { return m_fFilled; }
};

/*==========================================================================*/

class CGraphicRoundRect : public CGraphicObject
{
private:
    int m_iWidth;
    int m_iHeight;
    int m_iArcWidth;
    int m_iArcHeight;
    BOOL m_fFilled;

public:
    CGraphicRoundRect(BOOL fFilled);
    virtual ~CGraphicRoundRect();
    virtual BOOL Execute(IDADrawingSurface *pIDADrawingSurface, IDAStatics *pIDAStatics, BOOL fFlipCoords);
    virtual BOOL LoadObject(CParser &parser);
	virtual BOOL SaveObject(CParser &parser);
    virtual WORD GetObjectType(void) { return GR_ROUNDRECT; }
    virtual int  GetDataSize(void) { return sizeof(CGraphicRoundRect); }
    virtual BOOL IsFilled(void) { return m_fFilled; }
};

/*==========================================================================*/

class CGraphicString : public CGraphicObject
{
private:
	LPTSTR  m_pszString;
    int     m_iPointCount;
    LPPOINT m_lpPointArray;
    LPBYTE  m_lpByteArray;

public:
    CGraphicString();
    virtual ~CGraphicString();
    virtual BOOL Execute(IDADrawingSurface *pIDADrawingSurface, IDAStatics *pIDAStatics, BOOL fFlipCoords);
    virtual BOOL LoadObject(CParser &parser);
    virtual BOOL SaveObject(CParser &parser);
    virtual WORD GetObjectType(void) { return GR_STRING; }
    virtual int  GetDataSize(void) { return sizeof(CGraphicString); }
};

/*==========================================================================*/

class CGraphicFont : public CGraphicObject
{
private:
    LOGFONT m_logfont;

public:
    CGraphicFont();
    virtual ~CGraphicFont();
    virtual BOOL Execute(IDADrawingSurface *pIDADrawingSurface, IDAStatics *pIDAStatics, BOOL fFlipCoords);
    virtual BOOL LoadObject(CParser &parser);
    virtual BOOL SaveObject(CParser &parser);
    virtual WORD GetObjectType(void) { return GR_FONT; }
    virtual int  GetDataSize(void) { return sizeof(CGraphicFont); }
};

/*==========================================================================*/

class CGraphicTextureFill : public CGraphicObject
{
private:
    LPTSTR m_pszTexture;
    float  m_fltStartX;
    float  m_fltStartY;
    BOOL   m_iStyle;

public:
    CGraphicTextureFill();
    virtual ~CGraphicTextureFill();
    virtual BOOL Execute(IDADrawingSurface *pIDADrawingSurface, IDAStatics *pIDAStatics, BOOL fFlipCoords);
    virtual BOOL LoadObject(CParser &parser);
    virtual BOOL SaveObject(CParser &parser);
    virtual WORD GetObjectType(void) { return GR_TEXTUREFILL; }
    virtual int  GetDataSize(void) { return sizeof(CGraphicTextureFill); }
    virtual BOOL AnimatesOverTime(void) { return TRUE; }
};

/*==========================================================================*/

class CGraphicFillColor : public CGraphicObject
{
private:
    COLORREF m_clrrefFillFG;
    COLORREF m_clrrefFillBG;

public:
    CGraphicFillColor();
    virtual ~CGraphicFillColor();
    virtual BOOL Execute(IDADrawingSurface *pIDADrawingSurface, IDAStatics *pIDAStatics, BOOL fFlipCoords);
	virtual BOOL LoadObject(CParser &parser);
    virtual BOOL SaveObject(CParser &parser);
    virtual WORD GetObjectType(void) { return GR_FILLCOLOR; }
    virtual int  GetDataSize(void) { return sizeof(CGraphicFillColor); }
};

/*==========================================================================*/

class CGraphicFillStyle : public CGraphicObject
{
private:
    LONG m_lFillStyle;

public:
    CGraphicFillStyle();
    virtual ~CGraphicFillStyle();
    virtual BOOL Execute(IDADrawingSurface *pIDADrawingSurface, IDAStatics *pIDAStatics, BOOL fFlipCoords);
    virtual BOOL LoadObject(CParser &parser);
    virtual BOOL SaveObject(CParser &parser);
    virtual WORD GetObjectType(void) { return GR_FILLSTYLE; }
    virtual int  GetDataSize(void) { return sizeof(CGraphicFillStyle); }
};

/*==========================================================================*/

class CGraphicGradientFill : public CGraphicObject
{
private:
    LONG m_lxStart;
	LONG m_lyStart;
	LONG m_lxEnd;
	LONG m_lyEnd;
    float m_fltRolloff;

public:
    CGraphicGradientFill();
    virtual ~CGraphicGradientFill();
    virtual BOOL Execute(IDADrawingSurface *pIDADrawingSurface, IDAStatics *pIDAStatics, BOOL fFlipCoords);
    virtual BOOL LoadObject(CParser &parser);
    virtual BOOL SaveObject(CParser &parser);
    virtual WORD GetObjectType(void) { return GR_GRADFILL; }
    virtual int  GetDataSize(void) { return sizeof(CGraphicGradientFill); }
};

/*==========================================================================*/

class CGraphicGradientShape : public CGraphicObject
{
private:
    LPPOINT m_lpPolyPoints;
    int     m_iPointCount;

public:
    CGraphicGradientShape();
    virtual ~CGraphicGradientShape();
    virtual BOOL Execute(IDADrawingSurface *pIDADrawingSurface, IDAStatics *pIDAStatics, BOOL fFlipCoords);
    virtual BOOL LoadObject(CParser &parser);
    virtual BOOL SaveObject(CParser &parser);
    virtual WORD GetObjectType(void) { return GR_GRADSHAPE; }
    virtual int  GetDataSize(void) { return sizeof(CGraphicGradientShape) + (m_iPointCount * sizeof(POINT)); }
    virtual BOOL IsFilled(void) { return FALSE; }
};

/*==========================================================================*/

class CGraphicLineColor : public CGraphicObject
{
private:
    COLORREF m_clrrefLine;

public:
    CGraphicLineColor();
    virtual ~CGraphicLineColor();
    virtual BOOL Execute(IDADrawingSurface *pIDADrawingSurface, IDAStatics *pIDAStatics, BOOL fFlipCoords);
    virtual BOOL LoadObject(CParser &parser);
    virtual BOOL SaveObject(CParser &parser);
    virtual WORD GetObjectType(void) { return GR_LINECOLOR; }
    virtual int  GetDataSize(void) { return sizeof(CGraphicLineColor); }
};

/*==========================================================================*/

class CGraphicLineStyle : public CGraphicObject
{
private:
    LONG m_lLineStyle;
    LONG m_lLineWidth;

public:
    CGraphicLineStyle();
    virtual ~CGraphicLineStyle();
    virtual BOOL Execute(IDADrawingSurface *pIDADrawingSurface, IDAStatics *pIDAStatics, BOOL fFlipCoords);
    virtual BOOL LoadObject(CParser &parser);
    virtual BOOL SaveObject(CParser &parser);
    virtual WORD GetObjectType(void) { return GR_LINESTYLE; }
    virtual int  GetDataSize(void) { return sizeof(CGraphicLineStyle); }
};

/*==========================================================================*/

class CGraphicHatchFill : public CGraphicObject
{
private:
    BOOL m_fHatchFill;

public:
    CGraphicHatchFill();
    virtual ~CGraphicHatchFill();
    virtual BOOL Execute(IDADrawingSurface *pIDADrawingSurface, IDAStatics *pIDAStatics, BOOL fFlipCoords);
    virtual BOOL LoadObject(CParser &parser);
    virtual BOOL SaveObject(CParser &parser);
    virtual WORD GetObjectType(void) { return GR_HATCHFILL; }
    virtual int  GetDataSize(void) { return sizeof(CGraphicHatchFill); }
};

/*==========================================================================*/

#endif // __GROBJ_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\sgrfx\parser.cpp ===
/*==========================================================================*\

Module:
    parser.cpp

Author:
    IHammer Team (MByrd)

Created:
    November 1996

Description:
    CParser Class Implementation

History:
    11-07-1996  Created

\*==========================================================================*/

#include "..\ihbase\precomp.h"
#include "..\ihbase\debug.h"
#include "..\ihbase\utils.h"
#include <urlarchv.h>
#include "utils.h"
#include "strwrap.h"
#include "sgrfx.h"
#include "parser.h"

#ifndef ARRAYDIM
  #define ARRAYDIM(a)  (sizeof(a) / sizeof(a[0]))
#endif // ARRAYDIM

/*==========================================================================*\
    CParser Class Implementation:
\*==========================================================================*/

CGraphicObject * CParser::CreateArc(BOOL fFilled)
{
    CGraphicObject *pResult = NULL;

    pResult = (CGraphicObject *)New CGraphicArc(fFilled);

    return pResult;
}

/*==========================================================================*/

CGraphicObject * CParser::CreateOval(BOOL fFilled)
{
    CGraphicObject *pResult = NULL;

    pResult = (CGraphicObject *)New CGraphicOval(fFilled);

    return pResult;
}

/*==========================================================================*/

CGraphicObject * CParser::CreatePolygon(BOOL fFilled)
{
    CGraphicObject *pResult = NULL;

    pResult = (CGraphicObject *)New CGraphicPolygon(fFilled);

    return pResult;
}

/*==========================================================================*/

CGraphicObject * CParser::CreatePolyBez(BOOL fFilled)
{
    CGraphicObject *pResult = NULL;

    pResult = (CGraphicObject *)New CGraphicPolyBez(fFilled);

    return pResult;
}

/*==========================================================================*/

CGraphicObject * CParser::CreateRect(BOOL fFilled)
{
    CGraphicObject *pResult = NULL;

    pResult = (CGraphicObject *)New CGraphicRect(fFilled);

    return pResult;
}

/*==========================================================================*/

CGraphicObject * CParser::CreateRoundRect(BOOL fFilled)
{
    CGraphicObject *pResult = NULL;

    pResult = (CGraphicObject *)New CGraphicRoundRect(fFilled);

    return pResult;
}

/*==========================================================================*/

CGraphicObject * CParser::CreateString(BOOL fFilled)
{
    CGraphicObject *pResult = NULL;

    pResult = (CGraphicObject *)New CGraphicString();

    return pResult;
}

/*==========================================================================*/

CGraphicObject * CParser::CreateFillColor(BOOL fFilled)
{
    CGraphicObject *pResult = NULL;

    pResult = (CGraphicObject *)New CGraphicFillColor();

    return pResult;
}

/*==========================================================================*/

CGraphicObject * CParser::CreateFillStyle(BOOL fFilled)
{
    CGraphicObject *pResult = NULL;

    pResult = (CGraphicObject *)New CGraphicFillStyle();

    return pResult;
}

/*==========================================================================*/

CGraphicObject * CParser::CreateGradientFill(BOOL fFilled)
{
    CGraphicObject *pResult = NULL;

    pResult = (CGraphicObject *)New CGraphicGradientFill();

    return pResult;
}

/*==========================================================================*/

CGraphicObject * CParser::CreateGradientShape(BOOL fFilled)
{
    CGraphicObject *pResult = NULL;

    pResult = (CGraphicObject *)New CGraphicGradientShape();

    return pResult;
}

/*==========================================================================*/

CGraphicObject * CParser::CreateLineColor(BOOL fFilled)
{
    CGraphicObject *pResult = NULL;

    pResult = (CGraphicObject *)New CGraphicLineColor();

    return pResult;
}

/*==========================================================================*/

CGraphicObject * CParser::CreateLineStyle(BOOL fFilled)
{
    CGraphicObject *pResult = NULL;

    pResult = (CGraphicObject *)New CGraphicLineStyle();

    return pResult;
}

/*==========================================================================*/

CGraphicObject * CParser::CreateHatchFill(BOOL fFilled)
{
    CGraphicObject *pResult = NULL;

    pResult = (CGraphicObject *)New CGraphicHatchFill();

    return pResult;
}

/*==========================================================================*/

CGraphicObject * CParser::CreateFont(BOOL fFilled)
{
    CGraphicObject *pResult = NULL;

    pResult = (CGraphicObject *)New CGraphicFont();

    return pResult;
}

/*==========================================================================*/

CGraphicObject * CParser::CreateTextureFill(BOOL fFilled)
{
    CGraphicObject *pResult = NULL;

    pResult = (CGraphicObject *)New CGraphicTextureFill();

    return pResult;
}

/*==========================================================================*/

CParser::PARSERLOOKUP CParser::s_parserlookupTable[] =
{
    { _T("Arc"),                GR_ARC,         FALSE, (CREATEGRAPHICPROC)CParser::CreateArc},
    { _T("Oval"),               GR_OVAL,        TRUE,  (CREATEGRAPHICPROC)CParser::CreateOval},
    { _T("Pie"),                GR_ARC,         TRUE,  (CREATEGRAPHICPROC)CParser::CreateArc},
    { _T("Polyline"),           GR_POLYGON,     FALSE, (CREATEGRAPHICPROC)CParser::CreatePolygon},
    { _T("Polygon"),            GR_POLYGON,     TRUE,  (CREATEGRAPHICPROC)CParser::CreatePolygon},
    { _T("PolySpline"),         GR_POLYBEZ,     FALSE, (CREATEGRAPHICPROC)CParser::CreatePolyBez},
    { _T("FillSpline"),         GR_POLYBEZ,     TRUE,  (CREATEGRAPHICPROC)CParser::CreatePolyBez},
    { _T("Rect"),               GR_RECT,        TRUE,  (CREATEGRAPHICPROC)CParser::CreateRect},
    { _T("RoundRect"),          GR_ROUNDRECT,   TRUE,  (CREATEGRAPHICPROC)CParser::CreateRoundRect},
    { _T("Text"),               GR_STRING,      FALSE, (CREATEGRAPHICPROC)CParser::CreateString},
    { _T("SetFillColor"),       GR_FILLCOLOR,   FALSE, (CREATEGRAPHICPROC)CParser::CreateFillColor},
    { _T("SetFillStyle"),       GR_FILLSTYLE,   FALSE, (CREATEGRAPHICPROC)CParser::CreateFillStyle},
    { _T("SetGradientFill"),    GR_GRADFILL,    FALSE, (CREATEGRAPHICPROC)CParser::CreateGradientFill},
    { _T("SetGradientShape"),   GR_GRADSHAPE,   FALSE, (CREATEGRAPHICPROC)CParser::CreateGradientShape},
    { _T("SetLineColor"),       GR_LINECOLOR,   FALSE, (CREATEGRAPHICPROC)CParser::CreateLineColor},
    { _T("SetLineStyle"),       GR_LINESTYLE,   FALSE, (CREATEGRAPHICPROC)CParser::CreateLineStyle},
    { _T("SetHatchFill"),       GR_HATCHFILL,   FALSE, (CREATEGRAPHICPROC)CParser::CreateHatchFill},
    { _T("SetFont"),            GR_FONT,        FALSE, (CREATEGRAPHICPROC)CParser::CreateFont},
    { _T("SetTextureFill"),     GR_TEXTUREFILL, FALSE, (CREATEGRAPHICPROC)CParser::CreateTextureFill},
    { _T("\0"),                 GR_UNKNOWN,     FALSE, (CREATEGRAPHICPROC)NULL}
};

/*==========================================================================*/

CParser::CParser()
{
    m_cdrgObjectInfo.SetNonDefaultSizes(sizeof(CGraphicObject *));
    m_cdrgObjectInfo.MakeNull();

    m_pvio = (IVariantIO *)NULL;
    m_iParamLineIndex = -1;
    m_iParamIndex = -1;
    m_hfileSource = (HFILE)NULL;
    m_iCurrentParamIndex = -1;
    m_lptstrCurrentParam = (LPTSTR)NULL;
	m_pszParam = NULL;
}

/*==========================================================================*/

CParser::~CParser()
{
    Cleanup();
}

/*==========================================================================*/

void CParser::Cleanup()
{
    int iCount = m_cdrgObjectInfo.Count();

    if (iCount)
    {
        int iIndex = 0;

        for(iIndex=0;iIndex<iCount;iIndex++)
        {
            CGraphicObject **pGraphicObject = (CGraphicObject **)m_cdrgObjectInfo.GetAt(iIndex);

            if (pGraphicObject && *pGraphicObject)
            {
                Delete *pGraphicObject;
            }
        }
    }

    m_cdrgObjectInfo.MakeNull();
	
	if (NULL != m_pszParam)
		Delete [] m_pszParam;
}

/*==========================================================================*/

CGraphicObject *CParser::InstantiateObject(LPTSTR lptstrParam)
{
    CGraphicObject *pResult = NULL;

    if (lptstrParam && (CStringWrapper::Strlen(lptstrParam) > 0))
    {
        int iIndex = 0;
        int iMax   = sizeof(s_parserlookupTable) / sizeof(PARSERLOOKUP);

        // Strip leading whitespace
        while(*lptstrParam == _T(' ') || *lptstrParam == _T('\t'))
            lptstrParam = CStringWrapper::Strinc(lptstrParam);

        while(iIndex < iMax)
        {
            PARSERLOOKUP *pWalker = &s_parserlookupTable[iIndex];
            int iParseLen = CStringWrapper::Strlen(pWalker->rgtchName);

            if (iParseLen > 0 &&
                CStringWrapper::Strnicmp(pWalker->rgtchName, lptstrParam, iParseLen) == 0)
            {
                if (pWalker->pCreateGraphicProc)
                {
                    // Create the proper object type...
                    pResult = (*(pWalker->pCreateGraphicProc))(pWalker->fFilled);
                }

                break;
            }

            iIndex++;
        }
    }

    return pResult;
}

/*==========================================================================*/

BOOL CParser::GetParam(int iParamIndex, LPTSTR *lplptstrParam)
{
    BOOL fResult = FALSE;

    if (iParamIndex >= 0 && lplptstrParam)
    {
        TCHAR *ptchNext = (TCHAR *)m_pszParam;
        int iCurrIndex=0;

        *lplptstrParam = (LPTSTR)NULL;

        if (iParamIndex == m_iCurrentParamIndex)
        {
            // Special-case for current parameter...
            *lplptstrParam = m_lptstrCurrentParam;
            fResult = TRUE;
        }
        else
        {
            BOOL fGotParen = FALSE;

            if (m_iCurrentParamIndex < 0 || m_iCurrentParamIndex > iParamIndex)
            {
                // First, find the starting '(' ...
                while(*ptchNext && *ptchNext != START_PARAM)
                    ptchNext = CStringWrapper::Strinc(ptchNext);

                m_iCurrentParamIndex = -1;
                m_lptstrCurrentParam = (LPTSTR)NULL;
            }
            else
            {
                iCurrIndex = m_iCurrentParamIndex;
                ptchNext   = m_lptstrCurrentParam;
                fGotParen  = TRUE;
            }

            if (!fGotParen)
            {
                // Found the open parenthesis!
                if (*ptchNext == START_PARAM)
                {
                    // Skip the open parenthesis...
                    ptchNext = CStringWrapper::Strinc(ptchNext);
                    fGotParen = TRUE;
                }
            }

            if (fGotParen)
            {
                while(iParamIndex > iCurrIndex)
                {
                    BOOL fString  = FALSE;
                    BOOL fLiteral = FALSE;

                    // Look for a comma (PARAM_SEP)...
                    while(*ptchNext)
                    {
                        if (!fString)
                        {
                            if (*ptchNext == PARAM_SEP)
                            {
                                iCurrIndex++;

                                if (iParamIndex == iCurrIndex)
                                {
                                    ptchNext = CStringWrapper::Strinc(ptchNext);
                                    break;
                                }
                            }

                            if (*ptchNext == START_STRING)
                                fString = TRUE;

                            if (*ptchNext == END_PARAM)
                            {
                                ptchNext = (TCHAR *)NULL;
                                break;
                            }
                        }
                        else
                        {
                            if (!fLiteral)
                            {
                                if (*ptchNext == LITERAL)
                                {
                                    fLiteral = TRUE;
                                }
                                else
                                {
                                    if (*ptchNext == END_STRING)
                                        fString = FALSE;
                                }
                            }
                            else
                            {
                                // Completely ignore character following '\'
                                fLiteral = FALSE;
                            }
                        }

                        ptchNext = CStringWrapper::Strinc(ptchNext);
                    }

                    if (!ptchNext || !*ptchNext)
                        break;
                }

                // At this point, the offset should be correct...
                if (iParamIndex == iCurrIndex && ptchNext)
                {
                    // Skip any whitespace...
                    while(*ptchNext)
                    {
                        if (*ptchNext != _T(' ') &&
                            *ptchNext != _T('\r') &&
                            *ptchNext != _T('\n') &&
                            *ptchNext != _T('\t'))
                        {
                            break;
                        }

                        ptchNext = CStringWrapper::Strinc(ptchNext);
                    }

                    // Return the result...
                    if (*ptchNext)
                    {
                        m_iCurrentParamIndex = iParamIndex;
                        *lplptstrParam = ptchNext;
                        m_lptstrCurrentParam = ptchNext;
                        fResult = TRUE;
                    }
                }
            }
        }
    }

    return fResult;
}

/*==========================================================================*/

BOOL CParser::GetIntegerParam(int iParamIndex, int *piValue)
{
    BOOL fResult = FALSE;

    if (iParamIndex >= 0 && piValue)
    {
        LPTSTR lptstrParam = (LPTSTR)NULL;

        *piValue = 0;

        if (GetParam(iParamIndex, &lptstrParam))
        {
            *piValue = CStringWrapper::Atoi(lptstrParam);
            fResult = TRUE;
        }
    }

    return fResult;
}

/*==========================================================================*/

BOOL CParser::GetFloatParam(int iParamIndex, float *pfValue)
{
    BOOL fResult = FALSE;

    if (iParamIndex >= 0 && pfValue)
    {
        LPTSTR lptstrParam = (LPTSTR)NULL;

        *pfValue = 0.0f;

        if (GetParam(iParamIndex, &lptstrParam))
        {
            double  dbl;

			CStringWrapper::Sscanf1(lptstrParam, "%lf", &dbl);
            // *pdValue = CStringWrapper::Atof(lptstrParam); PAULD There's no TCHAR version of atof
            *pfValue = static_cast<float>(dbl);
            fResult = TRUE;
        }
    }

    return fResult;
}

/*==========================================================================*/

BOOL CParser::GetStringParam(int iParamIndex, LPTSTR lptstrValue)
{
    BOOL fResult = FALSE;

    if (iParamIndex >= 0 && lptstrValue)
    {
        LPTSTR lptstrParam = (LPTSTR)NULL;

        // Null-terminate the output string...
        lptstrValue[0] = 0;
        lptstrValue[1] = 0;

        if (GetParam(iParamIndex, &lptstrParam))
        {
            BOOL fString  = FALSE;
            BOOL fLiteral = FALSE;
            TCHAR *ptchNext = (TCHAR *)lptstrParam;

            // Look for a comma (PARAM_SEP)...
            while(*ptchNext)
            {
                if (!fString)
                {
                    if (*ptchNext == PARAM_SEP)
                        break;

                    if (*ptchNext == END_PARAM)
                        break;

                    if (*ptchNext == START_STRING)
                    {
                        fString = TRUE;
                    }
                }
                else
                {
                    TCHAR rgtchTemp[4];

                    rgtchTemp[0] = 0;
                    rgtchTemp[1] = 0;
                    rgtchTemp[2] = 0;
                    rgtchTemp[3] = 0;

                    if (!fLiteral)
                    {
                        if (*ptchNext == LITERAL)
                        {
                            fLiteral = TRUE;
                        }
                        else
                        {
                            if (*ptchNext == END_STRING)
                            {
                                fString = FALSE;
								fResult = TRUE;
                                break;
                            }
                            else
                            {
                                CStringWrapper::Strncpy(rgtchTemp, ptchNext, 1);
                                CStringWrapper::Strcat(lptstrValue, rgtchTemp);
                            }
                        }
                    }
                    else
                    {
                        // Copy over the literal character...
                        fLiteral = FALSE;

                        CStringWrapper::Strncpy(rgtchTemp, ptchNext, 1);
                        CStringWrapper::Strcat(lptstrValue, rgtchTemp);
                    }
                }

                ptchNext = CStringWrapper::Strinc(ptchNext);
            }
        }
    }

    return fResult;
}

/*==========================================================================*/

BOOL CParser::PutIntegerParam(int iValue)
{
    TCHAR rgtchTemp[80];

    if (m_iParamIndex != 0)
        AppendCharToParam(PARAM_SEP);

    m_iParamIndex++;

	CStringWrapper::Sprintf(rgtchTemp, "%d", iValue);
    CStringWrapper::Strcat(m_pszParam, rgtchTemp);

    return TRUE;
}

/*==========================================================================*/

BOOL CParser::PutFloatParam(float fValue)
{
    
	TCHAR rgtchTemp[80];
    double   dbl = static_cast<double>(fValue);

    if (m_iParamIndex != 0)
        AppendCharToParam(PARAM_SEP);

    m_iParamIndex++;
    
	CStringWrapper::Sprintf(rgtchTemp, "%.6lf", dbl);
    CStringWrapper::Strcat(m_pszParam, rgtchTemp);
    
	return TRUE;
}

/*==========================================================================*/

BOOL CParser::PutStringParam(LPTSTR lptstrValue)
{
	BOOL fResult = FALSE;

    if (lptstrValue)
    {
        TCHAR *ptchNext = (TCHAR *)lptstrValue;

        if (m_iParamIndex != 0)
            AppendCharToParam(PARAM_SEP);

        m_iParamIndex++;

        AppendCharToParam(START_STRING);

        // Walk the source string and replace any END_STRING chars with
        // LITERAL/END_STRING chars...

        while(*ptchNext)
        {
            TCHAR rgtchTemp[4];

            // zero out the temp string buffer...
            rgtchTemp[0] = 0;
            rgtchTemp[1] = 0;
            rgtchTemp[2] = 0;
            rgtchTemp[3] = 0;

            if (*ptchNext == END_STRING)
            {
                AppendCharToParam(LITERAL);
            }

            CStringWrapper::Strncpy(rgtchTemp, ptchNext, 1);
            CStringWrapper::Strcat(m_pszParam, rgtchTemp);

            ptchNext = CStringWrapper::Strinc(ptchNext);
        }

        AppendCharToParam(END_STRING);

        fResult = TRUE;
    }

    return fResult;
}

/*==========================================================================*/

BOOL CParser::ReadSourceLine(LPTSTR lptstrParam)
{
    BOOL fResult = FALSE;

    if (m_hfileSource)
    {
        // Force the line to be NULL-terminated by default...
        lptstrParam[0] = 0;
        lptstrParam[1] = 0;

        fResult = TRUE;
    }
    else if (m_pvio)
    {
        HRESULT hRes = S_OK;
        BSTR bstrParamLine = NULL;
        TCHAR rgchLineName[80];

		CStringWrapper::Sprintf(rgchLineName, "Line%04d", m_iParamLineIndex+1);

        // Read from the variant info...
        hRes = m_pvio->Persist(0, rgchLineName, VT_BSTR, &bstrParamLine, NULL);

        if (SUCCEEDED(hRes) && bstrParamLine)
        {
            // Convert to LPTSTR!
#ifdef UNICODE
            CStringWrapper::Strcpy(lptstrParam, bstrParamLine);
            fResult = TRUE;
#else // !UNICODE
			int iLen = WideCharToMultiByte(CP_ACP, 
				0, 
				bstrParamLine, 
				-1,
				NULL, 
				0, 
				NULL,
				NULL);

            if (iLen < MAX_PARAM_LENGTH)
            {
                CStringWrapper::Wcstombs(lptstrParam, bstrParamLine, MAX_PARAM_LENGTH);
				WideCharToMultiByte(CP_ACP, 
					0, 
					bstrParamLine, 
					-1,
					lptstrParam, 
					MAX_PARAM_LENGTH, 
					NULL,
					NULL);
                fResult = TRUE;
            }
#endif // !UNICODE

            SysFreeString(bstrParamLine);
        }

        // Make sure to strip off any leading whitespace...
    }

    return fResult;
}

/*==========================================================================*/

BOOL CParser::WriteSourceLine(LPTSTR lptstrParam)
{
    BOOL fResult = FALSE;

    if (m_pvio && lptstrParam)
    {
        LPWSTR pwszParam = NULL;
        BSTR bstrParamLine = NULL;
        HRESULT hRes = S_OK;
        TCHAR rgchLineName[80];

        pwszParam = New WCHAR[MAX_PARAM_LENGTH];

        // Make sure our allocation succeeded
        if (NULL == pwszParam)
            return FALSE;

        CStringWrapper::Sprintf(rgchLineName, "Line%04d", m_iParamLineIndex+1);
        CStringWrapper::Memset(pwszParam, 0, MAX_PARAM_LENGTH * sizeof(WCHAR));

#ifdef UNICODE
        CStringWrapper::Strcpy(pwszParam, lptstrParam);
        fResult = TRUE;
#else // !UNICODE
        CStringWrapper::Mbstowcs(pwszParam, lptstrParam, CStringWrapper::Strlen(lptstrParam));
#endif // !UNICODE

        // Convert the lptstrParam to a BSTR...
        bstrParamLine = SysAllocString(pwszParam);

        Delete pwszParam;

        // iff the allocation worked,  persist the parameter line...
        if (bstrParamLine)
        {
            // Write to the variant info...
            hRes = m_pvio->Persist(0, rgchLineName, VT_BSTR, &bstrParamLine, NULL);

            // Return code based upon success of Persist...
            fResult = SUCCEEDED(hRes);

            // Cleanup...
            SysFreeString(bstrParamLine);
        }
    }

    return fResult;
}

/*==========================================================================*/

HRESULT CParser::AddPrimitive(LPTSTR pszLine)
{
	HRESULT hr = S_OK;
	CGraphicObject *pGraphicObject = NULL;

    m_iCurrentParamIndex = -1;
    m_lptstrCurrentParam = (LPTSTR)NULL;
	m_pszParam = pszLine;
	pGraphicObject = InstantiateObject(m_pszParam);

	if (pGraphicObject)
	{
		if (pGraphicObject->LoadObject(*this))
		{
			m_cdrgObjectInfo.Insert((LPVOID)&pGraphicObject, DRG_APPEND);
		}
		else
		{
			hr = E_FAIL;
			Delete pGraphicObject;
		}
	}
	else
	{
		hr = E_FAIL;
	}

	m_pszParam = NULL;

	return hr;
}


/*==========================================================================*/

HRESULT CParser::LoadObjectInfo(IVariantIO *pvio, 
                                BSTR bstrSourceURL, 
                                IUnknown * punkContainer,
                                BOOL       fCleanFirst)
{
    HRESULT hr = S_OK;
    BOOL fDone = FALSE;

    // Get rid of any previous object info...
    if( fCleanFirst )
        Cleanup();

	m_pszParam = New TCHAR[MAX_PARAM_LENGTH*2];

	if (NULL == m_pszParam)
		return E_OUTOFMEMORY;

    // First attempt to open the source URL...
    if (bstrSourceURL)
    {
		CURLArchive urlArchive(punkContainer);

        if( SUCCEEDED( hr = urlArchive.Create(bstrSourceURL) ) )
        {
            CStringWrapper::Memset(m_pszParam, 0, (MAX_PARAM_LENGTH*2) * sizeof(TCHAR));

            while(urlArchive.ReadLine(m_pszParam, (MAX_PARAM_LENGTH*2)))
            {
                CGraphicObject *pGraphicObject = NULL;            

                m_iCurrentParamIndex = -1;
                m_lptstrCurrentParam = (LPTSTR)NULL;

                pGraphicObject = InstantiateObject(m_pszParam);

                if (pGraphicObject)
                {
                    if (pGraphicObject->LoadObject(*this))
                    {
                        m_cdrgObjectInfo.Insert((LPVOID)&pGraphicObject, DRG_APPEND);
                    }
                    else
                    {
                        Delete pGraphicObject;
                    }
                }
            }
            
        }
        //fDone = TRUE;
    }

    // Next read the html PARAM tags...
    if (pvio && !fDone)
    {
        int iParamIndex = 0;        

        // Walk the parameter lines...
        m_pvio = pvio;
        m_iParamLineIndex = 0;

		CStringWrapper::Memset(m_pszParam, 0, (MAX_PARAM_LENGTH*2) * sizeof(TCHAR)); 

        while(ReadSourceLine(m_pszParam))
        {
            CGraphicObject *pGraphicObject = NULL;

            m_iCurrentParamIndex = -1;
            m_lptstrCurrentParam = (LPTSTR)NULL;

            pGraphicObject = InstantiateObject(m_pszParam);

            if (pGraphicObject)
            {
                if (pGraphicObject->LoadObject(*this))
                {
                    m_cdrgObjectInfo.Insert((LPVOID)&pGraphicObject, DRG_APPEND);
                }
                else
                {
#ifdef _DEBUG
					TCHAR tchLine[80];
					wsprintf(tchLine, TEXT("CParser::LoadObjectInfo - error loading on line %lu\n"), m_iParamLineIndex);
					ODS(tchLine);
#endif
                    Delete pGraphicObject;
                }
            }

			CStringWrapper::Memset(m_pszParam, 0, sizeof(m_pszParam)); // BUGBUG

            m_iParamLineIndex++;
        }

        m_pvio = NULL;
        m_iParamLineIndex = -1;
    }

	if (m_pszParam)
	{
		Delete [] m_pszParam;
		m_pszParam = NULL;
	}

    return hr;
}

/*==========================================================================*/

BOOL CParser::InsertObject(CGraphicObject *pGraphicObject)
{
	return m_cdrgObjectInfo.Insert((LPVOID)&pGraphicObject, DRG_APPEND);
}
/*==========================================================================*/

HRESULT CParser::SaveObjectInfo(IVariantIO *pvio)
{
    HRESULT hr = S_OK;

    if (pvio)
    {
		m_pszParam = New TCHAR[MAX_PARAM_LENGTH*2];

		if (NULL == m_pszParam)
			return E_OUTOFMEMORY;

        int iObjectCount = m_cdrgObjectInfo.Count();
        int iObjectIndex = 0;

        // Output the internal object info...
        m_pvio = pvio;
        m_iParamLineIndex = 0;

        while(iObjectIndex < iObjectCount)
        {
            CGraphicObject **pGraphicObject = (CGraphicObject **)m_cdrgObjectInfo.GetAt(iObjectIndex);

            // Make sure we start with an empty parameter line...
            m_pszParam[0] = 0;

            // Is the CDrg Valid?
            if (pGraphicObject && *pGraphicObject)
            {
                WORD wObjectType = (*pGraphicObject)->GetObjectType();
                BOOL fFilled     = (*pGraphicObject)->IsFilled();
                int iTableIndex = 0;
                int iTableMax   = sizeof(s_parserlookupTable) / sizeof(PARSERLOOKUP);

                // This assumes that the object was found in the
                // Parse table
                while(iTableIndex < iTableMax)
                {
                    PARSERLOOKUP *pWalker = &s_parserlookupTable[iTableIndex];

                    if (pWalker->wObjectType == wObjectType &&
                        pWalker->fFilled     == fFilled)
                    {
                        CStringWrapper::Strcpy(m_pszParam, pWalker->rgtchName);
                        AppendCharToParam(START_PARAM);
                        break;
                    }

                    iTableIndex++;
                }

                // Keep track of the parameters...
                m_iParamIndex = 0;

                if ((*pGraphicObject)->SaveObject(*this))
                {
                    AppendCharToParam(END_PARAM);
                    WriteSourceLine(m_pszParam);
                    m_iParamLineIndex ++;
                }
            }

            iObjectIndex++;
        }

        // Cleanup...
        m_pvio = NULL;
        m_iParamLineIndex = -1;
        m_iParamIndex = -1;

		if (m_pszParam)
		{
			Delete [] m_pszParam;
			m_pszParam = NULL;
		}

    }
	
    return hr;
}

/*==========================================================================*/

HRESULT CParser::PlaybackObjectInfo(IDADrawingSurface *pIDADrawingSurface, IDAStatics *pIDAStatics, BOOL fFlipCoord)
{
    HRESULT hr = S_OK;

    if (pIDADrawingSurface && pIDAStatics)
    {
        int iCount = m_cdrgObjectInfo.Count();
        int iIndex = 0;

        while(iIndex < iCount)
        {
            CGraphicObject **pGraphicObject = (CGraphicObject **)m_cdrgObjectInfo.GetAt(iIndex);

            if (pGraphicObject && *pGraphicObject)
                (*pGraphicObject)->Execute(pIDADrawingSurface, pIDAStatics, fFlipCoord);

            iIndex++;
        }
    }

    return hr;
}

/*==========================================================================*/

BOOL CParser::AnimatesOverTime(void)
{
    BOOL fResult = FALSE;

    int iCount = m_cdrgObjectInfo.Count();
    int iIndex = 0;

    while(iIndex < iCount)
    {
        CGraphicObject **pGraphicObject = (CGraphicObject **)m_cdrgObjectInfo.GetAt(iIndex);

        if (pGraphicObject && *pGraphicObject)
        {
            if ((*pGraphicObject)->AnimatesOverTime())
            {
                fResult = TRUE;
                break;
            }
        }

        iIndex++;
    }

    return fResult;
}

/*==========================================================================*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\sprite\dll.cpp ===
// dll.cpp
//
// DLL entry points etc.
//


#ifdef _DEBUG
    #pragma message("_DEBUG is defined")
#else
    #pragma message("_DEBUG isn't defined")
#endif

#ifdef _DESIGN
    #pragma message("_DESIGN is defined")
#else
    #pragma message("_DESIGN isn't defined")
#endif

#include "..\ihbase\precomp.h"

#include <initguid.h> // once per build
#include <olectl.h>
#include <daxpress.h>
#include "..\mmctl\inc\ochelp.h"
#include "..\mmctl\inc\mmctlg.h"
#include "..\ihbase\debug.h"
#include "sprite.h"
#include "sprinit.h"


//////////////////////////////////////////////////////////////////////////////
// globals
//

// general globals
HINSTANCE       g_hinst;        // DLL instance handle
ULONG           g_cLock;        // DLL lock count
ControlInfo     g_ctlinfo;      // information about the control

// #define USELOGGING

#ifdef _DEBUG
BOOL			g_fLogDebugOutput; // Controls logging of debug info
#endif

extern "C" DWORD _fltused = (DWORD)(-1);

//////////////////////////////////////////////////////////////////////////////
// DLL Initialization
//

// TODO: Modify the data in this function appropriately


//////////////////////////////////////////////////////////////////////////////
// Standard DLL Entry Points
//

BOOL WINAPI _DllMainCRTStartup(HINSTANCE hInst, DWORD dwReason,LPVOID lpreserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        TRACE("SpriteCtl DLL loaded\n"); //TODO: Modify me
        g_hinst = hInst;
#ifdef _DEBUG
#ifdef USELOGGING
		g_fLogDebugOutput = TRUE;
#else
		g_fLogDebugOutput = FALSE;
#endif // USELOGGING
#endif // USELOGGING

        InitSpriteControlInfo(hInst, &g_ctlinfo, AllocSpriteControl);
    }
    else
    if (dwReason == DLL_PROCESS_DETACH)
    {
        TRACE("SpriteCtl DLL unloaded\n"); //TODO: Modify me
    }

    return TRUE;
}


STDAPI DllRegisterServer(void)
{
    return RegisterControls(&g_ctlinfo, RC_REGISTER);
}


STDAPI DllUnregisterServer(void)
{
	return RegisterControls(&g_ctlinfo, RC_UNREGISTER);
}


STDAPI DllCanUnloadNow()
{
    return ((g_cLock == 0) ? S_OK : S_FALSE);
}

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppv)
{
    return HelpGetClassObject(rclsid, riid, ppv, &g_ctlinfo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\sgrfx\sgrfx.cpp ===
/*==========================================================================*\

    Module:
        sgrfx.cpp

    Author:
        IHammer Team (SimonB)

    Created:
        June 1997

    Description:
        Implements any control-specific members, as well as the control's interface

    History:
        06-01-1997  Created

\*==========================================================================*/

#include "..\ihbase\precomp.h"
#include "..\ihbase\debug.h"
#include "..\ihbase\utils.h"
#include "sgrfx.h"
#include "sgevent.h"
#include "ddrawex.h"
#include <htmlfilter.h>
#include "urlmon.h"

#ifdef DEADCODE
/*==========================================================================*/
//
// The is a callback that will inform us if the mouse is inside or outside
// of the image
//
/*==========================================================================*/

extern ControlInfo     g_ctlinfoSG;

CPickCallback::CPickCallback(
    IConnectionPointHelper* pconpt,
    IDAStatics* pstatics,
    IDAImage* pimage,
    boolean& fOnWindowLoadFired,
    HRESULT& hr
) :
    m_pstatics(pstatics),
    m_pimage(pimage),
    m_pconpt(pconpt),
    m_fOnWindowLoadFired(fOnWindowLoadFired),
    m_cRef(1),
    m_bInside(false)
{
    ::InterlockedIncrement((long *)&(g_ctlinfoSG.pcLock));

    CComPtr<IDAPickableResult> ppickResult;

    if (FAILED(hr = m_pimage->Pickable(&ppickResult))) return;
    if (FAILED(hr = ppickResult->get_Image(&m_pimagePick))) return;
    if (FAILED(hr = ppickResult->get_PickEvent(&m_peventEnter))) return;
    if (FAILED(hr = m_pstatics->NotEvent(m_peventEnter, &m_peventLeave))) return;
}

CPickCallback::~CPickCallback()
{
    ::InterlockedDecrement((long *)&(g_ctlinfoSG.pcLock));
}

HRESULT CPickCallback::GetImage(IDABehavior** ppimage)
{
    CComPtr<IDAEvent> pevent;

    if (m_bInside) {
        pevent = m_peventLeave;
    } else {
        pevent = m_peventEnter;
    }

    return m_pstatics->UntilNotify(m_pimagePick, pevent, this, ppimage);
}

HRESULT STDMETHODCALLTYPE CPickCallback::Notify(
        IDABehavior __RPC_FAR *eventData,
        IDABehavior __RPC_FAR *curRunningBvr,
        IDAView __RPC_FAR *curView,
        IDABehavior __RPC_FAR *__RPC_FAR *ppBvr)
{
    if (m_bInside) {
        m_bInside = false;
        if (m_fOnWindowLoadFired) {
            m_pconpt->FireEvent(DISPID_SG_EVENT_MOUSELEAVE, 0);
        }
    } else {
        m_bInside = true;
        if (m_fOnWindowLoadFired) {
            m_pconpt->FireEvent(DISPID_SG_EVENT_MOUSEENTER, 0);
        }
    }

    return GetImage(ppBvr);
}

/*==========================================================================*/

///// IUnknown
HRESULT STDMETHODCALLTYPE CPickCallback::QueryInterface(
    REFIID riid,
    void __RPC_FAR *__RPC_FAR *ppvObject)
{
    if (NULL == ppvObject)
        return E_POINTER;

    HRESULT hr = E_NOINTERFACE;

    *ppvObject = NULL;

    if (IsEqualGUID(riid, IID_IDAUntilNotifier))
    {
        IDAUntilNotifier *pThis = this;

        *ppvObject = (LPVOID) pThis;
        AddRef(); // Since we only provide one interface, we can just AddRef here

        hr = S_OK;
    }

    return hr;
}

/*==========================================================================*/

ULONG STDMETHODCALLTYPE CPickCallback::AddRef(void)
{
    return ::InterlockedIncrement((LONG *)(&m_cRef));
}

/*==========================================================================*/

ULONG STDMETHODCALLTYPE CPickCallback::Release(void)
{
    ::InterlockedDecrement((LONG *)(&m_cRef));
    if (m_cRef == 0)
    {
        Delete this;
        return 0;
    }

    return m_cRef;
}
#endif // DEADCODE

/*==========================================================================*/
//
// CSGrfx Creation/Destruction
//

LPUNKNOWN __stdcall AllocSGControl(LPUNKNOWN punkOuter)
{
    // Allocate object
    HRESULT hr;
    CSGrfx *pthis = New CSGrfx(punkOuter, &hr);

    if (pthis == NULL)
        return NULL;

    if (FAILED(hr))
    {
        delete pthis;
        return NULL;
    }

    // return an IUnknown pointer to the object
    return (LPUNKNOWN) (INonDelegatingUnknown *) pthis;
}

/*==========================================================================*/
//
// Beginning of class implementation
//

CSGrfx::CSGrfx(IUnknown *punkOuter, HRESULT *phr):
    CMyIHBaseCtl(punkOuter, phr),
    m_fOnWindowLoadFired(false)
{
    // Initialise members
    m_pwszSourceURL = NULL;
    m_CoordSystem = LeftHanded;
    m_fMouseEventsEnabled = FALSE;
    m_iExtentTop = 0;
    m_iExtentLeft = 0;
    m_iExtentWidth = 0;
    m_iExtentHeight = 0;
    m_fHighQuality = FALSE;
    m_fStarted = FALSE;
    m_fHQStarted = FALSE;
    m_fPersistExtents = FALSE;
    m_fIgnoreExtentWH = TRUE;
    m_fMustSetExtent = FALSE;
    m_fSetExtentsInSetIdentity = FALSE;
    m_fUpdateDrawingSurface = TRUE;
    m_fShowTiming = FALSE;
    m_fPreserveAspectRatio = TRUE;
    m_fRectsSetOnce = false;
    m_fNeedOnTimer = false;
    m_fInside = FALSE;
    m_fExtentTopSet = false; 
    m_fExtentLeftSet = false; 
    m_fExtentWidthSet = false; 
    m_fExtentHeightSet = false;

    ZeroMemory(&m_rcLastRectScaled, sizeof(m_rcLastRectScaled));

 // Tie into the DANIM DLL now...
    if (phr)
    {
        if (SUCCEEDED(*phr))
        {
            *phr = CoCreateInstance(
                CLSID_DAView,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IDAView,
                (void **) &m_ViewPtr);

            if (SUCCEEDED(*phr))
            {
#ifdef DEADCODE
                //
                // move the mouse completely outside of the window
                //

                m_ViewPtr->OnMouseMove(
                    0,
                    -1000000,
                    -1000000,
                    0
                );
#endif // DEADCODE

                // turn off Bitmap caching for SG controls, since trident changes the bitmap depth

                IDAPreferences *pPref = NULL;
                VARIANT vOptVal;

                VariantInit (&vOptVal);

                // from danim\src\appel\privinc\opt.h & appel\privinc\privpref.cpp

                BSTR bstr = SysAllocString(L"BitmapCachingOptimization");

                vOptVal.boolVal = VARIANT_FALSE;

                *phr = m_ViewPtr->get_Preferences(&pPref);

                if (SUCCEEDED(*phr))
                {
                    pPref->PutPreference(bstr, vOptVal);
                    pPref->Propagate();
                    pPref->Release();
                    pPref = NULL;
                }
                
                *phr = CoCreateInstance(
                    CLSID_DAView,
                    NULL,
                    CLSCTX_INPROC_SERVER,
                    IID_IDAView,
                    (void **)&m_HQViewPtr);

                if (SUCCEEDED(*phr)) {
                    *phr = m_HQViewPtr->get_Preferences(&pPref);

                    if (SUCCEEDED(*phr))
                    {
                        pPref->PutPreference(bstr, vOptVal);
                        pPref->Propagate();
                        pPref->Release();
                        pPref = NULL;
                    }
                }
                SysFreeString( bstr );

            }
        }

        if (SUCCEEDED(*phr))
        {
            *phr = ::CoCreateInstance(
                CLSID_DAStatics,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IDAStatics,
                (void **) &m_StaticsPtr);
        }

        if (SUCCEEDED(*phr))
        {
            VARIANT_BOOL vBool = VARIANT_TRUE;

            *phr = m_StaticsPtr->put_PixelConstructionMode(vBool);

            if (SUCCEEDED(*phr))
                *phr = m_StaticsPtr->NewDrawingSurface(&m_DrawingSurfacePtr);
        }

        if (SUCCEEDED(*phr))
        {   m_CachedRotateTransformPtr = NULL;
            m_CachedScaleTransformPtr = NULL;
            m_CachedTranslateTransformPtr = NULL;

            if (SUCCEEDED(*phr = m_StaticsPtr->DANumber(0, &m_zero)) &&
                SUCCEEDED(*phr = m_StaticsPtr->DANumber(1, &m_one)) &&
                SUCCEEDED(*phr = m_StaticsPtr->DANumber(-1, &m_negOne)) &&
                SUCCEEDED(*phr = m_StaticsPtr->get_XVector3(&m_xVector3)) &&
                SUCCEEDED(*phr = m_StaticsPtr->get_YVector3(&m_yVector3)) &&
                SUCCEEDED(*phr = m_StaticsPtr->get_ZVector3(&m_zVector3)) &&
                SUCCEEDED(*phr = m_StaticsPtr->get_IdentityTransform2(&m_identityXform2)) &&
                SUCCEEDED(*phr = m_StaticsPtr->Scale2Anim(m_one, m_negOne, &m_yFlipXform2)))
            {
                // All happy here...
            }

            m_clocker.SetSink((CClockerSink *)this);
        }
    }
}

/*==========================================================================*/

CSGrfx::~CSGrfx()
{
    StopModel();

    if (m_pwszSourceURL)
    {
        Delete [] m_pwszSourceURL;
        m_pwszSourceURL = NULL;
    }
    FreeHQBitmap();
}

/*==========================================================================*/

STDMETHODIMP CSGrfx::NonDelegatingQueryInterface(REFIID riid, LPVOID *ppv)
{
    HRESULT hr = S_OK;
    BOOL fMustAddRef = FALSE;

    if (ppv)
        *ppv = NULL;
    else
        return E_POINTER;

#ifdef _DEBUG
    char ach[200];
    TRACE("SGrfx::QI('%s')\n", DebugIIDName(riid, ach));
#endif

    if ((IsEqualIID(riid, IID_ISGrfxCtl)) || (IsEqualIID(riid, IID_IDispatch)))
    {
        if (NULL == m_pTypeInfo)
        {
            HRESULT hr;

            // Load the typelib
            hr = LoadTypeInfo(&m_pTypeInfo, &m_pTypeLib, IID_ISGrfxCtl, LIBID_DAExpressLib, NULL);

            if (FAILED(hr))
            {
                m_pTypeInfo = NULL;
            }
            else
                *ppv = (ISGrfxCtl *) this;

        }
        else
            *ppv = (ISGrfxCtl *) this;

    }
    else // Call into the base class
    {
        DEBUGLOG(TEXT("Delegating QI to CIHBaseCtl\n"));
        return CMyIHBaseCtl::NonDelegatingQueryInterface(riid, ppv);
    }

    if (NULL != *ppv)
    {
        DEBUGLOG("CSGrfx: Interface supported in control class\n");
        ((IUnknown *) *ppv)->AddRef();
    }

    return hr;
}

/*==========================================================================*/

STDMETHODIMP CSGrfx::SetObjectRects(LPCRECT lprcPosRect, LPCRECT lprcClipRect)
{
    double dblScaleX = 1.0f, dblScaleY = 1.0f;
    bool fIgnoreScale = false;
    RECT rectOld = m_rcBounds;

    if (m_fSetExtentsInSetIdentity)
    {
        if (m_fRectsSetOnce)
        {
            // If we are going to have to scale to 0 in any dimension, we don't want to do it
            fIgnoreScale = ( (1 > (lprcPosRect->right - lprcPosRect->left)) || (1 > (lprcPosRect->bottom - lprcPosRect->top)) );
        }
        else
        {
            // Initialise the first time through ...
            m_rcLastRectScaled = *lprcPosRect;
        }
    }

    HRESULT hRes = CMyIHBaseCtl::SetObjectRects(lprcPosRect, lprcClipRect);

    if (SUCCEEDED(hRes))
    {
        if (!EqualRect(&rectOld, &m_rcBounds))
        {
            // We have to let go of the bitmap at this point...
            FreeHQBitmap();
        }

        if (m_fMustSetExtent)
        {
            m_fMustSetExtent = FALSE; // Make sure we don't set extents again
            if (!m_fDesignMode)
                SetIdentity();
        }

        // Scale when the rect changes, if necessary
        if (m_fSetExtentsInSetIdentity && m_fRectsSetOnce)
        {
            if (!fIgnoreScale)
            {
                dblScaleX = ((double)(lprcPosRect->right - lprcPosRect->left) / (double)(m_rcLastRectScaled.right - m_rcLastRectScaled.left));
                dblScaleY = ((double)(lprcPosRect->bottom - lprcPosRect->top) / (double)(m_rcLastRectScaled.bottom - m_rcLastRectScaled.top));

                if (dblScaleX > 0.0f && dblScaleY > 0.0f)
                {
                    VARIANT vaEmpty;

                    vaEmpty.vt = VT_ERROR;
                    vaEmpty.scode = DISP_E_PARAMNOTFOUND;

                    Scale(dblScaleX, dblScaleY, 1.0f, vaEmpty);

                    m_rcLastRectScaled = *lprcPosRect;
                }
            }
        }

        m_fRectsSetOnce = true;
    }

    return hRes;
}

/*==========================================================================*/

STDMETHODIMP CSGrfx::QueryHitPoint(
    DWORD dwAspect,
    LPCRECT prcBounds,
    POINT ptLoc,
    LONG lCloseHint,
    DWORD* pHitResult)
{
    HRESULT hr = E_POINTER;

    if (pHitResult)
    {
        if ((!m_fDesignMode) && (NULL != prcBounds))
        {
            *pHitResult = HITRESULT_OUTSIDE;

            switch (dwAspect)
            {
                case DVASPECT_CONTENT:
                    // Intentional fall-through

                case DVASPECT_TRANSPARENT:
                {
                    if (FAILED(m_ViewPtr->QueryHitPoint(
                        dwAspect,
                        prcBounds,
                        ptLoc,
                        lCloseHint,
                        pHitResult)))
                    {
                        *pHitResult = HITRESULT_OUTSIDE;
                    }
                    hr = S_OK;
                }
                break;

                default:
                    hr = E_FAIL;
                break;
            }
        }
        else if (m_fDesignMode)
        {
            *pHitResult = HITRESULT_HIT;
            hr = S_OK;
        }
        else
        {
            hr = E_POINTER;
        }
    }

    return hr;
}

/*==========================================================================*/

BOOL CSGrfx::InsideImage(POINT ptXY)
{
    BOOL fResult = FALSE;
    DWORD dwHitResult = HITRESULT_OUTSIDE;
    RECT rectBounds = m_rcBounds;

    (void)m_ViewPtr->QueryHitPoint(DVASPECT_TRANSPARENT, &rectBounds, ptXY, 0, &dwHitResult);

    if (dwHitResult != HITRESULT_OUTSIDE)
        fResult = TRUE;

    return fResult;
}

/*==========================================================================*/

STDMETHODIMP CSGrfx::OnWindowMessage(UINT msg, WPARAM wParam, LPARAM lParam, LRESULT *plResult)
{
    HRESULT hr = S_FALSE;

    if (m_fMouseEventsEnabled)
    {
        POINT ptXY;
        long lKeyState = 0;
        BOOL fInside = m_fInside;

#ifndef WM_MOUSEHOVER
#define WM_MOUSEHOVER 0x02a1
#endif
#ifndef WM_MOUSELEAVE
#define WM_MOUSELEAVE 0x02a3
#endif
        if (msg >= WM_MOUSEFIRST && msg <= WM_MOUSELAST)
        {
            // Note that this is only valid for WM_MOUSEXXXX messages.
            ptXY.x = LOWORD(lParam);
            ptXY.y = HIWORD(lParam);

            // Get the Keystate set up
            if (wParam & MK_CONTROL)
                lKeyState += KEYSTATE_CTRL;

            if (wParam & MK_SHIFT)
                lKeyState += KEYSTATE_SHIFT;

            if (GetAsyncKeyState(VK_MENU))
                lKeyState += KEYSTATE_ALT;

            m_fInside = InsideImage(ptXY);
        }

        switch (msg)
        {
            case WM_MOUSELEAVE:
                m_fInside = FALSE;
                hr = S_OK;
            break;

            case WM_MOUSEMOVE:
            {
                // Need to get button state...
                long iButton=0;

                if (wParam & MK_LBUTTON)
                    iButton += MOUSEBUTTON_LEFT;

                if (wParam & MK_MBUTTON)
                    iButton += MOUSEBUTTON_MIDDLE;

                if (wParam & MK_RBUTTON)
                    iButton += MOUSEBUTTON_RIGHT;

                FIRE_MOUSEMOVE(m_pconpt, iButton, lKeyState, LOWORD(lParam), HIWORD(lParam));
                hr = S_OK;
            }
            break;

            case WM_RBUTTONDOWN:
            {
                if (m_fInside)
                {
                    FIRE_MOUSEDOWN(m_pconpt, MOUSEBUTTON_RIGHT, lKeyState, LOWORD(lParam), HIWORD(lParam));
                }
                hr = S_OK;
            }
            break;

            case WM_MBUTTONDOWN:
            {
                if (m_fInside)
                {
                    FIRE_MOUSEDOWN(m_pconpt, MOUSEBUTTON_MIDDLE, lKeyState, LOWORD(lParam), HIWORD(lParam));
                }
                hr = S_OK;
            }
            break;

            case WM_LBUTTONDOWN:
            {
                if (m_fInside)
                {
                    FIRE_MOUSEDOWN(m_pconpt, MOUSEBUTTON_LEFT, lKeyState, LOWORD(lParam), HIWORD(lParam));
                }
                hr = S_OK;
            }
            break;

            case WM_RBUTTONUP:
            {
                if (m_fInside)
                {
                    FIRE_MOUSEUP(m_pconpt, MOUSEBUTTON_RIGHT, lKeyState, LOWORD(lParam), HIWORD(lParam));
                }
                hr = S_OK;
            }
            break;

            case WM_MBUTTONUP:
            {
                if (m_fInside)
                {
                    FIRE_MOUSEUP(m_pconpt, MOUSEBUTTON_MIDDLE, lKeyState, LOWORD(lParam), HIWORD(lParam));
                }
                hr = S_OK;
            }
            break;

            case WM_LBUTTONUP:
            {
                if (m_fInside)
                {
                    FIRE_MOUSEUP(m_pconpt, MOUSEBUTTON_LEFT, lKeyState, LOWORD(lParam), HIWORD(lParam));
                    FIRE_CLICK(m_pconpt);
                }
                hr = S_OK;
            }
            break;

            case WM_LBUTTONDBLCLK:
            {
                if (m_fInside)
                {
                    FIRE_DBLCLICK(m_pconpt);
                }
                hr = S_OK;
            }
            break;
        }

        if (fInside != m_fInside)
        {
            if (m_fOnWindowLoadFired)
            {
                if (m_fInside)
                {
                    m_pconpt->FireEvent(DISPID_SG_EVENT_MOUSEENTER, 0);
                }
                else
                {
                    m_pconpt->FireEvent(DISPID_SG_EVENT_MOUSELEAVE, 0);
                }
            }
        }
    }

    return hr;
}

/*==========================================================================*/

STDMETHODIMP CSGrfx::DoPersist(IVariantIO* pvio, DWORD dwFlags)
{
    HRESULT hr = S_OK;
    BSTR bstrSourceURL = NULL;

    BOOL fIsLoading = (S_OK == pvio->IsLoading());

    // Are we saving ?  If so, convert to BSTR
    if (!fIsLoading)
    {
        bstrSourceURL = SysAllocString(m_pwszSourceURL);
    }

    // load or save control properties
    if (FAILED(hr = pvio->Persist(0,
            "SourceURL", VT_BSTR, &bstrSourceURL,
            "CoordinateSystem", VT_I4, &m_CoordSystem,
            "MouseEventsEnabled", VT_BOOL, &m_fMouseEventsEnabled,
            "HighQuality", VT_BOOL, &m_fHighQuality,
            "PreserveAspectRatio", VT_BOOL, &m_fPreserveAspectRatio,
            NULL)))
        return hr;

    // Did we load ?
    if (fIsLoading)
    {
        HRESULT hResWidth = S_FALSE;
        HRESULT hResHeight = S_FALSE;

        // Wipe any previous data...
        m_cparser.Cleanup();

        hResWidth = pvio->Persist(0,
                "ExtentWidth", VT_I4, &m_iExtentWidth,
                NULL);

        hResHeight = pvio->Persist(0,
            "ExtentHeight", VT_I4, &m_iExtentHeight,
            NULL);

        hr = pvio->Persist(0,
            "ExtentTop", VT_I4, &m_iExtentTop,
            NULL);

        if (S_OK == hr)
        {
            hr = pvio->Persist(0,
                "ExtentLeft", VT_I4, &m_iExtentLeft,
                NULL);

            m_fPersistExtents = (SUCCEEDED(hr));
        }

        // Debugging helper...
        m_fShowTiming = FALSE;
        pvio->Persist(0, "ShowTiming", VT_BOOL, &m_fShowTiming, NULL);

        // Only set the extents if we read in both points, and they are valid
        // hRes MUST be successful, and hResWidth must equal hResHeight
        m_fMustSetExtent = ( (S_OK == hr) && (hResWidth == hResHeight) );
        m_fSetExtentsInSetIdentity = m_fMustSetExtent;

        m_fIgnoreExtentWH = ( (S_OK != hr) || (S_OK != hResWidth) || (S_OK != hResHeight) );

        // Invert for right-handed co-ordinate systems
        if ( (m_fMustSetExtent) && (m_CoordSystem == RightHanded) )
            m_iExtentHeight = -m_iExtentHeight;


#ifdef _DEBUG
        if (hResWidth != hResHeight)
            DEBUGLOG(TEXT("ExtentWidth and ExtentHeight both have to be specified, or not specified\n"));
#endif

        // Explictly disable drawing surface updates..
        m_fUpdateDrawingSurface = FALSE;

        // We loaded, so set the member variables to the appropriate values
        put_SourceURL(bstrSourceURL);

        // Explictly enable drawing surface updates..
        m_fUpdateDrawingSurface = TRUE;

        // Call the parser to instantiate the persisted primitives...
        m_cparser.LoadObjectInfo(pvio, NULL, NULL, FALSE);

        // Make sure to re-initialize the drawing state...
        InitializeSurface();

        // Finally, load the objects into our DrawingSurface...
        m_cparser.PlaybackObjectInfo(m_DrawingSurfacePtr, m_StaticsPtr, m_CoordSystem == LeftHanded);

        if (!m_fNeedOnTimer && m_cparser.AnimatesOverTime())
            m_fNeedOnTimer = TRUE;

        // Force the image to be updated...
        hr = UpdateImage(NULL, TRUE);

        // Make sure to set the proper identity matrix up...
        SetIdentity();
    }
    else
    {
        // Persist Top and Left if the loading code says we should, or if one was set through
        // properties.  It doesn't make sense to persist only one 
        if ( m_fPersistExtents || m_fExtentTopSet || m_fExtentLeftSet )
            hr = pvio->Persist(0,
                    "ExtentTop", VT_I4, &m_iExtentTop,
                    "ExtentLeft", VT_I4, &m_iExtentLeft,
                    NULL);

        // If the user didn't specify width and height, we take that to mean that
        // they want the defaults (ie the control's witdh and height as specified
        // by the container.  To preserve that, we don't i) change the value of
        // the member  variables unless the user sets them and ii) we don't persist
        // anything for those properties if they are set to 0

        // Also, if this is a design-time scenario and the user has set extents through the put_ methods,
        // they have to have set both width and height, as well as either of Top and Left.


        if (!m_fIgnoreExtentWH || ( (m_fExtentWidthSet && m_fExtentHeightSet) && (m_fExtentTopSet || m_fExtentLeftSet) ))
            hr = pvio->Persist(0,
                "ExtentWidth", VT_I4, &m_iExtentWidth,
                "ExtentHeight", VT_I4, &m_iExtentHeight,
                NULL);

        m_cparser.SaveObjectInfo( pvio );
    }

    // At this point, it's safe to free the BSTR
    if (bstrSourceURL)
        SysFreeString(bstrSourceURL);

    // if any properties changed, redraw the control
    if (SUCCEEDED(hr))
    {
        // If we are not active, we can't invalidate, so delay it if necessary
        if ( (m_fControlIsActive) && (m_poipsw != NULL) )
            m_poipsw->InvalidateRect(NULL, TRUE);
        else
            m_fInvalidateWhenActivated = TRUE;
    }
    // clear the dirty bit if requested
    if (dwFlags & PVIO_CLEARDIRTY)
        m_fDirty = FALSE;

    return S_OK;
}

/*==========================================================================*/
//
// IDispatch Implementation
//

STDMETHODIMP CSGrfx::GetTypeInfoCount(UINT *pctinfo)
{
    *pctinfo = 1;
    return S_OK;
}

/*==========================================================================*/

STDMETHODIMP CSGrfx::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)
{
    *pptinfo = NULL;

    if(itinfo != 0)
        return ResultFromScode(DISP_E_BADINDEX);

    m_pTypeInfo->AddRef();
    *pptinfo = m_pTypeInfo;

    return NOERROR;
}

/*==========================================================================*/

STDMETHODIMP CSGrfx::GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames,
    UINT cNames, LCID lcid, DISPID *rgdispid)
{
    return DispGetIDsOfNames(m_pTypeInfo, rgszNames, cNames, rgdispid);
}

/*==========================================================================*/

STDMETHODIMP CSGrfx::Invoke(DISPID dispidMember, REFIID riid, LCID lcid,
    WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult,
    EXCEPINFO *pexcepinfo, UINT *puArgErr)
{
    HRESULT hr;

    hr = DispInvoke((ISGrfxCtl *)this,
        m_pTypeInfo,
        dispidMember, wFlags, pdispparams,
        pvarResult, pexcepinfo, puArgErr);

    return hr;
}

/*==========================================================================*/

STDMETHODIMP CSGrfx::SetClientSite(IOleClientSite *pClientSite)
{
    HRESULT hr = CMyIHBaseCtl::SetClientSite(pClientSite);

    if (m_ViewPtr)
    {
        m_ViewPtr->put_ClientSite(pClientSite);
    }
    m_clocker.SetHost(pClientSite);
    m_StaticsPtr->put_ClientSite(pClientSite);
    m_ViewPtr->put_ClientSite(pClientSite);

    if (!pClientSite)
        StopModel();

    return hr;
}

/*==========================================================================*/

STDMETHODIMP CSGrfx::Draw(DWORD dwDrawAspect, LONG lindex, void *pvAspect,
     DVTARGETDEVICE *ptd, HDC hdcTargetDev, HDC hdcDraw,
     LPCRECTL lprcBounds, LPCRECTL lprcWBounds,
     BOOL (__stdcall *pfnContinue)(ULONG_PTR dwContinue), ULONG_PTR dwContinue)
{
    int iSaveContext = 0;
    RECT rectBounds = m_rcBounds;
    RECT rcSavedBounds = m_rcBounds;
    BOOL fPainted = FALSE;
    DWORD dwTickStart = 0;
    double dblScaleX = 1.0f;
    double dblScaleY = 1.0f;
    boolean fScaled = false;

    if(hdcDraw==NULL)
      return E_INVALIDARG;

    if (m_fShowTiming)
        dwTickStart = GetTickCount();

    iSaveContext = ::SaveDC(hdcDraw);

    if (m_fHighQuality && !lprcBounds) 
    {
        // Make sure that everything is started properly...
        if (!m_fStarted)
        {
            RECT rectDummy;

            rectDummy.top=0;
            rectDummy.left=0;
            rectDummy.right=1;
            rectDummy.bottom=1;

            PaintToDC(hdcDraw, &rectDummy, FALSE);
        }

        // High-quality paint path...
        fPainted = PaintHQBitmap(hdcDraw);
    }

    if (!fPainted)
    {
        // Get scaling and bounds set up for the case where we are printing
        if (NULL != lprcBounds)
        {
            m_rcBounds.left = lprcBounds->left;
            m_rcBounds.top = lprcBounds->top;
            m_rcBounds.right = lprcBounds->right;
            m_rcBounds.bottom = lprcBounds->bottom;
            
            rectBounds = m_rcBounds;

            if (m_fMustSetExtent)
            {
                if (!m_fDesignMode)
                    SetIdentity();
            }
            else if (!m_fSetExtentsInSetIdentity)
            {
                // Scale to printer resolution
                HDC hScreenDC = ::GetDC(::GetDesktopWindow());
                int iHorzScreen = ::GetDeviceCaps(hScreenDC, LOGPIXELSX);
                int iVertScreen = ::GetDeviceCaps(hScreenDC, LOGPIXELSY);

                ::ReleaseDC(::GetDesktopWindow(), hScreenDC);

                int iHorzPrint = ::GetDeviceCaps(hdcDraw, LOGPIXELSX);
                int iVertPrint = ::GetDeviceCaps(hdcDraw, LOGPIXELSY);
                
                if (iHorzScreen && iVertScreen)
                {
                    dblScaleX = ((double)iHorzPrint / (double)iHorzScreen);
                    dblScaleY = ((double)iVertPrint / (double)iVertScreen);
               
                    if ((dblScaleX > 0) && (dblScaleY > 0))
                    {
                        VARIANT vaEmpty;

                        vaEmpty.vt = VT_ERROR;
                        vaEmpty.scode = DISP_E_PARAMNOTFOUND;

                        Scale(dblScaleX, dblScaleY, 1.0f, vaEmpty);
                        fScaled = true;
                    }
                }
            }
        }

        ::LPtoDP(hdcDraw, reinterpret_cast<LPPOINT>(&rectBounds), 2 );
        ::SetViewportOrgEx(hdcDraw, 0, 0, NULL);

        // Normal paint path...
        PaintToDC(hdcDraw, &rectBounds, FALSE);

        if (fScaled)
        {
            VARIANT vaEmpty;

            vaEmpty.vt = VT_ERROR;
            vaEmpty.scode = DISP_E_PARAMNOTFOUND;

            Scale(1 / dblScaleX, 1 / dblScaleY, 1.0f, vaEmpty);
        }

    }

    ::RestoreDC(hdcDraw, iSaveContext);

    if (m_fShowTiming)
    {
        DWORD dwTickEnd = 0;
        char rgchTicks[80];

        dwTickEnd = GetTickCount();

        wsprintf(rgchTicks, "Ticks : %ld", dwTickEnd - dwTickStart);

        TextOut(
            hdcDraw,
            m_rcBounds.left + 1, m_rcBounds.top + 1,
            rgchTicks, lstrlen(rgchTicks));
    }

    if (NULL != lprcBounds)
    {
        // Set extents back appropriately
        m_fMustSetExtent = FALSE; 
        if (!m_fDesignMode)
            SetIdentity();

        m_rcBounds = rcSavedBounds;
    }

    return S_OK;
}

/*==========================================================================*/
//
// ISGrfxCtl implementation
//

HRESULT STDMETHODCALLTYPE CSGrfx::get_SourceURL(BSTR __RPC_FAR *bstrSourceURL)
{
    HANDLENULLPOINTER(bstrSourceURL);

    if (*bstrSourceURL)
        SysFreeString(*bstrSourceURL);

    *bstrSourceURL = SysAllocString(m_pwszSourceURL);

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSGrfx::put_SourceURL(BSTR bstrSourceURL)
{
    HRESULT hr = S_OK;

    if (bstrSourceURL)
    {
        int iLen = lstrlenW(bstrSourceURL);
        LPWSTR pwszUrlToPersist = bstrSourceURL;

        // Allocate memory if necessary
        if ( (!m_pwszSourceURL) || (lstrlenW(m_pwszSourceURL) < lstrlenW(bstrSourceURL)) )
        {
            if (m_pwszSourceURL)
                Delete [] m_pwszSourceURL;

            m_pwszSourceURL = (LPWSTR) New WCHAR[lstrlenW(bstrSourceURL) + 1];

            // Return an appropriate error code if we failed
            if (!m_pwszSourceURL)
                hr = E_OUTOFMEMORY;

            m_pwszSourceURL[0] = 0;
            m_pwszSourceURL[1] = 0;
        }

        BSTRtoWideChar(bstrSourceURL, m_pwszSourceURL, iLen + 1);

        // Call the parser to instantiate the persisted primitives...
        m_cparser.LoadObjectInfo(NULL,
            pwszUrlToPersist,
            m_punkOuter,
            TRUE );

        if (m_fUpdateDrawingSurface)
        {
            // Make sure to re-initialize the drawing state...
            InitializeSurface();

            // Finally, load the objects into our DrawingSurface...
            m_cparser.PlaybackObjectInfo(m_DrawingSurfacePtr, m_StaticsPtr, m_CoordSystem == LeftHanded);

            if (!m_fNeedOnTimer && m_cparser.AnimatesOverTime())
                m_fNeedOnTimer = TRUE;

            hr = UpdateImage(NULL, TRUE);
        }
    }
    else // No string passed in, zap ours
    {
        Delete [] m_pwszSourceURL;
        m_pwszSourceURL = NULL;
    }

    return hr;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSGrfx::get_CoordinateSystem(CoordSystemConstant __RPC_FAR *CoordSystem)
{
    HANDLENULLPOINTER(CoordSystem);

    *CoordSystem = m_CoordSystem;

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSGrfx::put_CoordinateSystem(CoordSystemConstant CoordSystem)
{
    if (m_fDesignMode)
    {
        HRESULT hr = S_OK;

        m_CoordSystem = CoordSystem;

        hr = RecomposeTransform(TRUE);

        return hr;
    }
    else
    {
        return CTL_E_SETNOTSUPPORTEDATRUNTIME;
    }
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSGrfx::get_MouseEventsEnabled(VARIANT_BOOL __RPC_FAR *fEnabled)
{
    HANDLENULLPOINTER(fEnabled);

    *fEnabled = BOOL_TO_VBOOL(m_fMouseEventsEnabled);

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSGrfx::put_MouseEventsEnabled(VARIANT_BOOL fEnabled)
{
    m_fMouseEventsEnabled = VBOOL_TO_BOOL(fEnabled);

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSGrfx::get_ExtentTop(int __RPC_FAR *iExtentTop)
{
    HANDLENULLPOINTER(iExtentTop);

    *iExtentTop = m_iExtentTop;
    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSGrfx::put_ExtentTop(int iExtentTop)
{
    if (m_fDesignMode)
    {
        m_iExtentTop = iExtentTop;
        m_fExtentTopSet = true; 
        return S_OK;
    }
    else
    {
        return CTL_E_SETNOTSUPPORTEDATRUNTIME;
    }
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSGrfx::get_ExtentLeft(int __RPC_FAR *iExtentLeft)
{
    HANDLENULLPOINTER(iExtentLeft);

    *iExtentLeft = m_iExtentLeft;

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSGrfx::put_ExtentLeft(int iExtentLeft)
{
    if (m_fDesignMode)
    {
        m_iExtentLeft = iExtentLeft;
        m_fExtentLeftSet = true; 
        return S_OK;
    }
    else
    {
        return CTL_E_SETNOTSUPPORTEDATRUNTIME;
    }
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSGrfx::get_ExtentWidth(int __RPC_FAR *iExtentWidth)
{
    HANDLENULLPOINTER(iExtentWidth);

    *iExtentWidth = m_iExtentWidth;

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSGrfx::put_ExtentWidth(int iExtentWidth)
{
    if (m_fDesignMode)
    {
        // Only positive values are useful
        if (iExtentWidth > 0)
        {
            m_iExtentWidth = iExtentWidth;
            m_fExtentWidthSet = true; 
            return S_OK;
        }
        else
        {
            return DISP_E_OVERFLOW;
        }
        }
    else
    {
        return CTL_E_SETNOTSUPPORTEDATRUNTIME;
    }
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSGrfx::get_ExtentHeight(int __RPC_FAR *iExtentHeight)
{
    HANDLENULLPOINTER(iExtentHeight);

    *iExtentHeight = m_iExtentHeight;

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSGrfx::put_ExtentHeight(int iExtentHeight)
{
    if (m_fDesignMode)
    {
        // Only positive values are useful
        if (iExtentHeight > 0)
        {
            m_iExtentHeight = iExtentHeight;
            m_fExtentHeightSet = true;
            return S_OK;
        }
        else
        {
            return DISP_E_OVERFLOW;
        }
        
    }
    else
    {
        return CTL_E_SETNOTSUPPORTEDATRUNTIME;
    }
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSGrfx::get_HighQuality(VARIANT_BOOL __RPC_FAR *pfHighQuality)
{
    HANDLENULLPOINTER(pfHighQuality);

    *pfHighQuality = m_fHighQuality ? VARIANT_TRUE : VARIANT_FALSE;

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSGrfx::put_HighQuality(VARIANT_BOOL fHighQuality)
{
    // Only bother with changing and invalidating if it really has changed
    if (m_fHighQuality != VBOOL_TO_BOOL(fHighQuality))
    {
        m_fHighQuality = VBOOL_TO_BOOL(fHighQuality);

        if (!m_fDesignMode)
            InvalidateControl(NULL, TRUE);
    }

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSGrfx::get_Library(IDAStatics __RPC_FAR **ppLibrary)
{
    HANDLENULLPOINTER(ppLibrary);

    if (!m_fDesignMode)
    {
        if (m_StaticsPtr)
        {
            // AddRef since this is really a Query...
            m_StaticsPtr.p->AddRef();

            // Set the return value...
            *ppLibrary = m_StaticsPtr.p;
        }
    }
    else
    {
        return CTL_E_GETNOTSUPPORTED;
    }

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSGrfx::get_Image(IDAImage __RPC_FAR **ppImage)
{
    HRESULT hr = S_OK;

    HANDLENULLPOINTER(ppImage);

    if (!m_ImagePtr)
    {
        if (FAILED(hr = UpdateImage(NULL, FALSE)))
            return hr;
    }

    if (m_ImagePtr)
    {
        // AddRef since this is really a Query...
        m_ImagePtr.p->AddRef();

        // Set the return value...
        *ppImage = m_ImagePtr.p;
    }

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSGrfx::put_Image(IDAImage __RPC_FAR *pImage)
{
    HRESULT hr = S_OK;
    HANDLENULLPOINTER(pImage);
    CComPtr<IDAImage> ImagePtr = pImage;
    CComPtr<IDAImage> TransformedImagePtr;

    // Apply the current control transform to the image...
    if (SUCCEEDED(hr = CreateBaseTransform()) &&
        SUCCEEDED(hr = RecomposeTransform(FALSE)) &&
        SUCCEEDED(hr = ImagePtr->Transform(m_TransformPtr, &TransformedImagePtr)))
    {
        // This will free any existing image and then use
        // the one passed into this method...
        hr = UpdateImage(TransformedImagePtr, TRUE);
        m_fNeedOnTimer = true;
    }

    return hr;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSGrfx::get_Transform(IDATransform3 __RPC_FAR **ppTransform)
{
    HRESULT hr = S_OK;

    HANDLENULLPOINTER(ppTransform);

    if (!m_FullTransformPtr)
    {
        if (FAILED(hr = CreateBaseTransform()))
            return hr;
    }

    if (m_FullTransformPtr)
    {
        // AddRef since this is really a Query...
        m_FullTransformPtr.p->AddRef();

        // Set the return value...
        *ppTransform = m_FullTransformPtr.p;
    }

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSGrfx::put_Transform(IDATransform3 __RPC_FAR *pTransform)
{
    HRESULT hr = S_OK;
    HANDLENULLPOINTER(pTransform);

    // This will free the old transform and select the new one in.
    m_FullTransformPtr = pTransform;

    // Recompose with the new transform...
    hr = RecomposeTransform(TRUE);
    
    m_fNeedOnTimer = true;

    return hr;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSGrfx::get_DrawingSurface(IDADrawingSurface __RPC_FAR **ppDrawingSurface)
{
    HANDLENULLPOINTER(ppDrawingSurface);

    if (m_DrawingSurfacePtr)
    {
        // AddRef since this is really a Query...
        m_DrawingSurfacePtr.p->AddRef();

        // Set the return value...
        *ppDrawingSurface = m_DrawingSurfacePtr.p;
    }

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSGrfx::put_DrawingSurface(IDADrawingSurface __RPC_FAR *pDrawingSurface)
{
    HRESULT hr = S_OK;
    HANDLENULLPOINTER(pDrawingSurface);

    if (pDrawingSurface)
    {
        // This will free any existing drawing surface and then use
        // the one passed into this method...
        m_DrawingSurfacePtr = pDrawingSurface;

        hr = UpdateImage(NULL, TRUE);

        m_fNeedOnTimer = true;
    }

    return hr;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSGrfx::get_DrawSurface(IDADrawingSurface __RPC_FAR **ppDrawingSurface)
{
    return get_DrawingSurface(ppDrawingSurface);
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSGrfx::put_DrawSurface(IDADrawingSurface __RPC_FAR *pDrawingSurface)
{
    return put_DrawingSurface(pDrawingSurface);
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSGrfx::get_PreserveAspectRatio(VARIANT_BOOL __RPC_FAR *pfPreserve)
{
    HANDLENULLPOINTER(pfPreserve);
    *pfPreserve = BOOL_TO_VBOOL(m_fPreserveAspectRatio);

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSGrfx::put_PreserveAspectRatio(VARIANT_BOOL fPreserve)
{
    m_fPreserveAspectRatio = VBOOL_TO_BOOL(fPreserve);

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSGrfx::Clear(void)
{
    HRESULT hr = S_OK;

    if (m_DrawingSurfacePtr)
    {
        // This wipes the internal representation...
        if (SUCCEEDED(hr = InitializeSurface()) &&
            SUCCEEDED(hr = UpdateImage(NULL, TRUE)))
        {
            // No need to invalidate because UpdateImage does...
            // InvalidateControl(NULL, TRUE);
        }
    }

    return hr;
}

/*==========================================================================*/

#define CHECK(stmt) if (FAILED(hr = (stmt))) return hr;

HRESULT STDMETHODCALLTYPE CSGrfx::Rotate(double dblXRot, double dblYRot, double dblZRot, VARIANT varReserved)
{
    HRESULT hr = S_OK;

    if (dblXRot != 0.0 ||
        dblYRot != 0.0 ||
        dblZRot != 0.0)
    {   CComPtr<IDATransform3> TransformPtr;
        CComPtr<IDATransform3> ResultTransformPtr;

        if (m_CachedRotateTransformPtr != NULL &&
            dblXRot == m_dblCachedRotateX &&
            dblYRot == m_dblCachedRotateY &&
            dblZRot == m_dblCachedRotateZ)

        { TransformPtr = m_CachedRotateTransformPtr;
        } else {
          CComPtr<IDATransform3> RotateYTransformPtr;
          CComPtr<IDATransform3> RotateZTransformPtr;

          if (FAILED(hr = CreateBaseTransform()))
            return hr;

          bool setXfYet = false;

          if (dblXRot != 0.0)
            {
              // First one we'd hit, so set TransformPtr directly.
              CHECK(m_StaticsPtr->Rotate3Degrees(m_xVector3,
                                                 dblXRot,
                                                 &TransformPtr));
              setXfYet = true;
            }

          if (dblYRot != 0.0)
            {
              CHECK(m_StaticsPtr->Rotate3Degrees(m_yVector3,
                                                 dblYRot,
                                                 &RotateYTransformPtr));
              if (setXfYet) {
                CHECK(m_StaticsPtr->Compose3(RotateYTransformPtr,
                                             TransformPtr,
                                             &ResultTransformPtr));

                TransformPtr = ResultTransformPtr;
                ResultTransformPtr = NULL;
              } else {
                TransformPtr = RotateYTransformPtr;
                setXfYet = true;
              }
            }

          if (dblZRot != 0.0)
            {
              double dblVector = -1.0;

              CHECK(m_StaticsPtr->Rotate3Degrees(m_zVector3,
                                                 dblZRot * dblVector,
                                                 &RotateZTransformPtr));
              if (setXfYet) {
                CHECK(m_StaticsPtr->Compose3(RotateZTransformPtr,
                                             TransformPtr,
                                             &ResultTransformPtr));

                TransformPtr = ResultTransformPtr;
                ResultTransformPtr = NULL;
              } else {
                TransformPtr = RotateZTransformPtr;
                setXfYet = true;
              }

              ASSERT(setXfYet == true);

            }
            m_CachedRotateTransformPtr = TransformPtr;
            m_dblCachedRotateX = dblXRot;
            m_dblCachedRotateY = dblYRot;
            m_dblCachedRotateZ = dblZRot;
        } /* else */

        CHECK(m_StaticsPtr->Compose3(TransformPtr,
                                     m_FullTransformPtr,
                                     &ResultTransformPtr));

        m_FullTransformPtr = ResultTransformPtr;

        hr = RecomposeTransform(TRUE);

    }

    return hr;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSGrfx::Scale(double dblXScale, double dblYScale, double dblZScale, VARIANT varReserved)
{
    HRESULT hr = S_OK;

    if (dblXScale != 1.0 ||
        dblYScale != 1.0 ||
        dblZScale != 1.0)
    { 
      CComPtr<IDATransform3> ScaleTransformPtr;
      CComPtr<IDATransform3> ResultTransformPtr;

      CHECK(CreateBaseTransform());

       /* check whether scale transform is already cached */

      if (m_CachedScaleTransformPtr != NULL &&
          dblXScale == m_dblCachedScaleX &&
          dblYScale == m_dblCachedScaleY &&
          dblZScale == m_dblCachedScaleZ)
        { ScaleTransformPtr = m_CachedScaleTransformPtr;
        } else {
          CComPtr<IDANumber> xs, ys, zs;

          if (dblXScale == 1) {
            xs = m_one;
          } else {
            CHECK(m_StaticsPtr->DANumber(dblXScale, &xs));
          }

          if (dblYScale == 1) {
            ys = m_one;
          } else {
            CHECK(m_StaticsPtr->DANumber(dblYScale, &ys));
          }

          if (dblZScale == 1) {
            zs = m_one;
          } else {
            CHECK(m_StaticsPtr->DANumber(dblZScale, &zs));
          }
          CHECK(m_StaticsPtr->Scale3Anim(xs, ys, zs, &ScaleTransformPtr));

          /* cache scale transform */

          m_dblCachedScaleX = dblXScale;
          m_dblCachedScaleY = dblYScale;
          m_dblCachedScaleZ = dblZScale;
          m_CachedScaleTransformPtr = ScaleTransformPtr;

        } 
    
      CHECK(m_StaticsPtr->Compose3(ScaleTransformPtr, m_FullTransformPtr, &ResultTransformPtr));

      m_FullTransformPtr = ResultTransformPtr;

      hr = RecomposeTransform(TRUE);
    }

  return hr;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSGrfx::SetIdentity(void)
{
    HRESULT hr = S_OK;

    if (m_FullTransformPtr)
        m_FullTransformPtr = NULL;

    hr = RecomposeTransform(TRUE);

    if (m_fSetExtentsInSetIdentity)
        SetSGExtent();

    return hr;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSGrfx::Transform4x4(VARIANT matrix)
{
    HRESULT hr = S_OK;

    CComPtr<IDATransform3> TransformPtr;
    CComPtr<IDATransform3> ResultTransformPtr;

    if (SUCCEEDED(hr = m_StaticsPtr->Transform4x4Anim(matrix, &TransformPtr)) &&
        SUCCEEDED(hr = m_StaticsPtr->Compose3(TransformPtr, m_FullTransformPtr, &ResultTransformPtr)))
    {
        m_FullTransformPtr = ResultTransformPtr;

        hr = RecomposeTransform(TRUE);
    }

    return hr;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSGrfx::Translate(double dblXTranslate, double dblYTranslate, double dblZTranslate, VARIANT varReserved)
{
  HRESULT hr = S_OK;

  if (dblXTranslate != 0.0 ||
      dblYTranslate != 0.0 ||
      dblZTranslate != 0.0)
    {
      CComPtr<IDATransform3> TranslateTransformPtr;
      CComPtr<IDATransform3> ResultTransformPtr;

      CHECK(CreateBaseTransform());

      if (m_CachedTranslateTransformPtr != NULL &&
          dblXTranslate == m_dblCachedTranslateX &&
          dblYTranslate == m_dblCachedTranslateY &&
          dblZTranslate == m_dblCachedTranslateZ)
        { TranslateTransformPtr = m_CachedTranslateTransformPtr;
        } else {

          CComPtr<IDANumber> xs, ys, zs;

          if (m_CoordSystem == RightHanded)
            dblYTranslate = -dblYTranslate;

          if (dblXTranslate == 0.0) {
            xs = m_zero;
          } else {
            CHECK(m_StaticsPtr->DANumber(dblXTranslate, &xs));
          }

          if (dblYTranslate == 0.0) {
            ys = m_zero;
          } else {
            CHECK(m_StaticsPtr->DANumber(dblYTranslate, &ys));
          }

          if (dblZTranslate == 0.0) {
            zs = m_zero;
          } else {
            CHECK(m_StaticsPtr->DANumber(dblZTranslate, &zs));
          }

          CHECK(m_StaticsPtr->Translate3Anim(xs, ys, zs, &TranslateTransformPtr));
          m_dblCachedTranslateX = dblXTranslate;
          m_dblCachedTranslateY = dblYTranslate;
          m_dblCachedTranslateZ  = dblZTranslate;
          m_CachedTranslateTransformPtr = TranslateTransformPtr;
        } 

      if (SUCCEEDED(hr = m_StaticsPtr->Compose3(TranslateTransformPtr, m_FullTransformPtr, &ResultTransformPtr)))
        {
          m_FullTransformPtr = ResultTransformPtr;

          hr = RecomposeTransform(TRUE);
        }
    }
    return S_OK;
}

/*==========================================================================*/
#ifdef INCLUDESHEAR
HRESULT STDMETHODCALLTYPE CSGrfx::ShearX(double dblShearAmount)
{
    HRESULT hr = S_OK;

    if (dblShearAmount != 0.0)
    {
        CComPtr<IDATransform3> ShearTransformPtr;
        CComPtr<IDATransform3> ResultTransformPtr;

        if (SUCCEEDED(hr = CreateBaseTransform()) &&
            SUCCEEDED(hr = m_StaticsPtr->XShear3(dblShearAmount, 0.0, &ShearTransformPtr)) &&
            SUCCEEDED(hr = m_StaticsPtr->Compose3(ShearTransformPtr, m_FullTransformPtr, &ResultTransformPtr)))
        {
            m_FullTransformPtr = ResultTransformPtr;

            hr = RecomposeTransform(TRUE);
        }
    }

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSGrfx::ShearY(double dblShearAmount)
{
    HRESULT hr = S_OK;

    if (dblShearAmount != 0.0)
    {
        CComPtr<IDATransform3> ShearTransformPtr;
        CComPtr<IDATransform3> ResultTransformPtr;

        if (SUCCEEDED(hr = CreateBaseTransform()) &&
            SUCCEEDED(hr = m_StaticsPtr->YShear3(dblShearAmount, 0.0, &ShearTransformPtr)) &&
            SUCCEEDED(hr = m_StaticsPtr->Compose3(ShearTransformPtr, m_FullTransformPtr, &ResultTransformPtr)))
        {
            m_FullTransformPtr = ResultTransformPtr;

            hr = RecomposeTransform(TRUE);
        }
    }

    return S_OK;
}
#endif // INCLUDESHEAR
/*==========================================================================*/

HRESULT CSGrfx::InitializeSurface(void)
{
    HRESULT hr = S_FALSE;

    if (m_DrawingSurfacePtr)
    {
        CComPtr<IDAColor> LineColorPtr;
        CComPtr<IDAColor> FGColorPtr;
        CComPtr<IDAColor> BGColorPtr;
        CComPtr<IDALineStyle> LineStylePtr;
        VARIANT_BOOL vBool = VARIANT_TRUE;

        if (SUCCEEDED(m_DrawingSurfacePtr->Clear()) &&
            SUCCEEDED(m_StaticsPtr->ColorRgb255(0, 0, 0, &LineColorPtr)) &&
            SUCCEEDED(m_StaticsPtr->ColorRgb255(255, 255, 255, &FGColorPtr)) &&
            SUCCEEDED(m_StaticsPtr->ColorRgb255(255, 255, 255, &BGColorPtr)) &&
            SUCCEEDED(m_StaticsPtr->get_DefaultLineStyle(&LineStylePtr)) &&
            SUCCEEDED(m_DrawingSurfacePtr->put_LineStyle(LineStylePtr)) &&
            SUCCEEDED(m_DrawingSurfacePtr->LineColor(LineColorPtr)) &&
            SUCCEEDED(m_DrawingSurfacePtr->LineDashStyle(DASolid)) &&
            SUCCEEDED(m_DrawingSurfacePtr->LineJoinStyle(DAJoinRound)) &&
            SUCCEEDED(m_DrawingSurfacePtr->LineEndStyle(DAEndRound)) &&
            SUCCEEDED(m_DrawingSurfacePtr->put_BorderStyle(LineStylePtr)) &&
            SUCCEEDED(m_DrawingSurfacePtr->BorderColor(LineColorPtr)) &&
            SUCCEEDED(m_DrawingSurfacePtr->BorderDashStyle(DASolid)) &&
            SUCCEEDED(m_DrawingSurfacePtr->BorderJoinStyle(DAJoinRound)) &&
            SUCCEEDED(m_DrawingSurfacePtr->BorderEndStyle(DAEndRound)) &&
            SUCCEEDED(m_DrawingSurfacePtr->FillColor(FGColorPtr)) &&
            SUCCEEDED(m_DrawingSurfacePtr->SecondaryFillColor(BGColorPtr)) &&
            SUCCEEDED(m_DrawingSurfacePtr->FillStyle(1)) &&
            SUCCEEDED(m_DrawingSurfacePtr->put_HatchFillTransparent(vBool)))
        {
            hr = S_OK;
        }
    }

    return hr;
}

/*==========================================================================*/

STDMETHODIMP CSGrfx::PaintToDC(HDC hdcDraw, LPRECT lprcBounds, BOOL fBW)
{
    HRESULT hr = S_OK;

    CComPtr<IDirectDrawSurface> DDrawSurfPtr;
    long lSurfaceLock = 0;

    if (!lprcBounds)
        lprcBounds = &m_rcBounds;

    if (IsRectEmpty(&m_rcBounds))
        return S_OK;

    if (!m_ServiceProviderPtr)
    {
        if (m_pocs)
        {
            // It's OK if this fails...
            hr = m_pocs->QueryInterface(IID_IServiceProvider, (LPVOID *)&m_ServiceProviderPtr);
        }
    }

    if ((!m_DirectDraw3Ptr) && (m_ServiceProviderPtr))
    {
        // It's OK if this fails...
        hr = m_ServiceProviderPtr->QueryService(
            SID_SDirectDraw3,
            IID_IDirectDraw3,
            (LPVOID *)&m_DirectDraw3Ptr);
    }

    if (m_DirectDraw3Ptr)
    {
        ASSERT(hdcDraw!=NULL && "Error, NULL hdcDraw in PaintToDC!!!");
        // Use DirectDraw 3 rendering...
        if (SUCCEEDED(hr = m_DirectDraw3Ptr->GetSurfaceFromDC(hdcDraw, &DDrawSurfPtr)))
        {
            if (FAILED(hr = m_ViewPtr->put_IDirectDrawSurface(DDrawSurfPtr)))
            {
                return hr;
            }

            if (FAILED(hr = m_ViewPtr->put_CompositeDirectlyToTarget(TRUE)))
            {
                return hr;
            }
        }
        else
        {
            // Fall back to generic HDC rendering services...
            if (FAILED(hr = m_ViewPtr->put_DC(hdcDraw)))
            {
                return hr;
            }
        }
    }
    else
    {
        // Use generic HDC rendering services...
        if (FAILED(hr = m_ViewPtr->put_DC(hdcDraw)))
        {
            return hr;
        }
    }

    if (FAILED(hr = m_ViewPtr->SetViewport(
        lprcBounds->left,
        lprcBounds->top,
        lprcBounds->right - lprcBounds->left,
        lprcBounds->bottom - lprcBounds->top)))
    {
        return hr;
    }

    //
    // From the HDC, get the clip rect (should be region) in
    // DC coords and convert to Device coords
    //
    RECT rcClip;  // in dc coords
    GetClipBox(hdcDraw, &rcClip);
    LPtoDP(hdcDraw, (POINT *) &rcClip, 2);

    if (FAILED(hr = m_ViewPtr->RePaint(
        rcClip.left,
        rcClip.top,
        rcClip.right-rcClip.left,
        rcClip.bottom-rcClip.top)))
    {
        return hr;
    }

    if (FAILED(hr = m_ViewPtr->SetClipRect(
        rcClip.left,
        rcClip.top,
        rcClip.right - rcClip.left,
        rcClip.bottom - rcClip.top)))
    {
        return hr;
    }

    if (!m_fStarted)
        StartModel();

    if (m_fStarted)
    {
        VARIANT_BOOL vBool;

        // Set the current time...
        hr = m_ViewPtr->Tick(m_dblTime, &vBool);

        // Finally,  render into the DC (or DirectDraw Surface)...
        hr = m_ViewPtr->Render();
    }

    if (DDrawSurfPtr)
    {
        if (FAILED(hr = m_ViewPtr->put_IDirectDrawSurface(NULL)))
        {
            return hr;
        }
    }

    return hr;
}

/*==========================================================================*/

DWORD CSGrfx::GetCurrTimeInMillis()
{
    return timeGetTime();
}

/*==========================================================================*/

STDMETHODIMP CSGrfx::InvalidateControl(LPCRECT pRect, BOOL fErase)
{
    if (m_fStarted)
    {
        RECT rectPaint;

        if (pRect)
            rectPaint = *pRect;
        else
            rectPaint = m_rcBounds;
    }

    if (NULL != m_poipsw) // Make sure we have a site - don't crash IE 3.0
    {
        if (m_fControlIsActive)
            m_poipsw->InvalidateRect(pRect, fErase);
        else
            m_fInvalidateWhenActivated = TRUE;
    }

    return S_OK;
}

/*==========================================================================*/

void CSGrfx::SetSGExtent()
{
    float fltScaleRatioX = 0.0f, fltScaleRatioY = 0.0f, fltScaleRatio = 0.0f;
    VARIANT vaDummy;

    // Strictly speaking we don't need to do this, because the variant is totally
    // ignored, but we'll do this to be safe, in case this changes in the future
    vaDummy.vt = VT_ERROR;
    vaDummy.scode = DISP_E_PARAMNOTFOUND;

    // Figure out where to get the width and height from: either the user
    // specified it,or we use the control's width and height

    if (m_iExtentWidth == 0)
        m_iExtentWidth = m_rcBounds.right - m_rcBounds.left;

    if (m_iExtentHeight == 0)
        m_iExtentHeight = m_rcBounds.bottom - m_rcBounds.top;

    // Compute scaling factor, preserving aspect ratio
    fltScaleRatioX = ((float)(m_rcBounds.right - m_rcBounds.left) / (float)m_iExtentWidth);
    fltScaleRatioY = (float)((m_rcBounds.bottom - m_rcBounds.top) / (float)m_iExtentHeight);

    // Yranslate the origin, and scale appropriately
    Translate(
        -((float)m_iExtentLeft + ((float)m_iExtentWidth)/2),
        -((float)m_iExtentTop + ((float)m_iExtentHeight)/2),
        0.0f,
        vaDummy);

    if (m_fPreserveAspectRatio)
    {
        fltScaleRatio = (fltScaleRatioX < fltScaleRatioY) ? fltScaleRatioX : fltScaleRatioY;
        Scale(fltScaleRatio, fltScaleRatio, 1.0f, vaDummy);
    }   
    else
    {
        Scale(fltScaleRatioX, fltScaleRatioY, 1.0f, vaDummy);
    }
}

/*==========================================================================*/

HRESULT CSGrfx::CreateBaseTransform(void)
{
    HRESULT hr = S_OK;

    if (!m_FullTransformPtr)
    {
        if (SUCCEEDED(hr = m_StaticsPtr->get_IdentityTransform3(&m_FullTransformPtr)))
        {
            // Let the last hr value get returned...
        }

#if 0
        CComPtr<IDANumber>  NumberPtr;
        CComPtr<IDAVector3> VectorPtr;
        CComPtr<IDAVector3> VectorScaledPtr;

        if (SUCCEEDED(hr = m_StaticsPtr->get_Pixel(&NumberPtr)) &&
            SUCCEEDED(hr = m_StaticsPtr->Vector3(1.0, 1.0, 1.0, &VectorPtr)) &&
            SUCCEEDED(hr = VectorPtr->MulAnim(NumberPtr, &VectorScaledPtr)) &&
            SUCCEEDED(hr = m_StaticsPtr->Scale3Vector(VectorScaledPtr, &m_FullTransformPtr)))
        {
            // Let the last hr value get returned...
        }
#endif // 0
    }

    return hr;
}

/*==========================================================================*/

HRESULT CSGrfx::RecomposeTransform(BOOL fInvalidate)
{
    HRESULT hr = S_OK;
    CComPtr<IDATransform2> ResultTransformPtr;

    CHECK(CreateBaseTransform());

    CHECK(m_FullTransformPtr->ParallelTransform2(&ResultTransformPtr));

    if (!m_TransformPtr)
    {
        CComPtr<IDABehavior> bvr;

        CHECK(m_StaticsPtr->ModifiableBehavior(m_identityXform2, &bvr));
        m_TransformPtr = (IDATransform2 *) bvr.p;
    }

#if BOGUS_CODE
    // TODO: Should be able to pre-compose this guy in once, rather
    // than every frame.

    if (m_CoordSystem == LeftHanded)
    {
        CComPtr<IDATransform2> TempTransformPtr;

        // Vertically flip the coordinate space...
        CHECK(m_StaticsPtr->Compose2(m_yFlipXform2,
                                     ResultTransformPtr,
                                     &TempTransformPtr));
        ResultTransformPtr = TempTransformPtr;
    }
#endif // 0

    CHECK(m_TransformPtr->SwitchTo(ResultTransformPtr));

    if (fInvalidate)
        InvalidateControl(NULL, TRUE);

    return hr;
}

/*==========================================================================*/

HRESULT CSGrfx::UpdateImage(IDAImage *pImage, BOOL fInvalidate)
{
    HRESULT hr = S_OK;

    if (m_DrawingSurfacePtr)
    {
        // We need a transform at this point...
        if (FAILED(hr = RecomposeTransform(FALSE)))
            return hr;

        if (!m_ImagePtr)
        {
            CComPtr<IDAImage> EmptyImagePtr;
            CComPtr<IDABehavior> BehaviorPtr;

            if (FAILED(hr = m_StaticsPtr->get_EmptyImage(&EmptyImagePtr)))
                return hr;

            if (FAILED(hr = m_StaticsPtr->ModifiableBehavior(EmptyImagePtr, &BehaviorPtr)))
                return hr;

            m_ImagePtr = (IDAImage *)BehaviorPtr.p;
        }

        if (m_ImagePtr)
        {
            CComPtr<IDAImage> ImagePtr = pImage;

            if (!ImagePtr)
            {
                CComPtr<IDAImage> TransformedImagePtr;

                if (FAILED(hr = m_DrawingSurfacePtr->get_Image(&ImagePtr)))
                    return hr;

                if (FAILED(hr = ImagePtr->Transform(m_TransformPtr, &TransformedImagePtr)))
                    return hr;

                ImagePtr = TransformedImagePtr;
                TransformedImagePtr = NULL;
            }

#ifdef DEADCODE
            if (m_fMouseEventsEnabled) {
                // turn on the picking callback

                CComPtr<IDABehavior> ppickedImage;

                m_pcallback = NULL;

                // Fill in class without AddRef'ing it
                *(&m_pcallback) = New CPickCallback(m_pconpt, m_StaticsPtr, ImagePtr, m_fOnWindowLoadFired, hr);
                if (FAILED(hr)) return hr;
                if (FAILED(hr = m_pcallback->GetImage(&ppickedImage))) return hr;

                // switch to the new image

                hr = m_ImagePtr->SwitchTo(ppickedImage);
            } else {
                hr = m_ImagePtr->SwitchTo(ImagePtr);
            }
#endif // DEADCODE

            hr = m_ImagePtr->SwitchTo(ImagePtr);

            if (SUCCEEDED(hr) && fInvalidate)
                InvalidateControl(NULL, TRUE);
        }
        else
        {
            hr = E_POINTER;
        }
    }

    return hr;
}

/*==========================================================================*/

BOOL CSGrfx::StopModel(void)
{
    // Stop any currently running model...
    if (m_fStarted)
    {
        BOOL fResult = SUCCEEDED(m_ViewPtr->StopModel());

        if (!fResult)
            return fResult;

        m_clocker.Stop();

        m_fStarted = FALSE;
    }

    if (m_fHQStarted)
    {
        m_HQViewPtr->StopModel();
        m_fHQStarted = FALSE;
    }

    return TRUE;
}

/*==========================================================================*/

BOOL CSGrfx::StartModel(void)
{
    BOOL fResult = FALSE;

    if (!m_fStarted)
    {
        CComPtr<IDASound> SoundPtr;

        m_ViewPtr->put_ClientSite(m_pocs);

        if (FAILED(RecomposeTransform(FALSE)))
            return FALSE;

        if (!m_ImagePtr)
        {
            CComPtr<IDAImage> ImagePtr;
            CComPtr<IDAImage> TransformedImagePtr;

            if (FAILED(m_DrawingSurfacePtr->get_Image(&ImagePtr)))
                return FALSE;

            // Transform based upon the given image...
            if (FAILED(ImagePtr->Transform(m_TransformPtr, &TransformedImagePtr)))
                return FALSE;

            // This will m_ImagePtr->SwitchTo...
            if (FAILED(UpdateImage(TransformedImagePtr, FALSE)))
                return FALSE;
        }

        if (FAILED(m_StaticsPtr->get_Silence(&SoundPtr)))
            return FALSE;

        if (FAILED(m_ViewPtr->StartModel(m_ImagePtr, SoundPtr, 0)))
            return FALSE;

        m_dblStartTime = GetCurrTime();
        m_dblTime = 0;

        m_clocker.Start();

        m_fStarted = TRUE;

        fResult = TRUE;
    }

    return fResult;
}

/*==========================================================================*/

BOOL CSGrfx::ReStartModel(void)
{
    BOOL fResult = FALSE;

    // Stop the running model so that it will restart for the
    // next paint...
    StopModel();

    InvalidateControl(NULL, TRUE);

    return fResult;
}

/*==========================================================================*/

BOOL CSGrfx::PaintHQBitmap(HDC hdc)
{
        BOOL fRet = FALSE;
        
    // If we don't have a DC, we need to create it
        if (!m_hdcHQ)
        {
                HDC hScreenDC = ::GetDC(NULL);

                // This should create a DC with a monochrome bitmap selected into it
                m_hdcHQ = ::CreateCompatibleDC(hScreenDC);
                ::ReleaseDC(NULL, hScreenDC);

        if (m_hdcHQ)
        {
            // Create the 24-bit offscreen for HQ rendering:
            m_bmInfoHQ.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
            m_bmInfoHQ.bmiHeader.biWidth = (m_rcBounds.right - m_rcBounds.left) * HQ_FACTOR;
            m_bmInfoHQ.bmiHeader.biHeight = (m_rcBounds.bottom - m_rcBounds.top) * HQ_FACTOR;
            m_bmInfoHQ.bmiHeader.biPlanes = 1;
            m_bmInfoHQ.bmiHeader.biBitCount = 24;
            m_bmInfoHQ.bmiHeader.biCompression = BI_RGB;
            m_bmInfoHQ.bmiHeader.biSizeImage = 0;
            m_bmInfoHQ.bmiHeader.biXPelsPerMeter = 75000;
            m_bmInfoHQ.bmiHeader.biYPelsPerMeter = 75000;
            m_bmInfoHQ.bmiHeader.biClrUsed = 0;
            m_bmInfoHQ.bmiHeader.biClrImportant = 0;

            m_hbmpHQ = ::CreateDIBSection(
                m_hdcHQ,
                &m_bmInfoHQ,
                DIB_RGB_COLORS,
                (VOID **)&m_pHQDIBBits,
                0,
                0);

            if (m_hbmpHQ)
            {
                        m_hbmpHQOld = (HBITMAP)::SelectObject(m_hdcHQ, m_hbmpHQ);
                ::SetViewportOrgEx(m_hdcHQ, 0, 0, NULL);
            }
            else
            {
                ::DeleteDC(m_hdcHQ);
                m_hdcHQ = NULL;
            }
        }
        }

        if (m_hdcHQ)
        {
        RECT rcBounds = m_rcBounds;
        RECT rcClip;
        int iWidth = m_bmInfoHQ.bmiHeader.biWidth;
        int iHeight = m_bmInfoHQ.bmiHeader.biHeight;
        int iSaveContext = 0;
        int iSaveOffContext = 0;

        // Save the current device context...
        iSaveContext = ::SaveDC(hdc);
        iSaveOffContext = ::SaveDC(m_hdcHQ);

        ::OffsetViewportOrgEx(hdc, m_rcBounds.left, m_rcBounds.top, NULL);
        ::OffsetRect(&rcBounds, -m_rcBounds.left, -m_rcBounds.top);
        ::GetClipBox(hdc, &rcClip);

        ::IntersectRect(&rcClip, &rcBounds, &rcClip);

        // Make sure we have coordinates in a valid range...
        if (rcClip.left < 0)
            rcClip.left = 0;

        if (rcClip.left >= iWidth)
            rcClip.left = iWidth-1;

        if (rcClip.right < 0)
            rcClip.right = 0;

        if (rcClip.right >= iWidth)
            rcClip.right = iWidth-1;

        // Get the current background bits...
        fRet = ::StretchBlt(
            m_hdcHQ,
            0,
            0,
            (rcBounds.right  - rcBounds.left) * HQ_FACTOR,
            (rcBounds.bottom - rcBounds.top) * HQ_FACTOR,
            hdc,
            rcBounds.left,
            rcBounds.top,
            (rcBounds.right  - rcBounds.left),
            (rcBounds.bottom - rcBounds.top),
            SRCCOPY);

        if (fRet)
        {
            // Paint the source bitmap on the new HDC:
            do
            {
                CComPtr<IDAImage> ImagePtr;
                CComPtr<IDAImage> TransformedImagePtr;
                double dblCurrentTime = GetCurrTime();
                VARIANT_BOOL vBool;
                DWORD dwTickStart = 0;

                fRet = FALSE;

                if (FAILED(m_HQViewPtr->put_CompositeDirectlyToTarget(FALSE)))
                    break;

                if (FAILED(m_HQViewPtr->put_DC(m_hdcHQ)))
                    break;

                if (FAILED(m_HQViewPtr->SetViewport(
                    0,
                    0,
                    (rcBounds.right  - rcBounds.left) * HQ_FACTOR,
                    (rcBounds.bottom - rcBounds.top) * HQ_FACTOR)))
                    break;

                if (FAILED(m_ViewPtr->RePaint(
                    rcClip.left * HQ_FACTOR,
                    rcClip.top * HQ_FACTOR,
                    (rcClip.right-rcClip.left) * HQ_FACTOR,
                    (rcClip.bottom-rcClip.top) * HQ_FACTOR)))
                    break;

                if (FAILED(m_HQViewPtr->SetClipRect(
                    rcClip.left * HQ_FACTOR,
                    rcClip.top * HQ_FACTOR,
                    (rcClip.right-rcClip.left) * HQ_FACTOR,
                    (rcClip.bottom-rcClip.top) * HQ_FACTOR)))
                    break;

                if (!m_fHQStarted)
                {
                    CComPtr<IDASound> SoundPtr;
                    CComPtr<IDATransform2> TransformPtr;
                    CComPtr<IDAImage> TransformedImagePtr;

                    if (FAILED(m_StaticsPtr->get_Silence(&SoundPtr)))
                        break;

                    if (FAILED(m_StaticsPtr->Scale2(2.0, 2.0, &TransformPtr)))
                        break;

                    if (FAILED(m_HQViewPtr->put_ClientSite(m_pocs)))
                        break;

                    if (!m_ImagePtr)
                        break;

                    // Transform based upon the given image...
                    if (FAILED(m_ImagePtr->Transform(TransformPtr, &TransformedImagePtr)))
                        break;

                    if (FAILED(m_HQViewPtr->StartModel(TransformedImagePtr, SoundPtr, dblCurrentTime)))
                        break;

                    m_fHQStarted = TRUE;
                }

                // Set the current time...
                if (FAILED(m_HQViewPtr->Tick(dblCurrentTime, &vBool)))
                    break;

                // Finally, render into the DC...
                if (FAILED(m_HQViewPtr->Render()))
                    break;

                m_HQViewPtr->put_ClientSite(NULL);

                ::GdiFlush();

                fRet = TRUE;
            }
            while(0);
        }

        if (fRet)
        {
            // Smooth the bitmap and place the result in the proper location
            SmoothHQBitmap(&rcClip);

            // Now, finally BLT to the display...
            fRet = ::BitBlt(
                hdc,
                rcBounds.left,
                rcBounds.top,
                (rcBounds.right  - rcBounds.left),
                (rcBounds.bottom - rcBounds.top),
                m_hdcHQ,
                0,
                (rcBounds.bottom - rcBounds.top),
                SRCCOPY);
        }

        // Restore the previous device context...
        ::RestoreDC(hdc, iSaveContext);
        ::RestoreDC(m_hdcHQ, iSaveOffContext);
    }
        
        return fRet;
}

/*==========================================================================*/

BOOL CSGrfx::FreeHQBitmap()
{
        BOOL fRet = TRUE;

        if (m_hdcHQ)
        {
                // Free up the bitmap
                SelectObject(m_hdcHQ, m_hbmpHQOld);
        DeleteObject(m_hbmpHQ);

                m_hbmpHQOld = NULL;
        m_hbmpHQ = NULL;

                // Get rid of the DC
                fRet = DeleteDC(m_hdcHQ);
                m_hdcHQ = (HDC)NULL;
        }
        return fRet;
}

/*==========================================================================*/

#pragma optimize( "agt", on )

BOOL CSGrfx::SmoothHQBitmap(LPRECT lprcBounds)
{
    BOOL fRet = TRUE;

#if HQ_FACTOR == 4
    if (m_hdcHQ && m_pHQDIBBits)
    {
        int iBytesLine = DibWidthBytes((LPBITMAPINFOHEADER)&m_bmInfoHQ);

        int iRow;
        int iCol;
        LPBYTE lpSrcLine = m_pHQDIBBits;
        LPBYTE lpDstLine = m_pHQDIBBits;
        int iR1 = iBytesLine;
        int iR2 = iBytesLine << 1;
        int iR3 = (iBytesLine << 1) + iBytesLine;

        iRow = m_bmInfoHQ.bmiHeader.biHeight >> 2;

        while(iRow-- > 0)
        {
            if (iRow >= lprcBounds->top && iRow <= lprcBounds->bottom)
            {
                LPBYTE lpDst = lpDstLine;
                LPBYTE lpSrc = lpSrcLine;
                int iRedTotal;
                int iGrnTotal;
                int iBluTotal;

                lpDst += lprcBounds->left * 3;
                lpSrc += lprcBounds->left * 12;

                iCol = lprcBounds->right - lprcBounds->left;

                while(iCol-- > 0)
                {
                    // Process Row 1
                    iRedTotal = lpSrc[2] + lpSrc[5] + lpSrc[8] + lpSrc[11];
                    iGrnTotal = lpSrc[1] + lpSrc[4] + lpSrc[7] + lpSrc[10];
                    iBluTotal = lpSrc[0] + lpSrc[3] + lpSrc[6] + lpSrc[ 9];

                    // Process Row 2
                    iRedTotal += lpSrc[iR1 + 2] + lpSrc[iR1 + 5] + lpSrc[iR1 + 8] + lpSrc[iR1 + 11];
                    iGrnTotal += lpSrc[iR1 + 1] + lpSrc[iR1 + 4] + lpSrc[iR1 + 7] + lpSrc[iR1 + 10];
                    iBluTotal += lpSrc[iR1 + 0] + lpSrc[iR1 + 3] + lpSrc[iR1 + 6] + lpSrc[iR1 +  9];

                    // Process Row 3
                    iRedTotal += lpSrc[iR2 + 2] + lpSrc[iR2 + 5] + lpSrc[iR2 + 8] + lpSrc[iR2 + 11];
                    iGrnTotal += lpSrc[iR2 + 1] + lpSrc[iR2 + 4] + lpSrc[iR2 + 7] + lpSrc[iR2 + 10];
                    iBluTotal += lpSrc[iR2 + 0] + lpSrc[iR2 + 3] + lpSrc[iR2 + 6] + lpSrc[iR2 +  9];

                    // Process Row 4
                    iRedTotal += lpSrc[iR3 + 2] + lpSrc[iR3 + 5] + lpSrc[iR3 + 8] + lpSrc[iR3 + 11];
                    iGrnTotal += lpSrc[iR3 + 1] + lpSrc[iR3 + 4] + lpSrc[iR3 + 7] + lpSrc[iR3 + 10];
                    iBluTotal += lpSrc[iR3 + 0] + lpSrc[iR3 + 3] + lpSrc[iR3 + 6] + lpSrc[iR3 +  9];

                    lpDst[2] = iRedTotal >> 4;
                    lpDst[1] = iGrnTotal >> 4;
                    lpDst[0] = iBluTotal >> 4;

                    lpDst += 3; // One pixel
                    lpSrc += 12;  // Four pixels
                }
            }

            lpDstLine += iBytesLine; // One scanline
            lpSrcLine += iBytesLine << 2;  // Four scanlines
        }
    }
#endif // HQ_FACTOR == 4

#if HQ_FACTOR == 2
    if (m_hdcHQ && m_pHQDIBBits)
    {
        int iBytesLine = DibWidthBytes((LPBITMAPINFOHEADER)&m_bmInfoHQ);

        int iRow;
        int iCol;
        LPBYTE lpSrcLine = m_pHQDIBBits;
        LPBYTE lpDstLine = m_pHQDIBBits;
        int iR1 = iBytesLine;

        iRow = m_bmInfoHQ.bmiHeader.biHeight >> 1;

        while(iRow-- > 0)
        {
            if (iRow >= lprcBounds->top && iRow <= lprcBounds->bottom)
            {
                LPBYTE lpDst = lpDstLine;
                LPBYTE lpSrc = lpSrcLine;

                lpDst += lprcBounds->left * 3;
                lpSrc += lprcBounds->left * 6;

                iCol = lprcBounds->right - lprcBounds->left;

                while(iCol-- > 0)
                {
                    // Process Row 1
                    lpDst[2] = (lpSrc[2] + lpSrc[5] + lpSrc[iR1 + 2] + lpSrc[iR1 + 5]) >> 2;
                    lpDst[1] = (lpSrc[1] + lpSrc[4] + lpSrc[iR1 + 1] + lpSrc[iR1 + 4]) >> 2;
                    lpDst[0] = (lpSrc[0] + lpSrc[3] + lpSrc[iR1 + 0] + lpSrc[iR1 + 3]) >> 2;

                    lpDst += 3; // One pixel
                    lpSrc += 6;  // Two pixels
                }
            }

            lpDstLine += iBytesLine; // One scanline
            lpSrcLine += iBytesLine << 1;  // Four scanlines
        }
    }
#endif // HQ_FACTOR == 2
    return fRet;
}

#pragma optimize( "", on )

/*==========================================================================*/

void CSGrfx::OnTimer(DWORD dwTime)
{
    VARIANT_BOOL vBool;
    HRESULT hr = S_OK;

    // Always update current time...
    m_dblTime = (dwTime / 1000.0) - m_dblStartTime;

    // Leave early if 
    if (!m_fNeedOnTimer)
        return;

    if (m_fHighQuality && m_fHQStarted)
    {
        hr = m_HQViewPtr->Tick(m_dblTime, &vBool);
    }
    else
    {
        hr = m_ViewPtr->Tick(m_dblTime, &vBool);
    }

    if (SUCCEEDED(hr))
    {
        if (vBool)
        {
            // Let the regular rendering path take care of this...
            InvalidateControl(NULL, TRUE);
        }
    }
}

/*==========================================================================*/

#ifdef SUPPORTONLOAD
void
CSGrfx::OnWindowLoad (void)
{
    m_fOnWindowLoadFired = true;
}

/*==========================================================================*/

void
CSGrfx::OnWindowUnload (void)
{
    m_fOnWindowLoadFired = false;
    StopModel();
}

/*==========================================================================*/

#endif //SUPPORTONLOAD
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\sprite\sprinit.cpp ===
/*++

Module: 
	sprinit.cpp

Author: 
	IHammer Team (SimonB)

Created: 
	May 1997

Description:
	Performs control-specific initialisation

History:
	05-26-1997	Created (SimonB)

++*/

#include "..\ihbase\ihbase.h"
#include "..\mmctl\inc\ochelp.h" // for ControlInfo
#include "sprinit.h"
#include "..\resource.h"
#include <daxpress.h>

extern ULONG g_cLock;


void InitSpriteControlInfo(HINSTANCE hInst, ControlInfo *pCtlInfo, AllocOCProc pAlloc)
{
    // for some reason I can't statically initalize <g_ctlinfo>, so do it here
    memset(pCtlInfo, 0, sizeof(ControlInfo));
    pCtlInfo->cbSize = sizeof(ControlInfo);
    pCtlInfo->tszProgID = TEXT("DirectAnimation.SpriteControl");
    pCtlInfo->tszFriendlyName = TEXT("Microsoft DirectAnimation Sprite");
    pCtlInfo->pclsid = &CLSID_SpriteControl;
    pCtlInfo->hmodDLL = hInst;
    pCtlInfo->tszVersion = TEXT("1.0");
    pCtlInfo->iToolboxBitmapID = IDB_ICON_SPRITE;
    pCtlInfo->dwMiscStatusContent = CTL_OLEMISC;
    pCtlInfo->pallococ = pAlloc;
    pCtlInfo->pcLock = &g_cLock;
    pCtlInfo->dwFlags = CI_CONTROL | CI_SAFEFORSCRIPTING | 
                        CI_SAFEFORINITIALIZING | CI_MMCONTROL;

    pCtlInfo->pguidTypeLib = &LIBID_DAExpressLib; // TODO: Change as appropriate
}

// end of file: sprinit.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\sgrfx\sgrfx.h ===
/*==========================================================================*\

    Module: 
            sgrfx.h

    Author: 
            IHammer Team (SimonB)

    Created: 
            May 1997

    Description:
            Defines the control's class

    History:
            05-28-1997  Created

\*==========================================================================*/

#ifndef __SGRFX_H__
#define __SGRFX_H__

#define USE_VIEWSTATUS_SURFACE
#include "..\ihbase\precomp.h"
#include "..\ihbase\ihbase.h"
#include <daxpress.h>
#include "clocker.h"
#include "parser.h"
#include "ddraw.h"
#include "ddrawex.h"

// Madness to prevent ATL from using CRT
#define _ATL_NO_DEBUG_CRT
#define _ASSERTE(x) ASSERT(x)
#include <atlbase.h>
#include <servprov.h>

/*==========================================================================*\
    HighQuality Support:
\*==========================================================================*/

//#define HQ_FACTOR 4
//#define HQ_LINE_FACTOR 5

#define HQ_FACTOR 2
#define HQ_LINE_FACTOR 3

#define WIDTHBYTES(i)           ((unsigned)((i+31)&(~31))/8)  /* ULONG aligned ! */

#define DibWidth(lpbi)          (UINT)(((LPBITMAPINFOHEADER)(lpbi))->biWidth)
#define DibHeight(lpbi)         (UINT)(((LPBITMAPINFOHEADER)(lpbi))->biHeight)
#define DibBitCount(lpbi)       (UINT)(((LPBITMAPINFOHEADER)(lpbi))->biBitCount)
#define DibCompression(lpbi)    (DWORD)(((LPBITMAPINFOHEADER)(lpbi))->biCompression)

#define DibWidthBytesN(lpbi, n) (UINT)WIDTHBYTES((UINT)(lpbi)->biWidth * (UINT)(n))
#define DibWidthBytes(lpbi)     DibWidthBytesN(lpbi, (lpbi)->biBitCount)

#define DibSizeImage(lpbi)      ((lpbi)->biSizeImage == 0 \
                                    ? ((DWORD)(UINT)DibWidthBytes(lpbi) * (DWORD)(UINT)(lpbi)->biHeight) \
                                    : (lpbi)->biSizeImage)

#define DibSize(lpbi)           ((lpbi)->biSize + (lpbi)->biSizeImage + (int)(lpbi)->biClrUsed * sizeof(RGBQUAD))
#define DibPaletteSize(lpbi)    (DibNumColors(lpbi) * sizeof(RGBQUAD))

#define DibFlipY(lpbi, y)       ((int)(lpbi)->biHeight-1-(y))

//HACK for NT BI_BITFIELDS DIBs
#define DibPtr(lpbi)            ((lpbi)->biCompression == BI_BITFIELDS \
                                    ? (LPVOID)(DibColors(lpbi) + 3) \
                                    : (LPVOID)(DibColors(lpbi) + (UINT)(lpbi)->biClrUsed))

#define DibColors(lpbi)         ((RGBQUAD FAR *)((LPBYTE)(lpbi) + (int)(lpbi)->biSize))

#define DibNumColors(lpbi)      ((lpbi)->biClrUsed == 0 && (lpbi)->biBitCount <= 8 \
                                    ? (int)(1 << (int)(lpbi)->biBitCount)          \
                                    : (int)(lpbi)->biClrUsed)

#define DibXYN(lpbi,pb,x,y,n)   (LPVOID)(                                     \
                                (BYTE _huge *)(pb) +                          \
                                (UINT)((UINT)(x) * (UINT)(n) / 8u) +          \
                                ((DWORD)DibWidthBytesN(lpbi,n) * (DWORD)(UINT)(y)))

#define DibXY(lpbi,x,y)         DibXYN(lpbi,DibPtr(lpbi),x,y,(lpbi)->biBitCount)

#define FixBitmapInfo(lpbi)     if ((lpbi)->biSizeImage == 0)                 \
                                    (lpbi)->biSizeImage = DibSizeImage(lpbi); \
                                if ((lpbi)->biClrUsed == 0)                   \
                                    (lpbi)->biClrUsed = DibNumColors(lpbi);   \
                                if ((lpbi)->biCompression == BI_BITFIELDS && (lpbi)->biClrUsed == 0) \
                                    ; // (lpbi)->biClrUsed = 3;                    

#define DibInfo(pDIB)     ((BITMAPINFO FAR *)(pDIB))

/*==========================================================================*/

#ifdef DEADCODE
class CPickCallback : public IDAUntilNotifier {
protected:
    CComPtr<IConnectionPointHelper> m_pconpt;
    CComPtr<IDAStatics>             m_pstatics;
    CComPtr<IDAImage>               m_pimage;
    CComPtr<IDAImage>               m_pimagePick;
    CComPtr<IDAEvent>               m_peventEnter;
    CComPtr<IDAEvent>               m_peventLeave;
    boolean m_bInside;
    boolean& m_fOnWindowLoadFired;
    ULONG m_cRef;

public :
    CPickCallback(
        IConnectionPointHelper* pconpt,
        IDAStatics* pstatics,
        IDAImage* pimage,
        boolean& fOnWindowLoadFired,
        HRESULT& hr
    );
    ~CPickCallback();

    boolean Inside() { return m_bInside; }
    HRESULT GetImage(IDABehavior** ppimage);
    HRESULT STDMETHODCALLTYPE Notify(
            IDABehavior __RPC_FAR *eventData,
            IDABehavior __RPC_FAR *curRunningBvr,
            IDAView __RPC_FAR *curView,
            IDABehavior __RPC_FAR *__RPC_FAR *ppBvr);

    ///// IUnknown
public :

    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void __RPC_FAR *__RPC_FAR *ppvObject);
    ULONG STDMETHODCALLTYPE AddRef(void);
    ULONG STDMETHODCALLTYPE Release(void);

    ///// IDispatch implementation
protected:
    STDMETHODIMP GetTypeInfoCount(UINT *pctinfo) { return E_NOTIMPL; }
    STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo) { return E_NOTIMPL; }
    STDMETHODIMP GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames, LCID lcid, DISPID *rgdispid) { return E_NOTIMPL; }
    STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr) { return E_NOTIMPL; }
};
#endif // DEADCODE

/*==========================================================================*/

/*
CIHBaseCtl <    
        CSGrfx,                         //TODO: Name of the derived class
        IIHCtl,                         //TODO: Name of interface defining methods and properties
        &CLSID_IHCtl,           //TODO: CLSID of the control  Get this from ihctl.h
        &IID_IIHCtl,            //TODO: IID of the interface above.  Get this from ihctl.h
        &LIBID_IHCtl,           //TODO: LIBID of the typelib.  Get this from ihctl.h
        &DIID_IHCtlEvents > //TODO: IID of the event interface.  Get this from ihctl.h

*/

#define SG_BASECLASS    \
CIHBaseCtl <        \
        CSGrfx,                 \
        ISGrfxCtl,                      \
        &CLSID_StructuredGraphicsControl,        \
        &IID_ISGrfxCtl, \
        &LIBID_DAExpressLib,    \
        &DIID_ISGrfxCtlEvents>

class CSGrfx:           
        public ISGrfxCtl,
        public SG_BASECLASS,
        public CClockerSink
        
{
friend LPUNKNOWN __stdcall AllocSGControl(LPUNKNOWN punkOuter);

// Template stuff
        typedef SG_BASECLASS CMyIHBaseCtl;

private:
    BOOL m_fMouseEventsEnabled;
    LPWSTR m_pwszSourceURL;
    CoordSystemConstant m_CoordSystem;
    int m_iExtentTop;
    int m_iExtentLeft;
    int m_iExtentWidth;
    int m_iExtentHeight;
    BOOL m_fPersistExtents, m_fIgnoreExtentWH, m_fMustSetExtent;
    BOOL m_fSetExtentsInSetIdentity;
    BOOL m_fUpdateDrawingSurface;
    BOOL m_fShowTiming;
    BOOL m_fPreserveAspectRatio;
    bool m_fRectsSetOnce;
    RECT m_rcLastRectScaled;
    boolean m_fOnWindowLoadFired;
    bool m_fNeedOnTimer;
    BOOL m_fInside;
    bool m_fExtentTopSet, m_fExtentLeftSet, m_fExtentWidthSet, m_fExtentHeightSet;

    // High Quality Support:
    BOOL       m_fHighQuality;
    BOOL       m_fHQStarted; // True iff the model has been started...
    HDC        m_hdcHQ;
    HBITMAP    m_hbmpHQOld;
    HBITMAP    m_hbmpHQ;
    BITMAPINFO m_bmInfoHQ;
    RGBQUAD    m_rgrgbqColorMap[256];
    LPBYTE     m_pHQDIBBits;

    CParser m_cparser;
    CClocker                   m_clocker;

    // DAnim Support:
    BOOL                       m_fStarted; // True iff the model has been started...
    CComPtr<IDATransform3>     m_FullTransformPtr;
    CComPtr<IDATransform2>     m_TransformPtr;
    CComPtr<IDAStatics>        m_StaticsPtr;
    CComPtr<IDAView>           m_ViewPtr;
    CComPtr<IDADrawingSurface> m_DrawingSurfacePtr;
    CComPtr<IDAImage>          m_ImagePtr;
    CComPtr<IDirectDraw3>      m_DirectDraw3Ptr;
    CComPtr<IServiceProvider>  m_ServiceProviderPtr;

    CComPtr<IDATransform3>     m_CachedRotateTransformPtr;
    double                     m_dblCachedRotateX;
    double                     m_dblCachedRotateY;
    double                     m_dblCachedRotateZ;

    CComPtr<IDATransform3>     m_CachedTranslateTransformPtr;
    double                     m_dblCachedTranslateX;
    double                     m_dblCachedTranslateY;
    double                     m_dblCachedTranslateZ;

    CComPtr<IDATransform3>     m_CachedScaleTransformPtr;
    double                     m_dblCachedScaleX;
    double                     m_dblCachedScaleY;
    double                     m_dblCachedScaleZ;

    // High-Quality Rendering...
    CComPtr<IDAView>           m_HQViewPtr;

    // Behavior constants
    CComPtr<IDANumber>         m_zero;
    CComPtr<IDANumber>         m_one;
    CComPtr<IDANumber>         m_negOne;
    CComPtr<IDAVector3>        m_xVector3;
    CComPtr<IDAVector3>        m_yVector3;
    CComPtr<IDAVector3>        m_zVector3;
    CComPtr<IDATransform2>     m_identityXform2;
    CComPtr<IDATransform2>     m_yFlipXform2;

#ifdef DEADCODE
    // picking
    CComPtr<CPickCallback>     m_pcallback;
#endif // DEADCODE

    double                     m_dblTime;
    double                     m_dblStartTime;

protected:

        //
        // Constructor and destructor
        // 
        CSGrfx(IUnknown *punkOuter, HRESULT *phr); 

    ~CSGrfx(); 

        // Overides
        STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, LPVOID *ppv);

    STDMETHODIMP SetObjectRects(LPCRECT lprcPosRect, LPCRECT lprcClipRect);

        STDMETHODIMP QueryHitPoint(DWORD dwAspect, LPCRECT prcBounds, POINT ptLoc, LONG lCloseHint, DWORD* pHitResult);

        STDMETHODIMP OnWindowMessage(UINT msg, WPARAM wParam, LPARAM lParam, LRESULT *plResult);
        
        STDMETHODIMP DoPersist(IVariantIO* pvio, DWORD dwFlags);
        
        STDMETHODIMP Draw(DWORD dwDrawAspect, LONG lindex, void *pvAspect,
         DVTARGETDEVICE *ptd, HDC hdcTargetDev, HDC hdcDraw,
         LPCRECTL lprcBounds, LPCRECTL lprcWBounds,
                 BOOL (__stdcall *pfnContinue)(ULONG_PTR dwContinue), ULONG_PTR dwContinue);

        ///// IDispatch implementation
        protected:
    STDMETHODIMP GetTypeInfoCount(UINT *pctinfo);
    STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo);
    STDMETHODIMP GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames,
         LCID lcid, DISPID *rgdispid);
    STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid,
        WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult,
        EXCEPINFO *pexcepinfo, UINT *puArgErr);
   
    ///// IOleObject implementation
    protected:
    STDMETHODIMP SetClientSite(IOleClientSite *pClientSite);
    
        ///// delegating IUnknown implementation
        protected:
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv)
      { return m_punkOuter->QueryInterface(riid, ppv); }
    STDMETHODIMP_(ULONG) AddRef()
      { return m_punkOuter->AddRef(); }
    STDMETHODIMP_(ULONG) Release()
      { return m_punkOuter->Release(); }

        //
        // ISGrfxCtl methods 
        //
        
protected:

    /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_SourceURL( 
                /* [retval][out] */ BSTR __RPC_FAR *bstrSourceURL);
        
    /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_SourceURL( 
                /* [in] */ BSTR bstrSourceURL);
        
    /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_CoordinateSystem( 
                /* [retval][out] */ CoordSystemConstant __RPC_FAR *CoordSystem);
        
    /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_CoordinateSystem( 
                /* [in] */ CoordSystemConstant CoordSystem);
        
    /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_MouseEventsEnabled( 
                /* [retval][out] */ VARIANT_BOOL __RPC_FAR *fEnabled);
        
    /* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_MouseEventsEnabled( 
                /* [in] */ VARIANT_BOOL fEnabled);
        
    /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ExtentTop( 
                /* [retval][out] */ int __RPC_FAR *iExtentTop);
        
    /* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_ExtentTop( 
                /* [in] */ int iExtentTop);
        
    /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ExtentLeft( 
                /* [retval][out] */ int __RPC_FAR *iExtentLeft);
        
    /* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_ExtentLeft( 
                /* [in] */ int iExtentLeft);
        
    /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ExtentWidth( 
                /* [retval][out] */ int __RPC_FAR *iExtentWidth);
        
    /* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_ExtentWidth( 
                /* [in] */ int iExtentWidth);
        
    /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ExtentHeight( 
                /* [retval][out] */ int __RPC_FAR *iExtentHeight);
        
    /* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_ExtentHeight( 
                /* [in] */ int iExtentHeight);
        
    /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_HighQuality( 
                /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfHighQuality);
        
    /* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_HighQuality( 
                /* [in] */ VARIANT_BOOL fHighQuality);
        
    /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Library( 
                /* [retval][out] */ IDAStatics __RPC_FAR **ppLibrary);

    /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Image( 
                /* [retval][out] */ IDAImage __RPC_FAR **ppImage);
        
    /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Image( 
                /* [in] */ IDAImage __RPC_FAR *pImage);
        
    /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Transform( 
                /* [retval][out] */ IDATransform3 __RPC_FAR **ppTransform);
        
    /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Transform( 
                /* [in] */ IDATransform3 __RPC_FAR *pTransform);

    /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_DrawingSurface( 
                /* [retval][out] */ IDADrawingSurface __RPC_FAR **ppDrawingSurface);
        
    /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_DrawingSurface( 
                /* [in] */ IDADrawingSurface __RPC_FAR *pDrawingSurface);
        
    /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_DrawSurface( 
                /* [retval][out] */ IDADrawingSurface __RPC_FAR **ppDrawingSurface);
        
    /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_DrawSurface( 
                /* [in] */ IDADrawingSurface __RPC_FAR *pDrawingSurface);

    /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_PreserveAspectRatio( 
        /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfPreserve);
    
    /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_PreserveAspectRatio( 
        /* [in] */ VARIANT_BOOL fPreserve);

    /* [id][helpstring] */ HRESULT STDMETHODCALLTYPE Clear( void);
        
    /* [id][helpstring] */ HRESULT STDMETHODCALLTYPE Rotate( 
                /* [in] */ double dblXRot,
                /* [in] */ double dblYRot,
                /* [in] */ double dblZRot,
                /* [optional][in] */ VARIANT varReserved);

    /* [id][helpstring] */ HRESULT STDMETHODCALLTYPE Scale( 
                /* [in] */ double dblXScale,
                /* [in] */ double dblYScale,
                /* [in] */ double dblZScale,
                /* [optional][in] */ VARIANT varReserved);

    /* [id][helpstring] */ HRESULT STDMETHODCALLTYPE SetIdentity( void);
        
    /* [id][helpstring] */ HRESULT STDMETHODCALLTYPE Transform4x4(/* [in] */ VARIANT matrix);
        
    /* [id][helpstring] */ HRESULT STDMETHODCALLTYPE Translate( 
                /* [in] */ double dblXOrigin,
                /* [in] */ double dblYOrigin,
                /* [in] */ double dblZOrigin,
                /* [optional][in] */ VARIANT varReserved);

#ifdef INCLUDESHEAR
    /* [id][helpstring] */ HRESULT STDMETHODCALLTYPE ShearX( 
                /* [in] */ double dblShearAmount);
        
    /* [id][helpstring] */ HRESULT STDMETHODCALLTYPE ShearY( 
                /* [in] */ double dblShearAmount);
#endif // INCLUDESHEAR
        
#ifdef SUPPORTONLOAD
        void OnWindowLoad (void);
        void OnWindowUnload (void);
#endif //SUPPORTONLOAD

private:
    HRESULT InitializeSurface(void);
    STDMETHODIMP PaintToDC(HDC hdcDraw, LPRECT lprcBounds, BOOL fBW);
    STDMETHODIMP InvalidateControl(LPCRECT pRect, BOOL fErase);
    void SetSGExtent();

    HRESULT CreateBaseTransform(void);
    HRESULT RecomposeTransform(BOOL fInvalidate);
    HRESULT UpdateImage(IDAImage *pImage, BOOL fInvalidate);
    BOOL StopModel(void);
    BOOL StartModel(void);
    BOOL ReStartModel(void);

    // HighQuality Support:
    BOOL PaintHQBitmap(HDC hdc);
    BOOL FreeHQBitmap();
    BOOL SmoothHQBitmap(LPRECT lprcBounds);

    // Timing info:
    DWORD GetCurrTimeInMillis(void);
    double GetCurrTime() { return (double)(GetCurrTimeInMillis()) / 1000.0; }

    BOOL InsideImage(POINT ptXY);

public:
    virtual void OnTimer(DWORD dwTime);
};

/*==========================================================================*/

#endif // __SGRFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\sprite\sprinit.h ===
/*++

Module: 
	sprinit.h

Author: 
	IHammer Team (SimonB)

Created: 
	May 1997

Description:
	Header for control-specific initialisation

History:
	05-27-1997	Created (SimonB)

++*/
#include "..\mmctl\inc\ochelp.h" // for ControlInfo

#ifndef __SPRINIT_H__
#define __SPRINIT_H__

void InitSpriteControlInfo(HINSTANCE hInst, ControlInfo *pCtlInfo, AllocOCProc pAlloc);

#endif // __SPRINIT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\sprite\sprevent.h ===
/*++

Module: 
    sprevent.h

Author: 
    IHammer Team (SimonB)

Created: 
    May 1997

Description:
    Macros to make firing events easier and safer.  Each macro can be customised for 
    the particular event.  However, the general form should be:

    #define FIRE_EVENTNAME(pConnectionPoint, param1, param2) \
        pConnectionPoint->FireEvent(DISPID_EVENT_EVENTNAME, \
            <VT for param1>, param1, \
            <VT for param2>, param2, \
            0) 

    NOTE: The terminating 0 is extremly important !!!

History:
    05-27-1997  Created (SimonB)

++*/

#include <dispids.h>

#ifndef __SPREVENT_H__
#define __SPREVENT_H__

// Shift/Ctrl/Alt, and mouse button states for events
#define KEYSTATE_SHIFT  1
#define KEYSTATE_CTRL   2
#define KEYSTATE_ALT    4

#define MOUSEBUTTON_LEFT     1
#define MOUSEBUTTON_RIGHT    2
#define MOUSEBUTTON_MIDDLE   4

#define FIRE_ONPLAYMARKER(pConnectionPoint, MARKER) \
        pConnectionPoint->FireEvent(DISPID_SPRITE_EVENT_ONPLAYMARKER, \
            VT_BSTR, MARKER, \
            0)

#define FIRE_ONMARKER(pConnectionPoint, MARKER) \
        pConnectionPoint->FireEvent(DISPID_SPRITE_EVENT_ONMARKER, \
            VT_BSTR, MARKER, \
            0)

#define FIRE_ONSTOP(pConnectionPoint) \
    if (!m_fOnWindowUnloadFired && !m_fOnStopFiring) \
    { \
        m_fOnStopFiring = true; \
        pConnectionPoint->FireEvent(DISPID_SPRITE_EVENT_ONSTOP, 0); \
        m_fOnStopFiring = false; \
    }

#define FIRE_ONPLAY(pConnectionPoint) \
    if (!m_fOnWindowUnloadFired && !m_fOnPlayFiring) \
    { \
        m_fOnPlayFiring = true; \
        pConnectionPoint->FireEvent(DISPID_SPRITE_EVENT_ONPLAY, 0); \
        m_fOnPlayFiring = false; \
    } 

#define FIRE_ONPAUSE(pConnectionPoint) \
    if (!m_fOnWindowUnloadFired && !m_fOnPauseFiring) \
    { \
        m_fOnPauseFiring = true; \
        pConnectionPoint->FireEvent(DISPID_SPRITE_EVENT_ONPAUSE, 0);\
        m_fOnPauseFiring = false;\
    } 

#define FIRE_CLICK(pConnectionPoint) \
    if (!m_fOnWindowUnloadFired) \
        pConnectionPoint->FireEvent(DISPID_SPRITE_EVENT_CLICK, 0)

#define FIRE_DBLCLICK(pConnectionPoint) \
    if (!m_fOnWindowUnloadFired) \
        pConnectionPoint->FireEvent(DISPID_SPRITE_EVENT_DBLCLICK, 0)

#define FIRE_MOUSEDOWN(pConnectionPoint, BUTTON, SHIFT, X, Y) \
    if (!m_fOnWindowUnloadFired) \
        pConnectionPoint->FireEvent(DISPID_SPRITE_EVENT_MOUSEDOWN, \
            VT_I4, BUTTON, \
            VT_I4, SHIFT, \
            VT_I4, X, \
            VT_I4, Y, \
            0)

#define FIRE_MOUSEENTER(pConnectionPoint) \
    if (!m_fOnWindowUnloadFired) \
        pConnectionPoint->FireEvent(DISPID_SPRITE_EVENT_MOUSEENTER, 0)

#define FIRE_MOUSELEAVE(pConnectionPoint) \
    if (!m_fOnWindowUnloadFired) \
        pConnectionPoint->FireEvent(DISPID_SPRITE_EVENT_MOUSELEAVE, 0)

#define FIRE_MOUSEMOVE(pConnectionPoint, BUTTON, SHIFT, X, Y) \
    if (!m_fOnWindowUnloadFired) \
        pConnectionPoint->FireEvent(DISPID_SPRITE_EVENT_MOUSEMOVE, \
            VT_I4, BUTTON, \
            VT_I4, SHIFT, \
            VT_I4, X, \
            VT_I4, Y, \
            0)

#define FIRE_MOUSEUP(pConnectionPoint, BUTTON, SHIFT, X, Y) \
    if (!m_fOnWindowUnloadFired) \
        pConnectionPoint->FireEvent(DISPID_SPRITE_EVENT_MOUSEUP, \
            VT_I4, BUTTON, \
            VT_I4, SHIFT, \
            VT_I4, X, \
            VT_I4, Y, \
            0)

#define FIRE_ONMEDIALOADED(pConnectionPoint, URL) \
    if (!m_fOnWindowUnloadFired) \
        pConnectionPoint->FireEvent(DISPID_SPRITE_EVENT_ONMEDIALOADED, \
            VT_BSTR, URL, \
            0)

#define FIRE_ONSEEK(pConnectionPoint, TIME) \
    if (!m_fOnWindowUnloadFired) \
        pConnectionPoint->FireEvent(DISPID_SPRITE_EVENT_ONSEEK, \
            VT_R8, TIME, \
            0)

#define FIRE_ONFRAMESEEK(pConnectionPoint, FRAME) \
    if (!m_fOnWindowUnloadFired) \
        pConnectionPoint->FireEvent(DISPID_SPRITE_EVENT_ONFRAMESEEK, \
            VT_I4, FRAME, \
            0)


#endif // __SPREVENT_H__

// End of file sprevent.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\sprite\sprite.cpp ===
/*==========================================================================*\

    Module:
            sprite.cpp

    Author:
            IHammer Team (SimonB)

    Created:
            May 1997

    Description:
            Implements any control-specific members, as well as the control's interface

    History:
            05-27-1997  Created (SimonB)

\*==========================================================================*/

#define USE_VIEWSTATUS_SURFACE
#include "..\ihbase\precomp.h"
#include "..\ihbase\debug.h"
#include "..\ihbase\utils.h"
#include "sprite.h"
#include "sprevent.h"
#include "ddrawex.h"
#include <htmlfilter.h>
#include "..\ihbase\parser.h"
#include "..\ihbase\timemark.h"
#include <strwrap.h>

/*==========================================================================*/

extern ControlInfo g_ctlinfoSprite;

/*==========================================================================*/
//
// CSpriteCtl Creation/Destruction
//

LPUNKNOWN __stdcall AllocSpriteControl(LPUNKNOWN punkOuter)
{
    // Allocate object
    HRESULT hr;
    CSpriteCtl *pthis = New CSpriteCtl(punkOuter, &hr);

    if (pthis == NULL)
        return NULL;

    if (FAILED(hr))
    {
        Delete pthis;
        return NULL;
    }

    // return an IUnknown pointer to the object
    return (LPUNKNOWN) (INonDelegatingUnknown *) pthis;
}

/*==========================================================================*/
//
// Beginning of class implementation
//

CSpriteCtl::CSpriteCtl(IUnknown *punkOuter, HRESULT *phr):
    CMyIHBaseCtl(punkOuter, phr),
    m_ptmFirst(NULL)
{
    // Initialise members
    m_fMouseInArea = FALSE;
    m_bstrSourceURL = NULL;
    m_iLoopCount = 1;
    m_fAutoStart = FALSE;
    m_iPrerollAmount = 1000;
    m_enumPlayState = Stopped;
    m_iInitialFrame = 0;
    m_iFinalFrame = -1;     // Defaults to InitialFrame
    m_iRepeat = 1;
    m_dblDuration = 1.0;
    m_dblUserPlayRate = m_dblPlayRate = 1.0;
    m_dblUserTimerInterval = m_dblTimerInterval = 0.1;   // Initialized to 100 millisecs
    m_iMaximumRate = 30;
    m_iFrame = 0;
    m_iNumFrames = 1;
    m_iNumFramesAcross = 1;
    m_iNumFramesDown = 1;
    m_fUseColorKey = FALSE;
    m_fMouseEventsEnabled = TRUE;
    m_fStarted = FALSE;
    m_dblBaseTime = 0.0;
    m_dblPreviousTime = 0.0;
    m_dblCurrentTick = 0.0;
    m_dblTimePaused = 0.0;
    m_fPersistComplete = FALSE;
    m_fOnWindowLoadFired = FALSE;
    m_iCurCycle = 0;
    m_iFrameCount = 0;
    m_iStartingFrame = 0;
    m_pArrayBvr = NULL;
    m_fOnSeekFiring = FALSE;
    m_fOnFrameSeekFiring = FALSE;
    m_fFireAbsoluteFrameMarker =  FALSE;
    m_fOnWindowUnloadFired = false;
    m_fWaitForImportsComplete = true;
    m_fOnStopFiring = false;
    m_fOnPlayFiring = false;
    m_fOnPauseFiring = false;
    m_hwndParent = 0;
    m_byteColorKeyR = m_byteColorKeyG = m_byteColorKeyB = 0;
    m_durations = NULL;

    // Tie into the DANIM DLL now...
    if (phr)
    {
        if (SUCCEEDED(*phr))
        {
            *phr = CoCreateInstance(
                CLSID_DAView,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IDAView,
                (void **) &m_ViewPtr);
        }

        if (SUCCEEDED(*phr))
        {
            *phr = ::CoCreateInstance(
                CLSID_DAStatics,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IDAStatics,
                (void **) &m_StaticsPtr);
        }

        m_clocker.SetSink((CClockerSink *)this);
    }
}

/*==========================================================================*/

CSpriteCtl::~CSpriteCtl()
{
    StopModel();

    if (m_bstrSourceURL)
    {
        SysFreeString(m_bstrSourceURL);
        m_bstrSourceURL = NULL;
    }

        m_drgFrameMarkers.MakeNullAndDelete();
        m_drgTimeMarkers.MakeNullAndDelete();
        m_drgFrameMaps.MakeNullAndDelete();

        // Delete any array of behaviors
        if (m_pArrayBvr != NULL)
        {
                Delete [] m_pArrayBvr;
                m_pArrayBvr = NULL;
        }

        // Delete any array of durations
        if (m_durations != NULL)
        {
                Delete [] m_durations;
                m_durations = NULL;
        }               
}

/*==========================================================================*/

STDMETHODIMP CSpriteCtl::NonDelegatingQueryInterface(REFIID riid, LPVOID *ppv)
{
        HRESULT hRes = S_OK;
        BOOL fMustAddRef = FALSE;

    if (ppv)
        *ppv = NULL;
    else
        return E_POINTER;

#ifdef _DEBUG
    char ach[200];
    TRACE("SpriteCtl::QI('%s')\n", DebugIIDName(riid, ach));
#endif

        if ((IsEqualIID(riid, IID_ISpriteCtl)) || (IsEqualIID(riid, IID_IDispatch)))
        {
                if (NULL == m_pTypeInfo)
                {
                        HRESULT hRes;

                        // Load the typelib
                        hRes = LoadTypeInfo(&m_pTypeInfo, &m_pTypeLib, IID_ISpriteCtl, LIBID_DAExpressLib, NULL);

                        if (FAILED(hRes))
                        {
                                m_pTypeInfo = NULL;
                        }
                        else
                                *ppv = (ISpriteCtl *) this;

                }
                else
                        *ppv = (ISpriteCtl *) this;

        }
    else // Call into the base class
        {
                DEBUGLOG(TEXT("Delegating QI to CIHBaseCtl\n"));
        return CMyIHBaseCtl::NonDelegatingQueryInterface(riid, ppv);

        }

    if (NULL != *ppv)
        {
                DEBUGLOG("SpriteCtl: Interface supported in control class\n");
                ((IUnknown *) *ppv)->AddRef();
        }

    return hRes;
}

/*==========================================================================*/

STDMETHODIMP CSpriteCtl::QueryHitPoint(
    DWORD dwAspect,
    LPCRECT prcBounds,
    POINT ptLoc,
    LONG lCloseHint,
    DWORD* pHitResult)
{
    if ((NULL != pHitResult) && (NULL != prcBounds) && m_fStarted)
    {
        *pHitResult = HITRESULT_OUTSIDE;

        if (!m_fMouseEventsEnabled)
            return S_OK;

        
/* Debug messages
        TCHAR sz[256];
        wsprintf (sz, "QueryHitPoint: dwa=%d, (%ld, %ld, %ld, %ld), (%ld, %ld), lCloseHint=%ld\r\n", 
            dwAspect, prcBounds->left, prcBounds->top, prcBounds->right, prcBounds->bottom, ptLoc.x, ptLoc.y, lCloseHint);
        DEBUGLOG(sz);
*/
        switch (dwAspect)
        {
            case DVASPECT_CONTENT:
            // Intentional fall-through
            case DVASPECT_TRANSPARENT:
            {
                // If we have a view, and we are inside the rectangle,
                // then we need to ask the view whether or not we've
                // hit the image inside.
                if (m_ViewPtr.p) {
                    HRESULT hr = m_ViewPtr->QueryHitPoint(dwAspect,
                                                          prcBounds,
                                                          ptLoc,
                                                          lCloseHint,
                                                          pHitResult);

                    // if we failed, assume that it didn't hit.
                    if (FAILED(hr)) {
                        *pHitResult = HITRESULT_OUTSIDE;
                    }
                }
                
                // Check for entry or departure
                if ((m_fMouseInArea) && (HITRESULT_OUTSIDE == *pHitResult))
                {
                    DEBUGLOG("Mouse out\r\n");
                    m_fMouseInArea = FALSE;
                    FIRE_MOUSELEAVE(m_pconpt);
                }
                else if ((!m_fMouseInArea) && (HITRESULT_HIT == *pHitResult))
                {
                    DEBUGLOG("Mouse In\r\n");
                    m_fMouseInArea = TRUE;
                    FIRE_MOUSEENTER(m_pconpt);
                }
            }
            return S_OK;

            default:
                return E_FAIL;
        }
    }
    else
    {
            return E_POINTER;
    }
}

/*==========================================================================*/

STDMETHODIMP CSpriteCtl::OnWindowMessage(UINT msg, WPARAM wParam, LPARAM lParam, LRESULT *plResult)
{
    HRESULT hr = S_FALSE;
    long lKeyState = 0;

    // Get the Keystate set up
    if (wParam & MK_CONTROL)
        lKeyState += KEYSTATE_CTRL;

    if (wParam & MK_SHIFT)
        lKeyState += KEYSTATE_SHIFT;

    if (GetAsyncKeyState(VK_MENU))
        lKeyState += KEYSTATE_ALT;

    switch (msg)
    {
        case WM_MOUSEMOVE:
        {
            // Need to get button state...
            long iButton=0;

            if (wParam & MK_LBUTTON)
                iButton += MOUSEBUTTON_LEFT;

            if (wParam & MK_MBUTTON)
                iButton += MOUSEBUTTON_MIDDLE;

            if (wParam & MK_RBUTTON)
                iButton += MOUSEBUTTON_RIGHT;

            FIRE_MOUSEMOVE(m_pconpt, iButton, lKeyState, LOWORD(lParam), HIWORD(lParam));
            hr = S_OK;
        }
        break;

#ifndef WM_MOUSEHOVER
#define WM_MOUSEHOVER 0x02a1
#endif
#ifndef WM_MOUSELEAVE
#define WM_MOUSELEAVE 0x02a3
#endif

        case WM_MOUSELEAVE:
           // Check for entry or departure
            if (m_fMouseInArea)
            {
                DEBUGLOG("Mouse out\r\n");
                m_fMouseInArea = FALSE;
                FIRE_MOUSELEAVE(m_pconpt);
            }
                        hr = S_OK;
            break;

        case WM_RBUTTONDOWN:
        {
            FIRE_MOUSEDOWN(m_pconpt, MOUSEBUTTON_RIGHT, lKeyState, LOWORD(lParam), HIWORD(lParam));
            hr = S_OK;
        }
        break;

        case WM_MBUTTONDOWN:
        {
            FIRE_MOUSEDOWN(m_pconpt, MOUSEBUTTON_MIDDLE, lKeyState, LOWORD(lParam), HIWORD(lParam));
            hr = S_OK;
        }
        break;

        case WM_LBUTTONDOWN:
        {
            FIRE_MOUSEDOWN(m_pconpt, MOUSEBUTTON_LEFT, lKeyState, LOWORD(lParam), HIWORD(lParam));
            hr = S_OK;
        }
        break;

        case WM_RBUTTONUP:
        {
            FIRE_MOUSEUP(m_pconpt, MOUSEBUTTON_RIGHT, lKeyState, LOWORD(lParam), HIWORD(lParam));
            hr = S_OK;
        }
        break;

        case WM_MBUTTONUP:
        {
            FIRE_MOUSEUP(m_pconpt, MOUSEBUTTON_MIDDLE, lKeyState, LOWORD(lParam), HIWORD(lParam));
            hr = S_OK;
        }
        break;

        case WM_LBUTTONUP:
        {
            FIRE_MOUSEUP(m_pconpt, MOUSEBUTTON_LEFT, lKeyState, LOWORD(lParam), HIWORD(lParam));
            if (m_fMouseInArea)
                FIRE_CLICK(m_pconpt);
            hr = S_OK;
        }
        break;

        case WM_LBUTTONDBLCLK:
        {
            FIRE_DBLCLICK(m_pconpt);
            hr = S_OK;
        }
        break;
    }

    return hr;
}

/*==========================================================================*/

STDMETHODIMP CSpriteCtl::DoPersist(IVariantIO* pvio, DWORD dwFlags)
{
    HRESULT hRes = S_OK;
    BSTR bstrSourceURL = NULL;
    int iMaximumRate = m_iMaximumRate;

    BOOL fIsLoading = (S_OK == pvio->IsLoading());

    // Are we saving ?  If so, convert to BSTR
    if (!fIsLoading)
    {
        bstrSourceURL = SysAllocString(m_bstrSourceURL);
    }
        else
        {
                m_fFireAbsoluteFrameMarker = FALSE;
        }


    // load or save control properties
    if (fIsLoading)
        hRes = pvio->Persist(0, "URL", VT_BSTR, &bstrSourceURL, NULL);

    if (!fIsLoading || hRes != S_OK)
        hRes = pvio->Persist(0, "SourceURL", VT_BSTR, &bstrSourceURL, NULL);

    hRes = pvio->Persist(0, "AutoStart", VT_BOOL, &m_fAutoStart, NULL);

    if (fIsLoading)
    {
        hRes = pvio->Persist(0, "InitialFrame", VT_I4, &m_iInitialFrame, NULL);
        if (hRes == S_OK)
            put_InitialFrame(m_iInitialFrame);
    }
    else
    {
        int iInitialFrame = m_iInitialFrame + 1;
        hRes = pvio->Persist(0, "InitialFrame", VT_I4, &iInitialFrame, NULL);
    }

    if (fIsLoading)
    {
        hRes = pvio->Persist(0, "FinalFrame", VT_I4, &m_iFinalFrame, NULL);
        if (hRes == S_OK)
            put_FinalFrame(m_iFinalFrame);
    }
    else
    {
        int iFinalFrame = m_iFinalFrame + 1;
        hRes = pvio->Persist(0, "FinalFrame", VT_I4, &iFinalFrame, NULL);
    }

    if (fIsLoading)
    {
        hRes = pvio->Persist(0, "Iterations", VT_I4, &m_iRepeat, NULL);
        if (hRes == S_OK)
            put_Repeat(m_iRepeat);
    }

    hRes = pvio->Persist(0, "Repeat", VT_I4, &m_iRepeat, NULL);
    if (hRes == S_OK && fIsLoading)
        put_Repeat(m_iRepeat);

    hRes = pvio->Persist(0, "TimerInterval", VT_R8, &m_dblUserTimerInterval, NULL);
    if (hRes == S_OK && fIsLoading)
        put_TimerInterval(m_dblUserTimerInterval);
    hRes = pvio->Persist(0, "PlayRate", VT_R8, &m_dblUserPlayRate, NULL);
    if (hRes == S_OK && fIsLoading)
        put_PlayRate(m_dblUserPlayRate);

    hRes = pvio->Persist(0, "MaximumRate", VT_I4, &iMaximumRate, NULL);
    if (hRes == S_OK && fIsLoading)
        put_MaximumRate(iMaximumRate);
    
    hRes = pvio->Persist(0, "NumFramesAcross", VT_I4, &m_iNumFramesAcross, NULL);
    if (hRes == S_OK && fIsLoading)
        put_NumFramesAcross(m_iNumFramesAcross);
    
    hRes = pvio->Persist(0, "NumFramesDown", VT_I4, &m_iNumFramesDown, NULL);
    if (hRes == S_OK && fIsLoading)
        put_NumFramesDown(m_iNumFramesDown);
    
    hRes = pvio->Persist(0, "NumFrames", VT_I4, &m_iNumFrames, NULL);
    if (hRes == S_OK && fIsLoading)
        put_NumFrames(m_iNumFrames);

    hRes = pvio->Persist(0, "UseColorKey", VT_BOOL, &m_fUseColorKey, NULL);
    hRes = pvio->Persist(0, "MouseEventsEnabled", VT_BOOL, &m_fMouseEventsEnabled, NULL);

    if (FAILED(hRes = PersistFrameMaps(pvio, fIsLoading)))
        {} // Ignore failure

    if (FAILED(hRes = PersistFrameMarkers(pvio, fIsLoading)))
        {}

    if (FAILED(hRes = PersistTimeMarkers(pvio, fIsLoading)))
        {}

    // Handle ColorKey persistence
    if (m_fUseColorKey)
    {
        if (fIsLoading)
        {
            BSTR bstrColorKey = NULL;
        
            if (FAILED(hRes = pvio->Persist(0,
                "ColorKey", VT_BSTR, &bstrColorKey,
                NULL)))
                return hRes;

            // Anything other than S_OK means the property doesn't exists
            if (hRes == S_OK)
            {
                int iR, iG, iB;

                iR = iG = iB = 0;
                CLineParser parser(bstrColorKey);
                if (parser.IsValid())
                {
                    parser.SetCharDelimiter(TEXT(','));
                    hRes = parser.GetFieldInt(&iR);
                
                    if (S_OK == hRes)
                        hRes = parser.GetFieldInt(&iG);

                    if (S_OK == hRes)
                    {
                        hRes = parser.GetFieldInt(&iB);
                        if (S_FALSE != hRes)
                            hRes = E_FAIL;
                        else
                            hRes = S_OK;
                    }

                    m_byteColorKeyR = iR;
                    m_byteColorKeyG = iG;
                    m_byteColorKeyB = iB;
                }
            }

            SysFreeString(bstrColorKey);
        }
        else
        {
            // Save the data
            CTStr tstrRGB(12);
            wsprintf(tstrRGB.psz(), TEXT("%lu,%lu,%lu"), m_byteColorKeyR, m_byteColorKeyG, m_byteColorKeyB);

#ifdef _UNICODE
            BSTR bstrRGB = tstrRGB.SysAllocString();

            hRes = pvio->Persist(NULL,
                "ColorKey", VT_BSTR, &bstrRGB,
                NULL);
            
            SysFreeString(bstrRGB);
#else
            LPSTR pszRGB = tstrRGB.psz();
            hRes = pvio->Persist(NULL,
                "ColorKey", VT_LPSTR, pszRGB,
                NULL);
#endif
        }
    }



    if (fIsLoading)
    {
        // We loaded, so set the member variables to the appropriate values
        put_SourceURL(bstrSourceURL);
    }

    // At this point, it's safe to free the BSTR
    SysFreeString(bstrSourceURL);

    // if any properties changed, redraw the control
    if (SUCCEEDED(hRes) && (m_poipsw != NULL)) 
    {
        if (m_fControlIsActive)
            m_poipsw->InvalidateRect(NULL, TRUE);
        else
            m_fInvalidateWhenActivated = TRUE;
    }

    // clear the dirty bit if requested
    if (dwFlags & PVIO_CLEARDIRTY)
        m_fDirty = FALSE;

    if (fIsLoading && m_fOnWindowLoadFired && m_fAutoStart)
        Play();

    m_fPersistComplete = TRUE;

    return S_OK;
}

/*==========================================================================*/
//
// IDispatch Implementation
//

STDMETHODIMP CSpriteCtl::GetTypeInfoCount(UINT *pctinfo)
{
    *pctinfo = 1;
    return S_OK;
}

/*==========================================================================*/

STDMETHODIMP CSpriteCtl::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)
{
        *pptinfo = NULL;

    if(itinfo != 0)
        return ResultFromScode(DISP_E_BADINDEX);

    m_pTypeInfo->AddRef();
    *pptinfo = m_pTypeInfo;

    return NOERROR;
}

/*==========================================================================*/

STDMETHODIMP CSpriteCtl::GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames,
    UINT cNames, LCID lcid, DISPID *rgdispid)
{
        return DispGetIDsOfNames(m_pTypeInfo, rgszNames, cNames, rgdispid);
}

/*==========================================================================*/

STDMETHODIMP CSpriteCtl::Invoke(DISPID dispidMember, REFIID riid, LCID lcid,
    WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult,
    EXCEPINFO *pexcepinfo, UINT *puArgErr)
{
        HRESULT hr;

        hr = DispInvoke((ISpriteCtl *)this,
                m_pTypeInfo,
                dispidMember, wFlags, pdispparams,
                pvarResult, pexcepinfo, puArgErr);

        return hr;
}

/*==========================================================================*/

STDMETHODIMP CSpriteCtl::SetClientSite(IOleClientSite *pClientSite)
{
    HRESULT hr = CMyIHBaseCtl::SetClientSite(pClientSite);

    if (m_ViewPtr)
    {
        m_ViewPtr->put_ClientSite(pClientSite);
    }

    m_clocker.SetHost(pClientSite);
    m_ViewPtr->put_ClientSite(pClientSite);
    m_StaticsPtr->put_ClientSite(pClientSite);

    if (!pClientSite)
        {
        StopModel();
        }
        else
        {
                // Start and stop the clocker to initiate it (to create the window etc)
                m_clocker.Start();
                m_clocker.Stop();
        }

    return hr;
}

/*==========================================================================*/

STDMETHODIMP CSpriteCtl::Draw(DWORD dwDrawAspect, LONG lindex, void *pvAspect,
     DVTARGETDEVICE *ptd, HDC hdcTargetDev, HDC hdcDraw,
     LPCRECTL lprcBounds, LPCRECTL lprcWBounds,
     BOOL (__stdcall *pfnContinue)(ULONG_PTR dwContinue), ULONG_PTR dwContinue)
{
    int iSaveContext = 0;
    RECT rectBounds = m_rcBounds;

    if(hdcDraw==NULL)
        return E_INVALIDARG;

    iSaveContext = ::SaveDC(hdcDraw);

    ::LPtoDP(hdcDraw, reinterpret_cast<LPPOINT>(&rectBounds), 2 );

    ::SetViewportOrgEx(hdcDraw, 0, 0, NULL);

    // Add code for high-quality here...
    PaintToDC(hdcDraw, &rectBounds, FALSE);

    ::RestoreDC(hdcDraw, iSaveContext);

    return S_OK;
}

/*==========================================================================*/

HRESULT CSpriteCtl::ParseFrameMapEntry(LPTSTR pszEntry, CFrameMap **ppFrameMap)
{
    HRESULT hRes = S_OK;

    ASSERT (ppFrameMap != NULL);

    *ppFrameMap = NULL;

    CLineParser parser(pszEntry, FALSE); // No compaction needed

    if (parser.IsValid())
    {
        parser.SetCharDelimiter(TEXT(','));
        *ppFrameMap = New CFrameMap();

        if (NULL != *ppFrameMap)
        {
            hRes = parser.GetFieldInt( &((*ppFrameMap)->m_iImg) );

            if (S_OK == hRes)
                hRes = parser.GetFieldDouble( &((*ppFrameMap)->m_dblDuration) );

            if (S_OK == hRes)
            {
                BOOL fAllocated = (*ppFrameMap)->m_tstrMarkerName.AllocBuffer(lstrlen(parser.GetStringPointer(TRUE)) + 1);

                if (fAllocated)
                    hRes = parser.GetFieldString( (*ppFrameMap)->m_tstrMarkerName.psz() );
            }

            if ( !SUCCEEDED(hRes) ) // It's OK if there isn't a name
            {
                // If we didn't get the whole thing, delete the FrameMap entry
                Delete *ppFrameMap;
                *ppFrameMap = NULL;
            }
            else
            {
                // Get the length correct
                (*ppFrameMap)->m_tstrMarkerName.ResetLength();
        
                if (S_FALSE == hRes)
                    hRes = S_OK;
            }

        }
        else
        {
            // Couldn't allocate a CFrameMap
            hRes = E_OUTOFMEMORY;
        }
    }
    else
    {
        // Couldn't initialize the parser
        hRes = E_OUTOFMEMORY;
    }

    return hRes;
}

/*==========================================================================*/

HRESULT CSpriteCtl::PersistFrameMaps(IVariantIO *pvio, BOOL fLoading)
{
    HRESULT hRes = S_OK;

    if (fLoading)
    {
        BSTR bstrLine = NULL;

        hRes = pvio->Persist(0,
            "FrameMap", VT_BSTR, &bstrLine,
            NULL);

        if (S_OK == hRes)
        {
            hRes = put_FrameMap(bstrLine);
            SysFreeString(bstrLine);
        }
    }
    else
    {
        BSTR bstrLine = NULL;
        hRes = get_FrameMap(&bstrLine);

        if (SUCCEEDED(hRes))
        {
            hRes = pvio->Persist(0,
                "FrameMap", VT_BSTR, &bstrLine,
                NULL);
        }

        SysFreeString(bstrLine);
    }

    return hRes;
}

/*==========================================================================*/

HRESULT CSpriteCtl::PersistFrameMarkers(IVariantIO *pvio, BOOL fLoading)
{
    HRESULT hRes = S_OK;

    if (fLoading)
    {
        char rgchTagName[20]; // Construct tag name in here (ANSI)
        int iLine = 1;
        BSTR bstrLine = NULL;

        int iFrame = 0;
        LPTSTR pszMarkerName = NULL;
        CLineParser parser;

        m_drgFrameMarkers.MakeNullAndDelete();
        CTStr tstrMarkerName;
        LPWSTR pszwMarkerName = NULL;

        while (S_OK == hRes)
        {
            pszMarkerName = NULL;

            wsprintf(rgchTagName, "AddFrameMarker%lu", iLine++);
            hRes = pvio->Persist(0,
                    rgchTagName, VT_BSTR, &bstrLine,
                    NULL);

            if (S_OK == hRes) // Read in the tag
            {
                parser.SetNewString(bstrLine);
                                parser.SetCharDelimiter(TEXT(','));
                SysFreeString (bstrLine);
                bstrLine = NULL;

                if (parser.IsValid())
                {
                    hRes = parser.GetFieldInt(&iFrame);
                    if (S_OK == hRes)
                    {
                        // Allocate space of at least the remaining length of the tag
                        pszMarkerName = New TCHAR [lstrlen(parser.GetStringPointer(TRUE))];

                        if (pszMarkerName)
                        {
                            // Get the string
                            hRes = parser.GetFieldString(pszMarkerName);
                            if (SUCCEEDED(hRes))
                            {
                                bool fAbsolute = false;

                                if (S_OK == hRes)
                                {
                                    int iTemp = 1;
                                    hRes = parser.GetFieldInt(&iTemp);

                                    // 0 is the only thing we consider
                                                                        fAbsolute = (0 == iTemp) ? false : true;
                                }

                                if (SUCCEEDED(hRes))
                                {
                                    // Set up the CTStr, so we can get back a Unicode string
                                    // No copies are involved, except for (possibly) the conversion to Unicode
                                    tstrMarkerName.SetStringPointer(pszMarkerName);
                                    pszwMarkerName = tstrMarkerName.pszW();
        
                                    if (NULL != pszwMarkerName)
                                    {
                                                                                // If absolute, set the absolute frame marker to TRUE. This will speed up sequence frames later
                                                                                if (!m_fFireAbsoluteFrameMarker && fAbsolute)
                                                                                        m_fFireAbsoluteFrameMarker =  TRUE;

                                        // Construct a FrameMarker object
                                        CFrameMarker *pFrameMarker = New CFrameMarker(iFrame, pszwMarkerName, fAbsolute);
                                
                                        hRes = AddFrameMarkerElement(&pFrameMarker);
                                    }
                                    else
                                    {
                                        hRes = E_OUTOFMEMORY;
                                    }

                                    // Let make sure we don't leak the string
                                    tstrMarkerName.SetStringPointer(NULL, FALSE);
                                
                                    if (NULL != pszwMarkerName)
                                    {
                                        Delete [] pszwMarkerName;
                                        pszwMarkerName = NULL;
                                    }
                                }
                            }

                        }
                        else
                        {
                                hRes = E_OUTOFMEMORY;
                        }

                        if (!parser.IsEndOfString())
                        {
                                hRes = E_FAIL;
                        }
                    }

                }
                else
                {
                    // Only reason parser isn't valid is if we don't have memory
                    hRes = E_OUTOFMEMORY;
                }

#ifdef _DEBUG
                if (E_FAIL == hRes)
                {
                    TCHAR rgtchErr[100];
                    wsprintf(rgtchErr, TEXT("SpriteCtl: Error in AddFrameMarker%lu \n"), iLine - 1);
                    DEBUGLOG(rgtchErr);
                }
#endif
            }

            // Free up the temporary string
            if (NULL != pszMarkerName)
                Delete [] pszMarkerName;
        }
    }
    else
    {
        // Save stuff out
        int iLine = 1;
        int iNumItems = m_drgFrameMarkers.Count();

        char rgchTagName[21];
        LPTSTR pszMarker = NULL;
        CTStr tstr;
        CTStr tstrMarkerName;
        CFrameMarker *pMarker;

        while ( (iLine <= iNumItems) && (S_OK == hRes) )
        {
            // Create the param name
            wsprintfA(rgchTagName, "AddFrameMarker%lu", iLine);

            // Now build up the tag
            pMarker = m_drgFrameMarkers[iLine - 1];
#ifdef _UNICODE
            // Avoid a redundant copy in Unicode
            tstrMarkerName.SetStringPointer(pMarker->m_bstrMarkerName);
#else
            // We need to do the conversion to ANSI anyway so copy
            tstrMarkerName.SetString(pMarker->m_bstrMarkerName);
#endif
            tstr.AllocBuffer(tstrMarkerName.Len() + 1);
            pszMarker = tstr.psz();

            int iAbsolute = (pMarker->m_fAbsolute) ? 1 : 0;

            // Because we used SetStringPointer. pszMarker is still valid
            wsprintf(pszMarker, TEXT("%lu,%s,%lu"), pMarker->m_iFrame, tstrMarkerName.psz(), iAbsolute);

            // Allocate a BSTR from what we constructed
            BSTR bstrLine = tstr.SysAllocString();

            // And write it out
            hRes = pvio->Persist(0,
                    rgchTagName, VT_BSTR, &bstrLine,
                    NULL);
            SysFreeString(bstrLine);

            iLine++;
#ifdef _UNICODE
            // For ANSI, the class will take care of freeing up any memory it has used
            tstrMarkerName.SetStringPointer(NULL, FALSE);
#endif
        }
    }

    return hRes;
}

/*==========================================================================*/

HRESULT CSpriteCtl::PersistTimeMarkers(IVariantIO* pvio, BOOL fLoading)
{
    HRESULT hRes = S_OK;

    if (fLoading)
    {
        int iLine = 1;

                // Poor design - We have two references to 
                // the first time marker in the list.  We need
                // to NULL this pointer out, and defer the 
                // actual deletion to the 
                // m_drgTimeMarkers.MakeNullAndDelete call.
                if (NULL != m_ptmFirst)
                {
                        m_ptmFirst = NULL;
                }
        m_drgTimeMarkers.MakeNullAndDelete();
        CTimeMarker *pTimeMarker;

        while (S_OK == hRes)
        {
            hRes = ParseTimeMarker(pvio, iLine++, &pTimeMarker, &m_ptmFirst);
            if (S_OK == hRes)
            {
                hRes = AddTimeMarkerElement(&pTimeMarker);
            }
        }
    }
    else // Saving
    {
        int iLine = 1;
        int iNumItems = m_drgTimeMarkers.Count();

        while ( (iLine <= iNumItems) && (S_OK == hRes) )
        {
            hRes = WriteTimeMarker(pvio, iLine, m_drgTimeMarkers[iLine - 1]);
            iLine++;
        }

    }
    return hRes;
}

/*==========================================================================*/

HRESULT CSpriteCtl::AddTimeMarkerElement(CTimeMarker **ppNewMarker)
{
    HRESULT hRes = S_OK;

    if ( (*ppNewMarker) && (NULL != (*ppNewMarker)->m_pwszMarkerName) )
    {
        m_drgTimeMarkers.Insert(*ppNewMarker);
    }
    else
    {
        if (NULL != *ppNewMarker)
        {
                Delete *ppNewMarker;
                *ppNewMarker = NULL;
        }

        hRes = E_OUTOFMEMORY;
    }

    return hRes;
}

/*==========================================================================*/

HRESULT CSpriteCtl::AddFrameMarkerElement(CFrameMarker **ppNewMarker)
{
    HRESULT hRes = S_OK;

    if ( (*ppNewMarker) && (NULL != (*ppNewMarker)->m_bstrMarkerName) )
    {
        m_drgFrameMarkers.Insert(*ppNewMarker);
    }
    else
    {
        if (NULL != *ppNewMarker)
        {
            Delete *ppNewMarker;
            *ppNewMarker = NULL;
        }

        hRes = E_OUTOFMEMORY;
    }

    return hRes;
}

/*==========================================================================*/
//
// ISpriteCtl implementation
//

HRESULT STDMETHODCALLTYPE CSpriteCtl::get_AutoStart(VARIANT_BOOL __RPC_FAR *fAutoStart)
{
    HANDLENULLPOINTER(fAutoStart);

    *fAutoStart = BOOL_TO_VBOOL(m_fAutoStart);

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::put_AutoStart(VARIANT_BOOL fAutoStart)
{
    m_fAutoStart = VBOOL_TO_BOOL(fAutoStart);
    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::get_Frame(unsigned int __RPC_FAR *piFrame)
{
    if (!m_fDesignMode)
    {
        HANDLENULLPOINTER(piFrame);

        if (Playing == m_enumPlayState)
        {
            int iFrame = GetFrameFromTime(m_dblCurrentTick-m_dblBaseTime);
            iFrame %= m_iFrameCount;
            *piFrame = (iFrame + 1);
        }
        else if (Paused == m_enumPlayState)
        {
            int iFrame = GetFrameFromTime(m_dblTimePaused-m_dblBaseTime);
            iFrame %= m_iFrameCount;
            *piFrame = (iFrame + 1);
        }
        else
        {
            *piFrame = (m_iInitialFrame + 1);
        }

        return S_OK;
    }
    else
    {
        return CTL_E_GETNOTSUPPORTED;
    }
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::put_Frame(unsigned int iFrame)
{
    HRESULT hRes = S_OK;

    if (!m_fDesignMode)
    {
        hRes = FrameSeek(iFrame);
    }
    else
    {
        return CTL_E_SETNOTSUPPORTED;
    }

    return hRes;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::get_FrameMap(BSTR __RPC_FAR *FrameMap)
{
    HANDLENULLPOINTER(FrameMap);

    *FrameMap = m_tstrFrameMap.SysAllocString();

    // Do we need to check that BSTR allocation worked ?
    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::put_FrameMap(BSTR FrameMap)
{
    HRESULT hRes = S_OK;

    if (m_enumPlayState == Stopped)
    {
        if (FrameMap == NULL)
            return S_OK;

        CLineParser parser(FrameMap);
        CTStr tstr(lstrlenW(FrameMap) + 1);

        if ( (NULL != tstr.psz()) && (parser.IsValid()) )
        {
            // Clear out the list
            m_drgFrameMaps.MakeNullAndDelete();
            m_tstrFrameMap.FreeBuffer();
            m_dblDuration = 0.0f;

            parser.SetCharDelimiter(TEXT(';'));

            while ( !parser.IsEndOfString() && (hRes == S_OK) )
            {
                hRes = parser.GetFieldString( tstr.psz() );

                if (SUCCEEDED(hRes))
                {
                    CFrameMap *pNewFrameMap;
                    hRes = ParseFrameMapEntry(tstr.psz(), &pNewFrameMap);
                    if (SUCCEEDED(hRes))
                    {
                        m_drgFrameMaps.Insert(pNewFrameMap);
                        m_dblDuration += pNewFrameMap->m_dblDuration;
                    }
                }
            }

            if ( SUCCEEDED(hRes) ) // S_FALSE and S_OK both permissible
            {
                m_tstrFrameMap.SetString(parser.GetStringPointer(FALSE));
                hRes = (NULL != m_tstrFrameMap.psz()) ? S_OK : E_OUTOFMEMORY;
            }
        }
        else
        {
                // Couldn't allocate a string for the line
                hRes = E_OUTOFMEMORY;
        }
    }
    else
    {
        return CTL_E_SETNOTPERMITTED;
    }

    return hRes;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::get_InitialFrame(int __RPC_FAR *iFrame)
{
    HANDLENULLPOINTER(iFrame);

    *iFrame = (m_iInitialFrame + 1);
    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::put_InitialFrame(int iFrame)
{
    if (iFrame < -1)
        return DISP_E_OVERFLOW;

    m_iInitialFrame = iFrame - 1;
    // Load the initial sprite
    ShowImage(m_iInitialFrame);

    // Set the m_iFrame 
    m_iFrame = (m_iInitialFrame < 0) ? 0 : m_iInitialFrame;

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::get_FinalFrame(int __RPC_FAR *iFrame)
{
    HANDLENULLPOINTER(iFrame);

    *iFrame = (m_iFinalFrame + 1);
    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::put_FinalFrame(int iFrame)
{
    if (iFrame < -1)
        return DISP_E_OVERFLOW;

    m_iFinalFrame = iFrame - 1;

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::get_Iterations(int __RPC_FAR *iRepeat)
{
    HANDLENULLPOINTER(iRepeat);

    get_Repeat(iRepeat);
    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::put_Iterations(int iRepeat)
{
    put_Repeat(iRepeat);
    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::get_Library(IDAStatics __RPC_FAR **ppLibrary)
{
    HANDLENULLPOINTER(ppLibrary);

    if (!m_fDesignMode)
    {
        if (m_StaticsPtr)
        {
            // AddRef since this is really a Query...
            m_StaticsPtr.p->AddRef();

            // Set the return value...
            *ppLibrary = m_StaticsPtr.p;
        }
    }
    else
    {
        return CTL_E_GETNOTSUPPORTED;
    }

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::get_Repeat(int __RPC_FAR *iRepeat)
{
    HANDLENULLPOINTER(iRepeat);

    *iRepeat = m_iRepeat;
    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::put_Repeat(int iRepeat)
{
    m_iRepeat = iRepeat;
    if (m_iRepeat < -1)
        m_iRepeat = -1;
    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::get_PlayRate(double __RPC_FAR *dblSpeed)
{
    HANDLENULLPOINTER(dblSpeed);

    *dblSpeed = m_dblUserPlayRate;

    return S_OK;
}

void CSpriteCtl::CalculateEffectiveTimerInterval()
// Calculate the effective timer interval from the 
// current user timer interval and the current play rate
{
    // Convert m_dblTimerInterval to seconds and adjust the limits
    m_dblTimerInterval = m_dblUserTimerInterval / m_dblPlayRate;
    if (m_dblTimerInterval < 0.0) m_dblTimerInterval *= -1;
    m_dblTimerInterval = max(m_dblTimerInterval, 0.02);
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::put_PlayRate(double dblSpeed)
{
    m_dblUserPlayRate = m_dblPlayRate = dblSpeed;

    // Check the limits of play rate
    if (m_dblPlayRate >= 0)
        m_dblPlayRate = max(m_dblPlayRate, 0.0000001);
    else
        m_dblPlayRate = min(m_dblPlayRate, -0.0000001);

    CalculateEffectiveTimerInterval();

    // TODO: Rebuild the imagelist and Update the sprite image
    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::get_Time(double __RPC_FAR *pdblTime)
{
    HANDLENULLPOINTER(pdblTime);

    // This property is only available at run-time
    if (m_fDesignMode)
        return CTL_E_GETNOTSUPPORTED;

    // Find the current time
        if (Stopped == m_enumPlayState || (DWORD)(m_dblDuration * 1000) == 0)
        {
                *pdblTime = 0.0;
        }
        else if (Playing == m_enumPlayState)
        {
                // Time passed so far in the current cycle
                DWORD dwTick = (DWORD)((m_dblCurrentTick - m_dblBaseTime) * 1000);
                dwTick %= (DWORD)(m_dblDuration * 1000);
                // Add any time during the previous cycles
                dwTick += (DWORD)(((m_iCurCycle-1) * m_dblDuration) * 1000);
                *pdblTime = (double)dwTick / 1000;
        }
        else if (Paused == m_enumPlayState)
        {
                // Time passed so far in the current cycle
                DWORD dwTick = (DWORD)((m_dblTimePaused - m_dblBaseTime) * 1000);
                dwTick %= (DWORD)(m_dblDuration * 1000);
                // Add any time during the previous cycles
                dwTick += (DWORD)(((m_iCurCycle-1) * m_dblDuration) * 1000);
                *pdblTime = (double)dwTick / 1000;
        }

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::get_MaximumRate(unsigned int __RPC_FAR *iFps)
{
    HANDLENULLPOINTER(iFps);
    *iFps = m_iMaximumRate;
    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::put_MaximumRate(unsigned int iFps)
{
    if (iFps > 0)
        m_iMaximumRate = min(iFps,30);
    else
        return DISP_E_OVERFLOW;
    
    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::get_NumFrames(unsigned int __RPC_FAR *iNumFrames)
{
    HANDLENULLPOINTER(iNumFrames);

    *iNumFrames = m_iNumFrames;

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::put_NumFrames(unsigned int iNumFrames)
{
        // Set the number of frames and check its limits
    m_iNumFrames = iNumFrames;
        
    if (m_iNumFrames <= 0)
            m_iNumFrames = 1;

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::get_PlayState(PlayStateConstant __RPC_FAR *PlayState)
{
    if (!m_fDesignMode)
    {
        HANDLENULLPOINTER(PlayState);

                if (m_fAutoStart && !m_fOnWindowLoadFired)
                {
                *PlayState = Playing;
                }
                else
                {
                *PlayState = m_enumPlayState;
                }
        return S_OK;
    }
    else
    {
        return CTL_E_GETNOTSUPPORTED;
    }
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::get_NumFramesAcross(unsigned int __RPC_FAR *iFrames)
{
    HANDLENULLPOINTER(iFrames);

    *iFrames = m_iNumFramesAcross;

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::put_NumFramesAcross(unsigned int iFrames)
{
        // Set the number of frames across and check its limits
    m_iNumFramesAcross = iFrames;
        if (m_iNumFramesAcross <= 0)
            m_iNumFramesAcross = 1;

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::get_NumFramesDown(unsigned int __RPC_FAR *iFrames)
{
    HANDLENULLPOINTER(iFrames);

    *iFrames = m_iNumFramesDown;

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::put_NumFramesDown(unsigned int iFrames)
{
        // Set the number of frames down and check its limits
    m_iNumFramesDown = iFrames;
        if (m_iNumFramesDown <= 0)
            m_iNumFramesDown = 1;

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::get_UseColorKey(VARIANT_BOOL __RPC_FAR *Solid)
{
    HANDLENULLPOINTER(Solid);

    *Solid = BOOL_TO_VBOOL(m_fUseColorKey);

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::put_UseColorKey(VARIANT_BOOL Solid)
{
    m_fUseColorKey = VBOOL_TO_BOOL(Solid);

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::get_Image(IDAImage __RPC_FAR **ppImage)
{
    HRESULT hr = S_OK;

    HANDLENULLPOINTER(ppImage);

    if (FAILED(hr = InitializeObjects()))
        return hr;

    if (m_ImagePtr)
    {
        // AddRef since this is really a Query...
        m_ImagePtr.p->AddRef();

        // Set the return value...
        *ppImage = m_ImagePtr.p;
    }

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::put_Image(IDAImage __RPC_FAR *pImage)
{
    HRESULT hr = S_OK;
    HANDLENULLPOINTER(pImage);

    // Stop any currently playing
    Stop();

    if (FAILED(hr = InitializeObjects()))
        return hr;

    // This will free any existing image and then use
    // the one passed into this method...
    if (SUCCEEDED(hr = UpdateImage(pImage)))
        hr = ShowImage(m_iInitialFrame);

    return hr;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::get_ColorKey(IDAColor __RPC_FAR **pColorKey)
{
    if (!m_fDesignMode)
    {
        HANDLENULLPOINTER(*pColorKey);
        *pColorKey = NULL;
        HRESULT hr = S_OK;

        if (m_fUseColorKey)
        {
            CComPtr<IDAColor> ColorPtr;
        
            if (FAILED(hr = m_StaticsPtr->ColorRgb255( (short)m_byteColorKeyR, (short)m_byteColorKeyG, (short)m_byteColorKeyB, &ColorPtr)))
                return hr;

            ColorPtr.p->AddRef();
            *pColorKey = ColorPtr.p;
        }
        
        return hr;
    }
    else
    {
        return CTL_E_GETNOTSUPPORTED;
    }
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::put_ColorKey(IDAColor __RPC_FAR *pColorKey)
{
    if (!m_fDesignMode)
    {
        HANDLENULLPOINTER(pColorKey);
        HRESULT hr = S_OK;
        double dblTemp;
        
        CComPtr<IDANumber> RedPtr, GreenPtr, BluePtr;

        // Make sure we get all the values successfully before converting
        if (FAILED(hr = pColorKey->get_Red(&RedPtr)))
            return hr;

        if (FAILED(hr = pColorKey->get_Green(&GreenPtr)))
            return hr;

        if (FAILED(hr = pColorKey->get_Blue(&BluePtr)))
            return hr;

        if (FAILED(hr = RedPtr->Extract(&dblTemp)))
            return hr;

        m_byteColorKeyR = (int)(dblTemp * 255.0);

        if (FAILED(hr = GreenPtr->Extract(&dblTemp)))
            return hr;

        m_byteColorKeyG = (int)(dblTemp * 255.0);

        if (FAILED(hr = BluePtr->Extract(&dblTemp)))
            return hr;

        m_byteColorKeyB = (int)(dblTemp * 255.0);

            // Stop any currently playing and reload the image
                Stop();
                UpdateImage(NULL);
                InitializeImage();
                ShowImage(m_iInitialFrame);
        
        return S_OK;
    }
    else
    {
        return CTL_E_SETNOTSUPPORTED;
    }
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::get_ColorKeyRGB(COLORREF* pColorKeyRGB)
{
    HANDLENULLPOINTER(pColorKeyRGB);

    if (m_fDesignMode)
    {
        *pColorKeyRGB = RGB((BYTE)m_byteColorKeyR, (BYTE)m_byteColorKeyG, (BYTE)m_byteColorKeyB);
        return S_OK;
    }
    else
    {
        return CTL_E_GETNOTSUPPORTEDATRUNTIME;
    }
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::put_ColorKeyRGB(COLORREF ColorKeyRGB)
{
    if (m_fDesignMode)
    {
        m_byteColorKeyR = (int)GetRValue(ColorKeyRGB);
        m_byteColorKeyG = (int)GetGValue(ColorKeyRGB);
        m_byteColorKeyB = (int)GetBValue(ColorKeyRGB);
        return S_OK;
    }
    else
    {
        return CTL_E_SETNOTSUPPORTEDATRUNTIME;
    }
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::get_SourceURL(BSTR __RPC_FAR *bstrSourceURL)
{
    HANDLENULLPOINTER(bstrSourceURL);

    if (*bstrSourceURL)
        SysFreeString(*bstrSourceURL);

    *bstrSourceURL = SysAllocString(m_bstrSourceURL);

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::put_SourceURL(BSTR bstrSourceURL)
{
    HRESULT hr = S_OK;

    if (bstrSourceURL)
    {
        BSTR bstrNewURL = SysAllocString(bstrSourceURL);

        if (bstrNewURL)
        {
            if (m_bstrSourceURL)
            {
                                // Stop any currently playing and reload the image
                                if (m_enumPlayState != Stopped) Stop();
                                UpdateImage(NULL);
                SysFreeString(m_bstrSourceURL);
                m_bstrSourceURL = NULL;
            }

            m_bstrSourceURL = bstrNewURL;
        }
        else
        {
            hr = S_FALSE;
        }
    }
    else
    {
        if (m_bstrSourceURL)
        {
            SysFreeString(m_bstrSourceURL);
            m_bstrSourceURL = NULL;
        }
    }

    return hr;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::get_MouseEventsEnabled(VARIANT_BOOL __RPC_FAR *Enabled)
{
    HANDLENULLPOINTER(Enabled);

    *Enabled = BOOL_TO_VBOOL(m_fMouseEventsEnabled);
    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::put_MouseEventsEnabled(VARIANT_BOOL Enabled)
{
    m_fMouseEventsEnabled = VBOOL_TO_BOOL(Enabled);

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::get_TimerInterval(double *pdblTimerInterval)
{
    HANDLENULLPOINTER(pdblTimerInterval);

    *pdblTimerInterval = m_dblUserTimerInterval;

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::put_TimerInterval(double dblTimerInterval)
{
    if (dblTimerInterval < 0.0)
        return E_INVALIDARG;

    m_dblUserTimerInterval = m_dblTimerInterval = dblTimerInterval;

    // Recalculate the timer interval using the user play rate
    CalculateEffectiveTimerInterval();

    return S_OK;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::AddFrameMarker(unsigned int iFrame, BSTR MarkerName, VARIANT varAbsolute)
{
    BOOL fAbsolute = FALSE;

    if (!ISEMPTYARG(varAbsolute))
        {
        VARIANT varTarget;
        VariantInit(&varTarget);

        if (SUCCEEDED(VariantChangeTypeEx(&varTarget, &varAbsolute, LANGID_USENGLISH, 0, VT_BOOL)))
            fAbsolute = VBOOL_TO_BOOL(V_BOOL(&varTarget));
        else
            return DISP_E_TYPEMISMATCH;
        }

        // If absolute, set the absolute frame marker to TRUE. This will speed up sequence frames later
        if (!m_fFireAbsoluteFrameMarker && fAbsolute)
                m_fFireAbsoluteFrameMarker =  TRUE;

    CFrameMarker *pNewMarker = New CFrameMarker(iFrame, MarkerName, fAbsolute ? true : false);

    return AddFrameMarkerElement(&pNewMarker);
}

/*==========================================================================*/

void FireSpriteMarker(IConnectionPointHelper* pconpt, CTimeMarker* pmarker, boolean bPlaying)
{
    BSTR bstr = SysAllocString(pmarker->m_pwszMarkerName);

    if (bPlaying) {
        FIRE_ONPLAYMARKER(pconpt, bstr);
    }

    FIRE_ONMARKER(pconpt, bstr);

    SysFreeString(bstr);
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::AddTimeMarker(double dblTime, BSTR bstrMarkerName, VARIANT varAbsolute)
{
    BOOL fAbsolute = TRUE;

    if (!ISEMPTYARG(varAbsolute))
        {
        VARIANT varTarget;
        VariantInit(&varTarget);

        if (SUCCEEDED(VariantChangeTypeEx(&varTarget, &varAbsolute, LANGID_USENGLISH, 0, VT_BOOL)))
            fAbsolute = VBOOL_TO_BOOL(V_BOOL(&varTarget));
        else
            return DISP_E_TYPEMISMATCH;
        }


    CTimeMarker *pNewMarker = New CTimeMarker(&m_ptmFirst, dblTime, bstrMarkerName, (boolean) fAbsolute);

    return AddTimeMarkerElement(&pNewMarker);
}

/*==========================================================================*/

double CSpriteCtl::GetTimeFromFrame(int iFrame)
// Returns the time at iFrame
{
    if (m_dblTimerInterval <= 0 || m_dblDuration <= 0 || iFrame <= 0)
            return 0;

    int nFrameMapsCount = m_drgFrameMaps.Count();

    if (nFrameMapsCount <= 0)
    // Regular animation using play rate
    {
            return iFrame * m_dblTimerInterval;
    }

    // Frame map; loop through each frame to get the time
    int nLoops = iFrame / nFrameMapsCount;
    double dblTotalTime = nLoops * m_dblDuration;   // Time of the frame maps
    for (int i=0; i < (iFrame % nFrameMapsCount); i++)
    {
        int j = (m_dblPlayRate >= 0.0) ? i : (nFrameMapsCount-1-i);
        dblTotalTime += m_durations[j]; // (m_drgFrameMaps[j]->m_dblDuration / m_dblPlayRate);
    }
    return dblTotalTime;
}

/*==========================================================================*/

int CSpriteCtl::GetFrameFromTime(double dblTime, double* pdblDuration/*=NULL*/)
// Returns the absolute frame at dblTime
// Assumes that m_dblTimerInterval and m_dblDuration are already set 
// Outs pdblDuration - the time remaining in the current frame
{
    if (m_dblTimerInterval <= 0 || m_dblDuration <= 0 || m_iFrameCount <= 0 || dblTime <= 0.0)
            return 0;

    // Initialize the duration to 0.0
    if (pdblDuration)
        *pdblDuration = 0.0;

    int nFrameMapsCount = m_drgFrameMaps.Count();

    if (nFrameMapsCount <= 0)
    // Regular animation using play rate
    {
        int iFrame = (int)(dblTime / m_dblTimerInterval);
        // Calculate the time remaining in iFrame
        if (pdblDuration)
            *pdblDuration = ((iFrame+1) * m_dblTimerInterval) - dblTime;
        return iFrame;
    }

    // Frame map; loop through each frame to get the frame
    double dblTotalTime = 0.0;      // Time of the frame maps
    int nLoops = (int)(dblTime/m_dblDuration);      // Number of loops traversed so far
    double dblFrameTime = dblTime - (nLoops * m_dblDuration);       // Relative time of the frame
    for (int i=0; i<nFrameMapsCount; i++)
    {
        int j = (m_dblPlayRate >= 0.0) ? i : (nFrameMapsCount-1-i);
        dblTotalTime += m_durations[j]; // (m_drgFrameMaps[j]->m_dblDuration / m_dblPlayRate);
        if (dblTotalTime > dblFrameTime)
        {
            // Calculate the time remaining in iFrame
            if (pdblDuration)
                *pdblDuration = dblTotalTime - dblFrameTime;
            break;
        }
    }
    return (i + (nLoops*nFrameMapsCount));
}

/*==========================================================================*/

HRESULT CSpriteCtl::Resume (void)
{
        HRESULT hr = S_OK;
        // Find the frame at which we paused
        double dblDuration=0.0;
        int iFrame = GetFrameFromTime(m_dblTimePaused - m_dblBaseTime, &dblDuration);

        // Resequence the frames starting with iFrame
        if (FAILED(hr = SequenceFrames(iFrame, dblDuration))) 
            return hr;

        // increment the current cycle
                m_iCurCycle++;

                // Update the base time to reflect the time paused
        double dblDelta = (GetCurrTime() - m_dblTimePaused); 
        m_dblBaseTime += dblDelta;
        m_dblCurrentTick += dblDelta;
        m_dblTimePaused = 0.0;

        // Restart the clock
        hr = m_clocker.Start();

                // Switch to the sequenced behaviour
                m_PlayImagePtr->SwitchTo(m_FinalBehaviorPtr);
                // Fire any starting frame Callouts
                FireFrameMarker(m_iStartingFrame);

                return hr;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::Play(void)
{
    HRESULT hr = S_OK;

    if (Playing != m_enumPlayState)
    {
        if (m_iRepeat == 0)
        {   // Need not play, so just show the initial sprite image
            return ShowImage(m_iInitialFrame);
        }

        if (Paused != m_enumPlayState)
        {
            hr = StartPlaying();
        }
        else
        {
            hr = Resume();
        }
        
        if (SUCCEEDED(hr))
        {
            m_enumPlayState = Playing;

                        FIRE_ONPLAY(m_pconpt);
        }
    }

    return hr;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::Stop(void)
{
    HRESULT hr = S_OK;

    if (m_enumPlayState != Stopped)
    {
        m_enumPlayState = Stopped;
        m_dblBaseTime = m_dblCurrentTick = 0.0;
        m_dblPreviousTime = 0;

        // Show the initial sprite image
        if (m_iFinalFrame >= -1)
            ShowImage(m_iFinalFrame == -1 ? m_iInitialFrame : m_iFinalFrame);

        InvalidateControl(NULL, TRUE);

        m_clocker.Stop();

        m_iCurCycle = m_iStartingFrame = 0;
        m_iFrame = (m_iInitialFrame < 0) ? 0 : m_iInitialFrame;

                FIRE_ONSTOP(m_pconpt);
    }
    else    // REVIEW: Is this else block necessary???
    {
        // Show the final sprite image
        if (m_iFinalFrame >= -1)
            ShowImage(m_iFinalFrame == -1 ? m_iInitialFrame : m_iFinalFrame);
    }

    return hr;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::Pause(void)
{
    HRESULT hr = S_OK;

    if (Playing == m_enumPlayState)
    {
        // Stop the clock from ticking.
        hr = m_clocker.Stop();
        ASSERT(SUCCEEDED(hr));

        if (SUCCEEDED(hr))
        {
            m_enumPlayState = Paused;
            m_dblCurrentTick = m_dblTimePaused = GetCurrTime();
            int iFrame = GetFrameFromTime(m_dblCurrentTick-m_dblBaseTime);
            iFrame %= m_iFrameCount;
            ShowImage(iFrame, TRUE);

            FIRE_ONPAUSE(m_pconpt);
        }
    }

    return hr;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::Seek(double dblTime)
// Seek to the frame at dblTime
{
    // Find the frame at dblTime and seek from that frame
    HRESULT hr = S_OK;
    double dblDuration = 0.0;
    int iFrame = GetFrameFromTime(dblTime, &dblDuration);

    if (iFrame >= 0)
    {
        hr = SeekFrame(iFrame, dblDuration);

        if (!m_fOnSeekFiring)
        {
            m_fOnSeekFiring = TRUE;
            FIRE_ONSEEK(m_pconpt, dblTime);
            m_fOnSeekFiring = FALSE;
        }
    }
    else
    {
        hr = DISP_E_OVERFLOW;
    }

    return hr;
}

/*==========================================================================*/

HRESULT STDMETHODCALLTYPE CSpriteCtl::FrameSeek(unsigned int iFrame)
{
    HRESULT hr = S_OK;
    
    hr = SeekFrame(iFrame - 1);

    if (!m_fOnFrameSeekFiring)
    {
        m_fOnFrameSeekFiring = TRUE;
        FIRE_ONFRAMESEEK(m_pconpt, iFrame);
        m_fOnFrameSeekFiring = FALSE;
    }

    return hr;
}

/*==========================================================================*/

HRESULT CSpriteCtl::SeekFrame(int iFrame, double dblDuration/*=0.0*/)
// Seek to the frame at iFrame
{
    HRESULT hr = S_OK;

    // Make sure everything's been initialized
    if (FAILED(hr = InitializeImage()) || m_iFrameCount <= 0 || 
        iFrame < 0 || (m_iRepeat >= 0 && iFrame >= m_iRepeat*m_iFrameCount)) 
        return E_FAIL;

    // Set the frame number and the loop count
    m_iFrame = iFrame;
    m_iCurCycle = iFrame / m_iFrameCount;

    // Check if current cycle leaped bounds
    if (m_iRepeat >= 0 && m_iCurCycle >= m_iRepeat)
    {
        return Stop();
    }

    // Stop the current play if it's playing and restart at the new frame
    if (Playing == m_enumPlayState)
    {
        // Stop the clock from ticking.
        hr = m_clocker.Stop();
        ASSERT(SUCCEEDED(hr));

        // Sequence the frames from iFrame
        if (FAILED(hr = SequenceFrames(iFrame, dblDuration))) 
            return hr;

        // increment the current cycle
        m_iCurCycle++;

        // Reset the timers 
        m_dblCurrentTick = GetCurrTime();
        m_dblBaseTime = m_dblCurrentTick - GetTimeFromFrame(iFrame) - dblDuration;

        // Fire any time marker
        FireTimeMarker(m_dblCurrentTick - m_dblBaseTime);

        // Restart the clock
        hr = m_clocker.Start();

                // Switch to the sequenced behaviour
                m_PlayImagePtr->SwitchTo(m_FinalBehaviorPtr);
                // Fire any starting frame Callouts
                FireFrameMarker(m_iStartingFrame);

                return hr;
    } 
    else 
    {
        // Switch to this frame
        hr = ShowImage(iFrame, TRUE);

        // Fire any time markers
        double dblNewTime = GetTimeFromFrame(iFrame) + dblDuration;
        FireTimeMarker(dblNewTime);
    }

    return hr;
}

/*==========================================================================*/

HRESULT CSpriteCtl::ShowImage(int iShowFrame, BOOL bPlayRate/*=FALSE*/)
// Shows the image at frame iShowFrame
// If the iShowFrame is out of bounds then nothing happens
// Assumes that m_pArray is set and everything else is initialized properly
{
    HRESULT hr = S_OK;

    // If we are already playing then don't show the image
    if (Playing == m_enumPlayState || !m_fOnWindowLoadFired)
        return hr;

    // Load the initial sprite if it hasn't been already
    if (m_pArrayBvr == NULL || m_iFrameCount <= 0) 
        if (FAILED(hr = InitializeImage()))
            return hr;

    if (m_pArrayBvr == NULL)
        return UpdateImage(NULL);

    // Check the limits of iShowFrame
    if (iShowFrame < 0 || (m_iRepeat >= 0 && iShowFrame >= m_iRepeat*m_iFrameCount))
        iShowFrame = m_iInitialFrame;

    // If m_iInitialFrame is -ve then just show a blank image
    if (iShowFrame < 0)
        return UpdateImage(NULL);

    // Set iShowFrame to array limits of frames
    iShowFrame %= m_iFrameCount;

    if (bPlayRate && m_dblPlayRate < 0.0)
    {
        // Count the frame backwards if the play rate is -ve
        iShowFrame = m_iFrameCount-1-iShowFrame;
    }

    // Switch to the loaded image
    hr = m_PlayImagePtr->SwitchTo(m_pArrayBvr[iShowFrame]);

    // Fire any frame markers at iShowFrame (note: don't use play rate)
    FireFrameMarker(iShowFrame, FALSE);

    // Cause the tick
    OnTimer((DWORD)GetCurrTime()*1000);

    // Update the sprite
    InvalidateControl(NULL, TRUE);

    return hr;
}

/*==========================================================================*/

BSTR *
CSpriteCtl::GetCallout(unsigned long frameNum)
// Assumes that frameNum is always relative
{
        // Add one because the frame markers are 1-based, and the array is 0-based.
    frameNum++;
        for (int i = 0; i < m_drgFrameMarkers.Count(); i++) 
        {
        CFrameMarker* pmarker = m_drgFrameMarkers[i];

                // If the frame marker is absolute then update frameNum
                unsigned long iFrame = (pmarker->m_fAbsolute) ? (frameNum+m_iCurCycle*m_iFrameCount) : frameNum;

                if (iFrame == pmarker->m_iFrame) 
                {
                        return &(m_drgFrameMarkers[i]->m_bstrMarkerName);
                }
        }

        return NULL;
}

/*==========================================================================*/

class CCalloutNotifier : public IDAUntilNotifier {


  protected:
    long                     _cRefs;
    CTStr                    m_pwszFrameCallout;
    int                      _frameNum;
    IConnectionPointHelper   *m_pconpt;
    CSpriteCtl               *m_pSprite;

  public:

    // IUnknown methods
    STDMETHODIMP_(ULONG) AddRef() { return InterlockedIncrement(&_cRefs); }
    
    STDMETHODIMP_(ULONG) Release() {
        ULONG refCount = InterlockedDecrement(&_cRefs);
        if ( 0 == refCount) {
            Delete this;
            return refCount;
        }
        return _cRefs;
    }
    
    STDMETHODIMP QueryInterface (REFIID riid, void **ppv) {
        if ( !ppv )
            return E_POINTER;

        *ppv = NULL;
        if (riid == IID_IUnknown) {
            *ppv = (void *)(IUnknown *)this;
        } else if (riid == IID_IDABvrHook) {
            *ppv = (void *)(IDAUntilNotifier *)this;
        }

        if (*ppv)
          {
              ((IUnknown *)*ppv)->AddRef();
              return S_OK;
          }

        return E_NOINTERFACE;
    }
        
    STDMETHODIMP GetTypeInfoCount(UINT *pctinfo) { return E_NOTIMPL; }
    STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo) { return E_NOTIMPL; }
    STDMETHODIMP GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames,
                               LCID lcid, DISPID *rgdispid) { return E_NOTIMPL; }
    STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid,
                        WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult,
                        EXCEPINFO *pexcepinfo, UINT *puArgErr) { return E_NOTIMPL; }

    CCalloutNotifier(CSpriteCtl *pSprite, LPWSTR frameCallout, int frameNum, IConnectionPointHelper *pconpt)
        {
        ASSERT (pconpt != NULL);
        ASSERT (pSprite != NULL);

        m_pSprite = pSprite;
        
        _cRefs             = 1;
        
        // Increment the lock count on the server by one
        ::InterlockedIncrement((long *)&(g_ctlinfoSprite.pcLock));
                
        m_pwszFrameCallout.SetString(frameCallout);

                _frameNum          = frameNum;

        // The reason the pointer below is not AddRef'd is because we know we 
        // will never have to use it after the sprite control has gone away.  The 
        // sprite control maintains the refcount on the pointer
        m_pconpt           = pconpt;
        
        
        }


    ~CCalloutNotifier()
    {
        // Decrement the lock count on the server by one
        ::InterlockedDecrement((long *)&(g_ctlinfoSprite.pcLock));
    }


    STDMETHODIMP Notify(IDABehavior * eventData,
                        IDABehavior * curRunningBvr,
                        IDAView * curView,
                        IDABehavior ** ppBvr)
    {
                HANDLENULLPOINTER(ppBvr);
                HANDLENULLPOINTER(curRunningBvr);
                
                // TODO: SIMON, add script callout code here!!!  You have
                // access to the sprite object itself (_spr), and the frame
                // callout string that was passed in with AddFrameMarker
                // (_frameCallout).

        BSTR bstr = m_pwszFrameCallout.SysAllocString();
        
        if (bstr)
        {
            FIRE_ONMARKER(m_pconpt, bstr);

            if (Playing == m_pSprite->m_enumPlayState)
                FIRE_ONPLAYMARKER(m_pconpt, bstr);

            SysFreeString(bstr);
        }

                // Since this is being used in an Until() and not an
                // UntilEx(), the return value is ignored, but we need to pass
                // back a valid, correctly typed behavior, so we use
                // curRunningBvr. 
                curRunningBvr->AddRef();
                *ppBvr = curRunningBvr;
                
                return S_OK;
    }

};

HRESULT CSpriteCtl::SequenceFrames(int iStartingFrame, double dblDuration)
// Sequences the frames starting with iStarting frame
{
        HRESULT hr = S_OK;

        if (m_pArrayBvr == NULL || m_iFrameCount <= 0) 
                return E_FAIL;

    // Check if the starting frame is within our bounds
    if (iStartingFrame < 0 || (m_iRepeat >= 0 && iStartingFrame >= m_iRepeat*m_iFrameCount))
        return E_FAIL;

    // Calculate the current cycle
    m_iCurCycle = iStartingFrame / m_iFrameCount;

        // Make sure the starting frame is within the m_iFrameCount
        m_iStartingFrame = iStartingFrame % m_iFrameCount;

        // Sequence the array of behavior pointers
        CComPtr<IDABehavior> accumulatingUntil;
        bool firstTime = true;

        for (int i=m_iStartingFrame; i < m_iFrameCount; i++)
        {
        int iFrame = (m_dblPlayRate >= 0.0) ? (m_iFrameCount-1-i+m_iStartingFrame) : (i-m_iStartingFrame);

                // Get the frame marker name
        BSTR *pFrameCallout = GetCallout((m_dblPlayRate >= 0.0) ? (iFrame+1) : (iFrame-1));

                CComPtr<IDAUntilNotifier> myNotify;
                if (pFrameCallout) 
        {
            // Get the callout notifier (callback)
                        myNotify.p = (IDAUntilNotifier *) New CCalloutNotifier(this, *pFrameCallout, iFrame, m_pconpt);
                        if (!myNotify) return E_FAIL;
                }
                                
                if (firstTime) 
        {
                        if (pFrameCallout) 
            {
                // If there is a frame callback then 
                                CComPtr<IDAEvent> alwaysEvent;
                                CComPtr<IDAEvent> notifyEvent;
                                CComPtr<IDABehavior> calloutBvr;

                // Set the callout notifier to the image behavior
                if (FAILED(hr = m_StaticsPtr->get_Always(&alwaysEvent)) ||
                                        FAILED(hr = alwaysEvent->Notify(myNotify, &notifyEvent)) ||
                                        FAILED(hr = m_StaticsPtr->Until(m_pArrayBvr[iFrame], notifyEvent, m_pArrayBvr[iFrame], &calloutBvr))) 
                {
                                        return hr;
                                }
                                
                                accumulatingUntil = calloutBvr;
                                
                        } 
            else 
            {
                            // Else just set the behavior       
                                accumulatingUntil = m_pArrayBvr[iFrame];
                        }

                        firstTime = false;
                        
                } else {
                        
                        CComPtr<IDABehavior> BehaviorPtr;
                        CComPtr<IDAEvent> eventToUse;

            // Calculate the correct duration 
            double dblTime = (dblDuration && i == (m_iFrameCount-1)) ? dblDuration : m_durations[iFrame];

                        // Get the timer event for the duration
            if (FAILED(hr = m_StaticsPtr->Timer(dblTime, &eventToUse))) 
            {
                                return hr;
                        }

                        if (pFrameCallout) 
            {
                // If there is a callout add the callout notifier to the event
                                CComPtr<IDAEvent> notifyEvent;
                                if (FAILED(hr = eventToUse->Notify(myNotify, &notifyEvent))) 
                {
                                        return hr;
                                }
                                eventToUse = notifyEvent;
                        }

                        // Until the event to accumulating
            if (FAILED(hr = m_StaticsPtr->Until(m_pArrayBvr[iFrame], eventToUse, accumulatingUntil, &BehaviorPtr))) 
            {
                                return hr;
                        }
                    
                        accumulatingUntil = BehaviorPtr;
                }

        }

        m_FinalBehaviorPtr = accumulatingUntil;

    return hr;
}

/*==========================================================================*/

HRESULT CSpriteCtl::FireTimeMarker(double dblNewTime, BOOL bReset/*=FALSE*/)
{
    HRESULT hr=S_OK;

    // If reset is TRUE, fire just the events at dblNewTime
    if (bReset)
    {
        m_dblPreviousTime = dblNewTime - 0.0001;
    }

    if (dblNewTime > m_dblPreviousTime) 
    {
        // Fire all time markers between m_dblPreviousTime and dblNewTime 
        FireMarkersBetween(m_pconpt, m_ptmFirst, FireSpriteMarker, 
            m_dblPreviousTime, dblNewTime, m_dblDuration, (Playing == m_enumPlayState));
    }

    // Update previous time
    m_dblPreviousTime = dblNewTime;

    return hr;
}

/*==========================================================================*/

HRESULT CSpriteCtl::FireFrameMarker(int iFrame, BOOL bPlayRate/*=TRUE*/)
// If bPlayRate is TRUE then we will use the play rate to determine the frame
// iFrame passed in is relative. So we need to test it with the abs/rel flag
{
    HRESULT hr=S_OK;

    if (iFrame < 0 || m_iFrameCount <= 0 || (m_iRepeat >= 0 && iFrame >= m_iRepeat*m_iFrameCount)) 
        return E_FAIL;

    // Make sure iFrame is within the limits
    iFrame = iFrame % m_iFrameCount;

    if (bPlayRate && m_dblPlayRate < 0.0)
    {
        // Count the frame backwards if the play rate is -ve
        iFrame = m_iFrameCount-1-iFrame;
    }

    BSTR *pFrameCallout = GetCallout(iFrame);
    if (pFrameCallout)
    {
        BSTR bstr = SysAllocString(*pFrameCallout);
        if (bstr)
        {
            FIRE_ONMARKER(m_pconpt, bstr);
            FIRE_ONPLAYMARKER(m_pconpt, bstr);
            SysFreeString(bstr);
        }
    }

    return hr;
}

/*==========================================================================*/

HRESULT CSpriteCtl::StartPlaying (void)
{
        HRESULT hr = InitializeImage();

        if (SUCCEEDED(hr))
        {
                // Sequence the frames starting at 0 and Set the behavior 
                if (SUCCEEDED(hr = SequenceFrames(m_iFrame)))
                {
                        // Set the clocker rate to sync with the desired frame rate
                        m_clocker.SetInterval(1000/m_iMaximumRate);
                        // Increment the current cycle (must be 1)
                        m_iCurCycle++;
                        // Start the clock only if m_fStarted; else let StartModel start the clock
                    if (m_fStarted)
                        {
                                // Calculate the base time and kick off the timer
                                m_dblCurrentTick = GetCurrTime();
                                m_dblBaseTime = m_dblCurrentTick - GetTimeFromFrame(m_iFrame);
                                m_dblPreviousTime = 0;
                                hr = m_clocker.Start();

                                // Switch to the sequenced behaviour
                                m_PlayImagePtr->SwitchTo(m_FinalBehaviorPtr);
                                // Fire any starting frame Callouts
                                FireFrameMarker(m_iStartingFrame);
                        }
                        ASSERT(SUCCEEDED(hr));
                }

                InvalidateControl(NULL, TRUE);
        }

        return hr;
}

/*==========================================================================*/

HRESULT CSpriteCtl::InitializeImage(void)
// Loads, updates and builds he sprite
{
        HRESULT hr = S_OK;

        // Load image if it hasn't been loaded yet
        if (!m_ImagePtr)
        {
                CComPtr<IDAImage> ImagePtr;

                if (FAILED(hr = LoadImage(m_bstrSourceURL, &ImagePtr)))
                        return hr;

                // S_FALSE means no SourceURL was specified.  No URL, no image, no action.
                // So we don't do anything further - just return.
                if (S_FALSE == hr)
                        return S_OK;

                if (ImagePtr)
                        hr = UpdateImage(ImagePtr);

                // Fire the media loaded event only if everything goes welll and m_ImagePtr is valid
            if (SUCCEEDED(hr) && m_ImagePtr != NULL && m_fStarted)
                    FIRE_ONMEDIALOADED(m_pconpt, m_bstrSourceURL);
        }
        else // Get an empty image and build the frames
        {
                hr = BuildPlayImage();
        }

        return hr;
}

STDMETHODIMP CSpriteCtl::PaintToDC(HDC hdcDraw, LPRECT lprcBounds, BOOL fBW)
{
    HRESULT hr = S_OK;
    CComPtr<IDirectDrawSurface> DDrawSurfPtr;
    double dblCurrentTime = GetCurrTime();

    if (!lprcBounds)
        lprcBounds = &m_rcBounds;

    if (!m_ServiceProviderPtr)
    {
        if (m_pocs)
        {
            // It's OK if this fails...
            hr = m_pocs->QueryInterface(IID_IServiceProvider, (LPVOID *)&m_ServiceProviderPtr);
        }
    }

    if (!m_DirectDraw3Ptr)
    {
        // It's OK if this fails...
        hr = m_ServiceProviderPtr->QueryService(
            SID_SDirectDraw3,
            IID_IDirectDraw3,
            (LPVOID *)&m_DirectDraw3Ptr);
    }

    if (m_DirectDraw3Ptr)
    {
        ASSERT((hdcDraw!=NULL) && "Error, NULL hdcDraw in PaintToDC!!!");

        // Use DirectDraw 3 rendering...
        if (SUCCEEDED(hr = m_DirectDraw3Ptr->GetSurfaceFromDC(hdcDraw, &DDrawSurfPtr)))
        {
            if (FAILED(hr = m_ViewPtr->put_IDirectDrawSurface(DDrawSurfPtr)))
            {
                return hr;
            }

            if (FAILED(hr = m_ViewPtr->put_CompositeDirectlyToTarget(TRUE)))
            {
                return hr;
            }
        }
        else
        {
            // Fall back to generic HDC rendering services...
            if (FAILED(hr = m_ViewPtr->put_DC(hdcDraw)))
            {
                return hr;
            }
        }
    }
    else
    {
        // Use generic HDC rendering services...
        if (FAILED(hr = m_ViewPtr->put_DC(hdcDraw)))
        {
            return hr;
        }
    }

    if (FAILED(hr = m_ViewPtr->SetViewport(
        lprcBounds->left,
        lprcBounds->top,
        lprcBounds->right - lprcBounds->left,
        lprcBounds->bottom - lprcBounds->top)))
    {
        return hr;
    }

    //
    // From the HDC, get the clip rect (should be region) in
    // DC coords and convert to Device coords
    //
    RECT rcClip;  // in dc coords
    GetClipBox(hdcDraw, &rcClip);

    LPtoDP(hdcDraw, (POINT *) &rcClip, 2);

    if (FAILED(hr = m_ViewPtr->SetClipRect(
        rcClip.left,
        rcClip.top,
        rcClip.right - rcClip.left,
        rcClip.bottom - rcClip.top)))
    {
        return hr;
    }

    if (FAILED(hr = m_ViewPtr->RePaint(
        rcClip.left,
        rcClip.top,
        rcClip.right - rcClip.left,
        rcClip.bottom - rcClip.top)))
    {
        return hr;
    }

    if (!m_fStarted)
    {
        // Wait until the data is loaded
        if (m_fWaitForImportsComplete)
        {
            m_clocker.Start();
        }
        // OnTimer will poll DA and set m_fWaitForImportsComplete to false 
        // when the imports are complete
        if (!m_fWaitForImportsComplete)
            StartModel();
    }

    if (m_fStarted)
    {
        // Finally,  render into the DC (or DirectDraw Surface)...
        hr = m_ViewPtr->Render();
    }

    if (DDrawSurfPtr)
    {
        if (FAILED(hr = m_ViewPtr->put_IDirectDrawSurface(NULL)))
        {
            return hr;
        }
    }

    return hr;
}

/*==========================================================================*/

DWORD CSpriteCtl::GetCurrTimeInMillis()
{
    return timeGetTime();
}

/*==========================================================================*/

STDMETHODIMP CSpriteCtl::InvalidateControl(LPCRECT pRect, BOOL fErase)
{
    if (m_fStarted)
    {
        RECT rectPaint;

        if (pRect)
            rectPaint = *pRect;
        else
            rectPaint = m_rcBounds;
    }

    if (NULL != m_poipsw) // Make sure we have a site - don't crash IE 3.0
    {
        if (m_fControlIsActive)
            m_poipsw->InvalidateRect(pRect, fErase);
        else
            m_fInvalidateWhenActivated = TRUE;
    }

    return S_OK;
}

/*==========================================================================*/

HRESULT CSpriteCtl::UpdateImage(IDAImage *pImage)
{
    HRESULT hr = S_OK;

    if (FAILED(hr = InitializeObjects()))
        return hr;

    if (m_PlayImagePtr)
    {
        CComPtr<IDAImage> ImagePtr = pImage;

        if (ImagePtr)
          {
              CComPtr<IDAImage> TransformedImagePtr;
              CComPtr<IDABbox2> pBox;
              CComPtr<IDAPoint2> pMin, pMax;
              CComPtr<IDANumber> pLeft, pTop, pRight, pBottom;
              CComPtr<IDANumber> framesAcross, framesDown;
              CComPtr<IDANumber> two;
              CComPtr<IDANumber> imwHalf, imhHalf;
              CComPtr<IDANumber> fmwHalf, fmhHalf;
              CComPtr<IDANumber> negFmwHalf, negFmhHalf;

              m_imageWidth = NULL;
              m_imageHeight = NULL;
              m_frameWidth = NULL;
              m_frameHeight = NULL;
              m_initTransX = NULL;
              m_initTransY = NULL;
              m_minCrop = NULL;
              m_maxCrop = NULL;
              
              // Calculate the width and height of the frame as
              // behaviors. 
              if (SUCCEEDED(hr = ImagePtr->get_BoundingBox(&pBox)) &&
                  // Get the left, top, right, bottom of the bounding box
                  SUCCEEDED(hr = pBox->get_Min(&pMin)) &&
                  SUCCEEDED(hr = pBox->get_Max(&pMax)) &&
                  SUCCEEDED(hr = pMin->get_X(&pLeft)) &&
                  SUCCEEDED(hr = pMin->get_Y(&pTop)) &&
                  SUCCEEDED(hr = pMax->get_X(&pRight)) &&
                  SUCCEEDED(hr = pMax->get_Y(&pBottom)) &&
                  // Convert m_iNumFramesAcross and m_iNumFramesDown to IDANumbers
                  SUCCEEDED(hr = m_StaticsPtr->DANumber(m_iNumFramesAcross, &framesAcross)) &&
                  SUCCEEDED(hr = m_StaticsPtr->DANumber(m_iNumFramesDown, &framesDown)) &&
                  // Get the image width (right-left) and height (bottom-top)
                  SUCCEEDED(hr = m_StaticsPtr->Sub(pRight, pLeft, &m_imageWidth)) &&
                  SUCCEEDED(hr = m_StaticsPtr->Sub(pBottom, pTop, &m_imageHeight)) &&
                  // Get the frame width and height
                  SUCCEEDED(hr = m_StaticsPtr->Div(m_imageWidth, framesAcross, &m_frameWidth)) &&
                  SUCCEEDED(hr = m_StaticsPtr->Div(m_imageHeight, framesDown, &m_frameHeight)) &&

                  // Prepare values that will be used in GenerateFrameImage.
                  
                  // m_initTransX = m_imageWidth/2 - m_frameWidth/2
                  // m_initTransY = m_frameHeight/2 - m_imageHeight/2
                  SUCCEEDED(hr = m_StaticsPtr->DANumber(2, &two)) &&
                  // imwHalf = m_imageWidth/2 and fmwHalf = m_frameWidth/2
                  SUCCEEDED(hr = m_StaticsPtr->Div(m_imageWidth, two, &imwHalf)) &&
                  SUCCEEDED(hr = m_StaticsPtr->Div(m_frameWidth, two, &fmwHalf)) &&
                  SUCCEEDED(hr = m_StaticsPtr->Sub(imwHalf, fmwHalf, &m_initTransX)) &&
                  // imhHalf = m_imageHeight/2 and fmhHalf = m_frameHeight/2
                  SUCCEEDED(hr = m_StaticsPtr->Div(m_imageHeight, two, &imhHalf)) &&
                  SUCCEEDED(hr = m_StaticsPtr->Div(m_frameHeight, two, &fmhHalf)) &&
                  SUCCEEDED(hr = m_StaticsPtr->Sub(fmhHalf, imhHalf, &m_initTransY)) &&

                  // maxCrop = point2(frameWidth/2, frameHeight/2)
                  // minCrop = point2(-frameWidth/2, -frameHeight/2)
                  SUCCEEDED(hr = m_StaticsPtr->Point2Anim(fmwHalf, fmhHalf, &m_maxCrop)) &&
                  // Create -frameWidth/2 and -frameHeight/2
                  SUCCEEDED(hr = m_StaticsPtr->Neg(fmwHalf, &negFmwHalf)) &&
                  SUCCEEDED(hr = m_StaticsPtr->Neg(fmhHalf, &negFmhHalf)) &&
                  SUCCEEDED(hr = m_StaticsPtr->Point2Anim(negFmwHalf, negFmhHalf, &m_minCrop)))
                {
                }
              else
                {
                    return hr;
                }

            // Keep track of the current image...
            m_ImagePtr = ImagePtr;

            // Now build up the playable behavior from the
            // list of transform numbers...
            if (FAILED(hr = BuildPlayImage()))
                return hr;
        }
        else
        {
            // Get rid of previous image...
            m_ImagePtr = NULL;

            if (FAILED(hr = m_StaticsPtr->get_EmptyImage(&ImagePtr)))
                return hr;

            // Switch in the current image...
            hr = m_PlayImagePtr->SwitchTo(ImagePtr);
        }
    }
    else
    {
        hr = E_POINTER;
    }

    return hr;
}

/*==========================================================================*/

HRESULT CSpriteCtl::GenerateFrameImage(int iFrameIndex, IDAImage *pImage, IDAImage **ppFrameImage)
{
    HRESULT hr = S_OK;

    if (!pImage || !ppFrameImage)
        return E_POINTER;

    if ((iFrameIndex < 0) || (iFrameIndex > (int)m_iNumFrames))
      {
          hr = E_FAIL;
      }
    else
      {
          // Note: The following values have already been calculated in UpdateImage
          // m_initTransX = m_imageWidth/2 - m_frameWidth/2
          // m_initTransY = m_frameHeight/2 - m_imageHeight/2
          // maxCrop = point2(frameWidth/2, frameHeight/2)
          // minCrop = point2(-frameWidth/2, -frameHeight/2)
          CComPtr<IDATransform2> TransformPtr;

          int iFrameX = (iFrameIndex % m_iNumFramesAcross);
          int iFrameY = (iFrameIndex / m_iNumFramesAcross);

          // Find the translation points
          // transX = m_initTransX - frameWidth * iFrameX
          // transY = m_initTransY + frameHeight * iFrameY
        
          CComPtr<IDANumber> transX, transY;
          CComPtr<IDANumber> xOffsetBvr, yOffsetBvr;
          CComPtr<IDANumber> iFrameXBvr, iFrameYBvr;
          CComPtr<IDAImage> TransformedImagePtr;
          CComPtr<IDAImage> CroppedImagePtr;
        
          if (SUCCEEDED(hr = m_StaticsPtr->DANumber(iFrameX, &iFrameXBvr)) &&
              SUCCEEDED(hr = m_StaticsPtr->DANumber(iFrameY, &iFrameYBvr)) &&
              SUCCEEDED(hr = m_StaticsPtr->Mul(m_frameWidth, iFrameXBvr, &xOffsetBvr)) &&
              SUCCEEDED(hr = m_StaticsPtr->Mul(m_frameHeight, iFrameYBvr, &yOffsetBvr)) &&
              SUCCEEDED(hr = m_StaticsPtr->Sub(m_initTransX, xOffsetBvr, &transX)) &&
              SUCCEEDED(hr = m_StaticsPtr->Add(m_initTransY, yOffsetBvr, &transY)) &&

              // Build a translation by these points
              SUCCEEDED(hr = m_StaticsPtr->Translate2Anim(transX, transY, &TransformPtr)) &&
            
              SUCCEEDED(hr = pImage->Transform(TransformPtr, &TransformedImagePtr)) &&
              SUCCEEDED(hr = TransformedImagePtr->Crop(m_minCrop, m_maxCrop, &CroppedImagePtr)))
            {
                CroppedImagePtr.p->AddRef();
                *ppFrameImage = CroppedImagePtr.p;
            }
      }

    return hr;
}

/*==========================================================================*/

HRESULT CSpriteCtl::BuildPlayImage(void)
{
        HRESULT hr = S_OK;

        if (FAILED(hr = InitializeObjects()))
        {
                return hr;
        }
        else if (m_iNumFrames > 0)
        {
        // Make sure the user doesn't do something bad.  Makes one wonder
        // why we even need a NumFrames property
        if (m_iNumFrames > (m_iNumFramesDown * m_iNumFramesAcross))
            m_iNumFrames = m_iNumFramesDown * m_iNumFramesAcross;

                int iFrameIndex = 0;
                BOOL fUseFrameMap = (m_drgFrameMaps.Count() > 0); 
                m_iFrameCount = (fUseFrameMap ? m_drgFrameMaps.Count() : (int)m_iNumFrames);

                // Create the array of behaviors
                if (m_pArrayBvr != NULL)
                {
                        Delete [] m_pArrayBvr;
                        m_pArrayBvr = NULL;
                }
                m_pArrayBvr = New CComPtr<IDABehavior>[m_iFrameCount];

                // Create the array of frame durations
                if (m_durations != NULL)
                {
                        Delete [] m_durations;
                        m_durations = NULL;
                }
                m_durations = New double[m_iFrameCount];
                
                // Build an image behavior for each frame
                for(iFrameIndex=0, m_dblDuration=0;iFrameIndex<m_iFrameCount;iFrameIndex++)
                {
                        CComPtr<IDABehavior> BehaviorPtr1;
                        CComPtr<IDAImage> ImagePtr;

                        // Get the frame image
                        int iFrameImage = fUseFrameMap ? (m_drgFrameMaps[iFrameIndex]->m_iImg - 1) : iFrameIndex;
                        if (FAILED(hr = GenerateFrameImage(iFrameImage, m_ImagePtr, &ImagePtr)))
                                return hr;

                        // Set the duration of each frame
                        double dblDuration = fUseFrameMap ? (m_drgFrameMaps[iFrameIndex]->m_dblDuration / m_dblPlayRate) : m_dblTimerInterval;

            m_dblDuration += dblDuration;

                        // Add the behavior to the behavior list
                        m_pArrayBvr[iFrameIndex] = ImagePtr;
                        m_durations[iFrameIndex] = dblDuration;
                }
        }

        return hr;
}

/*==========================================================================*/

HRESULT CSpriteCtl::LoadImage(BSTR bstrURL, IDAImage **ppImage)
{
    HRESULT hr = S_OK;
    CComPtr<IDAImage> ImagePtr;

    HANDLENULLPOINTER(ppImage);
    
    *ppImage = NULL;

    // Return S_FALSE if there is no URL.  This will allow us to determine
    // if we actually loaded an image or not, without causing failure

    if (NULL == bstrURL)
        return S_FALSE;

    if (!m_fUseColorKey)
        hr = m_StaticsPtr->ImportImage(bstrURL, &ImagePtr);
    else
        hr = m_StaticsPtr->ImportImageColorKey(bstrURL, (BYTE)m_byteColorKeyR, (BYTE)m_byteColorKeyG, (BYTE)m_byteColorKeyB, &ImagePtr);

    if (SUCCEEDED(hr))
    {
        ImagePtr.p->AddRef();
        *ppImage = ImagePtr.p;
        m_fWaitForImportsComplete = false;
        m_clocker.Start();
    }

    return hr;
}

/*==========================================================================*/

BOOL CSpriteCtl::StartModel(void)
{
    BOOL fResult = FALSE;

    if (!m_fStarted)
    {
        CComPtr<IDASound> SoundPtr;
        CComPtr<IDAImage> ImagePtr;

        if (FAILED(m_ViewPtr->put_ClientSite(m_pocs)))
            return FALSE;

        if (FAILED(m_StaticsPtr->get_Silence(&SoundPtr)))
            return FALSE;

        if (FAILED(InitializeObjects()))
            return FALSE;

        if (FAILED(m_ViewPtr->StartModel(m_PlayImagePtr, SoundPtr, GetCurrTime())))
            return FALSE;

        m_fStarted = TRUE;

        fResult = TRUE;

        if (Playing == m_enumPlayState && m_FinalBehaviorPtr != NULL)
                {
                        // If playing start the timer (to avoid delay between da and iham)
                        // Calculate the base time and kick off the timer
                        m_dblCurrentTick = GetCurrTime();
                        m_dblBaseTime = m_dblCurrentTick - GetTimeFromFrame(m_iFrame);
                        m_dblPreviousTime = 0;
                        m_clocker.Start();

            // Switch to the sequenced behaviour
                        m_PlayImagePtr->SwitchTo(m_FinalBehaviorPtr);
                        // Fire any starting frame Callouts
                        FireFrameMarker(m_iStartingFrame);
                }
                else
                {
                        // Cause the tick (to update any initial frames)
                        OnTimer((DWORD)GetCurrTime()*1000);
                }
    }

    return fResult;
}

/*==========================================================================*/

BOOL CSpriteCtl::StopModel(void)
{
    // Stop the play if necessary...
    Stop();

    // Stop any currently running model...
    if (m_fStarted)
    {
        BOOL fResult = SUCCEEDED(m_ViewPtr->StopModel());

        if (!fResult)
            return fResult;

        m_fStarted = FALSE;
    }

    return TRUE;
}

/*==========================================================================*/

BOOL CSpriteCtl::ReStartModel(void)
{
    BOOL fResult = FALSE;

    // Stop the running model so that it will restart for the
    // next paint...
    StopModel();

    InvalidateControl(NULL, TRUE);

    return fResult;
}

/*==========================================================================*/

HRESULT CSpriteCtl::InitializeObjects(void)
{
    HRESULT hr = S_OK;

    if (!m_PlayImagePtr)
    {
        CComPtr<IDAImage> ImagePtr;

        if (FAILED(hr = m_StaticsPtr->get_EmptyImage(&ImagePtr)))
            return hr;

        if (FAILED(hr = m_StaticsPtr->ModifiableBehavior(ImagePtr, (IDABehavior **)&m_PlayImagePtr)))
            return hr;
    }

    return hr;
}

/*==========================================================================*/

void CSpriteCtl::OnTimer(DWORD dwTime)
{
    VARIANT_BOOL vBool;

    //determine if the mouse is still in the area
    if (m_fMouseInArea)
    {
        POINT p;
        HWND CurWnd = 0, ParentWnd = 0;
    
        if (m_hwndParent == 0)  //if the parenthWnd has not been set, then grab the
        {                       //topmost window of the container object.
            HRESULT hr = S_OK;
            IOleWindow *poleWindow = NULL;
            IOleClientSite *pClientSite = NULL;

            if (m_ViewPtr)
            {
                hr = m_ViewPtr->get_ClientSite(&pClientSite);
            }

            hr = pClientSite->QueryInterface(IID_IOleWindow, reinterpret_cast<void**>(&poleWindow));
            pClientSite->Release();

            if (FAILED(hr))
            {
                return;
            }
            if (NULL == poleWindow)
            {
                return;
            }

            // Get HWND of OLE Container
            hr = poleWindow->GetWindow(&ParentWnd);
            poleWindow->Release();
            
            if (FAILED(hr))
            {
                return;
            }
            if (NULL == ParentWnd)
            {
                return;
            }

            while (ParentWnd) //get the topmost hwnd
            {
                m_hwndParent = ParentWnd;
                ParentWnd = GetParent(ParentWnd);
            }
        }

        GetCursorPos(&p);
  
        ParentWnd = WindowFromPoint(p);
        while (ParentWnd)
        {
            CurWnd = ParentWnd;
            ParentWnd = GetParent(CurWnd);
        }
        if (CurWnd != m_hwndParent)
        {
            DEBUGLOG("Mouse out\r\n");
            m_fMouseInArea = FALSE;
            FIRE_MOUSELEAVE(m_pconpt);
        }
    }
    if (m_fWaitForImportsComplete)
    {
        // Check if all data has been loaded
        VARIANT_BOOL bComplete;
        if (FAILED(m_StaticsPtr->get_AreBlockingImportsComplete(&bComplete)))
            return;
        if (!bComplete) // Still importing...
            return;

        // All data has been loaded; hence start animation
        m_fWaitForImportsComplete = false;
        m_clocker.Stop();

        // Fire the media loaded event only if everything goes welll and m_ImagePtr is valid
            if (m_ImagePtr != NULL)
                    FIRE_ONMEDIALOADED(m_pconpt, m_bstrSourceURL);

        // Invalidate the control; this will cause a :Draw and should StartModel()
        InvalidateControl(NULL, TRUE);
        return;
    }

    if (m_fStarted)
    {
        m_dblCurrentTick = dwTime / 1000.0;
    
        if (SUCCEEDED(m_ViewPtr->Tick(m_dblCurrentTick, &vBool)))
        {
            // Let the regular rendering path take care of this...
            if (vBool)
                InvalidateControl(NULL, TRUE);
        }

        if (Playing != m_enumPlayState)
            return;

        // Find the current time
        double time = m_dblCurrentTick - m_dblBaseTime;

        // Fire any time markers
        FireTimeMarker(time);

        if (m_iCurCycle * m_dblDuration <= time)
        // End of one cycle; see if we need to continue or stop
        {
            if (m_iRepeat < 0 || m_iRepeat > m_iCurCycle)
            {
                // Increment the current cycle
                m_iCurCycle++;

                // Restart the cycle
                ASSERT(m_FinalBehaviorPtr != NULL); 

                if (m_iStartingFrame == 0 && !m_fFireAbsoluteFrameMarker)
                {
                                        m_PlayImagePtr->SwitchTo(m_FinalBehaviorPtr);
                                        // Fire any starting frame Callouts
                                        FireFrameMarker(m_iStartingFrame);
                }
                else    // Pause and resume; hence restart the sequence
                                {
                                        if (FAILED(SequenceFrames(m_iCurCycle*m_iFrameCount))) 
                        return;

                                        // Switch to the sequenced behaviour
                                        m_PlayImagePtr->SwitchTo(m_FinalBehaviorPtr);
                                        // Fire any starting frame Callouts
                                        FireFrameMarker(m_iStartingFrame);
                                }
            }
            else    // We are done with the cycles
            {
                    // Stop if we are done...
                    Stop();
            }
        }
    }
}

/*==========================================================================*/

#ifdef SUPPORTONLOAD
void CSpriteCtl::OnWindowLoad (void) 
{
    m_fOnWindowLoadFired = TRUE;
    
    // Asserting to ensure that we are being constructed from scratch every time
    ASSERT(m_fOnWindowUnloadFired == false);
    m_fOnWindowUnloadFired = false;

    if (m_fAutoStart)
    {
        Play();
    }
    else
    {
        if (m_iInitialFrame >= -1)
        {
            // Show the initial sprite image
            ShowImage(m_iInitialFrame);
        }
    }
}

/*==========================================================================*/

void CSpriteCtl::OnWindowUnload (void) 
{ 
    m_fOnWindowUnloadFired = true;
    m_fOnWindowLoadFired = FALSE;
    StopModel();
}

/*==========================================================================*/

#endif //SUPPORTONLOAD
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\controls\sprite\sprite.h ===
/*==========================================================================*\

    Module: 
            sprite.h

    Author: 
            IHammer Team (SimonB)

    Created: 
            May 1997

    Description:
            Defines the control's class

    History:
            05-27-1997  Created (SimonB)

\*==========================================================================*/

#ifndef __SPRITE_H__
#define __SPRITE_H__

#define USE_VIEWSTATUS_SURFACE
#include "..\ihbase\precomp.h"
#include "..\ihbase\ihbase.h"
#include "..\ihbase\timemark.h"
#include <drg.h>
#include <ctstr.h>
#include <daxpress.h>
#include "..\ihbase\clocker.h"
#include "ddraw.h"
#include "ddrawex.h"

// Madness to prevent ATL from using CRT
#define _ATL_NO_DEBUG_CRT
#define _ASSERTE(x) ASSERT(x)
#include <atlbase.h>
#include <servprov.h>

/*==========================================================================*/

class CFrameMarker
{

public:
    unsigned long m_iFrame;
    BSTR m_bstrMarkerName;
    bool m_fAbsolute;

public:
    CFrameMarker() { m_iFrame = 0; }

    CFrameMarker(unsigned long iFrame, LPWSTR pwszName, bool fAbsolute = true)
    {
        m_iFrame = iFrame;
        m_fAbsolute = fAbsolute;
        m_bstrMarkerName = SysAllocString(pwszName);
    }


    ~CFrameMarker()
    {
        SysFreeString(m_bstrMarkerName);
    }

};

/*==========================================================================*/

class CFrameMap
{
public:
    int m_iImg;
    double m_dblDuration;
    CTStr m_tstrMarkerName;

public:
    CFrameMap() {m_iImg = 0;  m_dblDuration = 0.0f;}

    CFrameMap(unsigned int iImg, double dblDuration, LPTSTR pszMarkerName = NULL):
        m_tstrMarkerName(pszMarkerName)
    {
        m_iImg = iImg;  
        m_dblDuration = dblDuration;
    }

    ~CFrameMap() {}
};

/*==========================================================================*/

/*
CIHBaseCtl <    
        CSpriteCtl,                             //TODO: Name of the derived class
        IIHCtl,                         //TODO: Name of interface defining methods and properties
        &CLSID_IHCtl,           //TODO: CLSID of the control  Get this from ihctl.h
        &IID_IIHCtl,            //TODO: IID of the interface above.  Get this from ihctl.h
        &LIBID_IHCtl,           //TODO: LIBID of the typelib.  Get this from ihctl.h
        &DIID_IHCtlEvents > //TODO: IID of the event interface.  Get this from ihctl.h

*/

#define SPR_BASECLASS       \
CIHBaseCtl <                \
    CSpriteCtl,             \
    ISpriteCtl,             \
    &CLSID_SpriteControl,   \
    &IID_ISpriteCtl,        \
    &LIBID_DAExpressLib,    \
    &DIID_ISpriteCtlEvents>

class CSpriteCtl:               
    public ISpriteCtl,
    public SPR_BASECLASS,
    public CClockerSink

{
friend LPUNKNOWN __stdcall AllocSpriteControl(LPUNKNOWN punkOuter);

// Template stuff
    typedef SPR_BASECLASS CMyIHBaseCtl;

public:
    // Make PlayState public so that the CCalloutNotifier can access it
    PlayStateConstant     m_enumPlayState; 
private:

    BOOL                  m_fMouseInArea;
    BSTR                  m_bstrSourceURL; // Store the pointer to the image...
    BOOL                  m_fAutoStart;
    unsigned long         m_iPrerollAmount;
    int                   m_iLoopCount;
    int                   m_iInitialFrame;
    int                   m_iFinalFrame;
    long                  m_iRepeat;
    double                m_dblDuration;
    double                m_dblPlayRate;
    double                m_dblTimerInterval;
    double                m_dblUserPlayRate;
    double                m_dblUserTimerInterval;
    int                   m_iMaximumRate;
    int                   m_iNumFrames;
    int                   m_iNumFramesAcross;
    int                   m_iNumFramesDown;
    int                   m_byteColorKeyR, m_byteColorKeyG, m_byteColorKeyB;
    BOOL                  m_fOnSeekFiring;
    BOOL                  m_fOnFrameSeekFiring;
    BOOL                  m_fFireAbsoluteFrameMarker;
    bool                  m_fOnStopFiring, m_fOnPlayFiring, m_fOnPauseFiring;

    BOOL m_fUseColorKey;
    BOOL m_fMouseEventsEnabled;

    CPtrDrg<CFrameMarker> m_drgFrameMarkers;
    CPtrDrg<CTimeMarker>  m_drgTimeMarkers;
    CTimeMarker*          m_ptmFirst;
    CPtrDrg<CFrameMap>    m_drgFrameMaps;
    CTStr                 m_tstrFrameMap;
    CClocker              m_clocker;
    double                m_dblBaseTime;
    double                m_dblCurrentTick;
    double                m_dblTimePaused;
    double                m_dblPreviousTime;
    BOOL                  m_fPersistComplete;
    BOOL                  m_fOnWindowLoadFired;
    bool                  m_fOnWindowUnloadFired;
    bool                  m_fWaitForImportsComplete;
    HWND                  m_hwndParent;


    // DAnim Support:
    BOOL                      m_fStarted; // True iff the model has been started...
    CComPtr<IServiceProvider> m_ServiceProviderPtr;
    CComPtr<IDirectDraw3>     m_DirectDraw3Ptr;
    CComPtr<IDAStatics>       m_StaticsPtr;
    CComPtr<IDAView>          m_ViewPtr;
    CComPtr<IDAImage>         m_ImagePtr;
    CComPtr<IDAImage>         m_PlayImagePtr; // Switchable image selected into view..

    // Frame information (derived from m_ImagePtr on first play)
    unsigned int m_iFrame;
    CComPtr<IDANumber> m_imageWidth;
    CComPtr<IDANumber> m_imageHeight;
    CComPtr<IDANumber> m_frameWidth;
    CComPtr<IDANumber> m_frameHeight;
    CComPtr<IDANumber> m_initTransX;
    CComPtr<IDANumber> m_initTransY;
    CComPtr<IDAPoint2> m_minCrop;
    CComPtr<IDAPoint2> m_maxCrop;

    // Final sequenced behavior
    long m_iCurCycle;
    long m_iFrameCount;
    long m_iStartingFrame;
    CComPtr<IDABehavior>* m_pArrayBvr;
    double *m_durations;	// array of durations of each image
    CComPtr<IDABehavior> m_FinalBehaviorPtr;
    
    HRESULT InitializeImage(void);                          // Loads, updates and builds the image
    // Sequences the frames starting with iStartingFrame at dblDuration
    HRESULT SequenceFrames(int iStartingFrame, double dblDuration=0.0); 
    // Returns the frame and remaining duration at dblTime
    int GetFrameFromTime(double dblTime, double* pdblDuration=NULL); 
    double GetTimeFromFrame(int iFrame);                    // Returns the time at iFrame
    HRESULT SeekFrame(int iFrame, double dblDuration=0.0);  // Seek to iFrame
    HRESULT ShowImage(int iShowFrame, BOOL bPlayRate=FALSE);       // Shows the image at iShowFrame
    HRESULT FireFrameMarker(int iFrame, BOOL bPlayRate=TRUE);      // Fires a frame callout at iFrame
    HRESULT FireTimeMarker(double dblNewTime, BOOL bReset=FALSE);  // Fires time markers at dblNewTime

    void CalculateEffectiveTimerInterval();

protected:

    // 
    // Constructor and destructor
    // 
    CSpriteCtl(IUnknown *punkOuter, HRESULT *phr); //TODO: Change name

    ~CSpriteCtl(); //TODO: Change name as appropriate

    // Overides
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, LPVOID *ppv);

    STDMETHODIMP QueryHitPoint(DWORD dwAspect, LPCRECT prcBounds, POINT ptLoc, LONG lCloseHint, DWORD* pHitResult);

    STDMETHODIMP OnWindowMessage(UINT msg, WPARAM wParam, LPARAM lParam, LRESULT *plResult);

    STDMETHODIMP DoPersist(IVariantIO* pvio, DWORD dwFlags);

    STDMETHODIMP Draw(DWORD dwDrawAspect, LONG lindex, void *pvAspect,
         DVTARGETDEVICE *ptd, HDC hdcTargetDev, HDC hdcDraw,
         LPCRECTL lprcBounds, LPCRECTL lprcWBounds,
         BOOL (__stdcall *pfnContinue)(ULONG_PTR dwContinue), ULONG_PTR dwContinue);

    ///// IDispatch implementation
    protected:
    STDMETHODIMP GetTypeInfoCount(UINT *pctinfo);
    STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo);
    STDMETHODIMP GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames,
         LCID lcid, DISPID *rgdispid);
    STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid,
        WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult,
        EXCEPINFO *pexcepinfo, UINT *puArgErr);
   
    ///// IOleObject implementation
    protected:
    STDMETHODIMP SetClientSite(IOleClientSite *pClientSite);

    ///// delegating IUnknown implementation
    protected:
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv)
      { return m_punkOuter->QueryInterface(riid, ppv); }
    STDMETHODIMP_(ULONG) AddRef()
      { return m_punkOuter->AddRef(); }
    STDMETHODIMP_(ULONG) Release()
      { return m_punkOuter->Release(); }

    // Private members
    private:

    HRESULT ParseFrameMapEntry(LPTSTR pszEntry, CFrameMap **ppFrameMap);
    HRESULT PersistFrameMaps(IVariantIO *pvio, BOOL fLoading);
    HRESULT PersistFrameMarkers(IVariantIO *pvio, BOOL fIsLoading);
    HRESULT PersistTimeMarkers(IVariantIO* pvio, BOOL fLoading);
    HRESULT AddTimeMarkerElement(CTimeMarker **ppNewMarker);
    HRESULT AddFrameMarkerElement(CFrameMarker **ppNewMarker);
    //
    // ISpriteCtl methods 
    //

    protected:

    HRESULT STDMETHODCALLTYPE get_AutoStart(VARIANT_BOOL __RPC_FAR *fAutoStart); 
    HRESULT STDMETHODCALLTYPE put_AutoStart(VARIANT_BOOL fAutoStart); 
    HRESULT STDMETHODCALLTYPE get_Frame(unsigned int __RPC_FAR *piFrame); 
    HRESULT STDMETHODCALLTYPE put_Frame(unsigned int iFrame); 
    HRESULT STDMETHODCALLTYPE get_FrameMap(BSTR __RPC_FAR *FrameMap); 
    HRESULT STDMETHODCALLTYPE put_FrameMap(BSTR FrameMap); 
    HRESULT STDMETHODCALLTYPE get_InitialFrame(int __RPC_FAR *iFrame); 
    HRESULT STDMETHODCALLTYPE put_InitialFrame(int iFrame); 
    HRESULT STDMETHODCALLTYPE get_FinalFrame(int __RPC_FAR *iFrame);
    HRESULT STDMETHODCALLTYPE put_FinalFrame(int iFrame);
    HRESULT STDMETHODCALLTYPE get_Iterations(int __RPC_FAR *iRepeat); 
    HRESULT STDMETHODCALLTYPE put_Iterations(int iRepeat); 
    HRESULT STDMETHODCALLTYPE get_Library(IDAStatics __RPC_FAR *__RPC_FAR *ppLibrary);
    HRESULT STDMETHODCALLTYPE get_Repeat(int __RPC_FAR *iRepeat); 
    HRESULT STDMETHODCALLTYPE put_Repeat(int iRepeat); 
    HRESULT STDMETHODCALLTYPE get_PlayRate(double __RPC_FAR *dblSpeed); 
    HRESULT STDMETHODCALLTYPE put_PlayRate(double dblSpeed); 
    HRESULT STDMETHODCALLTYPE get_Time(double __RPC_FAR *pdblTime); 
    HRESULT STDMETHODCALLTYPE get_MaximumRate(unsigned int __RPC_FAR *iFps); 
    HRESULT STDMETHODCALLTYPE put_MaximumRate(unsigned int iFps); 
    HRESULT STDMETHODCALLTYPE get_NumFrames(unsigned int __RPC_FAR *iNumFrames); 
    HRESULT STDMETHODCALLTYPE put_NumFrames(unsigned int iNumFrames); 
    HRESULT STDMETHODCALLTYPE get_PlayState(PlayStateConstant __RPC_FAR *PlayState); 
    HRESULT STDMETHODCALLTYPE get_NumFramesAcross(unsigned int __RPC_FAR *iFrames); 
    HRESULT STDMETHODCALLTYPE put_NumFramesAcross(unsigned int iFrames); 
    HRESULT STDMETHODCALLTYPE get_NumFramesDown(unsigned int __RPC_FAR *iFrames); 
    HRESULT STDMETHODCALLTYPE put_NumFramesDown(unsigned int iFrames); 
    HRESULT STDMETHODCALLTYPE get_UseColorKey(VARIANT_BOOL __RPC_FAR *Solid); 
    HRESULT STDMETHODCALLTYPE put_UseColorKey(VARIANT_BOOL Solid); 
    HRESULT STDMETHODCALLTYPE get_Image(IDAImage __RPC_FAR **pImage); 
    HRESULT STDMETHODCALLTYPE put_Image(IDAImage __RPC_FAR *pImage); 
    HRESULT STDMETHODCALLTYPE get_ColorKey(IDAColor __RPC_FAR **ppColorKey); 
    HRESULT STDMETHODCALLTYPE put_ColorKey(IDAColor __RPC_FAR *pColorKey); 
    HRESULT STDMETHODCALLTYPE get_ColorKeyRGB(COLORREF* pColorKeyRGB); 
    HRESULT STDMETHODCALLTYPE put_ColorKeyRGB(COLORREF ColorKeyRGB); 
    HRESULT STDMETHODCALLTYPE get_SourceURL(BSTR __RPC_FAR *bstrSourceURL); 
    HRESULT STDMETHODCALLTYPE put_SourceURL(BSTR bstrSourceURL); 
    HRESULT STDMETHODCALLTYPE get_MouseEventsEnabled(VARIANT_BOOL __RPC_FAR *Enabled); 
    HRESULT STDMETHODCALLTYPE put_MouseEventsEnabled(VARIANT_BOOL Enabled); 
    HRESULT STDMETHODCALLTYPE get_TimerInterval(double *pdblTimerInterval);
    HRESULT STDMETHODCALLTYPE put_TimerInterval(double dblTimerInterval);
    HRESULT STDMETHODCALLTYPE AddFrameMarker(unsigned int iFrame, BSTR MarkerName, VARIANT varAbsolute); 
    HRESULT STDMETHODCALLTYPE AddTimeMarker(double dblTime, BSTR MarkerName, VARIANT varAbsolute); 
    HRESULT STDMETHODCALLTYPE Play(void); 
    HRESULT STDMETHODCALLTYPE Stop(void); 
    HRESULT STDMETHODCALLTYPE Pause(void); 
    HRESULT STDMETHODCALLTYPE Seek(double dblTime); 
    HRESULT STDMETHODCALLTYPE FrameSeek(unsigned int iFrame);

#ifdef SUPPORTONLOAD
    void OnWindowLoad (void);
    void OnWindowUnload (void);
#endif //SUPPORTONLOAD

private:
    HRESULT InitializeSurface(void);
    STDMETHODIMP PaintToDC(HDC hdcDraw, LPRECT lprcBounds, BOOL fBW);
    STDMETHODIMP InvalidateControl(LPCRECT pRect, BOOL fErase);

    HRESULT CreateBaseTransform(void);
    HRESULT UpdateImage(IDAImage *pImage);
    HRESULT LoadImage(BSTR bstrURL, IDAImage **ppImage);
    HRESULT GenerateFrameImage(int iFrameIndex, IDAImage *pImage, IDAImage **ppFrameImage);
    HRESULT BuildPlayImage(void);
    BOOL StopModel(void);
    BOOL StartModel(void);
    BOOL ReStartModel(void);
    HRESULT InitializeObjects(void);
    HRESULT StartPlaying (void);
    HRESULT Resume (void);
    
    BSTR* GetCallout(unsigned long);

    // Timing info:
    DWORD GetCurrTimeInMillis(void);
    double GetCurrTime() { return (double)(GetCurrTimeInMillis()) / 1000.0; }

public:
    virtual void OnTimer(DWORD dwTime);
};


/*==========================================================================*/

#endif // __SPRITE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\inc\actdata.h ===
#ifndef __ACTDATA_H__
#define __ACTDATA_H__

const DWORD g_dwTimeInfinite = (DWORD)(~0);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\inc\builddef.h ===
#ifndef _BUILDDEF_H
#define _BUILDDEF_H

#define BUG318

// #define STRICT
#define SHOW_PARAM_PAGES_IN_AV

#endif // _BUILDDEF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\inc\auto_ptr.h ===
/*-------------------------------------------------

  auto_ptr.h--
  auto_ptr declarations.
  (Just until VC implements their own).

  An auto_ptr automatically 
  frees its pointer in it's destructor,
  thus making it exception-safe and
  making all clean-up code implicit, beacuse
  objects are guaranteed to be destroyed
  when control leaves the containing scope.

  Caveats are marked with "note:" below.

  --USAGE:-----------------------------
  
  auto_ptr<CClass> pClass(new CClass);
  if( !pClass )
    // oopse, pClass did not allocate
  pClass->any_member_of_cclass
  *pClass.any_member_of_cclass


  auto_rg<CClass> prgClass( new CClass[5] );
  prgClass[2].member_of_cclass


  auto_com<IFace> pIface(ptr_to_real_interface); 
        or
  auto_com<IFace> pIface;
  CoGetMalloc( MEMCTX_TASK, &pIFace );
  pIFace->HeapMinimize();  // etc.
       or
  QueryInterface( IID_IDispatch, pIFace.SetVFace() ); //void **
  blahblah( pIFace.SetIFace() ); // IFace ** same as &pIFace

  -------------------------------------

  note: for all auto_... classes, assignment transfers ownership
  e.g. lvalautoptr = rvalautoptr;  
  means rvalautoptr's dtor will *not* free resources, but
  lvalautoptr has dumped whatever it did hold and will now
  free rvalautoptr's resource if rval was the rightful owner.

  -------------------------------------

  You can use auto_ptr instances both as locals
  and as class members.  An exception-safe alloc
  could go like this.

  class X
  {
        ...
        auto_rg<int> m_intarray1;
        auto_rg<int> m_intarray2;
  }

  X::X( )
  {
        auto_rg<int>  temp_intarray1( new int[500] );
        auto_rg<int>  temp_intarray2( new int[500] );
        // Either temp_ throws exception? Both temps clean-up automatically

        // No exceptions? transfer ownership to members
        // Resources will be automatically freed when X deletes
        temp_intarray1.TransferTo( m_intarray1 );
        temp_intarray2.TransferTo( m_intarray2 );        
  }

  Transfer a local auto_ptr to a real-live pointer by

        auto_ptr<X>  tempX( new X );
        pX = tempX.Relenquish();
  
        -----------------------------

  Norm Bryar    April, '96    Hammer 1.0
                Dec.,  '96    IHammer 1.0
				May 28, '97   VC5.0: auto_com copy-ctor, explicit

  Review(normb): consider making all derivations 
  from auto_base protected instead of public;
  there are no virtuals here, so no possible polymorphism.

  ------------------------------------------------*/
#ifndef INC_AUTO_PTR_H_
#define INC_AUTO_PTR_H_

namespace IHammer {

    #ifndef MEMBER_TEMPLATES_SUPPORTED
        // If member templates are not supported, we can't
        // assign or copy an auto_ptr to a derived class to
        // an auto_ptr of a base class quite as expected.
        // In VC5, allegedly these are supported.  Review(normb) True?
      #pragma message( "Member templates not supported" )
    #endif // MEMBER_TEMPLATES_SUPPORTED

        // The explicit keyword prevents implicit type conversion
        // when the compiler searches for methods to apply to the given type.
        // For instance, 
        //     array<int> a[5];  array<int> b[5];   if( a == b[i] )
        // would implcitly construct a temporary array of one item, b[i],
        // and compare 'a' to this temp array.  We'd rather the array ctor
        // not get called, rather the compiler to error.  
        // VC4 doesn't support this!
#if _MSC_VER < 1100
    #define explicit
#endif // pre VC5


    ////////////////////// auto_base class ////////////////        
    template<class T>
    class auto_base
    {
    public:
        explicit auto_base(T *p=NULL);

    protected:
            // note: That's right, you can't destroy auto_base!
            // I don't want this class instantiated, but I'm
            // not willing to incur vtable overhead 
            // just to make the class abstract.
        ~auto_base();

    public:
    #ifdef MEMBER_TEMPLATES_SUPPORTED
        template<class U>
        auto_base(const auto_base<U>& rhs);

        template<class U>
        auto_base<T>& operator=(const auto_base<U>& rhs);
    #else
        auto_base(const auto_base<T>& rhs);
        auto_base<T>& operator=(const auto_base<T>& rhs);
    #endif // MEMBER_TEMPLATES_SUPPORTED        

        #pragma warning( disable: 4284 )
        // note: only use -> when T represents a class or struct
        T* operator->() const;
        #pragma warning( default: 4284 )
        
        BOOL operator!() const; // NULL-ptr test: if(!autoPtr)
        
        // If you just can't resist getting your hands on the dumb pointer
        // Preferable to defining operator void*, which lets us compare
        // pointers w/o respect for type.       
        T* Get() const;

    protected:
            // Typically deletes owned ptr, 
            // then points to p w/o taking ownership
            // note: not virtual for speed and size reasons
            // yet every derived class will implement this
            // differently; any base-class method calling
            // Reset must be re-implemented in derived classes
            // to invoke the proper Reset().
        void Reset(T *p=NULL);  

    protected:
        T     *m_ptr;
    };


    template<class T>
    inline auto_base<T>::auto_base( T * p) : m_ptr(p)
    { NULL; }


    template<class T>
    inline auto_base<T>::~auto_base( )
    { NULL; }        


    template<class T>
    #ifdef MEMBER_TEMPLATES_SUPPORTED
      template<class U>
      inline auto_base<T>::auto_base(const auto_base<U>& rhs)
    #else
    inline auto_base<T>::auto_base(const auto_base<T>& rhs)
    #endif
      : m_ptr(rhs.m_ptr)
    { NULL; }


        // see copy ctor note
    template<class T>
    #ifdef MEMBER_TEMPLATES_SUPPORTED
      template<class U>
      inline auto_base<T>& auto_base<T>::operator=(const auto_base<U>& rhs)
    #else
    inline auto_base<T>& auto_base<T>::operator=(const auto_base<T>& rhs)
    #endif
    {         
            // protect against us = us;
        if( this != &rhs )
            Reset( rhs.m_ptr );
        return *this;
    }
    

    template<class T>
    inline T* auto_base<T>::operator->() const
    {  return m_ptr; }


    template<class T>
    inline BOOL auto_base<T>::operator!() const
    { return NULL == m_ptr; }


    template<class T>
    inline T* auto_base<T>::Get() const
    {  return m_ptr; }


    template<class T>
    inline void auto_base<T>::Reset( T *p)
    {  m_ptr = p; }



    //////////////////////// auto_ptr class //////////////////////
        
    template<class T>
    class auto_ptr : public auto_base<T>
    {
    public:
        explicit auto_ptr(T *p=NULL);
        ~auto_ptr();

    #ifdef MEMBER_TEMPLATES_SUPPORTED
        template<class U>
        auto_ptr(const auto_ptr<U>& rhs);

        template<class U>
        auto_ptr<T>& operator=(auto_ptr<U>& rhs);
      
        template<class U>
        void TransferTo( auto_ptr<U>& rhs );
    
    #else
        auto_ptr(const auto_ptr<T>& rhs);
        auto_ptr<T>& operator=(auto_ptr<T>& rhs);
        void TransferTo( auto_ptr<T>& rhs );
    #endif // MEMBER_TEMPLATES_SUPPORTED

        T& operator*() const;

            // Like Get() but relenquishes ownership
        T * Relenquish( void );

    protected:
        void Reset(T *p=NULL);  // delete owned ptr, assume p.

    
            // operator void * is protected so you can't call
            //         delete pauto_ptr 
            // We can later define an operator T*() and still have
            // this errant-delete safe-guard; compiler will err
            // on ambiguity between T* and void* conversion ops.
        operator void *() const
        { return NULL; }

    protected:        
        BOOL  m_fOwner;

        friend BOOL operator==( const auto_ptr<T> &lhs,
                                const auto_ptr<T> &rhs );
    };


    template<class T>
    inline auto_ptr<T>::auto_ptr( T *p ) : auto_base<T>(p), m_fOwner(TRUE)
    { NULL; }


    template<class T>
    inline auto_ptr<T>::~auto_ptr()
    { 
        Reset( );
        m_fOwner = FALSE;
    }


        // note: when an auto_ptr is assigned or copied,
        // ownership of the dumb-ptr is *not* transferred.
        // We don't want to delete the dumb-ptr twice when
        // both auto_ptrs destroy.  The dumb-ptr deletes when
        // the origional auto_ptr goes out of scope.
    template<class T>
    #ifdef MEMBER_TEMPLATES_SUPPORTED
      template<class U>
      inline auto_ptr<T>::auto_ptr(const auto_ptr<U>& rhs) : auto_base<T>(rhs)
    #else
    inline auto_ptr<T>::auto_ptr(const auto_ptr<T>& rhs) : auto_base<T>(rhs)
    #endif      
    { m_fOwner = FALSE; }


        // see copy ctor note
    template<class T>
    #ifdef MEMBER_TEMPLATES_SUPPORTED
      template<class U>
      inline auto_ptr<T>& auto_ptr<T>::operator=(auto_ptr<U>& rhs)
    #else
    inline auto_ptr<T>& auto_ptr<T>::operator=(auto_ptr<T>& rhs)
    #endif            
    {         
            // protect against us = us;
        if( this != &rhs )      
        {
			rhs.TransferTo( *this );
        }
        return *this;
    }


    template<class T>
    inline T& auto_ptr<T>::operator*() const
    {  return *m_ptr; }


    template<class T>
    inline T * auto_ptr<T>::Relenquish( void )
    {  
        m_fOwner = FALSE;
        return Get( );
    }


    template<class T>
    inline void auto_ptr<T>::Reset( T *p)
    {  
        if( m_fOwner )
            delete m_ptr;
        auto_base<T>::Reset( p );  //m_ptr = p;
    }


    template<class T>
    #ifdef MEMBER_TEMPLATES_SUPPORTED
      template<class U>
      inline void auto_ptr<T>::TransferTo( auto_ptr<U>& rhs )
    #else
      inline void auto_ptr<T>::TransferTo( auto_ptr<T>& rhs )
    #endif
    {
        BOOL fIOwnIt = m_fOwner;

        rhs.Reset( Get() );
		m_fOwner = FALSE;
        rhs.m_fOwner = fIOwnIt;        
    }


    template<class T>
    inline BOOL operator==( const auto_ptr<T> &lhs,
                            const auto_ptr<T> &rhs )
    {
        return lhs.m_ptr == rhs.m_ptr;
    }


    template<class T>
    inline BOOL operator!=( const auto_ptr<T> &lhs,
                            const auto_ptr<T> &rhs )
    {
        return !(lhs == rhs);
    }



    ///////////////////////// auto_rg class //////////////////////
            
    template<class T>
    class auto_rg : protected auto_ptr<T>
    {
    public:
        explicit auto_rg(T *p=NULL);
        ~auto_rg();

    #ifdef MEMBER_TEMPLATES_SUPPORTED
        template<class U>
        auto_rg( const auto_rg<U>& rhs);   // copy ctor
        template<class U>
        auto_rg<T>& operator=(auto_rg<U>& rhs);
    #else
        auto_rg(const auto_rg<T>& rhs);   // copy ctor
        auto_rg<T>& operator=(auto_rg<T>& rhs);
    #endif // MEMBER_TEMPLATES_SUPPORTED

     T& operator[](int idx);

     const T & operator[](int idx) const;

     #ifdef MEMBER_TEMPLATES_SUPPORTED
        template<class U>
        void TransferTo( auto_rg<U>& rhs );
    #else        
        void TransferTo( auto_rg<T>& rhs );
    #endif // MEMBER_TEMPLATES_SUPPORTED

        // Methods valuable to auto_rg, too.
     using auto_ptr<T>::operator!;
     using auto_ptr<T>::Get;
     using auto_ptr<T>::Relenquish;

    protected:
        void Reset(T *p=NULL);

        friend BOOL operator==( const auto_rg<T> &lhs,
                                const auto_rg<T> &rhs );
    };

    
    template<class T>
    inline auto_rg<T>::auto_rg( T *p ) : auto_ptr<T>(p)
    { NULL; }


    template<class T>
    inline auto_rg<T>::~auto_rg()
    { 
        Reset();
        m_fOwner = FALSE;
    }
    

    template<class T>
    #ifdef MEMBER_TEMPLATES_SUPPORTED
      template<class U>
      inline auto_rg<T>::auto_rg(const auto_rg<U>& rhs)
    #else
    inline auto_rg<T>::auto_rg(const auto_rg<T>& rhs)
    #endif
        : auto_ptr<T>(rhs)
    { NULL; }


    template<class T>
    #ifdef MEMBER_TEMPLATES_SUPPORTED
      template<class U>
      inline auto_rg<T>& auto_rg<T>::operator=(auto_rg<U>& rhs)
    #else
    inline auto_rg<T>& auto_rg<T>::operator=(auto_rg<T>& rhs)
    #endif
    {         
        if( this != &rhs )      
        {
			rhs.TransferTo( *this );            
        }
        return *this;
    }

    template<class T>
    #ifdef MEMBER_TEMPLATES_SUPPORTED
      template<class U>
      inline void auto_rg<T>::TransferTo( auto_rg<U>& rhs )
    #else        
    inline void auto_rg<T>::TransferTo( auto_rg<T>& rhs )
    #endif // MEMBER_TEMPLATES_SUPPORTED
    {          
          // Looks exactly like auto_ptr<T>::TransferTo,
          // but we can't call that implementation because
          // Reset is not virtual for speed's-sake.
		BOOL fIOwnIt = m_fOwner;

        rhs.Reset( Get() );
		m_fOwner = FALSE;
        rhs.m_fOwner = fIOwnIt;
    }


    template<class T>
    inline T& auto_rg<T>::operator[](int idx)
    {  return m_ptr[idx]; }


    template<class T>
    inline const T & auto_rg<T>::operator[](int idx) const
    {  return m_ptr[idx]; }


    template<class T>
    inline void auto_rg<T>::Reset( T *p)
    {
        if( m_fOwner )
            delete [] m_ptr;
        m_ptr = p;
    }


    template<class T>
    inline BOOL operator==( const auto_rg<T> &lhs,
                            const auto_rg<T> &rhs )
    {
        return lhs.m_ptr == rhs.m_ptr;
    }


    template<class T>
    inline BOOL operator!=( const auto_rg<T> &lhs,
                            const auto_rg<T> &rhs )
    {
        return !(lhs == rhs);
    }



    ///////////////////////// auto_com class /////////////////////
		// By the rules of COM, if you have a pointer, you're an owner  
    template<class T>
    class auto_com : public auto_base<T>
    {
    public:
        explicit auto_com(T *p=NULL); // default ctor

        ~auto_com();

        void * * SetVFace( void );
        T * *    SetIFace( void );
        T * *    operator&( void );
        
    #ifdef MEMBER_TEMPLATES_SUPPORTED
        template<class U>
        auto_com( const auto_com<U>& rhs );
        
        template<class U>
        auto_com<T>& operator=(const auto_com<U>& rhs);
    #else
        auto_com( const auto_com<T>& rhs );
        auto_com<T>& operator=(const auto_com<T>& rhs);
    #endif // MEMBER_TEMPLATES_SUPPORTED

        T * Relenquish( void );

    #ifdef MEMBER_TEMPLATES_SUPPORTED
        template<class U>
        void TransferTo( auto_com<U>& rhs );    
    #else        
        void TransferTo( auto_com<T>& rhs );
    #endif // MEMBER_TEMPLATES_SUPPORTED

    protected:
        void Reset( T *p=NULL );
        
        friend BOOL operator==( const auto_com<T> &lhs,
                                const auto_com<T> &rhs );	
    };


    template<class T>
    inline auto_com<T>::auto_com( T *p ) : auto_base<T>(p)
    { NULL; }

        
    template<class T>
    inline auto_com<T>::~auto_com()
    { 
        Reset( );  // note: C4702:unreachable code is benign here		
    }
    


    template<class T>
    #ifdef MEMBER_TEMPLATES_SUPPORTED
      template<class U>
      inline auto_com<T>::auto_com(const auto_com<U>& rhs)
    #else
    inline auto_com<T>::auto_com(const auto_com<T>& rhs)
    #endif
      : auto_base<T>(rhs.Get())
    { Get()->AddRef(); }


    template<class T>
    #ifdef MEMBER_TEMPLATES_SUPPORTED
      template<class U>
      inline auto_com<T>& auto_com<T>::operator=(const auto_com<U>& rhs)
    #else
    inline auto_com<T>& auto_com<T>::operator=(const auto_com<T>& rhs)
    #endif
    {
		    // protect against us = us;
        if( this != &rhs )      
        {
            Reset( rhs.Get() );            
        }
        return *this;        
    }
    
    
    template<class T>
    inline void * * auto_com<T>::SetVFace( void )
    {
        return (void * *) &m_ptr;
    }


    template<class T>
    inline T * * auto_com<T>::SetIFace( void )
    {
        return &m_ptr;
    }


    template<class T>
    inline T * * auto_com<T>::operator&( void )
    {
        return &m_ptr;
    }


    template<class T>
    inline T * auto_com<T>::Relenquish( void )
    {   
		Get()->AddRef( );	// We're giving away a pointer
							// we're going to Release in our dtor
        return Get();
    }



	    //note: occurrences of Reset() or Reset(NULL) will inline
        //an always-false if(NULL != p), unreachable code warning.
    #pragma warning( disable : 4702 )
    template<class T>
    inline void auto_com<T>::Reset( T *p)
    {   
		if( NULL != p )
			p->AddRef( );
		if( NULL != m_ptr )
			m_ptr->Release( );		
        m_ptr = p;
    }
    #pragma warning( default : 4702 )



    template<class T>
    #ifdef MEMBER_TEMPLATES_SUPPORTED
        template<class U>
        inline void auto_com<T>::TransferTo( auto_com<U>& rhs )
    #else        
    inline void auto_com<T>::TransferTo( auto_com<T>& rhs )
    #endif // MEMBER_TEMPLATES_SUPPORTED
    {
		rhs.Reset( Get() );		
    }


    template<class T>
    inline BOOL operator==( const auto_com<T> &lhs,
                            const auto_com<T> &rhs )
    {
        return lhs.m_ptr == rhs.m_ptr;
    }


    template<class T>
    inline BOOL operator!=( const auto_com<T> &lhs,
                            const auto_com<T> &rhs )
    {
        return !(lhs == rhs);
    }


    ///////////////////////// end /////////////////////

} // end namespace IHammer

#endif // INC_AUTO_PTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\inc\bitfield.h ===
#ifndef INC_BITFIELD_H_
#define INC_BITFIELD_H_
/*************************************
 *
 * Bitfield.h --
 * A quick-n'-dirty, fixed-size bitfield
 * class.
 *
 * Author: Norm Bryar     Apr., '97
 *
 *************************************/

namespace bargain {

	template< int N >
	class CBitField
	{
	public:
		CBitField( )
		{  
			for( int i=0; i<ctBytes; ++i )
				m_bits[i] = 0;
		}

		inline BOOL  Set( int bit )
		{
			BOOL fPrevious;
			int  idx   = bit / 8;
			BYTE mask = (1u << (bit % 8));

			fPrevious = !!(m_bits[ idx ]  & mask);
			m_bits[ idx ]  |= mask;
			return fPrevious;
		}

		inline BOOL  Clear( int bit )
		{
			BOOL fPrevious;
			int  idx   = bit / 8;
			BYTE mask = (1u << (bit % 8));

			fPrevious = !!(m_bits[ idx ]  & mask);
			m_bits[ idx ]  &= ~mask;
			return fPrevious;
		}

		inline BOOL operator[](int bit )
		{
			int  idx   = bit / 8;
			BYTE mask = (1u << (bit % 8));
			return !!(m_bits[ idx ] & mask);
		}

	private:
		enum { ctBytes = (N+7)/8 };
		BYTE   m_bits[ ctBytes ];	
	};

}; // end namespace bargain

#endif // INC_BITFIELD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\inc\avl.h ===
#include <iostream.h>
#include <iomanip.h>
#include <ctype.h>

template <class T>
class CAVLNode
{
    friend class CAVLTree<T>;
    int       m_iBal;
    CAVLNode<T>* m_pLeft;
    CAVLNode<T>* m_pRight;
    T         m_T;
 
    CAVLNode( T Element = 0, CAVLNode *L = NULL, CAVLNode *R = NULL ) : 
        m_T( Element ), m_pLeft( L ), m_pRight( R ), m_iBal(0) {}
};



template <class T>
class CAVLTree
{
public:
    CAVLTree():m_pRoot(NULL){}
    void Insert(T& t) {ins(m_pRoot, t);}
    void Remove(T& t) {del(m_pRoot, t);}
    void Print() const {pr(m_pRoot, 0);}
private:
    CAVLNode<T>* m_pRoot;
    void LeftRotate(CAVLNode<T>* &p);
    void RightRotate(CAVLNode<T>* &p);
    int ins(CAVLNode<T>* &p, T& t);
    int del(CAVLNode<T>* &p, T& t);
#ifdef DO_STDOUT
    void pr(const CAVLNode<T> *p, int nSpace)const;
#endif //DO_STDOUT
};



template <class T>
void CAVLTree<T>::LeftRotate(CAVLNode<T>* &p)
{  CAVLNode<T> *q = p;
   p = p->m_pRight;
   q->m_pRight = p->m_pLeft;
   p->m_pLeft = q;
   q->m_iBal--;
   if (p->m_iBal > 0) q->m_iBal -= p->m_iBal;
   p->m_iBal--;
   if (q->m_iBal < 0) p->m_iBal += q->m_iBal;
}

template <class T>
void CAVLTree<T>::RightRotate(CAVLNode<T>* &p)
{  CAVLNode<T> *q = p;
   p = p->m_pLeft;
   q->m_pLeft = p->m_pRight;
   p->m_pRight = q;
   q->m_iBal++;
   if (p->m_iBal < 0) q->m_iBal -= p->m_iBal;
   p->m_iBal++;
   if (q->m_iBal > 0) p->m_iBal += q->m_iBal;
}

template <class T>
int CAVLTree<T>::ins(CAVLNode<T>* &p, T& t)
{  // Return value: increase in height (0 or 1) after
   // inserting x in the (sub)tree with root p
   int deltaH=0;
   if (p == NULL)
   {  
      p = new CAVLNode<T>(t);
      deltaH = 1; // Tree height increased by 1
   }  
   else
   if (t > p->m_T)
   {  if (ins(p->m_pRight, t))
      {  p->m_iBal++; // Height of right subtree increased 
         if (p->m_iBal == 1) deltaH = 1; else
         if (p->m_iBal == 2)
         {  if (p->m_pRight->m_iBal == -1) RightRotate(p->m_pRight);
            LeftRotate(p);
         }
      }
   }  
   else
   if (t < p->m_T)
   {  if (ins(p->m_pLeft, t))
      {  p->m_iBal--; // Height of left subtree increased 
         if (p->m_iBal == -1) deltaH = 1; else
         if (p->m_iBal == -2)
         {  if (p->m_pLeft->m_iBal == 1) LeftRotate(p->m_pLeft);
            RightRotate(p);
         }
      }
   }
   return deltaH;
}



/* Return value: decrease in height (0 or 1) of subtree
   with root p, after deleting the node with key x.
   (If there is no such node, 0 will be returned.)
*/

template <class T>
int CAVLTree<T>::del(CAVLNode<T>* &p, T& t)
{  
   CAVLNode<T>** qq, *p0;
   int deltaH=0;
   if (p == NULL) return 0;
   if (t < p->m_T)
   {  if (del(p->m_pLeft, t))
      {  p->m_iBal++; // Height left subtree decreased
         if (p->m_iBal == 0) deltaH = 1; else
         if (p->m_iBal == 2)
         {  if (p->m_pRight->m_iBal == -1) RightRotate(p->m_pRight);
            LeftRotate(p);
            if (p->m_iBal == 0) deltaH = 1;
         }
      }
   }  else
   if (t > p->m_T)
   {  if (del(p->m_pRight, t))
      {  p->m_iBal--; // Height right subtree decreased
         if (p->m_iBal == 0) deltaH = 1; else
         if (p->m_iBal == -2)
         {  if (p->m_pLeft->m_iBal == 1) LeftRotate(p->m_pLeft);
            RightRotate(p);
            if (p->m_iBal == 0) deltaH = 1;
         }
      }
   }  else  // t == p->m_T
   {  if (p->m_pRight == NULL)
      {  p0 = p; p = p->m_pLeft; delete p0; return 1;
      }  else
      if (p->m_pLeft == NULL)
      {  p0 = p; p = p->m_pRight; delete p0; return 1;
      }  else
      {  qq = & p->m_pLeft;
         while ((*qq)->m_pRight != NULL) qq = & (*qq)->m_pRight;
         p->m_T = (*qq)->m_T;
         (*qq)->m_T = t;
         if (del(p->m_pLeft, t))
         {  p->m_iBal++; // Height left subtree decreased
            if (p->m_iBal == 0) deltaH = 1; else
            if (p->m_iBal == 2)
            {  if (p->m_pRight->m_iBal == -1) RightRotate(p->m_pRight);
               LeftRotate(p);
               if (p->m_iBal == 0) deltaH = 1;
            }
         }
      }
   }
   return deltaH;
}

#ifdef DO_STDOUT

template <class T>
void CAVLTree<T>::pr(const CAVLNode<T> *p, int nSpace)const
{  if (p != NULL)
   {  pr(p->m_pRight, nSpace+=6);
      cout << setw(nSpace) << p->m_T << " " << p->m_iBal << endl;
      pr(p->m_pLeft, nSpace);
   }
}

#endif //DO_STDOUT

int main()
{  int x;
   char ch;
   CAVLTree<int> t;

	for (x = 0; x < 100; x++)
		t.Insert(x);

	t.Print();

    cout << "-------------------------------------------\n";

    for (x = 0; x < 100; x++)
        t.Remove(x);

	t.Print();

   return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\inc\context.h ===
/*************************************************
CONTEXT.H:

Public header file used by users of Context Menus.

*************************************************/

#ifndef __CONTEXT_H__
#define __CONTEXT_H__

// Shared context message codes...
#define CM_ERROR                -1 // An error occurred
#define CM_CANCELLED            0  // Cancelled operation
#define CM_COMPLETED            1  // Completed operation
#define CM_CUTOBJECT            2  // Instruct Shell to Cut Object
#define CM_COPYOBJECT           3  // Instruct Shell to Copy Object
#define CM_PASTEOBJECT          4  // Instruct Shell to Paste Object
#define CM_DELETEOBJECT         5  // Instruct Shell to Delete Object
#define CM_OBJECTPROPERTIES     6  // Instruct Shell to launch Object Properties
#define CM_PLAYOBJECT           7  // Instruct Shell to Play Object
#define CM_STOPOBJECT           8  // Instruct Shell to Stop Object
#define CM_REWINDOBJECT         9  // Instruct Shell to Rewind Object
#define CM_COMMAND             10  // Instruct Shell to issue Command (string defined in lParam)
#define CM_EDITOBJECT          11  // Instruct Shell to launch object editor
#define CM_IMPORTOBJECTDATA    12  // Instruct Shell to launch object import dialog
#define CM_STEPOBJECTFWD       13  // Instruct Shell to step object forward
#define CM_STEPOBJECTBACK      14  // Instruct Shell to step object backward
#define CM_ACTIVATEOBJECT      15  // Instruct Shell to Activate (Deactivate) object
#define CM_RENAMEOBJECT        16  // Instruct Shell to Rename Object
#define CM_ASSIGNMEDIA         17  // Instruct Shell to Assign media to the object
#define CM_DELETESCENE         18  // Instruct Shell to Delete current scene
#define CM_SELECTALL           19  // Instruct to select all items
#define CM_MOVEUP              20  // Instruct to promote an item
#define CM_MOVEDOWN            21  // Instruct to demote an item
#define CM_CREATENEW           22  // Instruct to make a new item
#define CM_ZOOMIN              23  // Instruct to magnify view
#define CM_ZOOMOUT             24  // Instruct to diminish view

#define CM_CUSTOM            4000  // Base for Custom Context Messages...

#define CM_MESSAGE_ID_STRING  "Context Menu Message" // Do NOT localize!

// Use this macro to get the context message id
#define GetContextMenuID() (::RegisterWindowMessage(CM_MESSAGE_ID_STRING))

#endif // __CONTEXT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\inc\cbtree.h ===
// cbtree.h place holder
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\inc\ctstr.h ===
/*++

Module:
	cstr.h

Description:
	Header for TSTR wrapper class

Author:
	Simon Bernstein (simonb)

--*/

#include <ihammer.h>
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#undef WIN32_LEAN_AND_MEAN

#ifndef __CTSTR_H__
#define __CTSTR_H__

class CTStr
{
public:
	EXPORT CTStr(LPWSTR pszStringW);       // Construct with Unicode string
	EXPORT CTStr(LPSTR pszStringA);        // Construct with ANSI string
	EXPORT CTStr(int iAllocateLength = 0); // Default constructor (optional preallocate)
	EXPORT CTStr(CTStr &rhs);              // Copy constructor
	
	EXPORT ~CTStr();
	
	EXPORT BOOL SetString(LPWSTR pszStringW);
	EXPORT BOOL SetString(LPSTR pszStringA);
	EXPORT BOOL SetStringPointer(LPTSTR pszString, BOOL fDealloc = TRUE);
	EXPORT BOOL AllocBuffer(int iAllocateLength, BOOL fDealloc = TRUE);
	EXPORT void FreeBuffer();

	EXPORT BSTR SysAllocString();

	EXPORT LPTSTR psz() {return m_pszString;}
	EXPORT LPSTR pszA();
	EXPORT LPWSTR pszW();
	EXPORT int Len() {return m_iLen;}
	EXPORT void ResetLength();

private:
	LPTSTR m_pszString;
	int m_iLen;

	int UNICODEToANSI(LPSTR pchDst, LPCWSTR pwchSrc, int cchDstMax);
	int ANSIToUNICODE(LPWSTR pwchDst, LPCSTR pchSrc, int cwchDstMax);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\inc\dds_bs.h ===
#ifndef INC_DDS_BS_H_
#define INC_DDS_BS_H_
/***********************************************
 *
 *  DDS_BS.h --
 *  Adapter class to make an IBitmapSurface fit
 *  clients using IDirectDrawSurface.
 *
 *  Author:  Norm Bryar
 *  History:
 *		4/22/97 - Created
 *
 **********************************************/

#ifndef  __DDRAW_INCLUDED__
  #include <ddraw.h>
#endif // __DDRAW_INCLUDED__

	// forward declares
	struct lockpair;
	struct IBitmapSurface;
	class  lockcollection;


	class CDDSBitmapSurface : public IDirectDrawSurface
	{
	public:
		EXPORT CDDSBitmapSurface( IBitmapSurface * pibs );	   

		virtual ~CDDSBitmapSurface( );	

		STDMETHOD(QueryInterface)( REFIID riid, void * * ppv );

		STDMETHOD_(ULONG,   AddRef)( void );

		STDMETHOD_(ULONG,   Release)( void );

			// --- IDirectDrawSurface methods ---
		STDMETHOD(AddAttachedSurface)(THIS_ LPDIRECTDRAWSURFACE);
		STDMETHOD(AddOverlayDirtyRect)(THIS_ LPRECT);
		STDMETHOD(Blt)(THIS_ LPRECT,LPDIRECTDRAWSURFACE, LPRECT,DWORD, LPDDBLTFX);
		STDMETHOD(BltBatch)(THIS_ LPDDBLTBATCH, DWORD, DWORD );
		STDMETHOD(BltFast)(THIS_ DWORD,DWORD,LPDIRECTDRAWSURFACE, LPRECT,DWORD);
		STDMETHOD(DeleteAttachedSurface)(THIS_ DWORD,LPDIRECTDRAWSURFACE);
		STDMETHOD(EnumAttachedSurfaces)(THIS_ LPVOID,LPDDENUMSURFACESCALLBACK);
		STDMETHOD(EnumOverlayZOrders)(THIS_ DWORD,LPVOID,LPDDENUMSURFACESCALLBACK);
		STDMETHOD(Flip)(THIS_ LPDIRECTDRAWSURFACE, DWORD);
		STDMETHOD(GetAttachedSurface)(THIS_ LPDDSCAPS, LPDIRECTDRAWSURFACE FAR *);
		STDMETHOD(GetBltStatus)(THIS_ DWORD);
		STDMETHOD(GetCaps)(THIS_ LPDDSCAPS);
		STDMETHOD(GetClipper)(THIS_ LPDIRECTDRAWCLIPPER FAR*);
		STDMETHOD(GetColorKey)(THIS_ DWORD, LPDDCOLORKEY);
		STDMETHOD(GetDC)(THIS_ HDC FAR *);
		STDMETHOD(GetFlipStatus)(THIS_ DWORD);
		STDMETHOD(GetOverlayPosition)(THIS_ LPLONG, LPLONG );
		STDMETHOD(GetPalette)(THIS_ LPDIRECTDRAWPALETTE FAR*);
		STDMETHOD(GetPixelFormat)(THIS_ LPDDPIXELFORMAT);
		STDMETHOD(GetSurfaceDesc)(THIS_ LPDDSURFACEDESC);
		STDMETHOD(Initialize)(THIS_ LPDIRECTDRAW, LPDDSURFACEDESC);
		STDMETHOD(IsLost)(THIS);
		STDMETHOD(Lock)(THIS_ LPRECT,LPDDSURFACEDESC,DWORD,HANDLE);
		STDMETHOD(ReleaseDC)(THIS_ HDC);
		STDMETHOD(Restore)(THIS);
		STDMETHOD(SetClipper)(THIS_ LPDIRECTDRAWCLIPPER);
		STDMETHOD(SetColorKey)(THIS_ DWORD, LPDDCOLORKEY);
		STDMETHOD(SetOverlayPosition)(THIS_ LONG, LONG );
		STDMETHOD(SetPalette)(THIS_ LPDIRECTDRAWPALETTE);
		STDMETHOD(Unlock)(THIS_ LPVOID);
		STDMETHOD(UpdateOverlay)(THIS_ LPRECT, LPDIRECTDRAWSURFACE,LPRECT,DWORD, LPDDOVERLAYFX);
		STDMETHOD(UpdateOverlayDisplay)(THIS_ DWORD);
		STDMETHOD(UpdateOverlayZOrder)(THIS_ DWORD, LPDIRECTDRAWSURFACE);

	private:
		HRESULT  AddLockPair( lockpair & lp );
		HRESULT  RemoveLockPair( void * pv );
		HRESULT  UpdatePixFormat( void );	

	private:		
		IBitmapSurface * m_pibs;
		ULONG            m_ctRef;
		lockcollection * m_plockcollection;
		int              m_ctPairs;
		DDPIXELFORMAT    m_ddpixformat;

		friend  lockcollection;
	};	

#endif // INC_DDS_BS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\inc\debug.h ===
/*********************************************************
MODULE: DEBUG.H
AUTHOR: Outlaw     

summer '93

DESCRIPTION: Header for debugging functions.
**********************************************************/

#ifndef __DEBUG_H
#define __DEBUG_H            

#include <windows.h>
#include <assert.h>
      
/*==================================================================================================*/

#ifndef EXPORT
#define EXPORT __declspec(dllexport)
#endif
                         
    void EXPORT FAR CDECL RetailEcho(LPSTR lpstr, ...);
                             
#ifdef _DEBUG
    void EXPORT WINAPI AssertDebugBreak(BOOL f, LPSTR lpstrAssert, LPSTR lpstrFile, UINT uLine);
    void EXPORT WINAPI AssertDebugBreakMessage(BOOL f, LPSTR lpstrAssert, LPSTR lpstrFile, UINT uLine, LPSTR lpMessage);
    void EXPORT FAR CDECL OldEcho(LPSTR lpstr, ...);

#define Proclaim(x)     if (!(x)) { AssertDebugBreak((x) ? TRUE : FALSE, #x, (LPSTR)__FILE__, (UINT)__LINE__); }

#define ProclaimMessage(x, y)  if (!(x)) { AssertDebugBreakMessage((x) ? TRUE : FALSE, #x, (LPSTR)__FILE__, (UINT)__LINE__, (LPSTR)y); }

	void 	EXPORT WINAPI InitMemFailSim(BOOL	fFail);
	BOOL	EXPORT WINAPI FMemFailOn();
	void	SetCountMemFailSim(long cFail);
	long	CFailGetMemFailSim();
	void	EXPORT WINAPI ResetAndIncMemFailSim();
	BOOL	FFailMemFailSim();
	void	EXPORT WINAPI MemSimDlg(HWND	hwnd);
	LONG	EXPORT WINAPI LIdGetVbDlg(HWND	hwnd);
#else
    #define Proclaim(x)     void(0)
	#define ProclaimMessage(x, y)  void(0)
#endif                                  
    
    // We NEVER care about this...
    inline void FAR CDECL Echo(LPSTR lpstr, ...) {}

#ifdef _DEBUG
     #define ProclaimShortFileName(x)   assert((lstrlen(x) < CCH_SHORT_FILENAME) && !_fstrchr(x, ':') && !_fstrchr(x, '\\'))
#else
     #define ProclaimShortFileName(x) void(0)
#endif

// Added by VK
#ifdef _DEBUG
	void EXPORT ShowWndProcParams ( HINSTANCE hInst, LPCSTR name, HWND hwnd, UINT message, UINT wParam, LONG lParam );
	void SetWndProcParamsRange ( UINT uMin, UINT uMax );
#else
	#define ShowWndProcParams(x1,x2,x3,x4,x5,x6) void(0)
	#define SetWndProcParamsRange(x1,x2) void(0)
#endif

/*=====================================================================================================*/      
      
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\inc\dither.h ===
#ifndef __DITHER_H__
#define __DITHER_H__

#define PATTERN_ROWS 4
#define PATTERN_COLS 4

#ifndef DITHER_IMPL
  #define DLINKAGE __declspec( dllimport )
#else
  #define DLINKAGE __declspec( dllexport )
#endif  // DITHER_IMPL

    //forward declares...
struct IDirectDrawSurface;

typedef struct tagLOGPALETTE256
{
    WORD        palVersion;
    WORD        palNumEntries;
    PALETTEENTRY palPalEntry[256];
} LOGPALETTE256, *PLOGPALETTE256, *LPLOGPALETTE256;

	

class CHalftonePalette
{
    enum { significant_bits = 4,
           green_offset     = significant_bits,
           red_offset       = green_offset + significant_bits
         };

public:
	DLINKAGE CHalftonePalette( );
	DLINKAGE CHalftonePalette(HPALETTE hpal);
	virtual ~CHalftonePalette();

	STDMETHOD (Regenerate)( HPALETTE hPal );
	STDMETHOD_(BYTE,GetNearestPaletteIndex)(int iRed, int iGreen, int iBlue)
	{
		return m_pbQuantizationTable[ ((iRed>>significant_bits)<<red_offset) + 
                                      ((iGreen>>significant_bits)<<green_offset) + 
                                      (iBlue>>significant_bits) ];
	}

	STDMETHOD (GetPaletteEntry)(int iIndex, LPBYTE pbRedDst, LPBYTE pbGreenDst, LPBYTE pbBlueDst)
	{
		LPPALETTEENTRY pe = &m_logpal.palPalEntry[iIndex];
		*pbRedDst   = pe->peRed;
		*pbGreenDst = pe->peGreen;
		*pbBlueDst  = pe->peBlue;
		return S_OK;
	}

protected:
	STDMETHOD (Initialize)(void);

protected:
	LOGPALETTE256     m_logpal;
	LPBYTE            m_pbQuantizationTable;
	CRITICAL_SECTION  m_critSection;
};


class CHalftone
{
public:
	DLINKAGE CHalftone(HPALETTE hpal);
	virtual ~CHalftone();
	STDMETHOD (Initialize)(void);
	STDMETHOD (Dither32to1)(IDirectDrawSurface* pSrc, LPRECT prectSrc, IDirectDrawSurface* pDst, LPRECT prectDst);
	STDMETHOD (Dither32to8)(IDirectDrawSurface* pSrc, LPRECT prectSrc, IDirectDrawSurface* pDst, LPRECT prectDst);
	STDMETHOD (Blt32to555)(IDirectDrawSurface* pSrc, LPRECT prectSrc, IDirectDrawSurface* pDst, LPRECT prectDst);
	STDMETHOD (Blt32to565)(IDirectDrawSurface* pSrc, LPRECT prectSrc, IDirectDrawSurface* pDst, LPRECT prectDst);
	STDMETHOD (Blt32to24)(IDirectDrawSurface* pSrc, LPRECT prectSrc, IDirectDrawSurface* pDst, LPRECT prectDst);
	STDMETHOD (Blt32to32)(IDirectDrawSurface* pSrc, LPRECT prectSrc, IDirectDrawSurface* pDst, LPRECT prectDst);

protected:
	BYTE m_rgPattern[ 256 * (PATTERN_ROWS * PATTERN_COLS) ];
	CHalftonePalette m_cpal;
};


// ------------------------- HANDY UTILITIES --------------------------

	// If you know this hdc has 16 bit colordepth,
	// this will evaluate it for 555 or 565 encoding.
	// Return values: 15u=>555 encoding, 16u=>565 encoding.
DLINKAGE DWORD  GetSigBitsFrom16BPP( HDC hdc );

#endif //__DITHER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\inc\editres.h ===
#ifndef __EDITRES_H
#define __EDITRES_H

#ifndef EXPORT
	#define EXPORT __declspec(dllexport)
#endif

	// This contains the defines for these resources
	#include "..\editres\resource.h"

	// Use this to get the Instance for the DLL containing the edit mode resources
	HINSTANCE EXPORT WINAPI HGetEditResInstance(void);

	// Time spin control 
	void EXPORT WINAPI RegisterTimeSpin(HINSTANCE hInstance);
	void EXPORT WINAPI UnregisterTimeSpin(HINSTANCE hInstance);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\inc\dispids.h ===
/*++

Module: 
	dispids.h

Author: 
	IHammer Team (SimonB)

Created: 
	May 1997

Description:
	Lists DISPIDS for the DA/IHammer control object model

History:
    05-27-1997  Added SGrfx control ID's
    05-27-1997  Added sound control ID's
	05-24-1997	Created

++*/

#ifndef __DISPIDS_H__
#define __DISPIDS_H__


//////////////////////////////////////////////////////////////////
// Path control dispids
//////////////////////////////////////////////////////////////////

//
// Properties

#define DISPID_PATH_PROP_BASE             1

#define DISPID_PATH_PROP_TARGET           (DISPID_PATH_PROP_BASE + 0)
#define DISPID_PATH_PROP_DURATION         (DISPID_PATH_PROP_BASE + 1)
#define DISPID_PATH_PROP_REPEAT           (DISPID_PATH_PROP_BASE + 2)
#define DISPID_PATH_PROP_BOUNCE           (DISPID_PATH_PROP_BASE + 3)
#define DISPID_PATH_PROP_PLAYSTATE        (DISPID_PATH_PROP_BASE + 4)
#define DISPID_PATH_PROP_TIME             (DISPID_PATH_PROP_BASE + 5)
#define DISPID_PATH_PROP_DIRECTION        (DISPID_PATH_PROP_BASE + 6)
#define DISPID_PATH_PROP_PATH             (DISPID_PATH_PROP_BASE + 7)
#define DISPID_PATH_PROP_LIBRARY          (DISPID_PATH_PROP_BASE + 8)
#define DISPID_PATH_PROP_TIMERINTERVAL    (DISPID_PATH_PROP_BASE + 9)
#define DISPID_PATH_PROP_RELATIVE         (DISPID_PATH_PROP_BASE + 10)
#define DISPID_PATH_PROP_AUTOSTART        (DISPID_PATH_PROP_BASE + 11)
		
//
// Methods (start after properties)

#define DISPID_PATH_METH_BASE             (DISPID_PATH_PROP_BASE + 12)

#define DISPID_PATH_METH_STOP             (DISPID_PATH_METH_BASE + 0)
#define DISPID_PATH_METH_PAUSE            (DISPID_PATH_METH_BASE + 1)
#define DISPID_PATH_METH_PLAY             (DISPID_PATH_METH_BASE + 2)
#define DISPID_PATH_METH_SPIRAL           (DISPID_PATH_METH_BASE + 3)
#define DISPID_PATH_METH_OVAL             (DISPID_PATH_METH_BASE + 4)
#define DISPID_PATH_METH_RECT             (DISPID_PATH_METH_BASE + 5)
#define DISPID_PATH_METH_POLYLINE         (DISPID_PATH_METH_BASE + 6)
#define DISPID_PATH_METH_POLYGON          (DISPID_PATH_METH_BASE + 7)
#define DISPID_PATH_METH_KEYFRAME         (DISPID_PATH_METH_BASE + 8)
#define DISPID_PATH_METH_ADDTIMEMARKER    (DISPID_PATH_METH_BASE + 9)
#define DISPID_PATH_METH_SPLINE           (DISPID_PATH_METH_BASE + 10)
#define DISPID_PATH_METH_SEEK             (DISPID_PATH_METH_BASE + 11)

//
// Events (start from 0; different interface)


#define DISPID_PATH_EVENT_BASE 1

#define DISPID_PATH_EVENT_ONSTOP          (DISPID_PATH_EVENT_BASE + 0)
#define DISPID_PATH_EVENT_ONPLAY          (DISPID_PATH_EVENT_BASE + 1)
#define DISPID_PATH_EVENT_ONPAUSE         (DISPID_PATH_EVENT_BASE + 2)
#define DISPID_PATH_EVENT_ONSEEK          (DISPID_PATH_EVENT_BASE + 3)
#define DISPID_PATH_EVENT_ONPLAYMARKER    (DISPID_PATH_EVENT_BASE + 4)
#define DISPID_PATH_EVENT_ONMARKER        (DISPID_PATH_EVENT_BASE + 5)


//////////////////////////////////////////////////////////////////
// Sound control dispids
//////////////////////////////////////////////////////////////////

//
// Properties

#define DISPID_SND_PROP_BASE             1

#define DISPID_SND_PROP_SOURCEURL        (DISPID_SND_PROP_BASE + 0)
#define DISPID_SND_PROP_SOUNDTYPE        (DISPID_SND_PROP_BASE + 1)
#define DISPID_SND_PROP_CLOCK            (DISPID_SND_PROP_BASE + 2)
#define DISPID_SND_PROP_AUTOSTART        (DISPID_SND_PROP_BASE + 3)
#define DISPID_SND_PROP_AUTODOWNLOAD     (DISPID_SND_PROP_BASE + 4)
#define DISPID_SND_PROP_REPEAT           (DISPID_SND_PROP_BASE + 5)
#define DISPID_SND_PROP_PREROLLAMOUNT    (DISPID_SND_PROP_BASE + 6)
#define DISPID_SND_PROP_INITIALVOLUME    (DISPID_SND_PROP_BASE + 7)
#define DISPID_SND_PROP_PLAYSTATE        (DISPID_SND_PROP_BASE + 8)
#define DISPID_SND_PROP_SOUND            (DISPID_SND_PROP_BASE + 9)
#define DISPID_SND_PROP_LIBRARY          (DISPID_SND_PROP_BASE + 10)
//
// Methods (start after properties)

#define DISPID_SND_METH_BASE             (DISPID_SND_PROP_BASE + 11)

#define DISPID_SND_METH_PLAY             (DISPID_SND_METH_BASE + 0)
#define DISPID_SND_METH_PAUSE            (DISPID_SND_METH_BASE + 1)
#define DISPID_SND_METH_STOP             (DISPID_SND_METH_BASE + 2)
#define DISPID_SND_METH_REWIND           (DISPID_SND_METH_BASE + 3)
#define DISPID_SND_METH_ADDSOUND         (DISPID_SND_METH_BASE + 4)
#define DISPID_SND_METH_ADDTIMEMARKER	 (DISPID_SND_METH_BASE + 5)
#define DISPID_SND_METH_SEEK             (DISPID_SND_METH_BASE + 6)
//
// Events (start from 0; different interface)


#define DISPID_SND_EVENT_BASE 1

#define DISPID_SND_EVENT_ONSTOP          (DISPID_SND_EVENT_BASE + 0)
#define DISPID_SND_EVENT_ONPLAY          (DISPID_SND_EVENT_BASE + 1)
#define DISPID_SND_EVENT_ONPAUSE         (DISPID_SND_EVENT_BASE + 2)
#define DISPID_SND_EVENT_ONMEDIALOADED   (DISPID_SND_EVENT_BASE + 3)


//////////////////////////////////////////////////////////////////
// SGrfx control dispids
//////////////////////////////////////////////////////////////////

//
// Properties

#define DISPID_SG_PROP_BASE              1

#define DISPID_SG_PROP_SOURCEURL          (DISPID_SG_PROP_BASE + 0) 
#define DISPID_SG_PROP_COORDSYSTEM        (DISPID_SG_PROP_BASE + 1)
#define DISPID_SG_PROP_ENABLEMOUSEEVENTS  (DISPID_SG_PROP_BASE + 2)
#define DISPID_SG_PROP_EXTENTTOP          (DISPID_SG_PROP_BASE + 3)
#define DISPID_SG_PROP_EXTENTLEFT         (DISPID_SG_PROP_BASE + 4)
#define DISPID_SG_PROP_EXTENTWIDTH        (DISPID_SG_PROP_BASE + 5)
#define DISPID_SG_PROP_EXTENTHEIGHT       (DISPID_SG_PROP_BASE + 6)
#define DISPID_SG_PROP_HIQUALITY          (DISPID_SG_PROP_BASE + 7)
#define DISPID_SG_PROP_IMAGE              (DISPID_SG_PROP_BASE + 8)
#define DISPID_SG_PROP_DRAWSURFACE        (DISPID_SG_PROP_BASE + 9)
#define DISPID_SG_PROP_DRAWINGSURFACE     (DISPID_SG_PROP_BASE + 10)
#define DISPID_SG_PROP_LIBRARY            (DISPID_SG_PROP_BASE + 11)
#define DISPID_SG_PROP_TRANSFORM          (DISPID_SG_PROP_BASE + 12)
#define DISPID_SG_PROP_PRESERVEASPECTRATIO (DISPID_SG_PROP_BASE + 13)


//
// Methods  (start after properties)

#define DISPID_SG_METH_BASE              (DISPID_SG_PROP_BASE + 20)

#define DISPID_SG_METH_CLEAR             (DISPID_SG_METH_BASE + 0)
#define DISPID_SG_METH_ROTATE            (DISPID_SG_METH_BASE + 1)
#define DISPID_SG_METH_SCALE             (DISPID_SG_METH_BASE + 2)
#define DISPID_SG_METH_SETIDENTITY       (DISPID_SG_METH_BASE + 3)
#define DISPID_SG_METH_TRANSFORM4X4      (DISPID_SG_METH_BASE + 4)
#define DISPID_SG_METH_TRANSLATE         (DISPID_SG_METH_BASE + 5)
#define DISPID_SG_METH_XSHEAR            (DISPID_SG_METH_BASE + 6)
#define DISPID_SG_METH_YSHEAR            (DISPID_SG_METH_BASE + 7)
#define DISPID_SG_METH_ZSHEAR            (DISPID_SG_METH_BASE + 8)



//
// Events  (start from 0; different interface)


#define DISPID_SG_EVENT_BASE 1

#define DISPID_SG_EVENT_MOUSEMOVE        (DISPID_SG_EVENT_BASE + 0)
#define DISPID_SG_EVENT_MOUSEENTER       (DISPID_SG_EVENT_BASE + 1)
#define DISPID_SG_EVENT_MOUSELEAVE       (DISPID_SG_EVENT_BASE + 2)
#define DISPID_SG_EVENT_MOUSEDOWN        (DISPID_SG_EVENT_BASE + 3)
#define DISPID_SG_EVENT_MOUSEUP          (DISPID_SG_EVENT_BASE + 4)
#define DISPID_SG_EVENT_DBLCLICK         (DISPID_SG_EVENT_BASE + 5)
#define DISPID_SG_EVENT_CLICK            (DISPID_SG_EVENT_BASE + 6)

//////////////////////////////////////////////////////////////////
// Sprite control dispids
//////////////////////////////////////////////////////////////////

//
// Properties

#define DISPID_SPRITE_PROP_BASE                 1

#define DISPID_SPRITE_PROP_AUTOSTART            (DISPID_SPRITE_PROP_BASE + 0)
#define DISPID_SPRITE_PROP_FRAME                (DISPID_SPRITE_PROP_BASE + 1)
#define DISPID_SPRITE_PROP_FRAMEMAP             (DISPID_SPRITE_PROP_BASE + 2)
#define DISPID_SPRITE_PROP_INITIALFRAME         (DISPID_SPRITE_PROP_BASE + 3)
#define DISPID_SPRITE_PROP_ITERATIONS           (DISPID_SPRITE_PROP_BASE + 4)
#define DISPID_SPRITE_PROP_REPEAT               (DISPID_SPRITE_PROP_BASE + 5)
#define DISPID_SPRITE_PROP_PLAYRATE             (DISPID_SPRITE_PROP_BASE + 6)
#define DISPID_SPRITE_PROP_READYSTATE           (DISPID_SPRITE_PROP_BASE + 7)
#define DISPID_SPRITE_PROP_TIME                 (DISPID_SPRITE_PROP_BASE + 8)
#define DISPID_SPRITE_PROP_MAXIMUMRATE          (DISPID_SPRITE_PROP_BASE + 9)
#define DISPID_SPRITE_PROP_NUMFRAMES            (DISPID_SPRITE_PROP_BASE + 10)
#define DISPID_SPRITE_PROP_PLAYSTATE            (DISPID_SPRITE_PROP_BASE + 11)
#define DISPID_SPRITE_PROP_NUMFRAMESACROSS      (DISPID_SPRITE_PROP_BASE + 12)
#define DISPID_SPRITE_PROP_NUMFRAMESDOWN        (DISPID_SPRITE_PROP_BASE + 13)
#define DISPID_SPRITE_PROP_USECOLORKEY          (DISPID_SPRITE_PROP_BASE + 14)
#define DISPID_SPRITE_PROP_IMAGE                (DISPID_SPRITE_PROP_BASE + 15)
#define DISPID_SPRITE_PROP_COLORKEY             (DISPID_SPRITE_PROP_BASE + 16)
#define DISPID_SPRITE_PROP_SOURCEURL            (DISPID_SPRITE_PROP_BASE + 17)
#define DISPID_SPRITE_PROP_MOUSEEVENTSENABLED   (DISPID_SPRITE_PROP_BASE + 18)
#define DISPID_SPRITE_PROP_LIBRARY              (DISPID_SPRITE_PROP_BASE + 19)
#define DISPID_SPRITE_PROP_TIMERINTERVAL        (DISPID_SPRITE_PROP_BASE + 20)
#define DISPID_SPRITE_PROP_FINALFRAME           (DISPID_SPRITE_PROP_BASE + 21)
#define DISPID_SPRITE_PROP_COLORKEYRGB          (DISPID_SPRITE_PROP_BASE + 22)

//
// Methods  (start after properties)

#define DISPID_SPRITE_METH_BASE                 (DISPID_SPRITE_PROP_BASE + 23)

#define DISPID_SPRITE_METH_ADDFRAMEMARKER       (DISPID_SPRITE_METH_BASE + 0)
#define DISPID_SPRITE_METH_ADDTIMEMARKER        (DISPID_SPRITE_METH_BASE + 1)
#define DISPID_SPRITE_METH_PLAY                 (DISPID_SPRITE_METH_BASE + 2)
#define DISPID_SPRITE_METH_STOP                 (DISPID_SPRITE_METH_BASE + 3)
#define DISPID_SPRITE_METH_PAUSE                (DISPID_SPRITE_METH_BASE + 4)
#define DISPID_SPRITE_METH_SEEK                 (DISPID_SPRITE_METH_BASE + 5)
#define DISPID_SPRITE_METH_FRAMESEEK            (DISPID_SPRITE_METH_BASE + 6)


//
// Events  (start from 0; different interface)


#define DISPID_SPRITE_EVENT_BASE                1

#define DISPID_SPRITE_EVENT_ONPLAYMARKER        (DISPID_SPRITE_EVENT_BASE + 0)
#define DISPID_SPRITE_EVENT_ONMARKER            (DISPID_SPRITE_EVENT_BASE + 1)
#define DISPID_SPRITE_EVENT_MOUSEMOVE           (DISPID_SPRITE_EVENT_BASE + 2)
#define DISPID_SPRITE_EVENT_MOUSEENTER          (DISPID_SPRITE_EVENT_BASE + 3)
#define DISPID_SPRITE_EVENT_MOUSELEAVE          (DISPID_SPRITE_EVENT_BASE + 4)
#define DISPID_SPRITE_EVENT_MOUSEDOWN           (DISPID_SPRITE_EVENT_BASE + 5)
#define DISPID_SPRITE_EVENT_MOUSEUP             (DISPID_SPRITE_EVENT_BASE + 6)
#define DISPID_SPRITE_EVENT_DBLCLICK            (DISPID_SPRITE_EVENT_BASE + 7)
#define DISPID_SPRITE_EVENT_CLICK               (DISPID_SPRITE_EVENT_BASE + 8)
#define DISPID_SPRITE_EVENT_ONMEDIALOADED       (DISPID_SPRITE_EVENT_BASE + 9)
#define DISPID_SPRITE_EVENT_ONSEEK              (DISPID_SPRITE_EVENT_BASE + 10)
#define DISPID_SPRITE_EVENT_ONFRAMESEEK         (DISPID_SPRITE_EVENT_BASE + 11)
#define DISPID_SPRITE_EVENT_ONSTOP              (DISPID_SPRITE_EVENT_BASE + 12)
#define DISPID_SPRITE_EVENT_ONPAUSE             (DISPID_SPRITE_EVENT_BASE + 13)
#define DISPID_SPRITE_EVENT_ONPLAY              (DISPID_SPRITE_EVENT_BASE + 14)


//////////////////////////////////////////////////////////////////
// Sequencer control dispids
//////////////////////////////////////////////////////////////////

#define DISPID_SEQ_PROP_BASE                1

#define DISPID_SEQ_PROP_TIME                (DISPID_SEQ_PROP_BASE + 0)
#define DISPID_SEQ_PROP_COOKIE              (DISPID_SEQ_PROP_BASE + 1)
#define DISPID_SEQ_PROP_PLAYSTATE           (DISPID_SEQ_PROP_BASE + 2)

//
// Methods  (start after properties)

#define DISPID_SEQ_METH_BASE                (DISPID_SEQ_PROP_BASE + 3)
#define DISPID_SEQ_METH_PLAY                (DISPID_SEQ_METH_BASE + 0)
#define DISPID_SEQ_METH_PAUSE               (DISPID_SEQ_METH_BASE + 1)
#define DISPID_SEQ_METH_STOP                (DISPID_SEQ_METH_BASE + 2)
#define DISPID_SEQ_METH_AT                  (DISPID_SEQ_METH_BASE + 3)
#define DISPID_SEQ_METH_CLEAR               (DISPID_SEQ_METH_BASE + 4)
#define DISPID_SEQ_METH_SEEK                (DISPID_SEQ_METH_BASE + 5)


//
// Events  (start from 0; different interface)

#define DISPID_SEQ_EVENT_BASE               1
#define DISPID_SEQ_EVENT_ONPLAY             (DISPID_SEQ_EVENT_BASE + 0)
#define DISPID_SEQ_EVENT_ONSTOP             (DISPID_SEQ_EVENT_BASE + 1)
#define DISPID_SEQ_EVENT_ONPAUSE            (DISPID_SEQ_EVENT_BASE + 2)
#define DISPID_SEQ_EVENT_ONSEEK             (DISPID_SEQ_EVENT_BASE + 3)

//////////////////////////////////////////////////////////////////
// Sequencer Manager control dispids
//////////////////////////////////////////////////////////////////

//
// Properties

#define DISPID_SEQMGR_PROP_BASE             1

#define DISPID_SEQMGR_PROP_COUNT            (DISPID_SEQMGR_PROP_BASE + 0)

//
// Methods

#define DISPID_SEQMGR_METH_BASE             (DISPID_SEQMGR_PROP_BASE + 1)

#define DISPID_SEQMGR_METH_RELAYEVENT       (DISPID_SEQMGR_METH_BASE + 0)

//
// Events  (start from 0; different interface)

// The events which are being relayed from the sequencer *must* have the same dispids

#define DISPID_SEQMGR_EVENT_BASE            DISPID_SEQ_EVENT_ONSEEK + 1
#define DISPID_SEQMGR_EVENT_INIT            (DISPID_SEQMGR_EVENT_BASE + 0)
#define DISPID_SEQMGR_EVENT_ONPLAY          DISPID_SEQ_EVENT_ONPLAY
#define DISPID_SEQMGR_EVENT_ONSTOP          DISPID_SEQ_EVENT_ONSTOP
#define DISPID_SEQMGR_EVENT_ONPAUSE         DISPID_SEQ_EVENT_ONPAUSE
#define DISPID_SEQMGR_EVENT_ONSEEK          DISPID_SEQ_EVENT_ONSEEK

#endif

// End of file: dispids.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\inc\drg.h ===
/*+********************************************************
MODULE: DRG.H
AUTHOR: Outlaw
DATE: summer '93

DESCRIPTION: Dynamic Array ADT class.
*********************************************************-*/


#ifndef __DRG_H__
#define __DRG_H__

//===============================================================================================
                                  
#define DRG_APPEND  -1                  // CAN BE USED AS POSITION PARAMETER OF ::INSERT()                                  
#define DEFAULT_RESIZE_INCREMENT    0
                                  
class FAR CDrg
{
    protected:
        LONG m_lmax;            // MAX ELEMENTS THAT CAN BE CONTAINED IN ARRAY AT PRESENT
        LONG m_lmac;            // NUMBER OF ELEMENTS THAT ARE CURRENTLY IN ARRAY
        UINT m_cElementSize;    // BYTES IN EACH ARRAY ELEMENT
        UINT m_cResizeIncrement;// NUMBER OF ELEMENTS TO GROW ARRAY BY (AND SHRINK BY) WHEN NECESSARY....
        BYTE * m_qBuf;			// ARRAY BUFFER        
        LONG m_lIdxCurrent;     // USED BY GETFIRST()/GETNEXT()
            
    public: 
        WINAPI CDrg(void)
        { 
           SetNonDefaultSizes( sizeof(LONG), DEFAULT_RESIZE_INCREMENT );           
           m_lmax=0; m_lmac=0; m_qBuf=NULL; m_lIdxCurrent=0;
        }
        WINAPI ~CDrg(void) {MakeNull();}

        virtual void EXPORT WINAPI SetNonDefaultSizes(UINT cSizeElement, UINT cResizeIncrement=DEFAULT_RESIZE_INCREMENT);

        virtual BOOL EXPORT WINAPI Insert(void FAR *q, LONG cpos);
        virtual BOOL EXPORT WINAPI Remove(void FAR *q, LONG cpos);
        
        virtual LPVOID WINAPI GetFirst(void) {if (m_lmac) {m_lIdxCurrent=1; return(m_qBuf);} return(NULL);}
        virtual LPVOID WINAPI GetNext(void) {if (m_lmac > m_lIdxCurrent) return(m_qBuf + (m_lIdxCurrent++) * m_cElementSize); return(NULL);}

            // Norm Bryar  cpos is zero based, no access to <0 or >=m_lmac            
        virtual LPVOID WINAPI GetAt(LONG cpos) 
        {  
            Proclaim(m_qBuf); 
            if( (cpos >= m_lmac) || (0 > cpos) )
                return(NULL); 
            return(m_qBuf+(m_cElementSize*cpos));
        }
        
        virtual DWORD WINAPI GetDword(LONG cpos)
        {
            Proclaim(m_qBuf); 
            if( (cpos >= m_lmac) || (0 > m_lmac) )
                return(0); 
            return(((DWORD FAR *)m_qBuf)[cpos]);
        }

        VOID WINAPI SetAt(void FAR *q, LONG cpos)
        {
            Proclaim(m_qBuf);
            Proclaim((cpos<m_lmac) || (0 > cpos));             
			memcpy(m_qBuf+(m_cElementSize * cpos), (BYTE *)q, m_cElementSize);
        }
        
        virtual LONG WINAPI Count(void) {return(m_lmac);}  
        virtual VOID WINAPI MakeNull(void)
        {
            if (m_qBuf)
            {
                HANDLE h=MemGetHandle(m_qBuf);

                Proclaim(h);

                if (h)
                {
                    MemUnlock(h);
					MemFree(h);
                }
                m_qBuf=NULL;
                m_lmax=0;
                m_lmac=0;
                m_lIdxCurrent=0;
            }
        }
        
        virtual BOOL WINAPI CopyFrom(CDrg FAR *qdrg) {LONG i; MakeNull(); Proclaim(m_cElementSize==qdrg->m_cElementSize); for (i=0; i<qdrg->m_lmac; i++) {if (!Insert(qdrg->GetAt(i), DRG_APPEND)) return(FALSE);} return(TRUE);}

        virtual LPVOID WINAPI GetBufPtr(void) {return(m_qBuf);}
        
        virtual VOID WINAPI SetArray(BYTE * qBuf, LONG lElements, UINT uElementSize) {MakeNull(); m_qBuf=qBuf; m_lmax=lElements; m_lmac=lElements; m_cElementSize=uElementSize;}
        
		virtual LPBYTE WINAPI ExtractArray(void) {BYTE * q=m_qBuf; m_qBuf=NULL; m_lmax=0; m_lmac=0; m_lIdxCurrent=0; return(q);}
        
        virtual UINT WINAPI GetElSize(void) {return(m_cElementSize);}
};         


typedef CDrg FAR * LPDRG;


// DRG USED AS A DWORD QUEUE
class FAR CLongQueue
{                    
    protected:
        CDrg m_drg;

    public:        
        BOOL WINAPI Enqueue(LONG lVal) {return(m_drg.Insert(&lVal, DRG_APPEND));}
        BOOL WINAPI Dequeue(LONG FAR *qlVal) {return(m_drg.Remove(qlVal, 0));}
};
        
        
        
// FIXED ARRAY OF DRGS        
class FAR CRgDrg 
{
    protected:                                           
        LONG m_lmax;
        CDrg FAR * FAR *m_qrgdrg;

        void WINAPI Deallocate(void) {if (m_qrgdrg) {LONG i; CDrg FAR *q; for (i=0; i<m_lmax; i++) {q=m_qrgdrg[i]; if (q) Delete q;} HANDLE h=MemGetHandle(m_qrgdrg); MemUnlock(h); MemFree(h); m_qrgdrg=NULL; m_lmax=0;}}
    
    public:
        WINAPI CRgDrg(void) {m_qrgdrg=NULL; m_lmax=0;}
        WINAPI ~CRgDrg(void) {Deallocate();}
        LPDRG WINAPI GetDrgPtr(LONG lidx) {return(m_qrgdrg[lidx]);}
        
        BOOL WINAPI Init(LONG cDrg, UINT cElementSize) 
        {   
            LONG i;
            HANDLE h=MemAllocZeroInit(cDrg * sizeof(CDrg FAR *)); 
            if (!h) 
                return(FALSE); 
            m_qrgdrg=(CDrg FAR * FAR *)MemLock(h);                
            m_lmax=cDrg;
            for (i=0; i<cDrg; i++) 
            {
                m_qrgdrg[i]=New CDrg;
                if (!m_qrgdrg[i])
                {
                    Deallocate();
                    return(FALSE);
                }       
                m_qrgdrg[i]->SetNonDefaultSizes(cElementSize);
            }    
            return(TRUE);
        }                
};



// This class is essentially similar to the CDrg class ... but 
// when you insert an element into a particular array entry, it will stay at 
// that entry until it is removed; that is, the array won't shrink automatically.
// 

class FAR CNonCollapsingDrg : public CDrg
{
    public:
        WINAPI CNonCollapsingDrg(void) {}
        WINAPI ~CNonCollapsingDrg(void) {MakeNull();}

        //virtual void EXPORT WINAPI SetNonDefaultSizes(UINT cSizeElement, UINT cResizeIncrement=DEFAULT_RESIZE_INCREMENT);

        virtual BOOL WINAPI Insert(void FAR *q, LONG cpos) {return(FALSE);}  /* not supported */
        virtual BOOL EXPORT WINAPI Remove(void FAR *q, LONG cpos);
        
        virtual LPVOID EXPORT WINAPI GetFirst(void);
        virtual LPVOID EXPORT WINAPI GetNext(void);

        virtual LPVOID EXPORT WINAPI GetAt(LONG cpos);
        virtual DWORD WINAPI GetDword(LONG cpos) {return(0);}    /* not supported */
        virtual BOOL EXPORT WINAPI SetAt(void FAR *q, LONG cpos);
        
        virtual BOOL EXPORT WINAPI CopyFrom(CDrg FAR *qdrg);

        virtual LPVOID WINAPI GetBufPtr(void) {return(NULL);}

        virtual VOID EXPORT WINAPI SetArray(BYTE * qBuf, LONG lElements, UINT uElementSize);

        virtual UINT WINAPI GetMaxElements(void) {return(m_lmax);}
};


// -------- templatized extensions of CDrg --------------------

        // Assumes <class T> is a class or type
        // that you wish to store pointers to, e.g.
        // CPtrDrg<CFleagal> stores CFleagal *.
    template <class T>
    class CPtrDrg : protected CDrg
    {
    public:
        CPtrDrg( ) : CDrg( )
        { SetNonDefaultSizes( sizeof(T *) );  }

        CPtrDrg( const CPtrDrg<T> & toCopy );

            // note: SHALLOW COPY!!!            
        CPtrDrg<T> & operator=( const CPtrDrg<T> & toCopy );

        virtual EXPORT WINAPI  ~CPtrDrg()
        { NULL; }


        virtual BOOL EXPORT WINAPI Insert(T * qT , LONG cpos)
		{  return CDrg::Insert( &qT, cpos );  }

        virtual BOOL EXPORT WINAPI Insert( T * qT )
        {  return CDrg::Insert( &qT, DRG_APPEND );  }        

        virtual BOOL EXPORT WINAPI Remove( int idx )
        {  return CDrg::Remove( NULL, (ULONG) idx );  }

        virtual EXPORT T * WINAPI operator[]( int idx ) const;

        virtual int  EXPORT WINAPI Count( void ) const
        {  return (int) m_lmac; }

        virtual void WINAPI MakeNull( void )
        {  CDrg::MakeNull();  }

        virtual void WINAPI MakeNullAndDelete( void );
    };

    template <class T>
    CPtrDrg<T>::CPtrDrg( const CPtrDrg<T> & toCopy )
    {  CPtrDrg::operator=<T>(toCopy);  }

    template <class T>
    CPtrDrg<T> & CPtrDrg<T>::operator=( const CPtrDrg<T> & toCopy )
    {
            // We don't know whether we're supposed to 
            // delete our pointers or not when we nullify our drg.
            // Don't assign to a populated CPtrDrg!
        Proclaim( 0 == Count() );

        if( this == &toCopy )
            return *this;

        MakeNull( );
        for( int idx=0; idx<toCopy.Count(); idx++ )        
            Insert( toCopy[idx] );  // SHALLOW COPY!

        return *this;
    }

    template <class T>
    void WINAPI CPtrDrg<T>::MakeNullAndDelete( void )
    {
        T *  pT;
        for( int i=0; i<Count(); i++ )
        {
            pT = (*this)[ i ];
            Delete pT;
        }
        CDrg::MakeNull();
    }
    
    template <class T>
    T *  CPtrDrg<T>::operator[]( int idx ) const
    {   
        CPtrDrg<T> *  pThis;            
        pThis = const_cast<CPtrDrg<T> * const>(this);
        T * *  ppItem;
        ppItem = (T * *) pThis->GetAt( (LONG) idx );
        return *ppItem;
    }



        
        // Assumes <class T> is a class or type
        // that you wish to store pointers to, e.g.
        // CSortedPtrDrg<int> stores int *.
        // T must have an operator< and operator==.
    template <class T>
    class CSortedPtrDrg : public CPtrDrg<T>
    {
    public:
        CSortedPtrDrg( ) : CPtrDrg<T>( )
        { NULL; }

        virtual ~CSortedPtrDrg()
        { NULL; }

        virtual BOOL Insert( T * qT );        
        virtual BOOL Remove( T * qT );
        virtual BOOL Remove( int idx )
        {  return CPtrDrg<T>::Remove( idx );  }
        virtual BOOL ReSort( T * const qT = NULL );
        virtual BOOL ReSort( int idx )
        {  T * qT;  return CDrg::Remove( &qT, idx ) && Insert( qT );  }
        virtual BOOL Search( const T * pToFind,
                     int * pIdx ) const;
        virtual BOOL SearchForCeiling( const T * pToFind,
                               int *pIdx );

    protected:
        virtual int SearchForHigher( const T * pToFind ) const;
    };

    template <class T>
    BOOL CSortedPtrDrg<T>::Insert( T * qT )
    {
        int idx;
        idx = SearchForHigher( qT );
        return CDrg::Insert( &qT, idx );
    }

    template <class T>
    BOOL CSortedPtrDrg<T>::Remove( T * qT )
    {
        int idx;
        if( !Search( qT, &idx ) )
            return FALSE;

        return CDrg::Remove( NULL, (LONG) idx );
    }

    template <class T>
    BOOL CSortedPtrDrg<T>::ReSort( T * const qT )
    {
            // Just re-sort this one item
        if( NULL != qT )
        {
            int i;
            for( i=0; i<m_lmac; i++ )
            {
                    // Try finding the actual pointer.
                    // The object changed; can't find by sort-key.
                if( operator[](i) == qT )
                    return ReSort( i );
            }
        }

            // Review(all):  O(n^2) bubble sort
            // we may want to re-code this.  
        long    j, 
                flip, 
                size;
        T  * *  ptArray;
        T  *    ptemp;

            // Do pointer arithmatic on T* not BYTE
        ptArray = (T * *) m_qBuf;
            
        flip = 0;
        size = m_lmac-1;
        do
        {                
            for( j=0, flip = 0; j < size; j++ )
            {
                    // Compare T to T; T* < T* irrelevant.
                    // note: !(x<y) requires only operator<
                if( *ptArray[j+1] < *ptArray[j] )
                {
                    ptemp = ptArray[j+1];
                    ptArray[j+1] = ptArray[j];
                    ptArray[j]   = ptemp;
                    flip++;
                }

            } // end size

        } while( flip );

        return TRUE;
    }
  
    template <class T>
    BOOL CSortedPtrDrg<T>::Search( const T * pToFind,
                                       int * pIdx ) const
    {
        if( NULL == pToFind )
        {
            if( pIdx )
                *pIdx = -1;
            return FALSE;
        }

        int iLeft,
            iRight,
            idx;
        T * pT;
        iLeft = 0;
        iRight = Count()-1;
        while( iRight >= iLeft )
        {
            idx = (iLeft + iRight)/2;
            pT = (*this)[idx];
            if( *pToFind == *pT )
            {
                if( NULL != pIdx )
                    *pIdx = idx;
                return TRUE;
            }
            if( *pT < *pToFind )
                  iLeft = idx+1;
            else  iRight = idx-1;
        }
        if( NULL != pIdx )
            *pIdx = -1;
        return FALSE;
    }

    template <class T>
    BOOL CSortedPtrDrg<T>::SearchForCeiling( const T * pToFind,
                                             int *pIdx )
    {
        *pIdx = -1;
        if( !Count() )
            return FALSE;

        int iLeft,
            iRight,
            idx;
	    
        idx = 0;
        iLeft = 0;
        iRight = Count() - 1;
        while( iRight >= iLeft )
        {
            idx = (iLeft + iRight)/2;
            if( *pToFind == *(*this)[idx] )
            {
                *pIdx = idx;
                return TRUE;
            }
            if( *pToFind < *(*this)[idx] )
                  iRight = idx-1;
            else  iLeft = idx+1;
        }        
        return FALSE;
    }

    template <class T>
    int CSortedPtrDrg<T>::SearchForHigher( const T * pToFind ) const
    {
        if( !Count() )
            return 0;

        int iLeft,
            iRight,
            idx;
	    
        idx = 0;
        iLeft = 0;
        iRight = Count() - 1;
        while( iRight > iLeft )
        {
            idx = (iLeft + iRight)/2;        
            if( *pToFind < *(*this)[idx] )
                  iRight = idx-1;
            else  iLeft = idx+1;
        }
        return( *pToFind < *(*this)[iLeft] ? iLeft : iLeft+1 );
    }



//===============================================================================================

#endif // __DRG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\inc\dlgsup.h ===
#ifndef _DLGSUP_H
#define _DLGSUP_H

#include <strconv.h>
#include <commctrl.h>





BOOL EXPORT WINAPI StringToDouble(LPSTR lpszText, double FAR *qDoubleOut);
LPSTR EXPORT WINAPI DoubleToString(double dVal, LPSTR lpstrOut, int iLeadingDigits, int iPrecision);
BOOL EXPORT WINAPI IsValidDouble(LPTSTR lpszText);
BOOL EXPORT WINAPI IsValidLong(LPTSTR lpszText);
BOOL EXPORT WINAPI IsValidULong(LPTSTR lpszText);
EXPORT BOOL	SelectColor(CHOOSECOLOR* c);

// Review(RISC, a-rogerw): We need to merge these two ASAP

#ifdef _M_IX86
typedef struct _MYDLGDATA
{
    SHORT    cbExtra;
    DWORD	 pMyThis;
} MYDLGDATA, UNALIGNED *PMYDLGDATA;

#else // !_M_IX86

typedef struct _MYDLGDATA
{
    SHORT    cbExtra;
    DWORD	 pMyThis;
} MYDLGDATA;

typedef MYDLGDATA UNALIGNED *PMYDLGDATA;

#endif // _M_IX86

//@class	Displays a Wait Cursor in constructor, saving the current cursor \
		//  Restores saved cursor in destructor. Idea stolen from MFC
class CWaitCursor
{
	//	Note:		Because of how their constructors and destructors work,
	//				CWaitCursor objects are always declared as local variables
	//				they?re never declared as global variables, nor are they allocated
	//				with new.
	//
//@access Public Members
public:
	//@cmember,mfunc Constructor
	EXPORT WINAPI CWaitCursor(void);
	//@cmember,mfunc Destructor
	EXPORT WINAPI ~CWaitCursor(void);
	//@cmember,mfunc restores the previous cursor
	void EXPORT WINAPI Restore(void);

private:
	HCURSOR m_hSavedCursor;

};

//@class This is a generic (very limited) String class, use CString instead
class CStr
{
	public:
	//@cmember,mfunc Trims string on left
		EXPORT static void LTrim(LPTSTR String);
	//@cmember,mfunc Trims string on right
		EXPORT static void RTrim(LPTSTR String);
	//@cmember,mfunc Trims string on right, replacing bang ! with NULLS
		EXPORT static void RTrimBang(LPTSTR String);
	//@cmember,mfunc Trims string on left and right
		EXPORT static void AllTrim(LPTSTR String);
};


//***********************************************************************
//* This is a generic subclass class
//***********************************************************************
class CSubClassWnd
{
protected:
	WNDPROC	m_lpfnOldCltProc;
	BOOL m_fSubClassed;
	HWND m_hWnd;

public:
	static LONG EXPORT WINAPI LDefSubClassProc(HWND hWnd, UINT uMessage, WPARAM wParam, LPARAM lParam);
	virtual EXPORT LONG CALLBACK LSubClassProc( HWND hWnd, UINT uMessage, WPARAM wParam, LPARAM lParam);
	EXPORT WINAPI CSubClassWnd(void);
	virtual EXPORT WINAPI ~CSubClassWnd();
    EXPORT STDMETHOD_(void, SubClass)		(HWND hWnd);
    EXPORT STDMETHOD_(void, UnSubClass)	(void);
};




//***********************************************************************
//* This is the base class for controls
//***********************************************************************
class	CDlgCtrl
{

public:
	long	m_id;
	HWND	m_hdlg;		// The dialog this control belongs to.
	BOOL	m_fDirty;


public:
	EXPORT WINAPI CDlgCtrl();
	virtual ~CDlgCtrl(){};
	virtual EXPORT long	IdGet();
	virtual EXPORT void	SetId(long	id);
	virtual EXPORT void	SetHdlg(HWND	hdlg);
	virtual EXPORT HWND	HGetDlg()  const;
	virtual EXPORT HWND	HGetCtrl() const;
	virtual EXPORT void	Dirty(BOOL	fDirty);
	virtual EXPORT BOOL	FIsDirty();
	virtual EXPORT BOOL Initialize(long lID, HWND hWnd);
	virtual EXPORT void	InvalidateRect(const RECT* rect, BOOL fErase);
	virtual EXPORT void	InvalidateRect();
	virtual EXPORT void	UpdateWindow(void);
	virtual EXPORT void	SetFocusItem(void);
	virtual EXPORT void	Enable();
	virtual EXPORT void	Enable(BOOL	fEnable);
	virtual EXPORT BOOL	FIsEnabled();
	virtual EXPORT LRESULT	LResultSendMessage(UINT	uMsg, WPARAM	wparam, LPARAM	lparam);
	virtual EXPORT BOOL Show(int nShow);
	virtual EXPORT BOOL Show(void);
	virtual EXPORT BOOL Hide(void);
	virtual EXPORT BOOL	FIsVisible(void);
	virtual EXPORT BOOL Disable(void);
	virtual EXPORT BOOL	FSetText(LPCSTR	lpcstr);
	virtual EXPORT long	CchGetText(LPSTR	lpstr, long cch);
	virtual EXPORT BOOL	FGetClientRect(RECT* pRect);
	virtual EXPORT BOOL	FMoveWindow(int X,int Y,int nWidth,int nHeight,BOOL bRepaint);
};

class	CDlgIcon : virtual public CDlgCtrl
{
	public:
		virtual EXPORT void LoadFromResource(HINSTANCE hInst, LPCTSTR lpszName, int x = 32, int y = 32);
		virtual EXPORT BOOL LoadFromFile(HINSTANCE hInst, LPSTR lpszName, UINT uIconIndex);
		EXPORT STDMETHOD_(void, LoadFromFile)(LPSTR szName, HINSTANCE hInst = NULL, ULONG uDefault = NULL);
};


class	CDlgCursor : public CDlgIcon
{
	public:
		EXPORT WINAPI CDlgCursor() {};
		virtual ~CDlgCursor(){};
		EXPORT STDMETHOD_(void, LoadFromFile)(LPSTR szName, HINSTANCE hInst = NULL, ULONG uDefault = NULL);
};





//***********************************************************************
//* This is the class for text controls
//***********************************************************************
class	CDlgCtrlT : virtual public CDlgCtrl
{
	public:
		EXPORT WINAPI CDlgCtrlT() {};
		virtual ~CDlgCtrlT(){};
		virtual EXPORT void	SetLimitText(long	cbMax);
		virtual EXPORT void	Select(int	iStart, int	iEnd);
};


//***********************************************************************
//* This is the class for "intger" text controls
//***********************************************************************
class	CDlgCtrlIntT : virtual public CDlgCtrl
{
	public:
		EXPORT WINAPI CDlgCtrlIntT() {};
		virtual ~CDlgCtrlIntT(){};
		virtual EXPORT long	LValGet(BOOL	*pfParsed);
		virtual EXPORT BOOL	FSetLVal(long	lVal);
		virtual EXPORT long	ULValGet(BOOL	*pfParsed);
		virtual EXPORT BOOL	FSetULVal(long	lVal);
		virtual EXPORT void	Select(int	iStart, int	iEnd);
		virtual EXPORT void	SetLimitText(long	cbMax);
};


class	CDlgCtrlNumT : virtual public CDlgCtrlIntT, virtual public CStrConv
{
	public:
		virtual EXPORT long	LValGet(BOOL *pfParsed);

	private:
		char* lpszStopString;
};


//***********************************************************************
//* This is the class for slider controls
//***********************************************************************
class	CDlgCtrlSlider : virtual public CDlgCtrl
{
	public:
		EXPORT WINAPI CDlgCtrlSlider() {};
		virtual ~CDlgCtrlSlider(){};
		virtual EXPORT BOOL	FSetRange(BOOL	fRedraw, long	lMin, long	lMax);
		virtual EXPORT BOOL	FSetPos(long	lPos);
		virtual EXPORT long	LPosGet();
		virtual EXPORT void	SetTicFq(long	lFq, long	lPosStart);
};


//***********************************************************************
//* This is the class for button controls
//***********************************************************************
class	CDlgCtrlButn : virtual public CDlgCtrl
{
	public:
		EXPORT WINAPI CDlgCtrlButn() {};
		virtual ~CDlgCtrlButn(){};
};



//***********************************************************************
//* This is the class for button controls with a bitmap
//***********************************************************************
class  CDlgCtrlBitmapButn  : public virtual CDlgCtrlButn
{
	private:
		HBITMAP			m_hBitmap;		// Bitmap for button

	public:
		EXPORT WINAPI CDlgCtrlBitmapButn();
		virtual ~CDlgCtrlBitmapButn();
		virtual EXPORT void	Initialize(long lID, HWND hWnd, HINSTANCE hInst, long lBitmapID);
		virtual EXPORT LRESULT SetBitmap(HINSTANCE hInst, long lBitmapID);
		virtual EXPORT long SetImage(HBITMAP hBitmap);
		virtual EXPORT HBITMAP GetImage(void);
};




//***********************************************************************
//* This is the class for check box controls
//***********************************************************************
class	CDlgCtrlCheck : public CDlgCtrlButn
{
	public:
		EXPORT WINAPI CDlgCtrlCheck() {};
		virtual ~CDlgCtrlCheck(){};
		virtual EXPORT UINT	UintChecked(void);
		virtual EXPORT BOOL	FCheck(UINT	uCheck);
};

//***********************************************************************
//* This is the class for check box controls
//*
//* Warning, this is not the best of classes to use as it requires that
//* lFirstID > lLastId and that there be no other controls in between
//* the id's. If there are other controls in between these id #'s you
//* can have very wierd behaviour.
//***********************************************************************
class	CDlgCtrlRadio : public CDlgCtrlCheck
{
	private:
		LONG 	m_idFirst;
		LONG 	m_idLast;
		long	IdGetFirst;
		long	IdGetLast;


	public:
		EXPORT WINAPI CDlgCtrlRadio() {};
		virtual ~CDlgCtrlRadio(){};
		virtual EXPORT void SetId(long	id, long lFirstId, long lLastId);
		virtual EXPORT BOOL	FCheck(void);
};


//***********************************************************************
//* This is the class for list box controls
//***********************************************************************
class	CDlgCtrlListBox : virtual public CDlgCtrl
{
	public:
		EXPORT WINAPI CDlgCtrlListBox() {};
		virtual ~CDlgCtrlListBox(){};
		virtual EXPORT LRESULT	LResultSendMessage(UINT	uMsg, WPARAM	wparam, LPARAM	lparam);
		virtual EXPORT LONG SetItemData(UINT uIndex, DWORD dwData);
		virtual EXPORT LONG LGetItemData(UINT uIndex);
		virtual EXPORT LONG LAddString(LPSTR lpString);
		virtual EXPORT LONG LAddString(LPSTR lpString, DWORD dwData);
		virtual EXPORT void ResetContent(void);
		virtual EXPORT LONG LGetSel(UINT uIndex);
		virtual EXPORT LONG LSetSel(UINT uIndex, BOOL fSelected);
		virtual EXPORT LONG LSetCurSel(UINT uIndex);
		virtual EXPORT LONG LGetCurSel(void);
		virtual EXPORT LONG LInsertString(UINT uIndex, LPSTR lpString);
		virtual EXPORT LONG LInsertString(UINT uIndex, LPSTR lpString, DWORD dwData);
		virtual EXPORT LONG LDeleteString(UINT uIndex);
		virtual EXPORT LONG LGetText(UINT uIndex, LPSTR lpString);
		virtual EXPORT LONG LGetTextLen(UINT uIndex);
		virtual EXPORT LONG LGetCount(void);
		virtual EXPORT LONG LGetSelCount(void);
		virtual EXPORT LONG LGetSelItems(int* aItems, int cItems);

		/* Other possible, but not currently supported, list box messages
		LB_SELITEMRANGEEX
		LB_SELECTSTRING
		LB_DIR
		LB_GETTOPINDEX
		LB_FINDSTRING
		LB_SETTABSTOPS
		LB_GETHORIZONTALEXTENT
		LB_SETHORIZONTALEXTENT
		LB_SETCOLUMNWIDTH
		LB_ADDFILE
		LB_SETTOPINDEX
		LB_GETITEMRECT
		LB_SELITEMRANGE
		LB_SETANCHORINDEX
		LB_GETANCHORINDEX
		LB_SETCARETINDEX
		LB_GETCARETINDEX
		LB_SETITEMHEIGHT
		LB_GETITEMHEIGHT
		LB_FINDSTRINGEXACT
		LB_SETLOCALE
		LB_GETLOCALE
		LB_SETCOUNT
		LB_INITSTORAGE
		LB_ITEMFROMPOINT
		LB_MSGMAX

		*/
};


class	CDlgCtrlComboBox : virtual public CDlgCtrl
{
	public:
		EXPORT WINAPI CDlgCtrlComboBox() {};
		virtual ~CDlgCtrlComboBox(){};
		virtual EXPORT LONG LResultSendMessage(UINT	uMsg, WPARAM	wparam, LPARAM	lparam);
		virtual EXPORT LONG LAddString(LPSTR lpString);
		virtual EXPORT LONG LAddString(LPSTR lpString, DWORD dwData);
		virtual EXPORT void ResetContent(void);
		virtual EXPORT LONG LSetCurSel(UINT uIndex);
		virtual EXPORT LONG LGetCurSel(void);
		virtual EXPORT LONG LInsertString(UINT uIndex, LPSTR lpString);
		virtual EXPORT LONG LDeleteString(UINT uIndex);
		virtual EXPORT LONG LGetCount(void);
		virtual EXPORT DWORD DWLGetItemData(UINT uIndex);
		virtual EXPORT LONG SetItemData(UINT uIndex, DWORD dwData);
		virtual EXPORT LONG FindItemData(const DWORD dwData) ;
		virtual EXPORT LONG LGetLbTextLen(UINT uIndex);
		virtual EXPORT LONG LGetLbText(UINT uIndex, LPSTR lpStr, LONG lStrLen);
		virtual EXPORT LONG LFindString(UINT uIndex, LPSTR lpStr);
		virtual EXPORT LONG LSelectString(UINT uIndex, LPSTR lpStr);


		/* Other possible, but not supported combo box messages
		CB_GETEDITSEL
		CB_LIMITTEXT
		CB_SETEDITSEL
		CB_DIR
		CB_SHOWDROPDOWN
		CB_SETITEMHEIGHT
		CB_GETITEMHEIGHT
		CB_GETDROPPEDCONTROLRECT
		CB_SETEXTENDEDUI
		CB_GETEXTENDEDUI
		CB_GETDROPPEDSTATE
		CB_FINDSTRINGEXACT
		CB_SETLOCALE
		CB_GETLOCALE
		CB_GETTOPINDEX
		CB_SETTOPINDEX
		CB_GETHORIZONTALEXTENT
		CB_SETHORIZONTALEXTENT
		CB_GETDROPPEDWIDTH
		CB_SETDROPPEDWIDTH
		CB_INITSTORAGE
		CB_MSGMAX

		*/
};



class	CDlgCtrlSpin : virtual public CDlgCtrl
{
	public:
		EXPORT WINAPI CDlgCtrlSpin() {};
		virtual ~CDlgCtrlSpin(){};
		virtual EXPORT BOOL FSetRange(SHORT sMin, SHORT sMax);
		virtual EXPORT void GetRange(SHORT &sMin, SHORT &sMax);
		virtual EXPORT BOOL FSetRangeVisual(SHORT sMin, SHORT sMax);
		virtual EXPORT void LSetPosition(SHORT sPosition);
		virtual EXPORT LONG LGetPosition(void);
		virtual EXPORT LONG LSetBuddy(HWND hWnd);
		virtual EXPORT HWND HGetBuddy(HWND hWnd);
		virtual EXPORT HWND HGetBuddy();
		virtual EXPORT LONG LSetAccel(WORD cAccels, LPUDACCEL paAccels);
		virtual EXPORT LONG LGetAccel(WORD cAccels, LPUDACCEL paAccels);
		virtual EXPORT LONG LSetBase(WORD wBase);
		virtual EXPORT LONG LGetBase(void);
};



//***********************************************************************
//* This is the class for tab controls
//***********************************************************************
class	CDlgCtrlTab : public CDlgCtrl
{
	public:
		EXPORT WINAPI CDlgCtrlTab() {};
		virtual ~CDlgCtrlTab(){};
		EXPORT STDMETHOD_(BOOL, FIsWindow)(void) { return ::IsWindow(HGetCtrl()); } ;
		EXPORT STDMETHOD_(BOOL, FDeleteAllItems)(void);
        EXPORT STDMETHOD_(BOOL, FInsertItem)( int nIndex, LPTSTR szTabText);
        EXPORT STDMETHOD_(BOOL, FInsertItem)( int nIndex, TC_ITEM FAR *ptc_item);
        EXPORT STDMETHOD_(BOOL, FSetCurSel)	( int nIndex);
        EXPORT STDMETHOD_(BOOL, FSetItem)	( int nIndex, TC_ITEM FAR *ptc_item);
        EXPORT STDMETHOD_(int,  NGetCurSel)	( void );
};


class CSubClassCtrl : virtual public CDlgCtrl
{
	public:
		EXPORT WINAPI CSubClassCtrl();
		virtual EXPORT WINAPI ~CSubClassCtrl();
		virtual EXPORT void Subclass(void);
		virtual EXPORT void	WINAPI UnSubclass(void);
		virtual EXPORT BOOL  IsSubclassed( void ) const;
		virtual EXPORT BOOL Initialize(long lID, HWND hWnd);
		// Subclasses override this
		virtual EXPORT LONG CALLBACK	FCtrlProc(HWND hWnd, UINT uMessage, WPARAM wParam, LPARAM lParam);

	private:
		static	EXPORT LONG	CALLBACK FNewProc( HWND hWnd, UINT uMessage, WPARAM wParam, LPARAM lParam);

	protected:
		WNDPROC		m_lpfnOldCltProc;	// Used to store dialog proc

	private:
		BOOL m_fSubClassed;
};


class CColorCtrl : public virtual CSubClassCtrl
{
	public:
		EXPORT WINAPI CColorCtrl();
		virtual ~CColorCtrl(){};
		virtual EXPORT void		SetColor(COLORREF crColor);
		virtual EXPORT COLORREF	GetColor(void);
		virtual EXPORT void		Refresh(void);
		virtual EXPORT BOOL		SelColor(void);
		virtual EXPORT LONG CALLBACK	FCtrlProc(HWND hWnd, UINT uMessage, WPARAM wParam, LPARAM lParam);

	private:
		COLORREF		m_crColor;
};



//---------------------------------------------
// Filename control support
//---------------------------------------------
class	CDlgFilename : virtual public CDlgCtrlT
{
	public:
		EXPORT WINAPI CDlgFilename(){};
		virtual ~CDlgFilename(){};
		virtual EXPORT LPTSTR Get(void);
		virtual EXPORT void Set(LPCTSTR szFilename);
		virtual EXPORT BOOL SelectFile(LPCTSTR szCaption, LPCTSTR szMask);
		virtual EXPORT HRESULT hrValidate();
		virtual EXPORT BOOL FBrowse(LPTSTR	lpstrFileName, LPCTSTR szCaption, LPCTSTR	lpstrFilter, OPENFILENAME*	pofn = NULL);

	private:
		TCHAR	m_szFilename[_MAX_PATH];
};


//---------------------------------------------
// SaveAs Filename control support
//---------------------------------------------
class	CDlgSaveFilename : virtual public CDlgCtrlT
{
	public:
		EXPORT WINAPI CDlgSaveFilename(){};
		virtual ~CDlgSaveFilename(){};
		virtual EXPORT LPTSTR CDlgSaveFilename::Get(void);
		virtual EXPORT void CDlgSaveFilename::Set(LPCTSTR szFilename);
		virtual EXPORT BOOL CDlgSaveFilename::SelectFile(LPCTSTR szCaption, LPCTSTR szMask);
		virtual EXPORT HRESULT CDlgSaveFilename::hrValidate();
		virtual EXPORT BOOL CDlgSaveFilename::FBrowse(LPTSTR	lpstrFileName, LPCTSTR szCaption, LPCTSTR	lpstrFilter, OPENFILENAME*	pofn = NULL);

	private:
		TCHAR	m_szFilename[_MAX_PATH];

};

/*********************************************************\
*
*	Spin control which allows floating (double) point values
*
*	This control is made up of two other controls, a subclassed
*   edit control and standard spin control. The spin control is
*   buddied with the edit control.
*   To use this you initialize the CDlgCtrlDoubleSpin control
*   and set it's display format using SetDisplayFormat. You need
*   to make sure you call SetPosition when you receive a
*   EN_CHANGE message from the edit control
*
\*********************************************************/
//
// This is the edit control, you don't need to make an instance of this!
//
class CDlgCtrlDouble : public CSubClassCtrl
{
	public:
		EXPORT WINAPI CDlgCtrlDouble();
		virtual ~CDlgCtrlDouble() {};
		virtual	EXPORT LONG CALLBACK FCtrlProc(HWND hWnd, UINT uMessage, WPARAM wParam, LPARAM lParam);
		virtual EXPORT double DGetValue(void);

	private:
		BOOL m_InValidation;
};


//
// This is the combined edit/spin control
//
class	CDlgCtrlDoubleSpin : virtual public CDlgCtrl
{
	public:
		EXPORT WINAPI CDlgCtrlDoubleSpin::CDlgCtrlDoubleSpin();
		virtual CDlgCtrlDoubleSpin::~CDlgCtrlDoubleSpin(){};

		virtual EXPORT void Initialize(LONG lIDEdit, LONG lIDSpin, HWND hWndParent);
		virtual EXPORT void SetDisplayFormat(int iLeadingDigits, int iPrecision);
		virtual EXPORT BOOL FSetRange(double dMin, double tMax);
		virtual EXPORT void GetRange(double &dMin, double &tMax);
		virtual EXPORT BOOL FSetDelta(double dDelta);
		virtual EXPORT void SetPosition(double tPosition);
		virtual EXPORT double DGetPosition(void);
		virtual EXPORT double DGetValue(void);
		virtual EXPORT LONG LSetBuddy(void);
		virtual EXPORT HWND HGetBuddy(void);
		virtual EXPORT LONG LSetAccel(WORD cAccels, LPUDACCEL paAccels);
		virtual EXPORT LONG LGetAccel(WORD cAccels, LPUDACCEL paAccels);
		virtual EXPORT BOOL FIncrement(double Amount);
		virtual EXPORT BOOL FIncrement(void);
		virtual EXPORT BOOL FDecrement(double Amount);
		virtual EXPORT BOOL FDecrement(void);
		virtual EXPORT void Select(int	iStart, int	iEnd);
		virtual EXPORT void SetFocusItem(void);
		virtual EXPORT void Enable(BOOL	fEnable);


	public:
		LONG	m_idEdit;	// ID of edit control
		LONG	m_idSpin;	// ID of spin control
		HWND	m_hdlg;		// The dialog this control belongs to.

	protected:
		CDlgCtrlDouble	m_EditCtrl;
		CDlgCtrlSpin	m_Spin;
		double	m_dCurrentValue;
		double	m_dMinRange;
		double	m_dMaxRange;
		double	m_dDeltaPos;
		int     m_iFormatLeadingDigits;
		int     m_iFormatPrecision;
		BOOL	m_fRangeSet;


};



/*********************************************************\
*
*	Edit control which allows validated entry of Signed Longs
*
\*********************************************************/
class CDlgCtrlLong : virtual public CSubClassCtrl
{
public:
	EXPORT WINAPI CDlgCtrlLong();
	virtual EXPORT WINAPI ~CDlgCtrlLong();
	virtual EXPORT LONG CALLBACK FCtrlProc(HWND hWnd, UINT uMessage, WPARAM wParam, LPARAM lParam);
	EXPORT STDMETHOD_(void, Select)(int	iStart, int	iEnd);
	EXPORT STDMETHOD_(LONG, LValGet)(BOOL	*pfParsed);
	EXPORT STDMETHOD_(BOOL,	FSetLVal)(long	lVal);

private:
	BOOL m_InValidation;
};



/*********************************************************\
*
*	Edit control which allows validated entry of Unsigned Longs
*
\*********************************************************/
class CDlgCtrlULong : virtual public CSubClassCtrl
{
public:
	EXPORT WINAPI CDlgCtrlULong();
	virtual EXPORT WINAPI ~CDlgCtrlULong();
	virtual EXPORT LONG CALLBACK FCtrlProc(HWND hWnd, UINT uMessage, WPARAM wParam, LPARAM lParam);
	EXPORT STDMETHOD_(void, Select)(int	iStart, int	iEnd);
	EXPORT STDMETHOD_(ULONG, ULValGet)(BOOL	*pfParsed);
	EXPORT STDMETHOD_(BOOL,	FSetULVal)(ULONG lVal);

private:
	BOOL m_InValidation;
};





//////////////////////////////////////////////////////////////////
// This allows us to have seperate wndproc functions
// in each class (LWndProc)

class CBaseWindow
{
	public:
		EXPORT WINAPI CBaseWindow();
		virtual EXPORT ~CBaseWindow();
		EXPORT STDMETHOD_(LONG, LWndProc)( HWND hWnd, UINT uMessage, WPARAM wParam, LPARAM lParam) PURE;
		EXPORT STDMETHOD_(HWND, HGetWnd)(void);
		EXPORT STDMETHOD_(void, SetWnd)(HWND hWnd) {m_hWnd = hWnd;};
		EXPORT STDMETHOD_(LRESULT,	LResultSendMessage)(UINT	uMsg, WPARAM	wparam, LPARAM	lparam);
		EXPORT STDMETHOD_(LRESULT,	LResultPostMessage)(UINT	uMsg, WPARAM	wparam, LPARAM	lparam);
		EXPORT STDMETHOD_(HWND, HCreateWindow)(HWND hParentWindow) PURE;
		EXPORT STDMETHOD_(BOOL, FShowWindow)(int nCmdShow);
		EXPORT STDMETHOD_(HWND, HGetParent)(HWND){return m_hWndParent;};
		EXPORT STDMETHOD_(void, SetParent)(HWND hParent){m_hWndParent = hParent;};
		EXPORT STDMETHOD_(void, GetWindowRect)(RECT* pRect);
		EXPORT STDMETHOD_(BOOL, FIsWindow)(){return ::IsWindow(m_hWnd);};
		EXPORT STDMETHOD_(BOOL, FDestroyWindow)(void);
		EXPORT STDMETHOD_(BOOL, FMoveWindow)(int X,int Y,int nWidth,int nHeight,BOOL bRepaint) ;
		EXPORT STDMETHOD_(BOOL, FInvalidateRect)(CONST RECT *lpRect,BOOL bErase);
		EXPORT STDMETHOD_(HWND, HSetFocus)(void);
		EXPORT STDMETHOD_(BOOL, FGetClientRect)(RECT* pRect);
		EXPORT STDMETHOD_(void, UnRegisterClass)(LPTSTR szClassName, HINSTANCE hInstance);

	private:
		HWND m_hWnd;
		HWND m_hWndParent;
};


#ifdef NOT_YET	// See me if you think you need this (a-rogerw)
class CBaseMdiWindow : virtual public CBaseWindow
{
	public:
		WINAPI CBaseMdiWindow(){};
		virtual WINAPI ~CBaseMdiWindow(){};

		EXPORT STDMETHOD_(LONG, LWndProc)( HWND hWnd, UINT uMessage, WPARAM wParam, LPARAM lParam) PURE;
		EXPORT STDMETHOD_(HWND, HCreateWindow)(HWND hParentWindow) PURE;
		EXPORT static	LONG	CALLBACK  LBaseWndProc( HWND hWnd, UINT uMessage, WPARAM wParam, LPARAM lParam);
};
#endif // NOT_YET

class CBaseSdiWindow : virtual public CBaseWindow
{
	public:
		WINAPI CBaseSdiWindow(){};
		virtual WINAPI ~CBaseSdiWindow(){};

		EXPORT STDMETHOD_(LONG, LWndProc)( HWND hWnd, UINT uMessage, WPARAM wParam, LPARAM lParam) PURE;
		EXPORT STDMETHOD_(HWND, HCreateWindow)(HWND hParentWindow) PURE;
		EXPORT static	LONG	CALLBACK  LBaseWndProc( HWND hWnd, UINT uMessage, WPARAM wParam, LPARAM lParam);
};

class CBaseDialog
{
	public:
		EXPORT WINAPI CBaseDialog();
		virtual EXPORT ~CBaseDialog(){};
		EXPORT static	LONG	CALLBACK  LBaseDlgProc( HWND hWnd, UINT uMessage, WPARAM wParam, LPARAM lParam);
		EXPORT STDMETHOD_(LONG, LDlgProc)( HWND hWnd, UINT uMessage, WPARAM wParam, LPARAM lParam);
		EXPORT STDMETHOD_(HWND, HGetParent)(HWND){return m_hWndParent;};
		EXPORT STDMETHOD_(void, SetParent)(HWND hParent){m_hWndParent = hParent;};
		EXPORT STDMETHOD_(HWND, GetWnd)(void){return m_hDlg;};

	protected:
		HWND m_hDlg;
		HWND m_hWndParent;
};


#ifdef NOT_YET // (a-rogerw)
class CDialog : virtual public CBaseDialog
{
public:
	EXPORT WINAPI CDialog();
	EXPORT WINAPI CDialog(HINSTANCE hInst, UINT uiTemplateID, HWND hWndParent = NULL);
	EXPORT WINAPI CDialog(HINSTANCE hInst, LPCSTR lpszDlgTemp, HWND hWndParent = NULL);
	virtual EXPORT ~CDialog();


	// Modeless
public:
	EXPORT STDMETHOD_(BOOL, Create)(void);
	EXPORT STDMETHOD_(BOOL, Create)(HINSTANCE hInst, UINT uiTemplateID, HWND hWndParent = NULL);
	EXPORT STDMETHOD_(BOOL, Create)(HINSTANCE hInst, LPCSTR lpszDlgTemp, HWND hWndParent = NULL);


	// Modal
public:

	EXPORT STDMETHOD_(int, DoModal)(void);
	EXPORT STDMETHOD_(int, DoModal)(HINSTANCE hInst, UINT uiTemplateID, HWND hWndParent);
	EXPORT STDMETHOD_(int, DoModal)(HINSTANCE hInst, LPCSTR lpszTemplateName, HWND hWndParent);

protected:
	// Operations
	EXPORT STDMETHOD_(BOOL, OnInitDialog)(){ return TRUE; };
	EXPORT STDMETHOD_(void, OnOK)(){ EndDialog(1);};
	EXPORT STDMETHOD_(void, OnCancel)(){ EndDialog(0);};

	// support for passing on tab control - use 'PostMessage' if needed
	inline void NextDlgCtrl() const
	{ if(::IsWindow(m_hDlg)) { ::SendMessage(m_hDlg, WM_NEXTDLGCTL, 0, 0);}; };
	inline void PrevDlgCtrl() const
	{ if(::IsWindow(m_hDlg)) { ::SendMessage(m_hDlg, WM_NEXTDLGCTL, 1, 0); }; };
	inline void GotoDlgCtrl(HWND hWndCtrl)
	{ if(::IsWindow(m_hDlg)) { ::SendMessage(m_hDlg, WM_NEXTDLGCTL, (WPARAM)hWndCtrl, 1L); }; };

	// default button access
	inline void SetDefID(UINT nID)
	{ if(::IsWindow(m_hDlg)) { ::SendMessage(m_hDlg, DM_SETDEFID, nID, 0); }; };
	inline DWORD GetDefID() const
	{ if(::IsWindow(m_hDlg)) { return ::SendMessage(m_hDlg, DM_GETDEFID, 0, 0); } else return 0; };

	// termination
	EXPORT STDMETHOD_(void, EndDialog)(int nResult);


	// Attributes
	LPCSTR m_lpszTemplateName;
	HINSTANCE m_hInst;
};
#endif // NOT_YET (a-rogerw)


//@class List View dialog control.
class	CDlgCtrlListView : virtual public CDlgCtrl
{
	public:
	//@cmember,mfunc Constructor, initializes string to empty.
		EXPORT WINAPI CDlgCtrlListView();

	//@cmember,mfunc Destructor
	virtual EXPORT WINAPI ~CDlgCtrlListView();

	//@cmember,mfunc Set background color
	EXPORT STDMETHOD_(COLORREF, CRGetBkColor)(void);

	//@cmember,mfunc Set background color
	EXPORT STDMETHOD_(BOOL, FSetBkColor)(COLORREF clrBk);

	//@cmember,mfunc Get image list
	EXPORT STDMETHOD_(HIMAGELIST, HGetImageList)(int iImageList);

	//@cmember,mfunc Set image list
	EXPORT STDMETHOD_(HIMAGELIST, HSetImageList)(HIMAGELIST himl, int iImageList);

	//@cmember,mfunc Get item count
	EXPORT STDMETHOD_(int,  NGetItemCount)(void);

	//@cmember,mfunc Get item
	EXPORT STDMETHOD_(BOOL, FGetItem)(LV_ITEM FAR* pitem);

	//@cmember,mfunc Set item
	EXPORT STDMETHOD_(BOOL, FSetItem)(LV_ITEM FAR* pitem);

	//@cmember,mfunc Insert item
	EXPORT STDMETHOD_(int,  NInsertItem)(LV_ITEM FAR* pitem);

	//@cmember,mfunc Delete item
	EXPORT STDMETHOD_(BOOL, DeleteItem)(int i);

	//@cmember,mfunc Delete all items
	EXPORT STDMETHOD_(BOOL, FDeleteAllItems)(void);

	//@cmember,mfunc Get callback mask
	EXPORT STDMETHOD_(BOOL, FGetCallbackMask)(void);

	//@cmember,mfunc Set callback mask
	EXPORT STDMETHOD_(BOOL, FSetCallbackMask)(UINT uimask);

	//@cmember,mfunc Get next item
	EXPORT STDMETHOD_(int,  NGetNextItem)(int i, UINT flags);

	//@cmember,mfunc FindItem
	EXPORT STDMETHOD_(int,  NFindItem)(int iStart,  const LV_FINDINFO FAR* plvfi);

	//@cmember,mfunc Get item rect
	EXPORT STDMETHOD_(BOOL, FGetItemRect)(int i, RECT FAR* prc, int code);

	//@cmember,mfunc Set item position
	EXPORT STDMETHOD_(BOOL, FSetItemPosition)(int i, int x, int y);

	//@cmember,mfunc Get item position
	EXPORT STDMETHOD_(BOOL, FGetItemPosition)(int i, POINT FAR* ppt);

	//@cmember,mfunc Get  string width
	EXPORT STDMETHOD_(int,  NGetStringWidth)(LPCSTR psz);

	//@cmember,mfunc Hit Test
	EXPORT STDMETHOD_(int,  NHitTest)(LV_HITTESTINFO FAR *pinfo);

	//@cmember,mfunc Ensure visible
	EXPORT STDMETHOD_(BOOL, FEnsureVisible)(int i, BOOL fPartialOK);

	//@cmember,mfunc Scroll
	EXPORT STDMETHOD_(BOOL, FScroll)(int dx, int dy);

	//@cmember,mfunc Redraw items
	EXPORT STDMETHOD_(BOOL, FRedrawItems)(int iFirst, int iLast);

	//@cmember,mfunc Arrange
	EXPORT STDMETHOD_(BOOL, FArrange)(UINT code);

	//@cmember,mfunc Edit label
	EXPORT STDMETHOD_(HWND, HEditLabel)(int i);

	//@cmember,mfunc Get edit control
	EXPORT STDMETHOD_(HWND, HGetEditControl)(void);

	//@cmember,mfunc Get column
	EXPORT STDMETHOD_(BOOL, FGetColumn)(int iCol, LV_COLUMN FAR* pcol);

	//@cmember,mfunc Set column
	EXPORT STDMETHOD_(BOOL, FSetColumn)(int iCol, LV_COLUMN FAR* pcol);

	//@cmember,mfunc Insert column
	EXPORT STDMETHOD_(int,  NInsertColumn)(int iCol, const LV_COLUMN FAR* pcol);

	//@cmember,mfunc Delete column
	EXPORT STDMETHOD_(BOOL, FDeleteColumn)(int iCol);

	//@cmember,mfunc Get column width
	EXPORT STDMETHOD_(int,  NGetColumnWidth)(int iCol);

	//@cmember,mfunc Set column width
	EXPORT STDMETHOD_(BOOL, FSetColumnWidth)(int iCol, int cx);

	//@cmember,mfunc Create drag image
	EXPORT STDMETHOD_(HIMAGELIST, HCreateDragImage)(int i,  LPPOINT lpptUpLeft);

	//@cmember,mfunc Get view rect
	EXPORT STDMETHOD_(BOOL, FGetViewRect)(RECT FAR* prc);

	//@cmember,mfunc Get text color
	EXPORT STDMETHOD_(COLORREF, CRGetTextColor)(void);

	//@cmember,mfunc Set text color
	EXPORT STDMETHOD_(BOOL, FSetTextColor)(COLORREF clrText);

	//@cmember,mfunc Get text background color
	EXPORT STDMETHOD_(COLORREF, CRGetTextBkColor)(void);

	//@cmember,mfunc Set text background color
	EXPORT STDMETHOD_(BOOL, FSetTextBkColor)(COLORREF clrTextBk);

	//@cmember,mfunc Get top index
	EXPORT STDMETHOD_(int,  NGetTopIndex)(void);

	//@cmember,mfunc Get count per page
	EXPORT STDMETHOD_(int,  NGetCountPerPage)(void);

	//@cmember,mfunc Get origin
	EXPORT STDMETHOD_(BOOL, FGetOrigin)(LPPOINT ppt);

	//@cmember,mfunc Update
	EXPORT STDMETHOD_(BOOL, FUpdate)(int i);

	//@cmember,mfunc Set item state
	EXPORT STDMETHOD_(void, SetItemState)(int i, UINT data, UINT mask);

	//@cmember,mfunc Get item state
	EXPORT STDMETHOD_(UINT, ULGetItemState)(int i, UINT mask);

	//@cmember,mfunc Get item text
	EXPORT STDMETHOD_(void, GetItemText)(int i, int iSubItem, LPSTR pszText, int cchTextMax);

	//@cmember,mfunc Set item text
	EXPORT STDMETHOD_(void, SetItemText)(int i, int iSubItem_, LPSTR pszText);

	//@cmember,mfunc Set item count
	EXPORT STDMETHOD_(void, SetItemCount)(int cItems);

	//@cmember,mfunc Sort items
	EXPORT STDMETHOD_(BOOL, FSortItems)(PFNLVCOMPARE pfnCompare, LPARAM lPrm);

	//@cmember,mfunc Set item position
	EXPORT STDMETHOD_(void, SetItemPosition32)(int i, int x, int y);

	//@cmember,mfunc Get selected count
	EXPORT STDMETHOD_(UINT, UGetSelectedCount)(void);

	//@cmember,mfunc Get item spacing
	EXPORT STDMETHOD_(DWORD, DWGetItemSpacing)(BOOL fSmall);

	//@cmember,mfunc Get search string
	EXPORT STDMETHOD_(BOOL, FGetISearchString)(LPSTR lpsz);

};

//@class Tree View dialog control.
class	CDlgCtrlTreeView : virtual public CDlgCtrl
{
	public:
	//@cmember,mfunc Constructor, initializes string to empty.
		EXPORT WINAPI CDlgCtrlTreeView();

	//@cmember,mfunc Destructor
	virtual EXPORT WINAPI ~CDlgCtrlTreeView();

	//@cmember,mfunc Set background color
	//EXPORT STDMETHOD_(COLORREF, CRGetBkColor)(void);

	//@cmember,mfunc Set background color
	//EXPORT STDMETHOD_(BOOL, FSetBkColor)(COLORREF clrBk);

	//@cmember,mfunc Get image list
	EXPORT STDMETHOD_(HIMAGELIST, HGetImageList)(int iImageList);

	//@cmember,mfunc Set image list
	EXPORT STDMETHOD_(HIMAGELIST, HSetImageList)(HIMAGELIST himl, int iImageList);

	//@cmember,mfunc Get item count
	EXPORT STDMETHOD_(int,  NGetItemCount)(void);

	//@cmember,mfunc Get item
	EXPORT STDMETHOD_(BOOL, FGetItem)(TV_ITEM FAR* pitem);

	//@cmember,mfunc Set item
	EXPORT STDMETHOD_(BOOL, FSetItem)(TV_ITEM FAR* pitem);

	//@cmember,mfunc Insert item
	EXPORT STDMETHOD_(HTREEITEM,  NInsertItem)(TV_INSERTSTRUCT* pitem);

	//@cmember,mfunc Expand item
	EXPORT STDMETHOD_(BOOL, NExpandItem)( HTREEITEM htriItem);

	//@cmember,mfunc Insert item
	EXPORT STDMETHOD_(HTREEITEM,  NInsertTextItemAfter)(LPSTR pszName, HTREEITEM htiParent);

	//@cmember,mfunc add leaf
	EXPORT STDMETHOD_(HTREEITEM, htiAddLeaf)(HTREEITEM htiParent, void *pObject, int iBranch, int iLeaf);

	EXPORT STDMETHOD_(VOID, AddBranch)(HTREEITEM htiParent, void *pObject, int iBranch, int iMaxBranch);

	//@cmember,mfunc Delete item
	EXPORT STDMETHOD_(BOOL, DeleteItem)(HTREEITEM i);

	//@cmember,mfunc Delete all items
	EXPORT STDMETHOD_(BOOL, FDeleteAllItems)(void);

	//@cmember,mfunc Get callback mask
	//EXPORT STDMETHOD_(BOOL, FGetCallbackMask)(void);

	//@cmember,mfunc Set callback mask
	//EXPORT STDMETHOD_(BOOL, FSetCallbackMask)(UINT uimask);

	//@cmember,mfunc Get next item
	EXPORT STDMETHOD_(HTREEITEM,  NGetNextItem)(HTREEITEM i, UINT flags);

	//@cmember,mfunc Get selected item
	EXPORT STDMETHOD_(HTREEITEM,  NGetSelection)(void);

	//@cmember,mfunc select item in the view
	EXPORT STDMETHOD_(HTREEITEM,  NSelectItem)(HTREEITEM hi);

	//@cmember,mfunc select item in the view, pass flags
	EXPORT STDMETHOD_(HTREEITEM,  NSelectItem)(HTREEITEM hi, LONG lFlags);

	//@cmember,mfunc Get parent item in the view
	EXPORT STDMETHOD_(HTREEITEM,  NGetParent)(HTREEITEM hi);

	//@cmember,mfunc Get selected child item
	EXPORT STDMETHOD_(HTREEITEM,  NGetChild)(HTREEITEM hi);

	//@cmember,mfunc FindItem	Not supported by TreeView
	//EXPORT STDMETHOD_(int,  NFindItem)(int iStart,  const LV_FINDINFO FAR* plvfi);

	//@cmember,mfunc Get item rect
	EXPORT STDMETHOD_(BOOL, FGetItemRect)(HTREEITEM i, RECT FAR* prc, int code);

	//@cmember,mfunc Set item position
	//EXPORT STDMETHOD_(BOOL, FSetItemPosition)(int i, int x, int y);

	//@cmember,mfunc Get item position
	//EXPORT STDMETHOD_(BOOL, FGetItemPosition)(int i, POINT FAR* ppt);

	//@cmember,mfunc Get  string width
	//EXPORT STDMETHOD_(int,  NGetStringWidth)(LPCSTR psz);

	//@cmember,mfunc Hit Test
	EXPORT STDMETHOD_(HTREEITEM,  NHitTest)(TV_HITTESTINFO FAR *pinfo);

	//@cmember,mfunc Ensure visible
	EXPORT STDMETHOD_(BOOL, FEnsureVisible)(HTREEITEM i);

	//@cmember,mfunc Scroll
	//EXPORT STDMETHOD_(BOOL, FScroll)(int dx, int dy);

	//@cmember,mfunc Redraw items
	//EXPORT STDMETHOD_(BOOL, FRedrawItems)(int iFirst, int iLast);

	//@cmember,mfunc Arrange
	//EXPORT STDMETHOD_(BOOL, FArrange)(UINT code);

	//@cmember,mfunc Edit label
	EXPORT STDMETHOD_(HWND, HEditLabel)(int i);

	//@cmember,mfunc Get edit control
	EXPORT STDMETHOD_(HWND, HGetEditControl)(void);

	//@cmember,mfunc Get column 	Not supported by TreeView
	//EXPORT STDMETHOD_(BOOL, FGetColumn)(int iCol, LV_COLUMN FAR* pcol);

	//@cmember,mfunc Set column		Not supported by TreeView
	//EXPORT STDMETHOD_(BOOL, FSetColumn)(int iCol, LV_COLUMN FAR* pcol);

	//@cmember,mfunc Insert column	Not supported by TreeView
	//EXPORT STDMETHOD_(int,  NInsertColumn)(int iCol, const LV_COLUMN FAR* pcol);

	//@cmember,mfunc Delete column	Not supported by TreeView
	//EXPORT STDMETHOD_(BOOL, FDeleteColumn)(int iCol);

	//@cmember,mfunc Get column width	Not supported by TreeView
	//EXPORT STDMETHOD_(int,  NGetColumnWidth)(int iCol);

	//@cmember,mfunc Set column width	Not supported by TreeView
	//EXPORT STDMETHOD_(BOOL, FSetColumnWidth)(int iCol, int cx);

	//@cmember,mfunc Create drag image
	EXPORT STDMETHOD_(HIMAGELIST, HCreateDragImage)(HTREEITEM i);

	//@cmember,mfunc Get view rect
	//EXPORT STDMETHOD_(BOOL, FGetViewRect)(RECT FAR* prc);

	//@cmember,mfunc Get text color
	//EXPORT STDMETHOD_(COLORREF, CRGetTextColor)(void);

	//@cmember,mfunc Set text color
	//EXPORT STDMETHOD_(BOOL, FSetTextColor)(COLORREF clrText);

	//@cmember,mfunc Get text background color
	//EXPORT STDMETHOD_(COLORREF, CRGetTextBkColor)(void);

	//@cmember,mfunc Set text background color
	//EXPORT STDMETHOD_(BOOL, FSetTextBkColor)(COLORREF clrTextBk);

	//@cmember,mfunc Get top index
	//EXPORT STDMETHOD_(int,  NGetTopIndex)(void);

	//@cmember,mfunc Get count per page
	//EXPORT STDMETHOD_(int,  NGetCountPerPage)(void);

	//@cmember,mfunc Get origin
	//EXPORT STDMETHOD_(BOOL, FGetOrigin)(LPPOINT ppt);

	//@cmember,mfunc Update
	//EXPORT STDMETHOD_(BOOL, FUpdate)(int i);

	//@cmember,mfunc Set item state
	//EXPORT STDMETHOD_(void, SetItemState)(int i, UINT data, UINT mask);

	//@cmember,mfunc Get item state
	//EXPORT STDMETHOD_(UINT, ULGetItemState)(int i, UINT mask);

	//@cmember,mfunc Get item text
	//EXPORT STDMETHOD_(void, GetItemText)(int i, int iSubItem, LPSTR pszText, int cchTextMax);

	//@cmember,mfunc Set item text
	//EXPORT STDMETHOD_(void, SetItemText)(int i, int iSubItem_, LPSTR pszText);

	//@cmember,mfunc Set item count
	//EXPORT STDMETHOD_(void, SetItemCount)(int cItems);

	//@cmember,mfunc Sort items
	EXPORT STDMETHOD_(BOOL, FSortItems)(LPTV_SORTCB ptvsor);

	//@cmember,mfunc Set item position
	//EXPORT STDMETHOD_(void, SetItemPosition32)(int i, int x, int y);

	//@cmember,mfunc Get selected count
	//EXPORT STDMETHOD_(UINT, UGetSelectedCount)(void);

	//@cmember,mfunc Get item spacing
	//EXPORT STDMETHOD_(DWORD, DWGetItemSpacing)(BOOL fSmall);

	//@cmember,mfunc Get search string
	//EXPORT STDMETHOD_(BOOL, FGetISearchString)(LPSTR lpsz);

};


//
// This is the combined time/spin control
//
#define FRAMES_PER_SECOND	75

// These are used as parameters for the set type call
#define DISPLAY_MSM    0
#define DISPLAY_TMSF   1
#define DISPLAY_SM     2
#define DISPLAY_HMSM   3

#define TSM_BASE		(WM_APP+0)
#define TSM_GETPOS		TSM_BASE+1
#define TSM_GETRANGE	TSM_BASE+2
#define TSM_SETPOS		TSM_BASE+3
#define TSM_SETRANGE	TSM_BASE+4
#define TSM_GETDWPOS	TSM_BASE+5
#define TSM_GETDWRANGE	TSM_BASE+6
#define TSM_SETDWPOS	TSM_BASE+7
#define TSM_SETDWRANGE	TSM_BASE+8
#define TSM_SETTYPE		TSM_BASE+9
#define TSM_GETTYPE		TSM_BASE+10
#define TSM_ENFORCERG   TSM_BASE+11
#define TSM_CHECKRG     TSM_BASE+12
#define TSM_ENABLE      TSM_BASE+13


#define MAX_FRAMES			60
#define MAX_MILLISEC		999
#define MAX_SECONDS			59
#define MAX_MINUTES			59
#define MAX_HOURS			_I32_MAX
#define MAX_TRACKS			999

typedef struct tagTIMESTRUCT
{
	DWORD dwFrame:3;		// Frame: 0=0; 1=15;2=30;3=45;4=60;
	DWORD dwMilliSec:10;	// Millisecs 0 - 999
	DWORD dwSeconds:6;		// 0 - 60  seconds
	DWORD dwMinutes:7;		// 0 - 99  minutes
	DWORD dwReserved1:6;	// Reserved
	DWORD dwTrack:10;		// 0 - 999
    DWORD dwReserved2:18;	// Reserved
    DWORD iType : 4;        // DISPLAY_TMSF, DISPLAY_MSM, etc.
	DWORD dwHours;	        // 0 - dword hours
} TIMESTRUCT, *LPTIMESTRUCT;


    // For conversions involving milliseconds
DWORD EXPORT WINAPI tsTimeToMSec(TIMESTRUCT ts);
void EXPORT WINAPI tsMSecToTime(int TypeControl, DWORD msecs, TIMESTRUCT &ts);


    // For conversions involving MCI CD-Audio, vcr TMSF DWORDs
EXPORT TIMESTRUCT tsTMSFToTime( DWORD tmsf );
EXPORT DWORD tsTimeToTMSF( TIMESTRUCT ts );

    // Returns 0 if equal, <0 if lhs<rhs, >0 if lhs>rhs
    // lhs's iType determines the type for comparison
EXPORT int CompareTimeStructs( const TIMESTRUCT & lhs,
                               const TIMESTRUCT & rhs );

    // Does the frame/millisec conversion, iType assignment,
    // and nTrack assignment if converting to TMSF.
    // It is safe if tsBefore and tsAfter are the same object.
inline void ConvertTimeStruct( const TIMESTRUCT & tsBefore,
                               TIMESTRUCT &       tsAfter,
                               int                typeAfter,
                               DWORD              nTrack=0u )
{
    tsAfter = tsBefore;
    switch( tsBefore.iType )
    {
        case DISPLAY_MSM:
            if( DISPLAY_TMSF == typeAfter )
            {
                tsAfter.dwTrack = nTrack;
                tsAfter.dwFrame = ((5 * tsBefore.dwMilliSec)+500) / 1000;
                tsAfter.dwMilliSec = 0;
            }
            break;
        case DISPLAY_TMSF:
            if( DISPLAY_MSM == typeAfter )
            {
                tsAfter.dwMilliSec = 1000 * tsBefore.dwFrame / 5;
                tsAfter.dwFrame = 0;
            }
            break;
        default:
            break;
    }
    tsAfter.iType = typeAfter;
}


class	CDlgCtrlTimeSpin : public CDlgCtrl
{
	public:
    EXPORT WINAPI CDlgCtrlTimeSpin();

	virtual EXPORT WINAPI ~CDlgCtrlTimeSpin();

	EXPORT STDMETHOD_(int, GetType)	(void);
	EXPORT STDMETHOD_(void, SetType)	(int type);
	EXPORT STDMETHOD_(BOOL, FSetRange)	(DWORD dwMin, DWORD dwMax);
	EXPORT STDMETHOD_(BOOL, FSetRange)	(TIMESTRUCT tsMin, TIMESTRUCT tsMax);
	EXPORT STDMETHOD_(BOOL, FSetPos)	(TIMESTRUCT ts);
	EXPORT STDMETHOD_(BOOL, FSetPos)	(DWORD dw);
	EXPORT STDMETHOD_(BOOL, FGetPos)	(TIMESTRUCT* ts);
	EXPORT STDMETHOD_(BOOL, FGetPos)	(DWORD* dw);

            // note: FSetRange and FSetPos do not enforce the range
            // on the position.  This, I guess, to allow you to SetPos
            // out of range then SetRange to encompass the pos.
            // Review(rogerw)
            // To ensure the position clips to the range, call EnforceRange().
            // As a quick check to see if pos is in range, FRangeCheck().
	EXPORT STDMETHOD_(BOOL, FRangeCheck)(void) const;
	EXPORT STDMETHOD_(BOOL, EnforceRange)(void);

	// Needed to disable control
	EXPORT STDMETHOD_(BOOL, Enable)(DWORD dw);


};




//
// This is the combined template edit/spin control
//
template<class TYPE, class EDIT_TYPE>
class CBaseCtrlEditSpin
{
	public:
		// EXPORT WINAPI
		CBaseCtrlEditSpin(){};
		virtual ~CBaseCtrlEditSpin(){};

		void Initialize(LONG lIDEdit, LONG lIDSpin, HWND hWndParent);
		BOOL FSetRange(TYPE tMin, TYPE tMax);

		void GetRange(TYPE &lMin, TYPE &lMax);
		BOOL FSetDelta(TYPE lDelta);
		virtual void SetPosition(TYPE lPosition) PURE;
		TYPE DGetPosition(void);
		TYPE GetPosition(void);
		virtual TYPE GetValue(void) PURE;
		virtual void SetValue(TYPE tValue) PURE;
		LONG LSetBuddy(void);
		HWND HGetBuddy(void);
		LONG LSetAccel(WORD cAccels, LPUDACCEL paAccels);
		LONG LGetAccel(WORD cAccels, LPUDACCEL paAccels);
		BOOL FIncrement(TYPE tAmount);
		EXPORT BOOL FIncrement(void);
		BOOL FDecrement(TYPE tAmount);
		BOOL FDecrement(void);
		void Select(int	iStart, int	iEnd);
		void SetFocusItem(void);
		void Enable(BOOL	fEnable);

	public:
		LONG	m_idEdit;	// ID of edit control
		LONG	m_idSpin;	// ID of spin control
		HWND	m_hdlg;		// The dialog this control belongs to.

	protected:
		EDIT_TYPE	m_EditCtrl;
		CDlgCtrlSpin	m_Spin;
		TYPE	m_tCurrentValue;
		TYPE	m_tMinRange;
		TYPE	m_tMaxRange;
		TYPE    m_tDeltaPos;
		BOOL	m_fRangeSet;

};


template< class TYPE, class EDIT_TYPE > void CBaseCtrlEditSpin< TYPE, EDIT_TYPE >::Initialize(LONG lIDEdit, LONG lIDSpin, HWND hWndParent)
{
	m_hdlg = hWndParent;
	m_EditCtrl.SetId(lIDEdit);
	m_EditCtrl.SetHdlg(m_hdlg);
	m_EditCtrl.Subclass();
	m_Spin.SetId(lIDSpin);
	m_Spin.SetHdlg(m_hdlg);
	m_Spin.FSetRange(-10, 10);
	LSetBuddy();
}

template< class TYPE, class EDIT_TYPE > BOOL CBaseCtrlEditSpin< TYPE, EDIT_TYPE >::FSetRange(TYPE tMin, TYPE tMax)
{
	m_tMinRange = tMin;
	m_tMaxRange = tMax;
	m_fRangeSet = TRUE;
	return TRUE;
}

template< class TYPE, class EDIT_TYPE > void CBaseCtrlEditSpin< TYPE, EDIT_TYPE >::GetRange(TYPE &tMin, TYPE &tMax)
{
    tMin = m_tMinRange;
    tMax = m_tMaxRange;
}


template< class TYPE, class EDIT_TYPE > BOOL CBaseCtrlEditSpin< TYPE, EDIT_TYPE >::FSetDelta(TYPE tDelta)
{
	m_tDeltaPos = tDelta;
	return TRUE;
}

template< class TYPE, class EDIT_TYPE > TYPE CBaseCtrlEditSpin< TYPE, EDIT_TYPE >::DGetPosition(void)
{
    return m_tCurrentValue;
};

template< class TYPE, class EDIT_TYPE > LONG CBaseCtrlEditSpin< TYPE, EDIT_TYPE >::LSetBuddy(void)
{
    return m_Spin.LSetBuddy(m_EditCtrl.HGetCtrl());
};

template< class TYPE, class EDIT_TYPE > HWND CBaseCtrlEditSpin< TYPE, EDIT_TYPE >::HGetBuddy(void)
{
    return (HWND)m_Spin.HGetBuddy(m_Spin.HGetCtrl());
};

template< class TYPE, class EDIT_TYPE > LONG CBaseCtrlEditSpin< TYPE, EDIT_TYPE >::LSetAccel(WORD cAccels, LPUDACCEL paAccels)
{
    return m_Spin.LSetAccel(cAccels, paAccels);
};

template< class TYPE, class EDIT_TYPE > LONG CBaseCtrlEditSpin< TYPE, EDIT_TYPE >::LGetAccel(WORD cAccels, LPUDACCEL paAccels)
{
    return m_Spin.LGetAccel(cAccels, paAccels);
};

template< class TYPE, class EDIT_TYPE > BOOL CBaseCtrlEditSpin< TYPE, EDIT_TYPE >::FIncrement(TYPE Amount)
{
	if( (m_tCurrentValue + Amount) > m_tMaxRange)
		return FALSE;
	m_tCurrentValue += Amount;

    SetValue(m_tCurrentValue);
	return TRUE;
};

template< class TYPE, class EDIT_TYPE > BOOL CBaseCtrlEditSpin< TYPE, EDIT_TYPE >::FIncrement(void)
{
	return FIncrement(m_tDeltaPos);
};

template< class TYPE, class EDIT_TYPE > BOOL CBaseCtrlEditSpin< TYPE, EDIT_TYPE >::FDecrement(TYPE Amount)
{
	if( (m_tCurrentValue - Amount) < m_tMinRange)
		return FALSE;
	m_tCurrentValue -= Amount;
	SetValue(m_tCurrentValue);
	return TRUE;
};

template< class TYPE, class EDIT_TYPE > BOOL CBaseCtrlEditSpin< TYPE, EDIT_TYPE >::FDecrement(void)
{
	return FDecrement(m_tDeltaPos);
};

template< class TYPE, class EDIT_TYPE > void CBaseCtrlEditSpin< TYPE, EDIT_TYPE >::Select(int	iStart, int	iEnd)
{
	m_EditCtrl.LResultSendMessage(EM_SETSEL, (WPARAM)iStart, (LPARAM)iEnd);
}

template< class TYPE, class EDIT_TYPE > void CBaseCtrlEditSpin< TYPE, EDIT_TYPE >::SetFocusItem(void)
{
	m_EditCtrl.SetFocusItem();
}

template< class TYPE, class EDIT_TYPE > void CBaseCtrlEditSpin< TYPE, EDIT_TYPE >::Enable(BOOL	fEnable){
	m_EditCtrl.Enable(fEnable);
	m_Spin.Enable(fEnable);
}


class CDlgCtrlLongSpin : public CBaseCtrlEditSpin<LONG, CDlgCtrlLong>
{
	public:
		EXPORT WINAPI CDlgCtrlLongSpin();
		virtual ~CDlgCtrlLongSpin(){};

		virtual EXPORT void SetPosition(LONG tPosition);
		virtual EXPORT LONG GetValue(void);
		virtual EXPORT void SetValue(LONG tValue);
};


class CDlgCtrlDblSpin : public CBaseCtrlEditSpin<double, CDlgCtrlDouble>
{
	public:
		EXPORT WINAPI CDlgCtrlDblSpin();
		virtual ~CDlgCtrlDblSpin(){};

		virtual EXPORT void SetPosition(double dValue);
		virtual EXPORT double GetValue(void);
		virtual EXPORT void SetValue(double dValue);
		virtual EXPORT void SetDisplayFormat(int iLeadingDigits, int iPrecision);
		virtual EXPORT void DeltaPos(int iDelta);

	protected:
		int     m_iFormatLeadingDigits;
		int     m_iFormatPrecision;

};




class CDlgCtrlIntSpin : public CBaseCtrlEditSpin<int, CDlgCtrlLong>
{
	public:
		EXPORT WINAPI CDlgCtrlIntSpin();
		virtual ~CDlgCtrlIntSpin(){};

		virtual EXPORT void SetPosition(int nPosition);
		virtual EXPORT int  GetValue(void);
		virtual EXPORT void SetValue(int nValue);
};





#ifdef NOT_YET


#include <tchar.h>
#include <commctrl.h>
#include <io.h>  // included for _access
#include <strconv.h>




////////////// CCheckList checkbox report-view listview //////////

/////////////////////////////
// To use this, link to ADT
// Give your dialog a "SysListView32" control with LVS_SINGLESEL style
// Give your dialog class a member CCheckList  m_checkList;
// In your dialog's WM_INITDIALOG,
//     m_checkList.Initialize( IDC_LISTVIEWID, hWndDialog );
//     CCheckList::item  anItem;
//     anItem.pszText   = "Item's display name";
//     anItem.stateType = CCheckList::included;
//     m_checkList.AddItem( anItem );
// In your dialog's WM_COMMAND, IDOK
//     anItem = m_checkList.GetItem( i )
//     if( anItem.stateType == CCheckList::included ) ...
/////////////////////////////
class CCheckList : public CSubClassCtrl
{
public:
    enum state {
        excluded=1,
        included,
        mandatory,
        prohibited
    };

    enum { cszTextLen = 128 };

    struct item {
        TCHAR   szText[ cszTextLen ];
        LPVOID  pVoid;
        state   stateType;
        int     imageType;      // see SetNormalImages

        item() : pVoid(NULL),
                 stateType(excluded), imageType(0)
        { lstrcpy(szText, "blank");  }
    };

    CCheckList( ) : CSubClassCtrl( )
    { NULL; }

    virtual ~CCheckList( )
    { NULL; }

        // Sets default state image list, column size, etc.
        // (will automatically call Subclass())
    virtual EXPORT BOOL Initialize( long lID, HWND hDlg );

        // puts an item into the checklist
        // returns its index (if no sorting style specified)
        // and -1 on error.
    int  AddItem( CCheckList::item & anItem );

        // counts items in checklist
    int  CountItems( void ) const;

        // retrieves an item from the checklist
    CCheckList::item  GetItem( int idx ) const;


        // ------ "advanced" APIs ---------

        // cx can be LVSCW_AUTOSIZE, LVSCW_AUTOSIZE_USEHEADER,
        // or a value in pixels.
        // If using LVS_LIST window-style, iCol must be -1.
    void SetColumnPixelWidth( int iCol, int cx );

        // replaces the default state images with a new imagelist
        // please put your excluded, included, mandatory, and prohibited
        // images in the first four bitmaps.
        // Both HIMAGELISTS are mandatory; we use ILC_MASK.
    //BOOL SetStateImages( HIMAGELIST himlimg, HIMAGELIST himlmask );

        // Set normal-size icons - optional second icon
        // to better categorize your items
    //BOOL SetNormalImages( HIMAGELIST himlimg, HIMAGELIST himlmask );

        // sets small icon equivalents of SetNormalImages
        // only call this if you've called SetNormalImages
    //BOOL SetSmallImages( HIMAGELIST himlimg, HIMAGELIST himlmask );

    protected:
    virtual EXPORT LONG CALLBACK   FCtrlProc( HWND hWnd,
                                              UINT uMessage,
                                              WPARAM wParam,
                                              LPARAM lParam );

    virtual EXPORT void OnLButtonDown( BOOL fDoubleClick,
                                       int x, int y,
                                       UINT keyFlags );

    virtual EXPORT void OnKey( UINT vk, BOOL fDown,
                               int cRepeat, UINT flags );

        // housekeeping...
    void ToggleItemInclusion( int idx = -1 ) const;

    int  GetSelectedItem( void ) const;
};


inline int  CCheckList::AddItem( CCheckList::item & anItem )
{
    int idx;
    idx = CountItems( );

    LV_ITEM  lvItem;
	ZeroMemory( &lvItem, sizeof(lvItem) );
    lvItem.iItem = idx;
    lvItem.mask = LVIF_TEXT | LVIF_STATE;
    lvItem.pszText = anItem.szText;
    lvItem.state   = INDEXTOSTATEIMAGEMASK( anItem.stateType );

    if( anItem.pVoid )
    {
        lvItem.mask |= LVIF_PARAM;
        lvItem.lParam = (LPARAM)anItem.pVoid;
    }
    if( anItem.imageType )
    {
        lvItem.mask |= LVIF_IMAGE;
        lvItem.iImage = anItem.imageType;
    }

    return ListView_InsertItem( HGetCtrl(), &lvItem );
}

        // counts items in checklist
inline int  CCheckList::CountItems( void ) const
{
    return ListView_GetItemCount( HGetCtrl() );
}

        // retrieves an item from the checklist
inline CCheckList::item  CCheckList::GetItem( int idx ) const
{
    LV_ITEM  lvItem;
    item     theItem;

    ZeroMemory( &lvItem, sizeof(lvItem) );
    lvItem.iItem = idx;
    lvItem.mask  = LVIF_TEXT | LVIF_PARAM |
                   LVIF_STATE | LVIF_IMAGE;
    lvItem.stateMask = LVIS_STATEIMAGEMASK |
                       LVIS_SELECTED;
    lvItem.pszText    = &theItem.szText[0];
    lvItem.cchTextMax = sizeof(theItem.szText);
    if( !ListView_GetItem( HGetCtrl(), &lvItem ) )
        return theItem;

    theItem.pVoid = (LPVOID) lvItem.lParam;
    if( lvItem.stateMask & LVIS_STATEIMAGEMASK )
    {
        DWORD  dwstate;
        dwstate = lvItem.state;

        DWORD dwstatemask;
        dwstatemask = LVIS_STATEIMAGEMASK;
        while( !(dwstatemask & 0x00000001) )
        {
            dwstatemask = dwstatemask >> 1;
            dwstate = dwstate >> 1;
        }
        theItem.stateType = (CCheckList::state) dwstate;
    }
    if( lvItem.stateMask & LVIF_IMAGE )
    {
        theItem.imageType = lvItem.iImage;
    }
    return theItem;
}


inline int  CCheckList::GetSelectedItem( void ) const
{
    UINT  uState;
    int   iSelIdx = -1;
    for( int i=0; i<ListView_GetItemCount(HGetCtrl()); i++ )
    {
        uState = ListView_GetItemState( HGetCtrl(), i, LVIS_SELECTED );
        if( uState == LVIS_SELECTED )
        {
            iSelIdx = i;
            break;
        }
    }
    return iSelIdx;

}



inline void CCheckList::SetColumnPixelWidth( int iCol, int cx )
{
    ListView_SetColumnWidth( HGetCtrl(), iCol, cx );
}



inline void CCheckList::ToggleItemInclusion( int idx ) const
{
    if( -1 == idx )
        idx = GetSelectedItem( );

    if( -1 == idx )
        return;

    UINT ustate;
    ustate = ListView_GetItemState( HGetCtrl(), idx,
                                    LVIS_STATEIMAGEMASK );
    if( INDEXTOSTATEIMAGEMASK(excluded) == ustate )
        ustate = INDEXTOSTATEIMAGEMASK(included);
    else if( INDEXTOSTATEIMAGEMASK(included) == ustate )
        ustate = INDEXTOSTATEIMAGEMASK(excluded);
    ListView_SetItemState( HGetCtrl(), idx, ustate,
                           LVIS_STATEIMAGEMASK );
}




#endif // NOT_YET






#endif // _DLGSUP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\inc\cstring.h ===
//=============================================================================
// CString.h
// This was taken from the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1997 Microsoft Corporation
// All rights reserved.
//
//=============================================================================
#ifndef __CSTRING_H__
#define __CSTRING_H__
#define AFXAPI

#ifndef ASSERT
#ifdef Proclaim
#define ASSERT Proclaim
#else
#define ASSERT _ASSERTE
#endif // Proclaim
#endif // ASSERT


#ifndef EXPORT
	#define EXPORT __declspec(dllexport)
#endif

class CString;
EXPORT const CString& AfxGetEmptyString();
#define afxEmptyString AfxGetEmptyString()

// Useful formatting functions to handle the %1, & %2 type formatting
void AfxFormatString1(CString& rString, UINT nIDS, LPCTSTR lpsz1);
void AfxFormatString2(CString& rString, UINT nIDS, LPCTSTR lpsz1,LPCTSTR lpsz2);
void AfxFormatStrings(CString& rString, UINT nIDS, LPCTSTR const* rglpsz, int nString);
void AfxFormatStrings(CString& rString, LPCTSTR lpszFormat, LPCTSTR const* rglpsz, int nString);

struct CStringData
{
	long nRefs;     // reference count
	int nDataLength;
	int nAllocLength;
	// TCHAR data[nAllocLength]

	TCHAR* data()
		{ return (TCHAR*)(this+1); }
};

class CString
{
public:
// Constructors
	EXPORT CString();
	EXPORT CString(const CString& stringSrc);
	EXPORT CString(TCHAR ch, int nRepeat = 1);
	EXPORT CString(LPCSTR lpsz);
	EXPORT CString(LPCWSTR lpsz);
	EXPORT CString(LPCTSTR lpch, int nLength);
	EXPORT CString(const unsigned char* psz);

// Attributes & Operations
	// as an array of characters
	EXPORT int GetLength() const;
	EXPORT BOOL IsEmpty() const;
	EXPORT void Empty();                       // free up the data

	EXPORT TCHAR GetAt(int nIndex) const;      // 0 based
	EXPORT TCHAR operator[](int nIndex) const; // same as GetAt
	EXPORT void SetAt(int nIndex, TCHAR ch);
	EXPORT operator LPCTSTR() const;           // as a C string

	// overloaded assignment
	EXPORT const CString& operator=(const CString& stringSrc);
	EXPORT const CString& operator=(TCHAR ch);
#ifdef _UNICODE
	EXPORT const CString& operator=(char ch);
#endif
	EXPORT const CString& operator=(LPCSTR lpsz);
	EXPORT const CString& operator=(LPCWSTR lpsz);
	EXPORT const CString& operator=(const unsigned char* psz);

	// string concatenation
	EXPORT const CString& operator+=(const CString& string);
	EXPORT const CString& operator+=(TCHAR ch);
#ifdef _UNICODE
	EXPORT const CString& operator+=(char ch);
#endif
	EXPORT const CString& operator+=(LPCTSTR lpsz);

	EXPORT friend CString AFXAPI operator+(const CString& string1,
			const CString& string2);
	EXPORT friend CString AFXAPI operator+(const CString& string, TCHAR ch);
	EXPORT friend CString AFXAPI operator+(TCHAR ch, const CString& string);
#ifdef _UNICODE
	EXPORT friend CString AFXAPI operator+(const CString& string, char ch);
	EXPORT friend CString AFXAPI operator+(char ch, const CString& string);
#endif
	EXPORT friend CString AFXAPI operator+(const CString& string, LPCTSTR lpsz);
	EXPORT friend CString AFXAPI operator+(LPCTSTR lpsz, const CString& string);

	// string comparison
	EXPORT int Compare(LPCTSTR lpsz) const;         // straight character
	EXPORT int CompareNoCase(LPCTSTR lpsz) const;   // ignore case
	EXPORT int Collate(LPCTSTR lpsz) const;         // NLS aware

	// simple sub-string extraction
	EXPORT CString Mid(int nFirst, int nCount) const;
	EXPORT CString Mid(int nFirst) const;
	EXPORT CString Left(int nCount) const;
	EXPORT CString Right(int nCount) const;

	EXPORT CString SpanIncluding(LPCTSTR lpszCharSet) const;
	EXPORT CString SpanExcluding(LPCTSTR lpszCharSet) const;

	// upper/lower/reverse conversion
	EXPORT void MakeUpper();
	EXPORT void MakeLower();
	EXPORT void MakeReverse();

	// trimming whitespace (either side)
	EXPORT void TrimRight();
	EXPORT void TrimLeft();

	// searching (return starting index, or -1 if not found)
	// look for a single character match
	EXPORT int Find(TCHAR ch) const;               // like "C" strchr
	EXPORT int ReverseFind(TCHAR ch) const;
	EXPORT int FindOneOf(LPCTSTR lpszCharSet) const;

	// look for a specific sub-string
	EXPORT int Find(LPCTSTR lpszSub) const;        // like "C" strstr

	// simple formatting
	EXPORT void __cdecl Format(LPCTSTR lpszFormat, ...);
	EXPORT void __cdecl Format(UINT nFormatID, ...);

	// formatting for localization (uses FormatMessage API)
	EXPORT BOOL __cdecl FormatMessage(LPCTSTR lpszFormat, ...);
	EXPORT BOOL __cdecl FormatMessage(UINT nFormatID, ...);

	// Windows support
	EXPORT BOOL LoadString(UINT nID);          // load from string resource
										// 255 chars max
#ifndef _UNICODE
	// ANSI <-> OEM support (convert string in place)
	EXPORT void AnsiToOem();
	EXPORT void OemToAnsi();
#endif

	// OLE BSTR support (use for OLE automation)
	EXPORT BSTR AllocSysString() const;
	EXPORT BSTR SetSysString(BSTR* pbstr) const;

	EXPORT HRESULT GetOLESTR(LPOLESTR* ppszString);

	// Access to string implementation buffer as "C" character array
	EXPORT LPTSTR GetBuffer(int nMinBufLength);
	EXPORT void ReleaseBuffer(int nNewLength = -1);
	EXPORT LPTSTR GetBufferSetLength(int nNewLength);
	EXPORT void FreeExtra();

	// Use LockBuffer/UnlockBuffer to turn refcounting off
	EXPORT LPTSTR LockBuffer();
	EXPORT void UnlockBuffer();

// Implementation
public:
	EXPORT ~CString();
	EXPORT int GetAllocLength() const;

protected:
	LPTSTR m_pchData;   // pointer to ref counted string data

	// implementation helpers
	CStringData* GetData() const;
	void Init();
	void AllocCopy(CString& dest, int nCopyLen, int nCopyIndex, int nExtraLen) const;
	void AllocBuffer(int nLen);
	void AssignCopy(int nSrcLen, LPCTSTR lpszSrcData);
	void ConcatCopy(int nSrc1Len, LPCTSTR lpszSrc1Data, int nSrc2Len, LPCTSTR lpszSrc2Data);
	void ConcatInPlace(int nSrcLen, LPCTSTR lpszSrcData);
	void FormatV(LPCTSTR lpszFormat, va_list argList);
	void CopyBeforeWrite();
	void AllocBeforeWrite(int nLen);
	void Release();
	static void PASCAL Release(CStringData* pData);
	static int PASCAL SafeStrlen(LPCTSTR lpsz);
};

// Conversion helpers.
int __cdecl _wcstombsz(char* mbstr, const wchar_t* wcstr, size_t count);
int __cdecl _mbstowcsz(wchar_t* wcstr, const char* mbstr, size_t count);

// Compare helpers
bool AFXAPI operator==(const CString& s1, const CString& s2);
bool AFXAPI operator==(const CString& s1, LPCTSTR s2);
bool AFXAPI operator==(LPCTSTR s1, const CString& s2);
bool AFXAPI operator!=(const CString& s1, const CString& s2);
bool AFXAPI operator!=(const CString& s1, LPCTSTR s2);
bool AFXAPI operator!=(LPCTSTR s1, const CString& s2);
bool AFXAPI operator<(const CString& s1, const CString& s2);
bool AFXAPI operator<(const CString& s1, LPCTSTR s2);
bool AFXAPI operator<(LPCTSTR s1, const CString& s2);
bool AFXAPI operator>(const CString& s1, const CString& s2);
bool AFXAPI operator>(const CString& s1, LPCTSTR s2);
bool AFXAPI operator>(LPCTSTR s1, const CString& s2);
bool AFXAPI operator<=(const CString& s1, const CString& s2);
bool AFXAPI operator<=(const CString& s1, LPCTSTR s2);
bool AFXAPI operator<=(LPCTSTR s1, const CString& s2);
bool AFXAPI operator>=(const CString& s1, const CString& s2);
bool AFXAPI operator>=(const CString& s1, LPCTSTR s2);
bool AFXAPI operator>=(LPCTSTR s1, const CString& s2);

// CString Inlines
inline CStringData* CString::GetData() const
	{ ASSERT(m_pchData != NULL); return ((CStringData*)m_pchData)-1; }
inline void CString::Init()
	{ m_pchData = afxEmptyString.m_pchData; }
inline CString::CString(const unsigned char* lpsz)
	{ Init(); *this = (LPCSTR)lpsz; }
inline const CString& CString::operator=(const unsigned char* lpsz)
	{ *this = (LPCSTR)lpsz; return *this; }
#ifdef _UNICODE
inline const CString& CString::operator+=(char ch)
	{ *this += (TCHAR)ch; return *this; }
inline const CString& CString::operator=(char ch)
	{ *this = (TCHAR)ch; return *this; }
inline CString AFXAPI operator+(const CString& string, char ch)
	{ return string + (TCHAR)ch; }
inline CString AFXAPI operator+(char ch, const CString& string)
	{ return (TCHAR)ch + string; }
#endif

inline int CString::GetLength() const
	{ return GetData()->nDataLength; }
inline int CString::GetAllocLength() const
	{ return GetData()->nAllocLength; }
inline BOOL CString::IsEmpty() const
	{ return GetData()->nDataLength == 0; }
inline CString::operator LPCTSTR() const
	{ return m_pchData; }
inline int PASCAL CString::SafeStrlen(LPCTSTR lpsz)
	{ return (lpsz == NULL) ? 0 : lstrlen(lpsz); }

// CString support (windows specific)
inline int CString::Compare(LPCTSTR lpsz) const
	{ return _tcscmp(m_pchData, lpsz); }    // MBCS/Unicode aware
inline int CString::CompareNoCase(LPCTSTR lpsz) const
	{ return _tcsicmp(m_pchData, lpsz); }   // MBCS/Unicode aware
// CString::Collate is often slower than Compare but is MBSC/Unicode
//  aware as well as locale-sensitive with respect to sort order.
inline int CString::Collate(LPCTSTR lpsz) const
	{ return _tcscoll(m_pchData, lpsz); }   // locale sensitive

inline TCHAR CString::GetAt(int nIndex) const
{
	ASSERT(nIndex >= 0);
	ASSERT(nIndex < GetData()->nDataLength);
	return m_pchData[nIndex];
}
inline TCHAR CString::operator[](int nIndex) const
{
	// same as GetAt
	ASSERT(nIndex >= 0);
	ASSERT(nIndex < GetData()->nDataLength);
	return m_pchData[nIndex];
}
inline bool AFXAPI operator==(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) == 0; }
inline bool AFXAPI operator==(const CString& s1, LPCTSTR s2)
	{ return s1.Compare(s2) == 0; }
inline bool AFXAPI operator==(LPCTSTR s1, const CString& s2)
	{ return s2.Compare(s1) == 0; }
inline bool AFXAPI operator!=(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) != 0; }
inline bool AFXAPI operator!=(const CString& s1, LPCTSTR s2)
	{ return s1.Compare(s2) != 0; }
inline bool AFXAPI operator!=(LPCTSTR s1, const CString& s2)
	{ return s2.Compare(s1) != 0; }
inline bool AFXAPI operator<(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) < 0; }
inline bool AFXAPI operator<(const CString& s1, LPCTSTR s2)
	{ return s1.Compare(s2) < 0; }
inline bool AFXAPI operator<(LPCTSTR s1, const CString& s2)
	{ return s2.Compare(s1) > 0; }
inline bool AFXAPI operator>(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) > 0; }
inline bool AFXAPI operator>(const CString& s1, LPCTSTR s2)
	{ return s1.Compare(s2) > 0; }
inline bool AFXAPI operator>(LPCTSTR s1, const CString& s2)
	{ return s2.Compare(s1) < 0; }
inline bool AFXAPI operator<=(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) <= 0; }
inline bool AFXAPI operator<=(const CString& s1, LPCTSTR s2)
	{ return s1.Compare(s2) <= 0; }
inline bool AFXAPI operator<=(LPCTSTR s1, const CString& s2)
	{ return s2.Compare(s1) >= 0; }
inline bool AFXAPI operator>=(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) >= 0; }
inline bool AFXAPI operator>=(const CString& s1, LPCTSTR s2)
	{ return s1.Compare(s2) >= 0; }
inline bool AFXAPI operator>=(LPCTSTR s1, const CString& s2)
	{ return s2.Compare(s1) <= 0; }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\inc\effect.h ===
#ifndef __EFFECT_H__
#define __EFFECT_H__

// Forward declares...
struct IDirectDrawSurface;

//{1F9DDD20-4146-11d0-BDC2-00A0C908DB96}
DEFINE_GUID(CATID_BitmapEffect, 
0x1f9ddd20, 0x4146, 0x11d0, 0xbd, 0xc2, 0x0, 0xa0, 0xc9, 0x8, 0xdb, 0x96);

#define CATSZ_BitmapEffectDescription __T("Bitmap Effect")

// {ACEA25C0-415B-11d0-BDC2-00A0C908DB96}
DEFINE_GUID(IID_IBitmapEffect, 
0xacea25c0, 0x415b, 0x11d0, 0xbd, 0xc2, 0x0, 0xa0, 0xc9, 0x8, 0xdb, 0x96);

#define BITMAP_EFFECT_INPLACE 				0x00000001
#define BITMAP_EFFECT_REALTIME				0x00000002
#define BITMAP_EFFECT_DIRECTDRAW			0x00000004
#define BITMAP_EFFECT_SUPPORTS_INVALIDATE	0x00000008

DECLARE_INTERFACE_(IBitmapEffect, IUnknown)
{
	STDMETHOD(SetSite)(LPUNKNOWN pUnk) PURE;
	STDMETHOD(GetMiscStatusBits)(DWORD* pdwFlags) PURE;
    STDMETHOD(GetSupportedFormatsCount)(unsigned *pcFormats) PURE;
    STDMETHOD(GetSupportedFormats)(unsigned cFormats, DWORD *pdwColorDepths)  PURE;
    STDMETHOD(Begin)(DWORD dwColorDepth, SIZE* psizeEffect) PURE;
    STDMETHOD(End)(void) PURE;
	STDMETHOD(DoEffect)(IDirectDrawSurface* pbsIn, IDirectDrawSurface* pbsOut, RECT *prcFull, RECT* prcInvalid) PURE;
};

#endif //__EFFECT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\inc\evbrspg.h ===
/*---------------------------------------------

  EvBrsPg.h--
  Event Browser Property Page

  Yury Polykovsky April 97 Excalliber 1.0

  ----------------------------------------------*/

#ifndef _PROPPAGES_EV_BROWSE
#define _PROPPAGES_EV_BROWSE
#include <dlgsup.h>

class CDlgCtrlEvBrsView : public CDlgCtrlTreeView
{
	friend class CPropPageEvBrowse;
protected:
	HTREEITEM m_htriSelectedObj;
	CPropPageEvBrowse *m_pOwner;

	EXPORT STDMETHOD_(HTREEITEM, htiAddLeaf)(HTREEITEM htiParent, void *pObject, int iBranch, int iLeaf);
public:
	BOOL m_fSelectionChecked;
	CDlgCtrlEvBrsView();
};

class CPropPageEvBrowse : public CPropPageOWP
{
	friend class CDlgCtrlEvBrsView;
protected:
	EVBROWSEPARAM m_obpData;
	CDlgCtrlEvBrsView m_dcTreeView;

	BOOL EXPORT WINAPI FOnInitDialog( HWND	hdlg, WPARAM wparam);
	BOOL EXPORT WINAPI FOnCommand(HWND	hdlg, WORD	wCode, WORD	wID, HWND	hwndCtrl);
	BOOL EXPORT WINAPI FOnNotify(HWND hDlg, int wParam, LPNMHDR lParam);
	virtual void EXPORT WINAPI GetData(void *pData);
	virtual BOOL EXPORT WINAPI FComp(VOID *pData1, VOID *pData2);
	EXPORT STDMETHOD_(void,	WriteToDlg)(void *pData);
 	STDMETHOD_(BOOL,DialogProc) (HWND hwnd, UINT uiMsg, WPARAM wParam, LPARAM lParam, HRESULT* phr);

public:
	CPropPageEvBrowse(HRESULT* phr);//(HINSTANCE hInst, UINT uIDTemplate) 
};

#endif //_PROPPAGES_EV_BROWSE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\inc\iacttran.h ===
#ifndef __IACTTRAN_H__
#define __IACTTRAN_H__

// {F34B20E1-0BCE-11d0-97DF-00A0C90FEE54}
DEFINE_GUID(IID_IActionTransfer, 
0xf34b20e1, 0xbce, 0x11d0, 0x97, 0xdf, 0x0, 0xa0, 0xc9, 0xf, 0xee, 0x54);

interface IActionSet;
interface IEnumDispatch;

DECLARE_INTERFACE_(IActionTransfer, IUnknown)
{
	STDMETHOD(GetActions)				( THIS_ IActionSet ** ppCActionSet ) PURE;
	STDMETHOD(NotifyClose)				( THIS ) PURE;
	STDMETHOD(GetDispatchEnumerator)	( THIS_ IEnumDispatch ** ppIDispatchesOnForm ) PURE;
};

#endif

// End of IActTran.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\inc\ienumid.h ===
//	IDispatch enumerator interface
//	8/27/96 VK : Changed IEnumIDispatch to IEnumDispatch

#ifndef __IENUMID_H__
#define __IENUMID_H__

DECLARE_INTERFACE_( IEnumDispatch, IUnknown )
{
	STDMETHOD ( QueryInterface )( REFIID, void** )		PURE;
	STDMETHOD_( ULONG, AddRef )( void )					PURE;
	STDMETHOD_( ULONG, Release )( void )				PURE;

	STDMETHOD ( Next )( ULONG, IDispatch**, LPDWORD )	PURE;
	STDMETHOD ( Skip )( ULONG )							PURE;
	STDMETHOD ( Reset )( void )							PURE;
	STDMETHOD ( Clone )( IEnumDispatch ** )				PURE;
};
typedef IEnumDispatch *PENUMDISPATCH;

#endif //__IENUMID_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\inc\hash.h ===
/*
********************************************************************
* 
* 
* Module: HASH.H 
* 
* Author: ThomasOl
* 
* Description: General purpose
* 
* 
********************************************************************
*/

#ifndef __HASH_H__
#define __HASH_H__

#ifndef New
#define New new
#endif

#ifndef Delete
#define Delete delete
#endif

/*
********************************************************************
* 
* CListElement class definition
* 
********************************************************************
*/

template <class T>
class CListElement
{
protected:
    T*            m_pT;
    CListElement* m_pPrev;
    CListElement* m_pNext;

protected:
    void DestroyData(void) 
		{if (m_pT) Delete m_pT;m_pT=NULL;}
	void Init(void) 
		{m_pT=NULL;m_pPrev=NULL;m_pNext=NULL;};

public:
    CListElement() 
		{Init();}
    CListElement(T* pT) 
		{Init();SetData(pT);}
    virtual ~CListElement() 
		{DestroyData();}
    T* GetData(void) 
		{return m_pT;}

    BOOL SetData(T* pT) 
    {
        if ((m_pT=(T*)New T))
        {
            *m_pT = *pT;
            return TRUE;
        }
        return FALSE;
    }
    
    int operator==(const CListElement& le) const
    {
		if (le.m_pT && m_pT)
			return (*le.m_pT == *m_pT);
		return 0;
    }
    void SetPrev( CListElement* prev) {m_pPrev=prev;}
    void SetNext( CListElement* next) {m_pNext=next;}
    CListElement* GetPrev(void) {return m_pPrev;}
    CListElement* GetNext(void) {return m_pNext;}
};


/*
********************************************************************
* 
* CList class definition
* 
********************************************************************
*/

template <class T>
class CList
{
public:
    CListElement<T>*    m_pHead;

public:
    CList() 
		{m_pHead=NULL;}
    virtual ~CList() 
		{DestroyList();}

    void DestroyList(void)
    {
        CListElement<T>* ple=m_pHead;
        while (ple)
        {
            CListElement<T>* pne = ple->GetNext();
            Delete ple;
            ple = pne;
        }
		m_pHead = NULL;
    }
    
	CListElement<T>* Find(T* pT)
	{
        CListElement<T>* ple=m_pHead;
		CListElement<T> le(pT);
        while (ple)
        {
            if (*ple == le)
                return ple;
            ple = ple->GetNext();
        }
		return NULL;
	}

    BOOL Insert(T* pT)
    {
        if (Find(pT))			//can't insert if it's already in hash table
			return FALSE;

		CListElement<T>* ple = New CListElement<T>;
        if (ple && ple->SetData(pT))
        {
            if (m_pHead)
			{
                m_pHead->SetPrev(ple);
				ple->SetNext(m_pHead);
			}
            m_pHead = ple;
            return TRUE;
        }
        return FALSE;
    }
    
    BOOL Remove(T* pT)
    {
        CListElement<T>* ple = Find(pT);

		if (ple)
		{
            CListElement<T>* prev=ple->GetPrev();
            CListElement<T>* next=ple->GetNext();
    
            if (prev)
                prev->SetNext(next);
            if (next)
                next->SetPrev(prev);
            if (ple==m_pHead)
                m_pHead=next;
        	return TRUE;
		}
        return FALSE;
    }
};


/*
********************************************************************
* 
* CHashTable class definition
* 
********************************************************************
*/

#define NUM_HASH_BUCKETS 4097

template <class T>
class CHashTable
{
protected:
    CList<T> m_table[NUM_HASH_BUCKETS];
    DWORD m_dwIndex;
    CListElement<T>* m_pcListElement;
	ULONG m_lCount;

protected:
    virtual DWORD Hash(T* pT)=0;

public:
    CHashTable() {m_dwIndex=0;m_pcListElement=NULL;}
    virtual ~CHashTable() {}
    

    BOOL Insert(T* pT)
    {
        DWORD dwIndex=Hash(pT);
		BOOL fRet = m_table[dwIndex].Insert(pT);
		if (fRet)
		{
			++m_lCount;
		}
        return fRet;
    }
    
    BOOL Remove(T* pT)
    {
        DWORD dwIndex=Hash(pT);
		BOOL fRet = m_table[dwIndex].Remove(pT);
		if (fRet)
		{
			--m_lCount;
		}
        return fRet;
    }

	T*  Find(T* pT)
	{
		DWORD dwIndex=Hash(pT);
		CListElement<T>* ple = m_table[dwIndex].Find(pT);
		return (ple) ? ple->GetData() : NULL;
	}

    T*  FindFirst(void)
    {
        for (m_dwIndex=0; m_dwIndex < NUM_HASH_BUCKETS; m_dwIndex++)
        {
            if (m_pcListElement=m_table[m_dwIndex].m_pHead)
                return m_pcListElement->GetData();
        }
        return NULL;
    }


    T*  FindNext(void)
    {
        if (!m_pcListElement)
            return NULL;

        if (m_pcListElement = m_pcListElement->GetNext())
            return m_pcListElement->GetData();

        for (++m_dwIndex; m_dwIndex < NUM_HASH_BUCKETS; m_dwIndex++)
        {
            if (m_pcListElement=m_table[m_dwIndex].m_pHead)
                return m_pcListElement->GetData();
        }
        return NULL;
    }

	ULONG Count(void)
	{
		return m_lCount;
	}
};

#endif //__HASH_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\inc\idcol.h ===
//	IDispatch collection, with augment and enumerate interfaces
//	8/27/96 VK : Changed IEnumIDispatch to IEnumDispatch

#ifndef _IDISPATCHCOLLECTION_H_
#define _IDISPATCHCOLLECTION_H_

#include "IEnumID.h"
#include "IIdCol.h"

#define CPTRS	50	// Hard-coded array size and max.  Must change.  BUGBUG

class CIDispatchCollection : public IUnknown
{
	class CDispatchCollectionAugment : public IIDispatchCollectionAugment
	{
		public:
		STDMETHODIMP			QueryInterface ( REFIID, void** );
		STDMETHODIMP_(ULONG)	AddRef ( void );
		STDMETHODIMP_(ULONG)	Release ( void );

		STDMETHODIMP			AddToCollection ( IDispatch* );

		CDispatchCollectionAugment::CDispatchCollectionAugment ( CIDispatchCollection* pObj );
		CDispatchCollectionAugment::~CDispatchCollectionAugment ();
		
		private:
		ULONG					m_cRef;			// Reference count (for debugging purposes)
		CIDispatchCollection	*m_poBackPtr;	// Pointer to containing object
	};

	class CDispatchCollectionEnum : public IEnumDispatch
	{
		public:
		STDMETHODIMP			QueryInterface ( REFIID, void** );
		STDMETHODIMP_(ULONG)	AddRef ( void );
		STDMETHODIMP_(ULONG)	Release ( void );

		STDMETHODIMP			Next ( ULONG, IDispatch**, ULONG * );
		STDMETHODIMP			Skip ( ULONG );
		STDMETHODIMP			Reset ( void );
		STDMETHODIMP			Clone ( PENUMDISPATCH * );
		
		CDispatchCollectionEnum::CDispatchCollectionEnum ( CIDispatchCollection* pObj );
		CDispatchCollectionEnum::~CDispatchCollectionEnum ();

		private:
		ULONG					m_cRef;			// Reference count (for debugging purposes)
		ULONG					m_iCur;         // Current enum position
		CIDispatchCollection	*m_poBackPtr;	// Pointer to containing object
	};
	
	friend CDispatchCollectionAugment;
	friend CDispatchCollectionEnum;

	private:
	ULONG		m_cRef;			// Reference count
	ULONG		m_cPtrs;		// Current count of IDispatches contained
	IDispatch*	m_rpid[CPTRS];	// IDispatch pointers we enumerate

	CDispatchCollectionAugment	m_oAugment;
	CDispatchCollectionEnum		m_oEnum;

    public:
	STDMETHODIMP				QueryInterface ( REFIID, void** );
	STDMETHODIMP_(ULONG)		AddRef ( void );
	STDMETHODIMP_(ULONG)		Release ( void );

	CIDispatchCollection ( void );
	~CIDispatchCollection ( void );
};


typedef CIDispatchCollection *PCIDispatchCollection;


//Function that creates one of these objects
BOOL EXPORT WINAPI CreateIDispatchCollection ( IUnknown **ppUnk );

#endif //_IDISPATCHCOLLECTION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\inc\evbrs.h ===
/*---------------------------------------------

  EvBrs.h--
  Event Browser

  Yury Polykovsky April 97 Excaliber

  ----------------------------------------------*/

#ifndef _EV_BROWSE
#define _EV_BROWSE

class COWPFactoryEvBrowse : public CObjWPropFactory 
{
public:
	COWPFactoryEvBrowse() : CObjWPropFactory() {};
    STDMETHODIMP     CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
};

class CEvBrowse : public CObjectWProp
{
protected:
	EVBROWSEPARAM m_obpData;
	POSITION m_posObjSw;
	POSITION m_posMethodSw;
	CSwObjectControl* m_pControl;

	virtual BOOL fValidData(void *pData);
	virtual void SetData(void *pData);
	virtual void *pGetData(void);
public:
	CEvBrowse(LPUNKNOWN, PFNDESTROYED);
	EXPORT STDMETHOD_( BOOL, ResetObjectNames() );
	EXPORT STDMETHOD_( BOOL, FGetNextObjectName(TCHAR *ptszObjName, int ilenth) );
	EXPORT STDMETHOD_( BOOL, FObjectNameInAction(TCHAR *ptszObjName, int ilenth) );
	EXPORT STDMETHOD_( BOOL, ResetMethodNames() );
	EXPORT STDMETHOD_( BOOL, FGetNextMethodName(TCHAR *ptszMethodName, int ilenth) );
	EXPORT STDMETHOD_( BOOL, FMethodNameInAction(TCHAR *ptszMethodName, int ilenth) );
	virtual BOOL FIIDGetCLSIDPropPage(int i, IID *piid);
	// Object browser globals for registration, etc.
#ifdef	CSTRING_PROBLEM_SOLVED	
	static HRESULT WINAPI hrGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID * ppv);
#endif	//	CSTRING_PROBLEM_SOLVED	
	static BOOL fRegisterObj ();
	static BOOL fUnregisterObj ();
};


class CPropertyNotifySinkEB : public CPropertyNotifySink
{
protected:
    CSeqListItem*  m_pSeqItem;      //Backpointer to the app

public:
    CPropertyNotifySinkEB(CSeqListItem*);

    STDMETHODIMP OnChanged(DISPID);
    STDMETHODIMP OnRequestEdit(DISPID);
};

typedef CPropertyNotifySink *PCPropertyNotifySink;

#endif //_EV_BROWSE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\inc\idguids.h ===
//	GUIDs used for IDispatch collection interfaces
//	8/27/96 VK : Changed IEnumIDispatch to IEnumDispatch


// {66E5EC80-E669-11cf-B8DF-00AA00BBAF4D}
DEFINE_GUID(IID_IEnumDispatch, 
0x66e5ec80, 0xe669, 0x11cf, 0xb8, 0xdf, 0x0, 0xaa, 0x0, 0xbb, 0xaf, 0x4d);

// {66E5EC81-E669-11cf-B8DF-00AA00BBAF4D}
DEFINE_GUID(IID_IDispatchCollectionAugment,
0x66e5ec81, 0xe669, 0x11cf, 0xb8, 0xdf, 0x0, 0xaa, 0x0, 0xbb, 0xaf, 0x4d);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\inc\mathwrap.h ===
#ifndef __CMATH_H__
#define __CMATH_H__

class CMathWrapper
{

 private :

	static OTrig s_otrig;

 public :

	CMathWrapper (void);
	~CMathWrapper (void);

	static EXPORT float Pow( double x, double y );
	static EXPORT float __fastcall Sqrt( float x );

	static EXPORT	float __fastcall	SinDeg (float	fltAngle);
	static EXPORT	float __fastcall	CosDeg (float	fltAngle);
	static EXPORT	float __fastcall	SinDeg (long	lAngleOneTenths);
	static EXPORT	float __fastcall	CosDeg (long    lAngleOneTenths);

    static EXPORT	float __fastcall	SinDegWrap (float	fltAngle);
	static EXPORT	float __fastcall	CosDegWrap (float	fltAngle);
	static EXPORT	float __fastcall	SinDegWrap (long	lAngleOneTenths);
	static EXPORT	float __fastcall	CosDegWrap (long    lAngleOneTenths);

	static EXPORT double __fastcall SinRad (double dblRads);
	static EXPORT double __fastcall CosRad (double dblRads);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\inc\mmx.h ===
#ifndef _INC_MMX_H
#define _INC_MMX_H

		// IsMMXCpu() returns TRUE if the CPU
		// has Intel's MMX technology.
		// Link to the IHammer utils library
		// 
	__declspec(dllexport) BOOL IsMMXCpu( void );
	

#endif // _INC_MMX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\inc\itimer.h ===
#ifndef __ITIMER_H__
#define __ITIMER_H__

// Timer service modelled on the Trident proposal.

#define TIME_INFINITE 0xffffffff

DECLARE_INTERFACE_(ITimerServiceInit, IUnknown)
{
	STDMETHOD(Init)		(THIS) PURE;
	STDMETHOD(IsReady)	(THIS) PURE;
};

#endif

// End of ITimer.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\inc\iidcol.h ===
//	IIDCollection interface: add items to the IEnumID collection
//	Add items by passing IDispatch interface pointers to AddToCollection.
//	They will be AddRefed, so the caller must Release the pointers after calling
//	AddToCollection.
//	Cloning AddRefs each member, so the IDispatch interface isn't released until the
//	last enumerator is released.
//
//	AddToCollection returns an error is the pointer is invalid.

#ifndef __IIDCOL_H__
#define __IIDCOL_H__

#include <OLEAUTO.H>

typedef struct IIDispatchCollectionAugment IIDispatchCollectionAugment;
typedef IIDispatchCollectionAugment *PDISPATCHCOLLECTIONAUGMENT;


DECLARE_INTERFACE_( IIDispatchCollectionAugment, IUnknown )
{
    // IUnknown members
	STDMETHOD ( QueryInterface )( REFIID, void** )		PURE;
	STDMETHOD_( ULONG, AddRef )( void )					PURE;
	STDMETHOD_( ULONG, Release )( void )				PURE;

    // IIDispatchCollectionAugment members
	STDMETHOD ( AddToCollection )( IDispatch* )			PURE;
};

#endif //__IIDCOL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\inc\ihammer.h ===
/************************************************************
Derived from OUTLAW.H:

Shared, general header file for OMT's Peacemaker

Outlaw, summer '93

REV:     April, '96  Hammer 1.0   Norm Bryar
      Added the precompiler conditional CONSTANTS_ONLY so
      clients can get CCH_ID, et. al., without pulling in every
      header the English-speaking world has ever written.
      I did this rather than creating a seperate header for
      constants because I don't want to touch every makefile
      to inform it of a new header dependency.

*************************************************************/

#ifndef __OUTLAW_H__
#define __OUTLAW_H__
#include <builddef.h>

//#include <version.h>
#include <windows.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
// PAULD #include <port.h>

//#define  EDIT_TITLE_EXT     ((LPCSTR)"EMT")
//#define  RUN_TITLE_EXT      ((LPCSTR)"RMT")

// Generated purely out of the top of my head
// Pretty random.
//#define	dwMagicSymmetry		0x70adf981

// IMPORTANT, STANDARD DEFINED STRING CONSTANTS
#define CCH_MAXSTRING                   (2*_MAX_PATH)
#define CCH_ID                          256
#define CCH_HANDLER_NAME                13
#define CCH_HANDLER_DESCRIPTION_NAME	13	// The part before the : in the description.
#define CCH_HANDLER_DESCRIPTION         81
#define CCH_FILENAME              		_MAX_FNAME
#define CCH_SHORT_FILENAME              13
#define CCH_SCRIPT_FUNCTION             27
#define CCH_TITLE_BYTES                 81
#define CCH_SCRIPT_CAPTION              41
#define CCH_OFN_FILTERS                 64
#define cchStringMaxOutlaw				512


// --- Zoom constraints ---
#define MINZOOM    25u
#define MAXZOOM    800u

#define MAX_CAPTION		256
#define MAX_NAME		CCH_ID
#define MAX_COMMENT		256
#define TEMP_SIZE_MAX	256 // temporary string buffer maximum size in bytes
#define	EVT_NAMELEN		CCH_ID


//These character constants are used to replace the first character of the handler
//name dynamically so it will refer to the right dll. Can't wait to use windows
//reg file stuff. No need for hacks like this	-PhaniV
//#define	chEditMode						'X'
//#define	chRunMode						'Z'

// The reg file always has 'E' so irrespective of the
// mode/platform we need to restore it to 'E'
//#ifdef EDIT_MODE
//#define FixHandlerName(rgch, fRestore) {*rgch= (fRestore ? 'E' : chEditMode);}
//#else
//#define FixHandlerName(rgch, fRestore) {*rgch= (fRestore ? 'E' : chRunMode);}
//#endif  // EDIT_MODE

// RUNTIME CONSTANTS
#define MAX_CME_PALETTE_ENTRIES         236
#define NUM_DEFAULT_CME_PALETTE_ENTRIES 15
#define MAX_BOUNDING_RECT_SIDE          1500

//============================================================================

// PAULD #include <outlawrc.h> // Return codes from most Hammer functions
#include <memlayer.h>
#include <debug.h>
//#include <utility.h>
//#include <archive.h>
//#include <list.h>
//#include <hash.h>

//#ifdef EDIT_MODE
//#include <chelp.h>
//#endif

//#include <stg.h>
//#include <stockid.h>
//#include <object.h>
//#include <drg.h>
//#include <iprogres.h>
//#include <iasset.h>
// PAULD #include <coml.h>

//#include <icondarg.h>
//#include <icmdtarg.h>
//#include <icmepub.h>
//#include <imop.h>
//#include <ifmonikr.h>

//// #include <mop.h>

//============================================================================

#endif  // __OUTLAW_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\inc\otrig.h ===
/*+********************************************************
MODULE: OTRIG.H
AUTHOR: PhaniV
DATE: Jan '97

DESCRIPTION: OTrig class for a table look up sin and cos functions.
*********************************************************-*/


#ifndef __OTRIG_H__
#define __OTRIG_H__

//===============================================================================================
#define		cSinCosEntries	3601
class	OTrig
{
private:
	static	float	s_rgfltSin[cSinCosEntries];
	static	float	s_rgfltCos[cSinCosEntries];
	static	BOOL	s_fCalculated;

	void PreCalcRgSinCos(void);

public:
	EXPORT	OTrig(void);

        // These versions of the functions do no range checking!
        // Caller is responsible for ensuring 0.0 - 360.0 range.
        // _DEBUG ihamutil will assert, that's it.
        // It's faster this way.
	EXPORT	float __fastcall	Sin(float	fltAngle);
	EXPORT	float __fastcall	Cos(float	fltAngle);
	EXPORT	float __fastcall	Sin(long	lAngleOneTenths);
	EXPORT	float __fastcall	Cos(long    lAngleOneTenths);

        // These versions of the functions will wrap the input
        // into the 0.0-360.0 range for you.
    EXPORT	float __fastcall	SinWrap(float	fltAngle);
	EXPORT	float __fastcall	CosWrap(float	fltAngle);
	EXPORT	float __fastcall	SinWrap(long	lAngleOneTenths);
	EXPORT	float __fastcall	CosWrap(long    lAngleOneTenths);

};
#endif // __OTRIG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\inc\memlayer.h ===
/*=========================================================================*\

    File    : MEMMAN.H
    Purpose : CMemManager Class Definition
    Author  : Michael Byrd
    Date    : 07/10/96

\*=========================================================================*/

#ifndef __MEMMAN_H__
#define __MEMMAN_H__

#include <stdio.h> // Needed for FILE declaration...
#include <utils.h>

/*=========================================================================*\
     Forward class declarations:
\*=========================================================================*/

class CMemUser;
class CMemManager;

/*=========================================================================*\
     Constant definitions:
\*=========================================================================*/

// We always add extra bytes (because we can't alloc 0 bytes!)
#define ALLOC_EXTRA 4 + (sizeof(int))

// Array "Grow" size constants:
#define MEMHEAPGROW     4
#define MEMUSERGROW    10
#define MEMBLOCKGROW   64

#define HEAPINITIALITEMCOUNT 64 // Initial Heap size multiplier

// Debugging info constants:
#define MAX_SOURCEFILENAME  32  // Maximum number of characters in filename

// Memory Block Flags:
#define MEM_PURGEABLE      0x0001 // Memory block is purgeable
#define MEM_MOVEABLE       0x0002 // Memory block is moveable
#define MEM_EXTERNAL_FLAGS (MEM_PURGEABLE|MEM_MOVEABLE)

// Internal block flags:
#define MEM_SUBALLOC       0x8000 // Memory block is from sub-allocation

#define MEM_INTERNAL_FLAGS (MEM_SUBALLOC)

/*=========================================================================*\
     Type declarations:
\*=========================================================================*/

typedef struct HEAPHEADER_tag
{
    BOOL       fInUse;           // Flag to indicate usage
    HANDLE     handleHeap;       // Handle returned by HeapCreate
    DWORD      dwBlockAllocSize; // Size of object allocations
    int        iNumBlocks;       // Number of blocks currently allocated
} HEAPHEADER, FAR *LPHEAPHEADER;

typedef struct MEMBLOCK_tag
{
    BOOL      fInUse;           // Flag to indicate usage
    LPVOID    lpData;           // Pointer to actual bits of this memory block
    DWORD     dwSize;           // Size of this memory block
    WORD      wFlags;           // Flags associated with this memory block
    WORD      wLockCount;       // Lock Count on this memory block
    int       iHeapIndex;       // Index of heap where this was allocated
    int       iMemUserIndex;    // Index of CMemUser that allocated this
#ifdef _DEBUG
    int       iLineNum;         // Line number where created
    char      rgchFileName[MAX_SOURCEFILENAME]; // Filename where created
#endif // _DEBUG
} MEMBLOCK, FAR *LPMEMBLOCK;

typedef struct MEMUSERINFO_tag
{
    BOOL       fInUse;          // Flag to indicate usage
    DWORD      dwThreadID;      // Thread ID of the CMemUser object
    CMemUser  *lpMemUser;       // Pointer to the MEMUSER object
    int        iNumBlocks;      // Number of blocks currently allocated
} MEMUSERINFO, FAR *LPMEMUSERINFO;

// Notification types...
typedef enum
{
    eMemNone      = 0,  // No information available
    eMemAllocated = 1,  // Memory was allocated
    eMemResized   = 2,  // Memory was re-sized (re-allocated)
    eMemLowMemory = 3,  // Encountered a low-memory situation
    eMemDeleted   = 4,  // Memory was deleted
    eMemPurged    = 5   // Memory was purged
} MEMNOTIFYCODE;

// Notification structure...
typedef struct MEMNOTIFY_tag
{
    MEMNOTIFYCODE eNotifyCode;  // eMemXXXX notification code
    LPMEMBLOCK    lpMemBlock;   // MEMBLOCK for notification
} MEMNOTIFY, FAR *LPMEMNOTIFY;

/*=========================================================================*\
     CMemUser Class: (Provides notification mechanism)
\*=========================================================================*/

class FAR CMemUser
{
public:
    EXPORT CMemUser(void);
    EXPORT virtual ~CMemUser(void);

    // Basic memory allocation routines
    LPMEMBLOCK EXPORT AllocBuffer(DWORD dwBytesToAlloc, WORD wFlags);
    void EXPORT FreeBuffer(LPMEMBLOCK lpMemBlock);

    // Lock/Unlock methods (for purgeable memory)
    LPVOID EXPORT LockBuffer(LPMEMBLOCK lpMemBlock);
    void EXPORT UnLockBuffer(LPMEMBLOCK lpMemBlock);

    // Callback to notify the CMemUser of some action being taken...
    virtual BOOL EXPORT NotifyMemUser(LPMEMNOTIFY lpMemNotify);
};

/*=========================================================================*\
     CMemManager Class:
\*=========================================================================*/

class FAR CMemManager
{
public:
    // Construction
    EXPORT CMemManager(void);
    EXPORT virtual ~CMemManager(void);

#ifdef _DEBUG
    LPVOID EXPORT AllocBuffer(DWORD dwBytesToAlloc, WORD wFlags, int iLine, LPSTR lpstrFile);
    LPVOID EXPORT ReAllocBuffer(LPVOID lpBuffer, DWORD dwBytesToAlloc, WORD wFlags, int iLine, LPSTR lpstrFile);
#else // !_DEBUG
    LPVOID EXPORT AllocBuffer(DWORD dwBytesToAlloc, WORD wFlags);
    LPVOID EXPORT ReAllocBuffer(LPVOID lpBuffer, DWORD dwBytesToAlloc, WORD wFlags);
#endif // !_DEBUG

    VOID   EXPORT FreeBufferMemBlock(LPMEMBLOCK lpMemBlock);
    VOID   EXPORT FreeBuffer(LPVOID lpBuffer);
    DWORD  EXPORT SizeBuffer(LPVOID lpBuffer);

    BOOL   EXPORT RegisterMemUser(CMemUser *lpMemUser);
    BOOL   EXPORT UnRegisterMemUser(CMemUser *lpMemUser);

    VOID   EXPORT DumpAllocations(LPSTR lpstrFilename=NULL);

    // Global access to single g_CMemManager:
#ifdef _DEBUG
    static LPVOID EXPORT AllocBufferGlb(DWORD dwBytesToAlloc, WORD wFlags, int iLine, LPSTR lpstrFile);
    static LPVOID EXPORT ReAllocBufferGlb(LPVOID lpBuffer, DWORD dwBytesToAlloc, WORD wFlags, int iLine, LPSTR lpstrFile);
#else // !_DEBUG
    static LPVOID EXPORT AllocBufferGlb(DWORD dwBytesToAlloc, WORD wFlags);
    static LPVOID EXPORT ReAllocBufferGlb(LPVOID lpBuffer, DWORD dwBytesToAlloc, WORD wFlags);
#endif // !_DEBUG

    static VOID   EXPORT FreeBufferGlb(LPVOID lpBuffer);
    static DWORD  EXPORT SizeBufferGlb(LPVOID lpBuffer);

    static BOOL   EXPORT RegisterMemUserGlb(CMemUser *lpMemUser);
    static BOOL   EXPORT UnRegisterMemUserGlb(CMemUser *lpMemUser);

    static VOID   EXPORT DumpAllocationsGlb(LPSTR lpstrFilename=NULL);

private:
    // Internal management routines...
    void Cleanup(void);
    BOOL CreateHeap(DWORD dwAllocationSize);
    BOOL DestroyHeap(HANDLE handleHeap);
    int  FindHeap(DWORD dwAllocationSize, LPHEAPHEADER lpHeapHeader);

    LPVOID AllocFromHeap(int iHeapIndex, DWORD dwAllocationSize);
    BOOL   FreeFromHeap(int iHeapIndex, LPVOID lpBuffer);

    LPMEMBLOCK AllocMemBlock(int *piIndex);
    BOOL       FreeMemBlock(LPMEMBLOCK lpMemBlock, int iMemBlockIndex=-1);
    LPMEMBLOCK FindMemBlock(LPVOID lpBuffer, int *piIndex=NULL);

    VOID EXPORT DumpHeapHeader(LPHEAPHEADER lpHeapHeader, FILE *fileOutput);
    VOID EXPORT DumpMemUserInfo(LPMEMUSERINFO lpMemUserInfo, FILE *fileOutput);
    VOID EXPORT DumpMemBlock(LPMEMBLOCK lpMemBlock, FILE *fileOutput);

private:
    CRITICAL_SECTION m_CriticalHeap;
    CRITICAL_SECTION m_CriticalMemUser;
    CRITICAL_SECTION m_CriticalMemBlock;

    HANDLE           m_handleProcessHeap; // Default Process Heap handle

    int              m_iNumHeaps;      // Number of Allocated heaps
    LPHEAPHEADER     m_lpHeapHeader;   // Array of HEAPHEADER

    int              m_iNumMemUsers;   // Number of Allocated CMemUser
    LPMEMUSERINFO    m_lpMemUserInfo;  // Array of MEMUSERINFO

    int              m_iNumMemBlocks;  // Number of Allocated MEMBLOCK
    LPMEMBLOCK      *m_lplpMemBlocks;  // Pointer to Array of LPMEMBLOCK pointers

    int              m_iMemBlockFree;  // Index of first free MEMBLOCK

private:
    static CMemManager g_CMemManager;  // Global instance of memory manager
};

/*=========================================================================*/

// Global operator new/delete:

#ifdef _DEBUG

  #define DEBUG_OPERATOR_NEW
  #define New    new FAR (__LINE__, __FILE__)
  #define Delete delete

  #define MemAlloc(numBytes)             CMemManager::AllocBufferGlb(numBytes, 0, __LINE__, __FILE__)
  #define MemReAlloc(lpBuffer, numBytes) CMemManager::ReAllocBufferGlb(lpBuffer, numBytes, 0, __LINE__, __FILE__)
  #define MemFree(lpBuffer)              CMemManager::FreeBufferGlb(lpBuffer)
  #define MemSize(lpBuffer)              CMemManager::SizeBufferGlb(lpBuffer)

  __inline LPVOID __cdecl operator new(size_t cb, LONG cLine, LPSTR lpstrFile) 
  { return   CMemManager::AllocBufferGlb(cb, 0, cLine, lpstrFile); }

  __inline VOID __cdecl operator delete(LPVOID pv) 
  { CMemManager::FreeBufferGlb(pv); }

#else // !_DEBUG

  #undef DEBUG_OPERATOR_NEW
  #define New    new FAR
  #define Delete delete

  #define MemAlloc(numBytes)             CMemManager::AllocBufferGlb(numBytes, 0)
  #define MemReAlloc(lpBuffer, numBytes) CMemManager::ReAllocBufferGlb(lpBuffer, numBytes, 0)
  #define MemFree(lpBuffer)              CMemManager::FreeBufferGlb(lpBuffer)
  #define MemSize(lpBuffer)              CMemManager::SizeBufferGlb(lpBuffer)

  __inline LPVOID __cdecl operator new(size_t cb)
  { return CMemManager::AllocBufferGlb(cb, 0); }
  __inline VOID __cdecl operator delete(LPVOID pv)
  { CMemManager::FreeBufferGlb(pv); }

#endif // !_DEBUG

#define MemReallocZeroInit(p, cb) MemReAlloc(p, cb)
#define MemAllocZeroInit(cb)      MemAlloc(cb)
#define MemGetHandle(p)           (p)
#define MemLock(h)                (h)
#define MemUnlock(h)              (NULL)

/*=========================================================================*/

#endif // __MEMMAN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\inc\proputil.h ===
#ifndef __PROPUTIL_H__
#define __PROPUTIL_H__

HRESULT EXPORT ReadBstrFromPropBag(LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog, LPSTR pszName, OLECHAR ** pbstr);
HRESULT EXPORT WriteBstrToPropBag(LPPROPERTYBAG pPropBag, LPSTR pszName, LPOLESTR bstrVal);

HRESULT EXPORT ReadLongFromPropBag(LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog, LPSTR pszName, LONG * plValue);
HRESULT EXPORT WriteLongToPropBag(LPPROPERTYBAG pPropBag, LPSTR pszName, LONG lValue);

#endif

// End of PropUtil.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\inc\quickie.h ===
#ifndef INC_QUICKIE_H_
#define INC_QUICKIE_H_
/*-----------------------------------------------
    IHammer\inc\quickie.h--
    This header contains various lightnin'-fast
    inline utilties that otherwise don't have a home.
    
    NormB               Jan., '97    Created
  ---------------------------------------------*/

#ifndef _INC_FLOAT
  #include <float.h>
#endif _INC_FLOAT

#ifndef _INC_MATH
  #include <math.h>
#endif _INC_MATH

	// If you want fastest possible code, envelope it in
	// #pragma LIGHTNING  your-code-here #pragma ENDLIGHTNING
	// 
#ifdef _DEBUG
  #define LIGHTNING       optimize( "agt", on )
#else
  #define LIGHTNING       optimize( "agtyib1", on )
#endif // _DEBUG
#define ENDLIGHTNING    optimize( "", on )

#ifndef NO_INTRIN_MEM
#pragma warning( disable : 4164 )
#pragma intrinsic( memcmp, memset, memcpy )
#pragma warning( default : 4164 )
#endif // NO_INTRIN_MEM

#ifndef NO_INTRIN_MATH
#pragma intrinsic( fabs, labs, abs, \
                   sin, cos, tan, log, exp, sqrt )
#endif // NO_INTRIN_MATH

// note: see also recsqrt.h for the fastest "/ sqrt(x)"

// ----------------------------------

    // This is a faster (under /G5 /Ogit /Ob1) square-root routine
    // It operates on integer values 0 - 32768^2
    // and does so up to 60% faster than sqrt().
    // Caveat: (float) psi_sqrt((long) fval) takes *longer* than sqrt!
    // although (float) psi_sqrt( lval ) is still faster.
    // For floating-point sqrt, use sqrt()!!!!
    // Note: no checks for v<0.
inline int _fastcall  psi_sqrt(long v)
/* // Calculates the square root of a 32-bit number.*/
{    
  register long t = 1L << 30, r = 0, s;
  #define PSISTEP(k) \
    s = t + r; \
    r >>= 1; \
    if (s <= v) { \
        v -= s; \
        r |= t; \
    }

    PSISTEP(15); t >>= 2;
    PSISTEP(14); t >>= 2;
    PSISTEP(13); t >>= 2;
    PSISTEP(12); t >>= 2;
    PSISTEP(11); t >>= 2;
    PSISTEP(10); t >>= 2;
    PSISTEP(9); t >>= 2;
    PSISTEP(8); t >>= 2;
    PSISTEP(7); t >>= 2;
    PSISTEP(6); t >>= 2;
    PSISTEP(5); t >>= 2;
    PSISTEP(4); t >>= 2;
    PSISTEP(3); t >>= 2;
    PSISTEP(2); t >>= 2;
    PSISTEP(1); t >>= 2;
    PSISTEP(0);

    return r;

  #undef PSISTEP
}

// ----------------------------------

    // note: dotprodcut() doesn't use recsqrt
    // 'cause it turned out to be slower!  
    // Possibly as x,y,z typically ints cast to floats?
inline float dotproduct(float x1, float y1, float z1, float x2, float y2, float z2)
{
	//normalize the vector
	float dist;

    dist  = (x1*x1 + y1*y1 + z1*z1) * 
            (x2*x2 + y2*y2 + z2*z2);

    return (x1*x2 + y1*y2 + z1*z2)/(float)( sqrt(dist) + 1.0e-16);
}


// ----------------------------------

    // Use this instead of casting to convert float to int.
    // C/C++ generates _ftol calls that truncate the float
    // contrary to the round-to-even native to Intel chips.
    // Float2Int is thus more accurate and 25% faster than casts!
inline int _fastcall Float2Int( float fl )
{   
#if _M_IX86 >= 300 
    register int iRes;
    _asm{
        fld    fl
        fistp  iRes
    }
    return iRes;
#else
    return static_cast<int>(fl+0.5f);
#endif // Intel-chip
}

// ---------------------------------

#ifndef OFFSETPTR
#define OFFSETPTR
template< class T>
inline T OffsetPtr( T pT, int cb )
{
    return reinterpret_cast<T>( cb + 
        static_cast<char*>(const_cast<void*>(static_cast<const void*>(pT))) );
}
#endif // OFFSETPTR

// ----------------------------------

    // Untested on negative valued args    
template< class T >
inline T Div255( T arg )
{    
    return ((arg+128) + ((arg+128)>>8))>>8;
}

    // ...shifts don't work on floats
inline float Div255( float arg )
{  return arg / 255.0f;  }

inline double Div255( double arg )
{ return arg / 255.0; }

// ----------------------------------

#endif // INC_QUICKIE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\inc\params.h ===
/*-----------------------------------------------------------------------------
@doc
@module params.h | Method param class definitions.
@author 12-13-96 | pauld | Broke out from action classes and Autodoc'd
-----------------------------------------------------------------------------*/

#ifndef _PARAMS_H_
#define _PARAMS_H_

//	Represents a single parameter for an automation mehtod.
//
class CMethodParam
{

public:

	CMethodParam ();
	virtual ~CMethodParam ();

	BOOL Init ( BSTR bstrName, BOOL fOptional, VARTYPE vt );

	unsigned short	GetName ( char* szName, unsigned short wBufSize );
	BOOL			IsOptional ()	{ return m_fOptional; }
	VARTYPE			GetType ()		{ return m_varType; }
	HRESULT			GetVal ( VARIANT *pVar );
	HRESULT			SetVal ( VARIANT *pVar );

	// Persistence functions
	void			SaveOnString ( TCHAR* ptcText, DWORD dwLength );
	LPTSTR LoadVariantFromString	(LPTSTR szParamString);

	BOOL	EXPORT	SetName ( BSTR bstrName );
	void	EXPORT	SetOptional ( BOOL fOptional );
	void	EXPORT	SetVarType ( VARTYPE vt );

	// Trim leading commas and whitespace.
	static LPTSTR TrimToNextParam (LPTSTR szNextParam);

private:

	void	CleanOutEscapes			(LPTSTR szParamString, int iStringLength);
	LPTSTR ProcessStringParam (LPTSTR szParamString);
	BOOL	NeedEscape				(LPCTSTR szSourceText) const;
	int		CountEscapesOnString	(LPTSTR szParamString, int iLength) const;
	void	InsertEscapes			(LPTSTR szNewText, LPTSTR szSourceText, int cChars);
	void	SaveStringParamToString	(LPTSTR ptcActionText, DWORD dwLength);
	VARTYPE	NarrowVarType			(VARTYPE p_vt);

	char	*m_szName;
	BOOL	m_fOptional;
	VARTYPE	m_varType;
	VARIANT	m_var;
};


#endif _PARAMS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\inc\recsqrt.h ===
#ifndef _INC_RECSQRT_H
#define _INC_RECSQRT_H
/*------------------------------------------------------

  recsqrt.h -- 
  A faster-than-blazes implementation of reciprocal
  square-root (1 / sqrt(f)), float recsqrt(float).
  Using recsqrt() on binary-irrational numbers can save ~40%!
  NOTE: 1/sqrt() is faster, however, on ints cast to floats!
  Profile your code both ways to be sure.

  If you wish to use this, one of your source-files must
  #define RECSQRT_INIT prior to including this header.
  
  Note: the algorithm assumes input lies in (0.5 to 2.56M]
  (CRecSqrtTable_s_fLowBound, CRecSqrtTable_s_fHighBound],
  numbers chosen as a typical range occupied by vector
  magnitudes on high-resolution video.  
  For inputs outside this range, the algorithm falls-back
  to 1.0f / sqrt(f), only with added overhead.

  Note: REVIEW marks design decisions I haven't profiled.
  Need to run Intel's VTune2.1 dynamic-assembler analysis.

  Author:  Norm Bryar       Feb., '97

  ----------------------------------------------------*/

  #ifndef _INC_MATH
    #include <math.h>    // pow, sqrt
  #endif // _INC_MATH


    // The recsqrt() algorithm does a small number of 
    // Newton-Raphson iterations on an initial guess
    // generated by a piece-wise linear polynomial over
    // a restricted input range (a <= x <= b].
    // The range (a,b] is partitioned into sub-intervals
    // according to the paper
    //    "Optimal Partitioning of Newton's Method
    //     for Calculating Roots,"  
    //     Gunter Meinardus and G.D. Taylor,
    //     Mathematics of Computation, v35 no 152 October 1980,
    //     pp 1221-1230.
    // This partioning is critical to outperforming the Pentium's
    // intrinsic form of 1.0/sqrt(f).
    // Essentially, the subintervals are given by
    // ( a*(b/a)^j/v, a*(b/a)^(j+1)/v], each of which has a
    // linear equation optimally-adjusted (via gamma)
    // to provide the minimum-error first-guess for
    // Newton-Raphson iteration.
    // The Newton-Raphson algorithm, xN+1 = xN - f/f',
    // uses f = (1/x^2 - R) as the reciprocal root of R.
    // This form for f yields iterations w/ no divisions!

    class CRecSqrtTable
    {                
    public:
        enum { s_ctIntervals = 7 };   // chosen so m_fsubinterval
                                      // fits on one cache line

        CRecSqrtTable( );

		// If __inline is honored, __fastcall is ignored
		// Debug builds don't honor inlining.
        __inline float __fastcall GetStartingPoint( float x );        

    private:
        void CalcApproxCoeficients( );
        void CalcSubIntervals( );                

    private:
        struct lineareq 
        {
            float   a;
            float   b;
        };
		// We search m_fsubinterval first.
		// To maximize elements found in cache
		// we make it a seperate array.
		// REVIEW: profile it where interval is in lineareq
		// which might minimize cache misses getting a,b.
        static float       m_fsubinterval[ s_ctIntervals + 1 ];
        static lineareq    m_lineareq[ s_ctIntervals ];
    };
    
    #define CRecSqrtTable_s_fLowBound    0.5f
    #define CRecSqrtTable_s_fHighBound   2560000.0f

#ifdef RECSQRT_INIT

    inline CRecSqrtTable::CRecSqrtTable()
    {
        CalcSubIntervals( );
        CalcApproxCoeficients( );
    }

    inline void CRecSqrtTable::CalcSubIntervals( )
    {
        double  dGenerator;
        int     iInterval;
        
        m_fsubinterval[0] = CRecSqrtTable_s_fLowBound;

        dGenerator = CRecSqrtTable_s_fHighBound / 
                     CRecSqrtTable_s_fLowBound;
        iInterval = 1;
        while( iInterval <= s_ctIntervals )
        {
            m_fsubinterval[iInterval] = (float) 
                ((double) CRecSqrtTable_s_fLowBound * 
                 pow( dGenerator, 
                      ((double) iInterval) / s_ctIntervals ));
            ++iInterval;
        }
    }

        // REVIEW: We can always calculate this once, offline,
        // and just make a const array of initialized data.
        // This would probably go in .rdata and shorten
        // load-times and shrink workingset.
    inline void CRecSqrtTable::CalcApproxCoeficients( )
    {
        const  double three_3_2 =  5.196152422707;  // 3^3/2
        double alpha;
        double beta;
        double gamma;
        double lamda;
        double lamda_ba_geommean;
        double lamda_ba_normmean;
        float  a;
        float  b;
        int    iInterval = 0;

        while( iInterval < s_ctIntervals )
        {
            a = m_fsubinterval[ iInterval ];
            b = m_fsubinterval[ iInterval + 1 ];

            lamda_ba_geommean = three_3_2 * sqrt(a * b ) * 
                                (sqrt(b) + sqrt(a));
            lamda_ba_normmean = (b + sqrt(a * b) + a);
            lamda_ba_normmean *= 2 * sqrt(lamda_ba_normmean);
            lamda = (lamda_ba_normmean - lamda_ba_geommean) /
                    (lamda_ba_normmean + lamda_ba_geommean);

            alpha = (lamda - 1.0) / 
                    (sqrt(a*b) * (sqrt(b) + sqrt(a)));
            beta  = -(b + sqrt(a*b) + a) * alpha;
            gamma = 1.0; // sqrt( 3.0 / (3.0 - lamda*lamda) );

            m_lineareq[iInterval].a = (float) (gamma * alpha);
            m_lineareq[iInterval].b = (float) (gamma * beta);
            ++iInterval;
        }
    }    

    float                   CRecSqrtTable::m_fsubinterval[ CRecSqrtTable::s_ctIntervals + 1 ];
    CRecSqrtTable::lineareq CRecSqrtTable::m_lineareq[ CRecSqrtTable::s_ctIntervals ];
    CRecSqrtTable           g_recsqrttable;

#else  // user must have defined RECSQRT_INIT in another cpp file

    extern CRecSqrtTable g_recsqrttable;

#endif // RECSQRT_INIT

       // __fastcall for use in _DEBUG builds (ie /Ob0 - no inlining)
    inline float __fastcall CRecSqrtTable::GetStartingPoint( float x )
    {
            // intentional bit-wise AND, 
            // produces less asm instructions and 
            // no short-circuit branch to foul branch-prediction.
            // Pentium assumes this if will pass and will have
            // prefetched the instructions inside the if.
        if( (x >  CRecSqrtTable_s_fLowBound) & 
            (x <= CRecSqrtTable_s_fHighBound) )
        {
            register int  i = s_ctIntervals;

                // As the sub-intervals are much larger at the top
                // we begin at the top and walk down.
                // For even-distribution of x, yields fewest loops
                // Range test above ensures i < s_ctIntervals
                // If you *know* you're args cluster around 1,
                // you may want while(x > m[++i]) NULL; --i;
                // REVIEW: Cache assumes sequential, increasing access;
                // Consider ordering 2M at [0] and 0.5 at [N] instead
	            // thus maximizing cache hits as we increment i.
            while( x <= m_fsubinterval[--i] )
                NULL;
            
            return (m_lineareq[i].a * x) +m_lineareq[i].b;
        }
        return (float) (1.0f / sqrt((double) x));
    }


    inline float __fastcall recsqrt( float flt )
    {
        register float  x;
    
        x = g_recsqrttable.GetStartingPoint( flt );
        flt *= 0.5f;    
        x = (1.5f - flt * x * x) * x;
        x = (1.5f - flt * x * x) * x;
        return x;
    }

#endif // _INC_RECSQRT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\inc\strconv.h ===
#ifndef __STRCONV_H
#define __STRCONV_H


/* flag values */
#define FL_UNSIGNED   1       /* strtoul called */
#define FL_NEG        2       /* negative sign found */
#define FL_OVERFLOW   4       /* overflow occured */
#define FL_READDIGIT  8       /* we've read at least one correct digit */

#ifndef EXPORT
    #define EXPORT __declspec(dllexport)  
#endif

class CStrConv
{
    private:
        unsigned long EXPORT WINAPI StrToLX( const char *nptr,
                            const char **endptr,
                            int ibase,
                            int flags);



public:
    long __cdecl StrToL (
        const char *nptr,
        char **endptr,
        int ibase
        )
        {
            return (long) StrToLX(nptr, (const char **)endptr, ibase, 0);
        };

unsigned long __cdecl StrToUL (
        const char *nptr,
        char **endptr,
        int ibase
        )
        {
            return StrToLX(nptr, (const char **)endptr, ibase, FL_UNSIGNED);
        };

};

#endif //__STRCONV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\inc\page.h ===
//@class   The following class impliments a large portion of the IPropertyPage Interface \
		// It also handles the creation of the dialog for your property or parameter page \
		// and passes message on to the correct DlgProc 
class CPropertyPage : virtual public CBaseDialog, public IPropertyPage
{

//@access Public Members
public:
	//@cmember,mfunc Constructor
	EXPORT WINAPI CPropertyPage(void);
	//@cmember,mfunc Destructor
	EXPORT virtual ~CPropertyPage(void);

	//IUnknown interface
	EXPORT STDMETHOD(QueryInterface)(REFIID, LPVOID *);
	EXPORT STDMETHOD_(ULONG, AddRef)(void) ;
	EXPORT STDMETHOD_(ULONG, Release)(void) ;
	
	// IPropertyPage methods
	EXPORT STDMETHOD(SetPageSite)(LPPROPERTYPAGESITE pPageSite);
	EXPORT STDMETHOD(Activate)(HWND hwndParent, LPCRECT lprc, BOOL bModal);
	EXPORT STDMETHOD(Deactivate)(void);
	EXPORT STDMETHOD(GetPageInfo)(LPPROPPAGEINFO pPageInfo);
	EXPORT STDMETHOD(SetObjects)(ULONG cObjects, LPUNKNOWN FAR* ppunk);
	EXPORT STDMETHOD(Show)(UINT nCmdShow);
	EXPORT STDMETHOD(Move)(LPCRECT prect);
	EXPORT STDMETHOD(IsPageDirty)(void);
	EXPORT STDMETHOD(Help)(LPCOLESTR lpszHelpDir);
	EXPORT STDMETHOD(TranslateAccelerator)(LPMSG lpMsg);
	STDMETHOD(Apply)(void) PURE;


	// CBaseDialog you need to override this for your dialog proc
	STDMETHOD_(LONG, LDlgProc)( HWND hWnd, UINT uMessage, WPARAM wParam, LPARAM lParam) PURE;

protected:
	EXPORT STDMETHOD_ (void, FreeAllObjects)(void);

protected:
    ULONG			m_cRef;         // Reference count
    HINSTANCE       m_hInst;        // Module instance
    UINT            m_uIDTemplate;  // Dialog ID
    ULONG           m_cx;           // Dialog size
    ULONG           m_cy;
    UINT            m_cObjects;     // Number of objects
    BOOL            m_fDirty;       // Page dirty?
    IUnknown**		m_ppIUnknown;   // Objects to notify
    LCID            m_lcid;         // Current locale
	WORD            m_uiKillInputMsg; // Used to kill input window
	BOOL			m_fDisableUpdate; // Used to prevent re-entrency in the dialog update method
	UINT            m_uTabTextId;   // Tab string ID
	IPropertyPageSite *m_pIPropertyPageSite;    //Frame's parameter page site

}; // class CPropertyPage : virtual public CBaseDialog, public IPropertyPage





// Included to prevent compile error in dllmain.cpp
// this is declared in actclass.h
interface IObjectProxy;

//@class   The following class impliments a remaining portion of the IPropertyPage Interface \
		// for parameter pages
class CParameterPage : virtual public CPropertyPage
{

public:
	EXPORT WINAPI CParameterPage(void);
	EXPORT virtual ~CParameterPage(void);

	//IUnknown interface
	EXPORT STDMETHOD(QueryInterface)(REFIID, LPVOID *);
	
	// IPropertyPage methods (PURE in CPropertyPage)
	EXPORT STDMETHOD(Apply)(void);


	// CBaseDialog you need to override this for your dialog proc
	STDMETHOD_(LONG, LDlgProc)( HWND hWnd, UINT uMessage, WPARAM wParam, LPARAM lParam) PURE;

protected:
	EXPORT STDMETHOD (GetInitialData)(void);
	EXPORT STDMETHOD_(unsigned short, ParamTypeToString)( VARTYPE vt, char* szTypeName, unsigned short wBufSize );
	EXPORT STDMETHOD (Validate)(void);

protected:
	IObjectProxy*   m_piObjectProxy;//Pointer to ObjectProxy interface
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\inc\strwrap.h ===
#ifndef __STRWRAP_H__
#define __STRWRAP_H__

class CStringWrapper
{

 public :

	 CStringWrapper (void);
	 ~CStringWrapper (void);

	 static EXPORT LPTSTR Strcpy	(LPTSTR szDest, LPCTSTR szSource);
	 static EXPORT LPTSTR Strncpy	(LPTSTR szDest, LPCTSTR szSource, size_t nCount);
	 static EXPORT LPTSTR Strcat	(LPTSTR szDest, LPCTSTR szSource);
	 static EXPORT wchar_t * WStrcat (wchar_t *szDest, const wchar_t *szSource);
     static EXPORT int WStrlen (const wchar_t *szSource);
	 static EXPORT wchar_t * WStrcpy (wchar_t *szDest, const wchar_t *szSource);
     static EXPORT wchar_t *WStrncpy (wchar_t *szDest, const wchar_t *szSource, size_t nSize);

		// WStrCmpin - case-insensitive CompareStringW() ct chars.
		// Note: returns 0xBADBAAD on OOM or other error.
	 static EXPORT int      WStrCmpin( const wchar_t * sz1,
		                               const wchar_t * sz2,
									   size_t          ct );

	 static EXPORT int      LoadStringW(HINSTANCE hInst, 
										UINT uID, 
										wchar_t * szString, 
										int nMaxLen );
	 static EXPORT int Iswspace (wint_t c);
	 static EXPORT int         Strlen	(LPCTSTR szSource);
	 static EXPORT int         Strcmp	(LPCTSTR szLeft, LPCTSTR szRight);
	 static EXPORT int         Stricmp	(LPCTSTR szLeft, LPCTSTR szRight);
	 static EXPORT int         Strncmp	(LPCTSTR szLeft, LPCTSTR szRight, size_t nSize);
	 static EXPORT int         Strnicmp	(LPCTSTR szLeft, LPCTSTR szRight, size_t nSize);
	 static EXPORT LPTSTR Strchr	(LPCTSTR szSource, TCHAR chSearch);
	 static EXPORT LPTSTR Strrchr	(LPCTSTR szSource, TCHAR chSearch);
	 static EXPORT LPTSTR Strstr	(LPCTSTR szOne, LPCTSTR szTwo);
	 static EXPORT LPTSTR Strtok	(LPTSTR szTarget, LPCTSTR szTokens);
	 static EXPORT LPTSTR Strinc	(LPCTSTR szTarget);

// 	 static EXPORT int         Sscanf	(LPCTSTR szSource, LPCTSTR szFormat, ... );
	 static EXPORT int         Sscanf1	(LPCTSTR szSource, LPCTSTR szFormat, LPVOID pvParam1);
	 static EXPORT int         Sscanf2	(LPCTSTR szSource, LPCTSTR szFormat, LPVOID pvParam1, LPVOID pvParam2);
	 static EXPORT int         Sscanf3	(LPCTSTR szSource, LPCTSTR szFormat, LPVOID pvParam1, LPVOID pvParam2, LPVOID pvParam3);
	 static EXPORT int         Sprintf (LPTSTR szDest, LPCTSTR szFormat, ...);

	 static EXPORT long       Atol		(LPCTSTR szSource);
	 static EXPORT int         Atoi		(LPCTSTR szSource);

	 static EXPORT LPTSTR Ltoa			(long lSource, LPTSTR szDest, int iRadix);
	 static EXPORT LPTSTR Itoa			(int iSource, LPTSTR szDest, int iRadix);
	 
	 static EXPORT LPTSTR Gcvt			( double dblValue, int iDigits, LPTSTR szBuffer );

	 static EXPORT size_t Wcstombs		( char *mbstr, const wchar_t *wcstr, size_t count );
	 static EXPORT size_t Mbstowcs		( wchar_t *wcstr, const char *mbstr, size_t count );

	 static EXPORT int         Memcmp	(const void * pvLeft, const void * pvRight, size_t nSize);
	 static EXPORT void *	Memset		(void * pvLeft, int iValue, size_t nSize);
	 static EXPORT void *   Memcpy		( void * pvDest, const void * pvSrc, size_t count );

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\inc\servprov.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.00.44 */
/* at Mon Dec 16 08:37:08 1996
 */
/* Compiler settings for servprov.idl:
    Oic (OptLev=i1), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __servprov_h__
#define __servprov_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IServiceProvider_FWD_DEFINED__
#define __IServiceProvider_FWD_DEFINED__
typedef interface IServiceProvider IServiceProvider;
#endif 	/* __IServiceProvider_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL__intf_0000
 * at Mon Dec 16 08:37:08 1996
 * using MIDL 3.00.44
 ****************************************/
/* [local] */ 


//=--------------------------------------------------------------------------=
// ServProv.h
//=--------------------------------------------------------------------------=
// (C) Copyright 1995-1997 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//---------------------------------------------------------------------------=
// IServiceProvider Interfaces.


#ifndef _LPSERVICEPROVIDER_DEFINED
#define _LPSERVICEPROVIDER_DEFINED


extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_s_ifspec;

#ifndef __IServiceProvider_INTERFACE_DEFINED__
#define __IServiceProvider_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IServiceProvider
 * at Mon Dec 16 08:37:08 1996
 * using MIDL 3.00.44
 ****************************************/
/* [unique][uuid][object] */ 


typedef /* [unique] */ IServiceProvider __RPC_FAR *LPSERVICEPROVIDER;


EXTERN_C const IID IID_IServiceProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IServiceProvider : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE QueryService( 
            /* [in] */ REFGUID guidService,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IServiceProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IServiceProvider __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IServiceProvider __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IServiceProvider __RPC_FAR * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryService )( 
            IServiceProvider __RPC_FAR * This,
            /* [in] */ REFGUID guidService,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        END_INTERFACE
    } IServiceProviderVtbl;

    interface IServiceProvider
    {
        CONST_VTBL struct IServiceProviderVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IServiceProvider_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IServiceProvider_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IServiceProvider_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IServiceProvider_QueryService(This,guidService,riid,ppvObject)	\
    (This)->lpVtbl -> QueryService(This,guidService,riid,ppvObject)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IServiceProvider_RemoteQueryService_Proxy( 
    IServiceProvider __RPC_FAR * This,
    /* [in] */ REFGUID guidService,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppvObject);


void __RPC_STUB IServiceProvider_RemoteQueryService_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IServiceProvider_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL__intf_0055
 * at Mon Dec 16 08:37:08 1996
 * using MIDL 3.00.44
 ****************************************/
/* [local] */ 


#endif


extern RPC_IF_HANDLE __MIDL__intf_0055_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0055_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* [local] */ HRESULT STDMETHODCALLTYPE IServiceProvider_QueryService_Proxy( 
    IServiceProvider __RPC_FAR * This,
    /* [in] */ REFGUID guidService,
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IServiceProvider_QueryService_Stub( 
    IServiceProvider __RPC_FAR * This,
    /* [in] */ REFGUID guidService,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppvObject);



/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\inc\transit.h ===
#ifndef __TRANSIT_H__
#define __TRANSIT_H__


// forward declares...
struct IDirectDrawSurface;


//{1F9DDD21-4146-11d0-BDC2-00A0C908DB96}
DEFINE_GUID(CATID_BitmapTransition, 
0x1f9ddd21, 0x4146, 0x11d0, 0xbd, 0xc2, 0x0, 0xa0, 0xc9, 0x8, 0xdb, 0x96);

#define CATSZ_BitmapTransitionDescription __T("Bitmap Transition")

// {ACEA25C1-415B-11d0-BDC2-00A0C908DB96}
DEFINE_GUID(IID_IBitmapTransition, 
0xacea25c1, 0x415b, 0x11d0, 0xbd, 0xc2, 0x0, 0xa0, 0xc9, 0x8, 0xdb, 0x96);

DECLARE_INTERFACE_(IBitmapTransition, IUnknown)
{
	STDMETHOD(SetSite)(LPUNKNOWN pUnk) PURE;
	STDMETHOD(GetMiscStatusBits)(DWORD* pdwFlags) PURE;
	STDMETHOD(GetSupportedFormatsCount)(unsigned *pcFormats) PURE;
	STDMETHOD(GetSupportedFormats)(unsigned cFormats, DWORD *pdwColorDepths) PURE;
	STDMETHOD (Begin)(DWORD  dwColorDepth, SIZE* psizeTransition,
			IDirectDrawSurface* piddsSrc, IDirectDrawSurface* piddsSrcMask,
			/* in, optional */ HDC hDC ) PURE;
	STDMETHOD(DoTransition)(HDC hdc, IDirectDrawSurface* piddsDC, RECT *prcDC, 
					   IDirectDrawSurface* piddsDst, IDirectDrawSurface* piddsDstMask,
					   RECT* prcDst, LONG lPercent) PURE;
	STDMETHOD(End)(void) PURE;

	STDMETHOD_(void,UpdatePalette)(HPALETTE hPal) PURE;
};

#endif //__TRANSIT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\inc\surface.h ===
#ifndef __SURFACE_H__
#define __SURFACE_H__
/************************************************
 *
 *  surface.h --
 *  The IHammer-defined IDirectDrawSurface class
 *  used by transitions and effects for making
 *  masks and image-copies treated consistently
 *  with the image surfaces given us by Trident.
 *
 *  A very limited sub-set of the v1 
 *  IDirectDrawSurface is supported here! 
 *
 *  Author: Norm Bryar
 *  History:
 *     pre-history - Created for IBitmapSurface.
 *     4/97    - changed to IDirectDrawSurface.
 *     4/23/97 - moved to global inc directory
 *
 ***********************************************/

#ifndef __DDRAW_INCLUDED__
  #include <ddraw.h>
#endif // __DDRAW_INCLUDED__

	// I think we should use bpp
	// instead of DDBD_... constants
	// in DDPIXELFORMAT.dwRGBBitCount
#define DD_1BIT   1
#define DD_4BIT   4
#define DD_8BIT   8
#define DD_16BIT  16
#define DD_24BIT  24
#define DD_32BIT  32

#ifndef EXPORT
  #define EXPORT __declspec( dllexport )
#endif // EXPORT


typedef struct
{
	BITMAPINFOHEADER bmiHeader;
	RGBQUAD bmiColors[256];
} BITMAPINFO256;

    // No a class named CDirectDrawSurface,
    // there'd never be any collisions on that!
namespace IHammer {


class CDirectDrawSurface : public IDirectDrawSurface
{
public:
    EXPORT CDirectDrawSurface( HPALETTE hpal, 
							   DWORD dwColorDepth, 
							   const SIZE* psize, 
							   HRESULT * hr );
    virtual ~CDirectDrawSurface();

    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);
	
    //IDirectDrawSurface methods (that we care about)
    STDMETHOD (GetSurfaceDesc)( DDSURFACEDESC * pddsDesc );
    STDMETHOD (GetPixelFormat)( DDPIXELFORMAT * pddpixFormat );    

    STDMETHOD (Lock)(RECT *prcBounds, DDSURFACEDESC *pddsDesc, DWORD dwFlags, HANDLE hEvent);
    STDMETHOD (Unlock)(void *pBits);

	STDMETHOD(GetDC)(THIS_ HDC FAR *);
	STDMETHOD(ReleaseDC)(THIS_ HDC);


    // IDirectDrawSurface E_NOTIMPLs
    STDMETHOD(AddAttachedSurface)(THIS_ LPDIRECTDRAWSURFACE);
    STDMETHOD(AddOverlayDirtyRect)(THIS_ LPRECT);
    STDMETHOD(Blt)(THIS_ LPRECT,LPDIRECTDRAWSURFACE, LPRECT,DWORD, LPDDBLTFX);
    STDMETHOD(BltBatch)(THIS_ LPDDBLTBATCH, DWORD, DWORD );
    STDMETHOD(BltFast)(THIS_ DWORD,DWORD,LPDIRECTDRAWSURFACE, LPRECT,DWORD);
    STDMETHOD(DeleteAttachedSurface)(THIS_ DWORD,LPDIRECTDRAWSURFACE);
    STDMETHOD(EnumAttachedSurfaces)(THIS_ LPVOID,LPDDENUMSURFACESCALLBACK);
    STDMETHOD(EnumOverlayZOrders)(THIS_ DWORD,LPVOID,LPDDENUMSURFACESCALLBACK);
    STDMETHOD(Flip)(THIS_ LPDIRECTDRAWSURFACE, DWORD);
    STDMETHOD(GetAttachedSurface)(THIS_ LPDDSCAPS, LPDIRECTDRAWSURFACE FAR *);
    STDMETHOD(GetBltStatus)(THIS_ DWORD);
    STDMETHOD(GetCaps)(THIS_ LPDDSCAPS);
    STDMETHOD(GetClipper)(THIS_ LPDIRECTDRAWCLIPPER FAR*);
    STDMETHOD(GetColorKey)(THIS_ DWORD, LPDDCOLORKEY);    
    STDMETHOD(GetFlipStatus)(THIS_ DWORD);
    STDMETHOD(GetOverlayPosition)(THIS_ LPLONG, LPLONG );
    STDMETHOD(GetPalette)( THIS_ LPDIRECTDRAWPALETTE * );
    STDMETHOD(Initialize)(THIS_ LPDIRECTDRAW, LPDDSURFACEDESC);
    STDMETHOD(IsLost)(THIS);
    STDMETHOD(Restore)(THIS);
    STDMETHOD(SetClipper)(THIS_ LPDIRECTDRAWCLIPPER);
    STDMETHOD(SetColorKey)(THIS_ DWORD, LPDDCOLORKEY);
    STDMETHOD(SetOverlayPosition)(THIS_ LONG, LONG );
    STDMETHOD(SetPalette)(THIS_ LPDIRECTDRAWPALETTE);    
    STDMETHOD(UpdateOverlay)(THIS_ LPRECT, LPDIRECTDRAWSURFACE,LPRECT,DWORD, LPDDOVERLAYFX);
    STDMETHOD(UpdateOverlayDisplay)(THIS_ DWORD);
    STDMETHOD(UpdateOverlayZOrder)(THIS_ DWORD, LPDIRECTDRAWSURFACE);

		// CDDS:: Additions
	virtual HBITMAP  GetBitmap( void );
	virtual void     SetOrigin( int left, int top );
	virtual void     GetOrigin( int & left, int & top ) const;

 protected:
	ULONG			m_cRef;
	SIZE			m_size;
	BITMAPINFO256	m_bmi;
	LPVOID			m_pvBits;
	LONG			m_lBitCount;
    HBITMAP			m_hbmp;
	POINT			m_ptOrigin;
	HDC				m_hdcMem;
	HBITMAP			m_hbmpDCOld;
	int             m_ctDCRefs;

#ifdef _DEBUG
	int     m_ctLocks;
	LPVOID	m_pvLocked;
#endif // _DEBUG
};

} // end namespace IHammer


EXPORT long  BitCountFromDDPIXELFORMAT( const DDPIXELFORMAT & ddpf );


#endif //__SURFACE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\inc\typelib.h ===
// define_uuid macro - for ALL file types
#if defined(__MKTYPLIB__)
	#define define_uuid(uuidname, data1, data2, data3, d4_1, d4_2, d4_3, d4_4, d4_5, d4_6, d4_7, d4_8 ) // Nothing
#elif defined(__midl)
	#define define_uuid(uuidname, data1, data2, data3, d4_1, d4_2, d4_3, d4_4, d4_5, d4_6, d4_7, d4_8 ) \
		cpp_quote(stringify(EXTERN_C const IID uuidname;))
#elif defined(INITGUID)
	#define define_uuid(uuidname, data1, data2, data3, d4_1, d4_2, d4_3, d4_4, d4_5, d4_6, d4_7, d4_8 ) \
		EXTERN_C const GUID uuidname = \
		{ 0x##data1, 0x##data2, 0x##data3, { 0x##d4_1, 0x##d4_2, 0x##d4_3, 0x##d4_4, 0x##d4_5, 0x##d4_6, 0x##d4_7, 0x##d4_8 } };
#else // C or C++ file (Ok if done more than once)
	#define define_uuid(uuidname, data1, data2, data3, d4_1, d4_2, d4_3, d4_4, d4_5, d4_6, d4_7, d4_8 ) \
		EXTERN_C const GUID uuidname;
#endif


// **************
// **************
// **************
// macros - for ODL files
#ifndef stringify
	#define stringify(s) #s
#endif
#define GuidToString(guid)	stringify({guid})
#define CD_GUID(a)	GuidToString(a)



// ************************************************************
// ** Custom Data IDs
// ************************************************************

// CDID_ICParameterPage {708B33C1-657E-11d0-840C-00AA00BB8085}
define_uuid(CDID_ICParameterPage, 708B33C1,657E,11d0,84,0C,00,AA,00,BB,80,85)
#if defined(__midl) || defined(__MKTYPLIB__)
	#define CDID_ICParameterPage	708B33C1-657E-11d0-840C-00AA00BB8085
#endif


define_uuid(CLSID_NoParamsPage, AE56BEE5L,5403,11D0,84,0C,00,AA,00,BB,80,85)
#if defined(__midl) || defined(__MKTYPLIB__)
#define CLSID_NoParamsPage  AE56BEE5L-5403-11D0-84-0C-00-AA-00-BB-80-85
#endif

 

// **************
// **************
// **************
//	[
//	    uuid(0DA5AD44-3C2A-11d0-A069-00C04FD5C929),
//		IC_ADDIN_CODE( s:\\app\\features\\arrange\\ICArrange.vbp, ICArrange ),
//		helpstring( "Arrange events")
//	]
//	dispinterface IICArrangeAddInEvents
//	{
//		properties:
//		methods:
//
//			[
//				id(1),
//				custom(CDID_ICParameterPage, CD_GUID(<CLSID>)),
//				helpstring("Bring to front of the composition.")
//			]
//			void BringToFront();
//	}
//

#ifdef PARAMPGS_IN_TYPELIB

// Only want these when compliling C++
#ifndef __MKTYPLIB__
#ifndef __midl

EXPORT HRESULT GetFuncCustDataGUID( ITypeInfo2 *pTypeInfo, INT uiFuncIndex, REFCDID rCdid, GUID *pGuidData );
EXPORT HRESULT VariantToGUID( VARIANT *pvGuid, GUID *pGuid );


#endif // __midl
#endif // __MKTYPLIB__

#endif // PARAMPGS_IN_TYPELIB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\inc\unknown.h ===
#ifndef __UNKNOWN_H__
#define __UNKNOWN_H__

/*
****************************************************************************
*
*
*
*
*
*
*
*
*
*
*
*
****************************************************************************
*/

#ifndef INONDELEGATINGUNKNOWN_DEFINED
#undef  INTERFACE
#define INTERFACE INonDelegatingUnknown
DECLARE_INTERFACE(INonDelegatingUnknown)
{
    STDMETHOD(NonDelegatingQueryInterface) (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG, NonDelegatingAddRef)(THIS) PURE;
    STDMETHOD_(ULONG, NonDelegatingRelease)(THIS) PURE;
};
#define INONDELEGATINGUNKNOWN_DEFINED
#endif

typedef interface INonDelegatingUnknown *LPNONDELEGATINGUNKNOWN;

class CUnknown : public INonDelegatingUnknown, public IUnknown
{
protected:
	ULONG	m_cRef;
	LPUNKNOWN m_pUnkOuter;

public:
	CUnknown(LPUNKNOWN pUnkOuter)
	{ 
		m_cRef = 1;
		m_pUnkOuter = 
			pUnkOuter ? pUnkOuter : (LPUNKNOWN)((LPNONDELEGATINGUNKNOWN)this);
		InterlockedIncrement((LPLONG)&g_cLock);
	}
	virtual ~CUnknown() 
	{
		InterlockedDecrement((LPLONG)&g_cLock);
	}

    /* INonDelegatingUnknown Methods */
    STDMETHOD(NonDelegatingQueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) 
	{
    	if (IsEqualGUID(riid, IID_IUnknown))
	    {
	        *ppvObj = (LPUNKNOWN) (LPNONDELEGATINGUNKNOWN)this;
			(*(LPUNKNOWN*)ppvObj)->AddRef();
	        return(NOERROR);
	    }
	    *ppvObj = NULL;
	    return(E_NOINTERFACE);
	}

	STDMETHOD_(ULONG,NonDelegatingAddRef)(THIS)
	{
		LONG cRef = InterlockedIncrement((LPLONG)&m_cRef);
		return(cRef);
	}
	
	STDMETHOD_(ULONG,NonDelegatingRelease) (THIS)
	{
		LONG cRef = InterlockedDecrement((LPLONG)&m_cRef);
		if (0 == cRef)
		{
		 	delete this;
		}
		return cRef;
	}

    /* IUnknown Methods */
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) 
		{return m_pUnkOuter->QueryInterface(riid, ppvObj);}
    STDMETHOD_(ULONG,AddRef)  (THIS)
		{return m_pUnkOuter->AddRef();}
    STDMETHOD_(ULONG,Release) (THIS)
		{return m_pUnkOuter->Release();}
};

#endif //__UNKNOWN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\inc\webdc.h ===
//+-------------------------------------------------------------------------
//
//  webdc.h
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1996.
//
//--------------------------------------------------------------------------

#ifndef __webdc_h__
#define __webdc_h__


// CATID_WebDesigntimeControl
//
//   Controls that implement this CATID are used at design-time and support authoring textual
//   web content (e.g. HTML, JScript, VBScript). They implement the IActiveDesigner interface
//   and persist their runtime representation as text via
//   IActiveDesigner::SaveRuntimeState(IID_IPersistTextStream, IID_IStream, pStream)
//
// { 73cef3dd-ae85-11cf-a406-00aa00c00940 }
DEFINE_GUID(CATID_WebDesigntimeControl, 0x73cef3dd, 0xae85, 0x11cf, 0xa4, 0x06, 0x00, 0xaa, 0x00, 0xc0, 0x09, 0x40);

// IID_IPersistTextStream
//
// { 56223fe3-d397-11cf-a42e-00aa00c00940 }
DEFINE_GUID(IID_IPersistTextStream, 0x56223fe3, 0xd397, 0x11cf, 0xa4, 0x2e, 0x00, 0xaa, 0x00, 0xc0, 0x09, 0x40);

// IID_IProvideRuntimeText
// {56223FE1-D397-11cf-A42E-00AA00C00940}
DEFINE_GUID(IID_IProvideRuntimeText, 0x56223fe1, 0xd397, 0x11cf, 0xa4, 0x2e, 0x0, 0xaa, 0x0, 0xc0, 0x9, 0x40);


#ifndef __MSWDCTL_LIBRARY_DEFINED__
#define __MSWDCTL_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: MSWDCTL
 * at Mon Oct 07 16:35:01 1996
 * using MIDL 3.00.45
 ****************************************/
/* [version][lcid][helpstring][uuid] */ 


///////////////////////////////////////////////////////////////////////////////
// IPersistTextStream Interface
// 
///////////////////////////////////////////////////////////////////////////////
// IProvideRuntimeText Interface
// 

EXTERN_C const IID LIBID_MSWDCTL;

#ifndef __IPersistTextStream_INTERFACE_DEFINED__
#define __IPersistTextStream_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IPersistTextStream
 * at Mon Oct 07 16:35:01 1996
 * using MIDL 3.00.45
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IPersistTextStream;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IPersistTextStream : public IPersistStreamInit
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IPersistTextStreamVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IPersistTextStream __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IPersistTextStream __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IPersistTextStream __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetClassID )( 
            IPersistTextStream __RPC_FAR * This,
            /* [out] */ CLSID __RPC_FAR *pClassID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsDirty )( 
            IPersistTextStream __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Load )( 
            IPersistTextStream __RPC_FAR * This,
            /* [in] */ LPSTREAM pStm);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Save )( 
            IPersistTextStream __RPC_FAR * This,
            /* [in] */ LPSTREAM pStm,
            /* [in] */ BOOL fClearDirty);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSizeMax )( 
            IPersistTextStream __RPC_FAR * This,
            /* [out] */ ULARGE_INTEGER __RPC_FAR *pCbSize);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InitNew )( 
            IPersistTextStream __RPC_FAR * This);
        
        END_INTERFACE
    } IPersistTextStreamVtbl;

    interface IPersistTextStream
    {
        CONST_VTBL struct IPersistTextStreamVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPersistTextStream_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPersistTextStream_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPersistTextStream_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPersistTextStream_GetClassID(This,pClassID)	\
    (This)->lpVtbl -> GetClassID(This,pClassID)


#define IPersistTextStream_IsDirty(This)	\
    (This)->lpVtbl -> IsDirty(This)

#define IPersistTextStream_Load(This,pStm)	\
    (This)->lpVtbl -> Load(This,pStm)

#define IPersistTextStream_Save(This,pStm,fClearDirty)	\
    (This)->lpVtbl -> Save(This,pStm,fClearDirty)

#define IPersistTextStream_GetSizeMax(This,pCbSize)	\
    (This)->lpVtbl -> GetSizeMax(This,pCbSize)

#define IPersistTextStream_InitNew(This)	\
    (This)->lpVtbl -> InitNew(This)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPersistTextStream_INTERFACE_DEFINED__ */


#ifndef __IProvideRuntimeText_INTERFACE_DEFINED__
#define __IProvideRuntimeText_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IProvideRuntimeText
 * at Mon Oct 07 16:35:01 1996
 * using MIDL 3.00.45
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IProvideRuntimeText;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IProvideRuntimeText : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetRuntimeText( 
            /* [retval][out] */ BSTR __RPC_FAR *pstrRuntimeText) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IProvideRuntimeTextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IProvideRuntimeText __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IProvideRuntimeText __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IProvideRuntimeText __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRuntimeText )( 
            IProvideRuntimeText __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pstrRuntimeText);
        
        END_INTERFACE
    } IProvideRuntimeTextVtbl;

    interface IProvideRuntimeText
    {
        CONST_VTBL struct IProvideRuntimeTextVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IProvideRuntimeText_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IProvideRuntimeText_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IProvideRuntimeText_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IProvideRuntimeText_GetRuntimeText(This,pstrRuntimeText)	\
    (This)->lpVtbl -> GetRuntimeText(This,pstrRuntimeText)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IProvideRuntimeText_GetRuntimeText_Proxy( 
    IProvideRuntimeText __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pstrRuntimeText);


void __RPC_STUB IProvideRuntimeText_GetRuntimeText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IProvideRuntimeText_INTERFACE_DEFINED__ */

#endif /* __MSWDCTL_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
//}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\inc\utils.h ===
#ifndef __UTILS_H__
#define __UTILS_H__

// Repository for commonly used macros & classes.

#pragma intrinsic(memcpy,memcmp,strcpy,strcmp)

#ifndef EXPORT
#define EXPORT __declspec(dllexport)
#endif

#ifndef QI_Base
	// Use this macro to assign to ppv in
	// your QueryInterface implementation.
	// It's preferred over just casting 'this'
	// because casting does no type-checking,
	// allowing your QI to return interfaces
	// from which your 'this' isn't derived.
	// With QI_Base, you'll get a compiler error.
  #define QI_Base( T, pObj, ppv ) \
  { T * pT = pObj;  *ppv = (void *)pT; }
#endif // QI_Base


#ifndef RELEASE_OBJECT

#define RELEASE_OBJECT(ptr)\
{ \
	Proclaim(ptr); \
	if (ptr)\
	{\
		IUnknown *pUnk = (ptr);\
		(ptr) = NULL;\
		 ULONG cRef = pUnk->Release();\
	}\
}

#endif // RELEASE_OBJECT

#ifndef ADDREF_OBJECT
#define ADDREF_OBJECT(ptr)\
{\
	Proclaim(ptr);\
    if (ptr)\
	{\
		(ptr)->AddRef();\
	}\
}

#endif // ADDREF_OBJECT




#endif	// __UTILS_H__


// End of Utils.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\inc\urlarchv.h ===
#ifndef _INC_URLARCHV_H
#define _INC_URLARCHV_H

#ifndef __urlmon_h__
  #include <urlmon.h>
#endif // __urlmon_h__

#ifndef EXPORT
  #define EXPORT __declspec( dllexport )
#endif // EXPORT

// -----------------------------
    
class CURLArchive
{
public:
    enum origin { start   = STREAM_SEEK_SET,
                  current = STREAM_SEEK_CUR,
                  end     = STREAM_SEEK_END };

public:
    EXPORT CURLArchive( IUnknown * pUnk = NULL );
    EXPORT virtual ~CURLArchive();

        // Opens or creates the file szURL
    EXPORT virtual HRESULT Create( LPCSTR szURL );

    EXPORT virtual HRESULT Create( LPCWSTR szwURL );    

        // Closes the file
    EXPORT virtual HRESULT Close( );

    EXPORT virtual HRESULT GetFileSize( long & lSize );

        // For folks that just can't resist...
    EXPORT virtual IStream * GetStreamInterface( void ) const;

        // Reads bytes from the file.
        // 
    EXPORT virtual DWORD     Read( LPBYTE lpb,
                                   DWORD    ctBytes );

    EXPORT virtual DWORD     ReadLine( LPSTR lpstr,
                                       DWORD ctBytes );

    EXPORT virtual DWORD     ReadLine( LPWSTR lpstrw,
                                       DWORD  ctChars );

    EXPORT virtual long    Seek( long ctBytes, origin orig );

        // Writes bytes to the file.
        //
    EXPORT virtual DWORD     Write( LPBYTE lpb,
                           DWORD ctBytes );    

        // Make a local copy of the file
    EXPORT virtual HRESULT CopyLocal( LPSTR szLocalFile, int ctChars );
    EXPORT virtual HRESULT CopyLocal( LPWSTR szwLocalFile, int ctChars );    

private:
    CURLArchive( const CURLArchive & );
    CURLArchive & operator=( const CURLArchive & );

private:    
    IStream *   m_pStream;
    IUnknown *  m_pUnk;
};

#endif // _INC_URLARCHV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\inc\wndclass.h ===
/*-----------------------------------------------------------------------------
@doc    EXTERNAL
@module WndClass.h | This is a set location for all window class names
@comm   This file will simplify localization as these string will not show up in 
		cpp files when we do a string search. Saves time and makes one less file 
		to look through.
-----------------------------------------------------------------------------*/
// Do not localize this file
#ifndef _WND_CLASS
#define _WND_CLASS

// Do not localize these strings
#define szParameterFrameWindowClass "iHParameterFrameWindowClass" 
#define szTabWindowClass "iHTabWindowClass" 
#define szPagesWindowClass "iHPagesWindowClass"
const TCHAR szHamParamPgListItemInput[] = "CIHamParamPgListItemInput";
const TCHAR szHamParamPgListItemEsc[] = "CIHamParamPgListItemEsc";
const TCHAR szHamParamPgListItemEnter[] = "CIHamParamPgListItemEnter";
#define szTimeSpinCtrl "TimeSpinCtrl"
#define szUpdateTimingPgDataMsg "UpdateTimingPgDataMsg"
#define szUpdateTimePaneDataMsg "UpdateTimePaneDataMsg"

#endif _WND_CLASS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\srcodl\guids.cpp ===
// File to ensure various GUIDs are included in the library.  Before NT Build was used, we
// used initguid to define these.  With precompiled headers, this is difficult.

// SimonB, 10-29-1997

#include <objbase.h>
#include <initguid.h>

#include <transit.h>
#include <effect.h>
#include <htmlfilter.h>
#include <ddrawex.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\util\bfid_rgb.h ===
#ifndef UTIL_BFID_RGB_H_
#define UTIL_BFID_RGB_H_
/************************************
 *
 * bfid_rgb.h --
 * Defines the GUIDs for IBitmapSurface
 * bitmap-format-IDs, as extern declared
 * by trident's ocmm.h.
 *
 * This was stolen from mmctl\inc\ocmm.h,
 * their own private version.  
 * Imposter headers-- Great Fun!
 *
 ************************************/

DEFINE_GUID(BFID_MONOCHROME,    0xe436eb78, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);
DEFINE_GUID(BFID_RGB_4,         0xe436eb79, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);
DEFINE_GUID(BFID_RGB_8,         0xe436eb7a, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);
DEFINE_GUID(BFID_RGB_555,       0xe436eb7c, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);
DEFINE_GUID(BFID_RGB_565,       0xe436eb7b, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);
DEFINE_GUID(BFID_RGB_24,        0xe436eb7d, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);
DEFINE_GUID(BFID_RGB_32,        0xe436eb7e, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);

#endif // UTIL_BFID_RGB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\util\cstring.cpp ===
// Fossil file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\util\debug.cpp ===
/*********************************************************
MODULE: DEBUG.CPP
AUTHOR: Outlaw

summer '93

DESCRIPTION: Contains a debugging functions.
**********************************************************/

#include "utilpre.h"

BOOL vfEcho=FALSE;
UINT uWndProcMinParam = 0;
UINT uWndProcMaxParam = 0;


VOID EXPORT FAR CDECL RetailEcho(LPSTR lpstrFormat, ...)
{
    if (!vfEcho)
        return;

    char rgch[128], rgchOutput[256];
	va_list ap;

	va_start( ap, lpstrFormat);
    wsprintf((LPSTR)rgch, "%s\n", lpstrFormat);
    wvsprintf(rgchOutput, (LPSTR)rgch, ap);
    OutputDebugString(rgchOutput);
}

#ifdef _DEBUG

char rgch[128];
char rgchOutput[256];

VOID EXPORT FAR CDECL OldEcho(LPSTR lpstrFormat, ...)
{
    if (!vfEcho)
        return;

 	va_list ap;

	va_start( ap, lpstrFormat);
	wsprintf((LPSTR)rgch, "%s\n", lpstrFormat);
	wvsprintf(rgchOutput, (LPSTR)rgch, ap);
    OutputDebugString(rgchOutput);
}

// FUNCTION WE EXPAND "ProclaimMessage()" TO; PUTS UP ASSERTION DIALOG AND ALSO GENERATES DEBUGGER BREAK
void EXPORT WINAPI AssertDebugBreakMessage(BOOL f, LPSTR lpstrAssert, LPSTR lpstrFile, UINT uLine, LPSTR lpMessage)
{
    if (!f)
    {
    	int	id;

        if(lpMessage)
		{
			wsprintf(rgchOutput, "\"%s\"\n\n%s, line %u\n%s", (LPSTR)lpstrAssert, (LPSTR)lpstrFile, (UINT)uLine, (LPSTR)lpMessage);
		}
		else
		{
			wsprintf(rgchOutput, "\"%s\"\n\n%s, line %u", (LPSTR)lpstrAssert, (LPSTR)lpstrFile, (UINT)uLine);
		}

        id = MessageBox(NULL, rgchOutput, "Assertion failed! break into the debugger?", MB_YESNOCANCEL | MB_ICONEXCLAMATION | MB_SYSTEMMODAL);

		switch(id)
		{
    		case IDYES:
	    		DebugBreak();
			break;

    		case IDNO:
			break;

	    	case IDCANCEL:
            {
        	    char *pchGPF = NULL;
    			*pchGPF = 0;
            }
			break;
		}
    }
}

// FUNCTION WE EXPAND "Proclaim()" TO; PUTS UP ASSERTION DIALOG AND ALSO GENERATES DEBUGGER BREAK
void EXPORT WINAPI AssertDebugBreak(BOOL f, LPSTR lpstrAssert, LPSTR lpstrFile, UINT uLine)
{
	AssertDebugBreakMessage(f, lpstrAssert, lpstrFile, uLine, NULL);
}

long cTestFail = 0;
long cTestFailT = 0;
BOOL fMemSim = FALSE;
void EXPORT WINAPI InitMemFailSim(BOOL	fFail)
{
	fMemSim = fFail;
	cTestFail = cTestFailT = 0;
}
BOOL	 EXPORT WINAPI FMemFailOn()
{
	return(fMemSim);
}
void SetCountMemFailSim(long cFail)
{
	if(cFail < 0)
		cFail = 0;
	cTestFail = cTestFailT = cFail;
	fMemSim = TRUE;
}
long CFailGetMemFailSim()
{
	return(fMemSim ? cTestFail : 0);
}
void  EXPORT WINAPI ResetAndIncMemFailSim()
{
	cTestFail++;
	cTestFailT = cTestFail;
}
// Return value: True means memory allocation failed.
BOOL FFailMemFailSim()
{
	if(!fMemSim)
		return(FALSE);
	if(!cTestFailT)
		return(TRUE);
	--cTestFailT;
	return(FALSE);
}


void SetWndProcParamsRange ( UINT uMin, UINT uMax )
{
	uWndProcMinParam = uMin;
	uWndProcMaxParam = uMax;
}


void ShowWndProcParams ( HINSTANCE hInst, LPCSTR name, HWND hwnd, UINT message, UINT wParam, LONG lParam )
{
	BOOL	fOldEcho;
    char	rchOutput[256];
	char	rchMsg[64];
	static BOOL fFirstCall = TRUE;

	if ( ( 0 == uWndProcMinParam ) && ( 0 == uWndProcMaxParam ) )
	{
		return;
	}

	if ( ( message < uWndProcMinParam ) || ( message > uWndProcMaxParam ) )
	{
		return;
	}

	fOldEcho = vfEcho;
	vfEcho = TRUE;
	if ( fFirstCall )
	{
		fFirstCall = FALSE;
		RetailEcho ( "Function Name\tMessage\tMessage ID\thWnd\twParam\tlParam" );
	}

	LoadString ( hInst, message, rchMsg, 63 );
	if ( 0 == strlen ( rchMsg ) )
	{
		_ltoa ( message, rchMsg, 10 );
	}

	wsprintf((LPSTR)rchOutput, "%s\t%s", name, "%s\t%li\t0x%lX\t0x%lX\t0x%lX" );

	RetailEcho ( rchOutput, rchMsg, message, hwnd, wParam, lParam );

	vfEcho = fOldEcho;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\util\dll.cpp ===
/*=========================================================================*\

    File    : dll.cpp
    Purpose : DLL entry point
    Author  : Simon Bernstein (simonb)
    Date    : 04/29/97

\*=========================================================================*/
#include <windows.h>
#include <locale.h>

BOOL APIENTRY DllMain(HANDLE hModule, DWORD dwReason, LPVOID lpReserved)
{
    switch( dwReason ) 
	{
		case DLL_PROCESS_ATTACH:
		{
			// Set the locale to the default, which is the 
			// system-default ANSI code page.  
			setlocale( LC_ALL, "" );
		}
		break;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\util\dither.cpp ===
/*
********************************************************************
*
*
*
*
*
*
*
********************************************************************
*/

#include "utilpre.h"
#include <htmlfilter.h>
#include <minmax.h>

#define DITHER_IMPL
#include <dither.h>
#include <ddraw.h>
#include <quickie.h>

#ifdef _DEBUG
  #pragma optimize( "", on )
#else
  #pragma optimize( "agty", on )
#endif // _DEBUG

#define RED_LEVELS   5
#define GREEN_LEVELS 5
#define BLUE_LEVELS  5
#define RED_SHADES   (1 << CHalftonePalette::significant_bits)
#define GREEN_SHADES (1 << CHalftonePalette::significant_bits)
#define BLUE_SHADES  (1 << CHalftonePalette::significant_bits)

#define BGRA_ALPHA       3
#define BGRA_RED         2
#define BGRA_GREEN       1
#define BGRA_BLUE        0

inline int INT_MULT( BYTE a, int b )
{  
        int temp = (a*b) + 128;
        return ((temp>>8) + temp)>>8;
}

static g_i4x4[PATTERN_COLS][PATTERN_ROWS]=
   {{-7, 1,-5, 3},
        { 5,-3, 7,-1},
        {-4, 4,-6, 2},
        { 8, 0, 6,-2}};


// -------------------------------------------------

DLINKAGE CHalftonePalette::CHalftonePalette( )
{
        m_logpal.palVersion = 0x0300;
        m_logpal.palNumEntries = 0;
}


DLINKAGE CHalftonePalette::CHalftone