g
            //  Framing errors are ignored.
            //
            if (!(flags_count & RXDESC_ERR) || (flags_count & RXDESC_FRAM)) {
                //
                // A packet was received successfully.
                // Pass it upstream for processing.
                //
                // Note: we expect the processing to be done
                // synchronously here and the upstream component
                // we'll call CompletePacket on our packet
                // inside the following call.
                //

                NicStats.rxGoodFrames++;
                pkt->datalen = flags_count & 0xffff;

                // NOTE: Workaround for hardware bug
                //  If extra byte flag is set, decrement the frame length by 1
                if (flags_count & RXDESC_FRAM) {
                    NicStats.rxFramingErrors++;
                    if (flags_count & RXDESC_EXTRA) {
                        NicStats.rxExtraByteErrors++;
                        pkt->datalen--;
                    }
                }

                // BUGBUG: workaround for nv2a hardware bug
                #ifndef DVTSNOOPBUG

                EnetReceiveFrame(nic, pkt);

                #else // DVTSNOOPBUG

                {
                    UINT len = pkt->datalen;
                    Packet* p = (Packet*) NicTempRecvBuffer;

                    p->nextpkt = NULL;
                    p->pktflags = p->iphdrOffset = 0;
                    p->data = p->buf;
                    p->datalen = len;
                    p->recvifp = (IfInfo*) nic;
                    p->completionCallback = NicTempRecvBufferPktCompletion;
                    memcpy(p->data, pkt->data, len);

                    NicRecvBufferPktCompletion(pkt, NETERR_OK);
                    EnetReceiveFrame(nic, p);
                }

                #endif // DVTSNOOPBUG
            } else {
                if (flags_count & RXDESC_OFOL) NicStats.rxOverFlowErrors++;
                if (flags_count & RXDESC_CRC ) NicStats.rxCrcErrors++;
                if (flags_count & RXDESC_LFER) NicStats.rxLengthErrors++;
                if (flags_count & RXDESC_MAX ) NicStats.rxMaxFrameErrors++;
                if (flags_count & RXDESC_LCOL) NicStats.rxLateCollisions++;
                if (flags_count & RXDESC_RUNT) NicStats.rxRunts++;
            }
        } else {
            NicStats.rxEndOfFrameErrors++;
        }

        // Give the ownership of the receive descriptor back to the NIC
        // And tell the receiver to check the receive descriptor ring
        ASSERT(bufdesc->phyaddr == MmGetPhysicalAddress(pkt->data));
        PktQInsertTail(&nic->recvq, pkt);
        bufdesc->flags_count = RXDESC_OWN | (DMAPKT_MAXDATA - 1);

        // Move on to the next receive descriptor
        if (++bufdesc == nic->cmdbuf.rxend)
            bufdesc = nic->cmdbuf.rxstart;
    }

    // Update the next receive descriptor pointer
    nic->cmdbuf.rxptr = bufdesc;
}


PRIVATE VOID
NicCheckMiiStatus(
    IfEnet* nic,
    DWORD mintr,
    BOOL init
    )

/*++

Routine Description:

    Check the PHY status

Arguments:

    nic - Points to the NIC data structure
    mintr - MII interrupt bits
    init - Whether this is the first call after reboot
        (Tx and Rx are currently stopped)

Return Value:

    NONE

--*/

{
    PNIC_CSR csr = nic->CSR;
    DWORD miics = csr->mii_cs;
    DWORD delta = nic->linkStatus ^ miics;

    if (init || ((mintr & MINTR_MAPI) && (delta & MIICS_LS) && (miics & MIICS_LS))) {
        DWORD linkState = PhyGetLinkState(!init);

        // BUGBUG: always dump out Ethernet link status for now
        #if DBG
        DbgPrint("Ethernet link status: %s %dMbps %s-duplex\n",
            (linkState & XNET_LINK_IS_UP) ? "up" : "down",
            (linkState & XNET_LINK_100MBPS) ? 100 :
                (linkState & XNET_LINK_10MBPS) ? 10 : 0,
            (linkState & XNET_LINK_FULL_DUPLEX) ? "full" :
                (linkState & XNET_LINK_HALF_DUPLEX) ? "half" : "?");
        #endif

        // NOTE: When the link was up before, we need to stop
        // both Tx and Rx and then set Rx polling frequency
        // and Tx duplex mode according to the link status.

        if (!init) {
            NicStopXmitRecv(nic, -1);
        }

        nic->rxpollFreq = (linkState & XNET_LINK_10MBPS) ?
                                RXPOLL_FREQ_10MPS :
                                RXPOLL_FREQ_100MPS;

        if (linkState & XNET_LINK_FULL_DUPLEX)
            csr->tx_cntl &= ~TXCNTL_HDEN;
        else
            csr->tx_cntl |= TXCNTL_HDEN;

        if (!init) {
            NicStartXmitRecv(csr, nic->rxpollFreq);
        }

        if (init && (linkState & XNET_LINK_IS_UP))
            nic->flags |= IFFLAG_CONNECTED_BOOT;
    }

    nic->linkStatus = miics;
}


//
// Check if transmit descriptor td2 is the last one used
// to transmit an Ethernet frame that started at td1.
//
INLINE BOOL IsEndXmitDesc(IfEnet* nic, NicBufDesc* td1, NicBufDesc* td2) {
    if (td1 == td2) return TRUE;
    if (td1->flags_count & TXDESC_TEND) return FALSE;
    if (++td1 == nic->cmdbuf.txend)
        td1 = nic->cmdbuf.txstart;
    return (td1 == td2);
}


PRIVATE BOOL
NicProcessXmitInterrupt(
    IfEnet* nic
    )

/*++

Routine Description:

    Process transmit interrupts

Arguments:

    nic - Points to the NIC data structure

Return Value:

    TRUE if we processed any transmit completion interrupts
    FALSE otherwise

--*/

{
    NicBufDesc* bufdesc;
    Packet* pkt;
    DWORD flags_count;
    NTSTATUS status;
    BOOL processed = FALSE;
    
    // Loop through uncompleted transmission queue
    while (pkt = nic->cmdq.head) {
        bufdesc = (NicBufDesc*) pkt->ifdata;
        if ((flags_count = bufdesc->flags_count) & TXDESC_OWN) break;

        processed = TRUE;
        PktQRemoveHead(&nic->cmdq);
        nic->cmdqCount--;
        nic->cmdqWatchdog = 0;
        NicUnlockPacketPages(pkt);

        ASSERT(flags_count & TXDESC_TEND);
        if (!(flags_count & TXDESC_ERR)) {
            NicStats.txGoodFrames++;
            status = NETERR_OK;
        } else {
            if (flags_count & TXDESC_UFLO) NicStats.txUnderflowErrors++;
            if (flags_count & TXDESC_LCOL) NicStats.txLateCollisions++;
            if (flags_count & TXDESC_LCAR) NicStats.txLostCarriers++;
            if (flags_count & TXDESC_DEF) NicStats.txDefers++;
            if (flags_count & TXDESC_EXDEF) NicStats.txExcessiveDefers++;
            if (flags_count & TXDESC_RTRY) NicStats.txRetryErrors++;

            status = NETERR_HARDWARE;
        }
        COMPLETEPACKET(pkt, status);

        // Update the uncompleted transmit descriptor pointer
        ASSERT(IsEndXmitDesc(nic, nic->cmdbuf.txtail, bufdesc));
        ASSERT((nic->cmdbuf.txtail->flags_count & TXDESC_OWN) == 0);
        bufdesc++;
        nic->cmdbuf.txtail = (bufdesc == nic->cmdbuf.txend) ? nic->cmdbuf.txstart : bufdesc;
    }

    return processed;
}


VOID
NicWaitForXmitQEmpty(
    IfEnet* nic
    )

/*++

Routine Description:

    Wait until the transmit queue is empty
    This is only called by the debug monitor when the regular net stack is unloaded.

Arguments:

    nic - Points to the NIC data structure

Return Value:

    NONE

--*/

{
    UINT timeout = 0;
    while (!PktQIsEmpty(&nic->cmdq)) {
        NicProcessXmitInterrupt(nic);
        KeStallExecutionProcessor(50);

        timeout++;
        ASSERT(timeout < 20000);
    }
}


PRIVATE VOID
NicInterruptDpc(
    PKDPC dpc,
    PVOID deferredContext,
    PVOID noReenable,
    PVOID arg2
    )

/*++

Routine Description:

    Ethernet interface interrupt service routine
    (runs at DISPATCH_LEVEL)

Arguments:

    dpc - Pointer to the DPC object
    deferredContext - Points to the NIC data structure
    noReenable - Leave interrupts disabled
    arg2 - Unused arguments

Return Value:

    NONE

--*/

{
    IfEnet* nic = (IfEnet*) deferredContext;
    PNIC_CSR csr = nic->CSR;

    NicStats.dpcCount++;
    while (TRUE) {
        DWORD mintr = csr->mintr;
        DWORD intr = csr->intr;

        // Acknowledge all pending interrupts
        //  note that we need to acknowledge MII interrupts first
        if (intr == 0) break;
        csr->mintr = mintr;
        csr->intr = intr;

        if (intr & INTR_MINT) {
            // Process MII interrupt
            NicCheckMiiStatus(nic, mintr, FALSE);
        }

        if (intr & (INTR_MISS|INTR_RCINT|INTR_REINT)) {
            // Process any received packets
            NicProcessRecvInterrupt(nic);
            if (intr & INTR_MISS) {
                csr->mode = MODE_RXDM;
                NicStats.rxMissedFrames++;
            }
        }

        if (intr & (INTR_TCINT|INTR_TEINT)) {
            // Process any completed transmissions
            NicProcessXmitInterrupt(nic);

            // If there is more room now in the command queue, we can
            // move some packets from the send queue to the command queue.
            if (!EnetIsSendQEmpty(nic) && nic->cmdqCount < cfgXmitQLength) {
                EnetStartOutput(nic);
            }
        }
    }

    // Reenable interrupts
    if (!noReenable) {
        NicEnableInterrupt();
    }
}


PRIVATE BOOLEAN
NicIsr(
    PKINTERRUPT interrupt,
    PVOID serviceContext
    )

/*++

Routine Description:

    Ethernet interrupt service routine (runs at DIRQL)

Arguments:

    interrupt - Interrupt object
    serviceContext - Points to the NIC data structure

Return Value:

    TRUE if the interrupt was handled
    FALSE if the interrupt wasn't generated by our device

--*/

{
    IfEnet* nic = (IfEnet*) serviceContext;

    NicStats.isrCount++;
    if ((nic->CSR->intr & nic->CSR->intr_mk) == 0)
        return FALSE;

    // Yep, this is ours:
    //  schedule the DPC routine for execution
    //  and disable further interrupts
    KeInsertQueueDpc(&nic->dpc, NULL, NULL);
    NicDisableInterrupt();
    return TRUE;
}


VOID
NicTimerProc(
    IfEnet* nic
    )

/*++

Routine Description:

    NIC timer procedure

Arguments:

    nic - Points to the NIC data structure

Return Value:

    NONE

--*/

{
    // If the transmitter is stuck, start it
    if (!PktQIsEmpty(&nic->cmdq) && nic->cmdqWatchdog++ > 2) {
        WARNING_("Transmitter is stuck.");
        nic->cmdqWatchdog = 0;
        NicStats.txStuckXmits++;

        NicProcessXmitInterrupt(nic);
        nic->CSR->mode = MODE_TXDM;
    }
}


VOID
NicTransmitFrame(
    IfEnet* nic,
    Packet* pkt
    )

/*++

Routine Description:

    Transmit an Ethernet frame to the NIC

Arguments:

    nic - Points to the NIC data structure
    pkt - Points to the frame to be transmitted
        We assume the Ethernet frame has been completed filled out.

Return Value:

    NONE

--*/

{
    UINT_PTR phyaddr0;
    UINT len, len0;
    NicBufDesc* bufdesc;

    // Make sure we have at least 2 transmit descriptors available
    len = (nic->cmdbuf.txtail <= nic->cmdbuf.txhead) ?
            (NicXmitDescCount - (nic->cmdbuf.txhead - nic->cmdbuf.txtail)) :
            (nic->cmdbuf.txtail - nic->cmdbuf.txhead);
    
    if (len <= 2) {
        WARNING_("Out of transmit descriptors.");
        COMPLETEPACKET(pkt, NETERR_MEMORY);
        return;
    }

    // Check the packet data size
    ASSERT(pkt->datalen != 0);
    if (pkt->datalen > ENETHDRLEN+ENET_MAXDATASIZE) {
        COMPLETEPACKET(pkt, NETERR_MSGSIZE);
        return;
    }

    NicLockPacketPages(pkt);

    // Since the total buffer size is <= 1500+14 bytes,
    // it can at most span two physical pages.
    len = pkt->datalen;
    phyaddr0 = MmGetPhysicalAddress(pkt->data);
    len0 = PAGE_SIZE - (phyaddr0 & (PAGE_SIZE-1));

    if (len <= len0) {
        // The buffer is in a single physical page.
        // We only need one transmit descriptor here.
        //
        // Notice the funny len-1 business below.
        // This is an odd requirement of the NIC.
        bufdesc = nic->cmdbuf.txhead;
        bufdesc->phyaddr = phyaddr0;
        bufdesc->flags_count = TXDESC_OWN | TXDESC_TEND | (len-1);
    } else {
        // The buffer straddles page boundary.
        // So we need two transmit descriptors.
        NicBufDesc* bufdesc0 = nic->cmdbuf.txhead;

        bufdesc = bufdesc0+1;
        if (bufdesc == nic->cmdbuf.txend)
            bufdesc = nic->cmdbuf.txstart;

        // NOTE: We're setting up the second transmit descriptor
        // before the first one. Otherwise, the NIC might use up
        // the first descriptor before we have the second one ready.
        bufdesc->phyaddr = MmGetPhysicalAddress(pkt->data + len0);
        bufdesc->flags_count = TXDESC_OWN | TXDESC_TEND | (len-len0-1);
        bufdesc0->phyaddr = phyaddr0;
        bufdesc0->flags_count = TXDESC_OWN | (len0-1);
    }

    pkt->ifdata = (UINT_PTR) bufdesc;
    PktQInsertTail(&nic->cmdq, pkt);
    nic->cmdqCount++;

    // Tell the transmitter to check the transmit descriptor ring
    nic->CSR->mode = MODE_TXDM;

    bufdesc++;
    nic->cmdbuf.txhead = (bufdesc == nic->cmdbuf.txend) ? nic->cmdbuf.txstart : bufdesc;
}


//
// Tell the NIC to not to receive any multicast frames
//
INLINE VOID NicRecvMcastNone(PNIC_CSR csr) {
    csr->mult_mk0 = 0;
    csr->mult_mk1 = 0;
    csr->mult0 = 1;
    csr->mult1 = 0;
}


NTSTATUS
NicSetMcastAddrs(
    IfEnet* nic,
    const BYTE* addrs,
    UINT count
    )

/*++

Routine Description:

    Send multicast addresses down to the NIC.

Arguments:

    nic - Points to the NIC data structure
    addrs - Points to an array of multicast addresses
    count - Specifies the number of multicast addresses

Return Value:

    Status code

--*/

// Converting Ethernet address from a sequence of bytes
// to two DWORDs that can be set into UNIn and MULTn registers
#define HWADDR0(_hwaddr) ((const DWORD*) (_hwaddr))[0]
#define HWADDR1(_hwaddr) ((const WORD*) (_hwaddr))[2]

{
    PNIC_CSR csr = nic->CSR;

    // Stop the controller from transmitting and receiving
    NicStopXmitRecv(nic, 1);

    if (count == 0) {
        // Don't receive any multicast frames
        NicRecvMcastNone(csr);
    } else {
        // Compute the multicast address filter values.
        // Notice that the filtering here is not perfect.
        // Exactly filtering is done inside IP receive function.

        DWORD andMask0 = -1;
        DWORD orMask0 = 0;
        WORD andMask1 = -1;
        WORD orMask1 = 0;

        while (count--) {
            andMask0 &= HWADDR0(addrs);
            orMask0  |= HWADDR0(addrs);
            andMask1 &= HWADDR1(addrs);
            orMask1  |= HWADDR1(addrs);
            addrs += ENETADDRLEN;
        }

        orMask0 = andMask0 | ~orMask0;
        orMask1 = andMask1 | ~orMask1;

        csr->mult0 = andMask0;
        csr->mult1 = andMask1;
        csr->mult_mk0 = orMask0;
        csr->mult_mk1 = orMask1;
    }

    // Restart transmitter and receiver
    NicStartXmitRecv(csr, nic->rxpollFreq);
    NicEnableInterrupt();
    return NETERR_OK;
}


VOID
NicReset(
    IfEnet* nic,
    BOOL disconnectIntr
    )

/*++

Routine Description:

    Reset the network controller:
        disable transmit and receive
        disable all interrupts
        clear any pending interrupt bits

Arguments:

    nic - Points to the NIC data structure
    disconnectIntr - Whether to disconnect interrupts

Return Value:

    NONE

--*/

{
    PNIC_CSR csr = nic->CSR;

    // Stop transmitter and receiver
    NicStopXmitRecv(nic, 0);
    
    // Reset buffer management
    csr->mode = MODE_RESET_BUFFERS;
    KeStallExecutionProcessor(10);
    csr->mode = 0;
    KeStallExecutionProcessor(10);

    csr->intr_mk = 0;
    csr->mintr_mk = 0;
    csr->pm_cntl = 0;
    csr->swtr_cntl = 0;
    csr->tx_poll = 0;
    csr->rx_poll = 0;

    csr->tx_sta = csr->tx_sta;
    csr->rx_sta = csr->rx_sta;
    csr->intr = csr->intr;
    csr->mintr = csr->mintr;

    if (disconnectIntr) {
        NicDisconnectInterrupt(nic);
    }
}


PRIVATE NTSTATUS
NicInitBuffers(
    IfEnet* nic
    )

/*++

Routine Description:

    Initialize transmit and receive buffer descriptors

Arguments:

    nic - Points to the NIC data structure

Return Value:

    Status code

--*/

{
    BYTE* buf;
    NicBufDesc* bufdesc;
    UINT index;
    Packet* pkt;
    NTSTATUS status;

    status = NicPktPoolInit(cfgRecvQLength);
    if (!NT_SUCCESS(status)) return status;
    
    // Allocate one contiguous physical page
    buf = (BYTE*) NicAllocSharedMem(PAGE_SIZE);
    if (!buf) return NETERR_MEMORY;
    
    ZeroMem(buf, PAGE_SIZE);
    nic->cmdbuf.phyaddrOffset = MmGetPhysicalAddress(buf) - (UINT_PTR) buf;

    // First half page is used for transmit buffer descriptors
    nic->cmdbuf.txstart = (NicBufDesc*) buf;
    nic->cmdbuf.txend = nic->cmdbuf.txstart + NicXmitDescCount;
    nic->cmdbuf.txhead = nic->cmdbuf.txtail = nic->cmdbuf.txstart;

    // Second half page is used for receive buffer descriptors
    nic->cmdbuf.rxstart = (NicBufDesc*) (buf + PAGE_SIZE / 2);
    nic->cmdbuf.rxend = nic->cmdbuf.rxstart + cfgRecvQLength;
    nic->cmdbuf.rxptr = nic->cmdbuf.rxstart;

    // Allocate receive buffers
    bufdesc = nic->cmdbuf.rxstart;
    for (index=0; index < cfgRecvQLength; index++) {
        pkt = NicPktAlloc(index);
        pkt->data = GetPktFrameData(pkt);
        pkt->recvifp = (IfInfo*) nic;
        XnetSetPacketCompletion(pkt, NicRecvBufferPktCompletion);
        PktQInsertTail(&nic->recvq, pkt);

        bufdesc->phyaddr = NicPktGetPhyAddr(pkt->data);
        bufdesc->flags_count = RXDESC_OWN | (DMAPKT_MAXDATA - 1);
        bufdesc++;
    }

    return NETERR_OK;
}


PRIVATE NTSTATUS
NicReadEnetAddr(
    IfEnet* nic
    )

/*++

Routine Description:

    Read permanent Ethernet address

Arguments:

    nic - Points to the NIC data structure

Return Value:

    Status code

--*/

{
    DWORD err;
    ULONG type, size, tick0;

    err = XQueryValue(XC_FACTORY_ETHERNET_ADDR, &type, nic->hwaddr, ENETADDRLEN, &size);
    if (err != ERROR_SUCCESS || size != ENETADDRLEN) {
        // NOTE:
        // If we failed to read Ethernet address from non-volatile memory,
        // pick a random address among the first 32 addresses of
        // the 00-50-f2 address block. This is so that we can at least boot
        // on the manufacturing line and start communicating with the test server.

        #ifdef DEVKIT
        DbgPrint("########## Invalid Ethernet address:\n");
        DbgPrint("  You must run the Recovery CD.\n");
        DbgPrint("  Defaulting to hardcoded Ethernet address...\n");
        #endif

        __asm {
            rdtsc
            mov tick0, eax
        }

        nic->hwaddr[0] = 0x00;
        nic->hwaddr[1] = 0x50;
        nic->hwaddr[2] = 0xf2;
        nic->hwaddr[3] = 0x00;
        nic->hwaddr[4] = 0x00;
        nic->hwaddr[5] = (BYTE) (tick0 & 0x1f);
    }

    nic->hwaddrlen = ENETADDRLEN;
    return NETERR_OK;
}


VOID
NicCleanup(
    IfEnet* nic
    )

/*++

Routine Description:

    Cleanup the NIC interface

Arguments:

    nic - Points to the NIC data structure

Return Value:

    NONE

--*/

{
    // Clean up the command queue and the shared command data buffer
    while (!PktQIsEmpty(&nic->cmdq)) {
        Packet* pkt = PktQRemoveHead(&nic->cmdq);
        NicUnlockPacketPages(pkt);
        COMPLETEPACKET(pkt, NETERR_CANCELLED);
    }

    // Clean up the receive buffer queue
    NicPktPoolCleanup();
    PktQInit(&nic->recvq);

    if (nic->cmdbuf.txstart) {
        NicFreeSharedMem(nic->cmdbuf.txstart);
        nic->cmdbuf.txstart = NULL;
    }

    NicDisconnectInterrupt(nic);
}


NTSTATUS
NicInitialize(
    IfEnet* nic
    )

/*++

Routine Description:

    Initialize the NIC "driver" code

Arguments:

    nic - Points to the NIC data structure

Return Value:

    Status code

--*/

{
    PNIC_CSR csr = NicCsr;
    NTSTATUS status = NETERR_HARDWARE;

    // NicXmitDescCount must be > 2*cfgXmitQLength and < PAGE_SIZE/(2*8)
    NicXmitDescCount = 2*cfgXmitQLength+1;
    if (NicXmitDescCount < 64) NicXmitDescCount = 64;
    ASSERT(NicXmitDescCount < PAGE_SIZE/(2*sizeof(NicBufDesc)));

    // Locate the NIC card and get the assigned resources
    nic->CSR = (PNIC_CSR) XPCICFG_NIC_MEMORY_REGISTER_BASE_0;
    nic->csrSize = XPCICFG_NIC_MEMORY_REGISTER_LENGTH_0;
    nic->intrVector = HalGetInterruptVector(XPCICFG_NIC_IRQ, &nic->intrIrql);

    KeInitializeDpc(&nic->dpc, NicInterruptDpc, nic);
    KeInitializeInterrupt(
        &NicIntrObject,
        NicIsr,
        nic,
        nic->intrVector,
        nic->intrIrql,
        LevelSensitive,
        TRUE);

    // Reset the NIC
    NicReset(nic, FALSE);

    // Initialize transmit and receive buffers
    status = NicInitBuffers(nic);
    if (!NT_SUCCESS(status)) goto err;

    // Read permanent Ethernet address
    status = NicReadEnetAddr(nic);
    if (!NT_SUCCESS(status)) goto err;

    nic->rxpollFreq = RXPOLL_FREQ_100MPS;
    csr->uni0 = HWADDR0(nic->hwaddr);
    csr->uni1 = HWADDR1(nic->hwaddr);
    
    // Disable multicast frame reception by default
    NicRecvMcastNone(csr);

    // Setup transmitter and receiver
    // NOTE: nVidia NIC somehow expects the maximum
    // receive buffer size is 1518 instead of 1514.
    ASSERT(DMAPKT_MAXDATA > 1518);
    csr->rx_cntl_1 = 1518;
    csr->rx_cntl_0 = RXCNTL_DEFAULT;
    csr->tx_cntl = TXCNTL_DEFAULT;

    csr->bkoff_cntl = BKOFFCNTL_DEFAULT;
    csr->tx_def = TXDEF_DEFAULT;
    csr->rx_def = RXDEF_DEFAULT;

    csr->tx_dadr = NicBufPhyAddr(nic, nic->cmdbuf.txhead);
    csr->rx_dadr = NicBufPhyAddr(nic, nic->cmdbuf.rxptr);
    csr->dlen = ((cfgRecvQLength-1) << 16) | (NicXmitDescCount-1);
    csr->rx_fifo_wm = RXFIFOWM_DEFAULT;
    csr->tx_fifo_wm = TXFIFOWM_DEFAULT;

    // Enable MII auto-polling interrupt
    csr->mii_cs = MIICS_DEFAULT;
    csr->mii_tm = MIITM_DEFAULT;
    csr->mintr_mk = MINTR_MAPI;

    // Initialize the PHY
    csr->mii_cs &= ~MIICS_APEN;
    status = PhyInitialize(FALSE, NULL);
    csr->mii_cs |= MIICS_APEN;
    if (!NT_SUCCESS(status)) goto err;

    NicCheckMiiStatus(nic, 0, TRUE);

    // Enable transmit and receive
    NicStartXmitRecv(csr, nic->rxpollFreq);

    // Connect the NIC interrupt
    if (KeConnectInterrupt(&NicIntrObject))
        return NETERR_OK;

    status = STATUS_BIOS_FAILED_TO_CONNECT_INTERRUPT;

err:
    NicReset(nic, FALSE);
    NicCleanup(nic);
    return status;
}

#endif // !SILVER
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\http\handle.cxx ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    handle.cxx

Abstract:

    Functions for managing various types of WININET handles

Revision History:

    08/08/2000 davidx
        Created it.

--*/

#include "precomp.h"

HINTERNET WINAPI
InternetOpen(
    IN LPCWSTR lpszAgent,
    IN DWORD dwAccessType,
    IN LPCWSTR lpszProxy OPTIONAL,
    IN LPCWSTR lpszProxyBypass OPTIONAL,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Initializes an application's use of the Wininet functions.

Arguments:

    lpszAgent - Name of the user agent
    dwAccessType - Type of access required
    lpszProxy - Host name of the proxy server
    lpszProxyBypass - Must be NULL
    dwFlags - Must be 0

Return Value:

    Handle to the Wininet object
    NULL if there is an error

--*/

{
    // Validate function parameters:
    // - INTERNET_OPEN_TYPE_PRECONFIG and
    //   INTERNET_OPEN_TYPE_PRECONFIG_WITH_NO_AUTOPROXY
    //   are treated the same way as INTERNET_OPEN_TYPE_DIRECT
    // - we don't support proxy bypass,
    //   either everything go through the proxy
    //   or nothing go through the proxy
    // - flag parameter must be 0

    switch (dwAccessType) {
    case INTERNET_OPEN_TYPE_DIRECT:
    case INTERNET_OPEN_TYPE_PRECONFIG:
    case INTERNET_OPEN_TYPE_PRECONFIG_WITH_NO_AUTOPROXY:
        if (lpszProxy) {
            WARNING_("Proxy server ignored for direct connection");
            lpszProxy = NULL;
        }
        break;
    
    case INTERNET_OPEN_TYPE_PROXY:
        if (lpszProxy) break;

        // Fall through

    default:
        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;
    }

    if (lpszProxyBypass || dwFlags) {
        WARNING_("Unsupported InternetOpen parameters");
        SetLastError(ERROR_NOT_SUPPORTED);
        return NULL;
    }

    return InternetObject::Create(lpszAgent, lpszProxy);
}


BOOL WINAPI
InternetCloseHandle(
    IN HINTERNET hInternet
    )

/*++

Routine Description:

    Closes a single Internet handle.

Arguments:

    hInternet - Specifies the handle to be closed

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    BaseObject* obj = BaseObject::Lock(hInternet, OBJTYPE_NONE);
    if (!obj) return FALSE;

    obj->Unlock();
    obj->Release();
    return TRUE;
}


HINTERNET WINAPI
InternetConnect(
    IN HINTERNET hInternet,
    IN LPCWSTR lpszServerName,
    IN INTERNET_PORT nServerPort,
    IN LPCWSTR lpszUserName OPTIONAL,
    IN LPCWSTR lpszPassword OPTIONAL,
    IN DWORD dwService,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    Opens a HTTP session for a given site.

Arguments:

    hInternet - Handle returned by InternetOpen
    lpszServerName - Server host name
    nServerPort - Server port number
    lpszUserName - Username
    lpszPassword - Password
    dwService - Must be INTERNET_SERVICE_HTTP
    dwFlags - Must be 0
    dwContext - App-specific context value

Return Value:

    Handle to the connection object
    NULL if there is an error

--*/

{
    InternetObject* inetobj;
    ConnectObject* connobj;

    // Just assert to save code in free build
    ASSERT(lpszServerName != NULL);
    
    if (dwService != INTERNET_SERVICE_HTTP) {
        WARNING_("Unsupported InternetConnect parameters");
        SetLastError(ERROR_NOT_SUPPORTED);
        return NULL;
    }

    if (dwFlags != 0) {
        WARNING_("Flags to InternetConnect ignored: 0x%x", dwFlags);
    }
    
    inetobj = LOCK_INTERNET_OBJECT(hInternet);
    if (!inetobj) return NULL;

    // No need to hold the lock to inetobj
    // because it doesn't have any volatile fields.
    // Just incrementing its refcount is enough.
    inetobj->AddRef();
    inetobj->Unlock();

    connobj = ConnectObject::Create(
                inetobj,
                lpszServerName,
                nServerPort,
                lpszUserName,
                lpszPassword,
                dwContext);

    inetobj->Release();
    return connobj;
}


HINTERNET WINAPI
HttpOpenRequest(
    IN HINTERNET hConnect,
    IN LPCWSTR lpszVerb,
    IN LPCWSTR lpszObjectName,
    IN LPCWSTR lpszVersion,
    IN LPCWSTR lpszReferrer OPTIONAL,
    IN LPCWSTR* lplpszAcceptTypes OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    Creates an HTTP request handle.

Arguments:

    hConnect - Handle to the HTTP connection object
    lpszVerb - Verb to use for the request
    lpszObjectName - Object name
    lpszVersion - HTTP version number
    lpszReferrer - Referer URL
    lplpszAcceptTypes - Media types accepted by the client
    dwFlags - Must be 0
    dwContext - App-specific context value

Return Value:

    Handle to the request object
    NULL if there is an error

--*/

{
    ConnectObject* connobj;
    RequestObject* reqobj;

    if (dwFlags != 0) {
        WARNING_("Unsupported HttpOpenRequest parameters");
        SetLastError(ERROR_NOT_SUPPORTED);
        return NULL;
    }

    connobj = LOCK_CONNECT_OBJECT(hConnect);
    if (!connobj) return NULL;

    connobj->AddRef();
    connobj->Unlock();

    if (!lpszVerb) lpszVerb = HttpDefaultVerbStr;
    if (!lpszVersion) lpszVersion = HttpDefaultVersionStr;
    if (!lpszObjectName) lpszObjectName = HttpDefaultObjectStr;

    reqobj = RequestObject::Create(
                connobj,
                lpszVerb,
                lpszObjectName,
                lpszVersion,
                lpszReferrer,
                lplpszAcceptTypes,
                dwContext);

    connobj->Release();
    return reqobj;
}


HINTERNET WINAPI
InternetOpenUrl(
    IN HINTERNET hInternet,
    IN LPCWSTR lpszUrl,
    IN LPCWSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    Begins reading a complete HTTP URL

Arguments:

    hInternet - Points to the internet object returned by InternetOpen
    lpszUrl - URL string
    lpszHeaders - Extra HTTP request headers
    dwHeadersLength - Extra header length
    dwFlags - Must be 0
    dwContext - App-specific context value

Return Value:

    Handle to the HTTP request object
    NULL if there is an error

--*/

{
    WCHAR* serverName = NULL;
    WCHAR* objectName = NULL;
    HINTERNET hConnect = NULL;
    HINTERNET hRequest = NULL;
    INTERNET_PORT serverPort;

    //
    // Parse the HTTP URL to extra the server name and the object name
    //
    if (!HttpParseUrl(lpszUrl, &serverName, &serverPort, &objectName))
        return NULL;

    //
    // Create a connection handle
    //
    hConnect = InternetConnect(
                    hInternet,
                    serverName,
                    serverPort,
                    NULL,
                    NULL,
                    INTERNET_SERVICE_HTTP,
                    0,
                    0);

    if (hInternet) {
        //
        // Create a request handle
        //
        hRequest = HttpOpenRequest(
                        hConnect,
                        NULL,
                        objectName,
                        NULL,
                        NULL,
                        NULL,
                        0,
                        0);

        //
        // Send out the HTTP request to the server
        //
        if (hRequest &&
            !HttpSendRequest(hRequest, lpszHeaders, dwHeadersLength, NULL, 0)) {
            InternetCloseHandle(hRequest);
            hRequest = NULL;
        }
    }

    if (hConnect) { InternetCloseHandle(hConnect); }
    Free(serverName);
    Free(objectName);

    if (!hRequest) {
        WARNING_("InternetOpenUrl failed: %d", GetLastError());
    }
    return hRequest;
}


BOOL WINAPI
HttpSendRequest(
    IN HINTERNET hRequest,
    IN LPCWSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN LPVOID lpOptional OPTIONAL,
    IN DWORD dwOptionalLength
    )

/*++

Routine Description:

    Sends the specified request to the HTTP server.

Arguments:

    hRequest - Handle to an HTTP request object
    lpszHeaders - Extra HTTP request headers
    dwHeadersLength - Extra header length
    lpOptional - Optional data sent in the HTTP request
    dwOptionalLength - Optional data length

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    RequestObject* reqobj;
    BOOL result;

    ASSERT(lpszHeaders || !dwHeadersLength);
    ASSERT(lpOptional || !dwOptionalLength);

    reqobj = LOCK_REQUEST_OBJECT(hRequest);
    if (!reqobj) return FALSE;

    result = reqobj->SendRequest(
                lpszHeaders,
                dwHeadersLength,
                lpOptional,
                dwOptionalLength);

    reqobj->Unlock();
    return result;
}


BOOL WINAPI
InternetQueryDataAvailable(
    IN HINTERNET hRequest,
    OUT LPDWORD lpdwNumberOfBytesAvailable,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    Query the amount of response data currently available for reading

Arguments:

    hRequest - Handle to the HTTP request object
    lpdwNumberOfBytesAvailable - Returns the number of bytes available
    dwFlags - Must be 0
    dwContext - Ignored

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    RequestObject* reqobj;
    BOOL result;
    
    ASSERT(lpdwNumberOfBytesAvailable != NULL);

    if (dwFlags != 0) {
        WARNING_("Unsupported InternetQueryDataAvailable parameters");
        SetLastError(ERROR_NOT_SUPPORTED);
        return FALSE;
    }
    
    reqobj = LOCK_REQUEST_OBJECT(hRequest);
    if (!reqobj) return FALSE;

    result = reqobj->QueryDataAvailable(lpdwNumberOfBytesAvailable);
    reqobj->Unlock();

    return result;
}


BOOL WINAPI
InternetReadFile(
    IN HINTERNET hRequest,
    IN LPVOID lpBuffer,
    IN DWORD dwNumberOfBytesToRead,
    OUT LPDWORD lpdwNumberOfBytesRead
    )

/*++

Routine Description:

    Read HTTP response data

Arguments:

    hRequest - Handle to the HTTP request
    lpBuffer - Output data buffer
    dwNumberOfBytesToRead - Output buffer size
    lpdwNumberOfBytesRead - Returns the number of bytes actually read

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    RequestObject* reqobj;
    BOOL result;

    ASSERT(lpBuffer && lpdwNumberOfBytesRead);

    reqobj = LOCK_REQUEST_OBJECT(hRequest);
    if (!reqobj) return FALSE;

    result = reqobj->ReadData((CHAR*) lpBuffer, dwNumberOfBytesToRead, lpdwNumberOfBytesRead);
    reqobj->Unlock();

    return result;
}


BOOL WINAPI
HttpQueryInfo(
    IN HINTERNET hRequest,
    IN DWORD dwInfoLevel,
    IN LPVOID lpvBuffer,
    IN LPDWORD lpdwBufferLength,
    IN OUT LPDWORD lpdwIndex
    )

/*++

Routine Description:

    Retrieves header information associated with an HTTP request

Arguments:

    hRequest - Handle to the HTTP request
    dwInfoLevel - Specifies what attribute to retrieve
    lpvBuffer - Output data buffer
    lpdwBufferLength - Output data buffer size
        On entry, it contains the buffer size in number of WCHARs
        On return, it contains either the actual output data in number
        of WCHARs (not including the null terminator) or the actual
        number of bytes needed if the output buffer is too small
    lpdwIndex - 0-based index specifying which occurrence if of interest

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    RequestObject* reqobj;
    BOOL result;

    ASSERT(lpdwBufferLength);
    ASSERT(lpvBuffer || *lpdwBufferLength == 0);

    reqobj = LOCK_REQUEST_OBJECT(hRequest);
    if (!reqobj) return FALSE;

    result = reqobj->QueryRespInfo(
                        dwInfoLevel,
                        (WCHAR*) lpvBuffer,
                        lpdwBufferLength,
                        lpdwIndex);

    reqobj->Unlock();
    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\http\precomp.h ===
#include <xnetp.h>
#include <wininet.h>

#include "wininetp.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\http\http.cxx ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    http.cxx

Abstract:

    HTTP client functions

Revision History:

    08/08/2000 davidx
        Created it.

--*/

#include "precomp.h"
#include <stdio.h>
#include "httptime.h"

//
// Default HTTP string constants
//
const WCHAR WininetImpl::HttpDefaultVerbStr[] = L"GET";
const WCHAR WininetImpl::HttpDefaultVersionStr[] = HTTP_VERSION;
const WCHAR WininetImpl::HttpDefaultObjectStr[] = L"/";
static const WCHAR HttpSchemeStr[] = L"http://";


InternetObject*
InternetObject::Create(
    const WCHAR* userAgent,
    const WCHAR* proxyServer
    )

/*++

Routine Description:

    Instantiate a new internet object

Arguments:

    userAgent - Specifies the user agent
    proxyServer - Specifies the proxy server name

Return Value:

    Pointer to the newly created internet object
    NULL if there is an error

--*/

{
    static const WCHAR defaultUserAgent[] = L"XBox HTTP Client Library";
    InternetObject* inetobj;
    WSADATA wsadata;
    INT err;

    // Instantiate the object
    inetobj = new InternetObject();
    if (!inetobj) goto failed;

    // Startup winsock
    err = WSAStartup(WINSOCK_VERSION, &wsadata);
    if (err != NO_ERROR) {
        SetLastError(err);
        goto failed;
    }
    inetobj->wsastartup = TRUE;

    // Save user-agent string
    if (!userAgent) userAgent = defaultUserAgent;
    inetobj->userAgent = strdupWtoA(userAgent);
    if (!inetobj->userAgent) goto failed;

    // Save proxy server name and resolve its IP address
    if (proxyServer) {
        inetobj->proxyServer = strdupWtoA(proxyServer);
        if (!inetobj->proxyServer) goto failed;

        inetobj->proxyServerAddr = ResolveHostAddr(inetobj->proxyServer);
        if (inetobj->proxyServerAddr.s_addr == 0) goto failed;
    }

    return inetobj;

failed:
    WARNING_("InternetOpen failed: %d", GetLastError());
    delete inetobj;
    return NULL;
}


ConnectObject*
ConnectObject::Create(
    InternetObject* inetobj,
    const WCHAR* serverName,
    INTERNET_PORT serverPort,
    const WCHAR* username,
    const WCHAR* password,
    DWORD_PTR appContext
    )

/*++

Routine Description:

    Instantiate an HTTP connection object

Arguments:

    inetobj - Points to an InternetObject
    serverName - Server host name
    username - Username
    password - Password
    appContext - App-specific context value

Return Value:

    Pointer to the newly created connection object
    NULL if there is an error

--*/

{
    ConnectObject* connobj;

    connobj = new ConnectObject();
    if (!connobj) goto failed;

    // Keep a reference to the internet object
    inetobj->AddRef();
    connobj->inetobj = inetobj;
    connobj->appContext = appContext;
    connobj->serverPort = serverPort;

    // Save server name and resolve its IP address
    connobj->serverName = strdupWtoA(serverName);
    if (!connobj->serverName) goto failed;

    if (inetobj->GetProxyServer()) {
        connobj->serverAddr = inetobj->GetProxyServerAddr();
    } else {
        connobj->serverAddr = ResolveHostAddr(connobj->serverName);
        if (connobj->serverAddr.s_addr == 0) goto failed;
    }

    // Save username and password information
    if (username) {
        connobj->username = strdupWtoA(username);
        if (!connobj->username) goto failed;
    }

    if (password) {
        connobj->password = strdupWtoA(password);
        if (!connobj->password) goto failed;
    }

    // Successful return
    return connobj;

failed:
    WARNING_("InternetConnect failed: %d", GetLastError());
    delete connobj;
    return NULL;
}


RequestObject*
RequestObject::Create(
    ConnectObject* connobj,
    const WCHAR* verb,
    const WCHAR* objectName,
    const WCHAR* httpVer,
    const WCHAR* referer OPTIONAL,
    const WCHAR* acceptTypes[] OPTIONAL,
    DWORD_PTR appContext
    )

/*++

Routine Description:

    Instantiate a new HTTP request object

Arguments:

    connobj - Points to the HTTP connection object
    verb - Verb for the HTTP request
    objectName - Name of the object in question
    httpVer - HTTP version string
    referer - Referer URL
    acceptTypes - Media types accepted by the client
    appContext - App-specific context value

Return Value:

    Pointer to the newly created HTTP request object
    NULL if there is an error

--*/

{
    RequestObject* reqobj;

    reqobj = new RequestObject();
    if (!reqobj) return NULL;

    // Keep a reference to the parent connection object
    connobj->AddRef();
    reqobj->connobj = connobj;
    reqobj->appContext = appContext;

    //
    // Assemble default HTTP request headers
    //
    InternetObject* inetobj = connobj->GetInternetObject();
    HdrBuf* hdrbuf = &reqobj->reqhdrs;
    INT ok;

    // Request-line
    ok = hdrbuf->AppendUnicodeString(verb, SPACE);
    if (inetobj->GetProxyServer()) {
        ok &= hdrbuf->AppendUnicodeString(HttpSchemeStr, 0);
        ok &= hdrbuf->AppendAsciiString(connobj->GetServerName(), 0);
    }
    ok &= hdrbuf->AppendUnicodeString(objectName, SPACE);
    ok &= hdrbuf->AppendUnicodeString(httpVer, LF);

    // User-agent
    ok &= hdrbuf->AppendAsciiString("User-Agent", COLON);
    ok &= hdrbuf->AppendAsciiString(inetobj->GetUserAgent(), LF);

    // Accept
    //  note: this is actually an HTTP/1.1 header field
    if (acceptTypes && *acceptTypes) {
        const WCHAR* lasttype = *acceptTypes++;
        ok &= hdrbuf->AppendAsciiString("Accept", COLON);
        while (*acceptTypes) {
            ok &= hdrbuf->AppendUnicodeString(lasttype, COMMA);
            lasttype = *acceptTypes++;
        }
        ok &= hdrbuf->AppendUnicodeString(lasttype, LF);
    }

    // Referer
    if (referer) {
        ok &= hdrbuf->AppendAsciiString("Referer", COLON);
        ok &= hdrbuf->AppendUnicodeString(referer, LF);
    }

    if (!ok) {
        WARNING_("Failed to assembly default HTTP request headers");
        delete reqobj;
        return NULL;
    }
    return reqobj;
}


BOOL
RequestObject::Connect()

/*++

Routine Description:

    Establish a TCP connection to the HTTP server

Arguments:

    NONE

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    struct sockaddr_in serveraddr;

    // Do nothing if already connected
    if (IsConnected()) return TRUE;

    // Create the socket and connect to the HTTP server
    sock = socket(AF_INET, SOCK_STREAM, 0);
    if (sock == INVALID_SOCKET)
        return FALSE;

    connobj->GetServerAddr(&serveraddr);
    if (_connect(sock, &serveraddr) != NO_ERROR) {
        Disconnect();
        return FALSE;
    }

    // NOTE: we could set receive timeout option here...
    return TRUE;
}


static BOOL
DoSendData(
    SOCKET s,
    WSABUF* bufs,
    UINT bufcnt
    )

/*++

Routine Description:

    Send data out of a TCP connection

Arguments:

    s - Socket handle
    bufs - Data buffers
    bufcnt - Number of data buffers

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    INT err;
    DWORD sent;

    while (bufcnt) {
        err = WSASend(s, bufs, bufcnt, &sent, 0, NULL, NULL);
        if (err != NO_ERROR) return FALSE;

        // Only partial amount of data was sent:
        //  we need to update the send buffers and 
        //  then call WSASend again
        while (sent) {
            DWORD n = min(sent, bufs->len);

            if ((bufs->len -= n) == 0) {
                bufs++, bufcnt--;
            } else
                bufs->buf += n;
            sent -= n;
        }
    }

    return TRUE;
}


static HANDLE
DoOpenFile(
    const WCHAR* filename,
    UINT* fileSize
    )

/*++

Routine Description:

    Open a file for reading and get the file size

Arguments:

    filename - Specifies the filename
    fileSize - Return the file size

Return Value:

    Handle to the open file
    INVALID_HANDLE_VALUE if there is an error

--*/

{
    // BUGBUG
    // Since CreateFileW API is gone, we need to strip down
    // the Unicode string to ANSI string. Eventually we should
    // change the HttpSendRequest API to have it pass in
    // ANSI string.

    XDBGWRN("HTTP",
        "HttpSendRequest: lpOptional parameter is treated as Unicode filename - %ws",
        filename);
    
    CHAR *p, buf[MAX_PATH];
    ASSERT(wcslen(filename) < MAX_PATH);

    p = buf;
    while ((*p++ = (CHAR) *filename++) != 0)
        ;

    HANDLE file;

    //
    // Open the file for reading
    //
    file = CreateFileA(
                buf,
                GENERIC_READ,
                FILE_SHARE_READ,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL|FILE_FLAG_SEQUENTIAL_SCAN,
                NULL);

    if (file != INVALID_HANDLE_VALUE) {
        //
        // Get file size
        //
        *fileSize = GetFileSize(file, NULL);
        if (*fileSize == 0xffffffff) {
            CloseHandle(file);
            file = INVALID_HANDLE_VALUE;
        }
    }

    return file;
}


static BOOL
DoSendFile(
    SOCKET s,
    HANDLE file,
    UINT filesize
    )

/*++

Routine Description:

    Send the content of a file out of a TCP connection

Arguments:

    s - Specifies the socket handle
    file - Specifies the open file handle
    filesize - Total file size

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

#define SENDFILE_BLKSIZE 4096

{
    CHAR* buf = NULL;
    WSABUF wsabuf;
    UINT bufsize;
    
    bufsize = min(filesize, SENDFILE_BLKSIZE);
    buf = (CHAR*) MAlloc(bufsize);
    if (!buf) return FALSE;

    while (filesize) {
        DWORD count = min(filesize, bufsize);
        DWORD bytesRead;

        // Read the next chunk of data from the file
        if (!ReadFile(file, buf, count, &bytesRead, NULL) ||
            count != bytesRead)
            break;
        
        // Send it out
        wsabuf.buf = buf;
        wsabuf.len = count;
        if (!DoSendData(s, &wsabuf, 1)) break;

        filesize -= count;
    }

    Free(buf);
    return (filesize == 0);
}


BOOL
RequestObject::SendRequest(
    const WCHAR* headers,
    UINT headerLength,
    const VOID* optionalData,
    UINT optionalLength
    )

/*++

Routine Description:

    Send the request to the HTTP server

Arguments:

    headers - Points to extra HTTP request headers
    headerLength - Extra header length
    optionalData - Points to optional data sent along the HTTP request
    optionalLength - Optional data length

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    // Establish a TCP connection to the server
    if (!Connect()) return FALSE;

    // Free any existing response information
    ResetRespInfo();

    HdrBuf hdrend;
    CHAR* extrahdrs = NULL;
    INT ok = 1;
    HANDLE file = INVALID_HANDLE_VALUE;

    //
    // Artificial loop for error handling
    //
    do {
        CHAR lenstr[16];

        // Content-Length header field
        if (optionalLength == 0xffffffff) {
            file = DoOpenFile((const WCHAR*) optionalData, &optionalLength);
            if (file == INVALID_HANDLE_VALUE) {
                WARNING_("Couldn't open file: %ws", optionalData);
                ok = 0;
                break;
            }
        }

        ok &= hdrend.AppendAsciiString("Content-Length", COLON);
        sprintf(lenstr, "%u", optionalLength);
        ok &= hdrend.AppendAsciiString(lenstr, LF);

        // Empty line
        ok &= hdrend.AppendAsciiString("", LF);
        if (!ok) break;

        // Assemble send buffers
        WSABUF bufs[4];
        UINT bufcnt = 0;

        bufs[bufcnt].len = reqhdrs.size;
        bufs[bufcnt++].buf = (CHAR*) reqhdrs.data;

        if (headerLength == 0xffffffff) {
            headerLength = wcslen(headers);
        }

        if (headerLength) {
            extrahdrs = strdupWtoA(headers, headerLength);
            if (!extrahdrs) break;

            bufs[bufcnt].len = headerLength;
            bufs[bufcnt++].buf = extrahdrs;
        }

        bufs[bufcnt].len = hdrend.size;
        bufs[bufcnt++].buf = (CHAR*) hdrend.data;

        if (optionalLength && file == INVALID_HANDLE_VALUE) {
            bufs[bufcnt].len = optionalLength;
            bufs[bufcnt++].buf = (CHAR*) optionalData;
        }

        // Send request data
        //  note: we need to use a wrapper function here
        //  and cann't call WSASend directly because
        //  WSASend can return success only after
        //  sending partial amount of data.
        ok = DoSendData(sock, bufs, bufcnt) &&
             (file == INVALID_HANDLE_VALUE ||
              DoSendFile(sock, file, optionalLength));
    } while (FALSE);

    if (file == INVALID_HANDLE_VALUE) {
        CloseHandle(file);
    }
    Free(extrahdrs);

    if (!ok) {
        Disconnect();
    }
    return ok;
}


BOOL
RequestObject::QueryDataAvailable(
    DWORD* bytesAvailable
    )

/*++

Routine Description:

    Query the amount of HTTP response data available

Arguments:

    bytesAvailable - Returns the number of bytes available

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    //
    // Make sure we're connected and
    // we have already read the HTTP response headers
    //
    if (!ReadRespHdrs(FALSE)) return FALSE;

    // We didn't finish reading the response headers
    if (!IsRespHdrsOk()) {
        *bytesAvailable = 0;
        return TRUE;
    }

    // Check if there is any data to be read
    ULONG avail;
    INT err = ioctlsocket(sock, FIONREAD, &avail);

    if (err != NO_ERROR) return FALSE;
    *bytesAvailable = peeklen + avail;
    if (*bytesAvailable)
        return TRUE;

    // If there is no data, check if the connection is closed
    fd_set fds;
    FD_ZERO(&fds);
    FD_SET(sock, &fds);
    struct timeval timeout = { 0, 0 };

    err = select(1, &fds, NULL, NULL, &timeout);
    switch (err) {
    case 0:
        break;

    case SOCKET_ERROR:
        return FALSE;
    
    default:
        ASSERT(err == 1);
        err = ioctlsocket(sock, FIONREAD, &avail);
        if (err != NO_ERROR) return FALSE;

        // Connection has been closed
        if (avail == 0) {
            SetLastError(ERROR_HANDLE_EOF);
            return FALSE;
        }

        *bytesAvailable = avail;
        break;
    }

    return TRUE;
}


BOOL
RequestObject::ReadData(
    CHAR* buffer,
    UINT bufferSize,
    DWORD* bytesRead
    )

/*++

Routine Description:

    Read HTTP response data

Arguments:

    buffer - Output data buffer
    bufferSize - Output buffer size
    bytesRead - Returns the number of bytes actually read

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    *bytesRead = 0;

    //
    // Make sure we're connected and
    // we have already read the HTTP response headers
    //
    if (!ReadRespHdrs(TRUE)) return FALSE;

    //
    // If we have read too much data while parsing
    // the response headers, return it here.
    //
    UINT n;
    if (peeklen) {
        n = min(bufferSize, peeklen);
        CopyMem(buffer, peekdata, n);
        buffer += n;
        peekdata += n;
        peeklen -= n;

        *bytesRead += n;
        readcnt += n;
        bufferSize -= n;
    }

    while (bufferSize) {
        n = bufferSize;
        if (contentlen != 0xffffffff) {
            //
            // If Content-Length header field is not present,
            // we'll keep on reading until the server closes
            // the connection.
            //
            // Otherwise, we only read the specified amount of
            // data (and ignore any extra data at the end).
            //
            if (readcnt >= contentlen) break;
            if (n > contentlen - readcnt)
                n = contentlen - readcnt;
        }

        INT count = recv(sock, buffer, n, 0);
        if (count < 0) return FALSE;

        // Stop if connection is closed
        if (count == 0) break;

        n = count;
        *bytesRead += n;
        readcnt += n;
        buffer += n;
        bufferSize -= n;
    }

    return TRUE;
}


BOOL
RequestObject::ReadRespHdrs(
    BOOL wait
    )

/*++

Routine Description:

    Read HTTP response headers

Arguments:

    wait - Whether to wait for the header data

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    //
    // Check if we're currently connected
    //
    if (!IsConnected()) {
        SetLastError(ERROR_NOT_CONNECTED);
        return FALSE;
    }

    //
    // Check if we have already read the response headers
    //
    if (IsRespHdrsOk()) return TRUE;

    do {
        //
        // Reallocate memory buffer if necessary
        //
        if (resphdrs.SpaceLeft() < 512) {
            BYTE* olddata = resphdrs.data;
            if (!resphdrs.ReserveSpace(512)) goto failed;

            UINT offset = resphdrs.data - olddata;
            peekdata += offset;
            for (UINT i=0; i < resphdrLinecnt; i++)
                resphdrLines[i] += offset;
        }
        
        UINT n = resphdrs.SpaceLeft();
        INT result;
        if (!wait) {
            ULONG avail;
            result = ioctlsocket(sock, FIONREAD, &avail);
            if (result == SOCKET_ERROR) goto failed;
            if (avail == 0) break;
            if (n > avail) n = avail;
        }

        result = recv(sock, (CHAR*) resphdrs.data + resphdrs.size, n, 0);
        if (result == SOCKET_ERROR) goto failed;

        resphdrs.size += result;
        ParseRespHdrs(result == 0);
        if (result == 0) {
            //
            // Server has closed the connection
            //
            if (peeklen != 0) goto failed;
            resphdrsOk = TRUE;
        }
    } while (!IsRespHdrsOk());
    return TRUE;

failed:
    Disconnect();
    WARNING_("Failed to read HTTP response headers");
    SetLastError(ERROR_INVALID_DATA);
    return FALSE;
}


VOID
RequestObject::ParseRespHdrs(
    BOOL eof
    )

/*++

Routine Description:

    Parse HTTP response header fields

Arguments:

    eof - Whether the server connection has been closed

Return Value:

    NONE

--*/

#define IsLWS(c) ((c) == SPACE || (c) == TAB)

{
    BYTE* start = peekdata;
    BYTE* end = resphdrs.data + (resphdrs.size-1);

    while (TRUE) {
        //
        // Find the end of the next line
        //
        BYTE* p = start;
        BYTE* q;

    findeol:
        while (p < end) {
            if (p[0] == CR || p[1] == LF) break;
            p++;
        }
        if (p >= end) break;

        if (p == start) {
            //
            // Empty line - end of header section
            //
            start += 2;
            resphdrsOk = TRUE;
            break;
        }

        //
        // Handle line continuations
        //
        q = p + 2;
        if (q > end) {
            if (!eof) break;
        } else if (IsLWS(*q)) {
            do {
                q++;
            } while (q <= end && IsLWS(*q));
            if (q > end) break;

            UINT movecnt = (end-q) + 1;
            *p++ = SPACE;
            MoveMem(p, q, movecnt);

            end -= (q - p);
            goto findeol;
        }

        //
        // Strip trailing whitespaces
        //
        do {
            *p-- = 0;
        } while (p >= start && IsLWS(*p));

        if (resphdrLinecnt < MAXRESPHDRS) {
            resphdrLines[resphdrLinecnt++] = start;
        } else {
            WARNING_("Too many response header fields");
        }

        start = q;

        //
        // Look for Content-Length: field
        //
        CHAR* str;
        if (MatchHeaderField(start, "Content-Length", &str)) {
            NTSTATUS status;
            ULONG val;
            status = RtlCharToInteger(str, 10, &val);
            if (NT_SUCCESS(status)) contentlen = val;
        }
    }

    peekdata = start;
    peeklen = (end - start) + 1;
}


BOOL
RequestObject::MatchHeaderField(
    BYTE* data,
    const CHAR* fieldname,
    CHAR** fieldval
    )

/*++

Routine Description:

    Match a specified header field

Arguments:

    data - Points to the header field data
    fieldname - Specifies the name of the interested field
    fieldval - Return a pointer to the field value string

Return Value:

    TRUE if the name of the field matches the specified name
    FALSE otherwise

--*/

{
    INT len = strlen(fieldname);

    if (_strnicmp((CHAR*) data, fieldname, len) != 0 || data[len] != COLON)
        return FALSE;

    data += (len+1);
    while (*data && IsLWS(*data)) data++;
    *fieldval = (CHAR*) data;
    return TRUE;
}


BOOL
RequestObject::QueryRespInfo(
    DWORD infoLevel,
    WCHAR* buffer,
    DWORD* buflen,
    DWORD* hdrindex
    )

/*++

Routine Description:

    Retrieves header information associated with an HTTP request

Arguments:

    infoLevel - Specifies what attribute to retrieve
    buffer - Output data buffer
    buflen - Output data buffer size
        On entry, it contains the buffer size in number of WCHARs
        On return, it contains either the actual output data in number
        of WCHARs (not including the null terminator) or the actual
        number of bytes needed if the output buffer is too small
    hdrindex - 0-based index specifying which occurrence if of interest

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

#define HTTP_QUERY_FLAG_ALL \
        (HTTP_QUERY_FLAG_NUMBER | HTTP_QUERY_FLAG_SYSTEMTIME)

#define ReturnInsufficientBufferError(_bytesNeeded) { \
            *buflen = (_bytesNeeded); \
            SetLastError(ERROR_INSUFFICIENT_BUFFER); \
            return FALSE; \
        }

{
    static const struct {
        DWORD fieldindex;
        const CHAR* fieldname;
    } mapping[] = {
        { HTTP_QUERY_CONTENT_LENGTH, "Content-Length" },
        { HTTP_QUERY_CONTENT_TYPE, "Content-Type" },
        { HTTP_QUERY_DATE, "Date" },
        { HTTP_QUERY_EXPIRES, "Expires" },
        { HTTP_QUERY_LAST_MODIFIED, "Last-Modified" },
        { HTTP_QUERY_ACCEPT, "Accept" },
    };

    DWORD modifier = infoLevel & 0xffff0000;
    DWORD fieldIndex = infoLevel & 0xffff;
    CHAR tempbuf[64];
    const CHAR* fieldname;
    CHAR* fieldval = NULL;
    UINT i, count;
    DWORD occurrence = hdrindex ? *hdrindex : 0;

    //
    // Make sure we're connected and
    // we have already read the HTTP response headers
    //
    if (!ReadRespHdrs(TRUE)) return FALSE;

    if (modifier & ~HTTP_QUERY_FLAG_ALL)
        goto unsupported;

    switch (fieldIndex) {
    case HTTP_QUERY_VERSION:
    case HTTP_QUERY_STATUS_CODE:
    case HTTP_QUERY_STATUS_TEXT:
        //
        // Extract information from the status line
        //
        if (occurrence) goto unsupported;
        fieldval = ParseStatusLine(tempbuf, sizeof(tempbuf), fieldIndex);
        break;

    case HTTP_QUERY_RAW_HEADERS:
    case HTTP_QUERY_RAW_HEADERS_CRLF:
        //
        // Return all the header fields
        //
        if (modifier || occurrence) goto unsupported;
        return ReturnAllRespHdrs(buffer, buflen, fieldIndex);

    default:
        if (fieldIndex == HTTP_QUERY_CUSTOM) {
            //
            // Arbitrary field name
            //
            count = wcslen(buffer);
            if (count >= sizeof(tempbuf)) goto unsupported;
            strcpyWtoA(tempbuf, buffer);
            fieldname = tempbuf;
        } else {
            //
            // Map field index to field name
            //
            count = ARRAYCOUNT(mapping);
            for (i=0; i < count; i++) {
                if (fieldIndex == mapping[i].fieldindex) break;
            }

            if (i == count) goto unsupported;
            fieldname = mapping[i].fieldname;
        }

        //
        // Find the field with the specified name
        //
        for (i=count=0; i < resphdrLinecnt; i++) {
            if (MatchHeaderField(resphdrLines[i], fieldname, &fieldval)) {
                if (count == occurrence) break;
                count++;
            }
        }

        if (i == resphdrLinecnt)
            fieldval = NULL;
        break;
    }

    //
    // Check if the specified field is present
    //
    if (fieldval == NULL) {
        SetLastError(ERROR_NO_DATA);
        return FALSE;
    }

    if (modifier & HTTP_QUERY_FLAG_NUMBER) {
        //
        // Return the field value as an integer
        // NOTE: This is really confusing at the API level:
        //  should app pass in buffer length in # of WCHARs
        //  or should it be in # of bytes?
        if (*buflen < sizeof(DWORD)) {
            ReturnInsufficientBufferError(sizeof(DWORD));
        }

        NTSTATUS status;
        ULONG val;

        status = RtlCharToInteger(fieldval, 10, &val);
        if (!NT_SUCCESS(status)) {
            SetLastError(ERROR_INVALID_DATA);
            return FALSE;
        }

        *((DWORD*) buffer) = val;
    } else if (modifier & HTTP_QUERY_FLAG_SYSTEMTIME) {
        //
        // Parse the HTTP date/time string
        //
        if (*buflen < sizeof(SYSTEMTIME)) {
            ReturnInsufficientBufferError(sizeof(SYSTEMTIME));
        }

        if (!HttpDateTime::Parse(fieldval, (SYSTEMTIME*) buffer))
            return FALSE;
    } else {
        //
        // Return the field value as Unicode string.
        // Check if the caller's buffer is large enough
        //
        count = strlen(fieldval);
        if (*buflen <= count) {
            ReturnInsufficientBufferError((count + 1) * sizeof(WCHAR));
        }

        *buflen = count;
        strcpyAtoW(buffer, fieldval);
    }

    if (hdrindex) *hdrindex = ++occurrence;
    return TRUE;

unsupported:
    WARNING_("HttpQueryInfo: unsupported parameter", infoLevel);
    SetLastError(ERROR_NOT_SUPPORTED);
    return FALSE;
}


CHAR*
RequestObject::ParseStatusLine(
    CHAR* buf,
    DWORD buflen,
    DWORD field
    )

/*++

Routine Description:

    Extract the specified field from the HTTP response status line

Arguments:

    buf - Points to the output buffer
    buflen - Output buffer size
        These two parameters are only used for the version
        and status code fields.
    field - Specifies which field the caller is interested in

Return Value:

    Pointer to the string value for the specified field

--*/

{
    if (resphdrLinecnt == 0) return NULL;

    field = (field == HTTP_QUERY_VERSION) ? 0 :
            (field == HTTP_QUERY_STATUS_CODE) ? 1 : 2;

    CHAR* q = (CHAR*) resphdrLines[0];
    CHAR* p = NULL;
    DWORD i, n;

    for (i=n=0; i <= field; i++) {
        p = q;
        if (i < 2) {
            while (*q && !IsLWS(*q)) q++;
            n = q - p;
            while (*q && IsLWS(*q)) q++;
        } else {
            n = strlen(q);
            q += n;
        }
    }

    //
    // The request field is not present
    //
    if (n == 0) return NULL;

    //
    // For the status text field, return
    // a pointer to our internal data buffer
    //
    if (field == 2) return p;

    //
    // Copy version and status code value into the output buffer
    //
    if (buflen <= n) return NULL;
    CopyMem(buf, p, n);
    buf[n] = 0;
    return buf;
}


BOOL
RequestObject::ReturnAllRespHdrs(
    WCHAR* buf,
    DWORD* buflen,
    DWORD field
    )

/*++

Routine Description:

    Return all the HTTP response headers in one chunk

Arguments:

    buf - Points to the output buffer
    buflen - See comments for QueryRespInfo
    field - Specifies whether the header fields should be separated
        by the null character or the CRLF

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    if (resphdrLinecnt == 0) {
        SetLastError(ERROR_NO_DATA);
        return FALSE;
    }

    //
    // Figure out the size of output buffer we need
    //

    BOOL crlf = (field == HTTP_QUERY_RAW_HEADERS_CRLF);
    UINT i, count;

    for (i=count=0; i < resphdrLinecnt; i++)
        count += strlen((CHAR*) resphdrLines[i]);

    count += resphdrLinecnt * (crlf ? 2 : 1);
    if (*buflen <= count) {
        ReturnInsufficientBufferError((count + 1) * sizeof(WCHAR));
    }

    //
    // Copy all the header fields to the output buffer
    //

    *buflen = count;
    for (i=0; i < resphdrLinecnt; i++) {
        CHAR* str = (CHAR*) resphdrLines[i];
        strcpyAtoW(buf, str);
        count = strlen(str);
        buf += count;
        if (crlf) {
            *buf++ = CR;
            *buf++ = LF;
        } else
            *buf++ = 0;
    }

    *buf = 0;
    return TRUE;
}


BOOL
WininetImpl::HttpParseUrl(
    const WCHAR* url,
    WCHAR** serverName,
    INTERNET_PORT* serverPort,
    WCHAR** objectName
    )

/*++

Routine Description:

    Crack an HTTP URL to extract various parts:
        serverName
        serverPort
        objectName

Arguments:

    url - Specifies the input URL string
    serverName - Returns a pointer to the server name string
    serverPort - Returns the server port number
    objectName - Returns a pointer to the object name string

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    ASSERT(url != NULL);
    *serverName = NULL;
    *objectName = NULL;
    *serverPort = INTERNET_DEFAULT_HTTP_PORT;

    //
    // Artificial loop for error handling
    //
    while (TRUE) {
        //
        // We only support http:// scheme
        //
        UINT len = wcslen(HttpSchemeStr);
        if (_wcsnicmp(url, HttpSchemeStr, len) != 0) break;

        //
        // Parse the server name
        //
        const WCHAR* server = url + len;
        const WCHAR* cp = server;

        while (*cp && *cp != COLON && *cp != SLASH) cp++;
        if ((len = cp - server) == 0) break;
        
        WCHAR* p = (WCHAR*) MAlloc((len+1) * sizeof(WCHAR));
        if (!p) break;

        CopyMem(p, server, len*sizeof(WCHAR));
        p[len] = 0;
        *serverName = p;

        //
        // Parse the server port number
        //
        if (*cp == COLON) {
            const WCHAR* port = ++cp;
            while (*cp && *cp != SLASH) cp++;
            if ((len = cp - port) == 0) break;

            UNICODE_STRING ustr;
            NTSTATUS status;
            ULONG val;

            ustr.Buffer = (WCHAR*) port;
            ustr.Length = (USHORT) (len * sizeof(WCHAR));
            ustr.MaximumLength = (USHORT) (ustr.Length + sizeof(WCHAR));
            status = RtlUnicodeStringToInteger(&ustr, 0, &val);

            if (!NT_SUCCESS(status) || val > 0xffff) break;
            *serverPort = (INTERNET_PORT) val;
        }

        //
        // Parse the object name
        //
        if (*cp == SLASH) {
            len = (wcslen(cp) + 1) * sizeof(WCHAR);
            p = (WCHAR*) MAlloc(len);
            if (!p) break;

            *objectName = p;
            CopyMem(p, cp, len);
        }
        return TRUE;
    }

    WARNING_("HttpParseUrl failed: %ws", url);
    SetLastError(ERROR_INVALID_PARAMETER);
    Free(*serverName);
    *serverName = NULL;
    return FALSE;
}


//
// Semi-klugy way to determine if a hostname
// string is in dotted-decimal form
//
inline BOOL IsHostAddrString(const CHAR* hostname) {
    const CHAR* p = hostname;
    while (*p) {
        if ((*p < '0' || *p > '9') && *p != '.')
            return FALSE;
        p++;
    }
    return TRUE;
}

struct in_addr
WininetImpl::ResolveHostAddr(
    const CHAR* hostname
    )

/*++

Routine Description:

    Resolve a host name to its IP address

Arguments:

    hostname - Points to the hostname string

Return Value:

    IP address of the specified host
    0 if there is an error

--*/

{
    struct in_addr hostaddr;

    hostaddr.s_addr = 0;
    if (IsHostAddrString(hostname)) {
        //
        // The hostname is in dotted-decimal form:
        //  just convert it to IP address directly
        //
        LONG addr = inet_addr(hostname);
        if (addr != INADDR_NONE)
            hostaddr.s_addr = addr;
    } else {
        //
        // Use DNS to map hostname to IP address
        //
        struct hostent* hostent;
        LONG* paddr;

        hostent = gethostbyname(hostname);
        if (hostent) {
            ASSERT(hostent->h_addr_list);
            paddr = (LONG*) hostent->h_addr_list[0];
            if (paddr) hostaddr.s_addr = *paddr;
        }
    }

    return hostaddr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\http\httptime.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    httptime.h

Abstract:

    Helper class for parsing HTTP date/time string

Revision History:

    08/17/2000 davidx
        Created it.

--*/

#ifndef _HTTPTIME_H
#define _HTTPTIME_H

//
// Helper class to parse HTTP date/time string
//
class HttpDateTime {

public:

    // Parse a HTTP date/time string
    static BOOL Parse(const CHAR* s, SYSTEMTIME* systime) {
        HttpDateTime dateTime(s);
        if (dateTime.IsInvalid()) {
            SetLastError(ERROR_INVALID_DATA);
            return FALSE;
        }

        systime->wYear = dateTime.year;
        systime->wMonth = dateTime.month;
        systime->wDay = dateTime.day;
        systime->wDayOfWeek = dateTime.wkday;
        systime->wHour = dateTime.hour;
        systime->wMinute = dateTime.minute;
        systime->wSecond = dateTime.second;
        systime->wMilliseconds = 0;
        return TRUE;
    }

private:

    // Parse a HTTP date/time string
    HttpDateTime(const CHAR* s) {
        // Mark the object as invalid
        MarkInvalid();

        cp = s;
        while (*cp && *cp != COMMA && *cp != SPACE) cp++;
        if (*cp == 0) return;

        INT wkdaylen = cp - s;
        INT fmt;
        
        // Determine the date/time string format
        // from the content of the day-of-week field

        if (*cp == SPACE) {
            if (wkdaylen != 3) return;
            fmt = DTFMT_ANSIC;
        } else {
            cp++;
            fmt = (wkdaylen == 3) ? DTFMT_RFC822 : DTFMT_RFC850;
        }
        if (*cp++ != SPACE || !ParseWkDay(s, wkdaylen)) return;

        BOOL ok = FALSE;
        switch (fmt) {
        case DTFMT_RFC822:
            ok = ParseInt(&day, 2, SPACE) &&
                 ParseMonth(SPACE) &&
                 ParseInt(&year, 4, SPACE) &&
                 ParseTime() &&
                 strcmp(cp, "GMT") == 0;
            break;

        case DTFMT_RFC850:
            ok = ParseInt(&day, 2, DASH) &&
                 ParseMonth(DASH) &&
                 ParseInt(&year, 2, SPACE) &&
                 ParseTime() &&
                 strcmp(cp, "GMT") == 0;

            // Handle 2-digit year
            year = (WORD) (year + ((year < 70) ? 2000 : 1900));
            break;

        case DTFMT_ANSIC:
            ok = ParseMonth(SPACE) &&
                 ((*cp == SPACE) ?
                    (cp++, ParseInt(&day, 1, SPACE)) :
                    ParseInt(&day, 2, SPACE)) &&
                 ParseTime() &&
                 ParseInt(&year, 4, 0);
            break;
        }

        if (ok && VerifyMonthDay()) {
            // Mark the object as valid if everything was ok
            this->format = (WORD) fmt;
        }
    }

    // Parse an integer field
    BOOL ParseInt(WORD* result, INT width, CHAR sep) {
        WORD val = 0;
        while (width--) {
            if (*cp < '0' || *cp > '9') return FALSE;
            val = (WORD) (val*10 + (*cp++ - '0'));
        }
        if (*cp++ != sep) return FALSE;
        *result = val;
        return TRUE;
    }

    // Parse the time field hh:mm:ss
    BOOL ParseTime() {
        return ParseInt(&hour, 2, COLON) &&
               ParseInt(&minute, 2, COLON) &&
               ParseInt(&second, 2, SPACE) &&
               hour < 24 &&
               minute < 60 &&
               second < 60;
    }

    // Interpret the day-of-week string
    BOOL ParseWkDay(const CHAR* s, INT len) {
        static const PCSTR wkdays[] = {
            "Sunday"
            "Monday",
            "Tuesday",
            "Wednesday",
            "Thursday",
            "Friday",
            "Saturday"
        };

        for (INT d=0; d < 7; d++) {
            if (strncmp(s, wkdays[d], len) == 0) {
                wkday = (WORD) d;
                return TRUE;
            }
        }
        return FALSE;
    }

    // Interpret the month string
    BOOL ParseMonth(CHAR sep) {
        static const CHAR months[] = "JanFebMarAprMayJunJulAugSepOctNovDec";
        const CHAR* s = months;

        for (INT m=0; m < 12; m++, s+=3) {
            if (s[0] == cp[0] &&
                s[1] == cp[1] && 
                s[2] == cp[2]) {
                if (cp[3] == sep) {
                    cp += 4;
                    month = (WORD) (m+1);
                    return TRUE;
                } else
                    break;
            }
        }
        return FALSE;
    }

    // Verify the day of the month
    BOOL VerifyMonthDay() {
        // NOTE: This is a simple-minded check here
        // without taking leap-year into account.
        static const BYTE monthDays[12] = {
            31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31
        };

        return day > 0 && day <= monthDays[month-1];
    }

    VOID MarkInvalid() { format = DTFMT_INVALID; }
    BOOL IsInvalid() { return (format == DTFMT_INVALID); }

    // Date/time string format
    enum {
        DTFMT_INVALID,
        DTFMT_RFC822,
            // RFC 822 format: Sun, 06 Nov 1994 08:49:37 GMT
        DTFMT_RFC850,
            // RFC 850 format: Sunday, 06-Nov-94 08:49:37 GMT
        DTFMT_ANSIC,
            // ANSI C's asctime() format: Sun Nov  6 08:49:37 1994
    };

    WORD format;
    WORD year, month, day, wkday;
    WORD hour, minute, second;
    const CHAR* cp;
};

#endif // !_HTTPTIME_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\inc\ethernet.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    ethernet.h

Abstract:

    Ethernet and ARP protocol related declarations

Notes:

    Please refer to RFC 894, 826, and 1042.
    Also see RFC 1122, section 2.3.2 on ARP.

Revision History:

    05/02/2000 davidx
        Created it.

--*/

#ifndef _ETHERNET_H
#define _ETHERNET_H

//
// Ethernet hardware address is 6 bytes (48 bits)
//
#define ENETADDRLEN 6

//
// Ethernet frame header
//
#include <pshpack1.h>

typedef struct _EnetFrameHeader {
    BYTE dstaddr[ENETADDRLEN];
    BYTE srcaddr[ENETADDRLEN];
    WORD etherType;
} EnetFrameHeader;

#include <poppack.h>

//
// Ethernet frame header is 14 bytes
//
#define ENETHDRLEN sizeof(EnetFrameHeader)

//
// Mininum and maximum data size in an Ethernet frame
//
#define ENET_MINDATASIZE 46
#define ENET_MAXDATASIZE 1500

//
// Ethernet frame types
//
#define ENETTYPE_IP         0x0800
#define ENETTYPE_ARP        0x0806
#define ENETTYPE_LOOPBACK   0x9000

//
// IEEE 802.LLC and SNAP headers
//
#include <pshpack1.h>

typedef struct _IEEE802Header {
    BYTE DSAP;          // 0xaa
    BYTE SSAP;          // 0xaa
    BYTE control;       // 0x03
    BYTE orgcode[3];    // 0x00 0x00 0x00
    WORD etherType;
} IEEE802Header;

#define IEEE802HDRLEN sizeof(IEEE802Header)

#include <poppack.h>

//
// Constants we expect in the IEEE header
//
#define SNAP_DSAP 0xaa
#define SNAP_SSAP 0xaa
#define LLC_DGRAM 3

//
// Check if an Ethernet frame is actually an 802.3 frame
//
INLINE BOOL IsIEEE802Frame(WORD etherType) {
    return etherType <= ENET_MAXDATASIZE;
}

//
// Determine if an Ethernet hardware address is
// a broadcast or a multicast address
//
extern const BYTE EnetBroadcastAddr[ENETADDRLEN];

INLINE BOOL IsEnetAddrMcast(const BYTE* enetAddr) {
    return (enetAddr[0] & 1) != 0;
}

//
// ARP packet format
//
#include <pshpack1.h>

typedef struct _ArpPacket {
    WORD hrd;               // hardware address space
    WORD pro;               // protocol address space: ENETTYPE_IP
    BYTE hln;               // hardware address length: 6
    BYTE pln;               // protocol address length: 4
    WORD op;                // opcode
    BYTE sha[ENETADDRLEN];  // sender's hardware address
    IPADDR spa;             // sender's protocol address
    BYTE tha[ENETADDRLEN];  // target's hardware address
    IPADDR tpa;             // target's protocol address
} ArpPacket;

#include <poppack.h>

//
// Size of an ARP packet
//
#define ARPPKTLEN sizeof(ArpPacket)

//
// ARP packet opcodes
//
#define ARP_REQUEST 1
#define ARP_REPLY   2

//
// ARP hardware address spaces
//
#define ARP_HWTYPE_ENET 1
#define ARP_HWTYPE_802  6

#endif // !_ETHERNET_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\http\wininetp.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    wininetp.h

Abstract:

    Private header file for lightweight HTTP client implementation

Revision History:

    08/08/2000 davidx
        Created it.

--*/

#ifndef _WININETP_H
#define _WININETP_H


//
// Header information common to all handle types
//
class BaseObject {

protected:

    LONG lock;
        // Object lock

    #define OBJLOCK_CLOSED  '-NIH'
    #define OBJLOCK_ACTIVE  '+NIH'
    #define OBJLOCK_BUSY    '*NIH'

    LONG refcount;
        // reference count

    INT type;
        // Object type

    #define OBJTYPE_NONE        0
    #define OBJTYPE_INTERNET    1
    #define OBJTYPE_CONNECT     2
    #define OBJTYPE_REQUEST     3

protected:
    
    BaseObject(INT type) {
        lock = OBJLOCK_ACTIVE;
        this->type = type;
        refcount = 1;
    }

    virtual ~BaseObject() {
        // Mark the object as freed for simple protection
        // against apps that reuse a closed handle.
        lock = OBJLOCK_CLOSED;
    }

public:

    //
    // Lock an object handle
    //
    static BaseObject* Lock(HINTERNET handle, INT type) {
        BaseObject* obj = (BaseObject*) handle;
        INT err = ERROR_INVALID_HANDLE;
        LONG lock;

        // NOTE: We don't allow multiple threads to access the same
        // handle simultaneously. If the app tries to do that, the first
        // thread will succeed and other threads will get an error return.

        if (obj) {
            lock = InterlockedCompareExchange(&obj->lock, OBJLOCK_BUSY, OBJLOCK_ACTIVE);
            if (lock == OBJLOCK_ACTIVE) {
                if (obj->type == type || type == OBJTYPE_NONE) return obj;
                obj->Unlock();
            }

            if (lock == OBJLOCK_BUSY)
                err = ERROR_BUSY;
        }

        WARNING_("Invalid Wininet handle: %x, %d", obj, err);
        SetLastError(err);
        return NULL;
    }

    //
    // Unlock an object
    //
    VOID Unlock() {
        // NOTE: we assume this is an atomic operation
        lock = OBJLOCK_ACTIVE;
    }

    //
    // Increment / decrement the reference count of a handle
    //
    LONG AddRef() {
        return InterlockedIncrement(&refcount);
    }

    LONG Release() {
        LONG count = InterlockedDecrement(&refcount);
        if (count == 0) delete this;
        return count;
    }
};


//
// Object returned by InternetOpen call (OBJTYPE_INTERNET)
//
class InternetObject : public BaseObject {

public:
    // Instantiation
    static InternetObject*
    Create(
        const WCHAR* userAgent,
        const WCHAR* proxyServer
        );

    CHAR* GetUserAgent() { return userAgent; }
    CHAR* GetProxyServer() { return proxyServer; }
    struct in_addr GetProxyServerAddr() { return proxyServerAddr; }

protected:

    InternetObject() : BaseObject(OBJTYPE_INTERNET) {
        userAgent = proxyServer = NULL;
        wsastartup = FALSE;
    }

    ~InternetObject() {
        Free(userAgent);
        Free(proxyServer);
        if (wsastartup) {
            WSACleanup();
        }
    }

    CHAR* userAgent;
        // User agent

    CHAR* proxyServer;
        // Pointer to the proxy server name
        // NULL if we're not using proxy

    struct in_addr proxyServerAddr;
        // Proxy server IP address (0 if no proxy is used)

    BOOL wsastartup;
        // Whether we called WSAStartup successfully
};


//
// Special separators
//
enum {
    CR = 0xd,
    LF = 0xa,
    TAB = '\t',
    SPACE = ' ',
    COMMA = ',',
    SLASH = '/',
    COLON = ':',
    DASH = '-'
};


//
// Buffers for holding HTTP request/response header information
//
class HdrBuf {

public:

    UINT size;
        // Number of bytes currently in the buffer

    UINT maxsize;
        // Max buffer size

    BYTE* data;
        // Pointer to data buffer

    //
    // Constructor / destructor
    //
    HdrBuf() {
        size = maxsize = 0;
        data = NULL;
    }
    ~HdrBuf() { Dispose(); }

    //
    // Amount of space left in this buffer
    //
    UINT SpaceLeft() { return (maxsize-size); }

    //
    // Reserve additional space in the buffer
    //
    BOOL ReserveSpace(UINT bytesNeeded) {
        return (bytesNeeded <= SpaceLeft()) ||
               Alloc(size + bytesNeeded);
    }

    //
    // Append data to the end of this buffer
    //
    INT Append(const VOID* buf, UINT buflen) {
        // If the data buffer is too small, grow it first
        if (!ReserveSpace(buflen)) return 0;

        CopyMem(data+size, buf, buflen);
        size += buflen;
        return 1;
    }

    //
    // Append ASCII string to the buffer
    //
    INT AppendAsciiString(const CHAR* str, CHAR sep) {
        UINT len = strlen(str);

        if (!ReserveSpace(len+2)) return 0;
        CopyMem(data+size, str, len);
        size += len;

        AppendSeparator(sep);
        return 1;
    }

    //
    // Append Unicode string to the buffer
    //
    INT AppendUnicodeString(const WCHAR* str, CHAR sep) {
        UINT len = wcslen(str);

        if (!ReserveSpace(len+2)) return 0;

        BYTE* p = data + size;
        size += len;
        while (len--)
            *p++ = (BYTE) *str++;
        
        AppendSeparator(sep);
        return 1;
    }

    //
    // Free the data buffer
    //
    VOID Dispose() {
        Free(data);
        data = NULL;
        size = maxsize = 0;
    }

private:

    enum { ALLOCINCR = 1024 };
        // Grow the buffer in 1KB blocks

    //
    // Allocate data memory for this buffer
    //
    BOOL Alloc(UINT newMaxsize) {
        // Check if the buffer is already big enough
        if (maxsize >= newMaxsize) return TRUE;

        // Allocate new data buffer
        newMaxsize = (newMaxsize+ALLOCINCR-1) & ~(ALLOCINCR-1);
        BYTE* newData = (BYTE*) MAlloc(newMaxsize);
        if (!newData) return FALSE;

        // Copy the content of the existing data buffer
        if (size) {
            CopyMem(newData, data, size);
        }
        Free(data);
        data = newData;
        maxsize = newMaxsize;
        return TRUE;
    }

    //
    // Append separator to the buffer
    //  The buffer has at least 2 bytes of available space
    //
    VOID AppendSeparator(CHAR sep) {
        switch (sep) {
        case 0:
            break;
        case LF:
            data[size++] = CR;
            data[size++] = LF;
            break;
        case COMMA:
            data[size++] = COMMA;
            data[size++] = SPACE;
            break;
        case COLON:
            data[size++] = COLON;
            data[size++] = SPACE;
            break;
        default:
            data[size++] = sep;
            break;
        }
    }
};


//
// Object returned by InternetConnect call (OBJTYPE_CONNECT)
//
class ConnectObject : public BaseObject {
public:

    // Instantiate a new HTTP connection object
    static ConnectObject*
    Create(
        InternetObject* inetobj,
        const WCHAR* serverName,
        INTERNET_PORT serverPort,
        const WCHAR* username,
        const WCHAR* password,
        DWORD_PTR appContext
        );

    // Return the server address and port number
    // for this connection object
    VOID GetServerAddr(struct sockaddr_in* serveraddr) {
        ZeroMem(serveraddr, sizeof(*serveraddr));
        serveraddr->sin_family = AF_INET;
        serveraddr->sin_port = HTONS(serverPort);
        serveraddr->sin_addr = serverAddr;
    }

    CHAR* GetServerName() { return serverName; }
    CHAR* GetUserName() { return username; }
    InternetObject* GetInternetObject() { return inetobj; }

protected:

    ConnectObject() : BaseObject(OBJTYPE_CONNECT) {
        inetobj = NULL;
        serverName = username = password = NULL;
    }

    ~ConnectObject() {
        if (inetobj) inetobj->Release();
        Free(serverName);
        Free(username);
        Free(password);
    }

    InternetObject* inetobj;
        // Reference to the internet object

    CHAR* serverName;
    struct in_addr serverAddr;
    INTERNET_PORT serverPort;
        // Server host name and IP address and port number
    
    CHAR* username;
    CHAR* password;
        // Username and password
    
    DWORD_PTR appContext;
        // App-specific context value
};


//
// Object returned by InternetOpenUrl and InternetOpenRequest calls (OBJTYPE_REQUEST)
//
class RequestObject : public BaseObject {

public:

    // Instantiate a new HTTP request object
    static RequestObject*
    Create(
        ConnectObject* connobj,
        const WCHAR* verb,
        const WCHAR* objectName,
        const WCHAR* httpVer,
        const WCHAR* referer,
        const WCHAR* acceptTypes[],
        DWORD_PTR appContext
        );

    // Send out the HTTP request
    BOOL
    SendRequest(
        const WCHAR* headers,
        UINT headerLength,
        const VOID* optionalData,
        UINT optionalLength
        );

    // Query response header information
    BOOL
    QueryRespInfo(
        DWORD infoLevel,
        WCHAR* buffer,
        DWORD* buflen,
        DWORD* hdrindex
        );

    // Query the amount of HTTP response data available
    BOOL QueryDataAvailable(DWORD* bytesAvailable);

    // Read HTTP response data
    BOOL ReadData(CHAR* buffer, UINT bufferSize, DWORD* bytesRead);

protected:

    RequestObject() : BaseObject(OBJTYPE_REQUEST) {
        connobj = NULL;
        sock = INVALID_SOCKET;
    }

    ~RequestObject() {
        Disconnect();
        if (connobj) connobj->Release();
    }

    BOOL IsConnected() { return (sock != INVALID_SOCKET); }
    BOOL Connect();
    VOID Disconnect() {
        if (sock != INVALID_SOCKET) {
            closesocket(sock);
            sock = INVALID_SOCKET;
        }
        ResetRespInfo();
    }

    VOID ResetRespInfo() {
        resphdrs.Dispose();
        resphdrsOk = FALSE;
        resphdrLinecnt = 0;
        peekdata = resphdrs.data;
        peeklen = 0;
        contentlen = 0xffffffff;
        readcnt = 0;
    }

    BOOL ReadRespHdrs(BOOL wait);
    BOOL IsRespHdrsOk() { return resphdrsOk != 0; }
    VOID ParseRespHdrs(BOOL eof);
    BOOL MatchHeaderField(BYTE* data, const CHAR* fieldname, CHAR** fieldval);

    CHAR* ParseStatusLine(CHAR* buf, DWORD buflen, DWORD field);
    BOOL ReturnAllRespHdrs(WCHAR* buf, DWORD* buflen, DWORD field);

    ConnectObject* connobj;
        // Reference to the parent connection object
    
    DWORD_PTR appContext;
        // App-specific context value

    SOCKET sock;
        // Open socket handle

    HdrBuf reqhdrs;
        // HTTP request headers

    enum { MAXRESPHDRS = 32 };
        // Maximum number of HTTP response headers allowed

    HdrBuf resphdrs;
    BOOL resphdrsOk;
    BYTE* resphdrLines[MAXRESPHDRS];
    UINT resphdrLinecnt;
    BYTE* peekdata;
    UINT peeklen;
    UINT contentlen;
    UINT readcnt;
        // HTTP response information
};


//
// Macros for getting 
//
#define LOCK_INTERNET_OBJECT(_handle) \
        ((InternetObject*) BaseObject::Lock(_handle, OBJTYPE_INTERNET))

#define LOCK_CONNECT_OBJECT(_handle) \
        ((ConnectObject*) BaseObject::Lock(_handle, OBJTYPE_CONNECT))

#define LOCK_REQUEST_OBJECT(_handle) \
        ((RequestObject*) BaseObject::Lock(_handle, OBJTYPE_REQUEST))


//
// Wrap implementation-specific global functions
// and variable in our private namespace.
//
namespace WininetImpl {
    //
    // Resolve a host name to its IP address
    //  if the host name string is in dotted decimal form, 
    //  it's treated directly as an IP address string.
    //
    struct in_addr ResolveHostAddr(const CHAR* hostname);

    //
    // Crack an HTTP URL to extract various parts:
    //  serverName
    //  serverPort
    //  objectName
    //
    BOOL
    HttpParseUrl(
        const WCHAR* url,
        WCHAR** serverName,
        INTERNET_PORT* serverPort,
        WCHAR** objectName
        );


    //
    // Default HTTP string constants
    //
    extern const WCHAR HttpDefaultVerbStr[];
    extern const WCHAR HttpDefaultVersionStr[];
    extern const WCHAR HttpDefaultObjectStr[];

    //
    // Wrappers for Winsock APIs
    //
    inline _connect(SOCKET s, struct sockaddr_in* addr) {
        return connect(s, (struct sockaddr*) addr, sizeof(*addr));
    }

    //
    // Convert a Unicode string to an ASCII string
    //
    inline CHAR* strdupWtoA(const WCHAR* wstr, UINT count = 0xffffffff) {
        if (count == 0xffffffff) count = wcslen(wstr) + 1;
        CHAR* str = (CHAR*) MAlloc(count);
        CHAR* p;

        if ((p = str) != NULL) {
            // Just chop off the high byte of the Unicode value
            while (count--)
                *p++ = (CHAR) *wstr++;
        }
        return str;
    }

    inline VOID strcpyWtoA(CHAR* dst, const WCHAR* src) {
        while ((*dst++ = (CHAR) *src++) != 0) ;
    }

    inline VOID strcpyAtoW(WCHAR* dst, const CHAR* src) {
        while ((*dst++ = (UCHAR) *src++) != 0) ;
    }
}

using namespace WininetImpl;

#endif // !_WININETP_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\inc\ip.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    ip.h

Abstract:

    IPv4 protocol related declarations

Notes:

    Please refer to RFC 791, 950, and 1519.

Revision History:

    05/02/2000 davidx
        Created it.

--*/

#ifndef _IP_H
#define _IP_H

//
// IPv4 datagram header
//
typedef struct _IpHeader {
    BYTE ver_hdrlen;    // version & header length
    BYTE tos;           // type of service
    WORD length;        // total length
    WORD id;            // identification
    WORD fragoffset;    // flags & fragment offset
    BYTE ttl;           // time to live
    BYTE protocol;      // protocol
    WORD hdrxsum;       // header checksum
    IPADDR srcaddr;     // source address
    IPADDR dstaddr;     // destination address
} IpHeader;

// IP datagram header length without options (20 bytes)
#define IPHDRLEN sizeof(IpHeader)

// Maximum IP header length (60 bytes)
#define MAXIPHDRLEN (15*4)

// Maximum IP datagram length
#define MAXIPLEN 0xffff

// Check IP version and get header length (in bytes)
#define IPVER4 0x40
#define VERIFY_IPVER_HDRLEN(_verhdrlen) \
        ((((_verhdrlen) & 0xf0) == IPVER4) ? (((_verhdrlen) & 0x0f) << 2) : 0)

#define GETIPHDRLEN(_iphdr) (((_iphdr)->ver_hdrlen & 0x0f) << 2)
#define GETIPLEN(_iphdr)    NTOHS((_iphdr)->length)

//
// Bit assignment for the flags & fragment offset field
//  bit 15: reserved
//  bit 14: 1 = don't fragment
//  bit 13: 1 = more fragments
//  bit 12-0: fragment offset (in units of 8 bytes)
//
#define DONT_FRAGMENT   BIT(14)
#define MORE_FRAGMENTS  BIT(13)
#define FRAGOFFSET_MASK 0x1fff

//
// IP option tags
//  bit 7: 1 = option copied into fragments
//  bit 6-5: option class
//  bit 4-0: option number
//
#define IPOPT_EOL               0x00    // no copy
#define IPOPT_NOP               0x01    // no copy
#define IPOPT_SECURITY          0x82    // copy, control
#define IPOPT_LOOSE_SRCROUTE    0x83    // copy, control
#define IPOPT_RECORD_ROUTE      0x07    // no copy, control
#define IPOPT_STREAM_ID         0x88    // copy, control
#define IPOPT_STRICT_SRCROUTE   0x89    // copy, control
#define IPOPT_TIMESTAMP         0x44    // no copy, debug

//
// IP protocol numbers
//
#define IPPROTOCOL_ICMP 1
#define IPPROTOCOL_IGMP 2
#define IPPROTOCOL_TCP  6
#define IPPROTOCOL_UDP  17

#endif // !_IP_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\inc\debug.h ===
/*++

Copyright (c) 1999

Module Name:

    debug.h

Abstract:

    Macros used for debugging purposes

Revision History:

    12/16/1999 davidx
        Created it.

--*/

#ifndef _DEBUG_H
#define _DEBUG_H

#include <xdbg.h>

//
// These macros are used for debugging purposes.
// They expand to nop on a free build.
//
#ifndef XNET_DEBUG_COMPILE_LEVEL
#define XNET_DEBUG_COMPILE_LEVEL XDBG_COMPILE_LEVEL
#endif

#if DBG && (XNET_DEBUG_COMPILE_LEVEL >= XDBG_WARNING)
extern VOID XnetDbgWarn(CHAR* format, ...);
#define WARNING_ XnetDbgWarn
#else 
#define WARNING_ 1 ? (void)0 : (void)
#endif

#if DBG && (XNET_DEBUG_COMPILE_LEVEL >= XDBG_TRACE)
extern VOID XnetDbgVerbose(CHAR* format, ...);
#define VERBOSE_ XnetDbgVerbose
#else 
#define VERBOSE_ 1 ? (void)0 : (void)
#endif

#if DBG && (XNET_DEBUG_COMPILE_LEVEL >= XDBG_ENTRY)
extern VOID XnetDbgTrace(CHAR* format, ...);
#define TRACE_ XnetDbgTrace
#else 
#define TRACE_ 1 ? (void)0 : (void)
#endif

#if DBG

#define ASSERT_DISPATCH_LEVEL() \
        ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL)

//
// This macro is used as a reminder that a particular function
// needs to run at DISPATCH_LEVEL.
//
#define RUNS_AT_DISPATCH_LEVEL

#else // !DBG

#define ASSERT_DISPATCH_LEVEL()
#define RUNS_AT_DISPATCH_LEVEL

#endif // !DBG

#endif // !_DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\inc\nettypes.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    nettypes.h

Abstract:

    Common type definitions for the networking code

Revision History:

    05/04/2000 davidx
        Created it.

--*/

#ifndef _NETTYPES_H
#define _NETTYPES_H

//
// C inline function declaration
//
#define INLINE __inline

//
// Private function declaration
//  don't do it for debug build
//
#if DBG
#define PRIVATE
#else
#define PRIVATE static
#endif

//
// Map from bit index to bit mask
//
#define BIT(n) (1u << (n))

//
// System pool allocation functions
//
INLINE VOID* SysAlloc(SIZE_T size, ULONG tag) {
    return ExAllocatePoolWithTag(size, tag);
}

INLINE VOID* SysAlloc0(SIZE_T size, ULONG tag) {
    VOID* p = ExAllocatePoolWithTag(size, tag);
    if (p) { memset(p, 0, size); }
    return p;
}

INLINE VOID SysFree(VOID* ptr) {
    if (ptr) { ExFreePool(ptr); }
}

//
// Private pool allocation functions
//
NTSTATUS XnetPoolInit();
VOID XnetPoolCleanup();
VOID XnetPoolDump();
VOID* XnetAlloc(SIZE_T size, ULONG tag);
VOID XnetFree(VOID* ptr);
INLINE VOID* XnetAlloc0(SIZE_T size, ULONG tag) {
    VOID* p = XnetAlloc(size, tag);
    if (p) { memset(p, 0, size); }
    return p;
}

extern VOID* (*XnetUncachedAllocProc)(SIZE_T, ULONG);
extern VOID (*XnetUncachedFreeProc)(VOID*);
#ifdef DVTSNOOPBUG
NTSTATUS XnetUncachedPoolInit();
VOID XnetUncachedPoolCleanup();
#endif


//------------------------------------------------------------------------
// IP address and port types
//------------------------------------------------------------------------

// Byte-order swapping macros
//  - equivalent to htons/htonl/ntohs/ntohl functions
//  - assumes we're on a little-endian machine

#define HTONL(l) \
        ((((l) >> 24) & 0x000000FFL) | \
         (((l) >>  8) & 0x0000FF00L) | \
         (((l) <<  8) & 0x00FF0000L) | \
         (((l) << 24)              ))

#define HTONS(s) ((WORD) \
        ((((s) >> 8) & 0x00FF) | \
         (((s) << 8) & 0xFF00)))

#define NTOHL HTONL
#define NTOHS HTONS

// IPv4 address in network byte order
typedef DWORD IPADDR;

#define IPADDRLEN                sizeof(IPADDR)
#define IPADDR_ANY               0
#define IPADDR_BCAST             0xffffffff
#define IPADDR_LOOPBACK          HTONL(0x7f000001)
#define IPADDR_ALLHOSTS          HTONL(0xe0000001)
#define IPADDR_ALLROUTERS        HTONL(0xe0000002)
#define CLASSA_NETMASK           HTONL(0xff000000)
#define CLASSB_NETMASK           HTONL(0xffff0000)
#define CLASSC_NETMASK           HTONL(0xffffff00)
#define CLASSD_NETMASK           HTONL(0xf0000000)
#define CLASSD_NETID             HTONL(0xe0000000)
#define LOOPBACK_NETID           HTONL(0x7f000000)
#define IS_MCAST_IPADDR          IS_CLASSD_IPADDR
#define IS_BCAST_IPADDR(addr)    ((addr) == IPADDR_BCAST)
#define IS_CLASSA_IPADDR(addr)   (((addr) & HTONL(0x80000000)) == 0)
#define IS_CLASSB_IPADDR(addr)   (((addr) & HTONL(0xc0000000)) == HTONL(0x80000000))
#define IS_CLASSC_IPADDR(addr)   (((addr) & HTONL(0xe0000000)) == HTONL(0xc0000000))
#define IS_CLASSD_IPADDR(addr)   (((addr) & CLASSD_NETMASK) == CLASSD_NETID)
#define IS_LOOPBACK_IPADDR(addr) (((addr) & CLASSA_NETMASK) == LOOPBACK_NETID)

// TCP/UDP port number in network byte order
typedef WORD IPPORT;

// Source and destination address/port combination
typedef struct _IpAddrPair {
    IPADDR dstaddr;
    IPADDR srcaddr;
    IPPORT dstport;
    IPPORT srcport;
} IpAddrPair;

//------------------------------------------------------------------------
// Network data packet
//------------------------------------------------------------------------

typedef struct _IfInfo IfInfo;
typedef struct _Packet Packet;
typedef struct _IpHeader IpHeader;
typedef struct _RouteTableEntry RTE;
typedef VOID (*PktCompletionProc)(Packet* pkt, NTSTATUS status);

typedef struct _Packet {
    Packet* nextpkt;
        // Points to the next packet in the queue

    WORD pktflags;
        // Packet flags

    WORD iphdrOffset;
        // Offset to where IP datagram header starts

    BYTE* data;
        // Points to where actual data starts

    UINT datalen;
        // Specifies amount of data in the packet

    union {
        IPADDR nexthop;
        IfInfo* recvifp;
        UINT_PTR ifdata;
    };
        // This field has different meaning depending on
        // whether the packet is an incoming packet or
        // an outgoing packet:
        //  for an outgoing packet -
        //      initially contains the next hop IP address
        //      later used as scratch space by the interface driver 
        //  for an incoming packet -
        //      a pointer to the receiving interface

    PktCompletionProc completionCallback;
        // Before passing a packet along for processing,
        // the caller can optionally set up a packet completion
        // routine. When the callee is done with the packet,
        // it'll calls CompletePacket to dispose of the packet.
        // CompletePacket will call the completion routine
        // if it's present. Otherwise, it simply frees the
        // packet memory buffer.
        //
        // !! IMPORTANT NOTE:
        // The callee must not reuse a packet for other purposes
        // if the completion routine is present. Specifically,
        // when an interface driver passes a packet to the upper
        // layer protocols, the upper layer protocol must not
        // reuse the same packet for transmission if the packet
        // completion routine is set.

    BYTE buf[1];
        // Variable size data buffer
} Packet;

//
// Packet header size
//  NOTE: Change the packet fields with care. It should be
//  kept to be a multiple of 8 bytes.
//
#define PKTHDRLEN offsetof(Packet, buf)

// Convenience macros for getting a typecasted pointer
// to the beginning of the packet data buffer and to
// the current packet data.
#define GETPKTBUF(_pkt, _type) ((_type *) (_pkt)->buf)
#define GETPKTDATA(_pkt, _type) ((_type *) (_pkt)->data)

// Figure out where the IP header data starts
#define GETPKTIPHDR(_pkt) ((IpHeader*) ((BYTE*) (_pkt) + (_pkt)->iphdrOffset))
#define SETPKTIPHDR(_pkt, _iphdr) (_pkt)->iphdrOffset = (WORD) ((BYTE*) (_iphdr) - (BYTE*) (_pkt))

//
// bit 0: whether the packet memory came from our private pool
// bit 1: whether the packet is used by the debug monitor stack
// bit 2: physically contiguous memory allocated for DMA transfer
// bit 3: received as link-layer broadcast or multicast packet
//
#define PKTFLAG_NETPOOL BIT(0)  // came from our private pool
#define PKTFLAG_DBGMON  BIT(1)  // used by the debug monitor stack
#define PKTFLAG_DMA     BIT(2)  // receive-only
#define PKTFLAG_MCAST   BIT(3)  // receive-only
#define PKTFLAG_REXMIT  BIT(4)  // send-only: for retransmitted packets
#define PKTFLAG_UNCACHED BIT(5) // temporary hack to workaround nv2a bug

// Allocate and free a network packet
Packet* XnetAllocPacket(UINT size, UINT pktflags);
INLINE VOID XnetFreePacket(Packet* pkt) {
    #ifdef DVTSNOOPBUG
    if (pkt->pktflags & PKTFLAG_UNCACHED) {
        XnetUncachedFreeProc(pkt);
    } else
    #endif
    if (pkt->pktflags & PKTFLAG_NETPOOL) {
        XnetFree(pkt);
    } else {
        SysFree(pkt);
    }
}

// Call this to dispose a packet when we're done using it
INLINE VOID XnetCompletePacket(Packet* pkt, NTSTATUS status) {
    if (pkt->completionCallback) {
        // If the packet has an associated completion function, call it.
        pkt->completionCallback(pkt, status);
    } else {
        // Otherwise, just free it back to the packet pool
        XnetFreePacket(pkt);
    }
}

// Set packet completion function
INLINE VOID XnetSetPacketCompletion(Packet* pkt, PktCompletionProc proc) {
    pkt->completionCallback = proc;
}

//
// Calculate the free space in a packet before and after
// the current data buffer:
//  pkt             pkt->data  ... + pkt->datalen
//   |               |                |
//   v  header       v                v
//  |xxxxxxxxxxx     xxxxxxxxxxxxxxxxx          |
//              space                   space
//              before                  after
//
#define PktSpaceBefore(_pkt) \
        ((_pkt)->data - (_pkt)->buf)

//------------------------------------------------------------------------
// A singly-linked packet queue
//------------------------------------------------------------------------

typedef struct _PacketQueue {
    Packet* head;
    Packet* tail;
} PacketQueue;

// Initialize a packet queue
#define PktQInit(_q) ((_q)->head = (_q)->tail = NULL)

// Determine if a packet queue is empty
#define PktQIsEmpty(_q) ((_q)->head == NULL)

// Insert a packet to the end of a packet queue
INLINE VOID PktQInsertTail(PacketQueue* q, Packet* pkt) {
    if (q->tail)
        q->tail->nextpkt = pkt;
    else
        q->head = pkt;

    q->tail = pkt;
    pkt->nextpkt = NULL;
}

// Insert a packet to the beginning of a packet queue
INLINE VOID PktQInsertHead(PacketQueue* q, Packet* pkt) {
    if ((pkt->nextpkt = q->head) == NULL)
        q->tail = pkt;
    q->head = pkt;
}

// Remove a packet at the head of a packet queue
//  !!! The queue must not be empty when this is called.
INLINE Packet* PktQRemoveHead(PacketQueue* q) {
    Packet* pkt = q->head;

    if ((q->head = pkt->nextpkt) == NULL)
        q->tail = NULL;
    else
        pkt->nextpkt = NULL;

    return pkt;
}

// Join two queues together:
//  q2 is inserted before q1
//  and we assume q2 isn't empty
INLINE VOID PktQJoinBefore(PacketQueue* q1, PacketQueue* q2) {
    if (!q1->tail) q1->tail = q2->tail;
    q2->tail->nextpkt = q1->head;
    q1->head = q2->head;
}

#endif // !_NETTYPES_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\inc\netutil.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    netutil.h

Abstract:

    Common functions and macros shared by the networking code

Revision History:

    03/27/2000 davidx
        Created it.

--*/

#ifndef _NETUTIL_H
#define _NETUTIL_H

//
// Misc. macros
//
#define SizeofWSTR(ws)  ((wcslen(ws) + 1) * sizeof(WCHAR))
#define SizeofSTR(s)    ((strlen(s) + 1) * sizeof(CHAR))
#define ARRAYCOUNT(a)   (sizeof(a) / sizeof(a[0]))
#define ROUNDUP4(count) (((UINT)(count) + 3) & ~3)
#define ROUNDUP8(count) (((UINT)(count) + 7) & ~7)
#define ZeroMem(p, n)   memset(p, 0, n)
#define CopyMem         memcpy
#define MoveMem         memmove
#define EqualMem(d,s,n) (memcmp(d, s, n) == 0)

//
// Memory allocation and deallocation functions
//

#ifdef _XNET_SERVICE

// allocate from the process heap
INLINE VOID* MAlloc(SIZE_T size) {
    return (VOID*) LocalAlloc(LMEM_FIXED, size);
}

INLINE VOID* MAlloc0(SIZE_T size) {
    return (VOID*) LocalAlloc(LPTR, size);
}

// free to the process heap
INLINE VOID Free(VOID* ptr) {
    LocalFree((HLOCAL) (ptr));
}

#endif // _XNET_SERVICE

//
// General net error codes:
//  facility = win32 + winsock error code
//
#define NETERR(_err)        HRESULT_FROM_WIN32(_err)
#define NETERR_OK           STATUS_SUCCESS
#define NETERR_PARAM        NETERR(WSAEINVAL)
#define NETERR_MEMORY       NETERR(WSAENOBUFS)
#define NETERR_SYSCALL      NETERR(WSASYSCALLFAILURE)
#define NETERR_FAULT        NETERR(WSAEFAULT)
#define NETERR_CANCELLED    NETERR(WSAECANCELLED)
#define NETERR_PENDING      NETERR(WSA_IO_PENDING)
#define NETERR_WOULDBLOCK   NETERR(WSAEWOULDBLOCK)
#define NETERR_MSGSIZE      NETERR(WSAEMSGSIZE)
#define NETERR_TIMEOUT      NETERR(WSAETIMEDOUT)
#define NETERR_NOTIMPL      NETERR(ERROR_CALL_NOT_IMPLEMENTED)
#define NETERR_UNREACHABLE  NETERR(WSAEHOSTUNREACH)
#define NETERR_NETDOWN      NETERR(WSAENETDOWN)
#define NETERR_ADDRINUSE    NETERR(WSAEADDRINUSE)
#define NETERR_ADDRCONFLICT NETERR(ERROR_DHCP_ADDRESS_CONFLICT)
#define NETERR_CONNRESET    NETERR(WSAECONNRESET)

// XBox-specific net error codes:
#define NETERR_HARDWARE     0x801f0001  // hardware not responding
#define NETERR_DISCARDED    0x801f0002  // packet discarded
#define NETERR_REASSEMBLY   0x801f0003  // IP datagram reassembly failed

//
// Raise IRQL to DISPATCH_LEVEL and restore it
//
#define RaiseToDpc KeRaiseIrqlToDpcLevel
#define LowerFromDpc KeLowerIrql

// Check if a doubly-linked list head is NULL (uninitialized)
#define IsListNull(_list) ((_list)->Flink == NULL)

#ifndef _NTSYSTEM_

//
// Pseudo-random number generator
//  range: 0 to 0x7fffffff
//
extern ULONG XnetRandSeed;

VOID XnetInitRandSeed();

INLINE ULONG XnetRand() {
    return RtlRandom(&XnetRandSeed);
}

INLINE ULONG XnetRandScaled(ULONG maxval) {
    return RtlRandom(&XnetRandSeed) % (maxval+1);
}

// Check if an IP address is a valid non-loopback unicast address
INLINE XnetIsValidUnicastAddr(IPADDR addr) {
    return (addr != 0) &&
           !IS_BCAST_IPADDR(addr) &&
           !IS_MCAST_IPADDR(addr) &&
           !IS_LOOPBACK_IPADDR(addr);
}

// Convert an IP address to an ASCII character string and vice versa
CHAR* IpAddrToString(IPADDR ipaddr, CHAR* buf, INT buflen);
BOOL IpAddrFromString(const CHAR* str, IPADDR* addr);

INLINE CHAR* IPADDRSTR(IPADDR ipaddr) {
    static CHAR buf[16];
    return IpAddrToString(ipaddr, buf, sizeof(buf));
}

// Return the default subnet mask for a given IP address
IPADDR XnetGetDefaultSubnetMask(IPADDR ipaddr);

// Check if a subnet mask is valid (i.e. of the form 111...000)
INLINE BOOL XnetIsValidSubnetMask(IPADDR addrmask) {
    addrmask = ~NTOHL(addrmask);
    return (addrmask & (addrmask+1)) == 0;
}

//
// Compute and set the checksum field of some message header
//
UINT tcpipxsum(UINT xsum, const VOID* buf, UINT buflen);
#define COMPUTE_CHECKSUM(_field, _buf, _len) \
        (_field) = 0; \
        (_field) = (WORD) ~tcpipxsum(0, _buf, _len)

//
// Make a copy of the specified packet
//
Packet* XnetCopyPacket(Packet* pkt, UINT extraHdr);

//
// Deferenece an XAPI event handle to get
// a pointer to the kernel-mode event object
//
INLINE PRKEVENT GetKernelEventObject(HANDLE hEvent) {
    NTSTATUS status;
    PRKEVENT kEvent;

    if (!hEvent) return NULL;
    status = ObReferenceObjectByHandle(
                hEvent,
                ExEventObjectType,
                (VOID**) &kEvent);

    return NT_SUCCESS(status) ? kEvent : NULL;
}

//
// Wait for a kernel event object to be signalled
//
INLINE NTSTATUS WaitKernelEventObject(PRKEVENT kEvent, UINT timeout) {
    LARGE_INTEGER waittime;
    NTSTATUS status;

    waittime.QuadPart = Int32x32To64(timeout, -10000);
    status = KeWaitForSingleObject(
                    kEvent,
                    UserRequest,
                    UserMode,
                    FALSE,
                    timeout ? &waittime : NULL);

    return (status == STATUS_SUCCESS) ? NETERR_OK : NETERR_TIMEOUT;
}

//
// Signal a kernel event object
//
INLINE VOID SetKernelEvent(PRKEVENT kEvent) {
    KeSetEvent(kEvent, EVENT_INCREMENT, FALSE);
}

#endif // !_NTSYSTEM_

//
// Pool tags
//
#define PTAG_POOL   '!TEN'
#define PTAG_PKT    '0TEN'
#define PTAG_ENET   '1TEN'
#define PTAG_ARP    '2TEN'
#define PTAG_LPBK   '3TEN'
#define PTAG_MCAST  '4TEN'
#define PTAG_RTE    '5TEN'
#define PTAG_PCB    '6TEN'
#define PTAG_TCB    '7TEN'
#define PTAG_RREQ   '8TEN'
#define PTAG_RBUF   '9TEN'
#define PTAG_DHCP   'aTEN'
#define PTAG_DNS    'bTEN'
#define PTAG_SOPTS  'cTEN'
#define PTAG_NIC    'dTEN'

#endif // !_NETUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\inc\interface.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    interface.h

Abstract:

    Common declarations for all network interfaces

Revision History:

    05/04/2000 davidx
        Created it.

--*/

#ifndef _INTERFACE_H
#define _INTERFACE_H

//
// Common information for all network interfaces
//
typedef VOID (*IfDeleteProc)(IfInfo*);
typedef VOID (*IfStartOutputProc)(IfInfo*);
typedef VOID (*IfTimerProc)(IfInfo*);
typedef NTSTATUS (*IfIoctlProc)(IfInfo*, INT, VOID*, UINT, VOID*, UINT*);
typedef struct _IfMcastData IfMcastData;
typedef struct _DhcpInfo DhcpInfo;

typedef struct _IfInfo {
    //
    // Reference count
    //
    LONG refcount;

    //
    // Interface name
    //
    const CHAR* ifname;

    //
    // Interface functions:
    //  deletion
    //  start output
    //  timer
    //  ioctl
    //
    IfDeleteProc Delete;
    IfStartOutputProc StartOutput;
    IfTimerProc Timer;
    IfIoctlProc Ioctl;

    //
    // Output packet queue
    //
    PacketQueue sendq;

    //
    // Flags:
    //  low-order word is common to all interface types
    //  high-order word is interface type specific
    //
    INT flags;

    #define IFFLAG_UP               0x0001  // interface is initialized
    #define IFFLAG_RUNNING          0x0002  //  ... and has a valid IP address
    #define IFFLAG_DHCP_ENABLED     0x0100  // interface is enabled for DHCP
    #define IFFLAG_BCAST            0x0200  // ... supports broadcast
    #define IFFLAG_MCAST            0x0400  // ... supports multicast
    #define IFFLAG_CONNECTED_BOOT   0x0800  // ... is connected to at boot time

    //
    // Hardware address
    //  maximum hardware address length is 16 bytes
    //
    #define MAXHWADDRLEN    16
    #define IFTYPE_LOOPBACK 0
    #define IFTYPE_ETHERNET 1
    #define IFTYPE_DIALUP   2

    WORD iftype;
    WORD hwaddrlen;
    BYTE hwaddr[MAXHWADDRLEN];

    //
    // IP address and subnet mask
    //
    IPADDR ipaddr, addrmask;
    IPADDR subnetAddr, subnetBcastAddr;

    //
    // DHCP related data
    //
    DhcpInfo* dhcpInfo;

    //
    // Multicast groups that we belong to.
    // NOTE: This points to an array of IfMcast structures.
    // The last structure must have its mcastaddr field = 0.
    //
    IfMcastData* mcastData;

    //
    // Misc. configuration parameters
    //
    UINT mtu;               // MTU (maximum transfer unit)
    UINT framehdrlen;       // link layer frame header length
} IfInfo;

//
// Maximum link-layer header size (for all interfaces)
//  should be a multiple of 4
//
#define MAXLINKHDRLEN 16

//
// We only support a maximum of 3 interfaces
//
#define IFINDEX_LOOPBACK    0
#define IFINDEX_LAN         1
#define IFINDEX_DIALUP      2
#define IFINDEX_MAX         3

extern IfInfo* Interfaces[IFINDEX_MAX];

#define LoopbackIfp Interfaces[IFINDEX_LOOPBACK]
#define LanIfp      Interfaces[IFINDEX_LAN]
#define DialupIfp   Interfaces[IFINDEX_DIALUP]

//
// Loop through all interfaces - notice that we count
// down from the last interface to the first interface.
//
#define LOOP_THRU_INTERFACE_LIST(_ifp) { \
            INT _ifindex = IFINDEX_MAX; \
            while (_ifindex-- > 0) { \
                if ((_ifp = Interfaces[_ifindex]) == NULL) continue;

#define END_INTERFACE_LIST_LOOP() \
            } \
        }

// Find the interface with the specified IP address
INLINE IfInfo* IfFindInterface(IPADDR ipaddr) {
    IfInfo* ifp;

    RUNS_AT_DISPATCH_LEVEL

    LOOP_THRU_INTERFACE_LIST(ifp)
        if (ifp->ipaddr == ipaddr) return ifp;
    END_INTERFACE_LIST_LOOP()
    return NULL;
}

// Cache a reference to an interface object
#define CACHE_IFP_REFERENCE(_var, _ifp) ((_var) = (_ifp))

//
// Convenience macros for checking interface flags
//
#define IfUp(_ifp) ((_ifp)->flags & IFFLAG_UP)
#define IfRunning(_ifp) ((_ifp)->flags & IFFLAG_RUNNING)
#define IfDhcpEnabled(_ifp) ((_ifp)->flags & IFFLAG_DHCP_ENABLED)
#define IfBcastEnabled(_ifp) ((_ifp)->flags & IFFLAG_BCAST)
#define IfMcastEnabled(_ifp) ((_ifp)->flags & IFFLAG_MCAST)
#define IfLoopback(_ifp) ((_ifp)->iftype == IFTYPE_LOOPBACK)

//
// Check if the specified address is a broadcast address
// for a particular interface
//
#define IfBcastAddr(_ifp, _addr) \
        (IS_BCAST_IPADDR(_addr) || (_addr) == (_ifp)->subnetBcastAddr)

//
// Append a packet to the end of an interface's output queue.
//  NOTE: we assume we're at DISPATCH_LEVEL.
//
#define IfEnqueuePacket(_ifp, _pkt) \
        PktQInsertTail(&_ifp->sendq, _pkt)

#define IfDequeuePacket(_ifp) \
        PktQRemoveHead(&_ifp->sendq)

//
// Interface I/O control code
//
#define IFCTL_SET_MCAST_ADDRS       1
#define IFCTL_CHECK_ADDR_CONFLICT   2
#define IFCTL_GET_DNSSERVERS        3

//
// Multicast group membership information for each network interface
//
typedef struct _IfMcastGroup {
    LONG refcount;          // reference count for this mcast group
    IPADDR mcastaddr;       // mcast group address
    UINT reportTimer;       // when to send a report for this group
    BOOL sentLastReport;    // we were the last host to send report for this group
} IfMcastGroup;

typedef struct _IfMcastData {
    BOOL hasV1Querier;      // whether there is IGMPv1 querier
    UINT v1QuerierTimer;    // last time we heard IGMPv1 query (in seconds)

    // Variable number of multicast groups
    UINT groupCount;
    IfMcastGroup mcastGroups[1];
} IfMcastData;

// Join and leave multicast groups on an interface
NTSTATUS IfChangeMcastGroup(IfInfo* ifp, IPADDR addr, BOOL add);

#endif // !_INTERFACE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\inc\route.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    route.h

Abstract:

    Routing related declarations

Revision History:

    05/23/2000 davidx
        Created it.

--*/

#ifndef _ROUTE_H
#define _ROUTE_H

//
// Routing table entry
//
typedef struct _RouteTableEntry {
    union {                 // double-link pointers - must be the first field!
        LIST_ENTRY links;
        LIST_ENTRY;
    };
    LONG refcount;          // reference count on this entry
    INT flags;              // route flags
    INT metric;             // route metrics: smaller value = higher priority
    IPADDR dstaddr;         // destination address
    IPADDR addrmask;        // address mask
    IPADDR nexthop;         // next hop gateway address
    IfInfo* ifp;            // next hop interface
};

// Route table entry flags
#define RTEFLAG_ORPHAN      0x0001  // the route entry is orphaned
#define RTEFLAG_HOST        0x0002  // host route
#define RTEFLAG_DEFAULT     0x0004  // default gateway route
#define RTEFLAG_LOCAL       0x0008  // local route
#define RTEFLAG_BCAST       0x0010  // broadcast route
#define RTEFLAG_MCAST       0x0020  // multicast route

#define IsRteLocal(_rte)    ((_rte)->flags & RTEFLAG_LOCAL)
#define IsRteBcast(_rte)    ((_rte)->flags & RTEFLAG_BCAST)
#define IsRteOrphaned(_rte) ((_rte)->flags & RTEFLAG_ORPHAN)

// Increment or decrement route table entry reference count
#define RteAddRef(_rte) ((_rte)->refcount += 1)
#define RteDecRef(_rte) ((_rte)->refcount -= 1)

// Initialize and clean up the route table
NTSTATUS IpInitRouteTable();
VOID IpRemoveInterfaceRTE(IfInfo* ifp, BOOL deleteBcastRte);
INLINE VOID IpCleanupRouteTable() {
    IpRemoveInterfaceRTE(NULL, TRUE);
}

// Dump the route table in the debugger
#if DBG
VOID IpDumpRouteTable();
#endif

// Find a route table entry for the specified destination address
RTE* IpFindRTE(IPADDR dstaddr, IfInfo* ifp);

// Add or remove a route table entry
NTSTATUS
IpAddRTE(
    IPADDR dstaddr,
    IPADDR addrmask,
    IPADDR nexthop,
    IfInfo* ifp,
    INT flags,
    INT metric
    );

// Default route metric value
#define DEFAULT_RTE_METRIC 1

// Redirect the route for a destination host
VOID
IpRedirectHostRoute(
    IfInfo* ifp,
    IPADDR dstaddr,
    IPADDR oldgwaddr,
    IPADDR newgwaddr
    );

// Remove route table entries
VOID IpRemoveRTE(IPADDR dstaddr, IPADDR addrmask, IPADDR nexthop);

// Release the reference to a cached route entry
INLINE VOID IpReleaseCachedRTE(RTE* rte) {
    if (InterlockedDecrement(&rte->refcount) == 0) {
        ASSERT(IsRteOrphaned(rte));
        XnetFree(rte);
    }
}

// Add a default gateway route going through an interface
INLINE VOID IpAddDefaultGateway(IPADDR gwaddr, INT metric, IfInfo* ifp) {
    IpAddRTE(0, 0, gwaddr, ifp, RTEFLAG_DEFAULT, metric);
}

// Remove a default route going through an interface
INLINE VOID IpRemoveDefaultGateway(IPADDR gwaddr) {
    IpRemoveRTE(0, 0, gwaddr);
}

// Designate an interface for transmit outgoing broadcast/multicast packets.
NTSTATUS IpSetBroadcastInterface(IfInfo* ifp);
NTSTATUS IpSetMulticastInterface(IfInfo* ifp);

#endif // !_ROUTE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\inc\tcp.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    tcp.h

Abstract:

    TCP/UDP protocol related declarations.

Notes:

    Please refer to RFC 793, 768, and 2581.

Revision History:

    05/02/2000 davidx
        Created it.

--*/

#ifndef _TCP_H
#define _TCP_H

//
// UDP datagram header format
//
typedef struct _UdpHeader {
    IPPORT srcport;     // source port
    IPPORT dstport;     // destination port
    WORD length;        // datagram length (incl. header)
    WORD checksum;      // datagram checksum
} UdpHeader;

// UDP header length
#define UDPHDRLEN sizeof(UdpHeader)

//
// TCP/UDP pseudo-header structure
//
typedef struct _PseudoHeader {
    IPADDR srcaddr;
    IPADDR dstaddr;
    BYTE zero;
    BYTE protocol;
    WORD length;
} PseudoHeader;

//
// TCP segment header format
//
typedef struct _TcpHeader {
    IPPORT srcport;     // source port
    IPPORT dstport;     // destination port
    DWORD seqnum;       // sequence number
    DWORD acknum;       // acknowledgement number
    BYTE hdrlen;        // header length (# of DWORDs)
    BYTE flags;         // flags
    WORD window;        // window
    WORD checksum;      // checksum
    WORD urgent;        // urgent pointer
} TcpHeader;

// Default TCP header length (without options)
#define TCPHDRLEN sizeof(TcpHeader)
#define MAXTCPHDRLEN (4*15)

// Extract the TCP header length (in bytes)
#define GETTCPHDRLEN(_tcphdr) (((_tcphdr)->hdrlen & 0xf0) >> 2)
#define SETTCPHDRLEN(_tcphdr, _hdrlen) ((_tcphdr)->hdrlen = (BYTE) (ROUNDUP4(_hdrlen) << 2))

// TCP segment flag bits
#define TCP_FIN 0x01
#define TCP_SYN 0x02
#define TCP_RST 0x04
#define TCP_PSH 0x08
#define TCP_ACK 0x10
#define TCP_URG 0x20

// Control flags
#define TCP_CONTROLS (TCP_SYN|TCP_FIN|TCP_RST) 

// convenience macro for checking segment flags
#define ISTCPSEG(_tcphdr, _flag) ((_tcphdr)->flags & TCP_##_flag)

//
// TCP option tags
//
#define TCPOPT_EOL              0x00
#define TCPOPT_NOP              0x01
#define TCPOPT_MAX_SEGSIZE      0x02
#define TCPOPT_WINDOW_SCALE     0x03
#define TCPOPT_SACK_PERMITTED   0x04
#define TCPOPT_SACK             0x05
#define TCPOPT_TIMESTAMP        0x08

// Default MSS (maximum segment size)
//  576 - 20 (IP header) - 20 (TCP header)
#define TCP_DEFAULT_MSS 536

#endif // !_TCP_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\inc\xnetp.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    xnetp.h

Abstract:

    Prototypes shared by XBox net implementation

Revision History:

    05/17/2000 davidx
        Created it.

--*/

#ifndef _XNETP_H
#define _XNETP_H

// Put all xnet code in its own section
#pragma code_seg("XNET")
#pragma const_seg("XNET_RD")

#define _NTDRIVER_

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#include <stddef.h>
#include <ntos.h>
#include <nturtl.h>

#ifdef __cplusplus
}
#endif // __cplusplus

#include <xtl.h>
#include <winsockp.h>

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#include "nettypes.h"
#include "debug.h"
#include "ip.h"
#include "tcp.h"
#include "interface.h"
#include "netutil.h"

//
// TCP/UDP module
//

NTSTATUS TcpInitialize();
VOID TcpCleanup();
VOID TcpReceivePacket(Packet* pkt);
VOID TcpSourceQuench(const IpHeader* iphdr);
VOID UdpReceivePacket(Packet* pkt);
VOID RawReceivePacket(Packet* pkt);
VOID UdpSendPacketInternal(Packet*, IpAddrPair*, IfInfo*);

// TCP tick count is increment every half second (500ms)
#define SLOW_TCP_TIMER_FREQ 2
extern UINT TcpTickCount;

//
// IP module
//

NTSTATUS IpInitialize();
VOID IpCleanup();
VOID IpTimerProc();

NTSTATUS IpSendPacket(Packet* pkt, IPADDR dstaddr, IfInfo* ifp, RTE** rte);
VOID IpSendPacketInternal(Packet*, IPADDR, IPADDR, BYTE, IfInfo*);
VOID IcmpSendError(Packet* pkt, UINT type, UINT code);
VOID IpReceivePacket(Packet* pkt);

DWORD IpGetBestAddress(IPADDR* addr);
VOID IfSetIpAddr(IfInfo*, IPADDR, IPADDR);
NTSTATUS IfGetDefaultDnsServers(IfInfo*, CHAR*, UINT, IPADDR*, UINT*);

// Return the identifier for the next outgoing IP datagram
// Note that we use the same global ID space for all interfaces.
extern WORD IpNextDgramId;

// Fill in the information in an IP datagram header
#define FILL_IPHEADER(_iphdr, _hdrlen, _tos, _len, _df, _ttl, _proto, _srcaddr, _dstaddr) { \
            (_iphdr)->ver_hdrlen = (BYTE) (IPVER4 | (_hdrlen) >> 2); \
            (_iphdr)->tos = (_tos); \
            (_iphdr)->length = HTONS(_len); \
            (_iphdr)->id = HTONS(IpNextDgramId); IpNextDgramId++; \
            (_iphdr)->fragoffset = (WORD) (_df); \
            (_iphdr)->ttl = (BYTE) (_ttl); \
            (_iphdr)->protocol = (_proto); \
            (_iphdr)->srcaddr = (_srcaddr); \
            (_iphdr)->dstaddr = (_dstaddr); \
            COMPUTE_CHECKSUM((_iphdr)->hdrxsum, (_iphdr), (_hdrlen)); \
        }

// Allocate packet to hold the specified amount of
// protocol header information as well as data
INLINE Packet* XnetAllocIpPacket(UINT ipoptlen, UINT datalen) {
    // Reserve enough space at the beginning of the packet buffer
    // to hold the link-layer frame header. Then add the IP header
    // and option length.
    UINT hdrlen = MAXLINKHDRLEN + IPHDRLEN + ROUNDUP4(ipoptlen);
    Packet* pkt;

    if ((pkt = XnetAllocPacket(hdrlen+datalen, PKTFLAG_NETPOOL)) != NULL) {
        pkt->iphdrOffset = PKTHDRLEN + MAXLINKHDRLEN;
        pkt->data += hdrlen;
        pkt->datalen = datalen;
    }
    return pkt;
}

//
// DHCP module
//

NTSTATUS DhcpInitialize(IfInfo* ifp);
VOID DhcpCleanup(IfInfo* ifp);
VOID DhcpTimerProc(IfInfo* ifp);
VOID DhcpReceivePacket(IfInfo* ifp, Packet* pkt);
VOID DhcpNotifyAddressConflict(IfInfo* ifp);
VOID DhcpSetDefaultGateways(IfInfo* ifp);
DWORD DhcpGetActiveAddressType(IfInfo* ifp);
NTSTATUS DhcpWaitForAddress(IfInfo* ifp);
NTSTATUS DhcpGetDefaultDnsServers(IfInfo*, CHAR*, UINT, IPADDR*, UINT*);

//
// Network interface modules
//

NTSTATUS EnetInitialize(IfInfo** newifp);
NTSTATUS IpQueueLoopbackPacket(Packet* pkt, BOOL copyflag);

//
// DNS module
//

NTSTATUS DnsInitialize();
VOID DnsCleanup();
VOID DnsNotifyDefaultServers(IfInfo* ifp);

typedef struct hostent* (*DnsLookupCallback)(UINT size, VOID* param);
NTSTATUS DnsLookupByName(const char* name, DnsLookupCallback callback, VOID* param);
NTSTATUS DnsLookupByAddr(IPADDR addr, DnsLookupCallback callback, VOID* param);

//
// Configuration parameters
//
extern UINT cfgXnetPoolSize;
extern UINT cfgRecvQLength;
extern UINT cfgXmitQLength;
extern UINT cfgMaxReassemblySize;
extern UINT cfgMaxReassemblyDgrams;
extern BYTE cfgDefaultTtl;
extern BYTE cfgDefaultTos;
extern UINT cfgDefaultSendBufsize;
extern UINT cfgDefaultRecvBufsize;
extern UINT cfgMaxSendRecvBufsize;
extern UINT cfgMaxSockets;
extern UINT cfgXnetConfigFlags;

extern UINT defaultPacketAllocFlag;

// Check if XNET is running inside the debug monitor
#define XnetInsideDbgmon() (defaultPacketAllocFlag & PKTFLAG_DBGMON)

//
// Maximum number of default gateways and DNS servers
//
#define MAX_DEFAULT_DNSSERVERS 4
#define MAX_DEFAULT_GATEWAYS 4

//
// Perf counters
//
#ifdef DEVKIT

extern ULONGLONG IpTotalBytesSent;
extern ULONGLONG IpTotalBytesRecv;
extern ULONGLONG TcpTotalBytesSent;
extern ULONGLONG TcpTotalBytesRecv;
extern ULONGLONG UdpTotalBytesSent;
extern ULONGLONG UdpTotalBytesRecv;
extern ULONG IpTotalDgramsSent;
extern ULONG IpTotalDgramsRecv;
extern ULONG UdpTotalDgramsSent;
extern ULONG UdpTotalDgramsRecv;
extern ULONG TcpTotalSegmentsSent;
extern ULONG TcpTotalSegmentsRecv;

#define XnetIncrementPerfCount(counter, incr) ((counter) += (incr))

#else // !DEVKIT

#define XnetIncrementPerfCount(counter, incr)

#endif // !DEVKIT

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // !_XNETP_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\inc\xppp.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

    xppp.h

Abstract:

    Xbox PPP APIs.

--*/

#ifndef __XPPP_H__
#define __XPPP_H__

/*
 * Errors
 */
#define PPP_ERROR_BASE                  600
#define ERROR_PENDING                   (PPP_ERROR_BASE + 0)
#define ERROR_BUFFER_TOO_SMALL          (PPP_ERROR_BASE + 3)
#define ERROR_UNKNOWN                   (PPP_ERROR_BASE + 35)
#define ERROR_AUTHENTICATION_FAILURE    (PPP_ERROR_BASE + 91)
#define ERROR_PPP_INVALID_PACKET        (PPP_ERROR_BASE + 122)
#define ERROR_PPP_NOT_CONVERGING        (PPP_ERROR_BASE + 132)
#define ERROR_PPP_CP_REJECTED           (PPP_ERROR_BASE + 133)
#define ERROR_PPP_LOOPBACK_DETECTED     (PPP_ERROR_BASE + 137)

/*
 * API entry points
 */
BOOL PppConnect(CHAR *pszUsername, CHAR *pszPassword, CHAR *pszDomain, CHAR *pszNumber);

#endif // __XPPP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\inc\xmodem.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

    xmodem.h

Abstract:

    Microsoft XBox specific modem APIs.

--*/

#ifndef __XMODEM_H__
#define __XMODEM_H__

#define MODEM_BUFFER_SIZE 64

BOOL ModemIsConnected(VOID);
BOOL ModemOpen(HANDLE hEvent);
BOOL ModemClose(VOID);

BOOL ModemWrite(PUCHAR buffer, ULONG *pcb);
BOOL ModemRead(PUCHAR buffer, ULONG *pcb);
BOOL ModemPurge(DWORD dwFlags);

BOOL ModemGetLineCoding(PULONG pBaudRate, PUCHAR pStopBits, PUCHAR pParity,
        PUCHAR pDataBits);
BOOL ModemSetLineCoding(ULONG BaudRate, UCHAR StopBits, UCHAR Parity,
        UCHAR DataBits);
BOOL ModemGetDtrRts(USHORT *pwState);
BOOL ModemSetDtrRts(USHORT wState);

#endif // __XMODEM_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\ip\icmp.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    icmp.h

Abstract:

    ICMP protocol related declarations.

Notes:

    Please refer to RFC 792 and 1256.

Revision History:

    05/02/2000 davidx
        Created it.

--*/

#ifndef _ICMP_H
#define _ICMP_H

//
// ICMP message types and codes
//
#define ICMPTYPE_DESTINATION_UNREACHABLE    3
#define   ICMPCODE_NET_UNREACHABLE          0
#define   ICMPCODE_HOST_UNREACHABLE         1
#define   ICMPCODE_PROTOCOL_UNREACHABLE     2
#define   ICMPCODE_PORT_UNREACHABLE         3
#define   ICMPCODE_CANT_FRAGMENT_WITH_DF    4
#define   ICMPCODE_SRCROUTE_FAILED          5
#define   ICMPCODE_DEST_NET_UNKNOWN         6
#define   ICMPCODE_DEST_HOST_UNKNOWN        7
#define   ICMPCODE_SRC_HOST_ISOLATED        8
#define   ICMPCODE_DEST_NET_PROHIBITED      9
#define   ICMPCODE_DEST_HOST_PROHIBITED     10
#define   ICMPCODE_NET_UNREACHABLE_TOS      11
#define   ICMPCODE_HOST_UNREACHABLE_TOS     12
#define ICMPTYPE_TIME_EXECEEDED             11
#define   ICMPCODE_TTL_EXCEEDED             0
#define   ICMPCODE_REASSEMBLY_TIMEOUT       1
#define ICMPTYPE_PARAMETER_PROBLEM          12
#define   ICMPCODE_PTR_INDICATES_ERROR      0
#define   ICMPCODE_MISSING_REQD_OPTION      1
#define ICMPTYPE_SOURCE_QUENCH              4
#define ICMPTYPE_REDIRECT                   5
#define   ICMPCODE_REDIRECT_NET             0
#define   ICMPCODE_REDIRECT_HOST            1
#define   ICMPCODE_REDIRECT_NET_TOS         2
#define   ICMPCODE_REDIRECT_HOST_TOS        3
#define ICMPTYPE_ECHO_REQUEST               8
#define ICMPTYPE_ECHO_REPLY                 0
#define ICMPTYPE_TIMESTAMP_REQUEST          13
#define ICMPTYPE_TIMESTAMP_REPLY            14
#define ICMPTYPE_INFO_REQUEST               15
#define ICMPTYPE_INFO_REPLY                 16

//
// Generic ICMP message format
//
typedef struct _IcmpMessage {
    BYTE type;          // ICMP message type
    BYTE code;          // type specific code
    WORD checksum;      // ICMP checksum
    union {             // type/code specific parameters
        struct {        // - for request/reply messages:
            WORD id;    //   identifier
            WORD seqno; //   sequence number
        };
        IPADDR gwaddr;  // - redirect message: gateway address
        BYTE info[4];   // - for other messages
        DWORD unused;   //
    };
    BYTE origdata[1];   // original IP header + some data
} IcmpMessage;

// ICMP message header length
#define ICMPHDRLEN offsetof(IcmpMessage, origdata)

#endif // !_ICMP_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\ip\icmp.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    icmp.c

Abstract:

    Implementation of ICMP related functions

Revision History:

    05/22/2000 davidx
        Created it.

--*/

#include "precomp.h"


PRIVATE IPADDR
IcmpShouldSendResponse(
    Packet* recvpkt,
    BOOL error
    )

/*++

Routine Description:

    Determine if we should send an ICMP message in response
    to a received datagram

Arguments:

    recvpkt - Specifies the received datagram
    error - Whether we're trying to send an error response

Return Value:

    IP address of the host we should send the ICMP message to;
    0 if we should not send a response

--*/

{
    IPADDR fromaddr, toaddr;
    IfInfo* ifp = recvpkt->recvifp;
    IpHeader* iphdr = GETPKTIPHDR(recvpkt);

    fromaddr = iphdr->srcaddr;
    toaddr = iphdr->dstaddr;

    // We don't respond to ICMP Echo Requests
    // sent to broadcast or multicast addresses
    if (IfBcastAddr(ifp, toaddr) || IS_MCAST_IPADDR(toaddr))
        return 0;

    // Source IP address cannot be one of the following:
    //  0, broadcast or multicast addresses
    if (fromaddr == 0 ||
        IfBcastAddr(ifp, fromaddr) ||
        IS_MCAST_IPADDR(fromaddr))
        return 0;

    if (error) {
        // 1. We don't send ICMP error message to *any* ICMP message
        //    instead of just ICMP error messages.
        // 2. Only send ICMP error for the very first segment.
        // 3. Don't respond if link-layer broadcast or multicast.
        // 4. Don't respond if source is loopback address.
        if ((iphdr->protocol == IPPROTOCOL_ICMP) ||
            (iphdr->fragoffset & HTONS(FRAGOFFSET_MASK)) ||
            (recvpkt->pktflags & PKTFLAG_MCAST) ||
            IS_LOOPBACK_IPADDR(fromaddr))
            return 0;
    }

    return fromaddr;
}


VOID
IcmpSendError(
    Packet* origpkt,
    UINT type,
    UINT code
    )

/*++

Routine Description:

    Send out an ICMP error message in response to a received datagram

Arguments:

    origpkt - The received datagram
    type, code - Specifies the ICMP message type and code

Return Value:

    NONE

--*/

{
    Packet* sendpkt;
    UINT icmpdatalen;
    IcmpMessage* icmpmsg;
    IPADDR fromaddr;
    IpHeader* origiphdr;
    IfInfo* ifp = origpkt->recvifp;

    // make sure we're allowed to send an ICMP message
    fromaddr = IcmpShouldSendResponse(origpkt, TRUE);
    if (fromaddr == 0) return;
    
    // allocate packet buffer for composing the ICMP message
    origiphdr = GETPKTIPHDR(origpkt);
    icmpdatalen = min(GETIPHDRLEN(origiphdr) + 8, GETIPLEN(origiphdr));

    sendpkt = XnetAllocIpPacket(0, ICMPHDRLEN+icmpdatalen);
    if (!sendpkt) return;

    icmpmsg = GETPKTDATA(sendpkt, IcmpMessage);
    ZeroMem(icmpmsg, ICMPHDRLEN);
    icmpmsg->type = (BYTE) type;
    icmpmsg->code = (BYTE) code;
    CopyMem(icmpmsg->origdata, origiphdr, icmpdatalen);

    COMPUTE_CHECKSUM(icmpmsg->checksum, icmpmsg, ICMPHDRLEN+icmpdatalen);

    IpSendPacketInternal(sendpkt, ifp->ipaddr, fromaddr, IPPROTOCOL_ICMP, ifp);
}


PRIVATE VOID
IcmpSendEchoReply(
    Packet* reqpkt
    )

/*++

Routine Description:

    Respond to an ICMP Echo request message by sending
    out an ICMP Echo Reply message

Arguments:

    reqpkt - Points to the received packet

Return Value:

    NONE

--*/

{
    IPADDR fromaddr;
    Packet* replypkt;
    IfInfo* ifp;
    IcmpMessage* icmpreq;
    IcmpMessage* icmpreply;
    IpHeader* iphdrreq;
    IpHeader* iphdrreply;
    UINT iphdrlen, ipdatalen;

    // make sure it's ok to reply to the request
    fromaddr = IcmpShouldSendResponse(reqpkt, FALSE);
    if (!fromaddr) return;

    // calculate the reply message length
    //  (truncate data if we need to fragment)
    ifp = reqpkt->recvifp;
    iphdrreq = GETPKTIPHDR(reqpkt);
    iphdrlen = GETIPHDRLEN(iphdrreq);
    ipdatalen = GETIPLEN(iphdrreq) - iphdrlen;
    if (iphdrlen+ipdatalen > ifp->mtu)
        ipdatalen = ifp->mtu - iphdrlen;

    // allocate packet buffer and compose
    // the ICMP reply message

    replypkt = XnetAllocIpPacket(iphdrlen-IPHDRLEN, ipdatalen);
    if (!replypkt) return;

    iphdrreply = GETPKTIPHDR(replypkt);
    CopyMem(iphdrreply, iphdrreq, iphdrlen+ipdatalen);

    icmpreq = (IcmpMessage*) ((BYTE*) iphdrreq + iphdrlen);
    icmpreply = (IcmpMessage*) ((BYTE*) iphdrreply + iphdrlen);
    icmpreply->type = ICMPTYPE_ECHO_REPLY;
    icmpreply->code = icmpreq->code;
    icmpreply->id = icmpreq->id;
    icmpreply->seqno = icmpreq->seqno;

    COMPUTE_CHECKSUM(icmpreply->checksum, icmpreply, ipdatalen);

    // reflect option data in the IP header
    fromaddr = IpReflectIpOptions(ifp, iphdrreply, fromaddr);

    IpSendPacketInternal(replypkt, ifp->ipaddr, fromaddr, IPPROTOCOL_ICMP, ifp);
}


PRIVATE BOOL
IcmpCheckEmbeddedIpHeader(
    const IpHeader* iphdr,
    UINT buflen
    )

/*++

Routine Description:

    Validate the embedded IP header information inside an ICMP message

Arguments:

    iphdr - Points to the beginning of the embedded ICMP data
    buflen - Length of the data buffer

Return Value:

    TRUE if the embedded IP header information is valid
    FALSE otherwise

--*/

{
    UINT iphdrlen, iplen;

    if (buflen < IPHDRLEN) return FALSE;

    iphdrlen = VERIFY_IPVER_HDRLEN(iphdr->ver_hdrlen);
    iplen = NTOHS(iphdr->length);

    // must include the IP header plus at least 8 bytes of data
    return (iphdrlen >= IPHDRLEN &&
            iphdrlen <= iplen &&
            iphdrlen+8 <= buflen);
}


VOID
IcmpReceivePacket(
    Packet* pkt
    )

/*++

Routine Description:

    Handle the reception of an ICMP message

Arguments:

    pkt - Points to the received packet

Return Value:

    NONE

--*/

{
    IcmpMessage* icmpmsg;
    IpHeader* origiphdr;

    // verify the ICMP message length and checksum
    if (pkt->datalen < ICMPHDRLEN) goto discard;
    if (tcpipxsum(0, pkt->data, pkt->datalen) != 0xffff)
        goto discard;

    icmpmsg = GETPKTDATA(pkt, IcmpMessage);
    origiphdr = (IpHeader*) icmpmsg->origdata;

    switch (icmpmsg->type) {
    case ICMPTYPE_DESTINATION_UNREACHABLE:
    case ICMPTYPE_TIME_EXECEEDED:
    case ICMPTYPE_PARAMETER_PROBLEM:
    case ICMPTYPE_SOURCE_QUENCH:
    case ICMPTYPE_REDIRECT:
        // verify embedded IP header inside the ICMP message
        if (!IcmpCheckEmbeddedIpHeader(origiphdr, pkt->datalen-ICMPHDRLEN))
            goto discard;

        // handle ICMP redirect message
        //  we treat host and network redirects the same way
        if ((icmpmsg->type == ICMPTYPE_REDIRECT) &&
            (icmpmsg->code == ICMPCODE_REDIRECT_NET ||
             icmpmsg->code == ICMPCODE_REDIRECT_HOST ||
             icmpmsg->code == ICMPCODE_REDIRECT_NET_TOS ||
             icmpmsg->code == ICMPCODE_REDIRECT_HOST_TOS)) {
            IpRedirectHostRoute(
                pkt->recvifp,
                origiphdr->dstaddr,
                GETPKTIPHDR(pkt)->srcaddr,
                icmpmsg->gwaddr);
        }

        // Pass ICMP source quench error message to TCP layer
        if (icmpmsg->type == ICMPTYPE_SOURCE_QUENCH &&
            origiphdr->protocol == IPPROTOCOL_TCP) {
            TcpSourceQuench(origiphdr);
        }
        break;

    case ICMPTYPE_ECHO_REQUEST:
        IcmpSendEchoReply(pkt);
        break;
    }

    RawReceivePacket(pkt);
    return;

discard:
    XnetCompletePacket(pkt, NETERR_DISCARDED);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\ip\igmp.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    igmp.c

Abstract:

    Handle IGMP protocol version 2

Revision History:

    05/31/2000 davidx
        Created it.

--*/

#include "precomp.h"


VOID
IgmpSendMessage(
    IfInfo* ifp,
    IPADDR dstaddr,
    BYTE type,
    IPADDR groupaddr
    )

/*++

Routine Description:

    Send out an IGMP report or leave message

Arguments:

    ifp - Points to the interface structure
    dstaddr - Specifies the message's destination address
    type - Message type
    groupaddr - Address of the multicast group in question

Return Value:

    NONE

--*/

{
    Packet* pkt;
    IgmpMessage* igmpmsg;
    IpHeader* iphdr;

    pkt = XnetAllocIpPacket(0, IGMPHDRLEN);
    if (!pkt) return;

    igmpmsg = GETPKTDATA(pkt, IgmpMessage);
    igmpmsg->type = type;
    igmpmsg->maxresptime = 0;
    igmpmsg->groupaddr = groupaddr;
    COMPUTE_CHECKSUM(igmpmsg->checksum, igmpmsg, IGMPHDRLEN);

    iphdr = GETPKTIPHDR(pkt);
    pkt->data -= IPHDRLEN;
    pkt->datalen += IPHDRLEN;
    pkt->nexthop = dstaddr;

    FILL_IPHEADER(
        iphdr,
        IPHDRLEN,
        0,
        pkt->datalen,
        0,
        1,
        IPPROTOCOL_IGMP,
        ifp->ipaddr,
        dstaddr);

    // Queue up the packet for transmission
    IfEnqueuePacket(ifp, pkt);
    ifp->StartOutput(ifp);
}


PRIVATE VOID
IgmpSetQueryReportTimer(
    IfInfo* ifp,
    IfMcastGroup* mcastgrp,
    UINT maxresptime
    )

/*++

Routine Description:

    Set the query report timer on a multicast group we belong to.

Arguments:

    ifp - Points to the interface structure
    mcastgrp - Points to the multicast group in question
    maxresptime - Specifies the maximum response time in 1/10 of a second

Return Value:

    NONE

--*/

{
    // If existing timer value is less than the new max response time,
    // then we just leave the existing timer alone.
    if (mcastgrp->reportTimer && mcastgrp->reportTimer*10 <= maxresptime)
        return;

    // Randomize the response timer
    maxresptime = XnetRandScaled(maxresptime) / 10;

    if ((mcastgrp->reportTimer = maxresptime) == 0) {
        IgmpSendReport(ifp, mcastgrp);
    }
}


PRIVATE VOID
IgmpProcessMessage(
    IfInfo* ifp,
    IgmpMessage* igmpmsg,
    IPADDR dstaddr
    )

/*++

Routine Description:

    Process a received IGMP message

Arguments:

    ifp - Points to the interface structure
    igmpmsg - Points to the received IGMP message
    dstaddr - Destination group the message is addressed to

Return Value:

    NONE

Note:
    
    This function will only be called when the interface
    belongs to the message's destination address group.

--*/

#define LOCATE_MCASTGROUP() \
        while (count--) { \
            if (mcastgrp->mcastaddr == dstaddr) break; \
            mcastgrp++; \
        }

{
    IfMcastData* ifmcast = ifp->mcastData;
    IfMcastGroup* mcastgrp = ifmcast->mcastGroups;
    UINT count = ifmcast->groupCount;
    IPADDR grpaddr = igmpmsg->groupaddr;

    switch (igmpmsg->type) {
    case IGMPTYPE_MEMBER_QUERY:
        if (grpaddr == 0) {
            UINT maxresptime;

            // General query must be directed to all-hosts address
            if (dstaddr != IPADDR_ALLHOSTS) return;

            if (igmpmsg->maxresptime == 0) {
                ifmcast->hasV1Querier = TRUE;
                ifmcast->v1QuerierTimer = IGMP_V1_QUERIER_TIMER;
                maxresptime = IGMP_V1_QUERY_RESPONSE*10;
            } else
                maxresptime = igmpmsg->maxresptime;

            while (count--) {
                IgmpSetQueryReportTimer(ifp, mcastgrp, maxresptime);
                mcastgrp++;
            }
        } else {
            // Group-specific query must directed to that group address
            if (dstaddr != grpaddr) return;

            LOCATE_MCASTGROUP();
            IgmpSetQueryReportTimer(ifp, mcastgrp, igmpmsg->maxresptime);
        }
        break;

    case IGMPTYPE_MEMBER_REPORT_1:
    case IGMPTYPE_MEMBER_REPORT_2:
        // Membership report must be sent to the specific group
        if (dstaddr != grpaddr) return;

        LOCATE_MCASTGROUP();
        mcastgrp->reportTimer = 0;
        mcastgrp->sentLastReport = FALSE;
        break;
    }
}


VOID
IgmpReceivePacket(
    Packet* pkt
    )

/*++

Routine Description:

    Receive  an IGMP packet

Arguments:

    pkt - Points to the received IGMP message

Return Value:

    NONE

--*/

{
    RUNS_AT_DISPATCH_LEVEL

    // Verify packet length and checksum
    if (pkt->datalen < IGMPHDRLEN ||
        tcpipxsum(0, pkt->data, pkt->datalen) != 0xffff) {
        XnetCompletePacket(pkt, NETERR_DISCARDED);
        return;
    }

    // We're only interested in packets addressed
    // to the all-host multicast group here.
    if (pkt->recvifp->mcastData) {
        IgmpProcessMessage(
            pkt->recvifp,
            GETPKTDATA(pkt, IgmpMessage),
            GETPKTIPHDR(pkt)->dstaddr);
    }

    // Pass the packet upstream for further processing
    RawReceivePacket(pkt);
}


VOID
IgmpTimerProc(
    IfInfo* ifp
    )

/*++

Routine Description:

    IGMP timer procedure

Arguments:

    ifp - Points to the interface structure

Return Value:

    NONE

--*/

{
    IfMcastData* ifmcast = ifp->mcastData;
    IfMcastGroup* mcastgrp;
    UINT count;

    ASSERT(ifmcast != NULL);

    if (ifmcast->v1QuerierTimer && --(ifmcast->v1QuerierTimer) == 0)
        ifmcast->hasV1Querier = FALSE;

    mcastgrp = ifmcast->mcastGroups;
    count = ifmcast->groupCount;
    while (count--) {
        if (mcastgrp->reportTimer && --(mcastgrp->reportTimer) == 0) {
            IgmpSendReport(ifp, mcastgrp);
        }
        mcastgrp++;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\ip\iprecv.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    iprecv.c

Abstract:

    Handles IP datagram reception

Revision History:

    05/17/2000 davidx
        Created it.

--*/

#include "precomp.h"


//
// A singly-linked list of datagrams that're currently
// being reassembled. We're using a list rather than a
// hash table here for simplicity. We assume that fragmentation
// occurs very infrequently.
//
PRIVATE Packet* IpReassemblyPktList;
PRIVATE UINT IpReassemblyPktCount;

// Maximum number of actively reassembled datagrams
UINT cfgMaxReassemblyDgrams = 4;

// Maximum size for a reassembled datagram
UINT cfgMaxReassemblySize = 2048;

// Reassembly timeout period = 60sec
UINT cfgReassemblyTimeout = 60;

//
// Packet containing a datagram that's being reassembled:
//  packet header
//  reassembly information
//  space to hold maximum IP header
//  actual datagram data
//
typedef struct _ReassemblyHeader {
    IPADDR srcaddr;         // source IP address
    IPADDR dstaddr;         // destination IP address
    UINT proto_id;          // datagram ID and protocol
    UINT timer;             // reassembly timer
    UINT origdatalen;       // total length of the original IP datagram
    DWORD bitFlags[1];      // which fragments have arrived?
} ReassemblyHeader;


VOID
IpCleanupReassemblyPkts(
    IfInfo* ifp
    )

/*++

Routine Description:

    Clean up all partially reassembly datagrams

Arguments:

    ifp - Optional parameter: when present we only clean up
        the partial datagrams from the specified interface;
        otherwise, we clean up all partial datagrams.

Return Value:

    NONE

--*/

{
    Packet** link = &IpReassemblyPktList;
    Packet* pkt;

    while ((pkt = *link) != NULL) {
        if (ifp == pkt->recvifp || ifp == NULL) {
            *link = pkt->nextpkt;
            IpReassemblyPktCount--;
            XnetCompletePacket(pkt, NETERR_CANCELLED);
        } else {
            link = &pkt->nextpkt;
        }
    }
}


VOID
IpReassemblyTimerProc()

/*++

Routine Description:

    IP datagram reassembly timer routine

Arguments:

    NONE

Return Value:

    NONE

--*/

{
    Packet** link = &IpReassemblyPktList;
    Packet* pkt;
    ReassemblyHeader* rahdr;

    while ((pkt = *link) != NULL) {
        rahdr = GETPKTBUF(pkt, ReassemblyHeader);
        if (rahdr->timer-- == 0) {
            TRACE_("Reassembly timeout: src = %s", IPADDRSTR(rahdr->srcaddr));
            *link = pkt->nextpkt;
            IpReassemblyPktCount--;

            // Send out an ICMP error message if fragment 0 has been received
            if (pkt->iphdrOffset) {
                pkt->data = (BYTE*) GETPKTIPHDR(pkt);
                IcmpSendError(
                    pkt,
                    ICMPTYPE_TIME_EXECEEDED,
                    ICMPCODE_REASSEMBLY_TIMEOUT);
            }

            XnetCompletePacket(pkt, NETERR_REASSEMBLY);
        } else
            link = &pkt->nextpkt;
    }
}


PRIVATE Packet**
IpFindReassemblyPkt(
    IPADDR srcaddr,
    IPADDR dstaddr,
    UINT proto_id
    )

/*++

Routine Description:

    Check if we already have a partially assembled datagram
    matching the specified identification information.

Arguments:

    srcaddr - Specifies the source IP address
    dstaddr - Specifies the destination IP address
    proto_id - IP protocol number and datagram ID

Return Value:

    Address of the link pointer to the specified datagram

--*/

{
    Packet** link = &IpReassemblyPktList;
    Packet* pkt;
    ReassemblyHeader* rahdr;

    while ((pkt = *link) != NULL) {
        rahdr = GETPKTBUF(pkt, ReassemblyHeader);
        if (rahdr->srcaddr == srcaddr &&
            rahdr->dstaddr == dstaddr &&
            rahdr->proto_id == proto_id)
            break;

        link = &pkt->nextpkt;
    }

    return link;
}


PRIVATE Packet*
IpAllocReassemblyPkt(
    IPADDR srcaddr,
    IPADDR dstaddr,
    UINT proto_id,
    IfInfo* ifp
    )

/*++

Routine Description:

    Allocate buffer for assembling a datagram

Arguments:

    srcaddr - Specifies the source IP address
    dstaddr - Specifies the destination IP address
    proto_id - IP protocol number and datagram ID
    ifp - Points to the receiving interface

Return Value:

    Pointer to the allocated packet
    NULL if there is an error

--*/

{
    Packet* pkt;
    UINT hdrsize;
    ReassemblyHeader* rahdr;

    //
    // We reserve some space in the head of the packet buffer
    // for storing reassembly information.
    //

    hdrsize = offsetof(ReassemblyHeader, bitFlags) +
              (((cfgMaxReassemblySize / 8) + 31) / 32) * 4 +
              MAXIPHDRLEN;

    pkt = XnetAllocPacket(hdrsize + cfgMaxReassemblySize, PKTFLAG_NETPOOL);
    if (!pkt) return NULL;
    pkt->iphdrOffset = 0;

    rahdr = GETPKTBUF(pkt, ReassemblyHeader);
    ZeroMem(rahdr, hdrsize);
    rahdr->timer = cfgReassemblyTimeout;
    rahdr->srcaddr = srcaddr;
    rahdr->dstaddr = dstaddr;
    rahdr->proto_id = proto_id;

    pkt->data += hdrsize;
    CACHE_IFP_REFERENCE(pkt->recvifp,ifp);
    return pkt;
}


PRIVATE BOOL
IpUpdateFragmentFlags(
    Packet* pkt,
    UINT fragOffset,
    UINT fragCount
    )

/*++

Routine Description:

    Update the bit flags to indicate which fragments have already arrived

Arguments:

    pkt - Points to the packet contain partially assembled datagram
    fragOffset - Starting chunk offset for the current fragment
    fragCount - Number of 8 byte chunks in the current fragment

Return Value:

    TRUE if the entire datagram has been completed
    FALSE otherwise

--*/

{
    UINT chunks, i;
    ReassemblyHeader* rahdr = GETPKTBUF(pkt, ReassemblyHeader);

    // Update flag bits
    chunks = fragOffset % 32;
    i = fragOffset / 32;

    if (chunks) {
        UINT bits = min(fragCount, 32-chunks);
        rahdr->bitFlags[i++] |= (((1 << bits) - 1) << chunks);
        fragCount -= bits;
    }

    while (fragCount >= 32) {
        rahdr->bitFlags[i++] = 0xffffffff;
        fragCount -= 32;
    }

    if (fragCount)
        rahdr->bitFlags[i] |= (1 << fragCount) - 1;

    // We don't know the total datagram length yet,
    // which must mean we haven't finished reassembly.
    if (rahdr->origdatalen == 0) return FALSE;

    // Check if all bit flags are set
    i = 0;
    chunks = (rahdr->origdatalen + 7) / 8;
    while (chunks >= 32) {
        if (rahdr->bitFlags[i++] != 0xffffffff) return FALSE;
        chunks -= 32;
    }

    return (chunks == 0 ||
            rahdr->bitFlags[i] == (1u << chunks) - 1);
}


PRIVATE VOID
IpReassemblePkt(
    Packet* pkt
    )

/*++

Routine Description:

    Handle IP datagram reassembly:
    called when a datagram fragment is received

Arguments:

    pkt - Points to the received packet (datagram fragment)

Return Value:

    NONE

NOTE:

    We assume that fragmented datagrams are rare. Consequently,
    our priority here is implementation simplicity (over efficiency).

--*/

{
    IpHeader* iphdr = GETPKTIPHDR(pkt);
    UINT iphdrlen = GETIPHDRLEN(iphdr);
    UINT iplen = GETIPLEN(iphdr);
    UINT proto_id, fragOffset, lastbyte;
    BOOL moreFlag;
    Packet** link;
    Packet* rapkt;
    ReassemblyHeader* rahdr;

    // Extract datagram header information
    fragOffset = NTOHS(iphdr->fragoffset);
    moreFlag = (fragOffset & MORE_FRAGMENTS) != 0;
    fragOffset &= FRAGOFFSET_MASK;

    proto_id = NTOHS(iphdr->id);
    proto_id = (proto_id << 16) | iphdr->protocol;
    link = IpFindReassemblyPkt(iphdr->srcaddr, iphdr->dstaddr, proto_id);
    
    // Check if we already have fragments from the same datagram.
    // If no existing fragments are found, then we need to
    // allocate a new reassembly buffer
    if ((rapkt = *link) == NULL) {
        if (IpReassemblyPktCount >= cfgMaxReassemblyDgrams) {
            WARNING_("Too many fragmented IP datagrams");
            goto discard_fragment;
        }

        rapkt = IpAllocReassemblyPkt(iphdr->srcaddr, iphdr->dstaddr, proto_id, pkt->recvifp);
        if (!rapkt) goto discard_fragment;
        *link = rapkt;
        IpReassemblyPktCount++;
    }

    if ((iplen -= iphdrlen) == 0) goto reassembly_failed;
    lastbyte = fragOffset*8 + iplen;
    if (lastbyte > cfgMaxReassemblySize) {
        WARNING_("Exceeded max reassembly size");
        goto reassembly_failed;
    }

    rahdr = GETPKTBUF(rapkt, ReassemblyHeader);
    if (moreFlag) {
        // Only the last fragment can have size that's not a multiple of 8.
        if (iplen % 8 != 0) goto reassembly_failed;
    } else {
        // Update the total length field for the entire datagram
        if (rahdr->origdatalen && rahdr->origdatalen != lastbyte)
            goto reassembly_failed;

        rahdr->origdatalen = lastbyte;
    }

    // Check if we got the first fragment.
    // Remember the original IP datagram header if we did.
    if (fragOffset == 0 && rapkt->iphdrOffset == 0) {
        BYTE* hdr = rapkt->data - iphdrlen;
        SETPKTIPHDR(rapkt, hdr);
        CopyMem(hdr, pkt->data, iphdrlen);
        rapkt->pktflags |= (pkt->pktflags & PKTFLAG_MCAST);
    }

    // Copy the fragment data into the reassembly buffer
    CopyMem(rapkt->data + fragOffset*8, pkt->data + iphdrlen, iplen);
    XnetCompletePacket(pkt, NETERR_OK);

    // Update the flags to indicate which fragments have already arrived.
    // If the datagram is complete, pass it upstream for processing.
    if (IpUpdateFragmentFlags(rapkt, fragOffset, (iplen+7)/8)) {
        *link = rapkt->nextpkt;
        IpReassemblyPktCount--;
        rapkt->nextpkt = NULL;

        iphdr = GETPKTIPHDR(rapkt);
        iphdrlen = GETIPHDRLEN(iphdr);
        rapkt->data = (BYTE*) iphdr;
        rapkt->datalen = iphdrlen + rahdr->origdatalen;
        iphdr->length = (WORD) HTONS(rapkt->datalen);
        iphdr->fragoffset &= ~HTONS(MORE_FRAGMENTS|FRAGOFFSET_MASK);
        COMPUTE_CHECKSUM(iphdr->hdrxsum, iphdr, iphdrlen);
        IpReceivePacket(rapkt);
    }
    return;

reassembly_failed:
    // We detected an error during the reassembly process.
    // Flush all associated fragments.
    *link = rapkt->nextpkt;
    IpReassemblyPktCount--;

    TRACE_("Datagram reassembly failed");
    XnetCompletePacket(rapkt, NETERR_REASSEMBLY);

discard_fragment:
    // Discard this fragment and return
    XnetCompletePacket(pkt, NETERR_DISCARDED);
}



PRIVATE BOOL
IpProcessRecvOptions(
    BYTE* buf,
    UINT buflen,
    IfInfo* ifp
    )

/*++

Routine Description:

    Process options in a received IP datagram

Arguments:

    buf - Points to the option data buffer
    buflen - Size of the buffer, in bytes
    ifp - The interface that received the datagram

Return Value:

    TRUE if the option data is valid
    FALSE if there is an error and the datagram should be discarded

--*/

{
    BYTE opt, optlen, ptr;
    IPADDR* paddr;

    while (buflen) {
        // reached the end of option list?
        if ((opt = *buf) == IPOPT_EOL) break;

        // skip over the NOP option
        if (opt == IPOPT_NOP) {
            buf++; buflen--;
            continue;
        }

        // check the option length field
        if (buflen < 2 || (optlen = buf[1]) < 2 || optlen > buflen)
            return FALSE;

        switch (opt) {
        case IPOPT_LOOSE_SRCROUTE:
        case IPOPT_STRICT_SRCROUTE:
            // loose or strict source and record route options
            if (optlen % 4 != 3 || (ptr = buf[2]) < 4 || ptr % 4 != 0)
                return FALSE;
            
            // reached the end of the IP address list?
            if (ptr > optlen) break;

            // only one address left and it's ours
            //  this shouldn't happen but we handle it anyway
            paddr = (IPADDR*) (buf+ptr-1);
            if (optlen - ptr == 3 && ifp->ipaddr && ifp->ipaddr == *paddr) {
                *paddr = 0;
                break;
            }

            // otherwise, discard the datagram since we don't
            // participate in source routing.
            return FALSE;

        case IPOPT_RECORD_ROUTE:
            // record route
            if (optlen % 4 != 3 || (ptr = buf[2]) < 4 || ptr % 4 != 0)
                return FALSE;
            break;

        case IPOPT_TIMESTAMP:
            // internet timestamp
            if (optlen < 4 || optlen % 4 != 0 ||
                (ptr = buf[2]) < 5 || ptr % 4 != 1)
                return FALSE;
            break;
        }

        // move on to the next option
        buf += optlen;
        buflen -= optlen;
    }

    return TRUE;
}


IPADDR
IpReflectIpOptions(
    IfInfo* ifp,
    IpHeader* iphdr,
    IPADDR dstaddr
    )

/*++

Routine Description:

    Reflect any IP options in a received datagram

Arguments:

    ifp - Specifies the outgoing interface
    iphdr - Points to the received datagram header
    dstaddr - Specifies the final destination address

Return Value:

    New destination address

Note:

    We assume the option data in the received datagram
    has already been validated.

--*/

{
    BYTE* buf;
    BYTE opt, optlen, ptr;
    UINT buflen;
    IPADDR* paddr;

    buf = (BYTE*) iphdr + IPHDRLEN;
    buflen = GETIPHDRLEN(iphdr) - IPHDRLEN;

    while (buflen) {
        if ((opt = *buf) == IPOPT_EOL) break;
        if (opt == IPOPT_NOP) {
            buf++; buflen--;
            continue;
        }

        optlen = buf[1];

        switch (opt) {
        case IPOPT_LOOSE_SRCROUTE:
        case IPOPT_STRICT_SRCROUTE:
            //
            // We assume the record route option contains the following:
            //  G1 G2 ... Gn
            // and we'll modify it to:
            //  Gn-1 ... G2 G1 D
            // and return Gn as the new destination address
            //
            if ((ptr = buf[2]) > 4) {
                IPADDR addr;
                IPADDR* pend;

                ASSERT(optlen % 4 == 3 && ptr % 4 == 0);
                if (ptr > optlen) ptr = (BYTE) (optlen+1);

                paddr = (IPADDR*) (buf+3);
                pend = (IPADDR*) (buf+ptr-5);

                // swap Gn and D
                addr = *pend;
                
                // simple sanity check
                //  if the gateway address is bad, we'll just
                //  leave the source route option alone
                if (!XnetIsValidUnicastAddr(addr)) break;

                *pend = dstaddr;
                dstaddr = addr;
                pend--;

                // flip G1 ... Gn-1
                while (pend > paddr) {
                    addr = *pend;
                    *pend = *paddr;
                    *paddr = addr;
                    paddr++;
                    pend--;
                }
                
                // reset ptr field
                buf[2] = 4;
            }
            break;

        case IPOPT_RECORD_ROUTE:
            //
            // If there is room left, record our own IP address
            //
            if ((ptr = buf[2]) > optlen) break;
            ASSERT(optlen % 4 == 3 && ptr >= 4 && ptr % 4 == 0);

            paddr = (IPADDR*) (buf+ptr-1);
            *paddr = ifp->ipaddr;
            buf[2] += 4;
            break;
        
        case IPOPT_TIMESTAMP:
            if ((ptr = buf[2]) > optlen) {
                // increment the overflow count if we don't have room
                if ((buf[3] & 0xf0) < 0xf0) buf[3] += 0x10;
            } else {
                UINT timestamp;
                DWORD* p;

                ASSERT(optlen % 4 == 0 && optlen > 4 &&
                       ptr >= 5 && ptr % 4 == 1);

                p = (DWORD*) (buf+ptr-1);
                timestamp = IpGetMsecsSinceMidnightGMT();

                switch (buf[3] & 0xf) {
                case 3:
                    if (*p != ifp->ipaddr) break;
                    // fall through

                case 1:
                    if (optlen-ptr < 7) break;
                    *p++ = ifp->ipaddr;
                    buf[2] += 4;
                    ptr += 4;
                    // fall through

                case 0:
                    if (optlen-ptr < 3) break;
                    *p = HTONL(timestamp);
                    buf[2] += 4;
                    break;
                }
            }
            break;
        }

        buf += optlen;
        buflen -= optlen;
    }

    return dstaddr;
}



VOID
IpReceivePacket(
    Packet* pkt
    )

/*++

Routine Description:

    Receive an IP datagram
    (called by the NIC interface driver)

Arguments:

    pkt - Points to the received packet

Return Value:

    NONE

--*/

{
    IpHeader* iphdr;
    IPADDR dstaddr, srcaddr;
    UINT iphdrlen, iplen;
    IfInfo* ifp;

    ASSERT_DISPATCH_LEVEL();

    //
    // NOTE:
    // 1. We assume the received packet is at least large enough
    //    to hold the default IP header.
    // 2. It's more efficient if the interface driver can manage
    //    to place the IP header at DWORD-aligned boundary.
    //    This is NOT currently the case for EPRO100 interface driver:
    //    the Ethernet frame header starts at DWORD-aligned address;
    //    which causes the IP header to start at odd-WORD boundary.
    //
    ASSERT(pkt->datalen >= IPHDRLEN);

    // verify header and packet length
    iphdr = (IpHeader*) pkt->data;
    SETPKTIPHDR(pkt, iphdr);
    iphdrlen = VERIFY_IPVER_HDRLEN(iphdr->ver_hdrlen);
    iplen = GETIPLEN(iphdr);

    if (iphdrlen < IPHDRLEN || iphdrlen > iplen || iplen > pkt->datalen)
        goto discard;

    // if the received packet length is larger than the IP length,
    // ignore the data at the end
    pkt->datalen = iplen;

    // verify header checksum
    if (tcpipxsum(0, pkt->data, iphdrlen) != 0xffff)
        goto discard;

    //
    // Determine if the packet is addressed to us.
    //
    // NOTE:
    //
    // 1. We reject a packet if the destination address doesn't
    //    match the address of the interface it's received on
    //    (i.e. we implement the strong ES model).
    //
    // 2. We don't check if a packet with an IP broadcast/multicast
    //    destination address was received as unicast on the link-layer
    //    interface. Converse, we don't check if a packet with a unicast
    //    IP destination address was received as broadcast/multicast
    //    on the link-layer interface.
    //
    // 3. We'll receive multicast packets even before the interface
    //    has a valid IP address.
    //
    // 4. We only support the all-1's form of broadcast address.
    //    Also, we only support limited broadcasts and subnet
    //    directed broadcasts (i.e. no special case for directed
    //    broadcasts and all-subnets directed broadcasts).
    //
    // 5. We discard all datagrams whose source address is
    //    a broadcast or multicast address.
    //
    ifp = pkt->recvifp;
    dstaddr = iphdr->dstaddr;
    
    if (dstaddr == ifp->ipaddr && ifp->ipaddr != 0 ||
        IS_MCAST_IPADDR(dstaddr) && IfFindMcastGroup(ifp, dstaddr) ||
        IfBcastAddr(ifp, dstaddr) ||
        IfLoopback(ifp))
    {
        srcaddr = iphdr->srcaddr;
        if (IfBcastAddr(ifp, srcaddr) ||
            IS_MCAST_IPADDR(srcaddr) ||
            IS_LOOPBACK_IPADDR(srcaddr) && !IfLoopback(ifp))
            goto discard;

        // Check if there is fragmentation involved
        if (iphdr->fragoffset & HTONS(MORE_FRAGMENTS|FRAGOFFSET_MASK)) {
            IpReassemblePkt(pkt);
            return;
        }

        // Process options if needed
        if (iphdrlen > IPHDRLEN &&
            !IpProcessRecvOptions(pkt->data+IPHDRLEN, iphdrlen-IPHDRLEN, ifp)) {
            // NOTE: we could send a parameter problem ICMP packet here.
            TRACE_("IP datagram option error");
            goto discard;
        }

        pkt->data += iphdrlen;
        pkt->datalen -= iphdrlen;

        switch (iphdr->protocol) {
        case IPPROTOCOL_TCP:
            TcpReceivePacket(pkt);
            break;

        case IPPROTOCOL_UDP:
            UdpReceivePacket(pkt);
            break;

        case IPPROTOCOL_ICMP:
            IcmpReceivePacket(pkt);
            break;

        case IPPROTOCOL_IGMP:
            IgmpReceivePacket(pkt);
            break;

        default:
            RawReceivePacket(pkt);
            break;
        }
        return;
    }
    
discard:
    // Discard the packet and return
    XnetCompletePacket(pkt, NETERR_DISCARDED);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\ip\ipinit.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    ipinit.c

Abstract:

    IP module initialization and cleanup related functions

Revision History:

    05/24/2000 davidx
        Created it.

--*/

#include "precomp.h"


//
// Global interface table
//
IfInfo* Interfaces[IFINDEX_MAX];

VOID
IpTimerProc()

/*++

Routine Description:

    IP timer routine - called once a second

Arguments:

    dpc, context, param1, param2 - DPC function parameters

Return Value:

    NONE

--*/

{
    IfInfo* ifp;

    // Call interface timer routines
    LOOP_THRU_INTERFACE_LIST(ifp)
        // NOTE: This is a hack to ensure we don't call the Ethernet interface's
        // timer function twice when we are running under the debug monitor.
        if (XnetInsideDbgmon() &&
            ifp->refcount > 1 &&
            IfRunning(ifp))
            continue;

        if (ifp->Timer) ifp->Timer(ifp);
        if (ifp->mcastData) {
            IgmpTimerProc(ifp);
        }
        if (IfDhcpEnabled(ifp)) {
            DhcpTimerProc(ifp);
        }
    END_INTERFACE_LIST_LOOP()

    // Datagram reassembly timer routine
    IpReassemblyTimerProc();
}


//
// Interface initialization function
//
typedef NTSTATUS (*IfInitProc)(IfInfo**);
static const IfInitProc IfInitProcTable[IFINDEX_MAX] = {
    LoopbackInitialize,     // loopback interface
    EnetInitialize,         // Ethernet interface
    NULL                    // dial-up interface
};

NTSTATUS
IpInitialize()

/*++

Routine Description:

    Initialize the IP module

Arguments:

    NONE

Return Value:

    Status code

--*/

{
    NTSTATUS status;
    UINT ifindex;

    status = IpInitRouteTable();
    if (!NT_SUCCESS(status)) goto failed;

    for (ifindex=0; ifindex < IFINDEX_MAX; ifindex++) {
        IfInitProc initProc = IfInitProcTable[ifindex];
        IfInfo* ifp;

        if (!initProc) continue;
        status = initProc(&ifp);
        if (!NT_SUCCESS(status)) goto failed;

        ASSERT(ifp->hwaddrlen <= MAXHWADDRLEN);
        Interfaces[ifindex] = ifp;

        // Adjust the pseudo-random number generator seed
        // with the Ethernet hardware ID
        if (ifp->iftype == IFTYPE_ETHERNET) {
            ULONG seed = 0;
            WORD addrbyte;
            for (addrbyte=0; addrbyte < ifp->hwaddrlen; addrbyte++) {
                seed = (seed << 8) ^ ifp->hwaddr[addrbyte];
            }
            XnetRandSeed = (XnetRandSeed ^ seed) & 0x7fffffff;
        }

        if (IfBcastEnabled(ifp)) {
            status = IpSetBroadcastInterface(ifp);
            if (!NT_SUCCESS(status)) goto failed;
        }

        if (IfMcastEnabled(ifp)) {
            status = IfInitMcastGroup(ifp);
            if (!NT_SUCCESS(status)) goto failed;
        }

        if (IfDhcpEnabled(ifp)) {
            status = DhcpInitialize(ifp);
            if (!NT_SUCCESS(status)) goto failed;
        }
    }
    
    IpNextDgramId = (WORD) XnetRand();
    return NETERR_OK;

failed:
    WARNING_("IpInitialize failed: 0x%x", status);
    return status;
}


VOID
IpCleanup()

/*++

Routine Description:

    Cleanup the IP module

Arguments:

    NONE

Return Value:

    NONE

--*/

{
    IfInfo* ifp;

    RUNS_AT_DISPATCH_LEVEL

    // Cleanup DHCP info
    LOOP_THRU_INTERFACE_LIST(ifp)
        if (IfDhcpEnabled(ifp)) {
            DhcpCleanup(ifp);
        }
    END_INTERFACE_LIST_LOOP()

    IpCleanupReassemblyPkts(NULL);
    IpCleanupRouteTable();

    // Delete the interfaces
    LOOP_THRU_INTERFACE_LIST(ifp)
        Interfaces[_ifindex] = NULL;

        // NOTE: We shouldn't free per-interface multicast data
        // if the interface is shared by the debug monitor stack.
        if (ifp->refcount <= 1) {
            SysFree(ifp->mcastData);
            ifp->mcastData = NULL;
        }

        ifp->Delete(ifp);
    END_INTERFACE_LIST_LOOP()
    ZeroMem(Interfaces, sizeof(Interfaces));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\ip\iputil.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    iputil.c

Abstract:

    IP helper functions

Revision History:

    05/18/2000 davidx
        Created it.

--*/

#include "precomp.h"

//
// Maximum number of multicast groups an interface can belong to
//
UINT cfgMaxIfMcastAddrs = 32;


VOID
IfSetIpAddr(
    IfInfo* ifp,
    IPADDR ipaddr,
    IPADDR addrmask
    )

/*++

Routine Description:

    Set / clear the IP address for an interface

Arguments:

    ifp - Points to the interface structure
    ipaddr - Specifies the IP address (0 means to clear the address)
    addrmask - Specifies the subnet mask

Return Value:

    NONE

--*/

{
    KIRQL irql = RaiseToDpc();

    if (ipaddr == 0)
        addrmask = 0;
    else if (addrmask == 0 || !XnetIsValidSubnetMask(addrmask))
        addrmask = XnetGetDefaultSubnetMask(ipaddr);

    ifp->ipaddr = ipaddr;
    ifp->addrmask = addrmask;
    ifp->subnetAddr = (ipaddr & addrmask);
    ifp->subnetBcastAddr = ifp->subnetAddr | ~addrmask;

    if (ipaddr) {
        ifp->flags |= IFFLAG_RUNNING;

        // Add a host route for this interface
        if (!IfLoopback(ifp)) {

            #ifdef DEVKIT

            // BUGBUG: Spew out our IP address in the debugger
            // (even on a free build).
            if (ifp->refcount == 1) {
                DbgPrint("\n*** Xbox IP address: %s /", IPADDRSTR(ipaddr));
                DbgPrint(" %s\n\n", IPADDRSTR(addrmask));
            }

            #endif

            IpAddRTE(ifp->ipaddr,
                   0xffffffff,
                   IPADDR_LOOPBACK,
                   LoopbackIfp,
                   RTEFLAG_HOST,
                   DEFAULT_RTE_METRIC);

            DnsNotifyDefaultServers(ifp);
        }

        // Add a local subnet network route for this interface
        IpAddRTE(ifp->subnetAddr,
               ifp->addrmask,
               ifp->ipaddr,
               ifp,
               RTEFLAG_LOCAL,
               DEFAULT_RTE_METRIC);
    } else {
        // Mark the interface as inactive and clear all
        // route entries that go thru this interface.
        // Leave the broadcast route alone.
        ifp->flags &= ~IFFLAG_RUNNING;
        IpRemoveInterfaceRTE(ifp, FALSE);
    }

    LowerFromDpc(irql);
}


DWORD
IpGetBestAddress(
    IPADDR* addr
    )

/*++

Routine Description:

    Get the best available IP address for the local host

Arguments:

    addr - Returns the best IP address

Return Value:

    Flags indicating how the IP address was obtained

--*/

{
    KIRQL irql = RaiseToDpc();
    IfInfo* ifp;
    DWORD flags = 0;

    *addr = 0;

    LOOP_THRU_INTERFACE_LIST(ifp)
        if (IfRunning(ifp)) {
            *addr = ifp->ipaddr;
            if (IfLoopback(ifp)) {
                flags = XNET_ADDR_LOOPBACK;
            } else if (IfDhcpEnabled(ifp)) {
                flags = DhcpGetActiveAddressType(ifp);
            }
            break;
        }
    END_INTERFACE_LIST_LOOP()

    LowerFromDpc(irql);
    return flags;
}


NTSTATUS
IfGetDefaultDnsServers(
    IfInfo* dnsifp,
    CHAR* domainName,
    UINT namelen,
    IPADDR* serverAddrs,
    UINT* serverCnt
    )

/*++

Routine Description:

    Get the default DNS server information
    associated with the specified interface

Arguments:

    dnsifp - Points to an interface structure
    domainName - Buffer for receiving the default domain name
    namelen - Size of the domain name buffer
    serverAddrs - Buffer for receiving the default server addresses
    serverCnt - Number of default servers
        On entry, it specifies the size of the server address buffer
        On return, it contains the actual number of default servers

Return Value:

    Status code

--*/

{
    KIRQL irql = RaiseToDpc();
    IfInfo* ifp = NULL;
    NTSTATUS status;

    LOOP_THRU_INTERFACE_LIST(ifp)
        if (ifp == dnsifp) break;
    END_INTERFACE_LIST_LOOP()

    if (ifp != dnsifp) {
        status = NETERR_PARAM;
    } else if (IfDhcpEnabled(ifp)) {
        status = DhcpGetDefaultDnsServers(ifp, domainName, namelen, serverAddrs, serverCnt);
    } else {
        UINT count = *serverCnt * sizeof(IPADDR);
        status = ifp->Ioctl(ifp, IFCTL_GET_DNSSERVERS, domainName, namelen, serverAddrs, &count);
        *serverCnt = count / sizeof(IPADDR);
    }

    LowerFromDpc(irql);
    return status;
}


NTSTATUS
IfInitMcastGroup(
    IfInfo* ifp
    )

/*++

Routine Description:

    Initialize the per-interface multicast information

Arguments:

    ifp - Points to the interface structure

Return Value:

    Status code

--*/

{
    // NOTE: if ifp->mcastData is not NULL, then we must be sharing
    // the interface with the debug monitor. Since the debug monitor
    // has done the necessary initialization, we don't need to do it
    // again here.

    if (!ifp->mcastData) {
        UINT size = offsetof(IfMcastData, mcastGroups) +
                    sizeof(IfMcastGroup) * cfgMaxIfMcastAddrs;
        ifp->mcastData = (IfMcastData*) SysAlloc0(size, PTAG_MCAST);
        if (!ifp->mcastData)
            return NETERR_MEMORY;

        // Assume the querier is v1 when we start up
        ifp->mcastData->v1QuerierTimer = IGMP_V1_QUERIER_TIMER;
        ifp->mcastData->hasV1Querier = TRUE;

        // Join the all-hosts group
        IfChangeMcastGroup(ifp, IPADDR_ALLHOSTS, TRUE);
    }

    // Make this interface the default multicast interface
    return IpSetMulticastInterface(ifp);
}


BOOL
IfFindMcastGroup(
    IfInfo* ifp,
    IPADDR addr
    )

/*++

Routine Description:

    Check if an interface belongs to the specified multicast group

Arguments:

    ifp - Points to the interface structure
    addr - Specifies the multicast group address

Return Value:

    TRUE if we belong to the multicast group
    FALSE otherwise

--*/

{
    IfMcastData* ifmcast = ifp->mcastData;

    RUNS_AT_DISPATCH_LEVEL

    if (ifmcast) {
        IfMcastGroup* mcastgrp = ifmcast->mcastGroups;
        UINT count = ifmcast->groupCount;
        while (count--) {
            if (mcastgrp->mcastaddr == addr) return TRUE;
            mcastgrp++;
        }
    }

    return FALSE;
}


NTSTATUS
IfChangeMcastGroup(
    IfInfo* ifp,
    IPADDR mcastaddr,
    BOOL add
    )

/*++

Routine Description:

    Join or leave a multicast on the specified interface

Arguments:

    ifp - Points to the interface structure
    mcastaddr - Specifies the multicast group address
    add - Whether to join or leave the group

Return Value:

    Status code

--*/

{
    IfMcastData* ifmcast;
    IfMcastGroup* mcastgrp;
    UINT count;
    KIRQL irql;
    NTSTATUS status = NETERR_OK;
    BOOL notify;

    // Make sure addr is indeed a multicast address
    // and the interface supports multicast
    if (!IS_MCAST_IPADDR(mcastaddr) || (ifmcast = ifp->mcastData) == NULL)
        return NETERR_PARAM;

    irql = RaiseToDpc();
    mcastgrp = ifmcast->mcastGroups;
    count = ifmcast->groupCount;
    while (count) {
        if (mcastgrp->mcastaddr == mcastaddr) break;
        count--, mcastgrp++;
    }

    notify = FALSE;
    if (add) {
        // Joining a gruop
        if (count) {
            // The specified group already exists;
            // just increment its reference count.
            mcastgrp->refcount++;
        } else if (ifmcast->groupCount == cfgMaxIfMcastAddrs) {
            // Too many groups already
            status = NETERR(WSAEADDRNOTAVAIL);
        } else {
            // Add a new group
            ifmcast->groupCount++;
            mcastgrp->refcount = 1;
            mcastgrp->mcastaddr = mcastaddr;
            mcastgrp->reportTimer = 0;
            mcastgrp->sentLastReport = FALSE;
            notify = TRUE;
        }
    } else {
        // Leaving a group
        if (count == 0) {
            // The specified address is not found
            status = NETERR_PARAM;
        } else {
            // Remove the specified multicast group address
            IgmpSendLeave(ifp, mcastgrp);
            while (--count) {
                *mcastgrp = *(mcastgrp+1);
                mcastgrp++;
            }
            ifmcast->groupCount--;
            notify = TRUE;
        }
    }

    // Notify the NIC and inform the IGMP module
    if (notify) {
        status = ifp->Ioctl(ifp, IFCTL_SET_MCAST_ADDRS, NULL, 0, NULL, NULL);
        if (add) {
            if (NT_SUCCESS(status)) {
                // Send out an IGMP report message
                // and resend another one a short while later
                IgmpSendReport(ifp, mcastgrp);
                mcastgrp->reportTimer = IGMP_JOIN_RETRY_TIMER;
            } else {
                // If we failed to join a group, back out
                ifmcast->groupCount--;
            }
        }
    }

    LowerFromDpc(irql);
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\ip\igmp.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    igmp.h

Abstract:

    IGMP protocol related declarations.

Notes:

    Please refer to RFC 1112 and 2236.

Revision History:

    05/02/2000 davidx
        Created it.

--*/

#ifndef _IGMP_H
#define _IGMP_H

//
// IGMP v2 message header format
//
typedef struct _IgmpMessage {
    BYTE type;              // message type
    BYTE maxresptime;       // max response time
    WORD checksum;          // checksum
    IPADDR groupaddr;       // multicast group address
} IgmpMessage;

#define IGMPHDRLEN sizeof(IgmpMessage)

//
// Message type constants
//
#define IGMPTYPE_MEMBER_QUERY    0x11   // membership query
#define IGMPTYPE_MEMBER_REPORT_1 0x12   // membership report (version 1)
#define IGMPTYPE_MEMBER_REPORT_2 0x16   // membership report (version 2)
#define IGMPTYPE_LEAVE_GROUP     0x17   // leave group

//
// When we join a new group, we'll send out two membership report messages.
// The second report is sent out 2 seconds after the first one.
//
#define IGMP_JOIN_RETRY_TIMER   2

//
// IGMPv1 query response timer (10 seconds)
//
#define IGMP_V1_QUERY_RESPONSE  10

//
// How long to wait after hearing an IGMPv1 query
// before we can send IGMPv2 messages again.
//
#define IGMP_V1_QUERIER_TIMER   400

#endif // !_IGMP_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\ip\ipimpl.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    ipimpl.h

Abstract:

    Declarations private to the IP implementation

Revision History:

    05/22/2000 davidx
        Created it.

--*/

#ifndef _IPIMPL_H
#define _IPIMPL_H

// IP datagram reassembly related functions
VOID IpCleanupReassemblyPkts(IfInfo* ifp);
VOID IpReassemblyTimerProc();

// Handle the reception of an ICMP message
VOID IcmpReceivePacket(Packet* pkt);

// Reflect option data in the IP header
IPADDR IpReflectIpOptions(IfInfo* ifp, IpHeader* iphdr, IPADDR dstaddr);

//
// Returns the number of milliseconds since midnight GMT
//
INLINE UINT IpGetMsecsSinceMidnightGMT() {
    LARGE_INTEGER time;
    TIME_FIELDS timeFields;

    KeQuerySystemTime(&time);
    RtlTimeToTimeFields(&time, &timeFields);

    return timeFields.Milliseconds +
           (timeFields.Hour * 3600 +
            timeFields.Minute * 60 +
            timeFields.Second) * 1000;
}

// Find if an interface belongs to a multicast group
BOOL IfFindMcastGroup(IfInfo* ifp, IPADDR addr);
NTSTATUS IfInitMcastGroup(IfInfo* ifp);

// Initialize the loopback interface
NTSTATUS LoopbackInitialize(IfInfo** newifp);

// Process a received IGMP message
VOID IgmpReceivePacket(Packet* pkt);
VOID IgmpTimerProc(IfInfo* ifp);
VOID IgmpSendMessage(IfInfo* ifp, IPADDR dstaddr, BYTE type, IPADDR groupaddr);

INLINE VOID IgmpSendReport(IfInfo* ifp, IfMcastGroup* mcastgrp) {
    if (mcastgrp->mcastaddr != IPADDR_ALLHOSTS) {
        mcastgrp->sentLastReport = TRUE;
        IgmpSendMessage(
            ifp,
            mcastgrp->mcastaddr, 
            (BYTE) (ifp->mcastData->hasV1Querier ?
                    IGMPTYPE_MEMBER_REPORT_1 :
                    IGMPTYPE_MEMBER_REPORT_2),
            mcastgrp->mcastaddr);
    }
}

INLINE VOID IgmpSendLeave(IfInfo* ifp, IfMcastGroup* mcastgrp) {
    if (mcastgrp->mcastaddr != IPADDR_ALLHOSTS &&
        !ifp->mcastData->hasV1Querier &&
        mcastgrp->sentLastReport) {
        IgmpSendMessage(
            ifp,
            IPADDR_ALLROUTERS,
            IGMPTYPE_LEAVE_GROUP,
            mcastgrp->mcastaddr);
    }
}

#endif // !_IPIMPL_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\ip\precomp.h ===
#include "xnetp.h"
#include "icmp.h"
#include "igmp.h"
#include "ipimpl.h"
#include "route.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\ip\loopback.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    loopback.c

Abstract:

    Implement the loopback interface functions

Revision History:

    05/19/2000 davidx
        Created it.

--*/

#include "precomp.h"

//
// Loopback interface structure
//
typedef struct _IfLoopback {
    // Info common to all interface types
    IfInfo;

    // DPC object
    KDPC dpc;
} IfLoopback;


PRIVATE VOID
LoopbackDpc(
    PKDPC dpc,
    IfLoopback* ifp,
    VOID* arg1,
    VOID* arg2
    )

/*++

Routine Description:

    Loopback interface DPC function:
      remove packets queued up in the sendq
      and pass it upstream for processing.

Arguments:

    dpc - Pointer to the DPC object
    ifp - Pointer to the loopback interface object
    arg1, arg2 - Unused arguments

Return Value:

    NONE

--*/

{
    Packet* pkt;
    IPADDR dstaddr;

    while (!PktQIsEmpty(&ifp->sendq)) {
        pkt = IfDequeuePacket(ifp);

        if (pkt->datalen < IPHDRLEN) {
            XnetCompletePacket(pkt, NETERR_PARAM);
            continue;
        }
        
        dstaddr = GETPKTDATA(pkt, IpHeader)->dstaddr;
        if (IfBcastAddr(ifp, dstaddr) || IS_MCAST_IPADDR(dstaddr))
            pkt->pktflags |= PKTFLAG_MCAST;
        else
            pkt->pktflags &= ~PKTFLAG_MCAST;

        pkt->recvifp = (IfInfo*) ifp;
        IpReceivePacket(pkt);
    }
}


PRIVATE VOID
LoopbackStartOutput(
    IfLoopback* ifp
    )

/*++

Routine Description:

    Send out any queued packets on the loopback interface

Arguments:

    ifp - Points to the interface structure

Return Value:

    NONE

--*/

{
    RUNS_AT_DISPATCH_LEVEL
    if (!PktQIsEmpty(&ifp->sendq)) {
        KeInsertQueueDpc(&ifp->dpc, NULL, NULL);
    }
}


NTSTATUS
IpQueueLoopbackPacket(
    Packet* pkt,
    BOOL copyflag
    )

/*++

Routine Description:

    Queue up a packet on the loopback interface

Arguments:

    pkt - Points to the packet to be queued up
    copyflag - Whether to queue up the packet directly
        or to queue up a copy of the packet

Return Value:

    Status code

--*/

{
    IfLoopback* ifp;

    ASSERT_DISPATCH_LEVEL();

    if (copyflag) {
        Packet* newpkt = XnetCopyPacket(pkt, 0);
        if (!newpkt) return NETERR_MEMORY;
        pkt = newpkt;
    }

    ifp = (IfLoopback*) LoopbackIfp;
    ASSERT(ifp != NULL);
    IfEnqueuePacket(ifp, pkt);
    KeInsertQueueDpc(&ifp->dpc, NULL, NULL);

    return NETERR_OK;
}


PRIVATE NTSTATUS
LoopbackIoctl(
    IfLoopback* ifp,
    INT ctlcode,
    VOID* inbuf,
    UINT inlen,
    VOID* outbuf,
    UINT* outlen
    )

/*++

Routine Description:

    Loopback interface I/O control function

Arguments:

    ifp - Points to the interface structure
    ctlcode - Control code
    inbuf - Points to the input buffer
    inlen - Size of the input buffer
    outbuf - Points to the output buffer
    outlen - On entry, this contains the size of the output buffer
        On return, this is the actually number of output bytes

Return Value:

    Status code

--*/

{
    // We don't support any interface IOCTLs
    return NETERR_NOTIMPL;
}

   
PRIVATE VOID
LoopbackDelete(
    IfLoopback* ifp
    )

/*++

Routine Description:

    Delete the loopback interface

Arguments:

    ifp - Points to the interface structure

Return Value:

    NONE

--*/

{
    RUNS_AT_DISPATCH_LEVEL

    ASSERT(ifp->refcount == 1);
    KeRemoveQueueDpc(&ifp->dpc);

    // Cleanup the send queue
    while (!PktQIsEmpty(&ifp->sendq)) {
        Packet* pkt = PktQRemoveHead(&ifp->sendq);
        XnetCompletePacket(pkt, NETERR_CANCELLED);
    }
    
    SysFree(ifp);
}


NTSTATUS
LoopbackInitialize(
    IfInfo** newifp
    )

/*++

Routine Description:

    Initialize the loopback interface

Arguments:

    newifp - Returns a pointer to the loopback interface

Return Value:

    Status code

--*/

{
    IfLoopback* ifp;

    ifp = (IfLoopback*) SysAlloc0(sizeof(IfLoopback), PTAG_LPBK);
    if (!ifp) return NETERR_MEMORY;

    ifp->refcount = 1;
    ifp->ifname = "Loopback";
    ifp->Delete = (IfDeleteProc) LoopbackDelete;
    ifp->StartOutput = (IfStartOutputProc) LoopbackStartOutput;
    ifp->Ioctl = (IfIoctlProc) LoopbackIoctl;

    // We pretend to have a hardware address
    // which is the same as the IP address.
    ifp->iftype = IFTYPE_LOOPBACK;
    ifp->hwaddrlen = IPADDRLEN;
    *((IPADDR*) ifp->hwaddr) = IPADDR_LOOPBACK;

    ifp->mtu = MAXIPLEN;
    ifp->framehdrlen = 0;

    KeInitializeDpc(&ifp->dpc, (PKDEFERRED_ROUTINE) LoopbackDpc, ifp);
    ifp->flags |= IFFLAG_UP;

    *newifp = (IfInfo*) ifp;
    IfSetIpAddr(*newifp, IPADDR_LOOPBACK, CLASSA_NETMASK);
    return NETERR_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\ip\ipsend.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    ipsend.c

Abstract:

    IP datagram transmission related functions

Revision History:

    05/22/2000 davidx
        Created it.

--*/

#include "precomp.h"

//
// Default type-of-service value for outgoing datagrams
//
BYTE cfgDefaultTos = 0;

//
// Default time-to-live value for outgoing datagrams
//
BYTE cfgDefaultTtl = 64;

//
// Identifier to be assigned to the next outgoing IP datagram
//
WORD IpNextDgramId;


NTSTATUS
IpSendPacket(
    Packet* pkt,
    IPADDR dstaddr,
    IfInfo* ifp,
    RTE** cachedRte
    )

/*++

Routine Description:

    Send out an IP datagram to the specified destination address

Arguments:

    pkt - Specifies the datagram to be sent
    dstaddr - Specifies the destination address
    ifp - Points to the outgoing interface, optional
    cachedRte - Address of a cached route entry pointer

Return Value:

    Status code

--*/

{
    RTE* rte;

    RUNS_AT_DISPATCH_LEVEL

    // The IP header must be completely filled out
    ASSERT(pkt->data == (BYTE*) GETPKTIPHDR(pkt));

    // Find a route and cache it
    if ((rte = *cachedRte) == NULL || IsRteOrphaned(rte)) {
        // release the orphaned route entry
        if (rte) { IpReleaseCachedRTE(rte); }

        *cachedRte = rte = IpFindRTE(dstaddr, ifp);
        if (!rte) {
            XnetCompletePacket(pkt, NETERR_UNREACHABLE);
            return NETERR_UNREACHABLE;
        }
        RteAddRef(rte);
    }

    pkt->nexthop = IsRteLocal(rte) ? dstaddr : rte->nexthop;
    ifp = rte->ifp;
    if (pkt->datalen > ifp->mtu) {
        XnetCompletePacket(pkt, NETERR_MSGSIZE);
        return NETERR_MSGSIZE;
    }

    //
    // Queue up the packet for transmission
    // We use a very crude priority mechanism here:
    // - normal packets are added to the end of the queue
    // - retransmitted packets are added to the front of the queue
    //
    if (pkt->pktflags & PKTFLAG_REXMIT) {
        PktQInsertHead(&ifp->sendq, pkt);
    } else {
        PktQInsertTail(&ifp->sendq, pkt);
    }
    ifp->StartOutput(ifp);

    return NETERR_OK;
}


VOID
IpSendPacketInternal(
    Packet* pkt,
    IPADDR srcaddr,
    IPADDR dstaddr,
    BYTE protocol,
    IfInfo* ifp
    )

/*++

Routine Description:

    Send an IP datagram out on the specified interface.
    This is called by internal clients such as ICMP and DHCP.

Arguments:

    pkt - Specifies the datagram to be sent
    srcaddr - Specifies the source address
    dstaddr - Specifies the destination address
    protocol - Specifies the protocol number
    ifp - Points to the outgoing interface

Return Value:

    NONE

Note:

    We assume the pkt->iphdr field points to where the IP header starts.

--*/

{
    RTE* rte = NULL;
    IpHeader* iphdr;
    UINT iphdrlen;
    KIRQL irql;

    //
    // Fix up the IP header
    //
    iphdr = GETPKTIPHDR(pkt);
    ASSERT((BYTE*) iphdr < pkt->data);

    iphdrlen = pkt->data - (BYTE*) iphdr;
    pkt->data -= iphdrlen;
    pkt->datalen += iphdrlen;

    FILL_IPHEADER(
        iphdr,
        iphdrlen,
        cfgDefaultTos,
        pkt->datalen,
        0,
        cfgDefaultTtl,
        protocol,
        srcaddr,
        dstaddr);

    irql = RaiseToDpc();
    IpSendPacket(pkt, dstaddr, ifp, &rte);
    if (rte) { IpReleaseCachedRTE(rte); }
    LowerFromDpc(irql);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\lib\precomp.h ===
#include "xnetp.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\modem\globals.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

    globals.cpp

Abstract:
    
    Global variables for the USB modem.
    
Revision History:

    06-21-00    vadimg      created

--*/

#include "precomp.h"

USB_PNP_CLASS_DRIVER_DESCRIPTION gClassDescription;
USB_PNP_DEVICE_TYPE_DESCRIPTION  gDeviceDescription;

PMDL gpMdl;
URB gUrb;
BOOL gfUrbInUse;
BOOL gfRemoved;
KIRQL gIrql;

PMDL gpMdlRead;
URB gUrbRead;

URB_MEMORY gMem;

COMM_DEVICE_INFO gDevice;
READ_BUFFER gRead;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\lib\netutil.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    netutil.c

Abstract:

    Misc. utility functions used by the net code

Revision History:

    05/17/2000 davidx
        Created it.

--*/

#include "precomp.h"


Packet*
XnetAllocPacket(
    UINT size,
    UINT pktflags
    )

/*++

Routine Description:

    Allocate memory for holding a network packet

Arguments:

    size - Specifies the desired packet size (not including header)
    pktflags - Allocation flags: PKTFLAG_NETPOOL or 0

Return Value:

    Pointer to the allocated packet structure
    NULL if we ran out of memory

--*/

{
    Packet* pkt;

    size += PKTHDRLEN;

    #ifndef DVTSNOOPBUG

    if (pktflags & PKTFLAG_NETPOOL)
        pkt = (Packet*) XnetAlloc(size, PTAG_PKT);
    else 
        pkt = (Packet*) SysAlloc(size, PTAG_PKT);

    #else

    // BUGBUG: temporary hack to workaround nv2a snooping bug
    pktflags = PKTFLAG_UNCACHED;
    pkt = (Packet*) XnetUncachedAllocProc(size, PTAG_PKT);

    #endif

    if (pkt) {
        pkt->nextpkt = NULL;
        pkt->pktflags = (WORD) (pktflags | defaultPacketAllocFlag);
        pkt->data = pkt->buf;
        pkt->datalen = 0;
        pkt->completionCallback = NULL;
    } else {
        WARNING_("Couldn't allocate packet: out of memory");
    }

    return pkt;
}


Packet*
XnetCopyPacket(
    Packet* pkt,
    UINT extraHdr
    )

/*++

Routine Description:

    Make a copy of the specified packet

Arguments:

    pkt - Specifies the packet to be copied
    extraHdr - Extra space to reserve at the beginning of the copied packet

Return Value:

    Return a pointer to the copied packet
    NULL if out of memory

--*/

{
    Packet* newpkt;

    ASSERT(pkt != NULL);

    // Allocate memory space for the new packet
    newpkt = XnetAllocPacket(extraHdr + pkt->datalen, 0);
    if (!newpkt) return NULL;
    newpkt->data += extraHdr;

    // Copy data into the new packet
    if (pkt->datalen) {
        newpkt->datalen = pkt->datalen;
        CopyMem(newpkt->data, pkt->data, pkt->datalen);
    }

    return newpkt;
}


CHAR*
IpAddrToString(
    IPADDR ipaddr,
    CHAR* buf,
    INT buflen
    )

/*++

Routine Description:

    Convert an IP address to an ASCII character string

Arguments:

    ipaddr - Specifies the IP address in question
    buf - Output buffer
    buflen - Size of the output buffer

Return Value:

    Points to the converted IP address string

--*/

{
    // The longest string is xxx.xxx.xxx.xxx
    CHAR tmpbuf[16];
    INT i, j, q, r, d;
    CHAR* s;
    CHAR* p;

    // If the caller's buffer is large enough, then we'll
    // use it directly. Otherwise, we'll use a temporary
    // stack buffer first and then copy the result into
    // the caller's buffer.
    p = s = (buflen >= sizeof(tmpbuf)) ? buf : tmpbuf;

    for (i=0; i < 4; i++) {
        r = ipaddr & 0xff;
        ipaddr = ipaddr >> 8;   // assume little-endian here
        d = 100;
        for (j=0; j < 3; j++) {
            q = r / d;
            r = r % d;
            d /= 10;
            if (q || j == 2 || (p != s && p[-1] != '.'))
                *p++ = (CHAR) (q + '0');
        }
        *p++ = '.';
    }
    p[-1] = 0;

    if (s != buf) {
        CopyMem(buf, s, min(buflen, p-s));
    }
    return buf;
}


BOOL
IpAddrFromString(
    const CHAR* str,
    IPADDR* ipaddr
    )

/*++

Routine Description:

    Convert the string representation of IP address to its binary form.
    Following formats are recognized:
        a.b.c.d     8-8-8-8
        a.b.c       8-8-16
        a.b         8-24
        a           32
    Each field can be in decimal, octal, or hex format.

Arguments:

    str - Points to the IP address string to be converted
    ipaddr - Returns the binary representation of the IP address
        (in network byte order)

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    ULONG fields[4], addr;
    UINT fieldcnt = 0;
    const UCHAR* p = (const UCHAR*) str;

    // NOTE: We don't handle overflow conditions.

    while (TRUE) {
        // skip leading spaces
        while (*p == ' ') p++;
        if (fieldcnt >= 4 || *p == 0) break;
    
        addr = 0;
        if (*p == '0' && (p[1] == 'x' || p[1] == 'X')) {
            // hex number
            const UCHAR* q = (p += 2);

            while (TRUE) {
                if (*p >= '0' && *p <= '9')
                    addr = (addr << 4) + (*p - '0');
                else if (*p >= 'a' && *p <= 'f')
                    addr = (addr << 4) + 10 + (*p - 'a');
                else if (*p >= 'A' && *p <= 'F')
                    addr = (addr << 4) + 10 + (*p - 'A');
                else
                    break;
                p++;
            }

            if (q == p) return FALSE;

        } else if (*p == '0') {
            // octal number
            do {
                addr = (addr << 3) + (*p - '0');
                p++;
            } while (*p >= '0' && *p <= '7');
        } else if (*p >= '1' && *p <= '9') {
            // decimal number
            do {
                addr = addr*10 + (*p - '0');
                p++;
            } while (*p >= '0' && *p <= '9');
        } else {
            // invalid character
            break;
        }

        // skip trailing spaces and . separator
        while (*p == ' ') p++;
        if (*p == '.') p++;

        fields[fieldcnt++] = addr;
    }

    if (*p) return FALSE;

    switch (fieldcnt) {
    case 1:
        addr = fields[0];
        break;
    case 2:
        addr = ((fields[0] & 0xff) << 24) |
               (fields[1] & 0xffffff);
        break;
    case 3:
        addr = ((fields[0] & 0xff) << 24) |
               ((fields[1] & 0xff) << 16) |
               (fields[2] & 0xffff);
        break;
    case 4:
        addr = ((fields[0] & 0xff) << 24) |
               ((fields[1] & 0xff) << 16) |
               ((fields[2] & 0xff) <<  8) |
               (fields[3] & 0xff);
        break;

    default:
        addr = 0;
        break;
    }

    *ipaddr = HTONL(addr);
    return TRUE;
}


IPADDR
XnetGetDefaultSubnetMask(
    IPADDR ipaddr
    )

/*++

Routine Description:

    Return the default subnet mask for a given IP address

Arguments:

    ipaddr - Specifies the IP address

Return Value:

    Default subnet mask for the specified address

--*/

{
    IPADDR mask;

    if (IS_CLASSA_IPADDR(ipaddr))
        mask = CLASSA_NETMASK;
    else if (IS_CLASSB_IPADDR(ipaddr))
        mask = CLASSB_NETMASK;
    else if (IS_CLASSC_IPADDR(ipaddr))
        mask = CLASSC_NETMASK;
    else if (IS_CLASSD_IPADDR(ipaddr))
        mask = CLASSD_NETMASK;
    else {
        WARNING_("Invalid host IP address: %s", IPADDRSTR(ipaddr));
        mask = 0;
    }

    return mask;
}


//
// Pseudo-random number generator seed
//
ULONG XnetRandSeed;

VOID
XnetInitRandSeed()

/*++

Routine Description:

    Initialize the pseudo random number generator seed

Arguments:

    NONE

Return Value:

    NONE

Note:

    Our initial random number seed is based on processor's timestamp count
    and the system real-time clock. This will be later modified by the
    Ethernet hardware ID.

--*/

{
    LARGE_INTEGER currentTime;

    __asm {
        __emit  0x0f                // rdtsc
        __emit  0x31
        mov     XnetRandSeed, eax
    }

    KeQuerySystemTime(&currentTime);
    XnetRandSeed = (XnetRandSeed ^ currentTime.LowPart) & 0x7fffffff;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\modem\config.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

    usb.cpp

Abstract:
    
    USB code to talk to the modem.
    
Revision History:

    06-21-00    vadimg      created

--*/

#include "precomp.h"

/***************************************************************************\
* CloseEndpoints3
*
\***************************************************************************/

VOID CloseEndpoints3(PURB purb, PVOID)
{
    ASSERT_DISPATCH_LEVEL();

    if (gfRemoved) {
        gDevice.pDevice->RemoveComplete();
        gDevice.pDevice = NULL;
        gfRemoved = FALSE;
    }
}

/***************************************************************************\
* CloseEndpoints2
*
\***************************************************************************/

VOID CloseEndpoints2(PURB purb, PVOID)
{
    ASSERT_DISPATCH_LEVEL();

    if (gDevice.pIntInEndpointHandle != NULL) {

        USB_BUILD_CLOSE_ENDPOINT(
                (PURB_CLOSE_ENDPOINT)purb,
                gDevice.pIntInEndpointHandle,
                (PURB_COMPLETE_PROC)CloseEndpoints3,
                NULL);

        gDevice.pDevice->SubmitRequest((PURB)purb);

        gDevice.pIntInEndpointHandle = NULL;
    }
}

/***************************************************************************\
* CloseEndpoints1
*
\***************************************************************************/

VOID CloseEndpoints1(PURB purb, PVOID)
{
    ASSERT_DISPATCH_LEVEL();

    if (gDevice.pBulkOutEndpointHandle != NULL) {

        USB_BUILD_CLOSE_ENDPOINT(
                (PURB_CLOSE_ENDPOINT)purb,
                gDevice.pBulkOutEndpointHandle,
                (PURB_COMPLETE_PROC)CloseEndpoints2,
                NULL);

        gDevice.pDevice->SubmitRequest((PURB)purb);

        gDevice.pBulkOutEndpointHandle = NULL;
    }
}

/***************************************************************************\
* CloseEndpoints
*
\***************************************************************************/

VOID CloseEndpoints(VOID)
{
    PURB purb = &gUrb;

    ASSERT_DISPATCH_LEVEL();

    if (gDevice.pBulkInEndpointHandle != NULL) {

        USB_BUILD_CLOSE_ENDPOINT(
                (PURB_CLOSE_ENDPOINT)purb,
                gDevice.pBulkInEndpointHandle,
                (PURB_COMPLETE_PROC)CloseEndpoints1,
                NULL);

        gDevice.pDevice->SubmitRequest((PURB)purb);

        gDevice.pBulkInEndpointHandle = NULL;
    }
}

/***************************************************************************\
* OpenEndpoints
*
\***************************************************************************/

BOOL OpenEndpoints(VOID)
{
    USBD_STATUS status;
    PURB_OPEN_ENDPOINT purb = (PURB_OPEN_ENDPOINT)&gUrb;

    ASSERT_DISPATCH_LEVEL();

    if (gDevice.pBulkInEndpointHandle == NULL) {

        USB_BUILD_OPEN_ENDPOINT(
                purb,
                gDevice.bBulkInEndpointAddress,
                USB_ENDPOINT_TYPE_BULK,
                gDevice.wBulkInMaxPacket,
                2);
    
        status = gDevice.pDevice->SubmitRequest((PURB)purb);
        if (USBD_SUCCESS(status)) {
            gDevice.pBulkInEndpointHandle = purb->EndpointHandle;
        } else {
            return FALSE;
        }
    }

    if (gDevice.pBulkOutEndpointHandle == NULL) {

        USB_BUILD_OPEN_ENDPOINT(
                purb,
                gDevice.bBulkOutEndpointAddress,
                USB_ENDPOINT_TYPE_BULK,
                gDevice.wBulkOutMaxPacket,
                2);
    
        status = gDevice.pDevice->SubmitRequest((PURB)purb);
        if (USBD_SUCCESS(status)) {
            gDevice.pBulkOutEndpointHandle = purb->EndpointHandle;
        } else {
            return FALSE;
        }
    }

    if (gDevice.pIntInEndpointHandle == NULL) {

        USB_BUILD_OPEN_ENDPOINT(
                purb,
                gDevice.bIntInEndpointAddress,
                USB_ENDPOINT_TYPE_INTERRUPT,
                gDevice.wIntInMaxPacket,
                2);
    
        status = gDevice.pDevice->SubmitRequest((PURB)purb);
        if (USBD_SUCCESS(status)) {
            gDevice.pIntInEndpointHandle = purb->EndpointHandle;
        } else {
            return FALSE;
        }
    }

    return TRUE;
}

/***************************************************************************\
* EnumSetConfiguration1
*
\***************************************************************************/

VOID EnumSetConfiguration1(PURB purb, IUsbDevice *pDevice)
{
    ASSERT_DISPATCH_LEVEL();

    if (USBD_ERROR(purb->Header.Status)) {
        pDevice->AddComplete(USBD_STATUS_UNSUPPORTED_DEVICE, NULL);
        return;
    }

    gDevice.pDevice = pDevice;
    pDevice->SetClassSpecificType(0);
    pDevice->AddComplete(USBD_STATUS_SUCCESS, NULL);
}

/***************************************************************************\
* EnumGetConfiguration1
*
\***************************************************************************/

VOID EnumGetConfiguration1(PURB purb, IUsbDevice *pDevice)
{
    PUSB_COMMON_DESCRIPTOR pCommonDesc;
    PUSB_CONFIGURATION_DESCRIPTOR pConfigDesc;
    PUSB_INTERFACE_DESCRIPTOR pInterDesc;
    PUSB_ENDPOINT_DESCRIPTOR pEndDesc;
    UCHAR bType, bNumInter, bNumEnd, iInter, iEnd;
    PUCHAR pParse;
    BOOL fCommFound = FALSE;

    ASSERT_DISPATCH_LEVEL();

    if (USBD_ERROR(purb->Header.Status)) {
        pDevice->AddComplete(USBD_STATUS_UNSUPPORTED_DEVICE, NULL);
        return;
    }

    pConfigDesc = (PUSB_CONFIGURATION_DESCRIPTOR)&gMem.ConfigDesc;

    // pointer to the first interface
    pParse = (PUCHAR)pConfigDesc + pConfigDesc->bLength;
    pCommonDesc = (PUSB_COMMON_DESCRIPTOR)pParse;
    iInter = iEnd = 0;
    bNumInter = pConfigDesc->bNumInterfaces;

    while (TRUE) {

        if (pCommonDesc->bDescriptorType == USB_INTERFACE_DESCRIPTOR_TYPE) {

            pInterDesc = (PUSB_INTERFACE_DESCRIPTOR)pCommonDesc;
            bNumEnd = pInterDesc->bNumEndpoints;
            iInter++;
            iEnd = 0;

            if (pInterDesc->bInterfaceClass == USB_COMM_COMMUNICATION_CLASS_CODE) {
                gDevice.bCommInterface = pInterDesc->bInterfaceNumber;
                fCommFound = TRUE;
            }

            if ((iInter == bNumInter) && (bNumEnd == 0)) {
                break;
            }

        } else if (pCommonDesc->bDescriptorType == USB_ENDPOINT_DESCRIPTOR_TYPE) {

            pEndDesc = (PUSB_ENDPOINT_DESCRIPTOR)pCommonDesc;
            bType = (pEndDesc->bmAttributes & USB_ENDPOINT_TYPE_MASK);
            iEnd++;

            if (USB_ENDPOINT_DIRECTION_IN(pEndDesc->bEndpointAddress)) {
                if (bType == USB_ENDPOINT_TYPE_BULK) {
                    gDevice.bBulkInEndpointAddress = pEndDesc->bEndpointAddress;
                    gDevice.wBulkInMaxPacket = pEndDesc->wMaxPacketSize;
                    gDevice.pBulkInEndpointHandle = NULL;
                } else if (bType == USB_ENDPOINT_TYPE_INTERRUPT) {
                    gDevice.bIntInEndpointAddress = pEndDesc->bEndpointAddress;
                    gDevice.wIntInMaxPacket = pEndDesc->wMaxPacketSize;
                    gDevice.pIntInEndpointHandle = NULL;
                }
            } else {
                if (bType == USB_ENDPOINT_TYPE_BULK) {
                    gDevice.bBulkOutEndpointAddress = pEndDesc->bEndpointAddress;
                    gDevice.wBulkOutMaxPacket = pEndDesc->wMaxPacketSize;
                    gDevice.pBulkOutEndpointHandle = NULL;
                }
            }

            if ((iInter == bNumInter) && (iEnd == bNumEnd)) {
                break;
            }
        } 

        pParse += pCommonDesc->bLength;
        pCommonDesc = (PUSB_COMMON_DESCRIPTOR)pParse;
    }

    if (!fCommFound) {
        pDevice->AddComplete(USBD_STATUS_UNSUPPORTED_DEVICE, NULL);
        return;
    }

    USB_BUILD_SET_CONFIGURATION(
            (PURB_CONTROL_TRANSFER)purb,
            pConfigDesc->bConfigurationValue,
            (PURB_COMPLETE_PROC)EnumSetConfiguration1,
            (PVOID)pDevice);

    ((PURB_CONTROL_TRANSFER)purb)->InterruptDelay = 3;
    pDevice->SubmitRequest(purb);
}

/***************************************************************************\
* ConfigureDevice
*
\***************************************************************************/

VOID ConfigureDevice(IUsbDevice *pDevice)
{
    PURB purb = &gUrb;

    ASSERT_DISPATCH_LEVEL();

    DbgPrint("xmodem: ConfigureDevice\n");

    USB_BUILD_OPEN_DEFAULT_ENDPOINT((PURB_OPEN_ENDPOINT)purb);
    pDevice->SubmitRequest(purb);

    if (USBD_ERROR(purb->Header.Status)) {
        pDevice->AddComplete(USBD_STATUS_UNSUPPORTED_DEVICE, NULL);
        return;
    }

    MmInitializeMdl(gpMdl, &gMem, sizeof(gMem));

    USB_BUILD_GET_DESCRIPTOR(
            (PURB_CONTROL_TRANSFER)purb,
            USB_CONFIGURATION_DESCRIPTOR_TYPE,
            1,
            0,
            gpMdl,
            CONFIG_DESC_SIZE,
            (PURB_COMPLETE_PROC)EnumGetConfiguration1,
            (PVOID)pDevice);

    ((PURB_CONTROL_TRANSFER)purb)->InterruptDelay = 3;
    pDevice->SubmitRequest(purb);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\ip\route.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    route.c

Abstract:

    Simple IP datagram routing functionality

Revision History:

    05/22/2000 davidx
        Created it.

--*/

#include "precomp.h"

//
// Route table (actually a list)
//
LIST_ENTRY IpRouteList;
IPADDR IpLastRteAddr;
RTE* IpLastRte;

#define INVALIDATELASTRTE() (IpLastRteAddr = 0, IpLastRte = NULL)

//
// Convenience macros for loop through all route table entries
//
#define LOOP_THRU_ROUTE_LIST(_rte) { \
            RTE* _next; \
            _rte = (RTE*) IpRouteList.Flink; \
            for (; _rte != (RTE*) &IpRouteList; _rte = _next) { \
                _next = (RTE*) _rte->Flink;

#define END_ROUTE_LIST_LOOP \
            } \
        }


NTSTATUS
IpInitRouteTable()

/*++

Routine Description:

    Initialize the routing table

Arguments:

    NONE

Return Value:

    Status code

--*/

{
    INVALIDATELASTRTE();
    InitializeListHead(&IpRouteList);
    return NETERR_OK;
}


RTE*
IpFindRTE(
    IPADDR dstaddr,
    IfInfo* ifp
    )

/*++

Routine Description:

    Find a route table entry for the specified destination address

Arguments:

    dstaddr - Specifies the destination address
    ifp - Optional parameter, when present it indicates the caller
        is only interested in routes thru that particular interface.

Return Value:

    Pointer to the route table entry for the destination
    NULL if no route is found

NOTE:

    This is a very simple implementation. We're assuming that our
    route table will be very small (most likely a handful of entries +
    a default gateway).

--*/

{
    RTE* rte;
    RTE* found;

    RUNS_AT_DISPATCH_LEVEL
    if (dstaddr == 0) return NULL;

    // Fast check
    if (dstaddr == IpLastRteAddr && (!ifp || !IpLastRte || ifp == IpLastRte->ifp))
        return IpLastRte;

    found = NULL;
    LOOP_THRU_ROUTE_LIST(rte)

        if ((dstaddr & rte->addrmask) == rte->dstaddr &&
            (!ifp || ifp == rte->ifp)) {
            // Found a matching entry:
            //  since the route list is sorted by mask length,
            //  we can stop searching right away
            found = rte;
            break;
        }

    END_ROUTE_LIST_LOOP

    // Update the last route lookup information
    IpLastRteAddr = dstaddr;
    return (IpLastRte = found);
}


NTSTATUS
IpAddRTE(
    IPADDR dstaddr,
    IPADDR addrmask,
    IPADDR nexthop,
    IfInfo* ifp,
    INT flags,
    INT metric
    )

/*++

Routine Description:

    Add an entry to the route table

Arguments:

    dstaddr, addrmask - Specifies the destination address and mask
    nexthop - Specifies the next hop gateway address
    ifp - Points to the output interface for the route
    flags - Route flags
    metric - Route metrics

Return Value:

    Status code

--*/

{
    RTE* newrte;
    RTE* rte;
    KIRQL irql;

    // Validate input parameters:
    //  - address mask must be of the form 111...000
    //      be careful about the byte order
    //  - next hop address cannot be a broadcast address

    if (!XnetIsValidSubnetMask(addrmask) ||
        nexthop == 0 ||
        IfBcastAddr(ifp, nexthop) && !(flags & RTEFLAG_BCAST)) {
        WARNING_("Bad route to %s:", IPADDRSTR(dstaddr));
        WARNING_("  mask = %s", IPADDRSTR(addrmask));
        WARNING_("  nexthop = %s", IPADDRSTR(nexthop));
        return NETERR_PARAM;
    }

    // Make sure loopback address never goes outside
    ASSERT(!IS_LOOPBACK_IPADDR(dstaddr) ||
           IfLoopback(ifp) &&
           addrmask == CLASSA_NETMASK &&
           nexthop == IPADDR_LOOPBACK);

    dstaddr &= addrmask;
    irql = RaiseToDpc();

    // Find out if the specified route is already in the table

    LOOP_THRU_ROUTE_LIST(rte)

        if (rte->dstaddr == dstaddr &&
            rte->addrmask == addrmask && 
            (addrmask != 0 || rte->nexthop == nexthop)) {
            // Update the existing route information
            newrte = rte;
            RemoveEntryList(&rte->links)
            goto insert_route;
        }

    END_ROUTE_LIST_LOOP

    // Add a new route table entry
    newrte = XnetAlloc0(sizeof(RTE), PTAG_RTE);
    if (!newrte) {
        LowerFromDpc(irql);
        return NETERR_MEMORY;
    }
    newrte->refcount = 1;

insert_route:

    newrte->flags = flags;
    newrte->metric = metric;
    newrte->dstaddr = dstaddr;
    newrte->addrmask = addrmask;
    newrte->nexthop = nexthop;
    CACHE_IFP_REFERENCE(newrte->ifp, ifp);
    INVALIDATELASTRTE();

    // Insert the new route into the table
    //  sorted by the mask length and route metric

    LOOP_THRU_ROUTE_LIST(rte)

        if (addrmask > rte->addrmask || 
            addrmask == rte->addrmask && metric < rte->metric) {
            break;
        }

    END_ROUTE_LIST_LOOP

    newrte->Flink = (LIST_ENTRY*) rte;
    newrte->Blink = rte->Blink;
    rte->Blink->Flink = (LIST_ENTRY*) newrte;
    rte->Blink = (LIST_ENTRY*) newrte;

    LowerFromDpc(irql);
    return NETERR_OK;
}


PRIVATE VOID
IpDeleteRouteEntry(
    RTE* rte
    )

/*++

Routine Description:

    Delete the specified route entry

Arguments:

    rte - Points to the route entry to be deleted

Return Value:

    NONE

--*/

{
    RUNS_AT_DISPATCH_LEVEL

    INVALIDATELASTRTE();

    RemoveEntryList(&rte->links)
    if (RteDecRef(rte) == 0) {
        // no more reference to this entry, we can delete it
        XnetFree(rte);
    } else {
        // there is still cached reference to this entry,
        // mark it as orphaned and it will be deleted
        // when the last reference goes away.
        rte->flags |= RTEFLAG_ORPHAN;
        rte->ifp = NULL;
    }
}


VOID
IpRemoveInterfaceRTE(
    IfInfo* ifp,
    BOOL deleteBcastRte
    )

/*++

Routine Description:

    Remove all routes going through the specified interface

Arguments:

    ifp - Points to the interface structure
        if NULL, then all routes are removed
    deleteBcastRte - Whether to delete the broadcast routes

Return Value:

    NONE

--*/

{
    RTE* rte;

    RUNS_AT_DISPATCH_LEVEL
    if (IsListNull(&IpRouteList)) return;

    // go through the entire route table and look for
    // entries whose interface matches the specified one

    LOOP_THRU_ROUTE_LIST(rte)

        if (ifp && rte->ifp != ifp) continue;
        if (!deleteBcastRte && IsRteBcast(rte)) continue;
        IpDeleteRouteEntry(rte);

    END_ROUTE_LIST_LOOP
}


VOID
IpRemoveRTE(
    IPADDR dstaddr,
    IPADDR addrmask,
    IPADDR nexthop
    )

/*++

Routine Description:

    Delete a route going to the specified destination
    and through the specified gateway

Arguments:

    dstaddr, addrmask - Specifies the route destination
    nexthop - Specifies the next hop gateway for the route

Return Value:

    NONE

--*/

{
    RTE* rte;
    KIRQL irql = RaiseToDpc();

    LOOP_THRU_ROUTE_LIST(rte)

        if (rte->dstaddr == dstaddr &&
            rte->addrmask == addrmask &&
            rte->nexthop == nexthop) {
            IpDeleteRouteEntry(rte);
            break;
        }

    END_ROUTE_LIST_LOOP

    LowerFromDpc(irql);
}


NTSTATUS
IpSetBroadcastInterface(
    IfInfo* ifp
    )

/*++

Routine Description:

    Designate an interface for transmitting
    outgoing broadcast datagrams

Arguments:

    ifp - Specifies the new broadcast interface

Return Value:

    Status code

--*/

{
    // Remove the route entry for the previous broadcast interface
    IpRemoveRTE(IPADDR_BCAST, 0xffffffff, IPADDR_BCAST);
    if (ifp == NULL) return NETERR_OK;

    // Create an entry for the new broadcast interface
    return IpAddRTE(IPADDR_BCAST,
                  0xffffffff,
                  IPADDR_BCAST,
                  ifp,
                  RTEFLAG_BCAST|RTEFLAG_LOCAL,
                  DEFAULT_RTE_METRIC);
}


NTSTATUS
IpSetMulticastInterface(
    IfInfo* ifp
    )

/*++

Routine Description:

    Designate an interface for transmitting
    outgoing broadcast datagrams

Arguments:

    ifp - Specifies the new broadcast interface

Return Value:

    Status code

--*/

{
    // Remove the route entry for the previous broadcast interface
    IpRemoveRTE(CLASSD_NETID, CLASSD_NETMASK, CLASSD_NETID);
    if (ifp == NULL) return NETERR_OK;

    // Create an entry for the new broadcast interface
    return IpAddRTE(CLASSD_NETID,
                  CLASSD_NETMASK,
                  CLASSD_NETID,
                  ifp,
                  RTEFLAG_MCAST|RTEFLAG_LOCAL,
                  DEFAULT_RTE_METRIC);
}


VOID
IpRedirectHostRoute(
    IfInfo* ifp,
    IPADDR dstaddr,
    IPADDR oldgwaddr,
    IPADDR newgwaddr
    )

/*++

Routine Description:

    Redirect the route to a destination host

Arguments:

    ifp - Specifies the interface that received the redirect message
    dstaddr - Destination host address
    oldgwaddr - Specifies the current gateway to the destination host
    newgwaddr - Specifies the new gateway address

Return Value:

    NONE

--*/

{
    RTE* rte;

    RUNS_AT_DISPATCH_LEVEL

    // The redirected destination must be a unicast address
    if (!XnetIsValidUnicastAddr(dstaddr)) return;

    // Validate the new gateway address:
    //  must be a unicast address on the same subnet
    //  through which the redirect message arrived
    if (!XnetIsValidUnicastAddr(newgwaddr) ||
        ifp->subnetAddr != (newgwaddr & ifp->addrmask))
        return;

    // Find the current route to the destination
    // and see if the sender of the redirect message
    // is the current next-hop gateway
    rte = IpFindRTE(dstaddr, NULL);
    if (!rte || rte->nexthop != oldgwaddr) return;

    // Add a new host route
    IpAddRTE(dstaddr,
           0xffffffff,
           newgwaddr,
           ifp,
           RTEFLAG_HOST,
           DEFAULT_RTE_METRIC);
}


#if DBG

VOID
IpDumpRouteTable()

/*++

Routine Description:

    Dump the content of the route table in the debugger

Arguments:

    NONE

Return Value:

    NONE

--*/

{
    KIRQL irql;
    RTE* rte;

    DbgPrint("\n*** Route table:\n");
    if (IsListNull(&IpRouteList)) return;

    irql = RaiseToDpc();
    LOOP_THRU_ROUTE_LIST(rte)

        DbgPrint("%s/", IPADDRSTR(rte->dstaddr));
        DbgPrint("%s/", IPADDRSTR(rte->addrmask));
        DbgPrint("%s ", IPADDRSTR(rte->nexthop));
        DbgPrint("%02x %d %d %s\n",
                 rte->flags,
                 rte->metric,
                 rte->refcount,
                 rte->ifp->ifname);

    END_ROUTE_LIST_LOOP
    LowerFromDpc(irql);
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\lib\netpool.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    netpool.c

Abstract:

    Private pool used by the network stack

Notes:

    The private pool is used by the network stack
    when processing asynchronously received packets.
    We don't want to allocate directly out of
    the system pool because that would introduce
    unpredictable memory usage patterns.

Revision History:

    08/03/2000 davidx
        Created it.

--*/

#include "precomp.h"

//
// Pool allocation block header: We intentionally let this have
// the same size as the system pool header. But we've restructured
// the fields in such a way that if you try to free a memory block
// that was allocated out of our private pool to the system pool,
// you'd get a bugcheck.
//

typedef struct _PoolEntry {
    WORD busy;
        // Whether the block is allocated or free

    WORD tag;
        // We're only using 2 bytes for pool tag,
        // since all of our pool tags have the form NET*.

    WORD blockSize;
    WORD previousSize;
        // Size of this block and the previous block in 32-bit units

    LIST_ENTRY links;
        // A free pool entry has two additional pointer fields
        // for maintaining a doubly-linked list of free blocks.
} PoolEntry;

#define POOL_BLOCK_SHIFT 5
#define POOL_BLOCK_SIZE (1 << POOL_BLOCK_SHIFT)
#define MAX_POOL_SIZE (POOL_BLOCK_SIZE * 0xffff)
#define POOL_HEADER_SIZE offsetof(PoolEntry, links)

#define MarkPoolEntryBusy(_entry) ((_entry)->busy = 0x100)
#define MarkPoolEntryFree(_entry) ((_entry)->busy = 0)
#define IsPoolEntryBusy(_entry) ((_entry)->busy == 0x100)
#define IsPoolEntryFree(_entry) ((_entry)->busy == 0)
#define TagPoolEntry(_entry, _tag) ((_entry)->tag = (WORD) ((_tag) >> 16))

#define GetPoolEntryHeader(_ptr) \
        ((PoolEntry*) ((BYTE*) (_ptr) - POOL_HEADER_SIZE))
#define GetPoolEntryNext(_entry) \
        ((PoolEntry*) ((BYTE*) (_entry) + ((UINT) (_entry)->blockSize << POOL_BLOCK_SHIFT)))
#define GetPoolEntryPrev(_entry) \
        ((PoolEntry*) ((BYTE*) (_entry) - ((UINT) (_entry)->previousSize << POOL_BLOCK_SHIFT)))

//
// Default number of pages used for our private pool (48KB)
//
UINT cfgXnetPoolSize = 48*1024;

//
// Beginning and ending address of the entire pool
//
#define MAX_SMALL_BLOCKS 5
typedef struct _XnetPoolData {
    PoolEntry* start;
    PoolEntry* end;
    LIST_ENTRY freeLists[MAX_SMALL_BLOCKS+1];
        // List of free pool blocks:
        //  we keep a separate list for each type of small blocks
        //  and the last list is for all large blocks
} XnetPoolData;
XnetPoolData _XnetPool;

#define IsPoolEntryValid(pool,_entry) ((_entry) >= (pool)->start && (_entry) < (pool)->end)

#define InsertFreePoolEntry(pool,_entry) { \
            LIST_ENTRY* _head; \
            _head = &(pool)->freeLists[ \
                        (_entry)->blockSize <= MAX_SMALL_BLOCKS ? \
                            (_entry)->blockSize - 1 : \
                            MAX_SMALL_BLOCKS]; \
            InsertHeadList(_head, &(_entry)->links); \
        }

// Set this variable to TRUE to force a breakpoint
// when xnet pool allocation fails.
#if DBG
BOOL XnetBreakWhenPoolEmpty;
#endif


PRIVATE VOID
_XnetPoolInit(
    XnetPoolData* pool,
    VOID* bufstart,
    UINT bufsize
    )

/*++

Routine Description:

    Initialize a private memory pool

Arguments:

    pool - Points to the pool data structure
    bufstart - Starting address of the memory pool buffer
    bufsize - Size of the memory buffer

Return Value:

    NONE

--*/

{
    PoolEntry* entry;
    UINT n;

    pool->start = (PoolEntry*) bufstart;
    pool->end = (PoolEntry*) ((BYTE*) bufstart + bufsize);

    // Initialize the free lists with a single big block

    for (n=0; n <= MAX_SMALL_BLOCKS; n++) {
        InitializeListHead(&pool->freeLists[n]);
    }

    // NOTE: we reserved the very first and the very last
    // pool blocks. This saves us from a couple of extra checks
    // during alloc and free.

    entry = pool->start;
    MarkPoolEntryBusy(entry);
    TagPoolEntry(entry, PTAG_POOL);
    entry->previousSize = 0;
    entry->blockSize = 1;

    entry = GetPoolEntryNext(entry);
    n = (bufsize >> POOL_BLOCK_SHIFT) - 2;
    MarkPoolEntryFree(entry);
    TagPoolEntry(entry, PTAG_POOL);
    entry->previousSize = 1;
    entry->blockSize = (WORD) n;
    InsertFreePoolEntry(pool, entry);

    entry = GetPoolEntryNext(entry);
    MarkPoolEntryBusy(entry);
    TagPoolEntry(entry, PTAG_POOL);
    entry->previousSize = (WORD) n;
    entry->blockSize = 1;
}


#if DBG

PRIVATE VOID
_XnetPoolDump(
    XnetPoolData* pool
    )

/*++

Routine Description:

    Dump out the content of a private pool

Arguments:

    NONE

Return Value:

    NONE

--*/

{
    PoolEntry* entry;
    PoolEntry* prev;
    UINT total = 0;

    DbgPrint("XNET pool %x: %x - %x\n", pool, pool->start, pool->end);

    prev = NULL;
    entry = pool->start;

    while (entry < pool->end) {
        BOOL isbusy = IsPoolEntryBusy(entry);
        if (isbusy) total += entry->blockSize;

        DbgPrint("%c%c%c %08x l%x\n",
            isbusy ? '*' : ' ',
            entry->tag,
            entry->tag >> 8,
            entry,
            entry->blockSize << POOL_BLOCK_SHIFT);

        if (prev) {
            ASSERT(prev->blockSize == entry->previousSize);
            prev = entry;
        }
        entry = GetPoolEntryNext(entry);
    }

    DbgPrint(" Total allocation: %d / %d\n",
        total << POOL_BLOCK_SHIFT,
        (BYTE*) pool->end - (BYTE*) pool->start);
}

#endif // DBG

PRIVATE VOID*
_XnetAlloc(
    XnetPoolData* pool,
    SIZE_T size,
    ULONG tag
    )

/*++

Routine Description:

    Allocate memory from a private pool

Arguments:

    pool - Points to the pool data structure
    size - Specifies the number of bytes needed
    tag - Specifies the memory tag for the caller

Return Value:

    Pointer to the allocated memory buffer
    NULL if we're out of memory

--*/

{
    PoolEntry* entry;
    KIRQL irql;

    ASSERT(size > 0 && size <= MAX_POOL_SIZE - POOL_HEADER_SIZE);
    size = (size + (POOL_HEADER_SIZE + POOL_BLOCK_SIZE - 1)) >> POOL_BLOCK_SHIFT;

    irql = RaiseToDpc();

    // Find a free pool block that's large enough for us.
    // Handle small block allocation with the quick lookup.
    if (size <= MAX_SMALL_BLOCKS) {
        UINT index;

        for (index=size-1; index <= MAX_SMALL_BLOCKS; index++) {
            if (!IsListEmpty(&pool->freeLists[index])) {
                entry = GetPoolEntryHeader(pool->freeLists[index].Flink);
                goto found;
            }
        }
    } else {
        LIST_ENTRY* head;
        LIST_ENTRY* list;

        head = &pool->freeLists[MAX_SMALL_BLOCKS];
        list = head->Flink;
        while (list != head) {
            entry = GetPoolEntryHeader(list);
            if ((WORD) size <= entry->blockSize) goto found;
            list = list->Flink;
        }
    }

    #if DBG

    WARNING_("Xnet%s pool allocation failed: pool %x, %d blocks",
        XnetInsideDbgmon() ? " (XBDM)" : "", pool, size);
    WARNING_("Make sure you're promptly calling recv() to receive incoming data.\n");
    WARNING_("You may also want to consider setting a larger Xnet pool size.\n");

    if (XnetBreakWhenPoolEmpty || XnetInsideDbgmon()) {
        _XnetPoolDump(pool);
        __asm int 3
    }

    #endif

    LowerFromDpc(irql);
    return NULL;

found:
    // Take it out of the free list
    RemoveEntryList(&entry->links);

    // If we didn't use up the entire free block,
    // put the remaining portion back on the free list.
    if (entry->blockSize > size) {
        UINT leftover = entry->blockSize - size;
        PoolEntry* next;

        entry->blockSize = (WORD) size;
        next = GetPoolEntryNext(entry);
        next->blockSize = (WORD) leftover;
        next->previousSize = (WORD) size;
        next->tag = entry->tag;
        MarkPoolEntryFree(next);
        InsertFreePoolEntry(pool, next);

        next = GetPoolEntryNext(next);
        ASSERT(IsPoolEntryValid(pool, next));
        next->previousSize = (WORD) leftover;
    }

    MarkPoolEntryBusy(entry);
    TagPoolEntry(entry, tag);
    LowerFromDpc(irql);

    return (BYTE*) entry + POOL_HEADER_SIZE;
}


PRIVATE VOID
_XnetFree(
    XnetPoolData* pool,
    VOID* ptr
    )

/*++

Routine Description:

    Free the memory buffer to a private pool

Arguments:

    pool - Points to the pool data structure
    ptr - Points to the memory buffer to be freed

Return Value:

    NONE

--*/

{
    PoolEntry* entry;
    PoolEntry* prev;
    PoolEntry* next;
    WORD blockSize;
    KIRQL irql;

    if (!ptr) return;
    entry = GetPoolEntryHeader(ptr);
    ASSERT(IsPoolEntryValid(pool, entry) && IsPoolEntryBusy(entry));

    irql = RaiseToDpc();
    MarkPoolEntryFree(entry);
    blockSize = entry->blockSize;

    //
    // Check to see if the block before this one is free
    // If so, collapse the two free blocks together
    //
    prev = GetPoolEntryPrev(entry);
    ASSERT(IsPoolEntryValid(pool, prev));
    if (IsPoolEntryFree(prev)) {
        RemoveEntryList(&prev->links);
        prev->blockSize = (WORD) (prev->blockSize + blockSize);
        entry = prev;
    }

    //
    // Check if the block after this one is free
    // If so, collapse the two free blocks together
    //
    next = GetPoolEntryNext(entry);
    ASSERT(IsPoolEntryValid(pool, next) && next->previousSize == blockSize);
    if (IsPoolEntryFree(next)) {
        RemoveEntryList(&next->links);
        entry->blockSize = (WORD) (entry->blockSize + next->blockSize);
    }

    //
    // If we performed any collapsing, 
    // update the previousSize field of the next block.
    //
    if (entry->blockSize != blockSize) {
        next = GetPoolEntryNext(entry);
        ASSERT(IsPoolEntryValid(pool, next));
        next->previousSize = entry->blockSize;
    }

    InsertFreePoolEntry(pool, entry);
    LowerFromDpc(irql);
}


//
// Public functions
//

NTSTATUS XnetPoolInit()
{
    VOID* p;

    // Preallocate all the memory we need
    if (cfgXnetPoolSize > MAX_POOL_SIZE)
        cfgXnetPoolSize = MAX_POOL_SIZE;

    p = SysAlloc(cfgXnetPoolSize, PTAG_POOL);
    if (!p) return NETERR_MEMORY;
    _XnetPoolInit(&_XnetPool, p, cfgXnetPoolSize);
    return NETERR_OK;
}

VOID XnetPoolCleanup()
{
    if (_XnetPool.start) {
        SysFree(_XnetPool.start);
        _XnetPool.start = _XnetPool.end = NULL;
    }
}

VOID* XnetAlloc(SIZE_T size, ULONG tag)
{
    return _XnetAlloc(&_XnetPool, size, tag);
}

VOID XnetFree(VOID* p) {
    _XnetFree(&_XnetPool, p);
}


//
// BUGBUG: temporary workaround for nv2a snooping bug
//
#ifdef DVTSNOOPBUG

#define XNET_UNCACHED_POOL_SIZE (256*1024)
XnetPoolData XnetUncachedPool;

PRIVATE VOID* XnetUncachedAlloc(SIZE_T size, ULONG tag)
{
    return _XnetAlloc(&XnetUncachedPool, size, tag);
}

PRIVATE VOID XnetUncachedFree(VOID* p)
{
    _XnetFree(&XnetUncachedPool, p);
}

NTSTATUS XnetUncachedPoolInit()
{
    VOID* p;
    
    p = XnetInsideDbgmon() ?
        MmDbgAllocateMemory(XNET_UNCACHED_POOL_SIZE, PAGE_READWRITE|PAGE_NOCACHE) :
        MmAllocateContiguousMemoryEx(
                XNET_UNCACHED_POOL_SIZE,
                0,
                MAXULONG_PTR,
                0,
                PAGE_READWRITE|PAGE_NOCACHE);
    if (!p) return NETERR_MEMORY;

    __asm wbinvd;
    XnetUncachedAllocProc = XnetUncachedAlloc;
    XnetUncachedFreeProc = XnetUncachedFree;
    
    _XnetPoolInit(&XnetUncachedPool, p, XNET_UNCACHED_POOL_SIZE);
    return NETERR_OK;
}

VOID XnetUncachedPoolCleanup()
{
    if (XnetUncachedPool.start) {
        if (XnetInsideDbgmon()) {
            MmDbgFreeMemory(XnetUncachedPool.start, 0);
        } else {
            MmFreeContiguousMemory(XnetUncachedPool.start);
        }
        XnetUncachedPool.start = XnetUncachedPool.end = NULL;
        XnetUncachedAllocProc = NULL;
        XnetUncachedFreeProc = NULL;
    }
}

#endif // DVTSNOOPBUG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\lib\i386\tcpipxsum.asm ===
title  "Compute TCP/IP Checksum"

;/*++
;
; Copyright (c) 1992  Microsoft Corporation
;
; Module Name:
;
;    tcpipxsum.asm
;
; Abstract:
;
;    This module implements a function to compute the checksum of a buffer.
;
; Author:
;
;    David N. Cutler (davec) 27-Jan-1992
;
; Revision History:
;
;     Who         When        What
;     --------    --------    ----------------------------------------------
;     mikeab      01-22-94    Pentium optimization
;
;--*/



LOOP_UNROLLING_BITS equ     4
LOOP_UNROLLING      equ     (1 SHL LOOP_UNROLLING_BITS)

        .386
        .model  small,c

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include callconv.inc
        include ks386.inc
        .list

XNET    SEGMENT DWORD PUBLIC 'CODE'

;++
;
; ULONG
; tcpipxsum(
;   IN ULONG xsum,
;   IN const VOID* buf,
;   IN UINT len
;   )
;
; Routine Description:
;
;    This function computes the checksum of the specified buffer.
;    It uses Processor's prefetch instruction.
;
; Arguments:
;
;    xsum - Suppiles the initial checksum value, in 16-bit form,
;           with the high word set to 0.
;
;    buf - Supplies a pointer to the buffer to the checksum buffer.
;
;    len - Supplies the length of the buffer in bytes.
;
; Return Value:
;
;    The computed checksum in 32-bit two-partial-accumulators form, added to
;    the initial checksum, is returned as the function value.
;
;--

xsum    equ     12                      ; stack offset to initial checksum
buf     equ     16                      ; stack offset to source address
len     equ     20                      ; stack offset to length in words

to_checksum_last_word:
        jmp     checksum_last_word

to_checksum_done:
        jmp     checksum_done

to_checksum_dword_loop_done:
        jmp     checksum_dword_loop_done

cPublicProc tcpipxsum,3

        push    ebx                     ; save nonvolatile register
        push    esi                     ; save nonvolatile register

        mov     ecx,[esp + len]         ; get length in bytes
        sub     eax,eax                 ; clear computed checksum
        test    ecx,ecx                 ; any bytes to checksum at all?
        jz      short to_checksum_done  ; no bytes to checksum

;
; if the checksum buffer is not word aligned, then add the first byte of
; the buffer to the input checksum.
;

        mov     esi,[esp + buf]         ; get source address
        sub     edx,edx                 ; set up to load word into EDX below
        test    esi,1                   ; check if buffer word aligned
        jz      short checksum_word_aligned ; if zf, buffer word aligned
        mov     ah,[esi]                ; get first byte (we know we'll have
                                        ;  to swap at the end)
        inc     esi                     ; increment buffer address
        dec     ecx                     ; decrement number of bytes
        jz      short to_checksum_done  ; if zf set, no more bytes

;
; If the buffer is not an even number of of bytes, then initialize
; the computed checksum with the last byte of the buffer.
;

checksum_word_aligned:                  ;
        shr     ecx,1                   ; convert to word count
        jnc     short checksum_start    ; if nc, even number of bytes
        mov     al,[esi+ecx*2]          ; initialize the computed checksum
        jz      short to_checksum_done  ; if zf set, no more bytes

;
; Compute checksum in large blocks of dwords, with one partial word up front if
; necessary to get dword alignment, and another partial word at the end if
; needed.
;

;
; Compute checksum on the leading word, if that's necessary to get dword
; alignment.
;

checksum_start:                         ;
        test    esi,02h                 ; check if source dword aligned
        jz      short checksum_dword_aligned ; source is already dword aligned
        mov     dx,[esi]                ; get first word to checksum
        add     esi,2                   ; update source address
        add     eax,edx                 ; update partial checksum
                                        ;  (no carry is possible, because EAX
                                        ;  and EDX are both 16-bit values)
        dec     ecx                     ; count off this word (zero case gets
                                        ;  picked up below)

;
; Checksum as many words as possible by processing a dword at a time.
;

checksum_dword_aligned:
        push    ecx                     ; so we can tell if there's a trailing
                                        ;  word later
        shr     ecx,1                   ; # of dwords to checksum
        jz      short to_checksum_last_word ; no dwords to checksum

        mov     edx,[esi]               ; preload the first dword
        add     esi,4                   ; point to the next dword
        dec     ecx                     ; count off the dword we just loaded
        jz      short to_checksum_dword_loop_done
                                        ; skip the loop if that was the only dword
        mov     ebx,ecx                 ; EBX = # of dwords left to checksum
        add     ecx,LOOP_UNROLLING-1    ; round up loop count
        shr     ecx,LOOP_UNROLLING_BITS ; convert from word count to unrolled loop count
        and     ebx,LOOP_UNROLLING-1    ; # of partial dwords to do in first loop
        jz      short checksum_dword_loop ; special-case when no partial loop,
                                          ;  because fixup below doesn't work
                                          ;  in that case (carry flag is
                                          ;  cleared at this point, as required
                                          ;  at loop entry)
        lea     esi,[esi+ebx*4-(LOOP_UNROLLING*4)]
                                        ; adjust buffer pointer back to
                                        ;  compensate for hardwired displacement
                                        ;  at loop entry point
                                        ; ***doesn't change carry flag***
        jmp     loop_entry[ebx*4]       ; enter the loop to do the first,
                                        ; partial iteration, after which we can
                                        ; just do 32-word blocks
                                        ; ***doesn't change carry flag***

checksum_dword_loop:
        ; prefetch the 32-byte cache line from [esi+0]
        db 0fH
        db 18H
        db 46H
        db 00H

        ; prefetch the 32-byte cache line from [esi+20h]
        db 0fH
        db 18H
        db 46H
        db 20H

DEFLAB  macro   pre,suf
pre&suf:
        endm

TEMP=0
        REPT    LOOP_UNROLLING
        deflab  loop_entry_,%TEMP
        adc     eax,edx
        mov     edx,[esi + TEMP]
TEMP=TEMP+4
        ENDM

checksum_dword_loop_end:

        lea     esi,[esi + LOOP_UNROLLING * 4]  ; update source address
                                        ; ***doesn't change carry flag***
        dec     ecx                     ; count off unrolled loop iteration
                                        ; ***doesn't change carry flag***
        jnz     checksum_dword_loop     ; do more blocks

checksum_dword_loop_done label proc
        adc     eax,edx                 ; finish dword checksum
        mov     edx,0                   ; prepare to load trailing word
        adc     eax,edx

;
; Compute checksum on the trailing word, if there is one.
; High word of EDX = 0 at this point
; Carry flag set iff there's a trailing word to do at this point
;

checksum_last_word label proc           ; "proc" so not scoped to function
        pop     ecx                     ; get back word count
        test    ecx,1                   ; is there a trailing word?
        jz      short checksum_done     ; no trailing word
        add     ax,[esi]                ; add in the trailing word
        adc     eax,0                   ;

checksum_done label proc                ; "proc" so not scoped to function
        mov     ecx,eax                 ; fold the checksum to 16 bits
        ror     ecx,16
        add     eax,ecx
        mov     ebx,[esp + buf]
        shr     eax,16
        test    ebx,1                   ; check if buffer word aligned
        jz      short checksum_combine  ; if zf set, buffer word aligned
        ror     ax,8                    ; byte aligned--swap bytes back
checksum_combine label proc             ; "proc" so not scoped to function
        add     ax, word ptr [esp + xsum] ; combine checksums
        pop     esi                     ; restore nonvolatile register
        adc     eax,0                   ;
        pop     ebx                     ; restore nonvolatile register
        stdRET  tcpipxsum


REFLAB  macro   pre,suf
        dd      pre&suf
        endm

        align   4
loop_entry      label   dword
        dd      0
TEMP=LOOP_UNROLLING*4
        REPT    LOOP_UNROLLING-1
TEMP=TEMP-4
        reflab  loop_entry_,%TEMP
        ENDM

stdENDP tcpipxsum

        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\modem\ioctl.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

    ioctl.cpp

Abstract:
    
    Serial IO control for the modem.
    
Revision History:

    06-21-00    vadimg      created

--*/

#include "precomp.h"

#define CR_READ   0x00000001
#define CR_WRITE  0x00000002

/***************************************************************************\
* CompleteClassRequest
*
\***************************************************************************/

VOID CompleteClassRequest(PURB purb, PKEVENT pevent)
{
    ASSERT_DISPATCH_LEVEL();

    KeSetEvent(pevent, IO_NO_INCREMENT, FALSE);
}

/***************************************************************************\
* ClassRequest
*
\***************************************************************************/

BOOL ClassRequest(UCHAR uRequest, USHORT wValue, PVOID buffer,
        USHORT cb, ULONG flags)
{
    KEVENT event;
    PURB purb;
    UCHAR bmRequestType;
    UCHAR bTransferDirection;
    PMDL pMdl;

    ASSERT_DISPATCH_LEVEL();

    if (gfUrbInUse) {
        return FALSE;
    }
    purb = &gUrb;

    if (buffer != NULL) {
        MmInitializeMdl(gpMdl, buffer, cb);
        pMdl = gpMdl;
    } else {
        pMdl = NULL;
    }

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    bmRequestType = USB_CLASS_COMMAND | USB_COMMAND_TO_INTERFACE;
    if (flags & CR_READ) {
        bmRequestType |= USB_DEVICE_TO_HOST;
        bTransferDirection = USB_TRANSFER_DIRECTION_IN;
    } else {
        bmRequestType |= USB_HOST_TO_DEVICE;
        bTransferDirection = USB_TRANSFER_DIRECTION_OUT;
    }
    USB_BUILD_CONTROL_TRANSFER(
            (PURB_CONTROL_TRANSFER)purb,
            NULL,
            pMdl,
            cb,
            bTransferDirection,
            (PURB_COMPLETE_PROC)CompleteClassRequest,
            (PVOID)&event,
            TRUE,
            bmRequestType,
            uRequest,
            wValue,
            gDevice.bCommInterface,
            cb);

    gDevice.pDevice->SubmitRequest(purb);

    Wait(&event);

    if (USBD_SUCCESS(purb->Header.Status)) {
        return TRUE;
    } else {
        return FALSE;
    }
}

/***************************************************************************\
* GetLineCoding
*
\***************************************************************************/

BOOL GetLineCoding(PULONG pBaudRate, PUCHAR pStopBits, PUCHAR pParity,
        PUCHAR pDataBits)
{
    ASSERT_DISPATCH_LEVEL();

    if (ClassRequest(USB_COMM_GET_LINE_CODING, 0, &gMem.LineCoding,
            sizeof(USB_COMM_LINE_CODING), CR_READ)) {

        *pBaudRate = gMem.LineCoding.DTERate;
        *pStopBits = gMem.LineCoding.CharFormat;
        *pParity = gMem.LineCoding.ParityType;
        *pDataBits = gMem.LineCoding.DataBits;

        return TRUE;
    } else {
        return FALSE;
    }
}

/***************************************************************************\
* SetLineCoding
*
\***************************************************************************/

BOOL SetLineCoding(ULONG BaudRate, UCHAR StopBits, UCHAR Parity,
        UCHAR DataBits)
{
    ASSERT_DISPATCH_LEVEL();

    gMem.LineCoding.DTERate = BaudRate;
    gMem.LineCoding.CharFormat = StopBits;
    gMem.LineCoding.ParityType = Parity;
    gMem.LineCoding.DataBits = DataBits;

    return ClassRequest(USB_COMM_SET_LINE_CODING, 0, &gMem.LineCoding,
            sizeof(USB_COMM_LINE_CODING), CR_WRITE);
}

/***************************************************************************\
* GetDtrRts
*
\***************************************************************************/

BOOL GetDtrRts(USHORT *pwState)
{
    ASSERT_DISPATCH_LEVEL();

    *pwState = gDevice.wDTR_RTS;
    return TRUE;
}

/***************************************************************************\
* SetDtrRts
*
\***************************************************************************/

BOOL SetDtrRts(USHORT wState)
{
    ASSERT_DISPATCH_LEVEL();

    gDevice.wDTR_RTS = wState;

    return ClassRequest(USB_COMM_SET_CONTROL_LINE_STATE, wState, NULL, 0,
            CR_WRITE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\modem\modem.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

    modem.cpp

Abstract:
    
    Driver entry points for the XBox USB modem driver.
    
Revision History:

    06-21-00    vadimg      created

--*/

#include "precomp.h"

/***************************************************************************\
* Modem_IsConnected
*
\***************************************************************************/

BOOL Modem_IsConnected(VOID)
{
    ASSERT_DISPATCH_LEVEL();

    return (gDevice.pDevice != NULL);
}

/***************************************************************************\
* Modem_Create
*
\***************************************************************************/

BOOL Modem_Create(VOID)
{
    ASSERT_DISPATCH_LEVEL();

    if (!OpenEndpoints()) {
        CloseEndpoints();
        return FALSE;
    }

    ReadWorker();

    return TRUE;
}

/***************************************************************************\
* Modem_Close
*
\***************************************************************************/

BOOL Modem_Close(VOID)
{
    ASSERT_DISPATCH_LEVEL();

    if (gRead.pevent != NULL) {
        ObDereferenceObject(gRead.pevent);
        gRead.pevent = NULL;
    }

    CloseEndpoints();
    return TRUE;
}

/***************************************************************************\
* Modem_AddDevice
*
\***************************************************************************/

VOID Modem_AddDevice(IUsbDevice *pDevice, PVOID)
{
    ASSERT_DISPATCH_LEVEL();

    if (gDevice.pDevice == NULL) {
        ConfigureDevice(pDevice);
    } else {
        pDevice->AddComplete(USBD_STATUS_UNSUPPORTED_DEVICE, NULL);
    }
}

/***************************************************************************\
* CloseDefaultEndpoint
*
\***************************************************************************/

VOID CloseDefaultEndpoint(PURB purb, IUsbDevice *pDevice)
{
    ASSERT_DISPATCH_LEVEL();

    Modem_Close();
}

/***************************************************************************\
* Modem_RemoveDevice
*
\***************************************************************************/

VOID Modem_RemoveDevice(IUsbDevice *pDevice)
{
    PURB purb;

    ASSERT_DISPATCH_LEVEL();

    gfRemoved = TRUE;

    purb = &gUrb;

    USB_BUILD_CLOSE_DEFAULT_ENDPOINT(
            (PURB_CLOSE_ENDPOINT)purb,
            (PURB_COMPLETE_PROC)CloseDefaultEndpoint,
            (PVOID)pDevice);

    pDevice->SubmitRequest(purb);
}

/***************************************************************************\
* DriverEntry
*
\***************************************************************************/

extern "C" NTSTATUS DriverEntry(IN PDRIVER_OBJECT, IN PUNICODE_STRING)
{
    gpMdl = IoAllocateMdl(&gMem, sizeof(gMem), FALSE, FALSE, NULL);
    if (gpMdl == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    gpMdlRead = IoAllocateMdl(&gRead.buffer, MODEM_BUFFER_SIZE, FALSE, FALSE, NULL);
    if (gpMdlRead == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    gDeviceDescription.ConnectorType = USBPNP_CONNECTOR_TYPE_DIRECT;
    gDeviceDescription.ControlEndpointCount = 1;
    gDeviceDescription.BulkEndpointCount = 2;
    gDeviceDescription.InterruptEndpointCount = 1;
    gDeviceDescription.IsochEndpointCount = 0;
    gDeviceDescription.MaxBulkTDperTransfer = 2;
    gDeviceDescription.MaxControlTDperTransfer = 30;
    gDeviceDescription.NumNodes = 1;
    gClassDescription.AddDevice = (PFNADD_USB_DEVICE)Modem_AddDevice;
    gClassDescription.RemoveDevice = (PFNREMOVE_USB_DEVICE)Modem_RemoveDevice;
    gClassDescription.ClassId.AsLong = USB_DEVICE_TYPE_MODEM;
    gClassDescription.DeviceTypeCount = 1;
    gClassDescription.DeviceTypes = &gDeviceDescription;
    
    USBPNP_RegisterClassDriver(1, &gClassDescription);
    
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\modem\precomp.h ===
extern "C" {
#include <ntos.h>
#include <windef.h>
#include <ntddser.h>

#include <usb.h>
#include <usbntfy.h>
#include <debug.h>
#include <xmodem.h>

#include "usbcomm.h"
}

#include "modem.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\modem\modem.h ===
#ifndef __MODEM_H__
#define __MODEM_H__

// defines
#define CONFIG_DESC_SIZE 80

#define MODEM_ENTER_CRIT() \
    gIrql = KeRaiseIrqlToDpcLevel();

#define MODEM_LEAVE_CRIT() \
    KeLowerIrql(gIrql);
    
// data classes
typedef struct _COMM_DEVICE_INFO {

    IUsbDevice *pDevice;

    UCHAR bCommInterface;

    UCHAR bBulkInEndpointAddress;
    USHORT wBulkInMaxPacket;
    PVOID pBulkInEndpointHandle;

    UCHAR bBulkOutEndpointAddress;
    USHORT wBulkOutMaxPacket;
    PVOID pBulkOutEndpointHandle;

    UCHAR bIntInEndpointAddress;
    USHORT wIntInMaxPacket;
    PVOID pIntInEndpointHandle;

    USHORT wDTR_RTS;

} COMM_DEVICE_INFO;

typedef union _URB_MEMORY {

    UCHAR ConfigDesc[CONFIG_DESC_SIZE];
    USB_DEVICE_DESCRIPTOR DevDesc;
    PUSB_INTERFACE_DESCRIPTOR InterDesc;
    USB_COMM_LINE_CODING LineCoding;

} URB_MEMORY;

typedef struct _READ_BUFFER {

    UCHAR buffer[MODEM_BUFFER_SIZE];
    ULONG iCurrent;
    ULONG cb;
    PKEVENT pevent;
    ULONG fReadPending : 1;

} READ_BUFFER;

// globals
extern USB_PNP_CLASS_DRIVER_DESCRIPTION gClassDescription;
extern USB_PNP_DEVICE_TYPE_DESCRIPTION  gDeviceDescription;

extern PMDL gpMdl;
extern URB gUrb;
extern BOOL gfUrbInUse;
extern BOOL gfRemoved;
extern KIRQL gIrql;

extern PMDL gpMdlRead;
extern URB gUrbRead;

extern URB_MEMORY gMem;

extern COMM_DEVICE_INFO gDevice;
extern READ_BUFFER gRead;

// function declarations
BOOL Modem_IsConnected(VOID);
BOOL Modem_Create(VOID);
BOOL Modem_Close(VOID);

VOID Wait(PKEVENT pevent);

VOID CloseEndpoints(VOID);
BOOL OpenEndpoints(VOID);
VOID ConfigureDevice(IUsbDevice *pDevice);

VOID ReadWorker(VOID);
BOOL ReadData(PUCHAR buffer, ULONG *pcb);
BOOL WriteData(PUCHAR buffer, ULONG *pcb);

BOOL GetLineCoding(PULONG pBaudRate, PUCHAR pStopBits, PUCHAR pParity,
        PUCHAR pDataBits);
BOOL SetLineCoding(ULONG BaudRate, UCHAR StopBits, UCHAR Parity,
        UCHAR DataBits);
BOOL GetDtrRts(USHORT *pwState);
BOOL SetDtrRts(USHORT wState);

#endif // __MODEM_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\modem\stubs.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

    stubs.cpp

Abstract:
    
    APIs for interfacing with the modem.
    
Revision History:

    06-21-00    vadimg      created

--*/

#include "precomp.h"

#define STUB_BEGIN() \
    BOOL fRet = FALSE;

#define STUB_END() \
    return fRet;
    
#define STUB_ENTER() \
    STUB_BEGIN(); \
    MODEM_ENTER_CRIT();

#define STUB_LEAVE() \
    MODEM_LEAVE_CRIT(); \
    STUB_END();

/***************************************************************************\
* Wait
*
* Helper function to wait on an event while out of the critical section.
\***************************************************************************/

VOID Wait(PKEVENT pevent)
{
    gfUrbInUse = TRUE;

    MODEM_LEAVE_CRIT();

    KeWaitForSingleObject(pevent, Suspended, KernelMode, FALSE, NULL);

    MODEM_ENTER_CRIT();

    gfUrbInUse = FALSE;
}


/***************************************************************************\
* ModemIsConnected
*
\***************************************************************************/

BOOL ModemIsConnected(VOID)
{
    STUB_ENTER();

    fRet = Modem_IsConnected();

    STUB_LEAVE();
}

/***************************************************************************\
* ModemOpen
*
\***************************************************************************/

BOOL ModemOpen(HANDLE hEvent)
{
    NTSTATUS status;
    PKEVENT pevent;

    if (hEvent != NULL) {
        status = ObReferenceObjectByHandle(hEvent, *ExEventObjectType,
            (PVOID*)&pevent);
    } else {
        pevent = NULL;
        status = STATUS_SUCCESS;
    }

    STUB_ENTER();

    if (Modem_IsConnected() && (gRead.pevent == NULL) && NT_SUCCESS(status)) {
        if (Modem_Create()) {
            gRead.pevent = pevent;
            fRet = TRUE;
        }
    }

    MODEM_LEAVE_CRIT();

    if (!fRet && pevent != NULL) {
        ObDereferenceObject(pevent);
    }

    STUB_END();
}

/***************************************************************************\
* ModemClose
*
\***************************************************************************/

BOOL ModemClose(VOID)
{
    STUB_ENTER();

    if (Modem_IsConnected()) {
        fRet = Modem_Close();
    }

    STUB_LEAVE();
}

/***************************************************************************\
* ModemWrite
*
\***************************************************************************/

BOOL ModemWrite(PUCHAR buffer, ULONG *pcb)
{
    STUB_ENTER();

    if (Modem_IsConnected()) {
        if (*pcb > MODEM_BUFFER_SIZE) {
            *pcb = MODEM_BUFFER_SIZE;
        }
        fRet = WriteData(buffer, pcb);
    }

    STUB_LEAVE();
}

/***************************************************************************\
* ModemRead
*
\***************************************************************************/

BOOL ModemRead(PUCHAR buffer, ULONG *pcb)
{
    STUB_ENTER();

    if (Modem_IsConnected()) {
        if (*pcb > MODEM_BUFFER_SIZE) {
            *pcb = MODEM_BUFFER_SIZE;
        }
        fRet = ReadData(buffer, pcb);
    }

    STUB_LEAVE();
}

/***************************************************************************\
* ModemPurge
*
\***************************************************************************/

BOOL ModemPurge(DWORD dwFlags)
{
    STUB_ENTER();

    fRet = Modem_IsConnected();

    STUB_LEAVE();
}

/***************************************************************************\
* ModemGetLineCoding
*
\***************************************************************************/

BOOL ModemGetLineCoding(PULONG pBaudRate, PUCHAR pStopBits, PUCHAR pParity,
        PUCHAR pDataBits)
{
    STUB_ENTER();

    fRet = GetLineCoding(pBaudRate, pStopBits, pParity, pDataBits);

    STUB_LEAVE();
}

/***************************************************************************\
* ModemSetLineCoding
*
\***************************************************************************/

BOOL ModemSetLineCoding(ULONG BaudRate, UCHAR StopBits, UCHAR Parity,
        UCHAR DataBits)
{
    STUB_ENTER();

    fRet = SetLineCoding(BaudRate, StopBits, Parity, DataBits);

    STUB_LEAVE();
}

/***************************************************************************\
* ModemGetDtrRts
*
\***************************************************************************/

BOOL ModemGetDtrRts(USHORT *pwState)
{
    STUB_ENTER();

    fRet = GetDtrRts(pwState);

    STUB_LEAVE();
}

/***************************************************************************\
* ModemSetDtrRts
*
\***************************************************************************/

BOOL ModemSetDtrRts(USHORT wState)
{
    STUB_ENTER();

    fRet = SetDtrRts(wState);

    STUB_LEAVE();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\modem\transfer.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

    transfer.cpp

Abstract:
    
    Handle transfer of data to and from the modem.
    
Revision History:

    06-21-00    vadimg      created

--*/

#include "precomp.h"

/***************************************************************************\
* CompleteRead
*
\***************************************************************************/

VOID CompleteRead(PURB purb, PVOID)
{
    ASSERT_DISPATCH_LEVEL();

    gRead.fReadPending = FALSE;
    gRead.iCurrent = 0;

    if (USBD_SUCCESS(purb->Header.Status)) {
        gRead.cb = purb->BulkOrInterruptTransfer.TransferBufferLength;

        if (gRead.pevent != NULL) {
            KeSetEvent(gRead.pevent, IO_NO_INCREMENT, FALSE);
        }
    } else {
        gRead.cb = 0;
    }
}

/***************************************************************************\
* ReadWorker
*
\***************************************************************************/

VOID ReadWorker(VOID)
{
    PURB purb;

    ASSERT_DISPATCH_LEVEL();

    if (gRead.fReadPending) {
        return;
    }

    purb = &gUrbRead;

    USB_BUILD_BULK_OR_INTERRUPT_TRANSFER(
            (PURB_BULK_OR_INTERRUPT_TRANSFER)purb,
            gDevice.pBulkInEndpointHandle,
            gpMdlRead,
            MODEM_BUFFER_SIZE,
            USB_TRANSFER_DIRECTION_IN,
            (PURB_COMPLETE_PROC)CompleteRead,
            NULL,
            TRUE);

    if (USBD_SUCCESS(gDevice.pDevice->SubmitRequest(purb))) {
        gRead.fReadPending = TRUE;
    }
}

/***************************************************************************\
* ReadData
*
\***************************************************************************/

BOOL ReadData(PUCHAR buffer, ULONG *pcb)
{
    ULONG cbCopy;

    ASSERT_DISPATCH_LEVEL();

    if (gRead.cb != 0) {
        cbCopy = min(gRead.cb, *pcb);

        RtlCopyMemory(buffer, &gRead.buffer[gRead.iCurrent], cbCopy);

        gRead.iCurrent += cbCopy;
        gRead.cb -= cbCopy;
        *pcb = cbCopy;
    } else {
        *pcb = 0;
    }

    if (gRead.cb == 0) {
        ReadWorker();
    }

    return TRUE;
}

/***************************************************************************\
* CompleteWrite
*
\***************************************************************************/

VOID CompleteWrite(PURB purb, PKEVENT pevent)
{
    ASSERT_DISPATCH_LEVEL();

    KeSetEvent(pevent, IO_NO_INCREMENT, FALSE);
}

/***************************************************************************\
* WriteData
*
\***************************************************************************/

BOOL WriteData(PUCHAR buffer, ULONG *pcb)
{
    KEVENT event;    
    PURB purb;
    BOOL fRet;

    ASSERT_DISPATCH_LEVEL();

    if (gfUrbInUse) {
        return FALSE;
    }
    purb = &gUrb;

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    MmInitializeMdl(gpMdl, buffer, *pcb);

    USB_BUILD_BULK_OR_INTERRUPT_TRANSFER(
            (PURB_BULK_OR_INTERRUPT_TRANSFER)purb,
            gDevice.pBulkOutEndpointHandle,
            gpMdl,
            *pcb,
            USB_TRANSFER_DIRECTION_OUT,
            (PURB_COMPLETE_PROC)CompleteWrite,
            (PVOID)&event,
            TRUE);

    gDevice.pDevice->SubmitRequest(purb);

    Wait(&event);

    if (USBD_SUCCESS(purb->Header.Status)) {
        *pcb = purb->BulkOrInterruptTransfer.TransferBufferLength;
        fRet = TRUE;
    } else {
        *pcb = 0;
        fRet = FALSE;
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\phy\precomp.h ===
#include <stddef.h>
#include <ntos.h>
#include <nturtl.h>
#include <xtl.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\ppp\globals.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

    globals.cpp

Abstract:

    PPP globals.

Revision History:

    07-11-00    vadimg      created

--*/

#include "precomp.h"

PPP_INFO gInfo;
PPP_CP_INFO gCpTable[NUM_CP];
LCP_INFO gLcp;
READ_QUEUE gQueue;
PPP_TIMER gTimer;
FRAMING_INFO gFraming;
AP_INFO gAp;
IP_INFO gIp;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\ppp\auth.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

    auth.cpp

Abstract:

    Handle authentication.

Revision History:

    07-18-00    vadimg      created

--*/

#include "precomp.h"

/***************************************************************************\
* ApWork
*
\***************************************************************************/

VOID ApWork(DWORD CpIndex, PPP_CONFIG *pRecvConfig)
{
    DWORD dwRetCode;
    DWORD dwLength;
    PPP_PACKET *pSendPacket = GetSendPacket();
    PPP_CONFIG *pSendConfig = (PPP_CONFIG*)pSendPacket->Data;

    dwRetCode = gCpTable[CpIndex].CP_MakeMessage(pRecvConfig);

    if (dwRetCode != NO_ERROR) {
        gInfo.dwError = dwRetCode;
        return;
    }

    switch (gAp.Action) {
    case AP_SendWithTimeout2:
        gInfo.ConfigRetryCount++;

        // fall through

    case AP_Send:
    case AP_SendWithTimeout:
    case AP_SendAndDone:
        HostToWireFormat16((WORD)gCpTable[CpIndex].Protocol,
                (PBYTE)pSendPacket->Protocol);

        dwLength = WireToHostFormat16(pSendConfig->Length);

        SendFrame(dwLength + PPP_PACKET_HDR_LEN);

        gInfo.LastId = (BYTE)-1;
        break;

    case AP_Done:
        if (gInfo.dwError != NO_ERROR) {
            return;
        }

        gInfo.State = FSM_OPENED;
        FsmThisLayerUp(CpIndex);
        break;
    }
}

/***************************************************************************\
* ApStart
*
\***************************************************************************/

BOOL ApStart(DWORD CpIndex)
{
    if (!FsmInit(CpIndex)) {
        return FALSE;
    }

    ApWork(CpIndex, NULL);

    return TRUE;
}

/***************************************************************************\
* ApReset
*
\***************************************************************************/

VOID ApReset(VOID)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\ppp\frame.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

    frame.cpp

Abstract:

    Handle PPP framing.

Revision History:

    07-18-00    vadimg      created

--*/

#include "precomp.h"

const USHORT gCRCTable[256] = {
      0x0000, 0x1189, 0x2312, 0x329b, 0x4624, 0x57ad, 0x6536, 0x74bf,
      0x8c48, 0x9dc1, 0xaf5a, 0xbed3, 0xca6c, 0xdbe5, 0xe97e, 0xf8f7,
      0x1081, 0x0108, 0x3393, 0x221a, 0x56a5, 0x472c, 0x75b7, 0x643e,
      0x9cc9, 0x8d40, 0xbfdb, 0xae52, 0xdaed, 0xcb64, 0xf9ff, 0xe876,
      0x2102, 0x308b, 0x0210, 0x1399, 0x6726, 0x76af, 0x4434, 0x55bd,
      0xad4a, 0xbcc3, 0x8e58, 0x9fd1, 0xeb6e, 0xfae7, 0xc87c, 0xd9f5,
      0x3183, 0x200a, 0x1291, 0x0318, 0x77a7, 0x662e, 0x54b5, 0x453c,
      0xbdcb, 0xac42, 0x9ed9, 0x8f50, 0xfbef, 0xea66, 0xd8fd, 0xc974,
      0x4204, 0x538d, 0x6116, 0x709f, 0x0420, 0x15a9, 0x2732, 0x36bb,
      0xce4c, 0xdfc5, 0xed5e, 0xfcd7, 0x8868, 0x99e1, 0xab7a, 0xbaf3,
      0x5285, 0x430c, 0x7197, 0x601e, 0x14a1, 0x0528, 0x37b3, 0x263a,
      0xdecd, 0xcf44, 0xfddf, 0xec56, 0x98e9, 0x8960, 0xbbfb, 0xaa72,
      0x6306, 0x728f, 0x4014, 0x519d, 0x2522, 0x34ab, 0x0630, 0x17b9,
      0xef4e, 0xfec7, 0xcc5c, 0xddd5, 0xa96a, 0xb8e3, 0x8a78, 0x9bf1,
      0x7387, 0x620e, 0x5095, 0x411c, 0x35a3, 0x242a, 0x16b1, 0x0738,
      0xffcf, 0xee46, 0xdcdd, 0xcd54, 0xb9eb, 0xa862, 0x9af9, 0x8b70,
      0x8408, 0x9581, 0xa71a, 0xb693, 0xc22c, 0xd3a5, 0xe13e, 0xf0b7,
      0x0840, 0x19c9, 0x2b52, 0x3adb, 0x4e64, 0x5fed, 0x6d76, 0x7cff,
      0x9489, 0x8500, 0xb79b, 0xa612, 0xd2ad, 0xc324, 0xf1bf, 0xe036,
      0x18c1, 0x0948, 0x3bd3, 0x2a5a, 0x5ee5, 0x4f6c, 0x7df7, 0x6c7e,
      0xa50a, 0xb483, 0x8618, 0x9791, 0xe32e, 0xf2a7, 0xc03c, 0xd1b5,
      0x2942, 0x38cb, 0x0a50, 0x1bd9, 0x6f66, 0x7eef, 0x4c74, 0x5dfd,
      0xb58b, 0xa402, 0x9699, 0x8710, 0xf3af, 0xe226, 0xd0bd, 0xc134,
      0x39c3, 0x284a, 0x1ad1, 0x0b58, 0x7fe7, 0x6e6e, 0x5cf5, 0x4d7c,
      0xc60c, 0xd785, 0xe51e, 0xf497, 0x8028, 0x91a1, 0xa33a, 0xb2b3,
      0x4a44, 0x5bcd, 0x6956, 0x78df, 0x0c60, 0x1de9, 0x2f72, 0x3efb,
      0xd68d, 0xc704, 0xf59f, 0xe416, 0x90a9, 0x8120, 0xb3bb, 0xa232,
      0x5ac5, 0x4b4c, 0x79d7, 0x685e, 0x1ce1, 0x0d68, 0x3ff3, 0x2e7a,
      0xe70e, 0xf687, 0xc41c, 0xd595, 0xa12a, 0xb0a3, 0x8238, 0x93b1,
      0x6b46, 0x7acf, 0x4854, 0x59dd, 0x2d62, 0x3ceb, 0x0e70, 0x1ff9,
      0xf78f, 0xe606, 0xd49d, 0xc514, 0xb1ab, 0xa022, 0x92b9, 0x8330,
      0x7bc7, 0x6a4e, 0x58d5, 0x495c, 0x3de3, 0x2c6a, 0x1ef1, 0x0f78
};

/***************************************************************************\
* CalcCRC
*
\***************************************************************************/

USHORT CalcCRC(PBYTE pb, DWORD cb)
{
    USHORT crc = 0xFFFF;

    while (cb--) {
        crc = (crc >> 8) ^ gCRCTable[(crc ^ *pb++) & 0xFF];
    }

    return ~crc;
}

/***************************************************************************\
* CalcCrc
*
\***************************************************************************/

BOOL CheckCrc(PBYTE pb, DWORD cb)
{
    USHORT crc, crcCheck;

    crcCheck = CalcCRC(pb, cb - 2);
    crc = pb[cb - 2] | (pb[cb - 1] << 8);

    return (crc == crcCheck);
}

/***************************************************************************\
* DecodeFrame 
*
\***************************************************************************/

VOID DecodeFrame(PBYTE pIn, DWORD *pcb)
{
    PBYTE pEnd, pEncoded, pDecoded;
    DWORD cb;

    pEnd = pIn + (*pcb - 1);
    pDecoded = pEncoded = pIn;

    while (pEncoded <= pEnd) {

        if (*pEncoded == PPP_ESC_BYTE) {
            pEncoded++;
            *pDecoded = *pEncoded ^ 0x20;
        } else {
            *pDecoded = *pEncoded;
        }
        pEncoded++;
        pDecoded++;
    }

    cb = pDecoded - pIn;
    *pcb = cb;
}

/***************************************************************************\
* EncodeFrame
*
\***************************************************************************/

VOID EncodeFrame(PBYTE pIn, PBYTE pOut, DWORD *pcb)
{
    DWORD i;
    BYTE ch;
    PBYTE pStart = pOut;
    USHORT crc;

    crc = CalcCRC(pIn, *pcb);

    *(pIn + *pcb) = (UCHAR)crc;
    *(pIn + *pcb + 1) = (UCHAR)(crc >> 8);
    *pcb += 2;

    *pOut++ = PPP_FLAG_BYTE;

    for (i = 0; i < *pcb; i++) {

        ch = pIn[i];

        if ((ch < 0x20 && ((1 << ch) & gFraming.SendAccm)) ||
                ch == 0x7D || ch == 0x7E) {
            *pOut++ = PPP_ESC_BYTE;
            *pOut++ = ch ^ 0x20;
        } else {
            *pOut++ = ch;
        }
    }

    *pOut++ = PPP_FLAG_BYTE;

    *pcb = pOut - pStart;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\phy\phy.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    phy.c

Abstract:

    Ethernet transceiver code inside the ROM

Revision History:

    04//5/2001 davidx
        Created it.

--*/

#include "precomp.h"
#include "phy.h"
#include "nettypes.h"
#include "netutil.h"
#include "ethernet.h"
#ifdef SILVER
#include "i82558.h"
#else
#include "xnic.h"
#endif

//
// Global variables
//  NOTE: The init count persists across quick reboots.
//
DECLSPEC_STICKY DWORD PhyInitFlag;
DWORD PhyLinkState;
LONG PhyLockFlag;

#define PhyLock() InterlockedCompareExchange(&PhyLockFlag, 1, 0)
#define PhyUnlock() (PhyLockFlag = 0)

//
// Macro for spewing debug message
//
#if DBG
BOOL PhyVerboseMode = TRUE;
#define WARNING_ DbgPrint
#define VERBOSE_ !PhyVerboseMode ? (void)0 : (void)DbgPrint
#else !DBG
#define WARNING_ 1 ? (void)0 : (void)
#define VERBOSE_ 1 ? (void)0 : (void)
#endif

//
// Don't declaration private functions as static
//
#ifdef PRIVATE
#undef PRIVATE
#define PRIVATE
#endif

PRIVATE BOOL PhyWriteReg(PNIC_CSR csr, DWORD phyreg, DWORD val);
PRIVATE BOOL PhyReadReg(PNIC_CSR csr, DWORD phyreg, DWORD* val);

PRIVATE BOOL
PhyUpdateLinkState(
    PNIC_CSR csr
    )

/*++

Routine Description:

    Update PHY link state information
    (read the information from the PHY registers)

Arguments:

    csr - Points to the NIC registers

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    DWORD anar, lpanar, miiStatus, state = 0;

    if (!PhyReadReg(csr, MIIREG_ANAR, &anar) ||
        !PhyReadReg(csr, MIIREG_LPANAR, &lpanar) ||
        !PhyReadReg(csr, MIIREG_STATUS, &miiStatus))
        return FALSE;

    anar &= lpanar;
    if (anar & (MII4_100BASE_T_FULL_DUPLEX | MII4_100BASE_T_HALF_DUPLEX))
        state |= XNET_LINK_100MBPS;
    else if (anar & (MII4_10BASE_T_FULL_DUPLEX | MII4_10BASE_T_HALF_DUPLEX))
        state |= XNET_LINK_10MBPS;

    if (anar & (MII4_10BASE_T_FULL_DUPLEX | MII4_100BASE_T_FULL_DUPLEX))
        state |= XNET_LINK_FULL_DUPLEX;
    else if (anar & (MII4_10BASE_T_HALF_DUPLEX | MII4_100BASE_T_HALF_DUPLEX))
        state |= XNET_LINK_HALF_DUPLEX;

    if (miiStatus & MIISTATUS_LINK_IS_UP)
        state |= XNET_LINK_IS_UP;

    PhyLinkState = state;
    return TRUE;
}


//
// Wait for up to 500ms until the link to be up.
//
INLINE DWORD PhyWaitForLinkUp(PNIC_CSR csr) {
    DWORD miiStatus = 0;
    INT timeout = 1000;
    while (timeout-- && !(miiStatus & MIISTATUS_LINK_IS_UP)) {
        KeStallExecutionProcessor(500);
        if (!PhyReadReg(csr, MIIREG_STATUS, &miiStatus)) break;
    }
    return miiStatus;
}


#ifndef SILVER

// Clear MDIOADR_LOCK bit
PRIVATE VOID PhyClearMDIOLOCK(PNIC_CSR csr)
{
    INT timeout;

    csr->mdio_adr = MDIOADR_LOCK;
    WARNING_("PHY: MDIOADR_LOCK is set\n");

    timeout = PHYRW_TIMEOUT;
    do {
        KeStallExecutionProcessor(50);
        timeout -= 50;
    } while (timeout > 0 && (csr->mdio_adr & MDIOADR_LOCK));
}


PRIVATE BOOL
PhyReadReg(
    PNIC_CSR csr,
    DWORD phyreg,
    DWORD* val
    )

/*++

Routine Description:

    Read the value of a PHY register

Arguments:

    csr - Points to the NIC registers
    phyreg - Specifies the PHY register to be read
    val - Return the PHY register value

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    DWORD mdioadr;
    INT timeout;

    // The lock bit shouldn't be set.
    // Clear it just in case it's stuck.

    if (csr->mdio_adr & MDIOADR_LOCK) {
        PhyClearMDIOLOCK(csr);
    }

    // Write the PHY register address

    mdioadr = (PHY_ADDR << MDIOADR_PHYSHIFT) | (phyreg << MDIOADR_REGSHIFT);
    csr->mdio_adr = mdioadr;

    mdioadr |= MDIOADR_LOCK;
    for (timeout=PHYRW_TIMEOUT; timeout > 0 && (mdioadr & MDIOADR_LOCK); timeout -= 50) {
        KeStallExecutionProcessor(50);
        mdioadr = csr->mdio_adr;
    }

    // Read the PHY register value
    *val = csr->mdio_data;

    if (mdioadr & MDIOADR_LOCK) {
        WARNING_("PHY read failed: reg %d.\n", phyreg);
        ASSERT(FALSE);
        return FALSE;
    }

    return TRUE;
}


PRIVATE BOOL
PhyWriteReg(
    PNIC_CSR csr,
    DWORD phyreg,
    DWORD val
    )

/*++

Routine Description:

    Write the specified value to a PHY register

Arguments:

    csr - Points to the NIC registers
    phyreg - Specifies the PHY register to be written
    val - Specifies the value for the PHY register

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    DWORD mdioadr;
    INT timeout;

    // The lock bit shouldn't be set.
    // Clear it just in case it's stuck.

    if (csr->mdio_adr & MDIOADR_LOCK) {
        PhyClearMDIOLOCK(csr);
    }

    // Write the data first

    csr->mdio_data = val;

    // Write the PHY register address

    mdioadr = (PHY_ADDR << MDIOADR_PHYSHIFT) | (phyreg << MDIOADR_REGSHIFT) | MDIOADR_WRITE;
    csr->mdio_adr = mdioadr;

    mdioadr |= MDIOADR_LOCK;
    for (timeout=PHYRW_TIMEOUT; timeout > 0 && (mdioadr & MDIOADR_LOCK); timeout -= 50) {
        KeStallExecutionProcessor(50);
        mdioadr = csr->mdio_adr;
    }

    if (mdioadr & MDIOADR_LOCK) {
        WARNING_("PHY write failed: reg %d.\n", phyreg);
        ASSERT(FALSE);
        return FALSE;
    }

    return TRUE;
}


NTSTATUS
PhyInitialize(
    BOOL forceReset,
    VOID* param OPTIONAL
    )

/*++

Routine Description:

    Initialize the Ethernet PHY interface

Arguments:

    forceReset - Whether to force a PHY reset
    param -optional parameters

Return Value:

    Status code

--*/

{
    PNIC_CSR csr = NicCsr;
    DWORD miiControl, miiStatus;
    INT timeout;
    NTSTATUS status = NETERR_HARDWARE;

    if (PhyLock() != 0)
        return NETERR(ERROR_BUSY);
    
    if (forceReset) {
        PhyInitFlag = 0;
        PhyLinkState = 0;

        //
        // Force the PHY to reset
        //
        miiControl = MIICONTROL_RESET;
        if (!PhyWriteReg(csr, MIIREG_CONTROL, miiControl)) goto err;

        // Wait for up to 500ms
        timeout = 1000;
        while (timeout-- && (miiControl & MIICONTROL_RESET)) {
            KeStallExecutionProcessor(500);
            if (!PhyReadReg(csr, MIIREG_CONTROL, &miiControl)) goto err;
        }

        // If the reset is still asserted, return error
        if (miiControl & MIICONTROL_RESET) goto err;
    } else if (PhyInitFlag) {
        //
        // If PHY is already initialized, just update the link state
        //
        PhyUpdateLinkState(csr);
        status = NETERR_OK;
        goto exit;
    }

    // The auto-negotiation should be started by now.
    // Wait for a max of 3 seconds for it to complete.
    timeout = 6000;
    miiStatus = 0;
    while (timeout-- && !(miiStatus & MIISTATUS_AUTO_NEGOTIATION_COMPLETE)) {
        KeStallExecutionProcessor(500);
        if (!PhyReadReg(csr, MIIREG_STATUS, &miiStatus)) goto err;
    }

    // NOTE: Workaround for ICS PHY problems with some 10base-t hubs
    //  e.g. Garret Communications Magnum Personal Hub H50
    if (XboxHardwareInfo.McpRevision != 0xa1) {
        DWORD icshack;
        // clear bit 8 of undocumented register 0x18
        if (PhyReadReg(csr, 0x18, &icshack)) {
            icshack &= ~0x0100;
            PhyWriteReg(csr, 0x18, icshack);
        }
    }

    //
    // Use auto-negotiation
    //
    if (!PhyReadReg(csr, MIIREG_CONTROL, &miiControl)) goto err;

    if (miiControl & MIICONTROL_RESTART_AUTO_NEGOTIATION) {
        // If the restart-auto-negotiation bit is set,
        // default to the highest available speed in half-duplex mode.
        WARNING_("Auto-negotiation didn't succeed.\n");

        if (miiStatus & (MIISTATUS_100MBS_T4_CAPABLE |
                         MIISTATUS_100MBS_X_HALF_DUPLEX_CAPABLE |
                         MIISTATUS_100MBS_T2_HALF_DUPLEX_CAPABLE)) {
            // We can do 100Mbps
            miiControl |=  MIICONTROL_SPEED_SELECTION_BIT1;
            miiControl &= ~MIICONTROL_SPEED_SELECTION_BIT0;
            PhyLinkState |= XNET_LINK_100MBPS;
        } else if (miiStatus & MIISTATUS_10MBS_HALF_DUPLEX_CAPABLE) {
            // We can do 10Mbps
            miiControl &= ~MIICONTROL_SPEED_SELECTION_BIT1;
            miiControl |=  MIICONTROL_SPEED_SELECTION_BIT0;
            PhyLinkState |= XNET_LINK_10MBPS;
        } else
            goto err;

        PhyLinkState |= XNET_LINK_HALF_DUPLEX;

        // Set the desired speed if the auto-negotiation never completed
        PhyWriteReg(csr, MIIREG_CONTROL, miiControl);

        miiStatus = PhyWaitForLinkUp(csr);
        if (miiStatus & MIISTATUS_LINK_IS_UP)
            PhyLinkState |= XNET_LINK_IS_UP;
    } else {
        // Auto-negotiation worked.
        PhyWaitForLinkUp(csr);
        if (!PhyUpdateLinkState(csr)) goto err;
    }

    PhyInitFlag = 1;
    status = NETERR_OK;

exit:
    PhyUnlock();
    return status;

err:
    WARNING_("Ethernet PHY initialization failed.\n");
    goto exit;
}


//
// Public function for retrieving link state information
//
DWORD PhyGetLinkState(BOOL update)
{
    if ((!PhyLinkState || update) && PhyLock() == 0) {
        PhyUpdateLinkState(NicCsr);
        PhyUnlock();
    }
    return PhyLinkState;
}

#else // !SILVER

PRIVATE BOOL
PhyReadReg(
    PNIC_CSR csr,
    DWORD phyreg,
    DWORD* val
    )

/*++

Routine Description:

    Read the value of a PHY register

Arguments:

    csr - Points to the NIC registers
    phyreg - Specifies the PHY register to be read
    val - Return the PHY register value

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    DWORD mdictrl;
    INT timeout;

    if (!(csr->mdiCtrl & MDI_READY)) {
        WARNING_("PHY isn't ready.\n");
    }

    // Initiate the PHY read
    mdictrl = MDI_PHY_REG_ADDR(phyreg) | MDI_PHY_ADDR(1) | MDIOP_READ;
    csr->mdiCtrl = mdictrl;

    // Wait for max 10msecs
    for (timeout = 2000; timeout > 0 && !(mdictrl & MDI_READY); timeout -= 50) {
        KeStallExecutionProcessor(50);
        mdictrl = csr->mdiCtrl;
    }

    if (mdictrl & MDI_READY) {
        *val = (mdictrl & 0xffff);
        return TRUE;
    }
    
    WARNING_("PHY read failed: reg %d.\n", phyreg);
    return FALSE;
}


PRIVATE BOOL
PhyWriteReg(
    PNIC_CSR csr,
    DWORD phyreg,
    DWORD val
    )

/*++

Routine Description:

    Write the specified value to a PHY register

Arguments:

    csr - Points to the NIC registers
    phyreg - Specifies the PHY register to be written
    val - Specifies the value for the PHY register

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    DWORD mdictrl;
    INT timeout;

    if (!(csr->mdiCtrl & MDI_READY)) {
        WARNING_("PHY isn't ready.\n");
    }

    // Initiate the PHY write
    mdictrl = MDI_PHY_REG_ADDR(phyreg) | MDI_PHY_ADDR(1) | MDIOP_WRITE | val;
    csr->mdiCtrl = mdictrl;

    // Wait for max 10msecs
    for (timeout = 2000; timeout > 0 && !(mdictrl & MDI_READY); timeout -= 50) {
        KeStallExecutionProcessor(50);
        mdictrl = csr->mdiCtrl;
    }

    if (mdictrl & MDI_READY)
        return TRUE;

    WARNING_("PHY write failed: reg %d.\n", phyreg);
    return FALSE;
}

//
// NOTE: PHY related functions are not fully implemented on the silver xdk box.
//  It's going away anyhow.
//
DWORD PhyGetLinkState(BOOL update)
{
    return PhyLinkState;
}

NTSTATUS PhyInitialize(BOOL forceReset, VOID* param)
{
    PNIC_CSR csr;

    if (PhyLock() != 0)
        return NETERR(ERROR_BUSY);
    
    // On silver xdk box, param points to the NIC CSR register space
    ASSERT(param != NULL && !forceReset);
    csr = (PNIC_CSR) param;

    // Just wait for up to half a second until the link is up
    // and then update the link status
    PhyWaitForLinkUp(csr);
    PhyUpdateLinkState(csr);
    
    PhyInitFlag = 1;
    PhyUnlock();
    return NETERR_OK;
}

#endif // !SILVER
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\modem\usbcomm.h ===
/****************************************************************************

Copyright (c) 1998  Microsoft Corporation

Module Name:

	USBCOMM.H

Abstract:

	USB Communication Class Header File

Environment:

	Kernel mode & user mode

Notes:

	THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
	KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
	IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
	PURPOSE.

	Copyright (c) 1998 Microsoft Corporation.  All Rights Reserved.

Revision History:

	12/23/97 : created

Author:

	Tom Green

****************************************************************************/


#ifndef   __USBCOMM_H__
#define   __USBCOMM_H__

#include <pshpack1.h>


// USB Communication Class Code
#define USB_COMM_COMMUNICATION_CLASS_CODE		0x0002

// USB Communication Class Code
#define USB_COMM_DATA_CLASS_CODE				0x000A

// USB Communication Class SubClass Codes
#define USB_COMM_SUBCLASS_RESERVED				0x0000
#define USB_COMM_SUBCLASS_DIRECT_LINE_CONTROL	0x0001
#define USB_COMM_SUBCLASS_ABSTRACT_CONTROL		0x0002
#define USB_COMM_SUBCLASS_TELEPHONE_CONTROL		0x0003

// USB Communication Class Control Protocol Codes
#define USB_COMM_PROTOCOL_RESERVED				0x0000
#define USB_COMM_PROTOCOL_V25TER				0x0001

// Direct Line Control Model defines
#define USB_COMM_SET_AUX_LINE_STATE				0x0010
#define USB_COMM_SET_HOOK_STATE					0x0011
#define USB_COMM_PULSE_SETUP					0x0012
#define USB_COMM_SEND_PULSE						0x0013
#define USB_COMM_SET_PULSE_TIME					0x0014
#define USB_COMM_RING_AUX_JACK					0x0015

// Direct Line Control Model Notification defines
#define USB_COMM_AUX_JACK_HOOK_STATE			0x0008
#define USB_COMM_RING_DETECT					0x0009


// Abstract Control Model defines
#define USB_COMM_SEND_ENCAPSULATED_COMMAND		0x0000
#define USB_COMM_GET_ENCAPSULATED_RESPONSE		0x0001
#define USB_COMM_SET_COMM_FEATURE				0x0002
#define USB_COMM_GET_COMM_FEATURE				0x0003
#define USB_COMM_CLEAR_COMM_FEATURE				0x0004
#define USB_COMM_SET_LINE_CODING				0x0020
#define USB_COMM_GET_LINE_CODING				0x0021
#define USB_COMM_SET_CONTROL_LINE_STATE			0x0022
#define USB_COMM_SEND_BREAK						0x0023

// Abstract Control Model Notification defines
#define USB_COMM_NETWORK_CONNECTION				0x0000
#define USB_COMM_RESPONSE_AVAILABLE				0x0001
#define USB_COMM_SERIAL_STATE					0x0020


// Telephone Control Model defines
#define USB_COMM_SET_RINGER_PARMS				0x0030
#define USB_COMM_GET_RINGER_PARMS				0x0031
#define USB_COMM_SET_OPERATION_PARMS			0x0032
#define USB_COMM_GET_OPERATION_PARMS			0x0033
#define USB_COMM_SET_LINE_PARMS					0x0034
#define USB_COMM_GET_LINE_PARMS					0x0035
#define USB_COMM_DIAL_DIGITS					0x0036

// Telephone Control Model Notification defines
#define USB_COMM_CALL_STATE_CHANGE				0x0028
#define USB_COMM_LINE_STATE_CHANGE				0x0029


// Descriptor type for Functional Descriptors
#define	USB_COMM_CS_INTERFACE					0x0024
#define USB_COMM_CS_ENDPOINT					0x0025


// Communication Feature Selector Codes
#define USB_COMM_ABSTRACT_STATE					0x0001
#define USB_COMM_COUNTRY_SETTING				0x0002

// POTS Relay Configuration Values
#define USB_COMM_ON_HOOK						0x0000
#define USB_COMM_OFF_HOOK						0x0001
#define USB_COMM_SNOOPING						0x0002


// Operation Mode Values
#define USB_COMM_SIMPLE_MODE					0x0000
#define USB_COMM_STANDALONE_MODE				0x0001
#define USB_COMM_COMPUTER_CENTRIC_MODE			0x0002


// Line State Change Values for SET_LINE_PARMS
#define USB_COMM_DROP_ACTIVE_CALL				0x0000
#define USB_COMM_START_NEW_CALL					0x0001
#define USB_COMM_APPLY_RINGING					0x0002
#define USB_COMM_REMOVE_RINGING					0x0003
#define USB_COMM_SWITCH_TO_SPECIFIC_CALL		0x0004


// Call State Values for GET_LINE_PARMS
#define USB_COMM_CALL_IDLE						0x0000
#define USB_COMM_TYPICAL_DIAL_TONE				0x0001
#define USB_COMM_INTERRUPTED_DIAL_TONE			0x0002
#define USB_COMM_DIALING_IN_PROGRESS			0x0003
#define USB_COMM_RINGBACK						0x0004
#define USB_COMM_CONNECTED						0x0005
#define USB_COMM_INCOMING_CALL					0x0006


// Call State Change values for CALL_STATE_CHANGE
#define USB_COMM_CALL_RESERVED					0x0000
#define USB_COMM_CALL_CALL_HAS_BECOME_IDLE		0x0001
#define USB_COMM_CALL_DIALING					0x0002
#define USB_COMM_CALL_RINGBACK					0x0003
#define USB_COMM_CALL_CONNECTED					0x0004
#define USB_COMM_CALL_INCOMING_CALL				0x0005


// Line State Change Values for LINE_STATE_CHANGE
#define USB_COMM_LINE_LINE_HAS_BECOME_IDLE		0x0000
#define USB_COMM_LINE_LINE_HOLD_POSITION		0x0001
#define USB_COMM_LINE_HOOK_SWITCH_OFF			0x0002
#define USB_COMM_LINE_HOOK_SWITCH_ON			0x0003

// Line Coding Stop Bits
#define USB_COMM_STOPBITS_10					0x0000
#define USB_COMM_STOPBITS_15					0x0001
#define USB_COMM_STOPBITS_20					0x0002

// Line Coding Parity Type
#define USB_COMM_PARITY_NONE					0x0000
#define USB_COMM_PARITY_ODD						0x0001
#define USB_COMM_PARITY_EVEN					0x0002
#define USB_COMM_PARITY_MARK					0x0003
#define USB_COMM_PARITY_SPACE					0x0004


// Control Line State
#define USB_COMM_DTR							0x0001
#define USB_COMM_RTS							0x0002

// Serial State Notification bits
#define USB_COMM_DCD							0x0001
#define USB_COMM_DSR							0x0002
#define USB_COMM_BREAK							0x0004
#define USB_COMM_RING							0x0008
#define USB_COMM_FRAMING_ERROR					0x0010
#define USB_COMM_PARITY_ERROR					0x0020
#define USB_COMM_OVERRUN						0x0040



// Call Management Functional Descriptor

typedef struct _USB_COMM_CALL_MANAGEMENT_FUNC_DESCR
{
	UCHAR		FunctionLength;
	UCHAR		DescriptorType;
	UCHAR		DescriptorSubType;
	UCHAR		Capabilities;
	UCHAR		DataInterface;
} USB_COMM_CALL_MANAGEMENT_FUNC_DESCR, *PUSB_COMM_CALL_MANAGEMENT_FUNC_DESCR;


// Abstract Control Management Functional Descriptor

typedef struct _USB_COMM_ABSTRACT_CONTROL_MANAGEMENT_FUNC_DESCR
{
	UCHAR		FunctionLength;
	UCHAR		DescriptorType;
	UCHAR		DescriptorSubType;
	UCHAR		Capabilities;
} USB_COMM_ABSTRACT_CONTROL_MANAGEMENT_FUNC_DESCR, *PUSB_COMM_ABSTRACT_CONTROL_MANAGEMENT_FUNC_DESCR;


// Direct Line Management Functional Descriptor

typedef struct _USB_COMM_DIRECT_LINE_MANAGEMENT_FUNC_DESCR
{
	UCHAR		FunctionLength;
	UCHAR		DescriptorType;
	UCHAR		DescriptorSubType;
	UCHAR		Capabilities;
} USB_COMM_DIRECT_LINE_MANAGEMENT_FUNC_DESCR, *PUSB_COMM_DIRECT_LINE_MANAGEMENT_FUNC_DESCR;


// Telephone Ringer Functional Descriptor

typedef struct _USB_COMM_TELEPHONE_RINGER_FUNC_DESCR
{
	UCHAR		FunctionLength;
	UCHAR		DescriptorType;
	UCHAR		DescriptorSubType;
	UCHAR		RingerVolSteps;
	UCHAR		NumRingerPatterns;
} USB_COMM_TELEPHONE_RINGER_FUNC_DESCR, *PUSB_COMM_TELEPHONE_RINGER_FUNC_DESCR;


// Telephone Operational Modes Functional Descriptor

typedef struct _USB_COMM_TELEPHONE_OPERATIONAL_MODES_FUNC_DESCR
{
	UCHAR		FunctionLength;
	UCHAR		DescriptorType;
	UCHAR		DescriptorSubType;
	UCHAR		Capabilities;
} USB_COMM_TELEPHONE_OPERATIONAL_MODES_FUNC_DESCR, *PUSB_COMM_TELEPHONE_OPERATIONAL_MODES_FUNC_DESCR;


// Telephone Call and Line State Reporting Capabilities Descriptor

typedef struct _USB_COMM_TELEPHONE_CALL_LINE_STATE_DESCR
{
	UCHAR		FunctionLength;
	UCHAR		DescriptorType;
	UCHAR		DescriptorSubType;
	UCHAR		Capabilities;
} USB_COMM_TELEPHONE_CALL_LINE_STATE_DESCR, *PUSB_COMM_TELEPHONE_CALL_LINE_STATE_DESCR;


// Union Functional Descriptor

typedef struct _USB_COMM_UNION_FUNC_DESCR
{
	UCHAR		FunctionLength;
	UCHAR		DescriptorType;
	UCHAR		DescriptorSubType;
	UCHAR		MasterInterface;
	UCHAR		SlaveInterface;
} USB_COMM_UNION_FUNC_DESCR, *PUSB_COMM_UNION_FUNC_DESCR;


// Country Selection Functional Descriptor

typedef struct _USB_COMM_COUNTRY_SELECTION_FUNC_DESCR
{
	UCHAR		FunctionLength;
	UCHAR		DescriptorType;
	UCHAR		DescriptorSubType;
	UCHAR		CountryCodeRelDate;
	UCHAR		CountryCode;
} USB_COMM_COUNTRY_SELECTION_FUNC_DESCR, *PUSB_COMM_COUNTRY_SELECTION_FUNC_DESCR;


// Class Specific Interface Descriptor

typedef struct _USB_COMM_CLASS_SPECIFIC_INTERFACE_DESCR
{
	UCHAR		FunctionLength;
	UCHAR		DescriptorType;
	UCHAR		DescriptorSubType;
	UCHAR		CDC;
} USB_COMM_CLASS_SPECIFIC_INTERFACE_DESCR, *PUSB_COMM_CLASS_SPECIFIC_INTERFACE_DESCR;


// Line Coding for GET_LINE_CODING and SET_LINE_CODING

typedef struct _USB_COMM_LINE_CODING
{
	ULONG		DTERate;
	UCHAR		CharFormat;
	UCHAR		ParityType;
	UCHAR		DataBits;
} USB_COMM_LINE_CODING, *PUSB_COMM_LINE_CODING;

// Line Status Information for GET_LINE_PARMS

typedef struct _USB_COMM_LINE_STATUS
{
	USHORT		Length;
	ULONG		RingerBitmap;
	ULONG		LineState;
	ULONG		CallState;
} USB_COMM_LINE_STATUS, *PUSB_COMM_LINE_STATUS;

// Serial Status Notification

typedef struct _USB_COMM_SERIAL_STATUS
{
	UCHAR		RequestType;
	UCHAR		Notification;
	USHORT		Value;
	USHORT		Index;
	USHORT		Length;
	USHORT		SerialState;
} USB_COMM_SERIAL_STATUS, *PUSB_COMM_SERIAL_STATUS;


#include <poppack.h>

#endif /*  __USBCOMM_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\ppp\hostwire.cpp ===
#include "precomp.h"

VOID HostToWireFormat16(WORD wHostFormat, PBYTE pWireFormat)
{
    *((PBYTE)(pWireFormat)+0) = (BYTE)((DWORD)(wHostFormat) >> 8);
    *((PBYTE)(pWireFormat)+1) = (BYTE)(wHostFormat);
}

VOID HostToWireFormat32(DWORD dwHostFormat, PBYTE pWireFormat)
{
    *((PBYTE)(pWireFormat)+0) = (BYTE)((DWORD)(dwHostFormat) >> 24);
    *((PBYTE)(pWireFormat)+1) = (BYTE)((DWORD)(dwHostFormat) >> 16);
    *((PBYTE)(pWireFormat)+2) = (BYTE)((DWORD)(dwHostFormat) >>  8);
    *((PBYTE)(pWireFormat)+3) = (BYTE)(dwHostFormat);
}

WORD WireToHostFormat16(PBYTE pWireFormat)
{
    WORD wHostFormat = ((*((PBYTE)(pWireFormat)+0) << 8) +
            (*((PBYTE)(pWireFormat)+1)));
    return wHostFormat;
}

DWORD WireToHostFormat32(PBYTE pWireFormat)
{
    DWORD dwHostFormat = ((*((PBYTE)(pWireFormat)+0) << 24) +
            (*((PBYTE)(pWireFormat)+1) << 16) +
            (*((PBYTE)(pWireFormat)+2) << 8)  +
            (*((PBYTE)(pWireFormat)+3) ));

    return dwHostFormat;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\ppp\init.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

    init.cpp

Abstract:

    XBox PPP initialization routines.

Revision History:

    07-11-00    vadimg      created

--*/

#include "precomp.h"

VOID (*gCpGetInfo[])(PPP_CP_INFO *pInfo) = {
    GetLcpInfo,
    GetPapInfo,
    GetIpcpInfo
};

/***************************************************************************\
* PppConnect
*
\***************************************************************************/

BOOL PppConnect(CHAR *pszUsername, CHAR *pszPassword, CHAR *pszDomain, CHAR *pszNumber)
{
    BOOL fSuccess = FALSE;
    HANDLE hThread = NULL;
    DWORD dwTid;
    ULONG i;
    PBYTE pFrame;
    
    if (strlen(pszUsername) > UNLEN) {
        return FALSE;
    }
    if (strlen(pszPassword) > PWLEN) {
        return FALSE;
    }
    if (strlen(pszDomain) > DNLEN) {
        return FALSE;
    }
    if (strlen(pszNumber) > PNLEN) {
        return FALSE;
    }

    pFrame = (PBYTE)Alloc(PPP_FRAME_MAX_LEN);
    if (pFrame != NULL) {
        gInfo.pFrame = (PPP_FRAME*)pFrame;
        gInfo.pFrame->Address = 0xFF;
        gInfo.pFrame->Control = 0x03;
    } else {
        goto Cleanup;
    }

    for (i = 0; i < NUM_CP; i++) {
        gCpGetInfo[i](&gCpTable[i]);
    }

    gQueue.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (gQueue.hEvent == NULL) {
        goto Cleanup;
    }

    if (!InitModem()) {
        goto Cleanup;
    }

    strcpy(gInfo.szUsername, pszUsername);
    strcpy(gInfo.szPassword, pszPassword);
    strcpy(gInfo.szDomain, pszDomain);
    strcpy(gInfo.szNumber, pszNumber);

    if (!DialModem()) {
        goto Cleanup;
    }

    gFraming.SendAccm = 0xFFFFFFFF;
    gFraming.RecvAccm = 0xFFFFFFFF;

    if (!FsmInit(CP_LCP)) {
        goto Cleanup;
    }

    hThread = CreateThread(NULL, 0, WorkerThread, NULL, 0, &dwTid);
    if (hThread == NULL) {
        goto Cleanup;
    }
    CloseHandle(hThread);

    FsmOpen(CP_LCP);
    FsmUp(CP_LCP);

    fSuccess = TRUE;

Cleanup:

    if (!fSuccess) {

        ModemClose();

        if (gQueue.hEvent != NULL) {
            CloseHandle(gQueue.hEvent);
            gQueue.hEvent = NULL;
        }

        if (gInfo.pFrame != NULL) {
            Free((PBYTE)gInfo.pFrame);
            gInfo.pFrame = NULL;
        }
    }

    return fSuccess;
}

/***************************************************************************\
* DllMain
*
\***************************************************************************/

BOOL WINAPI DllMain(HINSTANCE hinst, DWORD dwReason, LPVOID pvReserved)
{
    switch (dwReason) {
    case DLL_THREAD_DETACH:
        break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\ppp\lcp.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

    lcp.cpp

Abstract:

    Line Control Protocol.

Revision History:

    07-11-00    vadimg      created

--*/

#include "precomp.h"

LCP_OPTIONS gLcpDefault = {
        0,                  // Negotiation flags
        LCP_DEFAULT_MRU,    // Default value for MRU
        0xFFFFFFFF,         // Default ACCM value.
        0,                  // no authentication ( for client )
        0,                  // no authentication data ( for client )
        NULL,               // no authentication data ( for client )
        0,                  // Magic Number.
        FALSE,               // Protocol field compression.
        FALSE,               // Address and Contorl-Field Compression.
        0,                  // Callback Operation message field
        LCP_DEFAULT_MRU,    // Default value for MRRU == MRU according to RFC1717
        0,                  // No short sequencing
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // No endpoint discriminator
        0,                  // Length of Endpoint Discriminator
        0                   // Link Discriminator (for BAP/BACP)
};

DWORD gSizeOfOption[] = {
        0,                          // unused 
        PPP_OPTION_HDR_LEN + 2,     // MRU 
        PPP_OPTION_HDR_LEN + 4,     // ACCM 
        PPP_OPTION_HDR_LEN + 2,     // authentication 
        0,                          // Unused.
        PPP_OPTION_HDR_LEN + 4,     // magic number 
        0,                          // Reserved, unused
        PPP_OPTION_HDR_LEN + 0,     // Protocol compression 
        PPP_OPTION_HDR_LEN + 0,     // Address/Control compression 
        0,                          // Unused
        0,                          // Unused
        0,                          // Unused
        0,                          // Unused
        PPP_OPTION_HDR_LEN + 1,     // Callback
        0,                          // Unused
        0,                          // Unused
        0,                          // Unused
        PPP_OPTION_HDR_LEN + 2,     // MRRU
        PPP_OPTION_HDR_LEN + 0,     // Short Sequence Header Format
        PPP_OPTION_HDR_LEN,         // Endpoint Discriminator
        0,                          // Unused
        0,                          // Unused
        0,                          // Unused
        PPP_OPTION_HDR_LEN + 2      // Link Discriminator (for BAP/BACP)
};

DWORD gLcpNegotiate = LCP_N_MRU | LCP_N_ACCM | LCP_N_AUTHENT | LCP_N_MAGIC | LCP_N_PFC | LCP_N_ACFC;

/***************************************************************************\
* MakeOption
*
\***************************************************************************/

DWORD MakeOption(LCP_OPTIONS *pOption, DWORD dwOptionCode,
        PPP_OPTION *pSendOption, DWORD cbSendOption)
{
    if (cbSendOption < gSizeOfOption[dwOptionCode]) {
        return ERROR_BUFFER_TOO_SMALL;
    }

    pSendOption->Type = (BYTE)dwOptionCode;
    pSendOption->Length = (BYTE)gSizeOfOption[dwOptionCode];

    switch (dwOptionCode) {
    case LCP_OPTION_MRU:
        HostToWireFormat16((WORD)pOption->MRU, pSendOption->Data);
        break;

    case LCP_OPTION_ACCM:
        HostToWireFormat32(pOption->ACCM, pSendOption->Data);
        break;

    case LCP_OPTION_AUTHENT:
        if (cbSendOption < (gSizeOfOption[dwOptionCode] + pOption->APDataSize)) {
            return ERROR_BUFFER_TOO_SMALL;
        }
        HostToWireFormat16((WORD)pOption->AP, pSendOption->Data);
        CopyMemory(pSendOption->Data + 2, pOption->pAPData, pOption->APDataSize);
        pSendOption->Length += (BYTE)pOption->APDataSize;
        break;

    case LCP_OPTION_MAGIC:
        HostToWireFormat32(pOption->MagicNumber, pSendOption->Data);
        break;
    
    case LCP_OPTION_PFC:
        break;

    case LCP_OPTION_ACFC:
        break;

    case LCP_OPTION_MRRU:    
        HostToWireFormat16((WORD)pOption->MRRU, pSendOption->Data);
        break;

    default: 
        return ERROR_INVALID_PARAMETER;
    }

    return NO_ERROR;
}

/***************************************************************************\
* CheckOption
*
\***************************************************************************/

DWORD CheckOption(LCP_SIDE *pLcpSide, PPP_OPTION *pOption, BOOL fMakingResult)
{
    DWORD dwIndex;
    DWORD dwAPDataSize;
    DWORD dwRetCode = CONFIG_ACK;

    if (pOption->Length < gSizeOfOption[pOption->Type]) {
        return CONFIG_REJ;
    }

    // If we do not want to negotiate the option we CONFIG_REJ it.
    if (!(pLcpSide->WillNegotiate & (1 << pOption->Type))) {
        return CONFIG_REJ;
    }

    switch (pOption->Type) {
    case LCP_OPTION_MRU:
        pLcpSide->Work.MRU = WireToHostFormat16(pOption->Data);

        // Check to see if this value is appropriate
        if (fMakingResult) {

            // We cannot send packets smaller than LCP_DEFAULT_MRU
            if (pLcpSide->Work.MRU < LCP_DEFAULT_MRU) {
                pLcpSide->Work.MRU = pLcpSide->Want.MRU;
                dwRetCode = CONFIG_NAK;
            }
        } else {

            // We cannot receive bigger packets.
            if (pLcpSide->Work.MRU > pLcpSide->Want.MRU) {
                pLcpSide->Work.MRU = pLcpSide->Want.MRU;
                dwRetCode = CONFIG_NAK;
            }
        }
    break;

    case LCP_OPTION_ACCM:
        pLcpSide->Work.ACCM = WireToHostFormat32(pOption->Data);

        // If we are responding to a request, we accept it blindly, if we are
        // processing a NAK, then the remote host may ask to escape more
        // control characters than we require, but must escape at least the
        // control chars that we require.
        if (!fMakingResult) {
            if (pLcpSide->Work.ACCM !=
                    (pLcpSide->Work.ACCM | pLcpSide->Want.ACCM)) {
                pLcpSide->Work.ACCM |= pLcpSide->Want.ACCM;
                dwRetCode = CONFIG_NAK;
            }
        }
        break;

    case LCP_OPTION_AUTHENT:
        pLcpSide->Work.AP = WireToHostFormat16( pOption->Data );

        // If there was Authentication data.
        if (pOption->Length > PPP_OPTION_HDR_LEN + 2) {

            dwAPDataSize = pOption->Length - PPP_OPTION_HDR_LEN - 2;

            if (dwAPDataSize != pLcpSide->Work.APDataSize) {

                pLcpSide->Work.APDataSize = dwAPDataSize;

                if (pLcpSide->Work.pAPData != NULL) {
                    Free(pLcpSide->Work.pAPData);
                    pLcpSide->Work.pAPData = NULL;
                }

                pLcpSide->Work.pAPData = (PBYTE)Alloc(pLcpSide->Work.APDataSize);

                if (pLcpSide->Work.pAPData == NULL) {
                    pLcpSide->Work.APDataSize = 0;
                    return CONFIG_REJ;
                }
            }

            CopyMemory(pLcpSide->Work.pAPData, pOption->Data + 2,
                    pLcpSide->Work.APDataSize);

        } else {

            pLcpSide->Work.APDataSize = 0;
        }

        switch (pLcpSide->Work.AP) {
        case PPP_PAP_PROTOCOL:
            if (!(pLcpSide->APsAvailable & LCP_AP_PAP)) {
                dwRetCode = CONFIG_NAK;
            }
            break;

        default:
            dwRetCode = CONFIG_NAK;
            break;
        }
        break;

    case LCP_OPTION_MAGIC:
        pLcpSide->Work.MagicNumber = WireToHostFormat32(pOption->Data);

        if (fMakingResult) {

            // Ensure that magic numbers are different and that the remote
            // request does not contain a magic number of 0.
            if ((pLcpSide->Work.MagicNumber == gLcp.Local.Work.MagicNumber) ||
                    (pLcpSide->Work.MagicNumber == 0)) {

                if (pLcpSide->Work.MagicNumber == gLcp.Local.Work.MagicNumber) {
                    ++gLcp.dwMagicNumberFailureCount;
                }

                pLcpSide->Work.MagicNumber = GetMagicNumber();

                dwRetCode = CONFIG_NAK;
            }
        } else {

            // The remote peer NAK'ed with a magic number, check to see if
            // the magic number in the NAK is the same as what we NAK'ed last
            if (pLcpSide->Work.MagicNumber == gLcp.Remote.Work.MagicNumber) {

                ++gLcp.dwMagicNumberFailureCount;

                pLcpSide->Work.MagicNumber = GetMagicNumber();

                dwRetCode = CONFIG_NAK;
            }
        }
        break;

    case LCP_OPTION_PFC:
        pLcpSide->Work.PFC = TRUE;

        if (pLcpSide->Want.PFC == FALSE) {
            dwRetCode = CONFIG_REJ;
        }
        break;

    case LCP_OPTION_ACFC:
        pLcpSide->Work.ACFC = TRUE;

        if (pLcpSide->Want.ACFC == FALSE) {
            dwRetCode = CONFIG_REJ;
        }
        break;

    case LCP_OPTION_MRRU:    
        pLcpSide->Work.MRRU = WireToHostFormat16(pOption->Data);

        // Check to see if this value is appropriate
        if (fMakingResult) {

            // We cannot send smaller reconstructed packets.
            if (pLcpSide->Work.MRRU < pLcpSide->Want.MRRU) {
                pLcpSide->Work.MRRU = pLcpSide->Want.MRRU;
                dwRetCode = CONFIG_NAK;
            }
        } else {

            // We cannot receive bigger reconstructed packets.
            if (pLcpSide->Work.MRRU > pLcpSide->Want.MRRU) {
                pLcpSide->Work.MRRU = pLcpSide->Want.MRRU;
                dwRetCode = CONFIG_NAK;
            }
        }
        break;

    default:
        // If we do not recognize the option we CONFIG_REJ it.
        dwRetCode = CONFIG_REJ;
        break;
    }

    return dwRetCode;
}

/***************************************************************************\
* BuildOptionList
*
\***************************************************************************/

DWORD BuildOptionList(BYTE *pOptions, DWORD *pcbOptions,
        LCP_OPTIONS *LcpOptions, DWORD Negotiate)
{
    DWORD OptionType;
    DWORD dwRetCode;
    DWORD cbOptionLength = *pcbOptions;
    DWORD dwResult;

    for (OptionType = 1; OptionType <= LCP_OPTION_LIMIT; OptionType++) {
        if (Negotiate & (1 << OptionType)) {

            dwResult = MakeOption(LcpOptions, OptionType,
                    (PPP_OPTION*)pOptions, cbOptionLength);

            if (dwResult != NO_ERROR) {
                return dwResult;
            }

            cbOptionLength -= ((PPP_OPTION*)pOptions)->Length;
            pOptions += ((PPP_OPTION*)pOptions)->Length;
        }
    }
    *pcbOptions -= cbOptionLength;

    return NO_ERROR;
}

/***************************************************************************\
* LcpMakeConfigResult
*
\***************************************************************************/

DWORD LcpMakeConfigResult(PPP_CONFIG *pRecvConfig, PPP_CONFIG *pSendConfig,
        DWORD cbSendConfig, BOOL fRejectNaks)
{
    DWORD dwDesired;
    DWORD dwRetCode;
    DWORD ResultType = CONFIG_ACK;
    PPP_OPTION *pRecvOption = (PPP_OPTION*)pRecvConfig->Data;
    PPP_OPTION *pSendOption = (PPP_OPTION*)pSendConfig->Data;
    LONG lSendLength = cbSendConfig - PPP_CONFIG_HDR_LEN;
    LONG lRecvLength = WireToHostFormat16(pRecvConfig->Length) - PPP_CONFIG_HDR_LEN;

    // Clear negotiate mask
    gLcp.Remote.Work.Negotiate = 0;

    while (lRecvLength > 0) {

        if (pRecvOption->Length == 0) {
            return ERROR_PPP_INVALID_PACKET;
        }

        lRecvLength -= pRecvOption->Length;

        if (lRecvLength < 0 ) {
            return ERROR_PPP_INVALID_PACKET;
        }

        dwRetCode = CheckOption(&gLcp.Remote, pRecvOption, TRUE);

        // If we were building an ACK and we got a NAK or reject OR
        // we were building a NAK and we got a reject.
        if ((ResultType == CONFIG_ACK && dwRetCode != CONFIG_ACK) ||
                (ResultType == CONFIG_NAK && dwRetCode == CONFIG_REJ)) {
            ResultType  = dwRetCode;
            pSendOption = (PPP_OPTION*)pSendConfig->Data;
            lSendLength = cbSendConfig - PPP_CONFIG_HDR_LEN;
        }

        // Remember that we processed this option
        if (dwRetCode != CONFIG_REJ && pRecvOption->Type <= LCP_OPTION_LIMIT) {
            gLcp.Remote.Work.Negotiate |= (1 << pRecvOption->Type);
        }

        if (dwRetCode == ResultType) {

            // If this option is to be rejected, simply copy the
            // rejected option to the send buffer
            if (dwRetCode == CONFIG_REJ  ||
                    (dwRetCode == CONFIG_NAK && fRejectNaks)) {
                CopyMemory(pSendOption, pRecvOption, pRecvOption->Length);
            } else {

                dwRetCode = MakeOption(&gLcp.Remote.Work, pRecvOption->Type,
                        pSendOption, lSendLength);

                if (dwRetCode != NO_ERROR) {
                    return dwRetCode;
                }
            }

            lSendLength -= pSendOption->Length;

            pSendOption  = (PPP_OPTION*)((BYTE*)pSendOption + pSendOption->Length);
        }

        pRecvOption = (PPP_OPTION*)((BYTE*)pRecvOption + pRecvOption->Length);
    }

    // If this was an NAK and we cannot send any more NAKS then we
    // make this a REJECT packet
    if (ResultType == CONFIG_NAK && fRejectNaks) {
        pSendConfig->Code = CONFIG_REJ;
    } else {
        pSendConfig->Code = (BYTE)ResultType;
    }

    HostToWireFormat16((WORD)(cbSendConfig - lSendLength), pSendConfig->Length);

    if (ResultType == CONFIG_NAK && gLcp.dwMagicNumberFailureCount > 3) {
        return ERROR_PPP_LOOPBACK_DETECTED;
    }

    return NO_ERROR;
}

/***************************************************************************\
* LcpMakeConfigRequest
*
\***************************************************************************/

DWORD LcpMakeConfigRequest(PPP_CONFIG *pConfig, DWORD cbConfig)
{
    DWORD dwRetCode;

    cbConfig -= PPP_CONFIG_HDR_LEN;

    dwRetCode = BuildOptionList(pConfig->Data, &cbConfig, &gLcp.Local.Work,
            gLcp.Local.Work.Negotiate);

    if (dwRetCode != NO_ERROR) {
        return dwRetCode;
    }

    HostToWireFormat16((WORD)(cbConfig + PPP_CONFIG_HDR_LEN), pConfig->Length);

    return NO_ERROR;
}

/***************************************************************************\
* LcpConfigAckReceived
*
\***************************************************************************/

DWORD LcpConfigAckReceived(PPP_CONFIG *pConfig)
{
    DWORD dwRetCode;
    BYTE ConfigReqSent[LCP_DEFAULT_MRU];
    PPP_OPTION *pOption = (PPP_OPTION*)pConfig->Data;
    DWORD cbConfigReqSent = sizeof(ConfigReqSent);
    DWORD dwLength;
            
    dwLength = WireToHostFormat16(pConfig->Length) - PPP_CONFIG_HDR_LEN;

    // Get a copy of last request we sent
    dwRetCode = BuildOptionList(ConfigReqSent, &cbConfigReqSent,
            &gLcp.Local.Work, gLcp.Local.Work.Negotiate);

    if (dwRetCode != NO_ERROR) {
        return dwRetCode;
    }

    if (dwLength != cbConfigReqSent) {
        return ERROR_PPP_INVALID_PACKET;
    }

    if (memcmp(ConfigReqSent, pConfig->Data, dwLength) != 0) {
        return ERROR_PPP_INVALID_PACKET;
    }

    return NO_ERROR;
}

/***************************************************************************\
* LcpConfigNakReceived
*
\***************************************************************************/

DWORD LcpConfigNakReceived(PPP_CONFIG *pConfig)
{
    LONG cbConfig = WireToHostFormat16(pConfig->Length) - PPP_CONFIG_HDR_LEN;
    PPP_OPTION *pOption = (PPP_OPTION*)pConfig->Data;
    DWORD dwLastOption = 0;
    DWORD dwResult;

    while (cbConfig > 0) {

        if (pOption->Length == 0) {
            return ERROR_PPP_INVALID_PACKET;
        }

        cbConfig -= pOption->Length;

        if (cbConfig < 0) {
            return ERROR_PPP_INVALID_PACKET;
        }

        // If this option wasn't requested, mark it as negotiable.
        if (pOption->Type <= LCP_OPTION_LIMIT &&
                (gLcp.Local.WillNegotiate & (1 << pOption->Type)) &&
                !(gLcp.Local.Work.Negotiate & (1 << pOption->Type))) {
            gLcp.Local.Work.Negotiate |= (1 << pOption->Type);
        }

        dwLastOption = pOption->Type;

        dwResult = CheckOption(&gLcp.Local, pOption, FALSE);

        if (dwResult == CONFIG_REJ && pOption->Type <= LCP_OPTION_LIMIT) {
            gLcp.Local.Work.Negotiate &= ~(1 << pOption->Type);
        }

        pOption = (PPP_OPTION*)((BYTE*)pOption + pOption->Length);
    }

    return NO_ERROR;
}

/***************************************************************************\
* LcpConfigRejReceived
*
\***************************************************************************/

DWORD LcpConfigRejReceived(PPP_CONFIG *pConfig)
{
    LONG cbConfig = WireToHostFormat16(pConfig->Length) - PPP_CONFIG_HDR_LEN;
    PPP_OPTION *pOption = (PPP_OPTION*)pConfig->Data;
    DWORD dwLastOption = 0;
    DWORD dwResult;
    BYTE ReqOption[LCP_DEFAULT_MRU];

    while (cbConfig > 0) {

        if (pOption->Length == 0) {
            return ERROR_PPP_INVALID_PACKET;
        }

        cbConfig -= pOption->Length;

        if (cbConfig < 0) {
            return ERROR_PPP_INVALID_PACKET;
        }

        // Can't receive an option out of order or an option that wasn't
        // requested.
        if (pOption->Type <= LCP_OPTION_LIMIT &&
                (pOption->Type < dwLastOption ||
                !(gLcp.Local.Work.Negotiate & (1 << pOption->Type)))) {
            return ERROR_PPP_INVALID_PACKET;
        }

        dwResult = MakeOption(&gLcp.Local.Work, pOption->Type,
                (PPP_OPTION*)ReqOption, sizeof(ReqOption));

        if (dwResult != NO_ERROR) {
            return dwResult;
        }

        if (memcmp(ReqOption, pOption, pOption->Length) != 0) {
            return ERROR_PPP_INVALID_PACKET;
        }

        dwLastOption = pOption->Type;

        if (pOption->Type <= LCP_OPTION_LIMIT) {
            gLcp.Local.Work.Negotiate &= ~(1 << pOption->Type);
        }

        pOption = (PPP_OPTION*)((BYTE*)pOption + pOption->Length);
    }

    return NO_ERROR;
}

/***************************************************************************\
* LcpThisLayerUp
*
\***************************************************************************/

DWORD LcpThisLayerUp(VOID)
{
    if (gLcp.Local.Work.Negotiate & LCP_N_ACCM) {
        gFraming.RecvAccm = gLcp.Local.Work.ACCM;
    }
    if (gLcp.Local.Work.Negotiate & LCP_N_PFC) {
        gFraming.fRecvPfc = gLcp.Local.Work.PFC;
    }
    if (gLcp.Local.Work.Negotiate & LCP_N_ACFC) {
        gFraming.fRecvAcfc = gLcp.Local.Work.ACFC;
    }

    if (gLcp.Remote.Work.Negotiate & LCP_N_ACCM) {
        gFraming.SendAccm = gLcp.Remote.Work.ACCM;
    }
    if (gLcp.Remote.Work.Negotiate & LCP_N_PFC) {
        gFraming.fSendPfc = gLcp.Remote.Work.PFC;
    }
    if (gLcp.Remote.Work.Negotiate & LCP_N_ACFC) {
        gFraming.fSendAcfc = gLcp.Remote.Work.ACFC;
    }

    return NO_ERROR;
}

/***************************************************************************\
* LcpThisLayerDown
*
\***************************************************************************/

DWORD LcpThisLayerDown(VOID)
{
    if (gLcp.Local.Work.Negotiate & LCP_N_ACCM) {
        gFraming.RecvAccm = gLcpDefault.ACCM;
    }
    if (gLcp.Local.Work.Negotiate & LCP_N_PFC) {
        gFraming.fRecvPfc = gLcpDefault.PFC;
    }
    if (gLcp.Local.Work.Negotiate & LCP_N_ACFC) {
        gFraming.fRecvAcfc = gLcpDefault.ACFC;
    }

    if (gLcp.Remote.Work.Negotiate & LCP_N_ACCM) {
        gFraming.SendAccm = gLcpDefault.ACCM;
    }
    if (gLcp.Remote.Work.Negotiate & LCP_N_PFC) {
        gFraming.fSendPfc = gLcpDefault.PFC;
    }
    if (gLcp.Remote.Work.Negotiate & LCP_N_ACFC) {
        gFraming.fSendAcfc = gLcpDefault.ACFC;
    }

    return NO_ERROR;
}

/***************************************************************************\
* LcpEnd
*
\***************************************************************************/

DWORD LcpEnd(VOID)
{
    if (gLcp.Local.Work.pAPData != NULL) {
        Free(gLcp.Local.Work.pAPData);
    }
    if (gLcp.Remote.Work.pAPData != NULL) {
        Free(gLcp.Remote.Work.pAPData);
    }
    return NO_ERROR;
}

/***************************************************************************\
* LcpBegin
*
\***************************************************************************/

DWORD LcpBegin(VOID)
{
    CopyMemory(&gLcp.Local.Want, &gLcpDefault, sizeof(LCP_OPTIONS));
    CopyMemory(&gLcp.Remote.Want, &gLcpDefault, sizeof(LCP_OPTIONS));

    gLcp.Local.WillNegotiate = gLcpNegotiate;
    gLcp.Remote.WillNegotiate = gLcpNegotiate;

    gLcp.Remote.APsAvailable = LCP_AP_PAP;

    gLcp.Local.Want.MagicNumber = GetMagicNumber();
    gLcp.Remote.Want.MagicNumber = gLcp.Local.Want.MagicNumber + 1;

    gLcp.Local.Want.ACCM = 0;
    gLcp.Local.Want.PFC = TRUE;
    gLcp.Local.Want.ACFC = TRUE;

    gLcp.Remote.Want.ACCM = 0;
    gLcp.Remote.Want.PFC = TRUE;
    gLcp.Remote.Want.ACFC = TRUE;

    gLcp.Local.Want.Negotiate = (LCP_N_MAGIC | LCP_N_ACCM | LCP_N_PFC | LCP_N_ACFC);
    gLcp.Remote.Want.Negotiate = (LCP_N_MAGIC | LCP_N_ACCM | LCP_N_PFC | LCP_N_ACFC);

    CopyMemory(&gLcp.Local.Work, &gLcp.Local.Want, sizeof(LCP_OPTIONS));
    CopyMemory(&gLcp.Remote.Work, &gLcp.Remote.Want, sizeof(LCP_OPTIONS));

    return NO_ERROR;
}

/***************************************************************************\
* GetLcpInfo
*
\***************************************************************************/

VOID GetLcpInfo(PPP_CP_INFO *pInfo)
{
    ZeroMemory(pInfo, sizeof(PPP_CP_INFO));
    pInfo->Protocol = PPP_LCP_PROTOCOL;
    pInfo->Recognize = DISCARD_REQ;
    pInfo->CP_Begin = LcpBegin;
    pInfo->CP_End = LcpEnd;
    pInfo->CP_ThisLayerDown = LcpThisLayerDown;
    pInfo->CP_ThisLayerUp = LcpThisLayerUp;
    pInfo->CP_ConfigNakReceived = LcpConfigNakReceived;
    pInfo->CP_ConfigRejReceived = LcpConfigRejReceived;
    pInfo->CP_ConfigAckReceived = LcpConfigAckReceived;
    pInfo->CP_MakeConfigResult = LcpMakeConfigResult;
    pInfo->CP_MakeConfigRequest = LcpMakeConfigRequest;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\ppp\lcp.h ===
#ifndef __LCP_H__
#define __LCP_H__

#define LCP_DEFAULT_MRU         1500

#define LCP_OPTION_MRU          0x01
#define LCP_OPTION_ACCM         0x02
#define LCP_OPTION_AUTHENT      0x03
#define LCP_OPTION_MAGIC        0x05
#define LCP_OPTION_PFC          0x07
#define LCP_OPTION_ACFC         0x08
#define LCP_OPTION_CALLBACK     0x0D
#define LCP_OPTION_MRRU         0x11
#define LCP_OPTION_SHORT_SEQ    0x12
#define LCP_OPTION_ENDPOINT     0x13
#define LCP_OPTION_LINK_DISCRIM 0x17
#define LCP_OPTION_LIMIT        0x17    // highest # we can handle

#define LCP_N_MRU               (1 << LCP_OPTION_MRU)
#define LCP_N_ACCM              (1 << LCP_OPTION_ACCM)
#define LCP_N_AUTHENT           (1 << LCP_OPTION_AUTHENT)
#define LCP_N_MAGIC             (1 << LCP_OPTION_MAGIC)
#define LCP_N_PFC               (1 << LCP_OPTION_PFC)
#define LCP_N_ACFC              (1 << LCP_OPTION_ACFC)
#define LCP_N_CALLBACK          (1 << LCP_OPTION_CALLBACK)
#define LCP_N_MRRU              (1 << LCP_OPTION_MRRU)
#define LCP_N_SHORT_SEQ         (1 << LCP_OPTION_SHORT_SEQ)
#define LCP_N_ENDPOINT          (1 << LCP_OPTION_ENDPOINT)
#define LCP_N_LINK_DISCRIM      (1 << LCP_OPTION_LINK_DISCRIM)

#define  LCP_AP_FIRST           0x00000001
#define  LCP_AP_EAP             0x00000001
#define  LCP_AP_CHAP_MS_NEW     0x00000002
#define  LCP_AP_CHAP_MS         0x00000004
#define  LCP_AP_CHAP_MD5        0x00000008
#define  LCP_AP_SPAP_NEW        0x00000010
#define  LCP_AP_SPAP_OLD        0x00000020
#define  LCP_AP_PAP             0x00000040
#define  LCP_AP_MAX             0x00000080

// Local.Want - options to request, contains desired values, only
// non-default options need to be negotiated.
// Local.WillNegotiate - options to accept in a NAK from remote.
// Local.Work - options currently being negotiated
// Remote.Want - options to suggest by NAK if not present in REQ.
// Remote.WillNegotiate - options to accept in a REQ from remote.
// Remote.Work - options currently being negotiated.

typedef struct _LCP_OPTIONS {

    DWORD Negotiate;            // negotiation flags
    DWORD MRU;                  // Maximum Receive Unit
    DWORD ACCM;                 // Async Control Char Map
    DWORD AP;                   // Authentication protocol
    DWORD APDataSize;           // Auth. protocol data size in bytes
    PBYTE pAPData;              // Pointer Auth. protocol data
    DWORD MagicNumber;          // Magic number value
    DWORD PFC;                  // Protocol field compression.
    DWORD ACFC;                 // Address and Control Field Compression.
    DWORD Callback;             // Callback
    DWORD MRRU;                 // Maximum Reconstructed Receive Unit
    DWORD ShortSequence;        // Short Sequence Number Header Format
    BYTE  EndpointDiscr[21];    // Endpoint Discriminator.
    DWORD dwEDLength;           // Length of Endpoint Discriminator
    DWORD dwLinkDiscriminator;  // Link Discriminator (for BAP/BACP)

} LCP_OPTIONS;

typedef struct _LCP_SIDE {
    DWORD WillNegotiate;
    DWORD APsAvailable;
    LCP_OPTIONS Want;
    LCP_OPTIONS Work;
} LCP_SIDE;

typedef struct _LCP_INFO {
    LCP_SIDE Local;
    LCP_SIDE Remote;
    DWORD dwMagicNumberFailureCount;
} LCP_INFO;

#endif __LCP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\ppp\modem.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

    init.cpp

Abstract:

    XBox PPP initialization routines.

Revision History:

    07-11-00    vadimg      created

--*/

#include "precomp.h"

/***************************************************************************\
* ModemCommand
*
\***************************************************************************/

BOOL ModemCommand(const CHAR *pszCommand, const CHAR *pszResponse)
{
    char buffer[MODEM_BUFFER_SIZE];
    ULONG cb = strlen(pszCommand);

    if (!ModemWrite((PUCHAR)pszCommand, &cb)) {
        return FALSE;
    }

    DbgPrint("WRITE: %s\n", pszCommand);

    if (WaitForSingleObject(gQueue.hEvent, READ_TIMEOUT) != WAIT_OBJECT_0) {
        return FALSE;
    }

    cb = MODEM_BUFFER_SIZE;
    if (!ModemRead((PUCHAR)buffer, &cb) || cb == 0) {
        return FALSE;
    }
    buffer[cb] = '\0';

    DbgPrint("READ: %s\n", buffer);

    if (str_search(buffer, pszResponse) == NULL) {
        return FALSE;
    }

    DbgPrint("RESPONSE: %s\n", pszResponse);
    return TRUE;
}

/***************************************************************************\
* InitModem
*
\***************************************************************************/

BOOL InitModem(VOID)
{
    if (!ModemOpen(gQueue.hEvent)) {
        return FALSE;
    }

    if (!ModemSetLineCoding(57600, 0, 0, 8)) {
        return FALSE;
    }

    if (!ModemCommand("AT &F E0 &C1 &D2 V1 S0=0\r", "OK")) {
        return FALSE;
    }

    if (!ModemCommand("ATS7=60S30=0L0M1\\N3%C1&K3N1X4\r", "OK")) {
        return FALSE;
    }

    return TRUE;
}

/***************************************************************************\
* DialModem
*
\***************************************************************************/

BOOL DialModem(VOID)
{
    char buffer[MODEM_BUFFER_SIZE];
    char *p = buffer;

    p = str_add(p, "ATDT");
    p = str_add(p, gInfo.szNumber);
    str_add(p, "\r");

    return ModemCommand(buffer, "CONNECT");
}

/***************************************************************************\
* HangupModem
*
\***************************************************************************/

BOOL HangupModem(VOID)
{
    return ModemCommand("ATH0\r", "OK");
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\ppp\misc.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

    misc.cpp

Abstract:

    Misc support functions.

Revision History:

    07-17-00    vadimg      created

--*/

#include "precomp.h"

/***************************************************************************\
* InitRestartCounters
*
\***************************************************************************/

VOID InitRestartCounters(VOID)
{
    gInfo.ConfigRetryCount = PPP_MAX_FAILURE;
    gInfo.TermRetryCount   = PPP_MAX_FAILURE;
}

/***************************************************************************\
* GetCpIndexFromProtocol
*
\***************************************************************************/

DWORD GetCpIndexFromProtocol(DWORD dwProtocol)
{
    DWORD i;

    for (i = 0; i < NUM_CP; i++) {
        if (gCpTable[i].Protocol == dwProtocol) {
            return i;
        }
    }

    return (DWORD)-1;
}

/***************************************************************************\
* ReverseString
*
\***************************************************************************/

VOID ReverseString(CHAR *psz)
{
    CHAR *pchBegin, *pchEnd, ch;

    pchBegin = psz;
    pchEnd = psz + strlen(psz) - 1;

    while (pchBegin < pchEnd) {

        ch = *pchBegin;
        *pchBegin = *pchEnd;
        *pchEnd = ch;

        ++pchBegin;
        --pchEnd;
    }
}

/***************************************************************************\
* EncodePw
*
\***************************************************************************/

#define PASSWORDMAGIC 0xA5

VOID EncodePw(CHAR* pszPassword)
{
    CHAR *pch;

    ReverseString(pszPassword);

    for (pch = pszPassword; *pch != '\0'; ++pch) {
        if (*pch != (CHAR)PASSWORDMAGIC) {
            *pch ^= PASSWORDMAGIC;
        }
    }
}

/***************************************************************************\
* DecodePw
*
\***************************************************************************/

VOID DecodePw(CHAR* pszPassword)
{
    EncodePw(pszPassword);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\ppp\ncp.h ===
#ifndef __NCP_H__
#define __NCP_H__

#define MAX_IPCP_CODE 7

#define IPCP_IpCompression          2
#define IPCP_IpAddress              3
#define IPCP_DnsIpAddress           129

#define IPADDRESSOPTIONLEN          6
#define IPCOMPRESSIONOPTIONLEN      6

#endif // __NCP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\ppp\net.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

    net.cpp

Abstract:

    Network stack integration code.

Revision History:

    07-27-00    vadimg      created

--*/

#include "precomp.h"

/***************************************************************************\
* PppDeleteProc
*
\***************************************************************************/

VOID PppDeleteProc(IfInfo *ifp)
{
    while (!PktQIsEmpty(&ifp->sendq)) {
        Packet* pkt = PktQRemoveHead(&ifp->sendq);
        XnetCompletePacket(pkt, NETERR_CANCELLED);
    }
    SysFree(ifp);
}

/***************************************************************************\
* PppStartOutputProc
*
\***************************************************************************/

VOID PppStartOutputProc(IfInfo *ifp)
{
    Packet *pkt;
    PPP_PACKET *pSendPacket = GetSendPacket();

    while (!PktQIsEmpty(&ifp->sendq)) {
        pkt = IfDequeuePacket(ifp);

        pSendPacket->Protocol[0] = 0x00;
        pSendPacket->Protocol[1] = 0x21;

        CopyMemory(pSendPacket->Data, pkt->data, pkt->datalen);

        SendFrame(pkt->datalen + 2);

        XnetCompletePacket(pkt, NO_ERROR);
    }
}

/***************************************************************************\
* PppIoctlProc
*
* Arguments:
*
*   ifp - Points to the interface structure
*   ctlcode - Control code
*   inbuf - Points to the input buffer
*   inlen - Size of the input buffer
*   outbuf - Points to the output buffer
*   outlen - On entry, this contains the size of the output buffer
*       On return, this is the actually number of output bytes
*
\***************************************************************************/

NTSTATUS
PppIoctlProc(
    IfInfo* ifp,
    INT ctlcode,
    VOID* inbuf,
    UINT inlen,
    VOID* outbuf,
    UINT* outlen
    )
{
    NTSTATUS status;

    switch (ctlcode) {
    case IFCTL_GET_DNSSERVERS:
        if (!inbuf || !inlen || !outbuf || !outlen || *outlen < sizeof(IPADDR)) {
            status = NETERR_PARAM;
        } else {
            //
            // NOTE: we're using the inbuf to return the default domain name string.
            // outbuf is used to return the default DNS server addresses.
            //
            *((CHAR*) inbuf) = 0;
            *outlen = sizeof(IPADDR);
            *((IPADDR*) outbuf) = gIp.IpAddrDns;
            status = NETERR_OK;
        }
        break;

    default:
        status = NETERR_NOTIMPL;
        break;
    }

    return status;
}

/***************************************************************************\
* InitNet
*
\***************************************************************************/

BOOL InitNet(VOID)
{
    DbgPrint("PPP: setting IP and DNS\n");

    gIp.ifp = (IfInfo*) SysAlloc0(sizeof(IfInfo), 'PPP0');
    if (gIp.ifp == NULL) {
        return FALSE;
    }

    gIp.ifp->refcount = 1;
    gIp.ifp->ifname = "Dialup";
    gIp.ifp->flags = IFFLAG_UP;
    gIp.ifp->Delete = PppDeleteProc;
    gIp.ifp->StartOutput = PppStartOutputProc;
    gIp.ifp->Ioctl = PppIoctlProc;

    IfSetIpAddr(gIp.ifp, gIp.IpAddrLocal, 0);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\ppp\ncp.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

    ncp.cpp

Abstract:

    Network control protocol and IPCP implementation.

Revision History:

    07-27-00    vadimg      created

--*/

#include "precomp.h"

/***************************************************************************\
* NcpStart
*
\***************************************************************************/

BOOL NcpStart(DWORD CpIndex)
{
    if (!FsmInit(CpIndex)) {
        return FALSE;
    }

    FsmOpen(CpIndex);
    FsmUp(CpIndex);

    return TRUE;
}

/***************************************************************************\
* NcpReset
*
\***************************************************************************/

VOID NcpReset(VOID)
{
    gIp.IpAddrRemote = 0;
    gIp.IpAddrLocal = 0;
    gIp.IpAddrDns = 0;
}

/***************************************************************************\
* AddIpAddressOption
*
\***************************************************************************/

VOID AddIpAddressOption(BYTE *pBuf, BYTE bOption, IPADDR ipaddr)
{
    *pBuf++ = bOption;
    *pBuf++ = IPADDRESSOPTIONLEN;
    *((IPADDR*)pBuf) = ipaddr;
}

/***************************************************************************\
* RejectCheck
*
\***************************************************************************/

DWORD RejectCheck(PPP_CONFIG* pRecvBuf, PPP_CONFIG* pSendBuf, BOOL *pfRej)
{
    PPP_OPTION *pROption = (PPP_OPTION*)pRecvBuf->Data;
    PPP_OPTION *pSOption = (PPP_OPTION*)pSendBuf->Data;
    WORD cbPacket = WireToHostFormat16(pRecvBuf->Length);
    WORD cbLeft = cbPacket - PPP_CONFIG_HDR_LEN;

    *pfRej = FALSE;

    while (cbLeft > 0) {

        if (cbLeft < pROption->Length) {
            return ERROR_PPP_INVALID_PACKET;
        }

        if (pROption->Type == IPCP_IpCompression) {

            *pfRej = TRUE;
            CopyMemory((VOID*)pSOption, (VOID*)pROption, pROption->Length);
            pSOption = (PPP_OPTION*)((BYTE*)pSOption + pROption->Length);

        } else {

            IPADDR ipaddr;

            BOOL fBad = (pROption->Type != IPCP_IpAddress || 
                    pROption->Length != IPADDRESSOPTIONLEN);

            if (!fBad) {
                CopyMemory(&ipaddr, pROption->Data, sizeof(IPADDR));
            }

            if (fBad || ipaddr == 0) {

                *pfRej = TRUE;

                CopyMemory((VOID*)pSOption, (VOID*)pROption, pROption->Length);
                pSOption = (PPP_OPTION*)((BYTE*)pSOption + pROption->Length);

            } else {
                gIp.IpAddrRemote = ipaddr;
            }
        }

        if (pROption->Length && pROption->Length < cbLeft) {
            cbLeft -= pROption->Length;
        } else {
            cbLeft = 0;
        }

        pROption = (PPP_OPTION*)((BYTE*)pROption + pROption->Length);
    }

    if (*pfRej) {
        pSendBuf->Code = CONFIG_REJ;
        HostToWireFormat16((WORD)((BYTE*)pSOption - (BYTE*)pSendBuf), pSendBuf->Length);
    }

    return NO_ERROR;
}

/***************************************************************************\
* IpcpMakeConfigRequest
*
\***************************************************************************/

DWORD IpcpMakeConfigRequest(PPP_CONFIG *pSendConfig, DWORD cbSendConfig)
{
    BYTE *pb = pSendConfig->Data;
    WORD cbPacket = PPP_CONFIG_HDR_LEN;

    AddIpAddressOption(pb, IPCP_IpAddress, gIp.IpAddrLocal);
    cbPacket += IPADDRESSOPTIONLEN;
    pb += IPADDRESSOPTIONLEN;

    AddIpAddressOption(pb, IPCP_DnsIpAddress, gIp.IpAddrDns);
    cbPacket += IPADDRESSOPTIONLEN;
    pb += IPADDRESSOPTIONLEN;

    HostToWireFormat16(cbPacket, pSendConfig->Length);

    return NO_ERROR;
}

/***************************************************************************\
* IpcpMakeConfigResult
*
\***************************************************************************/

DWORD IpcpMakeConfigResult(PPP_CONFIG *pRecvBuf, PPP_CONFIG *pSendBuf,
        DWORD cbSendBuf, BOOL fRejectNaks)
{
    DWORD dwErr;
    BOOL fRej;
    WORD cbPacket;

    dwErr = RejectCheck(pRecvBuf, pSendBuf, &fRej);
    if (dwErr != 0) {
        return dwErr;
    }

    if (fRej) {
        return NO_ERROR;
    }

    cbPacket = WireToHostFormat16(pRecvBuf->Length);
    CopyMemory(pSendBuf, pRecvBuf, cbPacket);
    pSendBuf->Code = CONFIG_ACK;

    return 0;
}

/***************************************************************************\
* IpcpConfigAckReceived
*
\***************************************************************************/

DWORD IpcpConfigAckReceived(PPP_CONFIG *pRecvBuf)
{
    return NO_ERROR;
}

/***************************************************************************\
* IpcpConfigRejReceived
*
\***************************************************************************/

DWORD IpcpConfigRejReceived(PPP_CONFIG *pRecvBuf)
{
    return NO_ERROR;
}

/***************************************************************************\
* IpcpConfigNakReceived
*
\***************************************************************************/

DWORD IpcpConfigNakReceived(PPP_CONFIG* pRecvBuf)
{
    PPP_OPTION *pROption = (PPP_OPTION*)pRecvBuf->Data;
    WORD cbPacket = WireToHostFormat16(pRecvBuf->Length);
    WORD cbLeft = cbPacket - PPP_CONFIG_HDR_LEN;
    IPADDR ipaddr;

    while (cbLeft > 0) {

        if (cbLeft < pROption->Length) {
            return ERROR_PPP_INVALID_PACKET;
        }

        switch (pROption->Type) {
        case IPCP_IpAddress:
            if (pROption->Length != IPADDRESSOPTIONLEN) {
                return ERROR_PPP_INVALID_PACKET;
            }

            CopyMemory(&ipaddr, pROption->Data, sizeof(IPADDR));

            if (ipaddr == 0) {
                return ERROR_PPP_INVALID_PACKET;
            }

            gIp.IpAddrLocal = ipaddr;
            break;

        case IPCP_DnsIpAddress:
            if (pROption->Length != IPADDRESSOPTIONLEN) {
                return ERROR_PPP_INVALID_PACKET;
            }

            CopyMemory(&gIp.IpAddrDns, pROption->Data, sizeof(IPADDR));
            break;
        }

        if (pROption->Length && pROption->Length < cbLeft) {
            cbLeft -= pROption->Length;
        } else {
            cbLeft = 0;
        }

        pROption = (PPP_OPTION*)((BYTE*)pROption + pROption->Length);
    }

    return NO_ERROR;
}

/***************************************************************************\
* IpcpBegin
*
\***************************************************************************/

DWORD IpcpBegin(VOID)
{
    return NO_ERROR;
}

/***************************************************************************\
* IpcpEnd
*
\***************************************************************************/

DWORD IpcpEnd(VOID)
{
    return NO_ERROR;
}

/***************************************************************************\
* GetIpcpInfo
*
\***************************************************************************/

VOID GetIpcpInfo(PPP_CP_INFO *pInfo)
{
    ZeroMemory(pInfo, sizeof(PPP_CP_INFO));
    pInfo->Protocol = PPP_IPCP_PROTOCOL;
    pInfo->Recognize = MAX_IPCP_CODE;
    pInfo->CP_Begin = IpcpBegin;
    pInfo->CP_End = IpcpEnd;
    pInfo->CP_MakeConfigRequest = IpcpMakeConfigRequest;
    pInfo->CP_MakeConfigResult = IpcpMakeConfigResult;
    pInfo->CP_ConfigAckReceived = IpcpConfigAckReceived;
    pInfo->CP_ConfigRejReceived = IpcpConfigRejReceived;
    pInfo->CP_ConfigNakReceived = IpcpConfigNakReceived;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\ppp\pap.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

    pap.cpp

Abstract:

    Password authentication protocol.

Revision History:

    07-26-00    vadimg      created

--*/

#include "precomp.h"

/***************************************************************************\
* PapBegin
*
\***************************************************************************/

DWORD PapBegin(VOID)
{
    gAp.State = PS_Initial;
    return NO_ERROR;
}

/***************************************************************************\
* PapEnd
*
\***************************************************************************/

DWORD PapEnd(VOID)
{
    return NO_ERROR;
}

/***************************************************************************\
* PapMakeRequestMessage
*
\***************************************************************************/

VOID PapMakeRequestMessage(PPP_CONFIG *pSendBuf)
{
    BYTE *pcbPeerId;
    BYTE *pcbPassword;
    WORD wLength;
    CHAR szAccount[DNLEN + 1 + UNLEN + 1];
    char *p = szAccount;

    if (gInfo.szDomain[0] != '\0') {
        p = str_add(p, gInfo.szDomain);
        p = str_add(p, "\\");
    }
    str_add(p, gInfo.szUsername);

    pcbPeerId = pSendBuf->Data;
    *pcbPeerId = (BYTE)strlen(szAccount);
    strcpy((char*)(pcbPeerId + 1), szAccount);

    pcbPassword = pcbPeerId + 1 + *pcbPeerId;
    *pcbPassword = (BYTE)strlen(gInfo.szPassword);
    strcpy((char*)(pcbPassword + 1), gInfo.szPassword);

    pSendBuf->Code = (BYTE)PAPCODE_Req;
    pSendBuf->Id = GetId();

    wLength = (WORD)(PPP_CONFIG_HDR_LEN + 1 + *pcbPeerId + 1 + *pcbPassword);
    HostToWireFormat16(wLength, pSendBuf->Length);
}

/***************************************************************************\
* PapMakeMessage
*
\***************************************************************************/

DWORD PapMakeMessage(PPP_CONFIG *pRecvBuf)
{
    PPP_PACKET *pSendPacket = GetSendPacket();
    PPP_CONFIG *pSendConfig = (PPP_CONFIG*)pSendPacket->Data;

    if (pRecvBuf == NULL && gAp.State != PS_Initial) {
        gAp.State = PS_Initial;
    }

    switch (gAp.State) {
    case PS_Initial:
        PapMakeRequestMessage(pSendConfig);
        gAp.Action = AP_SendWithTimeout;
        gAp.State = PS_RequestSent;
        break;

    case PS_RequestSent:
        if (pRecvBuf->Code == PAPCODE_Ack) {
            gInfo.dwError = 0;
            gAp.Action = AP_Done;
            gAp.State = PS_Done;
        } else if (pRecvBuf->Code == PAPCODE_Nak) {
            gInfo.dwError = ERROR_AUTHENTICATION_FAILURE;
            gAp.Action = AP_Done;
            gAp.State = PS_Done;
        } else {
            gAp.Action = AP_NoAction;
        }
    }

    return NO_ERROR;
}

/***************************************************************************\
* GetPapInfo
*
\***************************************************************************/

VOID GetPapInfo(PPP_CP_INFO *pInfo)
{
    ZeroMemory(pInfo, sizeof(PPP_CP_INFO));
    pInfo->Protocol = PPP_PAP_PROTOCOL;
    pInfo->Recognize = MAX_PAP_CODE;
    pInfo->CP_Begin = PapBegin;
    pInfo->CP_End = PapEnd;
    pInfo->CP_MakeMessage = PapMakeMessage;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\ppp\pap.h ===
#ifndef __PAP_H__
#define __PAP_H__

// PAP packet codes from PAP spec.
#define PAPCODE_Req 1
#define PAPCODE_Ack 2
#define PAPCODE_Nak 3

#define MAX_PAP_CODE  3

typedef enum _PAP_STATE {
    PS_Initial,
    PS_RequestSent,
    PS_WaitForRequest,
    PS_WaitForAuthenticationToComplete,
    PS_Done
} PAP_STATE;

#endif // __PAP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\ppp\precomp.h ===
#include <xnetp.h>

extern "C" {
#include <lmcons.h>
#include <xmodem.h>
#include <xppp.h>
}

#include "ppp.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\ppp\receive.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

    receive.cpp

Abstract:

    Handle received packets.

Revision History:

    07-18-00    vadimg      created

--*/

#include "precomp.h"

VOID (*gReceive[])(DWORD CpIndex, PPP_CONFIG *pRecvConfig) = {
        NULL,
        ReceiveConfigReq,
        ReceiveConfigAck,
        ReceiveConfigNakRej,
        ReceiveConfigNakRej,
        ReceiveTermReq,
        ReceiveTermAck,
        ReceiveCodeRej,
        NULL,
        ReceiveEchoReq,
        ReceiveEchoReply,
        ReceiveDiscardReq
};

/***************************************************************************\
* ReceiveConfigReq
*
\***************************************************************************/

VOID ReceiveConfigReq(DWORD CpIndex, PPP_CONFIG *pRecvConfig)
{
    PPP_PACKET *pSendPacket = GetSendPacket();
    PPP_CONFIG *pSendConfig = (PPP_CONFIG*)pSendPacket->Data;
    BOOL fAcked;

    switch (gInfo.State) {
    case FSM_OPENED:            
        if (!FsmThisLayerDown(CpIndex)) {
            return;
        }
        if (!FsmSendConfigReq(CpIndex)) {
            return;
        }
        if (!FsmSendConfigResult(CpIndex, pRecvConfig, &fAcked)) {
            return;
        }

        gInfo.State = fAcked ? FSM_ACK_SENT : FSM_REQ_SENT;
        break;

    case FSM_STOPPED:

        InitRestartCounters();

        if (!FsmSendConfigReq(CpIndex)) {
            return;
        }

        // fall through

    case FSM_REQ_SENT:
    case FSM_ACK_SENT:          
        if (!FsmSendConfigResult(CpIndex, pRecvConfig, &fAcked)) {
            return;
        }

        gInfo.State = fAcked ? FSM_ACK_SENT : FSM_REQ_SENT;
        break;

    case FSM_ACK_RCVD:
        if (!FsmSendConfigResult(CpIndex, pRecvConfig, &fAcked)) {
            return;
        }

        if (fAcked) {
            gInfo.State = FSM_OPENED;
            FsmThisLayerUp(CpIndex);
        }
        break;

    case FSM_CLOSED:
        FsmSendTermAck(CpIndex, pRecvConfig);
        break;

    case FSM_CLOSING:
    case FSM_STOPPING:
        break;
    }
}

/***************************************************************************\
* ReceiveConfigAck
*
\***************************************************************************/

VOID ReceiveConfigAck(DWORD CpIndex, PPP_CONFIG *pRecvConfig)
{
    // The Id of the Ack HAS to match the Id of the last request sent
    // If it is different, then we should silently discard it.
    if (pRecvConfig->Id != gInfo.LastId) {
        return;
    }

    ClearTimeout();

    switch (gInfo.State) {
    case FSM_REQ_SENT:
        if (!FsmConfigResultReceived(CpIndex, pRecvConfig)) {
            return;
        }

        InitRestartCounters();
        gInfo.State = FSM_ACK_RCVD;
        break;

    case FSM_ACK_SENT:
        if (!FsmConfigResultReceived(CpIndex, pRecvConfig)) {
            return;
        }

        InitRestartCounters();
        gInfo.State = FSM_OPENED;
        FsmThisLayerUp(CpIndex);
        break;

    case FSM_OPENED:            
        if (!FsmThisLayerDown(CpIndex)) {
            return;
        }

        // fall through

    case FSM_ACK_RCVD:  
        if (!FsmSendConfigReq(CpIndex)) {
            return;
        }

        gInfo.State = FSM_REQ_SENT;
        break;

    case FSM_CLOSED:
    case FSM_STOPPED:
        // Out of Sync; kill the remote 
        FsmSendTermAck(CpIndex, pRecvConfig);
        break;

    case FSM_CLOSING:
    case FSM_STOPPING:
        break;
    }
}

/***************************************************************************\
* ReceiveConfigNakRej
*
\***************************************************************************/

VOID ReceiveConfigNakRej(DWORD CpIndex, PPP_CONFIG *pRecvConfig)
{
    // The Id of the Nak/Rej HAS to match the Id of the last request sent
    // If it is different, then we should silently discard it.
    if (pRecvConfig->Id != gInfo.LastId) {
        return;
    }

    ClearTimeout();

    switch (gInfo.State) {
    case FSM_REQ_SENT:
    case FSM_ACK_SENT:
        if (!FsmConfigResultReceived(CpIndex, pRecvConfig)) {
            return;
        }

        InitRestartCounters();

        if (!FsmSendConfigReq(CpIndex)) {
            return;
        }
        break;

    case FSM_OPENED:            
        if (!FsmThisLayerDown(CpIndex)) {
            return;
        }

        // fall through

    case FSM_ACK_RCVD:          
        if (!FsmSendConfigReq(CpIndex)) {
            return;
        }

        gInfo.State = FSM_REQ_SENT;
        break;

    case FSM_CLOSED:
    case FSM_STOPPED:
        // Out of Sync; kill the remote 
        FsmSendTermAck(CpIndex, pRecvConfig);
        break;

    case FSM_CLOSING:
    case FSM_STOPPING:
        break;
    }
}

/***************************************************************************\
* ReceiveTermReq
*
\***************************************************************************/

VOID ReceiveTermReq(DWORD CpIndex, PPP_CONFIG *pConfig)
{
    switch (gInfo.State) {
    case FSM_OPENED:
        if (!FsmThisLayerDown(CpIndex)) {
            return;
        }

        FsmSendTermAck(CpIndex, pConfig);
        gInfo.State = FSM_STOPPING;
        break;

    case FSM_ACK_RCVD:
    case FSM_ACK_SENT:
    case FSM_REQ_SENT:
        FsmSendTermAck(CpIndex, pConfig);
        gInfo.State = FSM_REQ_SENT;
        break;

    case FSM_CLOSED:
    case FSM_CLOSING:
    case FSM_STOPPED:
    case FSM_STOPPING:
        FsmSendTermAck(CpIndex, pConfig);
        break;
    }

    FsmThisLayerFinished(CpIndex);
}

/***************************************************************************\
* ReceiveTermAck
*
\***************************************************************************/

VOID ReceiveTermAck(DWORD CpIndex, PPP_CONFIG *pRecvConfig)
{
    // The Id of the Term Ack HAS to match the Id of the last request sent
    // If it is different, then we should silently discard it.
    if (pRecvConfig->Id != gInfo.LastId) {
        return;
    }

    switch (gInfo.State) {
    case FSM_OPENED:
        if (!FsmThisLayerDown(CpIndex)) {
            return;
        }

        if (!FsmSendConfigReq(CpIndex)) {
            return;
        }

        gInfo.State = FSM_REQ_SENT;
        break;

    case FSM_ACK_RCVD:
        gInfo.State = FSM_REQ_SENT;
        break;

    case FSM_CLOSING:
    case FSM_STOPPING:
        if (!FsmThisLayerFinished(CpIndex)) {
            return;
        }

        gInfo.State = (gInfo.State == FSM_CLOSING) ? FSM_CLOSED : FSM_STOPPED;
        break;

    case FSM_REQ_SENT:
    case FSM_ACK_SENT:
    case FSM_CLOSED:
    case FSM_STOPPED:
        break;
    }
}

/***************************************************************************\
* ReceiveUnknownCode 
*
\***************************************************************************/

VOID ReceiveUnknownCode(DWORD CpIndex, PPP_CONFIG *pConfig)
{
    switch (gInfo.State) {
    case FSM_STOPPED:
    case FSM_STOPPING:
    case FSM_OPENED:
    case FSM_ACK_SENT:
    case FSM_ACK_RCVD:
    case FSM_REQ_SENT:
    case FSM_CLOSING:
    case FSM_CLOSED:
        FsmSendCodeReject(CpIndex, pConfig);
        break;
    }
}

/***************************************************************************\
* ReceiveDiscardReq
*
\***************************************************************************/

VOID ReceiveDiscardReq(DWORD CpIndex, PPP_CONFIG *pConfig)
{
}

/***************************************************************************\
* ReceiveEchoReq
*
\***************************************************************************/

VOID ReceiveEchoReq(DWORD CpIndex, PPP_CONFIG *pConfig)
{
    // Silently discard this packet if LCP is not in an opened state
    if (!IsLcpOpened()) {
        return;
    }

    switch (gInfo.State) {
    case FSM_STOPPED:
    case FSM_STOPPING:
    case FSM_ACK_SENT:
    case FSM_ACK_RCVD:
    case FSM_REQ_SENT:
    case FSM_CLOSING:
    case FSM_CLOSED:
    case FSM_STARTING:
    case FSM_INITIAL:
        break;

    case FSM_OPENED:
        FsmSendEchoReply(CpIndex, pConfig);
        break;
    }
}

/***************************************************************************\
* ReceiveEchoReply
*
\***************************************************************************/

VOID ReceiveEchoReply(DWORD CpIndex, PPP_CONFIG *pConfig)
{
}

/***************************************************************************\
* ReceiveCodeRej
*
\***************************************************************************/

VOID ReceiveCodeRej(DWORD CpIndex, PPP_CONFIG *pConfig)
{
    pConfig = (PPP_CONFIG*)pConfig->Data;

    // First check to see if these codes may be rejected without 
    // affecting implementation. Permitted code rejects
    if (CpIndex == CP_LCP) {
        switch (pConfig->Code) {
        case CONFIG_REQ:
        case CONFIG_ACK:
        case CONFIG_NAK:
        case CONFIG_REJ:
        case TERM_REQ:
        case TERM_ACK:
        case CODE_REJ:
        case PROT_REJ:
        case ECHO_REQ:
        case ECHO_REPLY:
        case DISCARD_REQ:
            // Unpermitted code rejects.
            break;

        default:
            // Permitted code rejects, we can still work.
            switch (gInfo.State) {
            case FSM_ACK_RCVD:
                gInfo.State = FSM_REQ_SENT;
                break;
            }

            return;
        }
    }
    // Actually the remote side did not reject the protocol, it rejected
    // the code. But for all practical purposes we cannot talk with
    // the corresponding CP on the remote side. This is actually an
    // implementation error in the remote side.
    gInfo.dwError = ERROR_PPP_NOT_CONVERGING;

    switch (gInfo.State) {
    case FSM_CLOSING:
        if (!FsmThisLayerFinished(CpIndex)) {
            return;
        }
        gInfo.State = FSM_CLOSED;
        break;

    case FSM_REQ_SENT:
    case FSM_ACK_RCVD:
    case FSM_ACK_SENT:
    case FSM_STOPPING:
        if (!FsmThisLayerFinished(CpIndex)) {
            return;
        }
        gInfo.State = FSM_STOPPED;
        break;

    case FSM_OPENED:
        if (!FsmThisLayerDown(CpIndex)) {
            return;
        }

        InitRestartCounters();
        FsmSendTermReq(CpIndex);
        gInfo.State = FSM_STOPPING;
        break;

    case FSM_CLOSED:
    case FSM_STOPPED:
        break;
    }
}

/***************************************************************************\
* ReceiveProtocolRej
*
\***************************************************************************/

VOID ReceiveProtocolRej(PPP_PACKET *pPacket)
{
    PPP_CONFIG *pRecvConfig = (PPP_CONFIG*)pPacket->Data;
    DWORD dwProtocol  = WireToHostFormat16(pRecvConfig->Data);
    DWORD CpIndex;

    CpIndex = GetCpIndexFromProtocol(dwProtocol);

    if (CpIndex == (DWORD)-1) {
        return;
    }

    if (CpIndex == CP_LCP) {
        gInfo.dwError = ERROR_PPP_NOT_CONVERGING;
        return;
    }

    // If LCP is not in the opened state we silently discard this packet 
    if (!IsLcpOpened()) {
        return;
    }

    gInfo.dwError = ERROR_PPP_CP_REJECTED;

    switch (gInfo.State) {
    case FSM_CLOSING:
        if (!FsmThisLayerFinished(CpIndex)) {
            return;
        }

        gInfo.State = FSM_CLOSED;
        break;

    case FSM_REQ_SENT:
    case FSM_ACK_RCVD:
    case FSM_ACK_SENT:
    case FSM_STOPPING:
        if (!FsmThisLayerFinished(CpIndex)) {
            return;
        }

        gInfo.State = FSM_STOPPED;
        break;

    case FSM_OPENED:
        if (!FsmThisLayerDown(CpIndex)) {
            return;
        }

        InitRestartCounters();
        FsmSendTermReq(CpIndex);
        gInfo.State = FSM_STOPPING;
        break;

    case FSM_CLOSED:
    case FSM_STOPPED:
        break;
    }
}

/***************************************************************************\
* FsmConfigResultReceived
*
\***************************************************************************/

BOOL FsmConfigResultReceived(DWORD CpIndex, PPP_CONFIG *pRecvConfig)
{
    DWORD dwRetCode; 

    switch (pRecvConfig->Code) {
    case CONFIG_NAK:
        dwRetCode = gCpTable[CpIndex].CP_ConfigNakReceived(pRecvConfig);
        break;

    case CONFIG_ACK:
        dwRetCode = gCpTable[CpIndex].CP_ConfigAckReceived(pRecvConfig);
        break;

    case CONFIG_REJ:
        dwRetCode = gCpTable[CpIndex].CP_ConfigRejReceived(pRecvConfig);
        break;

    default:
        return FALSE;
    }

    if (dwRetCode != NO_ERROR) {
        if (dwRetCode == ERROR_PPP_INVALID_PACKET) {
            return TRUE;
        } else {
            FsmClose(CpIndex);
            return FALSE;
        }
    }

    return TRUE;
}

/***************************************************************************\
* FsmReceive
*
\***************************************************************************/

VOID FsmReceive(PPP_PACKET *pPacket, DWORD dwPacketLength)
{
    DWORD dwProtocol;
    DWORD CpIndex;
    PPP_CONFIG *pRecvConfig;
    DWORD dwLength;
    BOOL fAuth = FALSE;
    
    // Validate length of packet
    if (dwPacketLength < (PPP_PACKET_HDR_LEN + PPP_CONFIG_HDR_LEN)) {
        return;
    }

    dwProtocol = WireToHostFormat16(pPacket->Protocol);
    CpIndex = GetCpIndexFromProtocol(dwProtocol);
    if (CpIndex == (DWORD)-1) {
        DbgPrint("Unknown protocol in PPP packet\n");
        return;
    }

    switch (gInfo.Phase) {
    case PPP_AP:
        if (CpIndex == GetCpIndexFromProtocol(gLcp.Remote.Work.AP)) {
            fAuth = TRUE;
            break;
        }

        // fall through

    case PPP_LCP:
        if (CpIndex == CP_LCP) {
            break;
        }

        return;
    }

    pRecvConfig = (PPP_CONFIG*)pPacket->Data;

    dwLength = WireToHostFormat16(pRecvConfig->Length);

    if (dwLength > (dwPacketLength - PPP_PACKET_HDR_LEN) || 
            (dwLength < PPP_CONFIG_HDR_LEN)) {
        return;
    }

    // Not in ProcessPacket table since parameters to this are different.
    if (CpIndex == CP_LCP && pRecvConfig->Code == PROT_REJ) {
        ReceiveProtocolRej(pPacket);
        return;
    }

    // Make sure that the protocol can handle the config code sent.
    if (pRecvConfig->Code == 0 || 
            pRecvConfig->Code > gCpTable[CpIndex].Recognize) {
        ReceiveUnknownCode(CpIndex, pRecvConfig);
        return;
    }

    if (fAuth) {
        ApWork(CpIndex, pRecvConfig);
    } else {
        gReceive[pRecvConfig->Code](CpIndex, pRecvConfig);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\ppp\smaction.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

    smaction.cpp

Abstract:

    Handle actions that occur during state transitions.

Revision History:

    07-14-00    vadimg      created

--*/

#include "precomp.h"

/***************************************************************************\
* FsmSendConfigReq
*
\***************************************************************************/

BOOL FsmSendConfigReq(DWORD CpIndex)
{
    DWORD dwRetCode;
    PPP_PACKET *pSendPacket = GetSendPacket();
    PPP_CONFIG *pSendConfig = (PPP_CONFIG*)pSendPacket->Data;
    DWORD dwLength;

    dwRetCode = (gCpTable[CpIndex].CP_MakeConfigRequest)(pSendConfig,
            LCP_DEFAULT_MRU - PPP_PACKET_HDR_LEN);

    if (dwRetCode != NO_ERROR) {
        gInfo.dwError = dwRetCode;
        FsmClose(CpIndex);
        return FALSE;
    }

    HostToWireFormat16((WORD)gCpTable[CpIndex].Protocol,
            (PBYTE)pSendPacket->Protocol);

    pSendConfig->Code = CONFIG_REQ;

    //
    // If we are resending a configure request because of a timeout, we do not
    // use the id of the previous configure request, instead we get a new Id.
    // Id we do not, then the wrong Config-Req's and Config-Acks may be matched
    // up and we start getting crossed connections.
    //

    pSendConfig->Id = GetId();

    dwLength = WireToHostFormat16(pSendConfig->Length);

    SendFrame(dwLength + PPP_PACKET_HDR_LEN);

    gInfo.LastId = pSendConfig->Id;

    SetTimeout();

    return TRUE;
}

/***************************************************************************\
* FsmSendTermReq
*
\***************************************************************************/

BOOL FsmSendTermReq(DWORD CpIndex)
{
    PPP_PACKET *pSendPacket = GetSendPacket();
    PPP_CONFIG *pSendConfig = (PPP_CONFIG*)pSendPacket->Data;

    HostToWireFormat16((WORD)gCpTable[CpIndex].Protocol,
                    (PBYTE)pSendPacket->Protocol);

    pSendConfig->Code = TERM_REQ;
    pSendConfig->Id = GetId();

    HostToWireFormat16((WORD)((PPP_CONFIG_HDR_LEN)+(sizeof(DWORD)*3)),
            (PBYTE)pSendConfig->Length);

    HostToWireFormat32(gLcp.Local.Work.MagicNumber, (PBYTE)pSendConfig->Data);
    HostToWireFormat32(777, (PBYTE)(pSendConfig->Data+4));
    HostToWireFormat32(gInfo.dwError, (PBYTE)(pSendConfig->Data+8));

    SendFrame(PPP_PACKET_HDR_LEN + PPP_CONFIG_HDR_LEN + sizeof(DWORD) * 3);

    gInfo.LastId = pSendConfig->Id;
    return TRUE;
}

/***************************************************************************\
* FsmSendTermAck
*
\***************************************************************************/

BOOL FsmSendTermAck(DWORD CpIndex, PPP_CONFIG *pRecvConfig)
{
    PPP_PACKET *pSendPacket = GetSendPacket();
    PPP_CONFIG *pSendConfig = (PPP_CONFIG*)pSendPacket->Data;
    DWORD dwLength;

    dwLength = PPP_PACKET_HDR_LEN + WireToHostFormat16(pRecvConfig->Length);
    if (dwLength > LCP_DEFAULT_MRU) {
        dwLength = LCP_DEFAULT_MRU;
    }

    HostToWireFormat16((WORD)gCpTable[CpIndex].Protocol,
            (PBYTE)pSendPacket->Protocol);

    pSendConfig->Code = TERM_ACK;
    pSendConfig->Id = pRecvConfig->Id;

    HostToWireFormat16((WORD)(dwLength - PPP_PACKET_HDR_LEN),
            (PBYTE)pSendConfig->Length);

    CopyMemory(pSendConfig->Data, pRecvConfig->Data,
            dwLength - PPP_CONFIG_HDR_LEN - PPP_PACKET_HDR_LEN);

    SendFrame(dwLength);

    return TRUE;
}

/***************************************************************************\
* FsmSendConfigResult
*
\***************************************************************************/

BOOL FsmSendConfigResult(DWORD CpIndex, PPP_CONFIG *pRecvConfig, BOOL *pfAcked)
{
    PPP_PACKET *pSendPacket = GetSendPacket();
    PPP_CONFIG *pSendConfig = (PPP_CONFIG*)pSendPacket->Data;
    DWORD dwLength;
    DWORD dwRetCode;

    *pfAcked = FALSE;

    ZeroMemory(pSendConfig, 30);

    pSendConfig->Id = pRecvConfig->Id;

    dwRetCode = (gCpTable[CpIndex].CP_MakeConfigResult)(pRecvConfig, pSendConfig,
            LCP_DEFAULT_MRU - PPP_PACKET_HDR_LEN, (gInfo.NakRetryCount == 0));

    if (dwRetCode == ERROR_PPP_INVALID_PACKET) {

        return FALSE;

    } else if (dwRetCode != NO_ERROR) {

        gInfo.dwError = dwRetCode;
        FsmClose(CpIndex);
        return FALSE;
    }

    switch (pSendConfig->Code) {
    case CONFIG_ACK:
        *pfAcked = TRUE;
        break;

    case CONFIG_NAK:
        if (gInfo.NakRetryCount > 0) {
            gInfo.NakRetryCount--;
        } else {

            gInfo.dwError = ERROR_PPP_NOT_CONVERGING;
            FsmClose(CP_LCP);
            return FALSE;
        }
        break;

    case CONFIG_REJ:
        if (gInfo.RejRetryCount > 0) {
            gInfo.RejRetryCount--;
        } else {
    
            gInfo.dwError = ERROR_PPP_NOT_CONVERGING;
            FsmClose(CP_LCP);
            return FALSE;
        }
        break;
    }

    HostToWireFormat16((WORD)gCpTable[CpIndex].Protocol,
            (PBYTE)pSendPacket->Protocol);

    pSendConfig->Id = pRecvConfig->Id;
    dwLength = WireToHostFormat16(pSendConfig->Length);

    SendFrame(dwLength + PPP_PACKET_HDR_LEN);

    return TRUE;
}

/***************************************************************************\
* FsmSendEchoReply
*
\***************************************************************************/

BOOL FsmSendEchoReply(DWORD CpIndex, PPP_CONFIG *pRecvConfig)
{
    PPP_PACKET *pSendPacket = GetSendPacket();
    PPP_CONFIG *pSendConfig = (PPP_CONFIG*)pSendPacket->Data;
    DWORD dwLength;

    dwLength =  PPP_PACKET_HDR_LEN + WireToHostFormat16(pRecvConfig->Length);
    if (dwLength > LCP_DEFAULT_MRU) {
        dwLength = LCP_DEFAULT_MRU;
    }

    if (dwLength < PPP_PACKET_HDR_LEN + PPP_CONFIG_HDR_LEN + 4) {
        return FALSE;
    }

    HostToWireFormat16((WORD)gCpTable[CpIndex].Protocol,
            (PBYTE)pSendPacket->Protocol);

    pSendConfig->Code = ECHO_REPLY;
    pSendConfig->Id = pRecvConfig->Id;

    HostToWireFormat16((WORD)(dwLength - PPP_PACKET_HDR_LEN),
            (PBYTE)pSendConfig->Length);

    HostToWireFormat32(gLcp.Local.Work.MagicNumber, (PBYTE)pSendConfig->Data);

    CopyMemory(pSendConfig->Data + 4, pRecvConfig->Data + 4,
            dwLength - PPP_CONFIG_HDR_LEN - PPP_PACKET_HDR_LEN - 4);

    SendFrame(dwLength);

    return TRUE;
}

/***************************************************************************\
* FsmSendCodeReject
*
\***************************************************************************/

BOOL FsmSendCodeReject(DWORD CpIndex, PPP_CONFIG *pRecvConfig)
{
    PPP_PACKET *pSendPacket = GetSendPacket();
    PPP_CONFIG *pSendConfig = (PPP_CONFIG*)pSendPacket->Data;
    DWORD dwLength;
        
    dwLength = PPP_PACKET_HDR_LEN + PPP_CONFIG_HDR_LEN +
            WireToHostFormat16(pRecvConfig->Length);

    if (dwLength > LCP_DEFAULT_MRU) {
        dwLength = LCP_DEFAULT_MRU;
    }

    HostToWireFormat16((WORD)gCpTable[CpIndex].Protocol,
            (PBYTE)pSendPacket->Protocol);

    pSendConfig->Code = CODE_REJ;
    pSendConfig->Id = GetId();

    HostToWireFormat16((WORD)(dwLength - PPP_PACKET_HDR_LEN),
            (PBYTE)pSendConfig->Length);

    CopyMemory( pSendConfig->Data,
                pRecvConfig,
                dwLength - PPP_CONFIG_HDR_LEN - PPP_PACKET_HDR_LEN );

    SendFrame(dwLength);

    return TRUE;
}

/***************************************************************************\
* FsmSendProtocolRej
*
\***************************************************************************/

BOOL FsmSendProtocolRej(PPP_PACKET *pPacket, DWORD dwPacketLength)
{
    PPP_PACKET *pSendPacket = GetSendPacket();
    PPP_CONFIG *pSendConfig = (PPP_CONFIG*)pSendPacket->Data;
    PPP_CONFIG *pRecvConfig = (PPP_CONFIG*)pPacket->Data;
    DWORD dwLength;

    // If LCP isn't in the opened state we can't send a protocol reject packet
    if (!IsLcpOpened()) {
        return ERROR_UNKNOWN;
    }

    dwLength = PPP_PACKET_HDR_LEN + PPP_CONFIG_HDR_LEN + dwPacketLength;

    if (dwLength > LCP_DEFAULT_MRU) {
        dwLength = LCP_DEFAULT_MRU;
    }

    HostToWireFormat16((WORD)gCpTable[CP_LCP].Protocol,
            (PBYTE)pSendPacket->Protocol);

    pSendConfig->Code = PROT_REJ;
    pSendConfig->Id = GetId();

    HostToWireFormat16((WORD)(dwLength - PPP_PACKET_HDR_LEN),
            (PBYTE)pSendConfig->Length);

    CopyMemory(pSendConfig->Data, pPacket,
                dwLength - PPP_CONFIG_HDR_LEN - PPP_PACKET_HDR_LEN);

    SendFrame(dwLength);

    return TRUE;
}

/***************************************************************************\
* FsmInit
*
\***************************************************************************/

BOOL FsmInit(DWORD CpIndex)
{
    DWORD dwRetCode;

    gInfo.dwError = NO_ERROR;
    gInfo.State = FSM_INITIAL;

    if (!FsmReset(CpIndex)) {
        return FALSE;
    }

    dwRetCode = gCpTable[CpIndex].CP_Begin();
    if (dwRetCode != NO_ERROR) {
        gInfo.dwError = dwRetCode;
        return FALSE;
    }

    return TRUE;
}

/***************************************************************************\
* FsmReset
*
\***************************************************************************/

BOOL FsmReset(DWORD CpIndex)
{
    InitRestartCounters();

    gInfo.NakRetryCount = PPP_MAX_FAILURE;
    gInfo.RejRetryCount = PPP_MAX_FAILURE;

    gInfo.LastId = 0;
    return TRUE;
}

/***************************************************************************\
* FsmThisLayerUp
*
\***************************************************************************/

BOOL FsmThisLayerUp(DWORD CpIndex)
{
    DWORD dwRetCode;

    DbgPrint("LcpThisLayerUp %4X\n", gCpTable[CpIndex].Protocol);

    if (gCpTable[CpIndex].CP_ThisLayerUp != NULL) {

        dwRetCode = gCpTable[CpIndex].CP_ThisLayerUp();
        if (dwRetCode != NO_ERROR) {
            gInfo.dwError = dwRetCode;
            FsmClose(CpIndex);
            return FALSE;
        }
    }

    switch (gInfo.Phase) {
    case PPP_LCP:
        gInfo.Phase = PPP_AP;
        CpIndex = GetCpIndexFromProtocol(gLcp.Remote.Work.AP);
        ApStart(CpIndex);
        break;

    case PPP_AP:
        gInfo.Phase = PPP_NCP;
        CpIndex = CP_IPCP;
        NcpStart(CpIndex);
        break;

    case PPP_NCP:
        InitNet();
        break;
    }

    return TRUE;
}

/***************************************************************************\
* FsmThisLayerDown
*
\***************************************************************************/

BOOL FsmThisLayerDown(DWORD CpIndex)
{
    DWORD dwRetCode;

    DbgPrint("LcpThisLayerDown %4X\n", gCpTable[CpIndex].Protocol);

    if (gCpTable[CpIndex].CP_ThisLayerDown != NULL) {
        dwRetCode = gCpTable[CpIndex].CP_ThisLayerDown();
        if (dwRetCode != NO_ERROR) {
            gInfo.dwError = dwRetCode;
            FsmClose(CpIndex);
            return FALSE;
        }
    }

    if (CpIndex == CP_LCP) {
        // bring down all NCPs
        // bring down AP
    }
    return TRUE;
}

/***************************************************************************\
* FsmThisLayerStarted
*
\***************************************************************************/

BOOL FsmThisLayerStarted(DWORD CpIndex)
{
    DWORD dwRetCode;

    if (gCpTable[CpIndex].CP_ThisLayerStarted != NULL) {
        dwRetCode = gCpTable[CpIndex].CP_ThisLayerStarted();
        if (dwRetCode != NO_ERROR) {
            gInfo.dwError = dwRetCode;
            FsmClose(CpIndex);
            return FALSE;
        }
    }
    return TRUE;
}

/***************************************************************************\
* FsmThisLayerFinished
*
\***************************************************************************/

BOOL FsmThisLayerFinished(DWORD CpIndex)
{
    DWORD dwRetCode;

    if (gCpTable[CpIndex].CP_ThisLayerFinished != NULL) {
        dwRetCode = gCpTable[CpIndex].CP_ThisLayerFinished();
        if (dwRetCode != NO_ERROR) {
            gInfo.dwError = dwRetCode;
            return FALSE;
        }
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\ppp\smevents.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

    smevents.cpp

Abstract:

    Handle event processing for the state machine.

Revision History:

    07-17-00    vadimg      created

--*/

#include "precomp.h"

/***************************************************************************\
* FsmUp
*
\***************************************************************************/

VOID FsmUp(DWORD CpIndex)
{
    if (CpIndex == CP_LCP) {
        gInfo.Phase = PPP_LCP;
    }

    switch (gInfo.State) {
    case FSM_INITIAL:
        gInfo.State = FSM_CLOSED;
        break;

    case FSM_STARTING:
        InitRestartCounters();

        if (!FsmSendConfigReq(CpIndex)) {
            return;
        }

        gInfo.State = FSM_REQ_SENT;
        break;
    }
}

/***************************************************************************\
* FsmOpen
*
\***************************************************************************/

VOID FsmOpen(DWORD CpIndex)
{
    switch (gInfo.State) {
    case FSM_INITIAL:
        if (!FsmThisLayerStarted(CpIndex)) {
            return;
        }

        gInfo.State = FSM_STARTING;
        break;

    case FSM_STARTING:
    case FSM_REQ_SENT:
    case FSM_ACK_RCVD:
    case FSM_ACK_SENT:
        break;

    case FSM_CLOSING:
        gInfo.State = FSM_STOPPING;
        break;

    case FSM_OPENED:
    case FSM_STOPPED:
    case FSM_STOPPING:
        break;

    case FSM_CLOSED:
        InitRestartCounters();

        if (!FsmSendConfigReq(CpIndex)) {
            return;
        }

        gInfo.State = FSM_REQ_SENT;
        break;
    }
}

/***************************************************************************\
* FsmDown
*
\***************************************************************************/

VOID FsmDown(DWORD CpIndex)
{
    switch (gInfo.State) {
    case FSM_CLOSED:
    case FSM_CLOSING:
        gInfo.State = FSM_INITIAL;
        break;

    case FSM_OPENED:

        if (!FsmThisLayerDown(CpIndex)) {
            return;
        }

        // fall through

    case FSM_REQ_SENT:
    case FSM_ACK_RCVD:
    case FSM_ACK_SENT:
    case FSM_STOPPING:
        if (!FsmReset(CpIndex)) {
            return;
        }

        gInfo.State = FSM_STARTING;
        break;

    case FSM_STOPPED:

        if (!FsmThisLayerStarted(CpIndex)) {
            return;
        }

        if (!FsmReset(CpIndex)) {
            return;
        }

        gInfo.State = FSM_STARTING;
        break;

    }

    if (CpIndex == CP_LCP) {
        gInfo.Phase = PPP_LCP;
    }
}

/***************************************************************************\
* FsmClose
*
\***************************************************************************/

VOID FsmClose(DWORD CpIndex)
{
    if (CpIndex == CP_LCP) {
        gInfo.Phase = PPP_LCP;
    }

    switch (gInfo.State) {
    case FSM_STARTING:
        gInfo.State = FSM_INITIAL;

        if (!FsmThisLayerFinished(CpIndex)) {
            return;
        }
        break;

    case FSM_STOPPED:
        gInfo.State = FSM_CLOSED;

        if (!FsmThisLayerFinished(CpIndex)) {
            return;
        }
        break;

    case FSM_STOPPING:
        gInfo.State = FSM_CLOSING;

        if (!FsmThisLayerFinished(CpIndex)) {
            return;
        }
        break;

    case FSM_REQ_SENT:
    case FSM_OPENED:
        if (!FsmThisLayerDown(CpIndex)) {
            return;
        }

        // fall through

    case FSM_ACK_RCVD:
    case FSM_ACK_SENT:
        gInfo.State = FSM_CLOSING;
        InitRestartCounters();
        FsmSendTermReq(CpIndex);
        break;

    case FSM_CLOSING:
    case FSM_CLOSED:
    case FSM_INITIAL:
        FsmThisLayerFinished(CpIndex);
        break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\ppp\ppp.h ===
#ifndef __PPP_H__
#define __PPP_H__

#include "lcp.h"
#include "pap.h"
#include "ncp.h"

typedef DWORD IPADDR;

/*
 * DEFINES
 */
#define PPP_FLAG_BYTE           0x7E
#define PPP_ESC_BYTE            0x7D

#define READ_TIMEOUT (3 * 60 * 1000)

// Maximum length used for the phone number
#define PNLEN                   56

// these constants are used as indecies into the PPP_CP_INFO array
#define CP_LCP                  0
#define CP_PAP                  1
#define CP_IPCP                 2
#define NUM_CP                  3

#define PPP_MAX_FAILURE         5

// Add 4 bytes for protocol (1), control (1), and CRC (2)
#define PPP_FRAME_MAX_LEN (LCP_DEFAULT_MRU + 4)

/*
 * Framing options
 */
#define PPP_MULTILINK_FRAMING           0x00000010
#define PPP_SHORT_SEQUENCE_HDR_FORMAT   0x00000020
#define PPP_MC_MULTILINK_FRAMING        0x00000040
#define PPP_FRAMING                     0x00000100
#define PPP_COMPRESS_ADDRESS_CONTROL    0x00000200
#define PPP_COMPRESS_PROTOCOL_FIELD     0x00000400
#define PPP_ACCM_SUPPORTED              0x00000800

// Various control protocol IDs
#define PPP_LCP_PROTOCOL        0xC021  // Link Control Protocol 
#define PPP_PAP_PROTOCOL        0xC023  // Password Authentication Protocol 
#define PPP_CBCP_PROTOCOL       0xC029  // Callback Control Protocol
#define PPP_BACP_PROTOCOL       0xC02B  // Bandwidth Allocation Control Protocol
#define PPP_BAP_PROTOCOL        0xC02D  // Bandwidth Allocation Protocol
#define PPP_CHAP_PROTOCOL       0xC223  // Challenge Handshake Auth. Protocol
#define PPP_IPCP_PROTOCOL       0x8021  // Internet Protocol Control Protocol 
#define PPP_ATCP_PROTOCOL       0x8029  // Appletalk Control Protocol 
#define PPP_IPXCP_PROTOCOL      0x802B  // Novel IPX Control Procotol 
#define PPP_NBFCP_PROTOCOL      0x803F  // NetBIOS Framing Control Protocol 
#define PPP_CCP_PROTOCOL        0x80FD  // Compression Control Protocol
#define PPP_SPAP_NEW_PROTOCOL   0xC027  // Shiva PAP new protocol
#define PPP_EAP_PROTOCOL        0xC227  // Extensible Authentication Protocol

// CHAP Digest codes
#define PPP_CHAP_DIGEST_MD5        0x05 // PPP standard MD5
#define PPP_CHAP_DIGEST_MSEXT      0x80 // Microsoft extended CHAP (nonstandard)
#define PPP_CHAP_DIGEST_MSEXT_NEW  0x81 // Microsoft extended CHAP (nonstandard)

// Config Codes
#define CONFIG_REQ              1
#define CONFIG_ACK              2
#define CONFIG_NAK              3
#define CONFIG_REJ              4
#define TERM_REQ                5
#define TERM_ACK                6
#define CODE_REJ                7
#define PROT_REJ                8
#define ECHO_REQ                9
#define ECHO_REPLY              10
#define DISCARD_REQ             11
#define IDENTIFICATION          12
#define TIME_REMAINING          13

typedef enum _PPP_PHASE {
    PPP_LCP,
    PPP_AP,
    PPP_NCP
} PPP_PHASE;

typedef enum _FSM_STATE {
    FSM_INITIAL,
    FSM_STARTING,
    FSM_CLOSED,
    FSM_STOPPED,
    FSM_CLOSING,
    FSM_STOPPING,
    FSM_REQ_SENT,
    FSM_ACK_RCVD,
    FSM_ACK_SENT,
    FSM_OPENED
} FSM_STATE;

typedef enum _AP_ACTION {

    AP_NoAction,        // Be passive, i.e. listen without timeout (default)
    AP_Done,            // End authentication session, dwError gives result
    AP_SendAndDone,     // As above but send message without timeout first
    AP_Send,            // Send message, don't timeout waiting for reply
    AP_SendWithTimeout, // Send message, timeout if reply not received
    AP_SendWithTimeout2,// As above, but don't increment retry count
    AP_Authenticate     // Authenticate using specified credentials.

} AP_ACTION;

/*
 * STRUCTURES
 */
typedef struct _PPP_FRAME {
    BYTE Address;
    BYTE Control;
    BYTE Data[1];
} PPP_FRAME;

#define PPP_FRAME_HDR_LEN (sizeof(PPP_FRAME) - 1)

typedef struct _PPP_PACKET {
    BYTE Protocol[2];   // Protocol Number
    BYTE Data[1];       // Data
} PPP_PACKET;

#define PPP_PACKET_HDR_LEN (sizeof(PPP_PACKET) - 1)

typedef struct _PPP_CONFIG {
    BYTE Code;          // Config code
    BYTE Id;            // ID of this config packet
    BYTE Length[2];     // Length of this packet
    BYTE Data[1];       // Data
} PPP_CONFIG;

#define PPP_CONFIG_HDR_LEN (sizeof(PPP_CONFIG) - 1)

typedef struct _PPP_OPTION {
    BYTE Type;          // Option Code
    BYTE Length;		// Length of this option packet
    BYTE Data[1];       // Data
} PPP_OPTION;

#define PPP_OPTION_HDR_LEN (sizeof(PPP_OPTION) - 1)

typedef struct _PPP_RECEIVED PPP_RECEIVED;
typedef struct _PPP_RECEIVED {

    PPP_RECEIVED *pNext;
    PPP_RECEIVED *pPrev;

    DWORD iCrc;
    DWORD cb;

    Packet *pkt;

} PPP_RECEIVED;

typedef struct _PPP_CP_INFO {
    
    // Protocol number for this CP
    DWORD Protocol;

    // Recognize options up to this number.
    DWORD Recognize;

    // Initialize all work values.
    DWORD (*CP_Begin)(VOID);

    // Free any allocated data.
    DWORD (*CP_End)(VOID);

    // When leaving Initial or Stopped states. May be NULL.
    DWORD (*CP_ThisLayerStarted)(VOID);

    // When entering Closed or Stopped states. May be NULL
    DWORD (*CP_ThisLayerFinished)(VOID);

    // When entering the Opened state. May be NULL. 
    DWORD (*CP_ThisLayerUp)(VOID);

    // When leaving the Opened state. May be NULL. 
    DWORD (*CP_ThisLayerDown)(VOID);
 
    // Called to make a configure request.
    DWORD (*CP_MakeConfigRequest)(PPP_CONFIG *pRequestBuf, DWORD cbRequestBuf);

    // Called when configure request is received and a result packet 
    // Ack/Nak/Reject needs to be sent
    DWORD (*CP_MakeConfigResult)(PPP_CONFIG *pReceiveBuf, PPP_CONFIG *pResultBuf,
            DWORD cbResultBuf, BOOL fRejectNaks);

    // Called to process an Ack that was received.
    DWORD (*CP_ConfigAckReceived)(PPP_CONFIG *pReceiveBuf);

    // Called to process a Nak that was received.
    DWORD (*CP_ConfigNakReceived)(PPP_CONFIG *pReceiveBuf);

    // Called to process a Rej that was received.
    DWORD (*CP_ConfigRejReceived)(PPP_CONFIG *pReceiveBuf);

    DWORD (*CP_MakeMessage)(PPP_CONFIG *pReceiveBuf);

} PPP_CP_INFO;

typedef struct _AP_INFO {
    AP_ACTION Action;
    PAP_STATE State;
} AP_INFO;

typedef struct _PPP_INFO {
    CHAR szUsername[UNLEN + 1];
    CHAR szPassword[PWLEN + 1];
    CHAR szDomain[DNLEN + 1];
    CHAR szNumber[PNLEN + 1];
    
    PPP_PHASE Phase;
    FSM_STATE State;
    DWORD dwError;

    BYTE Id;
    BYTE LastId;

    DWORD NakRetryCount;
    DWORD RejRetryCount;

    DWORD ConfigRetryCount;
    DWORD TermRetryCount;

    PPP_FRAME *pFrame;

} PPP_INFO;

typedef struct _READ_QUEUE {

    HANDLE hEvent;

    DWORD nHdr;
    DWORD nCrc;
    DWORD nOk;

    PPP_RECEIVED *pReceived;
    PPP_RECEIVED *pReceivedFirst;
    PPP_RECEIVED *pReceivedLast;

} READ_QUEUE;

typedef struct _PPP_TIMER {
    DWORD Expire;
    DWORD Timeout;
} PPP_TIMER;

typedef struct _FRAMING_INFO {
    DWORD SendAccm;
    DWORD RecvAccm;

    UINT fSendPfc : 1;
    UINT fSendAcfc : 1;
    UINT fRecvPfc : 1;
    UINT fRecvAcfc : 1;
} FRAMING_INFO;

typedef struct _IP_INFO {
    IfInfo *ifp;
    IPADDR IpAddrRemote;
    IPADDR IpAddrLocal;
    IPADDR IpAddrDns;
} IP_INFO;

// auth.cpp
BOOL ApStart(DWORD CpIndex);
VOID ApReset(VOID);
VOID ApWork(DWORD CpIndex, PPP_CONFIG *pRecvConfig);

// pap.cpp
VOID GetPapInfo(PPP_CP_INFO *pInfo);

// lcp.cpp
VOID GetLcpInfo(PPP_CP_INFO *pInfo);

// worker.cpp
DWORD WorkerThread(LPVOID pThreadParameter);
BOOL SendFrame(DWORD dwLength);
VOID SetTimeout(VOID);
VOID ClearTimeout(VOID);

// hostwire.cpp
VOID HostToWireFormat16(WORD wHostFormat, PBYTE pWireFormat);
VOID HostToWireFormat32(DWORD dwHostFormat, PBYTE pWireFormat);
WORD WireToHostFormat16(PBYTE pWireFormat);
DWORD WireToHostFormat32(PBYTE pWireFormat);

// string.cpp
char* str_search(const char *str1, const char *str2);
char* str_add(char *s1, const char *s2);

// modem.cpp
BOOL InitModem(VOID);
BOOL DialModem(VOID);
BOOL HangupModem(VOID);

// misc.cpp
VOID InitRestartCounters(VOID);
DWORD GetCpIndexFromProtocol(DWORD dwProtocol);
VOID EncodePw(CHAR* pszPassword);
VOID DecodePw(CHAR* pszPassword);

// smaction.cpp
BOOL FsmSendConfigReq(DWORD CpIndex);
BOOL FsmSendTermReq(DWORD CpIndex);
BOOL FsmSendTermAck(DWORD CpIndex, PPP_CONFIG *pRecvConfig);
BOOL FsmSendConfigResult(DWORD CpIndex, PPP_CONFIG *pRecvConfig, BOOL *pfAcked);
BOOL FsmSendEchoReply(DWORD CpIndex, PPP_CONFIG *pRecvConfig);
BOOL FsmSendCodeReject(DWORD CpIndex, PPP_CONFIG *pRecvConfig);
BOOL FsmSendProtocolRej(PPP_PACKET *pPacket, DWORD dwPacketLength);
BOOL FsmInit(DWORD CpIndex);
BOOL FsmReset(DWORD CpIndex);
BOOL FsmThisLayerUp(DWORD CpIndex);
BOOL FsmThisLayerDown(DWORD CpIndex);
BOOL FsmThisLayerStarted(DWORD CpIndex);
BOOL FsmThisLayerFinished(DWORD CpIndex);

/// smevents.cpp
VOID FsmUp(DWORD CpIndex);
VOID FsmOpen(DWORD CpIndex);
VOID FsmDown(DWORD CpIndex);
VOID FsmClose(DWORD CpIndex);

// ncp.cpp
VOID GetIpcpInfo(PPP_CP_INFO *pInfo);
BOOL NcpStart(DWORD CpIndex);
VOID NcpReset(VOID);

// net.cpp
BOOL InitNet(VOID);

// receive.cpp
VOID ReceiveConfigReq(DWORD CpIndex, PPP_CONFIG *pRecvConfig);
VOID ReceiveConfigAck(DWORD CpIndex, PPP_CONFIG *pRecvConfig);
VOID ReceiveConfigNakRej(DWORD CpIndex, PPP_CONFIG *pRecvConfig);
VOID ReceiveTermReq(DWORD CpIndex, PPP_CONFIG *pConfig);
VOID ReceiveTermAck(DWORD CpIndex, PPP_CONFIG *pRecvConfig);
VOID ReceiveUnknownCode(DWORD CpIndex, PPP_CONFIG *pConfig);
VOID ReceiveDiscardReq(DWORD CpIndex, PPP_CONFIG *pConfig);
VOID ReceiveEchoReq(DWORD CpIndex, PPP_CONFIG *pConfig);
VOID ReceiveEchoReply(DWORD CpIndex, PPP_CONFIG *pConfig);
VOID ReceiveCodeRej(DWORD CpIndex, PPP_CONFIG *pConfig);
VOID ReceiveProtocolRej(PPP_PACKET *pPacket);
VOID FsmReceive(PPP_PACKET *pPacket, DWORD dwPacketLength);
BOOL FsmConfigResultReceived(DWORD CpIndex, PPP_CONFIG *pRecvConfig);

// frame.cpp
VOID DecodeFrame(PBYTE pIn, DWORD *pcb);
VOID EncodeFrame(PBYTE pIn, PBYTE pOut, DWORD *pcb);
BOOL CheckCrc(PBYTE pb, DWORD cb);

/*
 * GLOBALS
 */
extern PPP_INFO gInfo;
extern PPP_CP_INFO gCpTable[NUM_CP];
extern LCP_INFO gLcp;
extern READ_QUEUE gQueue;
extern PPP_TIMER gTimer;
extern FRAMING_INFO gFraming;
extern AP_INFO gAp;
extern IP_INFO gIp;

/*
 * INLINES
 */

// Allocate from the process heap
inline PVOID Alloc(SIZE_T size)
{
    return (PVOID)LocalAlloc(LPTR, size);
}

// Free to the process heap
inline VOID Free(PVOID p)
{
    LocalFree((HLOCAL)p);
}

inline BYTE GetId(VOID)
{
    return ++gInfo.Id;
}

inline BOOL IsLcpOpened(VOID)
{
    return (gInfo.Phase == PPP_LCP);
}

inline PPP_PACKET* GetSendPacket(VOID)
{
    return (PPP_PACKET*)(gInfo.pFrame->Data);
}

inline DWORD GetMagicNumber(VOID)
{
    DWORD dwMagic = XnetRand();
    if (dwMagic == 0) {
        dwMagic = 29;
    }
    return dwMagic;
}

#endif // __PPP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\ppp\string.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

    string.cpp

Abstract:

    String functions, so we don't need to include msvcrt.

Revision History:

    07-11-00    vadimg      created

--*/

#include "precomp.h"

char* str_search(const char *str1, const char *str2)
{
    char *cp = (char*)str1;
    char *s1, *s2;

    while (*cp) {
        s1 = cp;
        s2 = (char*)str2;

        while (*s1 && *s2 && !(*s1-*s2)) {
            s1++, s2++;
        }

        if (!*s2) {
            return cp;
        }

        cp++;
    }

    return NULL;
}

char* str_add(char *s1, const char *s2)
{
    while (*s2) {
        *s1 = *s2;
        s1++, s2++;
    }

    *s1 = '\0';

    return s1;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\ppp\worker.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

    worker.cpp

Abstract:

    PPP worker thread.

Revision History:

    07-11-00    vadimg      created

--*/

#include "precomp.h"

/***************************************************************************\
* TimerProc
*
\***************************************************************************/

VOID TimerProc(VOID)
{
    if (gInfo.Phase != PPP_LCP && gInfo.Phase != PPP_NCP) {
        return;
    }

    switch (gInfo.State) {
    case FSM_REQ_SENT:
    case FSM_ACK_RCVD:
    case FSM_ACK_SENT:
        FsmSendConfigReq(gInfo.Phase);

        if (gInfo.State != FSM_ACK_SENT) {
            gInfo.State = FSM_REQ_SENT;
        }
        break;
    }
}

/***************************************************************************\
* SetTimeout
*
\***************************************************************************/

VOID SetTimeout(VOID)
{
    gTimer.Timeout = 4000;
    gTimer.Expire = GetTickCount() + gTimer.Timeout;
}

/***************************************************************************\
* ClearTimeout
*
\***************************************************************************/

VOID ClearTimeout(VOID)
{
    gTimer.Timeout = 0;
}

/***************************************************************************\
* ProcessTimer
*
\***************************************************************************/

VOID ProcessTimer(VOID)
{
    if (gTimer.Timeout == 0) {
        return;
    }

    if (GetTickCount() >= gTimer.Expire) {
        TimerProc();

        gTimer.Expire = GetTickCount() + gTimer.Timeout;
    }
}

/***************************************************************************\
* DumpFrame
*
\***************************************************************************/

VOID DumpFrame(PBYTE pBuffer, DWORD cb)
{
    DWORD i;

    for (i = 0; i < cb; i++) {

        if ((i % 16) == 0) {
            DbgPrint("\n");
        }

        DbgPrint("%02x ", pBuffer[i]);
    }

    DbgPrint("\n\n");
}

/***************************************************************************\
* SendFrame
*
\***************************************************************************/

BOOL SendFrame(DWORD dwLength)
{
    DWORD cb, i = 0;
    BYTE frame[PPP_FRAME_MAX_LEN];
    
    dwLength += 2;

    DbgPrint("s:");
    DumpFrame((PBYTE)gInfo.pFrame, dwLength);

    EncodeFrame((PBYTE)gInfo.pFrame, frame, &dwLength);

    while (dwLength > 0) {

        cb = min(dwLength, MODEM_BUFFER_SIZE);
        if (!ModemWrite(&frame[i], &cb)) {
            return FALSE;
        }

        dwLength -= cb;
        i += cb;
    }

    return TRUE;
}

/***************************************************************************\
* UnlinkReceived
*
\***************************************************************************/

VOID UnlinkReceived(PPP_RECEIVED *p)
{
    if (gQueue.pReceivedFirst == p && gQueue.pReceivedLast == p) {
        gQueue.pReceivedFirst = NULL;
        gQueue.pReceivedLast = NULL;
    } else if (gQueue.pReceivedFirst == p) {
        gQueue.pReceivedFirst = p->pNext;
        gQueue.pReceivedFirst->pPrev = NULL;
    } else if (gQueue.pReceivedLast == p) {
        gQueue.pReceivedLast = p->pPrev;
        gQueue.pReceivedLast->pNext = NULL;
    } else {
        p->pPrev->pNext = p->pNext;
        p->pNext->pPrev = p->pPrev;
    }
}

/***************************************************************************\
* LinkReceived
*
\***************************************************************************/

VOID LinkReceived(PPP_RECEIVED *p)
{
    if (gQueue.pReceivedFirst == NULL) {
        gQueue.pReceivedFirst = p;
        gQueue.pReceivedLast = p;
    } else {
        p->pPrev = gQueue.pReceivedLast;
        gQueue.pReceivedLast->pNext = p;
        gQueue.pReceivedLast = p;
    }
}

/***************************************************************************\
* DumpReceived
*
\***************************************************************************/

VOID ProcessReceived(VOID)
{
    PPP_RECEIVED *pNext;
    PPP_RECEIVED *p = gQueue.pReceivedFirst;
    PPP_PACKET *pPacket;
    DWORD dwProtocol;

    while (p != NULL) {

        DbgPrint("r:");
        DumpFrame(p->pkt->buf, p->cb);

        pPacket = (PPP_PACKET*)((PPP_FRAME*)p->pkt->buf)->Data;
        dwProtocol = WireToHostFormat16(pPacket->Protocol);

        if (dwProtocol == (PPP_IPCP_PROTOCOL - 0x8000)) {
            KIRQL irql = KeRaiseIrqlToDpcLevel();
            IpReceivePacket(p->pkt);
            KeLowerIrql(irql);
        } else {
            FsmReceive(pPacket, p->cb - PPP_FRAME_HDR_LEN);
            XnetFreePacket(p->pkt);
        }

        pNext = p->pNext;

        UnlinkReceived(p);
        Free(p);

        p = pNext;
    }
}

/***************************************************************************\
* AddFrameData
*
\***************************************************************************/

VOID AddFrameData(PBYTE frame, DWORD cb, BOOL fComplete)
{
    PPP_RECEIVED *p;
    DWORD i, iFrame;
    DWORD iCopy, iCrc;

    p = gQueue.pReceived;
    if (p != NULL) {

        // add to the end of this frame
        if (frame != NULL) {
            for (i = 0, iFrame = p->cb; i < cb; i++, iFrame++) {
                p->pkt->buf[iFrame] = frame[i];
            }
            p->cb = p->cb + cb;
        }
    } else if (frame != NULL) {

        DecodeFrame(frame, &cb);

        if (cb < 4) {
            gQueue.nHdr++;
            return;
        }

        // handle address and control field compression
        if (frame[0] == 0xFF && frame[1] == 0x03) {
            iCopy = 2;
            iCrc = 0;
        } else if (gFraming.fRecvAcfc) {
            iCopy = 0;
            iCrc = 2;
        } else {
            gQueue.nHdr++;
            return;
        }

        // allocate new frame
        PPP_RECEIVED *p = (PPP_RECEIVED*)Alloc(sizeof(PPP_RECEIVED));
        if (p == NULL) {
            DbgPrint("AddFrameData: out of memory\n");
            return;
        }
        p->pkt = XnetAllocPacket(PPP_FRAME_MAX_LEN, 0);
        if (p->pkt == NULL) {
            DbgPrint("AddFrameData: out of memory\n");
            Free(p);
            return;
        }

        p->pkt->recvifp = gIp.ifp;
        p->pkt->data = &p->pkt->buf[4];
        p->pkt->datalen = p->cb - 6; // 4 (hdr) + 2 (crc)
        p->pkt->buf[0] = 0xFF;
        p->pkt->buf[1] = 0x03;

        // handle protocol field compression
        if (frame[iCopy] & 0x01) {
            if (gFraming.fRecvPfc) {
                p->pkt->buf[2] = 0x00;
                iCrc += 1;
            } else {
                XnetFreePacket(p->pkt);
                Free(p);
                gQueue.nHdr++;
                return;
            }
        } else {
            p->pkt->buf[2] = frame[iCopy];
            iCopy += 1;
        }

        CopyMemory(&p->pkt->buf[3], &frame[iCopy], cb - iCopy);
        p->iCrc = iCrc;
        p->cb = cb;

        gQueue.pReceived = p;
    }

    if (p != NULL && fComplete) {
        if (CheckCrc(&p->pkt->buf[p->iCrc], p->cb)) {
            gQueue.nOk++;
            p->cb += p->iCrc;
            LinkReceived(p);
        } else {
            gQueue.nCrc++;
            XnetFreePacket(p->pkt);
            Free(p);
        }
        gQueue.pReceived = NULL;
    }
}

/***************************************************************************\
* ReadModemData
*
\***************************************************************************/

VOID ReadModemData(VOID)
{
    BYTE buffer[MODEM_BUFFER_SIZE + 1];
    DWORD cbBuffer, iBuffer;
    BYTE frame[PPP_FRAME_MAX_LEN];
    DWORD iFrame;

    iFrame = 0;

    while (TRUE) {

        iBuffer = 0;
        cbBuffer = MODEM_BUFFER_SIZE;
        if (!ModemRead((PUCHAR)buffer, &cbBuffer) || cbBuffer == 0) {

            if (iFrame > 0) {
                AddFrameData(frame, iFrame, FALSE);
            }

            return;
        }

        buffer[cbBuffer] = '\0';
        if (str_search((const char*)buffer, "NO CARRIER") != NULL) {
            AddFrameData(NULL, 0, TRUE);
            DbgPrint("%d ok, %d hdr, %d crc\n", gQueue.nOk, gQueue.nHdr, gQueue.nCrc);
            return;
        }

        while (iBuffer < cbBuffer) {

            if (buffer[iBuffer] == PPP_FLAG_BYTE) {

                if (iFrame == 0) {
                    AddFrameData(NULL, 0, TRUE);
                } else {
                    AddFrameData(frame, iFrame, TRUE);
                    iFrame = 0;
                }

            } else {
                frame[iFrame++] = buffer[iBuffer];
            }

            iBuffer++;
        }

        Sleep(5);
    }
}

/***************************************************************************\
* WorkerThread
*
\***************************************************************************/

DWORD WorkerThread(LPVOID pThreadParameter)
{
    DWORD dwWait;

    while (TRUE) {
        
        dwWait = WaitForSingleObject(gQueue.hEvent, 1000);

        if (dwWait == WAIT_OBJECT_0) {
            ReadModemData();
            ProcessReceived();
        }

        ProcessTimer();
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\tcp\mcast.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    mcast.c

Abstract:

    Implement multicast support on UDP and RAW sockets

Revision History:

    07/07/2000 davidx
        Created it.

--*/

#include "precomp.h"

//
// Maximum of multicast groups that can be joined from a single socket
//
UINT cfgMaxSocketMcastGroups = 16;


VOID
PcbCleanupMcastData(
    PCB* pcb
    )

/*++

Routine Description:

    Cleanup multicast group membership data associated with the PCB

Arguments:

    pcb - Points to the protocol control block

Return Value:

    NONE

--*/

{
    PcbMcastData* pcbmcast;
    PcbMcastGroup* mcastgrp;
    UINT count;

    RUNS_AT_DISPATCH_LEVEL
    if ((pcbmcast = pcb->mcastData) == NULL) return;
    pcb->mcastData = NULL;

    // Drop all multicast groups that this socket belongs to
    mcastgrp = pcbmcast->mcastGroups;
    count = pcbmcast->groupCount;
    while (count--) {
        IfChangeMcastGroup(mcastgrp->ifp, mcastgrp->mcastaddr, FALSE);
        mcastgrp++;
    }

    SysFree(pcbmcast);
}


INLINE PcbMcastData*
PcbGetMcastData(
    PCB* pcb
    )

/*++

Routine Description:

    Allocate per-socket multicast group membership information

Arguments:

    pcb - Points to the protocol control block

Return Value:

    Points to the per-socket multicast information
    NULL if out of memory

--*/

{
    if (pcb->mcastData == NULL) {
        UINT size = offsetof(PcbMcastData, mcastGroups) +
                    sizeof(PcbMcastGroup) * cfgMaxSocketMcastGroups;
        pcb->mcastData = (PcbMcastData*) SysAlloc0(size, PTAG_MCAST);
    }

    return pcb->mcastData;
}


NTSTATUS
PcbSetMcastIf(
    PCB* pcb,
    IPADDR ifaddr
    )

/*++

Routine Description:

    Specifies the default interface for sending out multicast datagrams

Arguments:

    pcb - Points to the protocol control block
    ifaddr - Specifies the address of the interface designated
        for sending out multicast datagrams by default;
        use 0 to unset any existing multicast interface

Return Value:

    Status code

--*/

{
    NTSTATUS status;
    KIRQL irql;
    IfInfo* ifp;
    PcbMcastData* pcbmcast;

    irql = RaiseToDpc();

    if ((pcbmcast = PcbGetMcastData(pcb)) != NULL) {
        if (ifaddr == 0) {
            RTE* rte = IpFindRTE(CLASSD_NETID, NULL);
            ifp = rte ? rte->ifp : NULL;
        } else {
            ifp = IfFindInterface(ifaddr);
        }

        if (ifp && IfMcastEnabled(ifp)) {
            CACHE_IFP_REFERENCE(pcbmcast->mcastIfp, ifp);
            pcbmcast->mcastIfAddr = ifaddr;
            status = NETERR_OK;
        } else {
            status = NETERR(WSAEADDRNOTAVAIL);
        }
    } else {
        status = NETERR_MEMORY;
    }

    LowerFromDpc(irql);
    return status;
}


IfInfo*
PcbGetMcastIf(
    PCB* pcb
    )

/*++

Routine Description:

    Return the default multicast interface for a socket

Arguments:

    pcb - Points to the protocol control block

Return Value:

    Status code

--*/

{
    NTSTATUS status;
    if (!pcb->mcastData || !pcb->mcastData->mcastIfp) {
        ASSERT(!pcb->mcastData || pcb->mcastData->mcastIfAddr == 0);
        status = PcbSetMcastIf(pcb, 0);
        if (!NT_SUCCESS(status))
            return NULL;
    }

    return pcb->mcastData->mcastIfp;
}


NTSTATUS
PcbChangeMcastGroup(
    PCB* pcb,
    IPADDR mcastaddr,
    IPADDR ifaddr,
    BOOL add
    )

/*++

Routine Description:

    Join or leave a multicast group

Arguments:

    pcb - Points to the protocol control block
    mcastaddr - Specifies the multicast group address
    ifaddr - Specifies the interface address (0 means any)
    add - Whether to join or leave the group

Return Value:

    Status code

--*/

{
    NTSTATUS status;
    PcbMcastData* pcbmcast;
    KIRQL irql = RaiseToDpc();

    pcbmcast = PcbGetMcastData(pcb);
    if (pcbmcast) {
        PcbMcastGroup* mcastgrp;
        UINT index;
        BOOL existing;

        // Check to see if the socket is already joined into
        // the specified group/interface combination.
        mcastgrp = pcbmcast->mcastGroups;
        for (index=0; index < pcbmcast->groupCount; index++, mcastgrp++) {
            if (mcastgrp->mcastaddr == mcastaddr &&
                mcastgrp->ifaddr == ifaddr)
                break;
        }

        existing = (index < pcbmcast->groupCount);
        if (add) {
            // Joining a group
            if (existing) {
                // The socket already belong to the specified group
                status = NETERR(WSAEADDRINUSE);
            } else if (pcbmcast->groupCount == cfgMaxSocketMcastGroups) {
                // Socket belongs to too many groups
                status = NETERR(WSAEADDRNOTAVAIL);
            } else {
                IfInfo* ifp;

                ifp = ifaddr ? IfFindInterface(ifaddr) : PcbGetMcastIf(pcb);
                if (ifp) {
                    status = IfChangeMcastGroup(ifp, mcastaddr, TRUE);
                    if (NT_SUCCESS(status)) {
                        mcastgrp->mcastaddr = mcastaddr;
                        mcastgrp->ifaddr = ifaddr;
                        CACHE_IFP_REFERENCE(mcastgrp->ifp, ifp);
                        pcbmcast->groupCount++;
                    }
                } else {
                    status = NETERR_UNREACHABLE;
                }
            }
        } else {
            // Leaving a group
            if (existing) {
                status = IfChangeMcastGroup(mcastgrp->ifp, mcastgrp->mcastaddr, FALSE);
                pcbmcast->groupCount--;
                while (index++ < pcbmcast->groupCount) {
                    *mcastgrp = *(mcastgrp+1);
                    mcastgrp++;
                }
            } else {
                status = NETERR_PARAM;
            }
        }
    } else {
        status = NETERR_MEMORY;
    }

    LowerFromDpc(irql);
    return status;
}


BOOL
PcbCheckMcastGroup(
    PCB* pcb,
    IPADDR mcastaddr
    )

/*++

Routine Description:

    Check if the socket is joined into the specified multicast group

Arguments:

    pcb - Points to the protocol control block
    mcastaddr - Specifies the multicast group address

Return Value:

    TRUE if the socket belongs to the specified multicast group
    FALSE otherwise

Note:

    We're not checking the receiving interface here.
    In theory, we could redundantly deliver a multicast
    datagram received from one interface to a socket that 
    belongs to the same multicast group on another interface.
    But such practice is discouraged. Besides, we'll only have
    one active interface other than the loopback interface.

--*/

{
    PcbMcastData* pcbmcast = pcb->mcastData;
    PcbMcastGroup* mcastgrp;
    UINT count;

    if (!pcbmcast) return FALSE;
    mcastgrp = pcbmcast->mcastGroups;
    count = pcbmcast->groupCount;
    while (count--) {
        if (mcastgrp->mcastaddr == mcastaddr) return TRUE;
        mcastgrp++;
    }

    return FALSE;
}


NTSTATUS
PcbSendMcastDgram(
    PCB* pcb,
    Packet* pkt,
    IPADDR dstaddr
    )

/*++

Routine Description:

    Send out a multicast datagram

Arguments:

    pcb - Points to the protocol control block
    pkt - Points to the packet to be sent
    dstaddr - Specifies the destination multicast address

Return Value:

    Status code

--*/

{
    IfInfo* ifp;

    RUNS_AT_DISPATCH_LEVEL

    // Send a copy of the multicast datagram to ourselves if needed
    if (!pcb->noMcastLoopback) {
        IpQueueLoopbackPacket(pkt, TRUE);
    }

    // Choose the outgoing interface if we have done so already
    if ((pcb->mcastData  == NULL || (ifp = pcb->mcastData->mcastIfp) == NULL) &&
        (ifp = PcbGetMcastIf(pcb)) == NULL) {
        XnetCompletePacket(pkt, NETERR_UNREACHABLE);
        return NETERR_UNREACHABLE;
    }

    // Check to see if the datagram size is too large
    if (pkt->datalen > ifp->mtu) {
        XnetCompletePacket(pkt, NETERR_MSGSIZE);
        return NETERR_MSGSIZE;
    }

    // Queue up the packet for transmission
    pkt->nexthop = dstaddr;
    IfEnqueuePacket(ifp, pkt);
    ifp->StartOutput(ifp);
    return NETERR_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\tcp\precomp.h ===
#include "xnetp.h"
#include "icmp.h"
#include "pcb.h"
#include "route.h"
#include "tcpimpl.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\tcp\pcb.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    pcb.c

Abstract:

    Functions for dealing with PCBs (protocol control blocks)

Revision History:

    06/01/2000 davidx
        Created it.

--*/

#include "precomp.h"

//
// Global PCB lists
//
LIST_ENTRY PcbList;
ULONG PcbCount;

//
// Default and max send and receive buffer sizes
// Since we don't do TCP window scaling option, the max
// receive buffer size cannot exceed 16-bit (65535).
//
UINT cfgDefaultSendBufsize = 16*1024;
UINT cfgDefaultRecvBufsize = 16*1024;
UINT cfgMinSendRecvBufsize = 1;
UINT cfgMaxSendRecvBufsize = 0xffff;

//
// Maximum number of sockets
//
UINT cfgMaxSockets = 64;


PCB*
PcbCreate(
    INT type,
    INT protocol,
    BYTE allocFlag
    )

/*++

Routine Description:

    Create a new PCB for the specified socket type and protocol

Arguments:

    type - Socket type: SOCK_STREAM, SOCK_DGRAM, or SOCK_RAW
    protocol - Protocol number
    allocFlag - Whether to allocate memory from our private pool
        PCBFLAG_NETPOOL or 0

Return Value:

    Pointer to the newly created PCB structure
    NULL if there is an error

--*/

{
    PCB* pcb;

    if (PcbCount >= cfgMaxSockets) {
        WARNING_("Too many sockets");
        return NULL;
    }

    //
    // Allocate memory out of the system pool or
    // our private pool based on the caller specified flag
    //
    if (allocFlag & PCBFLAG_NETPOOL) {
        pcb = (PCB*) ((type == SOCK_STREAM) ?
                        XnetAlloc0(sizeof(TCB), PTAG_TCB) :
                        XnetAlloc0(sizeof(PCB), PTAG_PCB));
    } else {
        pcb = (PCB*) ((type == SOCK_STREAM) ?
                        SysAlloc0(sizeof(TCB), PTAG_TCB) :
                        SysAlloc0(sizeof(PCB), PTAG_PCB));
    }

    if (!pcb) return NULL;

    pcb->magicCookie = ACTIVE_PCB_COOKIE;
    pcb->flags = allocFlag;
    pcb->type = (BYTE) type;
    pcb->protocol = (BYTE) protocol;
    pcb->maxSendBufsize = cfgDefaultSendBufsize;
    pcb->maxRecvBufsize = cfgDefaultRecvBufsize;
    pcb->ipTtl = cfgDefaultTtl;
    pcb->ipTos = cfgDefaultTos;
    pcb->mcastTtl = 1;

    InitializeListHead(&pcb->recvbuf);
    InitializeListHead(&pcb->sendbuf);
    KeInitializeEvent(GetPcbWaitEvent(pcb), NotificationEvent, FALSE);

    if (type == SOCK_STREAM) {
        TcbInit((TCB*) pcb);
    }

    InterlockedIncrement(&PcbCount);
    return pcb;
}


NTSTATUS
PcbClose(
    PCB* pcb,
    BOOL force
    )

/*++

Routine Description:

    Close a PCB structure

Arguments:

    pcb - Points to the PCB structure to be disposed of
    force - Forceful close, always succeed

Return Value:

    Status code

--*/

{
    KIRQL irql = RaiseToDpc();

    // If a TCP is being gracefully closed, then we'll
    // leave the the PCB structure in the global list
    // until the connection is really gone.
    if (IsTcb(pcb) && !TcbClose((TCB*) pcb, force)) {
        pcb->magicCookie = CLOSED_PCB_COOKIE;
        pcb->flags |= PCBFLAG_BOTH_SHUTDOWN;
        LowerFromDpc(irql);
        return NETERR_OK;
    }

    // Mark the PCB structure as invalid for simple protection
    // against bad apps trying to access closed socket handles.
    pcb->magicCookie = CLOSED_PCB_COOKIE;

    if (!IsListNull(&pcb->links)) {
        RemoveEntryList(&pcb->links);
    }

    // Clean up the information associated with the PCB
    PcbCleanup(pcb, FALSE);

    LowerFromDpc(irql);

    if (pcb->flags & PCBFLAG_NETPOOL) {
        XnetFree(pcb);
    } else {
        SysFree(pcb);
    }

    InterlockedDecrement(&PcbCount);
    return NETERR_OK;
}


VOID
PcbCleanup(
    PCB* pcb,
    BOOL revivable
    )

/*++

Routine Description:

    Clean up the information associated with a PCB

Arguments:

    pcb - Points to the protocol control block
    revivable - Only significant for a TCP socket;
        if TRUE we leave the socket in a revivable state

Return Value:

    NONE

--*/

{
    NTSTATUS status;
    RUNS_AT_DISPATCH_LEVEL

    status = NT_SUCCESS(pcb->errStatus) ? NETERR_CANCELLED : pcb->errStatus;
    PcbClearOverlappedRecvs(pcb, status);
    PcbClearOverlappedSends(pcb, status);

    // Flush send and receive buffers
    PcbFlushRecvBuffers(pcb);

    while (!IsPcbSendBufEmpty(pcb)) {
        SENDBUF* sendbuf = (SENDBUF*) RemoveHeadList(&pcb->sendbuf);
        SendbufRelease(sendbuf);
    }
    pcb->sendbufSize = 0;

    if (pcb->rte) {
        IpReleaseCachedRTE(pcb->rte);
        pcb->rte = NULL;
    }

    if (revivable) {
        pcb->flags |= PCBFLAG_REVIVABLE;
    } else {
        if (pcb->bindIfp)
            pcb->bindIfp = NULL;

        PcbCleanupMcastData(pcb);
        PcbFreeIpOpts(pcb);
    }
}


VOID
PcbCloseAll()

/*++

Routine Description:

    Forcefully close all sockets

Arguments:

    NONE

Return Value:

    NONE

--*/

{
    PCB* pcb;

    if (IsListNull(&PcbList)) return;
    while (!IsPcbListEmpty()) {
        pcb = (PCB*) PcbList.Flink;
        PcbDelete(pcb);
    }

    if (IsListNull(&DeadTcbList)) return;
    while (!IsListEmpty(&DeadTcbList)) {
        pcb = (PCB*) DeadTcbList.Flink;
        PcbDelete(pcb);
    }
}


PCB*
PcbFindMatch(
    IPADDR toaddr,
    IPPORT toport,
    IPADDR fromaddr,
    IPPORT fromport,
    BYTE type,
    BYTE protocol
    )

/*++

Routine Description:

    Find the matching socket for a received datagarm

Arguments:

    toaddr, toport - The destination address of the datagram
    fromaddr, fromport - The sender's address
    type - Specifies the socket type (SOCK_DGRAM or SOCK_RAW)
    protocol - Specifies the protocol number

Return Value:

    Points to the best socket to receive the datagram
    NULL if no matching socket is found

--*/

{
    PCB* pcb;
    PCB* found;
    UINT wildcard, minWildcard;

    RUNS_AT_DISPATCH_LEVEL
    found = NULL;
    minWildcard = 4;

    LOOP_THRU_PCB_LIST(pcb)

        if (pcb->type != type ||
            pcb->protocol != protocol && pcb->protocol != 0 ||
            pcb->srcport != toport)
            continue;

        wildcard = 0;
        if (pcb->srcaddr != toaddr) {
            if (pcb->srcaddr) continue;
            wildcard++;
        }

        if (pcb->dstaddr != fromaddr) {
            if (pcb->dstaddr) continue;
            wildcard++;
        }

        if (pcb->dstport != fromport) {
            if (pcb->dstport) continue;
            wildcard++;
        }

        if (wildcard == 0) return pcb;
        if (wildcard < minWildcard) {
            found = pcb;
            minWildcard = wildcard;
        }

    END_PCB_LIST_LOOP
    return found;
}


NTSTATUS
PcbUpdateBufferSize(
    PCB* pcb,
    INT sendBufsize,
    INT recvBufsize
    )

/*++

Routine Description:

    Update the send and receive buffer sizes

Arguments:

    pcb - Points to the PCB structure
    sendBufsize, recvBufsize - 
        Specifies the new send and receive buffer sizes

Return Value:

    Status code

--*/

{
    KIRQL irql;
    NTSTATUS status;

    if (sendBufsize > (INT) cfgMaxSendRecvBufsize)
        sendBufsize = (INT) cfgMaxSendRecvBufsize;
    else if (sendBufsize <= 0) {
        // NOTE: we never set actual send buffer size to 0
        // because we don't support the no-buffering option.
        sendBufsize = 1;
    }

    if (recvBufsize > (INT) cfgMaxSendRecvBufsize)
        recvBufsize = (INT) cfgMaxSendRecvBufsize;
    else if (recvBufsize <= 0)
        recvBufsize = 0;

    status = NETERR_OK;
    irql = RaiseToDpc();

    if (IsDgramPcb(pcb)) {
        // For datagram sockets, we'll just update the send and
        // receive buffers sizes. If the current buffers are bigger
        // than the specified limits, we'll leave the current data alone.
        pcb->maxSendBufsize = sendBufsize;
        pcb->maxRecvBufsize = recvBufsize;
    } else {
        TCB* tcb = (TCB*) pcb;

        // Set the send buffer size. If the current send buffer size
        // is larger than the specified limit, leave the current data untouched.
        tcb->maxSendBufsize = sendBufsize;
        
        // If the TCP socket is already connected,
        // don't allow the app to reduce the receive buffer size.
        if (!IsTcpIdleState(tcb) && recvBufsize < (INT) tcb->maxRecvBufsize) {
            status = NETERR_PARAM;
        } else {
            // NOTE: we don't update receive window to the connection peer
            // right away. The new window information will be sent
            // in the next outgoing ACK segment.
            tcb->maxRecvBufsize = recvBufsize;
        }
    }

    // NOTE: If the send buffer has just opened up,
    // we don't check to see if there is any pending
    // overlapped send request that can be started.
    // Rather the overlapped send request will be started
    // by the normal process.

    LowerFromDpc(irql);
    return status;
}


//
// Temporary port numbers are between 1024 and 4999 (inclusive)
// We're not using port number 5000 just as a safety precaution.
//
#define MIN_TEMP_PORT 1024
#define MAX_TEMP_PORT 4999
#define TEMP_PORT_COUNT (MAX_TEMP_PORT-MIN_TEMP_PORT+1)

INLINE IPPORT GenerateTempPort() {
    static USHORT nextTempPort = MAX_TEMP_PORT;
    if (++nextTempPort > MAX_TEMP_PORT)
        nextTempPort = MIN_TEMP_PORT;
    return HTONS(nextTempPort);
}


NTSTATUS
PcbBind(
    PCB* pcb,
    IPADDR srcaddr,
    IPPORT srcport
    )

/*++

Routine Description:

    Bind a socket to the specified local address

Arguments:

    pcb - Points to the protocol control block
    srcaddr, srcport - Specifies the local socket address

Return Value:

    Status code

--*/

{
    NTSTATUS status;
    INT retries = 1;
    KIRQL irql = RaiseToDpc();

    ASSERT(!IsPcbBound(pcb));

    if (pcb->type == SOCK_RAW) {
        // Port number is meaningless for raw sockets
        // and we always set it to 0.
        srcport = 0;
    } else if (srcport == 0) {
        // We're picking a randomly-generated port number.
        retries = min(cfgMaxSockets, TEMP_PORT_COUNT);
        srcport = GenerateTempPort();
    }

    while (TRUE) {
        PCB* cur;

        status = NETERR_OK;
        LOOP_THRU_PCB_LIST(cur)

            if (cur == pcb || !IsPcbBound(cur)) continue;

            // NOTE: Different raw sockets can bind to
            // the same address/protocol pair. This is
            // to follow win2k behavior.

            if ((pcb->type != SOCK_RAW) &&
                (cur->protocol == pcb->protocol) &&
                (cur->srcport == srcport) &&    // conflicting port number?
                (cur->bindSrcAddr == srcaddr || // conflicting address?
                 cur->bindSrcAddr == 0 ||
                 srcaddr == 0) &&
                (cur->exclusiveAddr ||          // address reuse disallowed?
                 pcb->exclusiveAddr ||
                 !pcb->reuseAddr)) {
                status = NETERR_ADDRINUSE;
                break;
            }

        END_PCB_LIST_LOOP

        if (status == NETERR_OK) {
            // If we're binding to a specific IP address,
            // loop through all the interfaces and
            // select the one with the matching address.
            if (srcaddr != 0) {
                IfInfo* ifp;

                ifp = IfFindInterface(srcaddr);
                if (ifp == NULL) {
                    status = NETERR(WSAEADDRNOTAVAIL);
                    break;
                }

                ASSERT(pcb->bindIfp == NULL);
                CACHE_IFP_REFERENCE(pcb->bindIfp, ifp);
            }
    
            pcb->srcaddr = pcb->bindSrcAddr = srcaddr;
            pcb->srcport = srcport;
            pcb->flags |= PCBFLAG_BOUND;
        } else {
            // The selected port is not available.
            // Check to see if we should try another one.
            if (--retries) {
                srcport = GenerateTempPort();
                continue;
            }
        }

        break;
    }

    LowerFromDpc(irql);
    return status;
}


NTSTATUS
PcbConnectDgram(
    PCB* pcb,
    IPADDR dstaddr,
    IPPORT dstport
    )

/*++

Routine Description:

    Connect a datagram socket to the specified foreign address

Arguments:

    pcb - Points to the protocol control block
    dstaddr, dstport - Specifies the foreign socket address

Return Value:

    Status code

--*/

{
    KIRQL irql;
    NTSTATUS status;

    if (pcb->type == SOCK_RAW) {
        // Port number for raw sockets is meaningless
        dstport = 0;
    } else {
        if (dstaddr == 0 && dstport != 0 ||
            dstaddr != 0 && dstport == 0)
            return NETERR(WSAEADDRNOTAVAIL);
    }

    // Destination hasn't changed, no need to do anything
    if (dstaddr == pcb->dstaddr && dstport == pcb->dstport)
        return NETERR_OK;

    // Is this socket allowed to send broadcast
    // datagrams on this socket?
    if (IS_BCAST_IPADDR(dstaddr) && !pcb->broadcast)
        return NETERR(WSAEACCES);

    irql = RaiseToDpc();

    // If the socket is currently connected,
    // we need to disconnect it first.
    if (IsPcbConnected(pcb)) {
        pcb->flags &= ~PCBFLAG_CONNECTED;
        pcb->dstaddr = 0;
        pcb->dstport = 0;
        pcb->srcaddr = pcb->bindSrcAddr;
        if (pcb->rte) {
            IpReleaseCachedRTE(pcb->rte);
            pcb->rte = NULL;
        }
    }

    // Discard any received packets that have been
    // queued up but not yet processed
    PcbFlushRecvBuffers(pcb);

    if (dstaddr != 0) {
        // Bind to a local address if necessary
        if (!IsPcbBound(pcb)) {
            status = PcbBind(pcb, 0, 0);
            if (!NT_SUCCESS(status)) {
                LowerFromDpc(irql);
                return status;
            }
        }
        
        if (!IS_MCAST_IPADDR(dstaddr)) {
            // Find a route to the connected destination.
            // And if we're bound to a wildcard source address,
            // then we'll pick a specific source address here
            // based on the route.

            ASSERT(pcb->rte == NULL);
            pcb->rte = IpFindRTE(dstaddr, NULL);
            if (!pcb->rte) {
                LowerFromDpc(irql);
                return NETERR_UNREACHABLE;
            }

            RteAddRef(pcb->rte);
            if (pcb->bindSrcAddr == 0) {
                pcb->srcaddr = PcbGetDefaultSrcAddr(pcb->rte);
            }
        }

        pcb->flags |= PCBFLAG_CONNECTED;
        pcb->dstaddr = dstaddr;
        pcb->dstport = dstport;
    }

    LowerFromDpc(irql);
    return NETERR_OK;
}


VOID
PcbSetupIpHeader(
    PCB* pcb,
    Packet* pkt,
    IpAddrPair* addrpair
    )

/*++

Routine Description:

    Prepare the IP header information in an outgoing packet
    using the connection information from the PCB.

Arguments:

    pcb - Points to a connected PCB
    pkt - Points to the outgoing packet
    addrpair - Specifies the source and destination address pair

Return Value:

    NONE

Note:

    This function really belong to the ..\ip\ipsend.c.
    We duplicate the code here to save a function call (with
    large number of parameters).

--*/

{
    UINT iphdrlen;
    IpHeader* iphdr;

    iphdrlen = IPHDRLEN + ROUNDUP4(pcb->ipoptlen);
    pkt->data -= iphdrlen;
    iphdr = (IpHeader*) pkt->data;
    SETPKTIPHDR(pkt, iphdr);
    pkt->datalen += iphdrlen;

    if (pcb->ipoptlen) {
        ZeroMem(iphdr+1, iphdrlen-IPHDRLEN);
        CopyMem(iphdr+1, pcb->ipopts, pcb->ipoptlen);
    }

    FILL_IPHEADER(
        iphdr,
        iphdrlen,
        pcb->ipTos,
        pkt->datalen,
        pcb->ipDontFrag ? HTONS(DONT_FRAGMENT) : 0,
        IS_BCAST_IPADDR(addrpair->dstaddr) ? 1 :
            IS_MCAST_IPADDR(addrpair->dstaddr) ? pcb->mcastTtl : pcb->ipTtl,
        pcb->protocol,
        addrpair->srcaddr,
        addrpair->dstaddr);
}


NTSTATUS
PcbWaitForEvent(
    PCB* pcb,
    INT eventMask,
    UINT timeout
    )

/*++

Routine Description:

    Block the current thread until the specified PCB event is signalled

Arguments:

    pcb - Points to the protocol control block
    eventMask - Flag bit to indicate which event to block on
    timeout - Specifies the wait timeout (in milliseconds, 0 means forever)

Return Value:

    Status code

--*/

{
    INT readyMask;
    NTSTATUS status = NETERR_OK;

    //
    // Check if the specified event is already available
    // or if the socket connection has been reset.
    //
    readyMask = PcbCheckSelectEvents(pcb, eventMask, 1);
    if (readyMask & PCBEVENT_CONNRESET) goto exit;
    if (readyMask != 0) return NETERR_OK;

    status = WaitKernelEventObject(GetPcbWaitEvent(pcb), timeout);
    PcbClearSelectEvents(pcb);

exit:
    return NT_SUCCESS(status) ? PcbGetErrStatus(pcb) : status;
}


INT
PcbCheckSelectEvents(
    PCB* pcb,
    INT eventMasks,
    INT setwait
    )

/*++

Routine Description:

    Check if the specified socket events are available
    and optionally set up the socket to wait for them

Arguments:

    pcb - Points to the protocol control block
    eventMasks - Specifies the socket events the caller is interested in
    setwait - Whether to set up the sockets to wait if 
        none of the specified events are avaiable

Return Value:

    Set of event flags that are already available

--*/

{
    NTSTATUS status;
    INT readyMasks;
    KIRQL irql = RaiseToDpc();

    // Check to see if the specified event is already available
    // Since our checks are trivial, it's faster to check
    // everything instead of trying to check selectively
    // based on the flags specified by the caller.
    
    if (IsTcb(pcb)) {
        // If the connection was reset, return reset status
        status = PcbGetErrStatus(pcb);
        if (!NT_SUCCESS(status)) {
            // Note: If we already told the app that the socket was connected
            // and then the socket got resetted, we don't need to set the socket
            // in the exceptfds again to tell the app the connection has failed.
            if (eventMasks != PCBEVENT_CONNRESET || !pcb->connectSelected) {
                LowerFromDpc(irql);
                return PCBEVENT_CONNRESET;
            }
        }

        readyMasks = (IsTcpRecvBufEmpty(pcb) ? 0 : PCBEVENT_READ) |
                     (TcbHasPendingConnReq((TCB*) pcb) ? PCBEVENT_ACCEPT : 0) |
                     (IsFINReceived(pcb) ? PCBEVENT_READ|PCBEVENT_CLOSE : 0);

        if (IsPcbConnected(pcb)) {
            if (!IsPcbSendBufFull(pcb)) readyMasks |= PCBEVENT_WRITE;

            // NOTE: we only signal the connect event exactly once
            if ((eventMasks & PCBEVENT_CONNECT) && !pcb->connectSelected) {
                readyMasks |= PCBEVENT_CONNECT;
                if (setwait >= 0) pcb->connectSelected = 1;
            }
        }
    } else {
        readyMasks = (IsDgramRecvBufEmpty(pcb) ? 0 : PCBEVENT_READ) |
                     (IsPcbSendBufFull(pcb) ? 0 : PCBEVENT_WRITE);
    }

    if ((readyMasks &= eventMasks) == 0 && setwait) {
        // Indicate that we're interested in the specified event
        // and prepare to wait
        pcb->eventFlags = eventMasks;
        KeClearEvent(GetPcbWaitEvent(pcb));
    }

    LowerFromDpc(irql);
    return readyMasks;
}


VOID
PcbCompleteOverlappedSendRecv(
    PcbOverlappedReq* req,
    NTSTATUS status
    )

/*++

Routine Description:

    Complete an overlapped send/receive request

Arguments:

    req - Points to the overlapped send/receive request
    status - Specifies the completion status

Return Value:

    NONE

--*/

{
    PCB* pcb = req->pcb;

    // NOTE: we can have at most 1 overlapped send/receive request
    if ((RECVREQ*) req == pcb->overlappedRecvs) {
        pcb->overlappedRecvs = NULL;
    } else if ((SENDREQ*) req == pcb->overlappedSends) {
        pcb->overlappedSends = NULL;
    }

    req->overlapped->_iostatus = status;
    SetKernelEvent(req->overlappedEvent);

    // If the wait event is our internal per-PCB event,
    // then this is a special case for implementing the
    // blocking recv call. See comments in PcbQueueOverlappedRecv.

    if (req->overlappedEvent != GetPcbWaitEvent(req->pcb)) {
        ObDereferenceObject(req->overlappedEvent);
        SysFree(req);
    }
}


NTSTATUS
PcbQueueOverlappedRecv(
    PCB* pcb,
    RECVREQ* recvreq
    )

/*++

Routine Description:

    Queue up an overlapped receive request

Arguments:

    pcb - Points to the protocol control block
    recvreq - Points to the receive request

Return Value:

    Status code

--*/

{
    RECVREQ* newreq;

    // Queue up an overlapped receive request.
    // We only support 1 outstanding overlapped receive request.
    if (HasOverlappedRecv(pcb) || !recvreq->overlappedEvent)
        return NETERR_WOULDBLOCK;

    if (recvreq->overlappedEvent == GetPcbWaitEvent(pcb)) {
        // If the wait event is our internal per-PCB event,
        // then this is a special case for implementing the
        // blocking recv call.
        //
        // In this case, we avoid an allocation by directly
        // queuing up the RECVREQ structure that was passed
        // in from the caller (winsock layer). This works because
        // the caller will wait for the recv to complete after
        // this function returns.

        newreq = recvreq;
    } else {
        newreq = (RECVREQ*) SysAlloc(sizeof(RECVREQ), PTAG_RREQ);
        if (!newreq) return NETERR_MEMORY;
        *newreq = *recvreq;
    }

    pcb->overlappedRecvs = newreq;
    newreq->pcb = pcb;
    newreq->overlapped->_ioxfercnt = 0;
    newreq->overlapped->_ioflags = 0;
    newreq->overlapped->_ioreq = (UINT_PTR) newreq;
    newreq->overlapped->_iostatus = (DWORD) NETERR_PENDING;
    return NETERR_PENDING;
}


NTSTATUS
PcbQueueOverlappedSend(
    PCB* pcb,
    SENDREQ* sendreq
    )

/*++

Routine Description:

    Queue up an overlapped send request

Arguments:

    pcb - Points to the protocol control block
    sendreq - Points to the overlapped send request

Return Value:

    Status code:
        NETERR_PENDING - the request was successfully queued up
        NETERR_OK - if the send buffer has opened up and
            there is no need to queue up the request
        otherwise - the request was not queued up due to an error

--*/

{
    NTSTATUS status;
    KIRQL irql = RaiseToDpc();

    if (HasOverlappedSend(pcb)) {
        // We only support 1 outstanding overlapped send request.
        status = NETERR_WOULDBLOCK;
    } else if (!IsPcbSendBufFull(pcb)) {
        // The send buffer opened up just as
        // we were raising to DPC level
        status = NETERR_OK;
    } else {
        SENDREQ* newreq;
        UINT size = sizeof(SENDREQ) +
                    (sendreq->toaddr ? sizeof(*sendreq->toaddr) : 0) +
                    sizeof(WSABUF) * sendreq->bufcnt;

        newreq = (SENDREQ*) SysAlloc(size, PTAG_RREQ);
        if (!newreq) {
            // Out of memory
            status = NETERR_MEMORY;
        } else {
            VOID* bufs;

            pcb->overlappedSends = newreq;
            *newreq = *sendreq;
            bufs = newreq+1;
            if (sendreq->toaddr) {
                newreq->toaddr = (struct sockaddr_in*) bufs;
                *newreq->toaddr = *sendreq->toaddr;
                bufs = newreq->toaddr + 1;
            }

            newreq->bufs = (WSABUF*) bufs;
            CopyMem(bufs, sendreq->bufs, sizeof(WSABUF) * sendreq->bufcnt);

            newreq->pcb = pcb;
            newreq->overlapped->_ioxfercnt = 0;
            newreq->overlapped->_ioflags = 0;
            newreq->overlapped->_ioreq = (UINT_PTR) newreq;
            newreq->overlapped->_iostatus = status = NETERR_PENDING;
        }
    }

    LowerFromDpc(irql);
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\tcp\tcpconn.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    tcpconn.c

Abstract:

    TCP connection management functions

Revision History:

    06/05/2000 davidx
        Created it.

--*/

#include "precomp.h"


//
// Maximum segment lifetime (30 seconds)
//
UINT cfgMSL = 30 * SLOW_TCP_TIMER_FREQ;

//
// Timeout period for active connection requests
// NOTE: Non-standard behavior!!!
//  Our connection timeout value of 20sec is much shorter
//  than the usual value of 75sec.
//
UINT cfgConnectTimeout = 20 * SLOW_TCP_TIMER_FREQ;

//
// Maximum backlogs for a listening socket
//
INT cfgMaxListenBacklog = 5;

//
// Default linger time when a connection is gracefully closed (2 minutes)
//
USHORT cfgDefaultLingerTime = 2*60;

//
// Default retransmission timeout (3 seconds)
//
UINT cfgDefaultRTO = 3*SLOW_TCP_TIMER_FREQ;

//
// List of TCP connections that has been reset but not yet closed
//
LIST_ENTRY DeadTcbList;


VOID
TcbInit(
    TCB* tcb
    )

/*++

Routine Description:

    Initialize a TCP control block

Arguments:

    tcb - Points to a newly allocated TCB structure

Return Value:

    NONE

Note:

    We assume all fields have been zero-initialized
    when this function is called.

--*/

{
    InitializeListHead(&tcb->listenq);
    tcb->linger.l_linger = cfgDefaultLingerTime;

    tcb->snd_mss = tcb->rcv_mss = TCP_DEFAULT_MSS;
    tcb->snd_cwnd = tcb->snd_ssthresh = MAX_TCP_WNDSIZE;
    tcb->srtt_8 = 0;
    tcb->rttvar_4 = tcb->RTO = cfgDefaultRTO;

    tcb->sendbufNext = TcbSendbufNil(tcb);
}


//
// Disassociate a child socket (i.e. pending connection
// request for a listening socket) from its parent
//
PRIVATE VOID TcbDisassociateChild(TCB* childTcb)
{
    RemoveEntryList(&childTcb->listenq);
    InitializeListHead(&childTcb->listenq);
    childTcb->parent->backlog--;
    childTcb->parent = NULL;
}


//
// Trim the backlog of pending connection requests
//
INLINE VOID TcbTrimConnReqBacklog(TCB* tcb, UINT maxBacklog) {
    while (tcb->backlog > maxBacklog) {
        TCB* childTcb = CONTAINING_RECORD(tcb->listenq.Blink, TCB, listenq);
        TcbDisassociateChild(childTcb);
        TcbDelete(childTcb);
    }
}


BOOL
TcbClose(
    TCB* tcb,
    BOOL forceful
    )

/*++

Routine Description:

    Close a TCP connection

Arguments:

    tcb - Points to the TCB structure
    forceful - Forceful close, always succeed and no wait

Return Value:

    TRUE if the TCB structure can be deleted immediately.
    FALSE if the connection is being gracefully closed
    and the TCB structure should be kept around until
    the connection is really closed.

--*/

{
    NTSTATUS status;

    //
    // Try to gracefully close the socket if requested by the caller
    //
    if (!forceful && (tcb->tcpstate >= TCPST_SYN_RECEIVED) &&
        (!tcb->linger.l_onoff || tcb->linger.l_linger > 0)) {
        status = TcbShutdown(tcb, PCBFLAG_BOTH_SHUTDOWN, FALSE);
        if (NT_SUCCESS(status)) {
            UINT linger = tcb->linger.l_onoff ?
                            tcb->linger.l_linger :
                            cfgDefaultLingerTime;

            // TIME-WAIT and linger timers are the same
            TcbSetTimeWaitTimer(tcb, linger * SLOW_TCP_TIMER_FREQ);
            return FALSE;
        }
    }

    if (tcb->parent) {
        // This was a pending connection request
        // for a listening socket.
        TcbDisassociateChild(tcb);
    } else {
        // Clear all pending connection requests
        TcbTrimConnReqBacklog(tcb, 0);
    }

    return TRUE;
}


NTSTATUS
TcbShutdown(
    TCB* tcb,
    BYTE flags,
    BOOL apicall
    )

/*++

Routine Description:

    Gracefully shutdown a TCP connection

Arguments:

    tcb - Points to the TCP control block
    flags - Shutdown flags: PCBFLAG_SEND_SHUTDOWN and/or PCBFLAG_RECV_SHUTDOWN
    apicall - Whether this is called by shutdown API

Return Value:

    Status code

--*/

{
    NTSTATUS status = NETERR_OK;
    KIRQL irql = RaiseToDpc();

    if ((flags & PCBFLAG_RECV_SHUTDOWN) && !IsPcbRecvShutdown(tcb)) {
        tcb->flags |= PCBFLAG_RECV_SHUTDOWN;
        if (!IsTcpRecvBufEmpty(tcb)) {
            //
            // If the receive buffer is not empty,
            // we'll send a RST to the connection peer
            // and reset the connection.
            //
            TcbResetPeer(tcb);
            status = apicall ? NETERR_OK : NETERR_CONNRESET;
            tcb = TcbReset(tcb, NETERR_CONNRESET);
            ASSERT(tcb != NULL);
        } else {
            // Cancel any pending overlapped receive requests
            PcbClearOverlappedRecvs(tcb, NETERR(WSAESHUTDOWN));
        }
    }

    if ((flags & PCBFLAG_SEND_SHUTDOWN) && !IsPcbSendShutdown(tcb)) {
        // Cancel any pending overlapped send requests
        PcbClearOverlappedSends(tcb, NETERR(WSAESHUTDOWN));

        switch (tcb->tcpstate) {
        case TCPST_SYN_RECEIVED:
        case TCPST_ESTABLISHED:
            status = TcbEmitFIN(tcb);
            if (NT_SUCCESS(status)) {
                TcbSetState(tcb, TCPST_FIN_WAIT_1, "Shutdown");
                tcb->flags |= PCBFLAG_SEND_SHUTDOWN;
            }
            break;

        case TCPST_CLOSE_WAIT:
            status = TcbEmitFIN(tcb);
            if (NT_SUCCESS(status)) {
                TcbSetState(tcb, TCPST_LAST_ACK, "Shutdown");
                tcb->flags |= PCBFLAG_SEND_SHUTDOWN;
            }
            break;

        default:
            ASSERT(tcb->tcpstate < TCPST_SYN_RECEIVED);
            status = NETERR(WSAENOTCONN);
            break;
        }
    }

    flags &= ~PCBFLAG_REVIVABLE;
    LowerFromDpc(irql);
    return status;
}


TCB*
TcbReset(
    TCB* tcb,
    NTSTATUS status
    )

/*++

Routine Description:

    Reset a TCP connection

Arguments:

    tcb - Points to the TCP control block
    status - Specifies the cause of the reset

Return Value:

    NULL if the specified TCB was deleted inside this call.
    Otherwise, just return the input tcb parameter.

--*/

{
    BOOL revivable;

    ASSERT(!IsTcpIdleState(tcb));
    
    if (IsPendingConnReqTcb(tcb) || TcbIsLingering(tcb)) {
        TcbDelete(tcb);
        return NULL;
    }

    // Remove the TCB from the active list
    // and move it to the zombie list.

    ASSERT(!IsListNull(&tcb->links));
    RemoveEntryList(&tcb->links);
    InsertHeadList(&DeadTcbList, &tcb->links);

    tcb->errStatus = (status != NETERR_CONNRESET || IsTcpSyncState(tcb)) ?
                            status :
                            NETERR(WSAECONNREFUSED);

    revivable = !IsTcpSyncState(tcb) &&
                (tcb->flags & PCBFLAG_BOTH_SHUTDOWN) == 0;

    tcb->flags |= PCBFLAG_BOTH_SHUTDOWN;
    TcbSetState(tcb, TCPST_CLOSED, "Reset");

    // Stop various timers
    // NOTE: This is a little hacky - we're clearing all the fields
    // from delayedAcks to rtt_tick in one shot. Be careful when you
    // add or remove fields from the TCB structure.

    ZeroMem(
        &tcb->delayedAcks,
        offsetof(TCB, rtt_tick) + sizeof(tcb->rtt_tick) - offsetof(TCB, delayedAcks));

    TcbInit(tcb);

    PcbSignalEvent(tcb, PCBEVENT_ALL);
    PcbCleanup((PCB*) tcb, revivable);
    return tcb;
}


TCB*
TcbCloneChild(
    TCB* tcb
    )

/*++

Routine Description:

    Add a pending connection request to a listening socket

Arguments:

    tcb - Points to the listening socket

Return Value:

    Pointer to the child socket
    NULL if there is an error

--*/

{
    TCB* childTcb;

    // Fail if the backlog is full
    ASSERT(tcb->tcpstate == TCPST_LISTEN);
    if (tcb->backlog >= tcb->maxBacklog)
        return NULL;
    
    // Allocate memory for the child socket
    childTcb = (TCB*) PcbCreate(SOCK_STREAM, IPPROTOCOL_TCP, PCBFLAG_NETPOOL);
    if (!childTcb) return NULL;

    // Associate the child socket with its parent
    childTcb->parent = tcb;
    tcb->backlog++;
    InsertTailList(&tcb->listenq, &childTcb->listenq);

    // Copy the local address bindings
    childTcb->flags |= PCBFLAG_BOUND;
    childTcb->bindSrcAddr = tcb->bindSrcAddr;
    childTcb->srcaddr = tcb->srcaddr;
    childTcb->srcport = tcb->srcport;
    if (tcb->bindIfp) {
        CACHE_IFP_REFERENCE(childTcb->bindIfp, tcb->bindIfp);
    }

    // Copy socket options
    childTcb->options = tcb->options;
    if (tcb->ipoptlen) {
        PcbSetIpOpts((PCB*) childTcb, tcb->ipopts, tcb->ipoptlen);
    } else {
        ASSERT(childTcb->ipopts == NULL);
    }

    return childTcb;
}


NTSTATUS
TcbListen(
    TCB* tcb,
    INT backlog
    )

/*++

Routine Description:

    Switch a TCP socket into listening state

Arguments:

    tcb - Points to the TCP control block
    backlog - Maximum number of pending connections

Return Value:

    Status code

--*/

{
    KIRQL irql;
    NTSTATUS status;

    if (!IsTcpIdleState(tcb))
        return NETERR(WSAEISCONN);

    irql = RaiseToDpc();

    status = PcbGetErrStatus(tcb);
    if (NT_SUCCESS(status)) {
        TcbSetState(tcb, TCPST_LISTEN, "Listen");
        tcb->maxBacklog = (backlog < 1) ? 1 :
                          (backlog > cfgMaxListenBacklog) ?
                            cfgMaxListenBacklog :
                            backlog;

        // Trim down the backlog of pending connections if needed
        TcbTrimConnReqBacklog(tcb, tcb->maxBacklog);
        status = NETERR_OK;
    }

    LowerFromDpc(irql);
    return status;
}


NTSTATUS
TcbAccept(
    TCB* tcb,
    TCB** newtcb
    )

/*++

Routine Description:

    Accept an incoming TCP connection request

Arguments:

    tcb - Points to the TCP control block
    newtcb - Returns a pointer to the newly accepted connection block

Return Value:

    Status code

--*/

{
    KIRQL irql;
    LIST_ENTRY* entry;
    NTSTATUS status = NETERR_CONNRESET;

    irql = RaiseToDpc();

    entry = tcb->listenq.Flink;
    while (entry != &tcb->listenq) {
        TCB* childTcb = CONTAINING_RECORD(entry, TCB, listenq);
        if (IsPcbConnected(childTcb)) {
            TcbDisassociateChild(childTcb);
            *newtcb = childTcb;
            status = NETERR_OK;
            break;
        }
        entry = entry->Flink;
    }

    LowerFromDpc(irql);
    return status;
}


BOOL
TcbHasConnectedPendingConnReq(
    TCB* tcb
    )

/*++

Routine Description:

    Check to see if a listening socket has pending connection
    requests that are in ESTABLISHED state.

Arguments:

    TCB - Points to the TCP control block

Return Value:

    TRUE if there is pending connections ready to be accepted
    FALSE otherwise

--*/

{
    KIRQL irql;
    LIST_ENTRY* entry;
    BOOL result = FALSE;

    irql = RaiseToDpc();

    entry = tcb->listenq.Flink;
    while (entry != &tcb->listenq) {
        TCB* childTcb = CONTAINING_RECORD(entry, TCB, listenq);
        if (IsPcbConnected(childTcb)) {
            result = TRUE;
            break;
        }
        entry = entry->Flink;
    }

    LowerFromDpc(irql);

    return result;
}


NTSTATUS
TcbConnect(
    TCB* tcb,
    IPADDR dstaddr,
    IPPORT dstport,
    BOOL synAck
    )

/*++

Routine Description:

    Make a TCP connection to the specified foreign address

Arguments:

    tcb - Points to the TCP control block
    dstaddr, dstport - Specifies the foreign address to connect to
    synAck - Whether we're acknowledging a received SYN request

Return Value:

    Status code

--*/

{
    NTSTATUS status;
    KIRQL irql;
    RTE* rte;

    if (dstport == 0 ||
        dstaddr == 0 ||
        IS_BCAST_IPADDR(dstaddr) ||
        IS_MCAST_IPADDR(dstaddr))
        return NETERR(WSAEADDRNOTAVAIL);

    if (IsTcpListenState(tcb))
        return NETERR_PARAM;

    // Bind to a local address if necessary
    if (!IsPcbBound(tcb)) {
        status = PcbBind((PCB*) tcb, 0, 0);
        if (!NT_SUCCESS(status)) return status;
    }

    irql = RaiseToDpc();

    if (tcb->flags & PCBFLAG_REVIVABLE) {
        // Revive a TCB that has been reset
        tcb->connectSelected = 0;
        tcb->flags &= ~(PCBFLAG_REVIVABLE|PCBFLAG_BOTH_SHUTDOWN);
        tcb->eventFlags = 0;
        KeClearEvent(GetPcbWaitEvent(tcb));
        tcb->errStatus = NETERR_OK;

        ASSERT(IsListEmpty(&tcb->listenq));
        TcbInit(tcb);

        // Move the TCB structure from the dead list
        // back to the active list.
        RemoveEntryList(&tcb->links);
        InsertHeadList(&PcbList, &tcb->links);
    } else {
        status = PcbGetErrStatus(tcb);
        if (!NT_SUCCESS(status)) goto exit;
    }

    if (!IsTcpIdleState(tcb) && !synAck) {
        status = NETERR(WSAEALREADY);
        goto exit;
    }

    // Find a route to the connected destination.
    ASSERT(tcb->rte == NULL);
    rte = tcb->rte = IpFindRTE(dstaddr, NULL);
    if (!rte) {
        status = NETERR_UNREACHABLE;
        goto exit;
    }

    RteAddRef(rte);
    if (tcb->bindSrcAddr == 0) {
        tcb->srcaddr = PcbGetDefaultSrcAddr(rte);
    }

    // If this is an active open, go to SYN-SENT state.
    // Otherwise, we should already be in SYN-RECEIVED state.
    if (!synAck) {
        TcbSetState(tcb, TCPST_SYN_SENT, "Connect");
    }

    // Set up MSS to make sure we don't have to
    // fragment on the first hop. We assume the first hop
    // interface won't change during the life of the connection.
    tcb->rcv_mss = rte->ifp->mtu - IPHDRLEN - TCPHDRLEN;
    tcb->maxRecvBufsize = 
        ((tcb->maxRecvBufsize + tcb->rcv_mss - 1) / tcb->rcv_mss) * tcb->rcv_mss;
    if (tcb->maxRecvBufsize > cfgMaxSendRecvBufsize)
        tcb->maxRecvBufsize = cfgMaxSendRecvBufsize;

    tcb->dstaddr = dstaddr;
    tcb->dstport = dstport;

    tcb->snd_isn = TcbGetIsn();
    tcb->rcv_wnd = tcb->maxRecvBufsize;
    ASSERT(IsTcpRecvBufEmpty(tcb));

    // send out a SYN or SYN/ACK segment
    status = TcbEmitSYN(tcb, synAck);

exit:
    LowerFromDpc(irql);
    return status;
}


#if DBG

extern ULONG XDebugOutLevel;

VOID
TcbSetState(
    TCB* tcb,
    BYTE state,
    const CHAR* caller
    )

/*++

Routine Description:

    Change the TCP connection state

Arguments:

    tcb - Points to the TCP control block
    state - Specifies the new connectio state
    caller - Name of the calling function

Return Value:

    NONE

--*/

{
    static const CHAR* stateNames[] = {
        "CLOSED",
        "LISTEN",
        "SYN_SENT",
        "SYN_RECEIVED",
        "ESTABLISHED",
        "FIN_WAIT_1",
        "FIN_WAIT_2",
        "CLOSING",
        "TIME_WAIT",
        "CLOSE_WAIT",
        "LAST_ACK"
    };

    BYTE oldstate = tcb->tcpstate;
    tcb->tcpstate = state;

    // Debug spew...

    if (XDebugOutLevel < XDBG_TRACE) return;

    DbgPrint("%s ", caller);
    DbgPrint("%s:%d - ", IPADDRSTR(tcb->srcaddr), NTOHS(tcb->srcport));
    DbgPrint("%s:%d: ", IPADDRSTR(tcb->dstaddr), NTOHS(tcb->dstport));
    DbgPrint("%s => %s\n", stateNames[oldstate], stateNames[state]);
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\tcp\pcb.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    pcb.h

Abstract:

    Protocol control blocks

Revision History:

    06/01/2000 davidx
        Created it.

--*/

#ifndef _PCB_H
#define _PCB_H

//------------------------------------------------------------------------
// Protocol control block for TCP/UDP/RAW sockets
//------------------------------------------------------------------------

typedef struct _RECVREQ RECVREQ;
typedef struct _RECVBUF RECVBUF;
typedef struct _SENDREQ SENDREQ;
typedef struct _SENDBUF SENDBUF;
typedef struct _TCPSENDBUF TCPSENDBUF;
typedef struct _PCBOPT PCBOPT;
typedef struct _PCB PCB;
typedef struct _TCB TCB;

// Socket options

typedef struct _PCBOPT {
    UINT sendTimeout;
    UINT recvTimeout;
    UINT maxSendBufsize;
    UINT maxRecvBufsize;
    BYTE ipTtl;
    BYTE ipTos;
    BYTE mcastTtl;
    BYTE unused;
    UINT ipoptlen;
    BYTE* ipopts;
    LINGER linger;

    struct {
        UINT nonblocking:1;
        UINT broadcast:1;
        UINT reuseAddr:1;
        UINT exclusiveAddr:1;
        UINT noNagle:1;
        UINT ipDontFrag:1;
        UINT ipHdrIncl:1;
        UINT noMcastLoopback:1;
        UINT connectSelected:1;
    };
};

// Per-socket multicast group membership information

typedef struct _PcbMcastGroup {
    IPADDR mcastaddr;
    IPADDR ifaddr;
    IfInfo* ifp;
} PcbMcastGroup;

typedef struct _PcbMcastData {
    IPADDR mcastIfAddr;     // outgoing multicast interface address
    IfInfo* mcastIfp;       // and pointer

    // Variable number of multicast groups
    UINT groupCount;
    PcbMcastGroup mcastGroups[1];
} PcbMcastData;

// Protocol control block for TCP/UDP/RAW sockets

typedef struct _PCB {
    //
    // Doubly-linked list pointers
    //  must be the first field!
    //
    LIST_ENTRY links;

    //
    // Magic cookie for debugging purposes and to indicate
    // whether the PCB is being exclusively accessed.
    //
    LONG magicCookie;

    #define ACTIVE_PCB_COOKIE '+BCP'
    #define BUSY_PCB_COOKIE   '*BCP'
    #define CLOSED_PCB_COOKIE '-bcp'

    //
    // PCB type (SOCK_STREAM/SOCK_DGRAM/SOCK_RAW) and protocol number
    //
    BYTE type;
    BYTE protocol;

    //
    // Current TCP connection state
    //
    BYTE tcpstate;

    //
    // PCB flags
    //
    BYTE flags;

    #define PCBFLAG_SEND_SHUTDOWN   0x01    // cannot send data
    #define PCBFLAG_RECV_SHUTDOWN   0x02    // cannot receive data
    #define PCBFLAG_BOUND           0x04    // bound to local address
    #define PCBFLAG_CONNECTED       0x08    // connected to remote address
    #define PCBFLAG_NETPOOL         0x10    // allocated from our private pool
    #define PCBFLAG_REVIVABLE       0x20    // a revivable TCP connection
    #define PCBFLAG_BOTH_SHUTDOWN   (PCBFLAG_SEND_SHUTDOWN|PCBFLAG_RECV_SHUTDOWN)

    #define IsPcbSendShutdown(_pcb) ((_pcb)->flags & PCBFLAG_SEND_SHUTDOWN)
    #define IsPcbRecvShutdown(_pcb) ((_pcb)->flags & PCBFLAG_RECV_SHUTDOWN)
    #define IsPcbBound(_pcb)        ((_pcb)->flags & PCBFLAG_BOUND)
    #define IsPcbConnected(_pcb)    ((_pcb)->flags & PCBFLAG_CONNECTED)

    //
    // Socket wait event flags
    //
    #define PCBEVENT_READ       0x0001  // = FD_READ
    #define PCBEVENT_WRITE      0x0002  // = FD_WRITE
    #define PCBEVENT_ACCEPT     0x0008  // = FD_ACCEPT
    #define PCBEVENT_CONNECT    0x0010  // = FD_CONNECT
    #define PCBEVENT_CLOSE      0x0020  // = FD_CLOSE
    #define PCBEVENT_CONNRESET  0x8000
    #define PCBEVENT_ALL        (-1)

    INT eventFlags;

    //
    // Socket notification event object
    //
    KEVENT blockEvent;

    #define GetPcbWaitEvent(_pcb) (&(_pcb)->blockEvent)

    //
    // Protocol flags (see XP1_* constants in winsock2.h)
    //
    INT protocolFlags;

    // Check if a PCB is for a datagram socket
    #define IsDgramPcb(_pcb) ((_pcb)->protocolFlags & XP1_CONNECTIONLESS)
    #define IsTcb(_pcb) (!IsDgramPcb(_pcb))

    //
    // Pending receive I/O request and receive buffers
    //
    RECVREQ* overlappedRecvs;
    LIST_ENTRY recvbuf;
    ULONG recvbufSize;

    #define HasOverlappedRecv(_pcb) ((_pcb)->overlappedRecvs != NULL)
    #define PcbGetOverlappedRecv(_pcb) ((_pcb)->overlappedRecvs)
    
    #define IsPcbRecvBufFull(_pcb) ((_pcb)->recvbufSize >= (_pcb)->maxRecvBufsize)
    #define IsDgramRecvBufEmpty(_pcb) IsListEmpty(&(_pcb)->recvbuf)
    #define IsTcpRecvBufEmpty(_tcb) ((_tcb)->recvbufSize == 0)
    #define IsPcbRecvBufEmpty(_pcb) \
            (IsDgramPcb(_pcb) ? IsDgramRecvBufEmpty(_pcb) : IsTcpRecvBufEmpty(_pcb))

    //
    // Pending send I/O request and send buffers
    //
    SENDREQ* overlappedSends;
    LIST_ENTRY sendbuf;
    ULONG sendbufSize;

    #define HasOverlappedSend(_pcb) ((_pcb)->overlappedSends != NULL)

    #define IsPcbSendBufEmpty(_pcb) IsListEmpty(&(_pcb)->sendbuf)
    #define IsPcbSendBufFull(_pcb) ((_pcb)->sendbufSize >= (_pcb)->maxSendBufsize)

    //
    // Socket address pairs: dstaddr, srcaddr, dstport, srcport
    //
    union {
        IpAddrPair addrpair;
        IpAddrPair;
    };
    IPADDR bindSrcAddr;

    //
    // Cached route table entry
    // Interface that the socket was explicitly bound to
    //
    RTE* rte;
    IfInfo* bindIfp;

    //
    // Multicast group membership information
    //  (for UDP and RAW sockets only)
    //
    PcbMcastData* mcastData;

    // 
    // Socket error status
    // For TCP socket, this indicates whether the connection
    // has been reset and; and if so, how the connection got reset.
    //
    NTSTATUS errStatus;

    #define PcbGetErrStatus(_pcb) ((_pcb)->errStatus)

    //
    // Socket options
    //
    union {
        PCBOPT options;
        PCBOPT;
    };
};

//
// Allocate and free a PCB structure
//
PCB* PcbCreate(INT type, INT protocol, BYTE allocFlag);
NTSTATUS PcbClose(PCB* pcb, BOOL force);
VOID PcbCloseAll();

//
// Allocate and free socket IP options
//
INLINE VOID PcbFreeIpOpts(PCB* pcb) {
    if (pcb->flags & PCBFLAG_NETPOOL) {
        XnetFree(pcb->ipopts);
    } else {
        SysFree(pcb->ipopts);
    }
    pcb->ipopts = NULL;
    pcb->ipoptlen = 0;
}

INLINE BYTE* PcbSetIpOpts(PCB* pcb, const VOID* opts, UINT optlen) {
    if (pcb->flags & PCBFLAG_NETPOOL) {
        pcb->ipopts = (BYTE*) XnetAlloc0(optlen, PTAG_SOPTS);
    } else {
        pcb->ipopts = (BYTE*) SysAlloc0(optlen, PTAG_SOPTS);
    }

    if (pcb->ipopts) {
        pcb->ipoptlen = optlen;
        CopyMem(pcb->ipopts, opts, optlen);
    }
    return pcb->ipopts;
}

//
// TCP connection block
//
typedef DWORD TCPSEQ;
typedef struct _TCB {
    //
    // Common protocol control block
    //  must be the first field!
    PCB;

    //
    // Pending connection requests
    //
    TCB* parent;
    LIST_ENTRY listenq;
    UINT backlog, maxBacklog;

    #define IsPendingConnReqTcb(_tcb) ((_tcb)->parent != NULL)
    #define TcbHasPendingConnReq(_tcb) \
            ((_tcb)->backlog ? TcbHasConnectedPendingConnReq(_tcb) : FALSE)
    
    //
    // TCP timers
    //  delayedAcks is the number of delay-acked segments;
    //  all other timers are measured in 500ms ticks.
    //
    // NOTE: Be careful when you add or remove fields between
    // delayedAcks and rtt_tick (inclusive). See comments in
    // function TcbReset().
    //
    UINT delayedAcks;
    UINT synTimer;          // connection establishment timer
    UINT xmitTimer;         // retransmission & persist timer
    UINT timeWaitTimer;     // TIME-WAIT & linger timer

    //
    // Send/receive state information
    //
    TCPSEQ snd_isn;         // initial send sequence number
    TCPSEQ snd_una;         // sent but not yet acknowledged
    TCPSEQ snd_nxt;         // buffered but not yet sent
    TCPSEQ snd_end;         // not yet buffered
    TCPSEQ snd_wl1;         // seq and ack numbers of the last ACK 
    TCPSEQ snd_wl2;         // that was used to update snd_wnd
    UINT snd_wnd;           // send window
    UINT snd_cwnd;          // congestion window
    UINT snd_ssthresh;      // slow-start threshold
    UINT snd_mss;           // send MSS
    WORD dupacks;           // number of duplicate ACKs received
    BYTE persistFlag;       // are we probing send window?
    BYTE fastRexmitFlag;    // in fast retransmit / fast recovery mode?

    TCPSEQ rcv_isn;         // initial receive sequence number
    TCPSEQ rcv_nxt;         // next expected receive sequence number
    UINT rcv_wnd;           // receive window
    UINT rcv_mss;           // receive MSS
    UINT rcv_swsthresh;     // receive SWS avoidance threshold

    //
    // Round-trip time measurements
    //
    INT srtt_8;             // smoothed round-trip time, in 1/8 ticks
    INT rttvar_4;           // round-trip time variance, in 1/4 ticks
    UINT RTO;               // retransmission timeout, in ticks
    TCPSEQ rtt_seq;         // the seqno of the segment being timed
    UINT rtt_tick;          // when the timed segment was sent

    #define SRTT_SHIFT      3
    #define SRTT_SCALE      (1 << SRTT_SHIFT)
    #define RTTVAR_SHIFT    2
    #define RTTVAR_SCALE    (1 << RTTVAR_SHIFT)

    //
    // This points to the next send buffer that has been
    // queued up but has yet to be sent
    //
    TCPSENDBUF* sendbufNext;
};

//
// TCP states
//
#define TCPST_CLOSED            0
#define TCPST_LISTEN            1
#define TCPST_SYN_SENT          2
#define TCPST_SYN_RECEIVED      3
#define TCPST_ESTABLISHED       4
#define TCPST_FIN_WAIT_1        5
#define TCPST_FIN_WAIT_2        6
#define TCPST_CLOSING           7
#define TCPST_TIME_WAIT         8
#define TCPST_CLOSE_WAIT        9
#define TCPST_LAST_ACK          10

// Idle states:
//  CLOSED, LISTEN
#define IsTcpIdleState(_tcb) ((_tcb)->tcpstate <= TCPST_LISTEN)
#define IsTcpListenState(_tcb) ((_tcb)->tcpstate == TCPST_LISTEN)

// Synchronized states:
//  ESTABLISHED, FIN_WAIT_1, FIN_WAIT_2, CLOSING
//  TIME_WAIT, CLOSE_WAIT, LAST_ACK
#define IsTcpSyncState(_tcb) ((_tcb)->tcpstate >= TCPST_ESTABLISHED)

// FIN has been received from the peer, no more incoming data
#define IsFINReceived(_tcb) ((_tcb)->tcpstate >= TCPST_CLOSING)

// FIN has been sent to the peer, no more outgoing data
#define IsFINSent(_tcb) ((_tcb)->tcpstate >= TCPST_FIN_WAIT_1 && \
                         (_tcb)->tcpstate != TCPST_CLOSE_WAIT)

// Maximum TCP window size (no window scaling option)
#define MAX_TCP_WNDSIZE 0xffff

// Increment the congestion window size for a TCP connection
INLINE VOID TcbIncrementCwnd(TCB* tcb, UINT incr) {
    if ((tcb->snd_cwnd += incr) > MAX_TCP_WNDSIZE)
        tcb->snd_cwnd = MAX_TCP_WNDSIZE;
}

// Reset the slow-start threshold for a TCP connection
INLINE VOID TcbResetSsthresh(TCB* tcb) {
    // NOTE: unsigned arithmetic
    tcb->snd_ssthresh = (tcb->snd_nxt - tcb->snd_una) >> 1;
    if (tcb->snd_ssthresh < 2*tcb->snd_mss)
        tcb->snd_ssthresh = 2*tcb->snd_mss;
}

//------------------------------------------------------------------------
// Data structures for transmitting and receiving data
//------------------------------------------------------------------------

//
// We use WSAOVERLAPPED structure to keep track of
// the status of an overlapped I/O request. When
// the request is pending, the fields are interpreted
// as follows:
//  Internal - pointer to the I/O request structure
//  InternalHigh - unused
//  Offset - unused
//  OffsetHigh - status code = NETERR_PENDING
//
// After a request is completed, the fields are
// interpreted differently:
//  Internal - unused
//  InternalHigh - I/O request completion flags
//  Offset - number of bytes actually transferred
//  OffsetHigh - status code != NETERR_PENDING
//
#define _ioreq      Internal
#define _ioflags    InternalHigh
#define _ioxfercnt  Offset
#define _iostatus   OffsetHigh

// A pending receive request

typedef struct _PcbOverlappedReq {
    PCB* pcb;
    PRKEVENT overlappedEvent;
    WSAOVERLAPPED* overlapped;
} PcbOverlappedReq;

typedef struct _RECVREQ {
    PcbOverlappedReq;   // must be the first field
    DWORD flags;
    DWORD* bytesRecv;
    BYTE* buf;
    UINT buflen;
    struct sockaddr_in* fromaddr;
};

// Complete an overlapped receive request
VOID PcbCompleteOverlappedSendRecv(PcbOverlappedReq* req, NTSTATUS status);

#define PcbCompleteOverlappedRecv(_recvreq, _status) \
        PcbCompleteOverlappedSendRecv((PcbOverlappedReq*) (_recvreq), _status)

// Clear all overlapped receive requests
#define PcbClearOverlappedRecvs(_pcb, _status) { \
            if ((_pcb)->overlappedRecvs) { \
                PcbCompleteOverlappedRecv((_pcb)->overlappedRecvs, _status); \
            } \
        }

// Set the sender's address for received data packet
#define SetRecvReqFromAddr(_recvreq, _fromaddr, _fromport) { \
            if ((_recvreq)->fromaddr) { \
                (_recvreq)->fromaddr->sin_port = (_fromport); \
                (_recvreq)->fromaddr->sin_addr.s_addr = (_fromaddr); \
            } \
        }

// Buffered incoming data

typedef struct _RECVBUF {
    LIST_ENTRY links;   // !! must be the first field
    UINT datalen;
    union {
        // For TCP sockets, points to the start of
        // the remaining data in this buffer.
        struct {
            TCPSEQ seqnext;
            WORD dataoffset;
            BYTE tcpflags;
        };

        // For UDP/RAW sockets, remembers the sender
        // of the datagram.
        struct {
            IPADDR fromaddr;
            IPPORT fromport;
        };
    };
};

// A send request

typedef struct _SENDREQ {
    PcbOverlappedReq;   // must be the first field
    WSABUF* bufs;
    UINT bufcnt;
    UINT sendtotal;
    struct sockaddr_in* toaddr;
};

// Queue up an overlapped send request
NTSTATUS PcbQueueOverlappedSend(PCB* pcb, SENDREQ* sendreq);

// Complete an overlapped send request
#define PcbCompleteOverlappedSend(_sendreq, _status) \
        PcbCompleteOverlappedSendRecv((PcbOverlappedReq*) (_sendreq), _status)

// Clear all overlapped send requests
#define PcbClearOverlappedSends(_pcb, _status) { \
            if ((_pcb)->overlappedSends) { \
                PcbCompleteOverlappedSend((_pcb)->overlappedSends, _status); \
            } \
        }

// Dequeue the overlapped send request
INLINE SENDREQ* PcbGetOverlappedSend(PCB* pcb) {
    SENDREQ* sendreq = pcb->overlappedSends;
    pcb->overlappedSends = NULL;
    return sendreq;
}

// Buffer outgoing data (common to UDP and TCP)

typedef struct _SENDBUF {
    LIST_ENTRY links;   // !! must be the first field
    LONG refcount;
    UINT datalen;
    PCB* pcb;
};

// Get the pointer to the Packet that contains a SENDBUF. For our
// outgoing packets (either UDP/RAW datagrams or TCP segments), we
// store a SENDBUF structure right after the packet header.
#define GetSendbufPkt(_sendbuf) \
        ((Packet*) ((BYTE*) (_sendbuf) - PKTHDRLEN))

#define IsSendbufActive(_sendbuf) ((_sendbuf)->refcount > 1)
#define SendbufIncRef(_sendbuf) ((_sendbuf)->refcount += 1)
#define SendbufDecRef(_sendbuf) ((_sendbuf)->refcount -= 1)
#define SendbufRelease(_sendbuf) { \
            if (SendbufDecRef(_sendbuf) == 0) { \
                XnetFreePacket(GetSendbufPkt(_sendbuf)); \
            } \
        }

// TCP send buffers

typedef struct _TCPSENDBUF {
    SENDBUF;
    BYTE* pktdata;      // saved packet data pointer and length
    UINT pktdatalen;    //
    TCPSEQ seq;         // starting sequence number for this TCP segment
    TCPSEQ seqnext;     // the first seqno after this segment
    WORD retries;       // number of times this segment has been rexmitted
    BYTE tcpflags;      // TCP segment flags
    BYTE tcphdrlen;     // TCP segment header length
    UINT firstSendTime; // the time this segment was first sent
};

#define TcbSendbufNil(_tcb) ((TCPSENDBUF*) &(_tcb)->sendbuf)
#define TcbFirstSendbuf(_tcb) ((TCPSENDBUF*) (_tcb)->sendbuf.Flink)
#define TcbSendbufFlink(_sendbuf) ((TCPSENDBUF*) (_sendbuf)->links.Flink)
#define TcbHasPendingSend(_tcb) ((_tcb)->sendbufNext != TcbSendbufNil(_tcb))

// Loop through all transmission buffers for a TCP connection block

#define LOOP_THRU_TCB_SENDBUF(_tcb, _sendbuf) { \
            TCPSENDBUF* _next; \
            _sendbuf = TcbFirstSendbuf(_tcb); \
            for (; _sendbuf != TcbSendbufNil(_tcb); _sendbuf = _next) { \
                _next = TcbSendbufFlink(_sendbuf);

#define END_TCB_SENDBUF_LOOP \
            } \
        }

#define TcbRecvbufNil(_tcb) ((RECVBUF*) &(_tcb)->recvbuf)
#define TcbLastRecvbuf(_tcb) ((RECVBUF*) (_tcb)->recvbuf.Blink)
#define TcbRecvbufBlink(_recvbuf) ((RECVBUF*) (_recvbuf)->links.Blink)
#define TcbRecvbufFlink(_recvbuf) ((RECVBUF*) (_recvbuf)->links.Flink)

//------------------------------------------------------------------------
// Global PCB list
//------------------------------------------------------------------------

extern LIST_ENTRY PcbList;
extern ULONG PcbCount;

#define LOOP_THRU_PCB_LIST(_pcb) { \
            PCB* _next; \
            _pcb = (PCB*) PcbList.Flink; \
            for (; _pcb != (PCB*) &PcbList; _pcb = _next) { \
                _next = (PCB*) _pcb->links.Flink;

#define END_PCB_LIST_LOOP \
            } \
        }
//
// Insert a PCB into the global list
//
INLINE VOID PcbInsertToList(PCB* pcb) {
    KIRQL irql = RaiseToDpc();
    InsertHeadList(&PcbList, &pcb->links);
    LowerFromDpc(irql);
}

#define IsPcbListEmpty() IsListEmpty(&PcbList)

//
// Block the current thread until the specified
// socket event is signalled
//
NTSTATUS PcbWaitForEvent(PCB* pcb, INT eventMask, UINT timeout);
INT PcbCheckSelectEvents(PCB* pcb, INT eventMasks, INT setwait);
INLINE VOID PcbClearSelectEvents(PCB* pcb) {
    pcb->eventFlags = 0;
}

//
// Flush a socket's receive buffers
//
INLINE VOID PcbFlushRecvBuffers(PCB* pcb) {
    while (!IsListEmpty(&pcb->recvbuf)) {
        VOID* head = RemoveHeadList(&pcb->recvbuf);
        XnetFree(head);
    }
    pcb->recvbufSize = 0;
}

//
// Public PCB functions
//
NTSTATUS PcbBind(PCB* pcb, IPADDR srcaddr, IPPORT srcport);
NTSTATUS PcbConnectDgram(PCB* pcb, IPADDR dstaddr, IPPORT dstport);
NTSTATUS PcbSendDgram(PCB* tcb, SENDREQ* sendreq);
NTSTATUS PcbRecvDgram(PCB* pcb, RECVREQ* recvreq);
NTSTATUS PcbShutdownDgram(PCB* pcb, BYTE flags);
NTSTATUS PcbUpdateBufferSize(PCB* pcb, INT sendBufsize, INT recvBufsize);
NTSTATUS PcbSetMcastIf(PCB* pcb, IPADDR ifaddr);
NTSTATUS PcbChangeMcastGroup(PCB* pcb, IPADDR mcastaddr, IPADDR ifaddr, BOOL add);

NTSTATUS TcbConnect(TCB* tcb, IPADDR dstaddr, IPPORT dstport, BOOL synAck);
NTSTATUS TcbListen(TCB* tcb, INT backlog);
NTSTATUS TcbAccept(TCB* tcb, TCB** newtcb);
NTSTATUS TcbSend(TCB* tcb, SENDREQ* sendreq);
NTSTATUS TcbRecv(TCB* tcb, RECVREQ* recvreq);
NTSTATUS TcbShutdown(TCB* tcb, BYTE flags, BOOL apicall);
BOOL TcbHasConnectedPendingConnReq(TCB* tcb);

#endif // !_PCB_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\tcp\tcpinit.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    tcpinit.c

Abstract:

    TCP/UDP initialization and cleanup related functions.

Revision History:

    05/24/2000 davidx
        Created it.

    06/30/2000 davidx
        Added TCP timer functions here.

--*/

#include "precomp.h"

//
// TCP timer objects and function
//
PRIVATE KTIMER TcpFastTimer;
PRIVATE KDPC TcpFastTimerDpc;
PRIVATE UINT TcpTimerFlag;

// TCP slow timer tick count (incremented every 500ms)
UINT TcpTickCount;

// Fast TCP timer fires every 200ms
#define FAST_TCP_TIMER_FREQ 5


PRIVATE VOID
TcpFastTimerProc(
    PKDPC dpc,
    VOID* context,
    VOID* param1,
    VOID* param2
    )

/*++

Routine Description:

    TCP fast (200ms cycle) timer routine

Arguments:

    dpc, context, param1, param2 - DPC function parameters

Return Value:

    NONE

--*/

{
    PCB* pcb;
    TCB* tcb;
    UINT isSlowTick;

    TcpTimerFlag = TcpTimerFlag << 1;

    // The slow timer has 500ms cycle.
    // NOTE: 500 is not an exact multiple of 200. So we end up firing
    // once after 400ms and again after 600ms. The approximation should
    // be good enough for our purpose. It saves us from having two timers.
    isSlowTick = (TcpTimerFlag & 0x24);
    if (isSlowTick) TcpTickCount++;

    LOOP_THRU_PCB_LIST(pcb)

        if (!IsTcb(pcb)) continue;
        tcb = (TCB*) pcb;

        // The fast timer is used to implement the TCP delayed-ACK feature
        if (tcb->delayedAcks) {
            TcbEmitACK(tcb);
        }

        if (isSlowTick) {
            // Connection establishment timer expired
            if (tcb->synTimer && --tcb->synTimer == 0) {
                if (TcbReset(tcb, NETERR_TIMEOUT) == NULL) continue;
            }

            // Transmission timer expired
            if (tcb->xmitTimer && --tcb->xmitTimer == 0) {
                if (TcbXmitTimeout(tcb) == NULL) continue;
            }

            // Time-wait period expired or linger period expired
            if (tcb->timeWaitTimer && --tcb->timeWaitTimer == 0) {
                ASSERT(TcbIsLingering(tcb));
                TcbDelete(tcb);
            }
        }

    END_PCB_LIST_LOOP

    // IP timer fires once every second
    if (TcpTimerFlag == (1 << FAST_TCP_TIMER_FREQ)) {
        TcpTimerFlag = 1;
        IpTimerProc();
    }
}


NTSTATUS
TcpInitialize()

/*++

Routine Description:

    Initialize TCP/UDP protocol module

Arguments:

    NONE

Return Value:

    Status code

--*/

{
    LARGE_INTEGER dueTime;
    UINT period;
    NTSTATUS status;

    InitializeListHead(&PcbList);
    InitializeListHead(&DeadTcbList);
    PcbCount = 0;

    // Initialize the TCP timers:
    //  fast timer has a 200ms cycle
    //  initial due time is 1sec

    TcpTickCount = 1;
    dueTime.QuadPart = -10000000;

    period = 1000 / FAST_TCP_TIMER_FREQ;
    KeInitializeDpc(&TcpFastTimerDpc, TcpFastTimerProc, NULL);
    KeInitializeTimer(&TcpFastTimer);
    KeSetTimerEx(&TcpFastTimer, dueTime, period, &TcpFastTimerDpc);

    // Initialize the IP module
    status = IpInitialize();
    TcpTimerFlag = 1;
    return status;
}


VOID
TcpCleanup()

/*++

Routine Description:

    Clean up TCP/UDP protocol module

Arguments:

    NONE

Return Value:

    NONE

--*/

{
    RUNS_AT_DISPATCH_LEVEL

    if (!TcpTimerFlag) return;
    TcpTimerFlag = 0;

    // Cancel TCP timers
    KeCancelTimer(&TcpFastTimer);

    // Clean up the IP module
    IpCleanup();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\tcp\tcpimpl.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    tcpimpl.h

Abstract:

    TCP implementation header file

Revision History:

    05/31/2000 davidx
        Created it.

--*/

#ifndef _TCPIMPL_H
#define _TCPIMPL_H

//
// Sequence number related functions and macros
//
INLINE TCPSEQ TcbGetIsn() {
    // Get the initial sequence number for a new TCP connection.
    // The return value is a 32-bit integer bound to
    // a real-time clock and whose value is incremented
    // every 4 microseconds.
    LARGE_INTEGER time;

    KeQuerySystemTime(&time);
    return (TCPSEQ) (time.QuadPart / 40);
}

#define SEQ_LT(a, b)    ((INT) ((a) - (b)) < 0)
#define SEQ_LE(a, b)    ((INT) ((a) - (b)) <= 0)
#define SEQ_GT(a, b)    ((INT) ((a) - (b)) > 0)
#define SEQ_GE(a, b)    ((INT) ((a) - (b)) >= 0)

// Return the sequence numbers in a TCP segment (in host byte order)
#define SEG_SEQ(_tcphdr) NTOHL((_tcphdr)->seqnum)
#define SEG_ACK(_tcphdr) NTOHL((_tcphdr)->acknum)
#define SEG_WIN(_tcphdr) NTOHS((_tcphdr)->window)
#define SEG_URG(_tcphdr) NTOHS((_tcphdr)->urgent)

// Return the length of a TCP segment (counting SYN and FIN)
#define SEG_LEN(_tcphdr, _datalen) \
        ((_datalen) + \
         (((_tcphdr)->flags & TCP_SYN) ? 1 : 0) + \
         (((_tcphdr)->flags & TCP_FIN) ? 1 : 0))

//
// Internal function prototypes
//
VOID PcbCleanup(PCB* pcb, BOOL revivable);
VOID PcbSetupIpHeader(PCB* pcb, Packet* pkt, IpAddrPair* addrpair);
PCB* PcbFindMatch(IPADDR, IPPORT, IPADDR, IPPORT, BYTE, BYTE);
VOID TcbInit(TCB* tcb);
BOOL TcbClose(TCB* tcb, BOOL force);
BOOL TcbStartOutput(TCB* tcb);
TCB* TcbReset(TCB* tcb, NTSTATUS status);
TCB* TcbCloneChild(TCB* tcb);
TCB* TcbXmitTimeout(TCB* tcb);
VOID TcbDoFastRexmit(TCB* tcb);

VOID TcbSendSegment(TCB* tcb, TCPSENDBUF* sendbuf);
NTSTATUS TcbEmitSYN(TCB* tcb, BOOL synAck);
NTSTATUS TcbEmitFIN(TCB* tcb);
VOID TcbEmitACK(TCB* tcb);
VOID TcbEmitRST(IfInfo*, IpAddrPair*, TCPSEQ, TCPSEQ, BYTE);

// Return the effective snd_nxt value for a TCP connection
// NOTE: we cannot use TCB.snd_nxt field directly here
// because the way we're doing persisting causes snd_nxt
// to go past the send window.
INLINE TCPSEQ TcbSndNxt(TCB* tcb) {
    TCPSEQ sndmax = tcb->snd_wl2 + tcb->snd_wnd;
    return (IsTcpSyncState(tcb) && SEQ_GT(tcb->snd_nxt, sndmax)) ?
                sndmax :
                tcb->snd_nxt;
}

// Send a RST segment to the TCP connection peer
INLINE VOID TcbResetPeer(TCB* tcb) {
    TcbEmitRST(tcb->bindIfp,
               &tcb->addrpair,
               TcbSndNxt(tcb),
               tcb->rcv_nxt,
               TCP_ACK);
}

// Multicast related functions
VOID PcbCleanupMcastData(PCB* pcb);
BOOL PcbCheckMcastGroup(PCB* pcb, IPADDR mcastaddr);
IfInfo* PcbGetMcastIf(PCB* pcb);
NTSTATUS PcbSendMcastDgram(PCB* pcb, Packet* pkt, IPADDR dstaddr);

// Forcefully delete PCB and TCB
#define PcbDelete(_pcb) PcbClose(_pcb, TRUE)
#define TcbDelete(_tcb) PcbClose((PCB*) (_tcb), TRUE)

// Is this a TCP socket lingering after being closed?
#define TcbIsLingering(_tcb) ((_tcb)->magicCookie == CLOSED_PCB_COOKIE)

// Calculate the checksum for an outgoing TCP/UDP packet
#define CALC_TCPUDP_CHECKSUM(_pkt, _addrpair, _protocol, _checksum) { \
            PseudoHeader _pseudohdr; \
            _pseudohdr.srcaddr = (_addrpair)->srcaddr; \
            _pseudohdr.dstaddr = (_addrpair)->dstaddr; \
            _pseudohdr.zero = 0; \
            _pseudohdr.protocol = (_protocol); \
            _pseudohdr.length = HTONS((_pkt)->datalen); \
            _checksum = tcpipxsum(0, &_pseudohdr, sizeof(_pseudohdr)); \
            _checksum = ~tcpipxsum(_checksum, (_pkt)->data, (_pkt)->datalen); \
        }

// Set up the TCP header information in an outgoing TCB segment
INLINE VOID
FILL_TCPHEADER(
    Packet* pkt,
    IpAddrPair* addrpair,
    TCPSEQ seq,
    TCPSEQ ack,
    BYTE hdrlen,
    BYTE flags,
    WORD wnd
    )
{
    TcpHeader* tcphdr;
    UINT checksum;
    tcphdr = GETPKTDATA(pkt, TcpHeader);
    tcphdr->srcport = addrpair->srcport;
    tcphdr->dstport = addrpair->dstport;
    tcphdr->seqnum = HTONL(seq);
    tcphdr->acknum = HTONL(ack);
    SETTCPHDRLEN(tcphdr, hdrlen);
    tcphdr->flags = flags;
    tcphdr->window = HTONS(wnd);
    tcphdr->checksum = tcphdr->urgent = 0;
    CALC_TCPUDP_CHECKSUM(pkt, addrpair, IPPROTOCOL_TCP, checksum);
    tcphdr->checksum = (WORD) checksum;
}

// Set up the UDP header information in an outgoing UDP datagram
INLINE VOID FILL_UDPHEADER(Packet* pkt, IpAddrPair* addrpair) {
    UdpHeader* udphdr;
    UINT checksum;
    udphdr = GETPKTDATA(pkt, UdpHeader);
    udphdr->srcport = addrpair->srcport;
    udphdr->dstport = addrpair->dstport;
    udphdr->length = (WORD) HTONS(pkt->datalen);
    udphdr->checksum = 0;
    CALC_TCPUDP_CHECKSUM(pkt, addrpair, IPPROTOCOL_UDP, checksum);
    udphdr->checksum = (WORD) (checksum ? checksum : ~checksum);
}

// Signal PCB events
#define PcbSignalEvent(_pcb, _eventMask) { \
            if ((_pcb)->eventFlags & (_eventMask)) { \
                SetKernelEvent(GetPcbWaitEvent(_pcb)); \
            } \
        }

// Queue up a receive user request on a socket
NTSTATUS PcbQueueOverlappedRecv(PCB* pcb, RECVREQ* recvreq);

//
// Change TCP connection state:
//
#if DBG
VOID TcbSetState(TCB* tcb, BYTE state, const CHAR* caller);
#else
#define TcbSetState(_tcb, _state, _caller) \
        (_tcb)->tcpstate = (_state)
#endif

//
// Global variable declarations
//
extern UINT cfgMSL;
extern UINT cfgMaxDelayedAcks;
extern UINT cfgConnectTimeout;
extern UINT cfgMaxXmitRetries;
extern UINT cfgMinRexmitTimeout;
extern UINT cfgMaxRexmitTimeout;
extern LIST_ENTRY DeadTcbList;

//
// Setting various TCP timers
//
INLINE VOID TcbSetSynTimer(TCB* tcb, UINT ticks) {
    tcb->synTimer = ticks;
}

INLINE VOID TcbSetTimeWaitTimer(TCB* tcb, UINT ticks) {
    if (tcb->timeWaitTimer == 0 || tcb->timeWaitTimer > ticks)
        tcb->timeWaitTimer = ticks;
}

//
// Stop TCP fast retransmit/recovery mode
//
INLINE VOID TcbStopFastRexmitMode(TCB* tcb) {
    tcb->fastRexmitFlag = 0;
    tcb->dupacks = 0;
}

//
// TCP statistics
//
typedef struct _TCPSTATS {
    UINT rexmitTimeouts;
    UINT fastRexmits;
    UINT persists;
    UINT misordered;
} TCPSTATS;

extern TCPSTATS TcpStats;

//
// Figure out the default source address that we should
// use for a TCP or UDP connection, given the outgoing route.
//
INLINE IPADDR PcbGetDefaultSrcAddr(RTE* rte) {
    return ((rte->flags & RTEFLAG_HOST) &&
            (rte->nexthop == IPADDR_LOOPBACK)) ?
                rte->dstaddr :
                rte->ifp->ipaddr;
}

#endif // !_TCPIMPL_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\test\gethost\precomp.h ===
#include "xnetp.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\test\sources.inc ===
TARGETPATH=obj
TARGETTYPE=PROGRAM
UMTYPE=xboxapp

INCLUDES=$(INCLUDES);$(PRIVATE_INC_PATH);$(SDK_INC_PATH);..\lib

TARGETLIBS= \
    ..\lib\$(O)\xnettest.lib \
    $(LIBRARY_PATH)\xnet$(D).lib
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\tcp\udp.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    udp.c

Abstract:

    UDP protocol related functions

Revision History:

    05/27/2000 davidx
        Created it.

--*/

#include "precomp.h"
#include "..\dhcp\dhcp.h"


PRIVATE VOID
PcbDeliverDgram(
    PCB* pcb,
    Packet* pkt,
    IPADDR fromaddr,
    IPPORT fromport
    )

/*++

Routine Description:

    Deliver a received datagram to the specified socket

Arguments:

    pcb - Points to the protcol control block
    pkt - Points to the received datagram
    fromaddr, fromport - The sender's address

Return Value:

    NONE

--*/

{
    RECVBUF* recvbuf;

    //
    // If there are datagrams queued up on this socket
    // that haven't been processed, then we must not
    // have any pending recv requests.
    //
    // Otherwise, check if there is a pending recv request
    // that can be satisfied with the incoming datagram.
    //
    if (HasOverlappedRecv(pcb)) {
        WSAOVERLAPPED* overlapped;
        RECVREQ* recvreq;
        UINT copycnt;
        NTSTATUS status;

        ASSERT(IsDgramRecvBufEmpty(pcb));
        recvreq = PcbGetOverlappedRecv(pcb);
        overlapped = recvreq->overlapped;

        SetRecvReqFromAddr(recvreq, fromaddr, fromport);

        copycnt = min(pkt->datalen, recvreq->buflen);
        CopyMem(recvreq->buf, pkt->data, copycnt);

        overlapped->_ioxfercnt = copycnt;
        if (copycnt < pkt->datalen) {
            overlapped->_ioflags = MSG_PARTIAL;
            status = NETERR_MSGSIZE;
        } else {
            overlapped->_ioflags = 0;
            status = NETERR_OK;
        }

        PcbCompleteOverlappedRecv(recvreq, status);
        return;
    }

    //
    // If the unprocessed receive queue is full,
    // we'll drop the incoming packet. The alternative
    // is to drop the oldest packet.
    //
    if (IsPcbRecvBufFull(pcb)) return;

    // Make a copy of the incoming datagram
    // NOTE: we're not copying protocol header data here.

    recvbuf = (RECVBUF*) XnetAlloc(sizeof(RECVBUF) + pkt->datalen, PTAG_RBUF);
    if (!recvbuf) {
        WARNING_("Received datagram discarded because of no memory");
        WARNING_("  local = %d, remote = %s:%d",
            NTOHS(pcb->srcport),
            IPADDRSTR(fromaddr),
            NTOHS(fromport));
        return;
    }

    CopyMem(recvbuf+1, pkt->data, pkt->datalen);
    recvbuf->datalen = pkt->datalen;
    pcb->recvbufSize += pkt->datalen;
    recvbuf->fromaddr = fromaddr;
    recvbuf->fromport = fromport;

    InsertTailList(&pcb->recvbuf, &recvbuf->links);
    PcbSignalEvent(pcb, PCBEVENT_READ);
}


UINT
PcbDeliverRecvDgramMulti(
    Packet* pkt,
    IPADDR toaddr,
    IPPORT toport,
    IPADDR fromaddr,
    IPPORT fromport,
    BYTE type,
    BYTE protocol
    )

/*++

Routine Description:

    Deliver a received datagram to all applicable socket(s)

Arguments:

    pkt - Points to the received datagram
    toaddr, toport - The destination address of the datagram
    fromaddr, fromport - The sender's address
    type - Specifies the socket type (SOCK_DGRAM or SOCK_RAW)
    protocol - Specifies the protocol number

Return Value:

    Number of sockets this datagram was delivered to

--*/

{
    PCB* pcb;
    UINT delivered = 0;

    LOOP_THRU_PCB_LIST(pcb)

        if (pcb->type != type ||
            pcb->protocol != protocol && pcb->protocol ||
            pcb->srcport != toport ||
            IS_MCAST_IPADDR(toaddr) && !PcbCheckMcastGroup(pcb, toaddr) ||
            pcb->dstaddr != fromaddr && pcb->dstaddr ||
            pcb->dstport != fromport && pcb->dstport ||
            !IsPcbBound(pcb) ||
            IsPcbRecvShutdown(pcb))
            continue;

        PcbDeliverDgram(pcb, pkt, fromaddr, fromport);
        delivered++;

    END_PCB_LIST_LOOP

    return delivered;
}


NTSTATUS
PcbRecvDgram(
    PCB* pcb,
    RECVREQ* recvreq
    )

/*++

Routine Description:

    Handle a user request to receive data from a datagram socket

Arguments:

    pcb - Points to the protocol control block
    recvreq - Points to the receive request information

Return Value:

    Status code

Note:

    This call always return immediately. For blocking calls,
    we assume the caller has done the necessary wait.

--*/

{
    NTSTATUS status;
    KIRQL irql = RaiseToDpc();

    if (!IsDgramRecvBufEmpty(pcb)) {
        //
        // If there is unprocessed datagram,
        // we must not have any pending recv requests.
        // So we can satisfy the request immediately.
        //
        RECVBUF* recvbuf;
        DWORD copycnt;

        recvbuf = (RECVBUF*) RemoveHeadList(&pcb->recvbuf);
        pcb->recvbufSize -= recvbuf->datalen;
        LowerFromDpc(irql);

        SetRecvReqFromAddr(recvreq, recvbuf->fromaddr, recvbuf->fromport);

        if (recvbuf->datalen <= recvreq->buflen) {
            copycnt = recvbuf->datalen;
            recvreq->flags = 0;
            status = NETERR_OK;
        } else {
            copycnt = recvreq->buflen;
            recvreq->flags = MSG_PARTIAL;
            status = NETERR_MSGSIZE;
        }

        *recvreq->bytesRecv = copycnt;
        CopyMem(recvreq->buf, recvbuf+1, copycnt);
        XnetFree(recvbuf);
        return status;
    }

    status = PcbQueueOverlappedRecv(pcb, recvreq);
    LowerFromDpc(irql);
    return status;
}


VOID
UdpReceivePacket(
    Packet* pkt
    )

/*++

Routine Description:

    Receive a UDP datagram

Arguments:

    pkt - Points to the received UDP datagram

Return Value:

    NONE

--*/

{
    IpHeader* iphdr;
    PseudoHeader pseudohdr;
    UdpHeader* udphdr;
    UINT udplen;
    INT delivered;
    IPADDR dstaddr;

    RUNS_AT_DISPATCH_LEVEL

    // Validate header length field
    if (pkt->datalen < UDPHDRLEN) goto discard;

    iphdr = GETPKTIPHDR(pkt);
    pseudohdr.srcaddr = iphdr->srcaddr;
    pseudohdr.dstaddr = dstaddr = iphdr->dstaddr;
    pseudohdr.zero = 0;
    pseudohdr.protocol = IPPROTOCOL_UDP;

    udphdr = GETPKTDATA(pkt, UdpHeader);
    udplen = NTOHS(udphdr->length);
    pseudohdr.length = udphdr->length;

    if (udplen < UDPHDRLEN || udplen > pkt->datalen)
        goto discard;

    // Validate checksum if it's present

    if (udphdr->checksum) {
        UINT checksum;
        checksum = tcpipxsum(0, &pseudohdr, sizeof(pseudohdr));
        if (tcpipxsum(checksum, udphdr, udplen) != 0xffff)
            goto discard;
    }

    pkt->data += UDPHDRLEN;
    pkt->datalen = udplen - UDPHDRLEN;

    if (udphdr->dstport == 0)
        goto discard;

    delivered = 0;

    //
    // Hardwired hooks to the DHCP client
    //
    if (udphdr->dstport == DHCP_CLIENT_PORT &&
        IfDhcpEnabled(pkt->recvifp)) {
        // NOTE: we retain ownership of the packet here,
        //  i.e. DhcpReceivePacket must not call XnetCompletePacket.
        DhcpReceivePacket(pkt->recvifp, pkt);
        delivered++;
    }

    //
    // If this is a unicast datagram, then we'll deliver it
    // to at most one matching socket. Broadcast or unicast
    // datagrams are delivered to all matching datagrams.
    //
    if (!IS_MCAST_IPADDR(dstaddr) && !IfBcastAddr(pkt->recvifp, dstaddr)) {
        PCB* pcb = PcbFindMatch(
                    dstaddr,
                    udphdr->dstport,
                    pseudohdr.srcaddr,
                    udphdr->srcport,
                    SOCK_DGRAM,
                    IPPROTOCOL_UDP);

        if (pcb && IsPcbBound(pcb) && !IsPcbRecvShutdown(pcb)) {
            PcbDeliverDgram(pcb, pkt, pseudohdr.srcaddr, udphdr->srcport);
            delivered++;
        }
    } else {
        delivered += PcbDeliverRecvDgramMulti(
                        pkt,
                        dstaddr,
                        udphdr->dstport,
                        pseudohdr.srcaddr,
                        udphdr->srcport,
                        SOCK_DGRAM,
                        IPPROTOCOL_UDP);
    }

    if (delivered) {
        XnetCompletePacket(pkt, NETERR_OK);
        return;
    }

    // If the datagram wasn't delivered,
    // send out a port-unreachable ICMP message.
    IcmpSendError(
        pkt,
        ICMPTYPE_DESTINATION_UNREACHABLE,
        ICMPCODE_PORT_UNREACHABLE);

discard:
    XnetCompletePacket(pkt, NETERR_DISCARDED);
}


VOID
RawReceivePacket(
    Packet* pkt
    )

/*++

Routine Description:

    Receive a raw IP datagram

Arguments:

    pkt - Points to the received datagram

Return Value:

    NONE

--*/

{
    UINT delivered;
    BYTE protocol;
    IpHeader* iphdr;

    RUNS_AT_DISPATCH_LEVEL

    // Since pkt->data points to after the IP header,
    // we need to fix it here.
    iphdr = GETPKTIPHDR(pkt);
    pkt->datalen += (pkt->data - (BYTE*) iphdr);
    pkt->data = (BYTE*) iphdr;

    if ((protocol = iphdr->protocol) != 0) {
        //
        // The same datagram could be delivered to
        // multiple sockets. This is to follow w2k behavior.
        //
        delivered = PcbDeliverRecvDgramMulti(
                        pkt,
                        iphdr->dstaddr,
                        0,
                        iphdr->srcaddr,
                        0,
                        SOCK_RAW,
                        protocol);
        
        if (delivered) {
            XnetCompletePacket(pkt, NETERR_OK);
            return;
        }

        if (protocol != IPPROTOCOL_IGMP &&
            protocol != IPPROTOCOL_ICMP) {
            IcmpSendError(
                pkt,
                ICMPTYPE_DESTINATION_UNREACHABLE,
                ICMPCODE_PROTOCOL_UNREACHABLE);
        }
    }

    XnetCompletePacket(pkt, NETERR_DISCARDED);
}


VOID
UdpSendPacketInternal(
    Packet* pkt,
    IpAddrPair* addrpair,
    IfInfo* ifp
    )

/*++

Routine Description:

    Send out a UDP datagram (used internally by DHCP client)

Arguments:

    pkt - Points to the packet to be sent
    addrpair - Specifies source & destination addresses and ports
    ifp - Specifies the outgoing interface

Return Value:

    NONE

--*/

{
    // Compose UDP header
    pkt->data -= UDPHDRLEN;
    pkt->datalen += UDPHDRLEN;
    FILL_UDPHEADER(pkt, addrpair);

    // Call the IP layer to send out the packet
    IpSendPacketInternal(pkt, addrpair->srcaddr, addrpair->dstaddr, IPPROTOCOL_UDP, ifp);
}


PRIVATE NTSTATUS
PcbPrepareSendto(
    PCB* pcb,
    IpAddrPair* addrpair,
    RTE** cachedRte
    )

/*++

Routine Description:

    Choose the proper source address for a sendto call

Arguments:

    pcb - Points to the protocol control block
    addrpair - Specifies source & destination addresses and ports
    cachedRte - Stored the cached route entry

Return Value:

    NONE

--*/

{
    NTSTATUS status = NETERR_OK;
    KIRQL irql = RaiseToDpc();

    if (IS_MCAST_IPADDR(addrpair->dstaddr)) {
        // Sendto is called with a multicast destination address.
        // We'll choose the outgoing interface and source address
        // based on the setting of IP_MULTICAST_IF option.
        IfInfo* ifp = PcbGetMcastIf(pcb);
        if (ifp != NULL)
            addrpair->srcaddr = ifp->ipaddr;
        else
            status = NETERR_UNREACHABLE;
    } else {
        // Trying to find a route to the sendto destination.
        // And use that interface's address as our source address.
        RTE* rte = IpFindRTE(addrpair->dstaddr, NULL);
        if (rte != NULL) {
            *cachedRte = rte;
            RteAddRef(rte);
            addrpair->srcaddr = PcbGetDefaultSrcAddr(rte);
        } else {
            status = NETERR_UNREACHABLE;
        }
    }
    
    LowerFromDpc(irql);
    return status;
}


//
// Completion routine that's called when an outgoing datagram is sent
// 
PRIVATE VOID DgramSendCompletionProc(Packet* pkt, NTSTATUS status) {
    SENDBUF* sendbuf = GETPKTBUF(pkt, SENDBUF);
    KIRQL irql = RaiseToDpc();
    LONG refcount;
    PCB* pcb;

    if ((refcount = SendbufDecRef(sendbuf)) > 0) {
        pcb = sendbuf->pcb;
        RemoveEntryList(&sendbuf->links);
        pcb->sendbufSize -= sendbuf->datalen;

        if (!IsPcbSendBufFull(pcb)) {
            if (HasOverlappedSend(pcb)) {
                SENDREQ* sendreq = PcbGetOverlappedSend(pcb);

                status = PcbSendDgram(pcb, sendreq);
                sendreq->overlapped->_ioxfercnt = sendreq->sendtotal;
                PcbCompleteOverlappedSend(sendreq, status);
            } else {
                PcbSignalEvent(pcb, PCBEVENT_WRITE);
            }
        }
    }

    LowerFromDpc(irql);
    XnetFreePacket(pkt);
}


NTSTATUS
PcbSendDgram(
    PCB* pcb,
    SENDREQ* sendreq
    )

/*++

Routine Description:

    Send out a datagram from a UDP or raw socket

Arguments:

    pcb - Points to the protocol control block
    sendreq - Points to send request information

Return Value:

    Status code

Note:

    This function always return immediately. For blocking operation,
    we assume the caller has taken care of any necessary wait.

    The winsock layer checks to see if the send buffer is full before
    calling this function. In the case that:
        old sendbuf size + the datagram size > max sendbuf size
    we'll temporarily go over the send buffer size limit.

--*/

{
    SENDBUF* sendbuf;
    Packet* pkt;
    UINT hdrsize;
    KIRQL irql;
    IpAddrPair* addrpair;
    IpAddrPair sendtoAddr;
    RTE** cachedRte;
    RTE* sendtoRte = NULL;
    NTSTATUS status;

    hdrsize = sizeof(SENDBUF) +
              MAXLINKHDRLEN +
              IPHDRLEN + pcb->ipoptlen +
              UDPHDRLEN;
                
    pkt = XnetAllocPacket(hdrsize + sendreq->sendtotal, 0);
    if (!pkt) return NETERR_MEMORY;
    pkt->data += hdrsize;
    pkt->datalen = sendreq->sendtotal;

    // Make a copy of the user data that's passed in
    if (sendreq->bufcnt == 1) {
        CopyMem(pkt->data, sendreq->bufs->buf, sendreq->sendtotal);
    } else {
        BYTE* p = pkt->data;
        WSABUF* bufs = sendreq->bufs;
        UINT bufcnt = sendreq->bufcnt;

        while (bufcnt--) {
            CopyMem(p, bufs->buf, bufs->len);
            p += bufs->len;
            bufs++;
        }
    }

    if (!sendreq->toaddr && !IS_MCAST_IPADDR(pcb->dstaddr)) {
        // Normal send request
        addrpair = &pcb->addrpair;
        cachedRte = &pcb->rte;
    } else {
        // This is a sendto request.
        addrpair = &sendtoAddr;
        cachedRte = &sendtoRte;
        if (sendreq->toaddr) {
            addrpair->dstport = sendreq->toaddr->sin_port;
            addrpair->dstaddr = sendreq->toaddr->sin_addr.s_addr;
        } else {
            addrpair->dstport = pcb->dstport;
            addrpair->dstaddr = pcb->dstaddr;
        }
        addrpair->srcport = pcb->srcport;
        addrpair->srcaddr = pcb->bindSrcAddr;

        if (addrpair->srcaddr == 0) {
            status = PcbPrepareSendto(pcb, addrpair, cachedRte);
            if (!NT_SUCCESS(status)) {
                XnetFreePacket(pkt);
                return status;
            }
        }
    }

    if (pcb->type == SOCK_DGRAM) {
        // Sending UDP datagram
        pkt->data -= UDPHDRLEN;
        pkt->datalen += UDPHDRLEN;
        FILL_UDPHEADER(pkt, addrpair);
        PcbSetupIpHeader(pcb, pkt, addrpair);
    } else {
        // Sending raw IP datagram
        if (pcb->ipHdrIncl) {
            if (pkt->datalen < IPHDRLEN) {
                XnetFreePacket(pkt);
                status = NETERR_PARAM;
                goto exit;
            }
            SETPKTIPHDR(pkt, pkt->data);
        } else {
            PcbSetupIpHeader(pcb, pkt, addrpair);
        }
    }

    // Set up the packet completion routine to
    // decrement the send buffer size when the packet is sent.

    sendbuf = GETPKTBUF(pkt, SENDBUF);
    sendbuf->refcount = 2;
    sendbuf->datalen = sendreq->sendtotal;
    sendbuf->pcb = pcb;
    XnetSetPacketCompletion(pkt, DgramSendCompletionProc);

    irql = RaiseToDpc();
    pcb->sendbufSize += sendreq->sendtotal;
    InsertTailList(&pcb->sendbuf, &sendbuf->links);

    if (IS_MCAST_IPADDR(addrpair->dstaddr)) {
        // Send a copy of the multicast datagram to ourselves if needed
        status = PcbSendMcastDgram(pcb, pkt, addrpair->dstaddr);
    } else {
        // If this is a broadcast datagram, send a copy to ourselves
        // NOTE: subnet directed broadcast isn't handled correctly.
        if (IS_BCAST_IPADDR(addrpair->dstaddr)) {
            IpQueueLoopbackPacket(pkt, TRUE);
        }

        status = IpSendPacket(pkt, addrpair->dstaddr, NULL, cachedRte);
    }
    LowerFromDpc(irql);

exit:
    if (sendtoRte) { IpReleaseCachedRTE(sendtoRte); }
    return status;
}


NTSTATUS
PcbShutdownDgram(
    PCB* pcb,
    BYTE flags
    )

/*++

Routine Description:

    Shutdown a datagram socket

Arguments:

    pcb - Points to the protocol control block
    flags - Shutdown flags: PCBFLAG_SEND_SHUTDOWN and/or PCBFLAG_RECV_SHUTDOWN

Return Value:

    Status code

--*/

{
    KIRQL irql = RaiseToDpc();

    if (flags & PCBFLAG_RECV_SHUTDOWN) {
        PcbClearOverlappedRecvs(pcb, NETERR(WSAESHUTDOWN));
        PcbFlushRecvBuffers(pcb);
    }

    if (flags & PCBFLAG_SEND_SHUTDOWN) {
        PcbClearOverlappedSends(pcb, NETERR(WSAESHUTDOWN));
    }

    pcb->flags |= flags;
    LowerFromDpc(irql);
    return NETERR_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\test\filexfer\precomp.h ===
#include "xnetp.h"
#include "xnettest.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\tcp\tcprecv.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    tcprecv.c

Abstract:

    TCP input processing functions

Revision History:

    05/31/2000 davidx
        Created it.

--*/

#include "precomp.h"


//
// Update the receive window information after accepting
// the specified amount data from the connection peer.
//
INLINE VOID
TcbSlideRecvWindow(
    TCB* tcb,
    UINT datalen
    )
{
    UINT newwnd = tcb->maxRecvBufsize - tcb->recvbufSize;

    // Here datalen must be <= rcv_wnd.
    ASSERT(datalen <= tcb->rcv_wnd);
    tcb->rcv_nxt += datalen;

    if ((datalen + newwnd) - tcb->rcv_wnd >= tcb->rcv_swsthresh) {
        // Enough space has freed up. Move the right edge of the receive window.
        tcb->rcv_wnd = newwnd;
    } else {
        // Implement receive side silly window avoidance:
        //  keep the right edge of the receive window unchanged.
        tcb->rcv_wnd -= datalen;
    }
}


//
// Copy data from the TCB receive buffer to the user's receive buffer
//
PRIVATE UINT
TcbCopyRecvData(
    TCB* tcb,
    RECVREQ* recvreq
    )
{
    RECVBUF* recvbuf;
    UINT copycnt, total = 0;
    BYTE tcpflags = 0;

    do {
        recvbuf = (RECVBUF*) tcb->recvbuf.Flink;
        ASSERT(SEQ_LE(recvbuf->seqnext, tcb->rcv_nxt));

        copycnt = min(recvbuf->datalen, recvreq->buflen);
        CopyMem(recvreq->buf, (BYTE*) recvbuf + recvbuf->dataoffset, copycnt);
        total += copycnt;
        tcb->recvbufSize -= copycnt;
        recvreq->buf += copycnt;
        recvreq->buflen -= copycnt;

        tcpflags |= recvbuf->tcpflags;
        if (copycnt == recvbuf->datalen) {
            RemoveEntryList(&recvbuf->links);
            XnetFree(recvbuf);
        } else {
            recvbuf->dataoffset = (WORD) (recvbuf->dataoffset + copycnt);
            recvbuf->datalen -= copycnt;
        }
    } while (recvreq->buflen && !IsTcpRecvBufEmpty(tcb));

    if (tcpflags & (TCP_PSH|TCP_URG))
        recvreq->buflen = 0;

    return total;
}


NTSTATUS
TcbRecv(
    TCB* tcb,
    RECVREQ* recvreq
    )

/*++

Routine Description:

    Handle a user request to receive data from a TCP socket

Arguments:

    tcb - Points to the TCP control block
    recvreq - Points to the receive request information

Return Value:

    Status code

--*/

{
    NTSTATUS status;
    UINT oldrcvwnd;
    KIRQL irql = RaiseToDpc();

    // Only segments from the connection peer are accepted
    SetRecvReqFromAddr(recvreq, tcb->dstaddr, tcb->dstport);
    *recvreq->bytesRecv = 0;

    if (!IsTcpRecvBufEmpty(tcb)) {

        // If the receive buffer is not empty, return as much data
        // as possible from the receive buffer.

        (*recvreq->bytesRecv) += TcbCopyRecvData(tcb, recvreq);
        status = NETERR_OK;

        // If the receive window was closed and there is
        // now enough free spce in the receive buffer,
        // then we'll send out a gratuitous ACK here.

        oldrcvwnd = tcb->rcv_wnd;
        TcbSlideRecvWindow(tcb, 0);
        if (oldrcvwnd < tcb->rcv_swsthresh &&
            tcb->rcv_wnd >= tcb->rcv_swsthresh) {
            TcbEmitACK(tcb);
        }
    } else if (IsFINReceived(tcb)) {
        // The connection has been gracefully closed
        status = NETERR_OK;
    } else {
        status = PcbGetErrStatus(tcb);
        if (NT_SUCCESS(status)) {
            status = PcbQueueOverlappedRecv((PCB*) tcb, recvreq);
        }
    }

    LowerFromDpc(irql);
    return status;
}


PRIVATE VOID
TcbUpdateRTO(
    TCB* tcb
    )

/*++

Routine Description:

    Update the round-trip time measurements for a TCP connection

Arguments:

    tcb - Points to the TCP control block

Return Value:

    NONE

--*/

{
    INT nticks, delta;

    // The computation is based on the following formula:
    //  delta = nticks - srtt
    //  srtt = srtt + delta / 8
    //  rttvar = rttvar + (|delta| - rttvar) / 4
    //  RTO = srtt + 4 * rttvar

    nticks = TcpTickCount - tcb->rtt_tick;
    tcb->rtt_tick = 0;

    if (tcb->srtt_8 != 0) {
        delta = nticks - (tcb->srtt_8 >> SRTT_SHIFT);
        if ((tcb->srtt_8 += delta) <= 0)
            tcb->srtt_8 = 1;

        if (delta < 0) delta = -delta;
        delta -= (tcb->rttvar_4 >> RTTVAR_SHIFT);
        if ((tcb->rttvar_4 += delta) <= 0)
            tcb->rttvar_4 = 1;
    } else {
        // The very first measurement - use the unsmoothed data
        if (nticks == 0) {
            tcb->srtt_8 = tcb->rttvar_4 = 1;
        } else {
            tcb->srtt_8 = nticks << SRTT_SHIFT;
            tcb->rttvar_4 = nticks << (RTTVAR_SHIFT-1);
        }
    }

    tcb->RTO = (tcb->srtt_8 >> SRTT_SHIFT) + tcb->rttvar_4;
    if (tcb->RTO < cfgMinRexmitTimeout)
        tcb->RTO = cfgMinRexmitTimeout;
}


PRIVATE BOOL
TcbUpdatePersistFlag(
    TCB* tcb
    )

/*++

Routine Description:

    This function is called after the send window information is updated.
    If we're currently sending out window probing segments, then
    we'll stop doing so if the send window has opened up.

Arguments:

    tcb - Points to the TCP control block

Return Value:

    FALSE if we got out of persist mode
    TRUE otherwise

--*/

{
    TCPSENDBUF* sendbuf = TcbFirstSendbuf(tcb);
    ASSERT(!IsPcbSendBufEmpty(tcb));

    if (sendbuf->datalen <= tcb->snd_wnd) {
        tcb->persistFlag = 0;
        if (sendbuf->retries) {
            TRACE_("Retransmit persisting segment...");
            sendbuf->retries = 0;
            TcbSendSegment(tcb, sendbuf);
        } else {
            tcb->xmitTimer = 0;
        }
        return FALSE;
    }
    return TRUE;
}


PRIVATE VOID
TcbUpdateSndUna(
    TCB* tcb,
    TCPSEQ ack
    )

/*++

Routine Description:

    Update the snd.una variable for a TCP connection

Arguments:

    tcb - Points to the TCP connection block
    ack - The acknowledged sequence number

Return Value:

    NONE

--*/

{
    TCPSENDBUF* sendbuf;
    UINT ackedSends = 0;

    if (SEQ_GT(ack, tcb->snd_una)) {
        tcb->snd_una = ack;

        // Update round-trip time measurements
        if (tcb->rtt_tick && SEQ_GT(ack, tcb->rtt_seq)) {
            TcbUpdateRTO(tcb);
        }

        // Complete fully acknowledged send user requests

        LOOP_THRU_TCB_SENDBUF(tcb, sendbuf)

            if (sendbuf->retries && SEQ_GE(ack, sendbuf->seqnext)) {
                RemoveEntryList(&sendbuf->links);
                tcb->sendbufSize -= sendbuf->datalen;
                ackedSends++;
                SendbufRelease(sendbuf);
            } else {
                break;
            }

        END_TCB_SENDBUF_LOOP
    }

    // Update congestion window
    if (tcb->fastRexmitFlag) {
        if (ackedSends) {
            //
            // Getting out of fast retransmit / fast recovery mode:
            //  "deflate" the congestion window
            //
            tcb->snd_cwnd = tcb->snd_ssthresh;
        } else {
            //
            // In fast recovery mode:
            //  increment the congestion window by SMSS
            //  for every duplicate ACK received.
            //
            TcbIncrementCwnd(tcb, tcb->snd_mss);
        }
    } else {
        if (tcb->snd_cwnd < tcb->snd_ssthresh) {
            //
            // Slow-start mode:
            //  increment the congestion window by SMSS
            //
            TcbIncrementCwnd(tcb, tcb->snd_mss);
        } else {
            //
            // Congestion avoidance mode:
            //  increment the congestion window by ~SMSS per RTT
            //
            // NOTE: Overflow is not possible here because snd_mss
            // and snd_cwnd are 16-bit numbers. Also snd_cwnd is never 0.
            //
            UINT inc = tcb->snd_mss * tcb->snd_mss / tcb->snd_cwnd;
            TcbIncrementCwnd(tcb, max(1, inc));
        }
    }

    if (ackedSends) {
        if (!IsPcbSendBufFull(tcb)) {
            if (HasOverlappedSend(tcb)) {
                SENDREQ* sendreq = PcbGetOverlappedSend((PCB*) tcb);
                NTSTATUS status = TcbSend(tcb, sendreq);

                sendreq->overlapped->_ioxfercnt = sendreq->sendtotal;
                PcbCompleteOverlappedSend(sendreq, status);
            } else {
                PcbSignalEvent(tcb, PCBEVENT_WRITE);
            }
        }
        tcb->persistFlag = 0;
        TcbStopFastRexmitMode(tcb);

        // Reset retransmission timer
        if (tcb->snd_una == tcb->snd_nxt)
            tcb->xmitTimer = 0;
        else {
            sendbuf = TcbFirstSendbuf(tcb);
            if (sendbuf->firstSendTime + tcb->RTO <= TcpTickCount) {
                TcbXmitTimeout(tcb);
            } else {
                tcb->xmitTimer = sendbuf->firstSendTime + tcb->RTO - TcpTickCount;
            }
        }

    } else if (tcb->persistFlag) {

        // If we're probing the send window and the ack was for
        // the probe segment, then make sure we continue to probe
        // without timing out.

        sendbuf = TcbFirstSendbuf(tcb);
        if (SEQ_GE(ack, sendbuf->seq) &&
            sendbuf->retries >= cfgMaxXmitRetries-1) {
            sendbuf->retries--;
        }

    } else {
        if (tcb->snd_una != tcb->snd_nxt &&
            !tcb->fastRexmitFlag &&
            ++tcb->dupacks >= 4) {
            //
            // Too many duplicate ACK received:
            //  do fast retransmit / recovery
            //
            TcbDoFastRexmit(tcb);
        }
    }

    // If the send window has opened up and
    // we have pending data to sent, try to do it now.
    if (!tcb->persistFlag || !TcbUpdatePersistFlag(tcb)) {
        while (TcbHasPendingSend(tcb) && TcbStartOutput(tcb))
            NULL;
    }
}


// 
// Check if an acknowledged sequence number is valid for a TCP connection
//
#define IsValidACK(_tcb, _ack) \
        (SEQ_GT((_ack), (_tcb)->snd_una) && \
         SEQ_LE((_ack), (_tcb)->snd_nxt))

//
// Indicate whether we should send out an ACK immediately
// in response to an incoming segment.
//
#define NeedSendACKNow(_tcb) ((_tcb)->delayedAcks += 0x20000)

//
// Save the send window information from the connection peer
//
#define TcbUpdateSndWnd(_tcb, _wnd, _seq, _ack) { \
            (_tcb)->snd_wnd = (_wnd); \
            (_tcb)->snd_wl1 = (_seq); \
            (_tcb)->snd_wl2 = (_ack); \
        }


PRIVATE BOOL
TcbValidateSeqs(
    TCB* tcb,
    TCPSEQ oldseq0,
    TCPSEQ oldseq1,
    TCPSEQ* newseq0,
    TCPSEQ* newseq1
    )

/*++

Routine Description:

    Check if the received sequence number is valid for a TCP connection

Arguments:

    tcb - Points to TCP control block
    oldseq0 - Starting sequence number from the received segment
    oldseq1 - Ending sequence number from the received segment (oldseq+seglen)
    newseq0 - Returns the effective starting sequence number inside the receive window
    newseq1 - Returns the effective ending sequence number

Return Value:

    FALSE if none of the received segment is inside the receive window,
    TRUE otherwise. In the latter case, seq0 and seq1 will return updated
    sequence numbers.

--*/

{
    TCPSEQ rcv_last;

    rcv_last = tcb->rcv_nxt + tcb->rcv_wnd;
    *newseq0 = SEQ_LT(oldseq0, tcb->rcv_nxt) ? tcb->rcv_nxt : oldseq0;
    *newseq1 = SEQ_GT(oldseq1, rcv_last) ? rcv_last : oldseq1;

    return SEQ_LT(*newseq0, *newseq1) ||
           (*newseq0 == *newseq1 && oldseq0 == oldseq1);
}


#if DBG

PRIVATE BOOL
TcbVerifyRecvBuf(
    TCB* tcb
    )

/*++

Routine Description:

    Verify the current receive buffers for a TCB is good

Arguments:

    tcb - Points to the TCP control block

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    RECVBUF* buf0 = (RECVBUF*) tcb->recvbuf.Flink;
    RECVBUF* buf1;

    if (buf0 == TcbRecvbufNil(tcb)) return TRUE;
    while (TRUE) {
        buf1 = TcbRecvbufFlink(buf0);
        if (buf1 == TcbRecvbufNil(tcb)) return TRUE;
        if (SEQ_GT(buf0->seqnext, buf1->seqnext-buf1->datalen)) return FALSE;
        buf0 = buf1;
    }
}

#endif // DBG


PRIVATE UINT
TcbCorrectMisorderedSegments(
    TCB* tcb,
    TCPSEQ seq,
    RECVBUF* recvbuf
    )

/*++

Routine Description:

    This function is called when we receive a segment
    whose starting sequence number matches rcv_nxt and
    there are buffered out-of-order segments after this one.

Arguments:

    tcb - Points to TCP control block
    seq - Specifies the starting sequence number for this segment
    recvbuf - Points to the received data buffer

Return Value:

    Number of continuous bytes that can be acknowledged

--*/

{
    RECVBUF* buf0 = TcbLastRecvbuf(tcb);
    RECVBUF* buf1;
    UINT count;

    do {
        buf0 = TcbRecvbufBlink(buf0);
    } while (buf0 != TcbRecvbufNil(tcb) && buf0->seqnext != seq);

    buf1 = TcbRecvbufFlink(buf0);
    if (SEQ_GT(recvbuf->seqnext, buf1->seqnext - buf1->datalen)) {
        // Weird case: data in this segment overlapps with
        // data in the buffered out-of-order segments.
        // Chop off the overlapped data in the current receive buffer.
        TRACE_("TcbCorrectMisorderedSegments: overlapping segment");

        count = recvbuf->seqnext - (buf1->seqnext - buf1->datalen);
        ASSERT(count < recvbuf->datalen);

        recvbuf->datalen -= count;
        recvbuf->seqnext -= count;
    }

    // Insert recvbuf after buf0 and before buf1
    buf0->links.Flink = buf1->links.Blink = (LIST_ENTRY*) recvbuf;
    recvbuf->links.Flink = (LIST_ENTRY*) buf1;
    recvbuf->links.Blink = (LIST_ENTRY*) buf0;

    count = recvbuf->datalen;
    buf0 = recvbuf;
    while (buf1 != TcbRecvbufNil(tcb) &&
           buf0->seqnext == buf1->seqnext - buf1->datalen) {
        count += buf1->datalen;
        buf0 = buf1;
        buf1 = TcbRecvbufFlink(buf1);
    }

    // If we filled up a hole, emit an ACK immediately
    if (count > recvbuf->datalen) {
        NeedSendACKNow(tcb);
    }

    // ASSERT(TcbVerifyRecvBuf(tcb));
    return count;
}


PRIVATE VOID
TcbBufferMisorderedSegment(
    TCB* tcb,
    UINT seq,
    RECVBUF* recvbuf
    )


/*++

Routine Description:

    This function is called when we receive an out-of-order segment.

Arguments:

    tcb - Points to TCP control block
    seq - Specifies the starting sequence number for this segment
    recvbuf - Points to the received data buffer

Return Value:

    NONE

--*/

{
    RECVBUF* buf0 = TcbLastRecvbuf(tcb);
    RECVBUF* buf1;
    UINT count;

    if (buf0 == TcbRecvbufNil(tcb) || SEQ_GE(seq, buf0->seqnext)) {
        // The sequence number for this segment is larger
        // than everything in the receive buffer.
        InsertTailList(&tcb->recvbuf, &recvbuf->links);
        return;
    }

    do {
        buf0 = TcbRecvbufBlink(buf0);
    } while (buf0 != TcbRecvbufNil(tcb) && SEQ_LT(seq, buf0->seqnext));

    // recvbuf should go in between buf0 and buf1

    buf1 = TcbRecvbufFlink(buf0);
    if (SEQ_GT(recvbuf->seqnext, buf1->seqnext - buf1->datalen)) {
        // Data in this segment overlapps with
        // data in the buffered out-of-order segments.
        TRACE_("TcbBufferMisorderedSegment: overlapping segment");
        
        count= recvbuf->seqnext - (buf1->seqnext - buf1->datalen);
        if (count >= recvbuf->datalen) {
            XnetFree(recvbuf);
            return;
        }

        recvbuf->datalen -= count;
        recvbuf->seqnext -= count;
    }

    buf0->links.Flink = buf1->links.Blink = (LIST_ENTRY*) recvbuf;
    recvbuf->links.Flink = (LIST_ENTRY*) buf1;
    recvbuf->links.Blink = (LIST_ENTRY*) buf0;

    // ASSERT(TcbVerifyRecvBuf(tcb));
}


PRIVATE UINT
TcbCompletePendingRecvReqFast(
    TCB* tcb,
    Packet* pkt,
    BYTE tcpflags
    )

/*++

Routine Description:

    This function is called when we received data from a TCP connection
    and there is a pending overlapped receive request
    and there is currently no data in the receive buffer.
    In this case we can satisfy the request right away without
    allocating memory to store data in the receive buffer.

Arguments:

    tcb - Points to the TCP control block
    pkt - Points to the received packet
    tcpflags - TCP segment flags

Return Value:

    Number of bytes used up in this call

--*/

{
    UINT copycnt;
    RECVREQ* recvreq = PcbGetOverlappedRecv(tcb);

    copycnt = min(pkt->datalen, recvreq->buflen);
    CopyMem(recvreq->buf, pkt->data, copycnt);
    recvreq->overlapped->_ioxfercnt += copycnt;
    recvreq->buf += copycnt;
    recvreq->buflen -= copycnt;

    if ((recvreq->buflen == 0) || (tcpflags & TCP_PSH|TCP_URG)) {
        PcbCompleteOverlappedRecv(recvreq, NETERR_OK);
    }

    TcbSlideRecvWindow(tcb, copycnt);
    return copycnt;
}


PRIVATE TCB*
TcbProcessDataAck(
    TCB* tcb,
    Packet* pkt,
    TcpHeader* tcphdr
    )

/*++

Routine Description:

    Process a received TCP data segment.
    And we assume the connection is in a synchronized state.

Arguments:

    tcb - Points to the TCP connection block
    pkt - Points to the received packet
    tcphdr - Points to the TCP segment header information

Return Value:

    NULL if the TCB was deleted as a result of the incoming segment;
    Otherwise, just return the input tcb parameter

--*/

{
    TCPSEQ seq, ack, seq0, seq1;
    RECVBUF* recvbuf;

    seq = SEG_SEQ(tcphdr);

    // Process ACK if it's present
    if (ISTCPSEG(tcphdr, ACK)) {
        ack = SEG_ACK(tcphdr);
        if (SEQ_LT(ack, tcb->snd_una)) {
            // ACK is an old duplicate, ignore it
        } else if (SEQ_GT(ack, tcb->snd_nxt)) {
            // ACKing something that hasn't been sent.
            // Emit an ACK, drop the segment
            NeedSendACKNow(tcb);
            return tcb;
        } else {
            // update the send window information
            if (SEQ_LT(tcb->snd_wl1, seq) ||
                tcb->snd_wl1 == seq && SEQ_LE(tcb->snd_wl2, ack)) {
                TcbUpdateSndWnd(tcb, SEG_WIN(tcphdr), seq, ack);
            }

            TcbUpdateSndUna(tcb, ack);

            // If we already sent FIN, check to see if FIN has been acknowledged
            if (IsFINSent(tcb) && IsPcbSendBufEmpty(tcb)) {
                switch (tcb->tcpstate) {
                case TCPST_FIN_WAIT_1:
                    TcbSetState(tcb, TCPST_FIN_WAIT_2, "FinAck");
                    break;

                case TCPST_CLOSING:
                    TcbSetState(tcb, TCPST_TIME_WAIT, "FinAck");
                    TcbSetTimeWaitTimer(tcb, 2*cfgMSL);
                    return NULL;

                case TCPST_LAST_ACK:
                    TcbDelete(tcb);
                    return NULL;
                }
            }
        }
    }

    // If we already receive FIN from the peer,
    // we'll just ignore incoming data.
    if (IsFINReceived(tcb) || pkt->datalen == 0) return tcb;

    tcb->delayedAcks += pkt->datalen;

    // Quick check to see if the data from incoming segment
    // fits entirely within the current receive window.
    if (seq != tcb->rcv_nxt || pkt->datalen > tcb->rcv_wnd) {
        // If the receive sequence number is outside of
        // the current receive window, send an ACK right away.
        if (!TcbValidateSeqs(tcb, seq, seq+pkt->datalen, &seq0, &seq1)) {
            TRACE_("Sequence number out-of-range: %u %u %d",
                   seq, tcb->rcv_nxt, tcb->rcv_wnd);
            NeedSendACKNow(tcb);
            return tcb;
        }

        pkt->data += (seq0 - seq);
        pkt->datalen = (seq1 - seq0);
        ASSERT((INT) pkt->datalen > 0);
        seq = seq0;
    }

    if (IsPcbRecvShutdown(tcb)) {
        TcbResetPeer(tcb);
        TcbReset(tcb, NETERR_CONNRESET);
        return NULL;
    }

    // Special fast path: there is a pending overlapped receive request
    // and there is no data in the receive buffer.
    if (HasOverlappedRecv(tcb) &&
        seq == tcb->rcv_nxt &&
        IsListEmpty(&tcb->recvbuf)) {
        UINT copied = TcbCompletePendingRecvReqFast(tcb, pkt, tcphdr->flags);
        if (copied == pkt->datalen) return tcb;

        pkt->data += copied;
        pkt->datalen -= copied;
        seq += copied;
    }

    // Make a copy of the incoming segment and buffer it up
    recvbuf = (RECVBUF*) XnetAlloc(sizeof(RECVBUF) + pkt->datalen, PTAG_RBUF);
    if (!recvbuf) {
        WARNING_("Received TCP data discarded because of no memory");
        WARNING_("  local = %d, remote = %s:%d",
            NTOHS(tcb->srcport),
            IPADDRSTR(tcb->dstaddr),
            NTOHS(tcb->dstport));
        return tcb;
    }

    recvbuf->seqnext = seq + pkt->datalen;
    recvbuf->dataoffset = sizeof(RECVBUF);
    recvbuf->tcpflags = tcphdr->flags;
    recvbuf->datalen = pkt->datalen;
    CopyMem(recvbuf+1, pkt->data, pkt->datalen);

    // Fast case: the receive segment is in sequence
    if (seq == tcb->rcv_nxt) {
        UINT datarun;
        RECVBUF* lastbuf = TcbLastRecvbuf(tcb);

        if (lastbuf == TcbRecvbufNil(tcb) || lastbuf->seqnext == seq) {
            // We haven't buffered any out-of-order segments behind this one.
            datarun = pkt->datalen;
            InsertTailList(&tcb->recvbuf, &recvbuf->links);
        } else {
            // Figure out if this segment fills out holes
            // in the receive buffer.
            ASSERT(SEQ_LT(seq, lastbuf->seqnext));
            datarun = TcbCorrectMisorderedSegments(tcb, seq, recvbuf);
        }
        tcb->recvbufSize += datarun;
        TcbSlideRecvWindow(tcb, datarun);

        if (HasOverlappedRecv(tcb)) {
            // If we have a pending overlapped receive request, satisfy it now
            RECVREQ* recvreq = PcbGetOverlappedRecv(tcb);

            recvreq->overlapped->_ioxfercnt += TcbCopyRecvData(tcb, recvreq);
            if (recvreq->buflen == 0) {
                PcbCompleteOverlappedRecv(recvreq, NETERR_OK);
            }

            TcbSlideRecvWindow(tcb, 0);
        } else {
            PcbSignalEvent(tcb, PCBEVENT_READ);
        }
    } else {
        // Slow case: a segment arrived out of order.
        // Buffer up this segment for later processing.
        TRACE_("Out-of-order segment: %u %u", SEG_SEQ(tcphdr), tcb->rcv_nxt);
        TcpStats.misordered++;

        NeedSendACKNow(tcb);
        TcbBufferMisorderedSegment(tcb, seq, recvbuf);
    }

    return tcb;
}


PRIVATE VOID
TcbProcessFIN(
    TCB* tcb,
    TcpHeader* tcphdr,
    TCPSEQ seqfin
    )

/*++

Routine Description:

    Process an incoming TCP FIN segment

Arguments:

    tcb - Points to the TCP control block
    tcphdr - Points to the TCP segment header
    seqfin - Sequence number for the FIN

Return Value:

    NONE

--*/

{
    if (seqfin != tcb->rcv_nxt) return;

    tcb->rcv_nxt = seqfin+1;
    NeedSendACKNow(tcb);
    PcbSignalEvent(tcb, PCBEVENT_CLOSE);

    switch (tcb->tcpstate) {
    case TCPST_SYN_RECEIVED:
    case TCPST_ESTABLISHED:
        PcbClearOverlappedRecvs(tcb, NETERR_OK);
        PcbSignalEvent(tcb, PCBEVENT_READ);
        TcbSetState(tcb, TCPST_CLOSE_WAIT, "FinRecv");
        break;

    case TCPST_FIN_WAIT_1:
        if (IsPcbSendBufEmpty(tcb)) {
            TcbSetState(tcb, TCPST_CLOSING, "FinRecv");
            break;
        }

        // If our FIN has been acknowledged,
        // fall through and change to TIME-WAIT state.

    case TCPST_FIN_WAIT_2:
        TcbSetState(tcb, TCPST_TIME_WAIT, "FinRecv");

        // Fall through

    case TCPST_TIME_WAIT:
        TcbSetTimeWaitTimer(tcb, 2*cfgMSL);
        break;
    }
}


//
// Structure for storing TCP option parameters
// from an incoming SYN segment
//
typedef struct _TcpOptions {
    UINT mss;
    // other TCP option parameters ...
} TcpOptions;

PRIVATE BOOL
TcpParseOptions(
    Packet* pkt,
    TcpHeader* tcphdr,
    TcpOptions* opts
    )

/*++

Routine Description:

    Parse the option information in an incoming TCP SYN segment

Arguments:

    pkt - Points to the received packet
    tcphdr - Points to the TCP segment header
    opts - Returns the parsed option information

Return Value:

    TRUE if successful, FALSE if the TCP options are not well-formed

--*/

#define TCP_MINIMUM_MSS (MAXIPHDRLEN+MAXTCPHDRLEN+8-IPHDRLEN-TCPHDRLEN)

{
    const BYTE* buf;
    UINT buflen;

    // We ignore any data that's sent in the initial SYN segment.
    // Not sure if this case actually happens in real-life.
    // In any case, the sender should retransmit the data.
    if (ISTCPSEG(tcphdr, SYN) && pkt->datalen > 0) {
        WARNING_("Ignoring data in SYN segment.");
    }

    // Use default values if no options are present
    opts->mss = TCP_DEFAULT_MSS;

    buflen = GETTCPHDRLEN(tcphdr) - TCPHDRLEN;
    buf = (const BYTE*) (tcphdr+1);

    while (buflen) {
        BYTE opt, optlen;

        if ((opt = *buf) == TCPOPT_EOL) break;
        if (opt == TCPOPT_NOP) {
            buf++; buflen--; 
            continue;
        }

        // Verify option length field
        if (buflen < 2 || (optlen = buf[1]) < 2 || optlen > buflen)
            return FALSE;

        switch (opt) {
        case TCPOPT_MAX_SEGSIZE:
            if (optlen != 4) return FALSE;
            opts->mss = ((UINT) buf[2] << 8) | buf[3];
            if (opts->mss < TCP_MINIMUM_MSS)
                opts->mss = TCP_DEFAULT_MSS;
            break;

        default:
            TRACE_("TCP option ignored: %d", opt);
            break;
        }

        buf += optlen;
        buflen -= optlen;
    }
    return TRUE;
}


//
// Save the relevant information in an incoming connection request
//
#define TcpSaveConnReqParams(_tcb, _tcphdr, _opts) { \
            (_tcb)->rcv_isn = SEG_SEQ(_tcphdr); \
            (_tcb)->rcv_nxt = (_tcb)->rcv_isn+1; \
            (_tcb)->snd_mss = (_opts)->mss; \
        }

PRIVATE BOOL
TcbAcceptConnReqPassive(
    TCB* tcb,
    Packet* pkt,
    TcpHeader* tcphdr
    )

/*++

Routine Description:

    Process an incoming TCP connection request
    that was made to a listening (passively opened) socket

Arguments:

    tcb - TCP control block
    pkt - Points to the incoming packet
    tcphdr - Points to the TCP segment header

Return Value:

    FALSE if the incoming connection request is bad and
    the caller should send out a RST in response; TRUE otherwise

--*/

{
    NTSTATUS status;
    TCB* tcbChild;
    TcpOptions opts;

    // Parse TCP options
    if (!TcpParseOptions(pkt, tcphdr, &opts)) return FALSE;

    tcbChild = TcbCloneChild(tcb);
    if (!tcbChild) return TRUE;

    TcbSetState(tcbChild, TCPST_SYN_RECEIVED, "Connection request");
    TcpSaveConnReqParams(tcbChild, tcphdr, &opts);

    status = TcbConnect(tcbChild, GETPKTIPHDR(pkt)->srcaddr, tcphdr->srcport, TRUE);
    if (!NT_SUCCESS(status)) {
        TcbDelete(tcbChild);
        return TRUE;
    }

    InsertHeadList(&PcbList, &tcbChild->links);
    return TRUE;
}


PRIVATE VOID
TcbConnectionEstablished(
    TCB* tcb,
    TcpHeader* tcphdr
    )

/*++

Routine Description:

    Change a TCP connection to established state

Arguments:

    tcb - Points to the TCP control block
    tcphdr - Points to the incoming SYN/ACK segment

Return Value:

    NONE

--*/

{
    TCPSEQ ack;
    TCPSENDBUF* sendbuf;

    TRACE_("Connection established: %s:%d ", IPADDRSTR(tcb->srcaddr), NTOHS(tcb->srcport));
    TRACE_("to %s:%d", IPADDRSTR(tcb->dstaddr), NTOHS(tcb->dstport));

    //
    // The incoming segment must acknowledge our SYN
    //
    sendbuf = TcbFirstSendbuf(tcb);
    ack = SEG_ACK(tcphdr);
    ASSERT(sendbuf->tcpflags & TCP_SYN);
    ASSERT(ISTCPSEG(tcphdr, ACK));
    ASSERT(ack == tcb->snd_nxt);

    tcb->snd_una = ack;
    TcbUpdateSndWnd(tcb, SEG_WIN(tcphdr), SEG_SEQ(tcphdr), ack);

    if (tcb->rtt_tick) {
        TcbUpdateRTO(tcb);
    }
    RemoveEntryList(&sendbuf->links);
    SendbufRelease(sendbuf);
    tcb->xmitTimer = tcb->synTimer = 0;

    // NOTE: Since we don't fragment outgoing IP datagrams, we need
    // to limit snd_mss to be less than the first-hop interface MTU
    // minus the TCP and IP headers.
    if (tcb->snd_mss > tcb->rcv_mss)
        tcb->snd_mss = tcb->rcv_mss;

    tcb->snd_cwnd = 2*tcb->snd_mss;
    tcb->snd_ssthresh = max(tcb->snd_wnd, tcb->snd_cwnd);
    tcb->rcv_swsthresh = min(tcb->maxRecvBufsize>>1, tcb->snd_mss);

    TcbSetState(tcb, TCPST_ESTABLISHED, "Connected");
    tcb->flags |= PCBFLAG_CONNECTED;
    PcbSignalEvent(tcb, PCBEVENT_CONNECT);

    if (IsPendingConnReqTcb(tcb)) {
        // Signal the connection request is ready for acceptance
        PcbSignalEvent(tcb->parent, PCBEVENT_ACCEPT);
    }
}


PRIVATE BOOL
TcbAcceptConnReqActive(
    TCB* tcb,
    Packet* pkt,
    TcpHeader* tcphdr
    )

/*++

Routine Description:

    Process an incoming TCP connection request
    that was made to an actively opened socket

Arguments:

    tcb - TCP control block
    pkt - Points to the incoming packet
    tcphdr - Points to the TCP segment header

Return Value:

    FALSE if the incoming connection request is bad and
    the caller should send out a RST in response; TRUE otherwise

--*/

{
    TcpOptions opts;
    NTSTATUS status;

    // Parse TCP options and save connection request information
    if (!TcpParseOptions(pkt, tcphdr, &opts)) return FALSE;
    TcpSaveConnReqParams(tcb, tcphdr, &opts);

    if (ISTCPSEG(tcphdr, ACK)) {
        TcbConnectionEstablished(tcb, tcphdr);
        NeedSendACKNow(tcb);
        status = NETERR_OK;
    } else {
        TcbSetState(tcb, TCPST_SYN_RECEIVED, "Simultaneous open");
        status = TcbEmitSYN(tcb, TRUE);
    }

    return NT_SUCCESS(status);
}


VOID
TcpReceivePacket(
    Packet* pkt
    )

/*++

Routine Description:

    Receive a TCP segment

Arguments:

    pkt - Points to the received TCP segment

Return Value:

    NONE

--*/

{
    IpHeader* iphdr;
    PseudoHeader pseudohdr;
    TcpHeader* tcphdr;
    UINT tcphdrlen;
    UINT checksum;
    TCB* tcb;
    BOOL isAck;
    TCPSEQ ack;

    // Verify TCP segment header
    if (pkt->datalen < TCPHDRLEN) goto discard;

    iphdr = GETPKTIPHDR(pkt);
    pseudohdr.srcaddr = iphdr->srcaddr;
    pseudohdr.dstaddr = iphdr->dstaddr;
    pseudohdr.zero = 0;
    pseudohdr.protocol = IPPROTOCOL_TCP;
    pseudohdr.length = (WORD) HTONS(pkt->datalen);

    tcphdr = GETPKTDATA(pkt, TcpHeader);
    tcphdrlen = GETTCPHDRLEN(tcphdr);
    if (tcphdrlen < TCPHDRLEN || tcphdrlen > pkt->datalen)
        goto discard;

    // Verify checksum
    checksum = tcpipxsum(0, &pseudohdr, sizeof(pseudohdr));
    if (tcpipxsum(checksum, tcphdr, pkt->datalen) != 0xffff)
        goto discard;

    pkt->data += tcphdrlen;
    pkt->datalen -= tcphdrlen;

    // Find the socket that the segment is addressed to
    tcb = (TCB*) PcbFindMatch(
                    pseudohdr.dstaddr,
                    tcphdr->dstport,
                    pseudohdr.srcaddr,
                    tcphdr->srcport,
                    SOCK_STREAM,
                    IPPROTOCOL_TCP);

    if (!tcb) goto sendrst;

    if (IsTcpSyncState(tcb) && (tcphdr->flags & TCP_CONTROLS) == 0) {
        // Quick check for special case:
        //  we're in a synchronized state and
        //  the segment has no control flags.
        tcb = TcbProcessDataAck(tcb, pkt, tcphdr);

rcvdone:
        // NOTE: We return the interface driver's buffer first
        // before trying to send out the ACK segment.

        XnetCompletePacket(pkt, NETERR_OK);
        if (tcb && tcb->delayedAcks >= (tcb->rcv_mss << 1)) {
            TcbEmitACK(tcb);
        }
        return;
    }
    
    // If the connection is closed, send RST
    if (tcb->tcpstate == TCPST_CLOSED) goto sendrst;

    // Discard packets with broadcast/multicast destination address.
    // We assume that packets with broadcast/multicast source address
    // are already discarded by the IP layer.
    if (IfBcastAddr(pkt->recvifp, pseudohdr.dstaddr) || 
        IS_MCAST_IPADDR(pseudohdr.dstaddr))
        goto discard;

    isAck = ISTCPSEG(tcphdr, ACK);

    switch (tcb->tcpstate) {
    case TCPST_LISTEN:

        // Ignore RST segment in listen state
        if (ISTCPSEG(tcphdr, RST)) goto discard;

        // If ACK is on, send RST
        if (isAck) goto sendrst;

        // If there is no SYN, discard the segment
        if (!ISTCPSEG(tcphdr, SYN)) goto discard;

        // Process an incoming connection request on a listening socket
        if (!TcbAcceptConnReqPassive(tcb, pkt, tcphdr)) goto sendrst;
        break;
    
    case TCPST_SYN_SENT:

        // If ACK is on and the acknowledgement number is bad, send RST
        if (isAck) {
            ack = SEG_ACK(tcphdr);
            if (!IsValidACK(tcb, ack)) goto sendrst;
        }

        if (ISTCPSEG(tcphdr, RST)) {
            // If RST is on and ACK is good, reset the connection.
            // Otherwise, discard the RST segment.
            if (isAck) { TcbReset(tcb, NETERR_CONNRESET); }
            goto discard;
        }

        // If there is no SYN, just discard the segment
        if (!ISTCPSEG(tcphdr, SYN)) goto discard;

        // Simultaneous active open
        if (!TcbAcceptConnReqActive(tcb, pkt, tcphdr)) goto sendrst;
        break;
    
    default: {
        TCPSEQ oldseq0 = SEG_SEQ(tcphdr);
        TCPSEQ oldseq1 = oldseq0 + SEG_LEN(tcphdr, pkt->datalen);
        TCPSEQ seq0, seq1;

        // Make sure the sequence number is correct.
        // If not and the incoming segment is not RST, we'll emit an ACK.
        if (!TcbValidateSeqs(tcb, oldseq0, oldseq1, &seq0, &seq1)) {
            if (!ISTCPSEG(tcphdr, RST)) {
                NeedSendACKNow(tcb);
            }
            break;
        }

        // If RST is on, then we'll reset the connection:
        //  - if the socket corresponds to a pending connection
        //    request, then we'll just close it and destroy the TCB.
        if (ISTCPSEG(tcphdr, RST)) {
            TcbReset(tcb, NETERR_CONNRESET);
            goto discard;
        }

        // If SYN is set, there is an error.
        // We send out a RST as well as reset the connection.
        if (ISTCPSEG(tcphdr, SYN)) {
            if (oldseq0 == seq0) {
                TcbReset(tcb, NETERR_CONNRESET);
                goto sendrst;
            }
            goto discard;
        }

        if (!ISTCPSEG(tcphdr, ACK)) goto discard;

        if (tcb->tcpstate == TCPST_SYN_RECEIVED) {
            ack = SEG_ACK(tcphdr);
            if (!IsValidACK(tcb, ack)) {
                // The acknowledgement number is bad, emit an RST
                goto sendrst;
            }

            // NOTE: The ACK for our SYN will be processed
            // inside the TcbProcessDataAck call below.
            TcbConnectionEstablished(tcb, tcphdr);
        }

        // Process the data and acknowledgement information
        // and continue to process the FIN flag if necessary
        tcb = TcbProcessDataAck(tcb, pkt, tcphdr);
        if (tcb && ISTCPSEG(tcphdr, FIN)) {
            TcbProcessFIN(tcb, tcphdr, seq1-1);
        }
        }
        break;
    }
    goto rcvdone;

sendrst:

    // If the received segment is a RST, do nothing
    if ((tcphdr->flags & TCP_RST) == 0) {
        TCPSEQ seq;
        BYTE flags;
        IpAddrPair addrpair;
        IfInfo* ifp;

        if (ISTCPSEG(tcphdr, ACK)) {
            ack = 0;
            seq = SEG_ACK(tcphdr);
            flags = 0;
        } else {
            ack = SEG_SEQ(tcphdr) + SEG_LEN(tcphdr, pkt->datalen);
            seq = 0;
            flags  = TCP_ACK;
        }

        addrpair.dstaddr = iphdr->srcaddr;
        addrpair.srcaddr = iphdr->dstaddr;
        addrpair.dstport = tcphdr->srcport;
        addrpair.srcport = tcphdr->dstport;
        ifp = pkt->recvifp;

        // NOTE: We return the interface driver's buffer first
        // before trying to send out the RST segment.

        XnetCompletePacket(pkt, NETERR_DISCARDED);
        TcbEmitRST(ifp, &addrpair, seq, ack, flags);
        return;
    }

discard:
    XnetCompletePacket(pkt, NETERR_DISCARDED);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\test\filexfer\filexfer.c ===
// File transfer program using a TCP connection

#include "precomp.h"

#define TESTPORT 600
#define RCVTIMEOUT 15000
#define RCVBUFSIZE 4096

INT testFlag = 1;
INT err;
ULONG total;
CHAR filename[MAX_PATH];
CHAR recvbuf[RCVBUFSIZE];
BOOL noWrite;


VOID
DoGetFile(
    SOCKET s,
    CHAR* filename
    )
{
    SeqFile* file;
    DWORD timer = GetTickCount();
    DWORD buflen, count;

    file = _CreateFile(filename, GENERIC_READ);
    if (!file) {
        WARNFAIL(CreateFile);
        return;
    }

    total = 0;
    do {
        CHAR* p;
        count = cfgSeqFileBufSize;
        if (!_ReadFile(file, &p, &count)) {
            WARNFAIL(ReadFile); goto exit;
        }

        total += count;
        buflen = count;
        while (buflen) {
            DWORD n = buflen;
            err = _send(s, p, &n);
            if (err != NO_ERROR) {
                WARNFAIL(send); goto exit;
            }

            p += n;
            buflen -= n;
        }
    } while (count == cfgSeqFileBufSize);

    timer = GetTickCount() - timer;
    if (timer == 0) timer = 1;
    DbgPrint("  total bytes transferred: %d\n", total);
    DbgPrint("  time: %dmsec, rate: %d bytes/sec\n", timer, MulDiv(total, 1000, timer));

exit:
    _CloseFile(file);
}


VOID
DoPutFile(
    SOCKET s,
    CHAR* filename
    )
{
    SeqFile* file;
    DWORD timer = GetTickCount();
    DWORD count;

    file = _CreateFile(filename, GENERIC_WRITE);
    if (!file) {
        WARNFAIL(CreateFile);
        return;
    }

    total = 0;
    while (TRUE) {
        count = RCVBUFSIZE;
        err = _recv(s, recvbuf, &count);
        if (err != NO_ERROR) {
            WARNFAIL(recv); goto exit;
        }

        if (count == 0) break;
        total += count;
        if (count && !noWrite) {
            if (!_WriteFile(file, recvbuf, count)) {
                WARNFAIL(WriteFile); goto exit;
            }
        }
    }

    timer = GetTickCount() - timer;
    if (timer == 0) timer = 1;
    DbgPrint("  total bytes transferred: %d\n", total);
    DbgPrint("  time: %dmsec, rate: %d bytes/sec\n", timer, MulDiv(total, 1000, timer));

exit:
    _CloseFile(file);
}


BOOL
GetXferRequest(
    IN SOCKET s,
    OUT BOOL* getFile,
    OUT CHAR* filename
    )
{
    DWORD buflen = RCVBUFSIZE;

    err = _recv(s, recvbuf, &buflen);
    if (err != NO_ERROR) {
        WARNFAIL(recv);
        return FALSE;
    }

    if (buflen <= 4 || buflen >= 4+MAX_PATH) goto badreq;

    if (strncmp(recvbuf, "GET ", 4) == 0)
        *getFile = TRUE;
    else if (strncmp(recvbuf, "PUT ", 4) == 0)
        *getFile = FALSE;
    else
        goto badreq;
    
    CopyMem(filename, &recvbuf[4], buflen-4);
    filename[buflen-4] = 0;

    DbgPrint("%s %s\n", *getFile ? "GET" : "PUT", filename);
    return TRUE;

badreq:
    DbgPrint("Bad file transfer request\n");
    return FALSE;
}


VOID
FileXfer()
{
    SOCKET sock, s;
    struct sockaddr_in sockname;
    INT total;
    DWORD timer;
    BOOL getFile;

    s = INVALID_SOCKET;
    sock = socket(AF_INET, SOCK_STREAM, 0);
    if (sock == INVALID_SOCKET) {
        WARNFAIL(socket); goto exit;
    }

    ZeroMem(&sockname, sizeof(sockname));
    sockname.sin_family = AF_INET;
    sockname.sin_port = htons(TESTPORT);
    sockname.sin_addr.s_addr = INADDR_ANY;

    err = _bind(sock, &sockname);
    if (err != NO_ERROR) {
        WARNFAIL(bind); goto exit;
    }

    err = listen(sock, 3);
    if (err != NO_ERROR) {
        WARNFAIL(listen); goto exit;
    }

    err = _getsockname(sock, &sockname);
    if (err != NO_ERROR) {
        WARNFAIL(getsockname); goto exit;
    }

    DbgPrint("Listening on: %s:%d\n",
             inet_ntoa(sockname.sin_addr),
             ntohs(sockname.sin_port));

    s = _accept(sock, &sockname);
    if (s == INVALID_SOCKET) {
        WARNFAIL(accept); goto exit;
    }

    err = _setrcvtimeout(s, RCVTIMEOUT);
    if (err != NO_ERROR) {
        WARNFAIL(setrcvtimeout); goto exit;
    }

    DbgPrint("Connected to: %s:%d\n",
             inet_ntoa(sockname.sin_addr),
             ntohs(sockname.sin_port));

    if (GetXferRequest(s, &getFile, filename)) {
        if (getFile) {
            DoGetFile(s, filename);
        } else {
            DoPutFile(s, filename);
        }
    }

exit:
    if (s != INVALID_SOCKET) { closesocket(s); }
    if (sock != INVALID_SOCKET) { closesocket(sock); }
}


void __cdecl main()
{
    WSADATA wsadata;

    DbgPrint("Loading XBox network stack...\n");
    err = XnetInitialize(NULL, TRUE);
    if (err != NO_ERROR) {
        WARNFAIL(XnetInitialize); goto stop;
    }

    DbgPrint("*** Test started, press 'g' to continue...\n");

    while (TRUE) {
        DbgPrint("*** To quit, press CTRL-C and type: ed %x 0;g\n", &testFlag);
        Sleep(1000);
        BREAK_INTO_DEBUGGER

        if (testFlag <= 0) break;
        err = WSAStartup(WINSOCK_VERSION, &wsadata);
        if (err != NO_ERROR) {
            WARNFAIL(WSAStartup); goto unload;
        }

        if (testFlag == 1) {
            FileXfer();
        }
        WSACleanup();
    }

unload:
    DbgPrint("Unloading XBox network stack...\n");
    XnetCleanup();

stop:
    if (testFlag == 0)
        HalReturnToFirmware(HalRebootRoutine);
    else
        Sleep(INFINITE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\tcp\tcpsend.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    tcpsend.c

Abstract:

    TCP data transmission related functions

Revision History:

    06/06/2000 davidx
        Created it.

--*/

#include "precomp.h"

//
// Maximum number of transmission retries
//
UINT cfgMaxXmitRetries = 5;

//
// Maximum and minimum retransmission timeout (in ticks)
// NOTE: Non-standard behavior!!!
//  Our maximum timeout between retries is 8sec, much shorter
//  than the usual value of 60sec. This is ok for our first
//  release since we only support LAN play.
//
UINT cfgMinRexmitTimeout = SLOW_TCP_TIMER_FREQ;
UINT cfgMaxRexmitTimeout = 8 * SLOW_TCP_TIMER_FREQ;

//
// Minimum zero-window-probe timeout (in ticks)
//
UINT cfgMinPersistTimeout = 5*SLOW_TCP_TIMER_FREQ;

//
// TCP statistics
//
TCPSTATS TcpStats;


VOID
TcbSendSegment(
    TCB* tcb,
    TCPSENDBUF* sendbuf
    )

/*++

Routine Description:

    Send a TCP segment out

Arguments:

    tcb - Points to the TCP control block
    sendbuf - Points to the segment to be sent

Return Value:

    NONE

--*/

{
    Packet* pkt = GetSendbufPkt(sendbuf);

    if (!IsSendbufActive(sendbuf)) {
        tcb->delayedAcks = 0;
        SendbufIncRef(sendbuf);

        ASSERT(SEQ_LE(sendbuf->seq, TcbSndNxt(tcb)) || (sendbuf->tcpflags & TCP_FIN));

        FILL_TCPHEADER(
            pkt,
            &tcb->addrpair,
            sendbuf->seq,
            tcb->rcv_nxt,
            sendbuf->tcphdrlen,
            sendbuf->tcpflags,
            (WORD) tcb->rcv_wnd);

        if (sendbuf->retries)
            pkt->pktflags |= PKTFLAG_REXMIT;

        PcbSetupIpHeader((PCB*) tcb, pkt, &tcb->addrpair);
        IpSendPacket(pkt, tcb->dstaddr, NULL, &tcb->rte);
    }

    if (sendbuf == TcbFirstSendbuf(tcb)) {
        // Set up the retransmisssion or persist timer

        UINT minTimeout = tcb->persistFlag ?
                            cfgMinPersistTimeout :
                            cfgMinRexmitTimeout;

        tcb->xmitTimer = (tcb->RTO << sendbuf->retries);
        if (tcb->xmitTimer < minTimeout)
            tcb->xmitTimer = minTimeout;
        else if (tcb->xmitTimer > cfgMaxRexmitTimeout)
            tcb->xmitTimer = cfgMaxRexmitTimeout;
    }

    sendbuf->retries++;
}


BOOL
TcbStartOutput(
    TCB* tcb
    )

/*++

Routine Description:

    Called when we have buffered data to send on a TCP socket. 

Arguments:

    tcb - Points to the TCP control block
    sendbuf - Specifies the segment to be sent

Return Value:

    TRUE if a segment was sent; FALSE otherwise.

--*/

{
    INT sndwndAvail;
    TCPSENDBUF* sendbuf;
    TCPSEQ cwndmax, swndmax;

    RUNS_AT_DISPATCH_LEVEL

    sendbuf = tcb->sendbufNext;
    ASSERT(tcb->snd_nxt == sendbuf->seq);
    ASSERT(sendbuf->retries == 0);

    // We always send SYN or FIN segments without delay
    if (sendbuf->datalen == 0) goto sendnow;

    // NOTE: We're using signed integer here in case
    // the send window was shrunk by the receiver.
    swndmax = tcb->snd_wl2 + tcb->snd_wnd;
    cwndmax = tcb->snd_una + tcb->snd_cwnd;
    sndwndAvail = (SEQ_LE(swndmax, cwndmax) ? swndmax : cwndmax) - tcb->snd_nxt;

    if ((INT) sendbuf->datalen <= sndwndAvail) {
        // Send window is large enough. Perform send-side
        // SWS avoidance. Note that if the PSH flag is not set,
        // then we must be sending a full-sized data segment.
        // Check the logic in TcbSend().

        // BUGBUG: Since we don't yet combine data from
        // multiple send calls into a single segment, it's
        // meaningless to delay the send.
        goto sendnow;
    }

    // Cannot send due to window constraints
    //  set up persist timers
    if (tcb->snd_nxt == tcb->snd_una) {
        TRACE_("Setting persist timer...");
        TcpStats.persists++;
        tcb->persistFlag = 1;
        tcb->xmitTimer = max(tcb->RTO, cfgMinPersistTimeout);
    }
    return FALSE;

sendnow:

    // Use this segment to measure round-trip time if possible
    tcb->persistFlag = 0;
    if (tcb->rtt_tick == 0) {
        tcb->rtt_tick = TcpTickCount;
        tcb->rtt_seq = sendbuf->seq;
    }
    
    sendbuf->firstSendTime = TcpTickCount;
    TcbSendSegment(tcb, sendbuf);
    tcb->snd_nxt = sendbuf->seqnext;
    tcb->sendbufNext = TcbSendbufFlink(sendbuf);
    return TRUE;
}


TCB*
TcbXmitTimeout(
    TCB* tcb
    )

/*++

Routine Description:

    This function is called when the TCP retransmission timer expires.

Arguments:

    tcb - Points to the TCP control block

Return Value:

    NULL if the specified TCB was deleted inside this call.
    Otherwise, just return the input tcb parameter.

--*/

{
    TCPSENDBUF* sendbuf;

    if (IsPcbSendBufEmpty(tcb)) return tcb;
    sendbuf = TcbFirstSendbuf(tcb);

    if (sendbuf->retries >= cfgMaxXmitRetries) {
        TcbResetPeer(tcb);
        return TcbReset(tcb, NETERR_TIMEOUT);
    }

    // Stop round-trip time measurement if there is retransmission
    tcb->rtt_tick = 0;

    // Retransmit the first segment
    if (tcb->persistFlag) {
        if (sendbuf->retries == 0) {
            // Send out the window probe segment for the first time.
            // BUGBUG: we always send out the whole segment instead
            // of just a single byte of data.

            ASSERT(sendbuf == tcb->sendbufNext);
            TcbSendSegment(tcb, sendbuf);
            tcb->snd_nxt = sendbuf->seqnext;
            tcb->sendbufNext = TcbSendbufFlink(sendbuf);
            return tcb;
        }
    } else {
        TRACE_("Retransmission timeout: %u, %d", sendbuf->seq, sendbuf->retries);
        ASSERT(sendbuf->retries != 0);
        TcpStats.rexmitTimeouts++;

        // Congestion control:
        //  set the slow-start threshold to be half the flight size
        //  and set the congestion window to be 1 SMSS
        TcbResetSsthresh(tcb);
        tcb->snd_cwnd = tcb->snd_mss;
        TcbStopFastRexmitMode(tcb);
    }

    TcbSendSegment(tcb, sendbuf);
    return tcb;
}


VOID
TcpSourceQuench(
    const IpHeader* iphdr
    )

/*++

Routine Description:

    Process ICMP source quench error message
    for a TCP connection

Arguments:

    iphdr - Points to the original IP header + at least 8 bytes of data

Return Value:

    NONE

--*/

{
    const TcpHeader* tcphdr;
    TCB* tcb;

    tcphdr = (const TcpHeader*) ((const BYTE*) iphdr + GETIPHDRLEN(iphdr));
    tcb = (TCB*) PcbFindMatch(
                    iphdr->srcaddr,
                    tcphdr->srcport,
                    iphdr->dstaddr,
                    tcphdr->dstport,
                    SOCK_STREAM,
                    IPPROTOCOL_TCP);

    if (tcb && IsTcpSyncState(tcb)) {
        // Treat source quench the same way as a retransmission timeout:
        //  reset the slow-start threshold
        //  and set the cwnd to 1 SMSS
        TcbResetSsthresh(tcb);
        tcb->snd_cwnd = tcb->snd_mss;
        TcbStopFastRexmitMode(tcb);
    }
}


VOID
TcbDoFastRexmit(
    TCB* tcb
    )

/*++

Routine Description:

    Initiate the TCP fast retransmit / recovery procedure

Arguments:

    tcb - Points to the TCP control block

Return Value:

    NONE

--*/

{
    TCPSENDBUF* sendbuf;

    TRACE_("Fast rexmit mode: %u", tcb->snd_una);
    TcpStats.fastRexmits++;

    // Reset the slow-start threshold
    // and set the congestion window to be that plus 3*SMSS
    TcbResetSsthresh(tcb);
    tcb->snd_cwnd = tcb->snd_ssthresh + 3*tcb->snd_mss;
    tcb->fastRexmitFlag = 1;
    tcb->dupacks = 0;

    // Retransmit the "lost" segment immediately
    sendbuf = TcbFirstSendbuf(tcb);
    ASSERT(sendbuf != TcbSendbufNil(tcb) && sendbuf->retries);
    TcbSendSegment(tcb, sendbuf);
}


VOID
TcbQueueSegment(
    TCB* tcb,
    Packet* pkt,
    BYTE tcpflags
    )

/*++

Routine Description:

    Initialize the header information for an outgoing TCP packet

Arguments:

    tcb - Points to the TCP control block
    pkt - Points to the outgoing TCP packet
    tcpflags - Specifies the TCP segment flags

Return Value:

    NONE

--*/

// TCP option length in our SYN segment
#define SYNTCPOPTLEN 4

{
    TCPSENDBUF* sendbuf;

    RUNS_AT_DISPATCH_LEVEL

    sendbuf = GETPKTBUF(pkt, TCPSENDBUF);
    sendbuf->refcount = 1;
    sendbuf->retries = 0;
    sendbuf->tcpflags = tcpflags;
    sendbuf->tcphdrlen = (BYTE) ((tcpflags & TCP_SYN) ?
                                    TCPHDRLEN+SYNTCPOPTLEN :
                                    TCPHDRLEN);
    sendbuf->seq = tcb->snd_end;

    if (tcpflags & (TCP_SYN|TCP_FIN)) {
        sendbuf->datalen = 0;
        sendbuf->seqnext = sendbuf->seq + 1;
    } else {
        sendbuf->datalen = pkt->datalen - TCPHDRLEN;
        sendbuf->seqnext = sendbuf->seq + sendbuf->datalen;
    }
    tcb->snd_end = sendbuf->seqnext;

    tcb->sendbufSize += sendbuf->datalen;
    InsertTailList(&tcb->sendbuf, &sendbuf->links);

    if (!TcbHasPendingSend(tcb)) {
        tcb->sendbufNext = sendbuf;
        TcbStartOutput(tcb);
    }
}


//
// TCP segment packet completion routine
//
PRIVATE VOID TcbSendCompletionProc(Packet* pkt, NTSTATUS status) {
    TCPSENDBUF* sendbuf = GETPKTBUF(pkt, TCPSENDBUF);
    pkt->data = sendbuf->pktdata;
    pkt->datalen = sendbuf->pktdatalen;
    SendbufRelease(sendbuf);
}

//
// Allocate packet buffer for sending a TCP segment
// (that could be retransmitted)
//
PRIVATE Packet*
TcbAllocSendbuf(
    UINT datalen,
    UINT pktflags
    )
{
    UINT hdrlen;
    Packet* pkt;
    TCPSENDBUF* sendbuf;

    hdrlen = sizeof(TCPSENDBUF) + MAXLINKHDRLEN + MAXIPHDRLEN;
    datalen += TCPHDRLEN;
    pkt = XnetAllocPacket(hdrlen + datalen, pktflags);
    if (!pkt) return NULL;

    pkt->data += hdrlen;
    pkt->datalen = datalen;
    sendbuf = GETPKTBUF(pkt, TCPSENDBUF);
    sendbuf->pktdata = pkt->data;
    sendbuf->pktdatalen = pkt->datalen;

    XnetSetPacketCompletion(pkt, TcbSendCompletionProc);
    return pkt;
}


NTSTATUS
TcbSend(
    TCB* tcb,
    SENDREQ* sendreq
    )

/*++

Routine Description:

    Handle a user request to send data from a TCP socket

Arguments:

    tcb - Points to the TCP control block
    sendreq - Points to the send request information

Return Value:

    Status code

Note:

    This function always return immediately. For blocking operation,
    we assume the caller has taken care of any necessary wait.

--*/

{
    NTSTATUS status = NETERR_OK;
    Packet* pkt = NULL;
    WSABUF* bufs = sendreq->bufs;
    UINT bytesToSend = sendreq->sendtotal;
    UINT mss = tcb->snd_mss - tcb->ipoptlen;
    UINT n, datalen;
    BYTE* data;
    KIRQL irql;

    // Make sure we don't overflow the send buffer too much.
    // In the following case:
    //  old sendbuf size + the datagram size > max sendbuf size
    // we'll temporarily exceed the send buffer size limit a little bit.
    ASSERT(!IsPcbSendBufFull(tcb));
    n = tcb->maxSendBufsize - tcb->sendbufSize;
    if (bytesToSend > max(n, mss))
        sendreq->sendtotal = bytesToSend = mss;

    data = bufs->buf;
    datalen = bufs->len;

    while (bytesToSend > 0) {
        UINT segsize = min(mss, bytesToSend);
        BYTE* p;

        pkt = TcbAllocSendbuf(segsize, 0);
        if (!pkt) {
            if ((sendreq->sendtotal -= bytesToSend) == 0) {
                // If we've already send out some data,
                // then return success with partial byte count.
                // Otherwise, return error code.
                status = NETERR_MEMORY;
            }
            break;
        }

        bytesToSend -= segsize;
        p = pkt->data + TCPHDRLEN;
        if (segsize <= datalen) {
            // Fast case: all the data for this segment
            // comes from the same user buffer.
            CopyMem(p, data, segsize);
            data += segsize;
            datalen -= segsize;
        } else {
            // Slow case: need to gather data for this segment
            // from multiple user buffers.
            while (segsize) {
                while (datalen == 0) {
                    bufs++;
                    data = bufs->buf;
                    datalen = bufs->len;
                }
                n = min(segsize, datalen);
                CopyMem(p, data, n);
                p += n;
                data += n;
                datalen -= n;
                segsize -= n;
            }
        }

        irql = RaiseToDpc();
        status = PcbGetErrStatus(tcb);
        if (NT_SUCCESS(status)) {
            TcbQueueSegment(tcb, pkt, (BYTE) (bytesToSend ? TCP_ACK : (TCP_ACK|TCP_PSH)));
            LowerFromDpc(irql);
        } else {
            XnetFreePacket(pkt);
            LowerFromDpc(irql);
            break;
        }
    }

    // If the app calls connect() on a non-blocking socket, and then calls send()
    // without calling select(), then we need to reset the connectSelected flag
    // so future select() calls will ignore PCBEVENT_CONNECT.
    tcb->connectSelected = 1;

    return status;
}


VOID
TcbEmitRST(
    IfInfo* ifp,
    IpAddrPair* addrpair,
    TCPSEQ seq,
    TCPSEQ ack,
    BYTE flags
    )

/*++

Routine Description:

    Send out a TCP RST segment in response to a received packet

Arguments:

    ifp - Points the interface involved
    addrpair - Specifies the source and destination
    seq, ack - Specifies the sequence and acknowledgement number
    flag - Specifies the TCP segment flags

Return Value:

    NONE

--*/

{
    Packet* pkt;

    pkt = XnetAllocIpPacket(0, TCPHDRLEN);
    if (!pkt) return;

    FILL_TCPHEADER(
        pkt,
        addrpair,
        seq,
        ack,
        TCPHDRLEN,
        (BYTE) (TCP_RST|flags),
        0);

    IpSendPacketInternal(pkt, addrpair->srcaddr, addrpair->dstaddr, IPPROTOCOL_TCP, ifp);
}


NTSTATUS
TcbEmitSYN(
    TCB* tcb,
    BOOL synAck
    )

/*++

Routine Description:

    Emit a TCP SYN segment

Arguments:

    tcb - Points to the TCP control block
    synAck - Whether to send ACK as well

Return Value:

    Status code

--*/

{
    Packet* pkt;
    BYTE* opt;
    TCPSENDBUF* sendbuf;

    // Check if we're already trying to send out a SYN segment
    if (!IsPcbSendBufEmpty(tcb)) {
        sendbuf = (TCPSENDBUF*) RemoveHeadList(&tcb->sendbuf);
        SendbufRelease(sendbuf);
        ASSERT(IsPcbSendBufEmpty(tcb));
        ASSERT(!TcbHasPendingSend(tcb));
    }

    tcb->snd_una = tcb->snd_nxt = tcb->snd_end = tcb->snd_isn;

    // Allocate a TCP send buffer for possible retransmission
    pkt = TcbAllocSendbuf(SYNTCPOPTLEN, synAck ? PKTFLAG_NETPOOL : 0);
    if (!pkt) {
        // This is very bad - we failed to allocate memory
        // for the SYN segment. We'll mark the TCB as dead
        // and return an error code.
        TcbReset(tcb, NETERR_MEMORY);
        return NETERR_MEMORY;
    }

    TcbSetSynTimer(tcb, cfgConnectTimeout);

    opt = pkt->data + TCPHDRLEN;
    opt[0] = TCPOPT_MAX_SEGSIZE;
    opt[1] = SYNTCPOPTLEN;
    opt[2] = (BYTE) (tcb->rcv_mss >> 8);
    opt[3] = (BYTE) tcb->rcv_mss;

    TcbQueueSegment(tcb, pkt, (BYTE) (synAck ? TCP_SYN|TCP_ACK : TCP_SYN));
    return NETERR_OK;
}


VOID
TcbEmitACK(
    TCB* tcb
    )

/*++

Routine Description:

    Send out an ACK segment on a TCP connection

Arguments:

    tcb - Points to the TCP control block

Return Value:

    NONE

--*/

{
    TCPSEQ seq;
    Packet* pkt = XnetAllocPacket(MAXLINKHDRLEN + MAXIPHDRLEN + TCPHDRLEN, PKTFLAG_NETPOOL);
    if (!pkt) return;

    pkt->data += MAXLINKHDRLEN + MAXIPHDRLEN;
    pkt->datalen = TCPHDRLEN;

    seq = TcbSndNxt(tcb);
    FILL_TCPHEADER(
        pkt,
        &tcb->addrpair,
        seq,
        tcb->rcv_nxt,
        TCPHDRLEN,
        TCP_ACK,
        (WORD) tcb->rcv_wnd);

    tcb->delayedAcks = 0;
    PcbSetupIpHeader((PCB*) tcb, pkt, &tcb->addrpair);
    IpSendPacket(pkt, tcb->dstaddr, NULL, &tcb->rte);
}


NTSTATUS
TcbEmitFIN(
    TCB* tcb
    )

/*++

Routine Description:

    Send out a FIN segment on a TCP connection

Arguments:

    tcb - Points to the TCP control block

Return Value:

    Status code

--*/

{
    Packet* pkt = TcbAllocSendbuf(0, 0);
    if (!pkt) return NETERR_MEMORY;
    TcbQueueSegment(tcb, pkt, TCP_ACK|TCP_FIN);
    return NETERR_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\test\lib\precomp.h ===
#include "xnetp.h"
#include "xnettest.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\test\gethost\gethost.c ===
// Simple DNS client test program

#include "precomp.h"
#include <stdlib.h>

#ifdef TEST_PPP
#include <xppp.h>
#endif // TEST_PPP

INT testFlag = 1;
INT err;


#define BREAK_INTO_DEBUGGER __asm int 3
#define WARNFAIL(_apiname) \
        DbgPrint(#_apiname " failed: %d %d\n", err, GetLastError())


CHAR* testnames[] = {
    "davidxu",
    "davidxu.ntdev.microsoft.com",
    "foobar",
    "www.msn.com."
};

struct {
    BYTE addr[4];
} testaddrs[] = {
    { 157, 56, 11, 44 },
    { 192, 55, 34, 25 }
};


VOID
PrintHostent(
    struct hostent* host
    )
{
    CHAR** p;
    if (host == NULL) {
        DbgPrint("  failed: %d\n", GetLastError());
    } else {
        DbgPrint("  %s\n", host->h_name);
        p = host->h_aliases;
        while (*p) {
            DbgPrint("  %s\n", *p);
            p++;
        }

        p = host->h_addr_list;
        while (*p) {
            DbgPrint("  %s\n", inet_ntoa(*((struct in_addr*) *p)));
            p++;
        }
    }
}

VOID
DnsTest()
{
    INT index, count;
    struct hostent* host;
    CHAR localhost[32];

    err = gethostname(localhost, 32);
    if (err != NO_ERROR) {
        WARNFAIL(gethostname);
    } else {
        DbgPrint("Lookup hostname: %s...\n", localhost);
        host = gethostbyname(localhost);
        PrintHostent(host);
    }

    count = ARRAYCOUNT(testnames);
    for (index=0; index < count; index++) {
        DbgPrint("Lookup hostname: %s...\n", testnames[index]);
        host = gethostbyname(testnames[index]);
        PrintHostent(host);
    }

    count = ARRAYCOUNT(testaddrs);
    for (index=0; index < count; index++) {
        struct in_addr* addr = (struct in_addr*) &testaddrs[index];
        DbgPrint("Lookup address: %s\n", inet_ntoa(*addr));
        host = gethostbyaddr((char*) addr, sizeof(*addr), AF_INET);
        PrintHostent(host);
    }
}


void __cdecl main()
{
    WSADATA wsadata;

    DbgPrint("Loading XBox network stack...\n");
    err = XnetInitialize(NULL, TRUE);
    if (err != NO_ERROR) {
        WARNFAIL(XnetInitialize); goto stop;
    }

#ifdef TEST_PPP
    PppConnect("guest", "password", "", "9-786-1000");
//    PppConnect("004vgorok@spinway", "Ob4seBa5", "", "9-827-3261");
    Sleep(90000);
#endif // TEST_PPP

    err = WSAStartup(WINSOCK_VERSION, &wsadata);
    if (err != NO_ERROR) {
        WARNFAIL(WSAStartup); goto unload;
    }

    DbgPrint("*** Test started, press 'g' to continue...\n");
    BREAK_INTO_DEBUGGER

    while (testFlag > 0) {
        Sleep(1000);
        DnsTest();
        DbgPrint("*** To quit, press CTRL-C and type: ed %x 0;g\n", &testFlag);
        BREAK_INTO_DEBUGGER
    }

    WSACleanup();

unload:
    DbgPrint("Unloading XBox network stack...\n");
    XnetCleanup();

stop:
    if (testFlag == 0)
        HalReturnToFirmware(HalRebootRoutine);
    else
        Sleep(INFINITE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\test\tcptest\precomp.h ===
#include "xnetp.h"
#include "xnettest.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\test\httptest\precomp.h ===
#include "xnetp.h"
#include "xnettest.h"
#include <wininet.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\test\tftp\precomp.h ===
#include "xnetp.h"
#include "xnettest.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\test\lib\xnettest.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    xnettest.h

Abstract:

    XBox network test shared header file

Revision History:

    08/07/2000 davidx
        Created it.

--*/

#ifndef _XNETTEST_H
#define _XNETTEST_H

//
// Wrap function for Winsock API
//
INLINE INT _send(SOCKET s, CHAR* buf, DWORD* buflen) {
    WSABUF wsabuf = { *buflen, buf };
    return WSASend(s, &wsabuf, 1, buflen, 0, 0, 0);
}

INLINE INT _sendto(SOCKET s, CHAR* buf, DWORD* buflen, struct sockaddr_in* to) {
    WSABUF wsabuf = { *buflen, buf };
    return WSASendTo(s, &wsabuf, 1, buflen, 0, (struct sockaddr*) to, sizeof(*to), 0, 0);
}

INLINE INT _recv(SOCKET s, CHAR* buf, DWORD* buflen) {
    WSABUF wsabuf = { *buflen, buf };
    DWORD flags = 0;
    return WSARecv(s, &wsabuf, 1, buflen, &flags, 0, 0);
}

INLINE INT _recvfrom(SOCKET s, CHAR* buf, DWORD* buflen, struct sockaddr_in* from) {
    WSABUF wsabuf = { *buflen, buf };
    INT fromlen = sizeof(*from);
    DWORD flags = 0;
    return WSARecvFrom(s, &wsabuf, 1, buflen, &flags, (struct sockaddr*) from, &fromlen, 0, 0);
}

INLINE INT _bind(SOCKET s, struct sockaddr_in* addr) {
    return bind(s, (struct sockaddr*) addr, sizeof(*addr));
}

INLINE INT _getsockname(SOCKET s, struct sockaddr_in* addr) {
    INT addrlen = sizeof(*addr);
    return getsockname(s, (struct sockaddr*) addr, &addrlen);
}

INLINE _connect(SOCKET s, struct sockaddr_in* addr) {
    return connect(s, (struct sockaddr*) addr, sizeof(*addr));
}

INLINE INT _accept(SOCKET s, struct sockaddr_in* addr) {
    INT addrlen = sizeof(*addr);
    return accept(s, (struct sockaddr*) addr, &addrlen);
}

INLINE INT _setrcvtimeout(SOCKET s, INT timeout) {
    return setsockopt(s, SOL_SOCKET, SO_RCVTIMEO, (CHAR*) &timeout, sizeof(timeout));
}

//
// Sequential file I/O functions
//
typedef struct _SeqFile SeqFile;
extern UINT cfgSeqFileBufSize;

SeqFile* _CreateFile(const CHAR* filename, DWORD accessMode);
VOID _CloseFile(SeqFile* file);
BOOL _ReadFile(SeqFile* file, CHAR** buf, UINT* buflen);
BOOL _WriteFile(SeqFile* file, const VOID* buf, UINT buflen);

//
// Debugging macros
//
#define BREAK_INTO_DEBUGGER __asm int 3
#define WARNFAIL(_apiname) \
        DbgPrint(#_apiname " failed: %d %d\n", err, GetLastError())

#endif // !_XNETTEST_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\test\mcping\precomp.h ===
#include "xnetp.h"
#include "xnettest.h"
#include "icmp.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\test\tftpd\precomp.h ===
#include "xnetp.h"
#include "xnettest.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\test\tcptest\tcptest.c ===
#include "precomp.h"
#include <stdlib.h>

#define MAXBUFSIZE      4096
#define MAXXFERCNT      0x100
#define TESTPORT        600
#define TESTADDR        "157.56.11.44"
//#define TESTADDR        "157.56.10.166"

CHAR buf[MAXBUFSIZE];
INT maxxfercnt = MAXXFERCNT;
INT fixxfersize = 0;
INT testFlag = 1;
INT err;
struct sockaddr_in sockname;


VOID
ServerTest()
{
    WSADATA wsadata;
    SOCKET sock, s;
    INT index, total;
    ULONG randSeed = GetTickCount();
    DWORD timer;

    err = WSAStartup(WINSOCK_VERSION, &wsadata);
    if (err != NO_ERROR) {
        WARNFAIL(WSAStartup); return;
    }

    sock = socket(AF_INET, SOCK_STREAM, 0);
    if (sock == INVALID_SOCKET) {
        WARNFAIL(socket);
        WSACleanup();
        return;
    }

    sockname.sin_family = AF_INET;
    sockname.sin_port = htons(TESTPORT);
    sockname.sin_addr.s_addr = INADDR_ANY;

    err = _bind(sock, &sockname);
    if (err != NO_ERROR) {
        WARNFAIL(bind); goto exit;
    }

    err = listen(sock, 1);
    if (err != NO_ERROR) {
        WARNFAIL(listen); goto exit;
    }

    err = _getsockname(sock, &sockname);
    if (err != NO_ERROR) {
        WARNFAIL(getsockname); goto exit;
    }

    DbgPrint("Listening on: %s:%d\n",
             inet_ntoa(sockname.sin_addr),
             ntohs(sockname.sin_port));

    s = _accept(sock, &sockname);
    if (s == INVALID_SOCKET) {
        WARNFAIL(accept); goto exit;
    }

    DbgPrint("Connected to: %s:%d\n",
             inet_ntoa(sockname.sin_addr),
             ntohs(sockname.sin_port));

    timer = GetTickCount();
    total = 0;
    for (index=0; index < maxxfercnt; index++) {
        INT count;

        if ((index & 0x3ff) == 0) DbgPrint(".");
        count = fixxfersize ? fixxfersize : RtlRandom(&randSeed) % MAXBUFSIZE + 1;

        count = send(s, buf, count, 0);
        if (count == SOCKET_ERROR) {
            WARNFAIL(send); break;
        }

        total += count;
    }

    closesocket(s);
    timer = GetTickCount() - timer;
    if (timer == 0) timer = 1;
    DbgPrint("Closing connection: %d total bytes transferred\n", total);
    DbgPrint("  time: %dmsec, rate: %d bytes/sec\n", timer, MulDiv(total, 1000, timer));
    Sleep(1000);

exit:
    closesocket(sock);
    WSACleanup();
}


VOID
ClientTest()
{
    WSADATA wsadata;
    SOCKET s;
    INT total, count;
    DWORD timer;

    err = WSAStartup(WINSOCK_VERSION, &wsadata);
    if (err != NO_ERROR) {
        WARNFAIL(WSAStartup); return;
    }

    s = socket(AF_INET, SOCK_STREAM, 0);
    if (s == INVALID_SOCKET) {
        WARNFAIL(socket);
        WSACleanup();
        return;
    }

    sockname.sin_family = AF_INET;
    sockname.sin_port = htons(TESTPORT);
    sockname.sin_addr.s_addr = inet_addr(TESTADDR);

    DbgPrint("Connecting to: %s:%d\n",
             inet_ntoa(sockname.sin_addr),
             ntohs(sockname.sin_port));

    timer = GetTickCount();
    err = _connect(s, &sockname);
    if (err != NO_ERROR) {
        WARNFAIL(connect); goto exit;
    }

    err = _getsockname(s, &sockname);
    if (err != NO_ERROR) {
        WARNFAIL(getsockname); goto exit;
    }

    DbgPrint("Local address: %s:%d\n",
             inet_ntoa(sockname.sin_addr),
             ntohs(sockname.sin_port));

    total = 0;
    do {
        count = recv(s, buf, MAXBUFSIZE, 0);
        if (count == SOCKET_ERROR) {
            WARNFAIL(recv); goto exit;
        }

        total += count;
    } while (count > 0);

    timer = GetTickCount() - timer;
    if (timer == 0) timer = 1;
    DbgPrint("Connection closed: %d total bytes transferred\n", total);
    DbgPrint("  time: %dmsec, rate: %d bytes/sec\n", timer, MulDiv(total, 1000, timer));

exit:
    closesocket(s);
    WSACleanup();
}


void __cdecl main()
{
    DbgPrint("Loading XBox network stack...\n");
    err = XnetInitialize(NULL, TRUE);
    if (err != NO_ERROR) {
        WARNFAIL(XnetInitialize); goto stop;
    }

    DbgPrint("*** Test started, press 'g' to continue...\n");

    while (TRUE) {
        DbgPrint("*** To quit, press CTRL-C and type: ed %x 0;g\n", &testFlag);
        BREAK_INTO_DEBUGGER

        if (testFlag <= 0) break;
        if (testFlag == 1) {
            ClientTest();
        } else {
            ServerTest();
        }
    }

    DbgPrint("Unloading XBox network stack...\n");
    XnetCleanup();

stop:
    if (testFlag == 0)
        HalReturnToFirmware(HalRebootRoutine);
    else
        Sleep(INFINITE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\test\httptest\httptest.cxx ===
// HTTP Client Library test program

#include "precomp.h"

INT testFlag = 1;
INT err;

#define BUFSIZE 4096
CHAR buf[BUFSIZE];
LPCWSTR acceptTypes[] = { L"*/*", NULL };

//
// Use our own new/delete operators
//
VOID* __cdecl operator new(size_t size) {
    return MAlloc(size);
}

VOID __cdecl operator delete(VOID* p) {
    Free(p);
}


//
// Dump the HTTP response headers
//
#define HTTPQUERYINFO(_infolevel, _buf, _len, _barf) \
        len = (_len); \
        ok = HttpQueryInfo(hRequest, _infolevel, &(_buf), &len, NULL); \
        if (!ok && _barf) { \
            WARNFAIL(HttpQueryInfo); return; \
        }


VOID
DumpResponseHeaders(
    HINTERNET hRequest
    )
{
    #define _FIELD(x) { x, #x }
    static const struct {
        DWORD index;
        CHAR* name;
    } infoLevels[] = {
        _FIELD(HTTP_QUERY_CONTENT_TYPE),
        _FIELD(HTTP_QUERY_CONTENT_LENGTH),
        _FIELD(HTTP_QUERY_DATE),
        _FIELD(HTTP_QUERY_EXPIRES),
        _FIELD(HTTP_QUERY_LAST_MODIFIED),
        _FIELD(HTTP_QUERY_VERSION),
        _FIELD(HTTP_QUERY_STATUS_CODE),
        _FIELD(HTTP_QUERY_STATUS_TEXT),
        _FIELD(HTTP_QUERY_ACCEPT),
    };

    DWORD statusCode;
    DWORD len;
    WCHAR buf[1024];
    UINT i, count;
    BOOL ok;

    HTTPQUERYINFO(
        HTTP_QUERY_STATUS_CODE|HTTP_QUERY_FLAG_NUMBER,
        statusCode,
        sizeof(statusCode),
        TRUE);
    DbgPrint("Response status code: %d\n", statusCode);

    switch (testFlag) {
    case 1: {
        SYSTEMTIME systime;
        HTTPQUERYINFO(
            HTTP_QUERY_DATE|HTTP_QUERY_FLAG_SYSTEMTIME,
            systime,
            sizeof(systime),
            TRUE);

        DbgPrint("Date: %04d/%02d/%02d %d %02d:%02d:%02d\n",
            systime.wYear,
            systime.wMonth,
            systime.wDay,
            systime.wDayOfWeek,
            systime.wHour,
            systime.wMinute,
            systime.wSecond);
        }

    case 2: {
        
        i = (testFlag == 1) ?
                HTTP_QUERY_RAW_HEADERS :
                HTTP_QUERY_RAW_HEADERS_CRLF;

        len = 0;
        if (HttpQueryInfo(hRequest, i, NULL, &len, NULL) ||
            GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
            WARNFAIL(HttpQueryInfo); return;
        }

        WCHAR* hdrbuf = (WCHAR*) MAlloc(len);
        if (!hdrbuf) {
            WARNFAIL(MAlloc); return;
        }

        len /= sizeof(WCHAR);
        if (!HttpQueryInfo(hRequest, i, hdrbuf, &len, NULL)) {
            WARNFAIL(HttpQueryInfo);
            Free(hdrbuf);
            return;
        }

        WCHAR* p = hdrbuf;
        if (i == HTTP_QUERY_RAW_HEADERS_CRLF) {
            while (*p) {
                if (p[0] == L'\r' && p[1] == L'\n') {
                    *p++ = L' ';
                    *p++ = 0;
                } else
                    p++;
            }
            p = hdrbuf;
        }

        while (*p) {
            DbgPrint("%ws\n", p);
            p += wcslen(p) + 1;
        }

        Free(hdrbuf);
        }
        break;

    case 3:

        count = ARRAYCOUNT(infoLevels);
        for (i=0; i < count; i++) {
            HTTPQUERYINFO(infoLevels[i].index, buf, ARRAYCOUNT(buf), FALSE);
            DbgPrint("%3s: ", infoLevels[i].name);
            if (ok) {
                DbgPrint("%ws\n", buf);
            } else {
                DbgPrint("*** error - %d\n", GetLastError());
            }
        }

        wcscpy(buf, L"Server");
        HTTPQUERYINFO(HTTP_QUERY_CUSTOM, buf, ARRAYCOUNT(buf), FALSE);
        DbgPrint("Server: ");
        if (ok) {
            DbgPrint("%ws\n", buf);
        } else {
            DbgPrint("*** error - %d\n", GetLastError());
        }
        break;
    }
}


//
// Dump the HTTP response message in response to a request
//
VOID
DumpGetResponse(
    HINTERNET hRequest
    )
{
    DumpResponseHeaders(hRequest);

    DWORD size, total = 0;

    do {
        if (!InternetReadFile(hRequest, buf, BUFSIZE, &size)) {
            WARNFAIL(InternetReadFile); return;
        }
        total += size;
    } while (size != 0);

    DbgPrint("Response data: %d bytes\n\n", total);
}


//
// HTTP GET without using a proxy server
//
VOID
GetTestDirect()
{
    HINTERNET hInternet;
    HINTERNET hRequest;

    hInternet = InternetOpen(NULL, INTERNET_OPEN_TYPE_DIRECT, NULL, NULL, 0);
    if (!hInternet) {
        WARNFAIL(InternetOpen); return;
    }

    hRequest = InternetOpenUrl(hInternet, L"http://davidx3", NULL, 0, 0, 0);
    if (!hRequest) {
        WARNFAIL(InternetOpenUrl);
    } else {
        DumpGetResponse(hRequest);
        InternetCloseHandle(hRequest);
    }

    InternetCloseHandle(hInternet);
}


//
// HTTP GET through a proxy server
//
VOID
GetTestProxied()
{
    HINTERNET hInternet;
    HINTERNET hConnect = NULL;
    HINTERNET hRequest = NULL;

    hInternet = InternetOpen(NULL, INTERNET_OPEN_TYPE_PROXY, L"itgproxy", NULL, 0);
    if (!hInternet) {
        WARNFAIL(InternetOpen); return;
    }

    // Use InternetConnect/HttpOpenRequest/HttpSendRequest
    // instead of InternetOpenUrl for this test

    hConnect = InternetConnect(
                    hInternet,
                    L"www.xbox.com",
                    INTERNET_DEFAULT_HTTP_PORT,
                    NULL,
                    NULL,
                    INTERNET_SERVICE_HTTP,
                    0,
                    0);

    if (!hConnect) {
        WARNFAIL(InternetConnect); goto exit;
    }

    hRequest = HttpOpenRequest(
                    hConnect,
                    L"GET",
                    L"/xbox/flash/home.asp",
                    NULL,
                    NULL,
                    acceptTypes,
                    0,
                    0);

    if (!hRequest) {
        WARNFAIL(HttpOpenRequest); goto exit;
    }

    if (HttpSendRequest(hRequest, NULL, 0, NULL, 0)) {
        DumpGetResponse(hRequest);
    }

exit:
    if (hRequest) { InternetCloseHandle(hRequest); }
    if (hConnect) { InternetCloseHandle(hConnect); }
    InternetCloseHandle(hInternet);
}


//
// HTTP POST without using a proxy server
//
VOID
PostTestDirect()
{
    static const WCHAR extraHeaders[] =
        L"From: foo@bar.com\r\n"
        L"Content-Type: application/x-www-form-urlencoded\r\n";

    HINTERNET hInternet;
    HINTERNET hConnect = NULL;
    HINTERNET hRequest = NULL;

    hInternet = InternetOpen(NULL, INTERNET_OPEN_TYPE_DIRECT, NULL, NULL, 0);
    if (!hInternet) {
        WARNFAIL(InternetOpen); return;
    }

    hConnect = InternetConnect(
                    hInternet,
                    L"davidx3",
                    INTERNET_DEFAULT_HTTP_PORT,
                    NULL,
                    NULL,
                    INTERNET_SERVICE_HTTP,
                    0,
                    0);

    if (!hConnect) {
        WARNFAIL(InternetConnect); goto exit;
    }

    hRequest = HttpOpenRequest(
                    hConnect,
                    L"POST",
                    L"/test",
                    NULL,
                    NULL,
                    acceptTypes,
                    0,
                    0);

    if (!hRequest) {
        WARNFAIL(HttpOpenRequest); goto exit;
    }

    // Send additional header fields
    // and send the content of a file as optional data

    if (HttpSendRequest(
            hRequest,
            extraHeaders,
            -1, 
            L"T:\\test",
            -1)) {
        DumpGetResponse(hRequest);
    }

exit:
    if (hRequest) { InternetCloseHandle(hRequest); }
    if (hConnect) { InternetCloseHandle(hConnect); }
    InternetCloseHandle(hInternet);
}


void __cdecl main()
{
    DbgPrint("Loading XBox network stack...\n");
    err = XnetInitialize(NULL, TRUE);
    if (err != NO_ERROR) {
        WARNFAIL(XnetInitialize);
        BREAK_INTO_DEBUGGER
    }

    DbgPrint("*** Test started, press 'g' to continue...\n");

    while (TRUE) {
        DbgPrint("*** To quit, press CTRL-C and type: ed %x 0;g\n", &testFlag);
        BREAK_INTO_DEBUGGER

        if (testFlag <= 0) break;
        switch (testFlag) {
        case 1:
            GetTestDirect();
            break;

        case 2:
            GetTestProxied();
            break;

        case 3:
            PostTestDirect();
            break;
        }
    }

    XnetCleanup();

    if (testFlag == 0)
        HalReturnToFirmware(HalRebootRoutine);
    else
        Sleep(INFINITE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\test\tftp\tftp.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    tftp.h

Abstract:

    Simple TFTP client implementation for XBox

Revision History:

    04/19/2000 davidx
        Created it.

--*/

#ifndef _TFTP_H
#define _TFTP_H

//
// TFTP server UDP port number
//

#define TFTP_SERVER_PORT 69

//
// TFTP opcodes
//

#define TFTPOP_RRQ      1
#define TFTPOP_WRQ      2
#define TFTPOP_DATA     3
#define TFTPOP_ACK      4
#define TFTPOP_ERROR    5
#define TFTPOP_OACK     6

//
// Max TFTP packet size: 4 bytes header + 512 bytes data
//

#define TFTP_DATAPACKET_HEADERSIZE  4
#define TFTP_DATAPACKET_BLOCKSIZE   512
#define TFTP_PACKET_BUFSIZE         (4+512)

//
// Error codes
//

#define TFTPERR_UNKNOWN         0
#define TFTPERR_FILE_NOT_FOUND  1
#define TFTPERR_ACCESS_DENIED   2
#define TFTPERR_DISK_FULL       3
#define TFTPERR_INVALID_OPCODE  4
#define TFTPERR_INVALID_ID      5
#define TFTPERR_FILE_EXISTS     6
#define TFTPERR_INVALID_USER    7
#define TFTPERR_INVALID_OACK    8

//
// Timeout and retry values
//
#define TFTP_MAX_RETRIES        3
#define TFTP_RECV_TIMEOUT       2000

//
// Extract a u_short field out of an incoming TFTP message
// NOTE:
//  we assume we're on a little-endian machine and
//  take care of byte swapping here.
//
#define GETUSHORTFIELD(_var) do { \
            if (buflen < 2) goto failed; \
            _var = ((UINT) ((BYTE*) buf)[0] << 8 | \
                    (UINT) ((BYTE*) buf)[1]); \
            buf += 2; \
            buflen -= 2; \
        } while (0)

//
// Extract a string field out of an incoming TFTP message
//
#define GETSTRINGFIELD(_var) do { \
            CHAR* _p = buf; \
            CHAR* _q = _p + buflen; \
            INT _n; \
            while (_p < _q && *_p) _p++; \
            if (_p == _q) goto failed; \
            _var = buf; \
            _n = (_p - buf) + 1; \
            buf += _n; \
            buflen -= _n; \
        } while (0)

//
// Insert a u_short field into an outgoing TFTP message
// NOTE:
//  we assume we're on a little-endian machine and
//  take care of byte swapping here.
//
#define ADDUSHORTFIELD(_var) do { \
            buf[0] = (CHAR) ((_var) >> 8); \
            buf[1] = (CHAR) (_var); \
            buf += 2; \
        } while (0)

//
// Insert a string field into an outgoing TFTP message
//
#define ADDSTRINGFIELD(_var) do { \
            INT _n = strlen(_var) + 1; \
            memcpy(buf, _var, _n); \
            buf += _n; \
        } while (0)

#endif // !_TFTP_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\test\mcping\mcping.c ===
// This is a simple program for testing the following functionality:
//  multicast send and receive
//  RAW socket
//  Winsock select API

#include "precomp.h"
#include <stdlib.h>

UINT WINAPI tcpipxsum(UINT xsum, const VOID* buf, UINT buflen);

#define RCVTIMEOUT  3
#define PINGBUFSIZE 2048
#define TESTADDR    "229.0.0.1"

INT testFlag = 2;
INT err;
CHAR databuf[PINGBUFSIZE];
INT rcvlen;
WORD id, seqno;
CHAR pingdata[] = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";


VOID
SendIcmpMessage(
    SOCKET s,
    struct sockaddr_in* toaddr,
    IcmpMessage* icmpmsg,
    UINT msglen
    )
{
    icmpmsg->checksum = 0;
    icmpmsg->checksum = (WORD) ~tcpipxsum(0, icmpmsg, msglen);

    err = _sendto(s, (CHAR*) icmpmsg, &msglen, toaddr);
    if (err != NO_ERROR) {
        WARNFAIL(sendto);
    }
}


BOOL
RecvIcmpMessage(
    SOCKET s,
    struct sockaddr_in* fromaddr
    )
{
    TIMEVAL timeout;
    fd_set readfds;
    DWORD len;

    // Wait until there is data to be read

    timeout.tv_sec = RCVTIMEOUT;
    timeout.tv_usec = 0;

    FD_ZERO(&readfds);
    FD_SET(s, &readfds);

    err = select(1, &readfds, NULL, NULL, &timeout);
    if (err == SOCKET_ERROR) {
        WARNFAIL(select); return FALSE;
    }

    if (err == 0) return FALSE;

    len = PINGBUFSIZE;
    err = _recvfrom(s, databuf, &len, fromaddr);
    if (err != NO_ERROR) {
        WARNFAIL(recvfrom); return FALSE;
    }

    rcvlen = len;
    return TRUE;
}


VOID
McastPing()
{
    SOCKET sock;
    struct sockaddr_in sockname;
    IcmpMessage* icmpmsg;
    struct in_addr mcastif;
    struct ip_mreq mcastreq;

    sock = socket(AF_INET, SOCK_RAW, IPPROTO_ICMP);
    if (sock == INVALID_SOCKET) {
        WARNFAIL(socket); return;
    }

    ZeroMem(&sockname, sizeof(sockname));
    sockname.sin_family = AF_INET;
    sockname.sin_port = 0;
    sockname.sin_addr.s_addr = INADDR_ANY;

    err = _bind(sock, &sockname);
    if (err != NO_ERROR) {
        WARNFAIL(bind); goto exit;
    }

    mcastif.s_addr = INADDR_ANY;
    err = setsockopt(sock, IPPROTO_IP, IP_MULTICAST_IF, (char*) &mcastif, sizeof(mcastif));
    if (err != NO_ERROR) {
        WARNFAIL(setmcastif); goto exit;
    }

    mcastreq.imr_multiaddr.s_addr = inet_addr(TESTADDR);
    mcastreq.imr_interface.s_addr = INADDR_ANY;
    err = setsockopt(sock, IPPROTO_IP, IP_ADD_MEMBERSHIP, (char*) &mcastreq, sizeof(mcastreq));
    if (err != NO_ERROR) {
        WARNFAIL(addmember); goto exit;
    }

    do {
        DbgPrint(".");
        if (testFlag == 2) {
            icmpmsg = (IcmpMessage*) databuf;
            icmpmsg->type = ICMPTYPE_ECHO_REQUEST;
            icmpmsg->code = 0;
            icmpmsg->id = id++;
            icmpmsg->seqno = seqno++;
            CopyMem(icmpmsg->origdata, pingdata, sizeof(pingdata));
            sockname.sin_addr.s_addr = inet_addr(TESTADDR);

            DbgPrint("Sending out ICMP echo request...\n");
            DbgPrint("  id = %d, seqno = %d\n", icmpmsg->id, icmpmsg->seqno);

            SendIcmpMessage(
                sock,
                &sockname,
                icmpmsg,
                ICMPHDRLEN + sizeof(pingdata));

            testFlag = 1;
        }

        if (RecvIcmpMessage(sock, &sockname)) {
            IpHeader* iphdr = (IpHeader*) databuf;
            INT iphdrlen, iplen;

            DbgPrint("Received ICMP message from %s:\n", inet_ntoa(sockname.sin_addr));

            if (rcvlen < IPHDRLEN ||
                (iphdrlen = GETIPHDRLEN(iphdr)) == 0 ||
                iphdrlen > rcvlen ||
                (iplen = GETIPLEN(iphdr)) > rcvlen ||
                iphdrlen > iplen) {
                DbgPrint("  Bad IP header!\n");
                continue;
            }

            rcvlen = iplen - iphdrlen;
            icmpmsg = (IcmpMessage*) &databuf[iphdrlen];
            
            if (rcvlen < ICMPHDRLEN ||
                tcpipxsum(0, icmpmsg, rcvlen) != 0xffff) {
                DbgPrint("  Bad ICMP header!\n");
            }
            
            DbgPrint("  type = %d, code = %d\n", icmpmsg->type, icmpmsg->code);
            DbgPrint("  id = %d, seqno = %d\n", icmpmsg->id, icmpmsg->seqno);
            DbgPrint("  %d bytes of data: %s\n", rcvlen - ICMPHDRLEN, icmpmsg->origdata);

            if (icmpmsg->type == ICMPTYPE_ECHO_REQUEST) {
                DbgPrint("Sending out ICMP echo reply...\n");
                icmpmsg->type = ICMPTYPE_ECHO_REPLY;
                SendIcmpMessage(sock, &sockname, icmpmsg, rcvlen);
            }
        }
    } while (testFlag > 0);

    err = setsockopt(sock, IPPROTO_IP, IP_DROP_MEMBERSHIP, (char*) &mcastreq, sizeof(mcastreq));
    if (err != NO_ERROR) {
        WARNFAIL(dropmember); goto exit;
    }

exit:
    closesocket(sock);
}


void __cdecl main()
{
    WSADATA wsadata;

    DbgPrint("Loading XBox network stack...\n");
    err = XnetInitialize(NULL, TRUE);
    if (err != NO_ERROR) {
        WARNFAIL(XnetInitialize); goto stop;
    }

    err = WSAStartup(WINSOCK_VERSION, &wsadata);
    if (err != NO_ERROR) {
        WARNFAIL(WSAStartup); goto unload;
    }

    DbgPrint("*** Test started, press 'g' to continue...\n");
    DbgPrint("*** To quit, press CTRL-C and type: ed %x 0;g\n", &testFlag);
    BREAK_INTO_DEBUGGER

    id = (WORD) (GetTickCount() >> 16);
    seqno = (WORD) (GetTickCount() & 0xffff);

    McastPing();
    WSACleanup();
    
unload:
    DbgPrint("Unloading XBox network stack...\n");
    XnetCleanup();

stop:
    if (testFlag == 0)
        HalReturnToFirmware(HalRebootRoutine);
    else
        Sleep(INFINITE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\test\tftp\tftp.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    tftp.c

Abstract:

    XBox TFTP client program

Revision History:

    06/30/2000 davidx
        Created it.

--*/

#include "precomp.h"
#include "tftp.h"

CHAR TftpRecvBuf[TFTP_PACKET_BUFSIZE];
CHAR TftpSendBuf[TFTP_PACKET_BUFSIZE];
DWORD TftpSendBufsize;
DWORD TftpRecvBufsize;

CHAR* TftpMode = "octet";
CHAR* TftpServerAddr = "157.56.10.165";
CHAR* SrcFilename = "c:\\temp\\data2";
CHAR* DstFilename = "c:\\temp\\test";
INT testFlag = 1;
INT err;
struct sockaddr_in sockname;

#define VERIFY(cond, _apiname) \
        if (!(cond)) { \
            DbgPrint(#_apiname " failed: %d %d\n", err, GetLastError()); \
            goto failed; \
        }

SOCKET
ConnectTftpServer()
{
    SOCKET sock = INVALID_SOCKET;

    sock = socket(AF_INET, SOCK_DGRAM, 0);
    VERIFY(sock != INVALID_SOCKET, socket);

    ZeroMem(&sockname, sizeof(sockname));
    sockname.sin_family = AF_INET;
    err = _bind(sock, &sockname);
    VERIFY(err == NO_ERROR, bind);

    err = _setrcvtimeout(sock, TFTP_RECV_TIMEOUT);
    VERIFY(err == NO_ERROR, setrcvtimeout);

    return sock;

failed:
    if (sock != INVALID_SOCKET) {
        closesocket(sock);
    }
    return INVALID_SOCKET;
}


//
// Send initial request to the server and wait for response
//
BOOL
SendRequestAndWait(
    SOCKET sock,
    UINT opcode,
    UINT blocknum
    )
{
    INT retries = TFTP_MAX_RETRIES;
    UINT buflen;

    ZeroMem(&sockname, sizeof(sockname));
    sockname.sin_family = AF_INET;
    
    while (TRUE) {
        if (retries-- == 0) {
            WARNING_("Server doesn't appear to be responding...");
            goto failed;
        }

        sockname.sin_port = htons(TFTP_SERVER_PORT);
        sockname.sin_addr.s_addr = inet_addr(TftpServerAddr);

        DbgPrint("Sending request to TFTP server: %s:%d\n",
                 inet_ntoa(sockname.sin_addr),
                 ntohs(sockname.sin_port));

        buflen = TftpSendBufsize;
        err = _sendto(sock, TftpSendBuf, &buflen, &sockname);
        VERIFY(err == NO_ERROR, sendto);

        TftpRecvBufsize = sizeof(TftpRecvBuf);
        if (_recvfrom(sock, TftpRecvBuf, &TftpRecvBufsize, &sockname) == NO_ERROR) {
            UINT op, blk, buflen = TftpRecvBufsize;
            CHAR* buf = TftpRecvBuf;

            GETUSHORTFIELD(op);
            GETUSHORTFIELD(blk);
            if (op == opcode && blocknum == blk) break;

            if (op == TFTPOP_ERROR) {
                WARNING_("Received ERROR packet: %d", blk);
                return FALSE;
            }
        }
    }

    DbgPrint("Connecting to TFTP server: %s:%d\n",
             inet_ntoa(sockname.sin_addr),
             ntohs(sockname.sin_port));

    err = _connect(sock, &sockname);
    VERIFY(err == NO_ERROR, connect);

    err = _getsockname(sock, &sockname);
    VERIFY(err == NO_ERROR, getsockname);

    DbgPrint("Local address: %s:%d\n",
             inet_ntoa(sockname.sin_addr),
             ntohs(sockname.sin_port));

    return TRUE;

failed:
    return FALSE;
}


//
// Send data to the server and wait for response
//
BOOL
SendAndWait(
    SOCKET sock,
    UINT opcode,
    UINT blocknum
    )
{
    INT retries = TFTP_MAX_RETRIES;
    UINT buflen;

    while (retries--) {
        buflen = TftpSendBufsize;
        err = _send(sock, TftpSendBuf, &buflen);
        VERIFY(err == NO_ERROR, send);

        TftpRecvBufsize = sizeof(TftpRecvBuf);
        if (_recv(sock, TftpRecvBuf, &TftpRecvBufsize) == NO_ERROR) {
            UINT op, blk, buflen = TftpRecvBufsize;
            CHAR* buf = TftpRecvBuf;

            GETUSHORTFIELD(op);
            GETUSHORTFIELD(blk);
            if (op == opcode && blocknum == blk) return TRUE;

            if (op == TFTPOP_ERROR) {
                WARNING_("Received ERROR packet: %d", blk);
                return FALSE;
            }
        }
    }
    SetLastError(ERROR_TIMEOUT);

failed:
    return FALSE;
}

//
// Send file to the TFTP server
//
VOID
PutTest()
{
    SeqFile* file;
    SOCKET sock = INVALID_SOCKET;
    CHAR* buf;
    DWORD buflen, timer, total = 0;
    UINT blocknum = 0;

    DbgPrint("Opening local file %s for reading...\n", SrcFilename);
    file = _CreateFile(SrcFilename, GENERIC_READ);
    VERIFY(file != NULL, CreateFile);

    timer = GetTickCount();

    sock = ConnectTftpServer();
    VERIFY(sock != INVALID_SOCKET, ConnectTftpServer);

    DbgPrint("Writing remote file %s...\n", DstFilename);

    buf = TftpSendBuf;
    ADDUSHORTFIELD(TFTPOP_WRQ);
    ADDSTRINGFIELD(DstFilename);
    ADDSTRINGFIELD(TftpMode);

    TftpSendBufsize = buf-TftpSendBuf;
    VERIFY(SendRequestAndWait(sock, TFTPOP_ACK, blocknum), WaitWRQAck);

    ASSERT(cfgSeqFileBufSize % TFTP_DATAPACKET_BLOCKSIZE == 0);

    do {
        //
        // Read a block of data from the file
        //
        buflen = TFTP_DATAPACKET_BLOCKSIZE;
        VERIFY(_ReadFile(file, &buf, &buflen), ReadFile);
        CopyMem(&TftpSendBuf[TFTP_DATAPACKET_HEADERSIZE], buf, buflen);

        //
        // Munge data packet header
        //
        blocknum++;
        buf = TftpSendBuf;
        ADDUSHORTFIELD(TFTPOP_DATA);
        ADDUSHORTFIELD(blocknum);

        TftpSendBufsize = TFTP_DATAPACKET_HEADERSIZE+buflen;
        VERIFY(SendAndWait(sock, TFTPOP_ACK, blocknum), WaitDataAck);

        total += buflen;
    } while (buflen == TFTP_DATAPACKET_BLOCKSIZE);

    timer = GetTickCount() - timer;
    if (timer == 0) timer = 1;
    DbgPrint("Total transfer: %d bytes in %d msecs\n", total, timer);
    DbgPrint("Transfer speed: %d bytes /sec\n", MulDiv(total, 1000, timer));

failed:
    _CloseFile(file);
    if (sock != INVALID_SOCKET) {
        closesocket(sock);
    }
}


//
// Retrieve file from the TFTP server
//
VOID
GetTest()
{
    SeqFile* file;
    SOCKET sock = INVALID_SOCKET;
    CHAR* buf;
    DWORD buflen, timer, total = 0;
    UINT blocknum = 1;

    DbgPrint("Opening local file %s for writing...\n", DstFilename);
    file = _CreateFile(DstFilename, GENERIC_WRITE);
    VERIFY(file != NULL, CreateFile);

    timer = GetTickCount();

    sock = ConnectTftpServer();
    VERIFY(sock != INVALID_SOCKET, ConnectTftpServer);

    DbgPrint("Reading remote file %s...\n", SrcFilename);

    buf = TftpSendBuf;
    ADDUSHORTFIELD(TFTPOP_RRQ);
    ADDSTRINGFIELD(SrcFilename);
    ADDSTRINGFIELD(TftpMode);

    TftpSendBufsize = buf-TftpSendBuf;
    VERIFY(SendRequestAndWait(sock, TFTPOP_DATA, blocknum), WaitRRQAck);

    ASSERT(cfgSeqFileBufSize % TFTP_DATAPACKET_BLOCKSIZE == 0);

    while (TRUE) {
        buf = &TftpRecvBuf[TFTP_DATAPACKET_HEADERSIZE];
        buflen = TftpRecvBufsize - TFTP_DATAPACKET_HEADERSIZE;
        if (buflen > 0) {
            total += buflen;
            VERIFY(_WriteFile(file, buf, buflen), WriteFile);
        }

        // Prepare ACK packet
        buf = TftpSendBuf;
        ADDUSHORTFIELD(TFTPOP_ACK);
        ADDUSHORTFIELD(blocknum);
        TftpSendBufsize = buf-TftpSendBuf;

        if (buflen != TFTP_DATAPACKET_BLOCKSIZE) {
            VERIFY(_send(sock, TftpSendBuf, &TftpSendBufsize) == NO_ERROR, send);
            break;
        }

        blocknum++;
        VERIFY(SendAndWait(sock, TFTPOP_DATA, blocknum), WaitData);
    }

    timer = GetTickCount() - timer;
    if (timer == 0) timer = 1;
    DbgPrint("Total transfer: %d bytes in %d msecs\n", total, timer);
    DbgPrint("Transfer speed: %d bytes /sec\n", MulDiv(total, 1000, timer));

failed:
    _CloseFile(file);
    if (sock != INVALID_SOCKET) {
        closesocket(sock);
    }
}


#define BREAK_INTO_DEBUGGER __asm int 3

void __cdecl main()
{
    WSADATA wsadata;

    DbgPrint("Loading XBox network stack...\n");
    err = XnetInitialize(NULL, TRUE);
    if (err != NO_ERROR) {
        WARNFAIL(XnetInitialize); goto stop;
    }

    err = WSAStartup(WINSOCK_VERSION, &wsadata);
    if (err != NO_ERROR) {
        WARNFAIL(WSAStartup); goto unload;
    }

    DbgPrint("*** Test started, press 'g' to continue...\n");

    while (TRUE) {
        DbgPrint("*** To quit, press CTRL-C and type: ed %x 0;g\n", &testFlag);
        BREAK_INTO_DEBUGGER

        if (testFlag <= 0) break;
        if (testFlag == 1) {
            PutTest();
        } else {
            GetTest();
        }
    }
    WSACleanup();

unload:
    DbgPrint("Unloading XBox network stack...\n");
    XnetCleanup();

stop:
    if (testFlag == 0)
        HalReturnToFirmware(HalRebootRoutine);
    else
        Sleep(INFINITE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\test\lib\seqfile.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    seqfile.c

Abstract:

    Sequential file I/O functions

Revision History:

    08/07/2000 davidx
        Created it.

--*/

#include "precomp.h"

//
// File buffer size (must be a multiple of 512, default = 4KB)
//
UINT cfgSeqFileBufSize = 4*1024;

//
// Sequential file object
//
typedef struct _SeqFile {
    HANDLE handle;
    DWORD accessMode;
    UINT writeTotal;
    UINT bufsize;
    UINT bufptr;
    CHAR* buf;
} SeqFile;

//
// Forward function declarations
//
PRIVATE BOOL WriteDataToDisk(SeqFile* file);
PRIVATE BOOL FixupFileSize(SeqFile* file);


SeqFile*
_CreateFile(
    const CHAR* filename,
    DWORD accessMode
    )

/*++

Routine Description:

    Open a file for sequential read or write access

Arguments:

    filename - Specifies the filename
    accessMode - Access mode: GENERIC_READ or GENERIC_WRITE

Return Value:

    Pointer to the open file object
    NULL if there is an error

--*/

{
    SeqFile* file;
    OBJECT_STRING str;
    CHAR filenamebuf[MAX_PATH];
    const CHAR* prefix;
    CHAR* p;
    INT prefixlen, filenamelen;
    HANDLE handle;
    IO_STATUS_BLOCK iostatusBlock;
    OBJECT_ATTRIBUTES objAttrs;
    NTSTATUS status;

    ASSERT(filename != NULL);
    ASSERT(accessMode == GENERIC_READ || accessMode == GENERIC_WRITE);

    // HACK: munge the input filename:
    //  convert from ASCII to unicode
    //  map drive letters to prefix strings

    filenamelen = strlen(filename);
    if (filenamelen >= 3 && filename[1] == ':' && filename[2] == '\\') {
        if (filename[0] == 'c' || filename[0] == 'C') {
            filename += 3;
            filenamelen -= 3;
            prefix = "\\Device\\Harddisk0\\Partition1\\";
        } else {
            prefix = "\\??\\";
        }
    } else {
        prefix = "";
    }

    prefixlen = strlen(prefix);
    if (filenamelen == 0 || (filenamelen += prefixlen) >= MAX_PATH) {
        SetLastError(ERROR_INVALID_NAME);
        return NULL;
    }

    p = filenamebuf;
    CopyMem(p, prefix, prefixlen);

    p += prefixlen;
    strcpy(p, filename);

    // Prepare parameters to call NtCreateFile

    str.Buffer = filenamebuf;
    str.Length = (USHORT) filenamelen;
    str.MaximumLength = str.Length + 1;
    InitializeObjectAttributes(&objAttrs, &str, OBJ_CASE_INSENSITIVE, NULL, NULL);

    // Allocate memory for the file object

    file = MAlloc0(sizeof(SeqFile));
    if (!file) return NULL;
    file->handle = INVALID_HANDLE_VALUE;
    file->accessMode = accessMode;

    file->buf = VirtualAlloc(NULL, cfgSeqFileBufSize, MEM_COMMIT|MEM_RESERVE, PAGE_READWRITE);
    if (!file->buf) {
        Free(file);
        return NULL;
    }

    // Open the file
    //  Notice that we always set the "no buffering" flag

    status = NtCreateFile(
               &file->handle,
               accessMode|SYNCHRONIZE|FILE_READ_ATTRIBUTES,
               &objAttrs,
               &iostatusBlock,
               NULL,
               FILE_ATTRIBUTE_NORMAL,
               (accessMode == GENERIC_READ) ? FILE_SHARE_READ : 0,
               (accessMode == GENERIC_READ) ? FILE_OPEN : FILE_OVERWRITE_IF,
               FILE_SYNCHRONOUS_IO_NONALERT |
                   FILE_SEQUENTIAL_ONLY |
                   FILE_NO_INTERMEDIATE_BUFFERING);

    if (!NT_SUCCESS(status)) {
        WARNING_("NtCreateFile failed: 0x%x", status);
        SetLastError(RtlNtStatusToDosError(status));
        _CloseFile(file);
        return NULL;
    }

    return file;
}


VOID
_CloseFile(
    SeqFile* file
    )

/*++

Routine Description:

    Close a file object returned by _CreateFile

Arguments:

    file - Points to the file object to be closed

Return Value:

    NONE

--*/

{
    if (!file) return;

    //
    // If the file was opened for writing, we to update
    // the correct file size before closing the file.
    //
    if (file->accessMode == GENERIC_WRITE) {
        FixupFileSize(file);
    }

    //
    // Close the file handle and
    // dispose of the file object
    //
    if (file->handle != INVALID_HANDLE_VALUE) {
        NTSTATUS status = NtClose(file->handle);
        if (!NT_SUCCESS(status)) {
            WARNING_("NtClose failed: 0x%x", status);
        }
    }

    if (file->buf && !VirtualFree(file->buf, 0, MEM_RELEASE)) {
        WARNING_("VirtualFree failed: %d", GetLastError());
    }
    Free(file);
}


BOOL
_ReadFile(
    SeqFile* file,
    CHAR** buf,
    UINT* buflen
    )

/*++

Routine Description:

    Read data from a file

Arguments:

    file - Points to the file object
    buf - Returns a pointer to the buffered data
    buflen - On input, contain the maximum buffer size;
        On exit, contain the actual number of bytes read

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    ASSERT(file != NULL && file->accessMode == GENERIC_READ);

    //
    // Check if we still have data left in our internal buffer
    // If not, read more data from the disk into our buffer
    //
    if (file->bufptr == file->bufsize) {
        NTSTATUS status;
        IO_STATUS_BLOCK iostatusBlock;

        file->bufptr = file->bufsize = 0;
        status = NtReadFile(
                    file->handle,
                    NULL,
                    NULL,
                    NULL,
                    &iostatusBlock,
                    file->buf,
                    cfgSeqFileBufSize,
                    NULL);

        if (status == STATUS_PENDING) {
            status = NtWaitForSingleObject(file->handle, FALSE, NULL);
            if (NT_SUCCESS(status))
                status = iostatusBlock.Status;
        }

        if (NT_SUCCESS(status)) {
            file->bufsize = iostatusBlock.Information;
        } else if (status != STATUS_END_OF_FILE) {
            WARNING_("NtReadFile failed: 0x%x", status);
            SetLastError(RtlNtStatusToDosError(status));
            return FALSE;
        }
    }

    //
    // Copy data from our internal buffer to
    // the caller-supplied output buffer
    //
    if (*buflen > file->bufsize - file->bufptr)
        *buflen = file->bufsize - file->bufptr;

    *buf = file->buf + file->bufptr;
    file->bufptr += *buflen;
    return TRUE;
}


BOOL
_WriteFile(
    SeqFile* file,
    const VOID* buf,
    UINT buflen
    )

/*++

Routine Description:

    Write data to a file

Arguments:

    file - Points to the file object
    buf - Points to the data buffer
    buflen - Specifies the buffer size

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    const CHAR* srcbuf = (const CHAR*) buf;
    ASSERT(file != NULL && file->accessMode == GENERIC_WRITE);

    while (buflen) {
        UINT count;

        // Copy data from the caller's buffer to our internal buffer
        count = min(cfgSeqFileBufSize - file->bufptr, buflen);
        CopyMem(file->buf + file->bufptr, srcbuf, count);
        srcbuf += count;
        file->bufptr += count;
        file->writeTotal += count;

        // If our buffer is full, write data out to the disk
        if (file->bufptr == cfgSeqFileBufSize && !WriteDataToDisk(file))
            return FALSE;

        buflen -= count;
    }

    return TRUE;
}


PRIVATE BOOL
FixupFileSize(
    SeqFile* file
    )

/*++

Routine Description:

    Fix up the correct file size information. This is called
    when a file that was opened for write is closed.

Arguments:

    file - Points to the file object

Return Value:

    TRUE if successful, FALSE otherwise

--*/

{
    NTSTATUS status;
    IO_STATUS_BLOCK iostatusBlock;
    FILE_END_OF_FILE_INFORMATION endOfFile;
    FILE_ALLOCATION_INFORMATION allocation;

    ASSERT(file->accessMode == GENERIC_WRITE);
    if (file->bufptr == 0) return TRUE;

    //
    // Write the last unfinished sector to disk
    //
    if (!WriteDataToDisk(file)) return FALSE;

    //
    // Set the end-of-file pointer
    //
    endOfFile.EndOfFile.QuadPart = file->writeTotal;
    status = NtSetInformationFile(
                file->handle,
                &iostatusBlock,
                &endOfFile,
                sizeof(endOfFile),
                FileEndOfFileInformation);

    if (NT_SUCCESS(status)) {
        //
        // Set the allocation based on the file size
        //
        allocation.AllocationSize.QuadPart = file->writeTotal;
        status = NtSetInformationFile(
                    file->handle,
                    &iostatusBlock,
                    &allocation,
                    sizeof(allocation),
                    FileAllocationInformation);
    }

    if (!NT_SUCCESS(status)) {
        WARNING_("Failed to set file size: 0x%x", status);
        SetLastError(RtlNtStatusToDosError(status));
        return FALSE;
    }

    return TRUE;
}


PRIVATE BOOL
WriteDataToDisk(
    SeqFile* file
    )

/*++

Routine Description:

    Write data from the file buffer to the disk

Arguments:

    file - Points to the file object

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    NTSTATUS status;
    IO_STATUS_BLOCK iostatusBlock;
    UINT count;

    // Always write in 512-byte blocks
    count = (file->bufptr + 511) & ~511;
    file->bufptr = 0;

    status = NtWriteFile(
                file->handle,
                NULL,
                NULL,
                NULL,
                &iostatusBlock,
                file->buf,
                count,
                NULL);

    if (status == STATUS_PENDING) {
        status = NtWaitForSingleObject(file->handle, FALSE, NULL);
        if (NT_SUCCESS(status))
            status = iostatusBlock.Status;
    }

    if (NT_SUCCESS(status) && count == iostatusBlock.Information)
        return TRUE;

    WARNING_("NtWriteFile failed: 0x%x", status);
    SetLastError(RtlNtStatusToDosError(status));
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\test\udptest\udptest.cpp ===
#include <xtl.h>
#include <xdbg.h>

#define TESTPORT 6000
#define SENDCOUNT 1024
#define BUFSIZE 4

#define SERVERADDR "157.56.11.44"
//#define SERVERADDR "157.56.10.166"

volatile INT testFlag = 1;
INT err;
SOCKET s;
static union {
    CHAR buf[BUFSIZE];
    UINT seqno;
};
static union {
    struct sockaddr sockname;
    struct sockaddr_in sockin;
};

VOID UdpSendTest()
{
    LARGE_INTEGER counter0, counter1, freq;
    BOOL ok;

    s = socket(AF_INET, SOCK_DGRAM, 0);
    ASSERT(s != INVALID_SOCKET);

    memset(&sockname, 0, sizeof(sockname));
    sockin.sin_family = AF_INET;
    sockin.sin_port = htons(TESTPORT);
    err = bind(s, &sockname, sizeof(sockname));
    ASSERT(err == NO_ERROR);

    sockin.sin_addr.s_addr = inet_addr(SERVERADDR);
    err = connect(s, &sockname, sizeof(sockname));
    ASSERT(err == NO_ERROR);

    DWORD tick = GetTickCount();

    for (seqno=0; seqno < SENDCOUNT; seqno++) {
        err = send(s, buf, BUFSIZE, 0);
        ASSERT(err == BUFSIZE);
    }

    tick = GetTickCount() - tick;
    DbgPrint("%d packets sent in %d msecs\n", SENDCOUNT, tick);
    Sleep(2000);
    closesocket(s);
}

VOID UdpRecvTest()
{
    s = socket(AF_INET, SOCK_DGRAM, 0);
    ASSERT(s != INVALID_SOCKET);

    memset(&sockname, 0, sizeof(sockname));
    sockin.sin_family = AF_INET;
    sockin.sin_port = htons(TESTPORT);
    err = bind(s, &sockname, sizeof(sockname));
    ASSERT(err == NO_ERROR);

    INT timeout = 2000;
    err = setsockopt(s, SOL_SOCKET, SO_RCVTIMEO, (CHAR*) &timeout, sizeof(timeout));
    ASSERT(err == NO_ERROR);

    DbgPrint("Listening on UDP port %d...\n", TESTPORT);

    INT count = 0;
    while (TRUE) {
        err = recv(s, buf, BUFSIZE, 0);
        if (err == SOCKET_ERROR) {
            ASSERT(WSAGetLastError() == WSAETIMEDOUT);
            if (count) break;
        } else {
            count++;
        }
    }

    closesocket(s);
    DbgPrint("%d packets received\n", count);
}

VOID __cdecl main()
{
    DbgPrint("Loading XBox network stack...\n");
    err = XnetInitialize(NULL, TRUE);
    ASSERT(err == NO_ERROR);

    WSADATA wsadata;
    err = WSAStartup(WINSOCK_VERSION, &wsadata);
    ASSERT(err == NO_ERROR);

    while (TRUE) {
        DbgPrint("*** To quit, type: ed %x 0;g\n", &testFlag);
        __asm int 3
        if (testFlag == 0) break;
        if (testFlag == 1)
            UdpSendTest();
        else
            UdpRecvTest();
    }

    DbgPrint("Unloading XBox network stack...\n");
    WSACleanup();
    XnetCleanup();

    DbgPrint("Test finished.\n");
    Sleep(INFINITE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\winsock\connect.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    connect.c

Abstract:

    Implementation of connection related Winsock APIs:
        bind
        connect
        listen
        accept
        getsockname
        getpeername

Revision History:

    06/02/2000 davidx
        Created it.

--*/

#include "precomp.h"


int WSAAPI
bind(
    SOCKET s,                          
    const struct sockaddr* name,   
    int namelen                        
    )

/*++

Routine Description:

    Refer to XAPI SDK documentation.

--*/

{
    const struct sockaddr_in* sin = (const struct sockaddr_in*) name;
    WinsockApiPrologSockLock_(bind, SOCKET_ERROR);

    WinsockApiParamCheck_(
        name != NULL &&
        namelen >= SOCKADDRLEN &&
        sin->sin_family == AF_INET &&
        !IS_BCAST_IPADDR(sin->sin_addr.s_addr) &&
        !IS_MCAST_IPADDR(sin->sin_addr.s_addr));

    if (IsPcbBound(pcb)) {
        WinsockApiGotoExit_(WSAEINVAL);
    }

    err = PcbBind(pcb, sin->sin_addr.s_addr, sin->sin_port);
    MapNtStatusToWinsockError_(err);

    WinsockApiExitSockUnlock_(NO_ERROR, SOCKET_ERROR);
}


int WSAAPI
connect(
    SOCKET s,                          
    const struct sockaddr* name,  
    int namelen                        
    )

/*++

Routine Description:

    Refer to XAPI SDK documentation.

--*/

{
    const struct sockaddr_in* sin = (const struct sockaddr_in*) name;
    IPADDR dstaddr;
    IPPORT dstport;
    WinsockApiPrologSockLock_(connect, SOCKET_ERROR);

    WinsockApiParamCheck_(
        name != NULL &&
        namelen >= SOCKADDRLEN &&
        sin->sin_family == AF_INET);

    if (IsPcbConnected(pcb) && IsTcb(pcb)) {
        WinsockApiGotoExit_(WSAEISCONN);
    }

    dstaddr = sin->sin_addr.s_addr;
    dstport = sin->sin_port;
    if (IsDgramPcb(pcb)) {
        err = PcbConnectDgram(pcb, dstaddr, dstport);
    } else if (pcb->nonblocking) {
        err = TcbConnect((TCB*) pcb, dstaddr, dstport, FALSE);

        // For nonblocking socket, we'll return WSAEWOULDBLOCK
        // error code but the operation proceeds.
        if (NT_SUCCESS(err)) err = NETERR_WOULDBLOCK;
    } else {
        err = TcbConnect((TCB*) pcb, dstaddr, dstport, FALSE);
        if (NT_SUCCESS(err)) {
            // For blocking socket, we need to wait here for
            // the operation to complete.
            err = PcbWaitForEvent(pcb, PCBEVENT_CONNECT, 0);
            pcb->connectSelected = 1;
        }
    }

    MapNtStatusToWinsockError_(err);

    WinsockApiExitSockUnlock_(NO_ERROR, SOCKET_ERROR);
}


int WSAAPI
listen(
    SOCKET s,    
    int backlog  
    )

/*++

Routine Description:

    Refer to XAPI SDK documentation.

--*/

{
    WinsockApiPrologSockLock_(listen, SOCKET_ERROR);

    WinsockApiParamCheck_(IsTcb(pcb));

    if (IsPcbConnected(pcb)) {
        WinsockApiGotoExit_(WSAEISCONN);
    }

    if (!IsPcbBound(pcb)) {
        WinsockApiGotoExit_(WSAEINVAL);
    }

    err = TcbListen((TCB*) pcb, backlog);
    MapNtStatusToWinsockError_(err);

    WinsockApiExitSockUnlock_(NO_ERROR, SOCKET_ERROR);
}


SOCKET WSAAPI
accept(
    SOCKET s, 
    struct sockaddr* addr,  
    int* addrlen  
    )

/*++

Routine Description:

    Refer to XAPI SDK documentation.

--*/

{
    TCB* tcb;
    TCB* newtcb = NULL;
    WinsockApiPrologSockLock_(accept, INVALID_SOCKET);

    WinsockApiParamCheck_(
        IsTcb(pcb) &&
        (addr == NULL ||
         addrlen != NULL && *addrlen >= SOCKADDRLEN));

    if (!IsTcpListenState(pcb)) {
        WinsockApiGotoExit_(WSAEINVAL);
    }

    // Check if we have any pending connection requests
    tcb = (TCB*) pcb;
    if (!TcbHasPendingConnReq(tcb)) {
        // For nonblocking socket, return an error code
        // if we don't have any pending connection requests.
        if (tcb->nonblocking) {
            WinsockApiGotoExit_(WSAEWOULDBLOCK);
        }

        // For blocking sockets, wait until there
        // is a connection request.
        err = PcbWaitForEvent(pcb, PCBEVENT_ACCEPT, 0);
    }

    err = TcbAccept(tcb, &newtcb);
    MapNtStatusToWinsockError_(err);

    if (newtcb && addr && addrlen) {
        struct sockaddr_in* sin;

        sin = (struct sockaddr_in*) addr;
        sin->sin_family = AF_INET;
        sin->sin_port = newtcb->dstport;
        sin->sin_addr.s_addr = newtcb->dstaddr;
        ZeroMem(sin->sin_zero, sizeof(sin->sin_zero));
        *addrlen = SOCKADDRLEN;
    }

    WinsockApiExitSockUnlock_((SOCKET) newtcb, INVALID_SOCKET);
}


int WSAAPI
getsockname(
    SOCKET s,                    
    struct sockaddr* name,  
    int* namelen            
    )

/*++

Routine Description:

    Refer to XAPI SDK documentation.

--*/

{
    struct sockaddr_in* sin;
    WinsockApiPrologSockLock_(getsockname, SOCKET_ERROR);

    WinsockApiParamCheck_(
        name != NULL &&
        namelen != NULL &&
        *namelen >= SOCKADDRLEN);

    if (!IsPcbBound(pcb)) {
        WinsockApiGotoExit_(WSAEINVAL);
    }

    sin = (struct sockaddr_in*) name;
    ZeroMem(sin, SOCKADDRLEN);
    sin->sin_family = AF_INET;
    sin->sin_port = pcb->srcport;
    sin->sin_addr.s_addr = pcb->srcaddr;

    *namelen = SOCKADDRLEN;
    err = NO_ERROR;

    WinsockApiExitSockUnlock_(NO_ERROR, SOCKET_ERROR);
}


int WSAAPI
getpeername(
    SOCKET s,                    
    struct sockaddr* name,  
    int* namelen            
    )

/*++

Routine Description:

    Refer to XAPI SDK documentation.

--*/

{
    struct sockaddr_in* sin;
    WinsockApiPrologSockLock_(getpeername, SOCKET_ERROR);

    WinsockApiParamCheck_(
        name != NULL &&
        namelen != NULL &&
        *namelen >= SOCKADDRLEN);

    if (!IsPcbConnected(pcb)) {
        WinsockApiGotoExit_(WSAENOTCONN);
    }

    sin = (struct sockaddr_in*) name;
    sin->sin_family = AF_INET;
    sin->sin_port = pcb->dstport;
    sin->sin_addr.s_addr = pcb->dstaddr;
    ZeroMem(sin->sin_zero, sizeof(sin->sin_zero));

    *namelen = SOCKADDRLEN;
    err = NO_ERROR;

    WinsockApiExitSockUnlock_(NO_ERROR, SOCKET_ERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\winsock\precomp.h ===
#define WINSOCK_API_LINKAGE

#ifdef BUILD_FOR_DEBUGGER
#define _KERNEL32_
#define _USER32_
#define _XAPI_
#include "ntos.h"
#include "dm.h"
#endif

#include "xnetp.h"

#include "pcb.h"
#include "xdbg.h"
#include "sockp.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\winsock\recv.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    recv.c

Abstract:

    Implementation of data reception related Winsock APIs:
        recv
        recvfrom
        WSARecv
        WSARecvFrom

Revision History:

    06/02/2000 davidx
        Created it.

--*/

#include "precomp.h"

// Disable unreference label warning
#pragma warning(disable:4102)


PRIVATE NTSTATUS
SockRecv(
    PCB* pcb,
    RECVREQ* recvreq
    )

/*++

Routine Description:

    Internal function for receiving data from a socket

Arguments:

    pcb - Points to the protocol control block
    recvreq - Describes the receive user request

Return Value:

    Status code

--*/

{
    NTSTATUS status;
    WSAOVERLAPPED* overlapped;
    WSAOVERLAPPED overlappedTemp;

    if (IsTcb(pcb)) {
        if (!IsPcbConnected(pcb)) {
            return NETERR(WSAENOTCONN);
        }
    } else {
        if (!IsPcbBound(pcb)) {
            return NETERR(WSAEINVAL);
        }
    }

    if (IsPcbRecvShutdown(pcb)) {
        return !NT_SUCCESS(PcbGetErrStatus(pcb)) ?
                    PcbGetErrStatus(pcb) :
                    NETERR(WSAESHUTDOWN);
    }

    // Since all our sockets are overlapped, we don't
    // enforce the Win32 behavior that the input socket
    // must be a non-overlapped socket.

    if ((overlapped = recvreq->overlapped) != NULL) {
        recvreq->overlappedEvent = GetKernelEventObject(overlapped->hEvent);
        if (!recvreq->overlappedEvent)
            return NETERR(WSASYSCALLFAILURE);
    } else
        recvreq->overlappedEvent = NULL;

    // Check if we have any buffered data waiting to be read
    if (IsPcbRecvBufEmpty(pcb)) {
        if (overlapped) {
            // Overlapped call
            KeClearEvent(recvreq->overlappedEvent);
        } else if (pcb->nonblocking) {
            // Nonoverlapped call and socket is nonblocking:
            // just return WOULDBLOCK error code.
            //
            // Note: For TCP socket, if FIN has been received
            // we should return success with bytesRecv set to 0.
            if (IsDgramPcb(pcb) || !IsFINReceived(pcb))
                return NETERR(WSAEWOULDBLOCK);
        } else {
            // Blocking call - prepare to wait
            recvreq->overlapped = &overlappedTemp;
            recvreq->overlappedEvent = GetPcbWaitEvent(pcb);
            KeClearEvent(recvreq->overlappedEvent);
        }
    }

    status = IsDgramPcb(pcb) ?
                PcbRecvDgram(pcb, recvreq) :
                TcbRecv((TCB*) pcb, recvreq);

    if (status == NETERR_PENDING) {
        if (!overlapped) {
            // A blocking call is still in progress
            WaitKernelEventObject(recvreq->overlappedEvent, pcb->recvTimeout);

            if (overlappedTemp._iostatus == NETERR_PENDING) {
                KIRQL irql = RaiseToDpc();
                if (overlappedTemp._iostatus == NETERR_PENDING) {
                    // We can use recvreq directly here because
                    // blocking recv call is treated as a special case
                    // in PcbQueueOverlappedRecv (in tcp\pcb.c).
                    PcbCompleteOverlappedRecv(recvreq, NETERR_TIMEOUT);
                }
                LowerFromDpc(irql);
            }

            *recvreq->bytesRecv = overlappedTemp._ioxfercnt;
            recvreq->flags = overlappedTemp._ioflags;
            status = overlappedTemp._iostatus;
        }
    } else {
        if (overlapped) {
            // An overlapped call was completed immediately
            overlapped->_ioflags = recvreq->flags;
            overlapped->_ioxfercnt = *recvreq->bytesRecv;
            overlapped->_iostatus = status;

            // It would seem to be a waste to signal the event here.
            // But that's win2k behavior.
            KeSetEvent(recvreq->overlappedEvent, 0, FALSE);
            ObDereferenceObject(recvreq->overlappedEvent);
        }
    }

    return status;
}


int WSAAPI
recv(
    SOCKET s,       
    char* buf,  
    int len,        
    int flags       
    )

/*++

Routine Description:

    Refer to XAPI SDK documentation.

--*/

{
    RECVREQ recvreq;
    DWORD count;
    WinsockApiPrologSockLock_(recv, SOCKET_ERROR);

    WinsockApiParamCheck_(
        (len > 0 && buf != NULL || len == 0) &&
        flags == 0);

    recvreq.buf = (BYTE*) buf;
    recvreq.buflen = len;
    recvreq.flags = flags;
    recvreq.bytesRecv = &count;
    recvreq.fromaddr = NULL;
    recvreq.overlapped = NULL;

    err = SockRecv(pcb, &recvreq);
    MapNtStatusToWinsockError_(err);
    WinsockApiExitSockUnlock_(count, SOCKET_ERROR);
}


//
// Verify buffers passed to WSARecv API
// NOTE: we do not support more than 1 receive buffers.
//
INLINE BOOL CheckRecvWsaBuf(WSABUF* bufs, UINT bufcnt) {
    return (bufcnt == 1 &&
            bufs != NULL &&
            (bufs->len > 0 && bufs->buf != NULL || bufs->len == 0));
}


int WSAAPI
WSARecv(
    SOCKET s,                                               
    LPWSABUF bufs,                                     
    DWORD bufcnt,                                    
    LPDWORD bytesRecv,                           
    LPDWORD flags,                                        
    LPWSAOVERLAPPED overlapped,                           
    LPWSAOVERLAPPED_COMPLETION_ROUTINE completionproc  
    )

/*++

Routine Description:

    Refer to XAPI SDK documentation.

--*/

{
    RECVREQ recvreq;
    WinsockApiPrologSockLock_(WSARecv, SOCKET_ERROR);

    WinsockApiParamCheck_(
        CheckRecvWsaBuf(bufs, bufcnt) &&
        bytesRecv != NULL &&
        flags != NULL && *flags == 0 &&
        completionproc == NULL);

    recvreq.buf = (BYTE*) bufs->buf;
    recvreq.buflen = bufs->len;
    recvreq.flags = *flags;
    recvreq.bytesRecv = bytesRecv;
    recvreq.fromaddr = NULL;
    recvreq.overlapped = overlapped;

    err = SockRecv(pcb, &recvreq);
    *flags = recvreq.flags;
    MapNtStatusToWinsockError_(err);
    WinsockApiExitSockUnlock_(NO_ERROR, SOCKET_ERROR);
}


int WSAAPI
recvfrom(
    SOCKET s,                   
    char FAR* buf,              
    int len,                    
    int flags,                  
    struct sockaddr* from,  
    int* fromlen            
    )

/*++

Routine Description:

    Refer to XAPI SDK documentation.

--*/

{
    DWORD count;
    INT err;
    WSABUF wsabuf;

    WinsockApiPrologLight_(recvfrom);
    WinsockApiParamCheck_(
        (len > 0 && buf != NULL || len == 0) &&
        (from == NULL ||
         fromlen != NULL && *fromlen >= SOCKADDRLEN));

    wsabuf.len = len;
    wsabuf.buf = buf;
    err = WSARecvFrom(s, &wsabuf, 1, &count, (DWORD*) &flags, from, fromlen, NULL, NULL);
    return (err == NO_ERROR) ? count : SOCKET_ERROR;
}


int WSAAPI
WSARecvFrom(
    SOCKET s,
    LPWSABUF bufs,
    DWORD bufcnt,
    LPDWORD bytesRecv,
    LPDWORD flags,
    struct sockaddr* fromaddr,
    LPINT fromlen,                                        
    LPWSAOVERLAPPED overlapped,                           
    LPWSAOVERLAPPED_COMPLETION_ROUTINE completionproc  
    )

/*++

Routine Description:

    Refer to XAPI SDK documentation.

--*/

{
    RECVREQ recvreq;
    WinsockApiPrologSockLock_(WSARecvFrom, SOCKET_ERROR);

    WinsockApiParamCheck_(
        CheckRecvWsaBuf(bufs, bufcnt) &&
        bytesRecv != NULL &&
        (fromaddr == NULL ||
         fromlen != NULL && *fromlen >= SOCKADDRLEN) &&
        flags != NULL && *flags == 0 &&
        completionproc == NULL);

    // Winsock documentation on this call is extremely confusing
    // regarding the correct behavior for connection-oriented sockets
    // Here I've taken the liberty to treat WSARecvFrom the same way
    // as WSARecv for such cases.
    if (IsTcb(pcb)) {
        VERBOSE_("WSARecvFrom called on stream socket!");
    }

    recvreq.buf = (BYTE*) bufs->buf;
    recvreq.buflen = bufs->len;
    recvreq.flags = *flags;
    recvreq.bytesRecv = bytesRecv;
    recvreq.overlapped = overlapped;
    recvreq.fromaddr = (struct sockaddr_in*) fromaddr;

    if (fromaddr) {
        ZeroMem(fromaddr, SOCKADDRLEN);
        *fromlen = SOCKADDRLEN;
        recvreq.fromaddr->sin_family = AF_INET;
    }

    err = SockRecv(pcb, &recvreq);
    *flags = recvreq.flags;
    MapNtStatusToWinsockError_(err);
    WinsockApiExitSockUnlock_(NO_ERROR, SOCKET_ERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\winsock\enumprot.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    enumprot.c

Abstract:

    Implement the Winsock WSAEnumProtocols API

Revision History:

    06/01/2000 davidx
        Created it.

--*/

#include "precomp.h"


//
// Hard-coded TCP/IP protocol information
//
#define NUM_TCPIP_PROTOCOLS 3
#define MAX_UDP_MSGSIZE (MAXIPLEN-MAXIPHDRLEN-UDPHDRLEN)

const WSAPROTOCOL_INFOW TcpIpProtocols[NUM_TCPIP_PROTOCOLS] = {
    //
    // TCP
    //
    {
        XP1_GUARANTEED_DELIVERY     // dwServiceFlags1
            | XP1_GUARANTEED_ORDER
            | XP1_GRACEFUL_CLOSE,
        0,                          // dwServiceFlags2
        0,                          // dwServiceFlags3
        0,                          // dwServiceFlags4
        PFL_MATCHES_PROTOCOL_ZERO,  // dwProviderFlags
        {                           // ProviderId
            0xe70f1aa0,
            0xab8b,
            0x11cf,
            { 0x8c, 0xa3, 0x00, 0x80, 0x5f, 0x48, 0xa1, 0x92 }
        },
        1001,                       // dwCatalogEntryId
        { BASE_PROTOCOL, },         // ProtocolChain
        2,                          // iVersion
        AF_INET,                    // iAddressFamily
        SOCKADDRLEN,                // iMaxSockAddr
        SOCKADDRLEN,                // iMinSockAddr
        SOCK_STREAM,                // iSocketType
        IPPROTO_TCP,                // iProtocol
        0,                          // iProtocolMaxOffset
        BIGENDIAN,                  // iNetworkByteOrder
        SECURITY_PROTOCOL_NONE,     // iSecurityScheme
        0,                          // dwMessageSize
        0,                          // dwProviderReserved
        L"MSAFD Tcpip [TCP/IP]"     // szProtocol
    },

    //
    // UDP
    //
    {
        XP1_CONNECTIONLESS          // dwServiceFlags1
            | XP1_MESSAGE_ORIENTED
            | XP1_SUPPORT_BROADCAST,
        0,                          // dwServiceFlags2
        0,                          // dwServiceFlags3
        0,                          // dwServiceFlags4
        PFL_MATCHES_PROTOCOL_ZERO,  // dwProviderFlags
        {                           // ProviderId
            0xe70f1aa0,
            0xab8b,
            0x11cf,
            { 0x8c, 0xa3, 0x00, 0x80, 0x5f, 0x48, 0xa1, 0x92 }
        },
        1002,                       // dwCatalogEntryId
        { BASE_PROTOCOL, },         // ProtocolChain
        2,                          // iVersion
        AF_INET,                    // iAddressFamily
        SOCKADDRLEN,                // iMaxSockAddr
        SOCKADDRLEN,                // iMinSockAddr
        SOCK_DGRAM,                 // iSocketType
        IPPROTO_UDP,                // iProtocol
        0,                          // iProtocolMaxOffset
        BIGENDIAN,                  // iNetworkByteOrder
        SECURITY_PROTOCOL_NONE,     // iSecurityScheme
        MAX_UDP_MSGSIZE,            // dwMessageSize
        0,                          // dwProviderReserved
        L"MSAFD Tcpip [UDP/IP]"     // szProtocol
    },

    //
    // Raw IP
    //
    {
        XP1_CONNECTIONLESS          // dwServiceFlags1
            | XP1_MESSAGE_ORIENTED
            | XP1_SUPPORT_BROADCAST,
        0,                          // dwServiceFlags2
        0,                          // dwServiceFlags3
        0,                          // dwServiceFlags4
        PFL_MATCHES_PROTOCOL_ZERO,  // dwProviderFlags
        {                           // ProviderId
            0xe70f1aa0,
            0xab8b,
            0x11cf,
            { 0x8c, 0xa3, 0x00, 0x80, 0x5f, 0x48, 0xa1, 0x92 }
        },
        1003,                       // dwCatalogEntryId
        { BASE_PROTOCOL, },         // ProtocolChain
        2,                          // iVersion
        AF_INET,                    // iAddressFamily
        SOCKADDRLEN,                // iMaxSockAddr
        SOCKADDRLEN,                // iMinSockAddr
        SOCK_RAW,                   // iSocketType
        0,                          // iProtocol
        255,                        // iProtocolMaxOffset
        BIGENDIAN,                  // iNetworkByteOrder
        SECURITY_PROTOCOL_NONE,     // iSecurityScheme
        MAX_UDP_MSGSIZE,            // dwMessageSize
        0,                          // dwProviderReserved
        L"MSAFD Tcpip [RAW/IP]"     // szProtocol
    }
};


INT
MatchTcpipProtocol(
    IN INT af,
    IN INT type,
    IN INT protocol,
    OUT const WSAPROTOCOL_INFOW** protoinfo
    )

/*++

Routine Description:

    Match the specified parameters to a TCP/IP protocol

Arguments:

    af - Supplies an address family specification
    type - Supplies a socket type specification
    protocol - Supplies an address family specific identification of a
        protocol to be used with a socket, or 0 if the caller does
        not wish to specify a protocol.
    protoinfo - Returns the matched protocol information

Return Value:

    Error code

--*/

#define MATCHED_NONE 0
#define MATCHED_TYPE 1
#define MATCHED_TYPE_FAMILY 2
#define MATCHED_TYPE_FAMILY_PROTOCOL 3

#define PROTOCOL_IN_RANGE(_info, _proto) \
        ((_proto) >= (_info)->iProtocol && \
         (_proto) <= (_info)->iProtocol + (_info)->iProtocolMaxOffset)

{
    const WSAPROTOCOL_INFOW* p = TcpIpProtocols;
    const WSAPROTOCOL_INFOW* matched_proto = NULL;
    INT match = MATCHED_NONE;
    INT count = NUM_TCPIP_PROTOCOLS;
    INT err;

    // Either address family or protocol must be specified
    *protoinfo = NULL;
    if (af == 0 && protocol == 0) return WSAEINVAL;

    while (count-- && match < MATCHED_TYPE_FAMILY_PROTOCOL) {
        // Does the socket type match?

        if ((p->iSocketType == type) || (type == 0)) {
            if (match < MATCHED_TYPE) {
                match = MATCHED_TYPE;
                matched_proto = p;
            }

            // Can it support the requested address family?
            // Or is the wildcard family specified?

            if ((p->iAddressFamily == af) || (af == 0)) {
                if (match < MATCHED_TYPE_FAMILY) {
                    match = MATCHED_TYPE_FAMILY;
                    matched_proto = p;
                }

                // Is the requested protcol in range? Or is the requested
                // protocol 0 and entry supports protocol 0?

                if (PROTOCOL_IN_RANGE(p, protocol) || protocol == 0) {
                    match = MATCHED_TYPE_FAMILY_PROTOCOL;
                    matched_proto = p;
                }
            }
        }

        p++;
    }

    // Select an appropriate error code for "no match" cases,
    // or success code to proceed.

    switch (match) {
    case MATCHED_NONE:
        err = WSAESOCKTNOSUPPORT;
        break;

    case MATCHED_TYPE:
        err = WSAEAFNOSUPPORT;
        break;

    case MATCHED_TYPE_FAMILY_PROTOCOL:
        // NOTE: we don't allow raw sockets with TCP or UDP protocol
        if (type != SOCK_RAW ||
            protocol != IPPROTO_TCP && protocol != IPPROTO_UDP) {
            err = NO_ERROR;
            break;
        }

        // fall through

    case MATCHED_TYPE_FAMILY:
        err = WSAEPROTONOSUPPORT;
        break;

    default:
        err = WSASYSCALLFAILURE;
        break;
    }

    *protoinfo = (LPWSAPROTOCOL_INFOW) matched_proto;
    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\test\tftpd\tftpd.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    tftpd.c

Abstract:

    Simple TFTP server implementation for XBox

Revision History:

    04/19/2000 davidx
        Created it.

Notes:

    Please refer to RFC1350 and RFC2347.

--*/

#include "precomp.h"
#include "tftpd.h"

//
// Global variable definitions
//
BOOL WinsockStarted;
SOCKET TftpSock = INVALID_SOCKET;
BOOL TftpServiceRunning;
INT err;
CHAR TftpRecvBuf[TFTP_PACKET_BUFSIZE];
CHAR TftpSendBuf[TFTP_PACKET_BUFSIZE];
INT tftpdTraceFlag;


BOOL
TftpSendErrorPacket(
    SOCKET s,
    DWORD err
    )

/*++

Routine Description:

    Send a TFTP error packet

Arguments:

    s - Specifies the socket to send to
    err - Specifies the TFTP error code

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

#define ARRAYCOUNT(a) (sizeof(a) / sizeof(a[0]))

{
    //
    // TFTP error message strings
    //
    static const PCSTR errorMessages[] = {
        "Undefined error code.",
        "File not found.",
        "Access violation.",
        "Disk full or allocation exceeded.",
        "Illegal TFTP operation.",
        "Unknown transfer ID.",
        "File already exists.",
        "No such user.",
        "Illegal OACK packet.\n"
    };

    CHAR* buf = TftpSendBuf;
    PCSTR str;
    UINT buflen;

    ADDUSHORTFIELD(TFTPOP_ERROR);
    ADDUSHORTFIELD(err);

    if (err >= ARRAYCOUNT(errorMessages)) err = 0;
    str = errorMessages[err];
    ADDSTRINGFIELD(str);

    buflen = buf - TftpSendBuf;
    return _send(s, TftpSendBuf, &buflen) == NO_ERROR;
}


BOOL
TftpSendAckPacket(
    SOCKET s,
    UINT blocknum
    )

/*++

Routine Description:

    Send a TFTP ACK packet

Arguments:

    s - Specifies the socket handle
    blocknum - Specifies the acknowledged block number

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    CHAR* buf = TftpSendBuf;
    UINT buflen;

    ADDUSHORTFIELD(TFTPOP_ACK);
    ADDUSHORTFIELD(blocknum);

    buflen = buf - TftpSendBuf;
    return _send(s, TftpSendBuf, &buflen) == NO_ERROR;
}


INLINE BOOL
TftpVerifyPacketHeader(
    CHAR* buf,
    DWORD buflen,
    UINT opcode,
    UINT blocknum
    )

/*++

Routine Description:

    Verify a received packet matches what we're expecting
    (the packet can be either ACK or DATA packets)

Arguments:

    buf - Points to the data buffer
    buflen - Length of the data buffer
    opcode - Expected opcode
    blocknum - Expected block number

Return Value:

    TRUE if the received packet is as expected
    FALSE otherwise

--*/

{
    UINT op, blk;

    GETUSHORTFIELD(op);
    GETUSHORTFIELD(blk);

    TRACE_("Received: opcode %d, block %d", op, blk);

    if (opcode == op && blocknum == blk)
        return TRUE;

failed:
    WARNING_("Invalid packet received: expecting %d", blocknum);
    return FALSE;
}


BOOL
TftpIsErrorPacket(
    CHAR* buf,
    DWORD buflen
    )

/*++

Routine Description:

    Determine if a received packet is an ERROR packet

Arguments:

    buf - Points to the data buffer
    buflen - Data buffer length

Return Value:

    TRUE if the packet is a well-formed ERROR packet
    FALSE otherwise

--*/

{
    UINT opcode, errcode;
    CHAR* errmsg;

    GETUSHORTFIELD(opcode);
    GETUSHORTFIELD(errcode);
    GETSTRINGFIELD(errmsg);

    if (opcode == TFTPOP_ERROR) {
        WARNING_("Received ERROR packet: %d, %s", errcode, errmsg);
        return TRUE;
    }

failed:
    return FALSE;
}


BOOL
TftpReadFile(
    SOCKET s,
    const CHAR* filename
    )

/*++

Routine Description:

    Read a file from the disk and send it to a client

Arguments:

    s - Specifies the socket handle
    filename - Specifies the filename

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    UINT blocknum = 1;
    CHAR* buf;
    DWORD buflen, total = 0;
    INT retries;
    SeqFile* file;
    BOOL retval = FALSE;

    VERBOSE_("Read file: %s", filename);

    //
    // Open the file for reading
    //
    file = _CreateFile(filename, GENERIC_READ);
    if (!file) {
        WARNFAIL(CreateFile); return FALSE;
    }
    ASSERT(cfgSeqFileBufSize % TFTP_DATAPACKET_BLOCKSIZE == 0);

    do {
        //
        // Read a block of data from the file
        //
        buflen = TFTP_DATAPACKET_BLOCKSIZE;
        if (!_ReadFile(file, &buf, &buflen)) {
            WARNFAIL(ReadFile); goto failed;
        }
        CopyMem(&TftpSendBuf[TFTP_DATAPACKET_HEADERSIZE], buf, buflen);

        // NOTE: If EOF is reached and buflen is 0,
        // we'll send an empty data packet.

        //
        // Munge data packet header
        //
        buf = TftpSendBuf;
        ADDUSHORTFIELD(TFTPOP_DATA);
        ADDUSHORTFIELD(blocknum);

        TRACE_("Send DATA packet: block %d", blocknum);

        for (retries=0; retries < TFTP_MAX_RETRIES; retries++) {
            //
            // Send the data packet to the client
            //
            DWORD count = TFTP_DATAPACKET_HEADERSIZE+buflen;

            err = _send(s, TftpSendBuf, &count);
            if (err != NO_ERROR) {
                WARNFAIL(send); goto failed;
            }
            
            //
            // Now wait to receive the ACK from the client or
            // until the timeout expires
            //
            count = sizeof(TftpRecvBuf);
            if (_recv(s, TftpRecvBuf, &count) == NO_ERROR) {
                //
                // Did we receive an ACK of correct block number?
                // If so, move on to the next block.
                //
                if (TftpVerifyPacketHeader(TftpRecvBuf, count, TFTPOP_ACK, blocknum)) {
                    total += buflen;
                    blocknum++;
                    break;
                }

                //
                // Did we get an error packet?
                // If so, abort. Otherwise, continue retry.
                //
                if (TftpIsErrorPacket(TftpRecvBuf, count)) goto failed;
            } else {
                //
                // Is the service shutting down?
                //
                if (!TftpServiceRunning) goto failed;
            }
        }

        //
        // Did we exceed our retry count? Give up if we did.
        //
        if (retries == TFTP_MAX_RETRIES) {
            WARNING_("Timed out while waiting for ACK");
            SetLastError(ERROR_TIMEOUT);
            goto failed;
        }

    } while (buflen == TFTP_DATAPACKET_BLOCKSIZE);

    VERBOSE_("Total number of bytes transferred: %d", total);
    retval = TRUE;

failed:
    _CloseFile(file);
    return retval;
}


BOOL
TftpWriteFile(
    SOCKET s,
    const CHAR* filename
    )

/*++

Routine Description:

    Receive a file from a client and write it to the disk

Arguments:

    s - Specifies the socket handle
    filename - Specifies the filename

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    UINT blocknum = 0;
    SeqFile* file;
    INT retries;
    CHAR* buf;
    DWORD buflen, total = 0;
    BOOL retval = FALSE;

    VERBOSE_("Write file: %s", filename);

    //
    // Open the file for writing
    //
    file = _CreateFile(filename, GENERIC_WRITE);
    if (!file) {
        WARNFAIL(CreateFile); return FALSE;
    }
    ASSERT(cfgSeqFileBufSize % TFTP_DATAPACKET_BLOCKSIZE == 0);

    do {
        for (retries=0; retries < TFTP_MAX_RETRIES; retries++) {
            //
            // Send the current ACK packet
            //
            TRACE_("Send ACK packet: block %d", blocknum);
            if (!TftpSendAckPacket(s, blocknum)) goto failed;

            //
            // Wait for the next data packet
            //
            buflen = sizeof(TftpRecvBuf);
            if (_recv(s, TftpRecvBuf, &buflen) == NO_ERROR) {
                //
                // Got a data packet: verify header information
                //
                if (TftpVerifyPacketHeader(TftpRecvBuf, buflen, TFTPOP_DATA, blocknum+1))
                    break;

                //
                // Did we get an error packet?
                // If so, abort. Otherwise, continue retry.
                //
                if (TftpIsErrorPacket(TftpRecvBuf, buflen)) goto failed;
            } else {
                //
                // We failed to receive a data packet.
                // If the service is shutting down, give up.
                // Otherwise, resend the ACK and wait again.
                //
                if (!TftpServiceRunning) goto failed;
            }
        }

        if (retries == TFTP_MAX_RETRIES) {
            WARNING_("Timed out waiting for data packet");
            SetLastError(ERROR_TIMEOUT);
            goto failed;
        }

        //
        // Write the received data to file
        //
        blocknum++;
        buf = &TftpRecvBuf[TFTP_DATAPACKET_HEADERSIZE];
        buflen -= TFTP_DATAPACKET_HEADERSIZE;
        total += buflen;

        if (buflen > 0) {
            if (!_WriteFile(file, buf, buflen)) {
                WARNFAIL(WriteFile); goto failed;
            }
        }
    } while (buflen == TFTP_DATAPACKET_BLOCKSIZE);

    //
    // Send the final ACK packet, ignore error
    //
    TftpSendAckPacket(s, blocknum);
    
    VERBOSE_("Total number of bytes transferred: %d", total);
    retval = TRUE;

failed:
    _CloseFile(file);
    return retval;
}


BOOL
TftpHandleRequest(
    CHAR* buf,
    DWORD buflen,
    struct sockaddr_in* from
    )

/*++

Routine Description:

    Handle a TFTP request packet

Arguments:

    buf - Points to the received data buffer
    buflen - Buffer length
    from - Specifies the requester's address and port

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

#define WAITREAD_TIMEOUT 2000

{
    UINT opcode;
    CHAR* filename;
    CHAR* mode;
    SOCKET s;
    struct sockaddr_in addr;
    INT err = TFTPERR_INVALID_OPCODE;

    TRACE_("Received request: %s %d", inet_ntoa(from->sin_addr), ntohs(from->sin_port));
    TftpDumpPacket(buf, buflen);

    //
    // Open a new socket to handle the request
    //
    s = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if (s == INVALID_SOCKET) goto sockfailed;

    //
    // Bind to local port and connect to remote client
    //
    ZeroMem(&addr, sizeof(addr));
    addr.sin_family = AF_INET;
    addr.sin_addr.s_addr = INADDR_ANY;

    if (_bind(s, &addr) != 0 ||
        _connect(s, from) != 0 ||
        _setrcvtimeout(s, WAITREAD_TIMEOUT) != 0)
        goto sockfailed;

    if (_getsockname(s, &addr) == NO_ERROR) {
        TRACE_("Local socket: %s %d", inet_ntoa(addr.sin_addr), ntohs(addr.sin_port));
    }

    //
    // Extract the opcode
    //
    GETUSHORTFIELD(opcode);
    if (opcode != TFTPOP_RRQ && opcode != TFTPOP_WRQ) goto failed;
    
    //
    // Extract the filename and transfer mode field
    // NOTE: we treat octet and netascii mode as the same
    //
    GETSTRINGFIELD(filename);
    GETSTRINGFIELD(mode);

    if (_stricmp(mode, "octet") != 0 && _stricmp(mode, "netascii") != 0) {
        WARNING_("Only octet and netascii mode are supported");
        goto failed;
    }

    // NOTE: Options are ignored

    //
    // Execute the read or write request
    //
    if (((opcode == TFTPOP_RRQ) ? TftpReadFile : TftpWriteFile)(s, filename)) {
        closesocket(s);
        return TRUE;
    }
    
    //
    // Map Win32 error code to TFTP error code
    //
    switch (GetLastError()) {

    case ERROR_FILE_NOT_FOUND:
    case ERROR_PATH_NOT_FOUND:
        err = TFTPERR_FILE_NOT_FOUND;
        break;
    
    case ERROR_ACCESS_DENIED:
        err = TFTPERR_ACCESS_DENIED;
        break;

    case ERROR_HANDLE_DISK_FULL:
        err = TFTPERR_DISK_FULL;
        break;

    case ERROR_FILE_EXISTS:
        err = TFTPERR_FILE_EXISTS;
        break;
    
    case ERROR_NO_SUCH_USER:
        err = TFTPERR_INVALID_USER;
        break;

    default:
        err = TFTPERR_UNKNOWN;
        break;
    }

failed:
    //
    // Failed to handle the TFTP request
    //
    WARNING_("TftpHandleRequest failed: %d", err);

    TftpSendErrorPacket(s, err);
    closesocket(s);
    return FALSE;

sockfailed:
    //
    // Failed to open a socket to handle the request
    //
    WARNING_("Failed to open response socket: %d", GetLastError());
    if (s != INVALID_SOCKET) closesocket(s);
    return FALSE;

}


VOID
TftpCleanup()

/*++

Routine Description:

    Cleanup the resources used by the TFTP service 

Arguments:

    NONE

Return Value:

    NONE

--*/

{
    if (TftpServiceRunning) {
        //
        // The TFTP service is still running when cleanup is called
        //
        WARNING_("TftpCleanup: the service thread is still running");
        TftpStopService();
        return;
    }

    //
    // Close the server socket
    //
    if (TftpSock != INVALID_SOCKET) {
        closesocket(TftpSock);
        TftpSock = INVALID_SOCKET;
    }

    //
    // Uninitialize Winsock
    //
    if (WinsockStarted) {
        WSACleanup();
        WinsockStarted = FALSE;
    }
}


BOOL
TftpSetDefaultDirectory()

/*++

Routine Description:

    Set the default directory for the TFTP service

Arguments:

    NONE

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    // _XBOX_BUGBUG: Do nothing for now
    return TRUE;
}


BOOL
TftpOpenServerSocket()

/*++

Routine Description:

    Open the TFTP server socket

Arguments:

    NONE

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

#define WAITREQ_TIMEOUT 2000

{
    struct sockaddr_in addr;

    //
    // Open the socket
    //
    TftpSock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);

    if (TftpSock == INVALID_SOCKET) {
        WARNING_("socket failed: %d\n", GetLastError());
        return FALSE;
    }

    //
    // Bind the socket to the TFTP server port
    // and set the receive timeout option
    //
    ZeroMemory(&addr, sizeof(addr));
    addr.sin_family = AF_INET;
    addr.sin_addr.s_addr = INADDR_ANY;
    addr.sin_port = htons(TFTP_SERVER_PORT);

    if (_bind(TftpSock, &addr) != 0 ||
        _setrcvtimeout(TftpSock, WAITREQ_TIMEOUT) != 0) {
        WARNING_("bind failed: %d", GetLastError());
        return FALSE;
    }

    return TRUE;
}


DWORD
TftpServiceThread(
    VOID* param
    )
{
    DWORD byteCount;
    struct sockaddr_in from;

    VERBOSE_("Waiting for the next request...");
    while (TftpServiceRunning) {
        //
        // Wait to receive the next request and then handle it
        //
        byteCount = sizeof(TftpRecvBuf);
        if (_recvfrom(TftpSock, TftpRecvBuf, &byteCount, &from) == NO_ERROR) {
            TftpHandleRequest(TftpRecvBuf, byteCount, &from);
            VERBOSE_("Waiting for the next request...");
        }
    }

    TftpCleanup();
    TRACE_("TFTP service stopped");
    return 0;
}


DWORD WINAPI
TftpStartService()

/*++

Routine Description:

    Start the TFTP service

Arguments:

    NONE

Return Value:

    Win32 error code

--*/

{
    HANDLE threadHandle;
    DWORD threadId;
    WSADATA wsadata;
    DWORD err;

    //
    // Initialize Winsock
    //
    if (WSAStartup(WINSOCK_VERSION, &wsadata) != 0) goto failed;
    WinsockStarted = TRUE;

    //
    // Set default directory
    //
    if (!TftpSetDefaultDirectory()) goto failed;

    //
    // Open TFTP server socket
    //
    if (!TftpOpenServerSocket()) goto failed;

    //
    // Create the TFTP server thread
    //
    TftpServiceRunning = TRUE;
    threadHandle = CreateThread(NULL, 0, TftpServiceThread, NULL, 0, &threadId);
    if (!threadHandle) goto failed;

    TRACE_("TFTP service started");
    return NO_ERROR;

failed:

    //
    // Cleanup and return error
    //
    TftpServiceRunning = FALSE;
    TftpCleanup();

    err = GetLastError();
    WARNING_("TftpStartService failed: %d", err);
    return err;
}


DWORD WINAPI
TftpStopService()
{
    if (TftpServiceRunning) {
        //
        // Signal the TFTP service thread to stop
        //
        TftpServiceRunning = FALSE;
        while (WinsockStarted) {
            Sleep(500);
        }
    } else {
        WARNING_("TFTP service already stopped");
    }

    return NO_ERROR;
}


#if DBG

VOID
TftpDumpPacket(
    CHAR* buf,
    DWORD buflen
    )

/*++

Routine Description:

    Dump a TFTP packet

Arguments:

    buf - Points to the packet data
    buflen - Specifies the packet length

Return Value:

    NONE

--*/

{
    //
    // Opcode strings
    //
    static const PCSTR opcodeStrings[] = {
        "RRQ",
        "WRQ",
        "DATA",
        "ACK",
        "ERROR",
        "OACK"
    };

    DWORD status;
    UINT opcode, blocknum, errcode;
    CHAR* s;

    if (!tftpdTraceFlag) return;

    GETUSHORTFIELD(opcode);

    DbgPrint("TFTP packet type: ");
    if (opcode > 0 && opcode <= ARRAYCOUNT(opcodeStrings))
        DbgPrint("%s\n", opcodeStrings[opcode-1]);
    else
        DbgPrint("unknown (%d)\n", opcode);

    switch (opcode) {
    case TFTPOP_RRQ:
    case TFTPOP_WRQ:
    case TFTPOP_OACK:
        while (buflen) {
            GETSTRINGFIELD(s);
            DbgPrint("  %s\n", s);
        }
        break;
    
    case TFTPOP_DATA:
        GETUSHORTFIELD(blocknum);
        DbgPrint("  block %d, %d bytes\n", blocknum, buflen);
        break;
        
    case TFTPOP_ACK:
        GETUSHORTFIELD(blocknum);
        DbgPrint("  block %d\n", blocknum);
        break;

    case TFTPOP_ERROR:
        GETUSHORTFIELD(errcode);
        GETSTRINGFIELD(s);
        DbgPrint("  code %d, %s\n", errcode, s);
        break;
    }
    
    return;

failed:
    DbgPrint("Ill-formed TFTP packet\n");
}

#endif // DBG


#ifndef BUILD_DLL

volatile INT testFlag = 1;

void __cdecl main()
{
    DbgPrint("Loading XBox network stack...\n");
    err = XnetInitialize(NULL, TRUE);
    if (err != NO_ERROR) {
        WARNFAIL(XnetInitialize); goto stop;
    }

    DbgPrint("Starting TFTP service...\n");
    err = TftpStartService();
    if (err != NO_ERROR) {
        WARNFAIL(TftpStartService); goto unload;
    }

    DbgPrint("*** Test started, press 'g' to continue...\n");
    DbgPrint("*** To quit, press CTRL-C and type: ed %x 0;g\n", &testFlag);
    BREAK_INTO_DEBUGGER

    while (testFlag > 0) {
        Sleep(1000);
    }

    DbgPrint("Stopping TFTP service...\n");
    TftpStopService();

unload:
    DbgPrint("Unloading XBox network stack...\n");
    XnetCleanup();

stop:
    if (testFlag == 0)
        HalReturnToFirmware(HalRebootRoutine);
    else
        Sleep(INFINITE);
}

#else // BUILD_DLL

BOOL WINAPI
DllMain(
    HINSTANCE hInstance,
    DWORD fdwReason,
    LPVOID lpReserved
    )
{
    UNREFERENCED_PARAMETER( hInstance );
    UNREFERENCED_PARAMETER( fdwReason );
    UNREFERENCED_PARAMETER( lpReserved );
    return TRUE;
}

#endif // BUILD_DLL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\test\tftpd\tftpd.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    tftpd.h

Abstract:

    Simple TFTP server implementation for XBox

Revision History:

    04/19/2000 davidx
        Created it.

--*/

#ifndef _TFTPD_H
#define _TFTPD_H

//
// TFTP server UDP port number
//

#define TFTP_SERVER_PORT 69

//
// TFTP opcodes
//

#define TFTPOP_RRQ      1
#define TFTPOP_WRQ      2
#define TFTPOP_DATA     3
#define TFTPOP_ACK      4
#define TFTPOP_ERROR    5
#define TFTPOP_OACK     6

//
// Max TFTP packet size: 4 bytes header + 512 bytes data
//

#define TFTP_DATAPACKET_HEADERSIZE  4
#define TFTP_DATAPACKET_BLOCKSIZE   512
#define TFTP_PACKET_BUFSIZE         (4+512)

//
// Error codes
//

#define TFTPERR_UNKNOWN         0
#define TFTPERR_FILE_NOT_FOUND  1
#define TFTPERR_ACCESS_DENIED   2
#define TFTPERR_DISK_FULL       3
#define TFTPERR_INVALID_OPCODE  4
#define TFTPERR_INVALID_ID      5
#define TFTPERR_FILE_EXISTS     6
#define TFTPERR_INVALID_USER    7
#define TFTPERR_INVALID_OACK    8

//
// Timeout and retry values
//
#define TFTP_MAX_RETRIES        3
#define TFTP_RECV_TIMEOUT       2000

//
// Extract a u_short field out of an incoming TFTP message
// NOTE:
//  we assume we're on a little-endian machine and
//  take care of byte swapping here.
//
#define GETUSHORTFIELD(_var) do { \
            if (buflen < 2) goto failed; \
            _var = ((UINT) ((BYTE*) buf)[0] << 8 | \
                    (UINT) ((BYTE*) buf)[1]); \
            buf += 2; \
            buflen -= 2; \
        } while (0)

//
// Extract a string field out of an incoming TFTP message
//
#define GETSTRINGFIELD(_var) do { \
            CHAR* _p = buf; \
            CHAR* _q = _p + buflen; \
            INT _n; \
            while (_p < _q && *_p) _p++; \
            if (_p == _q) goto failed; \
            _var = buf; \
            _n = (_p - buf) + 1; \
            buf += _n; \
            buflen -= _n; \
        } while (0)

//
// Insert a u_short field into an outgoing TFTP message
// NOTE:
//  we assume we're on a little-endian machine and
//  take care of byte swapping here.
//
#define ADDUSHORTFIELD(_var) do { \
            buf[0] = (CHAR) ((_var) >> 8); \
            buf[1] = (CHAR) (_var); \
            buf += 2; \
        } while (0)

//
// Insert a string field into an outgoing TFTP message
//
#define ADDSTRINGFIELD(_var) do { \
            INT _n = strlen(_var) + 1; \
            memcpy(buf, _var, _n); \
            buf += _n; \
        } while (0)

//
// Function prototypes
//

DWORD WINAPI
TftpStartService();

DWORD WINAPI
TftpStopService();

VOID
TftpCleanup();

BOOL
TftpSetDefaultDirectory();

BOOL
TftpOpenServerSocket();

BOOL
TftpHandleRequest(
    CHAR* buf,
    DWORD buflen,
    struct sockaddr_in* from
    );

BOOL
TftpSendAckPacket(
    SOCKET s,
    UINT blocknum
    );

BOOL
TftpVerifyPacketHeader(
    CHAR* buf,
    DWORD buflen,
    UINT opcode,
    UINT blocknum
    );

BOOL
TftpSendErrorPacket(
    SOCKET s,
    DWORD err
    );

BOOL
TftpReadFile(
    SOCKET s,
    const CHAR* filename
    );

BOOL
TftpWriteFile(
    SOCKET s,
    const CHAR* filename
    );

#if DBG

VOID
TftpDumpPacket(
    CHAR* buf,
    DWORD buflen
    );

#else

#define TftpDumpPacket(buf, buflen)

#endif

#endif // !_TFTPD_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\winsock\getxbyy.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    getxbyy.c

Abstract:

    Implementation of the following Winsock APIs:
        gethostbyaddr
        gethostbyname
        gethostname
        getservbyname
        getservbyport
        getprotobynumber
        getprotobyname
        XnetGetIpAddress

Revision History:

    03/30/2000 davidx
        Created it.

--*/

#include "precomp.h"

PRIVATE INT
SockGetLocalHostName(
    OUT CHAR* buf,
    IN UINT bufsize
    )

/*++

Routine Description:

    Return the name of the local host

Arguments:

    buf - Output buffer
    bufsize - Output buffer size

Return Value:

    Winsock error code

Note:

    For now, our local hostname will just be our Ethernet
    address in hexdecimal format.

--*/

{
    static const CHAR hexDigits[] = "0123456789abcdef";
    IfInfo* ifp = LanIfp;
    BYTE* hwaddr;
    UINT count;

    if (!ifp) return WSAENETDOWN;
    hwaddr = ifp->hwaddr;
    count = ifp->hwaddrlen;
    if (bufsize < 2 + count * 2) return WSAENOBUFS;

    *buf++ = '_';
    while (count--) {
        *buf++ = hexDigits[*hwaddr >> 4];
        *buf++ = hexDigits[*hwaddr & 15];
        hwaddr++;
    }

    *buf = 0;
    return NO_ERROR;
}


PRIVATE BOOL
SockIsLocalHostName(
    IN const CHAR* name,
    OUT CHAR* buf,
    IN UINT bufsize
    )

/*++

Routine Description:

    Check if the specified hostname matches the local hostname

Arguments:

    name - Specified the hostname in question
    buf - Output buffer for returning the local hostname
    bufsize - Output buffer size

Return Value:

    TRUE if the specified hostname is the same as the local hostname
    FALSE otherwise

--*/

{
    return (name[0] == '_' &&
            SockGetLocalHostName(buf, bufsize) == NO_ERROR &&
            strcmp(name, buf) == 0);
}


//
// hostent structure with 1 host name and 1 host address
//
typedef struct _HostEnt1 {
    struct hostent;
    CHAR* alias_array[1];
    CHAR* addr_array[2];
    IPADDR ipaddr;
    CHAR namebuf[1];
} HostEnt1;

PRIVATE INT
SockReturnLocalHostent(
    WinsockThreadbuf* hostentbuf,
    CHAR* localhost
    )

/*++

Routine Description:

    Return the local host address

Arguments:

    hostentbuf - Points to the per-thread temporary data buffer
    localhost - Local hostname

Return Value:

    Winsock error code

--*/

{
    UINT namesize, size;
    HostEnt1* host;

    //
    // Get the best available IP address
    //
    IPADDR ipaddr;
    if (IpGetBestAddress(&ipaddr) == XNET_ADDR_NONE)
        return WSAENETDOWN;

    //
    // Assemble the return information into a HOSTENT structure
    //
    namesize = SizeofSTR(localhost);
    size = offsetof(HostEnt1, namebuf) + namesize;
    if (!SockAllocThreadbuf(hostentbuf, size))
        return WSAENOBUFS;

    host = (HostEnt1*) hostentbuf->data;
    host->h_name = host->namebuf;
    host->h_aliases = host->alias_array;
    host->h_addrtype = AF_INET;
    host->h_length = IPADDRLEN;
    host->h_addr_list = host->addr_array;
    host->alias_array[0] = NULL;
    host->addr_array[0] = (CHAR*) &host->ipaddr;
    host->addr_array[1] = NULL;
    host->ipaddr = ipaddr;
    CopyMem(host->namebuf, localhost, namesize);

    return NO_ERROR;
}


//
// Callback function passed to DnsLookupBy___.  It's called to
// allocate memory buffer to store the hostent information.
//
PRIVATE struct hostent*
SockAllocHostentCallback(
    UINT size,
    VOID* param
    )
{
    return (struct hostent*) SockAllocThreadbuf((WinsockThreadbuf*) param, size);
}


struct hostent* WSAAPI
gethostbyaddr(
    IN const char* addr,
    IN int len,
    IN int type
    )

/*++

Routine Description:

    Refer to XAPI SDK documentation.

--*/

{
    WinsockThreadbuf* hostentbuf;
    IPADDR ipaddr;
    WinsockApiProlog_(gethostbyaddr, NULL);

    WinsockApiParamCheck_(
        addr != NULL &&
        len >= (INT) sizeof(struct in_addr) &&
        type == AF_INET);

    ipaddr = ((struct in_addr*) addr)->s_addr;
    hostentbuf = &tlsData->hostentbuf;
    err = DnsLookupByAddr(ipaddr, SockAllocHostentCallback, hostentbuf);
    MapNtStatusToWinsockError_(err);

    WinsockApiCheckError_(NULL);
    return (struct hostent*) hostentbuf->data;
}


struct hostent* WSAAPI
gethostbyname(
    IN const char* name
    )

/*++

Routine Description:

    Refer to XAPI SDK documentation.

--*/

{
    WinsockThreadbuf* hostentbuf;
    CHAR localhost[32];
    WinsockApiProlog_(gethostbyname, NULL);

    WinsockApiParamCheck_(name != NULL);

    hostentbuf = &tlsData->hostentbuf;
    if (SockIsLocalHostName(name, localhost, 32)) {
        err = SockReturnLocalHostent(hostentbuf, localhost);
    } else {
        err = DnsLookupByName(name, SockAllocHostentCallback, hostentbuf);
        MapNtStatusToWinsockError_(err);
    }

    WinsockApiCheckError_(NULL);
    return (struct hostent*) hostentbuf->data;
}


int WSAAPI
gethostname(
    OUT char* name,
    IN int namelen
    )

/*++

Routine Description:

    Refer to XAPI SDK documentation.

--*/

{
    WinsockApiProlog_(gethostname, SOCKET_ERROR);
    WinsockApiParamCheck_(name != NULL);

    if (namelen <= 0) {
        err = WSAEFAULT;
    } else {
        err = SockGetLocalHostName(name, namelen);
        if (err == WSAENOBUFS)
            err = WSAEFAULT;
    }

    WinsockApiCheckError_(SOCKET_ERROR);
    return NO_ERROR;
}



//
// !!! _XBOX_NOTE
//  Hard-coded services database
//

typedef struct {
    WORD port;
    WORD type;
    const CHAR* names;
} ServiceEntry;

#define SVCTYPE_TCP    1
#define SVCTYPE_UDP    2
#define SVCTYPE_ALL   (SVCTYPE_TCP|SVCTYPE_UDP)
#define SVCENTRYTCP(_port, _names) { HTONS(_port), SVCTYPE_TCP, _names }
#define SVCENTRYUDP(_port, _names) { HTONS(_port), SVCTYPE_UDP, _names }
#define SVCENTRYALL(_port, _names) { HTONS(_port), SVCTYPE_ALL, _names }
    
PRIVATE const ServiceEntry Services[] = {
    SVCENTRYTCP(20, "ftp-data\0"),
    SVCENTRYTCP(21, "ftp\0"),
    SVCENTRYTCP(23, "telnet\0"),
    SVCENTRYTCP(25, "smtp\0mail\0"),
    SVCENTRYALL(53, "domain\0"),
    SVCENTRYUDP(67, "bootps\0dhcps\0"),
    SVCENTRYUDP(68, "bootpc\0dhcpc\0"),
    SVCENTRYUDP(69, "tftp\0"),
    SVCENTRYTCP(70, "gopher\0"),
    SVCENTRYTCP(80, "http\0www\0www-http\0"),
    SVCENTRYTCP(110, "pop3\0"),
    SVCENTRYTCP(143, "imap\0imap4\0"),
    SVCENTRYUDP(161, "snmp\0"),
    SVCENTRYTCP(194, "irc\0"),
    SVCENTRYALL(443, "https\0MCom\0"),
    { 0, }
};


//
// Structure for storing the SERVENT information
// we return from the getservbyXxx APIs.
//

struct myservent {
    struct servent;
    CHAR* aliases[3];
};

PRIVATE struct servent*
SockComposeServentBuf(
    const ServiceEntry* service,
    WORD type
    )

/*++

Routine Description:

    Generate a SERVENT structure based on the specified service database entry

Arguments:

    service - Pointer to the service database entry
    type - Determine whether to use TCP or UDP protocol

Return Value:

    Points to the resulting SERVENT structure
    NULL if there is an error

--*/

{
    struct myservent* buf;
    INT bufsize, namelen, protolen, alias1len, alias2len;
    const CHAR* names = service->names;
    const CHAR* proto = (type & SVCTYPE_TCP) ? "tcp" : "udp";

    WinsockApiProlog_(getservby_, NULL);

    // Figure out how large a buffer we need

    protolen = SizeofSTR(proto);
    namelen = SizeofSTR(names);
    names += namelen;
    alias1len = *names ? SizeofSTR(names) : 0;
    names += alias1len;
    alias2len = *names ? SizeofSTR(names) : 0;

    bufsize = ROUNDUP8(sizeof(*buf) + protolen + namelen + alias1len + alias2len);

    // Allocate per-thread temporary buffer
    buf = (struct myservent*) SockAllocThreadbuf(&tlsData->serventbuf, bufsize);
    if (buf == NULL) {
        WinsockApiReturnError_(WSAENOBUFS, NULL);
    }

    // Fill out the SERVENT structure
    buf->s_port = service->port;
    buf->s_proto = (CHAR*) (buf+1);
    buf->s_name = buf->s_proto + protolen;
    buf->s_aliases = buf->aliases;
    buf->aliases[0] = buf->aliases[1] = buf->aliases[2] = NULL;

    if (alias1len) {
        buf->aliases[0] = buf->s_name + namelen;
        if (alias2len) buf->aliases[1] = buf->aliases[0] + alias1len;
    }

    CopyMem(buf->s_proto, proto, protolen);
    CopyMem(buf->s_name, service->names, namelen+alias1len+alias2len);

    return (struct servent*) buf;
}


//
// Map protocol name string to our internal service type flag
//
INLINE WORD
SockParseProtocolType(
    const CHAR* proto
    )
{
    return
     (WORD) ((proto == NULL) ? SVCTYPE_ALL :
             (_stricmp(proto, "tcp") == 0) ? SVCTYPE_TCP :
             (_stricmp(proto, "udp") == 0) ? SVCTYPE_UDP : 0);
}

struct servent* WSAAPI
getservbyport(
    IN int port,
    IN const char* proto
    )

/*++

Routine Description:

    Refer to XAPI SDK documentation.

--*/

{
    const ServiceEntry* service = Services;
    WORD type;

    WinsockApiPrologLight_(getservbyport);

    type = SockParseProtocolType(proto);
    while (service->type) {
        if ((port == service->port) && (type & service->type)) {
            return SockComposeServentBuf(service, type);
        }
        service++;
    }

    WARNING_("getservbyport: not found");
    SetLastError(WSANO_DATA);
    return NULL;
}


struct servent* WSAAPI
getservbyname(
    IN const char* name,
    IN const char* proto
    )

/*++

Routine Description:

    Refer to XAPI SDK documentation.

--*/

{
    const ServiceEntry* service = Services;
    WORD type;

    WinsockApiPrologLight_(getservbyname);
    WinsockApiParamCheck_(name != NULL);

    type = SockParseProtocolType(proto);
    while (service->type) {
        if ((type & service->type) && _stricmp(name, service->names) == 0) {
            return SockComposeServentBuf(service, type);
        }
        service++;
    }

    WARNING_("getservbyname: not found");
    SetLastError(WSANO_DATA);
    return NULL;
}



//
// !!! _XBOX_NOTE:
//  Hard-coded protocol database
//

typedef struct {
    const CHAR* name;
    const CHAR* alias;
    INT protocol;
} ProtocolEntry;

PRIVATE const ProtocolEntry Protocols[] = {
    { "ip", "IP", 0 },
    { "icmp", "ICMP", IPPROTOCOL_ICMP },
    { "igmp", "IGMP", IPPROTOCOL_IGMP },
    { "tcp", "TCP", IPPROTOCOL_TCP },
    { "udp", "UDP", IPPROTOCOL_UDP },
    { NULL, }
};

//
// Structure for storing the PROTOENT information
// we return from the getprotobyX APIs.
//

struct myprotoent {
    struct protoent;
    CHAR* aliases[2];
};

PRIVATE struct protoent*
SockComposeProtoentBuf(
    const ProtocolEntry* proto
    )

/*++

Routine Description:

    Generate a PROTOENT structure based on the specified protocol database entry

Arguments:

    proto - Pointer to the protocol database entry

Return Value:

    Points to the resulting PROTOENT structure
    NULL if there is an error

--*/

{
    struct myprotoent* buf;
    INT bufsize, namelen, aliaslen;

    WinsockApiProlog_(getprotoby_, NULL);

    // Figure out how big a buffer we need
    namelen = SizeofSTR(proto->name);
    aliaslen = SizeofSTR(proto->alias);
    bufsize = ROUNDUP8(sizeof(*buf) + namelen + aliaslen);

    // Allocate per-thread temporary buffer
    buf = (struct myprotoent*) SockAllocThreadbuf(&tlsData->protoentbuf, bufsize); 
    if (!buf) {
        WinsockApiReturnError_(WSAENOBUFS, NULL);
    }

    buf->p_proto = (short) proto->protocol;
    buf->p_name = (CHAR*) (buf+1);
    buf->p_aliases = buf->aliases;
    buf->aliases[0] = buf->p_name + namelen;
    buf->aliases[1] = NULL;

    CopyMem(buf->p_name, proto->name, namelen);
    CopyMem(buf->aliases[0], proto->alias, aliaslen);

    return (struct protoent*) buf;
}


struct protoent* WSAAPI
getprotobynumber(
    IN int number
    )

/*++

Routine Description:

    Refer to XAPI SDK documentation.

--*/

{
    const ProtocolEntry* proto = Protocols;
    WinsockApiPrologLight_(getprotobynumber);

    while (proto->name) {
        if (proto->protocol == number)
            return SockComposeProtoentBuf(proto);
        proto++;
    }

    WARNING_("getprotobynumber: not found");
    SetLastError(WSANO_DATA);
    return NULL;
}


struct protoent* WSAAPI
getprotobyname(
    IN const char* name
    )

/*++

Routine Description:

    Refer to XAPI SDK documentation.

--*/

{
    const ProtocolEntry* proto = Protocols;

    WinsockApiPrologLight_(getprotobyname);
    WinsockApiParamCheck_(name != NULL);

    while (proto->name) {
        if (_stricmp(proto->name, name) == 0)
            return SockComposeProtoentBuf(proto);
        proto++;
    }

    WARNING_("getprotobyname: not found");
    SetLastError(WSANO_DATA);
    return NULL;
}


DWORD WSAAPI
XnetGetIpAddress(
    OUT struct in_addr* addr
    )

/*++

Routine Description:

    Get the active IP address that's currently in use

Arguments:

    addr - Return the active IP address

Return Value:

    Flags indicating how the address was obtained

--*/

{
    IPADDR ipaddr;
    DWORD flags;
    WinsockApiPrologLight_(XnetGetIpAddress);
    WinsockApiParamCheck_(addr != NULL);

    flags = IpGetBestAddress(&ipaddr);
    addr->s_addr = ipaddr;
    return flags;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\winsock\socket.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    socket.c

Abstract:

    Implement the following Winsock APIs:
        socket
        closesocket
        shutdown

Revision History:

    06/01/2000 davidx
        Created it.

--*/

#include "precomp.h"

SOCKET WSAAPI
socket(
    IN int af,
    IN int type,
    IN int protocol
    )

/*++

Routine Description:

    Refer to XAPI SDK documentation.

--*/

{
    const WSAPROTOCOL_INFOW* protoinfo;
    PCB* pcb;

    WinsockApiProlog_(socket, INVALID_SOCKET);

    err = MatchTcpipProtocol(af, type, protocol, &protoinfo);
    WinsockApiCheckError_(INVALID_SOCKET);

    if (type == 0) type = protoinfo->iSocketType;
    if (protocol == 0) protocol = protoinfo->iProtocol;

    pcb = PcbCreate(type, protocol, 0);
    if (!pcb) {
        WinsockApiReturnError_(WSAENOBUFS, INVALID_SOCKET);
    }

    // Initialize socket information here
    pcb->protocolFlags = protoinfo->dwServiceFlags1;

    PcbInsertToList(pcb);
    return (SOCKET) pcb;
}


int WSAAPI
closesocket(
    IN SOCKET s
    )

/*++

Routine Description:

    Refer to XAPI SDK documentation.

--*/

{
    WinsockApiPrologSockLock_(closesocket, SOCKET_ERROR);

    err = pcb ? PcbClose(pcb, FALSE) : NETERR_PARAM;
    MapNtStatusToWinsockError_(err);

    // NOTE: PcbClose will always close the socket.
    // So there is no need for us to call SockUnlock here.

    WinsockApiCheckError_(SOCKET_ERROR);
    return NO_ERROR;
}


int WSAAPI
shutdown(
    IN SOCKET s,
    IN int how
    )

/*++

Routine Description:

    Refer to XAPI SDK documentation.

--*/

{
    BYTE flags;
    WinsockApiPrologSockLock_(shutdown, SOCKET_ERROR);

    WinsockApiParamCheck_(
        how == SD_SEND ||
        how == SD_RECEIVE ||
        how == SD_BOTH);

    switch (how) {
    case SD_SEND:
        flags = PCBFLAG_SEND_SHUTDOWN;
        break;

    case SD_RECEIVE:
        flags = PCBFLAG_RECV_SHUTDOWN;
        break;

    default:
        flags = PCBFLAG_SEND_SHUTDOWN|PCBFLAG_RECV_SHUTDOWN;
        break;
    }

    if (IsDgramPcb(pcb)) {
        err = PcbShutdownDgram(pcb, flags);
    } else {
        if (!IsPcbConnected(pcb)) {
            WinsockApiGotoExit_(WSAENOTCONN);
        }
        err = TcbShutdown((TCB*) pcb, flags, TRUE);
    }

    MapNtStatusToWinsockError_(err);
    WinsockApiExitSockUnlock_(NO_ERROR, SOCKET_ERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\winsock\select.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    select.c

Abstract:

    Implementation of asynchronous notification related Winsock APIs:
        select
        WSAGetOverlappedResult
        WSACancelOverlappedIO

Revision History:

    06/02/2000 davidx
        Created it.

--*/

#include "precomp.h"

//
// Count the total number of socket handles
//
#define SOCKETS_IN_SET(_set) ((_set) ? ((_set)->fd_count & 0xffff) : 0)

//
// Information about sockets that was passed to the select calls
//
typedef struct _SELECTINFO {
    SOCKET s;
    fd_set* fdset;
    INT eventMasks;
    PCB* pcb;
    INT pcbMasks;
} SELECTINFO;

//
// Select event masks
//
#define SELECT_READ_EVENTS (PCBEVENT_READ|PCBEVENT_ACCEPT|PCBEVENT_CLOSE|PCBEVENT_CONNRESET)
#define SELECT_WRITE_EVENTS (PCBEVENT_WRITE|PCBEVENT_CONNECT)
#define SELECT_EXCEPT_EVENTS (PCBEVENT_CONNRESET)

//
// Number of KWAIT_BLOCKs allocated on the stack for select() calls.
//
#define SELECT_STACK_KWAIT_BLOCKS 3


PRIVATE INT
SockLockSelectSockets(
    fd_set* fdset,
    SELECTINFO* selinfo,
    INT offset,
    INT eventMasks
    )

/*++

Routine Description:

    Lock the socket handles that was passed to the select API

Arguments:

    fdset - Points to the socket set
    selinfo - Points to an array of SELECTINFO structures
        for storing the locked socket information
    eventMasks - Specifies the interested events

Return Value:

    Winsock error code

--*/

{
    INT i, count;

    // Nothing to do if the set is empty
    count = SOCKETS_IN_SET(fdset);

    for (i=0; i < count; i++) {
        SOCKET s = fdset->fd_array[i];
        INT j, k = offset + i;

        selinfo[k].s = s;
        selinfo[k].fdset = fdset;
        selinfo[k].eventMasks = eventMasks;

        // Check to see if the socket is already used
        // in the same select call
        for (j=0; j < k && selinfo[j].s != s; j++)
            ;

        if (j == k) {
            //
            // The socket isn't seen already
            //
            selinfo[k].pcbMasks = eventMasks;
            selinfo[k].pcb = SockLock(s);
            if (!selinfo[k].pcb)
                return GetLastError();
        } else {
            //
            // The socket is already seen
            //
            selinfo[j].pcbMasks |= eventMasks;
            selinfo[k].pcbMasks = 0;
            selinfo[k].pcb = selinfo[j].pcb;
        }
    }

    return NO_ERROR;
}


int WSAAPI
select(
    int nfds,
    fd_set* readfds,
    fd_set* writefds,
    fd_set* exceptfds,
    const struct timeval* timeout  
    )

/*++

Routine Description:

    Refer to XAPI SDK documentation.

--*/

{
    SELECTINFO tempinfo;
    PRKEVENT tempevent;
    KWAIT_BLOCK tempWaitBlocks[SELECT_STACK_KWAIT_BLOCKS];
    SELECTINFO* selinfo;
    PRKEVENT* events;
    INT index, rdcnt, rwcnt, selcnt = 0;
    PCB* pcb;
    LARGE_INTEGER waittime;
    LARGE_INTEGER* pwait;
    PKWAIT_BLOCK waitBlockArray = tempWaitBlocks;

    WinsockApiProlog_(select, SOCKET_ERROR);

    // Count the total number of sockets
    // (ignore the input nfds parameter)
    rdcnt = SOCKETS_IN_SET(readfds);
    rwcnt = rdcnt + SOCKETS_IN_SET(writefds);
    nfds = rwcnt + SOCKETS_IN_SET(exceptfds);

    if (nfds == 0) {
        WinsockApiReturnError_(WSAEINVAL, SOCKET_ERROR);
    }

    if (nfds == 1) {
        // Use temporary stack buffers for the special case
        // where there is only one socket. This saves us from
        // two extra memory allocations.
        events = &tempevent;
        selinfo = &tempinfo;
        ZeroMem(selinfo, sizeof(SELECTINFO));
    } else {
        selinfo = (SELECTINFO*) MAlloc0(nfds*sizeof(SELECTINFO));
        events = (PRKEVENT*) MAlloc(nfds*sizeof(PRKEVENT));
        if (!selinfo || !events) {
            nfds = 0;
            WinsockApiGotoExit_(WSAENOBUFS);
        }
    }

    // Lock all the socket handles
    if ((err = SockLockSelectSockets(readfds, selinfo, 0, SELECT_READ_EVENTS)) != 0 ||
        (err = SockLockSelectSockets(writefds, selinfo, rdcnt, SELECT_WRITE_EVENTS)) != 0 ||
        (err = SockLockSelectSockets(exceptfds, selinfo, rwcnt, SELECT_EXCEPT_EVENTS)) != 0) {
        goto exit;
    }

    // Compute the wait time in 100ns unit
    if (timeout) {
        pwait = &waittime;
        waittime.QuadPart = Int32x32To64(timeout->tv_sec, -10000000) +
                            Int32x32To64(timeout->tv_usec, -10);
    } else {
        pwait = NULL;
    }

    // Check if we to wait:
    // if we do, set up the socket event flags
    if (!pwait || pwait->QuadPart) {
        INT waitCount = 0;
        for (index=0; index < nfds; index++) {
            pcb = selinfo[index].pcb;
            if (selinfo[index].pcbMasks) {
                if (PcbCheckSelectEvents(pcb, selinfo[index].pcbMasks, -1)) break;
                events[waitCount++] = GetPcbWaitEvent(pcb);
            }
        }

        if (index == nfds) {
            if (waitCount > SELECT_STACK_KWAIT_BLOCKS) {
                waitBlockArray = (PKWAIT_BLOCK) MAlloc0(waitCount * sizeof(KWAIT_BLOCK));
                if (!waitBlockArray) {
                    WinsockApiGotoExit_(WSAENOBUFS);
                }
            }

            err = KeWaitForMultipleObjects(
                        waitCount,
                        events,
                        WaitAny,
                        UserRequest,
                        UserMode,
                        FALSE,
                        pwait,
                        waitBlockArray);

            if ((err < 0 || err >= waitCount) && err != STATUS_TIMEOUT) {
                WinsockApiGotoExit_(WSAEFAULT);
            }
        }
    }

    // Determine which socket events are ready
    // and return appropriate information

    if (readfds) { FD_ZERO(readfds); }
    if (writefds) { FD_ZERO(writefds); }
    if (exceptfds) { FD_ZERO(exceptfds); }

    for (index=selcnt=0; index < nfds; index++) {
        if (PcbCheckSelectEvents(
                    selinfo[index].pcb,
                    selinfo[index].eventMasks,
                    0)) {
            FD_SET(selinfo[index].s, selinfo[index].fdset);
            selcnt++;
        }
    }

    err = NO_ERROR;

exit:
    for (index=0; index < nfds; index++) {
        pcb = selinfo[index].pcb;
        if (pcb && selinfo[index].pcbMasks) {
            PcbClearSelectEvents(pcb);
            SockUnlock(pcb);
        }
    }
    if (waitBlockArray != tempWaitBlocks) { Free(waitBlockArray); }
    if (selinfo != &tempinfo) { Free(selinfo); }
    if (events != &tempevent) { Free(events); }

    WinsockApiCheckError_(SOCKET_ERROR);
    return selcnt;
}


BOOL WSAAPI
WSAGetOverlappedResult(
    SOCKET s,                      
    LPWSAOVERLAPPED overlapped,  
    LPDWORD byteCount,          
    BOOL fWait,                    
    LPDWORD flags              
    )

/*++

Routine Description:

    Refer to XAPI SDK documentation.

--*/

{
    WinsockApiPrologSockLock_(WSAGetOverlappedResult, FALSE);

    WinsockApiParamCheck_(
        overlapped != NULL &&
        overlapped->hEvent != NULL &&
        byteCount != NULL &&
        flags != NULL);

    //
    // Check if we need to wait for the I/O request to complete
    //
    if (overlapped->_iostatus == NETERR_PENDING && fWait) {
        KIRQL irql;
        WaitForSingleObject(overlapped->hEvent, INFINITE);

        irql = RaiseToDpc();
        if (overlapped->_iostatus == NETERR_PENDING) {
            err = overlapped->_ioxfercnt ? NETERR_OK : NETERR_CANCELLED;
            PcbCompleteOverlappedSendRecv(
                (PcbOverlappedReq*) overlapped->_ioreq,
                err);
        }
        LowerFromDpc(irql);
    }

    //
    // If the I/O request was completed,
    // return the completion status information
    //
    if ((err = overlapped->_iostatus) != NETERR_PENDING && NT_SUCCESS(err)) {
        *byteCount = overlapped->_ioxfercnt;
        *flags = overlapped->_ioflags;
    }

    if (err == NETERR_PENDING) {
        WinsockApiGotoExit_(WSA_IO_INCOMPLETE);
    } else {
        MapNtStatusToWinsockError_(err);
    }
    
    WinsockApiExitSockUnlock_(TRUE, FALSE);
}


INT WSAAPI
WSACancelOverlappedIO(
    SOCKET s
    )

/*++

Routine Description:

    Cancel out any outstanding overlapped I/O requests on a socket

Arguments:

    s - Specifies the socket handle

Return Value:

    0 if successful, SOCKET_ERROR if there is an error

--*/

{
    KIRQL irql;
    WinsockApiPrologSockLock_(WSACancelOverlappedIO, SOCKET_ERROR);

    irql = RaiseToDpc();
    PcbClearOverlappedRecvs(pcb, NETERR_CANCELLED);
    PcbClearOverlappedSends(pcb, NETERR_CANCELLED);
    LowerFromDpc(irql);
    WinsockApiGotoExit_(NO_ERROR);

    WinsockApiExitSockUnlock_(NO_ERROR, SOCKET_ERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\winsock\send.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    send.c

Abstract:

    Implementation of data transmission related Winsock APIs:
        send
        sendto
        WSASend
        WSASendTo

Revision History:

    06/02/2000 davidx
        Created it.

--*/

#include "precomp.h"

// Disable unreferenced label warning
#pragma warning(disable: 4102)


PRIVATE NTSTATUS
SockSend(
    PCB* pcb,
    SENDREQ* sendreq
    )

/*++

Routine Description:

    Internal function for sending out data from a socket

Arguments:

    pcb - Points to the protocol control block
    sendreq - Points to send user request information

Return Value:

    Status code

--*/

{
    NTSTATUS status;
    WSAOVERLAPPED* overlapped;

    if (!IsPcbConnected(pcb) && !sendreq->toaddr)
        return NETERR(WSAENOTCONN);

    if (IsPcbSendShutdown(pcb)) {
        return !NT_SUCCESS(PcbGetErrStatus(pcb)) ?
                    PcbGetErrStatus(pcb) :
                    NETERR(WSAESHUTDOWN);
    }

    if ((overlapped = sendreq->overlapped) != NULL) {
        sendreq->overlappedEvent = GetKernelEventObject(overlapped->hEvent);
        if (!sendreq->overlappedEvent)
            return NETERR(WSASYSCALLFAILURE);
    }

    // Check if we have room in the send buffer
    if (IsPcbSendBufFull(pcb)) {
        if (overlapped) {
            // Queue the overlapped send request.
            KeClearEvent(sendreq->overlappedEvent);
            status = PcbQueueOverlappedSend(pcb, sendreq);

            // The overlapped request was successfully queued up
            if (status == NETERR_PENDING)
                return status;

            // The overlapped send request wasn't queued
            // because of an error.
            if (!NT_SUCCESS(status)) goto exit;

            // The send buffer has opened up and
            // the overlapped send request wasn't queued.
        } else if (pcb->nonblocking || HasOverlappedSend(pcb)) {
            return NETERR_WOULDBLOCK;
        } else {
            status = PcbWaitForEvent(pcb, PCBEVENT_WRITE, pcb->sendTimeout);
            if (!NT_SUCCESS(status)) return status;
        }
    }

    status = IsDgramPcb(pcb) ?
                PcbSendDgram(pcb, sendreq) :
                TcbSend((TCB*) pcb, sendreq);

exit:
    if (overlapped) {
        // An overlapped call was completed immediately
        overlapped->_ioflags = 0;
        overlapped->_ioxfercnt = sendreq->sendtotal;
        overlapped->_iostatus = status;

        // It would seem to be a waste to signal the event here.
        // But that's win2k behavior.
        KeSetEvent(sendreq->overlappedEvent, 0, FALSE);
        ObDereferenceObject(sendreq->overlappedEvent);
    }

    return status;
}


int WSAAPI
send(
    SOCKET s,              
    const char* buf,  
    int len,               
    int flags              
    )

/*++

Routine Description:

    Refer to XAPI SDK documentation.

--*/

{
    WSABUF wsabuf;
    SENDREQ sendreq;
    WinsockApiPrologSockLock_(send, SOCKET_ERROR);

    WinsockApiParamCheck_(
        (len > 0 && buf != NULL || len == 0) &&
        (flags  == 0));

    wsabuf.len = len;
    wsabuf.buf = (char*) buf;
    sendreq.overlapped = NULL;
    sendreq.bufs = &wsabuf;
    sendreq.bufcnt = 1;
    sendreq.sendtotal = len;
    sendreq.toaddr = NULL;

    err = SockSend(pcb, &sendreq);
    MapNtStatusToWinsockError_(err);
    WinsockApiExitSockUnlock_(sendreq.sendtotal, SOCKET_ERROR);
}


//
// Count the total number of bytes to send
//
INLINE UINT SockCountSendTotal(WSABUF* bufs, UINT bufcnt) {
    UINT total = 0;
    while (bufcnt--) {
        total += bufs->len;
        bufs++;
    }
    return total;
}

INLINE BOOL SockCheckSendWsaBuf(WSABUF* bufs, UINT bufcnt) {
    if (bufs == NULL || bufcnt == 0)
        return FALSE;

    while (bufcnt--) {
        if (bufs->len && bufs->buf == NULL)
            return FALSE;
        bufs++;
    }
    return TRUE;
}

int WSAAPI
WSASend(
    SOCKET s,
    LPWSABUF bufs,
    DWORD bufcnt,
    LPDWORD bytesSent,
    DWORD flags, 
    LPWSAOVERLAPPED overlapped,                           
    LPWSAOVERLAPPED_COMPLETION_ROUTINE completionproc  
    )

/*++

Routine Description:

    Refer to XAPI SDK documentation.

--*/

{
    SENDREQ sendreq;
    WinsockApiPrologSockLock_(WSASend, SOCKET_ERROR);

    WinsockApiParamCheck_(
        SockCheckSendWsaBuf(bufs, bufcnt) &&
        bytesSent != NULL &&
        flags == 0 &&
        completionproc == NULL);

    sendreq.overlapped = overlapped;
    sendreq.bufs = bufs;
    sendreq.bufcnt = bufcnt;
    sendreq.sendtotal = SockCountSendTotal(bufs, bufcnt);
    sendreq.toaddr = NULL;

    err = SockSend(pcb, &sendreq);
    if (NT_SUCCESS(err)) *bytesSent = sendreq.sendtotal;
    MapNtStatusToWinsockError_(err);
    WinsockApiExitSockUnlock_(NO_ERROR, SOCKET_ERROR);
}


int WSAAPI
sendto(
    SOCKET s,                        
    const char* buf,            
    int len,                         
    int flags,                       
    const struct sockaddr* to,  
    int tolen                        
    )

/*++

Routine Description:

    Refer to XAPI SDK documentation.

--*/

{
    DWORD count;
    INT err;
    WSABUF wsabuf;

    WinsockApiPrologLight_(sendto);
    WinsockApiParamCheck_(len > 0 && buf != NULL || len == 0);

    wsabuf.len = len;
    wsabuf.buf = (char*) buf;
    err = WSASendTo(s, &wsabuf, 1, &count, flags, to, tolen, NULL, NULL);
    return (err == NO_ERROR) ? count : SOCKET_ERROR;
}


int WSAAPI
WSASendTo(
    SOCKET s,                   
    LPWSABUF bufs,           
    DWORD bufcnt,       
    LPDWORD bytesSent, 
    DWORD flags,             
    const struct sockaddr* toaddr,               
    int tolen,              
    LPWSAOVERLAPPED overlapped,        
    LPWSAOVERLAPPED_COMPLETION_ROUTINE completionproc  
    )

/*++

Routine Description:

    Refer to XAPI SDK documentation.

--*/

{
    struct sockaddr_in* sin = (struct sockaddr_in*) toaddr;
    SENDREQ sendreq;
    WinsockApiPrologSockLock_(WSASendTo, SOCKET_ERROR);

    WinsockApiParamCheck_(
        SockCheckSendWsaBuf(bufs, bufcnt) &&
        bytesSent != NULL &&
        flags == 0 &&
        (toaddr == NULL ||
         tolen >= SOCKADDRLEN && sin->sin_family == AF_INET) &&
        completionproc == NULL);

    sendreq.overlapped = overlapped;
    sendreq.bufs = bufs;
    sendreq.bufcnt = bufcnt;
    sendreq.sendtotal = SockCountSendTotal(bufs, bufcnt);

    if (IsTcb(pcb) || toaddr == NULL) {
        // For TCP sockets, WSASendTo is equivalent to WSASend.
        // We simply ignore lpTo and iToLen parameters.
        //
        // Also, if toaddr parameter is NULL, we treat WSASendTo
        // the same way as WSASend.

        sendreq.toaddr = NULL;
        err = SockSend(pcb, &sendreq);
    } else {
        // Must do this check because downstream code
        // doesn't expect the destination address to be 0.
        // Also, we consider sending to UDP port 0 an error.
        if (sin->sin_addr.s_addr == 0 ||
            sin->sin_port == 0 && pcb->type == SOCK_DGRAM) {
            WinsockApiGotoExit_(WSAEADDRNOTAVAIL);
        }

        // Is this socket allowed to send broadcast
        // datagrams on this socket?
        if (IS_BCAST_IPADDR(sin->sin_addr.s_addr) && !pcb->broadcast) {
            WinsockApiGotoExit_(WSAEACCES);
        }

        // If the socket is not bound, bind it here
        if (!IsPcbBound(pcb)) {
            err = PcbBind(pcb, 0, 0);
            if (!NT_SUCCESS(err)) {
                MapNtStatusToWinsockError_(err);
                goto exit;
            }
        }

        // Send to the new destination
        sendreq.toaddr = sin;
        err = SockSend(pcb, &sendreq);
    }
        
    if (NT_SUCCESS(err)) *bytesSent = sendreq.sendtotal;
    MapNtStatusToWinsockError_(err);
    WinsockApiExitSockUnlock_(NO_ERROR, SOCKET_ERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\winsock\xnet\makefile.inc ===
$(XDK_LIB_PATH)\$(TARGETNAME).lib: $(SDK_LIB_PATH)\$(TARGETNAME).lib
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\winsock\sources.inc ===
!include ..\..\sources.inc

SYNCHRONIZE_DRAIN=1
C_DEFINES=$(C_DEFINES) -D_XNET_SERVICE

INCLUDES=..; \
    $(INCLUDES); \
    ..\..\tcp

PRECOMPILED_INCLUDE=..\precomp.h

SOURCES=\
    ..\sockinit.c \
    ..\socket.c \
    ..\sockopt.c \
    ..\recv.c \
    ..\send.c \
    ..\connect.c \
    ..\select.c \
    ..\sockmisc.c \
    ..\enumprot.c \
    ..\getxbyy.c

USE_NOLIBS=1
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\winsock\sockopt.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    sockopt.c

Abstract:

    Implement the following Winsock APIs
        setsockopt
        getsockopt
        ioctlsocket
        WSAIoctl

Revision History:

    06/01/2000 davidx
        Created it.

--*/

#include "precomp.h"


int WSAAPI
setsockopt(
    SOCKET s,                 
    int level,                
    int optname,              
    const char* optval,  
    int optlen                
    )

/*++

Routine Description:

    Refer to XAPI SDK documentation.

--*/

{
    INT val;
    WinsockApiPrologSockLock_(setsockopt, SOCKET_ERROR);
    WinsockApiParamCheck_(optval != NULL && optlen > 0);

    if (optlen < (INT) sizeof(INT))
        val = (UCHAR) *optval;
    else
        val = *((INT*) optval);

    switch (level) {
    case SOL_SOCKET:

        // NOTE: Some options may not be applicable to datagram sockets,
        // while others may not be applicable to stream sockets. But
        // we'll let apps set those options here anyway (to avoid extra
        // checking code). Downstream code just won't use those options.

        switch (optname) {
        case SO_BROADCAST:
            if (IsTcb(pcb)) goto noopt;
            pcb->broadcast = val;
            break;

        case SO_DONTLINGER:
            pcb->linger.l_onoff = (u_short) !val;
            break;

        case SO_LINGER:
            WinsockApiParamCheck_(optlen >= sizeof(LINGER));
            CopyMem(&pcb->linger, optval, sizeof(LINGER));
            break;

        case SO_REUSEADDR:
            if (pcb->exclusiveAddr && val != 0) goto inval;
            pcb->reuseAddr = val;
            break;

        case SO_EXCLUSIVEADDRUSE:
            if (pcb->reuseAddr && val != 0) goto inval;
            pcb->exclusiveAddr = val;
            break;
        
        case SO_RCVTIMEO:
            // Timeout value is in milliseconds
            WinsockApiParamCheck_(optlen >= sizeof(INT));
            pcb->recvTimeout = val;
            break;

        case SO_SNDTIMEO:
            // Timeout value is in milliseconds
            WinsockApiParamCheck_(optlen >= sizeof(INT));
            pcb->sendTimeout = val;
            break;

        case SO_RCVBUF:
            WinsockApiParamCheck_(optlen >= sizeof(INT));
            err = PcbUpdateBufferSize(pcb, pcb->maxSendBufsize, val);
            if (!NT_SUCCESS(err)) goto inval;
            break;

        case SO_SNDBUF:
            WinsockApiParamCheck_(optlen >= sizeof(INT));
            err = PcbUpdateBufferSize(pcb, val, pcb->maxRecvBufsize);
            if (!NT_SUCCESS(err)) goto inval;
            break;

        // case SO_OOBINLINE:
        // case SO_KEEPALIVE:
        // case SO_DONTROUTE:
        // case SO_RCVLOWAT:
        // case SO_SNDLOWAT:
        default:
            goto noopt;
        }
        break;

    case IPPROTO_TCP:
        if (IsDgramPcb(pcb)) goto noopt;

        switch (optname) {
        case TCP_NODELAY:
            pcb->noNagle = val;
            break;

        default:
            goto noopt;
        }
        break;

    case IPPROTO_IP:
        switch (optname) {
        case IP_DONTFRAGMENT:
            // NOTE: For TCP sockets, DF bit is controlled
            // by the path MTU discovery mechanism. So
            // we don't allow apps to muck with it.
            if (IsTcb(pcb)) goto inval;
            pcb->ipDontFrag = val;
            break;

        case IP_TTL:
            if (val < 0 || val > 255) goto inval;
            pcb->ipTtl = (BYTE) val;
            break;

        case IP_TOS:
            if (val < 0 || val > 255) goto inval;
            pcb->ipTos = (BYTE) val;
            break;

        case IP_OPTIONS:
            // NOTE:
            // - We allocate pool memory for holding the option data.
            // - We are not validating the IP option data here.
            if (optlen > MAXIPHDRLEN-IPHDRLEN) goto inval;
            PcbFreeIpOpts(pcb);
            if (optlen) {
                PcbSetIpOpts(pcb, optval, optlen);
            }
            break;

        case IP_HDRINCL:
            if (pcb->type != SOCK_RAW) goto noopt;
            pcb->ipHdrIncl = val;
            break;

        case IP_MULTICAST_TTL:
            if (IsTcb(pcb)) goto noopt;
            if (val < 0 || val > 255) goto inval;
            pcb->mcastTtl = (BYTE) val;
            break;

        case IP_MULTICAST_LOOP:
            if (IsTcb(pcb)) goto noopt;
            pcb->noMcastLoopback = !val;
            break;

        case IP_MULTICAST_IF:
            WinsockApiParamCheck_(optlen >= sizeof(struct in_addr));
            if (IsTcb(pcb)) goto noopt;

            err = PcbSetMcastIf(pcb, ((struct in_addr*) optval)->s_addr);
            MapNtStatusToWinsockError_(err);
            break;

        case IP_ADD_MEMBERSHIP:
        case IP_DROP_MEMBERSHIP: {
            struct ip_mreq* mreq;

            WinsockApiParamCheck_(optlen >= sizeof(struct ip_mreq));
            if (IsTcb(pcb)) goto noopt;

            mreq = (struct ip_mreq*) optval;
            err = PcbChangeMcastGroup(
                    pcb,
                    mreq->imr_multiaddr.s_addr,
                    mreq->imr_interface.s_addr,
                    optname == IP_ADD_MEMBERSHIP);

            MapNtStatusToWinsockError_(err);
            }
            break;

        default:
            goto noopt;
        }
        break;

    default:
        goto inval;
    }

    WinsockApiExitSockUnlock_(NO_ERROR, SOCKET_ERROR);

inval:
    err = WSAEINVAL;
    goto exit;

noopt:
    err = WSAENOPROTOOPT;
    goto exit;
}


int WSAAPI
getsockopt(
    SOCKET s,         
    int level,        
    int optname,      
    char* optval, 
    int* optlen  
    )

/*++

Routine Description:

    Refer to XAPI SDK documentation.

--*/

{
    INT val;
    WinsockApiPrologSockLock_(getsockopt, SOCKET_ERROR);

    WinsockApiParamCheck_(
        optval != NULL &&
        optlen != NULL &&
        *optlen > 0);

    ZeroMem(optval, *optlen);

    switch (level) {
    case SOL_SOCKET:

        switch (optname) {
        case SO_BROADCAST:
            if (IsTcb(pcb)) goto noopt;
            val = pcb->broadcast;
            break;

        case SO_DONTLINGER:
            val = !pcb->linger.l_onoff;
            break;

        case SO_LINGER:
            WinsockApiParamCheck_(*optlen >= sizeof(LINGER));
            CopyMem(optval, &pcb->linger, sizeof(LINGER));
            *optlen = sizeof(LINGER);
            goto exit;

        case SO_REUSEADDR:
            val = pcb->reuseAddr;
            break;

        case SO_EXCLUSIVEADDRUSE:
            val = pcb->exclusiveAddr;
            break;

        case SO_RCVTIMEO:
            WinsockApiParamCheck_(*optlen >= sizeof(INT));
            val = pcb->recvTimeout;
            break;

        case SO_SNDTIMEO:
            WinsockApiParamCheck_(*optlen >= sizeof(INT));
            val = pcb->sendTimeout;
            break;

        case SO_RCVBUF:
            WinsockApiParamCheck_(*optlen >= sizeof(INT));
            val = pcb->maxRecvBufsize;
            break;

        case SO_SNDBUF:
            WinsockApiParamCheck_(*optlen >= sizeof(INT));
            val = pcb->maxSendBufsize;
            break;

        case SO_TYPE:
            val = pcb->type;
            break;

        case SO_ACCEPTCONN:
            if (IsDgramPcb(pcb)) goto noopt;
            val = IsTcpListenState(pcb);
            break;

        // case SO_MAXDG:
        // case SO_MAXPATHDG:
        // case SO_OOBINLINE:
        // case SO_KEEPALIVE:
        // case SO_DONTROUTE:
        // case SO_RCVLOWAT:
        // case SO_SNDLOWAT:
        default:
            goto noopt;
        }
        break;

    case IPPROTO_TCP:
        if (IsDgramPcb(pcb)) goto noopt;

        switch (optname) {
        case TCP_NODELAY:
            val = pcb->noNagle;
            break;

        default:
            goto noopt;
        }
        break;

    case IPPROTO_IP:
        switch (optname) {
        case IP_DONTFRAGMENT:
            val = pcb->ipDontFrag;
            break;

        case IP_TTL:
            val = pcb->ipTtl;
            break;

        case IP_TOS:
            val = pcb->ipTos;
            break;

        case IP_OPTIONS:
            if (*optlen < (INT) pcb->ipoptlen)  {
                err = WSAEFAULT;
            } else if (pcb->ipopts) {
                CopyMem(optval, pcb->ipopts, pcb->ipoptlen);
            }
            *optlen = pcb->ipoptlen;
            goto exit;

        case IP_HDRINCL:
            if (pcb->type != SOCK_RAW) goto noopt;
            val = pcb->ipHdrIncl;
            break;

        case IP_MULTICAST_TTL:
            if (IsTcb(pcb)) goto noopt;
            val = pcb->mcastTtl;
            break;

        case IP_MULTICAST_LOOP:
            if (IsTcb(pcb)) goto noopt;
            val = !pcb->noMcastLoopback;
            break;

        case IP_MULTICAST_IF:
            WinsockApiParamCheck_(*optlen >= IPADDRLEN);
            if (IsTcb(pcb)) goto noopt;
            val = pcb->mcastData ? pcb->mcastData->mcastIfAddr : 0;
            break;

        // case IP_ADD_MEMBERSHIP:
        // case IP_DROP_MEMBERSHIP:
        default:
            goto noopt;
        }
        break;

    default:
        err = WSAEINVAL;
        goto exit;
    }

    if (*optlen < sizeof(INT)) {
        *optval = (CHAR) val;
        *optlen = 1;
    } else {
        *((INT*) optval) = val;
        *optlen = sizeof(INT);
    }

    WinsockApiExitSockUnlock_(NO_ERROR, SOCKET_ERROR);

noopt:
    err = WSAENOPROTOOPT;
    goto exit;
}


//
// NOTE: Special ioctlsocket command for enabling and disabling
// IP source address filtering on datagram sockets.
//
#define FIOFILTER _IOW('x', 1, u_long)


int WSAAPI
ioctlsocket(
    SOCKET s,         
    long cmd,         
    u_long* argp  
    )

/*++

Routine Description:

    Refer to XAPI SDK documentation.

--*/

{
    KIRQL irql;
    UINT bytesReady;

    WinsockApiPrologSockLock_(ioctlsocket, SOCKET_ERROR);
    WinsockApiParamCheck_(argp != NULL);

    switch (cmd) {
    case FIONBIO:
        pcb->nonblocking = *argp;
        break;

    case FIONREAD:
        irql = RaiseToDpc();
        if (IsDgramPcb(pcb)) {
            // For UDP/RAW sockets, return the size of the first buffered datagram
            // NOTE: For compatibility with win2k behavior, if the first datagram
            // is 0-sized, we'll return 1.
            if (IsDgramRecvBufEmpty(pcb)) {
                bytesReady = 0;
            } else {
                bytesReady = ((RECVBUF*) pcb->recvbuf.Flink)->datalen;
                if (bytesReady == 0) bytesReady = 1;
            }
        } else {
            // For TCP sockets, return the total number of bytes
            // available for reading.
            bytesReady = pcb->recvbufSize;
        }
        LowerFromDpc(irql);
        *argp = bytesReady;
        break;
    
    // case SIOCATMARK:
    default:
        WinsockApiGotoExit_(WSAENOPROTOOPT);
        break;
    }

    WinsockApiExitSockUnlock_(NO_ERROR, SOCKET_ERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\winsock\sockp.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    sockp.h

Abstract:

    Declarations internal to Winsock implementation

Revision History:

    05/30/2000 davidx
        Created it.

--*/

#ifndef _SOCKP_H
#define _SOCKP_H

//------------------------------------------------------------------------
// Per-thread Winsock data
//------------------------------------------------------------------------

typedef struct _WinsockThreadbuf {
    CHAR* data;
    UINT size;
} WinsockThreadbuf;

typedef struct _WinsockTlsData {
    WinsockThreadbuf strbuf;
    WinsockThreadbuf hostentbuf;
    WinsockThreadbuf serventbuf;
    WinsockThreadbuf protoentbuf;
} WinsockTlsData;

WinsockTlsData* SockAllocThreadData();
VOID SockFreeThreadData(WinsockTlsData* tlsData);

#if defined(BUILD_FOR_DEBUGGER)

INLINE WinsockTlsData* SockGetThreadData() {
    return (WinsockTlsData*) DmGetCurrentDmtd()->WinSockData;
}

INLINE VOID SockSetThreadData(WinsockTlsData* tlsData) {
    DmGetCurrentDmtd()->WinSockData = tlsData;
}

#else // !BUILD_FOR_DEBUGGER

extern __declspec(thread) WinsockTlsData* WinsockTlsDataPtr;

INLINE WinsockTlsData* SockGetThreadData() {
    return WinsockTlsDataPtr;
}

INLINE VOID SockSetThreadData(WinsockTlsData* tlsData) {
    WinsockTlsDataPtr = tlsData;
}

#endif // !BUILD_FOR_DEBUGGER

// Allocate per-thread temporary buffer
VOID* SockAllocThreadbuf(WinsockThreadbuf* buf, UINT size);

//------------------------------------------------------------------------
// Map an API-level socket handle to
// a pointer to our internal socket data structure
//------------------------------------------------------------------------

INLINE PCB* SockLock(SOCKET s) {
    PCB* pcb;
    INT err;
    LONG cookie;

    // NOTE: We don't allow multiple threads to access the same
    // socket simultaneously. If the app tries to do that, the first
    // thread will succeed and other threads will get an error return.

    if (s == 0 || s == INVALID_SOCKET) {
        err = WSAENOTSOCK;
    } else {
        pcb = (PCB*) s;
        cookie = InterlockedCompareExchange(
                    &pcb->magicCookie,
                    BUSY_PCB_COOKIE,
                    ACTIVE_PCB_COOKIE);

        if (cookie == ACTIVE_PCB_COOKIE) return pcb;
        err = (cookie == BUSY_PCB_COOKIE) ? WSAEINPROGRESS : WSAENOTSOCK;
    }

    #if DBG
    #if !defined(BUILD_FOR_DEBUGGER)
    if (err == WSAEINPROGRESS) {
        WARNING_("Thread contention on socket handle: tid = %x, socket = %x",
                 GetCurrentThreadId(), s);
    } else
    #endif
    {
        WARNING_("Invalid socket handle: socket = %x, error = %d", s, err);
    }
    #endif

    SetLastError(err);
    return NULL;
}

INLINE VOID SockUnlock(PCB* pcb) {
    pcb->magicCookie = ACTIVE_PCB_COOKIE;
}

//
// Socket address length
//
#define SOCKADDRLEN ((INT) sizeof(SOCKADDR_IN))

//
// Network stack initialization state
//
extern LONG XnetInitState;

#define XNETSTATE_INVALID   0   // not initialized
#define XNETSTATE_READY     1   // successfully initialized

//
// Find a supported protocol that matches the specified parameters
//
INT
MatchTcpipProtocol(
    IN INT af,
    IN INT type,
    IN INT protocol,
    OUT const WSAPROTOCOL_INFOW** protoinfo
    );

//------------------------------------------------------------------------
// Prolog and epilog code for Winsock API functions
//------------------------------------------------------------------------

INT SockEnterApiSlow(WinsockTlsData** tlsData);

#if DBG

#define SOCKTRACE_WSAStartup                BIT(0)
#define SOCKTRACE_WSACleanup                BIT(0)
#define SOCKTRACE_socket                    BIT(1)
#define SOCKTRACE_closesocket               BIT(1)
#define SOCKTRACE_shutdown                  BIT(1)
#define SOCKTRACE_setsockopt                BIT(2)
#define SOCKTRACE_getsockopt                BIT(2)
#define SOCKTRACE_ioctlsocket               BIT(2)
#define SOCKTRACE_WSARecv                   BIT(3)
#define SOCKTRACE_WSARecvFrom               BIT(3)
#define SOCKTRACE_recv                      BIT(3)
#define SOCKTRACE_recvfrom                  BIT(3)
#define SOCKTRACE_WSASend                   BIT(4)
#define SOCKTRACE_WSASendTo                 BIT(4)
#define SOCKTRACE_send                      BIT(4)
#define SOCKTRACE_sendto                    BIT(4)
#define SOCKTRACE_bind                      BIT(5)
#define SOCKTRACE_connect                   BIT(5)
#define SOCKTRACE_listen                    BIT(5)
#define SOCKTRACE_accept                    BIT(5)
#define SOCKTRACE_getsockname               BIT(5)
#define SOCKTRACE_getpeername               BIT(5)
#define SOCKTRACE_select                    BIT(6)
#define SOCKTRACE_WSAGetOverlappedResult    BIT(6)
#define SOCKTRACE_WSACancelOverlappedIO     BIT(6)
#define SOCKTRACE_inet_addr                 BIT(7)
#define SOCKTRACE_inet_ntoa                 BIT(7)
#define SOCKTRACE_gethostbyaddr             BIT(7)
#define SOCKTRACE_gethostbyname             BIT(7)
#define SOCKTRACE_gethostname               BIT(7)
#define SOCKTRACE_getprotoby_               BIT(7)
#define SOCKTRACE_getprotobyname            BIT(7)
#define SOCKTRACE_getprotobynumber          BIT(7)
#define SOCKTRACE_getservby_                BIT(7)
#define SOCKTRACE_getservbyname             BIT(7)
#define SOCKTRACE_getservbyport             BIT(7)
#define SOCKTRACE_WSAEnumProtocols          BIT(7)
#define SOCKTRACE_XnetInitialize            BIT(8)
#define SOCKTRACE_XnetCleanup               BIT(8)
#define SOCKTRACE_XnetGetIpAddress          BIT(8)

extern INT _winsockTraceFlag;

#define WinsockApiProlog_(_apiname, _result) \
        static const CHAR* fname_ = #_apiname; \
        WinsockTlsData* tlsData; \
        INT err; \
        if (_winsockTraceFlag & SOCKTRACE_##_apiname) { \
            DbgPrint("Entering %s...\n", fname_); \
        } \
        err = (XnetInitState == XNETSTATE_INVALID) ? WSASYSNOTREADY : \
              ((tlsData = SockGetThreadData()) != NULL) ? NO_ERROR : \
              SockEnterApiSlow(&tlsData); \
        WinsockApiCheckError_(_result)

#define WinsockApiPrologLight_(_apiname) \
        static const CHAR* fname_ = #_apiname; \
        if (_winsockTraceFlag & SOCKTRACE_##_apiname) { \
            DbgPrint("Entering %s...\n", fname_); \
        }

#define WinsockApiWarnError_(_err) { \
            if ((_err) != WSA_IO_PENDING && \
                (_err) != WSA_IO_INCOMPLETE && \
                (_err) != WSAETIMEDOUT && \
                (_err) != WSAEWOULDBLOCK) { \
                WARNING_("%s failed: %d", fname_, _err); \
            } \
        }

#define WinsockApiParamCheck_(_exp) { \
            if (!(_exp)) { \
                DbgPrint("%s: %s\n", fname_, #_exp); \
                RIP("bad winsock parameters\n"); \
            } \
        }

#else // !DBG

#define WinsockApiProlog_(_apiname, _result) \
        WinsockTlsData* tlsData; \
        INT err; \
        err = (XnetInitState == XNETSTATE_INVALID) ? WSASYSNOTREADY : \
              ((tlsData = SockGetThreadData()) != NULL) ? NO_ERROR : \
              SockEnterApiSlow(&tlsData); \
        WinsockApiCheckError_(_result)

#define WinsockApiPrologLight_(_apiname)
#define WinsockApiWarnError_(_err)
#define WinsockApiParamCheck_(_exp)

#endif // !DBG

#define WinsockApiReturnError_(_err, _result) { \
            WinsockApiWarnError_(_err); \
            SetLastError(_err); \
            return (_result); \
        }

#define WinsockApiCheckError_(_result) { \
            if (err != NO_ERROR) { \
                WinsockApiReturnError_(err, _result); \
            } \
        }

#define WinsockApiPrologSockLock_(_apiname, _result) \
        PCB* pcb; \
        WinsockApiProlog_(_apiname, _result); \
        pcb = SockLock(s); \
        if (!pcb) return (_result)

#define WinsockApiExitSockUnlock_(_resultOk, _resultErr) \
        exit: SockUnlock(pcb); \
        WinsockApiCheckError_(_resultErr); \
        return (_resultOk)

#define WinsockApiGotoExit_(_err) \
        { err = (_err); goto exit; }

#define MapNtStatusToWinsockError_(_err) \
        ((_err) = NT_SUCCESS(_err) ? NO_ERROR : RtlNtStatusToDosError(_err))

#endif // !_SOCKP_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\winsock\sockinit.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    sockinit.c

Abstract:

    Winsock initialization and cleanup related functions

Revision History:

    05/24/2000 davidx
        Created it.

--*/

#include "precomp.h"
#include "phy.h"
#include <xboxverp.h>

#pragma comment(linker, "/include:_XnetBuildNumber")
#pragma data_seg(".XBLD$V")

#if DBG
unsigned short XnetBuildNumber[8] =
        { 'X' | ('N' << 8), 'E' | ('T' << 8), 'D', 0, VER_PRODUCTVERSION | 0x8000 };
#else
unsigned short XnetBuildNumber[8] =
        { 'X' | ('N' << 8), 'E' | ('T' << 8),   0, 0, VER_PRODUCTVERSION };
#endif

#pragma data_seg()

//
// Linker directive to merge XNET_RD section into XNET section
//
#pragma comment(linker, "/merge:XNET_RD=XNET")

//
// Global variable definitions
//
LONG XnetInitCount = 0;
LONG WsaStartupCount = 0;
WORD WinsockVersion = WINSOCK_VERSION;
LONG XnetInitState = XNETSTATE_INVALID;
INITIALIZED_CRITICAL_SECTION(WinsockInitLock);
UINT cfgXnetConfigFlags;

// BUGBUG: temporary workaround for nv2a snooping bug
VOID* (*XnetUncachedAllocProc)(SIZE_T, ULONG);
VOID (*XnetUncachedFreeProc)(VOID*);

#if DBG
INT _winsockTraceFlag = 0;
#endif

#ifdef BUILD_FOR_DEBUGGER
UINT defaultPacketAllocFlag = PKTFLAG_DBGMON;
#else
UINT defaultPacketAllocFlag = 0;
__declspec(thread) WinsockTlsData* WinsockTlsDataPtr;
#endif

//
// Stuff we need to cleanup our per-thread data
// when a thread is deleted.
//
VOID WinsockThreadDetach();

#ifndef BUILD_FOR_DEBUGGER
PRIVATE XTHREAD_NOTIFICATION WinsockThreadNotification;
PRIVATE BOOL WinsockThreadNotifyRegistered;
PRIVATE VOID WINAPI WinsockThreadNotifyProc(BOOL Create) {
    if (!Create) WinsockThreadDetach();
}
#endif

//
// Acquire and release global initialization lock
//
INLINE LONG AcquireWinsockInitLock() {
    EnterCriticalSection(&WinsockInitLock);
    return XnetInitState;
}

INLINE VOID ReleaseWinsockInitLock(LONG state) {
    XnetInitState = state;
    LeaveCriticalSection(&WinsockInitLock);
}


PRIVATE VOID
XnetCleanupInternal()

/*++

Routine Description:

    Internal function to unload the XBox network stack

Arguments:

    NONE

Return Value:

    NONE

--*/

{
    KIRQL irql;

    DnsCleanup();

    // Forcefully close all open sockets
    PcbCloseAll();

    // Clean up the TCP/IP stack
    irql = RaiseToDpc();
    TcpCleanup();
    XnetPoolCleanup();
    #ifdef DVTSNOOPBUG
    XnetUncachedPoolCleanup();
    #endif
    LowerFromDpc(irql);

    WinsockThreadDetach();

    #ifndef BUILD_FOR_DEBUGGER

    if (WinsockThreadNotifyRegistered) {
        XRegisterThreadNotifyRoutine(&WinsockThreadNotification, FALSE);
        WinsockThreadNotifyRegistered = FALSE;
    }

    #endif // !BUILD_FOR_DEBUGGER
}


INT WSAAPI
XnetInitialize(
    const XnetInitParams* initParams,
    BOOL wait
    )

/*++

Routine Description:

    Load XBox network stack

Arguments:

    initParams - Optional initialization parameters
    wait - Whether to wait for the initialization to complete

Return Value:

    Winsock error code

--*/

{
    NTSTATUS status;
    LONG xnetstate;

    xnetstate = AcquireWinsockInitLock();

    // If this is the first XnetInitialize call,
    // initialize the network stack now.

    if (xnetstate == XNETSTATE_INVALID) {
        ASSERT(XnetInitCount == 0);

        #ifndef BUILD_FOR_DEBUGGER

        WinsockThreadNotification.pfnNotifyRoutine = WinsockThreadNotifyProc;
        XRegisterThreadNotifyRoutine(&WinsockThreadNotification, TRUE);
        WinsockThreadNotifyRegistered = TRUE;

        #endif // !BUILD_FOR_DEBUGGER

        // Use the specified configuration parameters
        if (initParams && initParams->structSize == sizeof(XnetInitParams)) {
            // private pool size
            if (initParams->privatePoolSize)
                cfgXnetPoolSize = initParams->privatePoolSize;

            // Ethernet receive queue length
            if (initParams->enetRecvQLength)
                cfgRecvQLength = initParams->enetRecvQLength;

            // max IP reassembly size
            if (initParams->maxIPReassemblySize &&
                initParams->maxIPReassemblySize <= (MAXIPLEN-MAXIPHDRLEN))
                cfgMaxReassemblySize = initParams->maxIPReassemblySize;

            // max IP reassembly datagrams
            if (initParams->maxIPReassemblyDgrams)
                cfgMaxReassemblyDgrams = initParams->maxIPReassemblyDgrams;

            // default send/recv buffer sizes
            if (initParams->defaultSocketRecvBufSize > 0 &&
                initParams->defaultSocketRecvBufSize <= cfgMaxSendRecvBufsize)
                cfgDefaultRecvBufsize = initParams->defaultSocketRecvBufSize;

            if (initParams->defaultSocketSendBufSize > 0 &&
                initParams->defaultSocketSendBufSize <= cfgMaxSendRecvBufsize)
                cfgDefaultSendBufsize = initParams->defaultSocketSendBufSize;

            // default IP datagram TTL and TOS
            cfgDefaultTtl = initParams->defaultIpTTL;
            cfgDefaultTos = initParams->defaultIpTOS;

            // max number of sockets
            if (initParams->maxSockets)
                cfgMaxSockets = initParams->maxSockets;

            // configuration flags
            if (initParams->configFlags)
                cfgXnetConfigFlags = initParams->configFlags;
        }

        XnetInitRandSeed();

        // Initialize our private pool
        status = XnetPoolInit();
        if (!NT_SUCCESS(status)) goto failed;

        // Initialize the DNS client
        status = DnsInitialize();
        if (!NT_SUCCESS(status)) goto failed;

        // Initialize the TCP/IP stack
        status = TcpInitialize();
        if (!NT_SUCCESS(status)) goto failed;

        xnetstate = XNETSTATE_READY;
    }

    XnetInitCount++;
    ReleaseWinsockInitLock(xnetstate);

    // Wait for the initialization to complete if necessary
    if (wait) {
        IfInfo* ifp;
        status = NETERR(WSASYSNOTREADY);
        LOOP_THRU_INTERFACE_LIST(ifp)
            if (IfDhcpEnabled(ifp)) {
                status = DhcpWaitForAddress(ifp);
                break;
            }
        END_INTERFACE_LIST_LOOP()

        if (!NT_SUCCESS(status)) {
            XnetCleanup();
            return RtlNtStatusToDosError(status);
        }
    }

    return NO_ERROR;

failed:
    // Fail to initialize the network stack.
    // Cleanup before returning error.

    XnetCleanupInternal();
    ReleaseWinsockInitLock(xnetstate);
    return RtlNtStatusToDosError(status);
}


INT WSAAPI
XnetCleanup()

/*++

Routine Description:

    Public API function to unload the XBox network stack

Arguments:

    NONE

Return Value:

    Winsock error code

--*/

{
    INT err;
    LONG xnetstate;

    xnetstate = AcquireWinsockInitLock();

    if (xnetstate == XNETSTATE_INVALID) {
        ASSERT(XnetInitCount == 0);
        err = WSASYSNOTREADY;
    } else {
        if (XnetInitCount <= 0) {
            err = WSANOTINITIALISED;
        } else {
            if (--XnetInitCount == 0) {
                ASSERT(WsaStartupCount == 0);
                XnetCleanupInternal();
                xnetstate = XNETSTATE_INVALID;
            }
            err = NO_ERROR;
        }
    }

    ReleaseWinsockInitLock(xnetstate);
    return err;
}


VOID
WinsockThreadDetach()

/*++

Routine Description:

    This is called when a thread dies and we use the chance
    to clean up any per-thread Winsock data we may have allocated.

Arguments:

    NONE

Return Value:

    NONE

--*/

{
    WinsockTlsData* tlsData;
    if ((tlsData = SockGetThreadData()) != NULL) {
        SockSetThreadData(NULL);
        SockFreeThreadData(tlsData);
    }
}


int WSAAPI
WSAStartup(
    IN WORD wVersionRequired,
    OUT LPWSADATA lpWSAData
    )

/*++

Routine Description:

    Refer to XAPI SDK documentation.

--*/

{
    BYTE majorVersion = LOBYTE(wVersionRequired);
    BYTE minorVersion = HIBYTE(wVersionRequired);
    WinsockTlsData* tlsData;
    LONG xnetstate;
    INT err;

    WinsockApiPrologLight_(WSAStartup);
    WinsockApiParamCheck_(lpWSAData != NULL);

    xnetstate = AcquireWinsockInitLock();
    if (xnetstate == XNETSTATE_INVALID) {
        WinsockApiGotoExit_(WSASYSNOTREADY);
    }

    //
    // Version checks
    //
    switch (majorVersion) {
    case 0:
        WinsockApiGotoExit_(WSAVERNOTSUPPORTED);
        break;

    case 1:
        if (minorVersion > 1) minorVersion = 1;
        break;

    case 2:
        if (minorVersion > 2) minorVersion = 2;
        break;

    default:
        majorVersion = minorVersion = 2;
        break;
    }

    WinsockVersion = MAKEWORD(majorVersion, minorVersion);
    TRACE_("WSAStartup: version = %d.%d", majorVersion, minorVersion);

    //
    // Fill in the user structure
    //
    ZeroMem(lpWSAData, sizeof(WSADATA));
    lpWSAData->wVersion = WinsockVersion;
    lpWSAData->wHighVersion = WINSOCK_VERSION;

    if (majorVersion == 1) {
        // Hack for Winsock 1.1
        lpWSAData->iMaxSockets = 0x7fff;
        lpWSAData->iMaxUdpDg = MAXIPLEN-MAXIPHDRLEN-UDPHDRLEN;
    }

    strcpy(lpWSAData->szDescription, "WinSock 2.0");
    strcpy(lpWSAData->szSystemStatus, "Running");

    //
    // Initialize per-thread information
    //
    if ((tlsData = SockGetThreadData()) == NULL &&
        (tlsData = SockAllocThreadData()) == NULL) {
        WinsockApiGotoExit_(WSAENOBUFS);
    }

    SockSetThreadData(tlsData);
    WsaStartupCount++;
    err =  NO_ERROR;

exit:
    ReleaseWinsockInitLock(xnetstate);
    return err;
}


int WSAAPI
WSACleanup()

/*++

Routine Description:

    Refer to XAPI SDK documentation.

--*/

{
    LONG xnetstate;
    INT err;

    xnetstate = AcquireWinsockInitLock();

    if (xnetstate == XNETSTATE_INVALID) {
        err = WSASYSNOTREADY;
    } else {
        if (WsaStartupCount <= 0) {
            err = WSANOTINITIALISED;
        } else {
            if (--WsaStartupCount == 0) {
                // Last call to WSACleanup
                //  perform any necessary cleanup work
                PcbCloseAll();
                WinsockThreadDetach();
            }
            err = NO_ERROR;
        }
    }

    ReleaseWinsockInitLock(xnetstate);

    if (err != NO_ERROR) {
        WARNING_("WSACleanup failed: %d", err);
        SetLastError(err);
        err = SOCKET_ERROR;
    }
    return err;
}


INT
SockEnterApiSlow(
    OUT WinsockTlsData** tlsData
    )

/*++

Routine Description:

    Initialize per-thread Winsock data

Arguments:

    tlsData - Returns a pointer to the per-thread Winsock data

Return Value:

    Error code

--*/

{
    WinsockTlsData* data;

    if (WsaStartupCount <= 0)
        return WSANOTINITIALISED;

    //
    // If this thread has not been initialized, do it now.
    //
    if ((data = SockAllocThreadData()) == NULL)
        return WSAENOBUFS;

    SockSetThreadData(data);
    *tlsData = data;
    return NO_ERROR;
}


WinsockTlsData*
SockAllocThreadData()

/*++

Routine Description:

    Allocate memory for per-thread Winsock data

Arguments:

    NONE

Return Value:

    Pointer to newly created per-thread data structure
    NULL if there is an error

--*/

{
    WinsockTlsData* tlsData;

    tlsData = MAlloc0(sizeof(*tlsData));
    if (!tlsData) return NULL;

    // Perform additional initialization here
    return tlsData;
}


VOID
SockFreeThreadData(
    WinsockTlsData* tlsData
    )

/*++

Routine Description:

    Dispose of per-thread Winsock data

Arguments:

    tlsData - Points to the per-thread data structure to be disposed

Return Value:

    NONE

--*/

{
    if (tlsData) {
        SockSetThreadData(NULL);
        Free(tlsData->strbuf.data);
        Free(tlsData->hostentbuf.data);
        Free(tlsData->serventbuf.data);
        Free(tlsData->protoentbuf.data);
        Free(tlsData);
    }
}


VOID*
SockAllocThreadbuf(
    WinsockThreadbuf* buf,
    UINT size
    )

/*++

Routine Description:

    Allocate (or grow) a temporary per-thread memory buffer

Arguments:

    buf - Points to the buffer structure
    size - Specifies the desired size of the buffer

Return Value:

    Pointer to the buffer data if successful
    NULL if there is an error

--*/

{
    VOID* data;

    // Check if the existing buffer is already ok
    if (size <= buf->size) return buf->data;

    data = MAlloc(size);
    if (data) {
        Free(buf->data);
        buf->data = (CHAR*) data;
        buf->size = size;
    }
    return data;
}


//
// Debug spew functions
//
#if DBG

VOID XnetDbgWarn(CHAR* format, ...) {
    va_list args;
    va_start(args, format);
    vXDebugPrint(XDBG_WARNING, "XNET", format, args);
    va_end(args);
}

VOID XnetDbgVerbose(CHAR* format, ...) {
    va_list args;
    va_start(args, format);
    vXDebugPrint(XDBG_TRACE, "XNET", format, args);
    va_end(args);
}

VOID XnetDbgTrace(CHAR* format, ...) {
    va_list args;
    va_start(args, format);
    vXDebugPrint(XDBG_ENTRY, "XNET", format, args);
    va_end(args);
}

#endif // DBG


//
// NOTE: XnetGetEthernetLinkStatus is placed in the default .text code section.
// This is so that it can be called before XNET code section is loaded.
//
#pragma code_seg(".text")

DWORD WSAAPI
XnetGetEthernetLinkStatus()

/*++

Routine Description:

    Get Ethernet link status

Arguments:

    NONE

Return Value:

    TRUE if Ethernet port is connected to the network
    FALSE otherwise

--*/

{
    // If Xnet is not yet initialized, we may need to
    // initialize the PHY first.
    #ifndef SILVER
    if (XnetInitCount == 0) {
        PhyInitialize(FALSE, NULL);
    }
    #endif

    return PhyGetLinkState(FALSE);
}

#pragma code_seg()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xnet\winsock\sockmisc.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    sockmisc.c

Abstract:

    Miscellaneous Winsock functions:
        htonl
        htons
        ntohl
        ntohs
        inet_addr
        inet_ntoa
        WSAGetLastError
        WSASetLastError
        WSACreateEvent
        WSACloseEvent
        WSASetEvent
        WSAResetEvent
        WSAWaitForMultipleEvents
        __WSAFDIsSet

Revision History:

    05/30/2000 davidx
        Created it.

--*/

#include "precomp.h"


//
// Converts a u_long from host to network byte order
//
u_long WSAAPI htonl(IN u_long hostlong) {
    return HTONL(hostlong);
}

//
// Converts a u_short from host to network byte order 
//
u_short WSAAPI htons(IN u_short hostshort) {
    return HTONS(hostshort);
}

// 
// Converts a u_long from network order to host byte order 
//
u_long WSAAPI ntohl(IN u_long netlong) {
    return NTOHL(netlong);
}

//
// Converts a u_short from network byte order to host byte order
//
u_short WSAAPI ntohs(IN u_short netshort) {
    return NTOHS(netshort);
}

//
// Converts a string containing an (Ipv4) Internet Protocol
// dotted address into a proper address for the IN_ADDR structure.
//
unsigned long WSAAPI inet_addr(IN const char* cp) {
    IPADDR addr;

    WinsockApiPrologLight_(inet_addr);
    WinsockApiParamCheck_(cp != NULL);

    return IpAddrFromString(cp, &addr) ? addr : INADDR_NONE;
}

//
// Converts an (Ipv4) Internet network address into
// a string in Internet standard dotted format.
//
char* WSAAPI inet_ntoa(IN struct in_addr in) {
    WinsockApiProlog_(inet_ntoa, NULL);

    if (!SockAllocThreadbuf(&tlsData->strbuf, 16)) {
        WinsockApiReturnError_(WSAENOBUFS, NULL);
    }

    return IpAddrToString(in.s_addr, tlsData->strbuf.data, tlsData->strbuf.size);
}

//
// Gets the error status for the last operation that failed
//
int WSAAPI WSAGetLastError() {
    return GetLastError();
}

//
// Sets the error code that can be retrieved
// through the WSAGetLastError function
//
void WSAAPI WSASetLastError(IN int error) {
    SetLastError(error);
}

//
// Creates a new event object
//
WSAEVENT WSAAPI WSACreateEvent() {
    return CreateEvent(NULL, TRUE, FALSE, NULL);
}

//
// Closes an open event object handle
//
BOOL WSAAPI WSACloseEvent(IN WSAEVENT hEvent) {
    return CloseHandle(hEvent);
}

//
// Sets the state of the specified event object to signaled
//
BOOL WSAAPI WSASetEvent(IN WSAEVENT hEvent) {
    return SetEvent(hEvent);
}

//
// Resets the state of the specified event object to nonsignaled
//
BOOL WSAAPI WSAResetEvent(IN WSAEVENT hEvent) {
    return ResetEvent(hEvent);
}

//
// Returns either when one or all of the specified event objects
// are in the signaled state, or when the time-out interval expires
//
DWORD WSAAPI
WSAWaitForMultipleEvents(
    IN DWORD cEvents,
    IN const WSAEVENT* lphEvents,
    IN BOOL fWaitAll,
    IN DWORD dwTimeout,
    IN BOOL fAlertable
    )
{
    return WaitForMultipleObjectsEx(
                cEvents,
                lphEvents,
                fWaitAll,
                dwTimeout,
                fAlertable);
}

//
// Determines if a specific socket is a contained in an FD_SET
//
int WSAAPI __WSAFDIsSet(SOCKET fd, fd_set* set) {
    int i = (set->fd_count & 0xffff);
    while (i--){
        if (set->fd_array[i] == fd) return 1;
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xprof\xbbt.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    xbbt.h

Abstract:

    BBT support header file

--*/

#pragma once

#define IRTSYS
typedef ULONG DWORD;
typedef UCHAR BYTE;

#include <stdlib.h>
#include "bbtirt.h"
#include "idf.h"

//
// We allocate 32MB of memory for collecting BBT runtime data
//
#define IRT_BUFFER_SIZE (32*1024*1024)

//
// Background sweep timer frequency (in milliseconds)
//
#define IRT_SWEEP_INTERVAL 42

//
// Saved information about client-init parameters
//
typedef struct IRTCLIENTINFO {
    const IRTP* pirtp;
    DWORD*      rgCounts;
    BYTE*       rgTobCounts;
    DWORD*      rgSeqNums;
    IDFHDR*     pidfhdr;
    DWORD       currentTime;
    DWORD       tobSweepTime;
    DWORD       copyCountsTime;
    DWORD       intervalCount;
} IRTCLIENTINFO;

//
// Round up to a power of 2
//
#define CbRound(cb, cbAlign) (((cb) + ((cbAlign)-1)) & ~((cbAlign)-1))
#define CbRoundToPage(cb)    CbRound(cb, PAGE_SIZE)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xprof\idf.h ===
/***********************************************************************
* Microsoft BBT
*
* Microsoft Confidential.  Copyright (c) Microsoft Corporation.  All rights reserved.
*
* File Comments:
*
*
***********************************************************************/

#pragma once

#pragma pack(push, 4)

struct IDFHDR                          // Instrumentation Data File Header
{
   DWORD    dwSignature;               // ( 0) File signature
   DWORD    dwVersion;                 // ( 4)
   DWORD    dwId;                      // ( 8) Id of original image (.exe, .dll, .sys, ...)
   DWORD    ibszIdfKeyPath;            // ( C) Name of .IDFKEY file
   DWORD    dwGeneration;              // (10) Database generation
   DWORDLONG    qwStartTime;               // (14) Creation time of this data

   DWORD    tov;                       // (1C) Variety of time order instrumentation

   DWORD    cb;                        // (20) Size of valid data
   DWORD    cqwCount;                  // (24) Count of static edge counts
   DWORD    ibrgqwCount;               // (28) Offset to array of static edge count
   DWORD    ciblh;                     // (2C) Count of IBLHs
   DWORD    ibrgiblh;                  // (30) Offset to array of IBLHs
   DWORD    cible;                     // (34) Number of IBLE structs allocated
   DWORD    ctlhCode;                  // (38) Count of TLHs for code
   DWORD    ibrgtlhCode;               // (3C) Offset to array of TLHs for code
   DWORD    ctlhResource;              // (40) Count of TLHs for resources
   DWORD    ibrgtlhResource;           // (44) Offset to array of TLHs for resources
   DWORD    cthd;                      // (48) Count of THDs
   DWORD    ibthdHead;                 // (4C) Offset to first THD
   DWORD    cmsStartTime;              // (50) Tick count at initialization

   DWORD    ifunEndBoot;               // (54) Index of EndBoot function (from IRTP)
   DWORD    iSequenceEndBoot;          // (58) Seq number of the last boot time code or resource
   DWORD    iIntervalEndBoot;          // (5C) Last internal of boot sequence

   // The following data is used at runtime and appears here
   // so that it can be shared among multiple processes.

   DWORD    dwLock;                    // (60) Used to lock shared structures

   DWORD    cbAllocated;               // (64) Size of allocated (committed) memory
   DWORD    cbMax;                     // (68) Maximum size of memory region

   DWORD    cpsActive;                 // (6C) Count of processes using this data

   DWORD    fSweepPending;             // (70)
   DWORD    cthdActive;                // (74) Number of threads within runtime

   DWORD    cmsTimer;                  // (78) Timer interval in milliseconds
   DWORD    pidTimer;                  // (7C) Process ID of timer process or 0?
   DWORD    iIntervalCur;              // (80) Current time interval
   DWORD    cmsNextAttempt;            // (84)

   DWORD    iSequence;                 // (88) Sequence number of initial references
   DWORD    iIntervalStart;            // (8C) First valid time interval
   DWORD    iSequenceStart;            // (90) First valid sequence number

                                       // Runtime-only state for storage allocators

   DWORD    cbPermanentFree;           // (94) Base of permanent free page
   DWORD    cbPermanentLimit;          // (98) End of permanent free page
   DWORD    cbReclaimableFree;         // (9C) Base of reclaimable free page
   DWORD    cbReclaimableLimit;        // (A0) End of reclaimable free page
   DWORD    cbReclaimablePageHead;     // (A4) Head of linked list of reclaimable pages
   DWORD    cbReclaimablePageTail;     // (A8) Tail of linked list of reclaimable pages

                                       // Bitfields are implemented from LSB to MSB.
                                       // Since the position of LSB is different for little endian
                                       // and big endian processors, bit fields cannot be used for
                                       // IDF purposes. Instead, a series of chars are used instead.
   char     fBigEndian;                // (AC) Non-zero if collected data is big-endian
   char     fSweepable;                //      Non-zero if IDF is sweepable.
   char     fWinNTPerf;
   char     fFastRT;                   // Are we using the faster runtime?
   

   DWORDLONG hIdfFile;                 // (B0) HANDLE of open .IDF file

   DWORD    dwDynProbeCount;           // (B8) Number of TOB Probes to execute to increment time.
   DWORDLONG   pWinNTBufInterval;      // (BC) pinter to NT buffer timer interval.
   DWORD    ibineHead;                 
                                       
};

#pragma pack(pop)

#define szIrtMutexPrefix   "BBT30.Mtx."
#define szIrtFMutexPrefix  "BBT30.Ftx."
#define szIrtMemoryPrefix  "BBT30.Mem."
#define szIrtTimerApp      "bbtimr30"

#define wszIrtMutexPrefix  L"BBT30.Mtx."
#define wszIrtMemoryPrefix L"BBT30.Mem."
#define wszIrtTimerApp     L"bbtimr30"

#define szIdfIdTemplate    "%BBT_Idf_Id%"
#define szIdfKeyIdTemplate "%BBT_Key_Id%"
#define szIdfSuffix        ".idf"
#define szIdfKeySuffix     ".key"

#define dwIdfKeySignature       0xa97df1eb
#define dwIdfSignature          0x09040600
#define dwDIdfSignature         0x09040601
#define dwIdfVerCurrent         0x00001010  // This also much be changed in bbtirt.h

// Flag to indicate IDF originated with pogo runtime

#define dwIdfVerPogo            0x90000000


struct IBLH                            // Indirect Branch List Header
{
   DWORD    ibibleFirst;               // Offset to first IBLE
};


struct IBLE                            // Indirect Branch List Element
{
   DWORD    ibibleNext;                // Offset to next IBLE or 0
   DWORD    blkidSrc;
   DWORDLONG    qwCount;
};


#define cdwTob          4              // Keep 4 DWORDs for each TOB
#define cbitDw          32             // There are 32 bits in a DWORD

struct TOB                             // Time Order Bits
{
   DWORD    iInterval;                 // Time interval represented
   DWORD    rgdwBit[cdwTob];           // One bit for each time interval
};


struct TLH                             // Time List Header
{
   DWORD    ibtleFirst;                // Offset to first TLE
   DWORD    iSequenceInit;             // Initial sequence number
   DWORDLONG    qwTOBFanin;                // Directly measured fanin for this block
};


struct TLE                             // Time List Element
{
   DWORD    ibtleNext;                 // Offset to next TLE or 0
   TOB      tob;
};


struct THD
{

   DWORD    iBrc;                      // Last recorded branch
   DWORD    blkidSrc;                  // Last recorded indirect branch source
   DWORD    iDst;                      // Last recorded indirect branch target
   DWORD    ibthdNext;                 // Offset of next THD or 0
};


struct RPH
{
   DWORD    cbNext;
};


#ifndef TOV_DEFINED
#define TOV_DEFINED

enum TOV                               // Time Order Variety
{
   tovNone,
   tovFunction,
   tovBlock,
   tovEveryBlock,
   
   tov4Mask,
   tov4Fun,
   tov4Block,
   tov4EveryBlock,

   tovFunctionAndPostCall,
   tovThreadEveryBlock,

   tovCTO,                            // IRT to sweep counts for tobs
};

struct INE                             // Interval name entry
{
   DWORD ibineNext;
   DWORD iInterval;
   char  szName[16];
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xprof\xbbt.cpp ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    xbbt.cpp

Abstract:

    BBT instrumented binary runtime support functions

--*/

#ifdef _XBOX_ENABLE_PROFILING

#include "ntos.h"
#include "xprofp.h"
#include "xbbt.h"

#ifdef _XBOX_ENABLE_BBT

IRTCLIENTINFO* IrtClientInfo;   // Client-init information
LONG IrtSweepingFlag;           // Whether we're currently sweep data to disk
KTIMER IrtTimer;                // Background timer
KDPC IrtTimerDpc;               //  and associated DPC

#define IsIrtClientInited() (IrtClientInfo != NULL)
#define IrtAssert(cond) do { if (!(cond)) KeBugCheckEx(0, __LINE__, 'IRTS', 0, 0); } while(0)


//
// Allocate space for an additional TLE structure
//
TLE* PtleCreate(IDFHDR* pidfhdr, TLH* ptlh, DWORD iInterval)
{
    DWORD ibtleNew = InterlockedExchangeAdd( (PLONG)&pidfhdr->cb, sizeof(TLE) );
   
    IrtAssert(ibtleNew + sizeof(TLE) <= pidfhdr->cbMax);

    // Fill in the TLE
    TLE* ptle = (TLE*) ((BYTE*) pidfhdr + ibtleNew);
    ptle->ibtleNext = ptlh->ibtleFirst;
    ptle->tob.iInterval = (iInterval & 0xFFFFFF80);

    // Link it into the list
    ptlh->ibtleFirst = ibtleNew;

    return ptle;
}


//
// Sweep TOB data
//
#define PtlhFromIfun(pidfhdr, ifun) \
        ((TLH*) ((BYTE*) pidfhdr + pidfhdr->ibrgtlhCode) + ifun)

#define COPYTOBBITS() { \
        ptlh = PtlhFromIfun(pidfhdr, i); \
        ptlh->qwTOBFanin++; \
        ibtle = ptlh->ibtleFirst; \
        if (ibtle != 0) { \
            ptle = (TLE*) ((BYTE*) pidfhdr + ibtle); \
            dwTimeSlot = iIntervalCur - ptle->tob.iInterval; \
            if (dwTimeSlot < cdwTob * cbitDw) { \
                ptle->tob.rgdwBit[dwTimeSlot>>5] |= 1 << (dwTimeSlot & 0x1F); \
                continue; \
            } \
        } \
        ptle = PtleCreate(pidfhdr, ptlh, iIntervalCur); \
        dwTimeSlot = iIntervalCur - ptle->tob.iInterval; \
        ptle->tob.rgdwBit[dwTimeSlot>>5] |= 1 << (dwTimeSlot & 0x1F); \
        }

VOID
IrtCopyCurrentTOBBits(IRTCLIENTINFO* pci)
{
    // Figure out the current interval index
    IDFHDR* pidfhdr = pci->pidfhdr;
    const IRTP* pirtp = pci->pirtp;
    DWORD iIntervalCur = pci->tobSweepTime / pirtp->cmsTimer;
    pci->tobSweepTime %= pirtp->cmsTimer;

    pci->intervalCount += iIntervalCur;
    pidfhdr->iIntervalCur = iIntervalCur = pci->intervalCount - 1;

    BYTE* rgTobBytes = pci->rgTobCounts;
    DWORD* rgCounts = pci->rgCounts;
    DWORDLONG* pqwDest = (DWORDLONG*) ((BYTE*) pidfhdr + pidfhdr->ibrgqwCount);
    DWORD i, n, ibtle, dwTimeSlot;
    TLH* ptlh;
    TLE* ptle;
    
    n = pidfhdr->ctlhCode;
    if (pidfhdr->tov == tovCTO) {
        // Make tobs from the counts

        // for each TOB
        for (i=0; i < n; i++) {
            // tob bytes are intialized to 1 and set to 0 when hit.
            if (rgCounts[i]) {
                // this byte was hit in the last interval - reset it for the next interval
                // Save counts too!
                pqwDest[i] += rgCounts[i];
                rgCounts[i] = 0;

                COPYTOBBITS();
            }
        }
    } else {
        IrtAssert((pidfhdr->tov & tov4Mask) == 0);

        // for each TOB
        for (i=0; i < n; i++) {
            // tob bytes are intialized to 1 and set to 0 when hit.
            if (rgTobBytes[i] == 0) {
                //this byte was hit in the last interval - reset it for the next interval
                rgTobBytes[i] = 1;

                COPYTOBBITS();
            }
        }
    }
}


//
// Sweep static edge counts
//
VOID IrtCopyCounts(IRTCLIENTINFO* pci)
{
    DWORD* srcCounts = pci->rgCounts;
    IDFHDR* pidfhdr = pci->pidfhdr;
    DWORDLONG* dstCounts = (DWORDLONG*) ((BYTE*) pidfhdr + pidfhdr->ibrgqwCount);
    DWORD i, n;

    n = pidfhdr->cqwCount;
    for (i=0; i < n; i++) {
        *dstCounts++ += *srcCounts;
        *srcCounts++ = 0;
    }

    if (pci->rgSeqNums) {
        n = pidfhdr->ctlhCode;
        for (i=0; i < n; i++) {
            TLH* ptlh = PtlhFromIfun(pidfhdr, i);
            ptlh->iSequenceInit = pci->rgSeqNums[i+1];
        }

        pidfhdr->iSequence = pci->rgSeqNums[0];
    }

    pci->copyCountsTime = 0;
}


VOID
IrtTimerProc(
    PKDPC dpc,
    VOID* context,
    VOID* param1,
    VOID* param2
    )

/*++

Routine Description:

    IRT runtime background sweeping timer procedure

Arguments:

    See DDK documentation

Return Value:

    NONE

Notes:

    This function runs at dispatch level.

--*/

{
    IRTCLIENTINFO* pci = IrtClientInfo;
    IrtAssert(IsIrtClientInited());

    // Check if we need to do a sweep yet. Note that if we're currently
    // in the process of writing IDF data to disk, then skip this round.
    pci->currentTime += IRT_SWEEP_INTERVAL;
    pci->tobSweepTime += IRT_SWEEP_INTERVAL;
    pci->copyCountsTime += IRT_SWEEP_INTERVAL;

    if (IrtSweepingFlag) return;

    if (pci->tobSweepTime >= pci->pirtp->cmsTimer) {
        IrtCopyCurrentTOBBits(pci);
    }

    // Call IrtCopyCounts once every 4 seconds
    if (pci->copyCountsTime >= 4000) {
        IrtCopyCounts(pci);
    }
}


//
// Initialize IDF header information
//
VOID IrtInitializeIdfHeader(IRTCLIENTINFO* pci)
{
    DWORD cb = CbRoundToPage(sizeof(*pci));
    IDFHDR* pidfhdr = (IDFHDR*) ((BYTE*) pci + cb);
    pci->pidfhdr = pidfhdr;

    DWORD cbMax = IRT_BUFFER_SIZE - cb;
    memset(pidfhdr, 0, cbMax);

    const IRTP* pirtp = pci->pirtp;
    pidfhdr->dwSignature = dwIdfSignature;
    pidfhdr->dwVersion = dwIdfVerCurrent;
    pidfhdr->dwId = pirtp->dwId;
    pidfhdr->dwGeneration = pirtp->dwGeneration;
    pidfhdr->tov = pirtp->tov;
    pidfhdr->fSweepable = pirtp->fSweepable ? 1 : 0;

    // Calculate the minimum size for the shared memory region

    cb = CbRound(sizeof(IDFHDR), sizeof(DWORDLONG));
    if (pirtp->szIdfKeyPath) {
        pidfhdr->ibszIdfKeyPath = cb;
        cb += strlen(pirtp->szIdfKeyPath) + 1;
    }
    cb = CbRound(cb, sizeof(DWORDLONG));

    pidfhdr->cqwCount = pirtp->cbrc;
    pidfhdr->ibrgqwCount = cb;
    cb += pidfhdr->cqwCount * sizeof(DWORDLONG);

    // Save space for indirect branches
    pidfhdr->ciblh = pirtp->cibd ? pirtp->cibd : pirtp->cibs;

    pidfhdr->ibrgiblh = cb;
    cb += pidfhdr->ciblh * sizeof(IBLH);
    cb = CbRound(cb, sizeof(DWORDLONG));

    IrtAssert(pirtp->cmsTimer != 0);

    if (pirtp->cfun != 0) {
        pidfhdr->ctlhCode = pirtp->cfun;
        pidfhdr->ibrgtlhCode = cb;
        cb += pidfhdr->ctlhCode * sizeof(TLH);
        cb = CbRound(cb, sizeof(DWORDLONG));
    }

    if (pirtp->crsc != 0) {
        pidfhdr->ctlhResource = pirtp->crsc;
        pidfhdr->ibrgtlhResource = cb;
        cb += pidfhdr->ctlhResource * sizeof(TLH);
        cb = CbRound(cb, sizeof(DWORDLONG));
    }

    pidfhdr->cb = cb;

    // Calculate the minimum size for the shared memory region

    DWORD cbMin = cb + sizeof(THD);
    cbMin += pidfhdr->ciblh * sizeof(IBLE);

    if (pirtp->cfun != 0)
        cbMin += pidfhdr->ctlhCode * sizeof(TLE);

    if (pirtp->crsc != 0)
        cbMin += pidfhdr->ctlhResource * sizeof(TLE);

    IrtAssert(cbMin <= cbMax);

    pidfhdr->cbMax = cbMax;
    pidfhdr->cbAllocated = cbMax;
    pidfhdr->cmsTimer = pirtp->cmsTimer;
    pidfhdr->cpsActive = 1;
    pidfhdr->ifunEndBoot = pirtp->ifunEndBoot;
    pidfhdr->iSequenceEndBoot = (DWORD) -1;
    pidfhdr->iIntervalEndBoot = (DWORD) -1;
    pidfhdr->fFastRT = (pci->rgCounts != NULL);
    pidfhdr->iIntervalStart = pci->intervalCount;
    pidfhdr->cmsStartTime = pci->currentTime;
    KeQuerySystemTime((LARGE_INTEGER*) &pidfhdr->qwStartTime);

    if (pirtp->szIdfKeyPath) {
        strcpy((char*) pidfhdr + pidfhdr->ibszIdfKeyPath, pirtp->szIdfKeyPath);
    }
}


DWORD IrtClientNewIndFast(const IRTP* pirtp, DWORD rvaDest, long iIndSrc)
{
   if (IrtSweepingFlag) return 0;

   IRTCLIENTINFO* pci = IrtClientInfo;
   IDFHDR* pidfhdr = pci->pidfhdr;
   IBLH* rgiblh = (IBLH*) ((BYTE*) pidfhdr + pidfhdr->ibrgiblh);
   IBLH* piblh = rgiblh + iIndSrc;
   DWORD* pibible = &piblh->ibibleFirst;

   // Allocate a new ible
   DWORD ibible = InterlockedExchangeAdd((PLONG)&pidfhdr->cb, sizeof(IBLE));
   IrtAssert(ibible + sizeof(IBLE) <= pidfhdr->cbMax);

   IBLE *pible = (IBLE *) ((BYTE *) pidfhdr + ibible);

   // Fill in the IBLE

   pible->blkidSrc = rvaDest;
   pible->qwCount = 0;

   // Atomically add to the front of the list
   DWORD ibibleFirst;
   do
   {
      ibibleFirst = piblh->ibibleFirst;
      pible->ibibleNext = ibibleFirst;
   }
   while (ibibleFirst != InterlockedCompareExchange((PLONG)&piblh->ibibleFirst, ibible, ibibleFirst ));
   
   InterlockedIncrement((PLONG)&pidfhdr->cible);

   return ibible;
}


//
// This function is called when a BBT instrumented binary is run.
// We assume this function is only called once.
//
extern "C" VOID
IrtClientInitFast(
    const IRTP* pirtp,
    DWORD* rgCounts,
    BYTE* rgTobCounts,
    FASTRTPARAM* pfrtp,
    DWORD* rgSeqNums,
    FASTINDDATA* pfid,
    VOID* unused
    )
{
    if (IsIrtClientInited()) return;

    // Allocate the necessary memory buffers
    IrtSweepingFlag = 0;

    IrtClientInfo = (IRTCLIENTINFO*) MmAllocateSystemMemory(IRT_BUFFER_SIZE, PAGE_READWRITE);
    IrtAssert(IrtClientInfo != NULL);

    // Remember the client init parameters
    memset(IrtClientInfo, 0, sizeof(IRTCLIENTINFO));
    IrtClientInfo->pirtp = pirtp;
    IrtClientInfo->rgCounts = rgCounts;
    IrtClientInfo->rgTobCounts = rgTobCounts;
    IrtClientInfo->rgSeqNums = rgSeqNums;

    // Initialize IDF header information
    IrtInitializeIdfHeader(IrtClientInfo);

    if (pfid) {
       IBLH* rgiblh = (IBLH*) ((BYTE*) IrtClientInfo->pidfhdr + IrtClientInfo->pidfhdr->ibrgiblh);
       pfid->rgiblh = (DWORD_PTR) rgiblh;
       pfid->negaddrbase = -(LONGLONG) pirtp->pvImageBase;
       pfid->pidfhdr = (DWORD_PTR) IrtClientInfo->pidfhdr;
       pfid->pfnInd = (DWORD_PTR) IrtClientNewIndFast;
    }

    // Start the background timer
    LARGE_INTEGER dueTime;
    dueTime.QuadPart = -10000*IRT_SWEEP_INTERVAL;

    KeInitializeDpc(&IrtTimerDpc, IrtTimerProc, NULL);
    KeInitializeTimer(&IrtTimer);
    KeSetTimerEx(&IrtTimer, dueTime, IRT_SWEEP_INTERVAL, &IrtTimerDpc);
}


//
// Sweep the BBT data into a disk file
//
NTSTATUS IrtSweep(HANDLE file)
{
    NTSTATUS status = STATUS_INVALID_PARAMETER;

    //
    // Make sure the client has been initialized
    // and we're not sweeping at the moment
    //
    if (!IsIrtClientInited() ||
        InterlockedCompareExchange(&IrtSweepingFlag, 1, 0) != 0) {
        status = STATUS_INVALID_PARAMETER;
    } else {
        // Sweep static edge counts
        IrtCopyCounts(IrtClientInfo);

        // Write the in-memory IDF data out to the disk

        IO_STATUS_BLOCK iostatusBlock;
        FILE_END_OF_FILE_INFORMATION endOfFile;
        FILE_ALLOCATION_INFORMATION allocation;
        IDFHDR* pidfhdr = IrtClientInfo->pidfhdr;
        DWORD count = pidfhdr->cb;

        status = NtWriteFile(
                   file,
                   NULL,
                   NULL,
                   NULL,
                   &iostatusBlock,
                   pidfhdr,
                   (count + 511) & ~511,
                   NULL);

        // Set file size

        if (NT_SUCCESS(status)) {
            endOfFile.EndOfFile.QuadPart = count;
            status = NtSetInformationFile(
                        file,
                        &iostatusBlock,
                        &endOfFile,
                        sizeof(endOfFile),
                        FileEndOfFileInformation);
        }

        if (NT_SUCCESS(status)) {
            allocation.AllocationSize.QuadPart = count;
            status = NtSetInformationFile(
                        file,
                        &iostatusBlock,
                        &allocation,
                        sizeof(allocation),
                        FileAllocationInformation);
        }

        // Clean up the in-memory data
        IrtInitializeIdfHeader(IrtClientInfo);

        IrtSweepingFlag = 0;
    }

    return status;
}

#else // !_XBOX_ENABLE_BBT

//
// When BBTBUILD is not enabled, just stub out these two functions
//
extern "C" VOID
IrtClientInitFast(
    const IRTP* pirtp,
    DWORD* rgCounts,
    BYTE* rgTobCounts,
    FASTRTPARAM* pfrtp,
    DWORD* rgSeqNums,
    VOID* unused
    ) {}

NTSTATUS IrtSweep(HANDLE file) { return STATUS_NOT_IMPLEMENTED; }

#endif // !_XBOX_ENABLE_BBT

#endif // _XBOX_ENABLE_PROFILING
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xprof\bbtirt.h ===
/***********************************************************************
* Microsoft BBT
*
* Microsoft Confidential.  Copyright 1994-2000 Microsoft Corporation.
*
* Component:
*
* File: bbtirt.h
*
* File Comments:
*
*
***********************************************************************/


//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//                                                                         !
//                                                                         !
//                                                                         !
// Please note that this file is being shared with the NT group for kernel !
// instrumentation since they are generating their own IDF files for BBT.  !
// So please notify one of us JohnLef/HoiV/BobFitz before changing any     !
// data structures that has to do with the IDFHDR or IRTP.                 !
//                                                                         !
//                                                                         !
//                                                                         !
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


struct IRTP                            // Instrumentation Run Time Parameters
{
   DWORD       dwVersion;              // Version of this structure
   DWORD       dwId;                   // Id of database
   DWORD       dwGeneration;           // Database generation
   void        *pvImageBase;           // Base address of this module
   DWORD       cmsTimer;               // Timer interval in milliseconds
   DWORD       fMultipleInstance;      // Instrument multiple instances together
   DWORD       fSweepable;             // Sweeping is supported
   DWORD       fNtVdm;                 // This is NTVDM.EXE or WOW32.DLL
   DWORD       tov;                    // Variety of time order instrumentation
   DWORD       *rgpfnCallback;         // Pointer to array of callback pointers
   void        *pfnNopCallback;        // Pointer to nop thunk
#ifdef  POGO
   DWORD       pfnNopCallback2;        // Pointer to nop thunk for switch probe
#endif
   void        **rgpvResource;         // Pointer to array of resource addresses
   DWORD       cbIdfMax;               // User requested maximum IDF size
   DWORD       cbrc;                   // Count of static branches
   DWORD       cibs;                   // Count of indirect branch sources
   DWORD       cibd;                   // Count of indirect branch targets
   DWORD       cfun;                   // Count of functions
   DWORD       crsc;                   // Count of resources
#ifdef  POGO
   DWORD       csbr;                   // Count of switches
#endif
   DWORD       ifunEndBoot;            // Last function of boot; 0xFFFFFFFF if none

   char        *szIdfPath;             // UNDONE: Remove when new IRT complete
   char        *szIdfKeyPath;          // UNDONE: Remove when new IRT complete
   DWORD       dwDynProbeCount;        // Number of TOB Probes to execute to increment time.
   DWORD       fFourBitTobs;           // Are we using 4-bit tobs?
};

// This is a copy of IRTP with all the pointer fields
// replaced by DWORDLONG so that we can get 64 bit values
// to pass over to IRT.
//
struct IRTPIA64                        // Instrumentation Run Time Parameters
{
   DWORD       dwVersion;              // Version of this structure
   DWORD       dwId;                   // Id of database
   DWORD       dwGeneration;           // Database generation
   DWORDLONG   pvImageBase;            // Base address of this module
   DWORD       cmsTimer;               // Timer interval in milliseconds
   DWORD       fMultipleInstance;      // Instrument multiple instances together
   DWORD       fSweepable;             // Sweeping is supported
   DWORD       fNtVdm;                 // This is NTVDM.EXE or WOW32.DLL
   DWORD       tov;                    // Variety of time order instrumentation
   DWORDLONG   rgpfnCallback;          // Pointer to array of callback pointers
   DWORDLONG   pfnNopCallback;         // Pointer to nop thunk
#ifdef  POGO
   DWORD       pfnNopCallback2;        // Pointer to nop thunk for switch probe
#endif
   DWORDLONG   rgpvResource;           // Pointer to array of resource addresses
   DWORD       cbIdfMax;               // User requested maximum IDF size
   DWORD       cbrc;                   // Count of static branches
   DWORD       cibs;                   // Count of indirect branch sources
   DWORD       cibd;                   // Count of indirect branch targets
   DWORD       cfun;                   // Count of functions
   DWORD       crsc;                   // Count of resources
#ifdef  POGO
   DWORD       csbr;                   // Count of switches
#endif
   DWORD       ifunEndBoot;            // Last function of boot; 0xFFFFFFFF if none

   DWORDLONG   szIdfPath;             // UNDONE: Remove when new IRT complete
   DWORDLONG   szIdfKeyPath;          // UNDONE: Remove when new IRT complete
   DWORD       dwDynProbeCount;        // Number of TOB Probes to execute to increment time.
   DWORD       fFourBitTobs;           // Are we using 4-bit tobs?
};


#ifdef POGO

const DWORD dwIrtVerCurrent = 0x8000100b;

#else   // !POGO

const DWORD dwIrtVerCurrent = 0x00001010; // This also much be changed in idf.h

#endif  // !POGO


enum IIFN                              // Index into IRTP.rpfnCallback array
{
#ifdef POGO
   iifnInit,                           // UNDONE: remove when complier updated
#endif
   iifnBranch,                         // Direct branch
   iifnIndirectSource,                 // Indirect branch source
   iifnIndirectTarget,                 // Indirect branch target
   iifnFunction,                       // Function entry
#ifdef POGO
   iifnSwitch,                         // Switch statement
#endif
   iifnMax
};

struct FASTRTPARAM
{
   char  szModulePath[ _MAX_PATH ];
};

struct FASTINDDATA
{
   DWORDLONG pidfhdr;
   DWORDLONG rgiblh;
   DWORDLONG negaddrbase;
   DWORDLONG pfnInd;
};

struct FASTINITINDIRECT
{
    DWORDLONG    pirtp; //const IRTP  *
    DWORDLONG    rgCounts; //DWORD *
    DWORDLONG    rgTobBytes; //BYTE *
    DWORDLONG    pfrtp;     //FASTRTPARAM *
    DWORDLONG    rgSeqNums; //DWORD *
    DWORDLONG    pFastInd;  //FASTINDDATA *
};


struct REGAXP
{
   DWORDLONG v0;                  // 0x00                                   $0
   DWORDLONG t0;                  // 0x08                                   $1
   DWORDLONG t1;                  // 0x10                                   $2
   DWORDLONG t2;                  // 0x18                                   $3
   DWORDLONG t3;                  // 0x20                                   $4
   DWORDLONG t4;                  // 0x28                                   $5
   DWORDLONG t5;                  // 0x30                                   $6
   DWORDLONG t6;                  // 0x38                                   $7
   DWORDLONG t7;                  // 0x40                                   $8
   DWORDLONG s0;                  // 0x48        Currently not used         $9
   DWORDLONG s1;                  // 0x50        Currently not used         $10
   DWORDLONG s2;                  // 0x58                                   $11
   DWORDLONG s3;                  // 0x60                                   $12
   DWORDLONG s4;                  // 0x68                                   $13
   DWORDLONG s5;                  // 0x70                                   $14
   DWORDLONG fp;                  // 0x78        Currently not used         $15
   DWORDLONG a0;                  // 0x80                                   $16
   DWORDLONG a1;                  // 0x88                                   $17
   DWORDLONG a2;                  // 0x90                                   $18
   DWORDLONG a3;                  // 0x98                                   $19
   DWORDLONG a4;                  // 0xA0                                   $20
   DWORDLONG a5;                  // 0xA8                                   $21
   DWORDLONG t8;                  // 0xB0                                   $22
   DWORDLONG t9;                  // 0xB8                                   $23
   DWORDLONG t10;                 // 0xC0                                   $24
   DWORDLONG t11;                 // 0xC8                                   $25
   DWORDLONG ra;                  // 0xD0                                   $26
   DWORDLONG t12;                 // 0xD8                                   $27
   DWORDLONG at;                  // 0xE0                                   $28

   DWORDLONG reserved;            // 0xE8
   DWORDLONG lr1;                 // 0xF0
   DWORDLONG arg;                 // 0xF8

   DWORDLONG f0;                  // 0x100
   DWORDLONG f1;                  // 0x108
   DWORDLONG f10;                 // 0x110
   DWORDLONG f11;                 // 0x118
   DWORDLONG f12;                 // 0x120
   DWORDLONG f13;                 // 0x128
   DWORDLONG f14;                 // 0x130
   DWORDLONG f15;                 // 0x138
   DWORDLONG f16;                 // 0x140
   DWORDLONG f17;                 // 0x148
   DWORDLONG f18;                 // 0x150
   DWORDLONG f19;                 // 0x158
   DWORDLONG f20;                 // 0x160
   DWORDLONG f21;                 // 0x168
   DWORDLONG f22;                 // 0x170
   DWORDLONG f23;                 // 0x178
   DWORDLONG f24;                 // 0x180
   DWORDLONG f25;                 // 0x188
   DWORDLONG f26;                 // 0x190
   DWORDLONG f27;                 // 0x198
   DWORDLONG f28;                 // 0x1a0
   DWORDLONG f29;                 // 0x1a8
   DWORDLONG f30;                 // 0x1b0

   DWORDLONG gp;                  //             Currently not saved        $29
   DWORDLONG sp;                  //             Currently not saved        $30
   DWORDLONG zr;                  //             Currently not saved        $31
};


struct REGMIPS
{
   DWORD reserved[4];         // 0x00, 16 byte preallocated argument build area

   DWORDLONG at;                  // 0x10,                                  $1
   DWORDLONG v0;                  // 0x18,                                  $2
   DWORDLONG v1;                  // 0x20,                                  $3
   DWORDLONG a0;                  // 0x28,                                  $4
   DWORDLONG a1;                  // 0x30,                                  $5
   DWORDLONG a2;                  // 0x38,                                  $6
   DWORDLONG a3;                  // 0x40,                                  $7
   DWORDLONG t0;                  // 0x48,                                  $8
   DWORDLONG t1;                  // 0x50,                                  $9
   DWORDLONG t2;                  // 0x58,                                  $10
   DWORDLONG t3;                  // 0x60,                                  $11
   DWORDLONG t4;                  // 0x68,                                  $12
   DWORDLONG t5;                  // 0x70,                                  $13
   DWORDLONG t6;                  // 0x78,                                  $14
   DWORDLONG t7;                  // 0x80,                                  $15
   DWORDLONG s0;                  // 0x88,                                  $16
   DWORDLONG s1;                  // 0x90,                                  $17
   DWORDLONG s2;                  // 0x98,                                  $18
   DWORDLONG s3;                  // 0xA0,                                  $19
   DWORDLONG s4;                  // 0xA8,                                  $20
   DWORDLONG s5;                  // 0xB0,                                  $21
   DWORDLONG t8;                  // 0xB8,                                  $24
   DWORDLONG t9;                  // 0xC0,                                  $25
   DWORDLONG ra;                  // 0xC8,                                  $31

   DWORDLONG rs1;                 // 0xD0     reserved1
   DWORDLONG rs2;                 // 0xD8     reserved2

                              //          k0 Not needed to save         $26
                              //          k1 Not needed to save         $27
                              //          gp Not needed to save         $29
                              //          sp Not needed to save         $30

};


struct REGMPPC
{
   DWORD reserved1[9];        // 0x00, Filler
   DWORD ibPatch;             // 0x24,          ib to instr code to be patched
   DWORD reserved2[22];       // 0x28, Filler

   DWORD ctr;                 // 0x80,          Offset to original CTR
   DWORD cr;                  // 0x84,          Offset to CR
   DWORD lr;                  // 0x88,          Offset to instrumentation site
   DWORD lr1;                 // 0x8C,          Offset to instr thunk site
   DWORD r0;                  // 0x90,
   DWORD r2;                  // 0x94,
   DWORD r3;                  // 0x98,
   DWORD r4;                  // 0x9C,
   DWORD r5;                  // 0xA0,
   DWORD r6;                  // 0xA4,
   DWORD r7;                  // 0xA8,
   DWORD r8;                  // 0xAC,
   DWORD r9;                  // 0xB0,
   DWORD r10;                 // 0xB4,
   DWORD r11;                 // 0xB8,
   DWORD r12;                 // 0xBC,

   DWORD arg;                 // 0xC0,
   DWORD pidfhdr;             // 0xC4,

   DWORD reserved3[14];       // 0xC8,
   DWORD r0Alias;             // 0x100,
};


struct REGPPC
{
   DWORD reserved[32];        // 0x00, Filler

   DWORD ctr;                 // 0x80,          Offset to original CTR
   DWORD cr;                  // 0x84,          Offset to CR
   DWORD lr;                  // 0x88,          Offset to instrumentation site
   DWORD lr1;                 // 0x8C,          Offset to instr thunk site
   DWORD r0;                  // 0x90,
   DWORD r2;                  // 0x94,
   DWORD r3;                  // 0x98,
   DWORD r4;                  // 0x9C,
   DWORD r5;                  // 0xA0,
   DWORD r6;                  // 0xA4,
   DWORD r7;                  // 0xA8,
   DWORD r8;                  // 0xAC,
   DWORD r9;                  // 0xB0,
   DWORD r10;                 // 0xB4,
   DWORD r11;                 // 0xB8,
   DWORD r12;                 // 0xBC,

   DWORD arg;                 // 0xC0,
   DWORD pidfhdr;             // 0xC4,
   DWORD pthd;                // 0xC8,
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\xprof\xprofile.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    xprofile.c

Abstract:

    Kernel profiler functions

--*/

#ifdef _XBOX_ENABLE_PROFILING

#include "ntos.h"
#include "xprofp.h"

//
// Global data structures maintained by the profiler
//
XProfpGlobals XProfpData;

XProfpGlobals* XProfpGetData() {
    return &XProfpData;
}


VOID __declspec(naked) __stdcall
_CAP_Start_Profiling(
    VOID* caller,
    VOID* callee
    )

/*++

Routine Description:

    Just before a function is about to be called

Arguments:

    caller - Specifies the caller function
    callee - Specifies the called function

Return Value:

    NONE

--*/

{
    /*
        ULONG* buf;

    loop:
        buf = XProfpData.bufnext
        if buf >= XProfpData.bufend, return
        atomic incremnt of XProfpData.bufnext by 4 ULONGs
        if failed, goto loop

        buf[0] = timestamp-high
        buf[1] = timestamp-low
        buf[2] = caller
        buf[3] = callee

     */

    __asm {
        push    eax
        push    ecx
        push    edx
        lea     ecx, XProfpData
        mov     eax, [ecx]          ; eax = XProfpData.bufnext
    loop1:
        cmp     eax, [ecx+4]        ; XProfpData.bufnext >= XProfpData.bufend?
        jae     ret1
        lea     edx, [eax+16]       ; XProfpData.bufnext += 4
        cmpxchg [ecx], edx
        jnz     loop1

        mov     ecx, eax
        rdtsc
        mov     [ecx], edx          ; timestamp-high
        mov     [ecx+4], eax        ; timestamp-low
        mov     eax, [esp+16]       ; caller - 3 pushes + return address
        mov     [ecx+8], eax
        mov     eax, [esp+20]       ; callee
        mov     [ecx+12], eax

    ret1:
        pop     edx
        pop     ecx
        pop     eax
        ret     8
    }
}


VOID __declspec(naked) __stdcall
_CAP_End_Profiling(
    VOID* caller
    )
/*++

Routine Description:

    Just after a function call is made

Arguments:

    caller - Specifies the caller function

Return Value:

    NONE

--*/

{
    // Same logic as above, except the record is smaller by 1 ULONG

    __asm {
        push    eax
        push    ecx
        push    edx
        lea     ecx, XProfpData
        mov     eax, [ecx]          ; eax = XProfpData.bufnext
    loop1:
        cmp     eax, [ecx+4]        ; XProfpData.bufnext >= XProfpData.bufend?
        jae     ret1
        lea     edx, [eax+12]       ; XProfpData.bufnext += 3
        cmpxchg [ecx], edx
        jnz     loop1

        mov     ecx, eax
        rdtsc
        bts     edx, 29             ; timestamp-high | XPROFREC_CALL_END
        mov     [ecx], edx
        mov     [ecx+4], eax        ; timestamp-low
        mov     eax, [esp+16]       ; caller
        mov     [ecx+8], eax

    ret1:
        pop     edx
        pop     ecx
        pop     eax
        ret     4
    }
}


VOID __declspec(naked) __stdcall
XProfpEmitControlRecord(
    ULONG type,
    ULONG param
    )

/*++

Routine Description:

    Emit a CAP control record

Arguments:

    type - Specifies the control record type
    param - Type-specific parameter

Return Value:

    NONE

--*/

{
    // Identical to _CAP_Start_Profiling except
    // the record is marked as XPROFREC_CONTROL.

    __asm {
        push    eax
        push    ecx
        push    edx
        lea     ecx, XProfpData
        mov     eax, [ecx]          ; eax = XProfpData.bufnext
    loop1:
        cmp     eax, [ecx+4]        ; XProfpData.bufnext >= XProfpData.bufend?
        jae     ret1
        lea     edx, [eax+16]       ; XProfpData.bufnext += 4
        cmpxchg [ecx], edx
        jnz     loop1

        mov     ecx, eax
        rdtsc
        or      edx, XPROFREC_CONTROL
        mov     [ecx], edx          ; timestamp-high
        mov     [ecx+4], eax        ; timestamp-low
        mov     eax, [esp+16]       ; caller - 3 pushes + return address
        mov     [ecx+8], eax
        mov     eax, [esp+20]       ; callee
        mov     [ecx+12], eax

    ret1:
        pop     edx
        pop     ecx
        pop     eax
        ret     8
    }
}


//
// Default profiling data buffer size is 32MB
//
#define XPROF_DEFAULT_BUFSIZE 32
#define XProfpCalcBufferSize(param) \
        ((((param) & 0xffff) ? ((param) & 0xffff) : XPROF_DEFAULT_BUFSIZE) * 1024*1024)

//
// Acquire and release global access lock
//
#define XProfpLock() InterlockedCompareExchange(&XProfpData.lock, 1, 0)
#define XProfpUnlock() (XProfpData.lock = 0)

//
// Disable / enable interrupts
//
#define XProfpDisableInterrupts() KfRaiseIrql(HIGH_LEVEL)
#define XProfpRestoreInterrupts(irql) KfLowerIrql(irql)

//
// Thread context switch notification routine
//
extern PSWAP_CONTEXT_NOTIFY_ROUTINE KiDbgCtxSwapNotify;
PSWAP_CONTEXT_NOTIFY_ROUTINE XProfpSavedCtxSwapNotify;

VOID FASTCALL
XProfpThreadSwitchNotifyCallback(
    HANDLE OldThreadId,
    HANDLE NewThreadId
    )
{
    XProfpEmitControlRecord(XPROF_THREAD_SWITCH, (ULONG) NewThreadId);

    // Call the original notification function
    if (XProfpSavedCtxSwapNotify) {
        (*XProfpSavedCtxSwapNotify)(OldThreadId, NewThreadId);
    }
}

//
// DPC dispatch notification routine
//
extern PVOID KiDpcDispatchNotify;

VOID FASTCALL
XProfpDpcDispatchNotifyCallback(
    VOID* dpcproc,
    ULONG param
    )
{
    XProfpEmitControlRecord(XPROF_DPC_BEGIN+param, (ULONG) dpcproc);
}

NTSTATUS
XProfpControl(
    ULONG Action,
    ULONG Param
    )

/*++

Routine Description:

    Profiler control function

Arguments:

    Action - Specify the control action
    Param - Action-specific parameter

Return Value:

    Status code

--*/

{
    KIRQL irql;
    ULONG tid;
    NTSTATUS status = STATUS_SUCCESS;

    switch (Action) {
    case XPROF_START:
    case XPROF_STOP:
        if (XProfpLock() != 0) {
            // Simple-minded locking mechanism: prevent multiple threads
            // from calling  start/stop/resume at the same time
            status = STATUS_DEVICE_BUSY;
            break;
        }

        tid = (ULONG) PsGetCurrentThread()->UniqueThread;

        if (Action == XPROF_START) {
            // Start a new profiling session

            //
            // Clear the existing profiling data buffer first
            //
            ULONG oldsize = XProfpCalcBufferSize(XProfpData.start_param);
            ULONG newsize = XProfpCalcBufferSize(Param);
            ULONG* buf = XProfpData.bufstart;
                
            if (buf) {
                if (!XProfpData.bufnext_stopped) {
                    // There is already an active profiling session.
                    XProfpUnlock();
                    return STATUS_INVALID_PARAMETER;
                }

                irql = XProfpDisableInterrupts();

                XProfpData.bufstart = 
                XProfpData.bufend = 
                XProfpData.bufnext = 
                XProfpData.bufnext_stopped = NULL;
                XProfpData.start_type = 
                XProfpData.start_param = 0;

                KiDbgCtxSwapNotify = XProfpSavedCtxSwapNotify = NULL;
                KiDpcDispatchNotify = NULL;
                XProfpRestoreInterrupts(irql);

                // If the old size and the new size are the same,
                // then we'll reuse the same buffer. Otherwise,
                // we'll free the old buffer first.
                if (oldsize != newsize) {
                    MmDbgFreeMemory(buf, oldsize);
                    buf = NULL;
                }
            }

            //
            // Allocate memory for the new profiling data buffer
            //
            if (!buf) buf = (ULONG*) MmDbgAllocateMemory(newsize, PAGE_READWRITE|PAGE_WRITECOMBINE);
            if (buf == NULL) {
                status = STATUS_NO_MEMORY;
            } else {
                irql = XProfpDisableInterrupts();

                XProfpData.bufstart = (ULONG*) buf;
                XProfpData.bufnext = XProfpData.bufstart;
                XProfpData.bufend = (ULONG*) ((UCHAR*) buf + newsize - XPROFREC_MAXSIZE);
                XProfpData.start_param = Param;
                XProfpData.start_type = Action;

                XProfpEmitControlRecord(XPROF_START, tid);
                XProfpSavedCtxSwapNotify = KiDbgCtxSwapNotify;
                KiDbgCtxSwapNotify = XProfpThreadSwitchNotifyCallback;
                if (Param & XPROF_DPC_ENABLED)
                    KiDpcDispatchNotify = XProfpDpcDispatchNotifyCallback;
                XProfpRestoreInterrupts(irql);
            }
        } else {
            // Stop the current profiling session
            
            if (!XProfpData.bufstart) {
                // No profiling session
                status = STATUS_INVALID_PARAMETER;
            } else if (XProfpData.bufnext_stopped) {
                // Profiling session already stopped
                //  do nothing
            } else {
                irql = XProfpDisableInterrupts();
                KiDbgCtxSwapNotify = XProfpSavedCtxSwapNotify;
                XProfpSavedCtxSwapNotify = NULL;
                KiDpcDispatchNotify = NULL;

                XProfpEmitControlRecord(XPROF_STOP, tid);

                XProfpData.bufnext_stopped = XProfpData.bufnext;
                XProfpData.bufnext = XProfpData.bufend;

                XProfpRestoreInterrupts(irql);
            }
        }

        XProfpUnlock();
        break;

    case XPROF_COMMENT:
        XProfpEmitControlRecord(Action, Param);
        break;

    default:
        status = STATUS_NOT_IMPLEMENTED;
        break;
    }

    return status;
}

#endif // _XBOX_ENABLE_PROFILING
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\public\ddk\inc\miniport.h ===
/*++

Copyright (c) 1989-1997  Microsoft Corporation

Module Name:

    miniport.h

Abstract:

    Type definitions for miniport drivers.

Revision History:

--*/

#ifndef _MINIPORT_
#define _MINIPORT_

#include "stddef.h"

#define ASSERT( exp )

#ifndef FAR
#define FAR
#endif


#ifndef IN
#define IN
#endif

#ifndef OUT
#define OUT
#endif

#ifndef OPTIONAL
#define OPTIONAL
#endif

#ifndef NOTHING
#define NOTHING
#endif

#ifndef CRITICAL
#define CRITICAL
#endif

#ifndef ANYSIZE_ARRAY
#define ANYSIZE_ARRAY 1       // winnt
#endif

// begin_winnt

#if defined(_M_MRX000) && !(defined(MIDL_PASS) || defined(RC_INVOKED)) && defined(ENABLE_RESTRICTED)
#define RESTRICTED_POINTER __restrict
#else
#define RESTRICTED_POINTER
#endif

#if defined(_M_MRX000) || defined(_M_ALPHA) || defined(_M_PPC) || defined(_M_IA64)
#define UNALIGNED __unaligned
#if defined(_WIN64)
#define UNALIGNED64 __unaligned
#else
#define UNALIGNED64
#endif
#else
#define UNALIGNED
#define UNALIGNED64
#endif


#if defined(_WIN64) || defined(_M_ALPHA)
#define MAX_NATURAL_ALIGNMENT sizeof(ULONGLONG)
#else
#define MAX_NATURAL_ALIGNMENT sizeof(ULONG)
#endif

//
// TYPE_ALIGNMENT will return the alignment requirements of a given type for
// the current platform.
//

#ifndef __cplusplus
#define TYPE_ALIGNMENT( t ) \
    FIELD_OFFSET( struct { char x; t test; }, test )
#endif

#if defined(_WIN64)

#define PROBE_ALIGNMENT( _s ) (TYPE_ALIGNMENT( _s ) > TYPE_ALIGNMENT( ULONG ) ? \
                               TYPE_ALIGNMENT( _s ) : TYPE_ALIGNMENT( ULONG ))

#else

#define PROBE_ALIGNMENT( _s ) TYPE_ALIGNMENT( ULONG )

#endif

//
// C_ASSERT() can be used to perform many compile-time assertions:
//            type sizes, field offsets, etc.
//
// An assertion failure results in error C2118: negative subscript.
//

#define C_ASSERT(e) typedef char __C_ASSERT__[(e)?1:-1]

#if !defined(_MAC) && (defined(_M_MRX000) || defined(_M_ALPHA) || defined(_M_IA64)) && (_MSC_VER >= 1100) && !(defined(MIDL_PASS) || defined(RC_INVOKED))
#define POINTER_64 __ptr64
typedef unsigned __int64 POINTER_64_INT;
#if defined(_WIN64)
#define POINTER_32 __ptr32
#else
#define POINTER_32
#endif
#else
#if defined(_MAC) && defined(_MAC_INT_64)
#define POINTER_64 __ptr64
typedef unsigned __int64 POINTER_64_INT;
#else
#define POINTER_64
typedef unsigned long POINTER_64_INT;
#endif
#define POINTER_32
#endif

#if defined(_IA64_)
#define FIRMWARE_PTR
#else
#define FIRMWARE_PTR POINTER_32
#endif

#include <basetsd.h>

// end_winnt

#ifndef CONST
#define CONST               const
#endif

// begin_winnt

#if (defined(_M_IX86) || defined(_M_ALPHA) || defined(_M_IA64)) && !defined(MIDL_PASS)
#define DECLSPEC_IMPORT     __declspec(dllimport)
#else
#define DECLSPEC_IMPORT
#endif

#ifndef DECLSPEC_NORETURN
#if (_MSC_VER >= 1200) && !defined(MIDL_PASS)
#define DECLSPEC_NORETURN   __declspec(noreturn)
#else
#define DECLSPEC_NORETURN
#endif
#endif

#ifndef DECLSPEC_ALIGN
#if (_MSC_VER >= 1300) && !defined(MIDL_PASS)
#define DECLSPEC_ALIGN(x)   __declspec(align(x))
#else
#define DECLSPEC_ALIGN(x)
#endif
#endif

#ifndef DECLSPEC_UUID
#if (_MSC_VER >= 1100) && defined (__cplusplus)
#define DECLSPEC_UUID(x)    __declspec(uuid(x))
#else
#define DECLSPEC_UUID(x)
#endif
#endif

#ifndef DECLSPEC_NOVTABLE
#if (_MSC_VER >= 1100) && defined(__cplusplus)
#define DECLSPEC_NOVTABLE   __declspec(novtable)
#else
#define DECLSPEC_NOVTABLE
#endif
#endif

#ifndef DECLSPEC_SELECTANY
#if (_MSC_VER >= 1100)
#define DECLSPEC_SELECTANY  __declspec(selectany)
#else
#define DECLSPEC_SELECTANY
#endif
#endif

#ifndef NOP_FUNCTION
#if (_MSC_VER >= 1210)
#define NOP_FUNCTION __noop
#else
#define NOP_FUNCTION (void)0
#endif
#endif

#ifndef DECLSPEC_ADDRSAFE
#if (_MSC_VER >= 1200) && (defined(_M_ALPHA) || defined(_M_AXP64))
#define DECLSPEC_ADDRSAFE  __declspec(address_safe)
#else
#define DECLSPEC_ADDRSAFE
#endif
#endif

// end_winnt

//
// Void
//
// begin_winnt

typedef void *PVOID;
typedef void * POINTER_64 PVOID64;

// end_winnt

#if defined(_M_IX86)
#define FASTCALL __fastcall
#else
#define FASTCALL
#endif

#if (_MSC_VER >= 1200) && defined(_M_IX86)
#define FORCEINLINE static __forceinline
#else
#define FORCEINLINE __inline
#endif


//
// Basics
//

#ifndef VOID
#define VOID void
typedef char CHAR;
typedef short SHORT;
typedef long LONG;
#endif

//
// UNICODE (Wide Character) types
//

#ifndef _MAC
typedef wchar_t WCHAR;    // wc,   16-bit UNICODE character
#else
// some Macintosh compilers don't define wchar_t in a convenient location, or define it as a char
typedef unsigned short WCHAR;    // wc,   16-bit UNICODE character
#endif

typedef WCHAR *PWCHAR;
typedef WCHAR *LPWCH, *PWCH;
typedef CONST WCHAR *LPCWCH, *PCWCH;
typedef WCHAR *NWPSTR;
typedef WCHAR *LPWSTR, *PWSTR;

typedef CONST WCHAR *LPCWSTR, *PCWSTR;

//
// ANSI (Multi-byte Character) types
//
typedef CHAR *PCHAR;
typedef CHAR *LPCH, *PCH;

typedef CONST CHAR *LPCCH, *PCCH;
typedef CHAR *NPSTR;
typedef CHAR *LPSTR, *PSTR;
typedef CONST CHAR *LPCSTR, *PCSTR;

//
// Neutral ANSI/UNICODE types and macros
//
#ifdef  UNICODE                     // r_winnt

#ifndef _TCHAR_DEFINED
typedef WCHAR TCHAR, *PTCHAR;
typedef WCHAR TUCHAR, *PTUCHAR;
#define _TCHAR_DEFINED
#endif /* !_TCHAR_DEFINED */

typedef LPWSTR LPTCH, PTCH;
typedef LPWSTR PTSTR, LPTSTR;
typedef LPCWSTR PCTSTR, LPCTSTR;
typedef LPWSTR LP;
#define __TEXT(quote) L##quote      // r_winnt

#else   /* UNICODE */               // r_winnt

#ifndef _TCHAR_DEFINED
typedef char TCHAR, *PTCHAR;
typedef unsigned char TUCHAR, *PTUCHAR;
#define _TCHAR_DEFINED
#endif /* !_TCHAR_DEFINED */

typedef LPSTR LPTCH, PTCH;
typedef LPSTR PTSTR, LPTSTR;
typedef LPCSTR PCTSTR, LPCTSTR;
#define __TEXT(quote) quote         // r_winnt

#endif /* UNICODE */                // r_winnt
#define TEXT(quote) __TEXT(quote)   // r_winnt


// end_winnt

typedef double DOUBLE;

typedef struct _QUAD {              // QUAD is for those times we want
    double  DoNotUseThisField;      // an 8 byte aligned 8 byte long structure
} QUAD;                             // which is NOT really a floating point
                                    // number.  Use DOUBLE if you want an FP
                                    // number.

//
// Pointer to Basics
//

typedef SHORT *PSHORT;  // winnt
typedef LONG *PLONG;    // winnt
typedef QUAD *PQUAD;

//
// Unsigned Basics
//

// Tell windef.h that some types are already defined.
#define BASETYPES

typedef unsigned char UCHAR;
typedef unsigned short USHORT;
typedef unsigned long ULONG;
typedef QUAD UQUAD;

//
// Pointer to Unsigned Basics
//

typedef UCHAR *PUCHAR;
typedef USHORT *PUSHORT;
typedef ULONG *PULONG;
typedef UQUAD *PUQUAD;

//
// Signed characters
//

typedef signed char SCHAR;
typedef SCHAR *PSCHAR;

#ifndef NO_STRICT
#ifndef STRICT
#define STRICT 1
#endif
#endif

//
// Handle to an Object
//

// begin_winnt

#ifdef STRICT
typedef void *HANDLE;
#define DECLARE_HANDLE(name) struct name##__ { int unused; }; typedef struct name##__ *name
#else
typedef PVOID HANDLE;
#define DECLARE_HANDLE(name) typedef HANDLE name
#endif
typedef HANDLE *PHANDLE;

//
// Flag (bit) fields
//

typedef UCHAR  FCHAR;
typedef USHORT FSHORT;
typedef ULONG  FLONG;

// Component Object Model defines, and macros

#ifndef _HRESULT_DEFINED
#define _HRESULT_DEFINED
typedef LONG HRESULT;

#endif // !_HRESULT_DEFINED

#ifdef __cplusplus
    #define EXTERN_C    extern "C"
#else
    #define EXTERN_C    extern
#endif

#if defined(_WIN32) || defined(_MPPC_)

// Win32 doesn't support __export

#ifdef _68K_
#define STDMETHODCALLTYPE       __cdecl
#else
#define STDMETHODCALLTYPE       __stdcall
#endif
#define STDMETHODVCALLTYPE      __cdecl

#define STDAPICALLTYPE          __stdcall
#define STDAPIVCALLTYPE         __cdecl

#else

#define STDMETHODCALLTYPE       __export __stdcall
#define STDMETHODVCALLTYPE      __export __cdecl

#define STDAPICALLTYPE          __export __stdcall
#define STDAPIVCALLTYPE         __export __cdecl

#endif


#define STDAPI                  EXTERN_C HRESULT STDAPICALLTYPE
#define STDAPI_(type)           EXTERN_C type STDAPICALLTYPE

#define STDMETHODIMP            HRESULT STDMETHODCALLTYPE
#define STDMETHODIMP_(type)     type STDMETHODCALLTYPE

// The 'V' versions allow Variable Argument lists.

#define STDAPIV                 EXTERN_C HRESULT STDAPIVCALLTYPE
#define STDAPIV_(type)          EXTERN_C type STDAPIVCALLTYPE

#define STDMETHODIMPV           HRESULT STDMETHODVCALLTYPE
#define STDMETHODIMPV_(type)    type STDMETHODVCALLTYPE

// end_winnt


//
// Low order two bits of a handle are ignored by the system and available
// for use by application code as tag bits.  The remaining bits are opaque
// and used to store a serial number and table index.
//

#define OBJ_HANDLE_TAGBITS  0x00000003L

//
// Cardinal Data Types [0 - 2**N-2)
//

typedef char CCHAR;          // winnt
typedef short CSHORT;
typedef ULONG CLONG;

typedef CCHAR *PCCHAR;
typedef CSHORT *PCSHORT;
typedef CLONG *PCLONG;


//
// __int64 is only supported by 2.0 and later midl.
// __midl is set by the 2.0 midl and not by 1.0 midl.
//

#define _ULONGLONG_
#if (!defined (_MAC) && (!defined(MIDL_PASS) || defined(__midl)) && (!defined(_M_IX86) || (defined(_INTEGRAL_MAX_BITS) && _INTEGRAL_MAX_BITS >= 64)))
typedef __int64 LONGLONG;
typedef unsigned __int64 ULONGLONG;

#define MAXLONGLONG                      (0x7fffffffffffffff)
#else

#if defined(_MAC) && defined(_MAC_INT_64)
typedef __int64 LONGLONG;
typedef unsigned __int64 ULONGLONG;

#define MAXLONGLONG                      (0x7fffffffffffffff)
#else
typedef double LONGLONG;
typedef double ULONGLONG;
#endif //_MAC and int64

#endif

typedef LONGLONG *PLONGLONG;
typedef ULONGLONG *PULONGLONG;

// Update Sequence Number

typedef LONGLONG USN;

#if defined(MIDL_PASS)
typedef struct _LARGE_INTEGER {
#else // MIDL_PASS
typedef union _LARGE_INTEGER {
    struct {
        ULONG LowPart;
        LONG HighPart;
    };
    struct {
        ULONG LowPart;
        LONG HighPart;
    } u;
#endif //MIDL_PASS
    LONGLONG QuadPart;
} LARGE_INTEGER;

typedef LARGE_INTEGER *PLARGE_INTEGER;


#if defined(MIDL_PASS)
typedef struct _ULARGE_INTEGER {
#else // MIDL_PASS
typedef union _ULARGE_INTEGER {
    struct {
        ULONG LowPart;
        ULONG HighPart;
    };
    struct {
        ULONG LowPart;
        ULONG HighPart;
    } u;
#endif //MIDL_PASS
    ULONGLONG QuadPart;
} ULARGE_INTEGER;

typedef ULARGE_INTEGER *PULARGE_INTEGER;


//
// Physical address.
//

typedef LARGE_INTEGER PHYSICAL_ADDRESS, *PPHYSICAL_ADDRESS;


//
// Boolean
//

typedef UCHAR BOOLEAN;           // winnt
typedef BOOLEAN *PBOOLEAN;       // winnt


//
// Constants
//

#define FALSE   0
#define TRUE    1

#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#define NULL64  0
#else
#define NULL    ((void *)0)
#define NULL64  ((void * POINTER_64)0)
#endif
#endif // NULL

//
// Calculate the byte offset of a field in a structure of type type.
//

#define FIELD_OFFSET(type, field)    ((LONG)(LONG_PTR)&(((type *)0)->field))


//
// Calculate the address of the base of the structure given its type, and an
// address of a field within the structure.
//

#define CONTAINING_RECORD(address, type, field) ((type *)( \
                                                  (PCHAR)(address) - \
                                                  (ULONG_PTR)(&((type *)0)->field)))


//
// Interrupt Request Level (IRQL)
//

typedef UCHAR KIRQL;

typedef KIRQL *PKIRQL;


//
// Macros used to eliminate compiler warning generated when formal
// parameters or local variables are not declared.
//
// Use DBG_UNREFERENCED_PARAMETER() when a parameter is not yet
// referenced but will be once the module is completely developed.
//
// Use DBG_UNREFERENCED_LOCAL_VARIABLE() when a local variable is not yet
// referenced but will be once the module is completely developed.
//
// Use UNREFERENCED_PARAMETER() if a parameter will never be referenced.
//
// DBG_UNREFERENCED_PARAMETER and DBG_UNREFERENCED_LOCAL_VARIABLE will
// eventually be made into a null macro to help determine whether there
// is unfinished work.
//

#if ! defined(lint)
#define UNREFERENCED_PARAMETER(P)          (P)
#define DBG_UNREFERENCED_PARAMETER(P)      (P)
#define DBG_UNREFERENCED_LOCAL_VARIABLE(V) (V)

#else // lint

// Note: lint -e530 says don't complain about uninitialized variables for
// this varible.  Error 527 has to do with unreachable code.
// -restore restores checking to the -save state

#define UNREFERENCED_PARAMETER(P)          \
    /*lint -save -e527 -e530 */ \
    { \
        (P) = (P); \
    } \
    /*lint -restore */
#define DBG_UNREFERENCED_PARAMETER(P)      \
    /*lint -save -e527 -e530 */ \
    { \
        (P) = (P); \
    } \
    /*lint -restore */
#define DBG_UNREFERENCED_LOCAL_VARIABLE(V) \
    /*lint -save -e527 -e530 */ \
    { \
        (V) = (V); \
    } \
    /*lint -restore */

#endif // lint

//
// Macro used to eliminate compiler warning 4715 within a switch statement
// when all possible cases have already been accounted for.
//
// switch (a & 3) {
//     case 0: return 1;
//     case 1: return Foo();
//     case 2: return Bar();
//     case 3: return 1;
//     DEFAULT_UNREACHABLE;
//

#if (_MSC_VER > 1200)
#define DEFAULT_UNREACHABLE default: __assume(0)
#else

//
// Older compilers do not support __assume(), and there is no other free
// method of eliminating the warning.
//

#define DEFAULT_UNREACHABLE

#endif


#ifdef _X86_

//
// Disable these two pramas that evaluate to "sti" "cli" on x86 so that driver
// writers to not leave them inadvertantly in their code.
//

#if !defined(MIDL_PASS)
#if !defined(RC_INVOKED)

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4164)   // disable C4164 warning so that apps that
                                // build with /Od don't get weird errors !
#ifdef _M_IX86
#pragma function(_enable)
#pragma function(_disable)
#endif

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4164)   // reenable C4164 warning
#endif

#endif
#endif


#endif //_X86_

//
// Define the I/O bus interface types.
//

typedef enum _INTERFACE_TYPE {
    InterfaceTypeUndefined = -1,
    Internal,
    Isa,
    Eisa,
    MicroChannel,
    TurboChannel,
    PCIBus,
    VMEBus,
    NuBus,
    PCMCIABus,
    CBus,
    MPIBus,
    MPSABus,
    ProcessorInternal,
    InternalPowerBus,
    PNPISABus,
    PNPBus,
    MaximumInterfaceType
}INTERFACE_TYPE, *PINTERFACE_TYPE;

//
// Define the DMA transfer widths.
//

typedef enum _DMA_WIDTH {
    Width8Bits,
    Width16Bits,
    Width32Bits,
    MaximumDmaWidth
}DMA_WIDTH, *PDMA_WIDTH;

//
// Define DMA transfer speeds.
//

typedef enum _DMA_SPEED {
    Compatible,
    TypeA,
    TypeB,
    TypeC,
    TypeF,
    MaximumDmaSpeed
}DMA_SPEED, *PDMA_SPEED;

//
// Define Interface reference/dereference routines for
//  Interfaces exported by IRP_MN_QUERY_INTERFACE
//

typedef VOID (*PINTERFACE_REFERENCE)(PVOID Context);
typedef VOID (*PINTERFACE_DEREFERENCE)(PVOID Context);

// end_wdm

//
// Define types of bus information.
//

typedef enum _BUS_DATA_TYPE {
    ConfigurationSpaceUndefined = -1,
    Cmos,
    EisaConfiguration,
    Pos,
    CbusConfiguration,
    PCIConfiguration,
    VMEConfiguration,
    NuBusConfiguration,
    PCMCIAConfiguration,
    MPIConfiguration,
    MPSAConfiguration,
    PNPISAConfiguration,
    SgiInternalConfiguration,
    MaximumBusDataType
} BUS_DATA_TYPE, *PBUS_DATA_TYPE;


#include <guiddef.h>


//
// Interrupt modes.
//

typedef enum _KINTERRUPT_MODE {
    LevelSensitive,
    Latched
    } KINTERRUPT_MODE;


//
// Structures used by the kernel drivers to describe which ports must be
// hooked out directly from the V86 emulator to the driver.
//

typedef enum _EMULATOR_PORT_ACCESS_TYPE {
    Uchar,
    Ushort,
    Ulong
} EMULATOR_PORT_ACCESS_TYPE, *PEMULATOR_PORT_ACCESS_TYPE;

//
// Access Modes
//

#define EMULATOR_READ_ACCESS    0x01
#define EMULATOR_WRITE_ACCESS   0x02

typedef struct _EMULATOR_ACCESS_ENTRY {
    ULONG BasePort;
    ULONG NumConsecutivePorts;
    EMULATOR_PORT_ACCESS_TYPE AccessType;
    UCHAR AccessMode;
    UCHAR StringSupport;
    PVOID Routine;
} EMULATOR_ACCESS_ENTRY, *PEMULATOR_ACCESS_ENTRY;


typedef struct _PCI_SLOT_NUMBER {
    union {
        struct {
            ULONG   DeviceNumber:5;
            ULONG   FunctionNumber:3;
            ULONG   Reserved:24;
        } bits;
        ULONG   AsULONG;
    } u;
} PCI_SLOT_NUMBER, *PPCI_SLOT_NUMBER;


#define PCI_TYPE0_ADDRESSES             6
#define PCI_TYPE1_ADDRESSES             2
#define PCI_TYPE2_ADDRESSES             5

typedef struct _PCI_COMMON_CONFIG {
    USHORT  VendorID;                   // (ro)
    USHORT  DeviceID;                   // (ro)
    USHORT  Command;                    // Device control
    USHORT  Status;
    UCHAR   RevisionID;                 // (ro)
    UCHAR   ProgIf;                     // (ro)
    UCHAR   SubClass;                   // (ro)
    UCHAR   BaseClass;                  // (ro)
    UCHAR   CacheLineSize;              // (ro+)
    UCHAR   LatencyTimer;               // (ro+)
    UCHAR   HeaderType;                 // (ro)
    UCHAR   BIST;                       // Built in self test

    union {
        struct _PCI_HEADER_TYPE_0 {
            ULONG   BaseAddresses[PCI_TYPE0_ADDRESSES];
            ULONG   CIS;
            USHORT  SubVendorID;
            USHORT  SubSystemID;
            ULONG   ROMBaseAddress;
            UCHAR   CapabilitiesPtr;
            UCHAR   Reserved1[3];
            ULONG   Reserved2;
            UCHAR   InterruptLine;      //
            UCHAR   InterruptPin;       // (ro)
            UCHAR   MinimumGrant;       // (ro)
            UCHAR   MaximumLatency;     // (ro)
        } type0;


    } u;

    UCHAR   DeviceSpecific[192];

} PCI_COMMON_CONFIG, *PPCI_COMMON_CONFIG;


#define PCI_COMMON_HDR_LENGTH (FIELD_OFFSET (PCI_COMMON_CONFIG, DeviceSpecific))

#define PCI_MAX_DEVICES                     32
#define PCI_MAX_FUNCTION                    8
#define PCI_MAX_BRIDGE_NUMBER               0xFF

#define PCI_INVALID_VENDORID                0xFFFF

//
// Bit encodings for  PCI_COMMON_CONFIG.HeaderType
//

#define PCI_MULTIFUNCTION                   0x80
#define PCI_DEVICE_TYPE                     0x00
#define PCI_BRIDGE_TYPE                     0x01
#define PCI_CARDBUS_BRIDGE_TYPE             0x02

#define PCI_CONFIGURATION_TYPE(PciData) \
    (((PPCI_COMMON_CONFIG)(PciData))->HeaderType & ~PCI_MULTIFUNCTION)

#define PCI_MULTIFUNCTION_DEVICE(PciData) \
    ((((PPCI_COMMON_CONFIG)(PciData))->HeaderType & PCI_MULTIFUNCTION) != 0)

//
// Bit encodings for PCI_COMMON_CONFIG.Command
//

#define PCI_ENABLE_IO_SPACE                 0x0001
#define PCI_ENABLE_MEMORY_SPACE             0x0002
#define PCI_ENABLE_BUS_MASTER               0x0004
#define PCI_ENABLE_SPECIAL_CYCLES           0x0008
#define PCI_ENABLE_WRITE_AND_INVALIDATE     0x0010
#define PCI_ENABLE_VGA_COMPATIBLE_PALETTE   0x0020
#define PCI_ENABLE_PARITY                   0x0040  // (ro+)
#define PCI_ENABLE_WAIT_CYCLE               0x0080  // (ro+)
#define PCI_ENABLE_SERR                     0x0100  // (ro+)
#define PCI_ENABLE_FAST_BACK_TO_BACK        0x0200  // (ro)

//
// Bit encodings for PCI_COMMON_CONFIG.Status
//

#define PCI_STATUS_CAPABILITIES_LIST        0x0010  // (ro)
#define PCI_STATUS_66MHZ_CAPABLE            0x0020  // (ro)
#define PCI_STATUS_UDF_SUPPORTED            0x0040  // (ro)
#define PCI_STATUS_FAST_BACK_TO_BACK        0x0080  // (ro)
#define PCI_STATUS_DATA_PARITY_DETECTED     0x0100
#define PCI_STATUS_DEVSEL                   0x0600  // 2 bits wide
#define PCI_STATUS_SIGNALED_TARGET_ABORT    0x0800
#define PCI_STATUS_RECEIVED_TARGET_ABORT    0x1000
#define PCI_STATUS_RECEIVED_MASTER_ABORT    0x2000
#define PCI_STATUS_SIGNALED_SYSTEM_ERROR    0x4000
#define PCI_STATUS_DETECTED_PARITY_ERROR    0x8000

//
// The NT PCI Driver uses a WhichSpace parameter on its CONFIG_READ/WRITE
// routines.   The following values are defined-
//

#define PCI_WHICHSPACE_CONFIG               0x0
#define PCI_WHICHSPACE_ROM                  0x52696350

// end_wdm
//
// PCI Capability IDs
//

#define PCI_CAPABILITY_ID_POWER_MANAGEMENT  0x01
#define PCI_CAPABILITY_ID_AGP               0x02
#define PCI_CAPABILITY_ID_MSI               0x05

//
// All PCI Capability structures have the following header.
//
// CapabilityID is used to identify the type of the structure (is
// one of the PCI_CAPABILITY_ID values above.
//
// Next is the offset in PCI Configuration space (0x40 - 0xfc) of the
// next capability structure in the list, or 0x00 if there are no more
// entries.
//
typedef struct _PCI_CAPABILITIES_HEADER {
    UCHAR   CapabilityID;
    UCHAR   Next;
} PCI_CAPABILITIES_HEADER, *PPCI_CAPABILITIES_HEADER;

//
// Power Management Capability
//

typedef struct _PCI_PMC {
    UCHAR       Version:3;
    UCHAR       PMEClock:1;
    UCHAR       Rsvd1:1;
    UCHAR       DeviceSpecificInitialization:1;
    UCHAR       Rsvd2:2;
    struct _PM_SUPPORT {
        UCHAR   Rsvd2:1;
        UCHAR   D1:1;
        UCHAR   D2:1;
        UCHAR   PMED0:1;
        UCHAR   PMED1:1;
        UCHAR   PMED2:1;
        UCHAR   PMED3Hot:1;
        UCHAR   PMED3Cold:1;
    } Support;
} PCI_PMC, *PPCI_PMC;

typedef struct _PCI_PMCSR {
    USHORT      PowerState:2;
    USHORT      Rsvd1:6;
    USHORT      PMEEnable:1;
    USHORT      DataSelect:4;
    USHORT      DataScale:2;
    USHORT      PMEStatus:1;
} PCI_PMCSR, *PPCI_PMCSR;


typedef struct _PCI_PMCSR_BSE {
    UCHAR       Rsvd1:6;
    UCHAR       D3HotSupportsStopClock:1;       // B2_B3#
    UCHAR       BusPowerClockControlEnabled:1;  // BPCC_EN
} PCI_PMCSR_BSE, *PPCI_PMCSR_BSE;


typedef struct _PCI_PM_CAPABILITY {

    PCI_CAPABILITIES_HEADER Header;

    //
    // Power Management Capabilities (Offset = 2)
    //

    union {
        PCI_PMC         Capabilities;
        USHORT          AsUSHORT;
    } PMC;

    //
    // Power Management Control/Status (Offset = 4)
    //

    union {
        PCI_PMCSR       ControlStatus;
        USHORT          AsUSHORT;
    } PMCSR;

    //
    // PMCSR PCI-PCI Bridge Support Extensions
    //

    union {
        PCI_PMCSR_BSE   BridgeSupport;
        UCHAR           AsUCHAR;
    } PMCSR_BSE;

    //
    // Optional read only 8 bit Data register.  Contents controlled by
    // DataSelect and DataScale in ControlStatus.
    //

    UCHAR   Data;

} PCI_PM_CAPABILITY, *PPCI_PM_CAPABILITY;

//
// AGP Capability
//

typedef struct _PCI_AGP_CAPABILITY {

    PCI_CAPABILITIES_HEADER Header;

    USHORT  Minor:4;
    USHORT  Major:4;
    USHORT  Rsvd1:8;

    struct  _PCI_AGP_STATUS {
        ULONG   Rate:3;
        ULONG   Rsvd1:1;
        ULONG   FastWrite:1;
        ULONG   FourGB:1;
        ULONG   Rsvd2:3;
        ULONG   SideBandAddressing:1;                   // SBA
        ULONG   Rsvd3:14;
        ULONG   RequestQueueDepthMaximum:8;             // RQ
    } AGPStatus;

    struct  _PCI_AGP_COMMAND {
        ULONG   Rate:3;
        ULONG   Rsvd1:1;
        ULONG   FastWriteEnable:1;
        ULONG   FourGBEnable:1;
        ULONG   Rsvd2:2;
        ULONG   AGPEnable:1;
        ULONG   SBAEnable:1;
        ULONG   Rsvd3:14;
        ULONG   RequestQueueDepth:8;
    } AGPCommand;

} PCI_AGP_CAPABILITY, *PPCI_AGP_CAPABILITY;

#define PCI_AGP_RATE_1X     0x1
#define PCI_AGP_RATE_2X     0x2
#define PCI_AGP_RATE_4X     0x4

//
// MSI (Message Signalled Interrupts) Capability
//

typedef struct _PCI_MSI_CAPABILITY {

      PCI_CAPABILITIES_HEADER Header;

      struct _PCI_MSI_MESSAGE_CONTROL {
         USHORT  MSIEnable:1;
         USHORT  MultipleMessageCapable:3;
         USHORT  MultipleMessageEnable:3;
         USHORT  CapableOf64Bits:1;
         USHORT  Reserved:8;
      } MessageControl;

      union {
            struct _PCI_MSI_MESSAGE_ADDRESS {
               ULONG_PTR Reserved:2;              // always zero, DWORD aligned address
               ULONG_PTR Address:30;
            } Register;
            ULONG_PTR Raw;
      } MessageAddress;

      //
      // The rest of the Capability structure differs depending on whether
      // 32bit or 64bit addressing is being used.
      //
      // (The CapableOf64Bits bit above determines this)
      //

      union {

         // For 64 bit devices

         struct _PCI_MSI_64BIT_DATA {
            ULONG MessageUpperAddress;
            USHORT MessageData;
         } Bit64;

         // For 32 bit devices

         struct _PCI_MSI_32BIT_DATA {
            USHORT MessageData;
            ULONG Unused;
         } Bit32;
      } Data;

} PCI_MSI_CAPABILITY, *PPCI_PCI_CAPABILITY;

// begin_wdm
//
// Base Class Code encodings for Base Class (from PCI spec rev 2.1).
//

#define PCI_CLASS_PRE_20                    0x00
#define PCI_CLASS_MASS_STORAGE_CTLR         0x01
#define PCI_CLASS_NETWORK_CTLR              0x02
#define PCI_CLASS_DISPLAY_CTLR              0x03
#define PCI_CLASS_MULTIMEDIA_DEV            0x04
#define PCI_CLASS_MEMORY_CTLR               0x05
#define PCI_CLASS_BRIDGE_DEV                0x06
#define PCI_CLASS_SIMPLE_COMMS_CTLR         0x07
#define PCI_CLASS_BASE_SYSTEM_DEV           0x08
#define PCI_CLASS_INPUT_DEV                 0x09
#define PCI_CLASS_DOCKING_STATION           0x0a
#define PCI_CLASS_PROCESSOR                 0x0b
#define PCI_CLASS_SERIAL_BUS_CTLR           0x0c

// 0d thru fe reserved

#define PCI_CLASS_NOT_DEFINED               0xff

//
// Sub Class Code encodings (PCI rev 2.1).
//

// Class 00 - PCI_CLASS_PRE_20

#define PCI_SUBCLASS_PRE_20_NON_VGA         0x00
#define PCI_SUBCLASS_PRE_20_VGA             0x01

// Class 01 - PCI_CLASS_MASS_STORAGE_CTLR

#define PCI_SUBCLASS_MSC_SCSI_BUS_CTLR      0x00
#define PCI_SUBCLASS_MSC_IDE_CTLR           0x01
#define PCI_SUBCLASS_MSC_FLOPPY_CTLR        0x02
#define PCI_SUBCLASS_MSC_IPI_CTLR           0x03
#define PCI_SUBCLASS_MSC_RAID_CTLR          0x04
#define PCI_SUBCLASS_MSC_OTHER              0x80

// Class 02 - PCI_CLASS_NETWORK_CTLR

#define PCI_SUBCLASS_NET_ETHERNET_CTLR      0x00
#define PCI_SUBCLASS_NET_TOKEN_RING_CTLR    0x01
#define PCI_SUBCLASS_NET_FDDI_CTLR          0x02
#define PCI_SUBCLASS_NET_ATM_CTLR           0x03
#define PCI_SUBCLASS_NET_OTHER              0x80

// Class 03 - PCI_CLASS_DISPLAY_CTLR

// N.B. Sub Class 00 could be VGA or 8514 depending on Interface byte

#define PCI_SUBCLASS_VID_VGA_CTLR           0x00
#define PCI_SUBCLASS_VID_XGA_CTLR           0x01
#define PCI_SUBCLASS_VID_OTHER              0x80

// Class 04 - PCI_CLASS_MULTIMEDIA_DEV

#define PCI_SUBCLASS_MM_VIDEO_DEV           0x00
#define PCI_SUBCLASS_MM_AUDIO_DEV           0x01
#define PCI_SUBCLASS_MM_OTHER               0x80

// Class 05 - PCI_CLASS_MEMORY_CTLR

#define PCI_SUBCLASS_MEM_RAM                0x00
#define PCI_SUBCLASS_MEM_FLASH              0x01
#define PCI_SUBCLASS_MEM_OTHER              0x80

// Class 06 - PCI_CLASS_BRIDGE_DEV

#define PCI_SUBCLASS_BR_HOST                0x00
#define PCI_SUBCLASS_BR_ISA                 0x01
#define PCI_SUBCLASS_BR_EISA                0x02
#define PCI_SUBCLASS_BR_MCA                 0x03
#define PCI_SUBCLASS_BR_PCI_TO_PCI          0x04
#define PCI_SUBCLASS_BR_PCMCIA              0x05
#define PCI_SUBCLASS_BR_NUBUS               0x06
#define PCI_SUBCLASS_BR_CARDBUS             0x07
#define PCI_SUBCLASS_BR_OTHER               0x80

// Class 07 - PCI_CLASS_SIMPLE_COMMS_CTLR

// N.B. Sub Class 00 and 01 additional info in Interface byte

#define PCI_SUBCLASS_COM_SERIAL             0x00
#define PCI_SUBCLASS_COM_PARALLEL           0x01
#define PCI_SUBCLASS_COM_OTHER              0x80

// Class 08 - PCI_CLASS_BASE_SYSTEM_DEV

// N.B. See Interface byte for additional info.

#define PCI_SUBCLASS_SYS_INTERRUPT_CTLR     0x00
#define PCI_SUBCLASS_SYS_DMA_CTLR           0x01
#define PCI_SUBCLASS_SYS_SYSTEM_TIMER       0x02
#define PCI_SUBCLASS_SYS_REAL_TIME_CLOCK    0x03
#define PCI_SUBCLASS_SYS_OTHER              0x80

// Class 09 - PCI_CLASS_INPUT_DEV

#define PCI_SUBCLASS_INP_KEYBOARD           0x00
#define PCI_SUBCLASS_INP_DIGITIZER          0x01
#define PCI_SUBCLASS_INP_MOUSE              0x02
#define PCI_SUBCLASS_INP_OTHER              0x80

// Class 0a - PCI_CLASS_DOCKING_STATION

#define PCI_SUBCLASS_DOC_GENERIC            0x00
#define PCI_SUBCLASS_DOC_OTHER              0x80

// Class 0b - PCI_CLASS_PROCESSOR

#define PCI_SUBCLASS_PROC_386               0x00
#define PCI_SUBCLASS_PROC_486               0x01
#define PCI_SUBCLASS_PROC_PENTIUM           0x02
#define PCI_SUBCLASS_PROC_ALPHA             0x10
#define PCI_SUBCLASS_PROC_POWERPC           0x20
#define PCI_SUBCLASS_PROC_COPROCESSOR       0x40

// Class 0c - PCI_CLASS_SERIAL_BUS_CTLR

#define PCI_SUBCLASS_SB_IEEE1394            0x00
#define PCI_SUBCLASS_SB_ACCESS              0x01
#define PCI_SUBCLASS_SB_SSA                 0x02
#define PCI_SUBCLASS_SB_USB                 0x03
#define PCI_SUBCLASS_SB_FIBRE_CHANNEL       0x04


// end_ntndis

//
// Bit encodes for PCI_COMMON_CONFIG.u.type0.BaseAddresses
//

#define PCI_ADDRESS_IO_SPACE                0x00000001  // (ro)
#define PCI_ADDRESS_MEMORY_TYPE_MASK        0x00000006  // (ro)
#define PCI_ADDRESS_MEMORY_PREFETCHABLE     0x00000008  // (ro)

#define PCI_ADDRESS_IO_ADDRESS_MASK         0xfffffffc
#define PCI_ADDRESS_MEMORY_ADDRESS_MASK     0xfffffff0
#define PCI_ADDRESS_ROM_ADDRESS_MASK        0xfffff800

#define PCI_TYPE_32BIT      0
#define PCI_TYPE_20BIT      2
#define PCI_TYPE_64BIT      4

//
// Bit encodes for PCI_COMMON_CONFIG.u.type0.ROMBaseAddresses
//

#define PCI_ROMADDRESS_ENABLED              0x00000001


//
// Reference notes for PCI configuration fields:
//
// ro   these field are read only.  changes to these fields are ignored
//
// ro+  these field are intended to be read only and should be initialized
//      by the system to their proper values.  However, driver may change
//      these settings.
//
// ---
//
//      All resources comsumed by a PCI device start as unitialized
//      under NT.  An uninitialized memory or I/O base address can be
//      determined by checking it's corrisponding enabled bit in the
//      PCI_COMMON_CONFIG.Command value.  An InterruptLine is unitialized
//      if it contains the value of -1.
//


//
// Defines the Type in the RESOURCE_DESCRIPTOR
//
// NOTE:  For all CM_RESOURCE_TYPE values, there must be a
// corresponding ResType value in the 32-bit ConfigMgr headerfile
// (cfgmgr32.h).  Values in the range [0x6,0x80) use the same values
// as their ConfigMgr counterparts.  CM_RESOURCE_TYPE values with
// the high bit set (i.e., in the range [0x80,0xFF]), are
// non-arbitrated resources.  These correspond to the same values
// in cfgmgr32.h that have their high bit set (however, since
// cfgmgr32.h uses 16 bits for ResType values, these values are in
// the range [0x8000,0x807F).  Note that ConfigMgr ResType values
// cannot be in the range [0x8080,0xFFFF), because they would not
// be able to map into CM_RESOURCE_TYPE values.  (0xFFFF itself is
// a special value, because it maps to CmResourceTypeDeviceSpecific.)
//

typedef int CM_RESOURCE_TYPE;

// CmResourceTypeNull is reserved

#define CmResourceTypeNull                0   // ResType_All or ResType_None (0x0000)
#define CmResourceTypePort                1   // ResType_IO (0x0002)
#define CmResourceTypeInterrupt           2   // ResType_IRQ (0x0004)
#define CmResourceTypeMemory              3   // ResType_Mem (0x0001)
#define CmResourceTypeDma                 4   // ResType_DMA (0x0003)
#define CmResourceTypeDeviceSpecific      5   // ResType_ClassSpecific (0xFFFF)
#define CmResourceTypeBusNumber           6   // ResType_BusNumber (0x0006)
// end_wdm
#define CmResourceTypeMaximum             7
#define CmResourceTypeAssignedResource    8   // BUGBUG--remove
#define CmResourceTypeSubAllocateFrom     9   // BUGBUG--remove
// begin_wdm
#define CmResourceTypeNonArbitrated     128   // Not arbitrated if 0x80 bit set
#define CmResourceTypeConfigData        128   // ResType_Reserved (0x8000)
#define CmResourceTypeDevicePrivate     129   // ResType_DevicePrivate (0x8001)
#define CmResourceTypePcCardConfig      130   // ResType_PcCardConfig (0x8002)
#define CmResourceTypeMfCardConfig      131   // ResType_MfCardConfig (0x8003)

//
// Defines the ShareDisposition in the RESOURCE_DESCRIPTOR
//

typedef enum _CM_SHARE_DISPOSITION {
    CmResourceShareUndetermined = 0,    // Reserved
    CmResourceShareDeviceExclusive,
    CmResourceShareDriverExclusive,
    CmResourceShareShared
} CM_SHARE_DISPOSITION;

//
// Define the PASSIGNED_RESOURCE type
//

#ifndef PASSIGNED_RESOURCE_DEFINED
#define PASSIGNED_RESOURCE_DEFINED
typedef PVOID PASSIGNED_RESOURCE;
#endif // PASSIGNED_RESOURCE_DEFINED

// end_wdm

//
// Define the bit masks for Flags common for all CM_RESOURCE_TYPE
//
// BUGBUG--remove the following 3 flags...
//
#define CM_RESOURCE_COMMON_COMPUTE_LENGTH_FROM_DEPENDENTS   0x8000
#define CM_RESOURCE_COMMON_NOT_REASSIGNED                   0x4000
#define CM_RESOURCE_COMMON_SUBSTRACTIVE                     0x2000

// begin_wdm

//
// Define the bit masks for Flags when type is CmResourceTypeInterrupt
//

#define CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE 0
#define CM_RESOURCE_INTERRUPT_LATCHED         1

//
// Define the bit masks for Flags when type is CmResourceTypeMemory
//

#define CM_RESOURCE_MEMORY_READ_WRITE       0x0000
#define CM_RESOURCE_MEMORY_READ_ONLY        0x0001
#define CM_RESOURCE_MEMORY_WRITE_ONLY       0x0002
#define CM_RESOURCE_MEMORY_PREFETCHABLE     0x0004

#define CM_RESOURCE_MEMORY_COMBINEDWRITE    0x0008
#define CM_RESOURCE_MEMORY_24               0x0010
#define CM_RESOURCE_MEMORY_CACHEABLE        0x0020

//
// Define the bit masks for Flags when type is CmResourceTypePort
//

#define CM_RESOURCE_PORT_MEMORY                             0x0000
#define CM_RESOURCE_PORT_IO                                 0x0001
// end_wdm
#define CM_RESOURCE_PORT_FORWARD_FIRST_256_OF_EACH_1024     0x0002  // BUGBUG--remove
// begin_wdm
#define CM_RESOURCE_PORT_10_BIT_DECODE                      0x0004
#define CM_RESOURCE_PORT_12_BIT_DECODE                      0x0008
#define CM_RESOURCE_PORT_16_BIT_DECODE                      0x0010
#define CM_RESOURCE_PORT_POSITIVE_DECODE                    0x0020
#define CM_RESOURCE_PORT_PASSIVE_DECODE                     0x0040
#define CM_RESOURCE_PORT_WINDOW_DECODE                      0x0080

//
// Define the bit masks for Flags when type is CmResourceTypeDma
//

#define CM_RESOURCE_DMA_8                   0x0000
#define CM_RESOURCE_DMA_16                  0x0001
#define CM_RESOURCE_DMA_32                  0x0002
#define CM_RESOURCE_DMA_8_AND_16            0x0004
#define CM_RESOURCE_DMA_BUS_MASTER          0x0008
#define CM_RESOURCE_DMA_TYPE_A              0x0010
#define CM_RESOURCE_DMA_TYPE_B              0x0020
#define CM_RESOURCE_DMA_TYPE_F              0x0040
// end_wdm

//
// Define the bit masks for Flags when type is CmResourceTypeBusNumber
//

#define CM_RESOURCE_BUSNUMBER_SUBALLOCATE_FIRST_VALUE   0x0001  // BUGBUG--remove

//
// Define the bit masks for Flags when type is CmResourceTypeSubAllocateFrom
//

#define CM_RESOURCE_SUBALLOCATEFROM_FIXED_TRANSLATION   0x0001  // BUGBUG--remove
#define CM_RESOURCE_SUBALLOCATEFROM_WIRED_TRANSLATION   0x0002  // BUGBUG--remove


#include "pshpack1.h"


//
// Define Mca POS data block for slot
//

typedef struct _CM_MCA_POS_DATA {
    USHORT AdapterId;
    UCHAR PosData1;
    UCHAR PosData2;
    UCHAR PosData3;
    UCHAR PosData4;
} CM_MCA_POS_DATA, *PCM_MCA_POS_DATA;

//
// Memory configuration of eisa data block structure
//

typedef struct _EISA_MEMORY_TYPE {
    UCHAR ReadWrite: 1;
    UCHAR Cached : 1;
    UCHAR Reserved0 :1;
    UCHAR Type:2;
    UCHAR Shared:1;
    UCHAR Reserved1 :1;
    UCHAR MoreEntries : 1;
} EISA_MEMORY_TYPE, *PEISA_MEMORY_TYPE;

typedef struct _EISA_MEMORY_CONFIGURATION {
    EISA_MEMORY_TYPE ConfigurationByte;
    UCHAR DataSize;
    USHORT AddressLowWord;
    UCHAR AddressHighByte;
    USHORT MemorySize;
} EISA_MEMORY_CONFIGURATION, *PEISA_MEMORY_CONFIGURATION;


//
// Interrupt configurationn of eisa data block structure
//

typedef struct _EISA_IRQ_DESCRIPTOR {
    UCHAR Interrupt : 4;
    UCHAR Reserved :1;
    UCHAR LevelTriggered :1;
    UCHAR Shared : 1;
    UCHAR MoreEntries : 1;
} EISA_IRQ_DESCRIPTOR, *PEISA_IRQ_DESCRIPTOR;

typedef struct _EISA_IRQ_CONFIGURATION {
    EISA_IRQ_DESCRIPTOR ConfigurationByte;
    UCHAR Reserved;
} EISA_IRQ_CONFIGURATION, *PEISA_IRQ_CONFIGURATION;


//
// DMA description of eisa data block structure
//

typedef struct _DMA_CONFIGURATION_BYTE0 {
    UCHAR Channel : 3;
    UCHAR Reserved : 3;
    UCHAR Shared :1;
    UCHAR MoreEntries :1;
} DMA_CONFIGURATION_BYTE0;

typedef struct _DMA_CONFIGURATION_BYTE1 {
    UCHAR Reserved0 : 2;
    UCHAR TransferSize : 2;
    UCHAR Timing : 2;
    UCHAR Reserved1 : 2;
} DMA_CONFIGURATION_BYTE1;

typedef struct _EISA_DMA_CONFIGURATION {
    DMA_CONFIGURATION_BYTE0 ConfigurationByte0;
    DMA_CONFIGURATION_BYTE1 ConfigurationByte1;
} EISA_DMA_CONFIGURATION, *PEISA_DMA_CONFIGURATION;


//
// Port description of eisa data block structure
//

typedef struct _EISA_PORT_DESCRIPTOR {
    UCHAR NumberPorts : 5;
    UCHAR Reserved :1;
    UCHAR Shared :1;
    UCHAR MoreEntries : 1;
} EISA_PORT_DESCRIPTOR, *PEISA_PORT_DESCRIPTOR;

typedef struct _EISA_PORT_CONFIGURATION {
    EISA_PORT_DESCRIPTOR Configuration;
    USHORT PortAddress;
} EISA_PORT_CONFIGURATION, *PEISA_PORT_CONFIGURATION;


//
// Eisa slot information definition
// N.B. This structure is different from the one defined
//      in ARC eisa addendum.
//

typedef struct _CM_EISA_SLOT_INFORMATION {
    UCHAR ReturnCode;
    UCHAR ReturnFlags;
    UCHAR MajorRevision;
    UCHAR MinorRevision;
    USHORT Checksum;
    UCHAR NumberFunctions;
    UCHAR FunctionInformation;
    ULONG CompressedId;
} CM_EISA_SLOT_INFORMATION, *PCM_EISA_SLOT_INFORMATION;


//
// Eisa function information definition
//

typedef struct _CM_EISA_FUNCTION_INFORMATION {
    ULONG CompressedId;
    UCHAR IdSlotFlags1;
    UCHAR IdSlotFlags2;
    UCHAR MinorRevision;
    UCHAR MajorRevision;
    UCHAR Selections[26];
    UCHAR FunctionFlags;
    UCHAR TypeString[80];
    EISA_MEMORY_CONFIGURATION EisaMemory[9];
    EISA_IRQ_CONFIGURATION EisaIrq[7];
    EISA_DMA_CONFIGURATION EisaDma[4];
    EISA_PORT_CONFIGURATION EisaPort[20];
    UCHAR InitializationData[60];
} CM_EISA_FUNCTION_INFORMATION, *PCM_EISA_FUNCTION_INFORMATION;

//
// The following defines the way pnp bios information is stored in
// the registry \\HKEY_LOCAL_MACHINE\HARDWARE\Description\System\MultifunctionAdapter\x
// key, where x is an integer number indicating adapter instance. The
// "Identifier" of the key must equal to "PNP BIOS" and the
// "ConfigurationData" is organized as follow:
//
//      CM_PNP_BIOS_INSTALLATION_CHECK        +
//      CM_PNP_BIOS_DEVICE_NODE for device 1  +
//      CM_PNP_BIOS_DEVICE_NODE for device 2  +
//                ...
//      CM_PNP_BIOS_DEVICE_NODE for device n
//

//
// Pnp BIOS device node structure
//

typedef struct _CM_PNP_BIOS_DEVICE_NODE {
    USHORT Size;
    UCHAR Node;
    ULONG ProductId;
    UCHAR DeviceType[3];
    USHORT DeviceAttributes;
    // followed by AllocatedResourceBlock, PossibleResourceBlock
    // and CompatibleDeviceId
} CM_PNP_BIOS_DEVICE_NODE,*PCM_PNP_BIOS_DEVICE_NODE;

//
// Pnp BIOS Installation check
//

typedef struct _CM_PNP_BIOS_INSTALLATION_CHECK {
    UCHAR Signature[4];             // $PnP (ascii)
    UCHAR Revision;
    UCHAR Length;
    USHORT ControlField;
    UCHAR Checksum;
    ULONG EventFlagAddress;         // Physical address
    USHORT RealModeEntryOffset;
    USHORT RealModeEntrySegment;
    USHORT ProtectedModeEntryOffset;
    ULONG ProtectedModeCodeBaseAddress;
    ULONG OemDeviceId;
    USHORT RealModeDataBaseAddress;
    ULONG ProtectedModeDataBaseAddress;
} CM_PNP_BIOS_INSTALLATION_CHECK, *PCM_PNP_BIOS_INSTALLATION_CHECK;

#include "poppack.h"

//
// Masks for EISA function information
//

#define EISA_FUNCTION_ENABLED                   0x80
#define EISA_FREE_FORM_DATA                     0x40
#define EISA_HAS_PORT_INIT_ENTRY                0x20
#define EISA_HAS_PORT_RANGE                     0x10
#define EISA_HAS_DMA_ENTRY                      0x08
#define EISA_HAS_IRQ_ENTRY                      0x04
#define EISA_HAS_MEMORY_ENTRY                   0x02
#define EISA_HAS_TYPE_ENTRY                     0x01
#define EISA_HAS_INFORMATION                    EISA_HAS_PORT_RANGE + \
                                                EISA_HAS_DMA_ENTRY + \
                                                EISA_HAS_IRQ_ENTRY + \
                                                EISA_HAS_MEMORY_ENTRY + \
                                                EISA_HAS_TYPE_ENTRY

//
// Masks for EISA memory configuration
//

#define EISA_MORE_ENTRIES                       0x80
#define EISA_SYSTEM_MEMORY                      0x00
#define EISA_MEMORY_TYPE_RAM                    0x01

//
// Returned error code for EISA bios call
//

#define EISA_INVALID_SLOT                       0x80
#define EISA_INVALID_FUNCTION                   0x81
#define EISA_INVALID_CONFIGURATION              0x82
#define EISA_EMPTY_SLOT                         0x83
#define EISA_INVALID_BIOS_CALL                  0x86


//
// Defines Resource Options
//

#define IO_RESOURCE_PREFERRED       0x01
#define IO_RESOURCE_DEFAULT         0x02
#define IO_RESOURCE_ALTERNATIVE     0x08


//
// This structure defines one type of resource requested by the driver
//

typedef struct _IO_RESOURCE_DESCRIPTOR {
    UCHAR Option;
    UCHAR Type;                         // use CM_RESOURCE_TYPE
    UCHAR ShareDisposition;             // use CM_SHARE_DISPOSITION
    UCHAR Spare1;
    USHORT Flags;                       // use CM resource flag defines
    USHORT Spare2;                      // align

    union {
        struct {
            ULONG Length;
            ULONG Alignment;
            PHYSICAL_ADDRESS MinimumAddress;
            PHYSICAL_ADDRESS MaximumAddress;
        } Port;

        struct {
            ULONG Length;
            ULONG Alignment;
            PHYSICAL_ADDRESS MinimumAddress;
            PHYSICAL_ADDRESS MaximumAddress;
        } Memory;

        struct {
            ULONG MinimumVector;
            ULONG MaximumVector;
        } Interrupt;

        struct {
            ULONG MinimumChannel;
            ULONG MaximumChannel;
        } Dma;

        struct {
            ULONG Length;
            ULONG Alignment;
            PHYSICAL_ADDRESS MinimumAddress;
            PHYSICAL_ADDRESS MaximumAddress;
        } Generic;

        struct {
            ULONG Data[3];
        } DevicePrivate;

        //
        // Bus Number information.
        //

        struct {
            ULONG Length;
            ULONG MinBusNumber;
            ULONG MaxBusNumber;
            ULONG Reserved;
        } BusNumber;

// end_wdm

        struct {
            PASSIGNED_RESOURCE AssignedResource;
        } AssignedResource;     // will be obsoleted

        struct {
            UCHAR Type;                 // use CM_RESOURCE_TYPE
            UCHAR Reserved[3];
            PASSIGNED_RESOURCE AssignedResource;
            PHYSICAL_ADDRESS Transformation;
        } SubAllocateFrom;      // will be obsoleted

// begin_wdm

        struct {
            ULONG Priority;   // use LCPRI_Xxx values in cfg.h
            ULONG Reserved1;
            ULONG Reserved2;
        } ConfigData;

    } u;

} IO_RESOURCE_DESCRIPTOR, *PIO_RESOURCE_DESCRIPTOR;


#endif /* _MINIPORT_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\public\ddk\inc\ntddk.h ===
/*++ BUILD Version: 0095    // Increment this if a change has global effects

Copyright (c) 1990-1999  Microsoft Corporation

Module Name:

    ntddk.h

Abstract:

    This module defines the NT types, constants, and functions that are
    exposed to device drivers.

Revision History:

--*/

#ifndef _NTDDK_
#define _NTDDK_

#define NT_INCLUDED
#define _CTYPE_DISABLE_MACROS

#include <wdmwarn4.h>
#include <excpt.h>
#include <ntdef.h>
#include <ntstatus.h>
#include <bugcodes.h>

#ifdef __cplusplus
extern "C" {   // extern "C"
#endif

//
// Define types that are not exported.
//

typedef struct _KTHREAD *PKTHREAD;
typedef struct _ETHREAD *PETHREAD;
typedef struct _EPROCESS *PEPROCESS;
typedef struct _PEB *PPEB;
typedef struct _KINTERRUPT *PKINTERRUPT;
typedef struct _IO_TIMER *PIO_TIMER;
typedef struct _OBJECT_TYPE *POBJECT_TYPE;
typedef struct _CALLBACK_OBJECT *PCALLBACK_OBJECT;
typedef struct _DEVICE_HANDLER_OBJECT *PDEVICE_HANDLER_OBJECT;
typedef struct _BUS_HANDLER *PBUS_HANDLER;

#if defined(_M_ALPHA)
void *__rdthread(void);
#pragma intrinsic(__rdthread)

unsigned char __swpirql(unsigned char);
#pragma intrinsic(__swpirql)

void *__rdpcr(void);
#pragma intrinsic(__rdpcr)
#define PCR ((PKPCR)__rdpcr())

#define KeGetCurrentThread() ((struct _KTHREAD *) __rdthread())
#endif // defined(_M_ALPHA)

#if defined(_M_IX86)
PKTHREAD NTAPI KeGetCurrentThread();
#endif // defined(_M_IX86)

#if defined(_M_IA64)

//
// Define Address of Processor Control Registers.
//

#define KIPCR ((ULONG_PTR)(KADDRESS_BASE + 0xffff0000))            // kernel address of first PCR

//
// Define Pointer to Processor Control Registers.
//

#define PCR ((volatile KPCR * const)KIPCR)

PKTHREAD NTAPI KeGetCurrentThread();

#endif // defined(_M_IA64)

#define PsGetCurrentProcess() IoGetCurrentProcess()
#define PsGetCurrentThread() ((PETHREAD) (KeGetCurrentThread()))
extern PCCHAR KeNumberProcessors;

#ifndef FAR
#define FAR
#endif

typedef union _SLIST_HEADER {
    ULONGLONG Alignment;
    struct {
        SINGLE_LIST_ENTRY Next;
        USHORT Depth;
        USHORT Sequence;
    };
} SLIST_HEADER, *PSLIST_HEADER;


//
// Define alignment macros to align structure sizes and pointers up and down.
//

#define ALIGN_DOWN(length, type) \
    ((ULONG)(length) & ~(sizeof(type) - 1))

#define ALIGN_UP(length, type) \
    (ALIGN_DOWN(((ULONG)(length) + sizeof(type) - 1), type))

#define ALIGN_DOWN_POINTER(address, type) \
    ((PVOID)((ULONG_PTR)(address) & ~((ULONG_PTR)sizeof(type) - 1)))

#define ALIGN_UP_POINTER(address, type) \
    (ALIGN_DOWN_POINTER(((ULONG_PTR)(address) + sizeof(type) - 1), type))

#define POOL_TAGGING 1

#ifndef DBG
#define DBG 0
#endif

#if DBG
#define IF_DEBUG if (TRUE)
#else
#define IF_DEBUG if (FALSE)
#endif

#if DEVL


extern ULONG NtGlobalFlag;

#define IF_NTOS_DEBUG( FlagName ) \
    if (NtGlobalFlag & (FLG_ ## FlagName))

#else
#define IF_NTOS_DEBUG( FlagName ) if (FALSE)
#endif

//
// Kernel definitions that need to be here for forward reference purposes
//

//
// APC function types
//

//
// Put in an empty definition for the KAPC so that the
// routines can reference it before it is declared.
//

struct _KAPC;

typedef
VOID
(*PKNORMAL_ROUTINE) (
    IN PVOID NormalContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

typedef
VOID
(*PKKERNEL_ROUTINE) (
    IN struct _KAPC *Apc,
    IN OUT PKNORMAL_ROUTINE *NormalRoutine,
    IN OUT PVOID *NormalContext,
    IN OUT PVOID *SystemArgument1,
    IN OUT PVOID *SystemArgument2
    );

typedef
VOID
(*PKRUNDOWN_ROUTINE) (
    IN struct _KAPC *Apc
    );

typedef
BOOLEAN
(*PKSYNCHRONIZE_ROUTINE) (
    IN PVOID SynchronizeContext
    );

typedef
BOOLEAN
(*PKTRANSFER_ROUTINE) (
    VOID
    );

//
//
// Asynchronous Procedure Call (APC) object
//

typedef struct _KAPC {
    CSHORT Type;
    KPROCESSOR_MODE ApcMode;
    BOOLEAN Inserted;
    struct _KTHREAD *Thread;
    LIST_ENTRY ApcListEntry;
    PKKERNEL_ROUTINE KernelRoutine;
    PKRUNDOWN_ROUTINE RundownRoutine;
    PKNORMAL_ROUTINE NormalRoutine;
    PVOID NormalContext;

    //
    // N.B. The following two members MUST be together.
    //

    PVOID SystemArgument1;
    PVOID SystemArgument2;
} KAPC, *PKAPC, *RESTRICTED_POINTER PRKAPC;

// begin_ntndis
//
// DPC routine
//

struct _KDPC;

typedef
VOID
(*PKDEFERRED_ROUTINE) (
    IN struct _KDPC *Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

//
// Deferred Procedure Call (DPC) object
//

typedef struct _KDPC {
    CSHORT Type;
    BOOLEAN Inserted;
    UCHAR Padding;
    LIST_ENTRY DpcListEntry;
    PKDEFERRED_ROUTINE DeferredRoutine;
    PVOID DeferredContext;
    PVOID SystemArgument1;
    PVOID SystemArgument2;
} KDPC, *PKDPC, *RESTRICTED_POINTER PRKDPC;

// end_ntndis
//
// switch to DBG when appropriate
//

#if DBG
#define PAGED_CODE() \
    if (KeGetCurrentIrql() > APC_LEVEL) { \
    KdPrint(( "EX: Pageable code called at IRQL %d\n", KeGetCurrentIrql() )); \
        ASSERT(FALSE); \
        }
#else
#define PAGED_CODE()
#endif

//
// Define function decoration depending on whether a driver, a file system,
// or a kernel component is being built.
//
// end_wdm

#if !defined(_NTSYSTEM_)

#define NTKERNELAPI DECLSPEC_IMPORT         // wdm

#else

#define NTKERNELAPI

#endif

//
// Define function decoration depending on whether the HAL or other kernel
// component is being build.
//

#define NTHALAPI NTKERNELAPI

//
// Define a statically allocated object string.
//

#define INITIALIZED_OBJECT_STRING(ObjectString, Value)                      \
    OCHAR ObjectString##Buffer[] = Value;                                   \
    OBJECT_STRING ObjectString = {                                          \
        sizeof(Value) - sizeof(OCHAR),                                      \
        sizeof(Value),                                                      \
        ObjectString##Buffer                                                \
    }

#define INITIALIZED_OBJECT_STRING_RDATA(ObjectString, Value)                \
    OCHAR DECLSPEC_RDATA ObjectString##Buffer[] = Value;                    \
    OBJECT_STRING DECLSPEC_RDATA ObjectString = {                           \
        sizeof(Value) - sizeof(OCHAR),                                      \
        sizeof(Value),                                                      \
        ObjectString##Buffer                                                \
    }

//
// Define a statically allocated list entry.
//

#define INITIALIZED_LIST_ENTRY(ListEntry)                       \
    LIST_ENTRY ListEntry = {                                    \
        &ListEntry, &ListEntry                                  \
    }

//
//  Define an access token from a programmer's viewpoint.  The structure is
//  completely opaque and the programer is only allowed to have pointers
//  to tokens.
//

typedef PVOID PACCESS_TOKEN;            // winnt

//
// Pointer to a SECURITY_DESCRIPTOR  opaque data type.
//

typedef PVOID PSECURITY_DESCRIPTOR;     // winnt

//
// Define a pointer to the Security ID data type (an opaque data type)
//

typedef PVOID PSID;     // winnt

typedef ULONG ACCESS_MASK;
typedef ACCESS_MASK *PACCESS_MASK;

// end_winnt
//
//  The following are masks for the predefined standard access types
//

#define DELETE                           (0x00010000L)
#define READ_CONTROL                     (0x00020000L)
#define WRITE_DAC                        (0x00040000L)
#define WRITE_OWNER                      (0x00080000L)
#define SYNCHRONIZE                      (0x00100000L)

#define STANDARD_RIGHTS_REQUIRED         (0x000F0000L)

#define STANDARD_RIGHTS_READ             (READ_CONTROL)
#define STANDARD_RIGHTS_WRITE            (READ_CONTROL)
#define STANDARD_RIGHTS_EXECUTE          (READ_CONTROL)

#define STANDARD_RIGHTS_ALL              (0x001F0000L)

#define SPECIFIC_RIGHTS_ALL              (0x0000FFFFL)

//
// AccessSystemAcl access type
//

#define ACCESS_SYSTEM_SECURITY           (0x01000000L)

//
// MaximumAllowed access type
//

#define MAXIMUM_ALLOWED                  (0x02000000L)

//
//  These are the generic rights.
//

#define GENERIC_READ                     (0x80000000L)
#define GENERIC_WRITE                    (0x40000000L)
#define GENERIC_EXECUTE                  (0x20000000L)
#define GENERIC_ALL                      (0x10000000L)


//
//  Define the generic mapping array.  This is used to denote the
//  mapping of each generic access right to a specific access mask.
//

typedef struct _GENERIC_MAPPING {
    ACCESS_MASK GenericRead;
    ACCESS_MASK GenericWrite;
    ACCESS_MASK GenericExecute;
    ACCESS_MASK GenericAll;
} GENERIC_MAPPING;
typedef GENERIC_MAPPING *PGENERIC_MAPPING;



////////////////////////////////////////////////////////////////////////
//                                                                    //
//                        LUID_AND_ATTRIBUTES                         //
//                                                                    //
////////////////////////////////////////////////////////////////////////
//
//


#include <pshpack4.h>

typedef struct _LUID_AND_ATTRIBUTES {
    LUID Luid;
    ULONG Attributes;
    } LUID_AND_ATTRIBUTES, * PLUID_AND_ATTRIBUTES;
typedef LUID_AND_ATTRIBUTES LUID_AND_ATTRIBUTES_ARRAY[ANYSIZE_ARRAY];
typedef LUID_AND_ATTRIBUTES_ARRAY *PLUID_AND_ATTRIBUTES_ARRAY;

#include <poppack.h>

// This is the *current* ACL revision

#define ACL_REVISION     (2)
#define ACL_REVISION_DS  (4)

// This is the history of ACL revisions.  Add a new one whenever
// ACL_REVISION is updated

#define ACL_REVISION1   (1)
#define MIN_ACL_REVISION ACL_REVISION2
#define ACL_REVISION2   (2)
#define ACL_REVISION3   (3)
#define ACL_REVISION4   (4)
#define MAX_ACL_REVISION ACL_REVISION4

typedef struct _ACL {
    UCHAR AclRevision;
    UCHAR Sbz1;
    USHORT AclSize;
    USHORT AceCount;
    USHORT Sbz2;
} ACL;
typedef ACL *PACL;

//
// Current security descriptor revision value
//

#define SECURITY_DESCRIPTOR_REVISION     (1)
#define SECURITY_DESCRIPTOR_REVISION1    (1)

//
// Privilege attributes
//

#define SE_PRIVILEGE_ENABLED_BY_DEFAULT (0x00000001L)
#define SE_PRIVILEGE_ENABLED            (0x00000002L)
#define SE_PRIVILEGE_USED_FOR_ACCESS    (0x80000000L)

//
// Privilege Set Control flags
//

#define PRIVILEGE_SET_ALL_NECESSARY    (1)

//
//  Privilege Set - This is defined for a privilege set of one.
//                  If more than one privilege is needed, then this structure
//                  will need to be allocated with more space.
//
//  Note: don't change this structure without fixing the INITIAL_PRIVILEGE_SET
//  structure (defined in se.h)
//

typedef struct _PRIVILEGE_SET {
    ULONG PrivilegeCount;
    ULONG Control;
    LUID_AND_ATTRIBUTES Privilege[ANYSIZE_ARRAY];
    } PRIVILEGE_SET, * PPRIVILEGE_SET;

//
// These must be converted to LUIDs before use.
//

#define SE_MIN_WELL_KNOWN_PRIVILEGE       (2L)
#define SE_CREATE_TOKEN_PRIVILEGE         (2L)
#define SE_ASSIGNPRIMARYTOKEN_PRIVILEGE   (3L)
#define SE_LOCK_MEMORY_PRIVILEGE          (4L)
#define SE_INCREASE_QUOTA_PRIVILEGE       (5L)

//
// Unsolicited Input is obsolete and unused.
//

#define SE_UNSOLICITED_INPUT_PRIVILEGE    (6L)

#define SE_MACHINE_ACCOUNT_PRIVILEGE      (6L)
#define SE_TCB_PRIVILEGE                  (7L)
#define SE_SECURITY_PRIVILEGE             (8L)
#define SE_TAKE_OWNERSHIP_PRIVILEGE       (9L)
#define SE_LOAD_DRIVER_PRIVILEGE          (10L)
#define SE_SYSTEM_PROFILE_PRIVILEGE       (11L)
#define SE_SYSTEMTIME_PRIVILEGE           (12L)
#define SE_PROF_SINGLE_PROCESS_PRIVILEGE  (13L)
#define SE_INC_BASE_PRIORITY_PRIVILEGE    (14L)
#define SE_CREATE_PAGEFILE_PRIVILEGE      (15L)
#define SE_CREATE_PERMANENT_PRIVILEGE     (16L)
#define SE_BACKUP_PRIVILEGE               (17L)
#define SE_RESTORE_PRIVILEGE              (18L)
#define SE_SHUTDOWN_PRIVILEGE             (19L)
#define SE_DEBUG_PRIVILEGE                (20L)
#define SE_AUDIT_PRIVILEGE                (21L)
#define SE_SYSTEM_ENVIRONMENT_PRIVILEGE   (22L)
#define SE_CHANGE_NOTIFY_PRIVILEGE        (23L)
#define SE_REMOTE_SHUTDOWN_PRIVILEGE      (24L)
#define SE_UNDOCK_PRIVILEGE               (25L)
#define SE_SYNC_AGENT_PRIVILEGE           (26L)
#define SE_ENABLE_DELEGATION_PRIVILEGE    (27L)
#define SE_MAX_WELL_KNOWN_PRIVILEGE       (SE_ENABLE_DELEGATION_PRIVILEGE)

//
// Impersonation Level
//
// Impersonation level is represented by a pair of bits in Windows.
// If a new impersonation level is added or lowest value is changed from
// 0 to something else, fix the Windows CreateFile call.
//

typedef enum _SECURITY_IMPERSONATION_LEVEL {
    SecurityAnonymous,
    SecurityIdentification,
    SecurityImpersonation,
    SecurityDelegation
    } SECURITY_IMPERSONATION_LEVEL, * PSECURITY_IMPERSONATION_LEVEL;

#define SECURITY_MAX_IMPERSONATION_LEVEL SecurityDelegation

#define DEFAULT_IMPERSONATION_LEVEL SecurityImpersonation

//
// Security Tracking Mode
//

#define SECURITY_DYNAMIC_TRACKING      (TRUE)
#define SECURITY_STATIC_TRACKING       (FALSE)

typedef BOOLEAN SECURITY_CONTEXT_TRACKING_MODE,
                    * PSECURITY_CONTEXT_TRACKING_MODE;



//
// Quality Of Service
//

typedef struct _SECURITY_QUALITY_OF_SERVICE {
    ULONG Length;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
    SECURITY_CONTEXT_TRACKING_MODE ContextTrackingMode;
    BOOLEAN EffectiveOnly;
    } SECURITY_QUALITY_OF_SERVICE, * PSECURITY_QUALITY_OF_SERVICE;


//
// Used to represent information related to a thread impersonation
//

typedef struct _SE_IMPERSONATION_STATE {
    PACCESS_TOKEN Token;
    BOOLEAN CopyOnOpen;
    BOOLEAN EffectiveOnly;
    SECURITY_IMPERSONATION_LEVEL Level;
} SE_IMPERSONATION_STATE, *PSE_IMPERSONATION_STATE;


typedef ULONG SECURITY_INFORMATION, *PSECURITY_INFORMATION;

#define OWNER_SECURITY_INFORMATION       (0x00000001L)
#define GROUP_SECURITY_INFORMATION       (0x00000002L)
#define DACL_SECURITY_INFORMATION        (0x00000004L)
#define SACL_SECURITY_INFORMATION        (0x00000008L)

#define PROTECTED_DACL_SECURITY_INFORMATION     (0x80000000L)
#define PROTECTED_SACL_SECURITY_INFORMATION     (0x40000000L)
#define UNPROTECTED_DACL_SECURITY_INFORMATION   (0x20000000L)
#define UNPROTECTED_SACL_SECURITY_INFORMATION   (0x10000000L)


#define LOW_PRIORITY 0              // Lowest thread priority level
#define LOW_REALTIME_PRIORITY 16    // Lowest realtime priority level
#define HIGH_PRIORITY 31            // Highest thread priority level
#define MAXIMUM_PRIORITY 32         // Number of thread priority levels
// begin_winnt
#define MAXIMUM_WAIT_OBJECTS 64     // Maximum number of wait objects

#define MAXIMUM_SUSPEND_COUNT MAXCHAR // Maximum times thread can be suspended
// end_winnt

//
// Thread affinity
//

typedef ULONG KAFFINITY;
typedef KAFFINITY *PKAFFINITY;

//
// Thread priority
//

typedef LONG KPRIORITY;

//
// Spin Lock
//

// begin_ntndis begin_winnt

typedef ULONG_PTR KSPIN_LOCK;
typedef KSPIN_LOCK *PKSPIN_LOCK;

// end_ntndis end_winnt

//
// Interrupt routine (first level dispatch)
//

typedef
VOID
(*PKINTERRUPT_ROUTINE) (
    VOID
    );

//
// Profile source types
//
typedef enum _KPROFILE_SOURCE {
    ProfileTime,
    ProfileAlignmentFixup,
    ProfileTotalIssues,
    ProfilePipelineDry,
    ProfileLoadInstructions,
    ProfilePipelineFrozen,
    ProfileBranchInstructions,
    ProfileTotalNonissues,
    ProfileDcacheMisses,
    ProfileIcacheMisses,
    ProfileCacheMisses,
    ProfileBranchMispredictions,
    ProfileStoreInstructions,
    ProfileFpInstructions,
    ProfileIntegerInstructions,
    Profile2Issue,
    Profile3Issue,
    Profile4Issue,
    ProfileSpecialInstructions,
    ProfileTotalCycles,
    ProfileIcacheIssues,
    ProfileDcacheAccesses,
    ProfileMemoryBarrierCycles,
    ProfileLoadLinkedIssues,
    ProfileMaximum
} KPROFILE_SOURCE;

//
// for move macros
//
#ifdef _MAC
#ifndef _INC_STRING
#include <string.h>
#endif /* _INC_STRING */
#else
#include <string.h>
#endif // _MAC

//
// If debugging support enabled, define an ASSERT macro that works.  Otherwise
// define the ASSERT macro to expand to an empty expression.
//

#if DBG
NTSYSAPI
VOID
NTAPI
RtlAssert(
    PVOID FailedAssertion,
    PVOID FileName,
    ULONG LineNumber,
    PCHAR Message
    );

#define ASSERT( exp ) \
    if (!(exp)) \
        RtlAssert( #exp, __FILE__, __LINE__, NULL )

#define ASSERTMSG( msg, exp ) \
    if (!(exp)) \
        RtlAssert( #exp, __FILE__, __LINE__, msg )

VOID
NTAPI
RtlRip(
    IN PVOID ApiName,
    IN PVOID Expression,
    IN PVOID Message
    );

#define RIP(Message) \
    do { RtlRip( NULL, NULL, Message ); } while(0)

#define RIP_ON_NOT_TRUE(ApiName, Expression) \
    do { if (!(Expression)) RtlRip(ApiName, #Expression, NULL); } while(0)

#define RIP_ON_NOT_TRUE_WITH_MESSAGE(Expression, Message) \
    do { if (!(Expression)) RtlRip(NULL, #Expression, Message); } while(0)

#else
#define ASSERT( exp )
#define ASSERTMSG( msg, exp )
#define RIP(msg)
#define RIP_ON_NOT_TRUE(api, exp)
#define RIP_ON_NOT_TRUE_WITH_MESSAGE(exp, msg)
#endif // DBG

//
//  Doubly-linked list manipulation routines.  Implemented as macros
//  but logically these are procedures.
//

//
//  VOID
//  InitializeListHead(
//      PLIST_ENTRY ListHead
//      );
//

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

//
//  BOOLEAN
//  IsListEmpty(
//      PLIST_ENTRY ListHead
//      );
//

#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))

//
//  PLIST_ENTRY
//  RemoveHeadList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveHeadList(ListHead) \
    (ListHead)->Flink;\
    {RemoveEntryList((ListHead)->Flink)}

//
//  PLIST_ENTRY
//  RemoveTailList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveTailList(ListHead) \
    (ListHead)->Blink;\
    {RemoveEntryList((ListHead)->Blink)}

//
//  VOID
//  RemoveEntryList(
//      PLIST_ENTRY Entry
//      );
//

#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }

//
//  VOID
//  InsertTailList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }

//
//  VOID
//  InsertHeadList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
    }

//
//
//  PSINGLE_LIST_ENTRY
//  PopEntryList(
//      PSINGLE_LIST_ENTRY ListHead
//      );
//

#define PopEntryList(ListHead) \
    (ListHead)->Next;\
    {\
        PSINGLE_LIST_ENTRY FirstEntry;\
        FirstEntry = (ListHead)->Next;\
        if (FirstEntry != NULL) {     \
            (ListHead)->Next = FirstEntry->Next;\
        }                             \
    }


//
//  VOID
//  PushEntryList(
//      PSINGLE_LIST_ENTRY ListHead,
//      PSINGLE_LIST_ENTRY Entry
//      );
//

#define PushEntryList(ListHead,Entry) \
    (Entry)->Next = (ListHead)->Next; \
    (ListHead)->Next = (Entry)

// end_wdm end_nthal end_ntifs end_ntndis



#if defined(_M_ALPHA) || defined(_M_AXP64) || defined(_M_IA64)
PVOID
_ReturnAddress (
    VOID
    );

#pragma intrinsic(_ReturnAddress)

#define RtlGetCallersAddress(CallersAddress, CallersCaller) \
    *CallersAddress = (PVOID)_ReturnAddress(); \
    *CallersCaller = NULL;
#else
NTSYSAPI
VOID
NTAPI
RtlGetCallersAddress(
    OUT PVOID *CallersAddress,
    OUT PVOID *CallersCaller
    );
#endif

NTSYSAPI
ULONG
NTAPI
RtlWalkFrameChain (
    OUT PVOID *Callers,
    IN ULONG Count,
    IN ULONG Flags);

NTSYSAPI                                            
NTSTATUS                                            
NTAPI                                               
RtlCharToInteger (                                  
    PCSZ String,                                    
    ULONG Base,                                     
    PULONG Value                                    
    );                                              

NTSYSAPI
NTSTATUS
NTAPI
RtlIntegerToUnicodeString (
    ULONG Value,
    ULONG Base,
    PUNICODE_STRING String
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlInt64ToUnicodeString (
    IN ULONGLONG Value,
    IN ULONG Base OPTIONAL,
    IN OUT PUNICODE_STRING String
    );

#ifdef _WIN64
#define RtlIntPtrToUnicodeString(Value, Base, String) RtlInt64ToUnicodeString(Value, Base, String)
#else
#define RtlIntPtrToUnicodeString(Value, Base, String) RtlIntegerToUnicodeString(Value, Base, String)
#endif

NTSYSAPI
NTSTATUS
NTAPI
RtlUnicodeStringToInteger (
    PUNICODE_STRING String,
    ULONG Base,
    PULONG Value
    );


//
//  String manipulation routines
//

NTSYSAPI
VOID
NTAPI
RtlInitString(
    PSTRING DestinationString,
    PCSZ SourceString
    );

NTSYSAPI
VOID
NTAPI
RtlInitAnsiString(
    PANSI_STRING DestinationString,
    PCSZ SourceString
    );

NTSYSAPI
VOID
NTAPI
RtlInitUnicodeString(
    PUNICODE_STRING DestinationString,
    PCWSTR SourceString
    );


NTSYSAPI
VOID
NTAPI
RtlCopyString(
    PSTRING DestinationString,
    PSTRING SourceString
    );

NTSYSAPI
CHAR
NTAPI
RtlUpperChar (
    CHAR Character
    );

NTSYSAPI
CHAR
NTAPI
RtlLowerChar (
    CHAR Character
    );

NTSYSAPI
LONG
NTAPI
RtlCompareString(
    PSTRING String1,
    PSTRING String2,
    BOOLEAN CaseInSensitive
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlEqualString(
    PSTRING String1,
    PSTRING String2,
    BOOLEAN CaseInSensitive
    );


NTSYSAPI
VOID
NTAPI
RtlUpperString(
    PSTRING DestinationString,
    PSTRING SourceString
    );

//
// NLS String functions
//

NTSYSAPI
NTSTATUS
NTAPI
RtlAnsiStringToUnicodeString(
    PUNICODE_STRING DestinationString,
    PANSI_STRING SourceString,
    BOOLEAN AllocateDestinationString
    );


NTSYSAPI
NTSTATUS
NTAPI
RtlUnicodeStringToAnsiString(
    PANSI_STRING DestinationString,
    PUNICODE_STRING SourceString,
    BOOLEAN AllocateDestinationString
    );


NTSYSAPI
LONG
NTAPI
RtlCompareUnicodeString(
    PUNICODE_STRING String1,
    PUNICODE_STRING String2,
    BOOLEAN CaseInSensitive
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlEqualUnicodeString(
    const UNICODE_STRING *String1,
    const UNICODE_STRING *String2,
    BOOLEAN CaseInSensitive
    );

// end_wdm

NTSYSAPI
BOOLEAN
NTAPI
RtlPrefixUnicodeString(
    IN PUNICODE_STRING String1,
    IN PUNICODE_STRING String2,
    IN BOOLEAN CaseInSensitive
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlUpcaseUnicodeString(
    PUNICODE_STRING DestinationString,
    PCUNICODE_STRING SourceString,
    BOOLEAN AllocateDestinationString
    );


NTSYSAPI
VOID
NTAPI
RtlCopyUnicodeString(
    PUNICODE_STRING DestinationString,
    PUNICODE_STRING SourceString
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlAppendUnicodeStringToString (
    PUNICODE_STRING Destination,
    PUNICODE_STRING Source
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlAppendUnicodeToString (
    PUNICODE_STRING Destination,
    PCWSTR Source
    );

// end_ntndis end_wdm

NTSYSAPI
WCHAR
NTAPI
RtlUpcaseUnicodeChar(
    WCHAR SourceCharacter
    );

NTSYSAPI
WCHAR
NTAPI
RtlDowncaseUnicodeChar(
    WCHAR SourceCharacter
    );

// begin_wdm

NTSYSAPI
VOID
NTAPI
RtlFreeUnicodeString(
    PUNICODE_STRING UnicodeString
    );

NTSYSAPI
VOID
NTAPI
RtlFreeAnsiString(
    PANSI_STRING AnsiString
    );


//
//  NTSYSAPI
//  ULONG
//  NTAPI
//  RtlAnsiStringToUnicodeSize(
//      PANSI_STRING AnsiString
//      );
//

#define RtlAnsiStringToUnicodeSize(STRING) (                 \
    ((STRING)->Length + sizeof(ANSI_NULL)) * sizeof(WCHAR) \
)


// begin_ntminiport

#include <guiddef.h>

// end_ntminiport

#ifndef DEFINE_GUIDEX
    #define DEFINE_GUIDEX(name) EXTERN_C const CDECL GUID name
#endif // !defined(DEFINE_GUIDEX)

#ifndef STATICGUIDOF
    #define STATICGUIDOF(guid) STATIC_##guid
#endif // !defined(STATICGUIDOF)

#ifndef __IID_ALIGNED__
    #define __IID_ALIGNED__
    #ifdef __cplusplus
        inline int IsEqualGUIDAligned(REFGUID guid1, REFGUID guid2)
        {
            return ((*(PLONGLONG)(&guid1) == *(PLONGLONG)(&guid2)) && (*((PLONGLONG)(&guid1) + 1) == *((PLONGLONG)(&guid2) + 1)));
        }
    #else // !__cplusplus
        #define IsEqualGUIDAligned(guid1, guid2) \
            ((*(PLONGLONG)(guid1) == *(PLONGLONG)(guid2)) && (*((PLONGLONG)(guid1) + 1) == *((PLONGLONG)(guid2) + 1)))
    #endif // !__cplusplus
#endif // !__IID_ALIGNED__

NTSYSAPI
NTSTATUS
NTAPI
RtlStringFromGUID(
    IN REFGUID Guid,
    OUT PUNICODE_STRING GuidString
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlGUIDFromString(
    IN PUNICODE_STRING GuidString,
    OUT GUID* Guid
    );

//
// Fast primitives to compare, move, and zero memory
//

// begin_winnt begin_ntndis

NTSYSAPI
SIZE_T
NTAPI
RtlCompareMemory (
    const VOID *Source1,
    const VOID *Source2,
    SIZE_T Length
    );

#define RtlEqualMemory(Destination,Source,Length) (!memcmp((Destination),(Source),(Length)))
#define RtlMoveMemory(Destination,Source,Length) memmove((Destination),(Source),(Length))
#define RtlCopyMemory(Destination,Source,Length) memcpy((Destination),(Source),(Length))
#define RtlFillMemory(Destination,Length,Fill) memset((Destination),(Fill),(Length))
#define RtlZeroMemory(Destination,Length) memset((Destination),0,(Length))

// end_ntndis end_winnt

#if defined(_M_ALPHA)

//
// Guaranteed byte granularity memory copy function.
//

NTSYSAPI
VOID
NTAPI
RtlCopyBytes (
   PVOID Destination,
   CONST VOID *Source,
   SIZE_T Length
   );

//
// Guaranteed byte granularity memory zero function.
//

NTSYSAPI
VOID
NTAPI
RtlZeroBytes (
   PVOID Destination,
   SIZE_T Length
   );

//
// Guaranteed byte granularity memory fill function.
//

NTSYSAPI
VOID
NTAPI
RtlFillBytes (
    PVOID Destination,
    SIZE_T Length,
    UCHAR Fill
    );

#else

#define RtlCopyBytes RtlCopyMemory
#define RtlZeroBytes RtlZeroMemory
#define RtlFillBytes RtlFillMemory

#endif

//
// Define kernel debugger print prototypes and macros.
//
// N.B. The following function cannot be directly imported because there are
//      a few places in the source tree where this function is redefined.
//

VOID
NTAPI
DbgBreakPoint(
    VOID
    );

// end_wdm

NTSYSAPI
VOID
NTAPI
DbgBreakPointWithStatus(
    IN ULONG Status
    );

// begin_wdm

#define DBG_STATUS_CONTROL_C        1
#define DBG_STATUS_SYSRQ            2
#define DBG_STATUS_BUGCHECK_FIRST   3
#define DBG_STATUS_BUGCHECK_SECOND  4
#define DBG_STATUS_FATAL            5
#define DBG_STATUS_DEBUG_CONTROL    6

#if DBG

#define KdPrint(_x_) DbgPrint _x_
#define KdBreakPoint() DbgBreakPoint()

// end_wdm

#define KdBreakPointWithStatus(s) DbgBreakPointWithStatus(s)

// begin_wdm

#else

#define KdPrint(_x_)
#define KdBreakPoint()

// end_wdm

#define KdBreakPointWithStatus(s)

// begin_wdm
#endif

#ifndef _DBGNT_

ULONG
_cdecl
DbgPrint(
    PCH Format,
    ...
    );

// end_wdm

ULONG
_cdecl
DbgPrintReturnControlC(
    PCH Format,
    ...
    );

// begin_wdm
#endif // _DBGNT_
//
// Large integer arithmetic routines.
//

//
// Large integer add - 64-bits + 64-bits -> 64-bits
//

#if !defined(MIDL_PASS)

__inline
LARGE_INTEGER
NTAPI
RtlLargeIntegerAdd (
    LARGE_INTEGER Addend1,
    LARGE_INTEGER Addend2
    )
{
    LARGE_INTEGER Sum;

    Sum.QuadPart = Addend1.QuadPart + Addend2.QuadPart;
    return Sum;
}

//
// Enlarged integer multiply - 32-bits * 32-bits -> 64-bits
//

__inline
LARGE_INTEGER
NTAPI
RtlEnlargedIntegerMultiply (
    LONG Multiplicand,
    LONG Multiplier
    )
{
    LARGE_INTEGER Product;

    Product.QuadPart = (LONGLONG)Multiplicand * (ULONGLONG)Multiplier;
    return Product;
}

//
// Unsigned enlarged integer multiply - 32-bits * 32-bits -> 64-bits
//

__inline
LARGE_INTEGER
NTAPI
RtlEnlargedUnsignedMultiply (
    ULONG Multiplicand,
    ULONG Multiplier
    )
{
    LARGE_INTEGER Product;

    Product.QuadPart = (ULONGLONG)Multiplicand * (ULONGLONG)Multiplier;
    return Product;
}

//
// Enlarged integer divide - 64-bits / 32-bits > 32-bits
//

__inline
ULONG
NTAPI
RtlEnlargedUnsignedDivide (
    IN ULARGE_INTEGER Dividend,
    IN ULONG Divisor,
    IN PULONG Remainder
    )
{
    ULONG Quotient;

    Quotient = (ULONG)(Dividend.QuadPart / Divisor);
    if (ARGUMENT_PRESENT( Remainder )) {

        *Remainder = (ULONG)(Dividend.QuadPart % Divisor);
    }

    return Quotient;
}

//
// Large integer negation - -(64-bits)
//

__inline
LARGE_INTEGER
NTAPI
RtlLargeIntegerNegate (
    LARGE_INTEGER Subtrahend
    )
{
    LARGE_INTEGER Difference;

    Difference.QuadPart = -Subtrahend.QuadPart;
    return Difference;
}

//
// Large integer subtract - 64-bits - 64-bits -> 64-bits.
//

__inline
LARGE_INTEGER
NTAPI
RtlLargeIntegerSubtract (
    LARGE_INTEGER Minuend,
    LARGE_INTEGER Subtrahend
    )
{
    LARGE_INTEGER Difference;

    Difference.QuadPart = Minuend.QuadPart - Subtrahend.QuadPart;
    return Difference;
}

#endif

//
// Extended large integer magic divide - 64-bits / 32-bits -> 64-bits
//

NTSYSAPI
LARGE_INTEGER
NTAPI
RtlExtendedMagicDivide (
    LARGE_INTEGER Dividend,
    LARGE_INTEGER MagicDivisor,
    CCHAR ShiftCount
    );

//
// Large Integer divide - 64-bits / 32-bits -> 64-bits
//

NTSYSAPI
LARGE_INTEGER
NTAPI
RtlExtendedLargeIntegerDivide (
    LARGE_INTEGER Dividend,
    ULONG Divisor,
    PULONG Remainder
    );

// end_wdm
//
// Large Integer divide - 64-bits / 32-bits -> 64-bits
//

NTSYSAPI
LARGE_INTEGER
NTAPI
RtlLargeIntegerDivide (
    LARGE_INTEGER Dividend,
    LARGE_INTEGER Divisor,
    PLARGE_INTEGER Remainder
    );

// begin_wdm
//
// Extended integer multiply - 32-bits * 64-bits -> 64-bits
//

NTSYSAPI
LARGE_INTEGER
NTAPI
RtlExtendedIntegerMultiply (
    LARGE_INTEGER Multiplicand,
    LONG Multiplier
    );

//
// Large integer and - 64-bite & 64-bits -> 64-bits.
//

#define RtlLargeIntegerAnd(Result, Source, Mask)   \
        {                                           \
            Result.HighPart = Source.HighPart & Mask.HighPart; \
            Result.LowPart = Source.LowPart & Mask.LowPart; \
        }

//
// Large integer conversion routines.
//

#if defined(MIDL_PASS) || defined(__cplusplus) || !defined(_M_IX86)

//
// Convert signed integer to large integer.
//

NTSYSAPI
LARGE_INTEGER
NTAPI
RtlConvertLongToLargeInteger (
    LONG SignedInteger
    );

//
// Convert unsigned integer to large integer.
//

NTSYSAPI
LARGE_INTEGER
NTAPI
RtlConvertUlongToLargeInteger (
    ULONG UnsignedInteger
    );


//
// Large integer shift routines.
//

NTSYSAPI
LARGE_INTEGER
NTAPI
RtlLargeIntegerShiftLeft (
    LARGE_INTEGER LargeInteger,
    CCHAR ShiftCount
    );

NTSYSAPI
LARGE_INTEGER
NTAPI
RtlLargeIntegerShiftRight (
    LARGE_INTEGER LargeInteger,
    CCHAR ShiftCount
    );

NTSYSAPI
LARGE_INTEGER
NTAPI
RtlLargeIntegerArithmeticShift (
    LARGE_INTEGER LargeInteger,
    CCHAR ShiftCount
    );

#else

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4035)               // re-enable below

//
// Convert signed integer to large integer.
//

__inline LARGE_INTEGER
NTAPI
RtlConvertLongToLargeInteger (
    LONG SignedInteger
    )
{
    __asm {
        mov     eax, SignedInteger
        cdq                 ; (edx:eax) = signed LargeInt
    }
}

//
// Convert unsigned integer to large integer.
//

__inline LARGE_INTEGER
NTAPI
RtlConvertUlongToLargeInteger (
    ULONG UnsignedInteger
    )
{
    __asm {
        sub     edx, edx    ; zero highpart
        mov     eax, UnsignedInteger
    }
}

//
// Large integer shift routines.
//

__inline LARGE_INTEGER
NTAPI
RtlLargeIntegerShiftLeft (
    LARGE_INTEGER LargeInteger,
    CCHAR ShiftCount
    )
{
    __asm    {
        mov     cl, ShiftCount
        and     cl, 0x3f                    ; mod 64

        cmp     cl, 32
        jc      short sl10

        mov     edx, LargeInteger.LowPart   ; ShiftCount >= 32
        xor     eax, eax                    ; lowpart is zero
        shl     edx, cl                     ; store highpart
        jmp     short done

sl10:
        mov     eax, LargeInteger.LowPart   ; ShiftCount < 32
        mov     edx, LargeInteger.HighPart
        shld    edx, eax, cl
        shl     eax, cl
done:
    }
}


__inline LARGE_INTEGER
NTAPI
RtlLargeIntegerShiftRight (
    LARGE_INTEGER LargeInteger,
    CCHAR ShiftCount
    )
{
    __asm    {
        mov     cl, ShiftCount
        and     cl, 0x3f               ; mod 64

        cmp     cl, 32
        jc      short sr10

        mov     eax, LargeInteger.HighPart  ; ShiftCount >= 32
        xor     edx, edx                    ; lowpart is zero
        shr     eax, cl                     ; store highpart
        jmp     short done

sr10:
        mov     eax, LargeInteger.LowPart   ; ShiftCount < 32
        mov     edx, LargeInteger.HighPart
        shrd    eax, edx, cl
        shr     edx, cl
done:
    }
}


__inline LARGE_INTEGER
NTAPI
RtlLargeIntegerArithmeticShift (
    LARGE_INTEGER LargeInteger,
    CCHAR ShiftCount
    )
{
    __asm {
        mov     cl, ShiftCount
        and     cl, 3fh                 ; mod 64

        cmp     cl, 32
        jc      short sar10

        mov     eax, LargeInteger.HighPart
        sar     eax, cl
        bt      eax, 31                     ; sign bit set?
        sbb     edx, edx                    ; duplicate sign bit into highpart
        jmp     short done
sar10:
        mov     eax, LargeInteger.LowPart   ; (eax) = LargeInteger.LowPart
        mov     edx, LargeInteger.HighPart  ; (edx) = LargeInteger.HighPart
        shrd    eax, edx, cl
        sar     edx, cl
done:
    }
}

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4035)
#endif

#endif

//
// Large integer comparison routines.
//
// BOOLEAN
// RtlLargeIntegerGreaterThan (
//     LARGE_INTEGER Operand1,
//     LARGE_INTEGER Operand2
//     );
//
// BOOLEAN
// RtlLargeIntegerGreaterThanOrEqualTo (
//     LARGE_INTEGER Operand1,
//     LARGE_INTEGER Operand2
//     );
//
// BOOLEAN
// RtlLargeIntegerEqualTo (
//     LARGE_INTEGER Operand1,
//     LARGE_INTEGER Operand2
//     );
//
// BOOLEAN
// RtlLargeIntegerNotEqualTo (
//     LARGE_INTEGER Operand1,
//     LARGE_INTEGER Operand2
//     );
//
// BOOLEAN
// RtlLargeIntegerLessThan (
//     LARGE_INTEGER Operand1,
//     LARGE_INTEGER Operand2
//     );
//
// BOOLEAN
// RtlLargeIntegerLessThanOrEqualTo (
//     LARGE_INTEGER Operand1,
//     LARGE_INTEGER Operand2
//     );
//
// BOOLEAN
// RtlLargeIntegerGreaterThanZero (
//     LARGE_INTEGER Operand
//     );
//
// BOOLEAN
// RtlLargeIntegerGreaterOrEqualToZero (
//     LARGE_INTEGER Operand
//     );
//
// BOOLEAN
// RtlLargeIntegerEqualToZero (
//     LARGE_INTEGER Operand
//     );
//
// BOOLEAN
// RtlLargeIntegerNotEqualToZero (
//     LARGE_INTEGER Operand
//     );
//
// BOOLEAN
// RtlLargeIntegerLessThanZero (
//     LARGE_INTEGER Operand
//     );
//
// BOOLEAN
// RtlLargeIntegerLessOrEqualToZero (
//     LARGE_INTEGER Operand
//     );
//

#define RtlLargeIntegerGreaterThan(X,Y) (                              \
    (((X).HighPart == (Y).HighPart) && ((X).LowPart > (Y).LowPart)) || \
    ((X).HighPart > (Y).HighPart)                                      \
)

#define RtlLargeIntegerGreaterThanOrEqualTo(X,Y) (                      \
    (((X).HighPart == (Y).HighPart) && ((X).LowPart >= (Y).LowPart)) || \
    ((X).HighPart > (Y).HighPart)                                       \
)

#define RtlLargeIntegerEqualTo(X,Y) (                              \
    !(((X).LowPart ^ (Y).LowPart) | ((X).HighPart ^ (Y).HighPart)) \
)

#define RtlLargeIntegerNotEqualTo(X,Y) (                          \
    (((X).LowPart ^ (Y).LowPart) | ((X).HighPart ^ (Y).HighPart)) \
)

#define RtlLargeIntegerLessThan(X,Y) (                                 \
    (((X).HighPart == (Y).HighPart) && ((X).LowPart < (Y).LowPart)) || \
    ((X).HighPart < (Y).HighPart)                                      \
)

#define RtlLargeIntegerLessThanOrEqualTo(X,Y) (                         \
    (((X).HighPart == (Y).HighPart) && ((X).LowPart <= (Y).LowPart)) || \
    ((X).HighPart < (Y).HighPart)                                       \
)

#define RtlLargeIntegerGreaterThanZero(X) (       \
    (((X).HighPart == 0) && ((X).LowPart > 0)) || \
    ((X).HighPart > 0 )                           \
)

#define RtlLargeIntegerGreaterOrEqualToZero(X) ( \
    (X).HighPart >= 0                            \
)

#define RtlLargeIntegerEqualToZero(X) ( \
    !((X).LowPart | (X).HighPart)       \
)

#define RtlLargeIntegerNotEqualToZero(X) ( \
    ((X).LowPart | (X).HighPart)           \
)

#define RtlLargeIntegerLessThanZero(X) ( \
    ((X).HighPart < 0)                   \
)

#define RtlLargeIntegerLessOrEqualToZero(X) (           \
    ((X).HighPart < 0) || !((X).LowPart | (X).HighPart) \
)


//
//  Time conversion routines
//

typedef struct _TIME_FIELDS {
    CSHORT Year;        // range [1601...]
    CSHORT Month;       // range [1..12]
    CSHORT Day;         // range [1..31]
    CSHORT Hour;        // range [0..23]
    CSHORT Minute;      // range [0..59]
    CSHORT Second;      // range [0..59]
    CSHORT Milliseconds;// range [0..999]
    CSHORT Weekday;     // range [0..6] == [Sunday..Saturday]
} TIME_FIELDS;
typedef TIME_FIELDS *PTIME_FIELDS;


NTSYSAPI
VOID
NTAPI
RtlTimeToTimeFields (
    PLARGE_INTEGER Time,
    PTIME_FIELDS TimeFields
    );

//
//  A time field record (Weekday ignored) -> 64 bit Time value
//

NTSYSAPI
BOOLEAN
NTAPI
RtlTimeFieldsToTime (
    PTIME_FIELDS TimeFields,
    PLARGE_INTEGER Time
    );

//
// The following macros store and retrieve USHORTS and ULONGS from potentially
// unaligned addresses, avoiding alignment faults.  they should probably be
// rewritten in assembler
//

#define SHORT_SIZE  (sizeof(USHORT))
#define SHORT_MASK  (SHORT_SIZE - 1)
#define LONG_SIZE       (sizeof(LONG))
#define LONGLONG_SIZE   (sizeof(LONGLONG))
#define LONG_MASK       (LONG_SIZE - 1)
#define LONGLONG_MASK   (LONGLONG_SIZE - 1)
#define LOWBYTE_MASK 0x00FF

#define FIRSTBYTE(VALUE)  ((VALUE) & LOWBYTE_MASK)
#define SECONDBYTE(VALUE) (((VALUE) >> 8) & LOWBYTE_MASK)
#define THIRDBYTE(VALUE)  (((VALUE) >> 16) & LOWBYTE_MASK)
#define FOURTHBYTE(VALUE) (((VALUE) >> 24) & LOWBYTE_MASK)

//
// if MIPS Big Endian, order of bytes is reversed.
//

#define SHORT_LEAST_SIGNIFICANT_BIT  0
#define SHORT_MOST_SIGNIFICANT_BIT   1

#define LONG_LEAST_SIGNIFICANT_BIT       0
#define LONG_3RD_MOST_SIGNIFICANT_BIT    1
#define LONG_2ND_MOST_SIGNIFICANT_BIT    2
#define LONG_MOST_SIGNIFICANT_BIT        3

//++
//
// VOID
// RtlStoreUshort (
//     PUSHORT ADDRESS
//     USHORT VALUE
//     )
//
// Routine Description:
//
// This macro stores a USHORT value in at a particular address, avoiding
// alignment faults.
//
// Arguments:
//
//     ADDRESS - where to store USHORT value
//     VALUE - USHORT to store
//
// Return Value:
//
//     none.
//
//--

#define RtlStoreUshort(ADDRESS,VALUE)                     \
         if ((ULONG_PTR)(ADDRESS) & SHORT_MASK) {         \
             ((PUCHAR) (ADDRESS))[SHORT_LEAST_SIGNIFICANT_BIT] = (UCHAR)(FIRSTBYTE(VALUE));    \
             ((PUCHAR) (ADDRESS))[SHORT_MOST_SIGNIFICANT_BIT ] = (UCHAR)(SECONDBYTE(VALUE));   \
         }                                                \
         else {                                           \
             *((PUSHORT) (ADDRESS)) = (USHORT) VALUE;     \
         }


//++
//
// VOID
// RtlStoreUlong (
//     PULONG ADDRESS
//     ULONG VALUE
//     )
//
// Routine Description:
//
// This macro stores a ULONG value in at a particular address, avoiding
// alignment faults.
//
// Arguments:
//
//     ADDRESS - where to store ULONG value
//     VALUE - ULONG to store
//
// Return Value:
//
//     none.
//
// Note:
//     Depending on the machine, we might want to call storeushort in the
//     unaligned case.
//
//--

#define RtlStoreUlong(ADDRESS,VALUE)                      \
         if ((ULONG_PTR)(ADDRESS) & LONG_MASK) {          \
             ((PUCHAR) (ADDRESS))[LONG_LEAST_SIGNIFICANT_BIT      ] = (UCHAR)(FIRSTBYTE(VALUE));    \
             ((PUCHAR) (ADDRESS))[LONG_3RD_MOST_SIGNIFICANT_BIT   ] = (UCHAR)(SECONDBYTE(VALUE));   \
             ((PUCHAR) (ADDRESS))[LONG_2ND_MOST_SIGNIFICANT_BIT   ] = (UCHAR)(THIRDBYTE(VALUE));    \
             ((PUCHAR) (ADDRESS))[LONG_MOST_SIGNIFICANT_BIT       ] = (UCHAR)(FOURTHBYTE(VALUE));   \
         }                                                \
         else {                                           \
             *((PULONG) (ADDRESS)) = (ULONG) (VALUE);     \
         }

//++
//
// VOID
// RtlStoreUlonglong (
//     PULONGLONG ADDRESS
//     ULONG VALUE
//     )
//
// Routine Description:
//
// This macro stores a ULONGLONG value in at a particular address, avoiding
// alignment faults.
//
// Arguments:
//
//     ADDRESS - where to store ULONGLONG value
//     VALUE - ULONGLONG to store
//
// Return Value:
//
//     none.
//
//--

#define RtlStoreUlonglong(ADDRESS,VALUE)                        \
         if ((ULONG_PTR)(ADDRESS) & LONGLONG_MASK) {            \
             RtlStoreUlong((ULONG_PTR)(ADDRESS),                \
                           (ULONGLONG)(VALUE) & 0xFFFFFFFF);    \
             RtlStoreUlong((ULONG_PTR)(ADDRESS)+sizeof(ULONG),  \
                           (ULONGLONG)(VALUE) >> 32);           \
         } else {                                               \
             *((PULONGLONG)(ADDRESS)) = (ULONGLONG)(VALUE);     \
         }

//++
//
// VOID
// RtlStoreUlongPtr (
//     PULONG_PTR ADDRESS
//     ULONG_PTR VALUE
//     )
//
// Routine Description:
//
// This macro stores a ULONG_PTR value in at a particular address, avoiding
// alignment faults.
//
// Arguments:
//
//     ADDRESS - where to store ULONG_PTR value
//     VALUE - ULONG_PTR to store
//
// Return Value:
//
//     none.
//
//--

#ifdef _WIN64

#define RtlStoreUlongPtr(ADDRESS,VALUE)                         \
         RtlStoreUlonglong(ADDRESS,VALUE)

#else

#define RtlStoreUlongPtr(ADDRESS,VALUE)                         \
         RtlStoreUlong(ADDRESS,VALUE)

#endif

//++
//
// VOID
// RtlRetrieveUshort (
//     PUSHORT DESTINATION_ADDRESS
//     PUSHORT SOURCE_ADDRESS
//     )
//
// Routine Description:
//
// This macro retrieves a USHORT value from the SOURCE address, avoiding
// alignment faults.  The DESTINATION address is assumed to be aligned.
//
// Arguments:
//
//     DESTINATION_ADDRESS - where to store USHORT value
//     SOURCE_ADDRESS - where to retrieve USHORT value from
//
// Return Value:
//
//     none.
//
//--

#define RtlRetrieveUshort(DEST_ADDRESS,SRC_ADDRESS)                   \
         if ((ULONG_PTR)SRC_ADDRESS & SHORT_MASK) {                       \
             ((PUCHAR) DEST_ADDRESS)[0] = ((PUCHAR) SRC_ADDRESS)[0];  \
             ((PUCHAR) DEST_ADDRESS)[1] = ((PUCHAR) SRC_ADDRESS)[1];  \
         }                                                            \
         else {                                                       \
             *((PUSHORT) DEST_ADDRESS) = *((PUSHORT) SRC_ADDRESS);    \
         }                                                            \

//++
//
// VOID
// RtlRetrieveUlong (
//     PULONG DESTINATION_ADDRESS
//     PULONG SOURCE_ADDRESS
//     )
//
// Routine Description:
//
// This macro retrieves a ULONG value from the SOURCE address, avoiding
// alignment faults.  The DESTINATION address is assumed to be aligned.
//
// Arguments:
//
//     DESTINATION_ADDRESS - where to store ULONG value
//     SOURCE_ADDRESS - where to retrieve ULONG value from
//
// Return Value:
//
//     none.
//
// Note:
//     Depending on the machine, we might want to call retrieveushort in the
//     unaligned case.
//
//--

#define RtlRetrieveUlong(DEST_ADDRESS,SRC_ADDRESS)                    \
         if ((ULONG_PTR)SRC_ADDRESS & LONG_MASK) {                        \
             ((PUCHAR) DEST_ADDRESS)[0] = ((PUCHAR) SRC_ADDRESS)[0];  \
             ((PUCHAR) DEST_ADDRESS)[1] = ((PUCHAR) SRC_ADDRESS)[1];  \
             ((PUCHAR) DEST_ADDRESS)[2] = ((PUCHAR) SRC_ADDRESS)[2];  \
             ((PUCHAR) DEST_ADDRESS)[3] = ((PUCHAR) SRC_ADDRESS)[3];  \
         }                                                            \
         else {                                                       \
             *((PULONG) DEST_ADDRESS) = *((PULONG) SRC_ADDRESS);      \
         }
//
//  BitMap routines.  The following structure, routines, and macros are
//  for manipulating bitmaps.  The user is responsible for allocating a bitmap
//  structure (which is really a header) and a buffer (which must be longword
//  aligned and multiple longwords in size).
//

typedef struct _RTL_BITMAP {
    ULONG SizeOfBitMap;                     // Number of bits in bit map
    PULONG Buffer;                          // Pointer to the bit map itself
} RTL_BITMAP;
typedef RTL_BITMAP *PRTL_BITMAP;

//
//  The following routine initializes a new bitmap.  It does not alter the
//  data currently in the bitmap.  This routine must be called before
//  any other bitmap routine/macro.
//

NTSYSAPI
VOID
NTAPI
RtlInitializeBitMap (
    PRTL_BITMAP BitMapHeader,
    PULONG BitMapBuffer,
    ULONG SizeOfBitMap
    );

//
//  The following two routines either clear or set all of the bits
//  in a bitmap.
//

NTSYSAPI
VOID
NTAPI
RtlClearAllBits (
    PRTL_BITMAP BitMapHeader
    );

NTSYSAPI
VOID
NTAPI
RtlSetAllBits (
    PRTL_BITMAP BitMapHeader
    );

//
//  The following two routines locate a contiguous region of either
//  clear or set bits within the bitmap.  The region will be at least
//  as large as the number specified, and the search of the bitmap will
//  begin at the specified hint index (which is a bit index within the
//  bitmap, zero based).  The return value is the bit index of the located
//  region (zero based) or -1 (i.e., 0xffffffff) if such a region cannot
//  be located
//

NTSYSAPI
ULONG
NTAPI
RtlFindClearBits (
    PRTL_BITMAP BitMapHeader,
    ULONG NumberToFind,
    ULONG HintIndex
    );

NTSYSAPI
ULONG
NTAPI
RtlFindSetBits (
    PRTL_BITMAP BitMapHeader,
    ULONG NumberToFind,
    ULONG HintIndex
    );

//
//  The following two routines locate a contiguous region of either
//  clear or set bits within the bitmap and either set or clear the bits
//  within the located region.  The region will be as large as the number
//  specified, and the search for the region will begin at the specified
//  hint index (which is a bit index within the bitmap, zero based).  The
//  return value is the bit index of the located region (zero based) or
//  -1 (i.e., 0xffffffff) if such a region cannot be located.  If a region
//  cannot be located then the setting/clearing of the bitmap is not performed.
//

NTSYSAPI
ULONG
NTAPI
RtlFindClearBitsAndSet (
    PRTL_BITMAP BitMapHeader,
    ULONG NumberToFind,
    ULONG HintIndex
    );

NTSYSAPI
ULONG
NTAPI
RtlFindSetBitsAndClear (
    PRTL_BITMAP BitMapHeader,
    ULONG NumberToFind,
    ULONG HintIndex
    );

//
//  The following two routines clear or set bits within a specified region
//  of the bitmap.  The starting index is zero based.
//

NTSYSAPI
VOID
NTAPI
RtlClearBits (
    PRTL_BITMAP BitMapHeader,
    ULONG StartingIndex,
    ULONG NumberToClear
    );

NTSYSAPI
VOID
NTAPI
RtlSetBits (
    PRTL_BITMAP BitMapHeader,
    ULONG StartingIndex,
    ULONG NumberToSet
    );

//
//  The following routine locates a set of contiguous regions of clear
//  bits within the bitmap.  The caller specifies whether to return the
//  longest runs or just the first found lcoated.  The following structure is
//  used to denote a contiguous run of bits.  The two routines return an array
//  of this structure, one for each run located.
//

typedef struct _RTL_BITMAP_RUN {

    ULONG StartingIndex;
    ULONG NumberOfBits;

} RTL_BITMAP_RUN;
typedef RTL_BITMAP_RUN *PRTL_BITMAP_RUN;

NTSYSAPI
ULONG
NTAPI
RtlFindClearRuns (
    PRTL_BITMAP BitMapHeader,
    PRTL_BITMAP_RUN RunArray,
    ULONG SizeOfRunArray,
    BOOLEAN LocateLongestRuns
    );

//
//  The following routine locates the longest contiguous region of
//  clear bits within the bitmap.  The returned starting index value
//  denotes the first contiguous region located satisfying our requirements
//  The return value is the length (in bits) of the longest region found.
//

NTSYSAPI
ULONG
NTAPI
RtlFindLongestRunClear (
    PRTL_BITMAP BitMapHeader,
    PULONG StartingIndex
    );

//
//  The following routine locates the first contiguous region of
//  clear bits within the bitmap.  The returned starting index value
//  denotes the first contiguous region located satisfying our requirements
//  The return value is the length (in bits) of the region found.
//

NTSYSAPI
ULONG
NTAPI
RtlFindFirstRunClear (
    PRTL_BITMAP BitMapHeader,
    PULONG StartingIndex
    );

//
//  The following macro returns the value of the bit stored within the
//  bitmap at the specified location.  If the bit is set a value of 1 is
//  returned otherwise a value of 0 is returned.
//
//      ULONG
//      RtlCheckBit (
//          PRTL_BITMAP BitMapHeader,
//          ULONG BitPosition
//          );
//
//
//  To implement CheckBit the macro retrieves the longword containing the
//  bit in question, shifts the longword to get the bit in question into the
//  low order bit position and masks out all other bits.
//

#define RtlCheckBit(BMH,BP) ((((BMH)->Buffer[(BP) / 32]) >> ((BP) % 32)) & 0x1)

//
//  The following two procedures return to the caller the total number of
//  clear or set bits within the specified bitmap.
//

NTSYSAPI
ULONG
NTAPI
RtlNumberOfClearBits (
    PRTL_BITMAP BitMapHeader
    );

NTSYSAPI
ULONG
NTAPI
RtlNumberOfSetBits (
    PRTL_BITMAP BitMapHeader
    );

//
//  The following two procedures return to the caller a boolean value
//  indicating if the specified range of bits are all clear or set.
//

NTSYSAPI
BOOLEAN
NTAPI
RtlAreBitsClear (
    PRTL_BITMAP BitMapHeader,
    ULONG StartingIndex,
    ULONG Length
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlAreBitsSet (
    PRTL_BITMAP BitMapHeader,
    ULONG StartingIndex,
    ULONG Length
    );

NTSYSAPI
ULONG
NTAPI
RtlFindNextForwardRunClear (
    IN PRTL_BITMAP BitMapHeader,
    IN ULONG FromIndex,
    IN PULONG StartingRunIndex
    );

NTSYSAPI
ULONG
NTAPI
RtlFindLastBackwardRunClear (
    IN PRTL_BITMAP BitMapHeader,
    IN ULONG FromIndex,
    IN PULONG StartingRunIndex
    );

//
//  The following two procedures return to the caller a value indicating
//  the position within a ULONGLONG of the most or least significant non-zero
//  bit.  A value of zero results in a return value of -1.
//

NTSYSAPI
CCHAR
NTAPI
RtlFindLeastSignificantBit (
    IN ULONGLONG Set
    );

NTSYSAPI
CCHAR
NTAPI
RtlFindMostSignificantBit (
    IN ULONGLONG Set
    );


NTSYSAPI
VOID
NTAPI
RtlMapGenericMask(
    PACCESS_MASK AccessMask,
    PGENERIC_MAPPING GenericMapping
    );

//
// Range list package
//

typedef struct _RTL_RANGE {

    //
    // The start of the range
    //
    ULONGLONG Start;    // Read only

    //
    // The end of the range
    //
    ULONGLONG End;      // Read only

    //
    // Data the user passed in when they created the range
    //
    PVOID UserData;     // Read/Write

    //
    // The owner of the range
    //
    PVOID Owner;        // Read/Write

    //
    // User defined flags the user specified when they created the range
    //
    UCHAR Attributes;    // Read/Write

    //
    // Flags (RTL_RANGE_*)
    //
    UCHAR Flags;       // Read only

} RTL_RANGE, *PRTL_RANGE;


#define RTL_RANGE_SHARED    0x01
#define RTL_RANGE_CONFLICT  0x02

typedef struct _RTL_RANGE_LIST {

    //
    // The list of ranges
    //
    LIST_ENTRY ListHead;

    //
    // These always come in useful
    //
    ULONG Flags;        // use RANGE_LIST_FLAG_*

    //
    // The number of entries in the list
    //
    ULONG Count;

    //
    // Every time an add/delete operation is performed on the list this is
    // incremented.  It is checked during iteration to ensure that the list
    // hasn't changed between GetFirst/GetNext or GetNext/GetNext calls
    //
    ULONG Stamp;

} RTL_RANGE_LIST, *PRTL_RANGE_LIST;

typedef struct _RANGE_LIST_ITERATOR {

    PLIST_ENTRY RangeListHead;
    PLIST_ENTRY MergedHead;
    PVOID Current;
    ULONG Stamp;

} RTL_RANGE_LIST_ITERATOR, *PRTL_RANGE_LIST_ITERATOR;


NTSYSAPI
VOID
NTAPI
RtlInitializeRangeList(
    IN OUT PRTL_RANGE_LIST RangeList
    );

NTSYSAPI
VOID
NTAPI
RtlFreeRangeList(
    IN PRTL_RANGE_LIST RangeList
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlCopyRangeList(
    OUT PRTL_RANGE_LIST CopyRangeList,
    IN PRTL_RANGE_LIST RangeList
    );

#define RTL_RANGE_LIST_ADD_IF_CONFLICT      0x00000001
#define RTL_RANGE_LIST_ADD_SHARED           0x00000002

NTSYSAPI
NTSTATUS
NTAPI
RtlAddRange(
    IN OUT PRTL_RANGE_LIST RangeList,
    IN ULONGLONG Start,
    IN ULONGLONG End,
    IN UCHAR Attributes,
    IN ULONG Flags,
    IN PVOID UserData,  OPTIONAL
    IN PVOID Owner      OPTIONAL
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlDeleteRange(
    IN OUT PRTL_RANGE_LIST RangeList,
    IN ULONGLONG Start,
    IN ULONGLONG End,
    IN PVOID Owner
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlDeleteOwnersRanges(
    IN OUT PRTL_RANGE_LIST RangeList,
    IN PVOID Owner
    );

#define RTL_RANGE_LIST_SHARED_OK           0x00000001
#define RTL_RANGE_LIST_NULL_CONFLICT_OK    0x00000002

typedef
BOOLEAN
(*PRTL_CONFLICT_RANGE_CALLBACK) (
    IN PVOID Context,
    IN PRTL_RANGE Range
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlFindRange(
    IN PRTL_RANGE_LIST RangeList,
    IN ULONGLONG Minimum,
    IN ULONGLONG Maximum,
    IN ULONG Length,
    IN ULONG Alignment,
    IN ULONG Flags,
    IN UCHAR AttributeAvailableMask,
    IN PVOID Context OPTIONAL,
    IN PRTL_CONFLICT_RANGE_CALLBACK Callback OPTIONAL,
    OUT PULONGLONG Start
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlIsRangeAvailable(
    IN PRTL_RANGE_LIST RangeList,
    IN ULONGLONG Start,
    IN ULONGLONG End,
    IN ULONG Flags,
    IN UCHAR AttributeAvailableMask,
    IN PVOID Context OPTIONAL,
    IN PRTL_CONFLICT_RANGE_CALLBACK Callback OPTIONAL,
    OUT PBOOLEAN Available
    );

#define FOR_ALL_RANGES(RangeList, Iterator, Current)            \
    for (RtlGetFirstRange((RangeList), (Iterator), &(Current)); \
         (Current) != NULL;                                     \
         RtlGetNextRange((Iterator), &(Current), TRUE)          \
         )

#define FOR_ALL_RANGES_BACKWARDS(RangeList, Iterator, Current)  \
    for (RtlGetLastRange((RangeList), (Iterator), &(Current));  \
         (Current) != NULL;                                     \
         RtlGetNextRange((Iterator), &(Current), FALSE)         \
         )

NTSYSAPI
NTSTATUS
NTAPI
RtlGetFirstRange(
    IN PRTL_RANGE_LIST RangeList,
    OUT PRTL_RANGE_LIST_ITERATOR Iterator,
    OUT PRTL_RANGE *Range
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlGetLastRange(
    IN PRTL_RANGE_LIST RangeList,
    OUT PRTL_RANGE_LIST_ITERATOR Iterator,
    OUT PRTL_RANGE *Range
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlGetNextRange(
    IN OUT PRTL_RANGE_LIST_ITERATOR Iterator,
    OUT PRTL_RANGE *Range,
    IN BOOLEAN MoveForwards
    );

#define RTL_RANGE_LIST_MERGE_IF_CONFLICT    RTL_RANGE_LIST_ADD_IF_CONFLICT

NTSYSAPI
NTSTATUS
NTAPI
RtlMergeRangeLists(
    OUT PRTL_RANGE_LIST MergedRangeList,
    IN PRTL_RANGE_LIST RangeList1,
    IN PRTL_RANGE_LIST RangeList2,
    IN ULONG Flags
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlInvertRangeList(
    OUT PRTL_RANGE_LIST InvertedRangeList,
    IN PRTL_RANGE_LIST RangeList
    );

// end_nthal

// begin_wdm

//
// Byte swap routines.  These are used to convert from little-endian to
// big-endian and vice-versa.
//

USHORT
FASTCALL
RtlUshortByteSwap(
    IN USHORT Source
    );

ULONG
FASTCALL
RtlUlongByteSwap(
    IN ULONG Source
    );

ULONGLONG
FASTCALL
RtlUlonglongByteSwap(
    IN ULONGLONG Source
    );


//
// Routine for converting from a volume device object to a DOS name.
//

NTSYSAPI
NTSTATUS
NTAPI
RtlVolumeDeviceToDosName(
    IN  PVOID           VolumeDeviceObject,
    OUT PUNICODE_STRING DosName
    );

typedef struct _OSVERSIONINFOA {
    ULONG dwOSVersionInfoSize;
    ULONG dwMajorVersion;
    ULONG dwMinorVersion;
    ULONG dwBuildNumber;
    ULONG dwPlatformId;
    CHAR   szCSDVersion[ 128 ];     // Maintenance string for PSS usage
} OSVERSIONINFOA, *POSVERSIONINFOA, *LPOSVERSIONINFOA;

typedef struct _OSVERSIONINFOW {
    ULONG dwOSVersionInfoSize;
    ULONG dwMajorVersion;
    ULONG dwMinorVersion;
    ULONG dwBuildNumber;
    ULONG dwPlatformId;
    WCHAR  szCSDVersion[ 128 ];     // Maintenance string for PSS usage
} OSVERSIONINFOW, *POSVERSIONINFOW, *LPOSVERSIONINFOW, RTL_OSVERSIONINFOW, *PRTL_OSVERSIONINFOW;
#ifdef UNICODE
typedef OSVERSIONINFOW OSVERSIONINFO;
typedef POSVERSIONINFOW POSVERSIONINFO;
typedef LPOSVERSIONINFOW LPOSVERSIONINFO;
#else
typedef OSVERSIONINFOA OSVERSIONINFO;
typedef POSVERSIONINFOA POSVERSIONINFO;
typedef LPOSVERSIONINFOA LPOSVERSIONINFO;
#endif // UNICODE

typedef struct _OSVERSIONINFOEXA {
    ULONG dwOSVersionInfoSize;
    ULONG dwMajorVersion;
    ULONG dwMinorVersion;
    ULONG dwBuildNumber;
    ULONG dwPlatformId;
    CHAR   szCSDVersion[ 128 ];     // Maintenance string for PSS usage
    USHORT wServicePackMajor;
    USHORT wServicePackMinor;
    USHORT wSuiteMask;
    UCHAR wProductType;
    UCHAR wReserved;
} OSVERSIONINFOEXA, *POSVERSIONINFOEXA, *LPOSVERSIONINFOEXA;
typedef struct _OSVERSIONINFOEXW {
    ULONG dwOSVersionInfoSize;
    ULONG dwMajorVersion;
    ULONG dwMinorVersion;
    ULONG dwBuildNumber;
    ULONG dwPlatformId;
    WCHAR  szCSDVersion[ 128 ];     // Maintenance string for PSS usage
    USHORT wServicePackMajor;
    USHORT wServicePackMinor;
    USHORT wSuiteMask;
    UCHAR wProductType;
    UCHAR wReserved;
} OSVERSIONINFOEXW, *POSVERSIONINFOEXW, *LPOSVERSIONINFOEXW, RTL_OSVERSIONINFOEXW, *PRTL_OSVERSIONINFOEXW;
#ifdef UNICODE
typedef OSVERSIONINFOEXW OSVERSIONINFOEX;
typedef POSVERSIONINFOEXW POSVERSIONINFOEX;
typedef LPOSVERSIONINFOEXW LPOSVERSIONINFOEX;
#else
typedef OSVERSIONINFOEXA OSVERSIONINFOEX;
typedef POSVERSIONINFOEXA POSVERSIONINFOEX;
typedef LPOSVERSIONINFOEXA LPOSVERSIONINFOEX;
#endif // UNICODE

//
// RtlVerifyVersionInfo() conditions
//

#define VER_EQUAL                       1
#define VER_GREATER                     2
#define VER_GREATER_EQUAL               3
#define VER_LESS                        4
#define VER_LESS_EQUAL                  5
#define VER_AND                         6
#define VER_OR                          7

#define VER_CONDITION_MASK              7
#define VER_NUM_BITS_PER_CONDITION_MASK 3

//
// RtlVerifyVersionInfo() type mask bits
//

#define VER_MINORVERSION                0x0000001
#define VER_MAJORVERSION                0x0000002
#define VER_BUILDNUMBER                 0x0000004
#define VER_PLATFORMID                  0x0000008
#define VER_SERVICEPACKMINOR            0x0000010
#define VER_SERVICEPACKMAJOR            0x0000020
#define VER_SUITENAME                   0x0000040
#define VER_PRODUCT_TYPE                0x0000080

//
// RtlVerifyVersionInfo() os product type values
//

#define VER_NT_WORKSTATION              0x0000001
#define VER_NT_DOMAIN_CONTROLLER        0x0000002
#define VER_NT_SERVER                   0x0000003

//
// dwPlatformId defines:
//

#define VER_PLATFORM_WIN32s             0
#define VER_PLATFORM_WIN32_WINDOWS      1
#define VER_PLATFORM_WIN32_NT           2


//
//
// VerifyVersionInfo() macro to set the condition mask
//
// For documentation sakes here's the old version of the macro that got
// changed to call an API
// #define VER_SET_CONDITION(_m_,_t_,_c_)  _m_=(_m_|(_c_<<(1<<_t_)))
//

#define VER_SET_CONDITION(_m_,_t_,_c_)  \
        ((_m_)=VerSetConditionMask((_m_),(_t_),(_c_)))

ULONGLONG
NTAPI
VerSetConditionMask(
        IN  ULONGLONG   ConditionMask,
        IN  ULONG   TypeMask,
        IN  UCHAR   Condition
        );
//
//
//

NTSYSAPI
NTSTATUS
RtlGetVersion(
    OUT PRTL_OSVERSIONINFOW lpVersionInformation
    );

NTSYSAPI
NTSTATUS
RtlVerifyVersionInfo(
    IN PRTL_OSVERSIONINFOEXW VersionInfo,
    IN ULONG TypeMask,
    IN ULONGLONG  ConditionMask
    );

//

typedef struct _RTL_CRITICAL_SECTION {

    //
    //  The following field is used for blocking when there is contention for
    //  the resource
    //

    union {
// end_winnt
        struct {
            UCHAR Type;
            UCHAR Absolute;
            UCHAR Size;
            UCHAR Inserted;
            LONG SignalState;
            LIST_ENTRY WaitListHead;
        } Event;
// begin_winnt
        ULONG_PTR RawEvent[4];
    } Synchronization;

    //
    //  The following three fields control entering and exiting the critical
    //  section for the resource
    //

    LONG LockCount;
    LONG RecursionCount;
    HANDLE OwningThread;
} RTL_CRITICAL_SECTION, *PRTL_CRITICAL_SECTION;

NTSYSAPI
VOID
NTAPI
RtlEnterCriticalSection(
    PRTL_CRITICAL_SECTION CriticalSection
    );

NTSYSAPI
VOID
NTAPI
RtlLeaveCriticalSection(
    PRTL_CRITICAL_SECTION CriticalSection
    );

NTSYSAPI
ULONG
NTAPI
RtlTryEnterCriticalSection(
    PRTL_CRITICAL_SECTION CriticalSection
    );

NTSYSAPI
VOID
NTAPI
RtlInitializeCriticalSection(
    PRTL_CRITICAL_SECTION CriticalSection
    );

#define RtlDeleteCriticalSection(CriticalSection) ((void)0)

//
// Define the various device type values.  Note that values used by Microsoft
// Corporation are in the range 0-32767, and 32768-65535 are reserved for use
// by customers.
//

#define DEVICE_TYPE ULONG

#define FILE_DEVICE_BEEP                0x00000001
#define FILE_DEVICE_CD_ROM              0x00000002
#define FILE_DEVICE_CD_ROM_FILE_SYSTEM  0x00000003
#define FILE_DEVICE_CONTROLLER          0x00000004
#define FILE_DEVICE_DATALINK            0x00000005
#define FILE_DEVICE_DFS                 0x00000006
#define FILE_DEVICE_DISK                0x00000007
#define FILE_DEVICE_DISK_FILE_SYSTEM    0x00000008
#define FILE_DEVICE_FILE_SYSTEM         0x00000009
#define FILE_DEVICE_INPORT_PORT         0x0000000a
#define FILE_DEVICE_KEYBOARD            0x0000000b
#define FILE_DEVICE_MAILSLOT            0x0000000c
#define FILE_DEVICE_MIDI_IN             0x0000000d
#define FILE_DEVICE_MIDI_OUT            0x0000000e
#define FILE_DEVICE_MOUSE               0x0000000f
#define FILE_DEVICE_MULTI_UNC_PROVIDER  0x00000010
#define FILE_DEVICE_NAMED_PIPE          0x00000011
#define FILE_DEVICE_NETWORK             0x00000012
#define FILE_DEVICE_NETWORK_BROWSER     0x00000013
#define FILE_DEVICE_NETWORK_FILE_SYSTEM 0x00000014
#define FILE_DEVICE_NULL                0x00000015
#define FILE_DEVICE_PARALLEL_PORT       0x00000016
#define FILE_DEVICE_PHYSICAL_NETCARD    0x00000017
#define FILE_DEVICE_PRINTER             0x00000018
#define FILE_DEVICE_SCANNER             0x00000019
#define FILE_DEVICE_SERIAL_MOUSE_PORT   0x0000001a
#define FILE_DEVICE_SERIAL_PORT         0x0000001b
#define FILE_DEVICE_SCREEN              0x0000001c
#define FILE_DEVICE_SOUND               0x0000001d
#define FILE_DEVICE_STREAMS             0x0000001e
#define FILE_DEVICE_TAPE                0x0000001f
#define FILE_DEVICE_TAPE_FILE_SYSTEM    0x00000020
#define FILE_DEVICE_TRANSPORT           0x00000021
#define FILE_DEVICE_UNKNOWN             0x00000022
#define FILE_DEVICE_VIDEO               0x00000023
#define FILE_DEVICE_VIRTUAL_DISK        0x00000024
#define FILE_DEVICE_WAVE_IN             0x00000025
#define FILE_DEVICE_WAVE_OUT            0x00000026
#define FILE_DEVICE_8042_PORT           0x00000027
#define FILE_DEVICE_NETWORK_REDIRECTOR  0x00000028
#define FILE_DEVICE_BATTERY             0x00000029
#define FILE_DEVICE_BUS_EXTENDER        0x0000002a
#define FILE_DEVICE_MODEM               0x0000002b
#define FILE_DEVICE_VDM                 0x0000002c
#define FILE_DEVICE_MASS_STORAGE        0x0000002d
#define FILE_DEVICE_SMB                 0x0000002e
#define FILE_DEVICE_KS                  0x0000002f
#define FILE_DEVICE_CHANGER             0x00000030
#define FILE_DEVICE_SMARTCARD           0x00000031
#define FILE_DEVICE_ACPI                0x00000032
#define FILE_DEVICE_DVD                 0x00000033
#define FILE_DEVICE_FULLSCREEN_VIDEO    0x00000034
#define FILE_DEVICE_DFS_FILE_SYSTEM     0x00000035
#define FILE_DEVICE_DFS_VOLUME          0x00000036
#define FILE_DEVICE_SERENUM             0x00000037
#define FILE_DEVICE_TERMSRV             0x00000038
#define FILE_DEVICE_KSEC                0x00000039
#define FILE_DEVICE_MEMORY_UNIT         0x0000003a
#define FILE_DEVICE_MEDIA_BOARD         0x0000003b

//
// Macro definition for defining IOCTL and FSCTL function control codes.  Note
// that function codes 0-2047 are reserved for Microsoft Corporation, and
// 2048-4095 are reserved for customers.
//

#define CTL_CODE( DeviceType, Function, Method, Access ) (                 \
    ((DeviceType) << 16) | ((Access) << 14) | ((Function) << 2) | (Method) \
)

//
// Macro to extract device type out of the device io control code
//
#define DEVICE_TYPE_FROM_CTL_CODE(ctrlCode)     (((ULONG)(ctrlCode & 0xffff0000)) >> 16)

//
// Define the method codes for how buffers are passed for I/O and FS controls
//

#define METHOD_BUFFERED                 0
#define METHOD_IN_DIRECT                1
#define METHOD_OUT_DIRECT               2
#define METHOD_NEITHER                  3

//
// Define the access check value for any access
//
//
// The FILE_READ_ACCESS and FILE_WRITE_ACCESS constants are also defined in
// ntioapi.h as FILE_READ_DATA and FILE_WRITE_DATA. The values for these
// constants *MUST* always be in sync.
//
//
// FILE_SPECIAL_ACCESS is checked by the NT I/O system the same as FILE_ANY_ACCESS.
// The file systems, however, may add additional access checks for I/O and FS controls
// that use this value.
//


#define FILE_ANY_ACCESS                 0
#define FILE_SPECIAL_ACCESS    (FILE_ANY_ACCESS)
#define FILE_READ_ACCESS          ( 0x0001 )    // file & pipe
#define FILE_WRITE_ACCESS         ( 0x0002 )    // file & pipe

// begin_winnt

//
// Define access rights to files and directories
//

//
// The FILE_READ_DATA and FILE_WRITE_DATA constants are also defined in
// devioctl.h as FILE_READ_ACCESS and FILE_WRITE_ACCESS. The values for these
// constants *MUST* always be in sync.
// The values are redefined in devioctl.h because they must be available to
// both DOS and NT.
//

#define FILE_READ_DATA            ( 0x0001 )    // file & pipe
#define FILE_LIST_DIRECTORY       ( 0x0001 )    // directory

#define FILE_WRITE_DATA           ( 0x0002 )    // file & pipe
#define FILE_ADD_FILE             ( 0x0002 )    // directory

#define FILE_APPEND_DATA          ( 0x0004 )    // file
#define FILE_ADD_SUBDIRECTORY     ( 0x0004 )    // directory
#define FILE_CREATE_PIPE_INSTANCE ( 0x0004 )    // named pipe


#define FILE_READ_EA              ( 0x0008 )    // file & directory

#define FILE_WRITE_EA             ( 0x0010 )    // file & directory

#define FILE_EXECUTE              ( 0x0020 )    // file
#define FILE_TRAVERSE             ( 0x0020 )    // directory

#define FILE_DELETE_CHILD         ( 0x0040 )    // directory

#define FILE_READ_ATTRIBUTES      ( 0x0080 )    // all

#define FILE_WRITE_ATTRIBUTES     ( 0x0100 )    // all

#define FILE_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | 0x1FF)

#define FILE_GENERIC_READ         (STANDARD_RIGHTS_READ     |\
                                   FILE_READ_DATA           |\
                                   FILE_READ_ATTRIBUTES     |\
                                   FILE_READ_EA             |\
                                   SYNCHRONIZE)


#define FILE_GENERIC_WRITE        (STANDARD_RIGHTS_WRITE    |\
                                   FILE_WRITE_DATA          |\
                                   FILE_WRITE_ATTRIBUTES    |\
                                   FILE_WRITE_EA            |\
                                   FILE_APPEND_DATA         |\
                                   SYNCHRONIZE)


#define FILE_GENERIC_EXECUTE      (STANDARD_RIGHTS_EXECUTE  |\
                                   FILE_READ_ATTRIBUTES     |\
                                   FILE_EXECUTE             |\
                                   SYNCHRONIZE)

// end_winnt


//
// Define share access rights to files and directories
//

#define FILE_SHARE_READ                 0x00000001  // winnt
#define FILE_SHARE_WRITE                0x00000002  // winnt
#define FILE_SHARE_DELETE               0x00000004  // winnt
#define FILE_SHARE_VALID_FLAGS          0x00000007

//
// Define the file attributes values
//
// Note:  0x00000008 is reserved for use for the old DOS VOLID (volume ID)
//        and is therefore not considered valid in NT.
//
// Note:  0x00000010 is reserved for use for the old DOS SUBDIRECTORY flag
//        and is therefore not considered valid in NT.  This flag has
//        been disassociated with file attributes since the other flags are
//        protected with READ_ and WRITE_ATTRIBUTES access to the file.
//
// Note:  Note also that the order of these flags is set to allow both the
//        FAT and the Pinball File Systems to directly set the attributes
//        flags in attributes words without having to pick each flag out
//        individually.  The order of these flags should not be changed!
//

#define FILE_ATTRIBUTE_READONLY             0x00000001  // winnt
#define FILE_ATTRIBUTE_HIDDEN               0x00000002  // winnt
#define FILE_ATTRIBUTE_SYSTEM               0x00000004  // winnt
//OLD DOS VOLID                             0x00000008

#define FILE_ATTRIBUTE_DIRECTORY            0x00000010  // winnt
#define FILE_ATTRIBUTE_ARCHIVE              0x00000020  // winnt
#define FILE_ATTRIBUTE_DEVICE               0x00000040  // winnt
#define FILE_ATTRIBUTE_NORMAL               0x00000080  // winnt

#define FILE_ATTRIBUTE_TEMPORARY            0x00000100  // winnt
#define FILE_ATTRIBUTE_SPARSE_FILE          0x00000200
#define FILE_ATTRIBUTE_REPARSE_POINT        0x00000400
#define FILE_ATTRIBUTE_COMPRESSED           0x00000800

#define FILE_ATTRIBUTE_OFFLINE              0x00001000
#define FILE_ATTRIBUTE_NOT_CONTENT_INDEXED  0x00002000
#define FILE_ATTRIBUTE_ENCRYPTED            0x00004000

//
//  This definition is old and will disappear shortly
//

#define FILE_ATTRIBUTE_CONTENT_INDEXED      FILE_ATTRIBUTE_NOT_CONTENT_INDEXED

#define FILE_ATTRIBUTE_VALID_FLAGS      0x00007fb7
#define FILE_ATTRIBUTE_VALID_SET_FLAGS  0x000031a7

//
// Define the create disposition values
//

#define FILE_SUPERSEDE                  0x00000000
#define FILE_OPEN                       0x00000001
#define FILE_CREATE                     0x00000002
#define FILE_OPEN_IF                    0x00000003
#define FILE_OVERWRITE                  0x00000004
#define FILE_OVERWRITE_IF               0x00000005
#define FILE_MAXIMUM_DISPOSITION        0x00000005

//
// Define the create/open option flags
//

#define FILE_DIRECTORY_FILE                     0x00000001
#define FILE_WRITE_THROUGH                      0x00000002
#define FILE_SEQUENTIAL_ONLY                    0x00000004
#define FILE_NO_INTERMEDIATE_BUFFERING          0x00000008

#define FILE_SYNCHRONOUS_IO_ALERT               0x00000010
#define FILE_SYNCHRONOUS_IO_NONALERT            0x00000020
#define FILE_NON_DIRECTORY_FILE                 0x00000040
#define FILE_CREATE_TREE_CONNECTION             0x00000080

#define FILE_COMPLETE_IF_OPLOCKED               0x00000100
#define FILE_NO_EA_KNOWLEDGE                    0x00000200
#define FILE_OPEN_FOR_RECOVERY                  0x00000400
#define FILE_RANDOM_ACCESS                      0x00000800

#define FILE_DELETE_ON_CLOSE                    0x00001000
#define FILE_OPEN_BY_FILE_ID                    0x00002000
#define FILE_OPEN_FOR_BACKUP_INTENT             0x00004000
#define FILE_NO_COMPRESSION                     0x00008000

#define FILE_RESERVE_OPFILTER                   0x00100000
#define FILE_OPEN_REPARSE_POINT                 0x00200000
#define FILE_OPEN_NO_RECALL                     0x00400000
#define FILE_OPEN_FOR_FREE_SPACE_QUERY          0x00800000

#define FILE_COPY_STRUCTURED_STORAGE            0x00000041
#define FILE_STRUCTURED_STORAGE                 0x00000441

#define FILE_VALID_OPTION_FLAGS                 0x00ffffff
#define FILE_VALID_SET_FLAGS                    0x00000036

//
// Define the I/O status information return values for NtCreateFile/NtOpenFile
//

#define FILE_SUPERSEDED                 0x00000000
#define FILE_OPENED                     0x00000001
#define FILE_CREATED                    0x00000002
#define FILE_OVERWRITTEN                0x00000003
#define FILE_EXISTS                     0x00000004
#define FILE_DOES_NOT_EXIST             0x00000005

//
// Define special ByteOffset parameters for read and write operations
//

#define FILE_WRITE_TO_END_OF_FILE       0xffffffff
#define FILE_USE_FILE_POINTER_POSITION  0xfffffffe

//
// Define alignment requirement values
//

#define FILE_BYTE_ALIGNMENT             0x00000000
#define FILE_WORD_ALIGNMENT             0x00000001
#define FILE_LONG_ALIGNMENT             0x00000003
#define FILE_QUAD_ALIGNMENT             0x00000007
#define FILE_OCTA_ALIGNMENT             0x0000000f
#define FILE_32_BYTE_ALIGNMENT          0x0000001f
#define FILE_64_BYTE_ALIGNMENT          0x0000003f
#define FILE_128_BYTE_ALIGNMENT         0x0000007f
#define FILE_256_BYTE_ALIGNMENT         0x000000ff
#define FILE_512_BYTE_ALIGNMENT         0x000001ff

//
// Define the maximum length of a filename string
//

#define MAXIMUM_FILENAME_LENGTH         256

//
// Define the various device characteristics flags
//

#define FILE_REMOVABLE_MEDIA            0x00000001
#define FILE_READ_ONLY_DEVICE           0x00000002
#define FILE_FLOPPY_DISKETTE            0x00000004
#define FILE_WRITE_ONCE_MEDIA           0x00000008
#define FILE_REMOTE_DEVICE              0x00000010
#define FILE_DEVICE_IS_MOUNTED          0x00000020
#define FILE_VIRTUAL_VOLUME             0x00000040
#define FILE_AUTOGENERATED_DEVICE_NAME  0x00000080
#define FILE_DEVICE_SECURE_OPEN         0x00000100

// end_wdm

//
// flags specified here will be propagated up and down a device stack
// after FDO and all filter devices are added, but before the device
// stack is started
//

#define FILE_CHARACTERISTICS_PROPAGATED (   FILE_REMOVABLE_MEDIA   | \
                                            FILE_READ_ONLY_DEVICE  | \
                                            FILE_FLOPPY_DISKETTE   | \
                                            FILE_WRITE_ONCE_MEDIA  | \
                                            FILE_DEVICE_SECURE_OPEN  )

//
// Define the base asynchronous I/O argument types
//

typedef struct _IO_STATUS_BLOCK {
    union {
        NTSTATUS Status;
        PVOID Pointer;
    };

    ULONG_PTR Information;
} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;

#if defined(_WIN64)
typedef struct _IO_STATUS_BLOCK32 {
    NTSTATUS Status;
    ULONG Information;
} IO_STATUS_BLOCK32, *PIO_STATUS_BLOCK32;
#endif


//
// Define an Asynchronous Procedure Call from I/O viewpoint
//

typedef
VOID
(NTAPI *PIO_APC_ROUTINE) (
    IN PVOID ApcContext,
    IN PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG Reserved
    );
#define PIO_APC_ROUTINE_DEFINED

//
// Define the file information class values
//
// WARNING:  The order of the following values are assumed by the I/O system.
//           Any changes made here should be reflected there as well.
//

typedef enum _FILE_INFORMATION_CLASS {
// end_wdm
    FileDirectoryInformation       = 1,
    FileFullDirectoryInformation, // 2
    FileBothDirectoryInformation, // 3
    FileBasicInformation,         // 4  wdm
    FileStandardInformation,      // 5  wdm
    FileInternalInformation,      // 6
    FileEaInformation,            // 7
    FileAccessInformation,        // 8
    FileNameInformation,          // 9
    FileRenameInformation,        // 10
    FileLinkInformation,          // 11
    FileNamesInformation,         // 12
    FileDispositionInformation,   // 13
    FilePositionInformation,      // 14 wdm
    FileFullEaInformation,        // 15
    FileModeInformation,          // 16
    FileAlignmentInformation,     // 17
    FileAllInformation,           // 18
    FileAllocationInformation,    // 19
    FileEndOfFileInformation,     // 20 wdm
    FileAlternateNameInformation, // 21
    FileStreamInformation,        // 22
    FilePipeInformation,          // 23
    FilePipeLocalInformation,     // 24
    FilePipeRemoteInformation,    // 25
    FileMailslotQueryInformation, // 26
    FileMailslotSetInformation,   // 27
    FileCompressionInformation,   // 28
    FileObjectIdInformation,      // 29
    FileCompletionInformation,    // 30
    FileMoveClusterInformation,   // 31
    FileQuotaInformation,         // 32
    FileReparsePointInformation,  // 33
    FileNetworkOpenInformation,   // 34
    FileAttributeTagInformation,  // 35
    FileTrackingInformation,      // 36
    FileMaximumInformation
// begin_wdm
} FILE_INFORMATION_CLASS, *PFILE_INFORMATION_CLASS;

//
// Define the various structures which are returned on query operations
//

typedef struct _FILE_BASIC_INFORMATION {                    
    LARGE_INTEGER CreationTime;                             
    LARGE_INTEGER LastAccessTime;                           
    LARGE_INTEGER LastWriteTime;                            
    LARGE_INTEGER ChangeTime;                               
    ULONG FileAttributes;                                   
} FILE_BASIC_INFORMATION, *PFILE_BASIC_INFORMATION;         
                                                            
typedef struct _FILE_STANDARD_INFORMATION {                 
    LARGE_INTEGER AllocationSize;                           
    LARGE_INTEGER EndOfFile;                                
    ULONG NumberOfLinks;                                    
    BOOLEAN DeletePending;                                  
    BOOLEAN Directory;                                      
} FILE_STANDARD_INFORMATION, *PFILE_STANDARD_INFORMATION;   
                                                            
typedef struct _FILE_POSITION_INFORMATION {                 
    LARGE_INTEGER CurrentByteOffset;                        
} FILE_POSITION_INFORMATION, *PFILE_POSITION_INFORMATION;   
                                                            
typedef struct _FILE_ALIGNMENT_INFORMATION {                
    ULONG AlignmentRequirement;                             
} FILE_ALIGNMENT_INFORMATION, *PFILE_ALIGNMENT_INFORMATION; 
                                                            
typedef struct _FILE_NAME_INFORMATION {                     
    ULONG FileNameLength;                                   
    OCHAR FileName[1];                                      
} FILE_NAME_INFORMATION, *PFILE_NAME_INFORMATION;           
                                                            
typedef struct _FILE_NETWORK_OPEN_INFORMATION {                 
    LARGE_INTEGER CreationTime;                                 
    LARGE_INTEGER LastAccessTime;                               
    LARGE_INTEGER LastWriteTime;                                
    LARGE_INTEGER ChangeTime;                                   
    LARGE_INTEGER AllocationSize;                               
    LARGE_INTEGER EndOfFile;                                    
    ULONG FileAttributes;                                       
} FILE_NETWORK_OPEN_INFORMATION, *PFILE_NETWORK_OPEN_INFORMATION;   
                                                                
typedef struct _FILE_ATTRIBUTE_TAG_INFORMATION {               
    ULONG FileAttributes;                                       
    ULONG ReparseTag;                                           
} FILE_ATTRIBUTE_TAG_INFORMATION, *PFILE_ATTRIBUTE_TAG_INFORMATION;  
                                                                
typedef struct _FILE_DISPOSITION_INFORMATION {                  
    BOOLEAN DeleteFile;                                         
} FILE_DISPOSITION_INFORMATION, *PFILE_DISPOSITION_INFORMATION; 
                                                                
typedef struct _FILE_END_OF_FILE_INFORMATION {                  
    LARGE_INTEGER EndOfFile;                                    
} FILE_END_OF_FILE_INFORMATION, *PFILE_END_OF_FILE_INFORMATION; 
                                                                
//
// Define the file system information class values
//
// WARNING:  The order of the following values are assumed by the I/O system.
//           Any changes made here should be reflected there as well.

typedef enum _FSINFOCLASS {
    FileFsVolumeInformation       = 1,
    FileFsLabelInformation,      // 2
    FileFsSizeInformation,       // 3
    FileFsDeviceInformation,     // 4
    FileFsAttributeInformation,  // 5
    FileFsControlInformation,    // 6
    FileFsFullSizeInformation,   // 7
    FileFsObjectIdInformation,   // 8
    FileFsMaximumInformation
} FS_INFORMATION_CLASS, *PFS_INFORMATION_CLASS;

typedef struct _FILE_FS_DEVICE_INFORMATION {                    
    DEVICE_TYPE DeviceType;                                     
    ULONG Characteristics;                                      
} FILE_FS_DEVICE_INFORMATION, *PFILE_FS_DEVICE_INFORMATION;     
                                                                

//
// Define segment buffer structure for scatter/gather read/write.
//

typedef union _FILE_SEGMENT_ELEMENT {
    PVOID Buffer;
    ULONG Alignment;
} FILE_SEGMENT_ELEMENT, *PFILE_SEGMENT_ELEMENT;

//
// Define the I/O bus interface types.
//

typedef enum _INTERFACE_TYPE {
    InterfaceTypeUndefined = -1,
    Internal,
    Isa,
    Eisa,
    MicroChannel,
    TurboChannel,
    PCIBus,
    VMEBus,
    NuBus,
    PCMCIABus,
    CBus,
    MPIBus,
    MPSABus,
    ProcessorInternal,
    InternalPowerBus,
    PNPISABus,
    PNPBus,
    MaximumInterfaceType
}INTERFACE_TYPE, *PINTERFACE_TYPE;

//
// Define the DMA transfer widths.
//

typedef enum _DMA_WIDTH {
    Width8Bits,
    Width16Bits,
    Width32Bits,
    MaximumDmaWidth
}DMA_WIDTH, *PDMA_WIDTH;

//
// Define DMA transfer speeds.
//

typedef enum _DMA_SPEED {
    Compatible,
    TypeA,
    TypeB,
    TypeC,
    TypeF,
    MaximumDmaSpeed
}DMA_SPEED, *PDMA_SPEED;

//
// Define Interface reference/dereference routines for
//  Interfaces exported by IRP_MN_QUERY_INTERFACE
//

typedef VOID (*PINTERFACE_REFERENCE)(PVOID Context);
typedef VOID (*PINTERFACE_DEREFERENCE)(PVOID Context);

// end_wdm

//
// Define types of bus information.
//

typedef enum _BUS_DATA_TYPE {
    ConfigurationSpaceUndefined = -1,
    Cmos,
    EisaConfiguration,
    Pos,
    CbusConfiguration,
    PCIConfiguration,
    VMEConfiguration,
    NuBusConfiguration,
    PCMCIAConfiguration,
    MPIConfiguration,
    MPSAConfiguration,
    PNPISAConfiguration,
    SgiInternalConfiguration,
    MaximumBusDataType
} BUS_DATA_TYPE, *PBUS_DATA_TYPE;

#ifdef _WIN64
#define PORT_MAXIMUM_MESSAGE_LENGTH 512
#else
#define PORT_MAXIMUM_MESSAGE_LENGTH 256
#endif
//
// Registry Specific Access Rights.
//

#define KEY_QUERY_VALUE         (0x0001)
#define KEY_SET_VALUE           (0x0002)
#define KEY_CREATE_SUB_KEY      (0x0004)
#define KEY_ENUMERATE_SUB_KEYS  (0x0008)
#define KEY_NOTIFY              (0x0010)
#define KEY_CREATE_LINK         (0x0020)

#define KEY_READ                ((STANDARD_RIGHTS_READ       |\
                                  KEY_QUERY_VALUE            |\
                                  KEY_ENUMERATE_SUB_KEYS     |\
                                  KEY_NOTIFY)                 \
                                  &                           \
                                 (~SYNCHRONIZE))


#define KEY_WRITE               ((STANDARD_RIGHTS_WRITE      |\
                                  KEY_SET_VALUE              |\
                                  KEY_CREATE_SUB_KEY)         \
                                  &                           \
                                 (~SYNCHRONIZE))

#define KEY_EXECUTE             ((KEY_READ)                   \
                                  &                           \
                                 (~SYNCHRONIZE))

#define KEY_ALL_ACCESS          ((STANDARD_RIGHTS_ALL        |\
                                  KEY_QUERY_VALUE            |\
                                  KEY_SET_VALUE              |\
                                  KEY_CREATE_SUB_KEY         |\
                                  KEY_ENUMERATE_SUB_KEYS     |\
                                  KEY_NOTIFY                 |\
                                  KEY_CREATE_LINK)            \
                                  &                           \
                                 (~SYNCHRONIZE))

//
// Open/Create Options
//

#define REG_OPTION_RESERVED         (0x00000000L)   // Parameter is reserved

#define REG_OPTION_NON_VOLATILE     (0x00000000L)   // Key is preserved
                                                    // when system is rebooted

#define REG_OPTION_VOLATILE         (0x00000001L)   // Key is not preserved
                                                    // when system is rebooted

#define REG_OPTION_CREATE_LINK      (0x00000002L)   // Created key is a
                                                    // symbolic link

#define REG_OPTION_BACKUP_RESTORE   (0x00000004L)   // open for backup or restore
                                                    // special access rules
                                                    // privilege required

#define REG_OPTION_OPEN_LINK        (0x00000008L)   // Open symbolic link

#define REG_LEGAL_OPTION            \
                (REG_OPTION_RESERVED            |\
                 REG_OPTION_NON_VOLATILE        |\
                 REG_OPTION_VOLATILE            |\
                 REG_OPTION_CREATE_LINK         |\
                 REG_OPTION_BACKUP_RESTORE      |\
                 REG_OPTION_OPEN_LINK)

//
// Key creation/open disposition
//

#define REG_CREATED_NEW_KEY         (0x00000001L)   // New Registry Key created
#define REG_OPENED_EXISTING_KEY     (0x00000002L)   // Existing Key opened

//
// Key restore flags
//

#define REG_WHOLE_HIVE_VOLATILE     (0x00000001L)   // Restore whole hive volatile
#define REG_REFRESH_HIVE            (0x00000002L)   // Unwind changes to last flush
#define REG_NO_LAZY_FLUSH           (0x00000004L)   // Never lazy flush this hive
#define REG_FORCE_RESTORE           (0x00000008L)   // Force the restore process even when we have open handles on subkeys

//
// Key query structures
//

typedef struct _KEY_BASIC_INFORMATION {
    LARGE_INTEGER LastWriteTime;
    ULONG   TitleIndex;
    ULONG   NameLength;
    WCHAR   Name[1];            // Variable length string
} KEY_BASIC_INFORMATION, *PKEY_BASIC_INFORMATION;

typedef struct _KEY_NODE_INFORMATION {
    LARGE_INTEGER LastWriteTime;
    ULONG   TitleIndex;
    ULONG   ClassOffset;
    ULONG   ClassLength;
    ULONG   NameLength;
    WCHAR   Name[1];            // Variable length string
//          Class[1];           // Variable length string not declared
} KEY_NODE_INFORMATION, *PKEY_NODE_INFORMATION;

typedef struct _KEY_FULL_INFORMATION {
    LARGE_INTEGER LastWriteTime;
    ULONG   TitleIndex;
    ULONG   ClassOffset;
    ULONG   ClassLength;
    ULONG   SubKeys;
    ULONG   MaxNameLen;
    ULONG   MaxClassLen;
    ULONG   Values;
    ULONG   MaxValueNameLen;
    ULONG   MaxValueDataLen;
    WCHAR   Class[1];           // Variable length
} KEY_FULL_INFORMATION, *PKEY_FULL_INFORMATION;

// end_wdm
typedef struct _KEY_NAME_INFORMATION {
    ULONG   NameLength;
    WCHAR   Name[1];            // Variable length string
} KEY_NAME_INFORMATION, *PKEY_NAME_INFORMATION;

// begin_wdm
typedef enum _KEY_INFORMATION_CLASS {
    KeyBasicInformation,
    KeyNodeInformation,
    KeyFullInformation
// end_wdm
    ,
    KeyNameInformation
// begin_wdm
} KEY_INFORMATION_CLASS;

typedef struct _KEY_WRITE_TIME_INFORMATION {
    LARGE_INTEGER LastWriteTime;
} KEY_WRITE_TIME_INFORMATION, *PKEY_WRITE_TIME_INFORMATION;

typedef enum _KEY_SET_INFORMATION_CLASS {
    KeyWriteTimeInformation
} KEY_SET_INFORMATION_CLASS;

//
// Value entry query structures
//

typedef struct _KEY_VALUE_BASIC_INFORMATION {
    ULONG   TitleIndex;
    ULONG   Type;
    ULONG   NameLength;
    WCHAR   Name[1];            // Variable size
} KEY_VALUE_BASIC_INFORMATION, *PKEY_VALUE_BASIC_INFORMATION;

typedef struct _KEY_VALUE_FULL_INFORMATION {
    ULONG   TitleIndex;
    ULONG   Type;
    ULONG   DataOffset;
    ULONG   DataLength;
    ULONG   NameLength;
    WCHAR   Name[1];            // Variable size
//          Data[1];            // Variable size data not declared
} KEY_VALUE_FULL_INFORMATION, *PKEY_VALUE_FULL_INFORMATION;

typedef struct _KEY_VALUE_PARTIAL_INFORMATION {
    ULONG   TitleIndex;
    ULONG   Type;
    ULONG   DataLength;
    UCHAR   Data[1];            // Variable size
} KEY_VALUE_PARTIAL_INFORMATION, *PKEY_VALUE_PARTIAL_INFORMATION;

typedef struct _KEY_VALUE_PARTIAL_INFORMATION_ALIGN64 {
    ULONG   Type;
    ULONG   DataLength;
    UCHAR   Data[1];            // Variable size
} KEY_VALUE_PARTIAL_INFORMATION_ALIGN64, *PKEY_VALUE_PARTIAL_INFORMATION_ALIGN64;

typedef struct _KEY_VALUE_ENTRY {
    PUNICODE_STRING ValueName;
    ULONG           DataLength;
    ULONG           DataOffset;
    ULONG           Type;
} KEY_VALUE_ENTRY, *PKEY_VALUE_ENTRY;

typedef enum _KEY_VALUE_INFORMATION_CLASS {
    KeyValueBasicInformation,
    KeyValueFullInformation,
    KeyValuePartialInformation,
    KeyValueFullInformationAlign64,
    KeyValuePartialInformationAlign64
} KEY_VALUE_INFORMATION_CLASS;



#define OBJ_NAME_PATH_SEPARATOR ((OCHAR)L'\\')

//
// Object Manager Object Type Specific Access Rights.
//

#define OBJECT_TYPE_CREATE (0x0001)

#define OBJECT_TYPE_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | 0x1)

//
// Object Manager Directory Specific Access Rights.
//

#define DIRECTORY_QUERY                 (0x0001)
#define DIRECTORY_TRAVERSE              (0x0002)
#define DIRECTORY_CREATE_OBJECT         (0x0004)
#define DIRECTORY_CREATE_SUBDIRECTORY   (0x0008)

#define DIRECTORY_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | 0xF)

//
// Object Manager Symbolic Link Specific Access Rights.
//

#define SYMBOLIC_LINK_QUERY (0x0001)

#define SYMBOLIC_LINK_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | 0x1)

typedef struct _OBJECT_NAME_INFORMATION {               
    OBJECT_STRING Name;                                 
} OBJECT_NAME_INFORMATION, *POBJECT_NAME_INFORMATION;   
#define DUPLICATE_CLOSE_SOURCE      0x00000001  // winnt
#define DUPLICATE_SAME_ACCESS       0x00000002  // winnt
#define DUPLICATE_SAME_ATTRIBUTES   0x00000004
typedef struct _MEMORY_BASIC_INFORMATION {
    PVOID BaseAddress;
    PVOID AllocationBase;
    ULONG AllocationProtect;
    SIZE_T RegionSize;
    ULONG State;
    ULONG Protect;
    ULONG Type;
} MEMORY_BASIC_INFORMATION, *PMEMORY_BASIC_INFORMATION;
typedef enum _SECTION_INHERIT {
    ViewShare = 1,
    ViewUnmap = 2
} SECTION_INHERIT;

//
// Section Access Rights.
//

// begin_winnt
#define SECTION_QUERY       0x0001
#define SECTION_MAP_WRITE   0x0002
#define SECTION_MAP_READ    0x0004
#define SECTION_MAP_EXECUTE 0x0008
#define SECTION_EXTEND_SIZE 0x0010

#define SECTION_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED|SECTION_QUERY|\
                            SECTION_MAP_WRITE |      \
                            SECTION_MAP_READ |       \
                            SECTION_MAP_EXECUTE |    \
                            SECTION_EXTEND_SIZE)
// end_winnt

#define SEGMENT_ALL_ACCESS SECTION_ALL_ACCESS

#define PAGE_NOACCESS          0x01     // winnt
#define PAGE_READONLY          0x02     // winnt
#define PAGE_READWRITE         0x04     // winnt
#define PAGE_WRITECOPY         0x08     // winnt
#define PAGE_EXECUTE           0x10     // winnt
#define PAGE_EXECUTE_READ      0x20     // winnt
#define PAGE_EXECUTE_READWRITE 0x40     // winnt
#define PAGE_EXECUTE_WRITECOPY 0x80     // winnt
#define PAGE_GUARD            0x100     // winnt
#define PAGE_NOCACHE          0x200     // winnt
#define PAGE_WRITECOMBINE     0x400     // winnt
#define PAGE_VIDEO              0x0     // winnt
#define PAGE_OLD_VIDEO        0x800

#define MEM_COMMIT           0x1000     
#define MEM_RESERVE          0x2000     
#define MEM_DECOMMIT         0x4000     
#define MEM_RELEASE          0x8000     
#define MEM_FREE            0x10000     
#define MEM_PRIVATE         0x20000     
#define MEM_MAPPED          0x40000     
#define MEM_RESET           0x80000     
#define MEM_TOP_DOWN       0x100000     
#define MEM_NOZERO         0x800000     
#define MEM_LARGE_PAGES  0x20000000     
#define MEM_4MB_PAGES    0x80000000     
#define SEC_RESERVE       0x4000000     
#define PROCESS_DUP_HANDLE        (0x0040)  // winnt
#define PROCESS_ALL_ACCESS        (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | \
                                   0xFFF)

// end_ntifs

#define MAXIMUM_PROCESSORS 32

// end_winnt

//
// Thread Specific Access Rights
//

#define THREAD_TERMINATE               (0x0001)  // winnt
#define THREAD_SET_INFORMATION         (0x0020)  // winnt

#define THREAD_ALL_ACCESS         (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | \
                                   0x3FF)

//
// ClientId
//

typedef struct _CLIENT_ID {
    HANDLE UniqueProcess;
    HANDLE UniqueThread;
} CLIENT_ID;
typedef CLIENT_ID *PCLIENT_ID;

//
// Thread Environment Block (and portable part of Thread Information Block)
//

//
//  NT_TIB - Thread Information Block - Portable part.
//
//      This is the subsystem portable part of the Thread Information Block.
//      It appears as the first part of the TEB for all threads which have
//      a user mode component.
//
//

// begin_winnt

typedef struct _NT_TIB {
    struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList;
    PVOID StackBase;
    PVOID StackLimit;
    PVOID SubSystemTib;
    union {
        PVOID FiberData;
        ULONG Version;
    };
    PVOID ArbitraryUserPointer;
    struct _NT_TIB *Self;
} NT_TIB;
typedef NT_TIB *PNT_TIB;
//
// Process Information Classes
//

typedef enum _PROCESSINFOCLASS {
    ProcessBasicInformation,
    ProcessQuotaLimits,
    ProcessIoCounters,
    ProcessVmCounters,
    ProcessTimes,
    ProcessBasePriority,
    ProcessRaisePriority,
    ProcessDebugPort,
    ProcessExceptionPort,
    ProcessAccessToken,
    ProcessLdtInformation,
    ProcessLdtSize,
    ProcessDefaultHardErrorMode,
    ProcessIoPortHandlers,          // Note: this is kernel mode only
    ProcessPooledUsageAndLimits,
    ProcessWorkingSetWatch,
    ProcessUserModeIOPL,
    ProcessEnableAlignmentFaultFixup,
    ProcessPriorityClass,
    ProcessWx86Information,
    ProcessHandleCount,
    ProcessAffinityMask,
    ProcessPriorityBoost,
    ProcessDeviceMap,
    ProcessSessionInformation,
    ProcessForegroundInformation,
    ProcessWow64Information,
    MaxProcessInfoClass
    } PROCESSINFOCLASS;
//
// Thread Information Classes
//

typedef enum _THREADINFOCLASS {
    ThreadBasicInformation,
    ThreadTimes,
    ThreadPriority,
    ThreadBasePriority,
    ThreadAffinityMask,
    ThreadImpersonationToken,
    ThreadDescriptorTableEntry,
    ThreadEnableAlignmentFaultFixup,
    ThreadEventPair_Reusable,
    ThreadQuerySetWin32StartAddress,
    ThreadZeroTlsCell,
    ThreadPerformanceCount,
    ThreadAmILastThread,
    ThreadIdealProcessor,
    ThreadPriorityBoost,
    ThreadSetTlsArrayAddress,
    ThreadIsIoPending,
    ThreadHideFromDebugger,
    MaxThreadInfoClass
    } THREADINFOCLASS;
//
// Process Information Structures
//

//
// PageFaultHistory Information
//  NtQueryInformationProcess using ProcessWorkingSetWatch
//
typedef struct _PROCESS_WS_WATCH_INFORMATION {
    PVOID FaultingPc;
    PVOID FaultingVa;
} PROCESS_WS_WATCH_INFORMATION, *PPROCESS_WS_WATCH_INFORMATION;

//
// Basic Process Information
//  NtQueryInformationProcess using ProcessBasicInfo
//

typedef struct _PROCESS_BASIC_INFORMATION {
    NTSTATUS ExitStatus;
    PPEB PebBaseAddress;
    ULONG_PTR AffinityMask;
    KPRIORITY BasePriority;
    ULONG_PTR UniqueProcessId;
    ULONG_PTR InheritedFromUniqueProcessId;
} PROCESS_BASIC_INFORMATION;
typedef PROCESS_BASIC_INFORMATION *PPROCESS_BASIC_INFORMATION;


//
// Process Device Map information
//  NtQueryInformationProcess using ProcessDeviceMap
//  NtSetInformationProcess using ProcessDeviceMap
//

typedef struct _PROCESS_DEVICEMAP_INFORMATION {
    union {
        struct {
            HANDLE DirectoryHandle;
        } Set;
        struct {
            ULONG DriveMap;
            UCHAR DriveType[ 32 ];
        } Query;
    };
} PROCESS_DEVICEMAP_INFORMATION, *PPROCESS_DEVICEMAP_INFORMATION;


//
// Multi-User Session specific Process Information
//  NtQueryInformationProcess using ProcessSessionInformation
//

typedef struct _PROCESS_SESSION_INFORMATION {
    ULONG SessionId;
} PROCESS_SESSION_INFORMATION, *PPROCESS_SESSION_INFORMATION;


//
// Process Quotas
//  NtQueryInformationProcess using ProcessQuotaLimits
//  NtQueryInformationProcess using ProcessPooledQuotaLimits
//  NtSetInformationProcess using ProcessQuotaLimits
//

// begin_winnt begin_ntsrv

typedef struct _QUOTA_LIMITS {
    SIZE_T PagedPoolLimit;
    SIZE_T NonPagedPoolLimit;
    SIZE_T MinimumWorkingSetSize;
    SIZE_T MaximumWorkingSetSize;
    SIZE_T PagefileLimit;
    LARGE_INTEGER TimeLimit;
} QUOTA_LIMITS;
typedef QUOTA_LIMITS *PQUOTA_LIMITS;

// end_winnt end_ntsrv

//
// Process I/O Counters
//  NtQueryInformationProcess using ProcessIoCounters
//

// begin_winnt
typedef struct _IO_COUNTERS {
    ULONGLONG  ReadOperationCount;
    ULONGLONG  WriteOperationCount;
    ULONGLONG  OtherOperationCount;
    ULONGLONG ReadTransferCount;
    ULONGLONG WriteTransferCount;
    ULONGLONG OtherTransferCount;
} IO_COUNTERS;
typedef IO_COUNTERS *PIO_COUNTERS;
// end_winnt

//
// Process Virtual Memory Counters
//  NtQueryInformationProcess using ProcessVmCounters
//

typedef struct _VM_COUNTERS {
    SIZE_T PeakVirtualSize;
    SIZE_T VirtualSize;
    ULONG PageFaultCount;
    SIZE_T PeakWorkingSetSize;
    SIZE_T WorkingSetSize;
    SIZE_T QuotaPeakPagedPoolUsage;
    SIZE_T QuotaPagedPoolUsage;
    SIZE_T QuotaPeakNonPagedPoolUsage;
    SIZE_T QuotaNonPagedPoolUsage;
    SIZE_T PagefileUsage;
    SIZE_T PeakPagefileUsage;
} VM_COUNTERS;
typedef VM_COUNTERS *PVM_COUNTERS;

//
// Process Pooled Quota Usage and Limits
//  NtQueryInformationProcess using ProcessPooledUsageAndLimits
//

typedef struct _POOLED_USAGE_AND_LIMITS {
    SIZE_T PeakPagedPoolUsage;
    SIZE_T PagedPoolUsage;
    SIZE_T PagedPoolLimit;
    SIZE_T PeakNonPagedPoolUsage;
    SIZE_T NonPagedPoolUsage;
    SIZE_T NonPagedPoolLimit;
    SIZE_T PeakPagefileUsage;
    SIZE_T PagefileUsage;
    SIZE_T PagefileLimit;
} POOLED_USAGE_AND_LIMITS;
typedef POOLED_USAGE_AND_LIMITS *PPOOLED_USAGE_AND_LIMITS;

//
// Process Security Context Information
//  NtSetInformationProcess using ProcessAccessToken
// PROCESS_SET_ACCESS_TOKEN access to the process is needed
// to use this info level.
//

typedef struct _PROCESS_ACCESS_TOKEN {

    //
    // Handle to Primary token to assign to the process.
    // TOKEN_ASSIGN_PRIMARY access to this token is needed.
    //

    HANDLE Token;

    //
    // Handle to the initial thread of the process.
    // A process's access token can only be changed if the process has
    // no threads or one thread.  If the process has no threads, this
    // field must be set to NULL.  Otherwise, it must contain a handle
    // open to the process's only thread.  THREAD_QUERY_INFORMATION access
    // is needed via this handle.

    HANDLE Thread;

} PROCESS_ACCESS_TOKEN, *PPROCESS_ACCESS_TOKEN;

//
// Process/Thread System and User Time
//  NtQueryInformationProcess using ProcessTimes
//  NtQueryInformationThread using ThreadTimes
//

typedef struct _KERNEL_USER_TIMES {
    LARGE_INTEGER CreateTime;
    LARGE_INTEGER ExitTime;
    LARGE_INTEGER KernelTime;
    LARGE_INTEGER UserTime;
} KERNEL_USER_TIMES;
typedef KERNEL_USER_TIMES *PKERNEL_USER_TIMES;
NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenProcess (
    OUT PHANDLE ProcessHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN PCLIENT_ID ClientId OPTIONAL
    );
#define NtCurrentProcess() ( (HANDLE) -1 )  
NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryInformationProcess(
    IN HANDLE ProcessHandle,
    IN PROCESSINFOCLASS ProcessInformationClass,
    OUT PVOID ProcessInformation,
    IN ULONG ProcessInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    );
#define NtCurrentThread() ( (HANDLE) -2 )   

#if defined(_X86_)

//
// Types to use to contain PFNs and their counts.
//

typedef ULONG PFN_COUNT;

typedef LONG SPFN_NUMBER, *PSPFN_NUMBER;
typedef ULONG PFN_NUMBER, *PPFN_NUMBER;

//
// Define maximum size of flush multiple TB request.
//

#define FLUSH_MULTIPLE_MAXIMUM 16

//
// Indicate that the i386 compiler supports the pragma textout construct.
//

#define ALLOC_PRAGMA 1

//
// Indicate that the i386 compiler supports the DATA_SEG("INIT") and
// DATA_SEG("PAGE") pragmas
//

#define ALLOC_DATA_PRAGMA 1

#define NORMAL_DISPATCH_LENGTH 22                   
#define DISPATCH_LENGTH NORMAL_DISPATCH_LENGTH      
//
// Interrupt Request Level definitions
//

#define PASSIVE_LEVEL 0             // Passive release level
#define LOW_LEVEL 0                 // Lowest interrupt level
#define APC_LEVEL 1                 // APC interrupt level
#define DISPATCH_LEVEL 2            // Dispatcher level

#define SMBUS_LEVEL 15              // System Management Bus interrupt level
#define PROFILE_LEVEL 26            // Profiler timer interrupt level
#define SCI_LEVEL 27                // System Control Interrupt (SCI) level
#define CLOCK_LEVEL 28              // Interval clock interrupt level
#define IPI_LEVEL 29                // Interprocessor interrupt level
#define POWER_LEVEL 30              // Power failure level
#define HIGH_LEVEL 31               // Highest interrupt level
#define SYNCH_LEVEL (IPI_LEVEL-1)   // Synchronization level

//
// I/O space read and write macros.
//
//  These have to be actual functions on the 386, because we need
//  to use assembler, but cannot return a value if we inline it.
//
//  The READ/WRITE_REGISTER_* calls manipulate I/O registers in MEMORY space.
//  (Use x86 move instructions, with LOCK prefix to force correct behavior
//   w.r.t. caches and write buffers.)
//
//  The READ/WRITE_PORT_* calls manipulate I/O registers in PORT space.
//  (Use x86 in/out instructions.)
//

NTHALAPI
UCHAR
READ_REGISTER_UCHAR(
    PUCHAR  Register
    );

NTHALAPI
USHORT
READ_REGISTER_USHORT(
    PUSHORT Register
    );

NTHALAPI
ULONG
READ_REGISTER_ULONG(
    PULONG  Register
    );

NTHALAPI
VOID
READ_REGISTER_BUFFER_UCHAR(
    PUCHAR  Register,
    PUCHAR  Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
READ_REGISTER_BUFFER_USHORT(
    PUSHORT Register,
    PUSHORT Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
READ_REGISTER_BUFFER_ULONG(
    PULONG  Register,
    PULONG  Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
WRITE_REGISTER_UCHAR(
    PUCHAR  Register,
    UCHAR   Value
    );

NTHALAPI
VOID
WRITE_REGISTER_USHORT(
    PUSHORT Register,
    USHORT  Value
    );

NTHALAPI
VOID
WRITE_REGISTER_ULONG(
    PULONG  Register,
    ULONG   Value
    );

NTHALAPI
VOID
WRITE_REGISTER_BUFFER_UCHAR(
    PUCHAR  Register,
    PUCHAR  Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
WRITE_REGISTER_BUFFER_USHORT(
    PUSHORT Register,
    PUSHORT Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
WRITE_REGISTER_BUFFER_ULONG(
    PULONG  Register,
    PULONG  Buffer,
    ULONG   Count
    );

NTHALAPI
UCHAR
READ_PORT_UCHAR(
    PUCHAR  Port
    );

NTHALAPI
USHORT
READ_PORT_USHORT(
    PUSHORT Port
    );

NTHALAPI
ULONG
READ_PORT_ULONG(
    PULONG  Port
    );

NTHALAPI
VOID
READ_PORT_BUFFER_UCHAR(
    PUCHAR  Port,
    PUCHAR  Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
READ_PORT_BUFFER_USHORT(
    PUSHORT Port,
    PUSHORT Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
READ_PORT_BUFFER_ULONG(
    PULONG  Port,
    PULONG  Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
WRITE_PORT_UCHAR(
    PUCHAR  Port,
    UCHAR   Value
    );

NTHALAPI
VOID
WRITE_PORT_USHORT(
    PUSHORT Port,
    USHORT  Value
    );

NTHALAPI
VOID
WRITE_PORT_ULONG(
    PULONG  Port,
    ULONG   Value
    );

NTHALAPI
VOID
WRITE_PORT_BUFFER_UCHAR(
    PUCHAR  Port,
    PUCHAR  Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
WRITE_PORT_BUFFER_USHORT(
    PUSHORT Port,
    PUSHORT Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
WRITE_PORT_BUFFER_ULONG(
    PULONG  Port,
    PULONG  Buffer,
    ULONG   Count
    );


#define ExAcquireSpinLock(Lock, OldIrql) KeAcquireSpinLock((Lock), (OldIrql))
#define ExReleaseSpinLock(Lock, OldIrql) KeReleaseSpinLock((Lock), (OldIrql))
#define ExAcquireSpinLockAtDpcLevel(Lock) KeAcquireSpinLockAtDpcLevel(Lock)
#define ExReleaseSpinLockFromDpcLevel(Lock) KeReleaseSpinLockFromDpcLevel(Lock)


//
// Processor Control Region Structure Definition
//

typedef struct _KPCR {

    NT_TIB  NtTib;
    struct _KPCR *SelfPcr;              // flat address of this PCR
    struct _KPRCB *Prcb;                // pointer to Prcb
    KIRQL   Irql;

} KPCR;
typedef KPCR *PKPCR;

//
// The non-volatile 387 state
//

typedef struct _KFLOATING_SAVE {
    ULONG   ControlWord;
    ULONG   StatusWord;
    ULONG   ErrorOffset;
    ULONG   ErrorSelector;
    ULONG   DataOffset;                 // Not used in wdm
    ULONG   DataSelector;
    ULONG   Cr0NpxState;
    ULONG   Spare1;                     // Not used in wdm
} KFLOATING_SAVE, *PKFLOATING_SAVE;

//
// i386 Specific portions of mm component
//

//
// Define the page size for the Intel 386 as 4096 (0x1000).
//

#define PAGE_SIZE 0x1000
#define PAGE_SIZE_LARGE 0x400000

//
// Define the number of trailing zeroes in a page aligned virtual address.
// This is used as the shift count when shifting virtual addresses to
// virtual page numbers.
//

#define PAGE_SHIFT 12L
#define PAGE_SHIFT_LARGE 22L

// end_wdm

//
// Define the highest user address and user probe address.
//

//
// The lowest user address reserves the low 64k.
//

#define MM_LOWEST_USER_ADDRESS (PVOID)0x10000


//
// Result type definition for i386.  (Machine specific enumerate type
// which is return type for portable exinterlockedincrement/decrement
// procedures.)  In general, you should use the enumerated type defined
// in ex.h instead of directly referencing these constants.
//

// Flags loaded into AH by LAHF instruction

#define EFLAG_SIGN      0x8000
#define EFLAG_ZERO      0x4000
#define EFLAG_SELECT    (EFLAG_SIGN | EFLAG_ZERO)

#define RESULT_NEGATIVE ((EFLAG_SIGN & ~EFLAG_ZERO) & EFLAG_SELECT)
#define RESULT_ZERO     ((~EFLAG_SIGN & EFLAG_ZERO) & EFLAG_SELECT)
#define RESULT_POSITIVE ((~EFLAG_SIGN & ~EFLAG_ZERO) & EFLAG_SELECT)

// begin_wdm

#define ExInterlockedInsertHeadList     ExfInterlockedInsertHeadList
#define ExInterlockedInsertTailList     ExfInterlockedInsertTailList
#define ExInterlockedRemoveHeadList     ExfInterlockedRemoveHeadList

// end_wdm

//
// Prototypes for architectural specific versions of Exi386 Api
//

NTKERNELAPI
LARGE_INTEGER
ExInterlockedExchangeAddLargeInteger (
    IN PLARGE_INTEGER Addend,
    IN LARGE_INTEGER Increment
    );

//
// Intrinsic interlocked functions
//

#if (defined(_NTDDK_) || defined(_NTIFS_) || defined(_NTHAL_) || defined(NO_INTERLOCKED_INTRINSICS)) && !defined(_WINBASE_)

// begin_wdm

NTKERNELAPI
LONG
FASTCALL
InterlockedIncrement(
    IN PLONG Addend
    );

NTKERNELAPI
LONG
FASTCALL
InterlockedDecrement(
    IN PLONG Addend
    );

NTKERNELAPI
LONG
FASTCALL
InterlockedExchange(
    IN OUT PLONG Target,
    IN LONG Value
    );

#define InterlockedExchangePointer(Target, Value) \
   (PVOID)InterlockedExchange((PLONG)(Target), (LONG)(Value))

NTKERNELAPI
LONG
FASTCALL
InterlockedExchangeAdd(
    IN OUT PLONG Addend,
    IN LONG Increment
    );

NTKERNELAPI
LONG
FASTCALL
InterlockedCompareExchange(
    IN OUT PLONG Destination,
    IN LONG ExChange,
    IN LONG Comperand
    );

#define InterlockedCompareExchangePointer(Destination, ExChange, Comperand) \
    (PVOID)InterlockedCompareExchange((PLONG)Destination, (LONG)ExChange, (LONG)Comperand)

// end_wdm

#endif


#if !defined(MIDL_PASS) && defined(_M_IX86)

//
// i386 function definitions
//

#pragma warning(disable:4035)               // re-enable below


//
// Get current IRQL.
//
// On x86 this function resides in the HAL
//

FORCEINLINE KIRQL KeGetCurrentIrql(VOID)
{
#if defined(_NTSYSTEM_)
    return KeGetPcr()->Irql;
#else
    __asm {  movzx eax, byte ptr fs:[0] KPCR.Irql }
#endif
}    



#endif // !defined(MIDL_PASS) && defined(_M_IX86)


NTKERNELAPI
NTSTATUS
NTAPI
KeSaveFloatingPointState (
    OUT PKFLOATING_SAVE     FloatSave
    );

NTKERNELAPI
NTSTATUS
NTAPI
KeRestoreFloatingPointState (
    IN PKFLOATING_SAVE      FloatSave
    );


#endif // defined(_X86_)


#if defined(_X86_)

//
// Define system time structure.
//

typedef struct _KSYSTEM_TIME {
    ULONG LowPart;
    LONG High1Time;
    LONG High2Time;
} KSYSTEM_TIME, *PKSYSTEM_TIME;

#endif


#ifdef _X86_

//
// Disable these two pramas that evaluate to "sti" "cli" on x86 so that driver
// writers to not leave them inadvertantly in their code.
//

#if !defined(MIDL_PASS)
#if !defined(RC_INVOKED)

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4164)   // disable C4164 warning so that apps that
                                // build with /Od don't get weird errors !
#ifdef _M_IX86
#pragma function(_enable)
#pragma function(_disable)
#endif

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4164)   // reenable C4164 warning
#endif

#endif
#endif

//
// Size of kernel mode stack.
//

#define KERNEL_STACK_SIZE 12288

//
// Size of kernel mode stack minus the overhead associated with the FPU save
// area and thread local storage area.  A thread's stack should have at least
// this many bytes available for actual stack usage.
//

#define KERNEL_USABLE_STACK_SIZE (KERNEL_STACK_SIZE - sizeof(FX_SAVE_AREA) - 512)

#ifdef _X86_

//
//  Define the size of the 80387 save area, which is in the context frame.
//

#define SIZE_OF_80387_REGISTERS      80

//
// Define the size of FP registers in the FXSAVE format.
//

#define SIZE_OF_FX_REGISTERS        128

//
// The following flags control the contents of the CONTEXT structure.
//

#if !defined(RC_INVOKED)

#define CONTEXT_i386    0x00010000    // this assumes that i386 and
#define CONTEXT_i486    0x00010000    // i486 have identical context records

// end_wx86

#define CONTEXT_CONTROL         (CONTEXT_i386 | 0x00000001L) // SS:SP, CS:IP, FLAGS, BP
#define CONTEXT_INTEGER         (CONTEXT_i386 | 0x00000002L) // AX, BX, CX, DX, SI, DI
#define CONTEXT_SEGMENTS        (CONTEXT_i386 | 0x00000004L) // DS, ES, FS, GS
#define CONTEXT_FLOATING_POINT  (CONTEXT_i386 | 0x00000008L) // 387 state
#define CONTEXT_DEBUG_REGISTERS (CONTEXT_i386 | 0x00000010L) // DB 0-3,6,7
#define CONTEXT_EXTENDED_REGISTERS  (CONTEXT_i386 | 0x00000020L) // cpu specific extensions

#define CONTEXT_FULL (CONTEXT_CONTROL | CONTEXT_INTEGER |\
                      CONTEXT_SEGMENTS)

// begin_wx86

#endif

#define MAXIMUM_SUPPORTED_EXTENSION     512

#include <pshpack1.h>
typedef struct _FLOATING_SAVE_AREA {
    USHORT  ControlWord;
    USHORT  StatusWord;
    USHORT  TagWord;
    USHORT  ErrorOpcode;
    ULONG   ErrorOffset;
    ULONG   ErrorSelector;
    ULONG   DataOffset;
    ULONG   DataSelector;
    ULONG   MXCsr;
    ULONG   Reserved2;
    UCHAR   RegisterArea[SIZE_OF_FX_REGISTERS];
    UCHAR   XmmRegisterArea[SIZE_OF_FX_REGISTERS];
    UCHAR   Reserved4[224];
    ULONG   Cr0NpxState;
} FLOATING_SAVE_AREA;
#include <poppack.h>

typedef FLOATING_SAVE_AREA *PFLOATING_SAVE_AREA;

//
// Context Frame
//
//  This frame has a several purposes: 1) it is used as an argument to
//  NtContinue, 2) is is used to constuct a call frame for APC delivery,
//  and 3) it is used in the user level thread creation routines.
//
//  The layout of the record conforms to a standard call frame.
//

typedef struct _CONTEXT {

    //
    // The flags values within this flag control the contents of
    // a CONTEXT record.
    //
    // If the context record is used as an input parameter, then
    // for each portion of the context record controlled by a flag
    // whose value is set, it is assumed that that portion of the
    // context record contains valid context. If the context record
    // is being used to modify a threads context, then only that
    // portion of the threads context will be modified.
    //
    // If the context record is used as an IN OUT parameter to capture
    // the context of a thread, then only those portions of the thread's
    // context corresponding to set flags will be returned.
    //
    // The context record is never used as an OUT only parameter.
    //

    ULONG ContextFlags;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_FLOATING_POINT.
    //

    FLOATING_SAVE_AREA FloatSave;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_INTEGER.
    //

    ULONG   Edi;
    ULONG   Esi;
    ULONG   Ebx;
    ULONG   Edx;
    ULONG   Ecx;
    ULONG   Eax;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_CONTROL.
    //

    ULONG   Ebp;
    ULONG   Eip;
    ULONG   SegCs;              // MUST BE SANITIZED
    ULONG   EFlags;             // MUST BE SANITIZED
    ULONG   Esp;
    ULONG   SegSs;

} CONTEXT;

typedef CONTEXT *PCONTEXT;

// begin_ntminiport

#endif //_X86_

#endif // _X86_
//
// Event Specific Access Rights.
//

#define EVENT_QUERY_STATE       0x0001
#define EVENT_MODIFY_STATE      0x0002  // winnt
#define EVENT_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|0x3) // winnt

//
// Semaphore Specific Access Rights.
//

#define SEMAPHORE_QUERY_STATE       0x0001
#define SEMAPHORE_MODIFY_STATE      0x0002  // winnt

#define SEMAPHORE_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|0x3) // winnt

//
// Timer APC routine definition.
//

typedef
VOID
(*PTIMER_APC_ROUTINE) (
    IN PVOID TimerContext,
    IN ULONG TimerLowValue,
    IN LONG TimerHighValue
    );


//
// Defined processor features
//

#define PF_FLOATING_POINT_PRECISION_ERRATA  0   // winnt
#define PF_FLOATING_POINT_EMULATED          1   // winnt
#define PF_COMPARE_EXCHANGE_DOUBLE          2   // winnt
#define PF_MMX_INSTRUCTIONS_AVAILABLE       3   // winnt
#define PF_PPC_MOVEMEM_64BIT_OK             4   // winnt
#define PF_ALPHA_BYTE_INSTRUCTIONS          5   // winnt
#define PF_XMMI_INSTRUCTIONS_AVAILABLE      6   // winnt
#define PF_3DNOW_INSTRUCTIONS_AVAILABLE     7   // winnt
#define PF_RDTSC_INSTRUCTION_AVAILABLE      8   // winnt
#define PF_PAE_ENABLED                      9   // winnt

typedef enum _ALTERNATIVE_ARCHITECTURE_TYPE {
    StandardDesign,                 // None == 0 == standard design
    NEC98x86,                       // NEC PC98xx series on X86
    EndAlternatives                 // past end of known alternatives
} ALTERNATIVE_ARCHITECTURE_TYPE;

#ifndef IsNEC_98
#define IsNEC_98 (FALSE)
#endif

#ifndef IsNotNEC_98
#define IsNotNEC_98 (TRUE)
#endif

#ifndef SetNEC_98
#define SetNEC_98
#endif

#ifndef SetNotNEC_98
#define SetNotNEC_98
#endif

#define PROCESSOR_FEATURE_MAX 64

// begin_winnt
//
// Predefined Value Types.
//

#define REG_NONE                    ( 0 )   // No value type
#define REG_SZ                      ( 1 )   // Unicode nul terminated string
#define REG_EXPAND_SZ               ( 2 )   // Unicode nul terminated string
                                            // (with environment variable references)
#define REG_BINARY                  ( 3 )   // Free form binary
#define REG_DWORD                   ( 4 )   // 32-bit number
#define REG_DWORD_LITTLE_ENDIAN     ( 4 )   // 32-bit number (same as REG_DWORD)
#define REG_DWORD_BIG_ENDIAN        ( 5 )   // 32-bit number
#define REG_LINK                    ( 6 )   // Symbolic Link (unicode)
#define REG_MULTI_SZ                ( 7 )   // Multiple Unicode strings
#define REG_RESOURCE_LIST           ( 8 )   // Resource list in the resource map
#define REG_FULL_RESOURCE_DESCRIPTOR ( 9 )  // Resource list in the hardware description
#define REG_RESOURCE_REQUIREMENTS_LIST ( 10 )
#define REG_QWORD                   ( 11 )  // 64-bit number
#define REG_QWORD_LITTLE_ENDIAN     ( 11 )  // 64-bit number (same as REG_QWORD)

// end_winnt
//
// Service Types (Bit Mask)
//
#define SERVICE_KERNEL_DRIVER          0x00000001
#define SERVICE_FILE_SYSTEM_DRIVER     0x00000002
#define SERVICE_ADAPTER                0x00000004
#define SERVICE_RECOGNIZER_DRIVER      0x00000008

#define SERVICE_DRIVER                 (SERVICE_KERNEL_DRIVER | \
                                        SERVICE_FILE_SYSTEM_DRIVER | \
                                        SERVICE_RECOGNIZER_DRIVER)

#define SERVICE_WIN32_OWN_PROCESS      0x00000010
#define SERVICE_WIN32_SHARE_PROCESS    0x00000020
#define SERVICE_WIN32                  (SERVICE_WIN32_OWN_PROCESS | \
                                        SERVICE_WIN32_SHARE_PROCESS)

#define SERVICE_INTERACTIVE_PROCESS    0x00000100

#define SERVICE_TYPE_ALL               (SERVICE_WIN32  | \
                                        SERVICE_ADAPTER | \
                                        SERVICE_DRIVER  | \
                                        SERVICE_INTERACTIVE_PROCESS)

//
// Start Type
//

#define SERVICE_BOOT_START             0x00000000
#define SERVICE_SYSTEM_START           0x00000001
#define SERVICE_AUTO_START             0x00000002
#define SERVICE_DEMAND_START           0x00000003
#define SERVICE_DISABLED               0x00000004

//
// Error control type
//
#define SERVICE_ERROR_IGNORE           0x00000000
#define SERVICE_ERROR_NORMAL           0x00000001
#define SERVICE_ERROR_SEVERE           0x00000002
#define SERVICE_ERROR_CRITICAL         0x00000003

//
//
// Define the registry driver node enumerations
//

typedef enum _CM_SERVICE_NODE_TYPE {
    DriverType               = SERVICE_KERNEL_DRIVER,
    FileSystemType           = SERVICE_FILE_SYSTEM_DRIVER,
    Win32ServiceOwnProcess   = SERVICE_WIN32_OWN_PROCESS,
    Win32ServiceShareProcess = SERVICE_WIN32_SHARE_PROCESS,
    AdapterType              = SERVICE_ADAPTER,
    RecognizerType           = SERVICE_RECOGNIZER_DRIVER
} SERVICE_NODE_TYPE;

typedef enum _CM_SERVICE_LOAD_TYPE {
    BootLoad    = SERVICE_BOOT_START,
    SystemLoad  = SERVICE_SYSTEM_START,
    AutoLoad    = SERVICE_AUTO_START,
    DemandLoad  = SERVICE_DEMAND_START,
    DisableLoad = SERVICE_DISABLED
} SERVICE_LOAD_TYPE;

typedef enum _CM_ERROR_CONTROL_TYPE {
    IgnoreError   = SERVICE_ERROR_IGNORE,
    NormalError   = SERVICE_ERROR_NORMAL,
    SevereError   = SERVICE_ERROR_SEVERE,
    CriticalError = SERVICE_ERROR_CRITICAL
} SERVICE_ERROR_TYPE;


//
// Resource List definitions
//

// begin_ntminiport begin_ntndis

//
// Defines the Type in the RESOURCE_DESCRIPTOR
//
// NOTE:  For all CM_RESOURCE_TYPE values, there must be a
// corresponding ResType value in the 32-bit ConfigMgr headerfile
// (cfgmgr32.h).  Values in the range [0x6,0x80) use the same values
// as their ConfigMgr counterparts.  CM_RESOURCE_TYPE values with
// the high bit set (i.e., in the range [0x80,0xFF]), are
// non-arbitrated resources.  These correspond to the same values
// in cfgmgr32.h that have their high bit set (however, since
// cfgmgr32.h uses 16 bits for ResType values, these values are in
// the range [0x8000,0x807F).  Note that ConfigMgr ResType values
// cannot be in the range [0x8080,0xFFFF), because they would not
// be able to map into CM_RESOURCE_TYPE values.  (0xFFFF itself is
// a special value, because it maps to CmResourceTypeDeviceSpecific.)
//

typedef int CM_RESOURCE_TYPE;

// CmResourceTypeNull is reserved

#define CmResourceTypeNull                0   // ResType_All or ResType_None (0x0000)
#define CmResourceTypePort                1   // ResType_IO (0x0002)
#define CmResourceTypeInterrupt           2   // ResType_IRQ (0x0004)
#define CmResourceTypeMemory              3   // ResType_Mem (0x0001)
#define CmResourceTypeDma                 4   // ResType_DMA (0x0003)
#define CmResourceTypeDeviceSpecific      5   // ResType_ClassSpecific (0xFFFF)
#define CmResourceTypeBusNumber           6   // ResType_BusNumber (0x0006)
// end_wdm
#define CmResourceTypeMaximum             7
#define CmResourceTypeAssignedResource    8   // BUGBUG--remove
#define CmResourceTypeSubAllocateFrom     9   // BUGBUG--remove
// begin_wdm
#define CmResourceTypeNonArbitrated     128   // Not arbitrated if 0x80 bit set
#define CmResourceTypeConfigData        128   // ResType_Reserved (0x8000)
#define CmResourceTypeDevicePrivate     129   // ResType_DevicePrivate (0x8001)
#define CmResourceTypePcCardConfig      130   // ResType_PcCardConfig (0x8002)
#define CmResourceTypeMfCardConfig      131   // ResType_MfCardConfig (0x8003)

//
// Defines the ShareDisposition in the RESOURCE_DESCRIPTOR
//

typedef enum _CM_SHARE_DISPOSITION {
    CmResourceShareUndetermined = 0,    // Reserved
    CmResourceShareDeviceExclusive,
    CmResourceShareDriverExclusive,
    CmResourceShareShared
} CM_SHARE_DISPOSITION;

//
// Define the PASSIGNED_RESOURCE type
//

#ifndef PASSIGNED_RESOURCE_DEFINED
#define PASSIGNED_RESOURCE_DEFINED
typedef PVOID PASSIGNED_RESOURCE;
#endif // PASSIGNED_RESOURCE_DEFINED

// end_wdm

//
// Define the bit masks for Flags common for all CM_RESOURCE_TYPE
//
// BUGBUG--remove the following 3 flags...
//
#define CM_RESOURCE_COMMON_COMPUTE_LENGTH_FROM_DEPENDENTS   0x8000
#define CM_RESOURCE_COMMON_NOT_REASSIGNED                   0x4000
#define CM_RESOURCE_COMMON_SUBSTRACTIVE                     0x2000

// begin_wdm

//
// Define the bit masks for Flags when type is CmResourceTypeInterrupt
//

#define CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE 0
#define CM_RESOURCE_INTERRUPT_LATCHED         1

//
// Define the bit masks for Flags when type is CmResourceTypeMemory
//

#define CM_RESOURCE_MEMORY_READ_WRITE       0x0000
#define CM_RESOURCE_MEMORY_READ_ONLY        0x0001
#define CM_RESOURCE_MEMORY_WRITE_ONLY       0x0002
#define CM_RESOURCE_MEMORY_PREFETCHABLE     0x0004

#define CM_RESOURCE_MEMORY_COMBINEDWRITE    0x0008
#define CM_RESOURCE_MEMORY_24               0x0010
#define CM_RESOURCE_MEMORY_CACHEABLE        0x0020

//
// Define the bit masks for Flags when type is CmResourceTypePort
//

#define CM_RESOURCE_PORT_MEMORY                             0x0000
#define CM_RESOURCE_PORT_IO                                 0x0001
// end_wdm
#define CM_RESOURCE_PORT_FORWARD_FIRST_256_OF_EACH_1024     0x0002  // BUGBUG--remove
// begin_wdm
#define CM_RESOURCE_PORT_10_BIT_DECODE                      0x0004
#define CM_RESOURCE_PORT_12_BIT_DECODE                      0x0008
#define CM_RESOURCE_PORT_16_BIT_DECODE                      0x0010
#define CM_RESOURCE_PORT_POSITIVE_DECODE                    0x0020
#define CM_RESOURCE_PORT_PASSIVE_DECODE                     0x0040
#define CM_RESOURCE_PORT_WINDOW_DECODE                      0x0080

//
// Define the bit masks for Flags when type is CmResourceTypeDma
//

#define CM_RESOURCE_DMA_8                   0x0000
#define CM_RESOURCE_DMA_16                  0x0001
#define CM_RESOURCE_DMA_32                  0x0002
#define CM_RESOURCE_DMA_8_AND_16            0x0004
#define CM_RESOURCE_DMA_BUS_MASTER          0x0008
#define CM_RESOURCE_DMA_TYPE_A              0x0010
#define CM_RESOURCE_DMA_TYPE_B              0x0020
#define CM_RESOURCE_DMA_TYPE_F              0x0040
// end_wdm

//
// Define the bit masks for Flags when type is CmResourceTypeBusNumber
//

#define CM_RESOURCE_BUSNUMBER_SUBALLOCATE_FIRST_VALUE   0x0001  // BUGBUG--remove

//
// Define the bit masks for Flags when type is CmResourceTypeSubAllocateFrom
//

#define CM_RESOURCE_SUBALLOCATEFROM_FIXED_TRANSLATION   0x0001  // BUGBUG--remove
#define CM_RESOURCE_SUBALLOCATEFROM_WIRED_TRANSLATION   0x0002  // BUGBUG--remove

// end_ntminiport end_ntndis

// begin_wdm

//
// This structure defines one type of resource used by a driver.
//
// There can only be *1* DeviceSpecificData block. It must be located at
// the end of all resource descriptors in a full descriptor block.
//

//
// Make sure alignment is made properly by compiler; otherwise move
// flags back to the top of the structure (common to all members of the
// union).
//
// begin_ntndis

#include "pshpack4.h"
typedef struct _CM_PARTIAL_RESOURCE_DESCRIPTOR {
    UCHAR Type;
    UCHAR ShareDisposition;
    USHORT Flags;
    union {

        //
        // Range of resources, inclusive.  These are physical, bus relative.
        // It is known that Port and Memory below have the exact same layout
        // as Generic.
        //

        struct {
            PHYSICAL_ADDRESS Start;
            ULONG Length;
        } Generic;

        //
        // end_wdm
        // Range of port numbers, inclusive. These are physical, bus
        // relative. The value should be the same as the one passed to
        // HalTranslateBusAddress().
        // begin_wdm
        //

        struct {
            PHYSICAL_ADDRESS Start;
            ULONG Length;
        } Port;

        //
        // end_wdm
        // IRQL and vector. Should be same values as were passed to
        // HalGetInterruptVector().
        // begin_wdm
        //

        struct {
            ULONG Level;
            ULONG Vector;
            ULONG Affinity;
        } Interrupt;

        //
        // Range of memory addresses, inclusive. These are physical, bus
        // relative. The value should be the same as the one passed to
        // HalTranslateBusAddress().
        //

        struct {
            PHYSICAL_ADDRESS Start;    // 64 bit physical addresses.
            ULONG Length;
        } Memory;

        //
        // Physical DMA channel.
        //

        struct {
            ULONG Channel;
            ULONG Port;
            ULONG Reserved1;
        } Dma;

        //
        // Device driver private data, usually used to help it figure
        // what the resource assignments decisions that were made.
        //

        struct {
            ULONG Data[3];
        } DevicePrivate;

        //
        // Bus Number information.
        //

        struct {
            ULONG Start;
            ULONG Length;
            ULONG Reserved;
        } BusNumber;

        //
        // Device Specific information defined by the driver.
        // The DataSize field indicates the size of the data in bytes. The
        // data is located immediately after the DeviceSpecificData field in
        // the structure.
        //

        struct {
            ULONG DataSize;
            ULONG Reserved1;
            ULONG Reserved2;
        } DeviceSpecificData;
    } u;
} CM_PARTIAL_RESOURCE_DESCRIPTOR, *PCM_PARTIAL_RESOURCE_DESCRIPTOR;
#include "poppack.h"

//
// A Partial Resource List is what can be found in the ARC firmware
// or will be generated by ntdetect.com.
// The configuration manager will transform this structure into a Full
// resource descriptor when it is about to store it in the regsitry.
//
// Note: There must a be a convention to the order of fields of same type,
// (defined on a device by device basis) so that the fields can make sense
// to a driver (i.e. when multiple memory ranges are necessary).
//

typedef struct _CM_PARTIAL_RESOURCE_LIST {
    USHORT Version;
    USHORT Revision;
    ULONG Count;
    CM_PARTIAL_RESOURCE_DESCRIPTOR PartialDescriptors[1];
} CM_PARTIAL_RESOURCE_LIST, *PCM_PARTIAL_RESOURCE_LIST;

//
// A Full Resource Descriptor is what can be found in the registry.
// This is what will be returned to a driver when it queries the registry
// to get device information; it will be stored under a key in the hardware
// description tree.
//
// end_wdm
// Note: The BusNumber and Type are redundant information, but we will keep
// it since it allows the driver _not_ to append it when it is creating
// a resource list which could possibly span multiple buses.
//
// begin_wdm
// Note: There must a be a convention to the order of fields of same type,
// (defined on a device by device basis) so that the fields can make sense
// to a driver (i.e. when multiple memory ranges are necessary).
//

typedef struct _CM_FULL_RESOURCE_DESCRIPTOR {
    INTERFACE_TYPE InterfaceType; // unused for WDM
    ULONG BusNumber; // unused for WDM
    CM_PARTIAL_RESOURCE_LIST PartialResourceList;
} CM_FULL_RESOURCE_DESCRIPTOR, *PCM_FULL_RESOURCE_DESCRIPTOR;

//
// The Resource list is what will be stored by the drivers into the
// resource map via the IO API.
//

typedef struct _CM_RESOURCE_LIST {
    ULONG Count;
    CM_FULL_RESOURCE_DESCRIPTOR List[1];
} CM_RESOURCE_LIST, *PCM_RESOURCE_LIST;

// end_ntndis
//
// Define the structures used to interpret configuration data of
// \\Registry\machine\hardware\description tree.
// Basically, these structures are used to interpret component
// sepcific data.
//

//
// Define DEVICE_FLAGS
//

typedef struct _DEVICE_FLAGS {
    ULONG Failed : 1;
    ULONG ReadOnly : 1;
    ULONG Removable : 1;
    ULONG ConsoleIn : 1;
    ULONG ConsoleOut : 1;
    ULONG Input : 1;
    ULONG Output : 1;
} DEVICE_FLAGS, *PDEVICE_FLAGS;

//
// Define Component Information structure
//

typedef struct _CM_COMPONENT_INFORMATION {
    DEVICE_FLAGS Flags;
    ULONG Version;
    ULONG Key;
    ULONG AffinityMask;
} CM_COMPONENT_INFORMATION, *PCM_COMPONENT_INFORMATION;

//
// The following structures are used to interpret x86
// DeviceSpecificData of CM_PARTIAL_RESOURCE_DESCRIPTOR.
// (Most of the structures are defined by BIOS.  They are
// not aligned on word (or dword) boundary.
//

//
// Define the Rom Block structure
//

typedef struct _CM_ROM_BLOCK {
    ULONG Address;
    ULONG Size;
} CM_ROM_BLOCK, *PCM_ROM_BLOCK;

// begin_ntminiport begin_ntndis

#include "pshpack1.h"

// end_ntminiport end_ntndis

//
// Define INT13 driver parameter block
//

typedef struct _CM_INT13_DRIVE_PARAMETER {
    USHORT DriveSelect;
    ULONG MaxCylinders;
    USHORT SectorsPerTrack;
    USHORT MaxHeads;
    USHORT NumberDrives;
} CM_INT13_DRIVE_PARAMETER, *PCM_INT13_DRIVE_PARAMETER;

// begin_ntminiport begin_ntndis

//
// Define Mca POS data block for slot
//

typedef struct _CM_MCA_POS_DATA {
    USHORT AdapterId;
    UCHAR PosData1;
    UCHAR PosData2;
    UCHAR PosData3;
    UCHAR PosData4;
} CM_MCA_POS_DATA, *PCM_MCA_POS_DATA;

//
// Memory configuration of eisa data block structure
//

typedef struct _EISA_MEMORY_TYPE {
    UCHAR ReadWrite: 1;
    UCHAR Cached : 1;
    UCHAR Reserved0 :1;
    UCHAR Type:2;
    UCHAR Shared:1;
    UCHAR Reserved1 :1;
    UCHAR MoreEntries : 1;
} EISA_MEMORY_TYPE, *PEISA_MEMORY_TYPE;

typedef struct _EISA_MEMORY_CONFIGURATION {
    EISA_MEMORY_TYPE ConfigurationByte;
    UCHAR DataSize;
    USHORT AddressLowWord;
    UCHAR AddressHighByte;
    USHORT MemorySize;
} EISA_MEMORY_CONFIGURATION, *PEISA_MEMORY_CONFIGURATION;


//
// Interrupt configurationn of eisa data block structure
//

typedef struct _EISA_IRQ_DESCRIPTOR {
    UCHAR Interrupt : 4;
    UCHAR Reserved :1;
    UCHAR LevelTriggered :1;
    UCHAR Shared : 1;
    UCHAR MoreEntries : 1;
} EISA_IRQ_DESCRIPTOR, *PEISA_IRQ_DESCRIPTOR;

typedef struct _EISA_IRQ_CONFIGURATION {
    EISA_IRQ_DESCRIPTOR ConfigurationByte;
    UCHAR Reserved;
} EISA_IRQ_CONFIGURATION, *PEISA_IRQ_CONFIGURATION;


//
// DMA description of eisa data block structure
//

typedef struct _DMA_CONFIGURATION_BYTE0 {
    UCHAR Channel : 3;
    UCHAR Reserved : 3;
    UCHAR Shared :1;
    UCHAR MoreEntries :1;
} DMA_CONFIGURATION_BYTE0;

typedef struct _DMA_CONFIGURATION_BYTE1 {
    UCHAR Reserved0 : 2;
    UCHAR TransferSize : 2;
    UCHAR Timing : 2;
    UCHAR Reserved1 : 2;
} DMA_CONFIGURATION_BYTE1;

typedef struct _EISA_DMA_CONFIGURATION {
    DMA_CONFIGURATION_BYTE0 ConfigurationByte0;
    DMA_CONFIGURATION_BYTE1 ConfigurationByte1;
} EISA_DMA_CONFIGURATION, *PEISA_DMA_CONFIGURATION;


//
// Port description of eisa data block structure
//

typedef struct _EISA_PORT_DESCRIPTOR {
    UCHAR NumberPorts : 5;
    UCHAR Reserved :1;
    UCHAR Shared :1;
    UCHAR MoreEntries : 1;
} EISA_PORT_DESCRIPTOR, *PEISA_PORT_DESCRIPTOR;

typedef struct _EISA_PORT_CONFIGURATION {
    EISA_PORT_DESCRIPTOR Configuration;
    USHORT PortAddress;
} EISA_PORT_CONFIGURATION, *PEISA_PORT_CONFIGURATION;


//
// Eisa slot information definition
// N.B. This structure is different from the one defined
//      in ARC eisa addendum.
//

typedef struct _CM_EISA_SLOT_INFORMATION {
    UCHAR ReturnCode;
    UCHAR ReturnFlags;
    UCHAR MajorRevision;
    UCHAR MinorRevision;
    USHORT Checksum;
    UCHAR NumberFunctions;
    UCHAR FunctionInformation;
    ULONG CompressedId;
} CM_EISA_SLOT_INFORMATION, *PCM_EISA_SLOT_INFORMATION;


//
// Eisa function information definition
//

typedef struct _CM_EISA_FUNCTION_INFORMATION {
    ULONG CompressedId;
    UCHAR IdSlotFlags1;
    UCHAR IdSlotFlags2;
    UCHAR MinorRevision;
    UCHAR MajorRevision;
    UCHAR Selections[26];
    UCHAR FunctionFlags;
    UCHAR TypeString[80];
    EISA_MEMORY_CONFIGURATION EisaMemory[9];
    EISA_IRQ_CONFIGURATION EisaIrq[7];
    EISA_DMA_CONFIGURATION EisaDma[4];
    EISA_PORT_CONFIGURATION EisaPort[20];
    UCHAR InitializationData[60];
} CM_EISA_FUNCTION_INFORMATION, *PCM_EISA_FUNCTION_INFORMATION;

//
// The following defines the way pnp bios information is stored in
// the registry \\HKEY_LOCAL_MACHINE\HARDWARE\Description\System\MultifunctionAdapter\x
// key, where x is an integer number indicating adapter instance. The
// "Identifier" of the key must equal to "PNP BIOS" and the
// "ConfigurationData" is organized as follow:
//
//      CM_PNP_BIOS_INSTALLATION_CHECK        +
//      CM_PNP_BIOS_DEVICE_NODE for device 1  +
//      CM_PNP_BIOS_DEVICE_NODE for device 2  +
//                ...
//      CM_PNP_BIOS_DEVICE_NODE for device n
//

//
// Pnp BIOS device node structure
//

typedef struct _CM_PNP_BIOS_DEVICE_NODE {
    USHORT Size;
    UCHAR Node;
    ULONG ProductId;
    UCHAR DeviceType[3];
    USHORT DeviceAttributes;
    // followed by AllocatedResourceBlock, PossibleResourceBlock
    // and CompatibleDeviceId
} CM_PNP_BIOS_DEVICE_NODE,*PCM_PNP_BIOS_DEVICE_NODE;

//
// Pnp BIOS Installation check
//

typedef struct _CM_PNP_BIOS_INSTALLATION_CHECK {
    UCHAR Signature[4];             // $PnP (ascii)
    UCHAR Revision;
    UCHAR Length;
    USHORT ControlField;
    UCHAR Checksum;
    ULONG EventFlagAddress;         // Physical address
    USHORT RealModeEntryOffset;
    USHORT RealModeEntrySegment;
    USHORT ProtectedModeEntryOffset;
    ULONG ProtectedModeCodeBaseAddress;
    ULONG OemDeviceId;
    USHORT RealModeDataBaseAddress;
    ULONG ProtectedModeDataBaseAddress;
} CM_PNP_BIOS_INSTALLATION_CHECK, *PCM_PNP_BIOS_INSTALLATION_CHECK;

#include "poppack.h"

//
// Masks for EISA function information
//

#define EISA_FUNCTION_ENABLED                   0x80
#define EISA_FREE_FORM_DATA                     0x40
#define EISA_HAS_PORT_INIT_ENTRY                0x20
#define EISA_HAS_PORT_RANGE                     0x10
#define EISA_HAS_DMA_ENTRY                      0x08
#define EISA_HAS_IRQ_ENTRY                      0x04
#define EISA_HAS_MEMORY_ENTRY                   0x02
#define EISA_HAS_TYPE_ENTRY                     0x01
#define EISA_HAS_INFORMATION                    EISA_HAS_PORT_RANGE + \
                                                EISA_HAS_DMA_ENTRY + \
                                                EISA_HAS_IRQ_ENTRY + \
                                                EISA_HAS_MEMORY_ENTRY + \
                                                EISA_HAS_TYPE_ENTRY

//
// Masks for EISA memory configuration
//

#define EISA_MORE_ENTRIES                       0x80
#define EISA_SYSTEM_MEMORY                      0x00
#define EISA_MEMORY_TYPE_RAM                    0x01

//
// Returned error code for EISA bios call
//

#define EISA_INVALID_SLOT                       0x80
#define EISA_INVALID_FUNCTION                   0x81
#define EISA_INVALID_CONFIGURATION              0x82
#define EISA_EMPTY_SLOT                         0x83
#define EISA_INVALID_BIOS_CALL                  0x86

// end_ntminiport end_ntndis

//
// The following structures are used to interpret mips
// DeviceSpecificData of CM_PARTIAL_RESOURCE_DESCRIPTOR.
//

//
// Device data records for adapters.
//

//
// The device data record for the Emulex SCSI controller.
//

typedef struct _CM_SCSI_DEVICE_DATA {
    USHORT Version;
    USHORT Revision;
    UCHAR HostIdentifier;
} CM_SCSI_DEVICE_DATA, *PCM_SCSI_DEVICE_DATA;

//
// Device data records for controllers.
//

//
// The device data record for the Video controller.
//

typedef struct _CM_VIDEO_DEVICE_DATA {
    USHORT Version;
    USHORT Revision;
    ULONG VideoClock;
} CM_VIDEO_DEVICE_DATA, *PCM_VIDEO_DEVICE_DATA;

//
// The device data record for the SONIC network controller.
//

typedef struct _CM_SONIC_DEVICE_DATA {
    USHORT Version;
    USHORT Revision;
    USHORT DataConfigurationRegister;
    UCHAR EthernetAddress[8];
} CM_SONIC_DEVICE_DATA, *PCM_SONIC_DEVICE_DATA;

//
// The device data record for the serial controller.
//

typedef struct _CM_SERIAL_DEVICE_DATA {
    USHORT Version;
    USHORT Revision;
    ULONG BaudClock;
} CM_SERIAL_DEVICE_DATA, *PCM_SERIAL_DEVICE_DATA;

//
// Device data records for peripherals.
//

//
// The device data record for the Monitor peripheral.
//

typedef struct _CM_MONITOR_DEVICE_DATA {
    USHORT Version;
    USHORT Revision;
    USHORT HorizontalScreenSize;
    USHORT VerticalScreenSize;
    USHORT HorizontalResolution;
    USHORT VerticalResolution;
    USHORT HorizontalDisplayTimeLow;
    USHORT HorizontalDisplayTime;
    USHORT HorizontalDisplayTimeHigh;
    USHORT HorizontalBackPorchLow;
    USHORT HorizontalBackPorch;
    USHORT HorizontalBackPorchHigh;
    USHORT HorizontalFrontPorchLow;
    USHORT HorizontalFrontPorch;
    USHORT HorizontalFrontPorchHigh;
    USHORT HorizontalSyncLow;
    USHORT HorizontalSync;
    USHORT HorizontalSyncHigh;
    USHORT VerticalBackPorchLow;
    USHORT VerticalBackPorch;
    USHORT VerticalBackPorchHigh;
    USHORT VerticalFrontPorchLow;
    USHORT VerticalFrontPorch;
    USHORT VerticalFrontPorchHigh;
    USHORT VerticalSyncLow;
    USHORT VerticalSync;
    USHORT VerticalSyncHigh;
} CM_MONITOR_DEVICE_DATA, *PCM_MONITOR_DEVICE_DATA;

//
// The device data record for the Floppy peripheral.
//

typedef struct _CM_FLOPPY_DEVICE_DATA {
    USHORT Version;
    USHORT Revision;
    CHAR Size[8];
    ULONG MaxDensity;
    ULONG MountDensity;
    //
    // New data fields for version >= 2.0
    //
    UCHAR StepRateHeadUnloadTime;
    UCHAR HeadLoadTime;
    UCHAR MotorOffTime;
    UCHAR SectorLengthCode;
    UCHAR SectorPerTrack;
    UCHAR ReadWriteGapLength;
    UCHAR DataTransferLength;
    UCHAR FormatGapLength;
    UCHAR FormatFillCharacter;
    UCHAR HeadSettleTime;
    UCHAR MotorSettleTime;
    UCHAR MaximumTrackValue;
    UCHAR DataTransferRate;
} CM_FLOPPY_DEVICE_DATA, *PCM_FLOPPY_DEVICE_DATA;

//
// The device data record for the Keyboard peripheral.
// The KeyboardFlags is defined (by x86 BIOS INT 16h, function 02) as:
//      bit 7 : Insert on
//      bit 6 : Caps Lock on
//      bit 5 : Num Lock on
//      bit 4 : Scroll Lock on
//      bit 3 : Alt Key is down
//      bit 2 : Ctrl Key is down
//      bit 1 : Left shift key is down
//      bit 0 : Right shift key is down
//

typedef struct _CM_KEYBOARD_DEVICE_DATA {
    USHORT Version;
    USHORT Revision;
    UCHAR Type;
    UCHAR Subtype;
    USHORT KeyboardFlags;
} CM_KEYBOARD_DEVICE_DATA, *PCM_KEYBOARD_DEVICE_DATA;

//
// Declaration of the structure for disk geometries
//

typedef struct _CM_DISK_GEOMETRY_DEVICE_DATA {
    ULONG BytesPerSector;
    ULONG NumberOfCylinders;
    ULONG SectorsPerTrack;
    ULONG NumberOfHeads;
} CM_DISK_GEOMETRY_DEVICE_DATA, *PCM_DISK_GEOMETRY_DEVICE_DATA;

// end_wdm
//
// Declaration of the structure for the PcCard ISA IRQ map
//

typedef struct _CM_PCCARD_DEVICE_DATA {
    UCHAR Flags;
    UCHAR ErrorCode;
    USHORT Reserved;
    ULONG BusData;
    ULONG DeviceId;
    ULONG LegacyBaseAddress;
    UCHAR IRQMap[16];
} CM_PCCARD_DEVICE_DATA, *PCM_PCCARD_DEVICE_DATA;

// Definitions for Flags

#define PCCARD_MAP_ERROR        0x01
#define PCCARD_DEVICE_PCI       0x10

#define PCCARD_SCAN_DISABLED    0x01
#define PCCARD_MAP_ZERO         0x02
#define PCCARD_NO_TIMER         0x03
#define PCCARD_NO_PIC           0x04
#define PCCARD_NO_LEGACY_BASE   0x05
#define PCCARD_DUP_LEGACY_BASE  0x06
#define PCCARD_NO_CONTROLLERS   0x07

// begin_wdm
// begin_ntminiport

//
// Defines Resource Options
//

#define IO_RESOURCE_PREFERRED       0x01
#define IO_RESOURCE_DEFAULT         0x02
#define IO_RESOURCE_ALTERNATIVE     0x08


//
// This structure defines one type of resource requested by the driver
//

typedef struct _IO_RESOURCE_DESCRIPTOR {
    UCHAR Option;
    UCHAR Type;                         // use CM_RESOURCE_TYPE
    UCHAR ShareDisposition;             // use CM_SHARE_DISPOSITION
    UCHAR Spare1;
    USHORT Flags;                       // use CM resource flag defines
    USHORT Spare2;                      // align

    union {
        struct {
            ULONG Length;
            ULONG Alignment;
            PHYSICAL_ADDRESS MinimumAddress;
            PHYSICAL_ADDRESS MaximumAddress;
        } Port;

        struct {
            ULONG Length;
            ULONG Alignment;
            PHYSICAL_ADDRESS MinimumAddress;
            PHYSICAL_ADDRESS MaximumAddress;
        } Memory;

        struct {
            ULONG MinimumVector;
            ULONG MaximumVector;
        } Interrupt;

        struct {
            ULONG MinimumChannel;
            ULONG MaximumChannel;
        } Dma;

        struct {
            ULONG Length;
            ULONG Alignment;
            PHYSICAL_ADDRESS MinimumAddress;
            PHYSICAL_ADDRESS MaximumAddress;
        } Generic;

        struct {
            ULONG Data[3];
        } DevicePrivate;

        //
        // Bus Number information.
        //

        struct {
            ULONG Length;
            ULONG MinBusNumber;
            ULONG MaxBusNumber;
            ULONG Reserved;
        } BusNumber;

// end_wdm

        struct {
            PASSIGNED_RESOURCE AssignedResource;
        } AssignedResource;     // will be obsoleted

        struct {
            UCHAR Type;                 // use CM_RESOURCE_TYPE
            UCHAR Reserved[3];
            PASSIGNED_RESOURCE AssignedResource;
            PHYSICAL_ADDRESS Transformation;
        } SubAllocateFrom;      // will be obsoleted

// begin_wdm

        struct {
            ULONG Priority;   // use LCPRI_Xxx values in cfg.h
            ULONG Reserved1;
            ULONG Reserved2;
        } ConfigData;

    } u;

} IO_RESOURCE_DESCRIPTOR, *PIO_RESOURCE_DESCRIPTOR;

// end_ntminiport


typedef struct _IO_RESOURCE_LIST {
    USHORT Version;
    USHORT Revision;

    ULONG Count;
    IO_RESOURCE_DESCRIPTOR Descriptors[1];
} IO_RESOURCE_LIST, *PIO_RESOURCE_LIST;


typedef struct _IO_RESOURCE_REQUIREMENTS_LIST {
    ULONG ListSize;
    INTERFACE_TYPE InterfaceType; // unused for WDM
    ULONG BusNumber; // unused for WDM
    ULONG SlotNumber;
    ULONG Reserved[3];
    ULONG AlternativeLists;
    IO_RESOURCE_LIST  List[1];
} IO_RESOURCE_REQUIREMENTS_LIST, *PIO_RESOURCE_REQUIREMENTS_LIST;

//
// Exception flag definitions.
//

// begin_winnt
#define EXCEPTION_NONCONTINUABLE 0x1    // Noncontinuable exception
// end_winnt

//
// Define maximum number of exception parameters.
//

// begin_winnt
#define EXCEPTION_MAXIMUM_PARAMETERS 15 // maximum number of exception parameters

//
// Exception record definition.
//

typedef struct _EXCEPTION_RECORD {
    NTSTATUS ExceptionCode;
    ULONG ExceptionFlags;
    struct _EXCEPTION_RECORD *ExceptionRecord;
    PVOID ExceptionAddress;
    ULONG NumberParameters;
    ULONG_PTR ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];
    } EXCEPTION_RECORD;

typedef EXCEPTION_RECORD *PEXCEPTION_RECORD;

typedef struct _EXCEPTION_RECORD32 {
    NTSTATUS ExceptionCode;
    ULONG ExceptionFlags;
    ULONG ExceptionRecord;
    ULONG ExceptionAddress;
    ULONG NumberParameters;
    ULONG ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];
} EXCEPTION_RECORD32, *PEXCEPTION_RECORD32;

typedef struct _EXCEPTION_RECORD64 {
    NTSTATUS ExceptionCode;
    ULONG ExceptionFlags;
    ULONG64 ExceptionRecord;
    ULONG64 ExceptionAddress;
    ULONG NumberParameters;
    ULONG __unusedAlignment;
    ULONG64 ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];
} EXCEPTION_RECORD64, *PEXCEPTION_RECORD64;

//
// Typedef for pointer returned by exception_info()
//

typedef struct _EXCEPTION_POINTERS {
    PEXCEPTION_RECORD ExceptionRecord;
    PCONTEXT ContextRecord;
} EXCEPTION_POINTERS, *PEXCEPTION_POINTERS;
// end_winnt


//
// Interrupt modes.
//

typedef enum _KINTERRUPT_MODE {
    LevelSensitive,
    Latched
    } KINTERRUPT_MODE;

//
// Wait reasons
//

typedef enum _KWAIT_REASON {
    Executive,
    FreePage,
    PageIn,
    PoolAllocation,
    DelayExecution,
    Suspended,
    UserRequest,
    WrExecutive,
    WrFreePage,
    WrPageIn,
    WrPoolAllocation,
    WrDelayExecution,
    WrSuspended,
    WrUserRequest,
    WrEventPair,
    WrQueue,
    WrLpcReceive,
    WrLpcReply,
    WrVirtualMemory,
    WrPageOut,
    WrRendezvous,
    WrFsCacheIn,
    WrFsCacheOut,
    Spare4,
    Spare5,
    Spare6,
    WrKernel,
    MaximumWaitReason
    } KWAIT_REASON;

//
// Common dispatcher object header
//
// N.B. The size field contains the number of dwords in the structure.
//

typedef struct _DISPATCHER_HEADER {
    UCHAR Type;
    UCHAR Absolute;
    UCHAR Size;
    UCHAR Inserted;
    LONG SignalState;
    LIST_ENTRY WaitListHead;
} DISPATCHER_HEADER;


typedef struct _KWAIT_BLOCK {
    LIST_ENTRY WaitListEntry;
    struct _KTHREAD *RESTRICTED_POINTER Thread;
    PVOID Object;
    struct _KWAIT_BLOCK *RESTRICTED_POINTER NextWaitBlock;
    USHORT WaitKey;
    USHORT WaitType;
} KWAIT_BLOCK, *PKWAIT_BLOCK, *RESTRICTED_POINTER PRKWAIT_BLOCK;

//
// Thread start function
//

typedef
VOID
(*PKSTART_ROUTINE) (
    IN PVOID StartContext
    );

// end_wdm

//
// Thread system function
//

typedef
VOID
(*PKSYSTEM_ROUTINE) (
    IN PKSTART_ROUTINE StartRoutine OPTIONAL,
    IN PVOID StartContext OPTIONAL
    );

// begin_wdm
//
// Kernel object structure definitions
//

//
// Device Queue object and entry
//

typedef struct _KDEVICE_QUEUE {
    CSHORT Type;
    UCHAR Size;
    BOOLEAN Busy;
    LIST_ENTRY DeviceListHead;
} KDEVICE_QUEUE, *PKDEVICE_QUEUE, *RESTRICTED_POINTER PRKDEVICE_QUEUE;

typedef struct _KDEVICE_QUEUE_ENTRY {
    LIST_ENTRY DeviceListEntry;
    ULONG SortKey;
    BOOLEAN Inserted;
} KDEVICE_QUEUE_ENTRY, *PKDEVICE_QUEUE_ENTRY, *RESTRICTED_POINTER PRKDEVICE_QUEUE_ENTRY;

//
// Event object
//

typedef struct _KEVENT {
    DISPATCHER_HEADER Header;
} KEVENT, *PKEVENT, *RESTRICTED_POINTER PRKEVENT;

//
// Define the interrupt service function type and the empty struct
// type.
//

typedef
BOOLEAN
(*PKSERVICE_ROUTINE) (
    IN struct _KINTERRUPT *Interrupt,
    IN PVOID ServiceContext
    );

//
// Mutant object
//

typedef struct _KMUTANT {
    DISPATCHER_HEADER Header;
    LIST_ENTRY MutantListEntry;
    struct _KTHREAD *RESTRICTED_POINTER OwnerThread;
    BOOLEAN Abandoned;
} KMUTANT, *PKMUTANT, *RESTRICTED_POINTER PRKMUTANT;

//
//
// Semaphore object
//

typedef struct _KSEMAPHORE {
    DISPATCHER_HEADER Header;
    LONG Limit;
} KSEMAPHORE, *PKSEMAPHORE, *RESTRICTED_POINTER PRKSEMAPHORE;

//
//
// Timer object
//

typedef struct _KTIMER {
    DISPATCHER_HEADER Header;
    ULARGE_INTEGER DueTime;
    LIST_ENTRY TimerListEntry;
    struct _KDPC *Dpc;
    LONG Period;
} KTIMER, *PKTIMER, *RESTRICTED_POINTER PRKTIMER;

//
// DPC object
//

NTKERNELAPI
VOID
KeInitializeDpc (
    IN PRKDPC Dpc,
    IN PKDEFERRED_ROUTINE DeferredRoutine,
    IN PVOID DeferredContext
    );

#define INITIALIZED_KDPC(_Dpc, _DeferredRoutine, _DeferredContext)  \
    KDPC _Dpc = {                                                   \
        DpcObject,                                                  \
        FALSE,                                                      \
        0,                                                          \
        NULL,                                                       \
        NULL,                                                       \
        _DeferredRoutine,                                           \
        _DeferredContext                                            \
    }

NTKERNELAPI
BOOLEAN
KeInsertQueueDpc (
    IN PRKDPC Dpc,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

NTKERNELAPI
BOOLEAN
KeRemoveQueueDpc (
    IN PRKDPC Dpc
    );

DECLSPEC_NORETURN
VOID
KeRetireDpcListLoop(
    VOID
    );

//
// Device queue object
//

NTKERNELAPI
VOID
KeInitializeDeviceQueue (
    IN PKDEVICE_QUEUE DeviceQueue
    );

NTKERNELAPI
BOOLEAN
KeInsertDeviceQueue (
    IN PKDEVICE_QUEUE DeviceQueue,
    IN PKDEVICE_QUEUE_ENTRY DeviceQueueEntry
    );

NTKERNELAPI
BOOLEAN
KeInsertByKeyDeviceQueue (
    IN PKDEVICE_QUEUE DeviceQueue,
    IN PKDEVICE_QUEUE_ENTRY DeviceQueueEntry,
    IN ULONG SortKey
    );

NTKERNELAPI
PKDEVICE_QUEUE_ENTRY
KeRemoveDeviceQueue (
    IN PKDEVICE_QUEUE DeviceQueue
    );

NTKERNELAPI
PKDEVICE_QUEUE_ENTRY
KeRemoveByKeyDeviceQueue (
    IN PKDEVICE_QUEUE DeviceQueue,
    IN ULONG SortKey
    );

NTKERNELAPI
BOOLEAN
KeRemoveEntryDeviceQueue (
    IN PKDEVICE_QUEUE DeviceQueue,
    IN PKDEVICE_QUEUE_ENTRY DeviceQueueEntry
    );

NTKERNELAPI                                         
BOOLEAN                                             
KeSynchronizeExecution (                            
    IN PKINTERRUPT Interrupt,                       
    IN PKSYNCHRONIZE_ROUTINE SynchronizeRoutine,    
    IN PVOID SynchronizeContext                     
    );                                              
                                                    
//
// Kernel dispatcher object functions
//
// Event Object
//


NTKERNELAPI
VOID
KeInitializeEvent (
    IN PRKEVENT Event,
    IN EVENT_TYPE Type,
    IN BOOLEAN State
    );


#define KeClearEvent(Event) ((Event)->Header.SignalState = 0)

NTKERNELAPI
LONG
KePulseEvent (
    IN PRKEVENT Event,
    IN KPRIORITY Increment,
    IN BOOLEAN Wait
    );

#define KeReadStateEvent(Event) (Event)->Header.SignalState

// begin_wdm

NTKERNELAPI
LONG
KeResetEvent (
    IN PRKEVENT Event
    );

NTKERNELAPI
LONG
KeSetEvent (
    IN PRKEVENT Event,
    IN KPRIORITY Increment,
    IN BOOLEAN Wait
    );

//
// Semaphore object
//

NTKERNELAPI
VOID
KeInitializeSemaphore (
    IN PRKSEMAPHORE Semaphore,
    IN LONG Count,
    IN LONG Limit
    );

#define KeReadStateSemaphore(Semaphore) (Semaphore)->Header.SignalState

NTKERNELAPI
LONG
KeReleaseSemaphore (
    IN PRKSEMAPHORE Semaphore,
    IN KPRIORITY Increment,
    IN LONG Adjustment,
    IN BOOLEAN Wait
    );

NTKERNELAPI                                         
NTSTATUS                                            
KeDelayExecutionThread (                            
    IN KPROCESSOR_MODE WaitMode,                    
    IN BOOLEAN Alertable,                           
    IN PLARGE_INTEGER Interval                      
    );                                              
                                                    
NTKERNELAPI                                         
LONG                                                
KeSetBasePriorityThread (                           
    IN PKTHREAD Thread,                             
    IN LONG Increment                               
    );                                              
NTKERNELAPI                                         
KPRIORITY                                           
KeSetPriorityThread (                               
    IN PKTHREAD Thread,                             
    IN KPRIORITY Priority                           
    );                                              
                                                    

#if (defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_) || defined(_NTHAL_)) && !defined(_NTSYSTEM_DRIVER_)

// begin_wdm

NTKERNELAPI
VOID
KeEnterCriticalRegion (
    VOID
    );

NTKERNELAPI
VOID
KeLeaveCriticalRegion (
    VOID
    );

// end_wdm

#else

//++
//
// VOID
// KeEnterCriticalRegion (
//    VOID
//    )
//
//
// Routine Description:
//
//    This function disables kernel APC's.
//
//    N.B. The following code does not require any interlocks. There are
//         two cases of interest: 1) On an MP system, the thread cannot
//         be running on two processors as once, and 2) if the thread is
//         is interrupted to deliver a kernel mode APC which also calls
//         this routine, the values read and stored will stack and unstack
//         properly.
//
// Arguments:
//
//    None.
//
// Return Value:
//
//    None.
//--

#define KeEnterCriticalRegion() KeGetCurrentThread()->KernelApcDisable -= 1;

//++
//
// VOID
// KeLeaveCriticalRegion (
//    VOID
//    )
//
//
// Routine Description:
//
//    This function enables kernel APC's.
//
//    N.B. The following code does not require any interlocks. There are
//         two cases of interest: 1) On an MP system, the thread cannot
//         be running on two processors as once, and 2) if the thread is
//         is interrupted to deliver a kernel mode APC which also calls
//         this routine, the values read and stored will stack and unstack
//         properly.
//
// Arguments:
//
//    None.
//
// Return Value:
//
//    None.
//--

#define KeLeaveCriticalRegion() KiLeaveCriticalRegion()

#endif

// begin_wdm

//
// Timer object
//

#define KeInitializeTimer(Timer) KeInitializeTimerEx(Timer, NotificationTimer)

NTKERNELAPI
VOID
KeInitializeTimerEx (
    IN PKTIMER Timer,
    IN TIMER_TYPE Type
    );

#define INITIALIZED_KTIMER(_Timer, _Type)                   \
    KTIMER _Timer = {                                       \
        TimerNotificationObject + _Type,                    \
        FALSE,                                              \
        sizeof(KTIMER) / sizeof(LONG),                      \
        FALSE,                                              \
        FALSE,                                              \
        &_Timer.Header.WaitListHead,                        \
        &_Timer.Header.WaitListHead                         \
    }

NTKERNELAPI
BOOLEAN
KeCancelTimer (
    IN PKTIMER
    );

#define KeClearTimer(Timer) ((Timer)->Header.SignalState = 0)

#define KeReadStateTimer(Timer) ((BOOLEAN)(Timer)->Header.SignalState)

NTKERNELAPI
BOOLEAN
KeSetTimer (
    IN PKTIMER Timer,
    IN LARGE_INTEGER DueTime,
    IN PKDPC Dpc OPTIONAL
    );

NTKERNELAPI
BOOLEAN
KeSetTimerEx (
    IN PKTIMER Timer,
    IN LARGE_INTEGER DueTime,
    IN LONG Period OPTIONAL,
    IN PKDPC Dpc OPTIONAL
    );


NTKERNELAPI
NTSTATUS
KeWaitForMultipleObjects (
    IN ULONG Count,
    IN PVOID Object[],
    IN WAIT_TYPE WaitType,
    IN KWAIT_REASON WaitReason,
    IN KPROCESSOR_MODE WaitMode,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL,
    IN PKWAIT_BLOCK WaitBlockArray
    );

NTKERNELAPI
NTSTATUS
KeWaitForSingleObject (
    IN PVOID Object,
    IN KWAIT_REASON WaitReason,
    IN KPROCESSOR_MODE WaitMode,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL
    );

//
// spin lock functions
//

#define KeInitializeSpinLock(a)             *(a) = 0

#define KeAcquireSpinLockAtDpcLevel(a)      ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL)
#define KeReleaseSpinLockFromDpcLevel(a)

#define KeAcquireSpinLock(a,b)              *(b) = KeRaiseIrqlToDpcLevel()
#define KeReleaseSpinLock(a,b)              KeLowerIrql(b)

#define KeTryToAcquireSpinLock(a,b)         (KeAcquireSpinLock(a,b),TRUE)


#if defined(_X86_)

NTHALAPI
VOID
FASTCALL
KfLowerIrql (
    IN KIRQL NewIrql
    );

NTHALAPI
KIRQL
FASTCALL
KfRaiseIrql (
    IN KIRQL NewIrql
    );

NTHALAPI
KIRQL
KeRaiseIrqlToDpcLevel(
    VOID
    );

NTHALAPI
KIRQL
KeRaiseIrqlToSynchLevel(
    VOID
    );

#define KeLowerIrql(a)      KfLowerIrql(a)
#define KeRaiseIrql(a,b)    *(b) = KfRaiseIrql(a)

#endif

//
// Miscellaneous kernel functions
//

// end_wdm

NTKERNELAPI
DECLSPEC_NORETURN
VOID
NTAPI
KeBugCheck (
    IN ULONG BugCheckCode
    );

// begin_wdm

NTKERNELAPI
DECLSPEC_NORETURN
VOID
KeBugCheckEx(
    IN ULONG BugCheckCode,
    IN ULONG_PTR BugCheckParameter1,
    IN ULONG_PTR BugCheckParameter2,
    IN ULONG_PTR BugCheckParameter3,
    IN ULONG_PTR BugCheckParameter4
    );

// end_wdm

NTKERNELAPI
VOID
KeEnterKernelDebugger (
    VOID
    );


NTKERNELAPI
ULONGLONG
KeQueryInterruptTime (
    VOID
    );

NTKERNELAPI
VOID
KeQuerySystemTime (
    OUT PLARGE_INTEGER CurrentTime
    );

#if !defined(_NTSYSTEM_)

#define KeQueryTickCount() *KeTickCount

#else

#define KeQueryTickCount() KeTickCount

#endif

#define KiQueryLowTickCount KeQueryTickCount

//
// Context swap notify routine.
//

typedef
VOID
(FASTCALL *PSWAP_CONTEXT_NOTIFY_ROUTINE)(
    IN HANDLE OldThreadId,
    IN HANDLE NewThreadId
    );

//
// Thread select notify routine.
//

typedef
LOGICAL
(FASTCALL *PTHREAD_SELECT_NOTIFY_ROUTINE)(
    IN HANDLE ThreadId
    );

//
// Time update notify routine.
//

typedef
VOID
(FASTCALL *PTIME_UPDATE_NOTIFY_ROUTINE)(
    IN HANDLE ThreadId,
    IN KPROCESSOR_MODE Mode
    );

//
// Define external data.
// because of indirection for all drivers external to ntoskrnl these are actually ptrs
//

#if defined(_NTDDK_) || defined(_NTIFS_) || defined(_NTHAL_) || defined(_WDMDDK_) || defined(_XBDM_)

extern PBOOLEAN KdDebuggerNotPresent;
extern PBOOLEAN KdDebuggerEnabled;

#else

extern BOOLEAN KdDebuggerNotPresent;
extern BOOLEAN KdDebuggerEnabled;

#endif




typedef struct _DBGKD_DEBUG_DATA_HEADER64 *PDBGKD_DEBUG_DATA_HEADER64;

BOOLEAN
KdRegisterDebuggerDataBlock(
    IN ULONG Tag,
    IN PDBGKD_DEBUG_DATA_HEADER64 DataHeader,
    IN ULONG Size
    );

VOID
KdDeregisterDebuggerDataBlock32(
    IN PDBGKD_DEBUG_DATA_HEADER64 DataHeader
    );


NTKERNELAPI
PVOID
ExAllocatePool(
    IN SIZE_T NumberOfBytes
    );

NTKERNELAPI
PVOID
NTAPI
ExAllocatePoolWithTag(
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag
    );

#ifndef POOL_TAGGING
#define ExAllocatePoolWithTag(a,b) ExAllocatePool(a)
#endif //POOL_TAGGING

NTKERNELAPI
VOID
NTAPI
ExFreePool(
    IN PVOID P
    );

//

NTKERNELAPI
VOID
FASTCALL
ExInterlockedAddLargeStatistic (
    IN PLARGE_INTEGER Addend,
    IN ULONG Increment
    );

// end_ntndis

NTKERNELAPI
LARGE_INTEGER
ExInterlockedAddLargeInteger (
    IN PLARGE_INTEGER Addend,
    IN LARGE_INTEGER Increment
    );

// begin_wdm begin_ntddk begin_nthal begin_ntifs

NTKERNELAPI
LONGLONG
FASTCALL
ExInterlockedCompareExchange64 (
    IN PLONGLONG Destination,
    IN PLONGLONG Exchange,
    IN PLONGLONG Comperand
    );

NTKERNELAPI
PLIST_ENTRY
FASTCALL
ExInterlockedInsertHeadList (
    IN PLIST_ENTRY ListHead,
    IN PLIST_ENTRY ListEntry
    );

NTKERNELAPI
PLIST_ENTRY
FASTCALL
ExInterlockedInsertTailList (
    IN PLIST_ENTRY ListHead,
    IN PLIST_ENTRY ListEntry
    );

NTKERNELAPI
PLIST_ENTRY
FASTCALL
ExInterlockedRemoveHeadList (
    IN PLIST_ENTRY ListHead
    );

// begin_ntndis

//
// Define interlocked sequenced listhead functions.
//
// A sequenced interlocked list is a singly linked list with a header that
// contains the current depth and a sequence number. Each time an entry is
// inserted or removed from the list the depth is updated and the sequence
// number is incremented. This enables MIPS, Alpha, and Pentium and later
// machines to insert and remove from the list without the use of spinlocks.
// The PowerPc, however, must use a spinlock to synchronize access to the
// list.
//
// N.B. A spinlock must be specified with SLIST operations. However, it may
//      not actually be used.
//

/*++

VOID
ExInitializeSListHead (
    IN PSLIST_HEADER SListHead
    )

Routine Description:

    This function initializes a sequenced singly linked listhead.

Arguments:

    SListHead - Supplies a pointer to a sequenced singly linked listhead.

Return Value:

    None.

--*/

#define ExInitializeSListHead(_listhead_) (_listhead_)->Alignment = 0

/*++

USHORT
ExQueryDepthSList (
    IN PSLIST_HEADERT SListHead
    )

Routine Description:

    This function queries the current number of entries contained in a
    sequenced single linked list.

Arguments:

    SListHead - Supplies a pointer to the sequenced listhead which is
        be queried.

Return Value:

    The current number of entries in the sequenced singly linked list is
    returned as the function value.

--*/

#define ExQueryDepthSList(_listhead_) (USHORT)(_listhead_)->Depth

#if !defined(_WINBASE_)

NTKERNELAPI
PSINGLE_LIST_ENTRY
FASTCALL
InterlockedPopEntrySList (
    IN PSLIST_HEADER ListHead
    );

NTKERNELAPI
PSINGLE_LIST_ENTRY
FASTCALL
InterlockedPushEntrySList (
    IN PSLIST_HEADER ListHead,
    IN PSINGLE_LIST_ENTRY ListEntry
    );

NTKERNELAPI
PSINGLE_LIST_ENTRY
FASTCALL
InterlockedFlushSList (
    IN PSLIST_HEADER ListHead
    );

#endif

// end_ntndis
//
// Raise status from kernel mode.
//

NTKERNELAPI
VOID
NTAPI
ExRaiseStatus (
    IN NTSTATUS Status
    );


//
// UUID Generation
//

typedef GUID UUID;

//
// Priority increment definitions.  The comment for each definition gives
// the names of the system services that use the definition when satisfying
// a wait.
//

//
// Priority increment used when satisfying a wait on an executive event
// (NtPulseEvent and NtSetEvent)
//

#define EVENT_INCREMENT                 1

//
// Priority increment when no I/O has been done.  This is used by device
// and file system drivers when completing an IRP (IoCompleteRequest).
//

#define IO_NO_INCREMENT                 0

//
// Priority increment for completing CD-ROM I/O.  This is used by CD-ROM device
// and file system drivers when completing an IRP (IoCompleteRequest)
//

#define IO_CD_ROM_INCREMENT             1

//
// Priority increment for completing disk I/O.  This is used by disk device
// and file system drivers when completing an IRP (IoCompleteRequest)
//

#define IO_DISK_INCREMENT               1

// end_ntifs
//
// Priority increment for completing keyboard I/O.  This is used by keyboard
// device drivers when completing an IRP (IoCompleteRequest)
//

#define IO_KEYBOARD_INCREMENT           6

// begin_ntifs
//
// Priority increment for completing mailslot I/O.  This is used by the mail-
// slot file system driver when completing an IRP (IoCompleteRequest).
//

#define IO_MAILSLOT_INCREMENT           2

// end_ntifs
//
// Priority increment for completing mouse I/O.  This is used by mouse device
// drivers when completing an IRP (IoCompleteRequest)
//

#define IO_MOUSE_INCREMENT              6

// begin_ntifs
//
// Priority increment for completing named pipe I/O.  This is used by the
// named pipe file system driver when completing an IRP (IoCompleteRequest).
//

#define IO_NAMED_PIPE_INCREMENT         2

//
// Priority increment for completing network I/O.  This is used by network
// device and network file system drivers when completing an IRP
// (IoCompleteRequest).
//

#define IO_NETWORK_INCREMENT            2

// end_ntifs
//
// Priority increment for completing parallel I/O.  This is used by parallel
// device drivers when completing an IRP (IoCompleteRequest)
//

#define IO_PARALLEL_INCREMENT           1

//
// Priority increment for completing serial I/O.  This is used by serial device
// drivers when completing an IRP (IoCompleteRequest)
//

#define IO_SERIAL_INCREMENT             2

//
// Priority increment for completing sound I/O.  This is used by sound device
// drivers when completing an IRP (IoCompleteRequest)
//

#define IO_SOUND_INCREMENT              8

//
// Priority increment for completing video I/O.  This is used by video device
// drivers when completing an IRP (IoCompleteRequest)
//

#define IO_VIDEO_INCREMENT              1

//
// Priority increment used when satisfying a wait on an executive semaphore
// (NtReleaseSemaphore)
//

#define SEMAPHORE_INCREMENT             1


//++
//
// ULONG_PTR
// ROUND_TO_PAGES(
//     IN ULONG_PTR Size
//     )
//
// Routine Description:
//
//     The ROUND_TO_PAGES macro takes a size in bytes and rounds it up to a
//     multiple of the page size.
//
//     NOTE: This macro fails for values 0xFFFFFFFF - (PAGE_SIZE - 1).
//
// Arguments:
//
//     Size - Size in bytes to round up to a page multiple.
//
// Return Value:
//
//     Returns the size rounded up to a multiple of the page size.
//
//--

#define ROUND_TO_PAGES(Size)  (((ULONG_PTR)(Size) + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1))

//++
//
// ULONG
// BYTES_TO_PAGES(
//     IN ULONG Size
//     )
//
// Routine Description:
//
//     The BYTES_TO_PAGES macro takes the size in bytes and calculates the
//     number of pages required to contain the bytes.
//
// Arguments:
//
//     Size - Size in bytes.
//
// Return Value:
//
//     Returns the number of pages required to contain the specified size.
//
//--

#define BYTES_TO_PAGES(Size)  ((ULONG)((ULONG_PTR)(Size) >> PAGE_SHIFT) + \
                               (((ULONG)(Size) & (PAGE_SIZE - 1)) != 0))

//++
//
// ULONG
// BYTE_OFFSET(
//     IN PVOID Va
//     )
//
// Routine Description:
//
//     The BYTE_OFFSET macro takes a virtual address and returns the byte offset
//     of that address within the page.
//
// Arguments:
//
//     Va - Virtual address.
//
// Return Value:
//
//     Returns the byte offset portion of the virtual address.
//
//--

#define BYTE_OFFSET(Va) ((ULONG)((LONG_PTR)(Va) & (PAGE_SIZE - 1)))

//++
//
// ULONG
// BYTE_OFFSET_LARGE(
//     IN PVOID Va
//     )
//
// Routine Description:
//
//     The BYTE_OFFSET macro takes a virtual address and returns the byte offset
//     of that address within the large page.
//
// Arguments:
//
//     Va - Virtual address.
//
// Return Value:
//
//     Returns the byte offset portion of the virtual address.
//
//--

#define BYTE_OFFSET_LARGE(Va) ((ULONG)((LONG_PTR)(Va) & (PAGE_SIZE_LARGE - 1)))

//++
//
// PVOID
// PAGE_ALIGN(
//     IN PVOID Va
//     )
//
// Routine Description:
//
//     The PAGE_ALIGN macro takes a virtual address and returns a page-aligned
//     virtual address for that page.
//
// Arguments:
//
//     Va - Virtual address.
//
// Return Value:
//
//     Returns the page aligned virtual address.
//
//--

#define PAGE_ALIGN(Va) ((PVOID)((ULONG_PTR)(Va) & ~(PAGE_SIZE - 1)))

//++
//
// PVOID
// PAGE_ALIGN_LARGE(
//     IN PVOID Va
//     )
//
// Routine Description:
//
//     The PAGE_ALIGN macro takes a virtual address and returns a page-aligned
//     virtual address for that page.
//
// Arguments:
//
//     Va - Virtual address.
//
// Return Value:
//
//     Returns the page aligned virtual address.
//
//--

#define PAGE_ALIGN_LARGE(Va) ((PVOID)((ULONG_PTR)(Va) & ~(PAGE_SIZE_LARGE - 1)))

//++
//
// ULONG
// ADDRESS_AND_SIZE_TO_SPAN_PAGES(
//     IN PVOID Va,
//     IN ULONG Size
//     )
//
// Routine Description:
//
//     The ADDRESS_AND_SIZE_TO_SPAN_PAGES macro takes a virtual address and
//     size and returns the number of pages spanned by the size.
//
// Arguments:
//
//     Va - Virtual address.
//
//     Size - Size in bytes.
//
// Return Value:
//
//     Returns the number of pages spanned by the size.
//
//--

#define ADDRESS_AND_SIZE_TO_SPAN_PAGES(Va,Size) \
   (((((Size) - 1) >> PAGE_SHIFT) + \
   (((((ULONG)(Size-1)&(PAGE_SIZE-1)) + (PtrToUlong(Va) & (PAGE_SIZE -1)))) >> PAGE_SHIFT)) + 1L)

#define COMPUTE_PAGES_SPANNED(Va, Size) \
    ((ULONG)((((ULONG_PTR)(Va) & (PAGE_SIZE -1)) + (Size) + (PAGE_SIZE - 1)) >> PAGE_SHIFT))


NTKERNELAPI
VOID
MmLockUnlockBufferPages(
    IN PVOID BaseAddress,
    IN SIZE_T NumberOfBytes,
    IN BOOLEAN UnlockPages
    );

NTKERNELAPI
VOID
MmLockUnlockPhysicalPage(
    IN ULONG_PTR PhysicalAddress,
    IN BOOLEAN UnlockPage
    );

// begin_wdm

NTKERNELAPI
PVOID
MmMapIoSpace(
    IN ULONG_PTR PhysicalAddress,
    IN SIZE_T NumberOfBytes,
    IN ULONG Protect
    );

NTKERNELAPI
VOID
MmUnmapIoSpace(
    IN PVOID BaseAddress,
    IN SIZE_T NumberOfBytes
    );


NTKERNELAPI
ULONG_PTR
MmGetPhysicalAddress(
    IN PVOID BaseAddress
    );

NTKERNELAPI
PVOID
MmAllocateContiguousMemory(
    IN SIZE_T NumberOfBytes
    );

NTKERNELAPI
PVOID
MmAllocateContiguousMemoryEx(
    IN SIZE_T NumberOfBytes,
    IN ULONG_PTR LowestAcceptableAddress,
    IN ULONG_PTR HighestAcceptableAddress,
    IN ULONG_PTR Alignment,
    IN ULONG Protect
    );

NTKERNELAPI
VOID
MmFreeContiguousMemory(
    IN PVOID BaseAddress
    );

NTKERNELAPI
VOID
MmPersistContiguousMemory(
    IN PVOID BaseAddress,
    IN SIZE_T NumberOfBytes,
    IN BOOLEAN Persist
    );

NTKERNELAPI
PVOID
MmAllocateSystemMemory(
    IN SIZE_T NumberOfBytes,
    IN ULONG Protect
    );

NTKERNELAPI
ULONG
MmFreeSystemMemory(
    IN PVOID BaseAddress,
    IN SIZE_T NumberOfBytes
    );

NTKERNELAPI
SIZE_T
MmQueryAllocationSize(
    IN PVOID BaseAddress
    );

NTKERNELAPI
ULONG
MmQueryAddressProtect(
    IN PVOID VirtualAddress
    );

NTKERNELAPI
VOID
MmSetAddressProtect(
    IN PVOID BaseAddress,
    IN ULONG NumberOfBytes,
    IN ULONG NewProtect
    );

NTKERNELAPI
BOOLEAN
MmIsAddressValid(
    IN PVOID VirtualAddress
    );

//
// System Thread and Process Creation and Termination
//

NTKERNELAPI
NTSTATUS
PsCreateSystemThread(
    OUT PHANDLE ThreadHandle,
    OUT PHANDLE ThreadId OPTIONAL,
    IN PKSTART_ROUTINE StartRoutine,
    IN PVOID StartContext,
    IN BOOLEAN DebuggerThread
    );

NTKERNELAPI
NTSTATUS
PsCreateSystemThreadEx(
    OUT PHANDLE ThreadHandle,
    IN SIZE_T ThreadExtensionSize,
    IN SIZE_T KernelStackSize,
    IN SIZE_T TlsDataSize,
    OUT PHANDLE ThreadId OPTIONAL,
    IN PKSTART_ROUTINE StartRoutine,
    IN PVOID StartContext,
    IN BOOLEAN CreateSuspended,
    IN BOOLEAN DebuggerThread,
    IN PKSYSTEM_ROUTINE SystemRoutine OPTIONAL
    );

DECLSPEC_NORETURN
NTKERNELAPI
VOID
PsTerminateSystemThread(
    IN NTSTATUS ExitStatus
    );


typedef
VOID
(*PCREATE_THREAD_NOTIFY_ROUTINE)(
    IN PETHREAD Thread,
    IN HANDLE ThreadId,
    IN BOOLEAN Create
    );

NTSTATUS
PsSetCreateThreadNotifyRoutine(
    IN PCREATE_THREAD_NOTIFY_ROUTINE NotifyRoutine
    );

//
// Define I/O system data structure type codes.  Each major data structure in
// the I/O system has a type code  The type field in each structure is at the
// same offset.  The following values can be used to determine which type of
// data structure a pointer refers to.
//

#define IO_TYPE_DEVICE                  0x00000003
#define IO_TYPE_DRIVER                  0x00000004
#define IO_TYPE_FILE                    0x00000005
#define IO_TYPE_IRP                     0x00000006
#define IO_TYPE_OPEN_PACKET             0x00000008
#define IO_TYPE_TIMER                   0x00000009

//
// Define the major function codes for IRPs.
//

#define IRP_MJ_CREATE                   0x00
#define IRP_MJ_CLOSE                    0x01
#define IRP_MJ_READ                     0x02
#define IRP_MJ_WRITE                    0x03
#define IRP_MJ_QUERY_INFORMATION        0x04
#define IRP_MJ_SET_INFORMATION          0x05
#define IRP_MJ_FLUSH_BUFFERS            0x06
#define IRP_MJ_QUERY_VOLUME_INFORMATION 0x07
#define IRP_MJ_DIRECTORY_CONTROL        0x08
#define IRP_MJ_FILE_SYSTEM_CONTROL      0x09
#define IRP_MJ_DEVICE_CONTROL           0x0a
#define IRP_MJ_INTERNAL_DEVICE_CONTROL  0x0b
#define IRP_MJ_SHUTDOWN                 0x0c
#define IRP_MJ_CLEANUP                  0x0d
#define IRP_MJ_MAXIMUM_FUNCTION         0x0d

//
// Make the Scsi major code the same as internal device control.
//

#define IRP_MJ_SCSI                     IRP_MJ_INTERNAL_DEVICE_CONTROL

//
// Define the minor function codes for IRPs.  The lower 128 codes, from 0x00 to
// 0x7f are reserved to Microsoft.  The upper 128 codes, from 0x80 to 0xff, are
// reserved to customers of Microsoft.
//

// end_ntndis

//
// Define option flags for IoCreateFile.  Note that these values must be
// exactly the same as the SL_... flags for a create function.  Note also
// that there are flags that may be passed to IoCreateFile that are not
// placed in the stack location for the create IRP.  These flags start in
// the next byte.
//

#define IO_FORCE_ACCESS_CHECK           0x0001
#define IO_OPEN_TARGET_DIRECTORY        0x0004
#define IO_NO_PARAMETER_CHECKING        0x0100

//
// Define Information fields for whether or not a REPARSE or a REMOUNT has
// occurred in the file system.
//

#define IO_REPARSE                      0x0
#define IO_REMOUNT                      0x1

//
// Define the structures used by the I/O system
//

//
// Define empty typedefs for the _IRP, _DEVICE_OBJECT, and _DRIVER_OBJECT
// structures so they may be referenced by function types before they are
// actually defined.
//
struct _DEVICE_DESCRIPTION;
struct _DEVICE_OBJECT;
struct _DMA_ADAPTER;
struct _DRIVER_OBJECT;
struct _DRIVE_LAYOUT_INFORMATION;
struct _DISK_PARTITION;
struct _FILE_OBJECT;
struct _IRP;
struct _SCSI_REQUEST_BLOCK;

// end_wdm

// begin_wdm begin_ntndis
//
// Define driver dispatch routine type.
//

typedef
NTSTATUS
(*PDRIVER_DISPATCH) (
    IN struct _DEVICE_OBJECT *DeviceObject,
    IN struct _IRP *Irp
    );

//
// Define driver start I/O routine type.
//

typedef
VOID
(*PDRIVER_STARTIO) (
    IN struct _DEVICE_OBJECT *DeviceObject,
    IN struct _IRP *Irp
    );

//
// Define driver device object deletion routine type.
//

typedef
VOID
(*PDRIVER_DELETEDEVICE) (
    IN struct _DEVICE_OBJECT *DeviceObject
    );

//
// Define driver dismount volume routine type.
//

typedef
NTSTATUS
(*PDRIVER_DISMOUNTVOLUME) (
    IN struct _DEVICE_OBJECT *DeviceObject
    );

//
// Define Device Object (DO) flags
//
#define DO_EXCLUSIVE                    0x00000002      
#define DO_DIRECT_IO                    0x00000004      
#define DO_DEVICE_HAS_NAME              0x00000008      
#define DO_DEVICE_INITIALIZING          0x00000010      
//
// Device Object structure definition
//

typedef struct _DEVICE_OBJECT {
    CSHORT Type;
    USHORT Size;
    LONG ReferenceCount;
    struct _DRIVER_OBJECT *DriverObject;
    struct _DEVICE_OBJECT *MountedOrSelfDevice;
    struct _IRP *CurrentIrp;
    ULONG Flags;                                // See above:  DO_...
    PVOID DeviceExtension;
    UCHAR DeviceType;
    UCHAR StartIoFlags;
    CCHAR StackSize;
    BOOLEAN DeletePending;
    ULONG SectorSize;
    ULONG AlignmentRequirement;
    KDEVICE_QUEUE DeviceQueue;
    KEVENT DeviceLock;
    ULONG StartIoKey;
} DEVICE_OBJECT;
typedef struct _DEVICE_OBJECT *PDEVICE_OBJECT; // ntndis

typedef struct _DRIVER_OBJECT {

    //
    // The following section describes the entry points to this particular
    // driver.  Note that the major function dispatch table must be the last
    // field in the object so that it remains extensible.
    //

    PDRIVER_STARTIO DriverStartIo;
    PDRIVER_DELETEDEVICE DriverDeleteDevice;
    PDRIVER_DISMOUNTVOLUME DriverDismountVolume;
    PDRIVER_DISPATCH MajorFunction[IRP_MJ_MAXIMUM_FUNCTION + 1];

} DRIVER_OBJECT;
typedef struct _DRIVER_OBJECT *PDRIVER_OBJECT; // ntndis

//
// Define the format of a completion message.
//

typedef struct _IO_COMPLETION_CONTEXT {
    PVOID Port;
    PVOID Key;
} IO_COMPLETION_CONTEXT, *PIO_COMPLETION_CONTEXT;

//
// Define File Object (FO) flags
//

#define FO_SYNCHRONOUS_IO               0x00000001
#define FO_ALERTABLE_IO                 0x00000002
#define FO_NO_INTERMEDIATE_BUFFERING    0x00000004
#define FO_SEQUENTIAL_ONLY              0x00000008
#define FO_CLEANUP_COMPLETE             0x00000010
#define FO_HANDLE_CREATED               0x00000020
#define FO_RANDOM_ACCESS                0x00000040

#include "pshpack4.h"

typedef struct _FILE_OBJECT {
    CSHORT Type;
    BOOLEAN DeletePending : 1;
    BOOLEAN ReadAccess : 1;
    BOOLEAN WriteAccess : 1;
    BOOLEAN DeleteAccess : 1;
    BOOLEAN SharedRead : 1;
    BOOLEAN SharedWrite : 1;
    BOOLEAN SharedDelete : 1;
    BOOLEAN Reserved : 1;
    UCHAR Flags;
    PDEVICE_OBJECT DeviceObject;
    PVOID FsContext;
    PVOID FsContext2;
    NTSTATUS FinalStatus;
    LARGE_INTEGER CurrentByteOffset;
    struct _FILE_OBJECT *RelatedFileObject;
    PIO_COMPLETION_CONTEXT CompletionContext;
    LONG LockCount;
    KEVENT Lock;
    KEVENT Event;
} FILE_OBJECT;
typedef struct _FILE_OBJECT *PFILE_OBJECT; // ntndis

#include "poppack.h"

//
// Define I/O Request Packet (IRP) flags
//

#define IRP_NOCACHE                     0x00000001
#define IRP_MOUNT_COMPLETION            0x00000002
#define IRP_SYNCHRONOUS_API             0x00000004
#define IRP_CREATE_OPERATION            0x00000008
#define IRP_READ_OPERATION              0x00000010
#define IRP_WRITE_OPERATION             0x00000020
#define IRP_CLOSE_OPERATION             0x00000040
// end_wdm

#define IRP_DEFER_IO_COMPLETION         0x00000080
#define IRP_OB_QUERY_NAME               0x00000100
#define IRP_UNLOCK_USER_BUFFER          0x00000200
#define IRP_SCATTER_GATHER_OPERATION    0x00000400
#define IRP_UNMAP_SEGMENT_ARRAY         0x00000800
#define IRP_NO_CANCELIO                 0x00001000

// begin_wdm
//
// I/O Request Packet (IRP) definition
//

typedef struct _IRP {
    CSHORT Type;
    USHORT Size;

    //
    // Define the common fields used to control the IRP.
    //

    //
    // Flags word - used to remember various flags.
    //

    ULONG Flags;

    //
    // Thread list entry - allows queueing the IRP to the thread pending I/O
    // request packet list.
    //

    LIST_ENTRY ThreadListEntry;

    //
    // I/O status - final status of operation.
    //

    IO_STATUS_BLOCK IoStatus;

    //
    // Stack state information.
    //

    CHAR StackCount;
    CHAR CurrentLocation;

    //
    // Pending returned - TRUE if pending was initially returned as the
    // status for this packet.
    //

    BOOLEAN PendingReturned;

    //
    // Cancel - packet has been canceled.
    //

    BOOLEAN Cancel;

    //
    // User parameters.
    //

    PIO_STATUS_BLOCK UserIosb;
    PKEVENT UserEvent;
    union {
        struct {
            PIO_APC_ROUTINE UserApcRoutine;
            PVOID UserApcContext;
        } AsynchronousParameters;
        LARGE_INTEGER AllocationSize;
    } Overlay;

    //
    // Note that the UserBuffer parameter is outside of the stack so that I/O
    // completion can copy data back into the user's address space without
    // having to know exactly which service was being invoked.  The length
    // of the copy is stored in the second half of the I/O status block. If
    // the UserBuffer field is NULL, then no copy is performed.
    //

    PVOID UserBuffer;

    //
    // If this is a scatter/gather I/O request, then the individual pages for
    // the request can be obtained via this array.
    //

    PFILE_SEGMENT_ELEMENT SegmentArray;

    //
    // Stores the number of bytes that were locked down for direct I/O.
    //

    ULONG LockedBufferLength;

    //
    // Kernel structures
    //
    // The following section contains kernel structures which the IRP needs
    // in order to place various work information in kernel controller system
    // queues.  Because the size and alignment cannot be controlled, they are
    // placed here at the end so they just hang off and do not affect the
    // alignment of other fields in the IRP.
    //

    union {

        struct {

            union {

                //
                // DeviceQueueEntry - The device queue entry field is used to
                // queue the IRP to the device driver device queue.
                //

                KDEVICE_QUEUE_ENTRY DeviceQueueEntry;

                struct {

                    //
                    // The following are available to the driver to use in
                    // whatever manner is desired, while the driver owns the
                    // packet.
                    //

                    PVOID DriverContext[5];
                } ;
            } ;

            //
            // Thread - pointer to caller's Thread Control Block.
            //

            PETHREAD Thread;

            //
            // The following unnamed structure must be exactly identical
            // to the unnamed structure used in the minipacket header used
            // for completion queue entries.
            //

            struct {

                //
                // List entry - used to queue the packet to completion queue, among
                // others.
                //

                LIST_ENTRY ListEntry;

                union {

                    //
                    // Current stack location - contains a pointer to the current
                    // IO_STACK_LOCATION structure in the IRP stack.  This field
                    // should never be directly accessed by drivers.  They should
                    // use the standard functions.
                    //

                    struct _IO_STACK_LOCATION *CurrentStackLocation;

                    //
                    // Minipacket type.
                    //

                    ULONG PacketType;
                };
            };

            //
            // Original file object - pointer to the original file object
            // that was used to open the file.  This field is owned by the
            // I/O system and should not be used by any other drivers.
            //

            PFILE_OBJECT OriginalFileObject;

        } Overlay;

        //
        // APC - This APC control block is used for the special kernel APC as
        // well as for the caller's APC, if one was specified in the original
        // argument list.  If so, then the APC is reused for the normal APC for
        // whatever mode the caller was in and the "special" routine that is
        // invoked before the APC gets control simply deallocates the IRP.
        //

        KAPC Apc;

        //
        // CompletionKey - This is the key that is used to distinguish
        // individual I/O operations initiated on a single file handle.
        //

        PVOID CompletionKey;

    } Tail;

} IRP, *PIRP;

//
// Define completion routine types for use in stack locations in an IRP
//

typedef
NTSTATUS
(*PIO_COMPLETION_ROUTINE) (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

//
// Define stack location control flags
//

#define SL_PENDING_RETURNED             0x01
#define SL_MUST_COMPLETE                0x02
#define SL_INVOKE_ON_CANCEL             0x20
#define SL_INVOKE_ON_SUCCESS            0x40
#define SL_INVOKE_ON_ERROR              0x80

//
// Define flags for various functions
//

//
// Create / Create Named Pipe
//
// The following flags must exactly match those in the IoCreateFile call's
// options.  The case sensitive flag is added in later, by the parse routine,
// and is not an actual option to open.  Rather, it is part of the object
// manager's attributes structure.
//

#define SL_FORCE_ACCESS_CHECK           0x01
#define SL_OPEN_TARGET_DIRECTORY        0x04

#define SL_CASE_SENSITIVE               0x80

//
// Read / Write
//

#define SL_OVERRIDE_VERIFY_VOLUME       0x02
#define SL_FSCACHE_REQUEST              0x80

//
// Device I/O Control
//
//
// Same SL_OVERRIDE_VERIFY_VOLUME as for read/write above.
//

//
// QueryDirectory / QueryEa / QueryQuota
//

#define SL_RESTART_SCAN                 0x01
#define SL_RETURN_SINGLE_ENTRY          0x02
#define SL_INDEX_SPECIFIED              0x04

//
// FileSystemControl
//
//    minor: mount/verify volume
//

#define SL_ALLOW_RAW_MOUNT              0x01

//
// Define I/O Request Packet (IRP) stack locations
//

#include "pshpack4.h"

#if defined(_WIN64)
#define POINTER_ALIGNMENT DECLSPEC_ALIGN(8)
#else
#define POINTER_ALIGNMENT
#endif

typedef struct _IO_STACK_LOCATION {
    UCHAR MajorFunction;
    UCHAR MinorFunction;
    UCHAR Flags;
    UCHAR Control;

    //
    // The following user parameters are based on the service that is being
    // invoked.  Drivers and file systems can determine which set to use based
    // on the above major and minor function codes.
    //

    union {

        //
        // System service parameters for:  NtCreateFile
        //

        struct {
            ACCESS_MASK DesiredAccess;
            ULONG Options;
            USHORT POINTER_ALIGNMENT FileAttributes;
            USHORT ShareAccess;
            POBJECT_STRING RemainingName;
        } Create;

        //
        // System service parameters for:  NtReadFile
        //

        struct {
            ULONG Length;
            union {
                ULONG BufferOffset;
                PVOID CacheBuffer;
            };
            LARGE_INTEGER ByteOffset;
        } Read;

        //
        // System service parameters for:  NtWriteFile
        //

        struct {
            ULONG Length;
            union {
                ULONG BufferOffset;
                PVOID CacheBuffer;
            };
            LARGE_INTEGER ByteOffset;
        } Write;


        //
        // System service parameters for:  NtQueryInformationFile
        //

        struct {
            ULONG Length;
            FILE_INFORMATION_CLASS POINTER_ALIGNMENT FileInformationClass;
        } QueryFile;

        //
        // System service parameters for:  NtSetInformationFile
        //

        struct {
            ULONG Length;
            FILE_INFORMATION_CLASS POINTER_ALIGNMENT FileInformationClass;
            PFILE_OBJECT FileObject;
        } SetFile;

        //
        // System service parameters for:  NtQueryVolumeInformationFile
        //

        struct {
            ULONG Length;
            FS_INFORMATION_CLASS POINTER_ALIGNMENT FsInformationClass;
        } QueryVolume;


        //
        // System service parameters for:  NtFlushBuffersFile
        //
        // No extra user-supplied parameters.
        //


        //
        // System service parameters for:  NtDeviceIoControlFile
        //

        struct {
            ULONG OutputBufferLength;
            PVOID InputBuffer;
            ULONG POINTER_ALIGNMENT InputBufferLength;
            ULONG POINTER_ALIGNMENT IoControlCode;
        } DeviceIoControl;

        //
        // Parameters for Scsi with internal device contorl.
        //

        struct {
            struct _SCSI_REQUEST_BLOCK *Srb;
        } Scsi;

        //
        // Parameters for Cleanup
        //
        // No extra parameters supplied
        //


        //
        // Others - driver-specific
        //

        struct {
            PVOID Argument1;
            PVOID Argument2;
            PVOID Argument3;
            PVOID Argument4;
        } Others;

    } Parameters;

    //
    // Save a pointer to this device driver's device object for this request
    // so it can be passed to the completion routine if needed.
    //

    PDEVICE_OBJECT DeviceObject;

    //
    // The following location contains a pointer to the file object for this
    //

    PFILE_OBJECT FileObject;

    //
    // The following routine is invoked depending on the flags in the above
    // flags field.
    //

    PIO_COMPLETION_ROUTINE CompletionRoutine;

    //
    // The following is used to store the address of the context parameter
    // that should be passed to the CompletionRoutine.
    //

    PVOID Context;

} IO_STACK_LOCATION, *PIO_STACK_LOCATION;

#include "poppack.h"

//
// Define the share access structure used by file systems to determine
// whether or not another accessor may open the file.
//

typedef struct _SHARE_ACCESS {
    UCHAR OpenCount;
    UCHAR Readers;
    UCHAR Writers;
    UCHAR Deleters;
    UCHAR SharedRead;
    UCHAR SharedWrite;
    UCHAR SharedDelete;
} SHARE_ACCESS, *PSHARE_ACCESS;

//
// Public I/O routine definitions
//

NTKERNELAPI
PIRP
IoAllocateIrp(
    IN CCHAR StackSize
    );

NTKERNELAPI
PIRP
IoBuildAsynchronousFsdRequest(
    IN ULONG MajorFunction,
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PVOID Buffer OPTIONAL,
    IN ULONG Length OPTIONAL,
    IN PLARGE_INTEGER StartingOffset OPTIONAL,
    IN PIO_STATUS_BLOCK IoStatusBlock OPTIONAL
    );

NTKERNELAPI
PIRP
IoBuildDeviceIoControlRequest(
    IN ULONG IoControlCode,
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN BOOLEAN InternalDeviceIoControl,
    IN PKEVENT Event,
    OUT PIO_STATUS_BLOCK IoStatusBlock
    );

NTKERNELAPI
PIRP
IoBuildSynchronousFsdRequest(
    IN ULONG MajorFunction,
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PVOID Buffer OPTIONAL,
    IN ULONG Length OPTIONAL,
    IN PLARGE_INTEGER StartingOffset OPTIONAL,
    IN PKEVENT Event,
    OUT PIO_STATUS_BLOCK IoStatusBlock
    );

NTKERNELAPI
NTSTATUS
FASTCALL
IofCallDriver(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

#define IoCallDriver(a,b)   \
        IofCallDriver(a,b)


NTKERNELAPI
NTSTATUS
IoCheckShareAccess(
    IN ACCESS_MASK DesiredAccess,
    IN ULONG DesiredShareAccess,
    IN OUT PFILE_OBJECT FileObject,
    IN OUT PSHARE_ACCESS ShareAccess,
    IN BOOLEAN Update
    );

NTKERNELAPI
VOID
FASTCALL
IofCompleteRequest(
    IN PIRP Irp,
    IN CCHAR PriorityBoost
    );

#define IoCompleteRequest(a,b)  \
        IofCompleteRequest(a,b)

NTKERNELAPI
NTSTATUS
IoCreateDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN ULONG DeviceExtensionSize,
    IN POBJECT_STRING DeviceName OPTIONAL,
    IN DEVICE_TYPE DeviceType,
    IN BOOLEAN Exclusive,
    OUT PDEVICE_OBJECT *DeviceObject
    );

// end_nthal

NTKERNELAPI
NTSTATUS
IoCreateFile(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PLARGE_INTEGER AllocationSize OPTIONAL,
    IN ULONG FileAttributes,
    IN ULONG ShareAccess,
    IN ULONG Disposition,
    IN ULONG CreateOptions,
    IN ULONG Options
    );


NTKERNELAPI
NTSTATUS
IoCreateSymbolicLink(
    IN POBJECT_STRING SymbolicLinkName,
    IN POBJECT_STRING DeviceName
    );

NTKERNELAPI
VOID
IoDeleteDevice(
    IN PDEVICE_OBJECT DeviceObject
    );

NTKERNELAPI
NTSTATUS
IoDeleteSymbolicLink(
    IN POBJECT_STRING SymbolicLinkName
    );

NTKERNELAPI
NTSTATUS
IoDismountVolume(
    IN PDEVICE_OBJECT DeviceObject
    );

NTKERNELAPI
NTSTATUS
IoDismountVolumeByName(
    IN POBJECT_STRING DeviceName
    );

NTKERNELAPI
VOID
IoFreeIrp(
    IN PIRP Irp
    );

//++
//
// PIO_STACK_LOCATION
// IoGetCurrentIrpStackLocation(
//     IN PIRP Irp
//     )
//
// Routine Description:
//
//     This routine is invoked to return a pointer to the current stack location
//     in an I/O Request Packet (IRP).
//
// Arguments:
//
//     Irp - Pointer to the I/O Request Packet.
//
// Return Value:
//
//     The function value is a pointer to the current stack location in the
//     packet.
//
//--

#define IoGetCurrentIrpStackLocation( Irp ) ( (Irp)->Tail.Overlay.CurrentStackLocation )

// end_nthal

//++
//
// ULONG
// IoGetFunctionCodeFromCtlCode(
//     IN ULONG ControlCode
//     )
//
// Routine Description:
//
//     This routine extracts the function code from IOCTL and FSCTL function
//     control codes.
//     This routine should only be used by kernel mode code.
//
// Arguments:
//
//     ControlCode - A function control code (IOCTL or FSCTL) from which the
//         function code must be extracted.
//
// Return Value:
//
//     The extracted function code.
//
// Note:
//
//     The CTL_CODE macro, used to create IOCTL and FSCTL function control
//     codes, is defined in ntioapi.h
//
//--

#define IoGetFunctionCodeFromCtlCode( ControlCode ) (\
    ( ControlCode >> 2) & 0x00000FFF )

// begin_nthal

//++
//
// PIO_STACK_LOCATION
// IoGetNextIrpStackLocation(
//     IN PIRP Irp
//     )
//
// Routine Description:
//
//     This routine is invoked to return a pointer to the next stack location
//     in an I/O Request Packet (IRP).
//
// Arguments:
//
//     Irp - Pointer to the I/O Request Packet.
//
// Return Value:
//
//     The function value is a pointer to the next stack location in the packet.
//
//--

#define IoGetNextIrpStackLocation( Irp ) (\
    (Irp)->Tail.Overlay.CurrentStackLocation - 1 )


NTKERNELAPI
VOID
IoInitializeIrp(
    IN OUT PIRP Irp,
    IN USHORT PacketSize,
    IN CCHAR StackSize
    );


NTKERNELAPI
NTSTATUS
IoInvalidDeviceRequest(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

//++
//
// BOOLEAN
// IoIsErrorUserInduced(
//     IN NTSTATUS Status
//     )
//
// Routine Description:
//
//     This routine is invoked to determine if an error was as a
//     result of user actions.  Typically these error are related
//     to removable media and will result in a pop-up.
//
// Arguments:
//
//     Status - The status value to check.
//
// Return Value:
//     The function value is TRUE if the user induced the error,
//     otherwise FALSE is returned.
//
//--
#define IoIsErrorUserInduced( Status ) ((BOOLEAN)  \
    (((Status) == STATUS_DEVICE_NOT_READY) ||      \
     ((Status) == STATUS_IO_TIMEOUT) ||            \
     ((Status) == STATUS_MEDIA_WRITE_PROTECTED) || \
     ((Status) == STATUS_NO_MEDIA_IN_DEVICE) ||    \
     ((Status) == STATUS_VERIFY_REQUIRED) ||       \
     ((Status) == STATUS_UNRECOGNIZED_MEDIA) ||    \
     ((Status) == STATUS_WRONG_VOLUME)))


//  begin_wdm

NTKERNELAPI
VOID
IoMarkIrpMustComplete(
    IN OUT PIRP Irp
    );

//++
//
// VOID
// IoMarkIrpPending(
//     IN OUT PIRP Irp
//     )
//
// Routine Description:
//
//     This routine marks the specified I/O Request Packet (IRP) to indicate
//     that an initial status of STATUS_PENDING was returned to the caller.
//     This is used so that I/O completion can determine whether or not to
//     fully complete the I/O operation requested by the packet.
//
// Arguments:
//
//     Irp - Pointer to the I/O Request Packet to be marked pending.
//
// Return Value:
//
//     None.
//
//--

#define IoMarkIrpPending( Irp ) ( \
    IoGetCurrentIrpStackLocation( (Irp) )->Control |= SL_PENDING_RETURNED )


NTKERNELAPI
VOID
IoRemoveShareAccess(
    IN PFILE_OBJECT FileObject,
    IN OUT PSHARE_ACCESS ShareAccess
    );

//  begin_wdm

//++
//
// VOID
// IoSetCompletionRoutine(
//     IN PIRP Irp,
//     IN PIO_COMPLETION_ROUTINE CompletionRoutine,
//     IN PVOID Context,
//     IN BOOLEAN InvokeOnSuccess,
//     IN BOOLEAN InvokeOnError,
//     IN BOOLEAN InvokeOnCancel
//     )
//
// Routine Description:
//
//     This routine is invoked to set the address of a completion routine which
//     is to be invoked when an I/O packet has been completed by a lower-level
//     driver.
//
// Arguments:
//
//     Irp - Pointer to the I/O Request Packet itself.
//
//     CompletionRoutine - Address of the completion routine that is to be
//         invoked once the next level driver completes the packet.
//
//     Context - Specifies a context parameter to be passed to the completion
//         routine.
//
//     InvokeOnSuccess - Specifies that the completion routine is invoked when the
//         operation is successfully completed.
//
//     InvokeOnError - Specifies that the completion routine is invoked when the
//         operation completes with an error status.
//
//     InvokeOnCancel - Specifies that the completion routine is invoked when the
//         operation is being canceled.
//
// Return Value:
//
//     None.
//
//--

#define IoSetCompletionRoutine( Irp, Routine, CompletionContext, Success, Error, Cancel ) { \
    PIO_STACK_LOCATION irpSp;                                               \
    ASSERT( (Success) | (Error) | (Cancel) ? (Routine) != NULL : TRUE );    \
    irpSp = IoGetNextIrpStackLocation( (Irp) );                             \
    irpSp->CompletionRoutine = (Routine);                                   \
    irpSp->Context = (CompletionContext);                                   \
    irpSp->Control = 0;                                                     \
    if ((Success)) { irpSp->Control = SL_INVOKE_ON_SUCCESS; }               \
    if ((Error)) { irpSp->Control |= SL_INVOKE_ON_ERROR; }                  \
    if ((Cancel)) { irpSp->Control |= SL_INVOKE_ON_CANCEL; } }

//++
//
// VOID
// IoSetNextIrpStackLocation (
//     IN OUT PIRP Irp
//     )
//
// Routine Description:
//
//     This routine is invoked to set the current IRP stack location to
//     the next stack location, i.e. it "pushes" the stack.
//
// Arguments:
//
//     Irp - Pointer to the I/O Request Packet (IRP).
//
// Return Value:
//
//     None.
//
//--

#define IoSetNextIrpStackLocation( Irp ) {      \
    (Irp)->CurrentLocation--;                   \
    (Irp)->Tail.Overlay.CurrentStackLocation--; }

//++
//
// VOID
// IoCopyCurrentIrpStackLocationToNext(
//     IN PIRP Irp
//     )
//
// Routine Description:
//
//     This routine is invoked to copy the IRP stack arguments and file
//     pointer from the current IrpStackLocation to the next
//     in an I/O Request Packet (IRP).
//
//     If the caller wants to call IoCallDriver with a completion routine
//     but does not wish to change the arguments otherwise,
//     the caller first calls IoCopyCurrentIrpStackLocationToNext,
//     then IoSetCompletionRoutine, then IoCallDriver.
//
// Arguments:
//
//     Irp - Pointer to the I/O Request Packet.
//
// Return Value:
//
//     None.
//
//--

#define IoCopyCurrentIrpStackLocationToNext( Irp ) { \
    PIO_STACK_LOCATION irpSp; \
    PIO_STACK_LOCATION nextIrpSp; \
    irpSp = IoGetCurrentIrpStackLocation( (Irp) ); \
    nextIrpSp = IoGetNextIrpStackLocation( (Irp) ); \
    RtlCopyMemory( nextIrpSp, irpSp, FIELD_OFFSET(IO_STACK_LOCATION, CompletionRoutine)); \
    nextIrpSp->Control = 0; }

//++
//
// VOID
// IoSkipCurrentIrpStackLocation (
//     IN PIRP Irp
//     )
//
// Routine Description:
//
//     This routine is invoked to increment the current stack location of
//     a given IRP.
//
//     If the caller wishes to call the next driver in a stack, and does not
//     wish to change the arguments, nor does he wish to set a completion
//     routine, then the caller first calls IoSkipCurrentIrpStackLocation
//     and the calls IoCallDriver.
//
// Arguments:
//
//     Irp - Pointer to the I/O Request Packet.
//
// Return Value:
//
//     None
//
//--

#define IoSkipCurrentIrpStackLocation( Irp ) \
    (Irp)->CurrentLocation++; \
    (Irp)->Tail.Overlay.CurrentStackLocation++;

NTKERNELAPI
VOID
IoSetShareAccess(
    IN ACCESS_MASK DesiredAccess,
    IN ULONG DesiredShareAccess,
    IN OUT PFILE_OBJECT FileObject,
    OUT PSHARE_ACCESS ShareAccess
    );


//++
//
// USHORT
// IoSizeOfIrp(
//     IN CCHAR StackSize
//     )
//
// Routine Description:
//
//     Determines the size of an IRP given the number of stack locations
//     the IRP will have.
//
// Arguments:
//
//     StackSize - Number of stack locations for the IRP.
//
// Return Value:
//
//     Size in bytes of the IRP.
//
//--

#define IoSizeOfIrp( StackSize ) \
    ((USHORT) (sizeof( IRP ) + ((StackSize) * (sizeof( IO_STACK_LOCATION )))))

// end_ntifs


NTKERNELAPI
VOID
IoStartNextPacket(
    IN PDEVICE_OBJECT DeviceObject
    );

NTKERNELAPI
VOID
IoStartNextPacketByKey(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG Key
    );

NTKERNELAPI
VOID
IoStartPacket(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PULONG Key OPTIONAL
    );

// begin_ntifs

//
// I/O driver configuration functions.
//

NTHALAPI
VOID
HalReadWritePCISpace(
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN ULONG RegisterNumber,
    IN PVOID Buffer,
    IN ULONG Length,
    IN BOOLEAN WritePCISpace
    );

#define HalReadPCISpace(BusNumber, SlotNumber, RegisterNumber, Buffer, Length) \
    HalReadWritePCISpace(BusNumber, SlotNumber, RegisterNumber, Buffer, Length, FALSE)

#define HalWritePCISpace(BusNumber, SlotNumber, RegisterNumber, Buffer, Length) \
    HalReadWritePCISpace(BusNumber, SlotNumber, RegisterNumber, Buffer, Length, TRUE)

NTHALAPI
ULONG
HalGetInterruptVector(
    IN ULONG BusInterruptLevel,
    OUT PKIRQL Irql
    );

#include <pshpack1.h>

typedef struct _PCI_DEVICE_ADDRESS {
    UCHAR     Type;  //CmResourceType
    UCHAR     Valid;
    UCHAR     Reserved[2];

    union {

        struct {
            PVOID TranslatedAddress;
            ULONG Length;
        } Port;

        struct {
            PVOID TranslatedAddress;
            ULONG Length;
        } Memory;

    } u;

} PCI_DEVICE_ADDRESS, *PPCI_DEVICE_ADDRESS;

typedef struct _PCI_DEVICE_DESCRIPTOR {
    ULONG     Bus;
    ULONG     Slot;
    USHORT    VendorID;
    USHORT    DeviceID;

    UCHAR     BaseClass;
    UCHAR     SubClass;
    UCHAR     ProgIf;
    UCHAR     Reserved[1];

    struct {

        PCI_DEVICE_ADDRESS Address[1];

        struct {
            ULONG Vector;
            ULONG Affinity;
            KIRQL Irql;         // KIRQL is uchar!

        } Interrupt;

    } ResourceData;

} PCI_DEVICE_DESCRIPTOR, *PPCI_DEVICE_DESCRIPTOR;

#include <poppack.h>

//
// Performance counter function.
//

NTHALAPI
LARGE_INTEGER
KeQueryPerformanceCounter(
    VOID
    );

NTHALAPI
LARGE_INTEGER
KeQueryPerformanceFrequency(
    VOID
    );

//
// Stall processor execution function.
//

NTHALAPI
VOID
KeStallExecutionProcessor(
    IN ULONG MicroSeconds
    );

// end_wdm

DECLSPEC_NORETURN
NTHALAPI
VOID
HalHaltSystem(
    VOID
    );


NTKERNELAPI
NTSTATUS
ObCreateObject(
    IN POBJECT_TYPE ObjectType,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN ULONG ObjectBodySize,
    OUT PVOID *Object
    );

NTKERNELAPI
NTSTATUS
ObInsertObject(
    IN PVOID Object,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN ULONG ObjectPointerBias,
    OUT PHANDLE Handle
    );

NTKERNELAPI
NTSTATUS
ObReferenceObjectByHandle(
    IN HANDLE Handle,
    IN POBJECT_TYPE ObjectType OPTIONAL,
    OUT PVOID *Object
    );

NTKERNELAPI
NTSTATUS
ObOpenObjectByName(
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN POBJECT_TYPE ObjectType,
    IN OUT PVOID ParseContext OPTIONAL,
    OUT PHANDLE Handle
    );

NTKERNELAPI
NTSTATUS
ObOpenObjectByPointer(
    IN PVOID Object,
    IN POBJECT_TYPE ObjectType,
    OUT PHANDLE Handle
    );

NTKERNELAPI
NTSTATUS
ObReferenceObjectByName(
    IN POBJECT_STRING ObjectName,
    IN ULONG Attributes,
    IN POBJECT_TYPE ObjectType,
    IN OUT PVOID ParseContext OPTIONAL,
    OUT PVOID *Object
    );

NTKERNELAPI
VOID
ObMakeTemporaryObject(
    IN PVOID Object
    );

NTKERNELAPI
VOID
FASTCALL
ObfReferenceObject(
    IN PVOID Object
    );

#define ObReferenceObject(Object) ObfReferenceObject(Object)

NTKERNELAPI
NTSTATUS
ObReferenceObjectByPointer(
    IN PVOID Object,
    IN POBJECT_TYPE ObjectType
    );

NTKERNELAPI
VOID
FASTCALL
ObfDereferenceObject(
    IN PVOID Object
    );

#define ObDereferenceObject(Object) ObfDereferenceObject(Object)


//
// A PCI driver can read the complete 256 bytes of configuration
// information for any PCI device by calling:
//
//      ULONG
//      HalGetBusData (
//          IN BUS_DATA_TYPE        PCIConfiguration,
//          IN ULONG                PciBusNumber,
//          IN PCI_SLOT_NUMBER      VirtualSlotNumber,
//          IN PPCI_COMMON_CONFIG   &PCIDeviceConfig,
//          IN ULONG                sizeof (PCIDeviceConfig)
//      );
//
//      A return value of 0 means that the specified PCI bus does not exist.
//
//      A return value of 2, with a VendorID of PCI_INVALID_VENDORID means
//      that the PCI bus does exist, but there is no device at the specified
//      VirtualSlotNumber (PCI Device/Function number).
//
//

// begin_wdm begin_ntminiport begin_ntndis

typedef struct _PCI_SLOT_NUMBER {
    union {
        struct {
            ULONG   DeviceNumber:5;
            ULONG   FunctionNumber:3;
            ULONG   Reserved:24;
        } bits;
        ULONG   AsULONG;
    } u;
} PCI_SLOT_NUMBER, *PPCI_SLOT_NUMBER;


#define PCI_TYPE0_ADDRESSES             6
#define PCI_TYPE1_ADDRESSES             2
#define PCI_TYPE2_ADDRESSES             5

typedef struct _PCI_COMMON_CONFIG {
    USHORT  VendorID;                   // (ro)
    USHORT  DeviceID;                   // (ro)
    USHORT  Command;                    // Device control
    USHORT  Status;
    UCHAR   RevisionID;                 // (ro)
    UCHAR   ProgIf;                     // (ro)
    UCHAR   SubClass;                   // (ro)
    UCHAR   BaseClass;                  // (ro)
    UCHAR   CacheLineSize;              // (ro+)
    UCHAR   LatencyTimer;               // (ro+)
    UCHAR   HeaderType;                 // (ro)
    UCHAR   BIST;                       // Built in self test

    union {
        struct _PCI_HEADER_TYPE_0 {
            ULONG   BaseAddresses[PCI_TYPE0_ADDRESSES];
            ULONG   CIS;
            USHORT  SubVendorID;
            USHORT  SubSystemID;
            ULONG   ROMBaseAddress;
            UCHAR   CapabilitiesPtr;
            UCHAR   Reserved1[3];
            ULONG   Reserved2;
            UCHAR   InterruptLine;      //
            UCHAR   InterruptPin;       // (ro)
            UCHAR   MinimumGrant;       // (ro)
            UCHAR   MaximumLatency;     // (ro)
        } type0;

// end_wdm end_ntminiport end_ntndis

        //
        // PCI to PCI Bridge
        //

        struct _PCI_HEADER_TYPE_1 {
            ULONG   BaseAddresses[PCI_TYPE1_ADDRESSES];
            UCHAR   PrimaryBus;
            UCHAR   SecondaryBus;
            UCHAR   SubordinateBus;
            UCHAR   SecondaryLatency;
            UCHAR   IOBase;
            UCHAR   IOLimit;
            USHORT  SecondaryStatus;
            USHORT  MemoryBase;
            USHORT  MemoryLimit;
            USHORT  PrefetchBase;
            USHORT  PrefetchLimit;
            ULONG   PrefetchBaseUpper32;
            ULONG   PrefetchLimitUpper32;
            USHORT  IOBaseUpper16;
            USHORT  IOLimitUpper16;
            UCHAR   CapabilitiesPtr;
            UCHAR   Reserved1[3];
            ULONG   ROMBaseAddress;
            UCHAR   InterruptLine;
            UCHAR   InterruptPin;
            USHORT  BridgeControl;
        } type1;

        //
        // PCI to CARDBUS Bridge
        //

        struct _PCI_HEADER_TYPE_2 {
            ULONG   SocketRegistersBaseAddress;
            UCHAR   CapabilitiesPtr;
            UCHAR   Reserved;
            USHORT  SecondaryStatus;
            UCHAR   PrimaryBus;
            UCHAR   SecondaryBus;
            UCHAR   SubordinateBus;
            UCHAR   SecondaryLatency;
            struct  {
                ULONG   Base;
                ULONG   Limit;
            }       Range[PCI_TYPE2_ADDRESSES-1];
            UCHAR   InterruptLine;
            UCHAR   InterruptPin;
            USHORT  BridgeControl;
        } type2;

// begin_wdm begin_ntminiport begin_ntndis

    } u;

    UCHAR   DeviceSpecific[192];

} PCI_COMMON_CONFIG, *PPCI_COMMON_CONFIG;


#define PCI_COMMON_HDR_LENGTH (FIELD_OFFSET (PCI_COMMON_CONFIG, DeviceSpecific))

#define PCI_MAX_DEVICES                     32
#define PCI_MAX_FUNCTION                    8
#define PCI_MAX_BRIDGE_NUMBER               0xFF

#define PCI_INVALID_VENDORID                0xFFFF

//
// Bit encodings for  PCI_COMMON_CONFIG.HeaderType
//

#define PCI_MULTIFUNCTION                   0x80
#define PCI_DEVICE_TYPE                     0x00
#define PCI_BRIDGE_TYPE                     0x01
#define PCI_CARDBUS_BRIDGE_TYPE             0x02

#define PCI_CONFIGURATION_TYPE(PciData) \
    (((PPCI_COMMON_CONFIG)(PciData))->HeaderType & ~PCI_MULTIFUNCTION)

#define PCI_MULTIFUNCTION_DEVICE(PciData) \
    ((((PPCI_COMMON_CONFIG)(PciData))->HeaderType & PCI_MULTIFUNCTION) != 0)

//
// Bit encodings for PCI_COMMON_CONFIG.Command
//

#define PCI_ENABLE_IO_SPACE                 0x0001
#define PCI_ENABLE_MEMORY_SPACE             0x0002
#define PCI_ENABLE_BUS_MASTER               0x0004
#define PCI_ENABLE_SPECIAL_CYCLES           0x0008
#define PCI_ENABLE_WRITE_AND_INVALIDATE     0x0010
#define PCI_ENABLE_VGA_COMPATIBLE_PALETTE   0x0020
#define PCI_ENABLE_PARITY                   0x0040  // (ro+)
#define PCI_ENABLE_WAIT_CYCLE               0x0080  // (ro+)
#define PCI_ENABLE_SERR                     0x0100  // (ro+)
#define PCI_ENABLE_FAST_BACK_TO_BACK        0x0200  // (ro)

//
// Bit encodings for PCI_COMMON_CONFIG.Status
//

#define PCI_STATUS_CAPABILITIES_LIST        0x0010  // (ro)
#define PCI_STATUS_66MHZ_CAPABLE            0x0020  // (ro)
#define PCI_STATUS_UDF_SUPPORTED            0x0040  // (ro)
#define PCI_STATUS_FAST_BACK_TO_BACK        0x0080  // (ro)
#define PCI_STATUS_DATA_PARITY_DETECTED     0x0100
#define PCI_STATUS_DEVSEL                   0x0600  // 2 bits wide
#define PCI_STATUS_SIGNALED_TARGET_ABORT    0x0800
#define PCI_STATUS_RECEIVED_TARGET_ABORT    0x1000
#define PCI_STATUS_RECEIVED_MASTER_ABORT    0x2000
#define PCI_STATUS_SIGNALED_SYSTEM_ERROR    0x4000
#define PCI_STATUS_DETECTED_PARITY_ERROR    0x8000

//
// The NT PCI Driver uses a WhichSpace parameter on its CONFIG_READ/WRITE
// routines.   The following values are defined-
//

#define PCI_WHICHSPACE_CONFIG               0x0
#define PCI_WHICHSPACE_ROM                  0x52696350

// end_wdm
//
// PCI Capability IDs
//

#define PCI_CAPABILITY_ID_POWER_MANAGEMENT  0x01
#define PCI_CAPABILITY_ID_AGP               0x02
#define PCI_CAPABILITY_ID_MSI               0x05

//
// All PCI Capability structures have the following header.
//
// CapabilityID is used to identify the type of the structure (is
// one of the PCI_CAPABILITY_ID values above.
//
// Next is the offset in PCI Configuration space (0x40 - 0xfc) of the
// next capability structure in the list, or 0x00 if there are no more
// entries.
//
typedef struct _PCI_CAPABILITIES_HEADER {
    UCHAR   CapabilityID;
    UCHAR   Next;
} PCI_CAPABILITIES_HEADER, *PPCI_CAPABILITIES_HEADER;

//
// Power Management Capability
//

typedef struct _PCI_PMC {
    UCHAR       Version:3;
    UCHAR       PMEClock:1;
    UCHAR       Rsvd1:1;
    UCHAR       DeviceSpecificInitialization:1;
    UCHAR       Rsvd2:2;
    struct _PM_SUPPORT {
        UCHAR   Rsvd2:1;
        UCHAR   D1:1;
        UCHAR   D2:1;
        UCHAR   PMED0:1;
        UCHAR   PMED1:1;
        UCHAR   PMED2:1;
        UCHAR   PMED3Hot:1;
        UCHAR   PMED3Cold:1;
    } Support;
} PCI_PMC, *PPCI_PMC;

typedef struct _PCI_PMCSR {
    USHORT      PowerState:2;
    USHORT      Rsvd1:6;
    USHORT      PMEEnable:1;
    USHORT      DataSelect:4;
    USHORT      DataScale:2;
    USHORT      PMEStatus:1;
} PCI_PMCSR, *PPCI_PMCSR;


typedef struct _PCI_PMCSR_BSE {
    UCHAR       Rsvd1:6;
    UCHAR       D3HotSupportsStopClock:1;       // B2_B3#
    UCHAR       BusPowerClockControlEnabled:1;  // BPCC_EN
} PCI_PMCSR_BSE, *PPCI_PMCSR_BSE;


typedef struct _PCI_PM_CAPABILITY {

    PCI_CAPABILITIES_HEADER Header;

    //
    // Power Management Capabilities (Offset = 2)
    //

    union {
        PCI_PMC         Capabilities;
        USHORT          AsUSHORT;
    } PMC;

    //
    // Power Management Control/Status (Offset = 4)
    //

    union {
        PCI_PMCSR       ControlStatus;
        USHORT          AsUSHORT;
    } PMCSR;

    //
    // PMCSR PCI-PCI Bridge Support Extensions
    //

    union {
        PCI_PMCSR_BSE   BridgeSupport;
        UCHAR           AsUCHAR;
    } PMCSR_BSE;

    //
    // Optional read only 8 bit Data register.  Contents controlled by
    // DataSelect and DataScale in ControlStatus.
    //

    UCHAR   Data;

} PCI_PM_CAPABILITY, *PPCI_PM_CAPABILITY;

//
// AGP Capability
//

typedef struct _PCI_AGP_CAPABILITY {

    PCI_CAPABILITIES_HEADER Header;

    USHORT  Minor:4;
    USHORT  Major:4;
    USHORT  Rsvd1:8;

    struct  _PCI_AGP_STATUS {
        ULONG   Rate:3;
        ULONG   Rsvd1:1;
        ULONG   FastWrite:1;
        ULONG   FourGB:1;
        ULONG   Rsvd2:3;
        ULONG   SideBandAddressing:1;                   // SBA
        ULONG   Rsvd3:14;
        ULONG   RequestQueueDepthMaximum:8;             // RQ
    } AGPStatus;

    struct  _PCI_AGP_COMMAND {
        ULONG   Rate:3;
        ULONG   Rsvd1:1;
        ULONG   FastWriteEnable:1;
        ULONG   FourGBEnable:1;
        ULONG   Rsvd2:2;
        ULONG   AGPEnable:1;
        ULONG   SBAEnable:1;
        ULONG   Rsvd3:14;
        ULONG   RequestQueueDepth:8;
    } AGPCommand;

} PCI_AGP_CAPABILITY, *PPCI_AGP_CAPABILITY;

#define PCI_AGP_RATE_1X     0x1
#define PCI_AGP_RATE_2X     0x2
#define PCI_AGP_RATE_4X     0x4

//
// MSI (Message Signalled Interrupts) Capability
//

typedef struct _PCI_MSI_CAPABILITY {

      PCI_CAPABILITIES_HEADER Header;

      struct _PCI_MSI_MESSAGE_CONTROL {
         USHORT  MSIEnable:1;
         USHORT  MultipleMessageCapable:3;
         USHORT  MultipleMessageEnable:3;
         USHORT  CapableOf64Bits:1;
         USHORT  Reserved:8;
      } MessageControl;

      union {
            struct _PCI_MSI_MESSAGE_ADDRESS {
               ULONG_PTR Reserved:2;              // always zero, DWORD aligned address
               ULONG_PTR Address:30;
            } Register;
            ULONG_PTR Raw;
      } MessageAddress;

      //
      // The rest of the Capability structure differs depending on whether
      // 32bit or 64bit addressing is being used.
      //
      // (The CapableOf64Bits bit above determines this)
      //

      union {

         // For 64 bit devices

         struct _PCI_MSI_64BIT_DATA {
            ULONG MessageUpperAddress;
            USHORT MessageData;
         } Bit64;

         // For 32 bit devices

         struct _PCI_MSI_32BIT_DATA {
            USHORT MessageData;
            ULONG Unused;
         } Bit32;
      } Data;

} PCI_MSI_CAPABILITY, *PPCI_PCI_CAPABILITY;

// begin_wdm
//
// Base Class Code encodings for Base Class (from PCI spec rev 2.1).
//

#define PCI_CLASS_PRE_20                    0x00
#define PCI_CLASS_MASS_STORAGE_CTLR         0x01
#define PCI_CLASS_NETWORK_CTLR              0x02
#define PCI_CLASS_DISPLAY_CTLR              0x03
#define PCI_CLASS_MULTIMEDIA_DEV            0x04
#define PCI_CLASS_MEMORY_CTLR               0x05
#define PCI_CLASS_BRIDGE_DEV                0x06
#define PCI_CLASS_SIMPLE_COMMS_CTLR         0x07
#define PCI_CLASS_BASE_SYSTEM_DEV           0x08
#define PCI_CLASS_INPUT_DEV                 0x09
#define PCI_CLASS_DOCKING_STATION           0x0a
#define PCI_CLASS_PROCESSOR                 0x0b
#define PCI_CLASS_SERIAL_BUS_CTLR           0x0c

// 0d thru fe reserved

#define PCI_CLASS_NOT_DEFINED               0xff

//
// Sub Class Code encodings (PCI rev 2.1).
//

// Class 00 - PCI_CLASS_PRE_20

#define PCI_SUBCLASS_PRE_20_NON_VGA         0x00
#define PCI_SUBCLASS_PRE_20_VGA             0x01

// Class 01 - PCI_CLASS_MASS_STORAGE_CTLR

#define PCI_SUBCLASS_MSC_SCSI_BUS_CTLR      0x00
#define PCI_SUBCLASS_MSC_IDE_CTLR           0x01
#define PCI_SUBCLASS_MSC_FLOPPY_CTLR        0x02
#define PCI_SUBCLASS_MSC_IPI_CTLR           0x03
#define PCI_SUBCLASS_MSC_RAID_CTLR          0x04
#define PCI_SUBCLASS_MSC_OTHER              0x80

// Class 02 - PCI_CLASS_NETWORK_CTLR

#define PCI_SUBCLASS_NET_ETHERNET_CTLR      0x00
#define PCI_SUBCLASS_NET_TOKEN_RING_CTLR    0x01
#define PCI_SUBCLASS_NET_FDDI_CTLR          0x02
#define PCI_SUBCLASS_NET_ATM_CTLR           0x03
#define PCI_SUBCLASS_NET_OTHER              0x80

// Class 03 - PCI_CLASS_DISPLAY_CTLR

// N.B. Sub Class 00 could be VGA or 8514 depending on Interface byte

#define PCI_SUBCLASS_VID_VGA_CTLR           0x00
#define PCI_SUBCLASS_VID_XGA_CTLR           0x01
#define PCI_SUBCLASS_VID_OTHER              0x80

// Class 04 - PCI_CLASS_MULTIMEDIA_DEV

#define PCI_SUBCLASS_MM_VIDEO_DEV           0x00
#define PCI_SUBCLASS_MM_AUDIO_DEV           0x01
#define PCI_SUBCLASS_MM_OTHER               0x80

// Class 05 - PCI_CLASS_MEMORY_CTLR

#define PCI_SUBCLASS_MEM_RAM                0x00
#define PCI_SUBCLASS_MEM_FLASH              0x01
#define PCI_SUBCLASS_MEM_OTHER              0x80

// Class 06 - PCI_CLASS_BRIDGE_DEV

#define PCI_SUBCLASS_BR_HOST                0x00
#define PCI_SUBCLASS_BR_ISA                 0x01
#define PCI_SUBCLASS_BR_EISA                0x02
#define PCI_SUBCLASS_BR_MCA                 0x03
#define PCI_SUBCLASS_BR_PCI_TO_PCI          0x04
#define PCI_SUBCLASS_BR_PCMCIA              0x05
#define PCI_SUBCLASS_BR_NUBUS               0x06
#define PCI_SUBCLASS_BR_CARDBUS             0x07
#define PCI_SUBCLASS_BR_OTHER               0x80

// Class 07 - PCI_CLASS_SIMPLE_COMMS_CTLR

// N.B. Sub Class 00 and 01 additional info in Interface byte

#define PCI_SUBCLASS_COM_SERIAL             0x00
#define PCI_SUBCLASS_COM_PARALLEL           0x01
#define PCI_SUBCLASS_COM_OTHER              0x80

// Class 08 - PCI_CLASS_BASE_SYSTEM_DEV

// N.B. See Interface byte for additional info.

#define PCI_SUBCLASS_SYS_INTERRUPT_CTLR     0x00
#define PCI_SUBCLASS_SYS_DMA_CTLR           0x01
#define PCI_SUBCLASS_SYS_SYSTEM_TIMER       0x02
#define PCI_SUBCLASS_SYS_REAL_TIME_CLOCK    0x03
#define PCI_SUBCLASS_SYS_OTHER              0x80

// Class 09 - PCI_CLASS_INPUT_DEV

#define PCI_SUBCLASS_INP_KEYBOARD           0x00
#define PCI_SUBCLASS_INP_DIGITIZER          0x01
#define PCI_SUBCLASS_INP_MOUSE              0x02
#define PCI_SUBCLASS_INP_OTHER              0x80

// Class 0a - PCI_CLASS_DOCKING_STATION

#define PCI_SUBCLASS_DOC_GENERIC            0x00
#define PCI_SUBCLASS_DOC_OTHER              0x80

// Class 0b - PCI_CLASS_PROCESSOR

#define PCI_SUBCLASS_PROC_386               0x00
#define PCI_SUBCLASS_PROC_486               0x01
#define PCI_SUBCLASS_PROC_PENTIUM           0x02
#define PCI_SUBCLASS_PROC_ALPHA             0x10
#define PCI_SUBCLASS_PROC_POWERPC           0x20
#define PCI_SUBCLASS_PROC_COPROCESSOR       0x40

// Class 0c - PCI_CLASS_SERIAL_BUS_CTLR

#define PCI_SUBCLASS_SB_IEEE1394            0x00
#define PCI_SUBCLASS_SB_ACCESS              0x01
#define PCI_SUBCLASS_SB_SSA                 0x02
#define PCI_SUBCLASS_SB_USB                 0x03
#define PCI_SUBCLASS_SB_FIBRE_CHANNEL       0x04


// end_ntndis

//
// Bit encodes for PCI_COMMON_CONFIG.u.type0.BaseAddresses
//

#define PCI_ADDRESS_IO_SPACE                0x00000001  // (ro)
#define PCI_ADDRESS_MEMORY_TYPE_MASK        0x00000006  // (ro)
#define PCI_ADDRESS_MEMORY_PREFETCHABLE     0x00000008  // (ro)

#define PCI_ADDRESS_IO_ADDRESS_MASK         0xfffffffc
#define PCI_ADDRESS_MEMORY_ADDRESS_MASK     0xfffffff0
#define PCI_ADDRESS_ROM_ADDRESS_MASK        0xfffff800

#define PCI_TYPE_32BIT      0
#define PCI_TYPE_20BIT      2
#define PCI_TYPE_64BIT      4

//
// Bit encodes for PCI_COMMON_CONFIG.u.type0.ROMBaseAddresses
//

#define PCI_ROMADDRESS_ENABLED              0x00000001


//
// Reference notes for PCI configuration fields:
//
// ro   these field are read only.  changes to these fields are ignored
//
// ro+  these field are intended to be read only and should be initialized
//      by the system to their proper values.  However, driver may change
//      these settings.
//
// ---
//
//      All resources comsumed by a PCI device start as unitialized
//      under NT.  An uninitialized memory or I/O base address can be
//      determined by checking it's corrisponding enabled bit in the
//      PCI_COMMON_CONFIG.Command value.  An InterruptLine is unitialized
//      if it contains the value of -1.
//

// end_ntminiport



#ifdef POOL_TAGGING
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,' kdD')
#define ExAllocatePoolWithQuota(a,b) ExAllocatePoolWithQuotaTag(a,b,' kdD')
#endif

extern POBJECT_TYPE *IoFileObjectType;
extern POBJECT_TYPE *ExEventObjectType;
extern POBJECT_TYPE *ExSemaphoreObjectType;

//
// Define exported ZwXxx routines to device drivers.
//

NTSYSAPI
NTSTATUS
NTAPI
ZwCreateFile(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PLARGE_INTEGER AllocationSize OPTIONAL,
    IN ULONG FileAttributes,
    IN ULONG ShareAccess,
    IN ULONG CreateDisposition,
    IN ULONG CreateOptions,
    IN PVOID EaBuffer OPTIONAL,
    IN ULONG EaLength
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwOpenFile(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG ShareAccess,
    IN ULONG OpenOptions
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwQueryInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID FileInformation,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwSetInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID FileInformation,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwReadFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN PLARGE_INTEGER ByteOffset OPTIONAL,
    IN PULONG Key OPTIONAL
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwWriteFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID Buffer,
    IN ULONG Length,
    IN PLARGE_INTEGER ByteOffset OPTIONAL,
    IN PULONG Key OPTIONAL
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwClose(
    IN HANDLE Handle
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwCreateDirectoryObject(
    OUT PHANDLE DirectoryHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwMakeTemporaryObject(
    IN HANDLE Handle
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwOpenSection(
    OUT PHANDLE SectionHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwMapViewOfSection(
    IN HANDLE SectionHandle,
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN ULONG ZeroBits,
    IN ULONG CommitSize,
    IN OUT PLARGE_INTEGER SectionOffset OPTIONAL,
    IN OUT PSIZE_T ViewSize,
    IN SECTION_INHERIT InheritDisposition,
    IN ULONG AllocationType,
    IN ULONG Protect
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwUnmapViewOfSection(
    IN HANDLE ProcessHandle,
    IN PVOID BaseAddress
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwSetInformationThread(
    IN HANDLE ThreadHandle,
    IN THREADINFOCLASS ThreadInformationClass,
    IN PVOID ThreadInformation,
    IN ULONG ThreadInformationLength
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwCreateKey(
    OUT PHANDLE KeyHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN ULONG TitleIndex,
    IN PUNICODE_STRING Class OPTIONAL,
    IN ULONG CreateOptions,
    OUT PULONG Disposition OPTIONAL
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwOpenKey(
    OUT PHANDLE KeyHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwDeleteKey(
    IN HANDLE KeyHandle
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwEnumerateKey(
    IN HANDLE KeyHandle,
    IN ULONG Index,
    IN KEY_INFORMATION_CLASS KeyInformationClass,
    OUT PVOID KeyInformation,
    IN ULONG Length,
    OUT PULONG ResultLength
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwEnumerateValueKey(
    IN HANDLE KeyHandle,
    IN ULONG Index,
    IN KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    OUT PVOID KeyValueInformation,
    IN ULONG Length,
    OUT PULONG ResultLength
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwFlushKey(
    IN HANDLE KeyHandle
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwQueryKey(
    IN HANDLE KeyHandle,
    IN KEY_INFORMATION_CLASS KeyInformationClass,
    OUT PVOID KeyInformation,
    IN ULONG Length,
    OUT PULONG ResultLength
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwQueryValueKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ValueName,
    IN KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    OUT PVOID KeyValueInformation,
    IN ULONG Length,
    OUT PULONG ResultLength
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwSetValueKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ValueName,
    IN ULONG TitleIndex OPTIONAL,
    IN ULONG Type,
    IN PVOID Data,
    IN ULONG DataSize
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwOpenSymbolicLinkObject(
    OUT PHANDLE LinkHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwQuerySymbolicLinkObject(
    IN HANDLE LinkHandle,
    IN OUT PUNICODE_STRING LinkTarget,
    OUT PULONG ReturnedLength OPTIONAL
    );

NTSTATUS
ZwCreateTimer (
    OUT PHANDLE TimerHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN TIMER_TYPE TimerType
    );

NTSTATUS
ZwOpenTimer (
    OUT PHANDLE TimerHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSTATUS
ZwCancelTimer (
    IN HANDLE TimerHandle,
    OUT PBOOLEAN CurrentState OPTIONAL
    );

NTSTATUS
ZwSetTimer (
    IN HANDLE TimerHandle,
    IN PLARGE_INTEGER DueTime,
    IN PTIMER_APC_ROUTINE TimerApcRoutine OPTIONAL,
    IN PVOID TimerContext OPTIONAL,
    IN BOOLEAN WakeTimer,
    IN LONG Period OPTIONAL,
    OUT PBOOLEAN PreviousState OPTIONAL
    );

#ifdef __cplusplus
}    // extern "C"
#endif

#endif // _NTDDK_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\public\ddk\inc\scsi.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    scsi.h

Abstract:

    These are the structures and defines that are used in the
    SCSI port and class drivers.

Authors:

Revision History:

--*/
#ifndef _NTSCSI_
#define _NTSCSI_

#if _MSC_VER >= 1200
#pragma warning(push)
#endif

#pragma warning(disable:4200)

// begin_ntminitape

//
// Command Descriptor Block. Passed by SCSI controller chip over the SCSI bus
//

#include <pshpack1.h>
typedef union _CDB {

    //
    // Generic 6-Byte CDB
    //

    struct _CDB6GENERIC {
       UCHAR  OperationCode;
       UCHAR  Immediate : 1;
       UCHAR  CommandUniqueBits : 4;
       UCHAR  LogicalUnitNumber : 3;
       UCHAR  CommandUniqueBytes[3];
       UCHAR  Link : 1;
       UCHAR  Flag : 1;
       UCHAR  Reserved : 4;
       UCHAR  VendorUnique : 2;
    } CDB6GENERIC, *PCDB6GENERIC;

    //
    // Standard 6-byte CDB
    //

    struct _CDB6READWRITE {
        UCHAR OperationCode;
        UCHAR LogicalBlockMsb1 : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR LogicalBlockMsb0;
        UCHAR LogicalBlockLsb;
        UCHAR TransferBlocks;
        UCHAR Control;
    } CDB6READWRITE, *PCDB6READWRITE;

    //
    // SCSI Inquiry CDB
    //

    struct _CDB6INQUIRY {
        UCHAR OperationCode;
        UCHAR Reserved1 : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR PageCode;
        UCHAR IReserved;
        UCHAR AllocationLength;
        UCHAR Control;
    } CDB6INQUIRY, *PCDB6INQUIRY;

    struct _CDB6VERIFY {
        UCHAR OperationCode;
        UCHAR Fixed : 1;
        UCHAR ByteCompare : 1;
        UCHAR Immediate : 1;
        UCHAR Reserved : 2;
        UCHAR LogicalUnitNumber : 3;
        UCHAR VerificationLength[3];
        UCHAR Control;
    } CDB6VERIFY, *PCDB6VERIFY;

    //
    // SCSI Format CDB
    //

    struct _CDB6FORMAT {
        UCHAR OperationCode;
        UCHAR FormatControl : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR FReserved1;
        UCHAR InterleaveMsb;
        UCHAR InterleaveLsb;
        UCHAR FReserved2;
    } CDB6FORMAT, *PCDB6FORMAT;

    //
    // Standard 10-byte CDB

    struct _CDB10 {
        UCHAR OperationCode;
        UCHAR RelativeAddress : 1;
        UCHAR Reserved1 : 2;
        UCHAR ForceUnitAccess : 1;
        UCHAR DisablePageOut : 1;
        UCHAR LogicalUnitNumber : 3;
        union {
            struct {
                UCHAR LogicalBlockByte0;
                UCHAR LogicalBlockByte1;
                UCHAR LogicalBlockByte2;
                UCHAR LogicalBlockByte3;
            };
            ULONG LogicalBlock;
        };
        UCHAR Reserved2;
        union {
            struct {
                UCHAR TransferBlocksMsb;
                UCHAR TransferBlocksLsb;
            };
            ULONG TransferBlocks;
        };
        UCHAR Control;
    } CDB10, *PCDB10;

    //
    // Standard 12-byte CDB
    //

    struct _CDB12 {
        UCHAR OperationCode;
        UCHAR RelativeAddress : 1;
        UCHAR Reserved1 : 2;
        UCHAR ForceUnitAccess : 1;
        UCHAR DisablePageOut : 1;
        UCHAR LogicalUnitNumber : 3;
        UCHAR LogicalBlock[4];      // [0]=MSB, [3]=LSB
        UCHAR TransferLength[4];    // [0]=MSB, [3]=LSB
        UCHAR Reserved2;
        UCHAR Control;
    } CDB12, *PCDB12;

    //
    // CD Rom Audio CDBs
    //

    struct _PAUSE_RESUME {
        UCHAR OperationCode;
        UCHAR Reserved1 : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Reserved2[6];
        UCHAR Action;
        UCHAR Control;
    } PAUSE_RESUME, *PPAUSE_RESUME;

    //
    // Read Table of Contents
    //

    struct _READ_TOC {
        UCHAR OperationCode;
        UCHAR Reserved0 : 1;
        UCHAR Msf : 1;
        UCHAR Reserved1 : 3;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Format2 : 4;
        UCHAR Reserved2 : 4;
        UCHAR Reserved3[3];
        UCHAR StartingTrack;
        UCHAR AllocationLength[2];
        UCHAR Control : 6;
        UCHAR Format : 2;
    } READ_TOC, *PREAD_TOC;

    struct _READ_DISK_INFORMATION {
        UCHAR OperationCode;    // 0x51
        UCHAR Reserved1 : 5;
        UCHAR Lun : 3;
        UCHAR Reserved2[5];
        UCHAR AllocationLength[2];
        UCHAR Control;
    } READ_DISK_INFORMATION, *PREAD_DISK_INFORMATION;

    struct _READ_TRACK_INFORMATION {
        UCHAR OperationCode;    // 0x52
        UCHAR Track : 1;
        UCHAR Reserved1 : 3;
        UCHAR Reserved2 : 1;
        UCHAR Lun : 3;
        UCHAR BlockAddress[4];  // or Track Number
        UCHAR Reserved3;
        UCHAR AllocationLength[2];
        UCHAR Control;
    } READ_TRACK_INFORMATION, *PREAD_TRACK_INFORMATION;

    struct _READ_HEADER {
        UCHAR OperationCode;    // 0x44
        UCHAR Reserved1 : 1;
        UCHAR Msf : 1;
        UCHAR Reserved2 : 3;
        UCHAR Lun : 3;
        UCHAR LogicalBlockAddress[4];
        UCHAR Reserved3;
        UCHAR AllocationLength[2];
        UCHAR Control;
    } READ_HEADER, *PREAD_HEADER;

    struct _PLAY_AUDIO {
        UCHAR OperationCode;
        UCHAR Reserved1 : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR StartingBlockAddress[4];
        UCHAR Reserved2;
        UCHAR PlayLength[2];
        UCHAR Control;
    } PLAY_AUDIO, *PPLAY_AUDIO;

    struct _PLAY_AUDIO_MSF {
        UCHAR OperationCode;
        UCHAR Reserved1 : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Reserved2;
        UCHAR StartingM;
        UCHAR StartingS;
        UCHAR StartingF;
        UCHAR EndingM;
        UCHAR EndingS;
        UCHAR EndingF;
        UCHAR Control;
    } PLAY_AUDIO_MSF, *PPLAY_AUDIO_MSF;

    struct _PLAY_CD {
        UCHAR OperationCode;    // 0xBC
        UCHAR Reserved1 : 1;
        UCHAR CMSF : 1;         // LBA = 0, MSF = 1
        UCHAR ExpectedSectorType : 3;
        UCHAR Lun : 3;

        union {
            struct _LBA {
                UCHAR StartingBlockAddress[4];
                UCHAR PlayLength[4];
            } LBA;

            struct _MSF {
                UCHAR Reserved1;
                UCHAR StartingM;
                UCHAR StartingS;
                UCHAR StartingF;
                UCHAR EndingM;
                UCHAR EndingS;
                UCHAR EndingF;
                UCHAR Reserved2;
            } MSF;
        };

        UCHAR Audio : 1;
        UCHAR Composite : 1;
        UCHAR Port1 : 1;
        UCHAR Port2 : 1;
        UCHAR Reserved2 : 3;
        UCHAR Speed : 1;
        UCHAR Control;
    } PLAY_CD, *PPLAY_CD;

    struct _SCAN_CD {
        UCHAR OperationCode;    // 0xBA
        UCHAR RelativeAddress : 1;
        UCHAR Reserved1 : 3;
        UCHAR Direct : 1;
        UCHAR Lun : 3;
        UCHAR StartingAddress[4];
        UCHAR Reserved2[3];
        UCHAR Reserved3 : 6;
        UCHAR Type : 2;
        UCHAR Reserved4;
        UCHAR Control;
    } SCAN_CD, *PSCAN_CD;

    struct _STOP_PLAY_SCAN {
        UCHAR OperationCode;    // 0x4E
        UCHAR Reserved1 : 5;
        UCHAR Lun : 3;
        UCHAR Reserved2[7];
        UCHAR Control;
    } STOP_PLAY_SCAN, *PSTOP_PLAY_SCAN;

    //
    // Read SubChannel Data
    //

    struct _SUBCHANNEL {
        UCHAR OperationCode;
        UCHAR Reserved0 : 1;
        UCHAR Msf : 1;
        UCHAR Reserved1 : 3;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Reserved2 : 6;
        UCHAR SubQ : 1;
        UCHAR Reserved3 : 1;
        UCHAR Format;
        UCHAR Reserved4[2];
        UCHAR TrackNumber;
        UCHAR AllocationLength[2];
        UCHAR Control;
    } SUBCHANNEL, *PSUBCHANNEL;

    //
    // Read CD. Used by Atapi for raw sector reads.
    //

    struct _READ_CD {
        UCHAR OperationCode;
        UCHAR RelativeAddress : 1;
        UCHAR Reserved0 : 1;
        UCHAR ExpectedSectorType : 3;
        UCHAR Lun : 3;
        UCHAR StartingLBA[4];
        UCHAR TransferBlocks[3];
        UCHAR Reserved2 : 1;
        UCHAR ErrorFlags : 2;
        UCHAR IncludeEDC : 1;
        UCHAR IncludeUserData : 1;
        UCHAR HeaderCode : 2;
        UCHAR IncludeSyncData : 1;
        UCHAR SubChannelSelection : 3;
        UCHAR Reserved3 : 5;
        UCHAR Control;
    } READ_CD, *PREAD_CD;

    struct _READ_CD_MSF {
        UCHAR OperationCode;
        UCHAR RelativeAddress : 1;
        UCHAR Reserved1 : 1;
        UCHAR ExpectedSectorType : 3;
        UCHAR Lun : 3;
        UCHAR Reserved2;
        UCHAR StartingM;
        UCHAR StartingS;
        UCHAR StartingF;
        UCHAR EndingM;
        UCHAR EndingS;
        UCHAR EndingF;
        UCHAR Reserved3;
        UCHAR Reserved4 : 1;
        UCHAR ErrorFlags : 2;
        UCHAR IncludeEDC : 1;
        UCHAR IncludeUserData : 1;
        UCHAR HeaderCode : 2;
        UCHAR IncludeSyncData : 1;
        UCHAR SubChannelSelection : 3;
        UCHAR Reserved5 : 5;
        UCHAR Control;
    } READ_CD_MSF, *PREAD_CD_MSF;

    //
    // Plextor Read CD-DA
    //

    struct _PLXTR_READ_CDDA {
        UCHAR OperationCode;
        UCHAR Reserved0 : 5;
        UCHAR LogicalUnitNumber :3;
        UCHAR LogicalBlockByte0;
        UCHAR LogicalBlockByte1;
        UCHAR LogicalBlockByte2;
        UCHAR LogicalBlockByte3;
        UCHAR TransferBlockByte0;
        UCHAR TransferBlockByte1;
        UCHAR TransferBlockByte2;
        UCHAR TransferBlockByte3;
        UCHAR SubCode;
        UCHAR Control;
    } PLXTR_READ_CDDA, *PPLXTR_READ_CDDA;

    //
    // NEC Read CD-DA
    //

    struct _NEC_READ_CDDA {
        UCHAR OperationCode;
        UCHAR Reserved0;
        UCHAR LogicalBlockByte0;
        UCHAR LogicalBlockByte1;
        UCHAR LogicalBlockByte2;
        UCHAR LogicalBlockByte3;
        UCHAR Reserved1;
        UCHAR TransferBlockByte0;
        UCHAR TransferBlockByte1;
        UCHAR Control;
    } NEC_READ_CDDA, *PNEC_READ_CDDA;

    //
    // Mode sense
    //

    struct _MODE_SENSE {
        UCHAR OperationCode;
        UCHAR Reserved1 : 3;
        UCHAR Dbd : 1;
        UCHAR Reserved2 : 1;
        UCHAR LogicalUnitNumber : 3;
        UCHAR PageCode : 6;
        UCHAR Pc : 2;
        UCHAR Reserved3;
        UCHAR AllocationLength;
        UCHAR Control;
    } MODE_SENSE, *PMODE_SENSE;

    struct _MODE_SENSE10 {
        UCHAR OperationCode;
        UCHAR Reserved1 : 3;
        UCHAR Dbd : 1;
        UCHAR Reserved2 : 1;
        UCHAR LogicalUnitNumber : 3;
        UCHAR PageCode : 6;
        UCHAR Pc : 2;
        UCHAR Reserved3[4];
        UCHAR AllocationLength[2];
        UCHAR Control;
    } MODE_SENSE10, *PMODE_SENSE10;

    //
    // Mode select
    //

    struct _MODE_SELECT {
        UCHAR OperationCode;
        UCHAR SPBit : 1;
        UCHAR Reserved1 : 3;
        UCHAR PFBit : 1;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Reserved2[2];
        UCHAR ParameterListLength;
        UCHAR Control;
    } MODE_SELECT, *PMODE_SELECT;

    struct _MODE_SELECT10 {
        UCHAR OperationCode;
        UCHAR SPBit : 1;
        UCHAR Reserved1 : 3;
        UCHAR PFBit : 1;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Reserved2[5];
        UCHAR ParameterListLength[2];
        UCHAR Control;
    } MODE_SELECT10, *PMODE_SELECT10;

    struct _LOCATE {
        UCHAR OperationCode;
        UCHAR Immediate : 1;
        UCHAR CPBit : 1;
        UCHAR BTBit : 1;
        UCHAR Reserved1 : 2;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Reserved3;
        UCHAR LogicalBlockAddress[4];
        UCHAR Reserved4;
        UCHAR Partition;
        UCHAR Control;
    } LOCATE, *PLOCATE;

    struct _LOGSENSE {
        UCHAR OperationCode;
        UCHAR SPBit : 1;
        UCHAR PPCBit : 1;
        UCHAR Reserved1 : 3;
        UCHAR LogicalUnitNumber : 3;
        UCHAR PageCode : 6;
        UCHAR PCBit : 2;
        UCHAR Reserved2;
        UCHAR Reserved3;
        UCHAR ParameterPointer[2];  // [0]=MSB, [1]=LSB
        UCHAR AllocationLength[2];  // [0]=MSB, [1]=LSB
        UCHAR Control;
    } LOGSENSE, *PLOGSENSE;

    struct _LOGSELECT {
        UCHAR OperationCode;
        UCHAR SPBit : 1;
        UCHAR PCRBit : 1;
        UCHAR Reserved1 : 3;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Reserved : 6;
        UCHAR PCBit : 2;
        UCHAR Reserved2[4];
        UCHAR ParameterListLength[2];  // [0]=MSB, [1]=LSB
        UCHAR Control;
    } LOGSELECT, *PLOGSELECT;

    struct _PRINT {
        UCHAR OperationCode;
        UCHAR Reserved : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR TransferLength[3];
        UCHAR Control;
    } PRINT, *PPRINT;

    struct _SEEK {
        UCHAR OperationCode;
        UCHAR Reserved1 : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR LogicalBlockAddress[4];
        UCHAR Reserved2[3];
        UCHAR Control;
    } SEEK, *PSEEK;

    struct _ERASE {
        UCHAR OperationCode;
        UCHAR Long : 1;
        UCHAR Immediate : 1;
        UCHAR Reserved1 : 3;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Reserved2[3];
        UCHAR Control;
    } ERASE, *PERASE;

    struct _START_STOP {
        UCHAR OperationCode;
        UCHAR Immediate: 1;
        UCHAR Reserved1 : 4;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Reserved2[2];
        UCHAR Start : 1;
        UCHAR LoadEject : 1;
        UCHAR Reserved3 : 6;
        UCHAR Control;
    } START_STOP, *PSTART_STOP;

    struct _MEDIA_REMOVAL {
        UCHAR OperationCode;
        UCHAR Reserved1 : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Reserved2[2];

        UCHAR Prevent : 1;
        UCHAR Persistant : 1;
        UCHAR Reserved3 : 6;

        UCHAR Control;
    } MEDIA_REMOVAL, *PMEDIA_REMOVAL;

    //
    // Tape CDBs
    //

    struct _SEEK_BLOCK {
        UCHAR OperationCode;
        UCHAR Immediate : 1;
        UCHAR Reserved1 : 7;
        UCHAR BlockAddress[3];
        UCHAR Link : 1;
        UCHAR Flag : 1;
        UCHAR Reserved2 : 4;
        UCHAR VendorUnique : 2;
    } SEEK_BLOCK, *PSEEK_BLOCK;

    struct _REQUEST_BLOCK_ADDRESS {
        UCHAR OperationCode;
        UCHAR Reserved1[3];
        UCHAR AllocationLength;
        UCHAR Link : 1;
        UCHAR Flag : 1;
        UCHAR Reserved2 : 4;
        UCHAR VendorUnique : 2;
    } REQUEST_BLOCK_ADDRESS, *PREQUEST_BLOCK_ADDRESS;

    struct _PARTITION {
        UCHAR OperationCode;
        UCHAR Immediate : 1;
        UCHAR Sel: 1;
        UCHAR PartitionSelect : 6;
        UCHAR Reserved1[3];
        UCHAR Control;
    } PARTITION, *PPARTITION;

    struct _WRITE_TAPE_MARKS {
        UCHAR OperationCode;
        UCHAR Immediate : 1;
        UCHAR WriteSetMarks: 1;
        UCHAR Reserved : 3;
        UCHAR LogicalUnitNumber : 3;
        UCHAR TransferLength[3];
        UCHAR Control;
    } WRITE_TAPE_MARKS, *PWRITE_TAPE_MARKS;

    struct _SPACE_TAPE_MARKS {
        UCHAR OperationCode;
        UCHAR Code : 3;
        UCHAR Reserved : 2;
        UCHAR LogicalUnitNumber : 3;
        UCHAR NumMarksMSB ;
        UCHAR NumMarks;
        UCHAR NumMarksLSB;
        union {
            UCHAR value;
            struct {
                UCHAR Link : 1;
                UCHAR Flag : 1;
                UCHAR Reserved : 4;
                UCHAR VendorUnique : 2;
            } Fields;
        } Byte6;
    } SPACE_TAPE_MARKS, *PSPACE_TAPE_MARKS;

    //
    // Read tape position
    //

    struct _READ_POSITION {
        UCHAR Operation;
        UCHAR BlockType:1;
        UCHAR Reserved1:4;
        UCHAR Lun:3;
        UCHAR Reserved2[7];
        UCHAR Control;
    } READ_POSITION, *PREAD_POSITION;

    //
    // ReadWrite for Tape
    //

    struct _CDB6READWRITETAPE {
        UCHAR OperationCode;
        UCHAR VendorSpecific : 5;
        UCHAR Reserved : 3;
        UCHAR TransferLenMSB;
        UCHAR TransferLen;
        UCHAR TransferLenLSB;
        UCHAR Link : 1;
        UCHAR Flag : 1;
        UCHAR Reserved1 : 4;
        UCHAR VendorUnique : 2;
    } CDB6READWRITETAPE, *PCDB6READWRITETAPE;

    //
    // Medium changer CDB's
    //

    struct _INIT_ELEMENT_STATUS {
        UCHAR OperationCode;
        UCHAR Reserved1 : 5;
        UCHAR LogicalUnitNubmer : 3;
        UCHAR Reserved2[3];
        UCHAR Reserved3 : 7;
        UCHAR NoBarCode : 1;
    } INIT_ELEMENT_STATUS, *PINIT_ELEMENT_STATUS;

    struct _INITIALIZE_ELEMENT_RANGE {
        UCHAR OperationCode;
        UCHAR Range : 1;
        UCHAR Reserved1 : 4;
        UCHAR LogicalUnitNubmer : 3;
        UCHAR FirstElementAddress[2];
        UCHAR Reserved2[2];
        UCHAR NumberOfElements[2];
        UCHAR Reserved3;
        UCHAR Reserved4 : 7;
        UCHAR NoBarCode : 1;
    } INITIALIZE_ELEMENT_RANGE, *PINITIALIZE_ELEMENT_RANGE;

    struct _POSITION_TO_ELEMENT {
        UCHAR OperationCode;
        UCHAR Reserved1 : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR TransportElementAddress[2];
        UCHAR DestinationElementAddress[2];
        UCHAR Reserved2[2];
        UCHAR Flip : 1;
        UCHAR Reserved3 : 7;
        UCHAR Control;
    } POSITION_TO_ELEMENT, *PPOSITION_TO_ELEMENT;

    struct _MOVE_MEDIUM {
        UCHAR OperationCode;
        UCHAR Reserved1 : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR TransportElementAddress[2];
        UCHAR SourceElementAddress[2];
        UCHAR DestinationElementAddress[2];
        UCHAR Reserved2[2];
        UCHAR Flip : 1;
        UCHAR Reserved3 : 7;
        UCHAR Control;
    } MOVE_MEDIUM, *PMOVE_MEDIUM;

    struct _EXCHANGE_MEDIUM {
        UCHAR OperationCode;
        UCHAR Reserved1 : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR TransportElementAddress[2];
        UCHAR SourceElementAddress[2];
        UCHAR Destination1ElementAddress[2];
        UCHAR Destination2ElementAddress[2];
        UCHAR Flip1 : 1;
        UCHAR Flip2 : 1;
        UCHAR Reserved3 : 6;
        UCHAR Control;
    } EXCHANGE_MEDIUM, *PEXCHANGE_MEDIUM;

    struct _READ_ELEMENT_STATUS {
        UCHAR OperationCode;
        UCHAR ElementType : 4;
        UCHAR VolTag : 1;
        UCHAR LogicalUnitNumber : 3;
        UCHAR StartingElementAddress[2];
        UCHAR NumberOfElements[2];
        UCHAR Reserved1;
        UCHAR AllocationLength[3];
        UCHAR Reserved2;
        UCHAR Control;
    } READ_ELEMENT_STATUS, *PREAD_ELEMENT_STATUS;

    struct _SEND_VOLUME_TAG {
        UCHAR OperationCode;
        UCHAR ElementType : 4;
        UCHAR Reserved1 : 1;
        UCHAR LogicalUnitNumber : 3;
        UCHAR StartingElementAddress[2];
        UCHAR Reserved2;
        UCHAR ActionCode : 5;
        UCHAR Reserved3 : 3;
        UCHAR Reserved4[2];
        UCHAR ParameterListLength[2];
        UCHAR Reserved5;
        UCHAR Control;
    } SEND_VOLUME_TAG, *PSEND_VOLUME_TAG;

    struct _REQUEST_VOLUME_ELEMENT_ADDRESS {
        UCHAR OperationCode;
        UCHAR ElementType : 4;
        UCHAR VolTag : 1;
        UCHAR LogicalUnitNumber : 3;
        UCHAR StartingElementAddress[2];
        UCHAR NumberElements[2];
        UCHAR Reserved1;
        UCHAR AllocationLength[3];
        UCHAR Reserved2;
        UCHAR Control;
    } REQUEST_VOLUME_ELEMENT_ADDRESS, *PREQUEST_VOLUME_ELEMENT_ADDRESS;

    //
    // Atapi 2.5 Changer 12-byte CDBs
    //

    struct _LOAD_UNLOAD {
        UCHAR OperationCode;
        UCHAR Immediate : 1;
        UCHAR Reserved1 : 4;
        UCHAR Lun : 3;
        UCHAR Reserved2[2];
        UCHAR Start : 1;
        UCHAR LoadEject : 1;
        UCHAR Reserved3: 6;
        UCHAR Reserved4[3];
        UCHAR Slot;
        UCHAR Reserved5[3];
    } LOAD_UNLOAD, *PLOAD_UNLOAD;

    struct _MECH_STATUS {
        UCHAR OperationCode;
        UCHAR Reserved : 5;
        UCHAR Lun : 3;
        UCHAR Reserved1[6];
        UCHAR AllocationLength[2];
        UCHAR Reserved2[1];
        UCHAR Control;
    } MECH_STATUS, *PMECH_STATUS;

    //
    // C/DVD 0.9 CDBs
    //

    struct _SYNCHRONIZE_CACHE10 {

        UCHAR OperationCode;    // 0x35

        UCHAR RelAddr : 1;
        UCHAR Immediate : 1;
        UCHAR Reserved : 3;
        UCHAR Lun : 3;

        UCHAR LogicalBlockAddress[4];   // Unused - set to zero
        UCHAR Reserved2;
        UCHAR BlockCount[2];            // Unused - set to zero
        UCHAR Control;
    } SYNCHRONIZE_CACHE10, *PSYNCHRONIZE_CACHE10;

    struct _GET_EVENT_STATUS_NOTIFICATION {
        UCHAR OperationCode;    // 0x4a

        UCHAR Immediate : 1;
        UCHAR Reserved : 4;
        UCHAR Lun : 3;

        UCHAR Reserved2[2];
        UCHAR NotificationClassRequest;
        UCHAR Reserved3[2];
        UCHAR EventListLength[2];  // [0]=MSB, [1]=LSB

        UCHAR Control;
    } GET_EVENT_STATUS_NOTIFICATION, *PGET_EVENT_STATUS_NOTIFICATION;

    struct _READ_DVD_STRUCTURE {
        UCHAR OperationCode;    // 0xAD
        UCHAR Reserved1 : 5;
        UCHAR Lun : 3;
        UCHAR RMDBlockNumber[4];
        UCHAR LayerNumber;
        UCHAR Format;
        UCHAR AllocationLength[2];  // [0]=MSB, [1]=LSB
        UCHAR Reserved3 : 6;
        UCHAR AGID : 2;
        UCHAR Control;
    } READ_DVD_STRUCTURE, *PREAD_DVD_STRUCTURE;

    struct _SEND_KEY {
        UCHAR OperationCode;    // 0xA3
        UCHAR Reserved1 : 5;
        UCHAR Lun : 3;
        UCHAR Reserved2[6];
        UCHAR ParameterListLength[2];
        UCHAR KeyFormat : 6;
        UCHAR AGID : 2;
        UCHAR Control;
    } SEND_KEY, *PSEND_KEY;

    struct _REPORT_KEY {
        UCHAR OperationCode;    // 0xA4
        UCHAR Reserved1 : 5;
        UCHAR Lun : 3;
        UCHAR LogicalBlockAddress[4];   // for title key
        UCHAR Reserved2[2];
        UCHAR AllocationLength[2];
        UCHAR KeyFormat : 6;
        UCHAR AGID : 2;
        UCHAR Control;
    } REPORT_KEY, *PREPORT_KEY;

    struct _SET_READ_AHEAD {
        UCHAR OperationCode;    // 0xA7
        UCHAR Reserved1 : 5;
        UCHAR Lun : 3;
        UCHAR TriggerLBA[4];
        UCHAR ReadAheadLBA[4];
        UCHAR Reserved2;
        UCHAR Control;
    } SET_READ_AHEAD, *PSET_READ_AHEAD;

    struct _READ_FORMATTED_CAPACITIES {
        UCHAR OperationCode;    // 0xA7
        UCHAR Reserved1 : 5;
        UCHAR Lun : 3;
        UCHAR Reserved2[5];
        UCHAR AllocationLength[2];
        UCHAR Control;
    } READ_FORMATTED_CAPACITIES, *PREAD_FORMATTED_CAPACITIES;

    //
    // SCSI-3
    //

    struct _REPORT_LUNS {
        UCHAR OperationCode;    // 0xA0
        UCHAR Reserved1[5];
        UCHAR AllocationLength[4];
        UCHAR Reserved2[1];
        UCHAR Control;
    } REPORT_LUNS, *PREPORT_LUNS;

    ULONG AsUlong[4];
    UCHAR AsByte[16];

} CDB, *PCDB;
#include <poppack.h>

//
// C/DVD CDB Constants & Structures.
//

//
// GET_EVENT_STATUS_NOTIFICATION
//

#define NOTIFICATION_NO_CLASS_EVENTS                0x0
#define NOTIFICATION_POWER_MANAGEMENT_CLASS_EVENTS  0x2
#define NOTIFICATION_MEDIA_STATUS_CLASS_EVENTS      0x4
#define NOTIFICATION_DEVICE_BUSY_CLASS_EVENTS       0x6

typedef struct _NOTIFICATION_EVENT_STATUS_HEADER {

    UCHAR EventDataLength[2];   // [0]=MSB, [1]=LSB

    UCHAR NotificationClass : 3;
    UCHAR Reserved : 4;
    UCHAR NEA : 1;

    UCHAR SupportedEventClasses;
    UCHAR ClassEventData[0];
} NOTIFICATION_EVENT_STATUS_HEADER, *PNOTIFICATION_EVENT_STATUS_HEADER;

//
// Class event data may be one or more (or none) of the following:
//

#define NOTIFICATION_POWER_EVENT_NO_CHANGE          0x0
#define NOTIFICATION_POWER_EVENT_CHANGE_SUCCEEDED   0x1
#define NOTIFICATION_POWER_EVENT_CHANGE_FAILED      0x2

#define NOTIFICATION_POWER_STATUS_ACTIVE            0x1
#define NOTIFICATION_POWER_STATUS_IDLE              0x2
#define NOTIFICATION_POWER_STATUS_STANDBY           0x3

typedef struct _NOTIFICATION_POWER_STATUS {
    UCHAR PowerEvent : 4;
    UCHAR Reserved : 4;
    UCHAR PowerStatus;
    UCHAR Reserved2[2];
} NOTIFICATION_POWER_STATUS, *PNOTIFICATION_POWER_STATUS;


#define NOTIFICATION_MEDIA_EVENT_NO_EVENT           0x0
#define NOTIFICATION_MEDIA_EVENT_EJECT_REQUEST      0x1
#define NOTIFICATION_MEDIA_EVENT_NEW_MEDIA          0x2
#define NOTIFICATION_MEDIA_EVENT_MEDIA_REMOVAL      0x3

typedef struct _NOTIFICATION_MEDIA_STATUS {
    UCHAR MediaStatus : 4;
    UCHAR Reserved : 4;

    UCHAR PowerStatus;
    UCHAR StartSlot;
    UCHAR EndSlot;
} NOTIFICATION_MEDIA_STATUS, *PNOTIFICATION_MEDIA_STATUS;


#define NOTIFICATION_BUSY_EVENT_NO_EVENT            0x0
#define NOTIFICATION_BUSY_EVENT_BUSY                0x1

#define NOTIFICATION_BUSY_STATUS_NO_EVENT           0x0
#define NOTIFICATION_BUSY_STATUS_POWER              0x1
#define NOTIFICATION_BUSY_STATUS_IMMEDIATE          0x2
#define NOTIFICATION_BUSY_STATUS_DEFERRED           0x3

typedef struct _NOTIFICATION_BUSY_STATUS {
    UCHAR DeviceBusyEvent : 4;
    UCHAR Reserved : 4;

    UCHAR DeviceBusyStatus;
    UCHAR Time[2];     // [0]=MSB, [1]=LSB
} NOTIFICATION_BUSY_STATUS, *PNOTIFICATION_BUSY_STATUS;

//
// Read DVD Structure Definitions and Constants
//

#define DVD_FORMAT_LEAD_IN          0x00
#define DVD_FORMAT_COPYRIGHT        0x01
#define DVD_FORMAT_DISK_KEY         0x02
#define DVD_FORMAT_BCA              0x03
#define DVD_FORMAT_MANUFACTURING    0x04

typedef struct _READ_DVD_STRUCTURES_HEADER {
    UCHAR Length[2];
    UCHAR Reserved[2];

    UCHAR Data[0];
} READ_DVD_STRUCTURES_HEADER, *PREAD_DVD_STRUCTURES_HEADER;

//
// DiskKey, BCA & Manufacturer information will provide byte arrays as their
// data.
//

//
// CDVD 0.9 Send & Report Key Definitions and Structures
//

#define DVD_REPORT_AGID            0x00
#define DVD_CHALLENGE_KEY          0x01
#define DVD_KEY_1                  0x02
#define DVD_KEY_2                  0x03
#define DVD_TITLE_KEY              0x04
#define DVD_REPORT_ASF             0x05
#define DVD_INVALIDATE_AGID        0x3F

typedef struct _CDVD_KEY_HEADER {
    UCHAR DataLength[2];
    UCHAR Reserved[2];
    UCHAR Data[0];
} CDVD_KEY_HEADER, *PCDVD_KEY_HEADER;

typedef struct _CDVD_REPORT_AGID_DATA {
    UCHAR Reserved1[3];
    UCHAR Reserved2 : 6;
    UCHAR AGID : 2;
} CDVD_REPORT_AGID_DATA, *PCDVD_REPORT_AGID_DATA;

typedef struct _CDVD_CHALLENGE_KEY_DATA {
    UCHAR ChallengeKeyValue[10];
    UCHAR Reserved[2];
} CDVD_CHALLENGE_KEY_DATA, *PCDVD_CHALLENGE_KEY_DATA;

typedef struct _CDVD_KEY_DATA {
    UCHAR Key[5];
    UCHAR Reserved[3];
} CDVD_KEY_DATA, *PCDVD_KEY_DATA;

typedef struct _CDVD_REPORT_ASF_DATA {
    UCHAR Reserved1[3];
    UCHAR Success : 1;
    UCHAR Reserved2 : 7;
} CDVD_REPORT_ASF_DATA, *PCDVD_REPORT_ASF_DATA;

typedef struct _CDVD_TITLE_KEY_HEADER {
    UCHAR DataLength[2];
    UCHAR Reserved1[1];
    UCHAR Reserved2 : 3;
    UCHAR CGMS : 2;
    UCHAR CP_SEC : 1;
    UCHAR CPM : 1;
    UCHAR Zero : 1;
    CDVD_KEY_DATA TitleKey;
} CDVD_TITLE_KEY_HEADER, *PCDVD_TITLE_KEY_HEADER;

//
// Read Formatted Capacity Data - returned in Big Endian Format
//

typedef struct _FORMATTED_CAPACITY_DESCRIPTOR {
    UCHAR NumberOfBlocks[4];
    UCHAR Maximum : 1;
    UCHAR Valid : 1;
    UCHAR BlockLength[3];
} FORMATTED_CAPACITY_DESCRIPTOR, *PFORMATTED_CAPACITY_DESCRIPTOR;

typedef struct _FORMATTED_CAPACITY_LIST {
    UCHAR Reserved[3];
    UCHAR CapacityListLength;
    FORMATTED_CAPACITY_DESCRIPTOR Descriptors[0];
} FORMATTED_CAPACITY_LIST, *PFORMATTED_CAPACITY_LIST;

//
// PLAY_CD definitions and constants
//

#define CD_EXPECTED_SECTOR_ANY          0x0
#define CD_EXPECTED_SECTOR_CDDA         0x1
#define CD_EXPECTED_SECTOR_MODE1        0x2
#define CD_EXPECTED_SECTOR_MODE2        0x3
#define CD_EXPECTED_SECTOR_MODE2_FORM1  0x4
#define CD_EXPECTED_SECTOR_MODE2_FORM2  0x5

//
// Read Disk Information Definitions and Capabilities
//

#define DISK_STATUS_EMPTY       0x00
#define DISK_STATUS_INCOMPLETE  0x01
#define DISK_STATUS_COMPLETE    0x02

#define LAST_SESSION_EMPTY      0x00
#define LAST_SESSION_INCOMPLETE 0x01
#define LAST_SESSION_COMPLETE   0x03

#define DISK_TYPE_CDDA          0x01
#define DISK_TYPE_CDI           0x10
#define DISK_TYPE_XA            0x20
#define DISK_TYPE_UNDEFINED     0xFF

typedef struct _OPC_TABLE_ENTRY {
    UCHAR Speed[2];
    UCHAR OPCValue[6];
} OPC_TABLE_ENTRY, *POPC_TABLE_ENTRY;

typedef struct _DISK_INFORMATION {
    UCHAR Length[2];

    UCHAR DiskStatus : 2;
    UCHAR LastSessionStatus : 2;
    UCHAR Erasable : 1;
    UCHAR Reserved1 : 3;

    UCHAR FirstTrackNumber;
    UCHAR NumberOfSessions;
    UCHAR LastSessionFirstTrack;
    UCHAR LastSessionLastTrack;

    UCHAR Reserved2 : 5;
    UCHAR GEN : 1;
    UCHAR DBC_V : 1;
    UCHAR DID_V : 1;

    UCHAR DiskType;
    UCHAR Reserved3[3];

    UCHAR DiskIdentification[4];
    UCHAR LastSessionLeadIn[4];     // MSF
    UCHAR LastPossibleStartTime[4]; // MSF
    UCHAR DiskBarCode[8];

    UCHAR Reserved4;
    UCHAR NumberOPCEntries;
    OPC_TABLE_ENTRY OPCTable[0];
} DISK_INFORMATION, *PDISK_INFORMATION;

//
// Read Header definitions and structures
//

typedef struct _DATA_BLOCK_HEADER {
    UCHAR DataMode;
    UCHAR Reserved[4];
    union {
        UCHAR LogicalBlockAddress[4];
        struct {
            UCHAR Reserved;
            UCHAR M;
            UCHAR S;
            UCHAR F;
        } MSF;
    };
} DATA_BLOCK_HEADER, *PDATA_BLOCK_HEADER;

#define DATA_BLOCK_MODE0    0x0
#define DATA_BLOCK_MODE1    0x1
#define DATA_BLOCK_MODE2    0x2

//
// Read TOC Format Codes
//

#define READ_TOC_FORMAT_TOC         0x00
#define READ_TOC_FORMAT_SESSION     0x01
#define READ_TOC_FORMAT_FULL_TOC    0x02
#define READ_TOC_FORMAT_PMA         0x03
#define READ_TOC_FORMAT_ATIP        0x04

typedef struct _TRACK_INFORMATION {
    UCHAR Length[2];
    UCHAR TrackNumber;
    UCHAR SessionNumber;
    UCHAR Reserved1;
    UCHAR TrackMode : 4;
    UCHAR Copy : 1;
    UCHAR Damage : 1;
    UCHAR Reserved2 : 2;
    UCHAR DataMode : 4;
    UCHAR FP : 1;
    UCHAR Packet : 1;
    UCHAR Blank : 1;
    UCHAR RT : 1;
    UCHAR NWA_V : 1;
    UCHAR Reserved3 : 7;
    UCHAR TrackStartAddress[4];
    UCHAR NextWritableAddress[4];
    UCHAR FreeBlocks[4];
    UCHAR FixedPacketSize[4];
} TRACK_INFORMATION, *PTRACK_INFORMATION;



//
// Command Descriptor Block constants.
//

#define CDB6GENERIC_LENGTH                   6
#define CDB10GENERIC_LENGTH                  10
#define CDB12GENERIC_LENGTH                  12

#define SETBITON                             1
#define SETBITOFF                            0

//
// Mode Sense/Select page constants.
//

#define MODE_PAGE_ERROR_RECOVERY        0x01
#define MODE_PAGE_DISCONNECT            0x02
#define MODE_PAGE_FORMAT_DEVICE         0x03
#define MODE_PAGE_RIGID_GEOMETRY        0x04
#define MODE_PAGE_FLEXIBILE             0x05
#define MODE_PAGE_VERIFY_ERROR          0x07
#define MODE_PAGE_CACHING               0x08
#define MODE_PAGE_PERIPHERAL            0x09
#define MODE_PAGE_CONTROL               0x0A
#define MODE_PAGE_MEDIUM_TYPES          0x0B
#define MODE_PAGE_NOTCH_PARTITION       0x0C
#define MODE_PAGE_CD_AUDIO_CONTROL      0x0E
#define MODE_PAGE_DATA_COMPRESS         0x0F
#define MODE_PAGE_DEVICE_CONFIG         0x10
#define MODE_PAGE_MEDIUM_PARTITION      0x11
#define MODE_PAGE_CDVD_FEATURE_SET      0x18
#define MODE_PAGE_POWER_CONDITION       0x1A
#define MODE_PAGE_FAULT_REPORTING       0x1C
#define MODE_PAGE_CDVD_INACTIVITY       0x1D
#define MODE_PAGE_ELEMENT_ADDRESS       0x1D
#define MODE_PAGE_TRANSPORT_GEOMETRY    0x1E
#define MODE_PAGE_DEVICE_CAPABILITIES   0x1F
#define MODE_PAGE_CAPABILITIES          0x2A

#define MODE_SENSE_RETURN_ALL           0x3f

#define MODE_SENSE_CURRENT_VALUES       0x00
#define MODE_SENSE_CHANGEABLE_VALUES    0x40
#define MODE_SENSE_DEFAULT_VAULES       0x80
#define MODE_SENSE_SAVED_VALUES         0xc0


//
// SCSI CDB operation codes
//

#define SCSIOP_TEST_UNIT_READY     0x00
#define SCSIOP_REZERO_UNIT         0x01
#define SCSIOP_REWIND              0x01
#define SCSIOP_REQUEST_BLOCK_ADDR  0x02
#define SCSIOP_REQUEST_SENSE       0x03
#define SCSIOP_FORMAT_UNIT         0x04
#define SCSIOP_READ_BLOCK_LIMITS   0x05
#define SCSIOP_REASSIGN_BLOCKS     0x07
#define SCSIOP_INIT_ELEMENT_STATUS 0x07
#define SCSIOP_READ6               0x08
#define SCSIOP_RECEIVE             0x08
#define SCSIOP_WRITE6              0x0A
#define SCSIOP_PRINT               0x0A
#define SCSIOP_SEND                0x0A
#define SCSIOP_SEEK6               0x0B
#define SCSIOP_TRACK_SELECT        0x0B
#define SCSIOP_SLEW_PRINT          0x0B
#define SCSIOP_SEEK_BLOCK          0x0C
#define SCSIOP_PARTITION           0x0D
#define SCSIOP_READ_REVERSE        0x0F
#define SCSIOP_WRITE_FILEMARKS     0x10
#define SCSIOP_FLUSH_BUFFER        0x10
#define SCSIOP_SPACE               0x11
#define SCSIOP_INQUIRY             0x12
#define SCSIOP_VERIFY6             0x13
#define SCSIOP_RECOVER_BUF_DATA    0x14
#define SCSIOP_MODE_SELECT         0x15
#define SCSIOP_RESERVE_UNIT        0x16
#define SCSIOP_RELEASE_UNIT        0x17

#define SCSIOP_COPY                0x18
#define SCSIOP_ERASE               0x19
#define SCSIOP_MODE_SENSE          0x1A
#define SCSIOP_START_STOP_UNIT     0x1B
#define SCSIOP_STOP_PRINT          0x1B
#define SCSIOP_LOAD_UNLOAD         0x1B
#define SCSIOP_RECEIVE_DIAGNOSTIC  0x1C
#define SCSIOP_SEND_DIAGNOSTIC     0x1D
#define SCSIOP_MEDIUM_REMOVAL      0x1E
#define SCSIOP_READ_FORMATTED_CAPACITY 0x23
#define SCSIOP_READ_CAPACITY       0x25
#define SCSIOP_READ                0x28
#define SCSIOP_WRITE               0x2A
#define SCSIOP_SEEK                0x2B
#define SCSIOP_LOCATE              0x2B
#define SCSIOP_POSITION_TO_ELEMENT 0x2B
#define SCSIOP_WRITE_VERIFY        0x2E
#define SCSIOP_VERIFY              0x2F
#define SCSIOP_SEARCH_DATA_HIGH    0x30
#define SCSIOP_SEARCH_DATA_EQUAL   0x31
#define SCSIOP_SEARCH_DATA_LOW     0x32
#define SCSIOP_SET_LIMITS          0x33
#define SCSIOP_READ_POSITION       0x34
#define SCSIOP_SYNCHRONIZE_CACHE   0x35
#define SCSIOP_COMPARE             0x39
#define SCSIOP_COPY_COMPARE        0x3A
#define SCSIOP_WRITE_DATA_BUFF     0x3B
#define SCSIOP_READ_DATA_BUFF      0x3C
#define SCSIOP_CHANGE_DEFINITION   0x40
#define SCSIOP_READ_SUB_CHANNEL    0x42
#define SCSIOP_READ_TOC            0x43
#define SCSIOP_READ_HEADER         0x44
#define SCSIOP_PLAY_AUDIO          0x45
#define SCSIOP_PLAY_AUDIO_MSF      0x47
#define SCSIOP_PLAY_TRACK_INDEX    0x48
#define SCSIOP_PLAY_TRACK_RELATIVE 0x49
#define SCSIOP_PAUSE_RESUME        0x4B
#define SCSIOP_LOG_SELECT          0x4C
#define SCSIOP_LOG_SENSE           0x4D
#define SCSIOP_STOP_PLAY_SCAN      0x4E
#define SCSIOP_READ_DISK_INFORMATION 0x51
#define SCSIOP_READ_TRACK_INFORMATION 0x52
#define SCSIOP_MODE_SELECT10       0x55
#define SCSIOP_MODE_SENSE10        0x5A
#define SCSIOP_REPORT_LUNS         0xA0
#define SCSIOP_SEND_KEY            0xA3
#define SCSIOP_REPORT_KEY          0xA4
#define SCSIOP_MOVE_MEDIUM         0xA5
#define SCSIOP_LOAD_UNLOAD_SLOT    0xA6
#define SCSIOP_EXCHANGE_MEDIUM     0xA6
#define SCSIOP_SET_READ_AHEAD      0xA7
#define SCSIOP_READ_DVD_STRUCTURE  0xAD
#define SCSIOP_REQUEST_VOL_ELEMENT 0xB5
#define SCSIOP_SEND_VOLUME_TAG     0xB6
#define SCSIOP_READ_ELEMENT_STATUS 0xB8
#define SCSIOP_READ_CD_MSF         0xB9
#define SCSIOP_SCAN_CD             0xBA
#define SCSIOP_PLAY_CD             0xBC
#define SCSIOP_MECHANISM_STATUS    0xBD
#define SCSIOP_READ_CD             0xBE
#define SCSIOP_INIT_ELEMENT_RANGE  0xE7

//
// If the IMMED bit is 1, status is returned as soon
// as the operation is initiated. If the IMMED bit
// is 0, status is not returned until the operation
// is completed.
//

#define CDB_RETURN_ON_COMPLETION   0
#define CDB_RETURN_IMMEDIATE       1

// end_ntminitape

//
// CDB Force media access used in extended read and write commands.
//

#define CDB_FORCE_MEDIA_ACCESS 0x08

//
// Denon CD ROM operation codes
//

#define SCSIOP_DENON_EJECT_DISC    0xE6
#define SCSIOP_DENON_STOP_AUDIO    0xE7
#define SCSIOP_DENON_PLAY_AUDIO    0xE8
#define SCSIOP_DENON_READ_TOC      0xE9
#define SCSIOP_DENON_READ_SUBCODE  0xEB

//
// SCSI Bus Messages
//

#define SCSIMESS_ABORT                0x06
#define SCSIMESS_ABORT_WITH_TAG       0x0D
#define SCSIMESS_BUS_DEVICE_RESET     0X0C
#define SCSIMESS_CLEAR_QUEUE          0X0E
#define SCSIMESS_COMMAND_COMPLETE     0X00
#define SCSIMESS_DISCONNECT           0X04
#define SCSIMESS_EXTENDED_MESSAGE     0X01
#define SCSIMESS_IDENTIFY             0X80
#define SCSIMESS_IDENTIFY_WITH_DISCON 0XC0
#define SCSIMESS_IGNORE_WIDE_RESIDUE  0X23
#define SCSIMESS_INITIATE_RECOVERY    0X0F
#define SCSIMESS_INIT_DETECTED_ERROR  0X05
#define SCSIMESS_LINK_CMD_COMP        0X0A
#define SCSIMESS_LINK_CMD_COMP_W_FLAG 0X0B
#define SCSIMESS_MESS_PARITY_ERROR    0X09
#define SCSIMESS_MESSAGE_REJECT       0X07
#define SCSIMESS_NO_OPERATION         0X08
#define SCSIMESS_HEAD_OF_QUEUE_TAG    0X21
#define SCSIMESS_ORDERED_QUEUE_TAG    0X22
#define SCSIMESS_SIMPLE_QUEUE_TAG     0X20
#define SCSIMESS_RELEASE_RECOVERY     0X10
#define SCSIMESS_RESTORE_POINTERS     0X03
#define SCSIMESS_SAVE_DATA_POINTER    0X02
#define SCSIMESS_TERMINATE_IO_PROCESS 0X11

//
// SCSI Extended Message operation codes
//

#define SCSIMESS_MODIFY_DATA_POINTER  0X00
#define SCSIMESS_SYNCHRONOUS_DATA_REQ 0X01
#define SCSIMESS_WIDE_DATA_REQUEST    0X03

//
// SCSI Extended Message Lengths
//

#define SCSIMESS_MODIFY_DATA_LENGTH   5
#define SCSIMESS_SYNCH_DATA_LENGTH    3
#define SCSIMESS_WIDE_DATA_LENGTH     2

//
// SCSI extended message structure
//

#pragma pack (1)
typedef struct _SCSI_EXTENDED_MESSAGE {
    UCHAR InitialMessageCode;
    UCHAR MessageLength;
    UCHAR MessageType;
    union _EXTENDED_ARGUMENTS {

        struct {
            UCHAR Modifier[4];
        } Modify;

        struct {
            UCHAR TransferPeriod;
            UCHAR ReqAckOffset;
        } Synchronous;

        struct{
            UCHAR Width;
        } Wide;
    }ExtendedArguments;
}SCSI_EXTENDED_MESSAGE, *PSCSI_EXTENDED_MESSAGE;
#pragma pack ()

//
// SCSI bus status codes.
//

#define SCSISTAT_GOOD                  0x00
#define SCSISTAT_CHECK_CONDITION       0x02
#define SCSISTAT_CONDITION_MET         0x04
#define SCSISTAT_BUSY                  0x08
#define SCSISTAT_INTERMEDIATE          0x10
#define SCSISTAT_INTERMEDIATE_COND_MET 0x14
#define SCSISTAT_RESERVATION_CONFLICT  0x18
#define SCSISTAT_COMMAND_TERMINATED    0x22
#define SCSISTAT_QUEUE_FULL            0x28

//
// Enable Vital Product Data Flag (EVPD)
// used with INQUIRY command.
//

#define CDB_INQUIRY_EVPD           0x01

//
// Defines for format CDB
//

#define LUN0_FORMAT_SAVING_DEFECT_LIST 0
#define USE_DEFAULTMSB  0
#define USE_DEFAULTLSB  0

#define START_UNIT_CODE 0x01
#define STOP_UNIT_CODE  0x00

// begin_ntminitape

//
// Inquiry buffer structure. This is the data returned from the target
// after it receives an inquiry.
//
// This structure may be extended by the number of bytes specified
// in the field AdditionalLength. The defined size constant only
// includes fields through ProductRevisionLevel.
//
// The NT SCSI drivers are only interested in the first 36 bytes of data.
//

#define INQUIRYDATABUFFERSIZE 36

typedef struct _INQUIRYDATA {
    UCHAR DeviceType : 5;
    UCHAR DeviceTypeQualifier : 3;
    UCHAR DeviceTypeModifier : 7;
    UCHAR RemovableMedia : 1;
    UCHAR Versions;
    UCHAR ResponseDataFormat : 4;
    UCHAR HiSupport : 1;
    UCHAR NormACA : 1;
    UCHAR ReservedBit : 1;
    UCHAR AERC : 1;
    UCHAR AdditionalLength;
    UCHAR Reserved[2];
    UCHAR SoftReset : 1;
    UCHAR CommandQueue : 1;
    UCHAR Reserved2 : 1;
    UCHAR LinkedCommands : 1;
    UCHAR Synchronous : 1;
    UCHAR Wide16Bit : 1;
    UCHAR Wide32Bit : 1;
    UCHAR RelativeAddressing : 1;
    UCHAR VendorId[8];
    UCHAR ProductId[16];
    UCHAR ProductRevisionLevel[4];
    UCHAR VendorSpecific[20];
    UCHAR Reserved3[40];
} INQUIRYDATA, *PINQUIRYDATA;

//
// Inquiry defines. Used to interpret data returned from target as result
// of inquiry command.
//
// DeviceType field
//

#define DIRECT_ACCESS_DEVICE            0x00    // disks
#define SEQUENTIAL_ACCESS_DEVICE        0x01    // tapes
#define PRINTER_DEVICE                  0x02    // printers
#define PROCESSOR_DEVICE                0x03    // scanners, printers, etc
#define WRITE_ONCE_READ_MULTIPLE_DEVICE 0x04    // worms
#define READ_ONLY_DIRECT_ACCESS_DEVICE  0x05    // cdroms
#define SCANNER_DEVICE                  0x06    // scanners
#define OPTICAL_DEVICE                  0x07    // optical disks
#define MEDIUM_CHANGER                  0x08    // jukebox
#define COMMUNICATION_DEVICE            0x09    // network
#define LOGICAL_UNIT_NOT_PRESENT_DEVICE 0x7F

#define DEVICE_QUALIFIER_ACTIVE         0x00
#define DEVICE_QUALIFIER_NOT_ACTIVE     0x01
#define DEVICE_QUALIFIER_NOT_SUPPORTED  0x03

//
// DeviceTypeQualifier field
//

#define DEVICE_CONNECTED 0x00

//
// Sense Data Format
//

typedef struct _SENSE_DATA {
    UCHAR ErrorCode:7;
    UCHAR Valid:1;
    UCHAR SegmentNumber;
    UCHAR SenseKey:4;
    UCHAR Reserved:1;
    UCHAR IncorrectLength:1;
    UCHAR EndOfMedia:1;
    UCHAR FileMark:1;
    UCHAR Information[4];
    UCHAR AdditionalSenseLength;
    UCHAR CommandSpecificInformation[4];
    UCHAR AdditionalSenseCode;
    UCHAR AdditionalSenseCodeQualifier;
    UCHAR FieldReplaceableUnitCode;
    UCHAR SenseKeySpecific[3];
} SENSE_DATA, *PSENSE_DATA;

//
// Default request sense buffer size
//

#define SENSE_BUFFER_SIZE 18

//
// Sense codes
//

#define SCSI_SENSE_NO_SENSE         0x00
#define SCSI_SENSE_RECOVERED_ERROR  0x01
#define SCSI_SENSE_NOT_READY        0x02
#define SCSI_SENSE_MEDIUM_ERROR     0x03
#define SCSI_SENSE_HARDWARE_ERROR   0x04
#define SCSI_SENSE_ILLEGAL_REQUEST  0x05
#define SCSI_SENSE_UNIT_ATTENTION   0x06
#define SCSI_SENSE_DATA_PROTECT     0x07
#define SCSI_SENSE_BLANK_CHECK      0x08
#define SCSI_SENSE_UNIQUE           0x09
#define SCSI_SENSE_COPY_ABORTED     0x0A
#define SCSI_SENSE_ABORTED_COMMAND  0x0B
#define SCSI_SENSE_EQUAL            0x0C
#define SCSI_SENSE_VOL_OVERFLOW     0x0D
#define SCSI_SENSE_MISCOMPARE       0x0E
#define SCSI_SENSE_RESERVED         0x0F

//
// Additional tape bit
//

#define SCSI_ILLEGAL_LENGTH         0x20
#define SCSI_EOM                    0x40
#define SCSI_FILE_MARK              0x80

//
// Additional Sense codes
//

#define SCSI_ADSENSE_NO_SENSE       0x00
#define SCSI_ADSENSE_LUN_NOT_READY  0x04

#define SCSI_ADSENSE_TRACK_ERROR    0x14
#define SCSI_ADSENSE_SEEK_ERROR     0x15
#define SCSI_ADSENSE_REC_DATA_NOECC 0x17
#define SCSI_ADSENSE_REC_DATA_ECC   0x18

#define SCSI_ADSENSE_ILLEGAL_COMMAND 0x20
#define SCSI_ADSENSE_ILLEGAL_BLOCK  0x21
#define SCSI_ADSENSE_INVALID_CDB    0x24
#define SCSI_ADSENSE_INVALID_LUN    0x25
#define SCSI_ADWRITE_PROTECT        0x27
#define SCSI_ADSENSE_MEDIUM_CHANGED 0x28
#define SCSI_ADSENSE_BUS_RESET      0x29

#define SCSI_ADSENSE_INVALID_MEDIA  0x30
#define SCSI_ADSENSE_NO_MEDIA_IN_DEVICE 0x3a
#define SCSI_ADSENSE_POSITION_ERROR 0x3b

// the second is for legacy apps.
#define SCSI_ADSENSE_FAILURE_PREDICTION_THRESHOLD_EXCEEDED 0x5d
#define SCSI_FAILURE_PREDICTION_THRESHOLD_EXCEEDED SCSI_ADSENSE_FAILURE_PREDICTION_THRESHOLD_EXCEEDED

#define SCSI_ADSENSE_COPY_PROTECTION_FAILURE 0x6f

#define SCSI_ADSENSE_VENDOR_UNIQUE  0x80

#define SCSI_ADSENSE_MUSIC_AREA     0xA0
#define SCSI_ADSENSE_DATA_AREA      0xA1
#define SCSI_ADSENSE_VOLUME_OVERFLOW 0xA7

//
// SCSI_ADSENSE_LUN_NOT_READY (0x04) qualifiers
//

#define SCSI_SENSEQ_CAUSE_NOT_REPORTABLE         0x00
#define SCSI_SENSEQ_BECOMING_READY               0x01
#define SCSI_SENSEQ_INIT_COMMAND_REQUIRED        0x02
#define SCSI_SENSEQ_MANUAL_INTERVENTION_REQUIRED 0x03
#define SCSI_SENSEQ_FORMAT_IN_PROGRESS           0x04
#define SCSI_SENSEQ_OPERATION_IN_PROGRESS        0x07

//
// SCSI_ADSENSE_NO_SENSE (0x00) qualifiers
//

#define SCSI_SENSEQ_FILEMARK_DETECTED 0x01
#define SCSI_SENSEQ_END_OF_MEDIA_DETECTED 0x02
#define SCSI_SENSEQ_SETMARK_DETECTED 0x03
#define SCSI_SENSEQ_BEGINNING_OF_MEDIA_DETECTED 0x04

//
// SCSI_ADSENSE_ILLEGAL_BLOCK (0x21) qualifiers
//

#define SCSI_SENSEQ_ILLEGAL_ELEMENT_ADDR 0x01

//
// SCSI_ADSENSE_POSITION_ERROR (0x3b) qualifiers
//

#define SCSI_SENSEQ_DESTINATION_FULL 0x0d
#define SCSI_SENSEQ_SOURCE_EMPTY     0x0e

// end_ntminitape

//
// SCSI_ADSENSE_INVALID_MEDIA (0x30) qualifiers
//

#define SCSI_SENSEQ_INCOMPATIBLE_MEDIA_INSTALLED 0x00
#define SCSI_SENSEQ_UNKNOWN_FORMAT 0x01
#define SCSI_SENSEQ_INCOMPATIBLE_FORMAT 0x02

//
// SCSI_ADSENSE_COPY_PROTECTION_FAILURE (0x6f) qualifiers
//
#define SCSI_SENSEQ_AUTHENTICATION_FAILURE                          0x00
#define SCSI_SENSEQ_KEY_NOT_PRESENT                                 0x01
#define SCSI_SENSEQ_KEY_NOT_ESTABLISHED                             0x02
#define SCSI_SENSEQ_READ_OF_SCRAMBLED_SECTOR_WITHOUT_AUTHENTICATION 0x03
#define SCSI_SENSEQ_MEDIA_CODE_MISMATCHED_TO_LOGICAL_UNIT           0x04
#define SCSI_SENSEQ_LOGICAL_UNIT_RESET_COUNT_ERROR                  0x05


//
// SCSI IO Device Control Codes
//

#define FILE_DEVICE_SCSI 0x0000001b

#define IOCTL_SCSI_EXECUTE_IN   ((FILE_DEVICE_SCSI << 16) + 0x0011)
#define IOCTL_SCSI_EXECUTE_OUT  ((FILE_DEVICE_SCSI << 16) + 0x0012)
#define IOCTL_SCSI_EXECUTE_NONE ((FILE_DEVICE_SCSI << 16) + 0x0013)

//
// SMART support in atapi
//

#define IOCTL_SCSI_MINIPORT_SMART_VERSION           ((FILE_DEVICE_SCSI << 16) + 0x0500)
#define IOCTL_SCSI_MINIPORT_IDENTIFY                ((FILE_DEVICE_SCSI << 16) + 0x0501)
#define IOCTL_SCSI_MINIPORT_READ_SMART_ATTRIBS      ((FILE_DEVICE_SCSI << 16) + 0x0502)
#define IOCTL_SCSI_MINIPORT_READ_SMART_THRESHOLDS   ((FILE_DEVICE_SCSI << 16) + 0x0503)
#define IOCTL_SCSI_MINIPORT_ENABLE_SMART            ((FILE_DEVICE_SCSI << 16) + 0x0504)
#define IOCTL_SCSI_MINIPORT_DISABLE_SMART           ((FILE_DEVICE_SCSI << 16) + 0x0505)
#define IOCTL_SCSI_MINIPORT_RETURN_STATUS           ((FILE_DEVICE_SCSI << 16) + 0x0506)
#define IOCTL_SCSI_MINIPORT_ENABLE_DISABLE_AUTOSAVE ((FILE_DEVICE_SCSI << 16) + 0x0507)
#define IOCTL_SCSI_MINIPORT_SAVE_ATTRIBUTE_VALUES   ((FILE_DEVICE_SCSI << 16) + 0x0508)
#define IOCTL_SCSI_MINIPORT_EXECUTE_OFFLINE_DIAGS   ((FILE_DEVICE_SCSI << 16) + 0x0509)
#define IOCTL_SCSI_MINIPORT_ENABLE_DISABLE_AUTO_OFFLINE ((FILE_DEVICE_SCSI << 16) + 0x050a)

//
// CLUSTER support
// deliberately skipped some values to allow for expansion above.
//
#define IOCTL_SCSI_MINIPORT_NOT_QUORUM_CAPABLE     ((FILE_DEVICE_SCSI << 16) + 0x0520)
#define IOCTL_SCSI_MINIPORT_NOT_CLUSTER_CAPABLE    ((FILE_DEVICE_SCSI << 16) + 0x0521)


// begin_ntminitape

//
// Read Capacity Data - returned in Big Endian format
//

typedef struct _READ_CAPACITY_DATA {
    ULONG LogicalBlockAddress;
    ULONG BytesPerBlock;
} READ_CAPACITY_DATA, *PREAD_CAPACITY_DATA;

//
// Read Block Limits Data - returned in Big Endian format
// This structure returns the maximum and minimum block
// size for a TAPE device.
//

typedef struct _READ_BLOCK_LIMITS {
    UCHAR Reserved;
    UCHAR BlockMaximumSize[3];
    UCHAR BlockMinimumSize[2];
} READ_BLOCK_LIMITS_DATA, *PREAD_BLOCK_LIMITS_DATA;


//
// Mode data structures.
//

//
// Define Mode parameter header.
//

typedef struct _MODE_PARAMETER_HEADER {
    UCHAR ModeDataLength;
    UCHAR MediumType;
    UCHAR DeviceSpecificParameter;
    UCHAR BlockDescriptorLength;
}MODE_PARAMETER_HEADER, *PMODE_PARAMETER_HEADER;

typedef struct _MODE_PARAMETER_HEADER10 {
    UCHAR ModeDataLength[2];
    UCHAR MediumType;
    UCHAR DeviceSpecificParameter;
    UCHAR Reserved[2];
    UCHAR BlockDescriptorLength[2];
}MODE_PARAMETER_HEADER10, *PMODE_PARAMETER_HEADER10;

#define MODE_FD_SINGLE_SIDE     0x01
#define MODE_FD_DOUBLE_SIDE     0x02
#define MODE_FD_MAXIMUM_TYPE    0x1E
#define MODE_DSP_FUA_SUPPORTED  0x10
#define MODE_DSP_WRITE_PROTECT  0x80

//
// Define the mode parameter block.
//

typedef struct _MODE_PARAMETER_BLOCK {
    UCHAR DensityCode;
    UCHAR NumberOfBlocks[3];
    UCHAR Reserved;
    UCHAR BlockLength[3];
}MODE_PARAMETER_BLOCK, *PMODE_PARAMETER_BLOCK;

//
// Define Disconnect-Reconnect page.
//

typedef struct _MODE_DISCONNECT_PAGE {
    UCHAR PageCode : 6;
    UCHAR Reserved : 1;
    UCHAR PageSavable : 1;
    UCHAR PageLength;
    UCHAR BufferFullRatio;
    UCHAR BufferEmptyRatio;
    UCHAR BusInactivityLimit[2];
    UCHAR BusDisconnectTime[2];
    UCHAR BusConnectTime[2];
    UCHAR MaximumBurstSize[2];
    UCHAR DataTransferDisconnect : 2;
    UCHAR Reserved2[3];
}MODE_DISCONNECT_PAGE, *PMODE_DISCONNECT_PAGE;

//
// Define mode caching page.
//

typedef struct _MODE_CACHING_PAGE {
    UCHAR PageCode : 6;
    UCHAR Reserved : 1;
    UCHAR PageSavable : 1;
    UCHAR PageLength;
    UCHAR ReadDisableCache : 1;
    UCHAR MultiplicationFactor : 1;
    UCHAR WriteCacheEnable : 1;
    UCHAR Reserved2 : 5;
    UCHAR WriteRetensionPriority : 4;
    UCHAR ReadRetensionPriority : 4;
    UCHAR DisablePrefetchTransfer[2];
    UCHAR MinimumPrefetch[2];
    UCHAR MaximumPrefetch[2];
    UCHAR MaximumPrefetchCeiling[2];
}MODE_CACHING_PAGE, *PMODE_CACHING_PAGE;

//
// Define mode flexible disk page.
//

typedef struct _MODE_FLEXIBLE_DISK_PAGE {
    UCHAR PageCode : 6;
    UCHAR Reserved : 1;
    UCHAR PageSavable : 1;
    UCHAR PageLength;
    UCHAR TransferRate[2];
    UCHAR NumberOfHeads;
    UCHAR SectorsPerTrack;
    UCHAR BytesPerSector[2];
    UCHAR NumberOfCylinders[2];
    UCHAR StartWritePrecom[2];
    UCHAR StartReducedCurrent[2];
    UCHAR StepRate[2];
    UCHAR StepPluseWidth;
    UCHAR HeadSettleDelay[2];
    UCHAR MotorOnDelay;
    UCHAR MotorOffDelay;
    UCHAR Reserved2 : 5;
    UCHAR MotorOnAsserted : 1;
    UCHAR StartSectorNumber : 1;
    UCHAR TrueReadySignal : 1;
    UCHAR StepPlusePerCyclynder : 4;
    UCHAR Reserved3 : 4;
    UCHAR WriteCompenstation;
    UCHAR HeadLoadDelay;
    UCHAR HeadUnloadDelay;
    UCHAR Pin2Usage : 4;
    UCHAR Pin34Usage : 4;
    UCHAR Pin1Usage : 4;
    UCHAR Pin4Usage : 4;
    UCHAR MediumRotationRate[2];
    UCHAR Reserved4[2];
}MODE_FLEXIBLE_DISK_PAGE, *PMODE_FLEXIBLE_DISK_PAGE;

//
// Define mode format page.
//

typedef struct _MODE_FORMAT_PAGE {
    UCHAR PageCode : 6;
    UCHAR Reserved : 1;
    UCHAR PageSavable : 1;
    UCHAR PageLength;
    UCHAR TracksPerZone[2];
    UCHAR AlternateSectorsPerZone[2];
    UCHAR AlternateTracksPerZone[2];
    UCHAR AlternateTracksPerLogicalUnit[2];
    UCHAR SectorsPerTrack[2];
    UCHAR BytesPerPhysicalSector[2];
    UCHAR Interleave[2];
    UCHAR TrackSkewFactor[2];
    UCHAR CylinderSkewFactor[2];
    UCHAR Reserved2 : 4;
    UCHAR SurfaceFirst : 1;
    UCHAR RemovableMedia : 1;
    UCHAR HardSectorFormating : 1;
    UCHAR SoftSectorFormating : 1;
    UCHAR Reserved3[3];
}MODE_FORMAT_PAGE, *PMODE_FORMAT_PAGE;

//
// Define rigid disk driver geometry page.
//

typedef struct _MODE_RIGID_GEOMETRY_PAGE {
    UCHAR PageCode : 6;
    UCHAR Reserved : 1;
    UCHAR PageSavable : 1;
    UCHAR PageLength;
    UCHAR NumberOfCylinders[3];
    UCHAR NumberOfHeads;
    UCHAR StartWritePrecom[3];
    UCHAR StartReducedCurrent[3];
    UCHAR DriveStepRate[2];
    UCHAR LandZoneCyclinder[3];
    UCHAR RotationalPositionLock : 2;
    UCHAR Reserved2 : 6;
    UCHAR RotationOffset;
    UCHAR Reserved3;
    UCHAR RoataionRate[2];
    UCHAR Reserved4[2];
}MODE_RIGID_GEOMETRY_PAGE, *PMODE_RIGID_GEOMETRY_PAGE;

//
// Define read write recovery page
//

typedef struct _MODE_READ_WRITE_RECOVERY_PAGE {

    UCHAR PageCode : 6;
    UCHAR Reserved1 : 1;
    UCHAR PSBit : 1;
    UCHAR PageLength;
    UCHAR DCRBit : 1;
    UCHAR DTEBit : 1;
    UCHAR PERBit : 1;
    UCHAR EERBit : 1;
    UCHAR RCBit : 1;
    UCHAR TBBit : 1;
    UCHAR ARRE : 1;
    UCHAR AWRE : 1;
    UCHAR ReadRetryCount;
    UCHAR Reserved4[4];
    UCHAR WriteRetryCount;
    UCHAR Reserved5[3];

} MODE_READ_WRITE_RECOVERY_PAGE, *PMODE_READ_WRITE_RECOVERY_PAGE;

//
// Define read recovery page - cdrom
//

typedef struct _MODE_READ_RECOVERY_PAGE {

    UCHAR PageCode : 6;
    UCHAR Reserved1 : 1;
    UCHAR PSBit : 1;
    UCHAR PageLength;
    UCHAR DCRBit : 1;
    UCHAR DTEBit : 1;
    UCHAR PERBit : 1;
    UCHAR Reserved2 : 1;
    UCHAR RCBit : 1;
    UCHAR TBBit : 1;
    UCHAR Reserved3 : 2;
    UCHAR ReadRetryCount;
    UCHAR Reserved4[4];

} MODE_READ_RECOVERY_PAGE, *PMODE_READ_RECOVERY_PAGE;


//
// Define Informational Exception Control Page. Used for failure prediction
//

typedef struct _MODE_INFO_EXCEPTIONS
{
    UCHAR PageCode : 6;
    UCHAR Reserved1 : 1;
    UCHAR PSBit : 1;

    UCHAR PageLength;

    UCHAR LogErr : 1;
    UCHAR Reserved2 : 1;
    UCHAR Test : 1;
    UCHAR Dexcpt : 1;
    UCHAR Reserved3 : 3;
    UCHAR Perf : 1;

    UCHAR ReportMethod : 4;
    UCHAR Reserved4 : 4;

    UCHAR IntervalTimer[4];       // [0]=MSB, [3]=LSB
    UCHAR ReportCount[4];         // [0]=MSB, [3]=LSB

} MODE_INFO_EXCEPTIONS, *PMODE_INFO_EXCEPTIONS;

//
// Begin C/DVD 0.9 definitions
//

//
// Power Condition Mode Page Format
//

typedef struct _POWER_CONDITION_PAGE {
    UCHAR PageCode : 6;         // 0x1A
    UCHAR Reserved : 1;
    UCHAR PSBit : 1;
    UCHAR PageLength;           // 0x0A
    UCHAR Reserved2;

    UCHAR Standby : 1;
    UCHAR Idle : 1;
    UCHAR Reserved3 : 6;

    UCHAR IdleTimer[4];         // [0]=MSB, [3]=LSB
    UCHAR StandbyTimer[4];      // [0]=MSB, [3]=LSB
} POWER_CONDITION_PAGE, *PPOWER_CONDITION_PAGE;

//
// CD-Audio Control Mode Page Format
//

typedef struct _CDDA_OUTPUT_PORT {
    UCHAR ChannelSelection : 4;
    UCHAR Reserved : 4;
    UCHAR Volume;
} CDDA_OUTPUT_PORT, *PCDDA_OUTPUT_PORT;


typedef struct _CDAUDIO_CONTROL_PAGE {
    UCHAR PageCode : 6;     // 0x0E
    UCHAR Reserved : 1;
    UCHAR PSBit : 1;

    UCHAR PageLength;       // 0x0E

    UCHAR Reserved2 : 1;
    UCHAR StopOnTrackCrossing : 1;         // Default 0
    UCHAR Immediate : 1;    // Always 1
    UCHAR Reserved3 : 5;

    UCHAR Reserved4[3];
    UCHAR Obsolete[2];

    CDDA_OUTPUT_PORT CDDAOutputPorts[4];

} CDAUDIO_CONTROL_PAGE, *PCDAUDIO_CONTROL_PAGE;

#define CDDA_CHANNEL_MUTED      0x0
#define CDDA_CHANNEL_ZERO       0x1
#define CDDA_CHANNEL_ONE        0x2
#define CDDA_CHANNEL_TWO        0x4
#define CDDA_CHANNEL_THREE      0x8

//
// C/DVD Feature Set Support & Version Page
//

typedef struct _CDVD_FEATURE_SET_PAGE {
    UCHAR PageCode : 6;     // 0x18
    UCHAR Reserved : 1;
    UCHAR PSBit : 1;

    UCHAR PageLength;       // 0x16

    UCHAR CDAudio[2];       // [0]=MSB, [1]=LSB
    UCHAR EmbeddedChanger[2];
    UCHAR PacketSMART[2];
    UCHAR PersistantPrevent[2];
    UCHAR EventStatusNotification[2];
    UCHAR DigitalOutput[2];
    UCHAR CDSequentialRecordable[2];
    UCHAR DVDSequentialRecordable[2];
    UCHAR RandomRecordable[2];
    UCHAR KeyExchange[2];
    UCHAR Reserved2[2];
} CDVD_FEATURE_SET_PAGE, *PCDVD_FEATURE_SET_PAGE;

//
// CDVD Inactivity Time-out Page Format
//

typedef struct _CDVD_INACTIVITY_TIMEOUT_PAGE {
    UCHAR PageCode : 6;     // 0x1D
    UCHAR Reserved : 1;
    UCHAR PSBit : 1;

    UCHAR PageLength;       // 0x08
    UCHAR Reserved2[2];

    UCHAR SWPP : 1;
    UCHAR DISP : 1;
    UCHAR Reserved3 : 6;

    UCHAR Reserved4;
    UCHAR GroupOneMinimumTimeout[2];
    UCHAR GroupTwoMinimumTimeout[2];
} CDVD_INACTIVITY_TIMEOUT_PAGE, *PCDVD_INACTIVITY_TIMEOUT_PAGE;

//
// CDVD Capabilities & Mechanism Status Page
//

#define CDVD_LMT_CADDY              0
#define CDVD_LMT_TRAY               1
#define CDVD_LMT_POPUP              2
#define CDVD_LMT_RESERVED1          3
#define CDVD_LMT_CHANGER_INDIVIDUAL 4
#define CDVD_LMT_CHANGER_CARTRIDGE  5
#define CDVD_LMT_RESERVED2          6
#define CDVD_LMT_RESERVED3          7


typedef struct _CDVD_CAPABILITIES_PAGE {
    UCHAR PageCode : 6;     // 0x2A
    UCHAR Reserved : 1;
    UCHAR PSBit : 1;                        // offset 0

    UCHAR PageLength;       // 0x18         // offset 1

    UCHAR CDRRead : 1;
    UCHAR CDERead : 1;
    UCHAR Method2 : 1;
    UCHAR DVDROMRead : 1;
    UCHAR DVDRRead : 1;
    UCHAR DVDRAMRead : 1;
    UCHAR Reserved2 : 2;                    // offset 2

    UCHAR CDRWrite : 1;
    UCHAR CDEWrite : 1;
    UCHAR TestWrite : 1;
    UCHAR Reserved3 : 1;
    UCHAR DVDRWrite : 1;
    UCHAR DVDRAMWrite : 1;
    UCHAR Reserved4 : 2;                    // offset 3

    UCHAR AudioPlay : 1;
    UCHAR Composite : 1;
    UCHAR DigitalPortOne : 1;
    UCHAR DigitalPortTwo : 1;
    UCHAR Mode2Form1 : 1;
    UCHAR Mode2Form2 : 1;
    UCHAR MultiSession : 1;
    UCHAR Reserved5 : 1;                    // offset 4

    UCHAR CDDA : 1;
    UCHAR CDDAAccurate : 1;
    UCHAR RWSupported : 1;
    UCHAR RWDeinterleaved : 1;
    UCHAR C2Pointers : 1;
    UCHAR ISRC : 1;
    UCHAR UPC : 1;
    UCHAR ReadBarCodeCapable : 1;           // offset 5

    UCHAR Lock : 1;
    UCHAR LockState : 1;
    UCHAR PreventJumper : 1;
    UCHAR Eject : 1;
    UCHAR Reserved6 : 1;
    UCHAR LoadingMechanismType : 3;         // offset 6

    UCHAR SeparateVolume : 1;
    UCHAR SeperateChannelMute : 1;
    UCHAR SupportsDiskPresent : 1;
    UCHAR SWSlotSelection : 1;
    UCHAR SideChangeCapable : 1;
    UCHAR RWInLeadInReadable : 1;
    UCHAR Reserved7 : 2;                    // offset 7

    UCHAR ObsoleteReserved[2];              // offset 8
    UCHAR NumberVolumeLevels[2];            // offset 10
    UCHAR BufferSize[2];                    // offset 12
    UCHAR ObsoleteReserved2[2];             // offset 14
    UCHAR ObsoleteReserved3;                // offset 16

    UCHAR Reserved8 : 1;
    UCHAR BCK : 1;
    UCHAR RCK : 1;
    UCHAR LSBF : 1;
    UCHAR Length : 2;
    UCHAR Reserved9 : 2;                    // offset 17

    UCHAR ObsoleteReserved4[2];             // offset 18
    UCHAR CopyManagementRevision[2];        // offset 20
    UCHAR Reserved10[2];                    // offset 22
} CDVD_CAPABILITIES_PAGE, *PCDVD_CAPABILITIES_PAGE;


typedef struct _LUN_LIST {
    UCHAR LunListLength[4]; // sizeof LunSize * 8
    UCHAR Reserved[4];
    UCHAR Lun[0][8];        // 4 level of addressing.  2 bytes each.
} LUN_LIST, *PLUN_LIST;


#define LOADING_MECHANISM_CADDY                 0x00
#define LOADING_MECHANISM_TRAY                  0x01
#define LOADING_MECHANISM_POPUP                 0x02
#define LOADING_MECHANISM_INDIVIDUAL_CHANGER    0x04
#define LOADING_MECHANISM_CARTRIDGE_CHANGER     0x05

//
// end C/DVD 0.9 mode page definitions

//
// Mode parameter list block descriptor -
// set the block length for reading/writing
//
//

#define MODE_BLOCK_DESC_LENGTH               8
#define MODE_HEADER_LENGTH                   4
#define MODE_HEADER_LENGTH10                 8

typedef struct _MODE_PARM_READ_WRITE {

   MODE_PARAMETER_HEADER  ParameterListHeader;  // List Header Format
   MODE_PARAMETER_BLOCK   ParameterListBlock;   // List Block Descriptor

} MODE_PARM_READ_WRITE_DATA, *PMODE_PARM_READ_WRITE_DATA;

// end_ntminitape

//
// CDROM audio control (0x0E)
//

#define CDB_AUDIO_PAUSE 0
#define CDB_AUDIO_RESUME 1

#define CDB_DEVICE_START 0x11
#define CDB_DEVICE_STOP 0x10

#define CDB_EJECT_MEDIA 0x10
#define CDB_LOAD_MEDIA 0x01

#define CDB_SUBCHANNEL_HEADER      0x00
#define CDB_SUBCHANNEL_BLOCK       0x01

#define CDROM_AUDIO_CONTROL_PAGE   0x0E
#define MODE_SELECT_IMMEDIATE      0x04
#define MODE_SELECT_PFBIT          0x10

#define CDB_USE_MSF                0x01

typedef struct _PORT_OUTPUT {
    UCHAR ChannelSelection;
    UCHAR Volume;
} PORT_OUTPUT, *PPORT_OUTPUT;

typedef struct _AUDIO_OUTPUT {
    UCHAR CodePage;
    UCHAR ParameterLength;
    UCHAR Immediate;
    UCHAR Reserved[2];
    UCHAR LbaFormat;
    UCHAR LogicalBlocksPerSecond[2];
    PORT_OUTPUT PortOutput[4];
} AUDIO_OUTPUT, *PAUDIO_OUTPUT;

//
// Multisession CDROM
//

#define GET_LAST_SESSION 0x01
#define GET_SESSION_DATA 0x02;

//
// Atapi 2.5 changer
//

typedef struct _MECHANICAL_STATUS_INFORMATION_HEADER {
    UCHAR CurrentSlot : 5;
    UCHAR ChangerState : 2;
    UCHAR Fault : 1;
    UCHAR Reserved : 5;
    UCHAR MechanismState : 3;
    UCHAR CurrentLogicalBlockAddress[3];
    UCHAR NumberAvailableSlots;
    UCHAR SlotTableLength[2];
} MECHANICAL_STATUS_INFORMATION_HEADER, *PMECHANICAL_STATUS_INFORMATION_HEADER;

typedef struct _SLOT_TABLE_INFORMATION {
    UCHAR DiscChanged : 1;
    UCHAR Reserved : 6;
    UCHAR DiscPresent : 1;
    UCHAR Reserved2[3];
} SLOT_TABLE_INFORMATION, *PSLOT_TABLE_INFORMATION;

typedef struct _MECHANICAL_STATUS {
    MECHANICAL_STATUS_INFORMATION_HEADER MechanicalStatusHeader;
    SLOT_TABLE_INFORMATION SlotTableInfo[1];
} MECHANICAL_STATUS, *PMECHANICAL_STATUS;


// begin_ntminitape

//
// Tape definitions
//

typedef struct _TAPE_POSITION_DATA {
    UCHAR Reserved1:2;
    UCHAR BlockPositionUnsupported:1;
    UCHAR Reserved2:3;
    UCHAR EndOfPartition:1;
    UCHAR BeginningOfPartition:1;
    UCHAR PartitionNumber;
    USHORT Reserved3;
    UCHAR FirstBlock[4];
    UCHAR LastBlock[4];
    UCHAR Reserved4;
    UCHAR NumberOfBlocks[3];
    UCHAR NumberOfBytes[4];
} TAPE_POSITION_DATA, *PTAPE_POSITION_DATA;

//
// This structure is used to convert little endian
// ULONGs to SCSI CDB 4 byte big endians values.
//

typedef union _FOUR_BYTE {

    struct {
        UCHAR Byte0;
        UCHAR Byte1;
        UCHAR Byte2;
        UCHAR Byte3;
    };

    ULONG AsULong;
} FOUR_BYTE, *PFOUR_BYTE;

typedef union _TWO_BYTE {

    struct {
        UCHAR Byte0;
        UCHAR Byte1;
    };

    USHORT AsUShort;
} TWO_BYTE, *PTWO_BYTE;

//
// Byte reversing macro for converting
// between big- and little-endian formats
//

#define REVERSE_BYTES(Destination, Source) {                \
    PFOUR_BYTE d = (PFOUR_BYTE)(Destination);               \
    PFOUR_BYTE s = (PFOUR_BYTE)(Source);                    \
    d->Byte3 = s->Byte0;                                    \
    d->Byte2 = s->Byte1;                                    \
    d->Byte1 = s->Byte2;                                    \
    d->Byte0 = s->Byte3;                                    \
}

//
// Byte reversing macro for converting
// USHORTS from big to little endian in place
//

#define REVERSE_SHORT(Short) {          \
    UCHAR tmp;                          \
    PTWO_BYTE w = (PTWO_BYTE)(Short);   \
    tmp = w->Byte0;                     \
    w->Byte0 = w->Byte1;                \
    w->Byte1 = tmp;                     \
    }

//
// Byte reversing macro for convering
// ULONGS between big & little endian in place
//

#define REVERSE_LONG(Long) {            \
    UCHAR tmp;                          \
    PFOUR_BYTE l = (PFOUR_BYTE)(Long);  \
    tmp = l->Byte3;                     \
    l->Byte3 = l->Byte0;                \
    l->Byte0 = tmp;                     \
    tmp = l->Byte2;                     \
    l->Byte2 = l->Byte1;                \
    l->Byte1 = tmp;                     \
    }

//
// This macro has the effect of Bit = log2(Data)
//

#define WHICH_BIT(Data, Bit) {                      \
    UCHAR tmp;                                      \
    for (tmp = 0; tmp < 32; tmp++) {                \
        if (((Data) >> tmp) == 1) {                 \
            break;                                  \
        }                                           \
    }                                               \
    ASSERT(tmp != 32);                              \
    (Bit) = tmp;                                    \
}

// end_ntminitape

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4200)
#endif

#endif // !defined _NTSCSI_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\public\oak\inc\compstui.h ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation


Module Name:

    compstui.h


Abstract:

    This module contains global header definition for the COMMON DRIVER UI


Author:

    19-Jun-1995 Mon 11:52:01 created  -by-  Daniel Chou (danielc)

    17-Aug-1995 Thu 14:59:28 updated  -by-  Daniel Chou (danielc)
        Updated for the first draft.

    23-Aug-1995 Wed 15:13:27 updated  -by-  Daniel Chou (danielc)
        Updated for second draft

    29-Aug-1995 Tue 11:33:24 updated  -by-  Daniel Chou (danielc)
        Adding ExtChkBox for some TVOT_xxx type

    31-Aug-1995 Thu 04:04:23 updated  -by-  Daniel Chou (danielc)
        Making UNICODE type

    01-Sep-1995 Fri 17:29:18 updated  -by-  Daniel Chou (danielc)
        Change the API interface type, so that it can be dynamically called
        and generate the property pages to be merge with the shell

    05-Sep-1995 Tue 11:52:43 updated  -by-  Daniel Chou (danielc)
        Rename to compspui.h and update the API entry structure

    07-Sep-1995 Thu 14:46:55 updated  -by-  Daniel Chou (danielc)
        rename to compstui.h and update comments

    07-Sep-1995 Thu 16:07:31 updated  -by-  Daniel Chou (danielc)
        Adding UNION type for pSel/Sel, pOldSel/OldSel

    08-Sep-1995 Fri 09:23:38 updated  -by-  Daniel Chou (danielc)
        Remove TypeIdx from OPTITEM and use pOptType, and remove all
        pOptType passed in the CPSUICBPARAM and COMPROPSHEETUI structures

    25-Sep-1995 Mon 19:39:45 updated  -by-  Daniel Chou (danielc)
        add other related stuff.

    26-Sep-1995 Tue 11:02:26 updated  -by-  Daniel Chou (danielc)
        Add error codes for GETLASTERROR

    27-Sep-1995 Wed 16:32:37 updated  -by-  Daniel Chou (danielc)
        Move hWndParent, pTitle, hInst and TitleIconID out from
        COMPROPSHEETUI to COMPROPSHEETUIHEADER.

    28-Sep-1995 Thu 17:06:46 updated  -by-  Daniel Chou (danielc)
        Add hInstCaller to COMPROPSHEETUI and add _COMPSTUI_ and cplusplus
        stuff

    28-Sep-1995 Thu 23:16:34 updated  -by-  Daniel Chou (danielc)
        change tick count for trackbar/scrollbar to multiply factor. and
        add the push button flag which can overwrite the update permission so
        it can let user view the current setting from push button's dialog
        display

    07-Feb-1996 Wed 17:45:31 updated  -by-  Daniel Chou (danielc)
        Change the API CommonPropSheetUI to CommonPropertySheetUI so that it
        not using stack but message base, this way any caller can add/delete
        pages as they want without worry about how many pages been added from
        its children.


[Environment:]

    NT Windows - Common Property Sheet UI DLL.


[Notes:]


Revision History:


--*/

#ifndef _COMPSTUI_
#define _COMPSTUI_

#ifdef __cplusplus
extern "C" {
#endif


#if (!defined(RC_INVOKED))


//
// For compilers that don't support nameless unions
//

#ifndef DUMMYUNIONNAME
#ifdef NONAMELESSUNION
#define DUMMYUNIONNAME      u
#define DUMMYUNIONNAME2     u2
#define DUMMYUNIONNAME3     u3
#define DUMMYUNIONNAME4     u4
#else
#define DUMMYUNIONNAME
#define DUMMYUNIONNAME2
#define DUMMYUNIONNAME3
#define DUMMYUNIONNAME4
#endif
#endif

//
// Predefined ID for the TreeView Option Type
//
//


#define TVOT_2STATES        0
#define TVOT_3STATES        1
#define TVOT_UDARROW        2
#define TVOT_TRACKBAR       3
#define TVOT_SCROLLBAR      4
#define TVOT_LISTBOX        5
#define TVOT_COMBOBOX       6
#define TVOT_EDITBOX        7
#define TVOT_PUSHBUTTON     8
#define TVOT_CHKBOX         9
#define TVOT_LAST           TVOT_CHKBOX
#define TVOT_NONE           (TVOT_LAST + 1)

//
// Predefined ID for the TreeView Option Type
//
//
// TVOT_2STATES:
//      Count       = 2
//      pOptParam[0]=pointer to the State 1 OPTPARAM
//      pOptParam[1]=pointer to the State 2 OPTPARAM
//
//      BegCtrlID  = 2 States Group Box ID
//      BegCtrlID+1= 2 States static Text
//      BegCtrlID+2= state 1 Radio button ID
//      BegCtrlID+3= state 1 icon control ID
//      BegCtrlID+4= state 2 Radio button ID
//      BegCtrlID+5= state 2 icon control ID
//      BegCtrlID+6= Extended Check Box/Push Button control ID
//      BegCtrlID+7= Extended Check Box/Push Button Icon control ID
//
//  * For TVOT_3STATES, TVOT_3STATES, each of OPTPARAM consisted
//
//      Style =Ignored
//      pData =Pointer to the string to describe the state
//      IconID=Icons resource ID, or common UI standard icon ID
//      lParam=Ignored
//
//  * OPTITEM's 'Sel' is the selection index range from 0 to 1
//  * On the non-treeview page, this must be a auto radio button
//
//
// TVOT_3STATES:
//      Count       = 3
//      pOptParam[0]=pointer to the State 1 OPTPARAM
//      pOptParam[1]=pointer to the State 2 OPTPARAM
//      pOptParam[2]=pointer to the State 3 OPTPARAM
//
//      BegCtrlID  = 3 States Group Box ID
//      BegCtrlID+1= 3 States static Text
//      BegCtrlID+2= state 1 Radio button ID
//      BegCtrlID+3= state 1 icon control ID
//      BegCtrlID+4= state 2 Radio button ID
//      BegCtrlID+5= state 2 icon control ID
//      BegCtrlID+6= state 3 Radio button ID
//      BegCtrlID+7= state 3 icon control ID
//      BegCtrlID+8= Extended Check Box/Push Button control ID
//      BegCtrlID+9= Extended Check Box/Push Button Icon control ID
//
//  * For TVOT_2STATES, TVOT_3STATES, each of OPTPARAM consisted
//
//      Style =Ignored
//      pData =Pointer to the string to describe the state
//      IconID=Icons resource ID, or common UI standard icon ID
//      lParam=Ignored
//
//  * OPTITEM's 'Sel' is the selection index range from 0 to 1
//  * On the non-treeview page, this must be a auto radio button
//
//  ** For TVOT_2STATES, TVOT_3STSATES the 'Sel' field in the OPTITEM has
//     following definitions
//
//      State 1, Sel = 0
//      State 2, Sel = 1
//      State 3, Sel = 2
//
//      for any selection which based on false/true, no/yes, off/ontrue/false,
//      none/select then state 1 (sel=0) must always be the NO, FALSE, OFF or
//      NONE type.
//
//
// TVOT_UDARROW:
//      Count       = 2
//      pOptParam[0]=Pointer to the text of postfix and ICONS
//      pOptParam[1]=Pointer to the help line text above the control and
//                      IconID = (SHORT)Low range of the up-down control
//                      lParam = (SHORT)High range of the up-down control
//
//                          * Low/High must in range of a 16-bit sign integer
//
//          if pData pointed to no help text then common UI automatically
//          set the (# - #) as help line
//
//      BegCtrlID  = udarrow Group Box ID
//      BegCtrlID+1= udarrow title static title ID
//      BegCtrlID+2= udarrow's editbox ID
//      BegCtrlID+3= udarrow icon control ID
//      BegCtrlID+4= udarrow postfix static text ID
//      BegCtrlID+5= udarrow help static text ID
//      BegCtrlID+6= udarrow arrow ID
//      BegCtrlID+7= Extended Check Box/Push Button control ID
//      BegCtrlID+8= Extended Check Box/Push Button Icon control ID
//
//      * OPTITEM's 'Sel' is the selection index between Low/High range
//      * Style field in the OPTPARAM is ignored
//
//
// TVOT_TRACKBAR:
//      Count       = 3
//      pOptParam[0]=Pointer to the text for the selection postfix and ICONS
//      pOptParam[1]=Pointer to the <Low Range Text> and
//                      IconID = (SHORT)Low range of the trackbar control
//                      lParam = (SHORT)High range of the trackbar control
//
//                          * Low/High must in range of a 16-bit sign integer
//
//      pOptParam[2]=Pointer to the <High Range Text> and
//                      IconID = 'Sel' multiply factor for display
//                      lParam = Page Size (increment)
//
//          if pData pointed to NULLt then common UI automatically
//          set the Low/High range.
//
//      BegCtrlID  = trackbar Group Box ID
//      BegCtrlID+1= trackbar static title ID
//      BegCtrlID+2= trackbar(horizontal) ID (static FRAME to define size)
//      BegCtrlID+3= trackbar icon control ID
//      BegCtrlID+4= trackbar low range text control ID
//      BegCtrlID+5= trackbar high range text control ID
//      BegCtrlID+6= trackbar postfix ID
//      BegCtrlID+7= Extended Check Box/Push Button control ID
//      BegCtrlID+8= Extended Check Box/Push Button Icon control ID
//
//      * OPTITEM's 'Sel' is the selection index between Low/High range
//      * The multiply factor is used to multiply the current select with
//        this factor and display it. typically this is one
//      * the tick frequency is automatically to set to PageSize increment
//      * Style field in the OPTPARAM is ignored
//
//
// TVOT_SCROLLBAR:
//      Count       = 3
//      pOptParam[0]=Pointer to the text for the selection postfix and ICONS
//      pOptParam[1]=Pointer to the <Low Range Text> and
//                      IconID = (SHORT)Low range of the scrollbar control
//                      lParam = (SHORT)High range of the scroll control
//
//                          * Low/High must in range of a 16-bit sign integer
//
//      pOptParam[2]=Pointer to the <High Range Text> and
//                      IconID = 'Sel' multiply factor for display
//                      lParam = Page Size (increment)
//
//          if pData pointed to NULLt then common UI automatically
//          set the Low/High range.
//
//
//      BegCtrlID  = scrollbar(horizontal) group box ID
//      BegCtrlID+1= scrollbar(horizontal) static text ID
//      BegCtrlID+2= scrollbar(horizontal) ID
//      BegCtrlID+3= scrollbar icon control ID
//      BegCtrlID+4= scrollbar low range text control ID
//      BegCtrlID+5= scrollbar high range text control ID
//      BegCtrlID+6= scrollbar postfix control ID
//      BegCtrlID+7= Extended Check Box/Push Button control ID
//      BegCtrlID+8= Extended Check Box/Push Button Icon control ID
//
//      * OPTITEM's 'Sel' is the selection index between Low/High range
//      * The multiply factor is used to multiply the current select with
//        this factor and display it. typically this is one
//      * Style field in the OPTPARAM is ignored
//
//
//
// TVOT_LISTBOX:
// TVOT_COMBOBOX:
//      Count       = N
//      pOptParam[0]=pointer to the first OPTPARAM (pData=string pointer)
//      pOptParam[1]=pointer to the second OPTPARAM (pData=string pointer)
//          .
//          .
//      pOptParam[N-1]=pointer to the N item string
//
//      BegCtrlID  = Listbox/ComboBox group box ID
//      BegCtrlID+1= Listbox/ComboBox static title ID
//      BegCtrlID+2= Listbox/Combobox ID
//      BegCtrlID+3= Listbox/Combobox icon control ID
//      BegCtrlID+4= Extended Check Box/Push Button control ID
//      BegCtrlID+5= Extended Check Box/Push Button Icon control ID
//
//      * for TVOT_LISTBOX, TVOT_COMBOBOX, the field used as
//
//          Style =Ignored by the common UI
//          pData =Pointer to the name of item
//          IconID=Icon resource ID for the item
//          lParam=ignored by the common UI
//
//      * Only SINGLE selection is supported, to do a multiple selction use
//        multiple OPTITEM and create a header for it
//
//      * an OTLBCBS_SORT style can be specified in the OPTTYPE's LBCBStyle
//        field, and the listbox or combobox will be sorted according to the
//        item's string.
//
//      * OPTITEM's 'Sel' is the selection index between Low/High range
//
//      * for TVOT_LISTBOX, TVOT_COMBOBOX, when it get received the keyboard
//        focus then common UI will call callback function (only if
//        OPTIF_CALLBACK bit set) with reason of CPSUICB_REASON_LBCB_ACTIVE,
//        this give caller a chance to modify following structure flags/pdata
//        which associate with the current OPTITEM.   The caller's callback
//        function can ONLY modify the flags/data specified here.
//
//          OPTTYPE pointed by the pOptType from OPTITEM
//
//              Style: OTS_LBCB_SORT
//                     OTS_LBCB_INCL_ITEM_NONE
//
//          OPTPARAMs pointed by the pOptParam from the OPTTYPE
//
//              Flags: OPTPF_HIDE
//                     OPTPF_DISABLED
//
//              pData: change string name
//
//
//      * The TVOT_COMBOBOX typically only used in the tree-view if there is
//        only one selection available for that item, when there is only one
//        item then dropdown list will not enabled by the common UI
//
//
//
// TVOT_EDITBOX:
//      Count       = 2
//      pOptParam[0]=Pointer to the text of postfix and ICONS
//      pOptParam[1]=Pointer to the help line text above the control and
//                      IconID = Edit buffer sie in character pointed by pSel
//                                 this is including the NULL terminator.
//                      lParam = ignored.
//
//      BegCtrlID  = editBox group Box ID
//      BegCtrlID+1= editBox static title ID
//      BegCtrlID+2= editbox ID
//      BegCtrlID+3= editbox icon control ID
//      BegCtrlID+4= editbox postfix ID
//      BegCtrlID+5= editbox help ID
//      BegCtrlID+6= Extended Check Box/Push Button control ID
//      BegCtrlID+7= Extended Check Box/Push Button Icon control ID
//
//      * Style field is ignored
//
//      * pSel in the OPTITEM is the pointer to the editing string, the pSel
//        must pointed to a buffer eqaul or larger than the count of the buffer
//        (pOptParam[1]->IconID) size
//
//
// TVOT_PUSHBUTTON:
//      Count       = 1
//
//      BegCtrlID  = push button group box ID
//      BegCtrlID+1= push button static text ID (Not used by common UI)
//      BegCtrlID+2= push button ID
//      BegCtrlID+3= push button icon control ID
//      BegCtrlID+4= Extended Check Box/Push Button control ID
//      BegCtrlID+5= Extended Check Box/Push Button Icon control ID
//
//
//      PUSHBUTTON_TYPE_xxx specified the action and content of pData in the
//      pOptParam[0] as describe in the following
//
//          PUSHBUTTON_TYPE_DLGPROC
//
//              This push button is designed to bring up caller's dialog box
//
//                  pOptParam[0].pData  = Caller's DLGPROC
//                  pOptParam[0].Style  = PUSHBUTTON_TYPE_DLGPROC
//                  pOptParam[0].IconID = Icon resource ID
//                  pOptParam[0].lParam = Caller's DIALOG resource template ID
//                                        or handle to the DLGTEMPLATE depends
//                                        on the OPTPF_USE_HDLGTEMPLATE flag
//
//
//              The 'lParam' passed to the DLGPROC's WM_INITDIALOG is the
//              CPSUICBPARAM structure pointer, and the reason field is set
//              to CPSUICB_REASON_DLGPROC.
//
//
//          PUSHBUTTON_TYPE_CALLBACK
//
//              This push button is designed to have caller process the item
//              which cannot accomplished with the dialog box along.
//
//                  pOptParam[0].pData  = CPSUICALLBACK function pointer
//                  pOptParam[0].Style  = PUSHBUTTON_TYPE_CALLBACK
//                  pOptParam[0].IconID = Icon resource ID
//                  pOptParam[0].lParam = Not Used;
//
//              Durning the callback the Reason field in CPSUICBPARAM will
//              set to CPSUICB_REASON_PUSHBUTTON.
//
//              ** If pOptParam[0].pData callback function is NULL then common
//                 UI will call the pfnCallBack pointer set in the
//                 COMPROPSHEETUI structure if it is not NULL
//
//              ** The callback function should put the result of the callback
//                 in the pSel/Sel of OPTITEM associate with the push button
//
//          PUSHBUTTON_TYPE_HTCLRADJ
//
//              This push button is designed to bring up halftone color
//              adjustment dialog box.
//
//                  pOptParam[0].pData  = pointer to COLORADJUSTMENT structure
//                  pOptParam[0].Style  = PUSHBUTTON_TYPE_HTCLRADJ
//                  pOptParam[0].IconID = Icon resource ID
//                  pOptParam[0].lParam =  Not Used;
//
//
//          PUSHBUTTON_TYPE_HTSETUP
//
//              This push button is designed to bring up device halftone
//              setup dialog box.
//
//                  pOptParam[0].pData  = pointer to DEVHTADJDATA structure
//                  pOptParam[0].Style  = PUSHBUTTON_TYPE_HTSETUP
//                  pOptParam[0].IconID = Icon resource ID
//                  pOptParam[0].lParam = Not Used;
//
//
//      * 'Sel' field in the OPTITEM for the PUSHBUTTON is the last returned
//        LONG result from the called dialog box or funcitons.  The result
//        only valid if OPTIF_CHANGEONCE flag is set.  The common UI will set
//        OPTIF_CHANGEONCE if push button ever pushed.
//
//      * Since common UI donot know the meaning of the return value and
//        content of the called parameter, it is up to the caller to use
//        callback function to determine the returned result.
//
//      * When returned from the push button except push botton type
//        PUSHBUTTON_TYPE_CALLBACK common ui will call the callback function
//        if the OPTIF_CALLBACK flat is set.  The callback reason is set to
//        CPSUICB_REASON_SEL_CHANGED.
//
//      * If the passed in CPSUIF_UPDATE_PERMISSION Flags in the COMPROPSHEETUI
//        is clear then the callback function must ONLY display the dialog box
//        and not changed any OPTITEM data if OTS_PUSH_ENABLE_ALWAYS
//        flag is set in the OPTTYPE
//
//
// TVOT_CHKBOX:
//      Count               = 1
//
//      pOptparam[0].Style  = CHKBOXS_FALSE_TRUE    False/True
//                            CHKBOXS_NO_YES,       No/YES
//                            CHKBOXS_OFF_ON,       Off/ON
//                            CHKBOXS_FALSEPDATA    False/pData
//                            CHKBOXS_NO_PDATA      No/pData
//                            CHKBOXS_OFF_PDATA     Off/pData
//                            CHKBOXS_NONE_PDATA    None/pData
//      pOptParam[0].pData  = Only used if Style is CHKBOXS_NONE_PDATA
//      pOptParam[0].IconID = Icon resource ID
//      pOptParam[0].lParam = Ignored
//
//
//      BegCtrlID  = check box group ID
//      BegCtrlID+1= Check Box static text (not used by common UI)
//      BegCtrlID+2= check box button ID
//      BegCtrlID+3= check box icon control ID
//      BegCtrlID+4= Extended Check Box/Push Button control ID
//      BegCtrlID+5= Extended Check Box/Push Button Icon control ID
//
//
//  * BegCtrlID only used if the OPTITEM/OPTTYPE is belong to the the DLGPAGE
//    which has non-common UI dialog box template (DlgTemplateID in the DLGPAGE
//    is not standard DP_STD_xxx common ui dialog box template).    The common
//    UI used this ID to managed caller's dialog boxes item's selections and
//    initialization.
//
//  * for each item, it has group box ID (BegCtrlID) and static text ctronl ID
//    (BegCtrlID + 1).  The common UI will set the text in one of these two
//    control ID in followng seauence.
//
//      1) If group box control ID's window (BegCtrlID) is exist and the
//         OPTITEM's flag OPTIF_NO_GROUPBOX_NAME is not set then common UI will
//         set the pName from OPTITEM to the group box.
//
//      2) If the group box name is not set and static control ID's window
//         (BegCtrlID + 1) is exist then common UI will set the pName from
//         OPTITEM to the static text control.
//
//  * for TVOT_TRACKBAR and TVOT_SCROLLBAR, if pName in the OPTITEM is set to
//    either group box or static text control then common UI will also append
//    the current selection position of trackbar or scroll bar to the pName.
//
//  * If multiple OPTITEMs using the same POPTPARAM and need different
//    BegCtrlID for each control then then a separate OPTTYPE structure should
//    be generated but POPTPARAM pointed to the same OPTPARAM[]
//
//  * If a BegCtrlID+N is not used then skip that ID in your dialog box
//    template
//
//

#define CHKBOXS_FALSE_TRUE          0
#define CHKBOXS_NO_YES              1
#define CHKBOXS_OFF_ON              2
#define CHKBOXS_FALSE_PDATA         3
#define CHKBOXS_NO_PDATA            4
#define CHKBOXS_OFF_PDATA           5
#define CHKBOXS_NONE_PDATA          6


#define PUSHBUTTON_TYPE_DLGPROC     0
#define PUSHBUTTON_TYPE_CALLBACK    1
#define PUSHBUTTON_TYPE_HTCLRADJ    2
#define PUSHBUTTON_TYPE_HTSETUP     3


#define MAX_RES_STR_CHARS           160

//
// Common Printer UI's LPTSTR
//
// All string pointer in common printer UI structures can be either a real
// memory pointer or a string resource ID.  These are applied to LPTSTR type.
//
// The LPTSTR is defined to identify that the pointer can be a real string
// pointer or a resource ID (either common printer UI provided ID or caller's
// own resource ID).  common UI using following logic to get the final string.
//
//  LPTSTR  pData;
//
//      if ((pData & ~(ULONG_PTR)0xFFFF) != 0) then pData is a NULL terminated
//      string pointer
//
//          ELSE
//
//          (pData & (ULONG_PTR)0xFFFF) = Resource ID
//
//          if (Resource ID is within the common UI string resource ID range)
//          then it load the string from common UI DLL
//
//          ELSE
//
//              it load string from caller's resource
//
//
//  *  You can use MAKEINTRESOURCE(StrResID) to set this field
//
//  * The MAX characters loaded by the common UI from the resource is defined
//    as MAX_RES_STR_CHARS
//
//  * You cannot use LPTSTR as resource ID for the TVOT_EDITBOX style's
//    pSel in the OPTITEM, this pointer must be a real buffer pointer
//
//
//
// ICONs
//
//  Common UI using two types of Icons, One is 32x32 and the other is 16x16
//  plus if any monochrome icon with 32x32 and 16x16 sizes.
//
//  The 16x16 icon when displayed on the screen is using 16x17 pixel space,
//  this is ensure that downware adjacent icon is not crowded together.
//
//  In common UI, if you need to passed a ICON ID, it can either passed a
//  common UI's predefined ID or caller's own ICON resource ID.
//
//
//  * You can use to imagedit or any other Window icon editor to create the
//    icon, each icon file should have one unique icon resource ID which is
//    not overlay with the standard common UI IDI_CPSUI_xxx identifier.  For
//    each icon file, its should have both 32x32 and 16x16 size icon on
//    different display. (ie. monochrome).
//
//    Common UI will try to load the correct size of icon from the icon
//    resource, but it will stretch them if the size is not found.
//
//

//
// Flags for the OPTTYPE
//
//

#define OPTPF_HIDE                  0x01
#define OPTPF_DISABLED              0x02
#define OPTPF_ICONID_AS_HICON       0x04
#define OPTPF_OVERLAY_WARNING_ICON  0x08
#define OPTPF_OVERLAY_STOP_ICON     0x10
#define OPTPF_OVERLAY_NO_ICON       0x20
#define OPTPF_USE_HDLGTEMPLATE      0x40

typedef struct _OPTPARAM {
    WORD        cbSize;         // size of this structure
    BYTE        Flags;          // OPTPF_xxxx flags
    BYTE        Style;          // style use in this structure
    LPTSTR      pData;          // pointer to the data
    ULONG_PTR   IconID;         // iconID;
    LPARAM      lParam;         // parameter used
    ULONG_PTR   dwReserved[2];  // reserved dword, must be 0
    } OPTPARAM, *POPTPARAM;


//
// OPTPARAM
//
//  The OPTPARAM structure is used to describe each slectable item in the
//  common UI such as 'letter', 'legal' in the form slection list box
//
//  cbSize      - size of this structure
//
//  Flags       - defined as OPTPF_xxxx
//
//                  OPTPF_HIDE
//
//                      Specified hide this listed selection item and not
//                      availabe for user to select. This only available to
//                      following TVOT_xxx types
//
//                          TVOT_3STATES
//                          TVOT_LISTBOX
//                          TVOT_COMBOBOX
//
//                      If all the seclection items are OPTPF_HIDE then the
//                      OPTITEM is automatically hided by the common UI, if
//                      TVOT_3STATES has 2 states hide then an error is
//                      returned
//
//
//                  OPTPF_DISABLED
//
//                      Specified this listed selection item is disabled and
//                      not availabe for user to select.   This only available
//                      to following TVOT_xxx types
//
//                          TVOT_2STATES
//                          TVOT_3STATES
//                          TVOT_LISTBOX
//                          TVOT_COMBOBOX
//
//
//                  OPTPF_ICONID_AS_HICON
//
//                      If this flag is set then IconID DWORD field is treated
//                      as a handle to the icon rather then the resource ID
//
//
//                  OPTPF_OVERLAY_WARNING_ICON
//
//                      If this bit is set then this OPTPARAM item's icon will
//                      be overlaied by a common UI's IDI_CPSUI_WARNING icon.
//
//
//                  OPTPF_OVERLAY_STOP_ICON
//
//                      If this bit is set then this OPTPARAM item's icon will
//                      be overlaied by a common UI's IDI_CPSUI_STOP icon.
//
//
//                  OPTPF_OVERLAY_NO_ICON
//
//                      If this bit is set then this OPTPARAM item's icon will
//                      be overlaied by a common UI's IDI_CPSUI_NO icon.
//
//
//  Style       - Style for the OPTPARAM, it depends on the TVOT_xxx type as
//                describe below
//
//                  TVOT_PUSBUTTON
//
//                      it can be one of PUSHBUTTON_TYPE_xxxx.
//
//                  other TVOT_xxxx
//
//                      this fields is not used.
//
//
//  pData       - Is either a pointer to the item name (string) or it is
//                used to describe other data.
//
//                   * If the pData in the OPTPARAM is supposed to be a static
//                     pointer to a string and the string is a common UI
//                     standard resource ID then common UI will check if pData
//                     is equal to IDS_CPSUI_NOTINSTALLED, if true then
//                     common UI will overaly a not installed icon on top of
//                     the OPTPARAM's Icon.   This will not applied to the
//                     TVOT_EDITBOX type since the pData is not a static text
//                     pointer or a string resource ID.
//
//                  ** See LPTSTR description above
//
//  IconID      - This is the icon identifier, which can be a common strandard
//                IDI_CPSUI_xxx icon ID, caller's own icon resource ID, or a
//                handle to the caller defined icon if OPTPF_ICONID_AS_HICON
//                flag is set, in any case if the IconID is zero then it
//                indicated no icon.
//
//  lParam      - Extra data used by the OPTPARAM, it depends on the TVOT_xxx
//                type.
//
//  dwReserved[]- Reserved DWORDs, must be 0
//
//


#define OPTTF_TYPE_DISABLED             0x01
#define OPTTF_NOSPACE_BEFORE_POSTFIX    0x02


#define OTS_LBCB_SORT                   0x0001
#define OTS_LBCB_PROPPAGE_LBUSECB       0x0002
#define OTS_LBCB_PROPPAGE_CBUSELB       0x0004
#define OTS_LBCB_INCL_ITEM_NONE         0x0008
#define OTS_LBCB_NO_ICON16_IN_ITEM      0x0010
#define OTS_PUSH_INCL_SETUP_TITLE       0x0020
#define OTS_PUSH_NO_DOT_DOT_DOT         0x0040
#define OTS_PUSH_ENABLE_ALWAYS          0x0080


typedef struct _OPTTYPE {
    WORD        cbSize;
    BYTE        Type;           // TVOT_xxxx type of OPTIONS
    BYTE        Flags;          // OPTTF_xxx flags
    WORD        Count;          // Count of pOptParam passed
    WORD        BegCtrlID;      // start of item's group window ID
    POPTPARAM   pOptParam;      // pointer to the OPTPARAM
    WORD        Style;          // option type style as OTS_xxxx
    WORD        wReserved[3];   // wReserved, must be 0
    ULONG_PTR   dwReserved[3];  // DWORD reserved field (must be 0)
} OPTTYPE, *POPTTYPE;


//
// OPTTYPE
//
//  The OPTTYPE structure is used to describe a set of selection and its
//  select method,  such as Form/Tray assignment.  It has a pointer to a set
//  of selection item (OPTPARAM)
//
//
//  cbSize      - size of this structure
//
//  Type        - Specified the option type using predefined ID as TVOT_xxxx
//
//  Flags       - currently only one flag is defined
//
//
//                  OPTTF_TYPE_DISABLED
//
//                      The whole OPTTYPE's OPTPARAMs are disabled, and non of
//                      the selection in the OPTTYPE can be selected
//
//
//                  OPTTF_NOSPACE_BEFORE_POSTFIX
//
//                      This bit only valid if the OPTTYPE's pOptParam item
//                      specified a postfix string as describe in the above
//                      section.  If this flag is set then it asked common UI
//                      do not add a space character before the postfix string
//                      when it combine the pName in the OPTITEM and postfix
//                      string.   Typeically this bit is not set for the
//                      postfix string, but sometime it may be required not to
//                      add a space character in front of it, such as '%'
//                      postfix string.
//
//
//  Count       - Count of item pointed by pOptParam.  Some predefined number
//                must be set according to the TVOT_XXX description.
//
//  BegCtrlID   - Only used if the OPTITEM/OPTTYPE is belong to the the DLGPAGE
//                which has non-common UI dialog box template (DlgTemplateID
//                in the DLGPAGE is not standard DP_STD_xxx common ui dialog
//                box template).    The common UI used this ID to managed
//                caller's dialog boxes item's selections and initialization.
//
//                Each OPTITEM has predefined number of window ID which
//                associated with that item, the BegCtrlID specified the start
//                control window ID.  Each control window ID in the OPTITEM
//                must have the control ID sequence as describe in the TVOT_xxx
//                above.
//
//  pOptParam   - Pointer to array of OPTPARAM to describe each selectable item
//
//  Style       - Specified the style of type of control box, certain style
//                only apply to centain type of TVOT_xxxx.
//
//                OTS_LBCB_xxx only applied to TVOT_LISTBOX, TVOT_COMBOBOX
//                OTS_PUSH_xxx only applied to TVOT_PUSHBUTTON
//
//
//                  OTS_LBCB_SORT
//
//                      Specified that the listbox or combobox item is sorted
//                      in ascending order based on the pData string
//
//
//                  OTS_LBCB_PROPAGE_LBUSECB
//
//                      Used when Type is TVOT_LISTBOX, if it specified and
//                      this OPTTYPE also on the non-treeview user defined
//                      property sheet page dialog then common UI assume
//                      control is comobobox instead of listbox on the non-
//                      treeview page
//
//
//                  OTS_LBCB_PROPAGE_CBUSELB
//
//                      Used when Type is TVOT_COMBOBOX, if it specified and
//                      this OPTTYPE also on the non-treeview user defined
//                      property sheet page dialog then common UI assume
//                      control is listbox instead of combobox on the non-
//                      treeview page
//
//
//                  OTS_LBCB_INCL_ITEM_NONE
//
//                      when this flag is specified, the common ui will
//                      automatically add a 'None' selection to the listbox or
//                      combobox.   The 'Sel' will set to -1 if 'none' is
//                      selection is selected by the user.  It will also
//                      validate the 'Sel' durning the initialization,  any
//                      out of range value will be set to -1 (None).
//
//
//                  OTS_LBCB_NO_ICON16_IN_ITEM
//
//                      By default, each listbox, combox will have a small
//                      icon (16x16) in front of item text. by specified this
//                      bit, the listbox/combobox will not includes icons
//                      in the listbox/combobox.
//
//                      If clear then it specified that in the listbox/combobox
//                      to have 16x16 Icon added to the front of each item
//
//
//                  OTS_PUSH_INCL_SETUP_TITLE
//
//                      If specified for the push button then it automatically
//                      add the 'Setup' to the end of push botton text.
//
//
//                  OTS_PUSH_NO_DOT_DOT_DOT
//
//                      If specified then common UI will not add '...' to the
//                      end of the pName in the OPTITEM and push button name
//
//
//                  OTS_PUSH_ENABLE_ALWAYS
//
//                      This flag specified that even update permissio is not
//                      allowed, it still let user push the push button, if
//                      this flag is set then callback function or dialog box
//                      proc must disable all the control which let user
//                      modified the content, but just let user view the
//                      current setting.
//
//
//  wReserved[] - Reserved fields, must be 0
//
//  dwReserved[]- Reserved fields, must be 0
//
//


//
// Following are flags for the EXTPUSH
//


#define EPF_PUSH_TYPE_DLGPROC       0x0001
#define EPF_INCL_SETUP_TITLE        0x0002
#define EPF_NO_DOT_DOT_DOT          0x0004
#define EPF_ICONID_AS_HICON         0x0008
#define EPF_OVERLAY_WARNING_ICON    0x0010
#define EPF_OVERLAY_STOP_ICON       0x0020
#define EPF_OVERLAY_NO_ICON         0x0040
#define EPF_USE_HDLGTEMPLATE        0x0080


typedef struct _EXTPUSH {
    WORD                cbSize;         // size of the structure
    WORD                Flags;          // EPCBF_xxx flags
    LPTSTR              pTitle;         // extended push botton title
    union {
        DLGPROC         DlgProc;        // pointer to the dialog box proc
        FARPROC         pfnCallBack;    // callback function pointer
        } DUMMYUNIONNAME;
    ULONG_PTR           IconID;         // icon to be used
    union {
        WORD    DlgTemplateID;          // dialog box template ID
        HANDLE  hDlgTemplate;           // handle to the dialog template
        } DUMMYUNIONNAME;
    ULONG_PTR   dwReserved[3];          // reserved field, must be 0
    } EXTPUSH, *PEXTPUSH;

//
// EXTPUSH structure is used to describe the extened push button available
// on OPTITEM/OPTITEM, each OPTTYPE can optional have either one extended check
// box or one extended push button callback.
//
//
//  cbSize          - size of this structure
//
//  Flags           - flags for the EXTPUSH as EPF_xxxx
//
//                      EPF_PUSH_TYPE_DLGPROC
//
//                          If this bit is set then it specified the extended
//                          push button is type of DLGPROC and DlgProc and
//                          DlgTemplateID is valid for common UI to call.
//
//                          If this bit is clear then it specfied the extended
//                          push button is the callback style and pfnCallBack
//                          should be called by the common UI
//
//
//                      EPF_INCL_SETUP_TITLE
//
//                          If specified for the extended push button then it
//                          automatically add the 'Setup' to the end of
//                          extended push button's title
//
//
//                      EPF_NO_DOT_DOT_DOT
//
//                          If specified then common UI will not add '...' to
//                          the end of the pTitle in the EXTPUSH.
//
//
//                      EPF_ICONID_AS_HICON
//
//                          If this flag is set then IconID DWORD field is
//                          treated as a handle to the icon rather then the
//                          resource ID.
//
//
//                      EPF_OVERLAY_WARNING_ICON
//
//                          If this bit is set then this EXTPUSH's icon will be
//                          overlaied by a common UI's IDI_CPSUI_WARNING icon.
//
//
//                      EPF_OVERLAY_STOP_ICON
//
//                          If this bit is set then this EXTPUSH's icon will be
//                          overlaied by a common UI's IDI_CPSUI_STOP icon.
//
//
//                      EPF_OVERLAY_NO_ICON
//
//                          If this bit is set then this EXTPUSH's icon will be
//                          overlaied by a common UI's IDI_CPSUI_NO icon.
//
//
//  pTitle          - Pointed to extended push botton title
//
//                      ** See LPTSTR description above
//
//  DlgProc         - Pointer to the DLGPROC function supplied by the caller.
//                    When user push the button the common UI will call
//                    DialogBoxParam() with this fucction pointer and passed
//                    CPSUICBPARAM structure pointer to the WM_INITDIALOG with
//                    the Reason set to CPSUICB_REASON_EXTPUSH.  If this
//                    filed is NULL then common UI assumed that EXTPUSH is
//                    disabled (OPTIF_EXT_DISABLED | OPTIF_EXT_HIDE), this
//                    fields only used if EPF_PUSH_TYPE_DLGPROC flag is set
//
//  pfnCallBack     - Pointer to CPSUICALLBACK function, this only used if
//                    EPF_PUSH_TYPE_DLGPROC bit is clear, duringing callback
//                    it passed the CPSUICBPARAM pointer as parameter
//
//  IconID          - This is the icon identifier, which can be a common
//                    strandard IDI_CPSUI_xxx icon ID, caller's own icon
//                    resource ID, or a handle to the caller defined icon if
//                    EPF_ICONID_AS_HICON flag is set, in any case if the
//                    IconID is zero then it indicated no icon.
//
//  DlgTemplateID   - Specified the ressource ID for the dilaog box. If the
//                    DlgTemplateID = 0 then common UI will call the DlgProc
//                    with following parameter.
//
//                      DlgProc(hDlg, WM_USER, NULL, (LPARAM)pCPSUICBPaam);
//
//  hDlgTemplate    - Handle to the DLGTEMPLATE which will be use for pop up
//                    dialog box
//
//  wReserved[]     - WORD reserved field, must be 0
//
//  dwReserved[]    - DWORD reserved field, must be 0
//
//
//


//
// Following are flags for the EXTCHKBOX
//

#define ECBF_CHECKNAME_AT_FRONT         0x0001
#define ECBF_CHECKNAME_ONLY_ENABLED     0x0002
#define ECBF_ICONID_AS_HICON            0x0004
#define ECBF_OVERLAY_WARNING_ICON       0x0008
#define ECBF_OVERLAY_ECBICON_IF_CHECKED 0x0010
#define ECBF_OVERLAY_STOP_ICON          0x0020
#define ECBF_OVERLAY_NO_ICON            0x0040
#define ECBF_CHECKNAME_ONLY             0x0080


typedef struct _EXTCHKBOX {
    WORD        cbSize;         // size of the structure
    WORD        Flags;          // ECBF_xxx flags
    LPTSTR      pTitle;         // extended checkbox title
    LPTSTR      pSeparator;     // pointer to separator string for treeview
    LPTSTR      pCheckedName;   // string to be displayed when checked
    ULONG_PTR   IconID;         // icon to be used
    WORD        wReserved[4];   // reserved word, must be 0
    ULONG_PTR   dwReserved[2];  // reserved field, must be 0
    } EXTCHKBOX, *PEXTCHKBOX;


//
// EXTCHKBOX structure is used to describe the extened check box available on
// OPTITEM/OPTITEM, each OPTTYPE can optional have one extended check box.
// When using EXTCHKBOX the selection item can be checked or not checked
// based on user input.
//
//
//  cbSize      - size of this structure
//
//  Flags       - flags for the EXTCHKBOX as ECBF_xxxx
//
//                  ECBF_CHECKNAME_AT_FRONT
//
//                      This flag specified how to display item's name and its
//                      checked name in the treeview display.   If this flag is
//                      set then the checked name is display in front of
//                      separator name, otherwise the checked name is displayed
//                      after the separator.  For Example.
//
//                      Flag Set:   pCheckedName pSeparator SelectName
//                      Flag Clear: SelectName pSeparator pCheckedName
//
//
//                  ECBF_CHECKNAME_ONLY_ENABLED
//
//                      If set then it specified that in the treeview display,
//                      it will only show the pCheckedName if this extended
//                      check box is visible and enabled.  Some items may not
//                      desired to display the pCheckedName if the extended
//                      check box is disabled, such as Copy/Collate checkbox.
//
//
//                  ECBF_ICONID_AS_HICON
//
//                      If this flag is set then IconID DWORD field is treated
//                      as a handle to the icon rather then the resource ID
//
//
//                  ECBF_OVERLAY_WARNING_ICON
//
//                      If this bit is set then this EXTCHKBOX's icon will
//                      be overlaied by a common UI's IDI_CPSUI_WARNING icon.
//
//
//                  ECBF_OVERLAY_ECBICON_IF_CHECKED
//
//                      This bit specified to overlay the ExtChkBox's Icon to
//                      the OPTITEM's icon (or OPTPARAM) if the the extended
//                      checked box is checked
//
//
//                  ECBF_OVERLAY_STOP_ICON
//
//                      If this bit is set then this EXTCHKBOX's icon will
//                      be overlaied by a common UI's IDI_CPSUI_STOP icon.
//
//
//                  ECBF_OVERLAY_NO_ICON
//
//                      If this bit is set then this EXTCHKBOX's icon will
//                      be overlaied by a common UI's IDI_CPSUI_NO icon.
//
//
//  pTitle      - Pointed to extended check box title
//
//                  ** See LPTSTR description above
//
//  pSeparator  - Pointer to the separator to be used in the treeview
//                display or the static title control in the non-treeview
//                page,
//
//  pCheckedName- Pointed to the name to be displayed in the treeview if item
//                is checked.  pCheckedName is added according to the
//                pSeparator and the ECBF_CHECKNAME_AT_FRONT flags.
//
//                  * If the pCheckedName is equal to IDS_CPSUI_NOTINSTALLED
//                    then common UI will automatically overaly a not installed
//                    icon on top of the extended check box Icon.
//
//                      ** See LPTSTR description above
//
//  IconID      - This is the icon identifier, which can be a common strandard
//                IDI_CPSUI_xxx icon ID, caller's own icon resource ID, or a
//                handle to the caller defined icon if ECBF_ICONID_AS_HICON
//                flag is set, in any case if the IconID is zero then it
//                indicated no icon.
//
//  wReserved[] - WORD reserved field, must be 0
//
//  dwReserved[]- DWORD reserved field, must be 0
//


//
// Following the the Flags for the OPTITEM
//

#define OPTIF_COLLAPSE              0x00000001L
#define OPTIF_HIDE                  0x00000002L
#define OPTIF_CALLBACK              0x00000004L
#define OPTIF_CHANGED               0x00000008L
#define OPTIF_CHANGEONCE            0x00000010L
#define OPTIF_DISABLED              0x00000020L
#define OPTIF_ECB_CHECKED           0x00000040L
#define OPTIF_EXT_HIDE              0x00000080L
#define OPTIF_EXT_DISABLED          0x00000100L
#define OPTIF_SEL_AS_HICON          0x00000200L
#define OPTIF_EXT_IS_EXTPUSH        0x00000400L
#define OPTIF_NO_GROUPBOX_NAME      0x00000800L
#define OPTIF_OVERLAY_WARNING_ICON  0x00001000L
#define OPTIF_OVERLAY_STOP_ICON     0x00002000L
#define OPTIF_OVERLAY_NO_ICON       0x00004000L
#define OPTIF_INITIAL_TVITEM        0x00008000L
#define OPTIF_HAS_POIEXT            0x00010000L

#define OPTIF_MASK                  0x0001ffffL


#define DMPUB_NONE                  0
#define DMPUB_FIRST                 1

#define DMPUB_ORIENTATION           1
#define DMPUB_SCALE                 2
#define DMPUB_COPIES_COLLATE        3
#define DMPUB_DEFSOURCE             4
#define DMPUB_PRINTQUALITY          5
#define DMPUB_COLOR                 6
#define DMPUB_DUPLEX                7
#define DMPUB_TTOPTION              8
#define DMPUB_FORMNAME              9
#define DMPUB_ICMMETHOD             10
#define DMPUB_ICMINTENT             11
#define DMPUB_MEDIATYPE             12
#define DMPUB_DITHERTYPE            13
#define DMPUB_OUTPUTBIN             14
#define DMPUB_QUALITY               15
#define DMPUB_NUP                   16
#define DMPUB_PAGEORDER             17

#define DMPUB_LAST                  17

#define DMPUB_OEM_PAPER_ITEM        97
#define DMPUB_OEM_GRAPHIC_ITEM      98
#define DMPUB_OEM_ROOT_ITEM         99
#define DMPUB_USER                  100

#define MAKE_DMPUB_HIDEBIT(DMPub)   (DWORD)(((DWORD)0x01 << ((DMPub) - 1)))
#define IS_DMPUB_HIDDEN(dw, DMPub)  (BOOL)((DWORD)(dw) &                    \
                                           MAKE_DMPUB_HIDEBIT(DMPub))

//
// DMPUB_xxxx is used in OPTITEM to identify if the item is a DEVMODE public
// field. Following it identify which field correspond to the DMPUB_xxxx
//
//
//  DMPUB_ORIENTATION   - dmOrientation
//
//  DMPUB_SCALE         - dmScale
//
//  DMPUB_COPIES_COLLATE- dmCopies/dmCollate
//
//  DMPUB_DEFSOURCE     - dmDefSource    (Should only used form by caller)
//
//  DMPUB_PRINTQUALITY  - dmPrintQuality
//
//  DMPUB_COLOR         - dmColor
//
//  DMPUB_DUPLEX        - dmDuplex
//
//  DMPUB_TTOPTION      - dmTTOption
//
//  DMPUB_FORMNAME      - dmFormName
//
//  DMPUB_ICMMETHOD     - dmICMMethod
//
//  DMPUB_ICMINTENT     - dmICMIntent
//
//  DMPUB_MEDIATYPE     - dmMediaType
//
//  DMPUB_DITHERTYPE    - dmDitherType
//
//  DMPUB_USER          - Anything greater than or equal to DMPUB_USER can be
//                        used by the caller.
//
//  DMPUB_OUTPUTBIN     - Private
//
//  DMPUB_QUALITY       - Private
//
//  DMPUB_NUP           - Private
//
//  DMPUB_PAGEORDER     - Private
//
// When common UI is called for the 'Document Properties' (DEVMODE), it will
// group some of public items together simillar to the following in the
// treeview. How it group is common UI version dependent and caller should not
// concern its placement
//
//      Paper/Output                (Add in by the common UI)
//        Document Form             (DMPUB_FORMNAME)
//        Output Bin                (DMPUB_OUTPUTBIN)
//        Orientation               (DMPUB_ORIENTATION)
//        Source                    (DMPUB_DEFSOURCE)
//        Media                     (DMPUB_MEDIATYPE)
//        Number of Copies          (DMPUB_COPIES_COLLATE)
//        Page Order                (DMPUB_PAGEORDER)
//        Page Per Sheet            (DMPUB_NUP)
//        Duplex                    (DMPUB_DUPLEX)
//
//      Graphic                     (Add in by the common UI)
//        Print Quality             (DMPUB_PRINTQUALITY)
//        Quality Settings          (DMPUB_QUALITY)
//        Color                     (DMPUB_COLOR)
//          Image Color Matching    (Add in by the common UI)
//              ICM Method          (DMPUB_ICMMETHOD)
//              ICM Intent          (DMPUB_ICMINTENT)
//        Scaling                   (DMPUB_SCALE)
//        Dithering                 (DMPUB_DITHERTYPE)
//        TrueType Option           (DMPUB_TTOPTION)
//
//      Options
//        Halftone Color Adjustment...
//        ALL Other Caller's Document sticky options
//
//
//  For 'Document Properties' the standard page 1 (user friendly page) will
//  consist following items if it appear in the OPTITEM array passed by the
//  caller.   These items must have following predefined TVOT_xxx type
//  defined here and specified in the OPTTYPE's Type field.
//
//  All DMPUB_xxx (except >= DMPUB_USER) public ID must have following
//  TVOT_xxxx type specified, else a CPDU_INVALID_DMPUB_TVOT error is returned
//
//      DMPUB_ORIENTATION       - TVOT_2STATES/TVOT_3STATES
//      DMPUB_SCALE             - TVOT_UDARROW
//      DMPUB_COPIES_COLLATE    - TVOT_UDARROW + EXTCHKBOX (Collate)
//      DMPUB_DEFSOURCE         - TVOT_LISTBOX
//      DMPUB_PRINTQUALITY      - TVOT_LISTBOX
//      DMPUB_COLOR             - TVOT_2STATES
//      DMPUB_DUPLEX            - TVOT_2STATES/TVOT_3STATES
//      DMPUB_TTOPTION          - TVOT_LISTBOX
//      DMPUB_FORMNAME          - TVOT_LISTBOX
//      DMPUB_ICMMETHOD         - TVOT_2STATES/TVOT_3STATES
//      DMPUB_ICMINTENT         - TVOT_2STATES/TVOT_3STATES
//      DMPUB_MEDIATYPE         - TVOT_LISTBOX
//      DMPUB_DITHERTYPE        - TVOT_LISTBOX
//
//


#define OIEXTF_ANSI_STRING      0x0001

typedef struct _OIEXT {
    WORD        cbSize;
    WORD        Flags;
    HINSTANCE   hInstCaller;
    LPTSTR      pHelpFile;
    ULONG_PTR   dwReserved[4];
    } OIEXT, *POIEXT;

//
// OIEXT is a data structure used as extension to the OPTITEM data structure
//
//
//  cbSize      - sizeof this structure
//
//  Flags       - One or more of OIEXTF_xxxx may be specified.
//
//                  OIEXTF_ANSI_STRING
//
//                      Specified that LPTSTR in this data structure is a ansi
//                      string (not UNICODE).  This bit only checked if the
//                      LPTSTR is not the resource string ID
//
//  hInstCaller - DLL instance handle, when this hInst is not NULL then all
//                resource string and icon loading for this OPTITEM and its
//                OPTTYPE, OPTPARAM are loaded from this hInstCaller Handle.
//                If this filed is NULL then it will use the hInstCaller handle
//                specified in the COMPROPSHEETUI data structure
//
//  pHelpFile   - Resource string ID or pointer to the help file for this
//                OPTITEM.  If this pointer is NULL then help file for the
//                help index is assume specified in the pHelpFile field in the
//                COMPROPSHEETUI data structure.
//
//  dwReserved  - These fields are not used now, and must 0
//


typedef struct _OPTITEM {
    WORD        cbSize;                 // size of this structure
    BYTE        Level;                  // level in the tree view
    BYTE        DlgPageIdx;             // Index to the pDlgPage
    DWORD       Flags;                  // OPTIF_xxxx flags
    ULONG_PTR   UserData;               // caller's own data
    LPTSTR      pName;                  // name of the item
    union {
        LONG    Sel;                    // current selection (index)
        LPTSTR  pSel;                   // current selection (pStr)
        } DUMMYUNIONNAME;
    union {
        PEXTCHKBOX  pExtChkBox;         // Pointer to EXTCHKBOX structure
        PEXTPUSH    pExtPush;           // Pointer to EXTPUSH
        } DUMMYUNIONNAME2;
    POPTTYPE    pOptType;               // pointer to OPTTYPE structure
    DWORD       HelpIndex;              // Help file index
    BYTE        DMPubID;                // Devmode public filed ID
    BYTE        UserItemID;             // caller's own item ID
    WORD        wReserved;              // reserved WORD field, must be 0
    POIEXT      pOIExt;                 // Optitem extension pointer
    ULONG_PTR   dwReserved[3];          // reserved DWORD fields (must be 0)
    } OPTITEM, *POPTITEM;

//
// OPTITEM is to describe each treeview item's name, selection type and
// possible selection
//
//  cbSize          - sizeof this structure
//
//  Level           - The level in the treeview, the root should have lowest
//                    number and number should start with level 0.  the maximum
//                    number of levels are 256.
//
//  DlgPageIdx      - Zero-based index to the DLGPAGE araay pointee by
//                    pDlgPage. The Maximum index is MAX_DLGPPAGE_COUNT, if
//                    pDlgPage is a standard CPSUI_PDLGPAGE_xxxx then this
//                    field is automatically set the common UI
//
//  Flags           - OPTIF_xxxx flags as describe above
//
//                      OPTIF_COLLAPSE
//
//                          Collaspe treeview item and its children so it is
//                          not expanded initially.
//
//
//                      OPTIF_HIDE
//
//                          Hide this item from the treeview
//
//
//                      OPTIF_CALLBACK
//
//                          Callback to the caller when user making some
//                          changes a pointer (pfnCallBack) must provided and
//                          process as defined by the common UI.
//
//
//                      OPTIF_CHANGED
//
//                          This item was changed and need to re-display. this
//                          flag only used when caller returned from callback
//                          funciton.
//
//
//                      OPTIF_CHANGEONCE
//
//                          This item has been changed at least once.
//
//
//                      OPTIF_DISABLED
//
//                          Disable this item so it become not selectable.
//
//
//                      OPTIF_ECB_CHECKED
//
//                          Specified the associated extended check box is
//                          in checked state.
//
//
//                      OPTIF_EXT_HIDE
//
//                          Hide the extended check box/extended push botton.
//
//
//                      OPTIF_EXT_DISABLED
//
//                          The Extended check box/push botton is disabled and
//                          not selectable
//
//
//                      OPTIF_SEL_AS_HICON
//
//                          This flag only used if this item has no type,
//                          pOptType=NULL that is, when pOptType is NULL then
//                          'Sel' field is the IconID. if flag is set then it
//                          indicate 'pSel' is the Icon handle rather
//                          than the icon resource ID specified in Sel.
//
//
//                      OPTIF_EXT_IS_EXTPUSH
//
//                          Specified that pExtPush should be used when this
//                          pointer is not NULL, if this pointer is not NULL
//                          and this flag is clear then pExtChkBox is assumed.
//
//
//                      OPTIF_NO_GROUPBOX_NAME
//
//                          Specified that do not overwrite the group box title
//                          text, if group box ID is defined. See the TVOT_xx
//                          description above.
//
//
//                      OPTIF_OVERLAY_WARNING_ICON
//
//                          If this bit is set then this header OPTITEM's icon
//                          will be overlaied by a common UI's
//                          IDI_CPSUI_WARNING icon.  This bit only used if this
//                          item has no type, pOptType is NULL that is.
//
//
//                      OPTIF_OVERLAY_STOP_ICON
//
//                          If this bit is set then this header OPTITEM's icon
//                          will be overlaied by a common UI's IDI_CPSUI_STOP
//                          icon.  This bit only used if this item has no type,
//                          pOptType is NULL that is.
//
//
//                      OPTIF_OVERLAY_NO_ICON
//
//                          If this bit is set then this header OPTITEM's icon
//                          will be overlaied by a common UI's IDI_CPSUI_NO
//                          icon.  This bit only used if this item has no type,
//                          pOptType is NULL that is.
//
//
//                      OPTIF_INITIAL_TVITEM
//
//                          Specified that this item will be the initial item
//                          to be selected and display on the treeview page.
//                          If the selected item is currently a child or
//                          collapse then common UI will expand the selection
//                          then scroll it into view.
//
//                          If this flag is clear or the set item is in hide
//                          status common UI will pick the initial item to
//                          display.
//
//                      OPTIF_HAS_POIEXT
//
//                          Specified that pOIExt field is a valid pointer that
//                          points to OIEXT data structure.  The pOIExt only
//                          used by the common UI if this bit is set.
//
//
//  UserData        - a 32-bit number used by the caller and common UI will not
//                    modify it.
//
//  pName           - Pointer to the item's name, such as 'Upper Tray',
//                    'Memory' or it is used as data as describe in
//                    OPTPARAM/OPTTYPE structure
//
//                      ** See LPTSTR description above
//
//  pSel
//  Sel             - Current selection for this item. This is a union field
//                    which can be a pointer to a string or a LONG index
//                    selection.
//
//                      ** If pOptType field is NULL then 'Sel' is the icon ID
//                         to be used for the header.
//
//  pExtPush
//  pExtChkBox      - Pointer to either EXTPUSH or EXTCHKBOX data structure,
//                    if this pointer is NULL then this item does not have
//                    ectended check box/push botton associate with it.
//
//                    When an extended check box is associate with the
//                    OPTTYPE, the OPTIF_EXT_IS_EXTPUSH must not set, the
//                    OPTIF_ECB_CHECKED flag specified if the extended check
//                    box is checked or not checked.
//
//                    When an Extended push botton is associated with the
//                    OPTTYPE, the OPTIF_EXT_IS_EXTPUSH flag must set.
//
//                    The following flags are used in both EXTCHKBOX or
//                    EXTPUSH
//
//                      OPTIF_EXT_HIDE,
//                      OPTIF_EXT_DISABLED
//                      OPTIF_EXT_CHANGEONCE
//
//
//  pOptType        - Pointer to the OPTTYPE structure to describe the display
//                    and selections of the item.   If this pointer is NULL
//                    then this this item does not have any selection. and it
//                    is used as sub-items' header.
//
//                      * When pOptType is NULL then the 'Sel' is the Icon ID.
//
//
//  HelpIndex       - a index to the help file for context sensitive help
//                    if HelpInex=0 then there is no help for this item
//
//  DMPubID         - specified if this item is one of the public fields in the
//                    DEVMODE structure and supported by the common UI.
//
//                      DMPUB_NONE              - Not DEVMODE public fields
//                      DMPUB_ORIENTATION       - dmOrientation
//                      DMPUB_SCALE             - dmScale
//                      DMPUB_COPIES_COLLATE    - dmCopies/dmCollate
//                      DMPUB_DEFSOURCE         - dmDefSource
//                      DMPUB_PRINTQUALITY      - dmPrintQuality
//                      DMPUB_COLOR             - dmColor
//                      DMPUB_DUPLEX            - dmDuplex
//                      DMPUB_TTOPTION          - dmTTOption
//                      DMPUB_FORMNAME          - dmFormName
//                      DMPUB_ICMMETHOD         - dmICMMethod
//                      DMPUB_ICMINTENT         - dmICMIntent
//                      DMPUB_MEDIATYPE         - dmMediaType
//                      DMPUB_DITHERTYPE        - dmDitherType
//
//                      ** for most of DMPUB_FIRST to DMPUB_LAST each OPTITEM's
//                         pName is automatically set to the standard
//                         IDS_CPSUI_xxx for the consistancy reason, the
//                         standard pName is set according to following table.
//
//                          DMPUB_ORIENTATION    - IDS_CPSUI_ORIENTATION
//                          DMPUB_SCALE          - IDS_CPSUI_SCALING
//                          DMPUB_COPIES_COLLATE - IDS_CPSUI_COPIES
//                          DMPUB_DEFSOURCE      - IDS_CPSUI_SOURCE
//                          DMPUB_PRINTQUALITY   - IDS_CPSUI_PRINTQUALITY
//                                                 IDS_CPSUI_RESOLUTION
//                          DMPUB_COLOR          - IDS_CPSUI_COLOR_APPERANCE
//                          DMPUB_DUPLEX         - IDS_CPSUI_DUPLEX
//                          DMPUB_TTOPTION       - IDS_CPSUI_TTOPTION
//                          DMPUB_FORMNAME       - IDS_CPSUI_FORMNAME
//                          DMPUB_ICMMETHOD      - IDS_CPSUI_ICMMETHOD
//                          DMPUB_ICMINTENT      - IDS_CPSUI_ICMINTENT
//                          DMPUB_MEDIATYPE      - IDS_CPSUI_MEDIA
//                          DMPUB_DITHERTYPE     - IDS_CPSUI_DITHERING
//
//                          for DMPUB_PRINTQUALITY, if the pName is not one of
//                          IDS_CPSUI_PRINTQUALITY or IDS_CPSUI_RESOLUTION then
//                          common UI will automatically default the pName to
//                          IDS_CPSUI_RESOLUTION.
//
//                          Each pData (OPTPARAM) selection in OPTPARAM which
//                          OPTITEM's pOptType pointed to should use as much
//                          as IDS_CPSUI_xxx standard name as possible.
//
//
//                      ** for DMPUB_COPIES_COLLATE the common UI automatically
//                         doing the following before the callback
//
//                          1) Enable/Disable the collate extended check box if
//                             OPTIF_EXT_HIDE is not specified and pExtChkBox
//                             is not NULL in the OPTITEM.
//
//                          2) Automatically change the postfix for this item
//                             to be 'Copy' if selection is one, and 'Copies'
//                             if selection is greater than one in the treeview
//                             page, and it will also set the postfix in
//                             standard document property page if the postfix
//                             ID is provided (BegCtrlID + 4)
//
//
//                      ** for DMPUB_COLOR the common UI automatically doing
//                         the following before the callback, the gray
//                         selection must be Sel=0 and Color slection must be
//                         Sel=1
//
//                          1) Calling halftone color adjustment with current
//                             color/mono selection
//
//                          2) Disable ICM when color is not selected
//
//
//                      ** Please see above DMPUB_xx description for details.
//
//  UserItemID      - This is a byte ID intented to be used by the caller to
//                    identify the item
//
//  wReserved       - WORD reserved. Must be zero
//
//  pOIExt          - Pointer to the OIEXT data structure to specified that
//                    it has a OPTITEM extenstion structure.
//
//  dwReserved[]    - DWORD reserved and must be 0
//
//

//
// predefined ID for call back reason
//

#define CPSUICB_REASON_SEL_CHANGED      0
#define CPSUICB_REASON_PUSHBUTTON       1
#define CPSUICB_REASON_ECB_CHANGED      2
#define CPSUICB_REASON_DLGPROC          3
#define CPSUICB_REASON_UNDO_CHANGES     4
#define CPSUICB_REASON_EXTPUSH          5
#define CPSUICB_REASON_APPLYNOW         6
#define CPSUICB_REASON_OPTITEM_SETFOCUS 7
#define CPSUICB_REASON_ITEMS_REVERTED   8
#define CPSUICB_REASON_ABOUT            9
#define CPSUICB_REASON_SETACTIVE        10
#define CPSUICB_REASON_KILLACTIVE       11


//
// predefined ID for call back action
//

#define CPSUICB_ACTION_NONE             0
#define CPSUICB_ACTION_OPTIF_CHANGED    1
#define CPSUICB_ACTION_REINIT_ITEMS     2
#define CPSUICB_ACTION_NO_APPLY_EXIT    3
#define CPSUICB_ACTION_ITEMS_APPLIED    4


typedef struct _CPSUICBPARAM {
    WORD        cbSize;             // size of this structure
    WORD        Reason;             // CPSUICB_REASON_XXXXX callback reason
    HWND        hDlg;               // handle of the dialog box
    POPTITEM    pOptItem;           // pOptItem field from COMPROPSHEETUI
    WORD        cOptItem;           // cOptItem field from COMPROPSHEETUI
    WORD        Flags;              // flags field from COMPROPSHEETUI
    POPTITEM    pCurItem;           // current selected item of callback
    union {
        LONG    OldSel;             // Last selection (index)
        LPTSTR  pOldSel;            // Last selection (pStr)
        } DUMMYUNIONNAME;
    ULONG_PTR   UserData;           // UserData in the COMPROPSHEETUI struct.
    ULONG_PTR   Result;             // OUT parameter for the APPLYNOW
    } CPSUICBPARAM, *PCPSUICBPARAM;


typedef LONG (APIENTRY *_CPSUICALLBACK)(PCPSUICBPARAM pCPSUICBParam);
#define CPSUICALLBACK   LONG APIENTRY


//
// CPSUICBPARAM is used when commom UI callback to the caller, this structure
// describe the nature of callback and passed all necessary parameter for the
// caller to make changes in the pOptItem and passed an action back to the
// commom UI to redisplay the tree or page 1 data
//
//
//  cbSize      - must be CPSUICBPARAM
//
//  Reason      - defined the nature of the callback
//
//                  CPSUICB_REASON_SEL_CHANGED
//
//                      User make change to the pCurItem.  if the item is
//                      DMPUB_COPIES_COLLATE then common UI automatically
//                      change the collate extended check box without callback
//                      to the caller of the extended check box changes
//
//
//                  CPSUICB_REASON_PUSHBUTTON
//
//                      User push the push button and push button item is set
//                      to PUSHBUTTON_TYPE_CALLBACK.
//
//
//                  CPSUICB_REASON_ECB_CHANGED
//
//                      User make change to the extended checked box (i.e. it
//                      eiterh checked or not checked) EXTCHKBOX in the
//                      pCurItem passed in the call back parameter.
//
//
//                  CPSUICB_REASON_DLGPROC
//
//                      The callback reason is PUSHBUTTON_TYPE_DLGPROC
//
//
//                  CPSUICB_REASON_UNDO_CHANGES
//
//                      This callback currently is not implmented.
//
//
//                  CPSUICB_REASON_EXTPUSH
//
//                      The callback is result of user push the extend push
//                      button.
//
//
//                  CPSUICB_REASON_APPLYNOW
//
//                      The user press the apply now button. Durning callback
//                      the pCurItem is set to equal to pOptItem in this
//                      structure and 'OldSel' is set to the active DlgPageIdx
//                      (compare to the OPTITEM's DlgPageIdx) which the page
//                      user hitting the apply now button if the page is
//                      non-treeview page, otherwise the 'OldSel' is set to -1
//                      (for treeview page) to indicate all valid item should
//                      be apply now, if the callback return
//                      CPSUICB_ACTION_NONE then the common UI will exit the
//                      property sheet and returned CPSUI_OK back to the
//                      caller, and if the callback function returned
//                      CPSUICB_ACTION_NO_APPLY_EXIT then common UI will not
//                      exit the property sheet and callback function must
//                      pop-up messages dialog box to tell user why it cannot
//                      exist the property sheet until certain action is take
//                      by the user.
//
//
//                  CPSUICB_REASON_OPTITEM_SETFOCUS
//
//                      This callback reason is used when an OPTITEM is getting
//                      the keyboard focus. and give the callback function a
//                      chance to examine the item.
//
//
//                  CPSUICB_REASON_ITEMS_REVERTED
//
//                      This callback reason is used when user changed items
//                      and decided to revert changes from the parent item in
//                      the treeview.  The callback funciton is called after
//                      all revertable items are reverted to its original.
//
//                      The CPSUICBPARAM's pCurItem is same as pOptItem and
//                      'OldSel' field is same as cOptItem field.  for each of
//                      reverted item, the OPTIF_CHANGED bit will be set in the
//                      OPTITEM by the common UI to indicate the item is revert
//                      by the common UI.   The callback function MUST NOT
//                      reset this bit if it is set.
//
//
//                  CPSUICB_REASON_ABOUT
//
//                      This callback reason is used when user hit 'About...'
//                      push button in the treeview page, and the flag
//                      CPSUIF_ABOUT_CALLBACK is set.  The pCurItem is set to
//                      same as pOptItem and 'pOldSel' is a pointer pointed to
//                      original copy of COMPROPSHEETUI data structure which
//                      passed to the common UI.
//
//
//                  CPSUICB_REASON_SETACTIVE
//                  CPSUICB_REASON_KILLACTIVE
//
//                      The current property sheet is gaining or loosing focus,
//                      the pCurItem is set to equal to pOptItem in this
//                      structure and 'OldSel' is set to the current active
//                      DlgPageIdx (compare to the OPTITEM's DlgPageIdx).
//                      if the page is non-treeview page, otherwise the
//                      'OldSel' is set to -1 (for treeview page).
//
//  hDlg        - The handle to the dialog box (Properties page TAB) current
//                active for the callback.
//
//                Durning the callback the caller must not change the
//                DWLP_USERDATA on hDlg, otherwise the common UI will be crash.
//                If callback function need to get/set DWLP_USERDATA it should
//                call common UI's SetCPSUIUserData() and GetCPSUIUserData()
//                functions instead.
//
//  pCurItem    - Pointed to POPTITEM which the callback is generated for.
//
//  pOldSel
//  OldSel      - The last OPTITEM's pSel/Sel field before the change was made
//                by the user.  The pOldSel/OldSel only valid if the callback
//                reason is CPSUICB_REASON_SEL_CHANGED, this give the callback
//                function a chance to check against the previous item
//                selection.  This is a union field which can be a pointer to
//                a string or a LONG index selection.
//
//  UserData    - a 32-bit user defined data in the COMPROPSHEETUI structure,
//                commom UI will not changed it.
//
//  Result      - When the reason is CPSUICB_REASON_APPLYNOW, the callback
//                function MUST set the requested result for the caller into
//                'Result' field when it returned a value other than the
//                CPSUICB_ACTION_NO_APPLY_EXIT and common UI will send the
//                'Result' field value to this page's parent.
//
//                The called function should save the current result of
//                pOptItem.  The default 'Result' is set to CPSUI_OK (1) from
//                common UI.  This function can alter this result before it
//                return back to to the common UI.
//
//
//  Return Values:
//
//      CPSUICB_ACTION_NONE             - No action need to be take by the
//                                        common UI.
//
//      CPSUICB_ACTION_OPTIF_CHANGED    - Ask the common UI to examine the
//                                        OPTIF_CHANGED flag in the OPTITEM
//                                        data structure.  if the flag is set
//                                        then that item is assume need to be
//                                        re-display because of OPTITEM's Flags
//                                        field changed or item's selection
//                                        changed.   This is different from
//                                        CPSUICB_ACTION_REINIT_ITEMS which
//                                        it assume OPTTYPE or OPTPARAM data
//                                        also changed.
//
//
//      CPSUICB_ACTION_REINIT_ITEMS     - Ask the common UI to examine the
//                                        OPTIF_CHANGED flag in the OPTITEM
//                                        data structure.  if the flag is set
//                                        then that item is assume need to be
//                                        re-initialized in the dilaog box
//                                        control.  This happened if item's
//                                        OPTTYPE or OPTPARAMs flag/pdata
//                                        changed.
//
//
//      CPSUICB_ACTION_NO_APPLY_EXIT    - This return value only valid durning
//                                        CPSUICB_REASON_APPLYNOW callback
//                                        reason, it tell common UI it has
//                                        some constraints in its OPTITEM which
//                                        must correct or confirm by the user
//                                        before exit.  The callback function
//                                        must display and/or have user taking
//                                        some actions before return this
//                                        action to the common UI
//
//      CPSUICB_ACTION_ITEMS_APPLIED    - When responsed to the
//                                        CPSUICB_REASON_APPLYNOW, if the
//                                        returned action is
//                                        CPSUICB_ACTION_ITEMS_APPLIED then
//                                        common UI will reset OPTIF_CHANGEONCE
//                                        bit and save the new default for the
//                                        future undo operations.
//
//

#define DP_STD_TREEVIEWPAGE             0xFFFF
#define DP_STD_DOCPROPPAGE2             0xFFFE
#define DP_STD_DOCPROPPAGE1             0XFFFD
#define DP_STD_RESERVED_START           0xFFF0

#define MAX_DLGPAGE_COUNT               64

#define DPF_ICONID_AS_HICON             0x0001
#define DPF_USE_HDLGTEMPLATE            0x0002

typedef struct _DLGPAGE {
    WORD        cbSize;         // size of this structure
    WORD        Flags;          // DPF_xxxx flags
    DLGPROC     DlgProc;        // caller's dialog box subclass procedue
    LPTSTR      pTabName;       // pointer to the tab name
    ULONG_PTR   IconID;         // icon to be used
    union {
        WORD    DlgTemplateID;  // dialog box template ID
        HANDLE  hDlgTemplate;   // handle to the dialog template
        } DUMMYUNIONNAME;
    } DLGPAGE, *PDLGPAGE;


//
// DLGPAGE structure describe non-treeview page characteristics
//
//
//  cbSize          - size of this structure
//
//  Flags           - DPF_xxxx flags
//
//                      DPF_ICONID_AS_HICON
//
//                          If this flag is set then IconID DWORD field is
//                          treated as a handle to the icon rather then the
//                          resource ID
//
//
//  DlgProc         - caller's supplied DLGPROC for sub-class the page
//                    dialog box processing,
//
//                    if DlgProc is not NULL then common UI do the following
//                    according the the message received except for the
//                    DP_STD_xxx pages
//
//
//                      WM_INITDIALOG
//
//                          Common UI initialize the dialog box and then call
//                          DlgProc(WM_INITDIALOG) the DlgProc should return
//                          exactly the behavior for the WM_INITDIALOG
//
//                          The lParam in the WM_INITDIALOG data structure is
//                          a pointer to the PROPSHEETPAGE data structure.
//
//                          the lParam field in the PROPSHEETPAGE (lParam
//                          passed to the WM_INITDIALOG) is the UserData
//                          defined in COMPROPSHEETUI data structure
//
//                          To access to the PSPINFO data structure which
//                          associate with this page, use the common UI macro
//                          PPSPINFO_FROM_WM_INITDIALOG_LPARAM(lParam) where
//                          lParam is the parameter passed to the
//                          WM_INITDIALOG message.
//
//                          The subclass function should save these pointers
//                          for its later use, but it MUST NOT modified the
//                          content of the PSPINFO data structure or system
//                          may crashed.
//
//
//                      OTHER DIALOG MESSAGES
//
//                          Iit call DlgProc() and if it returned the value is
//                          non-zero then common UI assume DlgProc() processed
//                          the message and will not process this message.
//
//                          If the returned vlaue from DlgProc() is zero then
//                          common UI will process this message.
//
//
//                      * Durning the DlgProc the caller must not change the
//                        DWLP_USERDATA on hDlg, otherwise the common UI will
//                        be crash.  If caller need to get/set DWLP_USERDATA it
//                        should call common UI's SetCPSUIUserData() and
//                        GetCPSUIUserData() instead.
//
//  pTabName        - Pointer to a string to describe the TAB title
//
//  IconID          - This is the icon identifier, which can be a common
//                    strandard IDI_CPSUI_xxx icon ID, caller's own icon
//                    resource ID, or a handle to the caller defined icon if
//                    DPF_ICONID_AS_HICON flag is set, in any case if the
//                    IconID is zero then it indicated no icon.
//
//  DlgTemplateID   - The template id to be use for the ProPage, it can be
//                    one of DP_STD_xxxx, the DP_STD_xxx has 240 x 240 dialog
//                    box units.
//
//
//                      DP_STD_TREEVIEWPAGE
//
//                          Specified that this page is a standard treeview
//                          page provided by the common ui.  The treeview page
//                          is a page using treeview display all valid OPTITEM
//                          passed to the common UI.  User can modify every
//                          valid selectable OPTITEM from the treeview page.
//
//                      DP_STD_DOCPROPPAGE
//
//                          Specified that this page is a standard document
//                          property page provided by the common UI
//
//  hDlgTemplate    - Handle to the DLGTEMPLATE which will be use for pop up
//                    dialog box
//
//
//  wReserved[]
//  dwReserved[]    - Reserved fields, must be 0
//
//
//  ** Tips of designing the dialog box controls
//
//      When designing the dialog box controls, each OPTITEM is correspoonds
//      to one input control plus one extended check box or extended push
//      button.  Since common UI will automatically disable and remove
//      OPTIF_HIDE items item from the property sheet and dynamically move
//      other controls, the following tips of designing the dialog box controls
//      should follow.
//
//      * Each item should have one input control plus optional of extended
//        check box/push botton, one icon control and other static controls
//
//      * Each item should occupied whole horizontal spaces of the property
//        sheet, items must not overlay in vertical direction.
//
//      * for TVOT_2STATES, TVOT_3STATES, if it araange radio buttons from
//        left to right in state order (ie. from first state's OPTPARAM to
//        last state's OPTPARAM) then the radio buttons and icons should
//        aligned in the Y coordinate.    If it arrange radio buttons from top
//        to bottom (ie. from first state's OPTPARAM to last state's OPTPARAM)
//        then the radio buttons and icons should aligned in the X coordinate.
//
//        common UI will automatically hide/move the radio buttons to compact
//        the dialog box controls.  If radio buttons/icons are arranged in
//        top/down order and there is other controls obscure in Y direction
//        then radio buttons will only be re-arranged but not remove any white
//        spaces in Y direction.
//
//      * If multiple items shared one group box, then the group box must
//        belongs to the first item (topmost in the dialog box group) in the
//        group, the group box must large enough to cover all the items in
//        side the group box.
//
//


#define CPSUIF_UPDATE_PERMISSION        0x0001
#define CPSUIF_ICONID_AS_HICON          0x0002
#define CPSUIF_ABOUT_CALLBACK           0x0004

#define CPSUI_PDLGPAGE_DOCPROP          (PDLGPAGE)1
#define CPSUI_PDLGPAGE_ADVDOCPROP       (PDLGPAGE)2
#define CPSUI_PDLGPAGE_PRINTERPROP      (PDLGPAGE)3
#define CPSUI_PDLGPAGE_TREEVIEWONLY     (PDLGPAGE)4

//
// For compatible misspelling #define
//

#define CPSUI_PDLGPAGE_TREEVIWONLY      CPSUI_PDLGPAGE_TREEVIEWONLY

typedef struct _COMPROPSHEETUI {
    WORD            cbSize;             // size of this structure
    WORD            Flags;              // CPSUIF_xxxx flags
    HINSTANCE       hInstCaller;        // caller's hInstance
    LPTSTR          pCallerName;        // pointer to the caller's name
    ULONG_PTR       UserData;           // caller's own data
    LPTSTR          pHelpFile;          // pointer to the help file
    _CPSUICALLBACK  pfnCallBack;        // callback function pointer
    POPTITEM        pOptItem;           // pointer to POPTITEM array
    PDLGPAGE        pDlgPage;           // pointer to the DLGPAGE array
    WORD            cOptItem;           // count of pOptItem array
    WORD            cDlgPage;           // count of pDlgPage array
    ULONG_PTR       IconID;             // icon to be used
    LPTSTR          pOptItemName;       // pointer to the optitem's data name
    WORD            CallerVersion;      // version for the caller apps
    WORD            OptItemVersion;     // version for the optitem name
    ULONG_PTR       dwReserved[4];      // reserved, must be 0
    } COMPROPSHEETUI, *PCOMPROPSHEETUI;


//
// COMPROPSHEETUI data structure is used when calling common UI to display dialog
// box of properties pages.
//
//
//  Size                - Must be sizeof (COMPROPSHEETUI)
//
//  Flags               - can be one or more of following
//
//                          CPSUIF_UPDATE_PERMISSION
//
//                              Specified the any valid pOptItem items are
//                              changeable by the user.
//
//
//                          CPSUIF_ICONID_AS_HICON
//
//                              If this flag is set then IconID DWORD field is
//                              treated as a handle to the icon rather then the
//                              resource ID
//
//
//                          CPSUIF_ABOUT_CALLBACK
//
//                              If this flag bit is set, then when user hit
//                              'About...' button in the treeview tab, it will
//                              call the callback function with a reason of
//                              CPSUICB_REASON_ABOUT, and callback MUST handle
//                              the about which pop-up dialog box to show user
//                              the information about the caller and OPTITEMs.
//
//                              If this bit is not set then common UI will call
//                              the ShellAbout() with formatted caller Name and
//                              pOptItemName with version numbers.
//
//
//  hInstCaller         - the caller's handle to its instance.  Commom UI use
//                        this handle to load caller's icon and other resources.
//
//  pCallerName         - Pointer to the caller's NULL terminated caller's
//                        name, most time this is driver's name,
//                        such as 'Postscript Driver'
//
//  UserData            - a 32-bit number used by the caller and common UI will
//                        not modify it.  this 32-bit number is passed back to
//                        the caller durning the callback function
//
//  pHelpFile           - specified a standard microsoft help file (path/file)
//                        for using in the common UI.  in OPTITEM specified
//                        HelpIndex for help in each item.
//
//  pfnCallBack         - Pointer to _CPSUICALLBACK callback function.  Common
//                        UI only callback to the caller if an OPTIF_CALLBACK
//                        is set OPTITEM data structure's flag fields and the
//                        item selection is changed by the user.
//
//  pOptItem            - Pointer to array of OPTITEM structure to be displayed
//                        by the common UI
//
//  pDlgPage            - Pointer to array of DLGPAGE structure to describe
//                        each property sheet page infomation, the following
//                        are the standard common ui DLGPAGEs.  When specified
//                        CPSUI_PDLGPAGE_xxxx, the common UI will automatically
//                        modify DlgPageIdx field in the OPTITEM, caller must
//                        set the iStartPage correctly.
//
//                          CPSUI_PDLGPAGE_DOCPROP
//
//                              specified this a common ui standard document
//                              property sheets. This includes two property
//                              sheets, 1) Page Setup 2) Advance (TreeView)
//
//
//                          CPSUI_PDLGPAGE_ADVDOCPROP
//
//                              Specified this is a treeview page only UI
//                              provided by the common UI, this only has one
//                              treeview page with tab of 'Advance'
//
//
//                          CPSUI_PDLGPAGE_PRINTERPROP
//
//                              Specified this is a common UI standard printer
//                              property sheet.  This only has one treeview
//                              page with tab of 'Device Options'
//
//
//                          CPSUI_PDLGPAGE_TREEVIEWONLY
//
//                              Specified this is a treeview page only UI
//                              provided by the common UI, this only has one
//                              treeview page
//
//
//
//  cOptItem            - Count of OPTITEM pointed by the pOptItem above
//
//  cDlgPage            - Count of DLGPAGE pointed by the pDlgPage.  If
//                        pDlgPage is one of the CPSUI_PDLGPAGE_xxxx then this
//                        field is ignored by the common UI.
//
//  IconID              - This is the icon identifier, which can be a common
//                        strandard IDI_CPSUI_xxx icon ID, caller's own icon
//                        resource ID, or a handle to the caller defined icon
//                        if CPSUIF_ICONID_AS_HICON flag is set, in any case
//                        if the IconID is zero then it indicated no icon.
//
//  pOptItemName        - Pointer to the pOptItem data NULL terminated name,
//                        most time this is device name, such as 'HP 4si'
//
//  CallerVersion       - Version for the caller, the HIBYTE(CallerVersion) is
//                        the major version, and LOBYTE(CallerVersion) is the
//                        minor version, such as 0x310 display as 3.16, 0x3ff
//                        display as 3.255 and 0x30a display as 3.10
//
//  OptItemVersion      - Version for the OPTITEM's data, the
//                        HIBYTE(OptItemVersion) is the major version, and
//                        LOBYTE(OptItemVersion) is the minor version, such as
//                        0x310 display as 3.16, 0x3ff display as 3.255 and
//                        0x30a display as 3.10.
//
//  dwReserved[4]       - reserved fields, must be 0
//
//
//  ** pTitlee and TitleBarIcon only used if CommonPrinterPropSheetUI()
//     is the last one the Property sheet UI chain and call the PropertySheet()
//
//


#define CPSFUNC_ADD_HPROPSHEETPAGE          0
#define CPSFUNC_ADD_PROPSHEETPAGEW          1
#define CPSFUNC_ADD_PCOMPROPSHEETUIA        2
#define CPSFUNC_ADD_PCOMPROPSHEETUIW        3
#define CPSFUNC_ADD_PFNPROPSHEETUIA         4
#define CPSFUNC_ADD_PFNPROPSHEETUIW         5
#define CPSFUNC_DELETE_HCOMPROPSHEET        6
#define CPSFUNC_SET_HSTARTPAGE              7
#define CPSFUNC_GET_PAGECOUNT               8
#define CPSFUNC_SET_RESULT                  9
#define CPSFUNC_GET_HPSUIPAGES              10
#define CPSFUNC_LOAD_CPSUI_STRINGA          11
#define CPSFUNC_LOAD_CPSUI_STRINGW          12
#define CPSFUNC_LOAD_CPSUI_ICON             13
#define CPSFUNC_GET_PFNPROPSHEETUI_ICON     14
#define CPSFUNC_ADD_PROPSHEETPAGEA          15
#define CPSFUNC_INSERT_PSUIPAGEA            16
#define CPSFUNC_INSERT_PSUIPAGEW            17
#define CPSFUNC_SET_PSUIPAGE_TITLEA         18
#define CPSFUNC_SET_PSUIPAGE_TITLEW         19
#define CPSFUNC_SET_PSUIPAGE_ICON           20
#define CPSFUNC_SET_DATABLOCK               21
#define CPSFUNC_QUERY_DATABLOCK             22
#define CPSFUNC_SET_DMPUB_HIDEBITS          23
#define CPSFUNC_IGNORE_CPSUI_PSN_APPLY      24
#define CPSFUNC_DO_APPLY_CPSUI              25
#define MAX_CPSFUNC_INDEX                   25

#ifdef UNICODE
#define CPSFUNC_ADD_PCOMPROPSHEETUI         CPSFUNC_ADD_PCOMPROPSHEETUIW
#define CPSFUNC_ADD_PFNPROPSHEETUI          CPSFUNC_ADD_PFNPROPSHEETUIW
#define CPSFUNC_LOAD_CPSUI_STRING           CPSFUNC_LOAD_CPSUI_STRINGW
#define CPSFUNC_ADD_PROPSHEETPAGE           CPSFUNC_ADD_PROPSHEETPAGEW
#define CPSFUNC_INSERT_PSUIPAGE             CPSFUNC_INSERT_PSUIPAGEW
#define CPSFUNC_SET_PSUIPAGE_TITLE          CPSFUNC_SET_PSUIPAGE_TITLEW

#else
#define CPSFUNC_ADD_PCOMPROPSHEETUI         CPSFUNC_ADD_PCOMPROPSHEETUIA
#define CPSFUNC_ADD_PFNPROPSHEETUI          CPSFUNC_ADD_PFNPROPSHEETUIA
#define CPSFUNC_LOAD_CPSUI_STRING           CPSFUNC_LOAD_CPSUI_STRINGA
#define CPSFUNC_ADD_PROPSHEETPAGE           CPSFUNC_ADD_PROPSHEETPAGEA
#define CPSFUNC_INSERT_PSUIPAGE             CPSFUNC_INSERT_PSUIPAGEA
#define CPSFUNC_SET_PSUIPAGE_TITLE          CPSFUNC_SET_PSUIPAGE_TITLEA

#endif

//
// for the CPSFUNC_SET_RESULT
//

#define SR_OWNER            0
#define SR_OWNER_PARENT     1

typedef struct _SETRESULT_INFO {
    WORD        cbSize;
    WORD        wReserved;
    HANDLE      hSetResult;
    LRESULT     Result;
    } SETRESULT_INFO, *PSETRESULT_INFO;

//
// This is for CPSFUNC_INSERT_PSUIPAGE
//

#define HINSPSUIPAGE_FIRST              (HANDLE)0xFFFFFFFE
#define HINSPSUIPAGE_LAST               (HANDLE)0xFFFFFFFF
#define HINSPSUIPAGE_INDEX(i)           (HANDLE)MAKELONG(i, 0);

#define PSUIPAGEINSERT_GROUP_PARENT     0
#define PSUIPAGEINSERT_PCOMPROPSHEETUI  1
#define PSUIPAGEINSERT_PFNPROPSHEETUI   2
#define PSUIPAGEINSERT_PROPSHEETPAGE    3
#define PSUIPAGEINSERT_HPROPSHEETPAGE   4
#define PSUIPAGEINSERT_DLL              5
#define MAX_PSUIPAGEINSERT_INDEX        5


#define INSPSUIPAGE_MODE_BEFORE         0
#define INSPSUIPAGE_MODE_AFTER          1
#define INSPSUIPAGE_MODE_FIRST_CHILD    2
#define INSPSUIPAGE_MODE_LAST_CHILD     3
#define INSPSUIPAGE_MODE_INDEX          4


typedef struct _INSERTPSUIPAGE_INFO {
    WORD        cbSize;
    BYTE        Type;
    BYTE        Mode;
    ULONG_PTR   dwData1;
    ULONG_PTR   dwData2;
    ULONG_PTR   dwData3;
    } INSERTPSUIPAGE_INFO, *PINSERTPSUIPAGE_INFO;


//
// for the CPSFUNC_SET_HSTARTPAGE
//

#define SSP_TVPAGE          10000
#define SSP_STDPAGE1        10001
#define SSP_STDPAGE2        10002

typedef LONG_PTR (CALLBACK *PFNCOMPROPSHEET)(HANDLE hComPropSheet,
                                             UINT   Function,
                                             LPARAM lParam1,
                                             LPARAM lParam2);


typedef struct _PSPINFO {
    WORD            cbSize;
    WORD            wReserved;
    HANDLE          hComPropSheet;
    HANDLE          hCPSUIPage;
    PFNCOMPROPSHEET pfnComPropSheet;
    } PSPINFO, *PPSPINFO;

//
// PPSPINFO_FROM_WM_INITDIALOG_LPARAM(lParam) macro retrieve a pointer to the
// PSPINFO data structure. the lParam must be the lParam passed to the
// WM_INITDIALOG, otherwise the system can failed
//

#define PPSPINFO_FROM_WM_INITDIALOG_LPARAM(lParam)  \
                (PPSPINFO)((LPBYTE)lParam + ((LPPROPSHEETPAGE)lParam)->dwSize)

//
// PSPINFO
//
//  This structure is used durning property sheet page's WM_INITDIALOG message.
//  At WM_INITDIALOG, the lParam is a pointer to the PROPSHEETPAGE, and
//  lParam field in the PROPSHEETPAGE is a pointer to the PSPINFO.  the
//  original lParam in the PROPSHEETPAGE is saved in the lParam field in the
//  PSPINFO data structure.
//
//  When process WM_INITDIALOG message, it should save the lParam (PSPINFO
//  structure pointer) for later to call common UI callback functions.
//
//
//  cbSize          - Size of this structure in bytes
//
//  wReserved       - Reserved, must be set to zero
//
//  hComPropSheet   - Handle to the parent page which is the hComPropSheet
//                    passed to the CPSFUNC_ADD_PROPSHEETPAGE
//
//  hCPSUIPage      - Handle to the this added common UI property sheet page.
//
//  pfnComPropSheet - Pointer to the common UI callback function, using this
//                    function pointer to do CPSFUNC_xxxx
//
//

typedef struct _CPSUIDATABLOCK {
    DWORD   cbData;
    LPBYTE  pbData;
    } CPSUIDATABLOCK, *PCPSUIDATABLOCK;


#define APPLYCPSUI_NO_NEWDEF        0x00000001
#define APPLYCPSUI_OK_CANCEL_BUTTON 0x00000002

//
// PFNCOMPROPSHEET function descriptions
//
// For each function index, it passed a handle, a Function Index and two (2)
// long parameters, the 'hComPropSheet' handle passed must be the handle passed
// from common UI when common UI called the caller supplied function
//
// pfnPropSheetUI(pPropSheetUIData);
//
// Following are the description of each function index
//
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_ADD_HPROPSHEETPAGE
//
//      This function add a page to the hComPropSheet using handle to the
//      PROPSHEETPAGE
//
//
//  Parameters:
//
//      lParam1 - is a handle to the PROPSHEETPAGE that created by the caller
//                using CreatePropertySheetPage()
//
//      lParam2 - Not used, must be 0
//
//
//  Return Value:
//
//      The return value is the handle of newly added common property sheet
//      page, if return value is NULL then function failed.
//
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_ADD_PROPSHEETPAGE
//
//      This function add a page to the hComPropSheet using PROPSHEETPAGE
//      data structure.
//
//
//  Parameters:
//
//      lParam1 - is a pointer to PROPSHEETPAGE data structure
//
//      lParam2 - Not used.
//
//
//  Return Value:
//
//      The return value is the handle of newly added common property sheet
//      page, if return value is NULL then function failed.
//
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_ADD_PCOMPROPSHEETUI
//
//      This function add propety page(s) to the hComPropSheet handle using
//      COMPROPSHEETUI data structure.
//
//
//  Parameters:
//
//      lParam1 - is a pointer to COMPROPSHEETUI data structure
//
//      lParam2 - pointer to a 32-bit location that received the total pages
//                added by the COMPROPSHEETUI data structure if sucessful else
//                it contains the ERR_CPSUI_xxx error codes.
//
//
//  Return Value:
//
//      The return value is the handle of newly added common property sheet
//      page(s), if return value is NULL then function failed.
//
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_ADD_PFNPROPSHEETUI
//
//      This function add property page(s) to the hChild handle using
//      lParam1 as PFNPROPSHEETUI function pointer and lParam2 as the function
//      parameter.   The common UI call supplied function as following
//
//          PROPSHEETUI_INFO    PSUIInfo;
//
//          PSUIInfo.cbSize          = sizeof(PROPSHEETUI_INFO);
//          PSUIInfo.Version         = PROPSHEETUI_INFO_VERSION;
//          PSUIInfo.Flags           = (Ansi) ? 0: PSUIINFO_UNICODE;
//          PSUIInfo.Reason          = PROPSHEETUI_REASON_INIT;
//          PSUIInfo.hComPropSheet   = hComPropSheet;
//          PSUIInfo.pfnComPropSheet = ComPropSheetUICallBack;
//          PSUIInfo.lParamInit      = lParam2;
//          PSUIInfo.UserData        = 0;
//          PSUIInfo.Result          = 0;
//
//          ((PFNPROPSHEETUI)lParam1)(&PSUIInfo, lParam2);
//
//
//          If the pfnPropSheetUI() need to add/delete any common UI pages then
//          it must use hComPropSheet as its handle when calling the
//          ComPropSheetUICallBack().
//
//
//  Parameters:
//
//      lParam1 - a PFNPROPSHEETUI function pointer.
//
//      lParam2 - a 32-bit data that will be used as lParam when calling
//                PFNPROPSHEETUI function pointer.
//
//
//  Return Value:
//
//      The return value is the newly added property pages function handle, if
//      return value is NULL then function failed or no page is added.
//
//
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_DELETE_HCOMPROPSHEET
//
//      This function delete child property page(s) from hComPropSheet parent
//      using the child handle passed.
//
//
//  Parameters:
//
//      lParam1 - the handle of common property sheet pages that to be deleted.
//                This handle must be the handle returned from CPSFUNC_ADD_xxx
//                functions.
//
//      lParam2 - not used, must be 0
//
//  Return Value:
//
//      The return value is greater than zero if function sucessful, and less
//      or equal to zero if the function failed.
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_GET_PAGECOUNT
//
//      This function return total property sheet pages belongs to a common
//      UI property sheet page handle hComPropSheet
//
//
//  Parameters:
//
//      lParam1 - not used, must be 0
//
//      lParam2 - not used, must be 0.
//
//
//  Return Value:
//
//      The return value is total page count if function sucessful or zero if
//      function failed.
//
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_SET_RESULT
//
//      This function set the result of property sheet page to its owner that
//      added this page by CPSFUNC_ADD_xxx function indices
//
//  Parameters:
//
//      lParam1 - Handle to the common UI property sheet page that setting the
//                result.  If this handle is NULL then it is treated as
//                equal to the hComPropSheet.
//
//      lParam2 - a 32-bit DWORD result to be set.
//
//
//  Return Value:
//
//      > 0: Successful, return value is total count of parents set the result
//      = 0: There is no owner or parent for the lParam1 handle.
//      < 0: function failed because of invalid lParam1 handle.
//
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_SET_HSTARTPAGE
//
//
//  Parameters:
//
//      lParam1 - the handle of common property sheet pages that to be set
//                as initial page that appear when the property sheet dialog
//                boxes is created.  This handle must be the handle returned
//                from CPSFUNC_ADD_xxx functions.
//
//                If lParam1 is NULL then lParam2 is a string pointer to the
//                page name (tab) that to be set for the start page
//
//      lParam2 - a LONG number to specified the children index. if lParam1
//                handle is a parent then lParam2 specified zero base children
//                index for using as start page.
//
//                It also can be one of following special index
//
//                  SSP_TVPAGE
//
//                      set to the treeview page, this only valid if lParam1
//                      handle was added by the CPSFUNC_ADD_PCOMPROPSHEETUI.
//
//                  SSP_STDPAGE
//
//                      Set to the standard document property sheet page
//                      (Page 1 user friendly page).  this only valid if
//                      lParam1 handle was added by the
//                      CPSFUNC_ADD_PCOMPROPSHEETUI.
//
//
//  Return Value:
//
//      The return value is greater than zero if function sucessful, and less
//      or equal to zero if the function failed.  This function can only be
//      called when the property sheet is not display yet so the place to
//      call is during the PROPSHEETUI_REASON_GET_INFO_HEADER callback.
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_GET_HPSUIPAGES
//
//      This function return array of children HPROPSHEETPAGE belongs to
//      the parent hComPropSheet UI property sheet page handle hComPropSheet
//
//
//  Parameters:
//
//      lParam1 - Pointer to an array of HPROPSHEETPAGE that to be stored
//                the handle upon return.
//
//      lParam2 - Count of HPROPSHEETPAGE array pointed by the lParam1
//
//
//  Return Value:
//
//      The return value is total HPROPSHEETPAGE stored in the array pointed
//      by the lParam1.   To get all hPropSheetPage for any common property
//      sheet handle's (hCPSUIPage) children, it can use following sequence.
//
//          if ((cPage = pfnComPropSheet(hComPropSheet,
//                                       CPSFUNC_GET_PAGECOUNT,
//                                       (LPARAM)hCPSUIPage,
//                                       0L))   &&
//              (phPage = ALLOCMEM(cPage * sizeof(HANDLE)))) {
//
//              pfnComPropSheet(hCPSUIPage,
//                              CPSFUNC_GET_HPSUIPAGES,
//                              (LPARAM)phPage,
//                              (LPARAM)cPage);
//          }
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_LOAD_CPSUI_STRING
//
//      This function load the common property sheet UI resource string
//
//  Parameters:
//
//      lParam1 - Pointer to LPTSTR string which will stored the loaded
//                resource string from the common property sheet UI DLL.
//
//      lParam2 - LOWORD(lParam2) = Count of characters (includes null
//                                  terminator) which pointed by the lParam1
//
//                HIWORD(lParam2) = Common property sheet UI predefined string
//                                  resource ID as IDS_CPSUI_xxxx
//
//
//  Return Value:
//
//      > 0: Total characters stored in the string pointed by the lParam1, this
//           is not includes the null terminator
//      = 0: Invalid IDS_CPSUI_xxx passed from HIWORD(lParam)
//      < 0: Either lParam1 is NULL or count of character is 0 from
//           LOWORD(lParam2)
//
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_LOAD_CPSUI_ICON
//
//      This function load the common property sheet UI resource icon.
//
//  Parameters:
//
//      lParam1 - Common property sheet UI predefined icon resource ID as
//                IDI_CPSUI_xxxx.
//
//      lParam2 - LOWORD(lParam2) = cx icon size in pixel.  If zero then
//                                  SM_CXICON is used
//                HIWORD(lParam2) = cy icon size in pixel.  If zero then
//                                  SM_CYICON is used
//
//
//  Return Value:
//
//      Return value is the handle to the hIcon if function succeed, a NULL
//      if function failed. The caller must call DestroyIcon() when it no
//      longer need to use the hIcon returned
//
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_GET_PFNPROPSHEETUI_ICON
//
//      This function let the caller return hIcon of its children pages that
//      was added by CPSFUNC_ADD_PFNPROPSHEETUI
//
//  Parameters:
//
//      lParam1 - Handle of common property sheet pages that the hIcon will be
//                queried.  This handle must be the handle returned from
//                CPSFUNC_ADD_PFNPROPSHEETUI function.
//
//      lParam2 - LOWORD(lParam2) = cx icon size in pixel.  If zero then
//                                  SM_CXICON is used
//                HIWORD(lParam2) = cy icon size in pixel.  If zero then
//                                  SM_CYICON is used
//
//
//  Return Value:
//
//      Return value is the handle to the hIcon if function succeed, a NULL
//      if function failed. The caller must call DestroyIcon() when it no
//      longer need to use the hIcon returned
//
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_INSERT_PSUIPAGE
//
//      This function let the caller insert common property sheet pages at
//      set position.  The hComPropSheet must be the parent handle.
//
//  Parameters:
//
//      lParam1 - Handle of common property sheet pages that the page position
//                will be inserted.  This handle must be the handle returned
//                from previous CPSFUNC_ADD_xxx or CPSFUNC_INSERT_PSUIPAGE that
//                added or inserted using the hComPropSheet if the Mode field
//                in INSPSUIPAGE_INFO data structure is one of the follwing
//
//                  INSPSUIPAGE_MODE_BEFORE
//                  INSPSUIPAGE_MODE_AFTER      - Common UI page handle
//
//                  INSPSUIPAGE_MODE_INDEX      - the lParam1 is an zero based
//                                                child index.
//
//                  INSPSUIPAGE_MODE_FIRST_CHILD
//                  INSPSUIPAGE_MODE_LAST_CHILD - The lParam1 is ignonred.
//
//
//                If lParam1 is a valid common property sheet page handle then
//                it is  the child page handle of hComPropSheet that added by
//                CPSFUNC_ADD_xxx or inserted by CPSFUNC_INSERT_PSUIPAGE.
//
//      lParam2 - A pointer that points to INSERTPSUIPAGE_INFO data structure.
//                Fields must set according to the following.
//
//                  cbSize  - size of this structure
//
//                  Type    - Type of page(s) to be inserted.  It can be one
//                            of the following
//
//                      PSUIPAGEINSERT_GROUP_PARENT
//
//                          Insert a group parent that can be used to insert
//                          new pages under it.  This is typically used when
//                          a set of common UI pages must be group together and
//                          can be deleted later using a single group parent
//                          handle without individual deleting each page.
//
//                          This handle can be nested.  After this function
//                          returned the group parent handle, it can be used
//                          as hComPropSheet handle (first parameter in the
//                          common UI callback) as parent handle so insertion
//                          will be inserted at level below returned group
//                          parent handle.
//
//
//                      PSUIPAGEINSERT_PCOMPROPSHEETUI
//
//                          Insert pages using COMPROPSHEETUI data structure,
//                          dwData1 is a pointer to the COMPROPSHEETUI data
//                          structure.
//
//
//                      PSUIPAGEINSERT_PFNPROPSHEETUI
//
//                          Insert pages using PFNPROPSHEETUI function pointer.
//                          The dwData1 is a PFNPROPSHEETUI function pointer.
//                          The common UI will call this pfnPropSheetUI()
//                          function pointer with PROPSHEETUI_REASON_INIT to
//                          have it add pages.
//
//                          When common UI call pfnPropSheetUI() (dwData1) it
//                          also passed a 32-bit parameter from the dwData2
//                          field in INSERTPSUIPAGE_INFO data structure.
//
//
//                      PSUIPAGEINSERT_PROPSHEETPAGE
//
//                          Insert pages using PROPSHEETPAGE data structure.
//                          The dwData1 is a pointer to the PROPSHEETPAGE
//                          data structure.
//
//
//                      PSUIPAGEINSERT_HPROPSHEETPAGE
//
//                          Insert pages using HPROPSHEETPAGE handle.  The
//                          dwData1 is a PROPSHEETPAGE handle which was
//                          created by CreatePropertySheetPage().
//
//
//                      PSUIPAGEINSERT_DLL
//
//                          Insert pages from a dynnmaic link library.  The
//                          dwData1 is a pointer to a null terminated string
//                          that specified the dynamic link library file name.
//
//                          The dwData2 is a pointer to a null terminated ASCII
//                          string that specified the pfnPropSheetUI function
//                          name. (MUST BE ASCII STRING)
//
//                          Common UI will do a LoadLibrary((LPTSTR)dwData1),
//                          pfnPropSheetUI = GetProcAddress((LPTSTR)dwData2)
//                          then call the pfnPropSheetUI with a lParam from
//                          dwData3.  The called reason from common UI is
//                          set to PROPSHEETUI_REASON_INIT.
//
//                          Using this method insert pages will guaranteed that
//                          library will be unload correctly.
//
//
//                  Mode    - Insert Mode, it can be one of the following
//
//
//                      INSPSUIPAGE_MODE_BEFORE
//
//                          Insert pages before the common property sheet page
//                          handle specified by lParam1
//
//
//                      INSPSUIPAGE_MODE_AFTER
//
//                          Insert pages after the common property sheet page
//                          handle specified by lParam1
//
//
//                      INSPSUIPAGE_MODE_FIRST_CHILD
//
//                          Insert pages as the first child of hComPropSheet
//                          parent handle, the lParam1 is ignored
//
//
//                      INSPSUIPAGE_MODE_LAST_CHILD
//
//                          Insert pages as the last child of hComPropSheet
//                          parent handle, the lParam1 is ignored
//
//
//                      INSPSUIPAGE_MODE_INDEX
//
//                          Insert pages as a zero base child index of its
//                          parent handle specified by hComPropSheet.
//
//                          The lParam1 is the zero based index special handle
//                          that must generated by HINSPSUIPAGE_INDEX(Index)
//                          macro.   If the index is greater than or equal to
//                          the total count of children then it will treat the
//                          mode same as INSPSUIPAGE_MODE_LAST_CHILD
//
//
//                  dwData1
//                  dwData2
//                  dwData3 - 32-bit data associate with the 'Type' field
//                            as following
//
//
//                      PSUIPAGEINSERT_GROUP_PARENT
//
//                          dwData1 = Not used, must be 0
//                          dwData2 = Not used, must be 0
//                          dwData3 = Not used, must be 0
//
//
//                      PSUIPAGEINSERT_PCOMPROPSHEETUI
//
//                          dwData1 = pointer to COMPORPSHEETUI data structure.
//                          dwData2 = at return if sucessful, it contains total
//                                    page added.  If failed, it contains the
//                                    ERR_CPSUI_xxx codes
//                          dwData3 = Not used, must be 0
//
//
//                      PSUIPAGEINSERT_PFNPROPSHEETUI
//
//                          dwData1 = PFNPROPSHEETUI function pointer
//                          dwData2 = 32-bit parameter passed to pfnPropSheetUI
//                          dwData3 = Not used, must be 0
//
//
//                      PSUIPAGEINSERT_PROPSHEETPAGE
//
//                          dwData1 = Pointer to PROPSHEETPAGE data structure.
//                          dwData2 = not used, must be 0
//                          dwData3 = not used, must be 0
//
//
//                      PSUIPAGEINSERT_HPROPSHEETPAGE
//
//                          dwData1 = Is the HPROPSHEETPAGE handle that created
//                                    by a call to CreatePropertySheetPage().
//                          dwData2 = not used, must be 0
//                          dwData3 = not used, must be 0
//
//
//                      PSUIPAGEINSERT_DLL
//
//                          dwData1 = Pointer to a null terminated dynamic link
//                                    library filename.
//                          dwData2 = Pointer to a null terminated function
//                                    name (PFNPROPSHEETUI) in the dynamin link
//                                    library.
//                          dwData3 = 32-bit parameter passed to pfnPropSheetUI
//                                    (PFNPROPSHEETUI) function from dwData2
//
//
//  Return Value:
//
//      The return value is the handle of newly added common property sheet
//      page(s), if return value is NULL then function failed.
//
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_SET_PSUIPAGE_TITLE
//
//      This function let the caller set a new title for a particular common
//      UI page title (on the property sheet page tab)
//
//  Parameters:
//
//      lParam1 - the handle of common property sheet pages that title to be
//                set.  This handle must be the handle returned from following
//
//                  CPSFUNC_ADD_PROPSHEETPAGE
//                  CPSFUNC_ADD_HPROPSHEETPAGE
//                  CPSFUNC_INSERT_PSUIPAGE with type of
//                              PSUIPAGEINSERT_PROPSHEETPAGE or
//                              PSUIPAGEINSERT_HPROPSHEETPAGE
//
//      lParam2 - Pointer to a null terminated string for the new title
//
//
//  Return Value:
//
//      The return value is greater than zero if function sucessful, and less
//      or equal to zero if the function failed.
//
//      This function will returned 0 if the property sheet pages is not
//      currently displayed.
//
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_SET_PSUIPAGE_ICON
//
//      This function let the caller set a new icon for a particular common
//      UI page icon (on the property sheet page tab)
//
//  Parameters:
//
//      lParam1 - the handle of common property sheet pages that icon to be
//                set.  This handle must be the handle returned from following
//
//                  CPSFUNC_ADD_PROPSHEETPAGE
//                  CPSFUNC_ADD_HPROPSHEETPAGE
//                  CPSFUNC_INSERT_PSUIPAGE with type of
//                              PSUIPAGEINSERT_PROPSHEETPAGE or
//                              PSUIPAGEINSERT_HPROPSHEETPAGE
//
//      lParam2 - Handle to Icon, this icon is best as 16x16 icon otherwise it
//                will be stretch to 16x16 (pixel).
//
//
//  Return Value:
//
//      The return value is greater than zero if function sucessful, and less
//      or equal to zero if the function failed.
//
//      This function will returned 0 if the property sheet pages is not
//      currently displayed.
//
//      After this function is successful set the icon, the caller can destroy
//      the hIcon using DestroyIcon() if the hIcon is created by CreateIcon().
//      If the hIcon (lParam2) passed is using LoadIcon() then it does not need
//      to destroy the icon.
//
// -------------------------------------------------------------------------
//
// Function = CPSFUNC_SET_DATABLOCK
//
//      This function let the caller register a new data block so it can be
//      later query by other pages in the property sheet, this function should
//      call durning PSN_KILLACTIVE message
//
//  Parameters:
//
//      lParam1 - pointer CPSUIDATABLOCK structure which speicifed the buffer
//                and size for queried datablock identify by lParam2 to be set.
//
//      lParam2 - DWORD Identifier of data block to be set
//
//
//  Return Value:
//
//      The return value is greater than zero if function sucessful which
//      indicate total bytes of data block registered.  If return value is less
//      or equal to zero then function failed and data block is not registered.
//
//      If lParam1 is NULL, (lParam1)->cbData or (lParam1)->pbbData is NULL
//      it return a -1 to indicate an error parameter passed.
//
// -------------------------------------------------------------------------
//
// Function = CPSFUNC_QUERY_DATABLOCK
//
//      This function let the caller query a registered data block so it can
//      used this data block to communicate between property sheet pages.
//      This function should call durning PSN_SETACTIVE message
//
//  Parameters:
//
//      lParam1 - pointer CPSUIDATABLOCK structure which speicifed the buffer
//                and size for queried datablock identify by lParam2
//
//      lParam2 - DWORD Identifier of data block to be queried
//
//
//  Return Value:
//
//      The return value is greater than zero if function sucessful which
//      indicate total bytes of data block copied into the pointer pointed by
//      the lParam1.  If return value is less or equal to zero then function
//      failed and data block is not copied to diciate the spcified datablock
//      Identifier (lParam2) is not found.
//
//      If CPSUIDATABLOCK pointer (lParam1) is NULL, (lParam1)->cbData or
//      (lParam1)->pbData is NULL then return value is the total bytes required
//      to copy the specified datablock identifier, if return value is less or
//      equal to zero then it indicate the spcified datablock identifier is
//      not found.
//
// -------------------------------------------------------------------------
//
// Function = CPSFUNC_SET_DMPUB_HIDEBITS
//
//      This function let the caller hide a set of predefined OPTITEMS in the
//      pages that was created using PSUIPAGEINSERT_PCOMPROPSHEETUI or
//      CPSFUNC_ADD_PCOMPROPSHEETUI with pDlgPage equal to
//      CPSUI_PDLGPAGE_DOCPROP or CPSUI_PDLGPAGE_ADVDOCPROP.
//
//      This function MUST called BEFORE the DOCPROP or ADVDOCPROP property
//      sheet pages are added using  PSUIPAGEINSERT_PCOMPROPSHEETUI or
//      CPSFUNC_ADD_PCOMPROPSHEETUI.
//
//  Parameters:
//
//      lParam1 - prdefined bit array masks to specified which DOCPROP item to
//                be hidden.  Each DMPUB item bit can be generate using macro
//                MAKE_DMPUB_HIDEBIT() and all items can be OR together.
//
//      lParam2 - Not used, MUST be 0
//
//
//  Return Value:
//
//      The return value is equal to lParam1 if this function is called before
//      DOCPROP or ADVDOCPROP pages are added. Return value is zero if these
//      pages already added which means failure.
//
// -------------------------------------------------------------------------
//
// Function = CPSFUNC_IGNORE_CPSUI_PSN_APPLY
//
//      This function let caller control how CPSUI process PSN_APPLY messages
//      for pages added through CPSFUNC_ADD_PCOMPROPSHEETUI or
//      CPSFUNC_INSERT_PSUIPAGE with type of PSUIPAGEINSERT_PROPSHEETPAGE.
//
//      If this function never called, the Default CPSUI behavior is to process
//      PSN_APPLY messages.
//
//  Parameters:
//
//      lParam1 - Handle to the page returned from pages added by using
//                CPSFUNC_ADD_PCOMPROPSHEETUI or CPSFUNC_INSERT_PSUIPAGE with
//                type of PSUIPAGEINSERT_PROPSHEETPAGE.
//
//      lParam2 - A non-zero value indicate to IGNORE the PSN_APPLY messages
//                for pages handle of lParam1.
//
//                A zero value to have CPSUI nomally process (not ignored) the
//                PSN_APPLY messages for pages handle of lParam1.
//
//                WARNING: if a PSN_APPLY messages are ignored, the caller must
//                         simulate a PSN_APPLY using CPSFUNC_DO_APPLY_CPSUI
//                         function or all changes WILL NOT applied, this is
//                         true even user hit 'OK' button.
//
//  Return Value:
//
//      the return value is zero if function failed, or non-zero to indicate
//      the function is successful.
//
// -------------------------------------------------------------------------
//
// Function = CPSFUNC_DO_APPLY_CPSUI
//
//      This function let caller simulate an apply (PSN_APPLY) to the pages
//      which added through CPSFUNC_ADD_PCOMPROPSHEETUI or
//      CPSFUNC_INSERT_PSUIPAGE with type of PSUIPAGEINSERT_PROPSHEETPAGE.
//
//  Parameters:
//
//      lParam1 - Handle to the page returned from pages added by using
//                CPSFUNC_ADD_PCOMPROPSHEETUI or CPSFUNC_INSERT_PSUIPAGE with
//                type of PSUIPAGEINSERT_PROPSHEETPAGE.
//
//      lParam2 - 32-bit flag to indicate how to do apply, currently only
//
//                  APPLYCPSUI_NO_NEWDEF
//
//                      The APPLYCPSUI_NO_NEWDEF bit specified that after the
//                      apply is done the undo buffer for all OPTITEMs still
//                      remain unchanged, this make next undo still possible.
//
//                      If APPLYCPSUI_NO_NEWDEF bit is clear then undo buffers
//                      are re-initialized after apply is done, the current
//                      changes for all OPTITEMs become the new undo default.
//
//
//                  APPLYCPSUI_OK_CANCEL_BUTTON
//
//                      If bit is set then it specified the apply is simulate
//                      a user hit 'Ok' or 'Cancel' button, if this bit is
//                      clear then it simulate a user hit 'Close' or 'Apply'
//                      button.  If caller getting a PSN_APPLY message, it can
//                      simulated using passed PSHNOTIFY (passed as lParam in
//                      WM_NOTIFY message) structure to determine how to set
//                      this bit as follow.
//
//                          if PSHNOTIFY.lParam == 0, then clear this bit
//                          otherwise set this bit.
//
//
//  Return Value:
//
//      the return value is less or equal to zero if it encounter an error and
//      apply failed (the active page will be switch to these pages).
//
//      If return value is greater than zero then changes were applied and
//      function sucessful.
//
// -------------------------------------------------------------------------
//



#define PROPSHEETUI_REASON_INIT             0
#define PROPSHEETUI_REASON_GET_INFO_HEADER  1
#define PROPSHEETUI_REASON_DESTROY          2
#define PROPSHEETUI_REASON_SET_RESULT       3
#define PROPSHEETUI_REASON_GET_ICON         4
#define MAX_PROPSHEETUI_REASON_INDEX        4

#define PROPSHEETUI_INFO_VERSION            0x0100

#define PSUIINFO_UNICODE                    0x0001

typedef struct _PROPSHEETUI_INFO {
    WORD            cbSize;
    WORD            Version;
    WORD            Flags;
    WORD            Reason;
    HANDLE          hComPropSheet;
    PFNCOMPROPSHEET pfnComPropSheet;
    LPARAM          lParamInit;
    ULONG_PTR       UserData;
    ULONG_PTR       Result;
    } PROPSHEETUI_INFO, *PPROPSHEETUI_INFO;


//
// For the PROPSHEETUI_REASON_GET_ICON call which lParam is a pointer to
// PROPSHEETUI_GETICON_INFO
//

typedef struct _PROPSHEETUI_GETICON_INFO {
    WORD    cbSize;
    WORD    Flags;
    WORD    cxIcon;
    WORD    cyIcon;
    HICON   hIcon;
    } PROPSHEETUI_GETICON_INFO, *PPROPSHEETUI_GETICON_INFO;


typedef LONG (FAR *PFNPROPSHEETUI)(PPROPSHEETUI_INFO   pPSUIInfo,
                                   LPARAM              lParam);


//
// PFNPROPSHEETUI
//
//  This function is user defined function which will be called by the common
//  UI when a caller wish to include the executable property sheets.
//
//  pPSUIInfo   - Pointer to PROPSHEETUI_INFO below for description of
//                PROPSHEETUI_INFO.
//
//                If this pointer is NULL then this function is not called from
//                common UI, and lParam should be used to determined the
//                action and outcome of this funciton.
//
//  lParam      - A LPARAM intented for this funciton depends on the reason.
//                If pPSUIInfo is NULL then this function is not called from
//                common UI, the lParam is the parameter which agreed with
//                the caller.
//
//                if pPSUIInfo is not NULL then this function assume the call
//                is from the common UI.  lParam has following meanion depends
//                on the reason field.
//
//                PROPSHEETUI_REASON_INIT
//
//                  The lParam is either passed from CPSFUNC_ADD_PFNPROPSHEETUI
//                  callback function's second parameter (lParam2) or it is
//                  from CommonPropertySheetUI()'s lParam (seccond parameter)
//                  without any modification.
//
//                  The lParam MUST NOT be a variable or a pointer to memory
//                  block which resides on the caller function's stack, since
//                  after this function exit, the lParam will become invalid
//                  and can cause fatal system error.
//
//                  The lParam parameter is copied to the lParamInit field in
//                  PROPSHEETUI_INFO data structure.  The lParamInit field
//                  will be passed to all subsequent pfnPropSheetUI() calls
//                  without any modification.
//
//
//                PROPSHEETUI_REASON_GET_INFO_HEADER:
//
//                  lParam is a pointer to the PROPSHEETUI_INFO_HEADER data
//                  structure. this function must correctly fill this structure
//                  fields before it returned.
//
//
//                PROPSHEETUI_REASON_DESTROY
//
//                  lParam is zero to indicate the destroy is cause either by a
//                  caller calling CPSFUNC_DELETE_HCOMPROPSHEET or failed
//                  in caller's CPSFUNC_ADD_xxxx.
//
//                  lParam is non zero to indicate the destroy is cause by
//                  exiting from the property sheet user interface.
//
//
//                PROPSHEETUI_REASON_SET_RESULT
//
//                  lParam is a pointer to SETRESULT_INFO data structure.
//                  Fields in SETRESULT_INFO data structure is set to following
//
//                      hSetResult: Handle to the common UI property sheet
//                                  pages which added by the CPSFUNC_ADD_xxx
//                                  callback function indices.
//
//                          Result: The result from the hSetResult to be set.
//                                  When return greater than zero then Result
//                                  in this field is set to its parent.
//
//
//                PROPSHEETUI_REASON_GET_ICON
//
//                  lParam is a pointer to PROPSHEETUI_GETICON_INFO data
//                  structure.  Fields in PROPSHEETUI_GETICON_INFO data
//                  structure are set to following
//
//                      cxIcon = cx Icon size in pixel
//                      cyIcon = cy Icon size in pixel
//                      hIcon  = Initial to NULL, and this function must put
//                               the created icon handle in this field before
//                               returned.
//


//
// PROPSHEETUI_INFO
//
//  This structure is used when common UI calling the caller passed function
//  entry point PFNPROPSHEETUI, the pfnPropSheetUI() return a LONG to
//  indicate result of this function.
//
//  When the pfnPropSheetUI() returned, it must also put the required result
//  in the Result field, each PROPSHEETUI_REASON_xxx has different required
//  result as describe below.
//
//
//
//  cbSize          - sizeof this structure (PROPSHEETUI_INFO)
//
//  Version         - the PROPSHEETUI_INFO data structure version. Current
//                    version is set to PROPSHEETUI_INFO_VERSION
//
//  Flags           - One or more following is may be defined
//
//                      PSUIINFO_UNICODE
//
//                          The caller's executable was original compiled was
//                          intented using unicode.
//
//
//  Reason          - Following reasons are defined.
//
//                      PROPSHEETUI_REASON_INIT
//
//                          When first time the pfnPropSheetUI() called, this
//                          reason is used to have the function initialize
//                          itself and use the pfnComPropSheet() function
//                          pointer provided to add new pages to the
//                          hComPropSheet handle passed.   The UserData in this
//                          data structure is initially set equal to zero (0).
//
//                          * Return > 0 to indicate sucesful and <= 0 to
//                            indicate error.
//
//                      *NOTE*
//
//                          The lParam MUST NOT be a variable or a pointer to
//                          memory block which resides on the caller function's
//                          stack, since after this function exit, the lParam
//                          will become invalid and can cause fatal system
//                          error.
//
//                          If this function reason returned failed ( <= 0),
//                          this function (pfnPropSheetUI) will received a
//                          PROPSHEETUI_REASON_DESTROY function reason right
//                          after this function reason returned.
//
//
//                      PROPSHEETUI_REASON_GET_INFO_HEADER
//
//                          It is called after the PROPSHEETUI_REASON_INIT is
//                          successful returned.  This reason is used to asked
//                          the function fill in the PROPSHEETUI_INFO_HEADER
//                          for pop-up the property sheet dialog boxes.
//
//                          lParam in this reason is a pointer to the
//                          PROPSHEETUI_INFO_HEADER data structure, following
//                          fields are requrested to be filled in.
//
//                              Flags       - PSUIHDRF_xxx flags
//                              pTitle      - The property sheet title
//                              hWndParent  - handle to the parent of property
//                                            sheet pages.
//                              hInst       - Instance data handle for this
//                                            function.
//                              hIcon
//                              IconID      - Icon used on the title bar.
//
//                          * Return > 0 to indicate sucesful and pop-up the
//                            property sheet dialog boxes or returned <= 0 to
//                            indicate error (not property sheet UI appeared)
//
//
//                      PROPSHEETUI_REASON_DESTROY
//
//                          When the property sheet ready to dismissed or the
//                          caller is delete the common UI pages added by the
//                          pfnPropSheetUI(), the common UI will call this
//                          entry point to have it de-initialized itself and
//                          free up all the memory used for this function
//                          instance.  The UserData field passed is the
//                          'UserData' field which returned from previous
//                          PROPSHEETUI_REASON_xxxx.
//
//                          When this function called, all hComPropSheet's
//                          children are desotroyed and children's common UI
//                          handles are not longer valid.
//
//                          * Return > 0 to indicate sucesful and <= 0 to
//                            indicate error.
//
//
//                      PROPSHEETUI_REASON_SET_RESULT
//
//                          The reason is used when an added handle from
//                          CPSFUNC_ADD_xxxx whant to return the result to
//                          this pfnPropSheetUI() caller.
//
//                          The lParam in second parameter is a pointer to a
//                          SETRESULT_INFO data structure.
//
//                              hSetResult: specified the common UI property
//                                          sheet page handle which added by
//                                          this function using
//                                          CPSFUNC_ADD_xxx indicies.
//
//                                  Result: Specified the Result to be set to
//                                          this pfnPropSheetUI() form the
//                                          hSetResult property sheet page
//                                          handle. If return value is greater
//                                          than zero then the value in this
//                                          Result field will be set to its
//                                          parent if one exist, at this case
//                                          this function can alter the Result
//                                          field value for its parent.
//
//                          * Returned greater than zero to continue send to
//                            its parent, else it stop sending the Result filed
//                            value to its parent.
//
//
//                      PROPSHEETUI_REASON_GET_ICON
//
//                          The reason is used to retrived the Icon which
//                          represent this pfnPropSheetUI().
//
//                          lParam is a pointer to PROPSHEETUI_GETICON_INFO '
//                          data structure.  Fields in PROPSHEETUI_GETICON_INFO
//                          data structure are set to following
//
//                              cxIcon = cx Icon size in pixel
//                              cyIcon = cy Icon size in pixel
//                              hIcon  = Initial to NULL, and this function
//                                       must put the created icon handle in
//                                       this field before return.
//
//
//                          * Return > 0 to indicate sucesful (hIcon is the
//                            requested icon handle).   Return = 0 to indicate
//                            no icon available, or return < 0 to indicate an
//                            error.
//
//              *NOTE*
//
//                  * For all PROPSHEETUI_REASON_xxx, the function can set new
//                    user defined DWORD data in the PROPSHEETUI_INFO data
//                    structure's UserData field.
//
//                  * For all PROPSHEETUI_REASON_xxx, the function can set new
//                    pfnPropSheetUI() DWORD result in PROPSHEETUI_INFO data
//                    structure's Result field.
//
//
//  hComPropSheet   - Handle to the COMPROPSHEETPAGE which this function should
//                    used as hComPropSheet parameter when calling
//                    pfnComPropSheet() to add or delete common UI property
//                    sheet pages.  The hComPropSheet is the instance handle to
//                    pfnPropSheetUI() function.
//
//  pfnComPropSheet - Pointer to the common UI callback function which for the
//                    pfnPropSheetUI() to add, delete, set user data, for a
//                    completed set of callback, see CPSFUNC_xxx descriptions
//                    above.
//
//  lParamInit      - The lParam originally passed duning the the first call
//                    reason PROPSHEETUI_REASON_INIT.  The lParamInit will be
//                    passed to each PROPSHEETUI_REASON_xxx calls.
//
//  UserData        - the UserData field is an IN and OUT parameter for each
//                    of the Reason,
//
//                      PROPSHEETUI_REASON_INIT
//
//                           IN: Initial set to zero (0).
//
//                          OUT: Specified new callee's own user data which
//                               will be passed back to other reason calls.
//
//
//                      PROPSHEETUI_REASON_DESTROY
//                      PROPSHEETUI_REASON_SET_RESULT
//                      PROPSHEETUI_REASON_GET_INFO_HEADER
//
//                           IN: The UserData specified at time when returned
//                               from the previous PROPSHEETUI_REASON_xxx
//
//                          OUT: Specified new callee's own user data which
//                               will be passed back to other reason calls.
//
//
// Result           - The Result field is an IN and OUT parameter for each of
//                    the reason.
//
//                      PROPSHEETUI_REASON_INIT
//
//                           IN: Set to zero (0).
//
//                          OUT: Set to default result of this PropSheetUI()
//                               function.
//
//
//                      PROPSHEETUI_REASON_DESTROY
//                      PROPSHEETUI_REASON_GET_INFO_HEADER
//                      PROPSHEETUI_REASON_SET_RESULT
//
//                           IN: The current 'Result' returned from previous
//                               PROPSHEETUI_REASON_xxx function.
//
//                          OUT: Set the new result of this PropSheetUI()
//                               function.
//
//


#define PSUIHDRF_OBSOLETE       0x0001
#define PSUIHDRF_NOAPPLYNOW     0x0002
#define PSUIHDRF_PROPTITLE      0x0004
#define PSUIHDRF_USEHICON       0x0008
#define PSUIHDRF_DEFTITLE       0x0010
#define PSUIHDRF_EXACT_PTITLE   0x0020

typedef struct _PROPSHEETUI_INFO_HEADER {
    WORD                    cbSize;
    WORD                    Flags;
    LPTSTR                  pTitle;
    HWND                    hWndParent;
    HINSTANCE               hInst;
    union {
        HICON               hIcon;
        ULONG_PTR           IconID;
        } DUMMYUNIONNAME;
    } PROPSHEETUI_INFO_HEADER, *PPROPSHEETUI_INFO_HEADER;

//
// PROPSHEETUI_INFO_HEADER
//
//  This data structure is used when common UI ready to pop-up the property
//  sheet page dialog boxes and it asked caller to provide more information.
//
//  Common property sheet UI passed this data structure as lParam when it call
//  provided pfnPropSheetUI() with PROPSHEETUI_REASON_GET_INFO_HEADER reason.
//
//
//  cbSize      - size of this structure
//
//  Flags       - PSUIHDRF_xxxx flags
//
//                  PSUIHDRF_OBSOLETE
//
//                      Not used, must not set this bit
//
//
//                  PSUIHDRF_NOAPPLYNOW
//
//                      Remove 'Apply Now' button.
//
//
//                  PSUIHDRF_PROPTITLE
//
//                      Automatically include 'Properties' in the title bar
//
//
//                  PSUIHDRF_USEHICON
//
//                      If this bit is specified then hIcon union field is
//                      a valid handle to the icon otherwise the IconID is
//                      the either caller's resource ID or common UI standard
//                      icon ID.
//
//                  PSUIHDRF_DEFTITLE
//
//                      Automatically include 'Default' in the title bar, the
//                      'Default' always added right after pTitle and before
//                      'Properties' if PSUIHDRF_PROPTITLE flag is set.
//
//                  PSUIHDRF_EXACT_PTITLE
//
//                      This flag indicate the pTitle set in this structure
//                      will be use without any modification by the compstui
//                      ie. compstui will not modified pTitle in any way and
//                      it will ignored PSUIHDRF_PROPTITLE, PSUIHDRF_DEFTITLE
//
//
//  pTitle      - Pointer to the NULL terminated caption name for the
//                property sheets.
//
//                  ** See LPTSTR typedef description above
//
//  hWndParent  - The handle of the window which will be parent of the common
//                UI property sheets, if NULL then current active window for
//                the calling thread is used.
//
//  hInst       - the caller's handle to its instance.  Commom UI use this
//                handle to load caller's icon and other resources.
//
//  hIcon
//  IconID      - Specified the icon which put on the title bar, it either a
//                handle to the icon or a icon resource ID depends on the
//                PSUIHDRF_USEHICON flag.
//



//
// LONG
// CommonPropertySheetUI(
//     HWND            hWndOwner,
//     PFNPROPSHEETUI  pfnPropSheetUI,
//     LPARAM          lParam,
//     LPDWORD         pResult
//     );
//
//
// The CommonPropSheetUI is the main entry point for the common property sheet
// user interface.   The original caller that wish to using common UI to pop-up
// property sheet will call this function and passed its own PFNPROPSHEETUI
// function address and a long parameter.
//
// If pfnPropSheetUI function return a LONG number greater than zero (0) then
// common UI will pop-up the property sheet page dialog boxes, when Property
// sheet pages is finished. (either hit Ok or Cancel) it will return the
// result of CPSUI_xxxx back to the caller.
//
// If pfnPropSheetUI function return a LONG number equal or less than zero (0)
// then it will return the CPSUI_CANCEL back to caller without pop-up the
// property sheet page dialog boxes.
//
//
//  Parameters:
//
//      hWndOwner       - Window handle for the owner of this proerty sheet
//                        pages dialog boxes.
//
//      pfnPropSheetUI  - a PFNPROPSHEETUI function pointer which is used by
//                        the caller to add its property sheet pages.
//
//      lParam          - a long parameter will be passed to the pfnPropSheetUI
//                        funciton.  The common UI called the pfnPropSheetUI as
//
//                          PROPSHEETUI_INFO    PSUIInfo;
//
//                          pfnPropSheetUI(&PSUIInfo, lParam);
//
//                        The caller must use pfnComPropSheet() to add/delete
//                        pages.  When it is done adding pages, it retuned
//                        greater than zero to indicate successful, and return
//                        less or equal to zero to indicate failure.
//
//      pResult         - a pointer to DWORD which received the final result
//                        of pfnPropSheetUI() funciton, this result is a copy
//                        from Result field of PROPSHEETUI_INFO data structure
//                        which passed to the pfnPropSheetUI() as the first
//                        parameter.  The pResult only will be set if the
//                        returned value from CommonPropertySheetUI() is not
//                        ERR_CPSUI_xxx.
//
//                        if pResult is NULL then common UI will not return
//                        pfnPropSheetUI()'s result back.
//
//
//  Return Value:
//
//      LONG    - < 0                   - property page does not displayed and
//                                        ERR_CPSUI_xxx is the error code
//                CPSUI_OK              - property page displayed.
//                CPSUI_RESTARTWINDOWS  - property page displayed and need to
//                                        restart window to take effect
//                CPSUI_REBOOTSYSTEM    - property page dispalyed and need
//                                        to reboot system to take effect
//
//


LONG
APIENTRY
CommonPropertySheetUIA(
    HWND            hWndOwner,
    PFNPROPSHEETUI  pfnPropSheetUI,
    LPARAM          lParam,
    LPDWORD         pResult
    );

LONG
APIENTRY
CommonPropertySheetUIW(
    HWND            hWndOwner,
    PFNPROPSHEETUI  pfnPropSheetUI,
    LPARAM          lParam,
    LPDWORD         pResult
    );


#ifdef UNICODE
#define CommonPropertySheetUI   CommonPropertySheetUIW
#else
#define CommonPropertySheetUI   CommonPropertySheetUIA
#endif



//
// GetCPSUIUserData() and SetCPSUIUserData() is used for the pages added
// by the CPSFUNC_ADD_PCOMPROPSHEETUI.  The caller add this function and has
// sub class dialog procedure should not set DWLP_USERDATA but calling these
// function instead, otherwise the system can failed.
//

ULONG_PTR
APIENTRY
GetCPSUIUserData(
    HWND    hDlg
    );

BOOL
APIENTRY
SetCPSUIUserData(
    HWND        hDlg,
    ULONG_PTR   CPSUIUserData
    );


#define CPSUI_CANCEL                        0
#define CPSUI_OK                            1
#define CPSUI_RESTARTWINDOWS                2
#define CPSUI_REBOOTSYSTEM                  3

#define ERR_CPSUI_GETLASTERROR              -1
#define ERR_CPSUI_ALLOCMEM_FAILED           -2
#define ERR_CPSUI_INVALID_PDATA             -3
#define ERR_CPSUI_INVALID_LPARAM            -4
#define ERR_CPSUI_NULL_HINST                -5
#define ERR_CPSUI_NULL_CALLERNAME           -6
#define ERR_CPSUI_NULL_OPTITEMNAME          -7
#define ERR_CPSUI_NO_PROPSHEETPAGE          -8
#define ERR_CPSUI_TOO_MANY_PROPSHEETPAGES   -9
#define ERR_CPSUI_CREATEPROPPAGE_FAILED     -10
#define ERR_CPSUI_MORE_THAN_ONE_TVPAGE      -11
#define ERR_CPSUI_MORE_THAN_ONE_STDPAGE     -12
#define ERR_CPSUI_INVALID_PDLGPAGE          -13
#define ERR_CPSUI_INVALID_DLGPAGE_CBSIZE    -14
#define ERR_CPSUI_TOO_MANY_DLGPAGES         -15
#define ERR_CPSUI_INVALID_DLGPAGEIDX        -16
#define ERR_CPSUI_SUBITEM_DIFF_DLGPAGEIDX   -17
#define ERR_CPSUI_NULL_POPTITEM             -18
#define ERR_CPSUI_INVALID_OPTITEM_CBSIZE    -19
#define ERR_CPSUI_INVALID_OPTTYPE_CBSIZE    -20
#define ERR_CPSUI_INVALID_OPTTYPE_COUNT     -21
#define ERR_CPSUI_NULL_POPTPARAM            -22
#define ERR_CPSUI_INVALID_OPTPARAM_CBSIZE   -23
#define ERR_CPSUI_INVALID_EDITBOX_PSEL      -24
#define ERR_CPSUI_INVALID_EDITBOX_BUF_SIZE  -25
#define ERR_CPSUI_INVALID_ECB_CBSIZE        -26
#define ERR_CPSUI_NULL_ECB_PTITLE           -27
#define ERR_CPSUI_NULL_ECB_PCHECKEDNAME     -28
#define ERR_CPSUI_INVALID_DMPUBID           -29
#define ERR_CPSUI_INVALID_DMPUB_TVOT        -30
#define ERR_CPSUI_CREATE_TRACKBAR_FAILED    -31
#define ERR_CPSUI_CREATE_UDARROW_FAILED     -32
#define ERR_CPSUI_CREATE_IMAGELIST_FAILED   -33
#define ERR_CPSUI_INVALID_TVOT_TYPE         -34
#define ERR_CPSUI_INVALID_LBCB_TYPE         -35
#define ERR_CPSUI_SUBITEM_DIFF_OPTIF_HIDE   -36
#define ERR_CPSUI_INVALID_PUSHBUTTON_TYPE   -38
#define ERR_CPSUI_INVALID_EXTPUSH_CBSIZE    -39
#define ERR_CPSUI_NULL_EXTPUSH_DLGPROC      -40
#define ERR_CPSUI_NO_EXTPUSH_DLGTEMPLATEID  -41
#define ERR_CPSUI_NULL_EXTPUSH_CALLBACK     -42
#define ERR_CPSUI_DMCOPIES_USE_EXTPUSH      -43
#define ERR_CPSUI_ZERO_OPTITEM              -44


#define ERR_CPSUI_FUNCTION_NOT_IMPLEMENTED  -9999
#define ERR_CPSUI_INTERNAL_ERROR            -10000

#endif  // (!defined(RC_INVOKED))



//
//****************************************************************************
//*                                                                          *
//*      Common Property Sheet UI resource ID for the ICONs and STRINGs      *
//*                                                                          *
//* The Resource ID from 64000 to 65535 are reserved for common UI and must  *
//* not used as caller resource ID else the string, icon loading will not be *
//* correct.                                                                 *
//*                                                                          *
//****************************************************************************
//


//
// Common UI standard 32x32, 16x16 color and monochrome Icon IDs
//

#define IDI_CPSUI_ICONID_FIRST          64000

#define IDI_CPSUI_EMPTY                 64000
#define IDI_CPSUI_SEL_NONE              64001
#define IDI_CPSUI_WARNING               64002
#define IDI_CPSUI_NO                    64003
#define IDI_CPSUI_YES                   64004
#define IDI_CPSUI_FALSE                 64005
#define IDI_CPSUI_TRUE                  64006
#define IDI_CPSUI_OFF                   64007
#define IDI_CPSUI_ON                    64008
#define IDI_CPSUI_PAPER_OUTPUT          64009
#define IDI_CPSUI_ENVELOPE              64010
#define IDI_CPSUI_MEM                   64011
#define IDI_CPSUI_FONTCARTHDR           64012
#define IDI_CPSUI_FONTCART              64013
#define IDI_CPSUI_STAPLER_ON            64014
#define IDI_CPSUI_STAPLER_OFF           64015
#define IDI_CPSUI_HT_HOST               64016
#define IDI_CPSUI_HT_DEVICE             64017
#define IDI_CPSUI_TT_PRINTASGRAPHIC     64018
#define IDI_CPSUI_TT_DOWNLOADSOFT       64019
#define IDI_CPSUI_TT_DOWNLOADVECT       64020
#define IDI_CPSUI_TT_SUBDEV             64021
#define IDI_CPSUI_PORTRAIT              64022
#define IDI_CPSUI_LANDSCAPE             64023
#define IDI_CPSUI_ROT_LAND              64024
#define IDI_CPSUI_AUTOSEL               64025
#define IDI_CPSUI_PAPER_TRAY            64026
#define IDI_CPSUI_PAPER_TRAY2           64027
#define IDI_CPSUI_PAPER_TRAY3           64028
#define IDI_CPSUI_TRANSPARENT           64029
#define IDI_CPSUI_COLLATE               64030
#define IDI_CPSUI_DUPLEX_NONE           64031
#define IDI_CPSUI_DUPLEX_HORZ           64032
#define IDI_CPSUI_DUPLEX_VERT           64033
#define IDI_CPSUI_RES_DRAFT             64034
#define IDI_CPSUI_RES_LOW               64035
#define IDI_CPSUI_RES_MEDIUM            64036
#define IDI_CPSUI_RES_HIGH              64037
#define IDI_CPSUI_RES_PRESENTATION      64038
#define IDI_CPSUI_MONO                  64039
#define IDI_CPSUI_COLOR                 64040
#define IDI_CPSUI_DITHER_NONE           64041
#define IDI_CPSUI_DITHER_COARSE         64042
#define IDI_CPSUI_DITHER_FINE           64043
#define IDI_CPSUI_DITHER_LINEART        64044
#define IDI_CPSUI_SCALING               64045
#define IDI_CPSUI_COPY                  64046
#define IDI_CPSUI_HTCLRADJ              64047
#define IDI_CPSUI_HALFTONE_SETUP        64048
#define IDI_CPSUI_WATERMARK             64049
#define IDI_CPSUI_ERROR                 64050
#define IDI_CPSUI_ICM_OPTION            64051
#define IDI_CPSUI_ICM_METHOD            64052
#define IDI_CPSUI_ICM_INTENT            64053
#define IDI_CPSUI_STD_FORM              64054
#define IDI_CPSUI_OUTBIN                64055
#define IDI_CPSUI_OUTPUT                64056
#define IDI_CPSUI_GRAPHIC               64057
#define IDI_CPSUI_ADVANCE               64058
#define IDI_CPSUI_DOCUMENT              64059
#define IDI_CPSUI_DEVICE                64060
#define IDI_CPSUI_DEVICE2               64061
#define IDI_CPSUI_PRINTER               64062
#define IDI_CPSUI_PRINTER2              64063
#define IDI_CPSUI_PRINTER3              64064
#define IDI_CPSUI_PRINTER4              64065
#define IDI_CPSUI_OPTION                64066
#define IDI_CPSUI_OPTION2               64067
#define IDI_CPSUI_STOP                  64068
#define IDI_CPSUI_NOTINSTALLED          64069
#define IDI_CPSUI_WARNING_OVERLAY       64070
#define IDI_CPSUI_STOP_WARNING_OVERLAY  64071
#define IDI_CPSUI_GENERIC_OPTION        64072
#define IDI_CPSUI_GENERIC_ITEM          64073
#define IDI_CPSUI_RUN_DIALOG            64074
#define IDI_CPSUI_QUESTION              64075
#define IDI_CPSUI_FORMTRAYASSIGN        64076
#define IDI_CPSUI_PRINTER_FOLDER        64077
#define IDI_CPSUI_INSTALLABLE_OPTION    64078
#define IDI_CPSUI_PRINTER_FEATURE       64079
#define IDI_CPSUI_DEVICE_FEATURE        64080
#define IDI_CPSUI_FONTSUB               64081
#define IDI_CPSUI_POSTSCRIPT            64082
#define IDI_CPSUI_TELEPHONE             64083
#define IDI_CPSUI_DUPLEX_NONE_L         64084
#define IDI_CPSUI_DUPLEX_HORZ_L         64085
#define IDI_CPSUI_DUPLEX_VERT_L         64086
#define IDI_CPSUI_LF_PEN_PLOTTER        64087
#define IDI_CPSUI_SF_PEN_PLOTTER        64088
#define IDI_CPSUI_LF_RASTER_PLOTTER     64089
#define IDI_CPSUI_SF_RASTER_PLOTTER     64090
#define IDI_CPSUI_ROLL_PAPER            64091
#define IDI_CPSUI_PEN_CARROUSEL         64092
#define IDI_CPSUI_PLOTTER_PEN           64093
#define IDI_CPSUI_MANUAL_FEED           64094
#define IDI_CPSUI_FAX                   64095
#define IDI_CPSUI_PAGE_PROTECT          64096
#define IDI_CPSUI_ENVELOPE_FEED         64097
#define IDI_CPSUI_FONTCART_SLOT         64098
#define IDI_CPSUI_LAYOUT_BMP_PORTRAIT   64099
#define IDI_CPSUI_LAYOUT_BMP_ARROWL     64100
#define IDI_CPSUI_LAYOUT_BMP_ARROWS     64101
#define IDI_CPSUI_LAYOUT_BMP_BOOKLETL   64102
#define IDI_CPSUI_LAYOUT_BMP_BOOKLETP   64103
#define IDI_CPSUI_ICONID_LAST           64103

//
// Common UI standard String IDs
//


#define IDS_CPSUI_STRID_FIRST           64700

#define IDS_CPSUI_SETUP                 64700
#define IDS_CPSUI_MORE                  64701
#define IDS_CPSUI_CHANGE                64702
#define IDS_CPSUI_OPTION                64703
#define IDS_CPSUI_OF                    64704
#define IDS_CPSUI_RANGE_FROM            64705
#define IDS_CPSUI_TO                    64706
#define IDS_CPSUI_COLON_SEP             64707
#define IDS_CPSUI_LEFT_ANGLE            64708
#define IDS_CPSUI_RIGHT_ANGLE           64709
#define IDS_CPSUI_SLASH_SEP             64710
#define IDS_CPSUI_PERCENT               64711
#define IDS_CPSUI_LBCB_NOSEL            64712
#define IDS_CPSUI_PROPERTIES            64713
#define IDS_CPSUI_DEFAULTDOCUMENT       64714
#define IDS_CPSUI_DOCUMENT              64715
#define IDS_CPSUI_ADVANCEDOCUMENT       64716
#define IDS_CPSUI_PRINTER               64717
#define IDS_CPSUI_AUTOSELECT            64718
#define IDS_CPSUI_PAPER_OUTPUT          64719
#define IDS_CPSUI_GRAPHIC               64720
#define IDS_CPSUI_OPTIONS               64721
#define IDS_CPSUI_ADVANCED              64722
#define IDS_CPSUI_STDDOCPROPTAB         64723
#define IDS_CPSUI_STDDOCPROPTVTAB       64724
#define IDS_CPSUI_DEVICEOPTIONS         64725
#define IDS_CPSUI_FALSE                 64726
#define IDS_CPSUI_TRUE                  64727
#define IDS_CPSUI_NO                    64728
#define IDS_CPSUI_YES                   64729
#define IDS_CPSUI_OFF                   64730
#define IDS_CPSUI_ON                    64731
#define IDS_CPSUI_DEFAULT               64732
#define IDS_CPSUI_ERROR                 64733
#define IDS_CPSUI_NONE                  64734
#define IDS_CPSUI_NOT                   64735
#define IDS_CPSUI_EXIST                 64736
#define IDS_CPSUI_NOTINSTALLED          64737
#define IDS_CPSUI_ORIENTATION           64738
#define IDS_CPSUI_SCALING               64739
#define IDS_CPSUI_NUM_OF_COPIES         64740
#define IDS_CPSUI_SOURCE                64741
#define IDS_CPSUI_PRINTQUALITY          64742
#define IDS_CPSUI_RESOLUTION            64743
#define IDS_CPSUI_COLOR_APPERANCE       64744
#define IDS_CPSUI_DUPLEX                64745
#define IDS_CPSUI_TTOPTION              64746
#define IDS_CPSUI_FORMNAME              64747
#define IDS_CPSUI_ICM                   64748
#define IDS_CPSUI_ICMMETHOD             64749
#define IDS_CPSUI_ICMINTENT             64750
#define IDS_CPSUI_MEDIA                 64751
#define IDS_CPSUI_DITHERING             64752
#define IDS_CPSUI_PORTRAIT              64753
#define IDS_CPSUI_LANDSCAPE             64754
#define IDS_CPSUI_ROT_LAND              64755
#define IDS_CPSUI_COLLATE               64756
#define IDS_CPSUI_COLLATED              64757
#define IDS_CPSUI_PRINTFLDSETTING       64758
#define IDS_CPSUI_DRAFT                 64759
#define IDS_CPSUI_LOW                   64760
#define IDS_CPSUI_MEDIUM                64761
#define IDS_CPSUI_HIGH                  64762
#define IDS_CPSUI_PRESENTATION          64763
#define IDS_CPSUI_COLOR                 64764
#define IDS_CPSUI_GRAYSCALE             64765
#define IDS_CPSUI_MONOCHROME            64766
#define IDS_CPSUI_SIMPLEX               64767
#define IDS_CPSUI_HORIZONTAL            64768
#define IDS_CPSUI_VERTICAL              64769
#define IDS_CPSUI_LONG_SIDE             64770
#define IDS_CPSUI_SHORT_SIDE            64771
#define IDS_CPSUI_TT_PRINTASGRAPHIC     64772
#define IDS_CPSUI_TT_DOWNLOADSOFT       64773
#define IDS_CPSUI_TT_DOWNLOADVECT       64774
#define IDS_CPSUI_TT_SUBDEV             64775
#define IDS_CPSUI_ICM_BLACKWHITE        64776
#define IDS_CPSUI_ICM_NO                64777
#define IDS_CPSUI_ICM_YES               64778
#define IDS_CPSUI_ICM_SATURATION        64779
#define IDS_CPSUI_ICM_CONTRAST          64780
#define IDS_CPSUI_ICM_COLORMETRIC       64781
#define IDS_CPSUI_STANDARD              64782
#define IDS_CPSUI_GLOSSY                64783
#define IDS_CPSUI_TRANSPARENCY          64784
#define IDS_CPSUI_REGULAR               64785
#define IDS_CPSUI_BOND                  64786
#define IDS_CPSUI_COARSE                64787
#define IDS_CPSUI_FINE                  64788
#define IDS_CPSUI_LINEART               64789
#define IDS_CPSUI_ERRDIFFUSE            64790
#define IDS_CPSUI_HALFTONE              64791
#define IDS_CPSUI_HTCLRADJ              64792
#define IDS_CPSUI_USE_HOST_HT           64793
#define IDS_CPSUI_USE_DEVICE_HT         64794
#define IDS_CPSUI_USE_PRINTER_HT        64795
#define IDS_CPSUI_OUTBINASSIGN          64796
#define IDS_CPSUI_WATERMARK             64797
#define IDS_CPSUI_FORMTRAYASSIGN        64798
#define IDS_CPSUI_UPPER_TRAY            64799
#define IDS_CPSUI_ONLYONE               64800
#define IDS_CPSUI_LOWER_TRAY            64801
#define IDS_CPSUI_MIDDLE_TRAY           64802
#define IDS_CPSUI_MANUAL_TRAY           64803
#define IDS_CPSUI_ENVELOPE_TRAY         64804
#define IDS_CPSUI_ENVMANUAL_TRAY        64805
#define IDS_CPSUI_TRACTOR_TRAY          64806
#define IDS_CPSUI_SMALLFMT_TRAY         64807
#define IDS_CPSUI_LARGEFMT_TRAY         64808
#define IDS_CPSUI_LARGECAP_TRAY         64809
#define IDS_CPSUI_CASSETTE_TRAY         64810
#define IDS_CPSUI_DEFAULT_TRAY          64811
#define IDS_CPSUI_FORMSOURCE            64812
#define IDS_CPSUI_MANUALFEED            64813
#define IDS_CPSUI_PRINTERMEM_KB         64814
#define IDS_CPSUI_PRINTERMEM_MB         64815
#define IDS_CPSUI_PAGEPROTECT           64816
#define IDS_CPSUI_HALFTONE_SETUP        64817
#define IDS_CPSUI_INSTFONTCART          64818
#define IDS_CPSUI_SLOT1                 64819
#define IDS_CPSUI_SLOT2                 64820
#define IDS_CPSUI_SLOT3                 64821
#define IDS_CPSUI_SLOT4                 64822
#define IDS_CPSUI_LEFT_SLOT             64823
#define IDS_CPSUI_RIGHT_SLOT            64824
#define IDS_CPSUI_STAPLER               64825
#define IDS_CPSUI_STAPLER_ON            64826
#define IDS_CPSUI_STAPLER_OFF           64827
#define IDS_CPSUI_STACKER               64828
#define IDS_CPSUI_MAILBOX               64829
#define IDS_CPSUI_COPY                  64830
#define IDS_CPSUI_COPIES                64831
#define IDS_CPSUI_TOTAL                 64832
#define IDS_CPSUI_MAKE                  64833
#define IDS_CPSUI_PRINT                 64834
#define IDS_CPSUI_FAX                   64835
#define IDS_CPSUI_PLOT                  64836
#define IDS_CPSUI_SLOW                  64837
#define IDS_CPSUI_FAST                  64838
#define IDS_CPSUI_ROTATED               64839
#define IDS_CPSUI_RESET                 64840
#define IDS_CPSUI_ALL                   64841
#define IDS_CPSUI_DEVICE                64842
#define IDS_CPSUI_SETTINGS              64843
#define IDS_CPSUI_REVERT                64844
#define IDS_CPSUI_CHANGES               64845
#define IDS_CPSUI_CHANGED               64846
#define IDS_CPSUI_WARNING               64847
#define IDS_CPSUI_ABOUT                 64848
#define IDS_CPSUI_VERSION               64849
#define IDS_CPSUI_NO_NAME               64850
#define IDS_CPSUI_SETTING               64851
#define IDS_CPSUI_DEVICE_SETTINGS       64852
#define IDS_CPSUI_STDDOCPROPTAB1        64853
#define IDS_CPSUI_STDDOCPROPTAB2        64854
#define IDS_CPSUI_PAGEORDER             64855
#define IDS_CPSUI_FRONTTOBACK           64856
#define IDS_CPSUI_BACKTOFRONT           64857
#define IDS_CPSUI_QUALITY_SETTINGS      64858
#define IDS_CPSUI_QUALITY_DRAFT         64859
#define IDS_CPSUI_QUALITY_BETTER        64860
#define IDS_CPSUI_QUALITY_BEST          64861
#define IDS_CPSUI_QUALITY_CUSTOM        64862
#define IDS_CPSUI_OUTPUTBIN             64863
#define IDS_CPSUI_NUP                   64864
#define IDS_CPSUI_NUP_NORMAL            64865
#define IDS_CPSUI_NUP_TWOUP             64866
#define IDS_CPSUI_NUP_FOURUP            64867
#define IDS_CPSUI_NUP_SIXUP             64868
#define IDS_CPSUI_NUP_NINEUP            64869
#define IDS_CPSUI_NUP_SIXTEENUP         64870
#define IDS_CPSUI_SIDE1                 64871
#define IDS_CPSUI_SIDE2                 64872
#define IDS_CPSUI_BOOKLET               64873

#define IDS_CPSUI_STRID_LAST            64873


#ifdef __cplusplus
}
#endif

#endif      // _COMPSTUI
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\public\oak\inc\d3dnthal.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   d3dnthal.h
 *  Content:    Direct3D HAL include file for NT
 *
 ***************************************************************************/

#ifndef _D3DNTHAL_H_
#define _D3DNTHAL_H_

#include <ddrawint.h>
#ifndef _WINDOWS_
#define _WINDOWS_
#include <d3dtypes.h>
#include <d3dcaps.h>
#undef _WINDOWS_
#else
#include <d3dtypes.h>
#include <d3dcaps.h>
#endif

/*
 * If the HAL driver does not implement clipping, it must reserve at least
 * this much space at the end of the LocalVertexBuffer for use by the HEL
 * clipping.  I.e. the vertex buffer contain dwNumVertices+dwNumClipVertices
 * vertices.  No extra space is needed by the HEL clipping in the
 * LocalHVertexBuffer.
 */
#define D3DNTHAL_NUMCLIPVERTICES    20

/*
 * If no dwNumVertices is given, this is what will be used.
 */
#define D3DNTHAL_DEFAULT_TL_NUM ((32 * 1024) / sizeof (D3DTLVERTEX))
#define D3DNTHAL_DEFAULT_H_NUM  ((32 * 1024) / sizeof (D3DHVERTEX))

/*
 * Description for a device.
 * This is used to describe a device that is to be created or to query
 * the current device.
 *
 * For DX5 and subsequent runtimes, D3DNTDEVICEDESC is a user-visible
 * structure that is not seen by the device drivers. The runtime
 * stitches a D3DNTDEVICEDESC together using the D3DNTDEVICEDESC_V1
 * embedded in the GLOBALDRIVERDATA and the extended caps queried
 * from the driver using GetDriverInfo.
 */

typedef struct _D3DNTHALDeviceDesc_V1 {
    DWORD        dwSize;             /* Size of D3DNTHALDEVICEDESC_V1 structure */
    DWORD        dwFlags;                /* Indicates which fields have valid data */
    D3DCOLORMODEL    dcmColorModel;      /* Color model of device */
    DWORD        dwDevCaps;              /* Capabilities of device */
    D3DTRANSFORMCAPS dtcTransformCaps;       /* Capabilities of transform */
    BOOL         bClipping;              /* Device can do 3D clipping */
    D3DLIGHTINGCAPS  dlcLightingCaps;        /* Capabilities of lighting */
    D3DPRIMCAPS      dpcLineCaps;
    D3DPRIMCAPS      dpcTriCaps;
    DWORD        dwDeviceRenderBitDepth; /* One of DDBB_8, 16, etc.. */
    DWORD        dwDeviceZBufferBitDepth;/* One of DDBD_16, 32, etc.. */
    DWORD        dwMaxBufferSize;        /* Maximum execute buffer size */
    DWORD        dwMaxVertexCount;       /* Maximum vertex count */
} D3DNTHALDEVICEDESC_V1, *LPD3DNTHALDEVICEDESC_V1;

#define D3DNTHALDEVICEDESCSIZE_V1 (sizeof(D3DNTHALDEVICEDESC_V1))

/*
 * This is equivalent to the D3DNTDEVICEDESC understood by DX5, available only
 * from DX6. It is the same as D3DNTDEVICEDESC structure in DX5.
 * D3DNTDEVICEDESC is still the user-visible structure that is not seen by the
 * device drivers. The runtime stitches a D3DNTDEVICEDESC together using the
 * D3DNTDEVICEDESC_V1 embedded in the GLOBALDRIVERDATA and the extended caps
 * queried from the driver using GetDriverInfo.
 */

typedef struct _D3DNTHALDeviceDesc_V2 {
    DWORD        dwSize;             /* Size of D3DNTDEVICEDESC structure */
    DWORD        dwFlags;                /* Indicates which fields have valid data */
    D3DCOLORMODEL    dcmColorModel;      /* Color model of device */
    DWORD        dwDevCaps;              /* Capabilities of device */
    D3DTRANSFORMCAPS dtcTransformCaps;       /* Capabilities of transform */
    BOOL         bClipping;              /* Device can do 3D clipping */
    D3DLIGHTINGCAPS  dlcLightingCaps;        /* Capabilities of lighting */
    D3DPRIMCAPS      dpcLineCaps;
    D3DPRIMCAPS      dpcTriCaps;
    DWORD            dwDeviceRenderBitDepth; /* One of DDBD_16, etc.. */
    DWORD        dwDeviceZBufferBitDepth;/* One of DDBD_16, 32, etc.. */
    DWORD        dwMaxBufferSize;        /* Maximum execute buffer size */
    DWORD        dwMaxVertexCount;       /* Maximum vertex count */

    DWORD        dwMinTextureWidth, dwMinTextureHeight;
    DWORD        dwMaxTextureWidth, dwMaxTextureHeight;
    DWORD        dwMinStippleWidth, dwMaxStippleWidth;
    DWORD        dwMinStippleHeight, dwMaxStippleHeight;

} D3DNTHALDEVICEDESC_V2, *LPD3DNTHALDEVICEDESC_V2;

#define D3DNTHALDEVICEDESCSIZE_V2 (sizeof(D3DNTHALDEVICEDESC_V2))

#if(DIRECT3D_VERSION >= 0x0700)
/*
 * This is equivalent to the D3DNTDEVICEDESC understood by DX6, available only
 * from DX6. It is the same as D3DNTDEVICEDESC structure in DX6.
 * D3DNTDEVICEDESC is still the user-visible structure that is not seen by the
 * device drivers. The runtime stitches a D3DNTDEVICEDESC together using the
 * D3DNTDEVICEDESC_V1 embedded in the GLOBALDRIVERDATA and the extended caps
 * queried from the driver using GetDriverInfo.
 */

typedef struct _D3DNTDeviceDesc_V3 {
    DWORD        dwSize;             /* Size of D3DNTDEVICEDESC structure */
    DWORD        dwFlags;                /* Indicates which fields have valid data */
    D3DCOLORMODEL    dcmColorModel;      /* Color model of device */
    DWORD        dwDevCaps;              /* Capabilities of device */
    D3DTRANSFORMCAPS dtcTransformCaps;       /* Capabilities of transform */
    BOOL         bClipping;              /* Device can do 3D clipping */
    D3DLIGHTINGCAPS  dlcLightingCaps;        /* Capabilities of lighting */
    D3DPRIMCAPS      dpcLineCaps;
    D3DPRIMCAPS      dpcTriCaps;
    DWORD            dwDeviceRenderBitDepth; /* One of DDBD_16, etc.. */
    DWORD        dwDeviceZBufferBitDepth;/* One of DDBD_16, 32, etc.. */
    DWORD        dwMaxBufferSize;        /* Maximum execute buffer size */
    DWORD        dwMaxVertexCount;       /* Maximum vertex count */

    DWORD        dwMinTextureWidth, dwMinTextureHeight;
    DWORD        dwMaxTextureWidth, dwMaxTextureHeight;
    DWORD        dwMinStippleWidth, dwMaxStippleWidth;
    DWORD        dwMinStippleHeight, dwMaxStippleHeight;

    DWORD       dwMaxTextureRepeat;
    DWORD       dwMaxTextureAspectRatio;
    DWORD       dwMaxAnisotropy;
    D3DVALUE    dvGuardBandLeft;
    D3DVALUE    dvGuardBandTop;
    D3DVALUE    dvGuardBandRight;
    D3DVALUE    dvGuardBandBottom;
    D3DVALUE    dvExtentsAdjust;
    DWORD       dwStencilCaps;
    DWORD       dwFVFCaps;  /* low 4 bits: 0 implies TLVERTEX only, 1..8 imply FVF aware */
    DWORD       dwTextureOpCaps;
    WORD        wMaxTextureBlendStages;
    WORD        wMaxSimultaneousTextures;
} D3DNTDEVICEDESC_V3, *LPD3DNTDEVICEDESC_V3;

#define D3DNTDEVICEDESCSIZE_V3 (sizeof(D3DNTDEVICEDESC_V3))
#endif /* DIRECT3D_VERSION >= 0x0700 */
/* --------------------------------------------------------------
 * Instantiated by the HAL driver on driver connection.
 *
 * Regarding dwNumVertices, specify 0 if you are relying on the HEL to do
 * everything and you do not need the resultant TLVertex buffer to reside
 * in device memory.
 * The HAL driver will be asked to allocate dwNumVertices + dwNumClipVertices
 * in the case described above.
 */
typedef struct _D3DNTHAL_GLOBALDRIVERDATA {
    DWORD       dwSize;         // Size of this structure
    D3DNTHALDEVICEDESC_V1 hwCaps;       // Capabilities of the hardware
    DWORD       dwNumVertices;      // see following comment
    DWORD       dwNumClipVertices;  // see following comment
    DWORD       dwNumTextureFormats;    // Number of texture formats
    LPDDSURFACEDESC lpTextureFormats;   // Pointer to texture formats
} D3DNTHAL_GLOBALDRIVERDATA;
typedef D3DNTHAL_GLOBALDRIVERDATA *LPD3DNTHAL_GLOBALDRIVERDATA;

#define D3DNTHAL_GLOBALDRIVERDATASIZE (sizeof(D3DNTHAL_GLOBALDRIVERDATA))

#if(DIRECT3D_VERSION >= 0x0700)
/* --------------------------------------------------------------
 * Extended caps introduced with DX5 and queried with
 * GetDriverInfo (GUID_D3DExtendedCaps).
 */
typedef struct _D3DNTHAL_D3DDX6EXTENDEDCAPS {
    DWORD       dwSize;         // Size of this structure

    DWORD       dwMinTextureWidth, dwMaxTextureWidth;
    DWORD       dwMinTextureHeight, dwMaxTextureHeight;
    DWORD       dwMinStippleWidth, dwMaxStippleWidth;
    DWORD       dwMinStippleHeight, dwMaxStippleHeight;

    /* fields added for DX6 */
    DWORD       dwMaxTextureRepeat;
    DWORD       dwMaxTextureAspectRatio;
    DWORD       dwMaxAnisotropy;
    D3DVALUE    dvGuardBandLeft;
    D3DVALUE    dvGuardBandTop;
    D3DVALUE    dvGuardBandRight;
    D3DVALUE    dvGuardBandBottom;
    D3DVALUE    dvExtentsAdjust;
    DWORD       dwStencilCaps;
    DWORD       dwFVFCaps;  /* low 4 bits: 0 implies TLVERTEX only, 1..8 imply FVF aware */
    DWORD       dwTextureOpCaps;
    WORD        wMaxTextureBlendStages;
    WORD        wMaxSimultaneousTextures;

} D3DNTHAL_D3DDX6EXTENDEDCAPS;
#endif /* DIRECT3D_VERSION >= 0x0700 */

/* --------------------------------------------------------------
 * Extended caps introduced with DX5 and queried with
 * GetDriverInfo (GUID_D3DExtendedCaps).
 */
typedef struct _D3DNTHAL_D3DEXTENDEDCAPS {
    DWORD       dwSize;         // Size of this structure
    DWORD       dwMinTextureWidth, dwMaxTextureWidth;
    DWORD       dwMinTextureHeight, dwMaxTextureHeight;
    DWORD       dwMinStippleWidth, dwMaxStippleWidth;
    DWORD       dwMinStippleHeight, dwMaxStippleHeight;

    /* fields added for DX6 */
    DWORD       dwMaxTextureRepeat;
    DWORD       dwMaxTextureAspectRatio;
    DWORD       dwMaxAnisotropy;
    D3DVALUE    dvGuardBandLeft;
    D3DVALUE    dvGuardBandTop;
    D3DVALUE    dvGuardBandRight;
    D3DVALUE    dvGuardBandBottom;
    D3DVALUE    dvExtentsAdjust;
    DWORD       dwStencilCaps;
    DWORD       dwFVFCaps;  /* 0 implies TLVERTEX only, 1..8 imply full FVF aware */
    DWORD       dwTextureOpCaps;
    WORD        wMaxTextureBlendStages;
    WORD        wMaxSimultaneousTextures;
#if(DIRECT3D_VERSION >= 0x0700)
    /* fields added for DX7 */
    DWORD       dwMaxActiveLights;
    D3DVALUE    dvMaxVertexW;

    WORD        wMaxUserClipPlanes;
    WORD        wMaxVertexBlendMatrices;

    DWORD       dwVertexProcessingCaps;

    DWORD       dwReserved1;
    DWORD       dwReserved2;
    DWORD       dwReserved3;
    DWORD       dwReserved4;
#endif /* DIRECT3D_VERSION >= 0x0700 */
} D3DNTHAL_D3DEXTENDEDCAPS;

typedef D3DNTHAL_D3DEXTENDEDCAPS *LPD3DNTHAL_D3DEXTENDEDCAPS;

#define D3DNTHAL_D3DEXTENDEDCAPSSIZE (sizeof(D3DNTHAL_D3DEXTENDEDCAPS))

// This is a temporary fix to make older NT drivers to compile
#define dvVertexProcessingCaps dwVertexProcessingCaps

#if(DIRECT3D_VERSION >= 0x0700)
typedef D3DNTHAL_D3DDX6EXTENDEDCAPS *LPD3DNTHAL_D3DDX6EXTENDEDCAPS;
#define D3DNTHAL_D3DDX6EXTENDEDCAPSSIZE (sizeof(D3DNTHAL_D3DDX6EXTENDEDCAPS))
#endif /* DIRECT3D_VERSION >= 0x0700 */

/* --------------------------------------------------------------
 * Argument to the HAL functions.
 */

typedef ULONG_PTR D3DINTHAL_BUFFERHANDLE, *LPD3DINTHAL_BUFFERHANDLE;

typedef struct _D3DNTHAL_CONTEXTCREATEDATA {
union
{
    PDD_DIRECTDRAW_GLOBAL lpDDGbl;  // in:  obsolete
    PDD_DIRECTDRAW_LOCAL lpDDLcl;   // in:  Driver struct
};
union
{
    PDD_SURFACE_LOCAL   lpDDS;      // in:  obsolete
    PDD_SURFACE_LOCAL   lpDDSLcl;   // in:  Surface to be used as target
};
union
{
    PDD_SURFACE_LOCAL   lpDDSZ;     // in:  obsolete
    PDD_SURFACE_LOCAL   lpDDSZLcl;  // in:  Surface to be used as Z
};
    DWORD               dwPID;      // in:  Current process id
    ULONG_PTR           dwhContext; // in/out: Context handle
    HRESULT             ddrval;     // out: Return value
} D3DNTHAL_CONTEXTCREATEDATA;
typedef D3DNTHAL_CONTEXTCREATEDATA *LPD3DNTHAL_CONTEXTCREATEDATA;

typedef struct _D3DNTHAL_CONTEXTDESTROYDATA {
    ULONG_PTR    dwhContext; // in:  Context handle
    HRESULT     ddrval;     // out: Return value
} D3DNTHAL_CONTEXTDESTROYDATA;
typedef D3DNTHAL_CONTEXTDESTROYDATA *LPD3DNTHAL_CONTEXTDESTROYDATA;

typedef struct _D3DNTHAL_CONTEXTDESTROYALLDATA {
    DWORD       dwPID;      // in:  Process id to destroy contexts for
    HRESULT     ddrval;     // out: Return value
} D3DNTHAL_CONTEXTDESTROYALLDATA;
typedef D3DNTHAL_CONTEXTDESTROYALLDATA *LPD3DNTHAL_CONTEXTDESTROYALLDATA;

typedef struct _D3DNTHAL_SCENECAPTUREDATA {
    ULONG_PTR    dwhContext; // in:  Context handle
    DWORD       dwFlag;     // in:  Indicates beginning or end
    HRESULT     ddrval;     // out: Return value
} D3DNTHAL_SCENECAPTUREDATA;
typedef D3DNTHAL_SCENECAPTUREDATA *LPD3DNTHAL_SCENECAPTUREDATA;

typedef struct _D3DNTHAL_TEXTURECREATEDATA {
    ULONG_PTR    dwhContext; // in:  Context handle
    HANDLE          hDDS;       // in:  Handle to surface object
    ULONG_PTR    dwHandle;   // out: Handle to texture
    HRESULT     ddrval;     // out: Return value
} D3DNTHAL_TEXTURECREATEDATA;
typedef D3DNTHAL_TEXTURECREATEDATA *LPD3DNTHAL_TEXTURECREATEDATA;

typedef struct _D3DNTHAL_TEXTUREDESTROYDATA {
    ULONG_PTR    dwhContext; // in:  Context handle
    ULONG_PTR    dwHandle;   // in:  Handle to texture
    HRESULT     ddrval;     // out: Return value
} D3DNTHAL_TEXTUREDESTROYDATA;
typedef D3DNTHAL_TEXTUREDESTROYDATA *LPD3DNTHAL_TEXTUREDESTROYDATA;

typedef struct _D3DNTHAL_TEXTURESWAPDATA {
    ULONG_PTR    dwhContext; // in:  Context handle
    ULONG_PTR    dwHandle1;  // in:  Handle to texture 1
    ULONG_PTR    dwHandle2;  // in:  Handle to texture 2
    HRESULT     ddrval;     // out: Return value
} D3DNTHAL_TEXTURESWAPDATA;
typedef D3DNTHAL_TEXTURESWAPDATA *LPD3DNTHAL_TEXTURESWAPDATA;

typedef struct _D3DNTHAL_TEXTUREGETSURFDATA {
    ULONG_PTR    dwhContext; // in:  Context handle
    HANDLE      hDDS;       // out: Handle to surface object
    ULONG_PTR    dwHandle;   // in:  Handle to texture
    HRESULT     ddrval;     // out: Return value
} D3DNTHAL_TEXTUREGETSURFDATA;
typedef D3DNTHAL_TEXTUREGETSURFDATA *LPD3DNTHAL_TEXTUREGETSURFDATA;

/* --------------------------------------------------------------
 * Flags for the data parameters.
 */

/*
 * SceneCapture()
 * This is used as an indication to the driver that a scene is about to
 * start or end, and that it should capture data if required.
 */
#define D3DNTHAL_SCENE_CAPTURE_START    0x00000000L
#define D3DNTHAL_SCENE_CAPTURE_END  0x00000001L

/* --------------------------------------------------------------
 * Return values from HAL functions.
 */

/*
 * The context passed in was bad.
 */
#define D3DNTHAL_CONTEXT_BAD        0x000000200L

/*
 * No more contexts left.
 */
#define D3DNTHAL_OUTOFCONTEXTS      0x000000201L

/* --------------------------------------------------------------
 * Direct3D HAL Table.
 * Instantiated by the HAL driver on connection.
 *
 * Calls take the form of:
 *  retcode = HalCall(HalCallData* lpData);
 */

typedef DWORD   (APIENTRY *LPD3DNTHAL_CONTEXTCREATECB)  (LPD3DNTHAL_CONTEXTCREATEDATA);
typedef DWORD   (APIENTRY *LPD3DNTHAL_CONTEXTDESTROYCB) (LPD3DNTHAL_CONTEXTDESTROYDATA);
typedef DWORD   (APIENTRY *LPD3DNTHAL_CONTEXTDESTROYALLCB) (LPD3DNTHAL_CONTEXTDESTROYALLDATA);
typedef DWORD   (APIENTRY *LPD3DNTHAL_SCENECAPTURECB)   (LPD3DNTHAL_SCENECAPTUREDATA);
typedef DWORD   (APIENTRY *LPD3DNTHAL_TEXTURECREATECB)  (LPD3DNTHAL_TEXTURECREATEDATA);
typedef DWORD   (APIENTRY *LPD3DNTHAL_TEXTUREDESTROYCB) (LPD3DNTHAL_TEXTUREDESTROYDATA);
typedef DWORD   (APIENTRY *LPD3DNTHAL_TEXTURESWAPCB)    (LPD3DNTHAL_TEXTURESWAPDATA);
typedef DWORD   (APIENTRY *LPD3DNTHAL_TEXTUREGETSURFCB) (LPD3DNTHAL_TEXTUREGETSURFDATA);

typedef struct _D3DNTHAL_CALLBACKS {
    DWORD           dwSize;

    // Device context
    LPD3DNTHAL_CONTEXTCREATECB  ContextCreate;
    LPD3DNTHAL_CONTEXTDESTROYCB ContextDestroy;
    LPD3DNTHAL_CONTEXTDESTROYALLCB ContextDestroyAll;

    // Scene Capture
    LPD3DNTHAL_SCENECAPTURECB   SceneCapture;

    // Execution
    LPVOID          dwReserved10;       // Must be zero (was Execute)
    LPVOID          dwReserved11;       // Must be zero (was ExecuteClipped)
    LPVOID          dwReserved22;       // Must be zero (was RenderState)
    LPVOID          dwReserved23;       // Must be zero (was RenderPrimitive)

    ULONG_PTR            dwReserved;     // Must be zero

    // Textures
    LPD3DNTHAL_TEXTURECREATECB  TextureCreate;
    LPD3DNTHAL_TEXTUREDESTROYCB TextureDestroy;
    LPD3DNTHAL_TEXTURESWAPCB    TextureSwap;
    LPD3DNTHAL_TEXTUREGETSURFCB TextureGetSurf;

    LPVOID                       dwReserved12;           // Must be zero
    LPVOID                       dwReserved13;           // Must be zero
    LPVOID                       dwReserved14;           // Must be zero
    LPVOID                       dwReserved15;           // Must be zero
    LPVOID                       dwReserved16;           // Must be zero
    LPVOID                       dwReserved17;           // Must be zero
    LPVOID                       dwReserved18;           // Must be zero
    LPVOID                       dwReserved19;           // Must be zero
    LPVOID                       dwReserved20;           // Must be zero
    LPVOID                       dwReserved21;           // Must be zero

    // Pipeline state
    LPVOID                       dwReserved24;           // Was GetState;

    ULONG_PTR            dwReserved0;        // Must be zero
    ULONG_PTR            dwReserved1;        // Must be zero
    ULONG_PTR            dwReserved2;        // Must be zero
    ULONG_PTR            dwReserved3;        // Must be zero
    ULONG_PTR            dwReserved4;        // Must be zero
    ULONG_PTR            dwReserved5;        // Must be zero
    ULONG_PTR            dwReserved6;        // Must be zero
    ULONG_PTR            dwReserved7;        // Must be zero
    ULONG_PTR            dwReserved8;        // Must be zero
    ULONG_PTR            dwReserved9;        // Must be zero

} D3DNTHAL_CALLBACKS;
typedef D3DNTHAL_CALLBACKS *LPD3DNTHAL_CALLBACKS;

#define D3DNTHAL_SIZE_V1 sizeof( D3DNTHAL_CALLBACKS )

typedef struct _D3DNTHAL_SETRENDERTARGETDATA {
    ULONG_PTR            dwhContext;     // in:  Context handle
    PDD_SURFACE_LOCAL   lpDDS;          // in:  new render target
    PDD_SURFACE_LOCAL   lpDDSZ;         // in:  new Z buffer
    HRESULT             ddrval;         // out: Return value
} D3DNTHAL_SETRENDERTARGETDATA;
typedef D3DNTHAL_SETRENDERTARGETDATA *LPD3DNTHAL_SETRENDERTARGETDATA;


typedef DWORD (APIENTRY *LPD3DNTHAL_SETRENDERTARGETCB) (LPD3DNTHAL_SETRENDERTARGETDATA);

typedef struct _D3DNTHAL_CALLBACKS2
{
    DWORD                       dwSize;                 // size of struct
    DWORD                       dwFlags;                // flags for callbacks

    LPD3DNTHAL_SETRENDERTARGETCB  SetRenderTarget;
    LPVOID                dwReserved1;           // was Clear
    LPVOID                dwReserved2;           // was DrawOnePrimitive
    LPVOID                dwReserved3;           // was DrawOneIndexedPrimitive
    LPVOID                dwReserved4;           // was DrawPrimitives
} D3DNTHAL_CALLBACKS2;
typedef D3DNTHAL_CALLBACKS2 *LPD3DNTHAL_CALLBACKS2;

#define D3DNTHAL2_CB32_SETRENDERTARGET    0x00000001L


typedef struct _D3DNTHAL_CLEAR2DATA
{
    ULONG_PTR            dwhContext;     // in:  Context handle

    // dwFlags can contain D3DCLEAR_TARGET or D3DCLEAR_ZBUFFER
    DWORD               dwFlags;        // in:  surfaces to clear

    DWORD               dwFillColor;    // in:  Color value for rtarget
    D3DVALUE            dvFillDepth;    // in:  Depth value for
                                        //      Z-buffer (0.0-1.0)
    DWORD               dwFillStencil;  // in:  value used to clear stencil buffer

    LPD3DRECT           lpRects;        // in:  Rectangles to clear
    DWORD               dwNumRects;     // in:  Number of rectangles

    HRESULT             ddrval;         // out: Return value
} D3DNTHAL_CLEAR2DATA;
typedef D3DNTHAL_CLEAR2DATA FAR *LPD3DNTHAL_CLEAR2DATA;

typedef struct _D3DNTHAL_VALIDATETEXTURESTAGESTATEDATA
{
    ULONG_PTR        dwhContext; // in:  Context handle
    DWORD           dwFlags;    // in:  Flags, currently set to 0
    ULONG_PTR        dwReserved; //
    DWORD           dwNumPasses;// out: Number of passes the hardware
                                //      can perform the operation in
    HRESULT         ddrval;     // out: return value
} D3DNTHAL_VALIDATETEXTURESTAGESTATEDATA;
typedef D3DNTHAL_VALIDATETEXTURESTAGESTATEDATA FAR *LPD3DNTHAL_VALIDATETEXTURESTAGESTATEDATA;

//-----------------------------------------------------------------------------
// DrawPrimitives2 DDI
//-----------------------------------------------------------------------------

//
// Command structure for vertex buffer rendering
//

typedef struct _D3DNTHAL_DP2COMMAND
{
    BYTE bCommand;           // vertex command
    BYTE bReserved;
    union
    {
        WORD wPrimitiveCount;   // primitive count for unconnected primitives
        WORD wStateCount;     // count of render states to follow
    };
} D3DNTHAL_DP2COMMAND, *LPDNT3DHAL_DP2COMMAND;

//
// DrawPrimitives2 commands:
//

typedef enum _D3DNTHAL_DP2OPERATION
{
    D3DNTDP2OP_POINTS               = 1,
    D3DNTDP2OP_INDEXEDLINELIST      = 2,
    D3DNTDP2OP_INDEXEDTRIANGLELIST  = 3,
    D3DNTDP2OP_RESERVED0            = 4,
    D3DNTDP2OP_RENDERSTATE          = 8,
    D3DNTDP2OP_LINELIST             = 15,
    D3DNTDP2OP_LINESTRIP            = 16,
    D3DNTDP2OP_INDEXEDLINESTRIP     = 17,
    D3DNTDP2OP_TRIANGLELIST         = 18,
    D3DNTDP2OP_TRIANGLESTRIP        = 19,
    D3DNTDP2OP_INDEXEDTRIANGLESTRIP = 20,
    D3DNTDP2OP_TRIANGLEFAN          = 21,
    D3DNTDP2OP_INDEXEDTRIANGLEFAN   = 22,
    D3DNTDP2OP_TRIANGLEFAN_IMM      = 23,
    D3DNTDP2OP_LINELIST_IMM         = 24,
    D3DNTDP2OP_TEXTURESTAGESTATE    = 25,
    D3DNTDP2OP_INDEXEDTRIANGLELIST2 = 26,
    D3DNTDP2OP_INDEXEDLINELIST2     = 27,
    D3DNTDP2OP_VIEWPORTINFO         = 28,
    D3DNTDP2OP_WINFO                = 29,
    D3DNTDP2OP_SETPALETTE           = 30,
    D3DNTDP2OP_UPDATEPALETTE        = 31,
#if(DIRECT3D_VERSION >= 0x0700)
    //new for DX7
    D3DNTDP2OP_ZRANGE               = 32,
    D3DNTDP2OP_SETMATERIAL          = 33,
    D3DNTDP2OP_SETLIGHT             = 34,
    D3DNTDP2OP_CREATELIGHT          = 35,
    D3DNTDP2OP_SETTRANSFORM         = 36,
    D3DNTDP2OP_EXT                  = 37,
    D3DNTDP2OP_TEXBLT               = 38,
    D3DNTDP2OP_STATESET             = 39,
    D3DNTDP2OP_SETPRIORITY          = 40,
#endif /* DIRECT3D_VERSION >= 0x0700 */
    D3DNTDP2OP_SETRENDERTARGET      = 41,
    D3DNTDP2OP_CLEAR                = 42,
#if(DIRECT3D_VERSION >= 0x0700)
    D3DNTDP2OP_SETTEXLOD            = 43,
    D3DNTDP2OP_SETCLIPPLANE         = 44,
#endif /* DIRECT3D_VERSION >= 0x0700 */
} D3DNTHAL_DP2OPERATION;

//
// DrawPrimitives2 point primitives
//

typedef struct _D3DNTHAL_DP2POINTS
{
    WORD wCount;
    WORD wVStart;
} D3DNTHAL_DP2POINTS;

//
// DrawPrimitives2 line primitives
//

typedef struct _D3DNTHAL_DP2STARTVERTEX {
    WORD wVStart;
} D3DNTHAL_DP2STARTVERTEX, *LPD3DNTHAL_DP2STARTVERTEX;

typedef struct _D3DNTHAL_DP2LINELIST
{
    WORD wVStart;
} D3DNTHAL_DP2LINELIST;

typedef struct _D3DNTHAL_DP2INDEXEDLINELIST
{
    WORD wV1;
    WORD wV2;
} D3DNTHAL_DP2INDEXEDLINELIST;

typedef struct _D3DNTHAL_DP2LINESTRIP
{
    WORD wVStart;
} D3DNTHAL_DP2LINESTRIP;

typedef struct _D3DNTHAL_DP2INDEXEDLINESTRIP
{
    WORD wV[2];
} D3DNTHAL_DP2INDEXEDLINESTRIP;

//
// DrawPrimitives2 triangle primitives
//

typedef struct _D3DNTHAL_DP2TRIANGLELIST
{
    WORD wVStart;
} D3DNTHAL_DP2TRIANGLELIST;

typedef struct _D3DNTHAL_DP2INDEXEDTRIANGLELIST
{
    WORD wV1;
    WORD wV2;
    WORD wV3;
    WORD wFlags;
} D3DNTHAL_DP2INDEXEDTRIANGLELIST;

typedef struct _D3DNTHAL_DP2INDEXEDTRIANGLELIST2 {
    WORD wV1;
    WORD wV2;
    WORD wV3;
} D3DNTHAL_DP2INDEXEDTRIANGLELIST2, *LPD3DNTHAL_DP2INDEXEDTRIANGLELIST2;

typedef struct _D3DNTHAL_DP2TRIANGLESTRIP
{
    WORD wVStart;
} D3DNTHAL_DP2TRIANGLESTRIP;

typedef struct _D3DNTHAL_DP2INDEXEDTRIANGLESTRIP
{
    WORD wV[3];
} D3DNTHAL_DP2INDEXEDTRIANGLESTRIP;

typedef struct _D3DNTHAL_DP2TRIANGLEFAN
{
    WORD wVStart;
} D3DNTHAL_DP2TRIANGLEFAN;

typedef struct _D3DNTHAL_DP2INDEXEDTRIANGLEFAN
{
    WORD wV[3];
} D3DNTHAL_DP2INDEXEDTRIANGLEFAN;

typedef struct _D3DNTHAL_DP2TRIANGLEFAN_IMM {
    DWORD dwEdgeFlags;
} D3DNTHAL_DP2TRIANGLEFAN_IMM, *LPD3DNTHAL_DP2TRIANGLEFAN_IMM;

//
// DrawPrimitives2 Renderstate changes
//

typedef struct _D3DNTHAL_DP2RENDERSTATE
{
    D3DRENDERSTATETYPE RenderState;
    union
    {
        D3DVALUE fState;
        DWORD dwState;
    };
} D3DNTHAL_DP2RENDERSTATE;

typedef struct _D3DNTHAL_DP2TEXTURESTAGESTATE
{
    WORD wStage;
    WORD TSState;
    DWORD dwValue;
} D3DNTHAL_DP2TEXTURESTAGESTATE;

typedef struct _D3DNTHAL_DP2VIEWPORTINFO {
    DWORD dwX;
    DWORD dwY;
    DWORD dwWidth;
    DWORD dwHeight;
} D3DNTHAL_DP2VIEWPORTINFO, *LPD3DNTHAL_DP2VIEWPORTINFO;

typedef struct _D3DNTHAL_DP2WINFO {
    D3DVALUE        dvWNear;
    D3DVALUE        dvWFar;
} D3DNTHAL_DP2WINFO, *LPD3DNTHAL_DP2WINFO;

typedef struct _D3DNTHAL_DP2SETPALETTE
{
    DWORD dwPaletteHandle;
    DWORD dwPaletteFlags;
    DWORD dwSurfaceHandle;
} D3DNTHAL_DP2SETPALETTE, *LPD3DNTHAL_DP2SETPALETTE;

typedef struct _D3DNTHAL_DP2UPDATEPALETTE
{
    DWORD dwPaletteHandle;
    WORD  wStartIndex;
    WORD  wNumEntries;
} D3DNTHAL_DP2UPDATEPALETTE, *LPD3DNTHAL_DP2UPDATEPALETTE;

typedef struct _D3DNTHAL_DP2SETRENDERTARGET
{
    DWORD hRenderTarget;
    DWORD hZBuffer;
} D3DNTHAL_DP2SETRENDERTARGET, *LPD3DNTHAL_DP2SETRENDERTARGET;

#if(DIRECT3D_VERSION >= 0x0700)
// Values for dwOperations in the D3DHAL_DP2STATESET
#define D3DHAL_STATESETBEGIN     0
#define D3DHAL_STATESETEND       1
#define D3DHAL_STATESETDELETE    2
#define D3DHAL_STATESETEXECUTE   3
#define D3DHAL_STATESETCAPTURE   4

typedef struct _D3DNTHAL_DP2STATESET
{
    DWORD       dwOperation;
    DWORD       dwParam;        // State set handle passed with D3DHAL_STATESETBEGIN,
                                // D3DHAL_STATESETEXECUTE, D3DHAL_STATESETDELETE
                                // D3DHAL_STATESETCAPTURE
    D3DSTATEBLOCKTYPE   sbType; // Type use with D3DHAL_STATESETBEGIN/END
} D3DNTHAL_DP2STATESET, *LPD3DNTHAL_DP2STATESET;
//
// T&L Hal specific stuff
//
typedef struct _D3DNTHAL_DP2ZRANGE
{
    D3DVALUE    dvMinZ;
    D3DVALUE    dvMaxZ;
} D3DNTHAL_DP2ZRANGE, *LPD3DNTHAL_DP2ZRANGE;

typedef D3DMATERIAL7 D3DNTHAL_DP2SETMATERIAL, *LPD3DNTHAL_DP2SETMATERIAL;

typedef struct _D3DNTHAL_DP2SETLIGHT
{
    DWORD     dwIndex;
    DWORD     lightData;
} D3DNTHAL_DP2SETLIGHT, *LPD3DNTHAL_DP2SETLIGHT;

typedef struct _D3DNTHAL_DP2SETCLIPPLANE
{
    DWORD     dwIndex;
    D3DVALUE  plane[4];
} D3DNTHAL_DP2SETCLIPPLANE, *LPD3DNTHAL_DP2SETCLIPPLANE;

typedef struct _D3DNTHAL_DP2CREATELIGHT
{
    DWORD dwIndex;
} D3DNTHAL_DP2CREATELIGHT, *LPD3DNTHAL_DP2CREATELIGHT;

typedef struct _D3DNTHAL_DP2SETTRANSFORM
{
    D3DTRANSFORMSTATETYPE xfrmType;
    D3DMATRIX matrix;
} D3DNTHAL_DP2SETTRANSFORM, *LPD3DNTHAL_DP2SETTRANSFORM;

typedef struct _D3DNTHAL_DP2EXT
{
    DWORD dwExtToken;
    DWORD dwSize;
} D3DNTHAL_DP2EXT, *LPD3DNTHAL_DP2EXT;
typedef struct _D3DNTHAL_DP2TEXBLT
{
    DWORD   dwDDDestSurface;// dest surface
    DWORD   dwDDSrcSurface; // src surface
    POINT   pDest;
    RECTL   rSrc;       // src rect
    DWORD   dwFlags;    // blt flags
} D3DNTHAL_DP2TEXBLT, *LPD3DNTHAL_DP2TEXBLT;

typedef struct _D3DNTHAL_DP2SETPRIORITY
{
    DWORD dwDDDestSurface;// dest surface
    DWORD dwPriority;
} D3DNTHAL_DP2SETPRIORITY, *LPD3DNTHAL_DP2SETPRIORITY;

typedef struct _D3DNTHAL_DP2CLEAR
{
  // dwFlags can contain D3DCLEAR_TARGET, D3DCLEAR_ZBUFFER, and/or D3DCLEAR_STENCIL
    DWORD               dwFlags;        // in:  surfaces to clear
    DWORD               dwFillColor;    // in:  Color value for rtarget
    D3DVALUE            dvFillDepth;    // in:  Depth value for Z buffer (0.0-1.0)
    DWORD               dwFillStencil;  // in:  value used to clear stencil buffer
    RECT                Rects[1];       // in:  Rectangles to clear
} D3DNTHAL_DP2CLEAR, *LPD3DNTHAL_DP2CLEAR;

typedef struct _D3DNTHAL_DP2SETTEXLOD
{
    DWORD dwDDSurface;
    DWORD dwLOD;
} D3DNTHAL_DP2SETTEXLOD, *LPD3DNTHAL_DP2SETTEXLOD;

#endif /* DIRECT3D_VERSION >= 0x0700 */


typedef struct _D3DNTHAL_DRAWPRIMITIVES2DATA
{
    ULONG_PTR          dwhContext;        // in: Context handle
    DWORD             dwFlags;           // in: flags (look below)
    DWORD             dwVertexType;      // in: vertex type
    PDD_SURFACE_LOCAL lpDDCommands;      // in: vertex buffer command data
    DWORD             dwCommandOffset;   // in: offset to start of vb commands
    DWORD             dwCommandLength;   // in: number of bytes of command data
    union
    {
        PDD_SURFACE_LOCAL lpDDVertex;    // in: surface containing vertex data
        LPVOID lpVertices;               // in: User mode pointer to vertices
    };
    DWORD             dwVertexOffset;    // in: offset to start of vertex data
    DWORD             dwVertexLength;    // in: number of bytes of vertex data
    DWORD             dwReqVertexBufSize;// in: number of bytes required for
                                         //     the next vertex buffer
    DWORD             dwReqCommandBufSize; // in: number if bytes required for
                                         //     the next commnand buffer
    LPDWORD           lpdwRStates;       // in: Pointer to the array where render states are updated
    union
    {
        DWORD         dwVertexSize;      // in: Size of each vertex in bytes
        HRESULT       ddrval;            // out: return value
    };
    DWORD             dwErrorOffset;     // out: offset in LPDDVBCOMMAND to
                                         //      first failed D3DNTHAL_VBCOMMAND
} D3DNTHAL_DRAWPRIMITIVES2DATA;
typedef D3DNTHAL_DRAWPRIMITIVES2DATA FAR *LPD3DNTHAL_DRAWPRIMITIVES2DATA;

// Indicates that the lpVertices field in the DrawPrimitives2 data is
// valid, i.e. user allocated memory.
#define D3DNTHALDP2_USERMEMVERTICES   0x00000001L
// Indicates that the command buffer and vertex buffer are a system memory execute buffer
// resulting from the use of the Execute buffer API.
#define D3DNTHALDP2_EXECUTEBUFFER     0x00000002L

// The swap flags indicate if it is OK for the driver to swap the submitted buffers with new
// buffers and asyncronously work on the submitted buffers.
#define D3DNTHALDP2_SWAPVERTEXBUFFER  0x00000004L
#define D3DNTHALDP2_SWAPCOMMANDBUFFER 0x00000008L
// The requested flags are present if the new buffers which the driver can allocate need to be
// of atleast a given size. If any of these flags are set, the corresponding dwReq* field in
// D3DNTHAL_DRAWPRIMITIVES2DATA will also be set with the requested size in bytes.
#define D3DNTHALDP2_REQVERTEXBUFSIZE  0x00000010L
#define D3DNTHALDP2_REQCOMMANDBUFSIZE 0x00000020L
// These flags are set by the driver upon return from DrawPrimitives2 indicating if the new
// buffers are not in system memory.
#define D3DNTHALDP2_VIDMEMVERTEXBUF   0x00000040L
#define D3DNTHALDP2_VIDMEMCOMMANDBUF  0x00000080L


// Return values for the driver callback used in DP2 implementations
// Used by the driver to ask runtime to parse the execute buffer
#define D3DNTERR_COMMAND_UNPARSED         MAKE_DDHRESULT(3000)


typedef DWORD (APIENTRY *LPD3DNTHAL_CLEAR2CB) (LPD3DNTHAL_CLEAR2DATA);
typedef DWORD (APIENTRY *LPD3DNTHAL_VALIDATETEXTURESTAGESTATECB) (LPD3DNTHAL_VALIDATETEXTURESTAGESTATEDATA);
typedef DWORD (APIENTRY *LPD3DNTHAL_DRAWPRIMITIVES2CB) (LPD3DNTHAL_DRAWPRIMITIVES2DATA);

typedef struct _D3DNTHAL_CALLBACKS3
{
    DWORD                       dwSize;                 // size of struct
    DWORD                       dwFlags;                // flags for callbacks

    LPD3DNTHAL_CLEAR2CB            Clear2;
    LPVOID                         lpvReserved;
    LPD3DNTHAL_VALIDATETEXTURESTAGESTATECB  ValidateTextureStageState;
    LPD3DNTHAL_DRAWPRIMITIVES2CB   DrawPrimitives2;
} D3DNTHAL_CALLBACKS3;
typedef D3DNTHAL_CALLBACKS3 *LPD3DNTHAL_CALLBACKS3;

#define D3DNTHAL3_CB32_CLEAR2             0x00000001L
#define D3DNTHAL3_CB32_RESERVED           0x00000002L
#define D3DNTHAL3_CB32_VALIDATETEXTURESTAGESTATE   0x00000004L
#define D3DNTHAL3_CB32_DRAWPRIMITIVES2    0x00000008L

// typedef for the Callback that the drivers can use to parse unknown commands
// passed to them via the DrawPrimitives2 callback. The driver obtains this
// callback thru a GetDriverInfo call with GUID_D3DParseUnknownCommandCallback
// made by ddraw somewhere around the initialization time.
typedef HRESULT (CALLBACK *PFND3DNTPARSEUNKNOWNCOMMAND) (LPVOID lpvCommands,
                                                         LPVOID *lplpvReturnedCommand);

/* --------------------------------------------------------------
 * Texture stage renderstate mapping definitions.
 *
 * 256 renderstate slots [256, 511] are reserved for texture processing
 * stage controls, which provides for 8 texture processing stages each
 * with 32 DWORD controls.
 *
 * The renderstates within each stage are indexed by the
 * D3DTEXTURESTAGESTATETYPE enumerants by adding the appropriate
 * enumerant to the base for a given texture stage.
 *
 * Note, "state overrides" bias the renderstate by 256, so the two
 * ranges overlap.  Overrides are enabled for exebufs only, so all
 * this means is that Texture3 cannot be used with exebufs.
 */

/*
 * Base of all texture stage state values in renderstate array.
 */
#define D3DNTHAL_TSS_RENDERSTATEBASE 256UL

/*
 * Maximum number of stages allowed.
 */
#define D3DNTHAL_TSS_MAXSTAGES 8

/*
 * Number of state DWORDS per stage.
 */
#define D3DNTHAL_TSS_STATESPERSTAGE 64

/*
 * Texture handle's offset into the 32-DWORD cascade state vector
 */
#ifndef D3DTSS_TEXTUREMAP
#define D3DTSS_TEXTUREMAP 0
#endif

#define D3DRENDERSTATE_EVICTMANAGEDTEXTURES 61  // DDI render state only to Evict textures
#define D3DRENDERSTATE_SCENECAPTURE         62  // DDI only to replace SceneCapture

#endif /* _D3DNTHAL_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\public\ddk\inc\usb.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    usb.h

    Generated from usb.x

Abstract:

    Header File for all class drivers

Environment:

    Xbox
    C++ Only

--*/

#ifndef __USB_X__
#define __USB_X__

#ifndef __cplusplus
#error "usb.h may only be included by C++ modules"
#endif

#define EXTERNUSB extern "C"

//
//	USB drivers, and XAPI code modules that rely on USB all go into 
//	the XPP section.
//
#pragma code_seg(".XPPCODE")
#pragma data_seg(".XPP$Data")
#pragma const_seg(".XPPRDATA")

#include <usb100.h>

//
// XBOX platform USB device classes
//

#define XBOX_DEVICE_CLASS_INPUT_DEVICE              0x58
#define XBOX_DEVICE_CLASS_XDCS                      0x59
#define XBOX_DEVICE_CLASS_AUDIO_DEVICE              0x78

//
// USBD status codes
//
//  Status values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+---------------------------+-------------------------------+
//  | S |               Status Code                                 |
//  +---+---------------------------+-------------------------------+
//
//  where
//
//      S - is the state code
//
//          00 - completed with success
//          01 - request is pending
//          10 - completed with error, endpoint not stalled
//          11 - completed with error, endpoint stalled
//
//
//      Code - is the status code
//

typedef LONG USBD_STATUS;

//
// Generic test for success on any status value (non-negative numbers
// indicate success).
//

#define USBD_SUCCESS(Status) ((USBD_STATUS)(Status) >= 0)

//
// Generic test for pending status value.
//

#define USBD_PENDING(Status) ((ULONG)(Status) >> 30 == 1)

//
// Generic test for error on any status value.
//

#define USBD_ERROR(Status) ((USBD_STATUS)(Status) < 0)

//
//  Macro to ensure that error bit is set.
//
#define SET_USBD_ERROR(err)  ((err) | USBD_STATUS_ERROR)


//
// Generic test for stall on any status value.
//

#define USBD_HALTED(Status) ((ULONG)(Status) >> 30 == 3)

#define USBD_STATUS_SUCCESS                  ((USBD_STATUS)0x00000000L)
#define USBD_STATUS_PENDING                  ((USBD_STATUS)0x40000000L)
#define USBD_STATUS_HALTED                   ((USBD_STATUS)0xC0000000L)
#define USBD_STATUS_ERROR                    ((USBD_STATUS)0x80000000L)

//
// HC status codes
// Note: these status codes have both the error and the stall bit set.
//
#define USBD_STATUS_CRC                      ((USBD_STATUS)0xC0000001L)
#define USBD_STATUS_BTSTUFF                  ((USBD_STATUS)0xC0000002L)
#define USBD_STATUS_DATA_TOGGLE_MISMATCH     ((USBD_STATUS)0xC0000003L)
#define USBD_STATUS_STALL_PID                ((USBD_STATUS)0xC0000004L)
#define USBD_STATUS_DEV_NOT_RESPONDING       ((USBD_STATUS)0xC0000005L)
#define USBD_STATUS_PID_CHECK_FAILURE        ((USBD_STATUS)0xC0000006L)
#define USBD_STATUS_UNEXPECTED_PID           ((USBD_STATUS)0xC0000007L)
#define USBD_STATUS_DATA_OVERRUN             ((USBD_STATUS)0xC0000008L)
#define USBD_STATUS_DATA_UNDERRUN            ((USBD_STATUS)0xC0000009L)
#define USBD_STATUS_RESERVED1                ((USBD_STATUS)0xC000000AL)
#define USBD_STATUS_RESERVED2                ((USBD_STATUS)0xC000000BL)
#define USBD_STATUS_BUFFER_OVERRUN           ((USBD_STATUS)0xC000000CL)
#define USBD_STATUS_BUFFER_UNDERRUN          ((USBD_STATUS)0xC000000DL)
#define USBD_STATUS_NOT_ACCESSED             ((USBD_STATUS)0xC000000EL)
#define USBD_STATUS_FIFO                     ((USBD_STATUS)0xC0000010L)

//
// HC status codes
// Note: these status codes have the error bit and not the stall bit set.
//
#define USBD_ISOCH_STATUS_CRC                      (1)
#define USBD_ISOCH_STATUS_BTSTUFF                  (2)
#define USBD_ISOCH_STATUS_DATA_TOGGLE_MISMATCH     (3)
#define USBD_ISOCH_STATUS_STALL_PID                (4)
#define USBD_ISOCH_STATUS_DEV_NOT_RESPONDING       (5)
#define USBD_ISOCH_STATUS_PID_CHECK_FAILURE        (6)
#define USBD_ISOCH_STATUS_UNEXPECTED_PID           (7)
#define USBD_ISOCH_STATUS_DATA_OVERRUN             (8)
#define USBD_ISOCH_STATUS_DATA_UNDERRUN            (9)
#define USBD_ISOCH_STATUS_RESERVED1                (A)
#define USBD_ISOCH_STATUS_RESERVED2                (B)
#define USBD_ISOCH_STATUS_BUFFER_OVERRUN           (C)
#define USBD_ISOCH_STATUS_BUFFER_UNDERRUN          (D)
#define USBD_ISOCH_STATUS_NOT_ACCESSED             (E)

//
// returned by HCD if a transfer is submitted to an endpoint that is 
// stalled
//
#define USBD_STATUS_ENDPOINT_HALTED         ((USBD_STATUS)0xC0000030L)

//
// Software status codes
// Note: the following status codes have only the error bit set
//
#define USBD_STATUS_NO_MEMORY                ((USBD_STATUS)0x80000100L)
#define USBD_STATUS_INVALID_URB_FUNCTION     ((USBD_STATUS)0x80000200L)
#define USBD_STATUS_INVALID_PARAMETER        ((USBD_STATUS)0x80000300L)
#define USBD_STATUS_UNSUPPORTED_DEVICE       ((USBD_STATUS)0x80000400L)
#define USBD_STATUS_TRANSFER_TOO_LONG        ((USBD_STATUS)0x80000500L)

//
// returned by USBD if it cannot complete a URB request, typically this 
// will be returned in the URB status field when the Irp is completed
// with a more specific NT error code in the irp.status field.
//
#define USBD_STATUS_REQUEST_FAILED           ((USBD_STATUS)0x80000600L)

#define USBD_STATUS_NO_DEVICE                ((USBD_STATUS)0x80000700L)

// returned when there is not enough bandwidth avialable
// to open a requested endpoint
#define USBD_STATUS_NO_BANDWIDTH             ((USBD_STATUS)0x80000800L)
//
// generic HC error
// 
#define USBD_STATUS_INTERNAL_HC_ERROR        ((USBD_STATUS)0x80000900L)
//
// returned when a short packet terminates the transfer
// ie USBD_SHORT_TRANSFER_OK bit not set
// 
#define USBD_STATUS_ERROR_SHORT_TRANSFER     ((USBD_STATUS)0x80000A00L)


// 
// returned if the requested start frame is not within
// USBD_ISOCH_START_FRAME_RANGE of the current USB frame, 
// note that the stall bit is set
// 
#define USBD_STATUS_BAD_START_FRAME          ((USBD_STATUS)0xC0000B00L)
//
// returned by HCD if all packets in an iso transfer complete with an error 
//
#define USBD_STATUS_ISOCH_REQUEST_FAILED     ((USBD_STATUS)0xC0000C00L)
//
// returned by HCD if an attempt is made to attach more isoch
// buffers to an endpoint than specified as the maximum when opening
// the endpoint.
//
#define USBD_STATUS_ISOCH_TOO_MANY_BUFFERS   ((USBD_STATUS)0xC0000D00L)
//
// returned by HCD if an attempt is made to start an endpoint which is
// already started.
//
#define USBD_STATUS_ISOCH_ALREADY_STARTED    ((USBD_STATUS)0xC0000E00L)
//
// returned by HCD if an attempt is made to stop an endpoint which is
// not already started.
//
#define USBD_STATUS_ISOCH_NOT_STARTED        ((USBD_STATUS)0xC0000F00L)
//
// returned by HCD if an attempt is made to start an endpoint setup for
// circular DMA with fewer than MaxAttachedBuffers,
//
#define USBD_STATUS_ISOCH_ATTACH_MORE_BUFFERS ((USBD_STATUS)0xC0001000L)
//
// This build of the usb driver does not support isochronous requests.
//
#define USBD_STATUS_ISOCH_NOT_SUPPORTED      ((USBD_STATUS)0xC0002000L)
//
// set when a transfers is completed due to an AbortPipe request from
// the client driver
//
#define USBD_STATUS_CANCELED                 ((USBD_STATUS)0xC000000FL)
#define USBD_STATUS_CANCELING                ((USBD_STATUS)0x40020000L)

//
//	Status returned by hub, when a reset completes successfully and the
//	device is low-speed.
//
#define USBD_STATUS_LOWSPEED				 ((USBD_STATUS)0x01000000L)

extern "C" {

//------------------------------------------------------------------------------------
// URB Function Codes   - High bit indicates that USBD (pre-)processes URB
//------------------------------------------------------------------------------------
//-- special bit in URB_FUNCTION codes -----------------
#define URB_FUNCTION_USBD_PROCESSED                 0x80    
#define URB_FUNCTION_ASYNCHRONOUS                   0x40
//------------------------------------------------------
#define URB_FUNCTION_CONTROL_TRANSFER               (0x00 | URB_FUNCTION_ASYNCHRONOUS)
#define URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER     (0x01 | URB_FUNCTION_ASYNCHRONOUS)
#define URB_FUNCTION_OPEN_ENDPOINT                  0x02
#define URB_FUNCTION_CLOSE_ENDPOINT                 (0x03 | URB_FUNCTION_ASYNCHRONOUS)
#define URB_FUNCTION_GET_ENDPOINT_STATE             0x04
#define URB_FUNCTION_SET_ENDPOINT_STATE             0x05
#define URB_FUNCTION_ABORT_ENDPOINT                 (0x06 | URB_FUNCTION_ASYNCHRONOUS)
#define URB_FUNCTION_GET_FRAME_NUMBER               0x07
#define URB_FUNCTION_OPEN_DEFAULT_ENDPOINT          (URB_FUNCTION_USBD_PROCESSED | URB_FUNCTION_OPEN_ENDPOINT)
#define URB_FUNCTION_CLOSE_DEFAULT_ENDPOINT         (URB_FUNCTION_USBD_PROCESSED | URB_FUNCTION_CLOSE_ENDPOINT)
#define URB_FUNCTION_RESET_PORT                     (URB_FUNCTION_USBD_PROCESSED | 0x08)
#define URB_FUNCTION_ISOCH_OPEN_ENDPOINT            0x09
#define URB_FUNCTION_ISOCH_CLOSE_ENDPOINT           (0x0A | URB_FUNCTION_ASYNCHRONOUS)
#define URB_FUNCTION_ISOCH_ATTACH_BUFFER            0x0B
#define URB_FUNCTION_ISOCH_START_TRANSFER           0x0C
#define URB_FUNCTION_ISOCH_STOP_TRANSFER            0x0D

//------------------------------------------------------------------------------------
//  Values for the transfer directions
//------------------------------------------------------------------------------------
#define USB_TRANSFER_DIRECTION_OUT              0x01
#define USB_TRANSFER_DIRECTION_IN               0x02

//----------------------------------------------------------------------------------------------------------------------
// Flags for URB_FUNCTION_GET_ENDPOINT_STATE
//----------------------------------------------------------------------------------------------------------------------
#define USB_ENDPOINT_STATE_HALTED              	0x01    //Set on return if endpoint is halted.
#define USB_ENDPOINT_STATE_TRANSFERS_QUEUED     0x02    //Set on return if one or more transfers are queued to endpoint.

//----------------------------------------------------------------------------------------------------------------------
// Flags for URB_FUNCTION_SET_ENDPOINT_STATE
//----------------------------------------------------------------------------------------------------------------------
#define USB_ENDPOINT_STATE_CLEAR_HALT		    0x00    //Clear endpoint halt.
#define USB_ENDPOINT_STATE_KEEP_HALT		    0x01    //Do not clear enddpoint halt
#define USB_ENDPOINT_STATE_DATA_TOGGLE_RESET    0x04    //Reset data toggle. (i.e. DATA0)
#define USB_ENDPOINT_STATE_DATA_TOGGLE_SET      0x08    //Set data toggle. (i.e. DATA1), provided for testing.
//There is no USB_ENDPOINT_STATE_SET_HALT, since only the hardware may set it.

//----------------------------------------------------------------------------------------------------------------------
// Macros for the InterruptDelay variable in transfer and attach buffer URBs - this is really an OpenHCI thing,
// but gives more control to class drivers.  These are the same as OHCI_TD_DELAY_INTERRUPT_XXX
// DUE TO BUG 9512 IT IS ONLY SAFE TO USE USBD_DELAY_INTERRUPT_0_MS.  OTHERWISE, YOU MAY EXPERIENCE PROBLEMS
// WHEN CLOSING THE ENDPOINT.  SEE BUG 9512 FOR MORE DETAILS.
//----------------------------------------------------------------------------------------------------------------------
#define USBD_DELAY_INTERRUPT_0_MS        0   // Interrupt at end of frame TD is completed
#define USBD_DELAY_INTERRUPT_1_MS        1   // Interrupt within 1 frame of TD compeletion
#define USBD_DELAY_INTERRUPT_2_MS        2   // Interrupt within 2 frames of TD compeletion
#define USBD_DELAY_INTERRUPT_3_MS        3   // Interrupt within 3 frame of TD compeletion
#define USBD_DELAY_INTERRUPT_4_MS        4   // Interrupt within 4 frame of TD compeletion
#define USBD_DELAY_INTERRUPT_5_MS        5   // Interrupt within 5 frame of TD compeletion
#define USBD_DELAY_INTERRUPT_6_MS        6   // Interrupt within  frame of TD compeletion
#define USBD_DELAY_INTERRUPT_NONE        7   // Do not Interrupt upon completion of TD

//------------------------------------------------------------------------------------
// USBD Structures for class drivers
//------------------------------------------------------------------------------------
typedef union _URB *PURB;
typedef VOID (*PURB_COMPLETE_PROC)(PURB Urb, PVOID Context);

//
//  See approptate HCD header file for
//  for flags.
//
struct _URB_HCD_AREA
{
    union
    {
        USHORT  HcdTDCount;
        USHORT  HcdOriginalLength;  //While programed contains the original length
    
	};
    USHORT  HcdUrbFlags;
	PURB    HcdUrbLink;     //Used while the URB is pending
};

struct _URB_HEADER
{
    UCHAR               Length;
    UCHAR               Function;
    USBD_STATUS         Status;
    PURB_COMPLETE_PROC  CompleteProc;       // A completetion routine if the URB is not associated with an Irp
    PVOID               CompleteContext;    // Context to pass into the completion routine.
};

typedef struct _USB_CONTROL_SETUP_PACKET
{
    UCHAR   bmRequestType;
    UCHAR   bRequest;
    USHORT  wValue;
    USHORT  wIndex;
    USHORT  wLength;
} USB_CONTROL_SETUP_PACKET;

typedef struct _URB_CONTROL_TRANSFER
{
    struct _URB_HEADER          Hdr;                    
    PVOID                       EndpointHandle;
    ULONG                       TransferBufferLength;
    PVOID                       TransferBuffer;
    UCHAR                       TransferDirection;
    BOOLEAN                     ShortTransferOK;
    UCHAR                       InterruptDelay;
    UCHAR                       Padding;
    struct _URB_HCD_AREA        Hca;
    USB_CONTROL_SETUP_PACKET    SetupPacket;
} URB_CONTROL_TRANSFER, *PURB_CONTROL_TRANSFER;

typedef struct _URB_BULK_OR_INTERRUPT_TRANSFER
{
    struct _URB_HEADER      Hdr;
    PVOID                   EndpointHandle;
    ULONG                   TransferBufferLength;
    PVOID                   TransferBuffer;
    UCHAR                   TransferDirection;
    BOOLEAN                 ShortTransferOK;
    UCHAR                   InterruptDelay;
    UCHAR                   Padding;
    struct _URB_HCD_AREA    Hca;   // fields for HCD use
} URB_BULK_OR_INTERRUPT_TRANSFER, *PURB_BULK_OR_INTERRUPT_TRANSFER;


typedef struct _URB_OPEN_ENDPOINT
{
    struct _URB_HEADER          Hdr;
    PVOID                       EndpointHandle;
    UCHAR                       FunctionAddress;
    UCHAR                       EndpointAddress;
    UCHAR                       EndpointType;
    UCHAR                       Interval;
    PULONG                      DataToggleBits; // Filled out by USBD
    USHORT                      MaxPacketSize;
    BOOLEAN                     LowSpeed;   //Temporary - filled out by USBD
} URB_OPEN_ENDPOINT, *PURB_OPEN_ENDPOINT;

typedef struct _URB_CLOSE_ENDPOINT
{
    struct _URB_HEADER     Hdr;
    PVOID                  EndpointHandle;
    PURB                   HcdNextClose;   // An extra pointer which Hcd can use to link pending closes.
    PULONG                 DataToggleBits; // Filled out by USBD
} URB_CLOSE_ENDPOINT, *PURB_CLOSE_ENDPOINT;

typedef struct _URB_GET_SET_ENDPOINT_STATE
{
    struct _URB_HEADER      Hdr;
    PVOID                   EndpointHandle;
    ULONG                   EndpointState;
} URB_GET_SET_ENDPOINT_STATE, *PURB_GET_SET_ENDPOINT_STATE;

typedef struct _URB_ABORT_ENDPOINT
{
    struct _URB_HEADER      Hdr;
    PVOID                   EndpointHandle;
    PURB                    HcdNextAbort;   // An extra pointer which Hcd can use to link pending aborts.
} URB_ABORT_ENDPOINT, *PURB_ABORT_ENDPOINT;

typedef struct _URB_RESET_PORT
{
    struct _URB_HEADER  Hdr;
    UCHAR               DeviceNode;
    UCHAR               PortNumber;
} URB_RESET_PORT, *PURB_RESET_PORT;

typedef struct _URB_GET_FRAME_NUMBER
{
    struct _URB_HEADER  Hdr;
    UCHAR               DeviceNode;
    ULONG               FrameNumber;
} URB_GET_FRAME_NUMBER, *PURB_GET_FRAME_NUMBER;


//------------------------------------------------
// Isoch related URBs and related structures
//------------------------------------------------
typedef struct _USBD_ISOCH_PACKET_STATUS_WORD
{
    USHORT BytesRead:12;
    USHORT ConditionCode:4;
} USBD_ISOCH_PACKET_STATUS_WORD, *PUSBD_ISOCH_PACKET_STATUS_WORD;

typedef struct _USBD_ISOCH_TRANSFER_STATUS
{
    USBD_STATUS                     Status;
    ULONG                           FrameCount;
    USBD_ISOCH_PACKET_STATUS_WORD   PacketStatus[8];
} USBD_ISOCH_TRANSFER_STATUS, *PUSBD_ISOCH_TRANSFER_STATUS;

typedef VOID (*PFNUSBD_ISOCH_TRANSFER_COMPLETE)(PUSBD_ISOCH_TRANSFER_STATUS Status, PVOID Context);

typedef struct _USBD_ISOCH_BUFFER_DESCRIPTOR
{
    ULONG                               FrameCount;
    PVOID                               TransferBuffer;
    USHORT                              Pattern[8];
    PFNUSBD_ISOCH_TRANSFER_COMPLETE     TransferComplete;
    PVOID                               Context;
} USBD_ISOCH_BUFFER_DESCRIPTOR, *PUSBD_ISOCH_BUFFER_DESCRIPTOR;

typedef struct _URB_ISOCH_ATTACH_BUFFER
{
    struct _URB_HEADER            Hdr;
    PVOID                         EndpointHandle;
    UCHAR                         InterruptDelay;
    PUSBD_ISOCH_BUFFER_DESCRIPTOR BufferDescriptor;
} URB_ISOCH_ATTACH_BUFFER, *PURB_ISOCH_ATTACH_BUFFER;

typedef struct _URB_ISOCH_START_TRANSFER
{
    struct _URB_HEADER     Hdr;
    PVOID                  EndpointHandle;
    ULONG                  FrameNumber;
    ULONG                  Flags;
} URB_ISOCH_START_TRANSFER, *PURB_ISOCH_START_TRANSFER;
#define URB_FLAG_ISOCH_START_ASAP 0x0001
#define USBD_ISOCH_START_FRAME_RANGE 1024

typedef struct _URB_ISOCH_STOP_TRANSFER
{
    struct _URB_HEADER     Hdr;
    PVOID                  EndpointHandle;
} URB_ISOCH_STOP_TRANSFER, *PURB_ISOCH_STOP_TRANSFER;

typedef struct _URB_ISOCH_OPEN_ENDPOINT
{
    struct _URB_HEADER              Hdr;
    PVOID                           EndpointHandle;
    UCHAR                           FunctionAddress;
    UCHAR                           EndpointAddress;
    USHORT                          MaxPacketSize;
    USHORT                          Flags;
    USHORT                          Pad;
} URB_ISOCH_OPEN_ENDPOINT, *PURB_ISOCH_OPEN_ENDPOINT;
#define URB_FLAG_ISOCH_CIRCULAR_DMA 0x0001

typedef struct _URB_CLOSE_ENDPOINT URB_ISOCH_CLOSE_ENDPOINT, *PURB_ISOCH_CLOSE_ENDPOINT;

//------------------------------------------------
// Union of all URBs
//------------------------------------------------
typedef union _URB
{
    struct _URB_HEADER              Header;
    URB_CONTROL_TRANSFER            ControlTransfer;
    URB_BULK_OR_INTERRUPT_TRANSFER  BulkOrInterruptTransfer;
    URB_BULK_OR_INTERRUPT_TRANSFER  CommonTransfer;
    URB_OPEN_ENDPOINT               OpenEndpoint;
    URB_CLOSE_ENDPOINT              CloseEndpoint;
    URB_GET_SET_ENDPOINT_STATE      GetSetEndpointState;
    URB_ABORT_ENDPOINT              AbortEndpoint;
    URB_RESET_PORT                  ResetPort;
    URB_GET_FRAME_NUMBER            GetFrame;
    URB_ISOCH_ATTACH_BUFFER         IsochAttachBuffer;
    URB_ISOCH_START_TRANSFER        IsochStartTransfer;
    URB_ISOCH_STOP_TRANSFER         IsochStopTransfer;
    URB_ISOCH_OPEN_ENDPOINT         IsochOpenEndpoint;
    URB_ISOCH_CLOSE_ENDPOINT        IsochCloseEndpoint;
} URB;

//------------------------------------------------------------------------------------
// Macros to build USB Request Blocks
//------------------------------------------------------------------------------------
#define USB_BUILD_CONTROL_TRANSFER(\
                        _UrbControlTransfer_,\
                        _EndpointHandle_,\
                        _TransferBuffer_,\
                        _TransferBufferLength_,\
                        _TransferDirection_,\
                        _CompleteProc_,\
                        _CompleteContext_,\
                        _ShortTransferOK_,\
                        _bmRequestType_,\
                        _bRequest_,\
                        _wValue_,\
                        _wIndex_,\
                        _wLength_\
    )\
    {\
        (_UrbControlTransfer_)->Hdr.Length                  =   sizeof(URB_CONTROL_TRANSFER);\
        (_UrbControlTransfer_)->Hdr.Function                =   URB_FUNCTION_CONTROL_TRANSFER;\
        (_UrbControlTransfer_)->Hdr.CompleteProc            =   (_CompleteProc_);\
        (_UrbControlTransfer_)->Hdr.CompleteContext         =   (_CompleteContext_);\
        (_UrbControlTransfer_)->EndpointHandle              =   (_EndpointHandle_);\
        (_UrbControlTransfer_)->TransferBuffer              =   (_TransferBuffer_);\
        (_UrbControlTransfer_)->TransferBufferLength        =   (_TransferBufferLength_);\
        (_UrbControlTransfer_)->TransferDirection           =   (_TransferDirection_);\
        (_UrbControlTransfer_)->ShortTransferOK             =   (_ShortTransferOK_);\
        (_UrbControlTransfer_)->InterruptDelay              =   USBD_DELAY_INTERRUPT_0_MS;\
        (_UrbControlTransfer_)->SetupPacket.bmRequestType   =   (_bmRequestType_);\
        (_UrbControlTransfer_)->SetupPacket.bRequest        =   (_bRequest_);\
        (_UrbControlTransfer_)->SetupPacket.wValue          =   (_wValue_);\
        (_UrbControlTransfer_)->SetupPacket.wIndex          =   (_wIndex_);\
        (_UrbControlTransfer_)->SetupPacket.wLength         =   (_wLength_);\
    }


#define USB_BUILD_BULK_OR_INTERRUPT_TRANSFER(\
                        _UrbBulkOrInterruptTransfer_,\
                        _EndpointHandle_,\
                        _TransferBuffer_,\
                        _TransferBufferLength_,\
                        _TransferDirection_,\
                        _CompleteProc_,\
                        _CompleteContext_,\
                        _ShortTransferOK_\
    )\
    {\
        (_UrbBulkOrInterruptTransfer_)->Hdr.Length          =   sizeof(URB_BULK_OR_INTERRUPT_TRANSFER);\
        (_UrbBulkOrInterruptTransfer_)->Hdr.Function        =   URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER;\
        (_UrbBulkOrInterruptTransfer_)->Hdr.CompleteProc    =   (_CompleteProc_);\
        (_UrbBulkOrInterruptTransfer_)->Hdr.CompleteContext =   (_CompleteContext_);\
        (_UrbBulkOrInterruptTransfer_)->EndpointHandle      =   (_EndpointHandle_);\
        (_UrbBulkOrInterruptTransfer_)->TransferBuffer      =   (_TransferBuffer_);\
        (_UrbBulkOrInterruptTransfer_)->TransferBufferLength=   (_TransferBufferLength_);\
        (_UrbBulkOrInterruptTransfer_)->TransferDirection   =   (_TransferDirection_);\
        (_UrbBulkOrInterruptTransfer_)->ShortTransferOK     =   (_ShortTransferOK_);\
        (_UrbBulkOrInterruptTransfer_)->InterruptDelay      =   USBD_DELAY_INTERRUPT_0_MS;\
    }

//
// Isoch requests
//

#define USB_BUILD_ISOCH_OPEN_ENDPOINT(\
                        _UrbIsochOpenEndpoint_,\
                        _EndpointAddress_,\
                        _MaxPacketSize_,\
                        _Flags_\
    )\
    {\
        (_UrbIsochOpenEndpoint_)->Hdr.Length         =   sizeof(URB_ISOCH_OPEN_ENDPOINT);\
        (_UrbIsochOpenEndpoint_)->Hdr.Function       =   URB_FUNCTION_ISOCH_OPEN_ENDPOINT;\
        (_UrbIsochOpenEndpoint_)->Hdr.CompleteProc   =   NULL;\
        (_UrbIsochOpenEndpoint_)->Hdr.CompleteContext=   NULL;\
        (_UrbIsochOpenEndpoint_)->EndpointAddress    =   (_EndpointAddress_);\
        (_UrbIsochOpenEndpoint_)->MaxPacketSize      =   (_MaxPacketSize_);\
        (_UrbIsochOpenEndpoint_)->Flags              =   (_Flags_);\
    }

#define USB_BUILD_ISOCH_CLOSE_ENDPOINT(\
                        _UrbIsochCloseEndpoint_,\
                        _EndpointHandle_,\
						_CompleteProc_,\
						_CompleteContext_\
    )\
    {\
        (_UrbIsochCloseEndpoint_)->Hdr.Length           =   sizeof(URB_ISOCH_CLOSE_ENDPOINT);\
        (_UrbIsochCloseEndpoint_)->Hdr.Function         =   URB_FUNCTION_ISOCH_CLOSE_ENDPOINT;\
        (_UrbIsochCloseEndpoint_)->Hdr.CompleteProc     =   (_CompleteProc_);\
        (_UrbIsochCloseEndpoint_)->Hdr.CompleteContext  =   (_CompleteContext_);\
        (_UrbIsochCloseEndpoint_)->EndpointHandle       =   (_EndpointHandle_);\
    }

#define USB_BUILD_ISOCH_START_TRANSFER(\
                        _UrbIsochStartTransfer_,\
                        _EndpointHandle_,\
                        _FrameNumber_,\
                        _Flags_\
    )\
    {\
        (_UrbIsochStartTransfer_)->Hdr.Length           =   sizeof(URB_ISOCH_START_TRANSFER);\
        (_UrbIsochStartTransfer_)->Hdr.Function         =   URB_FUNCTION_ISOCH_START_TRANSFER;\
        (_UrbIsochStartTransfer_)->Hdr.CompleteProc     =   NULL;\
        (_UrbIsochStartTransfer_)->Hdr.CompleteContext  =   NULL;\
        (_UrbIsochStartTransfer_)->EndpointHandle       =   (_EndpointHandle_);\
        (_UrbIsochStartTransfer_)->FrameNumber          =   (_FrameNumber_);\
        (_UrbIsochStartTransfer_)->Flags                =   (_Flags_);\
    }

#define USB_BUILD_ISOCH_STOP_TRANSFER(\
                        _UrbIsochStopTransfer_,\
                        _EndpointHandle_\
    )\
    {\
        (_UrbIsochStopTransfer_)->Hdr.Length           =   sizeof(URB_ISOCH_STOP_TRANSFER);\
        (_UrbIsochStopTransfer_)->Hdr.Function         =   URB_FUNCTION_ISOCH_STOP_TRANSFER;\
        (_UrbIsochStopTransfer_)->Hdr.CompleteProc     =   NULL;\
        (_UrbIsochStopTransfer_)->Hdr.CompleteContext  =   NULL;\
        (_UrbIsochStopTransfer_)->EndpointHandle       =   (_EndpointHandle_);\
    }


#define USB_BUILD_ISOCH_ATTACH_BUFFER(\
                        _UrbIsochAttachBuffer_,\
                        _EndpointHandle_,\
                        _InterruptDelay_,\
                        _BufferDescriptor_\
    )\
    {\
        (_UrbIsochAttachBuffer_)->Hdr.Length            =   sizeof(URB_ISOCH_ATTACH_BUFFER);\
        (_UrbIsochAttachBuffer_)->Hdr.Function          =   URB_FUNCTION_ISOCH_ATTACH_BUFFER;\
        (_UrbIsochAttachBuffer_)->Hdr.CompleteProc      =   NULL;\
        (_UrbIsochAttachBuffer_)->Hdr.CompleteContext   =   NULL;\
        (_UrbIsochAttachBuffer_)->EndpointHandle       =   (_EndpointHandle_);\
        (_UrbIsochAttachBuffer_)->InterruptDelay       =   (_InterruptDelay_);\
        (_UrbIsochAttachBuffer_)->BufferDescriptor     =   (_BufferDescriptor_);\
    }

//
// Bulk or Interrupt requests
//

#define USB_BUILD_OPEN_ENDPOINT(\
                        _UrbOpenEndpoint_,\
                        _EndpointAddress_,\
                        _EndpointType_,\
                        _MaxPacketSize_,\
                        _Interval_\
    )\
    {\
        (_UrbOpenEndpoint_)->Hdr.Length         =   sizeof(URB_OPEN_ENDPOINT);\
        (_UrbOpenEndpoint_)->Hdr.Function       =   URB_FUNCTION_OPEN_ENDPOINT;\
        (_UrbOpenEndpoint_)->Hdr.CompleteProc   =   NULL;\
        (_UrbOpenEndpoint_)->EndpointAddress    =   (_EndpointAddress_);\
        (_UrbOpenEndpoint_)->EndpointType       =   (_EndpointType_);\
        (_UrbOpenEndpoint_)->Interval           =   (_Interval_);\
        (_UrbOpenEndpoint_)->MaxPacketSize      =   (_MaxPacketSize_);\
    }

#define USB_BUILD_CLOSE_ENDPOINT(\
                        _UrbCloseEndpoint_,\
                        _EndpointHandle_,\
                        _CompleteProc_,\
                        _CompleteContext_\
    )\
    {\
        (_UrbCloseEndpoint_)->Hdr.Length        =   sizeof(URB_CLOSE_ENDPOINT);\
        (_UrbCloseEndpoint_)->Hdr.Function      =   URB_FUNCTION_CLOSE_ENDPOINT;\
        (_UrbCloseEndpoint_)->Hdr.CompleteProc  =   (_CompleteProc_);\
        (_UrbCloseEndpoint_)->Hdr.CompleteContext = (_CompleteContext_);\
        (_UrbCloseEndpoint_)->EndpointHandle    =   (_EndpointHandle_);\
    }

#define USB_BUILD_OPEN_DEFAULT_ENDPOINT(\
                            _UrbOpenEndpoint_\
    )\
    {\
        (_UrbOpenEndpoint_)->Hdr.Length         =   sizeof(URB_OPEN_ENDPOINT);\
        (_UrbOpenEndpoint_)->Hdr.Function       =   URB_FUNCTION_OPEN_DEFAULT_ENDPOINT;\
        (_UrbOpenEndpoint_)->Hdr.CompleteProc   =   NULL;\
    }

#define USB_BUILD_CLOSE_DEFAULT_ENDPOINT(_UrbCloseEndpoint_, _CompleteProc_, _CompleteContext_)\
    {\
        (_UrbCloseEndpoint_)->Hdr.Length        =   sizeof(URB_CLOSE_ENDPOINT);\
        (_UrbCloseEndpoint_)->Hdr.Function      =   URB_FUNCTION_CLOSE_DEFAULT_ENDPOINT;\
        (_UrbCloseEndpoint_)->Hdr.CompleteProc  =   (_CompleteProc_);\
        (_UrbCloseEndpoint_)->Hdr.CompleteContext = (_CompleteContext_);\
    }

#define USB_BUILD_GET_ENDPOINT_STATE(_UrbGetSetEndpointState_, _EndpointHandle_)\
{\
    (_UrbGetSetEndpointState_)->Hdr.Length          =   sizeof(URB_GET_SET_ENDPOINT_STATE);\
    (_UrbGetSetEndpointState_)->Hdr.Function        =   URB_FUNCTION_GET_ENDPOINT_STATE;\
    (_UrbGetSetEndpointState_)->Hdr.CompleteProc    =   NULL;\
    (_UrbGetSetEndpointState_)->EndpointHandle      =   (_EndpointHandle_);\
}

#define USB_BUILD_SET_ENDPOINT_STATE(_UrbGetSetEndpointState_, _EndpointHandle_, _StateFlags_)\
{\
    (_UrbGetSetEndpointState_)->Hdr.Length          =   sizeof(URB_GET_SET_ENDPOINT_STATE);\
    (_UrbGetSetEndpointState_)->Hdr.Function        =   URB_FUNCTION_SET_ENDPOINT_STATE;\
    (_UrbGetSetEndpointState_)->Hdr.CompleteProc    =   NULL;\
    (_UrbGetSetEndpointState_)->EndpointHandle      =   (_EndpointHandle_);\
    (_UrbGetSetEndpointState_)->EndpointState       =   (_StateFlags_);\
}

#define USB_BUILD_ABORT_ENDPOINT(_UrbAbortEndpoint_, _EndpointHandle_, _CompleteProc_, _CompleteContext_)\
{\
    (_UrbAbortEndpoint_)->Hdr.Length          =   sizeof(URB_ABORT_ENDPOINT);\
    (_UrbAbortEndpoint_)->Hdr.Function        =   URB_FUNCTION_ABORT_ENDPOINT;\
    (_UrbAbortEndpoint_)->Hdr.CompleteProc    =   (_CompleteProc_);\
	(_UrbAbortEndpoint_)->Hdr.CompleteContext =   (_CompleteContext_);\
    (_UrbAbortEndpoint_)->EndpointHandle      =   (_EndpointHandle_);\
}

#define USB_BUILD_RESET_PORT(_UrbResetPort_)\
{\
    (_UrbResetPort_)->Hdr.Length        =   sizeof(URB_RESET_PORT);\
    (_UrbResetPort_)->Hdr.Function      =   URB_FUNCTION_RESET_PORT;\
    (_UrbResetPort_)->Hdr.CompleteProc  =   NULL;\
}

#define USB_BUILD_GET_FRAME(_UrbGetFrame_)\
{\
    (_UrbResetPort_)->Hdr.Length        =   sizeof(URB_GET_FRAME);\
    (_UrbResetPort_)->Hdr.Function      =   URB_FUNCTION_GET_FRAME;\
    (_UrbResetPort_)->Hdr.CompleteProc  =   NULL;\
}

//------------------------------------------------------------------------------------
// Macros to build standard USB Command Request Blocks
//------------------------------------------------------------------------------------
#define USB_BUILD_CLEAR_FEATURE(\
                _UrbControlTransfer_,\
                _Recipient_,\
                _FeatureSelect_,\
                _Index_,\
                _CompleteProc_,\
                _CompleteContext_\
                )\
{\
    (_UrbControlTransfer_)->Hdr.Length                  = sizeof(URB_CONTROL_TRANSFER);\
    (_UrbControlTransfer_)->Hdr.Function                = URB_FUNCTION_CONTROL_TRANSFER;\
    (_UrbControlTransfer_)->Hdr.CompleteProc            = (_CompleteProc_);\
    (_UrbControlTransfer_)->Hdr.CompleteContext         = (_CompleteContext_);\
    (_UrbControlTransfer_)->EndpointHandle              = NULL;\
    (_UrbControlTransfer_)->TransferBuffer              = NULL;\
    (_UrbControlTransfer_)->TransferBufferLength        = 0;\
    (_UrbControlTransfer_)->TransferDirection           = 0;\
    (_UrbControlTransfer_)->ShortTransferOK             = 0;\
    (_UrbControlTransfer_)->InterruptDelay              = USBD_DELAY_INTERRUPT_0_MS;\
    (_UrbControlTransfer_)->SetupPacket.bmRequestType   = (_Recipient_);\
    (_UrbControlTransfer_)->SetupPacket.bRequest        = USB_REQUEST_CLEAR_FEATURE;\
    (_UrbControlTransfer_)->SetupPacket.wValue          = (_FeatureSelect_);\
    (_UrbControlTransfer_)->SetupPacket.wIndex          = (_Index_);\
    (_UrbControlTransfer_)->SetupPacket.wLength         = 0;\
}

#define USB_BUILD_SET_FEATURE(\
                _UrbControlTransfer_,\
                _Recipient_,\
                _FeatureSelect_,\
                _Index_,\
                _CompleteProc_,\
                _CompleteContext_\
                )\
{\
    (_UrbControlTransfer_)->Hdr.Length                  = sizeof(URB_CONTROL_TRANSFER);\
    (_UrbControlTransfer_)->Hdr.Function                = URB_FUNCTION_CONTROL_TRANSFER;\
    (_UrbControlTransfer_)->Hdr.CompleteProc            = (_CompleteProc_);\
    (_UrbControlTransfer_)->Hdr.CompleteContext         = (_CompleteContext_);\
    (_UrbControlTransfer_)->EndpointHandle              = NULL;\
    (_UrbControlTransfer_)->TransferBuffer              = NULL;\
    (_UrbControlTransfer_)->TransferBufferLength        = 0;\
    (_UrbControlTransfer_)->TransferDirection           = 0;\
    (_UrbControlTransfer_)->ShortTransferOK             = 0;\
    (_UrbControlTransfer_)->InterruptDelay              = USBD_DELAY_INTERRUPT_0_MS;\
    (_UrbControlTransfer_)->SetupPacket.bmRequestType   = (_Recipient_);\
    (_UrbControlTransfer_)->SetupPacket.bRequest        = USB_REQUEST_SET_FEATURE;\
    (_UrbControlTransfer_)->SetupPacket.wValue          = (_FeatureSelect_);\
    (_UrbControlTransfer_)->SetupPacket.wIndex          = (_Index_);\
    (_UrbControlTransfer_)->SetupPacket.wLength         = 0;\
}

#define USB_BUILD_GET_CONFIGURATION(\
                _UrbControlTransfer_,\
                _Configuration_,\
                _CompleteProc_,\
                _CompleteContext_\
                )\
{\
    (_UrbControlTransfer_)->Hdr.Length                  = sizeof(URB_CONTROL_TRANSFER);\
    (_UrbControlTransfer_)->Hdr.Function                = URB_FUNCTION_CONTROL_TRANSFER;\
    (_UrbControlTransfer_)->Hdr.CompleteProc            = (_CompleteProc_);\
    (_UrbControlTransfer_)->Hdr.CompleteContext         = (_CompleteContext_);\
    (_UrbControlTransfer_)->EndpointHandle              = NULL;\
    (_UrbControlTransfer_)->TransferBuffer              = (_Configuration_);\
    (_UrbControlTransfer_)->TransferBufferLength        = sizeof(UCHAR);\
    (_UrbControlTransfer_)->TransferDirection           = USB_TRANSFER_DIRECTION_IN;\
    (_UrbControlTransfer_)->ShortTransferOK             = 0;\
    (_UrbControlTransfer_)->InterruptDelay              = USBD_DELAY_INTERRUPT_0_MS;\
    (_UrbControlTransfer_)->SetupPacket.bmRequestType   = USB_DEVICE_TO_HOST;\
    (_UrbControlTransfer_)->SetupPacket.bRequest        = USB_REQUEST_GET_CONFIGURATION;\
    (_UrbControlTransfer_)->SetupPacket.wValue          = 0;\
    (_UrbControlTransfer_)->SetupPacket.wIndex          = 0;\
    (_UrbControlTransfer_)->SetupPacket.wLength         = 1;\
}

#define USB_BUILD_SET_CONFIGURATION(\
                _UrbControlTransfer_,\
                _Configuration_,\
                _CompleteProc_,\
                _CompleteContext_\
                )\
{\
    (_UrbControlTransfer_)->Hdr.Length                  = sizeof(URB_CONTROL_TRANSFER);\
    (_UrbControlTransfer_)->Hdr.Function                = URB_FUNCTION_CONTROL_TRANSFER;\
    (_UrbControlTransfer_)->Hdr.CompleteProc            = (_CompleteProc_);\
    (_UrbControlTransfer_)->Hdr.CompleteContext         = (_CompleteContext_);\
    (_UrbControlTransfer_)->EndpointHandle              = NULL;\
    (_UrbControlTransfer_)->TransferBuffer              = 0;\
    (_UrbControlTransfer_)->TransferBufferLength        = 0;\
    (_UrbControlTransfer_)->TransferDirection           = 0;\
    (_UrbControlTransfer_)->ShortTransferOK             = 0;\
    (_UrbControlTransfer_)->InterruptDelay              = USBD_DELAY_INTERRUPT_0_MS;\
    (_UrbControlTransfer_)->SetupPacket.bmRequestType   = USB_HOST_TO_DEVICE;\
    (_UrbControlTransfer_)->SetupPacket.bRequest        = USB_REQUEST_SET_CONFIGURATION;\
    (_UrbControlTransfer_)->SetupPacket.wValue          = (_Configuration_);\
    (_UrbControlTransfer_)->SetupPacket.wIndex          = 0;\
    (_UrbControlTransfer_)->SetupPacket.wLength         = 0;\
}


#define USB_BUILD_GET_DESCRIPTOR(\
                _UrbControlTransfer_,\
                _DescriptorType_,\
                _DescriptorIndex_,\
                _LanguageID_,\
                _DescriptorBuffer_,\
                _DescriptorBufferLength_,\
                _CompleteProc_,\
                _CompleteContext_\
                )\
{\
    (_UrbControlTransfer_)->Hdr.Length                  = sizeof(URB_CONTROL_TRANSFER);\
    (_UrbControlTransfer_)->Hdr.Function                = URB_FUNCTION_CONTROL_TRANSFER;\
    (_UrbControlTransfer_)->Hdr.CompleteProc            = (_CompleteProc_);\
    (_UrbControlTransfer_)->Hdr.CompleteContext         = (_CompleteContext_);\
    (_UrbControlTransfer_)->EndpointHandle              = NULL;\
    (_UrbControlTransfer_)->TransferBuffer              = (_DescriptorBuffer_);\
    (_UrbControlTransfer_)->TransferBufferLength        = (_DescriptorBufferLength_);\
    (_UrbControlTransfer_)->TransferDirection           = USB_TRANSFER_DIRECTION_IN;\
    (_UrbControlTransfer_)->ShortTransferOK             = TRUE;\
    (_UrbControlTransfer_)->InterruptDelay              = USBD_DELAY_INTERRUPT_0_MS;\
    (_UrbControlTransfer_)->SetupPacket.bmRequestType   = USB_DEVICE_TO_HOST;\
    (_UrbControlTransfer_)->SetupPacket.bRequest        = USB_REQUEST_GET_DESCRIPTOR;\
    (_UrbControlTransfer_)->SetupPacket.wValue          = ((_DescriptorType_)<<8)|(_DescriptorIndex_);\
    (_UrbControlTransfer_)->SetupPacket.wIndex          = (_LanguageID_);\
    (_UrbControlTransfer_)->SetupPacket.wLength         = (_DescriptorBufferLength_);\
}

#define USB_BUILD_SET_DESCRIPTOR(\
                _UrbControlTransfer_,\
                _DescriptorType_,\
                _DescriptorIndex_,\
                _LanguageID_,\
                _DescriptorBuffer_,\
                _DescriptorBufferLength_,\
                _CompleteProc_,\
                _CompleteContext_\
                )\
{\
    (_UrbControlTransfer_)->Hdr.Length                  = sizeof(URB_CONTROL_TRANSFER);\
    (_UrbControlTransfer_)->Hdr.Function                = URB_FUNCTION_CONTROL_TRANSFER;\
    (_UrbControlTransfer_)->Hdr.CompleteProc            = (_CompleteProc_);\
    (_UrbControlTransfer_)->Hdr.CompleteContext         = (_CompleteContext_);\
    (_UrbControlTransfer_)->EndpointHandle              = NULL;\
    (_UrbControlTransfer_)->TransferBuffer              = (_DescriptorBuffer_);\
    (_UrbControlTransfer_)->TransferBufferLength        = (_DescriptorBufferLength_);\
    (_UrbControlTransfer_)->TransferDirection           = USB_TRANSFER_DIRECTION_OUT;\
    (_UrbControlTransfer_)->ShortTransferOK             = FALSE;\
    (_UrbControlTransfer_)->InterruptDelay              = USBD_DELAY_INTERRUPT_0_MS;\
    (_UrbControlTransfer_)->SetupPacket.bmRequestType   = USB_HOST_TO_DEVICE;\
    (_UrbControlTransfer_)->SetupPacket.bRequest        = USB_REQUEST_SET_DESCRIPTOR;\
    (_UrbControlTransfer_)->SetupPacket.wValue          = ((_DescriptorType_)<<8)|(_DescriptorIndex_);\
    (_UrbControlTransfer_)->SetupPacket.wIndex          = (_LanguageID_);\
    (_UrbControlTransfer_)->SetupPacket.wLength         = (_DescriptorBufferLength_);\
}


#define USB_BUILD_GET_INTERFACE(\
                _UrbControlTransfer_,\
                _Interface_,\
                _AlternateSetting_,\
                _CompleteProc_,\
                _CompleteContext_\
                )\
{\
    (_UrbControlTransfer_)->Hdr.Length                  = sizeof(URB_CONTROL_TRANSFER);\
    (_UrbControlTransfer_)->Hdr.Function                = URB_FUNCTION_CONTROL_TRANSFER;\
    (_UrbControlTransfer_)->Hdr.CompleteProc            = (_CompleteProc_);\
    (_UrbControlTransfer_)->Hdr.CompleteContext         = (_CompleteContext_);\
    (_UrbControlTransfer_)->EndpointHandle              = NULL;\
    (_UrbControlTransfer_)->TransferBuffer              = (_AlternateSetting_);\
    (_UrbControlTransfer_)->TransferBufferLength        = sizeof(UCHAR);\
    (_UrbControlTransfer_)->TransferDirection           = USB_TRANSFER_DIRECTION_IN;\
    (_UrbControlTransfer_)->ShortTransferOK             = 0;\
    (_UrbControlTransfer_)->InterruptDelay              = USBD_DELAY_INTERRUPT_0_MS;\
    (_UrbControlTransfer_)->SetupPacket.bmRequestType   = USB_DEVICE_TO_HOST;\
    (_UrbControlTransfer_)->SetupPacket.bRequest        = USB_REQUEST_GET_INTERFACE;\
    (_UrbControlTransfer_)->SetupPacket.wValue          = 0\
    (_UrbControlTransfer_)->SetupPacket.wIndex          = (_Interface_);\
    (_UrbControlTransfer_)->SetupPacket.wLength         = 1;\
}

#define USB_BUILD_SET_INTERFACE(\
                _UrbControlTransfer_,\
                _Interface_,\
                _AlternateSetting_,\
                _CompleteProc_,\
                _CompleteContext_\
                )\
{\
    (_UrbControlTransfer_)->Hdr.Length                  = sizeof(URB_CONTROL_TRANSFER);\
    (_UrbControlTransfer_)->Hdr.Function                = URB_FUNCTION_CONTROL_TRANSFER;\
    (_UrbControlTransfer_)->Hdr.CompleteProc            = (_CompleteProc_);\
    (_UrbControlTransfer_)->Hdr.CompleteContext         = (_CompleteContext_);\
    (_UrbControlTransfer_)->EndpointHandle              = NULL;\
    (_UrbControlTransfer_)->TransferBuffer              = 0;\
    (_UrbControlTransfer_)->TransferBufferLength        = 0;\
    (_UrbControlTransfer_)->TransferDirection           = 0;\
    (_UrbControlTransfer_)->ShortTransferOK             = 0;\
    (_UrbControlTransfer_)->InterruptDelay              = USBD_DELAY_INTERRUPT_0_MS;\
    (_UrbControlTransfer_)->SetupPacket.bmRequestType   = USB_HOST_TO_DEVICE;\
    (_UrbControlTransfer_)->SetupPacket.bRequest        = USB_REQUEST_SET_INTERFACE;\
    (_UrbControlTransfer_)->SetupPacket.wValue          = (_AlternateSetting_);\
    (_UrbControlTransfer_)->SetupPacket.wIndex          = (_Interface_);\
    (_UrbControlTransfer_)->SetupPacket.wLength         = 0;\
}


#define USB_BUILD_GET_STATUS(\
                _UrbControlTransfer_,\
                _Recipient_,\
                _Index_,\
                _Status_,\
                _CompleteProc_,\
                _CompleteContext_\
                )\
{\
    (_UrbControlTransfer_)->Hdr.Length                  = sizeof(URB_CONTROL_TRANSFER);\
    (_UrbControlTransfer_)->Hdr.Function                = URB_FUNCTION_CONTROL_TRANSFER;\
    (_UrbControlTransfer_)->Hdr.CompleteProc            = (_CompleteProc_);\
    (_UrbControlTransfer_)->Hdr.CompleteContext         = (_CompleteContext_);\
    (_UrbControlTransfer_)->EndpointHandle              = NULL;\
    (_UrbControlTransfer_)->TransferBuffer              = (_Status_);\
    (_UrbControlTransfer_)->TransferBufferLength        = size(WORD);\
    (_UrbControlTransfer_)->TransferDirection           = USB_TRANSFER_DIRECTION_IN;\
    (_UrbControlTransfer_)->ShortTransferOK             = 0;\
    (_UrbControlTransfer_)->InterruptDelay              = USBD_DELAY_INTERRUPT_0_MS;\
    (_UrbControlTransfer_)->SetupPacket.bmRequestType   = (USB_DEVICE_TO_HOST|(_Recipient_));\
    (_UrbControlTransfer_)->SetupPacket.bRequest        = USB_REQUEST_GET_STATUS;\
    (_UrbControlTransfer_)->SetupPacket.wValue          = 0;\
    (_UrbControlTransfer_)->SetupPacket.wIndex          =(_Index_);\
    (_UrbControlTransfer_)->SetupPacket.wLength         = 2;\
}

#define USB_BUILD_SYNC_FRAME(\
                _UrbControlTransfer_,\
                _Endpoint_,\
                _Frame_,\
                _CompleteProc_,\
                _CompleteContext_\
                )\
{\
    (_UrbControlTransfer_)->Hdr.Length                  = sizeof(URB_CONTROL_TRANSFER);\
    (_UrbControlTransfer_)->Hdr.Function                = URB_FUNCTION_CONTROL_TRANSFER;\
    (_UrbControlTransfer_)->Hdr.CompleteProc            = (_CompleteProc_);\
    (_UrbControlTransfer_)->Hdr.CompleteContext         = (_CompleteContext_);\
    (_UrbControlTransfer_)->EndpointHandle              = NULL;\
    (_UrbControlTransfer_)->TransferBuffer              = (_Frame_);\
    (_UrbControlTransfer_)->TransferBufferLength        = size(WORD);\
    (_UrbControlTransfer_)->TransferDirection           = USB_TRANSFER_DIRECTION_IN;\
    (_UrbControlTransfer_)->ShortTransferOK             = 0;\
    (_UrbControlTransfer_)->InterruptDelay              = USBD_DELAY_INTERRUPT_0_MS;\
    (_UrbControlTransfer_)->SetupPacket.bmRequestType   = (USB_DEVICE_TO_HOST|USB_COMMAND_TO_ENDPOINT);\
    (_UrbControlTransfer_)->SetupPacket.bRequest        = USB_REQUEST_SYNC_FRAME;\
    (_UrbControlTransfer_)->SetupPacket.wValue          = 0;\
    (_UrbControlTransfer_)->SetupPacket.wIndex          =(_Endpoint_);\
    (_UrbControlTransfer_)->SetupPacket.wLength         = 2;\
}

//-------------------------------------------------------------------------------------------------------------
// Get the USB status code
//-------------------------------------------------------------------------------------------------------------
#define URB_STATUS(urb) ((urb)->Header.Status)
} //end of 'extern "C"'
//------------------------------------------------------------------------------------
// bmRequestType values for commands over control pipes, belongs in usb100.h
//------------------------------------------------------------------------------------

//  Data Direction
#define USB_HOST_TO_DEVICE              0x00    
#define USB_DEVICE_TO_HOST              0x80

//  Type
#define USB_STANDARD_COMMAND            0x00
#define USB_CLASS_COMMAND               0x20
#define USB_VENDOR_COMMAND              0x40

//  Recipient
#define USB_COMMAND_TO_DEVICE           0x00
#define USB_COMMAND_TO_INTERFACE        0x01
#define USB_COMMAND_TO_ENDPOINT         0x02
#define USB_COMMAND_TO_OTHER            0x03

//------------------------------------------------------------------------------------
// The enumerator only provides the first eight bytes of the device descriptor
//------------------------------------------------------------------------------------
typedef struct _USB_DEVICE_DESCRIPTOR8 {
    UCHAR bLength;
    UCHAR bDescriptorType;
    USHORT bcdUSB;
    UCHAR bDeviceClass;
    UCHAR bDeviceSubClass;
    UCHAR bDeviceProtocol;
    UCHAR bMaxPacketSize0;
} USB_DEVICE_DESCRIPTOR8, *PUSB_DEVICE_DESCRIPTOR8;
//------------------------------------------------------------------------------------
//  Forward declaration of classes
//------------------------------------------------------------------------------------
class IUsbDevice;

//--------------------------------------------------------------------------------------------------------------
// Resource Requirements Structure
//--------------------------------------------------------------------------------------------------------------
typedef struct _USB_RESOURCE_REQUIREMENTS
{
    UCHAR ConnectorType;
    UCHAR MaxDevices;
    UCHAR MaxCompositeInterfaces;
    UCHAR MaxControlEndpoints;
    UCHAR MaxBulkEndpoints;
    UCHAR MaxInterruptEndpoints;
    UCHAR MaxControlTDperTransfer;
    UCHAR MaxBulkTDperTransfer;
    //Isoch
    UCHAR MaxIsochEndpoints;
    UCHAR MaxIsochMaxBuffers;
} USB_RESOURCE_REQUIREMENTS, *PUSB_RESOURCE_REQUIREMENTS;
//-------------------------------------------------------------------------------------------------
// This class is used to assist initialization.
//-------------------------------------------------------------------------------------------------
class IUsbInit
{
  public:
    ULONG GetMaxDeviceTypeCount(PXPP_DEVICE_TYPE XppDeviceType);
    VOID  RegisterResources(PUSB_RESOURCE_REQUIREMENTS pResourceRequirements);
    BOOL  UseDefaultCount();
};
//--------------------------------------------------------------------------------------------------------------
// Class Driver Static Registration 
//--------------------------------------------------------------------------------------------------------------
typedef union _PNP_CLASS_ID
{
    LONG AsLong;
    struct
    {
        UCHAR bClassSpecificType;
        UCHAR bClass;
        UCHAR bSubClass;
        UCHAR bProtocol;
    } USB;
} PNP_CLASS_ID, *PPNP_CLASS_ID;

// The high-bit of bClassSpecificType is set
// if the class driver has not indicated a class
// specific type.  Prior to calling AddDevice
// this is used to track whether this is a 
// device level or interface level class.
// 
// USB_CLASS_DRIVER_DECLARATION assumes PNP_INTERFACE_LEVEL_CLASS
// 
#define PNP_CLASS_SPECIFIC_TYPE_NOT_SET(bClassSpecificType) (bClassSpecificType&0x80)
#define PNP_DEVICE_LEVEL_CLASS    0x81
#define PNP_INTERFACE_LEVEL_CLASS 0x82

typedef
VOID
 (*PFNINIT_USB_DRIVER)(IUsbInit *UsbInit);

typedef
VOID
 (*PFNADD_USB_DEVICE)(
    IN IUsbDevice *Device
    );

typedef
VOID
 (*PFNREMOVE_USB_DEVICE)(
    IN IUsbDevice *Device
    );


typedef struct _USB_DEVICE_TYPE_DESCRIPTION
{
    PXPP_DEVICE_TYPE XppDeviceType;
} USB_DEVICE_TYPE_DESCRIPTION, *PUSB_DEVICE_TYPE_DESCRIPTION;

#define USB_CONNECTOR_TYPE_DIRECT     0  //Plugs directly into the front of xbox (or a hub port)
#define USB_CONNECTOR_TYPE_HIGH_POWER 1  //Plugs into a high power slot in gamepad
#define USB_CONNECTOR_TYPE_LOW_POWER  2  //Plugs into a high power or low power slot in gamepad

typedef struct _USB_CLASS_DRIVER_DESCRIPTION
{
    PNP_CLASS_ID                 ClassId;
    PFNINIT_USB_DRIVER           Init;
    PFNADD_USB_DEVICE            AddDevice;
    PFNREMOVE_USB_DEVICE         RemoveDevice;
    ULONG                        DeviceTypeCount;
    PXPP_DEVICE_TYPE             *DeviceTypes;
} USB_CLASS_DRIVER_DESCRIPTION, *PUSB_CLASS_DRIVER_DESCRIPTION;

#define DECLARE_XPP_TYPE(XppTypeName)\
EXTERNUSB XPP_DEVICE_TYPE XppTypeName##_TABLE = {0,0,0};

#define USB_DEVICE_TYPE_TABLE_BEGIN(ClassName)\
EXTERNUSB PXPP_DEVICE_TYPE ClassName##Types[]={

#define USB_DEVICE_TYPE_TABLE_ENTRY(XppDeviceType)\
                 (XppDeviceType)

#define USB_DEVICE_TYPE_TABLE_END() };

#define USB_CLASS_DRIVER_DECLARATION(ClassName, bClass, bSubClass, bProtocol)\
               EXTERNUSB VOID ClassName##Init(IUsbInit *UsbInit);\
               EXTERNUSB VOID ClassName##AddDevice(IUsbDevice *Device);\
               EXTERNUSB VOID ClassName##RemoveDevice(IUsbDevice *Device);\
               EXTERNUSB USB_CLASS_DRIVER_DESCRIPTION ClassName##Description = {\
                    PNP_INTERFACE_LEVEL_CLASS + ((bClass << 8) + (bSubClass << 16) + (bProtocol << 24)),\
                    ClassName##Init,\
                    ClassName##AddDevice,\
                    ClassName##RemoveDevice,\
                    sizeof(ClassName##Types)/sizeof(USB_DEVICE_TYPE_DESCRIPTION),\
                    ClassName##Types\
                   };

#define USB_CLASS_DRIVER_DECLARATION_DUPLICATE(ClassName, DuplicateNumber, bClass, bSubClass, bProtocol)\
               EXTERNUSB USB_CLASS_DRIVER_DESCRIPTION ClassName##DuplicateNumber##Description = {\
                    PNP_INTERFACE_LEVEL_CLASS + ((bClass << 8) + (bSubClass << 16) + (bProtocol << 24)),\
                    ClassName##Init,\
                    ClassName##AddDevice,\
                    ClassName##RemoveDevice,\
                    sizeof(ClassName##Types)/sizeof(USB_DEVICE_TYPE_DESCRIPTION),\
                    ClassName##Types\
                   };

#define USB_CLASS_DRIVER_DECLARATION_DEVICE_LEVEL(ClassName, bClass, bSubClass, bProtocol)\
               EXTERNUSB VOID ClassName##Init(IUsbInit *UsbInit);\
               EXTERNUSB VOID ClassName##AddDevice(IUsbDevice *Device);\
               EXTERNUSB VOID ClassName##RemoveDevice(IUsbDevice *Device);\
               EXTERNUSB USB_CLASS_DRIVER_DESCRIPTION ClassName##Description = {\
                    PNP_DEVICE_LEVEL_CLASS + ((bClass << 8) + (bSubClass << 16) + (bProtocol << 24)),\
                    ClassName##Init,\
                    ClassName##AddDevice,\
                    ClassName##RemoveDevice,\
                    sizeof(ClassName##Types)/sizeof(USB_DEVICE_TYPE_DESCRIPTION),\
                    ClassName##Types\
                   };

#define USB_CLASS_DECLARATION_POINTER(ClassName)\
                EXTERNUSB USB_CLASS_DRIVER_DESCRIPTION *ClassName##DescriptionPointer=&ClassName##Description;
#define USB_CLASS_DECLARATION_POINTER_DUPLICATE(ClassName, DuplicateNumber)\
                EXTERNUSB USB_CLASS_DRIVER_DESCRIPTION *ClassName##DuplicateNumber##DescriptionPointer=\
                &ClassName##DuplicateNumber##Description;

#define REFERENCE_CLASS(ClassName)\
    EXTERNUSB USB_CLASS_DRIVER_DESCRIPTION ClassName##Description;\
    static USB_CLASS_DRIVER_DESCRIPTION *classMU = &(ClassName##Description);

//---------------------------------------------------------------------------------------------------------------
//  IUsbDevice is the main interface to the core driver
//---------------------------------------------------------------------------------------------------------------
class IUsbDevice
{
    public:
    /*  IUsbDevice methods calleable at any time by class driver*/
    USBD_STATUS SubmitRequest(PURB Urb);
    USBD_STATUS CancelRequest(PURB Urb);
    BOOLEAN IsHardwareConnected() const;
    PVOID GetExtension() const;
    PVOID SetExtension(PVOID Extension);
    UCHAR GetInterfaceNumber() const;
	void SetClassSpecificType(UCHAR ClassSpecificType);
    ULONG GetPort() const;

    /*  IUsbDevice methods related to device enumeration*/
    void AddComplete(USBD_STATUS UsbdStatus);
    void RemoveComplete();
    void DeviceNotResponding();

    /*  IUsbDevice methods calleable only at enum time*/
    const USB_DEVICE_DESCRIPTOR8 *GetDeviceDescriptor() const;
    const USB_CONFIGURATION_DESCRIPTOR *GetConfigurationDescriptor() const;
    const USB_INTERFACE_DESCRIPTOR *GetInterfaceDescriptor() const;
    const USB_ENDPOINT_DESCRIPTOR *GetEndpointDescriptor(UCHAR EndpointType, BOOLEAN Direction, UCHAR Index) const;
    
	/*  IUsbDevice methods used only by hubs */
    void DeviceConnected(UCHAR PortNumber, UCHAR RetryCount);
    void DeviceDisconnected(UCHAR PortNumber);
    void ResetComplete(USBD_STATUS UsbdStatus, PVOID Context);
    void DisableComplete(USBD_STATUS UsbdStatus, PVOID Context);

    /* static IUsbDevice methods */
    static ULONG Win32FromUsbdStatus(USBD_STATUS UsbdStatus);
	static NTSTATUS NtStatusFromUsbdStatus(USBD_STATUS UsbdStatus);
};
//--------------------------------------------------------------------------------
//  Hub driver must implement this method
//--------------------------------------------------------------------------------
extern VOID USBHUB_DisableResetPort(
	                    IN IUsbDevice *HubDevice,
	                    IN UCHAR PortNumber,
	                    IN PVOID Context,
                        IN BOOLEAN Disable
	                    );

#endif //__USB_X__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\public\oak\bin\i386mk.inc ===
!IF 0

Copyright (c) 1994-1996  Microsoft Corporation

Module Name:

    i386mk.inc

Abstract:

        This module contains the x86 specific build controls.  It is included
        by makefile.def.

Revision History:

!ENDIF

DELAYLOAD_SUPPORTED=1
!ifndef DELAYLOAD_VERSION
DELAYLOAD_VERSION=0x0100
!endif

#
# x86 option control
#
UMBASE=$(UMBASE:*=i386)
UMLIBS=$(UMLIBS:*=i386)
NTRES=$(NTRES:*=i386)
UMRES=$(UMRES:*=i386)
UMOBJS=$(UMOBJS:*=i386)
LINKLIBS=$(LINKLIBS:*=i386)
GDI_DRIVER_LIBS=$(GDI_DRIVER_LIBS:*=i386)
DLLBASE=$(DLLBASE:*=i386)
DLLDEF=$(DLLDEF:*=i386)
MACHINE_TARGETLIBS=$(MACHINE_TARGETLIBS:*=i386)
!ifdef USE_MSHTML_PDB_RULES
MACHINE_TARGETLIBS=$(MACHINE_TARGETLIBS:????????=*)
!endif
TARGET=$(TARGET:*=i386)
DYNLINK_LIB=$(DYNLINK_LIB:*=i386)
TARGETEXEFILES=$(TARGETEXEFILES:*=i386)
TARGETLIBFILES=$(TARGETLIBFILES:*=i386)
TARGETOBJFILES=$(TARGETOBJFILES:*=i386)
UMOBJFILES=$(UMOBJFILES:*=i386)
UMEXEFILES=$(UMEXEFILES:*=i386)
HEADERFILE=$(HEADERFILE:*=i386)
HEADEROBJNAME=$(HEADEROBJNAME:*=i386)
HEADEROBJ=$(HEADEROBJ:*=i386)
PRECOMPILED=$(PRECOMPILED:*=i386)
PRECOMPILED_CXX=$(PRECOMPILED_CXX:*=i386)
PRECOMPILED_TARGET=$(PRECOMPILED_TARGET:*=i386)
MFC_STATIC_LIB=$(MFC_STATIC_LIB:*=i386)
CRT_LIB_PATH=$(CRT_LIB_PATH:*=i386)
SDK_LIB_PATH=$(SDK_LIB_PATH:*=i386)
ORDER=$(ORDER:*=i386)
OBJLIBFILES=$(OBJLIBFILES:*=i386)
MISCFILES=$(MISCFILES) $(I386_MISCFILES)

!ifdef CHICAGO_PRODUCT
USE_MAPSYM=1
!endif

# "$(TARGETTYPE)"=="DRIVER"     ||
# "$(TARGETTYPE)" == "HAL" ||
# "$(TARGETTYPE)" == "EXPORT_DRIVER" ||

!IF "$(TARGETTYPE)"=="GDI_DRIVER" || \
    "$(TARGETTYPE)"=="MINIPORT"
#
#Drivers don't link with link libs.
#
MACHINE_TARGETLIBS=$(SDK_LIB_PATH)\int64.lib $(MACHINE_TARGETLIBS)
!ELSE
!IF defined(USE_NTDLL) || defined (USE_NOLIBS)
! ifndef RESOURCE_ONLY_DLL
MACHINE_TARGETLIBS=$(SDK_LIB_PATH)\int64.lib $(MACHINE_TARGETLIBS)
! endif
!ENDIF
!ENDIF

!ifdef NTTARGETFILES
NTTARGETFILES=$(NTTARGETFILES:*=i386)
!endif
!ifdef NTTARGETFILE0
NTTARGETFILE0=$(NTTARGETFILE0:*=i386)
!endif
!ifdef NTTARGETFILE1
NTTARGETFILE1=$(NTTARGETFILE1:*=i386)
!endif

!IF "$(DLLENTRY)" != "-noentry"
!   IF "$(DLLENTRY:@12=)" == "$(DLLENTRY)"
DLLENTRY=$(DLLENTRY)@12
!   ENDIF
!ENDIF

!IFDEF STD_CALL_ENTRY
UMENTRY=$(UMENTRY)@4
!ENDIF

ENTRY_SUFFIX=@4
GDI_ENTRY_SUFFIX=@12

ADDITIONAL_ATL_LIBS = $(ADDITIONAL_ATL_LIBS)

!IFDEF 386_WARNING_LEVEL
MSC_WARNING_LEVEL=$(386_WARNING_LEVEL)
!ENDIF

!ifdef 386_PERFFLAGS
PERFFLAGS = $(386_PERFFLAGS)
!endif

# Set MSC_OPTIMIZATION.
# Order of precedence:
#   Platform specific override
#   Environment variable
#   System Default

!if defined(386_OPTIMIZATION)
MSC_OPTIMIZATION=$(386_OPTIMIZATION)
!elseif !defined(MSC_OPTIMIZATION)
MSC_OPTIMIZATION=$(DEFAULT_MSC_OPT)
!endif

!ifdef NOCODFLAGS
MSC_OPTIMIZATION=$(MSC_OPTIMIZATION:/FAcs=)
USER_C_FLAGS=$(USER_C_FLAGS:/FAcs=)
!endif

DBGFLAGS=$(DBGFLAGS) $(MSC_OPTIMIZATION)

!IFDEF 386_CPPFLAGS
MSC_CPPFLAGS=$(386_CPPFLAGS)
!ENDIF

!ifdef USE_VS70_RULES

!else # USE_VS70_RULES

!ifdef NO_STRING_POOLING
STRING_POOLING =
!else
!ifdef NO_READONLY_STRINGS
STRING_POOLING = /Gf
!else
STRING_POOLING = /GF
!endif
!endif

! ifdef USE_RTTI
RTTI_FLAGS=/GR
! else
RTTI_FLAGS=/GR-
! endif

!endif

!ifdef USE_NATIVE_EH
EH_FLAGS=/GX
!else
EH_FLAGS=/GX-
!endif

!ifdef USE_INCREMENTAL_COMPILING
! ifndef RESOURCE_ONLY_DLL
C_INCREMENTAL_FLAG = /Gi /Gm
USE_PDB_TO_COMPILE = 1
!endif
!else
C_INCREMENTAL_FLAG = /Gi- /Gm-
!endif

!ifndef X86_CPU_OPTIMIZATION
X86_CPU_OPTIMIZATION=/GB
!endif

# Undocumented switch definitions
# /QIfdiv- : Don't emit code to test for bad pentiums
# /QIf     : Emit FPO records for every function
# /QI0f    : Workaround Pentium bug

# ERATTA_FLAGS=/QIfdiv- /QIf
ERATTA_FLAGS=/QIfdiv- /QIf /QI0f

!ifdef NEWCOMPILER
# /d2compflag : Emit VC5 compatible S_COMPILE symbolic records.
ERATTA_FLAGS=$(ERATTA_FLAGS) /d2compflag

!if [set __GUIDLIB_CL_FLAGS=/d2compflag]
!endif
!endif

STDFLAGS= /c /Zel /Zp8 /Gy $(CBSTRING) $(MSC_WARNING_LEVEL) $(MSC_CALL_TYPE) \
          $(ERATTA_FLAGS) $(X86_CPU_OPTIMIZATION) $(C_INCREMENTAL_FLAG) $(EH_FLAGS) \
          $(RTTI_FLAGS) $(STRING_POOLING)

!IF "$(386_STDCALL)" == "0"
MSC_CALL_TYPE=/Gd
MSC_CALL_DEFINE=
!ELSE
!   IF "$(386_STDCALL)" == "2"
MSC_CALL_TYPE=/Gr
MSC_CALL_DEFINE=
!   ELSE
MSC_CALL_TYPE=/Gz
MSC_CALL_DEFINE=-DSTD_CALL
!   ENDIF
!ENDIF

!IF $(FREEBUILD)
ASM_DBG_DEFINES=-DDBG=0
!   IFDEF NTNOFPO
!MESSAGE $(NTMAKEENV)\i386mk.inc(1) : Overriding FPO default with NTNOFPO
TARGET_DBG_DEFINES= $(TARGET_DBG_DEFINES) -DFPO=0
DBGFLAGS=$(DBGFLAGS) /Oy-
!   ELSE
TARGET_DBG_DEFINES= $(TARGET_DBG_DEFINES) -DFPO=1
DBGFLAGS=$(DBGFLAGS) /Oy
!   ENDIF
!ELSE
TARGET_DBG_DEFINES= $(TARGET_DBG_DEFINES) -DFPO=0
DBGFLAGS=$(DBGFLAGS) /Oy-
386_ADBGFLAGS=$(386_ADBGFLAGS) /Zi
!ENDIF

!IFDEF NTBBT
DBGFLAGS=$(DBGFLAGS) /Zi
386_ADBGFLAGS=$(386_ADBGFLAGS) /Zi
LINKER_FLAGS=$(LINKER_FLAGS) -debug:full -debugtype:cv,fixup
USE_PDB=1
!ENDIF

!ifndef USE_PDB_TO_COMPILE
DBGFLAGS=$(DBGFLAGS:/Zi=-Z7)
DBGFLAGS=$(DBGFLAGS:-Zi=-Z7)
!else
! ifdef USE_VS70_RULES
!  if "$(TARGETTYPE)" == "LIBRARY"
DBGFLAGS=$(DBGFLAGS) /Fd$(TARGETPATH)\$(TARGETNAME).pdb
!  IF [ if not exist $(TARGETPATH) mkdir $(TARGETPATH) ]
!  ENDIF
!  else if "$(COMPILE_PDB_NAME)" != ""
DBGFLAGS=$(DBGFLAGS) /Fd$(MAKEDIR)\$(_OBJ_DIR)\i386\$(COMPILE_PDB_NAME).pdb
!  else if "$(TARGETNAME)" != ""
DBGFLAGS=$(DBGFLAGS) /Fd$(MAKEDIR)\$(_OBJ_DIR)\i386\$(TARGETNAME)_COMP.pdb
!  else
DBGFLAGS=$(DBGFLAGS) /Fd$(MAKEDIR)\$(_OBJ_DIR)\i386^\
!  endif
! else ifndef USE_MSHTML_PDB_RULES
!  if "$(TARGETTYPE)" == "LIBRARY"
DBGFLAGS=$(DBGFLAGS) /Fd$(TARGETPATH)\$(TARGET_DIRECTORY)\$(TARGETNAME).pdb
!  else
DBGFLAGS=$(DBGFLAGS) /Fd$(MAKEDIR)\$(_OBJ_DIR)\i386^\
!  endif
! else
!  ifndef TARGETPDB
TARGETPDB=$(TARGETNAME)
!  endif
!  ifndef ROOT
ROOT=$(MAKEDIR)
!  endif
DBGFLAGS=$(DBGFLAGS) /Fd$(ROOT)\$(_OBJ_DIR)\i386\$(TARGETPDB).pdb
! endif
!endif

!ifndef NO_BROWSER_INFO
! ifdef BROWSER_INFO
DBGFLAGS=$(DBGFLAGS) /FR$(MAKEDIR)\$(_OBJ_DIR)\i386^\
! endif
!endif

#
# 386 option control
#

ENV_DEFINES= $(MSC_CPPFLAGS) $(NTCPPFLAGS)

!IF "$(HALTYPE)" == ""
HALDEF=
!ELSE
HALDEF=-D$(HALTYPE)=1
!ENDIF

STD_DEFINES= -D_X86_=1 -Di386=1 $(HALDEF) $(MSC_CALL_DEFINE) $(STD_DEFINES)

CDEFINES=$(STD_DEFINES) $(TARGET_DBG_DEFINES) $(ENV_DEFINES) \
              $(LIBC_DEFINES) $(C_DEFINES) $(NET_C_DEFINES) $(MFC_DEFINES) $(USER_C_DEFINES)
CFLAGS=$(386_FLAGS) $(NT386FLAGS) $(STDFLAGS) $(DBGFLAGS) $(PERFFLAGS) $(USER_C_FLAGS)
386_ASMFLAGS=$(386_ADBGFLAGS) $(STD_DEFINES) $(ASM_DBG_DEFINES)\
              $(TARGET_DBG_DEFINES) $(ENV_DEFINES) $(ASM_DEFINES)

386_CDEFINES=$(CDEFINES)
386_CFLAGS=$(CFLAGS)

!if "$(SUBSTITUTE_386_CC)" != ""
CC_NAME = $(SUBSTITUTE_386_CC) -nologo
!else
CC_NAME = $(VC_PATH)cl -nologo
!endif

C_COMPILER_NAME     = $(CC_NAME)
CXX_COMPILER_NAME   = $(CC_NAME)
C_PREPROCESSOR_NAME = $(CC_NAME)
!ifndef 386_ASSEMBLER_NAME
386_ASSEMBLER_NAME  = ml
!endif

GLOBAL_C_FLAGS = -Ii386\ -I. $(INCPATH1) $(CDEFINES) $(CFLAGS)

NP_COMPILER_FLAGS = $(GLOBAL_C_FLAGS) $(COMPILER_WARNINGS)

C_COMPILER_FLAGS = $(NP_COMPILER_FLAGS) $(CC_FLAGS) $(PRECOMPILED)
CXX_COMPILER_FLAGS = $(NP_COMPILER_FLAGS) $(CXX_FLAGS) $(PRECOMPILED_CXX)
C_PREPROCESSOR_FLAGS = $(GLOBAL_C_FLAGS) -EP -Tc

C_PREPROCESSOR = $(C_PREPROCESSOR_NAME) $(C_PREPROCESSOR_FLAGS)
C_COMPILER     = $(C_COMPILER_NAME) $(C_COMPILER_FLAGS)
NP_C_COMPILER  = $(C_COMPILER_NAME) $(NP_COMPILER_FLAGS)
CXX_COMPILER   = $(CXX_COMPILER_NAME) $(CXX_COMPILER_FLAGS)

!if defined(NOMASMCOMPATIBILITY)
386_ASSEMBLER=$(386_ASSEMBLER_NAME) -c -coff -Cx -nologo -Ii386\ -I. $(INCPATH1) $(386_ASMFLAGS)
!else
386_ASSEMBLER=$(386_ASSEMBLER_NAME) -c -coff -Cx -nologo -Ii386\ -I. $(INCPATH1) -Zm $(386_ASMFLAGS)
!endif

ECHO_MSG=$(C_COMPILER) $<
ECHO_MSG_P=$(NP_C_COMPILER) $**
ECHO_CXX_MSG=$(CXX_COMPILER) $<

ECHO_PRECOMPILED_MSG1=$(C_COMPILER_NAME) $(PRECOMPILED_FLAG) $(PRECOMPILED_SOURCEFILE) \
               $(C_COMPILER_FLAGS) /Yl$(TARGETNAME) /Yc$(?F) $(HEADERFILE) $(HEADEROBJ)

ECHO_PRECOMPILED_MSG2=$(C_COMPILER_NAME) $(PRECOMPILED_FLAG) \
               $(C_COMPILER_FLAGS) /Yl$(TARGETNAME) /Yc$(?F) $(HEADERFILE) $(HEADEROBJ)


{}.c{}.asm:
    $(C_COMPILER_NAME) @<< /Fa $(MAKEDIR)\$(<F)
$(C_COMPILER_FLAGS: =
)
$(C_COMPILER_FLAGS:##= )
<<NOKEEP

{..\i386\}.asm{}.lst:
    $(386_ASSEMBLER) /Fl$@ /Fo$(_OBJ_DIR)\i386\$(@B).obj $<

{i386\}.asm{}.lst:
    $(386_ASSEMBLER) /Fl$@ /Fo$(MAKEDIR)\$(_OBJ_DIR)\i386\$(@B).obj $<

{..\i386\}.asm{$(_OBJ_DIR)\i386\}.obj:
    $(386_ASSEMBLER) -Fo$(MAKEDIR)\$@ $<

{$(_OBJ_DIR)\i386\}.asm{$(_OBJ_DIR)\i386\}.obj:
    $(386_ASSEMBLER) -Fo$(MAKEDIR)\$@ $<

{i386\}.asm{$(_OBJ_DIR)\i386\}.obj:
    $(386_ASSEMBLER) -Fo$(MAKEDIR)\$@ $<

!IFDEF _NT386LIBS
_NTLIBS=$(_NT386LIBS)
!ENDIF

COPYDST=$(386COPYDST)
LIB_COPY=nti386cp.cmd

!IFDEF SILVER
NTTEST_LINK_OPTIONS=-fixed -base:0x80100000 -entry:main
!ELSE
NTTEST_LINK_OPTIONS=-fixed -base:0x80010000 -entry:main
!ENDIF

!if 0
!if defined(LINKER_WIN98OPT) || defined (CHICAGO_PRODUCT)
LINKER_FLAGS=$(LINKER_FLAGS) /opt:win98
!else
LINKER_FLAGS=$(LINKER_FLAGS) /opt:nowin98
!endif
!endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\public\oak\inc\dx95type.h ===
/******************************Module*Header*******************************\
*
* Module Name: dx95type.h
*
* Portability module for NT kernel-mode DirectX components created from
* Win95 sources
*
* Copyright (c) 1996-1997 Microsoft Corp.
*
\**************************************************************************/

#ifndef __DX95TYPE_H__
#define __DX95TYPE_H__

// Basic includes
#ifndef NODXINCLUDES
#ifdef WINNT
#include <stddef.h>
// Includes ddrawint.h and d3dnthal.h
#include <winddi.h>
#else // WINNT
#include <ddrawi.h>
#include <d3dhal.h>
#endif // WINNT
#endif // NODXINCLUDES

// Simple memory allocation of N bytes
#ifndef NODXMALLOC
#ifdef WINNT
#define DXMALLOC(n) EngAllocMem(0, n, 'amxD')
#define DXMALLOCZ(n) EngAllocMem(FL_ZERO_MEMORY, n, 'amxD')
#define DXFREE(p) EngFreeMem(p)
#else // WINNT
#define DXMALLOC(n) HeapAlloc(GetProcessHeap(), 0, n)
#define DXMALLOCZ(n) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, n)
#define DXFREE(n) HeapFree(GetProcessHeap(), 0, n)
#endif // WINNT
#endif // NODXMALLOC

// Surface and palette access macros
#ifndef NODXLCL
#ifdef WINNT
#define DDS_LCL(pdds) (pdds)
#define DDP_LCL(pddp) (pddp)
#else // WINNT
#define DDS_LCL(pdds) (((DDRAWI_DDRAWSURFACE_INT *)(pdds))->lpLcl)
#define DDP_LCL(pddp) (((DDRAWI_DDRAWPALETTE_INT *)(pddp))->lpLcl)
#endif // WINNT
#define DDS_LCL_OR_NULL(pdds) ((pdds) == NULL ? NULL : DDS_LCL(pdds))
#define DDP_LCL_OR_NULL(pddp) ((pddp) == NULL ? NULL : DDP_LCL(pddp))
#endif // NODXLCL

// Typedefs and defines to create a Win95-like compilation environment

#ifndef NODX95TYPES
#ifdef WINNT

typedef D3DNTHALDEVICEDESC_V1           D3DDEVICEDESC_V1;
typedef PDD_SURFACE_LOCAL               LPDDRAWI_DDRAWSURFACE_LCL;
typedef PDD_SURFACE_MORE                LPDDRAWI_DDRAWSURFACE_MORE;
typedef PDD_SURFACE_GLOBAL              LPDDRAWI_DDRAWSURFACE_GBL;
typedef PDD_DIRECTDRAW_GLOBAL           LPDDRAWI_DIRECTDRAW_GBL;
typedef PDD_ATTACHLIST                  LPATTACHLIST;

typedef DDNTCORECAPS                    DDCORECAPS;
typedef PDDNTCORECAPS                   LPDDCORECAPS;
typedef DD_HALINFO                      DDHALINFO;
typedef PDD_HALINFO                     LPDDHALINFO;
typedef DD_MORECAPS                     DDMORECAPS;
typedef PDD_MORECAPS                    LPDDMORECAPS;

// DirectDraw HAL function data structures

typedef PDD_CREATEPALETTEDATA           LPDDHAL_CREATEPALETTEDATA;
typedef PDD_CREATESURFACEDATA           LPDDHAL_CREATESURFACEDATA;
typedef PDD_CREATESURFACEEXDATA         LPDDHAL_CREATESURFACEEXDATA;
typedef PDD_CANCREATESURFACEDATA        LPDDHAL_CANCREATESURFACEDATA;
typedef PDD_WAITFORVERTICALBLANKDATA    LPDDHAL_WAITFORVERTICALBLANKDATA;
typedef PDD_DESTROYDRIVERDATA           LPDDHAL_DESTROYDRIVERDATA;
typedef PDD_SETMODEDATA                 LPDDHAL_SETMODEDATA;
typedef PDD_DRVSETCOLORKEYDATA          LPDDHAL_DRVSETCOLORKEYDATA;
typedef PDD_GETSCANLINEDATA             LPDDHAL_GETSCANLINEDATA;
typedef PDD_MAPMEMORYDATA               LPDDHAL_MAPMEMORYDATA;
typedef PDD_SETEXCLUSIVEMODEDATA        LPDDHAL_SETEXCLUSIVEMODEDATA;
typedef PDD_FLIPTOGDISURFACEDATA        LPDDHAL_FLIPTOGDISURFACEDATA;
typedef PDD_UPDATENONLOCALHEAPDATA      LPDDHAL_UPDATENONLOCALHEAPDATA;
typedef PDD_GETHEAPALIGNMENTDATA        LPDDHAL_GETHEAPALIGNMENTDATA;
typedef DD_CREATEPALETTEDATA            DDHAL_CREATEPALETTEDATA;
typedef DD_CREATESURFACEDATA            DDHAL_CREATESURFACEDATA;
typedef DD_CREATESURFACEEXDATA          DDHAL_CREATESURFACEEXDATA;
typedef DD_CANCREATESURFACEDATA         DDHAL_CANCREATESURFACEDATA;
typedef DD_WAITFORVERTICALBLANKDATA     DDHAL_WAITFORVERTICALBLANKDATA;
typedef DD_DRVSETCOLORKEYDATA           DDHAL_DRVSETCOLORKEYDATA;
typedef DD_GETSCANLINEDATA              DDHAL_GETSCANLINEDATA;
typedef DD_MAPMEMORYDATA                DDHAL_MAPMEMORYDATA;
typedef DD_SETEXCLUSIVEMODEDATA         DDHAL_SETEXCLUSIVEMODEDATA;
typedef DD_FLIPTOGDISURFACEDATA         DDHAL_FLIPTOGDISURFACEDATA;
typedef DD_UPDATENONLOCALHEAPDATA       DDHAL_UPDATENONLOCALHEAPDATA;

typedef PDD_DESTROYPALETTEDATA          LPDDHAL_DESTROYPALETTEDATA;
typedef PDD_SETENTRIESDATA              LPDDHAL_SETENTRIESDATA;
typedef DD_DESTROYPALETTEDATA           DDHAL_DESTROYPALETTEDATA;
typedef DD_SETENTRIESDATA               DDHAL_SETENTRIESDATA;

typedef PDD_BLTDATA                     LPDDHAL_BLTDATA;
typedef PDD_LOCKDATA                    LPDDHAL_LOCKDATA;
typedef PDD_UNLOCKDATA                  LPDDHAL_UNLOCKDATA;
typedef PDD_UPDATEOVERLAYDATA           LPDDHAL_UPDATEOVERLAYDATA;
typedef PDD_SETOVERLAYPOSITIONDATA      LPDDHAL_SETOVERLAYPOSITIONDATA;
typedef PDD_SETPALETTEDATA              LPDDHAL_SETPALETTEDATA;
typedef PDD_FLIPDATA                    LPDDHAL_FLIPDATA;
typedef PDD_DESTROYSURFACEDATA          LPDDHAL_DESTROYSURFACEDATA;
typedef PDD_SETCLIPLISTDATA             LPDDHAL_SETCLIPLISTDATA;
typedef PDD_ADDATTACHEDSURFACEDATA      LPDDHAL_ADDATTACHEDSURFACEDATA;
typedef PDD_SETCOLORKEYDATA             LPDDHAL_SETCOLORKEYDATA;
typedef PDD_GETBLTSTATUSDATA            LPDDHAL_GETBLTSTATUSDATA;
typedef PDD_GETFLIPSTATUSDATA           LPDDHAL_GETFLIPSTATUSDATA;
typedef PDD_GETAVAILDRIVERMEMORYDATA    LPDDHAL_GETAVAILDRIVERMEMORYDATA;
typedef PDD_GETDRIVERINFODATA           LPDDHAL_GETDRIVERINFODATA;
typedef PDD_GETDRIVERSTATEDATA          LPDDHAL_GETDRIVERSTATEDATA;
typedef PDD_DESTROYDDLOCALDATA          LPDDHAL_DESTROYDDLOCALDATA;
typedef DD_BLTDATA                      DDHAL_BLTDATA;
typedef DD_LOCKDATA                     DDHAL_LOCKDATA;
typedef DD_UNLOCKDATA                   DDHAL_UNLOCKDATA;
typedef DD_UPDATEOVERLAYDATA            DDHAL_UPDATEOVERLAYDATA;
typedef DD_SETOVERLAYPOSITIONDATA       DDHAL_SETOVERLAYPOSITIONDATA;
typedef DD_SETPALETTEDATA               DDHAL_SETPALETTEDATA;
typedef DD_FLIPDATA                     DDHAL_FLIPDATA;
typedef DD_DESTROYSURFACEDATA           DDHAL_DESTROYSURFACEDATA;
typedef DD_SETCLIPLISTDATA              DDHAL_SETCLIPLISTDATA;
typedef DD_ADDATTACHEDSURFACEDATA       DDHAL_ADDATTACHEDSURFACEDATA;
typedef DD_SETCOLORKEYDATA              DDHAL_SETCOLORKEYDATA;
typedef DD_GETBLTSTATUSDATA             DDHAL_GETBLTSTATUSDATA;
typedef DD_GETFLIPSTATUSDATA            DDHAL_GETFLIPSTATUSDATA;
typedef DD_GETAVAILDRIVERMEMORYDATA     DDHAL_GETAVAILDRIVERMEMORYDATA;
typedef DD_GETDRIVERINFODATA            DDHAL_GETDRIVERINFODATA;
typedef DD_GETDRIVERSTATEDATA           DDHAL_GETDRIVERSTATEDATA;
typedef DD_DESTROYDDLOCALDATA           DDHAL_DESTROYDDLOCALDATA;

typedef PDD_CANCREATEVPORTDATA          LPDDHAL_CANCREATEVPORTDATA;
typedef PDD_CREATEVPORTDATA             LPDDHAL_CREATEVPORTDATA;
typedef PDD_FLIPVPORTDATA               LPDDHAL_FLIPVPORTDATA;
typedef PDD_GETVPORTCONNECTDATA         LPDDHAL_GETVPORTCONNECTDATA;
typedef PDD_GETVPORTBANDWIDTHDATA       LPDDHAL_GETVPORTBANDWIDTHDATA;
typedef PDD_GETVPORTINPUTFORMATDATA     LPDDHAL_GETVPORTINPUTFORMATDATA;
typedef PDD_GETVPORTOUTPUTFORMATDATA    LPDDHAL_GETVPORTOUTPUTFORMATDATA;
typedef PDD_GETVPORTFIELDDATA           LPDDHAL_GETVPORTFIELDDATA;
typedef PDD_GETVPORTLINEDATA            LPDDHAL_GETVPORTLINEDATA;
typedef PDD_DESTROYVPORTDATA            LPDDHAL_DESTROYVPORTDATA;
typedef PDD_GETVPORTFLIPSTATUSDATA      LPDDHAL_GETVPORTFLIPSTATUSDATA;
typedef PDD_UPDATEVPORTDATA             LPDDHAL_UPDATEVPORTDATA;
typedef PDD_WAITFORVPORTSYNCDATA        LPDDHAL_WAITFORVPORTSYNCDATA;
typedef PDD_GETVPORTSIGNALDATA          LPDDHAL_GETVPORTSIGNALDATA;
typedef PDD_VPORTCOLORDATA              LPDDHAL_VPORTCOLORDATA;
typedef DD_CANCREATEVPORTDATA           DDHAL_CANCREATEVPORTDATA;
typedef DD_CREATEVPORTDATA              DDHAL_CREATEVPORTDATA;
typedef DD_FLIPVPORTDATA                DDHAL_FLIPVPORTDATA;
typedef DD_GETVPORTCONNECTDATA          DDHAL_GETVPORTCONNECTDATA;
typedef DD_GETVPORTBANDWIDTHDATA        DDHAL_GETVPORTBANDWIDTHDATA;
typedef DD_GETVPORTINPUTFORMATDATA      DDHAL_GETVPORTINPUTFORMATDATA;
typedef DD_GETVPORTOUTPUTFORMATDATA     DDHAL_GETVPORTOUTPUTFORMATDATA;
typedef DD_GETVPORTFIELDDATA            DDHAL_GETVPORTFIELDDATA;
typedef DD_GETVPORTLINEDATA             DDHAL_GETVPORTLINEDATA;
typedef DD_DESTROYVPORTDATA             DDHAL_DESTROYVPORTDATA;
typedef DD_GETVPORTFLIPSTATUSDATA       DDHAL_GETVPORTFLIPSTATUSDATA;
typedef DD_UPDATEVPORTDATA              DDHAL_UPDATEVPORTDATA;
typedef DD_WAITFORVPORTSYNCDATA         DDHAL_WAITFORVPORTSYNCDATA;
typedef DD_GETVPORTSIGNALDATA           DDHAL_GETVPORTSIGNALDATA;
typedef DD_VPORTCOLORDATA               DDHAL_VPORTCOLORDATA;

typedef PDD_COLORCONTROLDATA            LPDDHAL_COLORCONTROLDATA;
typedef DD_COLORCONTROLDATA             DDHAL_COLORCONTROLDATA;

typedef PDD_SYNCSURFACEDATA             LPDDHAL_SYNCSURFACEDATA;
typedef PDD_SYNCVIDEOPORTDATA           LPDDHAL_SYNCVIDEOPORTDATA;
typedef DD_SYNCSURFACEDATA              DDHAL_SYNCSURFACEDATA;
typedef DD_SYNCVIDEOPORTDATA            DDHAL_SYNCVIDEOPORTDATA;

typedef PDD_GETMOCOMPGUIDSDATA          LPDDHAL_GETMOCOMPGUIDSDATA;
typedef PDD_GETMOCOMPFORMATSDATA        LPDDHAL_GETMOCOMPFORMATSDATA;
typedef PDD_CREATEMOCOMPDATA            LPDDHAL_CREATEMOCOMPDATA;
typedef PDD_GETMOCOMPCOMPBUFFDATA       LPDDHAL_GETMOCOMPCOMPBUFFDATA;
typedef PDD_GETINTERNALMOCOMPDATA       LPDDHAL_GETINTERNALMOCOMPDATA;
typedef PDD_BEGINMOCOMPFRAMEDATA        LPDDHAL_BEGINMOCOMPFRAMEDATA;
typedef PDD_ENDMOCOMPFRAMEDATA          LPDDHAL_ENDMOCOMPFRAMEDATA;
typedef PDD_RENDERMOCOMPDATA            LPDDHAL_RENDERMOCOMPDATA;
typedef PDD_QUERYMOCOMPSTATUSDATA       LPDDHAL_QUERYMOCOMPSTATUSDATA;
typedef PDD_DESTROYMOCOMPDATA           LPDDHAL_DESTROYMOCOMPDATA;
typedef DD_GETMOCOMPGUIDSDATA           DDHAL_GETMOCOMPGUIDSDATA;
typedef DD_GETMOCOMPFORMATSDATA         DDHAL_GETMOCOMPFORMATSDATA;
typedef DD_CREATEMOCOMPDATA             DDHAL_CREATEMOCOMPDATA;
typedef DD_GETMOCOMPCOMPBUFFDATA        DDHAL_GETMOCOMPCOMPBUFFDATA;
typedef DD_GETINTERNALMOCOMPDATA        DDHAL_GETINTERNALMOCOMPDATA;
typedef DD_BEGINMOCOMPFRAMEDATA         DDHAL_BEGINMOCOMPFRAMEDATA;
typedef DD_ENDMOCOMPFRAMEDATA           DDHAL_ENDMOCOMPFRAMEDATA;
typedef DD_RENDERMOCOMPDATA             DDHAL_RENDERMOCOMPDATA;
typedef DD_QUERYMOCOMPSTATUSDATA        DDHAL_QUERYMOCOMPSTATUSDATA;
typedef DD_DESTROYMOCOMPDATA            DDHAL_DESTROYMOCOMPDATA;

// DirectDraw HAL call backs

typedef PDD_SETCOLORKEY                 LPDDHAL_SETCOLORKEY;
typedef PDD_CANCREATESURFACE            LPDDHAL_CANCREATESURFACE;
typedef PDD_WAITFORVERTICALBLANK        LPDDHAL_WAITFORVERTICALBLANK;
typedef PDD_CREATESURFACE               LPDDHAL_CREATESURFACE;
typedef PDD_DESTROYDRIVER               LPDDHAL_DESTROYDRIVER;
typedef PDD_SETMODE                     LPDDHAL_SETMODE;
typedef PDD_CREATEPALETTE               LPDDHAL_CREATEPALETTE;
typedef PDD_GETSCANLINE                 LPDDHAL_GETSCANLINE;
typedef PDD_MAPMEMORY                   LPDDHAL_MAPMEMORY;
typedef PDD_GETAVAILDRIVERMEMORY        LPDDHAL_GETAVAILDRIVERMEMORY;
typedef PDD_GETDRIVERINFODATA           LPDDHAL_GETDRIVERINFODATA;
typedef PDD_SYNCSURFACEDATA             LPDDHAL_SYNCSURFACEDATA;
typedef PDD_SYNCVIDEOPORTDATA           LPDDHAL_SYNCVIDEOPORTDATA;
typedef PDD_SETEXCLUSIVEMODE            LPDDHAL_SETEXCLUSIVEMODE;
typedef PDD_FLIPTOGDISURFACE            LPDDHAL_FLIPTOGDISURFACE;

typedef PDD_ALPHABLT                    LPDDHAL_ALPHABLT;
typedef PDD_CREATESURFACEEX             LPDDHAL_CREATESURFACEEX;
typedef PDD_GETDRIVERSTATE              LPDDHAL_GETDRIVERSTATE;

typedef PDD_PALCB_DESTROYPALETTE        LPDDHALPALCB_DESTROYPALETTE;
typedef PDD_PALCB_SETENTRIES            LPDDHALPALCB_SETENTRIES;

typedef PDD_SURFCB_LOCK                 LPDDHALSURFCB_LOCK;
typedef PDD_SURFCB_UNLOCK               LPDDHALSURFCB_UNLOCK;
typedef PDD_SURFCB_BLT                  LPDDHALSURFCB_BLT;
typedef PDD_SURFCB_UPDATEOVERLAY        LPDDHALSURFCB_UPDATEOVERLAY;
typedef PDD_SURFCB_SETOVERLAYPOSITION   LPDDHALSURFCB_SETOVERLAYPOSITION;
typedef PDD_SURFCB_SETPALETTE           LPDDHALSURFCB_SETPALETTE;
typedef PDD_SURFCB_FLIP                 LPDDHALSURFCB_FLIP;
typedef PDD_SURFCB_DESTROYSURFACE       LPDDHALSURFCB_DESTROYSURFACE;
typedef PDD_SURFCB_SETCLIPLIST          LPDDHALSURFCB_SETCLIPLIST;
typedef PDD_SURFCB_ADDATTACHEDSURFACE   LPDDHALSURFCB_ADDATTACHEDSURFACE;
typedef PDD_SURFCB_SETCOLORKEY          LPDDHALSURFCB_SETCOLORKEY;
typedef PDD_SURFCB_GETBLTSTATUS         LPDDHALSURFCB_GETBLTSTATUS;
typedef PDD_SURFCB_GETFLIPSTATUS        LPDDHALSURFCB_GETFLIPSTATUS;

typedef PDD_VPORTCB_CANCREATEVIDEOPORT  LPDDHALVPORTCB_CANCREATEVIDEOPORT;
typedef PDD_VPORTCB_CREATEVIDEOPORT     LPDDHALVPORTCB_CREATEVIDEOPORT;
typedef PDD_VPORTCB_FLIP                LPDDHALVPORTCB_FLIP;
typedef PDD_VPORTCB_GETBANDWIDTH        LPDDHALVPORTCB_GETBANDWIDTH;
typedef PDD_VPORTCB_GETINPUTFORMATS     LPDDHALVPORTCB_GETINPUTFORMATS;
typedef PDD_VPORTCB_GETOUTPUTFORMATS    LPDDHALVPORTCB_GETOUTPUTFORMATS;
typedef PDD_VPORTCB_GETFIELD            LPDDHALVPORTCB_GETFIELD;
typedef PDD_VPORTCB_GETLINE             LPDDHALVPORTCB_GETLINE;
typedef PDD_VPORTCB_GETVPORTCONNECT     LPDDHALVPORTCB_GETVPORTCONNECT;
typedef PDD_VPORTCB_DESTROYVPORT        LPDDHALVPORTCB_DESTROYVPORT;
typedef PDD_VPORTCB_GETFLIPSTATUS       LPDDHALVPORTCB_GETFLIPSTATUS;
typedef PDD_VPORTCB_UPDATE              LPDDHALVPORTCB_UPDATE;
typedef PDD_VPORTCB_WAITFORSYNC         LPDDHALVPORTCB_WAITFORSYNC;
typedef PDD_VPORTCB_GETSIGNALSTATUS     LPDDHALVPORTCB_GETSIGNALSTATUS;
typedef PDD_VPORTCB_COLORCONTROL        LPDDHALVPORTCB_COLORCONTROL;

typedef PDD_MOCOMPCB_GETGUIDS           LPDDHALMOCOMPCB_GETGUIDS;
typedef PDD_MOCOMPCB_GETFORMATS         LPDDHALMOCOMPCB_GETFORMATS;
typedef PDD_MOCOMPCB_CREATE             LPDDHALMOCOMPCB_CREATE;
typedef PDD_MOCOMPCB_GETCOMPBUFFINFO    LPDDHALMOCOMPCB_GETCOMPBUFFINFO;
typedef PDD_MOCOMPCB_GETINTERNALINFO    LPDDHALMOCOMPCB_GETINTERNALINFO;
typedef PDD_MOCOMPCB_BEGINFRAME         LPDDHALMOCOMPCB_BEGINFRAME;
typedef PDD_MOCOMPCB_ENDFRAME           LPDDHALMOCOMPCB_ENDFRAME;
typedef PDD_MOCOMPCB_RENDER             LPDDHALMOCOMPCB_RENDER;
typedef PDD_MOCOMPCB_QUERYSTATUS        LPDDHALMOCOMPCB_QUERYSTATUS;
typedef PDD_MOCOMPCB_DESTROY            LPDDHALMOCOMPCB_DESTROY;

typedef DD_CALLBACKS                    DDHAL_DDCALLBACKS;
typedef DD_PALETTECALLBACKS             DDHAL_DDPALETTECALLBACKS;
typedef DD_SURFACECALLBACKS             DDHAL_DDSURFACECALLBACKS;
typedef DD_VIDEOPORTCALLBACKS           DDHAL_DDVIDEOPORTCALLBACKS;
typedef DD_COLORCONTROLCALLBACKS        DDHAL_DDCOLORCONTROLCALLBACKS;
typedef DD_KERNELCALLBACKS              DDHAL_DDKERNELCALLBACKS;
typedef DD_MOTIONCOMPCALLBACKS          DDHAL_DDMOTIONCOMPCALLBACKS;
typedef DD_MISCELLANEOUS2CALLBACKS      DDHAL_DDMISCELLANEOUS2CALLBACKS;
typedef DD_D3DBUFCALLBACKS              DDHAL_D3DBUFCALLBACKS;
typedef DD_NTCALLBACKS                  DDHAL_DDNTCALLBACKS;

typedef PDD_CALLBACKS                   LPDDHAL_DDCALLBACKS;
typedef PDD_PALETTECALLBACKS            LPDDHAL_DDPALETTECALLBACKS;
typedef PDD_SURFACECALLBACKS            LPDDHAL_DDSURFACECALLBACKS;
typedef PDD_VIDEOPORTCALLBACKS          LPDDHAL_DDVIDEOPORTCALLBACKS;
typedef PDD_COLORCONTROLCALLBACKS       LPDDHAL_DDCOLORCONTROLCALLBACKS;
typedef PDD_KERNELCALLBACKS             LPDDHAL_DDKERNELCALLBACKS;
typedef PDD_MOTIONCOMPCALLBACKS         LPDDHAL_DDMOTIONCOMPCALLBACKS;
typedef PDD_MISCELLANEOUS2CALLBACKS     LPDDHAL_DDMISCELLANEOUS2CALLBACKS;
typedef PDD_D3DBUFCALLBACKS             LPDDHAL_D3DBUFCALLBACKS;
typedef PDD_NTCALLBACKS                 LPDDHAL_DDNTCALLBACKS;

// bit definition for dwFlags in dwPaletteFlags in D3DHAL_DP2SETPALETTE
#define DDRAWIPAL_256       0x00000001l // 256 entry palette
#define DDRAWIPAL_16        0x00000002l // 16 entry palette
#define DDRAWIPAL_GDI       0x00000004l // palette allocated through GDI
#define DDRAWIPAL_STORED_8  0x00000008l // palette stored as 8bpp/entry
#define DDRAWIPAL_STORED_16 0x00000010l // palette stored as 16bpp/entry
#define DDRAWIPAL_STORED_24 0x00000020l // palette stored as 24bpp/entry
#define DDRAWIPAL_EXCLUSIVE 0x00000040l // palette being used in exclusive mode
#define DDRAWIPAL_INHEL     0x00000080l // palette is done in the hel
#define DDRAWIPAL_DIRTY         0x00000100l     // gdi palette out 'o sync
#define DDRAWIPAL_ALLOW256  0x00000200l // can fully update palette
#define DDRAWIPAL_4             0x00000400l     // 4 entry palette
#define DDRAWIPAL_2             0x00000800l     // 2 entry palette
#define DDRAWIPAL_STORED_8INDEX 0x00001000l     // palette stored as 8-bit index into dst palette
#define DDRAWIPAL_ALPHA     0x00002000l // palette entries contain alpha

typedef D3DNTHAL_CALLBACKS              D3DHAL_CALLBACKS;
typedef D3DNTHAL_GLOBALDRIVERDATA       D3DHAL_GLOBALDRIVERDATA;
typedef D3DNTHAL_CONTEXTCREATEDATA      D3DHAL_CONTEXTCREATEDATA;
typedef D3DNTHAL_CONTEXTDESTROYDATA     D3DHAL_CONTEXTDESTROYDATA;
typedef D3DNTHAL_CONTEXTDESTROYALLDATA  D3DHAL_CONTEXTDESTROYALLDATA;
typedef D3DNTHAL_SCENECAPTUREDATA       D3DHAL_SCENECAPTUREDATA;
typedef D3DNTHAL_TEXTURECREATEDATA      D3DHAL_TEXTURECREATEDATA;
typedef D3DNTHAL_TEXTUREDESTROYDATA     D3DHAL_TEXTUREDESTROYDATA;
typedef D3DNTHAL_TEXTURESWAPDATA        D3DHAL_TEXTURESWAPDATA;
typedef D3DNTHAL_TEXTUREGETSURFDATA     D3DHAL_TEXTUREGETSURFDATA;

typedef D3DNTHAL_CALLBACKS2             D3DHAL_CALLBACKS2;
typedef D3DNTHAL_SETRENDERTARGETDATA    D3DHAL_SETRENDERTARGETDATA;

typedef D3DNTHAL_CALLBACKS3             D3DHAL_CALLBACKS3;
typedef D3DNTHAL_CLEAR2DATA             D3DHAL_CLEAR2DATA;
typedef D3DNTHAL_VALIDATETEXTURESTAGESTATEDATA   D3DHAL_VALIDATETEXTURESTAGESTATEDATA;
typedef D3DNTHAL_DRAWPRIMITIVES2DATA    D3DHAL_DRAWPRIMITIVES2DATA;
typedef D3DNTHAL_D3DEXTENDEDCAPS        D3DHAL_D3DEXTENDEDCAPS;

typedef LPD3DNTHAL_CALLBACKS            LPD3DHAL_CALLBACKS;
typedef LPD3DNTHAL_GLOBALDRIVERDATA     LPD3DHAL_GLOBALDRIVERDATA;
typedef LPD3DNTHAL_CONTEXTCREATEDATA    LPD3DHAL_CONTEXTCREATEDATA;
typedef LPD3DNTHAL_CONTEXTDESTROYDATA   LPD3DHAL_CONTEXTDESTROYDATA;
typedef LPD3DNTHAL_CONTEXTDESTROYALLDATA LPD3DHAL_CONTEXTDESTROYALLDATA;
typedef LPD3DNTHAL_SCENECAPTUREDATA     LPD3DHAL_SCENECAPTUREDATA;
typedef LPD3DNTHAL_TEXTURECREATEDATA    LPD3DHAL_TEXTURECREATEDATA;
typedef LPD3DNTHAL_TEXTUREDESTROYDATA   LPD3DHAL_TEXTUREDESTROYDATA;
typedef LPD3DNTHAL_TEXTURESWAPDATA      LPD3DHAL_TEXTURESWAPDATA;
typedef LPD3DNTHAL_TEXTUREGETSURFDATA   LPD3DHAL_TEXTUREGETSURFDATA;

typedef LPD3DNTHAL_CALLBACKS2           LPD3DHAL_CALLBACKS2;
typedef LPD3DNTHAL_SETRENDERTARGETDATA  LPD3DHAL_SETRENDERTARGETDATA;

typedef LPD3DNTHAL_CALLBACKS3           LPD3DHAL_CALLBACKS3;
typedef LPD3DNTHAL_CLEAR2DATA           LPD3DHAL_CLEAR2DATA;
typedef LPD3DNTHAL_VALIDATETEXTURESTAGESTATEDATA LPD3DHAL_VALIDATETEXTURESTAGESTATEDATA;
typedef LPD3DNTHAL_DRAWPRIMITIVES2DATA  LPD3DHAL_DRAWPRIMITIVES2DATA;
typedef LPD3DNTHAL_D3DEXTENDEDCAPS      LPD3DHAL_D3DEXTENDEDCAPS;

#define D3DHAL2_CB32_SETRENDERTARGET          D3DNTHAL2_CB32_SETRENDERTARGET

#define D3DHAL_CONTEXT_BAD              D3DNTHAL_CONTEXT_BAD
#define D3DHAL_OUTOFCONTEXTS            D3DNTHAL_OUTOFCONTEXTS
#define D3DHALSTATE_GET_RENDER          D3DNTHALSTATE_GET_RENDER
#define D3DHAL_SCENE_CAPTURE_START      D3DNTHAL_SCENE_CAPTURE_START
#define D3DHAL_SCENE_CAPTURE_END        D3DNTHAL_SCENE_CAPTURE_END

#define D3DHAL3_CB32_CLEAR2                   D3DNTHAL3_CB32_CLEAR2
#define D3DHAL3_CB32_RESERVED                 D3DNTHAL3_CB32_RESERVED
#define D3DHAL3_CB32_VALIDATETEXTURESTAGESTATE  D3DNTHAL3_CB32_VALIDATETEXTURESTAGESTATE
#define D3DHAL3_CB32_DRAWPRIMITIVES2          D3DNTHAL3_CB32_DRAWPRIMITIVES2

//-----------------------------------------------------------------------------
// DrawPrimitives2 DDI
//-----------------------------------------------------------------------------
typedef D3DNTHAL_DP2COMMAND D3DHAL_DP2COMMAND;
typedef LPDNT3DHAL_DP2COMMAND LPD3DHAL_DP2COMMAND;
typedef D3DNTHAL_DP2OPERATION D3DHAL_DP2OPERATION;
typedef D3DNTHAL_DP2POINTS D3DHAL_DP2POINTS;
typedef D3DNTHAL_DP2LINELIST D3DHAL_DP2LINELIST;
typedef D3DNTHAL_DP2INDEXEDLINELIST D3DHAL_DP2INDEXEDLINELIST;
typedef D3DNTHAL_DP2LINESTRIP D3DHAL_DP2LINESTRIP;
typedef D3DNTHAL_DP2INDEXEDLINESTRIP D3DHAL_DP2INDEXEDLINESTRIP;
typedef D3DNTHAL_DP2TRIANGLELIST D3DHAL_DP2TRIANGLELIST;
typedef D3DNTHAL_DP2INDEXEDTRIANGLELIST D3DHAL_DP2INDEXEDTRIANGLELIST;
typedef D3DNTHAL_DP2INDEXEDTRIANGLELIST2 D3DHAL_DP2INDEXEDTRIANGLELIST2;
typedef D3DNTHAL_DP2TRIANGLESTRIP D3DHAL_DP2TRIANGLESTRIP;
typedef D3DNTHAL_DP2INDEXEDTRIANGLESTRIP D3DHAL_DP2INDEXEDTRIANGLESTRIP;
typedef D3DNTHAL_DP2TRIANGLEFAN D3DHAL_DP2TRIANGLEFAN;
typedef D3DNTHAL_DP2INDEXEDTRIANGLEFAN D3DHAL_DP2INDEXEDTRIANGLEFAN;
typedef D3DNTHAL_DP2RENDERSTATE D3DHAL_DP2RENDERSTATE;
typedef D3DNTHAL_DP2TEXTURESTAGESTATE D3DHAL_DP2TEXTURESTAGESTATE;
typedef D3DNTHAL_DP2TRIANGLEFAN_IMM D3DHAL_DP2TRIANGLEFAN_IMM;
typedef D3DNTHAL_DP2STARTVERTEX D3DHAL_DP2STARTVERTEX;
typedef D3DNTHAL_DP2VIEWPORTINFO D3DHAL_DP2VIEWPORTINFO;
typedef D3DNTHAL_DP2WINFO D3DHAL_DP2WINFO;
typedef D3DNTHAL_DP2SETPALETTE      D3DHAL_DP2SETPALETTE;
typedef D3DNTHAL_DP2UPDATEPALETTE   D3DHAL_DP2UPDATEPALETTE;
typedef D3DNTHAL_DP2ZRANGE          D3DHAL_DP2ZRANGE;
typedef D3DNTHAL_DP2SETMATERIAL     D3DHAL_DP2SETMATERIAL;
typedef D3DNTHAL_DP2SETLIGHT        D3DHAL_DP2SETLIGHT;
typedef D3DNTHAL_DP2SETCLIPPLANE    D3DHAL_DP2SETCLIPPLANE;
typedef D3DNTHAL_DP2CREATELIGHT     D3DHAL_DP2CREATELIGHT;
typedef D3DNTHAL_DP2SETTRANSFORM    D3DHAL_DP2SETTRANSFORM;
typedef D3DNTHAL_DP2EXT             D3DHAL_DP2EXT;
typedef D3DNTHAL_DP2TEXBLT          D3DHAL_DP2TEXBLT;
typedef D3DNTHAL_DP2STATESET        D3DHAL_DP2STATESET;
typedef D3DNTHAL_DP2SETPRIORITY     D3DHAL_DP2SETPRIORITY;
typedef D3DNTHAL_DP2SETRENDERTARGET D3DHAL_DP2SETRENDERTARGET;
typedef D3DNTHAL_DP2CLEAR           D3DHAL_DP2CLEAR;
typedef D3DNTHAL_DP2SETTEXLOD       D3DHAL_DP2SETTEXLOD;

#define D3DDP2OP_POINTS               D3DNTDP2OP_POINTS
#define D3DDP2OP_INDEXEDLINELIST      D3DNTDP2OP_INDEXEDLINELIST
#define D3DDP2OP_INDEXEDLINELIST2     D3DNTDP2OP_INDEXEDLINELIST2
#define D3DDP2OP_INDEXEDTRIANGLELIST  D3DNTDP2OP_INDEXEDTRIANGLELIST
#define D3DDP2OP_INDEXEDTRIANGLELIST2 D3DNTDP2OP_INDEXEDTRIANGLELIST2
#define D3DDP2OP_RENDERSTATE          D3DNTDP2OP_RENDERSTATE
#define D3DDP2OP_LINELIST             D3DNTDP2OP_LINELIST
#define D3DDP2OP_LINESTRIP            D3DNTDP2OP_LINESTRIP
#define D3DDP2OP_INDEXEDLINESTRIP     D3DNTDP2OP_INDEXEDLINESTRIP
#define D3DDP2OP_TRIANGLELIST         D3DNTDP2OP_TRIANGLELIST
#define D3DDP2OP_TRIANGLESTRIP        D3DNTDP2OP_TRIANGLESTRIP
#define D3DDP2OP_INDEXEDTRIANGLESTRIP D3DNTDP2OP_INDEXEDTRIANGLESTRIP
#define D3DDP2OP_TRIANGLEFAN          D3DNTDP2OP_TRIANGLEFAN
#define D3DDP2OP_INDEXEDTRIANGLEFAN   D3DNTDP2OP_INDEXEDTRIANGLEFAN
#define D3DDP2OP_TRIANGLEFAN_IMM      D3DNTDP2OP_TRIANGLEFAN_IMM
#define D3DDP2OP_LINELIST_IMM         D3DNTDP2OP_LINELIST_IMM
#define D3DDP2OP_TEXTURESTAGESTATE    D3DNTDP2OP_TEXTURESTAGESTATE
#define D3DDP2OP_VIEWPORTINFO         D3DNTDP2OP_VIEWPORTINFO
#define D3DDP2OP_WINFO                D3DNTDP2OP_WINFO
#define D3DDP2OP_SETPALETTE           D3DNTDP2OP_SETPALETTE
#define D3DDP2OP_UPDATEPALETTE        D3DNTDP2OP_UPDATEPALETTE

#define D3DDP2OP_ZRANGE               D3DNTDP2OP_ZRANGE
#define D3DDP2OP_SETMATERIAL          D3DNTDP2OP_SETMATERIAL
#define D3DDP2OP_SETLIGHT             D3DNTDP2OP_SETLIGHT
#define D3DDP2OP_CREATELIGHT          D3DNTDP2OP_CREATELIGHT
#define D3DDP2OP_SETTRANSFORM         D3DNTDP2OP_SETTRANSFORM
#define D3DDP2OP_EXT                  D3DNTDP2OP_EXT                  
#define D3DDP2OP_TEXBLT               D3DNTDP2OP_TEXBLT
#define D3DDP2OP_STATESET             D3DNTDP2OP_STATESET
#define D3DDP2OP_SETPRIORITY          D3DNTDP2OP_SETPRIORITY
#define D3DDP2OP_SETRENDERTARGET      D3DNTDP2OP_SETRENDERTARGET
#define D3DDP2OP_CLEAR                D3DNTDP2OP_CLEAR
#define D3DDP2OP_SETTEXLOD            D3DNTDP2OP_SETTEXLOD
#define D3DDP2OP_SETCLIPPLANE         D3DNTDP2OP_SETCLIPPLANE

#define D3DERR_COMMAND_UNPARSED       D3DNTERR_COMMAND_UNPARSED
#define D3DHALDP2_USERMEMVERTICES     D3DNTHALDP2_USERMEMVERTICES
#define D3DHALDP2_EXECUTEBUFFER       D3DNTHALDP2_EXECUTEBUFFER
#define D3DHALDP2_SWAPVERTEXBUFFER    D3DNTHALDP2_SWAPVERTEXBUFFER
#define D3DHALDP2_SWAPCOMMANDBUFFER   D3DNTHALDP2_SWAPCOMMANDBUFFER
#define D3DHALDP2_REQVERTEXBUFSIZE    D3DNTHALDP2_REQVERTEXBUFSIZE
#define D3DHALDP2_REQCOMMANDBUFSIZE   D3DNTHALDP2_REQCOMMANDBUFSIZE
#define D3DHALDP2_VIDMEMVERTEXBUF     D3DNTHALDP2_VIDMEMVERTEXBUF
#define D3DHALDP2_VIDMEMCOMMANDBUF    D3DNTHALDP2_VIDMEMCOMMANDBUF


#define PFND3DPARSEUNKNOWNCOMMAND     PFND3DNTPARSEUNKNOWNCOMMAND
#endif // WINNT
#endif // NODX95TYPES

#endif // __DX95TYPE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\public\oak\inc\ddkmapi.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	ddkmapi.h
 *  Content:	Kernel mode APIs for accessing DirectDraw support.
 *
 ***************************************************************************/

#ifndef __DDKMAPI_INCLUDED__
#define __DDKMAPI_INCLUDED__


/*
 * API entry point
 */
DWORD
FAR PASCAL
DxApi(
    DWORD  dwFunctionNum,
    LPVOID lpvInBuffer,
    DWORD  cbInBuffer,
    LPVOID lpvOutBuffer,
    DWORD  cbOutBuffer
);

typedef
DWORD
(FAR PASCAL *LPDXAPI)(
    DWORD   dwFunctionNum,
    LPVOID  lpvInBuffer,
    DWORD   cbInBuffer,
    LPVOID  lpvOutBuffer,
    DWORD   cbOutBuffer
);

#define DXAPI_MAJORVERSION		1
#define DXAPI_MINORVERSION              0

#define DD_FIRST_DXAPI					0x500

typedef ULONG (FAR PASCAL *LPDD_NOTIFYCALLBACK)(DWORD dwFlags, PVOID pContext, DWORD dwParam1, DWORD dwParam2);

/*
 * Queries the DXAPI version number.
 *
 * Input:  Null
 * Output: LPDDGETVERSIONNUMBER
 */
#define DD_DXAPI_GETVERSIONNUMBER                       (DD_FIRST_DXAPI)

    typedef struct _DDGETVERSIONNUMBER
    {
        DWORD   ddRVal;
        DWORD   dwMajorVersion;
        DWORD   dwMinorVersion;
    } DDGETVERSIONNUMBER, FAR *LPDDGETVERSIONNUMBER;

/*
 * Closes the kernel mode handle.
 *
 * Input:  LPDDCLOSEHANDLE
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_CLOSEHANDLE                            (DD_FIRST_DXAPI+1)

    typedef struct _DDCLOSEHANDLE
    {
        HANDLE  hHandle;
    } DDCLOSEHANDLE, FAR *LPDDCLOSEHANDLE;

/*
 * Opens the DirectDraw object and returns a kernel mode handle.
 *
 * Input:  LPDDOPENDIRECTDRAWIN
 * Output: LPDDOPENDIRECTDRAWOUT
 */
#define DD_DXAPI_OPENDIRECTDRAW                         (DD_FIRST_DXAPI+2)

    typedef struct _DDOPENDIRECTDRAWIN
    {
        ULONG_PTR            dwDirectDrawHandle;
        LPDD_NOTIFYCALLBACK pfnDirectDrawClose;
        PVOID               pContext;
    } DDOPENDIRECTDRAWIN, FAR *LPDDOPENDIRECTDRAWIN;

    typedef struct _DDOPENDIRECTDRAWOUT
    {
        DWORD   ddRVal;
        HANDLE  hDirectDraw;
    } DDOPENDIRECTDRAWOUT, FAR *LPDDOPENDIRECTDRAWOUT;

/*
 * Opens the surface and returns a kernel mode handle.
 *
 * Input:  LPDDOPENSURFACEIN
 * Output: LPDDOPENSURFACEOUT
 */
#define DD_DXAPI_OPENSURFACE                            (DD_FIRST_DXAPI+3)

    typedef struct _DDOPENSURFACEIN
    {
	HANDLE	            hDirectDraw;
        ULONG_PTR            dwSurfaceHandle;
        LPDD_NOTIFYCALLBACK pfnSurfaceClose;
        PVOID               pContext;
    } DDOPENSURFACEIN, FAR *LPDDOPENSURFACEIN;

    typedef struct _DDOPENSURFACEOUT
    {
        DWORD   ddRVal;
        HANDLE  hSurface;
    } DDOPENSURFACEOUT, FAR *LPDDOPENSURFACEOUT;

/*
 * Opens the VideoPort and returns a kernel mode handle.
 *
 * Input:  LPDDOPENVIDEOPORTIN
 * Output: LPDDOPENVIDEOPORTOUT
 */
#define DD_DXAPI_OPENVIDEOPORT                          (DD_FIRST_DXAPI+4)

    typedef struct _DDOPENVIDEOPORTIN
    {
	HANDLE		    hDirectDraw;
        ULONG               dwVideoPortHandle;
        LPDD_NOTIFYCALLBACK pfnVideoPortClose;
        PVOID               pContext;
    } DDOPENVIDEOPORTIN, FAR *LPDDOPENVIDEOPORTIN;

    typedef struct _DDOPENVIDEOPORTOUT
    {
        DWORD   ddRVal;
        HANDLE  hVideoPort;
    } DDOPENVIDEOPORTOUT, FAR *LPDDOPENVIDEOPORTOUT;

/*
 * Returns the kernel mode capabilities supported by the device
 *
 * Input:  HANDLE hDirectDraw
 * Output: LPDDGETKERNELCAPSOUT
 */
#define DD_DXAPI_GETKERNELCAPS                          (DD_FIRST_DXAPI+5)

    typedef struct _DDGETKERNELCAPSOUT
    {
	DWORD	ddRVal;
        DWORD	dwCaps;
	DWORD	dwIRQCaps;
    } DDGETKERNELCAPSOUT, FAR *LPDDGETKERNELCAPSOUT;

/*
 * Gets the current field number
 *
 * Input:  LPDDGETFIELDNUMIN
 * Output: LPDDGETFIELDNUMOUT
 */
#define DD_DXAPI_GET_VP_FIELD_NUMBER			(DD_FIRST_DXAPI+6)

    typedef struct _DDGETFIELDNUMIN
    {
	HANDLE	hDirectDraw;
	HANDLE	hVideoPort;
    } DDGETFIELDNUMIN, FAR *LPDDGETFIELDNUMIN;

    typedef struct _DDGETFIELDNUMOUT
    {
	DWORD	ddRVal;
	DWORD	dwFieldNum;
    } DDGETFIELDNUMOUT, FAR *LPDDGETFIELDNUMOUT;

/*
 * Sets the current field number
 *
 * Input:  LPDDSETFIELDNUM
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_SET_VP_FIELD_NUMBER			(DD_FIRST_DXAPI+7)

    typedef struct _DDSETFIELDNUM
    {
	HANDLE	hDirectDraw;
	HANDLE	hVideoPort;
	DWORD	dwFieldNum;
    } DDSETFIELDNUM, FAR *LPDDSETFIELDNUM;

/*
 * Indicates which fields should be skipped to undo the 3:2 pulldown.
 *
 * Input:  LPDDSETSKIPFIELD
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_SET_VP_SKIP_FIELD			(DD_FIRST_DXAPI+8)

    typedef struct _DDSETSKIPFIELD
    {
	HANDLE	hDirectDraw;
	HANDLE	hVideoPort;
	DWORD	dwStartField;
    } DDSETSKIPFIELD, FAR *LPDDSETSKIPFIELD;

/*
 * Notifies whether the surface is in bob or weave mode.
 *
 * Input:  LPDDGETSURFACESTATEIN
 * Output: LPDDGETSURFACESTATEOUT
 */
#define DD_DXAPI_GET_SURFACE_STATE			(DD_FIRST_DXAPI+9)

    typedef struct _DDGETSURFACESTATEIN
    {
	HANDLE	hDirectDraw;
	HANDLE	hSurface;
    } DDGETSURFACESTATEIN, FAR *LPDDGETSURFACESTATEIN;

    typedef struct _DDGETSURFACESTATEOUT
    {
	DWORD	ddRVal;
	DWORD	dwStateCaps;
	DWORD	dwStateStatus;
    } DDGETSURFACESTATEOUT, FAR *LPDDGETSURFACESTATEOUT;

/*
 * Changes the surface between bob and weave mode.
 *
 * Input:  LPDDSETSURFACESTATE
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_SET_SURFACE_STATE			(DD_FIRST_DXAPI+10)

    typedef struct _DDSETSURFACETATE
    {
	HANDLE	hDirectDraw;
	HANDLE	hSurface;
	DWORD	dwState;
	DWORD	dwStartField;
    } DDSETSURFACESTATE, FAR *LPDDSETSURFACESTATE;

/*
 * Allows direct access to the surface memory
 *
 * Input:  LPDDLOCKIN
 * Output: LPDDLOCKOUT
 */
#define DD_DXAPI_LOCK					(DD_FIRST_DXAPI+11)

    typedef struct _DDLOCKIN
    {
	HANDLE	hDirectDraw;
	HANDLE	hSurface;
    } DDLOCKIN, FAR *LPDDLOCKIN;

    typedef struct _DDLOCKOUT
    {
	DWORD	ddRVal;
	DWORD	dwSurfHeight;
	DWORD	dwSurfWidth;
	LONG	lSurfPitch;
	PVOID	lpSurface;
	DWORD	SurfaceCaps;
	DWORD	dwFormatFlags;
	DWORD	dwFormatFourCC;
	DWORD	dwFormatBitCount;
	union
	{
	    DWORD	dwRBitMask;
	    DWORD	dwYBitMask;
    	};
    	union
    	{
	    DWORD	dwGBitMask;
	    DWORD	dwUBitMask;
	};
	union
	{
	    DWORD	dwBBitMask;
	    DWORD	dwVBitMask;
	};
    } DDLOCKOUT, FAR *LPDDLOCKOUT;

/*
 * Flips the overlay surface
 *
 * Input:  LPDDFLIPOVERLAY
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_FLIP_OVERLAY				(DD_FIRST_DXAPI+12)

    typedef struct _DDFLIPOVERLAY
    {
	HANDLE	hDirectDraw;
	HANDLE	hCurrentSurface;
	HANDLE	hTargetSurface;
	DWORD	dwFlags;
    } DDFLIPOVERLAY, FAR *LPDDFLIPOVERLAY;

/*
 * Flips the video port
 *
 * Input:  LPDDFLIPOVERLAY
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_FLIP_VP				(DD_FIRST_DXAPI+13)

    typedef struct _DDFLIPVIDEOPORT
    {
	HANDLE	hDirectDraw;
	HANDLE	hVideoPort;
	HANDLE	hCurrentSurface;
	HANDLE	hTargetSurface;
	DWORD	dwFlags;
    } DDFLIPVIDEOPORT, FAR *LPDDFLIPVIDEOPORT;

/*
 * Returns the current surface receiving the data while autoflipping
 *
 * Input:  LPDDGETAUTOFLIPIN
 * Output: LPDDGETAUTOFLIPOUT
 */
#define DD_DXAPI_GET_CURRENT_VP_AUTOFLIP_SURFACE	(DD_FIRST_DXAPI+14)

    typedef struct _DDGETAUTOFLIPIN
    {
	HANDLE	hDirectDraw;
	HANDLE	hVideoPort;
    } DDGETAUTOFLIPIN, FAR *LPDDGETAUTOFLIPIN;

    typedef struct _DDGETAUTOFLIPOUT
    {
	DWORD	ddRVal;
	HANDLE	hVideoSurface;
	HANDLE	hVBISurface;
	BOOL	bPolarity;
    } DDGETAUTOFLIPOUT, FAR *LPDDGETAUTOFLIPOUT;

/*
 * Returns the surface that received the previous field of data (could
 * be the same as current if video is interleaved)
 *
 * Input:  LPDDGETAUTOFLIPIN
 * Output: LPDDGETAUTOFLIPOUT
 */
#define DD_DXAPI_GET_LAST_VP_AUTOFLIP_SURFACE		(DD_FIRST_DXAPI+15)

/*
 * Registers a callback for when various events occur.
 *
 * Input:  LPDDREGISTERCALLBACK
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_REGISTER_CALLBACK			(DD_FIRST_DXAPI+16)

    typedef struct _DDREGISTERCALLBACK
    {
	HANDLE 	            hDirectDraw;
	ULONG	            dwEvents;
	LPDD_NOTIFYCALLBACK pfnCallback;
	ULONG_PTR            dwParam1;
	ULONG_PTR            dwParam2;
	PVOID	            pContext;
    } DDREGISTERCALLBACK, FAR *LPDDREGISTERCALLBACK;

/*
 * Unregisters a callback for when various events occur.
 *
 * Input:  LPDDREGISTERCALLBACK
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_UNREGISTER_CALLBACK			(DD_FIRST_DXAPI+17)

/*
 * Returns the polarity (odd/even) of the current field
 *
 * Input:  LPDDGETPOLARITYIN
 * Output: LPDDGETPOLARITYOUT
 */
#define DD_DXAPI_GET_POLARITY				(DD_FIRST_DXAPI+18)

    typedef struct _DDGETPOLARITYIN
    {
	HANDLE 	hDirectDraw;
	HANDLE	hVideoPort;
    } DDGETPOLARITYIN, FAR *LPDDGETPOLARITYIN;

    typedef struct _DDGETPOLARITYOUT
    {
	DWORD 	ddRVal;
	BOOL	bPolarity;
    } DDGETPOLARITYOUT, FAR *LPDDGETPOLARITYOUT;

/*
 * Opens the device for capture
 *
 * Input:  LPDDOPENCAPTUREDEVICEIN
 * Output: LPDDOPENCAPTUREDEVICEOUT
 */
#define DD_DXAPI_OPENVPCAPTUREDEVICE			(DD_FIRST_DXAPI+19)

    typedef struct _DDOPENVPCAPTUREDEVICEIN
    {
	HANDLE  hDirectDraw;
	HANDLE  hVideoPort;
	DWORD   dwStartLine;
	DWORD   dwEndLine;
	DWORD   dwCaptureEveryNFields;
	LPDD_NOTIFYCALLBACK pfnCaptureClose;
	PVOID   pContext;
	DWORD	dwFlags;
    } DDOPENVPCAPTUREDEVICEIN, FAR * LPDDOPENVPCAPTUREDEVICEIN;

    typedef struct _DDOPENVPCAPTUREDEVICEOUT
    {
	DWORD	ddRVal;
	HANDLE	hCapture;
    } DDOPENVPCAPTUREDEVICEOUT, FAR * LPDDOPENVPCAPTUREDEVICEOUT;

    #define DDOPENCAPTURE_VIDEO	0x0001	// Capture from the video stream
    #define DDOPENCAPTURE_VBI	0x0002	// Capture from the VBI stream

/*
 * Adds a capture buffer to the internal video port capture queue
 *
 * Input:  LPDDADDVPCAPTUREBUFF
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_ADDVPCAPTUREBUFFER			(DD_FIRST_DXAPI+20)

    typedef struct _DDCAPBUFFINFO
    {
	DWORD   	dwFieldNumber;
	DWORD   	bPolarity;
	LARGE_INTEGER	liTimeStamp;
	DWORD   	ddRVal;
    } DDCAPBUFFINFO, FAR * LPDDCAPBUFFINFO;

    typedef struct _DDADDVPCAPTUREBUFF
    {
	HANDLE  hCapture;
	DWORD   dwFlags;
	PMDL    pMDL;
	PKEVENT pKEvent;
	LPDDCAPBUFFINFO lpBuffInfo;
    } DDADDVPCAPTUREBUFF, FAR * LPDDADDVPCAPTUREBUFF;

    #define DDADDBUFF_SYSTEMMEMORY	0x0001	// lpBuffer points to sys mem
    #define DDADDBUFF_NONLOCALVIDMEM	0x0002	// lpBuffer points to AGP mem
    #define DDADDBUFF_INVERT		0x0004	// invert the buffer during capture

/*
 * Flushes the internal video port capture queue
 *
 * Input:  HANDLE to capture device
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_FLUSHVPCAPTUREBUFFERS			(DD_FIRST_DXAPI+21)


/*
 * State flags returned by DSVXD_DXAPI_DD_GET_SURFACE_STATE
 */
#define DDSTATE_BOB				0x0001
#define DDSTATE_WEAVE				0x0002
#define DDSTATE_EXPLICITLY_SET			0x0004
#define DDSTATE_SOFTWARE_AUTOFLIP		0x0008
#define DDSTATE_SKIPEVENFIELDS			0x0010

/*
 * Event flags - passed into RegisterCallback
 */
#define DDEVENT_DISPLAY_VSYNC			0x0001
#define DDEVENT_VP_VSYNC			0x0002
#define DDEVENT_VP_LINE				0x0004
#define DDEVENT_PRERESCHANGE			0x0008
#define DDEVENT_POSTRESCHANGE			0x0010
#define DDEVENT_PREDOSBOX			0x0020
#define DDEVENT_POSTDOSBOX			0x0040

/*
 * Notification flags - passed to the notification proc
 */
#define DDNOTIFY_DISPLAY_VSYNC			0x0001	// dwParam1 = hDirectDraw
#define DDNOTIFY_VP_VSYNC			0x0002	// dwParam1 = hVideoPort
#define DDNOTIFY_VP_LINE	  		0x0004	// dwParam1 = hVideoPort
#define DDNOTIFY_PRERESCHANGE			0x0008	// dwParam1 = hDirectDraw
#define DDNOTIFY_POSTRESCHANGE			0x0010	// dwParam1 = hDirectDraw
#define DDNOTIFY_PREDOSBOX			0x0020  // dwParam1 = hDirectDraw
#define DDNOTIFY_POSTDOSBOX			0x0040  // dwParam1 = hDirectDraw
#define DDNOTIFY_CLOSEDIRECTDRAW		0x0080  // dwParam1 = hDirectDraw
#define DDNOTIFY_CLOSESURFACE			0x0100  // dwParam1 = hSurface
#define DDNOTIFY_CLOSEVIDEOPORT			0x0200  // dwParam1 = hVideoPort
#define DDNOTIFY_CLOSECAPTURE			0x0400  // dwParam1 = hCapture

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\public\oak\inc\dmemmgr.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	dmemmgr.h
 *  Content:	Direct Memory Manager include file
 *
 ***************************************************************************/

#ifndef __DMEMMGR_INCLUDED__
#define __DMEMMGR_INCLUDED__

#ifdef __cplusplus
extern "C" {
#endif

#ifndef __NTDDKCOMP__

/*
 * pointer to video memory
 */
typedef ULONG_PTR FLATPTR;

typedef struct _VIDMEM *LPVIDMEM;

#else

/*
 * pointer to video memory, potentially 64-bit
 */
typedef ULONG_PTR FLATPTR;

typedef struct _VIDEOMEMORY *LPVIDMEM;

#endif

/*
 * Structure for querying extended heap alignment requirements
 */

typedef struct _SURFACEALIGNMENT
{
    union
    {
        struct
        {
            DWORD       dwStartAlignment;
            DWORD       dwPitchAlignment;
            DWORD       dwFlags;
            DWORD       dwReserved2;
        } Linear;
        struct
        {
            DWORD       dwXAlignment;
            DWORD       dwYAlignment;
            DWORD       dwFlags;
            DWORD       dwReserved2;
        } Rectangular;
    };
} SURFACEALIGNMENT;
typedef struct _SURFACEALIGNMENT FAR *LPSURFACEALIGNMENT;

#define SURFACEALIGN_DISCARDABLE	0x00000001l /* Surface can be discarded to   */
                                                    /* make room for another surface */


typedef struct _HEAPALIGNMENT
{
    DWORD                dwSize;
    DDSCAPS              ddsCaps;       /* Indicates which alignment fields are valid.*/
    DWORD                dwReserved;
    SURFACEALIGNMENT     ExecuteBuffer; /* Surfaces tagged with DDSCAPS_EXECUTEBUFFER */
    SURFACEALIGNMENT     Overlay;       /* Surfaces tagged with DDSCAPS_OVERLAY       */
    SURFACEALIGNMENT     Texture;       /* Surfaces tagged with DDSCAPS_TEXTURE       */
    SURFACEALIGNMENT     ZBuffer;       /* Surfaces tagged with DDSCAPS_ZBUFFER       */
    SURFACEALIGNMENT     AlphaBuffer;   /* Surfaces tagged with DDSCAPS_ALPHA         */
    SURFACEALIGNMENT     Offscreen;     /* Surfaces tagged with DDSCAPS_OFFSCREENPLAIN*/
    SURFACEALIGNMENT     FlipTarget;    /* Surfaces whose bits are potential primaries i.e. back buffers*/
} HEAPALIGNMENT;
typedef struct _HEAPALIGNMENT FAR *LPHEAPALIGNMENT;

typedef struct _DD_GETHEAPALIGNMENTDATA
{
    ULONG_PTR                  dwInstance;         // driver context
    DWORD                      dwHeap;             // heap index passed by DirectDraw
    HRESULT                    ddRVal;             // return value
    VOID*                      GetHeapAlignment;   // Unused: Win95 compatibility
    HEAPALIGNMENT              Alignment;          // Filled in by driver.
} DD_GETHEAPALIGNMENTDATA;
typedef struct _DD_GETHEAPALIGNMENTDATA *PDD_GETHEAPALIGNMENTDATA;

/*
 * video memory manager structures
 */
typedef struct _VMEML
{
    struct _VMEML 	FAR *next;
    FLATPTR		ptr;
    DWORD		size;
    BOOL                bDiscardable;
} VMEML, FAR *LPVMEML, FAR * FAR *LPLPVMEML;

typedef struct _VMEMR
{
    struct _VMEMR 	FAR *next;
    struct _VMEMR       FAR *prev;
    /*
     * The pUp, pDown, pLeft and pRight members were removed in DX5
     */
    struct _VMEMR 	FAR *pUp;
    struct _VMEMR 	FAR *pDown;
    struct _VMEMR 	FAR *pLeft;
    struct _VMEMR 	FAR *pRight;
    FLATPTR		ptr;
    DWORD		size;
    DWORD               x;
    DWORD               y;
    DWORD               cx;
    DWORD               cy;
    DWORD		flags;
    FLATPTR             pBits;
    BOOL                bDiscardable;
} VMEMR, FAR *LPVMEMR, FAR * FAR *LPLPVMEMR;

typedef struct _VMEMHEAP
{
    DWORD		        dwFlags;
    DWORD                       stride;
    LPVOID		        freeList;
    LPVOID		        allocList;
    DWORD                       dwTotalSize;
    FLATPTR                     fpGARTLin;      /* AGP: GART linear base of heap (app. visible)   */
    FLATPTR                     fpGARTDev;      /* AGP: GART device base of heap (driver visible) */
    DWORD                       dwCommitedSize; /* AGP: Number of bytes commited to heap          */
    /*
     * Extended alignment data:
     * Filled in by DirectDraw in response to a GetHeapAlignment HAL call.
     */
    DWORD                       dwCoalesceCount;
    HEAPALIGNMENT               Alignment;
    /*
     * These are analogous to VIDMEM.ddsCaps and VIDMEM.ddsCapsAlt. These values are queried from the
     * driver by a GetDriverInfo call. See the documentation for GUID_DDMoreSurfaceCaps
     */
    DDSCAPSEX                   ddsCapsEx;
    DDSCAPSEX                   ddsCapsExAlt;
#ifndef IS_16
    // Full physical address of heap base for NT AGP heaps.
    LARGE_INTEGER               liPhysAGPBase;
#endif
    // hdev for use with VidMemAllocAligned on NT.  Set by the system at
    // initialization time.
    HANDLE                      hdevAGP;
    // Physical reservation handle for NT heaps.
    LPVOID                      pvPhysRsrv;
} VMEMHEAP;

typedef VMEMHEAP FAR *LPVMEMHEAP;

#define VMEMHEAP_LINEAR			0x00000001l /* Heap is linear                    */
#define VMEMHEAP_RECTANGULAR		0x00000002l /* Heap is rectangular               */
#define VMEMHEAP_ALIGNMENT  		0x00000004l /* Heap has extended alignment info  */

/*
 * This legacy export doesn't handle nonlocal heaps
 * This function is not available on Windows NT
 */
#ifndef __NTDDKCOMP__
extern FLATPTR WINAPI VidMemAlloc( LPVMEMHEAP pvmh, DWORD width, DWORD height );
#endif

/*
 * This export can be used by drivers to allocate aligned surfaces from heaps which
 * they have previously exposed to DirectDraw. This function can allocate from nonlocal heaps.
 */
extern FLATPTR WINAPI HeapVidMemAllocAligned(
                LPVIDMEM lpVidMem,
                DWORD dwWidth,
                DWORD dwHeight,
                LPSURFACEALIGNMENT lpAlignment ,
                LPLONG lpNewPitch );

/*
 * This export can free memory allocated via either allocation function
 */
extern void WINAPI VidMemFree( LPVMEMHEAP pvmh, FLATPTR ptr );

#ifdef __cplusplus
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\public\oak\inc\ddrawint.h ===
/*++

Copyright (c) 1995-1997, Microsoft Corporation

Module Name:

    ddrawint.h

Abstract:

    Private entry points, defines and types for Windows NT DirectDraw
    driver interface.  Corresponds to Windows' 'ddrawi.h' file.

    The structure names for NT are different from that of Win95.  Use
    dx95type.h to aid in porting DirectX code from Win95 to NT.

--*/

#ifndef __DD_INCLUDED__
#define __DD_INCLUDED__

/*
 * These GUIDs are used to identify driver info structures, not interfaces,
 * so the prefix GUID_ is used instead of IID_.
 */

DEFINE_GUID( GUID_MiscellaneousCallbacks,       0xefd60cc0, 0x49e7, 0x11d0, 0x88, 0x9d, 0x0, 0xaa, 0x0, 0xbb, 0xb7, 0x6a);
DEFINE_GUID( GUID_Miscellaneous2Callbacks,      0x406B2F00, 0x3E5A, 0x11D1, 0xB6, 0x40, 0x00, 0xAA, 0x00, 0xA1, 0xF9, 0x6A);
DEFINE_GUID( GUID_VideoPortCallbacks,           0xefd60cc1, 0x49e7, 0x11d0, 0x88, 0x9d, 0x0, 0xaa, 0x0, 0xbb, 0xb7, 0x6a);
DEFINE_GUID( GUID_ColorControlCallbacks,        0xefd60cc2, 0x49e7, 0x11d0, 0x88, 0x9d, 0x0, 0xaa, 0x0, 0xbb, 0xb7, 0x6a);
DEFINE_GUID( GUID_MotionCompCallbacks,          0xb1122b40, 0x5dA5, 0x11d1, 0x8f, 0xcF, 0x00, 0xc0, 0x4f, 0xc2, 0x9b, 0x4e);
DEFINE_GUID( GUID_VideoPortCaps,                0xefd60cc3, 0x49e7, 0x11d0, 0x88, 0x9d, 0x0, 0xaa, 0x0, 0xbb, 0xb7, 0x6a);
DEFINE_GUID( GUID_D3DCaps,                      0x7bf06991, 0x8794, 0x11d0, 0x91, 0x39, 0x08, 0x00, 0x36, 0xd2, 0xef, 0x02);
DEFINE_GUID( GUID_D3DExtendedCaps, 		0x7de41f80, 0x9d93, 0x11d0, 0x89, 0xab, 0x00, 0xa0, 0xc9, 0x05, 0x41, 0x29);
DEFINE_GUID( GUID_D3DCallbacks,                 0x7bf06990, 0x8794, 0x11d0, 0x91, 0x39, 0x08, 0x00, 0x36, 0xd2, 0xef, 0x02);
DEFINE_GUID( GUID_D3DCallbacks2,                0xba584e1, 0x70b6, 0x11d0, 0x88, 0x9d, 0x0, 0xaa, 0x0, 0xbb, 0xb7, 0x6a);
DEFINE_GUID( GUID_D3DCallbacks3,                0xddf41230, 0xec0a, 0x11d0, 0xa9, 0xb6, 0x00, 0xaa, 0x00, 0xc0, 0x99, 0x3e);
DEFINE_GUID( GUID_NonLocalVidMemCaps,           0x86c4fa80, 0x8d84, 0x11d0, 0x94, 0xe8, 0x00, 0xc0, 0x4f, 0xc3, 0x41, 0x37);
DEFINE_GUID( GUID_KernelCallbacks,              0x80863800, 0x6B06, 0x11D0, 0x9B, 0x06, 0x0, 0xA0, 0xC9, 0x03, 0xA3, 0xB8);
DEFINE_GUID( GUID_KernelCaps,                   0xFFAA7540, 0x7AA8, 0x11D0, 0x9B, 0x06, 0x00, 0xA0, 0xC9, 0x03, 0xA3, 0xB8);
DEFINE_GUID( GUID_ZPixelFormats,                0x93869880, 0x36cf, 0x11d1, 0x9b, 0x1b, 0x0, 0xaa, 0x0, 0xbb, 0xb8, 0xae);
DEFINE_GUID( GUID_DDMoreCaps,                   0x880baf30, 0xb030, 0x11d0, 0x8e, 0xa7, 0x00, 0x60, 0x97, 0x97, 0xea, 0x5b);
DEFINE_GUID( GUID_D3DParseUnknownCommandCallback, 0x2e04ffa0, 0x98e4, 0x11d1, 0x8c, 0xe1, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0xa8);
DEFINE_GUID( GUID_NTCallbacks,                  0x6fe9ecde, 0xdf89, 0x11d1, 0x9d, 0xb0, 0x00, 0x60, 0x08, 0x27, 0x71, 0xba);
DEFINE_GUID( GUID_DDMoreSurfaceCaps,            0x3b8a0466, 0xf269, 0x11d1, 0x88, 0x0b, 0x0, 0xc0, 0x4f, 0xd9, 0x30, 0xc5);
DEFINE_GUID( GUID_GetHeapAlignment,             0x42e02f16, 0x7b41, 0x11d2, 0x8b, 0xff, 0x0, 0xa0, 0xc9, 0x83, 0xea, 0xf6);
DEFINE_GUID( GUID_UpdateNonLocalHeap,           0x42e02f17, 0x7b41, 0x11d2, 0x8b, 0xff, 0x0, 0xa0, 0xc9, 0x83, 0xea, 0xf6);
DEFINE_GUID( GUID_NTPrivateDriverCaps,          0xfad16a23, 0x7b66, 0x11d2, 0x83, 0xd7, 0x0, 0xc0, 0x4f, 0x7c, 0xe5, 0x8c);
DEFINE_GUID( GUID_DDStereoMode,                 0xf828169c, 0xa8e8, 0x11d2, 0xa1, 0xf2, 0x0, 0xa0, 0xc9, 0x83, 0xea, 0xf6);

#ifndef GUID_DEFS_ONLY

#ifndef _NO_DDRAWINT_NO_COM
#ifndef _NO_COM
#define _NO_COM
#include "ddraw.h"
#include "dvp.h"
#undef _NO_COM
#else
#include "ddraw.h"
#include "dvp.h"
#endif
#else
#include "ddraw.h"
#include "dvp.h"
#endif

#ifdef __cplusplus
extern "C" {
#endif

#define MAKE_HRESULT(sev,fac,code) \
    ((HRESULT) (((unsigned long)(sev)<<31) | ((unsigned long)(fac)<<16) | ((unsigned long)(code))) )

/*
 * offset into video meory
 */
typedef ULONG_PTR FLATPTR;

/*
 * maximum number of surfaces that can be autoflipped between
 */
#define MAX_AUTOFLIP_BUFFERS    10

/*
 * Indicates the surface is D3D buffer, i.e., a linear chunk of
 * memory that holds a Direct3D structure. A driver reports this
 * cap to indicate that it can create buffers in video memory and
 * Direct3D uses this bit to request buffers. However, it is not
 * visible to the API.
 */
#define DDSCAPS_EXECUTEBUFFER DDSCAPS_RESERVED2
#define DDSCAPS_COMMANDBUFFER DDSCAPS_RESERVED3
#define DDSCAPS_VERTEXBUFFER DDSCAPS_RESERVED4


/*
 * Internal formats are not exposed to applications.
//@@BEGIN_MSINTERNAL
 * NOTE: Must keep these in sync with enum in d3d8types.h
//@@END_MSINTERNAL
 */

#define D3DFMT_INTERNAL_D32                  71
#define D3DFMT_INTERNAL_S1D15                72
#define D3DFMT_INTERNAL_D15S1                73
#define D3DFMT_INTERNAL_S8D24                74
#define D3DFMT_INTERNAL_D24S8                75
#define D3DFMT_INTERNAL_X8D24                76
#define D3DFMT_INTERNAL_D24X8                77

/*
 * pre-declare pointers to structs containing data for DDHAL driver fns
 */
typedef struct _DD_CREATEPALETTEDATA *PDD_CREATEPALETTEDATA;
typedef struct _DD_CREATESURFACEDATA *PDD_CREATESURFACEDATA;
typedef struct _DD_CANCREATESURFACEDATA *PDD_CANCREATESURFACEDATA;
typedef struct _DD_WAITFORVERTICALBLANKDATA *PDD_WAITFORVERTICALBLANKDATA;
typedef struct _DD_DESTROYDRIVERDATA *PDD_DESTROYDRIVERDATA;
typedef struct _DD_SETMODEDATA *PDD_SETMODEDATA;
typedef struct _DD_DRVSETCOLORKEYDATA *PDD_DRVSETCOLORKEYDATA;
typedef struct _DD_GETSCANLINEDATA *PDD_GETSCANLINEDATA;
typedef struct _DD_MAPMEMORYDATA *PDD_MAPMEMORYDATA;

typedef struct _DD_DESTROYPALETTEDATA *PDD_DESTROYPALETTEDATA;
typedef struct _DD_SETENTRIESDATA *PDD_SETENTRIESDATA;

typedef struct _DD_BLTDATA *PDD_BLTDATA;
typedef struct _DD_LOCKDATA *PDD_LOCKDATA;
typedef struct _DD_UNLOCKDATA *PDD_UNLOCKDATA;
typedef struct _DD_UPDATEOVERLAYDATA *PDD_UPDATEOVERLAYDATA;
typedef struct _DD_SETOVERLAYPOSITIONDATA *PDD_SETOVERLAYPOSITIONDATA;
typedef struct _DD_SETPALETTEDATA *PDD_SETPALETTEDATA;
typedef struct _DD_FLIPDATA *PDD_FLIPDATA;
typedef struct _DD_DESTROYSURFACEDATA *PDD_DESTROYSURFACEDATA;
typedef struct _DD_SETCLIPLISTDATA *PDD_SETCLIPLISTDATA;
typedef struct _DD_ADDATTACHEDSURFACEDATA *PDD_ADDATTACHEDSURFACEDATA;
typedef struct _DD_SETCOLORKEYDATA *PDD_SETCOLORKEYDATA;
typedef struct _DD_GETBLTSTATUSDATA *PDD_GETBLTSTATUSDATA;
typedef struct _DD_GETFLIPSTATUSDATA *PDD_GETFLIPSTATUSDATA;

typedef struct _DD_CANCREATEVPORTDATA *PDD_CANCREATEVPORTDATA;
typedef struct _DD_CREATEVPORTDATA *PDD_CREATEVPORTDATA;
typedef struct _DD_FLIPVPORTDATA *PDD_FLIPVPORTDATA;
typedef struct _DD_GETVPORTCONNECTDATA *PDD_GETVPORTCONNECTDATA;
typedef struct _DD_GETVPORTBANDWIDTHDATA *PDD_GETVPORTBANDWIDTHDATA;
typedef struct _DD_GETVPORTINPUTFORMATDATA *PDD_GETVPORTINPUTFORMATDATA;
typedef struct _DD_GETVPORTOUTPUTFORMATDATA *PDD_GETVPORTOUTPUTFORMATDATA;
typedef struct _DD_GETVPORTAUTOFLIPSURFACEDATA *PDD_GETVPORTAUTOFLIPSURFACEDATA;
typedef struct _DD_GETVPORTFIELDDATA *PDD_GETVPORTFIELDDATA;
typedef struct _DD_GETVPORTLINEDATA *PDD_GETVPORTLINEDATA;
typedef struct _DD_DESTROYVPORTDATA *PDD_DESTROYVPORTDATA;
typedef struct _DD_GETVPORTFLIPSTATUSDATA *PDD_GETVPORTFLIPSTATUSDATA;
typedef struct _DD_UPDATEVPORTDATA *PDD_UPDATEVPORTDATA;
typedef struct _DD_WAITFORVPORTSYNCDATA *PDD_WAITFORVPORTSYNCDATA;
typedef struct _DD_GETVPORTSIGNALDATA *PDD_GETVPORTSIGNALDATA;
typedef struct _DD_VPORTCOLORDATA *PDD_VPORTCOLORDATA;

typedef struct _DD_COLORCONTROLDATA *PDD_COLORCONTROLDATA;

typedef struct _DD_GETAVAILDRIVERMEMORYDATA *PDD_GETAVAILDRIVERMEMORYDATA;

typedef struct _DD_FREEDRIVERMEMORYDATA *PDD_FREEDRIVERMEMORYDATA;
typedef struct _DD_SETEXCLUSIVEMODEDATA *PDD_SETEXCLUSIVEMODEDATA;
typedef struct _DD_FLIPTOGDISURFACEDATA *PDD_FLIPTOGDISURFACEDATA;

typedef struct _DD_GETDRIVERINFODATA *PDD_GETDRIVERINFODATA;

typedef struct _DD_SYNCSURFACEDATA *PDD_SYNCSURFACEDATA;
typedef struct _DD_SYNCVIDEOPORTDATA *PDD_SYNCVIDEOPORTDATA;

typedef struct _DD_GETMOCOMPGUIDSDATA *PDD_GETMOCOMPGUIDSDATA;
typedef struct _DD_GETMOCOMPFORMATSDATA *PDD_GETMOCOMPFORMATSDATA;
typedef struct _DD_CREATEMOCOMPDATA *PDD_CREATEMOCOMPDATA;
typedef struct _DD_GETMOCOMPCOMPBUFFDATA *PDD_GETMOCOMPCOMPBUFFDATA;
typedef struct _DD_GETINTERNALMOCOMPDATA *PDD_GETINTERNALMOCOMPDATA;
typedef struct _DD_BEGINMOCOMPFRAMEDATA *PDD_BEGINMOCOMPFRAMEDATA;
typedef struct _DD_ENDMOCOMPFRAMEDATA *PDD_ENDMOCOMPFRAMEDATA;
typedef struct _DD_RENDERMOCOMPDATA *PDD_RENDERMOCOMPDATA;
typedef struct _DD_QUERYMOCOMPSTATUSDATA *PDD_QUERYMOCOMPSTATUSDATA;
typedef struct _DD_DESTROYMOCOMPDATA *PDD_DESTROYMOCOMPDATA;

// Miscelleneous2 callbacks
typedef struct _DD_CREATESURFACEEXDATA *PDD_CREATESURFACEEXDATA;
typedef struct _DD_GETDRIVERSTATEDATA *PDD_GETDRIVERSTATEDATA;
typedef struct _DD_DESTROYDDLOCALDATA *PDD_DESTROYDDLOCALDATA;
typedef struct _DD_MORESURFACECAPS *PDD_MORESURFACECAPS;
typedef struct _DD_STEREOMODE *PDD_STEREOMODE;
typedef struct _DD_UPDATENONLOCALHEAPDATA *PDD_UPDATENONLOCALHEAPDATA;



/*
 * The following structure is defined in dmemmgr.h
 */
struct _DD_GETHEAPALIGNMENTDATA;
typedef struct _DD_GETHEAPALIGNMENTDATA *PDD_GETHEAPALIGNMENTDATA;

/*
 * value in the fpVidMem; indicates dwBlockSize is valid (surface object)
 */
#define DDHAL_PLEASEALLOC_BLOCKSIZE     0x00000002l
#define DDHAL_PLEASEALLOC_USERMEM       0x00000004l

/*
 * video memory data structures (passed in DD_HALINFO)
 */
typedef struct _VIDEOMEMORY
{
    DWORD               dwFlags;        // flags
    FLATPTR             fpStart;        // start of memory chunk
    union
    {
        FLATPTR         fpEnd;          // end of memory chunk
        DWORD           dwWidth;        // width of chunk (rectanglar memory)
    };
    DDSCAPS             ddsCaps;        // what this memory CANNOT be used for
    DDSCAPS             ddsCapsAlt;     // what this memory CANNOT be used for if it must
    union
    {
        struct _VMEMHEAP *lpHeap;       // heap pointer, used by DDRAW
        DWORD           dwHeight;       // height of chunk (rectanguler memory)
    };
} VIDEOMEMORY;
typedef VIDEOMEMORY *LPVIDEOMEMORY;

/*
 * flags for vidmem struct
 */
#define VIDMEM_ISLINEAR         0x00000001l     // heap is linear
#define VIDMEM_ISRECTANGULAR    0x00000002l     // heap is rectangular
#define VIDMEM_ISHEAP           0x00000004l     // heap is preallocated by driver
#define VIDMEM_ISNONLOCAL       0x00000008l     // heap populated with non-local video memory
#define VIDMEM_ISWC             0x00000010l     // heap populated with write combining memory
#define VIDMEM_HEAPDISABLED     0x00000020l     // heap disabled

typedef struct _VIDEOMEMORYINFO
{
    FLATPTR             fpPrimary;              // offset to primary surface
    DWORD               dwFlags;                // flags
    DWORD               dwDisplayWidth;         // current display width
    DWORD               dwDisplayHeight;        // current display height
    LONG                lDisplayPitch;          // current display pitch
    DDPIXELFORMAT       ddpfDisplay;            // pixel format of display
    DWORD               dwOffscreenAlign;       // byte alignment for offscreen surfaces
    DWORD               dwOverlayAlign;         // byte alignment for overlays
    DWORD               dwTextureAlign;         // byte alignment for textures
    DWORD               dwZBufferAlign;         // byte alignment for z buffers
    DWORD               dwAlphaAlign;           // byte alignment for alpha
    PVOID               pvPrimary;              // kernel-mode pointer to primary surface
} VIDEOMEMORYINFO;
typedef VIDEOMEMORYINFO *LPVIDEOMEMORYINFO;

/*
 * These structures contain the entry points in the display driver that
 * DDRAW will call.   Entries that the display driver does not care about
 * should be NULL.   Passed to DDRAW in DD_HALINFO.
 */
typedef struct _DD_DIRECTDRAW_GLOBAL *PDD_DIRECTDRAW_GLOBAL;
typedef struct _DD_SURFACE_GLOBAL *PDD_SURFACE_GLOBAL;
typedef struct _DD_PALETTE_GLOBAL *PDD_PALETTE_GLOBAL;
typedef struct _DD_CLIPPER_GLOBAL *PDD_CLIPPER_GLOBAL;
typedef struct _DD_DIRECTDRAW_LOCAL *PDD_DIRECTDRAW_LOCAL;
typedef struct _DD_SURFACE_LOCAL *PDD_SURFACE_LOCAL;
typedef struct _DD_SURFACE_MORE *PDD_SURFACE_MORE;
typedef struct _DD_SURFACE_INT *PDD_SURFACE_INT;
typedef struct _DD_VIDEOPORT_LOCAL *PDD_VIDEOPORT_LOCAL;
typedef struct _DD_PALETTE_LOCAL *PDD_PALETTE_LOCAL;
typedef struct _DD_CLIPPER_LOCAL *PDD_CLIPPER_LOCAL;
typedef struct _DD_MOTIONCOMP_LOCAL *PDD_MOTIONCOMP_LOCAL;

/*
 * DIRECTDRAW object callbacks
 */
typedef DWORD   (APIENTRY *PDD_SETCOLORKEY)(PDD_DRVSETCOLORKEYDATA );
typedef DWORD   (APIENTRY *PDD_CANCREATESURFACE)(PDD_CANCREATESURFACEDATA );
typedef DWORD   (APIENTRY *PDD_WAITFORVERTICALBLANK)(PDD_WAITFORVERTICALBLANKDATA );
typedef DWORD   (APIENTRY *PDD_CREATESURFACE)(PDD_CREATESURFACEDATA);
typedef DWORD   (APIENTRY *PDD_DESTROYDRIVER)(PDD_DESTROYDRIVERDATA);
typedef DWORD   (APIENTRY *PDD_SETMODE)(PDD_SETMODEDATA);
typedef DWORD   (APIENTRY *PDD_CREATEPALETTE)(PDD_CREATEPALETTEDATA);
typedef DWORD   (APIENTRY *PDD_GETSCANLINE)(PDD_GETSCANLINEDATA);
typedef DWORD   (APIENTRY *PDD_MAPMEMORY)(PDD_MAPMEMORYDATA);

typedef DWORD   (APIENTRY *PDD_GETDRIVERINFO)(PDD_GETDRIVERINFODATA);

typedef struct DD_CALLBACKS
{
    DWORD                       dwSize;
    DWORD                       dwFlags;
    PDD_DESTROYDRIVER           DestroyDriver;
    PDD_CREATESURFACE           CreateSurface;
    PDD_SETCOLORKEY             SetColorKey;
    PDD_SETMODE                 SetMode;
    PDD_WAITFORVERTICALBLANK    WaitForVerticalBlank;
    PDD_CANCREATESURFACE        CanCreateSurface;
    PDD_CREATEPALETTE           CreatePalette;
    PDD_GETSCANLINE             GetScanLine;
    PDD_MAPMEMORY               MapMemory;
} DD_CALLBACKS;

typedef DD_CALLBACKS *PDD_CALLBACKS;

#define DDHAL_CB32_DESTROYDRIVER        0x00000001l
#define DDHAL_CB32_CREATESURFACE        0x00000002l
#define DDHAL_CB32_SETCOLORKEY          0x00000004l
#define DDHAL_CB32_SETMODE              0x00000008l
#define DDHAL_CB32_WAITFORVERTICALBLANK 0x00000010l
#define DDHAL_CB32_CANCREATESURFACE     0x00000020l
#define DDHAL_CB32_CREATEPALETTE        0x00000040l
#define DDHAL_CB32_GETSCANLINE          0x00000080l
#define DDHAL_CB32_MAPMEMORY            0x80000000l

// This structure can be queried from the driver from NT5 onward
// using GetDriverInfo with GUID_MiscellaneousCallbacks

typedef DWORD   (APIENTRY *PDD_GETAVAILDRIVERMEMORY)(PDD_GETAVAILDRIVERMEMORYDATA);

typedef struct _DD_MISCELLANEOUSCALLBACKS {
    DWORD                               dwSize;
    DWORD                               dwFlags;
    PDD_GETAVAILDRIVERMEMORY            GetAvailDriverMemory;
} DD_MISCELLANEOUSCALLBACKS, *PDD_MISCELLANEOUSCALLBACKS;

#define DDHAL_MISCCB32_GETAVAILDRIVERMEMORY    0x00000001l

// DDHAL_DDMISCELLANEOUS2CALLBACKS:
//   This structure can be queried from the driver from DX7 onward
//   using GetDriverInfo with GUID_Miscellaneous2Callbacks

typedef DWORD   (APIENTRY *PDD_ALPHABLT)(PDD_BLTDATA);
typedef DWORD   (APIENTRY *PDD_CREATESURFACEEX)(PDD_CREATESURFACEEXDATA);
typedef DWORD   (APIENTRY *PDD_GETDRIVERSTATE)(PDD_GETDRIVERSTATEDATA);
typedef DWORD   (APIENTRY *PDD_DESTROYDDLOCAL)(PDD_DESTROYDDLOCALDATA);

typedef struct _DD_MISCELLANEOUS2CALLBACKS {
    DWORD                               dwSize;
    DWORD                               dwFlags;
    PDD_ALPHABLT                        AlphaBlt;
    PDD_CREATESURFACEEX                 CreateSurfaceEx;
    PDD_GETDRIVERSTATE                  GetDriverState;
    PDD_DESTROYDDLOCAL                  DestroyDDLocal;
} DD_MISCELLANEOUS2CALLBACKS, *PDD_MISCELLANEOUS2CALLBACKS;

#define DDHAL_MISC2CB32_ALPHABLT                 0x00000001l
#define DDHAL_MISC2CB32_CREATESURFACEEX          0x00000002l
#define DDHAL_MISC2CB32_GETDRIVERSTATE           0x00000004l
#define DDHAL_MISC2CB32_DESTROYDDLOCAL           0x00000008l

// This is used in the CreateSurfaceEx callback to indicate that the
// SwapHandle emulation is being done
#define DDHAL_CREATESURFACEEX_SWAPHANDLES      0x00000001l

// This structure can be queried from the driver from NT5 onward
// using GetDriverInfo with GUID_NTCallbacks

typedef DWORD   (APIENTRY *PDD_FREEDRIVERMEMORY)(PDD_FREEDRIVERMEMORYDATA);
typedef DWORD   (APIENTRY *PDD_SETEXCLUSIVEMODE)(PDD_SETEXCLUSIVEMODEDATA);
typedef DWORD   (APIENTRY *PDD_FLIPTOGDISURFACE)(PDD_FLIPTOGDISURFACEDATA);

typedef struct _DD_NTCALLBACKS {
    DWORD                   dwSize;
    DWORD                   dwFlags;
    PDD_FREEDRIVERMEMORY    FreeDriverMemory;
    PDD_SETEXCLUSIVEMODE    SetExclusiveMode;
    PDD_FLIPTOGDISURFACE    FlipToGDISurface;
} DD_NTCALLBACKS, *PDD_NTCALLBACKS;

#define DDHAL_NTCB32_FREEDRIVERMEMORY   0x00000001l
#define DDHAL_NTCB32_SETEXCLUSIVEMODE   0x00000002l
#define DDHAL_NTCB32_FLIPTOGDISURFACE   0x00000004l

/*
 * DIRECTDRAWPALETTE object callbacks
 */
typedef DWORD   (APIENTRY *PDD_PALCB_DESTROYPALETTE)(PDD_DESTROYPALETTEDATA );
typedef DWORD   (APIENTRY *PDD_PALCB_SETENTRIES)(PDD_SETENTRIESDATA );

typedef struct DD_PALETTECALLBACKS
{
    DWORD                       dwSize;
    DWORD                       dwFlags;
    PDD_PALCB_DESTROYPALETTE    DestroyPalette;
    PDD_PALCB_SETENTRIES        SetEntries;
} DD_PALETTECALLBACKS;

typedef DD_PALETTECALLBACKS *PDD_PALETTECALLBACKS;

#define DDHAL_PALCB32_DESTROYPALETTE    0x00000001l
#define DDHAL_PALCB32_SETENTRIES        0x00000002l

/*
 * DIRECTDRAWSURFACE object callbacks
 */
typedef DWORD   (APIENTRY *PDD_SURFCB_LOCK)(PDD_LOCKDATA);
typedef DWORD   (APIENTRY *PDD_SURFCB_UNLOCK)(PDD_UNLOCKDATA);
typedef DWORD   (APIENTRY *PDD_SURFCB_BLT)(PDD_BLTDATA);
typedef DWORD   (APIENTRY *PDD_SURFCB_UPDATEOVERLAY)(PDD_UPDATEOVERLAYDATA);
typedef DWORD   (APIENTRY *PDD_SURFCB_SETOVERLAYPOSITION)(PDD_SETOVERLAYPOSITIONDATA);
typedef DWORD   (APIENTRY *PDD_SURFCB_SETPALETTE)(PDD_SETPALETTEDATA);
typedef DWORD   (APIENTRY *PDD_SURFCB_FLIP)(PDD_FLIPDATA);
typedef DWORD   (APIENTRY *PDD_SURFCB_DESTROYSURFACE)(PDD_DESTROYSURFACEDATA);
typedef DWORD   (APIENTRY *PDD_SURFCB_SETCLIPLIST)(PDD_SETCLIPLISTDATA);
typedef DWORD   (APIENTRY *PDD_SURFCB_ADDATTACHEDSURFACE)(PDD_ADDATTACHEDSURFACEDATA);
typedef DWORD   (APIENTRY *PDD_SURFCB_SETCOLORKEY)(PDD_SETCOLORKEYDATA);
typedef DWORD   (APIENTRY *PDD_SURFCB_GETBLTSTATUS)(PDD_GETBLTSTATUSDATA);
typedef DWORD   (APIENTRY *PDD_SURFCB_GETFLIPSTATUS)(PDD_GETFLIPSTATUSDATA);


typedef struct DD_SURFACECALLBACKS
{
    DWORD                               dwSize;
    DWORD                               dwFlags;
    PDD_SURFCB_DESTROYSURFACE           DestroySurface;
    PDD_SURFCB_FLIP                     Flip;
    PDD_SURFCB_SETCLIPLIST              SetClipList;
    PDD_SURFCB_LOCK                     Lock;
    PDD_SURFCB_UNLOCK                   Unlock;
    PDD_SURFCB_BLT                      Blt;
    PDD_SURFCB_SETCOLORKEY              SetColorKey;
    PDD_SURFCB_ADDATTACHEDSURFACE       AddAttachedSurface;
    PDD_SURFCB_GETBLTSTATUS             GetBltStatus;
    PDD_SURFCB_GETFLIPSTATUS            GetFlipStatus;
    PDD_SURFCB_UPDATEOVERLAY            UpdateOverlay;
    PDD_SURFCB_SETOVERLAYPOSITION       SetOverlayPosition;
    LPVOID                              reserved4;
    PDD_SURFCB_SETPALETTE               SetPalette;
} DD_SURFACECALLBACKS;
typedef DD_SURFACECALLBACKS *PDD_SURFACECALLBACKS;

#define DDHAL_SURFCB32_DESTROYSURFACE           0x00000001l
#define DDHAL_SURFCB32_FLIP                     0x00000002l
#define DDHAL_SURFCB32_SETCLIPLIST              0x00000004l
#define DDHAL_SURFCB32_LOCK                     0x00000008l
#define DDHAL_SURFCB32_UNLOCK                   0x00000010l
#define DDHAL_SURFCB32_BLT                      0x00000020l
#define DDHAL_SURFCB32_SETCOLORKEY              0x00000040l
#define DDHAL_SURFCB32_ADDATTACHEDSURFACE       0x00000080l
#define DDHAL_SURFCB32_GETBLTSTATUS             0x00000100l
#define DDHAL_SURFCB32_GETFLIPSTATUS            0x00000200l
#define DDHAL_SURFCB32_UPDATEOVERLAY            0x00000400l
#define DDHAL_SURFCB32_SETOVERLAYPOSITION       0x00000800l
#define DDHAL_SURFCB32_RESERVED4                0x00001000l
#define DDHAL_SURFCB32_SETPALETTE               0x00002000l

/*
 * DIRECTVIDEOPORT object callbacks
 */
typedef DWORD (APIENTRY *PDD_VPORTCB_CANCREATEVIDEOPORT)(PDD_CANCREATEVPORTDATA);
typedef DWORD (APIENTRY *PDD_VPORTCB_CREATEVIDEOPORT)(PDD_CREATEVPORTDATA);
typedef DWORD (APIENTRY *PDD_VPORTCB_FLIP)(PDD_FLIPVPORTDATA);
typedef DWORD (APIENTRY *PDD_VPORTCB_GETBANDWIDTH)(PDD_GETVPORTBANDWIDTHDATA);
typedef DWORD (APIENTRY *PDD_VPORTCB_GETINPUTFORMATS)(PDD_GETVPORTINPUTFORMATDATA);
typedef DWORD (APIENTRY *PDD_VPORTCB_GETOUTPUTFORMATS)(PDD_GETVPORTOUTPUTFORMATDATA);
typedef DWORD (APIENTRY *PDD_VPORTCB_GETAUTOFLIPSURF)(PDD_GETVPORTAUTOFLIPSURFACEDATA);
typedef DWORD (APIENTRY *PDD_VPORTCB_GETFIELD)(PDD_GETVPORTFIELDDATA);
typedef DWORD (APIENTRY *PDD_VPORTCB_GETLINE)(PDD_GETVPORTLINEDATA);
typedef DWORD (APIENTRY *PDD_VPORTCB_GETVPORTCONNECT)(PDD_GETVPORTCONNECTDATA);
typedef DWORD (APIENTRY *PDD_VPORTCB_DESTROYVPORT)(PDD_DESTROYVPORTDATA);
typedef DWORD (APIENTRY *PDD_VPORTCB_GETFLIPSTATUS)(PDD_GETVPORTFLIPSTATUSDATA);
typedef DWORD (APIENTRY *PDD_VPORTCB_UPDATE)(PDD_UPDATEVPORTDATA);
typedef DWORD (APIENTRY *PDD_VPORTCB_WAITFORSYNC)(PDD_WAITFORVPORTSYNCDATA);
typedef DWORD (APIENTRY *PDD_VPORTCB_GETSIGNALSTATUS)(PDD_GETVPORTSIGNALDATA);
typedef DWORD (APIENTRY *PDD_VPORTCB_COLORCONTROL)(PDD_VPORTCOLORDATA);

typedef struct DD_VIDEOPORTCALLBACKS
{
    DWORD                               dwSize;
    DWORD                               dwFlags;
    PDD_VPORTCB_CANCREATEVIDEOPORT      CanCreateVideoPort;
    PDD_VPORTCB_CREATEVIDEOPORT         CreateVideoPort;
    PDD_VPORTCB_FLIP                    FlipVideoPort;
    PDD_VPORTCB_GETBANDWIDTH            GetVideoPortBandwidth;
    PDD_VPORTCB_GETINPUTFORMATS         GetVideoPortInputFormats;
    PDD_VPORTCB_GETOUTPUTFORMATS        GetVideoPortOutputFormats;
    LPVOID                              lpReserved1;
    PDD_VPORTCB_GETFIELD                GetVideoPortField;
    PDD_VPORTCB_GETLINE                 GetVideoPortLine;
    PDD_VPORTCB_GETVPORTCONNECT         GetVideoPortConnectInfo;
    PDD_VPORTCB_DESTROYVPORT            DestroyVideoPort;
    PDD_VPORTCB_GETFLIPSTATUS           GetVideoPortFlipStatus;
    PDD_VPORTCB_UPDATE                  UpdateVideoPort;
    PDD_VPORTCB_WAITFORSYNC             WaitForVideoPortSync;
    PDD_VPORTCB_GETSIGNALSTATUS         GetVideoSignalStatus;
    PDD_VPORTCB_COLORCONTROL            ColorControl;
} DD_VIDEOPORTCALLBACKS;

typedef DD_VIDEOPORTCALLBACKS *PDD_VIDEOPORTCALLBACKS;

#define DDHAL_VPORT32_CANCREATEVIDEOPORT        0x00000001l
#define DDHAL_VPORT32_CREATEVIDEOPORT           0x00000002l
#define DDHAL_VPORT32_FLIP                      0x00000004l
#define DDHAL_VPORT32_GETBANDWIDTH              0x00000008l
#define DDHAL_VPORT32_GETINPUTFORMATS           0x00000010l
#define DDHAL_VPORT32_GETOUTPUTFORMATS          0x00000020l
#define DDHAL_VPORT32_GETAUTOFLIPSURF           0x00000040l
#define DDHAL_VPORT32_GETFIELD                  0x00000080l
#define DDHAL_VPORT32_GETLINE                   0x00000100l
#define DDHAL_VPORT32_GETCONNECT                0x00000200l
#define DDHAL_VPORT32_DESTROY                   0x00000400l
#define DDHAL_VPORT32_GETFLIPSTATUS             0x00000800l
#define DDHAL_VPORT32_UPDATE                    0x00001000l
#define DDHAL_VPORT32_WAITFORSYNC               0x00002000l
#define DDHAL_VPORT32_GETSIGNALSTATUS           0x00004000l
#define DDHAL_VPORT32_COLORCONTROL              0x00008000l

/*
 * DIRECTDRAWCOLORCONTROL object callbacks
 */
typedef DWORD (APIENTRY *PDD_COLORCB_COLORCONTROL)(PDD_COLORCONTROLDATA);

typedef struct _DD_COLORCONTROLCALLBACKS
{
    DWORD                               dwSize;
    DWORD                               dwFlags;
    PDD_COLORCB_COLORCONTROL            ColorControl;
} DD_COLORCONTROLCALLBACKS;

typedef DD_COLORCONTROLCALLBACKS *PDD_COLORCONTROLCALLBACKS;

#define DDHAL_COLOR_COLORCONTROL                0x00000001l

/*
 * DIRECTDRAWSURFACEKERNEL object callbacks
 * This structure can be queried from the driver from DX5 onward
 * using GetDriverInfo with GUID_KernelCallbacks
 */
typedef DWORD (APIENTRY *PDD_KERNELCB_SYNCSURFACE)(PDD_SYNCSURFACEDATA);
typedef DWORD (APIENTRY *PDD_KERNELCB_SYNCVIDEOPORT)(PDD_SYNCVIDEOPORTDATA);

typedef struct DD_KERNELCALLBACKS
{
    DWORD                               dwSize;
    DWORD                               dwFlags;
    PDD_KERNELCB_SYNCSURFACE            SyncSurfaceData;
    PDD_KERNELCB_SYNCVIDEOPORT          SyncVideoPortData;
} DD_KERNELCALLBACKS, *PDD_KERNELCALLBACKS;

#define DDHAL_KERNEL_SYNCSURFACEDATA            0x00000001l
#define DDHAL_KERNEL_SYNCVIDEOPORTDATA          0x00000002l

/*
 * DIRECTDRAWVIDEO object callbacks
 */
typedef DWORD (APIENTRY *PDD_MOCOMPCB_GETGUIDS)( PDD_GETMOCOMPGUIDSDATA);
typedef DWORD (APIENTRY *PDD_MOCOMPCB_GETFORMATS)( PDD_GETMOCOMPFORMATSDATA);
typedef DWORD (APIENTRY *PDD_MOCOMPCB_CREATE)( PDD_CREATEMOCOMPDATA);
typedef DWORD (APIENTRY *PDD_MOCOMPCB_GETCOMPBUFFINFO)( PDD_GETMOCOMPCOMPBUFFDATA);
typedef DWORD (APIENTRY *PDD_MOCOMPCB_GETINTERNALINFO)( PDD_GETINTERNALMOCOMPDATA);
typedef DWORD (APIENTRY *PDD_MOCOMPCB_BEGINFRAME)( PDD_BEGINMOCOMPFRAMEDATA);
typedef DWORD (APIENTRY *PDD_MOCOMPCB_ENDFRAME)( PDD_ENDMOCOMPFRAMEDATA);
typedef DWORD (APIENTRY *PDD_MOCOMPCB_RENDER)( PDD_RENDERMOCOMPDATA);
typedef DWORD (APIENTRY *PDD_MOCOMPCB_QUERYSTATUS)( PDD_QUERYMOCOMPSTATUSDATA);
typedef DWORD (APIENTRY *PDD_MOCOMPCB_DESTROY)( PDD_DESTROYMOCOMPDATA);

typedef struct DD_MOTIONCOMPCALLBACKS
{
    DWORD                           dwSize;
    DWORD                           dwFlags;
    PDD_MOCOMPCB_GETGUIDS           GetMoCompGuids;
    PDD_MOCOMPCB_GETFORMATS         GetMoCompFormats;
    PDD_MOCOMPCB_CREATE             CreateMoComp;
    PDD_MOCOMPCB_GETCOMPBUFFINFO    GetMoCompBuffInfo;
    PDD_MOCOMPCB_GETINTERNALINFO    GetInternalMoCompInfo;
    PDD_MOCOMPCB_BEGINFRAME         BeginMoCompFrame;
    PDD_MOCOMPCB_ENDFRAME           EndMoCompFrame;
    PDD_MOCOMPCB_RENDER             RenderMoComp;
    PDD_MOCOMPCB_QUERYSTATUS        QueryMoCompStatus;
    PDD_MOCOMPCB_DESTROY            DestroyMoComp;
} DD_MOTIONCOMPCALLBACKS;
typedef DD_MOTIONCOMPCALLBACKS *PDD_MOTIONCOMPCALLBACKS;

#define DDHAL_MOCOMP32_GETGUIDS                 0x00000001
#define DDHAL_MOCOMP32_GETFORMATS               0x00000002
#define DDHAL_MOCOMP32_CREATE                   0x00000004
#define DDHAL_MOCOMP32_GETCOMPBUFFINFO          0x00000008
#define DDHAL_MOCOMP32_GETINTERNALINFO          0x00000010
#define DDHAL_MOCOMP32_BEGINFRAME               0x00000020
#define DDHAL_MOCOMP32_ENDFRAME                 0x00000040
#define DDHAL_MOCOMP32_RENDER                   0x00000080
#define DDHAL_MOCOMP32_QUERYSTATUS              0x00000100
#define DDHAL_MOCOMP32_DESTROY                  0x00000200

/*
 * CALLBACK RETURN VALUES
 *
 * these are values returned by the driver from the above callback routines
 */
/*
 * indicates that the display driver didn't do anything with the call
 */
#define DDHAL_DRIVER_NOTHANDLED         0x00000000l

/*
 * indicates that the display driver handled the call; HRESULT value is valid
 */
#define DDHAL_DRIVER_HANDLED            0x00000001l

/*
 * indicates that the display driver couldn't handle the call because it
 * ran out of color key hardware resources
 */
#define DDHAL_DRIVER_NOCKEYHW           0x00000002l

/*
 * Capabilities structure for non-local video memory
 */
typedef struct _DD_NONLOCALVIDMEMCAPS
{
    DWORD   dwSize;
    DWORD   dwNLVBCaps;           // driver specific capabilities for non-local->local vidmem blts
    DWORD   dwNLVBCaps2;          // more driver specific capabilities non-local->local vidmem blts
    DWORD   dwNLVBCKeyCaps;       // driver color key capabilities for non-local->local vidmem blts
    DWORD   dwNLVBFXCaps;         // driver FX capabilities for non-local->local blts
    DWORD   dwNLVBRops[DD_ROP_SPACE]; // ROPS supported for non-local->local blts
} DD_NONLOCALVIDMEMCAPS;
typedef struct _DD_NONLOCALVIDMEMCAPS *PDD_NONLOCALVIDMEMCAPS;

/*
 * DDRAW internal version of DIRECTDRAWPALETTE object; it has data after the vtable
 */
typedef struct _DD_PALETTE_GLOBAL
{
    ULONG_PTR                   dwReserved1;    // reserved for use by display driver
} DD_PALETTE_GLOBAL;

typedef struct _DD_PALETTE_LOCAL
{
    ULONG                       dwReserved0;    // reserved for future expansion
    ULONG_PTR                   dwReserved1;    // reserved for use by display driver
} DD_PALETTE_LOCAL;

/*
 * DDRAW internal version of DIRECTDRAWCLIPPER object; it has data after the vtable
 */
typedef struct _DD_CLIPPER_GLOBAL
{
    ULONG_PTR                   dwReserved1;    // reserved for use by display driver
} DD_CLIPPER_GLOBAL;

typedef struct _DD_CLIPPER_LOCAL
{
    ULONG_PTR                   dwReserved1;    // reserved for use by display driver
} DD_CLIPPER_LOCAL;

typedef struct _DD_ATTACHLIST *PDD_ATTACHLIST;
typedef struct _DD_ATTACHLIST
{
    PDD_ATTACHLIST              lpLink;         // link to next attached surface
    PDD_SURFACE_LOCAL           lpAttached;     // attached surface local object
} DD_ATTACHLIST;

/*
 * DDRAW surface interface struct
 */
typedef struct _DD_SURFACE_INT
{
    PDD_SURFACE_LOCAL           lpLcl;          // pointer to interface data
} DD_SURFACE_INT;

/*
 * DDRAW internal version of DIRECTDRAWSURFACE struct
 *
 * the GBL structure is global data for all duplicate objects
 */
typedef struct _DD_SURFACE_GLOBAL
{
    DWORD                       dwBlockSizeY;   // block size that display driver requested (return)
    union {
        LPVIDEOMEMORY           lpVidMemHeap;   // heap vidmem was alloc'ed from
        DWORD                   dwBlockSizeX;   // block size that display driver requested (return)
        DWORD                   dwUserMemSize;  // user-mode memory size that display driver requested (return)
    };
    FLATPTR                     fpVidMem;       // pointer to video memory
    union
    {
        LONG                    lPitch;         // pitch of surface
        DWORD                   dwLinearSize;   // linear size of non-rectangular surface
    };
    LONG                        yHint;          // y-coordinate of surface
    LONG                        xHint;          // x-coordinate of surface
    DWORD                       wHeight;        // height of surface
    DWORD                       wWidth;         // width of surface
    ULONG_PTR                   dwReserved1;    // reserved for use by display driver
    DDPIXELFORMAT               ddpfSurface;    // pixel format of surface
    FLATPTR                     fpHeapOffset;   // raw offset in source heap
    HANDLE                      hCreatorProcess;// opaque identifier for creating process
} DD_SURFACE_GLOBAL;

/*
 * a structure holding additional LCL surface information (to maintain some
 * compatibility with Win95).
 */
typedef struct _DD_SURFACE_MORE
{
    DWORD                       dwMipMapCount;      // number of mip-map levels
    PDD_VIDEOPORT_LOCAL         lpVideoPort;        // video port currently writing data to this surface
    DWORD                       dwOverlayFlags;     // current overlay flags
    DDSCAPSEX                   ddsCapsEx;          // more surface capabilities
    DWORD                       dwSurfaceHandle;    // cookie for use with CreateSurfaceEx DDI
} DD_SURFACE_MORE, *PDD_SURFACE_MORE;

/*
 * the LCL structure is local data for each individual surface object
 */
typedef struct _DD_SURFACE_LOCAL
{
    PDD_SURFACE_GLOBAL          lpGbl;            // pointer to surface shared data
    DWORD                       dwFlags;          // flags
    DDSCAPS                     ddsCaps;          // capabilities of surface
    ULONG_PTR                   dwReserved1;      // reserved for use by display driver
    union
    {
        DDCOLORKEY              ddckCKSrcOverlay; // color key for source overlay use
        DDCOLORKEY              ddckCKSrcBlt;     // color key for source blt and texture use
    };
    union
    {
        DDCOLORKEY              ddckCKDestOverlay;// color key for destination overlay use
        DDCOLORKEY              ddckCKDestBlt;    // color key for destination blt
    };
    PDD_SURFACE_MORE            lpSurfMore;       // pointer to additional local data
    PDD_ATTACHLIST              lpAttachList;     // link to surfaces we attached to
    PDD_ATTACHLIST              lpAttachListFrom; // link to surfaces that attached to us
    RECT                        rcOverlaySrc;     // Overlay source rectangle relative to surface
} DD_SURFACE_LOCAL;

#define DDRAWISURF_HASCKEYSRCBLT        0x00000800L     // surface has CKSrcBlt
#define DDRAWISURF_HASPIXELFORMAT       0x00002000L     // surface structure has pixel format data
#define DDRAWISURF_HASOVERLAYDATA       0x00004000L     // surface structure has overlay data
#define DDRAWISURF_FRONTBUFFER          0x04000000L     // surface was originally a front buffer
#define DDRAWISURF_BACKBUFFER           0x08000000L     // surface was originally backbuffer
#define DDRAWISURF_INVALID              0x10000000L     // surface has been invalidated by mode set
#define DDRAWISURF_DRIVERMANAGED        0x40000000L     // surface is a driver managed texture (D3D)

/*
 * More driver capabilities (in addition to those described in DDCORECAPS).
 * This struct contains the caps bits added to the DDCAPS structure in DX6.
 */
typedef struct _DD_MORECAPS
{
    DWORD   dwSize; 		    // size of DDMORECAPS structure
    DWORD   dwAlphaCaps;	    // driver-specific alpha caps for overlays & Vmem->Vmem blts
    DWORD   dwSVBAlphaCaps;	    // driver-specific alpha capabilities for System->Vmem blts
    DWORD   dwVSBAlphaCaps;	    // driver-specific alpha capabilities for Vmem->System blts
    DWORD   dwSSBAlphaCaps;	    // driver-specific alpha capabilities for System->System blts
    DWORD   dwFilterCaps;           // driver-specific filter caps for overlays & Vmem->Vmem blts
    DWORD   dwSVBFilterCaps;        // driver-specific filter capabilities for System->Vmem blts
    DWORD   dwVSBFilterCaps;        // driver-specific filter capabilities for Vmem->System blts
    DWORD   dwSSBFilterCaps;        // driver-specific filter capabilities for System->System blts
} DD_MORECAPS;

typedef DD_MORECAPS *PDD_MORECAPS;

/*
 * rop stuff
 */
#define ROP_HAS_SOURCE          0x00000001l
#define ROP_HAS_PATTERN         0x00000002l
#define ROP_HAS_SOURCEPATTERN   ROP_HAS_SOURCE | ROP_HAS_PATTERN

/*
 * This structure mirrors the first entries of the DDCAPS but is of a fixed
 * size and will not grow as DDCAPS grows. This is the structure your driver
 * returns in DDCOREINFO. Additional caps will be requested via a GetDriverInfo
 * call.
 */
typedef struct _DDNTCORECAPS
{
    DWORD       dwSize;                 // size of the DDDRIVERCAPS structure
    DWORD       dwCaps;                 // driver specific capabilities
    DWORD       dwCaps2;                // more driver specific capabilites
    DWORD       dwCKeyCaps;             // color key capabilities of the surface
    DWORD       dwFXCaps;               // driver specific stretching and effects capabilites
    DWORD       dwFXAlphaCaps;          // alpha driver specific capabilities
    DWORD       dwPalCaps;              // palette capabilities
    DWORD       dwSVCaps;               // stereo vision capabilities
    DWORD       dwAlphaBltConstBitDepths;       // DDBD_2,4,8
    DWORD       dwAlphaBltPixelBitDepths;       // DDBD_1,2,4,8
    DWORD       dwAlphaBltSurfaceBitDepths;     // DDBD_1,2,4,8
    DWORD       dwAlphaOverlayConstBitDepths;   // DDBD_2,4,8
    DWORD       dwAlphaOverlayPixelBitDepths;   // DDBD_1,2,4,8
    DWORD       dwAlphaOverlaySurfaceBitDepths; // DDBD_1,2,4,8
    DWORD       dwZBufferBitDepths;             // DDBD_8,16,24,32
    DWORD       dwVidMemTotal;          // total amount of video memory
    DWORD       dwVidMemFree;           // amount of free video memory
    DWORD       dwMaxVisibleOverlays;   // maximum number of visible overlays
    DWORD       dwCurrVisibleOverlays;  // current number of visible overlays
    DWORD       dwNumFourCCCodes;       // number of four cc codes
    DWORD       dwAlignBoundarySrc;     // source rectangle alignment
    DWORD       dwAlignSizeSrc;         // source rectangle byte size
    DWORD       dwAlignBoundaryDest;    // dest rectangle alignment
    DWORD       dwAlignSizeDest;        // dest rectangle byte size
    DWORD       dwAlignStrideAlign;     // stride alignment
    DWORD       dwRops[DD_ROP_SPACE];   // ROPS supported
    DDSCAPS     ddsCaps;                // DDSCAPS structure has all the general capabilities
    DWORD       dwMinOverlayStretch;    // minimum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD       dwMaxOverlayStretch;    // maximum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD       dwMinLiveVideoStretch;  // minimum live video stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD       dwMaxLiveVideoStretch;  // maximum live video stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD       dwMinHwCodecStretch;    // minimum hardware codec stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD       dwMaxHwCodecStretch;    // maximum hardware codec stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD       dwReserved1;            // reserved
    DWORD       dwReserved2;            // reserved
    DWORD       dwReserved3;            // reserved
    DWORD       dwSVBCaps;              // driver specific capabilities for System->Vmem blts
    DWORD       dwSVBCKeyCaps;          // driver color key capabilities for System->Vmem blts
    DWORD       dwSVBFXCaps;            // driver FX capabilities for System->Vmem blts
    DWORD       dwSVBRops[DD_ROP_SPACE];// ROPS supported for System->Vmem blts
    DWORD       dwVSBCaps;              // driver specific capabilities for Vmem->System blts
    DWORD       dwVSBCKeyCaps;          // driver color key capabilities for Vmem->System blts
    DWORD       dwVSBFXCaps;            // driver FX capabilities for Vmem->System blts
    DWORD       dwVSBRops[DD_ROP_SPACE];// ROPS supported for Vmem->System blts
    DWORD       dwSSBCaps;              // driver specific capabilities for System->System blts
    DWORD       dwSSBCKeyCaps;          // driver color key capabilities for System->System blts
    DWORD       dwSSBFXCaps;            // driver FX capabilities for System->System blts
    DWORD       dwSSBRops[DD_ROP_SPACE];// ROPS supported for System->System blts
    DWORD       dwMaxVideoPorts;        // maximum number of usable video ports
    DWORD       dwCurrVideoPorts;       // current number of video ports used
    DWORD       dwSVBCaps2;             // more driver specific capabilities for System->Vmem blts
} DDNTCORECAPS, *PDDNTCORECAPS;

/*
 * structure for D3D buffer callbacks
 */
typedef struct _DD_D3DBUFCALLBACKS
{
    DWORD dwSize;
    DWORD dwFlags;
    PDD_CANCREATESURFACE        CanCreateD3DBuffer;
    PDD_CREATESURFACE           CreateD3DBuffer;
    PDD_SURFCB_DESTROYSURFACE   DestroyD3DBuffer;
    PDD_SURFCB_LOCK             LockD3DBuffer;
    PDD_SURFCB_UNLOCK           UnlockD3DBuffer;
} DD_D3DBUFCALLBACKS, *PDD_D3DBUFCALLBACKS;

#define DDHAL_EXEBUFCB32_CANCREATEEXEBUF    0x00000001l
#define DDHAL_EXEBUFCB32_CREATEEXEBUF       0x00000002l
#define DDHAL_EXEBUFCB32_DESTROYEXEBUF      0x00000004l
#define DDHAL_EXEBUFCB32_LOCKEXEBUF         0x00000008l
#define DDHAL_EXEBUFCB32_UNLOCKEXEBUF       0x00000010l

/*
 * NT friendly names
 */
#define DDHAL_D3DBUFCB32_CANCREATED3DBUF    DDHAL_EXEBUFCB32_CANCREATEEXEBUF    
#define DDHAL_D3DBUFCB32_CREATED3DBUF       DDHAL_EXEBUFCB32_CREATEEXEBUF       
#define DDHAL_D3DBUFCB32_DESTROYD3DBUF      DDHAL_EXEBUFCB32_DESTROYEXEBUF      
#define DDHAL_D3DBUFCB32_LOCKD3DBUF         DDHAL_EXEBUFCB32_LOCKEXEBUF         
#define DDHAL_D3DBUFCB32_UNLOCKD3DBUF       DDHAL_EXEBUFCB32_UNLOCKEXEBUF       


/*
 * structure for display driver to call DDHAL_Create with
 * the _V4 version was used by NT4 drivers
 */
typedef struct _DD_HALINFO_V4
{
    DWORD                       dwSize;
    VIDEOMEMORYINFO             vmiData;                // video memory info
    DDNTCORECAPS                ddCaps;                 // hw specific caps
    PDD_GETDRIVERINFO           GetDriverInfo;          // callback for querying driver data
    DWORD                       dwFlags;                // create flags
} DD_HALINFO_V4, *PDD_HALINFO_V4;

typedef struct _DD_HALINFO
{
    DWORD                       dwSize;
    VIDEOMEMORYINFO             vmiData;                // video memory info
    DDNTCORECAPS                ddCaps;                 // hw specific caps
    PDD_GETDRIVERINFO           GetDriverInfo;          // callback for querying driver data
    DWORD                       dwFlags;                // create flags
    LPVOID                      lpD3DGlobalDriverData;  // D3D global Data
    LPVOID                      lpD3DHALCallbacks;      // D3D callbacks
    PDD_D3DBUFCALLBACKS         lpD3DBufCallbacks;      // Buffer callbacks
} DD_HALINFO, *PDD_HALINFO;

#define DDHALINFO_GETDRIVERINFOSET      0x00000004l     // indicates that GetDriverInfo is set

/*
 * DDRAW version of DirectDraw object;
 *
 */
typedef struct _DD_DIRECTDRAW_GLOBAL
{
    VOID*                       dhpdev;         // driver's private PDEV pointer
    ULONG_PTR                   dwReserved1;    // reserved for use by display driver
    ULONG_PTR                   dwReserved2;    // reserved for use by display driver
    LPDDVIDEOPORTCAPS           lpDDVideoPortCaps;// Info returned by the HAL (an array if more than one video port)
} DD_DIRECTDRAW_GLOBAL;

typedef struct _DD_DIRECTDRAW_LOCAL
{
    PDD_DIRECTDRAW_GLOBAL       lpGbl;            // pointer to data
} DD_DIRECTDRAW_LOCAL;

typedef struct _DD_VIDEOPORT_LOCAL
{
    PDD_DIRECTDRAW_LOCAL        lpDD;             // pointer to DIRECTDRAW_LCL
    DDVIDEOPORTDESC             ddvpDesc;         // description used at create time
    DDVIDEOPORTINFO             ddvpInfo;         // most recent video port info
    PDD_SURFACE_INT             lpSurface;        // surface receiving the data
    PDD_SURFACE_INT             lpVBISurface;     // surface receiving the VBI data
    DWORD                       dwNumAutoflip;    // Number of current autoflip surfaces
    DWORD                       dwNumVBIAutoflip; // Number of VBI surfaces currently being autoflipped
    ULONG_PTR                   dwReserved1;      // Reserved for display driver
    ULONG_PTR                   dwReserved2;      // Reserved for display driver
    ULONG_PTR                   dwReserved3;      // Reserved for display driver
} DD_VIDEOPORT_LOCAL;

#define DDRAWIVPORT_ON                  0x00000001      // Video port is pumping data
#define DDRAWIVPORT_SOFTWARE_AUTOFLIP   0x00000002      // Video port cannot use hardware autoflip
#define DDRAWIVPORT_COLORKEYANDINTERP   0x00000004      // Overlay cannot bob and colorkey at same time

typedef struct _DD_MOTIONCOMP_LOCAL
{
    PDD_DIRECTDRAW_LOCAL        lpDD;             // pointer to DIRECTDRAW_LCL
    GUID                            guid;
    DWORD                           dwUncompWidth;
    DWORD                           dwUncompHeight;
    DDPIXELFORMAT                   ddUncompPixelFormat;
    DWORD                           dwDriverReserved1;
    DWORD                           dwDriverReserved2;
    DWORD                           dwDriverReserved3;
    LPVOID                          lpDriverReserved1;
    LPVOID                          lpDriverReserved2;
    LPVOID                          lpDriverReserved3;
} DD_MOTIONCOMP_LOCAL;


/*
 * More driver surface capabilities (in addition to those described in DDCORECAPS).
 * This struct contains the caps bits added to the DDCAPS.ddsCaps structure in DX6.
 */
typedef struct _DD_MORESURFACECAPS
{
    DWORD       dwSize;             // size of DDMORESURFACECAPS structure
    DDSCAPSEX   ddsCapsMore;
    /*
     * The DDMORESURFACECAPS struct is of variable size. The following list may be
     * filled in by DX6-aware drivers (see DDVERSIONINFO) to restrict their
     * video memory heaps (those which are exposed to DirectDraw) to
     * certain sets of DDSCAPS_ bits. Thse entries are exactly analogous to
     * the ddsCaps and ddsCapsAlt members of the VIDMEM structures listed in
     * the VIDMEMINFO.pvmList member of DDHALINFO.vmiData. There should be
     * exactly DDHALINFO.vmiData.dwNumHeaps copies of tagExtendedHeapRestrictions
     * in this struct. The size of this struct is thus:
     *  DDMORESURFACECAPS.dwSize = sizeof(DDMORESURFACECAPS) +
     *          (DDHALINFO.vmiData.dwNumHeaps-1) * sizeof(DDSCAPSEX)*2;
     * Note the -1 accounts for the fact that DDMORESURFACECAPS is declared to have 1
     * tagExtendedHeapRestrictions member.
     */
    struct tagNTExtendedHeapRestrictions
    {
        DDSCAPSEX   ddsCapsEx;
        DDSCAPSEX   ddsCapsExAlt;
    } ddsExtendedHeapRestrictions[1];
} DD_MORESURFACECAPS;

// for DX7, we check each mode in the driver if it supports 
// Stereo, driver returns DD_OK if mode is ok for stereo
typedef struct _DD_STEREOMODE
{
    DWORD       dwSize;             // size of DDSTEREOMODECAPS structure

    DWORD       dwHeight;
    DWORD       dwWidth;
    DWORD       dwBpp;
    DWORD       dwRefreshRate;

    BOOL        bSupported;

} DD_STEREOMODE;

typedef struct _DD_UPDATENONLOCALHEAPDATA
{
    PDD_DIRECTDRAW_GLOBAL      lpDD;                // driver struct
    DWORD                      dwHeap;              // heap index
    FLATPTR                    fpGARTLin;           // linear GART address of start of heap
    FLATPTR                    fpGARTDev;           // high physical GART address of start of heap
    ULONG_PTR                  ulPolicyMaxBytes;    // maximum amount of AGP memory to use
    HRESULT                    ddRVal;              // return value
    VOID*                      UpdateNonLocalHeap;  // Unused: Win95 compatibility
} DD_UPDATENONLOCALHEAPDATA;

/*
 * Private caps that the driver passes to change DirectDraw behavior.
 * These caps are not exposed to the application
 */

typedef struct DD_NTPRIVATEDRIVERCAPS
{
    DWORD                               dwSize;
    DWORD                               dwPrivateCaps;
} DD_NTPRIVATEDRIVERCAPS;

// Driver wants DD_CREATESURFACEDATA.lplpSList to contain a list of
// surfaces to create rather than always a single surface.
#define DDHAL_PRIVATECAP_ATOMICSURFACECREATION 0x00000001l

// Driver wants to be notified when creating a primary surface.
#define DDHAL_PRIVATECAP_NOTIFYPRIMARYCREATION  0x00000002l

/////////////////////////////////////////////////////////////////////////////
// NT Note:
//
// The following structures must match, field for field, the corresponding
// structures as declared in 'ddrawi.h.'  We cannot simply use the same
// structures because the sub-structures such as DD_DIRECTDRAW_GLOBAL are
// different, and have to be properly typed for the drivers.
//
/////////////////////////////////////////////////////////////////////////////

/****************************************************************************
 *
 * DDHAL structures for Surface Object callbacks
 *
 ***************************************************************************/

/*
 * This special flag is seen only by drivers.  The DD runtime sets this
 * bit in DDHAL_BLTDATA.dwFlags if the dwAFlags and ddrgbaScaleFactors
 * members at the end of the DDHAL_BLTDATA structure are valid.
 * The flag is always set if the DDHAL_BLTDATA structure is passed to
 * the driver via the AlphaBlt HAL callback; otherwise, the flag is zero.
 */
#define DDBLT_AFLAGS 		0x80000000L

/*
 * This flag will be set in DDHAL_BLTDATA.dwAFlags if the call was originated
 * by the AlphaBlt API method. If the call was originated by the Blt API,
 * this flag will not be set.
 * Drivers which have a unified Blt/AlphaBlt DDI can use this flag to distinguish
 * between the two API calls.
 */
#define DDABLT_SRCOVERDEST      0x00000001L

/*
 * structure for passing information to DDHAL Blt fn
 */
typedef struct _DD_BLTDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    PDD_SURFACE_LOCAL           lpDDDestSurface;// dest surface
    RECTL                       rDest;          // dest rect
    PDD_SURFACE_LOCAL           lpDDSrcSurface; // src surface
    RECTL                       rSrc;           // src rect
    DWORD                       dwFlags;        // blt flags
    DWORD                       dwROPFlags;     // ROP flags (valid for ROPS only)
    DDBLTFX                     bltFX;          // blt FX
    HRESULT                     ddRVal;         // return value
    VOID*                       Blt;            // Unused: Win95 compatibility
    BOOL                        IsClipped;      // clipped blt?
    RECTL                       rOrigDest;      // unclipped dest rect
                                                // (only valid if IsClipped)
    RECTL                       rOrigSrc;       // unclipped src rect
                                                // (only valid if IsClipped)
    DWORD                       dwRectCnt;      // count of dest rects
                                                // (only valid if IsClipped)
    LPRECT                      prDestRects;    // array of dest rects
                                                // (only valid if IsClipped)
    DWORD                       dwAFlags;       // DDABLT_ flags (for AlphaBlt DDI)
    DDARGB                      ddargbScaleFactors;  // ARGB scaling factors (AlphaBlt)
} DD_BLTDATA;

/*
 * structure for passing information to DDHAL Lock fn
 */
typedef struct _DD_LOCKDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    PDD_SURFACE_LOCAL           lpDDSurface;    // surface struct
    DWORD                       bHasRect;       // rArea is valid
    RECTL                       rArea;          // area being locked
    LPVOID                      lpSurfData;     // pointer to screen memory (return value)
    HRESULT                     ddRVal;         // return value
    VOID*                       Lock;           // Unused: Win95 compatibility
    DWORD                       dwFlags;        // DDLOCK flags
    FLATPTR                     fpProcess;      // process start address
} DD_LOCKDATA;

/*
 * structure for passing information to DDHAL Unlock fn
 */
typedef struct _DD_UNLOCKDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    PDD_SURFACE_LOCAL           lpDDSurface;    // surface struct
    HRESULT                     ddRVal;         // return value
    VOID*                       Unlock;         // Unused: Win95 compatibility
} DD_UNLOCKDATA;

/*
 * structure for passing information to DDHAL UpdateOverlay fn
 */
typedef struct _DD_UPDATEOVERLAYDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    PDD_SURFACE_LOCAL           lpDDDestSurface;// dest surface
    RECTL                       rDest;          // dest rect
    PDD_SURFACE_LOCAL           lpDDSrcSurface; // src surface
    RECTL                       rSrc;           // src rect
    DWORD                       dwFlags;        // flags
    DDOVERLAYFX                 overlayFX;      // overlay FX
    HRESULT                     ddRVal;         // return value
    VOID*                       UpdateOverlay;  // Unused: Win95 compatibility
} DD_UPDATEOVERLAYDATA;

/*
 * structure for passing information to DDHAL UpdateOverlay fn
 */
typedef struct _DD_SETOVERLAYPOSITIONDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    PDD_SURFACE_LOCAL           lpDDSrcSurface; // src surface
    PDD_SURFACE_LOCAL           lpDDDestSurface;// dest surface
    LONG                        lXPos;          // x position
    LONG                        lYPos;          // y position
    HRESULT                     ddRVal;         // return value
    VOID*                       SetOverlayPosition; // Unused: Win95 compatibility
} DD_SETOVERLAYPOSITIONDATA;
/*
 * structure for passing information to DDHAL SetPalette fn
 */
typedef struct _DD_SETPALETTEDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    PDD_SURFACE_LOCAL           lpDDSurface;    // surface struct
    PDD_PALETTE_GLOBAL          lpDDPalette;    // palette to set to surface
    HRESULT                     ddRVal;         // return value
    VOID*                       SetPalette;     // Unused: Win95 compatibility
    BOOL                        Attach;         // attach this palette?
} DD_SETPALETTEDATA;

/*
 * structure for passing information to DDHAL Flip fn
 */
typedef struct _DD_FLIPDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    PDD_SURFACE_LOCAL           lpSurfCurr;     // current surface
    PDD_SURFACE_LOCAL           lpSurfTarg;     // target surface (to flip to)
    DWORD                       dwFlags;        // flags
    HRESULT                     ddRVal;         // return value
    VOID*                       Flip;           // Unused: Win95 compatibility
    PDD_SURFACE_LOCAL           lpSurfCurrLeft;     // left target surface (to flip to)
    PDD_SURFACE_LOCAL           lpSurfTargLeft;     // left target surface (to flip to)
} DD_FLIPDATA;

/*
 * structure for passing information to DDHAL DestroySurface fn
 */
typedef struct _DD_DESTROYSURFACEDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    PDD_SURFACE_LOCAL           lpDDSurface;    // surface struct
    HRESULT                     ddRVal;         // return value
    VOID*                       DestroySurface;// Unused: Win95 compatibility
} DD_DESTROYSURFACEDATA;

/*
 * structure for passing information to DDHAL SetClipList fn
 */
typedef struct _DD_SETCLIPLISTDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    PDD_SURFACE_LOCAL           lpDDSurface;    // surface struct
    HRESULT                     ddRVal;         // return value
    VOID*                       SetClipList;    // Unused: Win95 compatibility
} DD_SETCLIPLISTDATA;

/*
 * structure for passing information to DDHAL AddAttachedSurface fn
 */
typedef struct _DD_ADDATTACHEDSURFACEDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    PDD_SURFACE_LOCAL           lpDDSurface;    // surface struct
    PDD_SURFACE_LOCAL           lpSurfAttached; // surface to attach
    HRESULT                     ddRVal;         // return value
    VOID*                       AddAttachedSurface; // Unused: Win95 compatibility
} DD_ADDATTACHEDSURFACEDATA;

/*
 * structure for passing information to DDHAL SetColorKey fn
 */
typedef struct _DD_SETCOLORKEYDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    PDD_SURFACE_LOCAL           lpDDSurface;    // surface struct
    DWORD                       dwFlags;        // flags
    DDCOLORKEY                  ckNew;          // new color key
    HRESULT                     ddRVal;         // return value
    VOID*                       SetColorKey;    // Unused: Win95 compatibility
} DD_SETCOLORKEYDATA;

/*
 * structure for passing information to DDHAL GetBltStatus fn
 */
typedef struct _DD_GETBLTSTATUSDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    PDD_SURFACE_LOCAL           lpDDSurface;    // surface struct
    DWORD                       dwFlags;        // flags
    HRESULT                     ddRVal;         // return value
    VOID*                       GetBltStatus;   // Unused: Win95 compatibility
} DD_GETBLTSTATUSDATA;

/*
 * structure for passing information to DDHAL GetFlipStatus fn
 */
typedef struct _DD_GETFLIPSTATUSDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    PDD_SURFACE_LOCAL           lpDDSurface;    // surface struct
    DWORD                       dwFlags;        // flags
    HRESULT                     ddRVal;         // return value
    VOID*                       GetFlipStatus;  // Unused: Win95 compatibility
} DD_GETFLIPSTATUSDATA;

/****************************************************************************
 *
 * DDHAL structures for Palette Object callbacks
 *
 ***************************************************************************/

/*
 * structure for passing information to DDHAL DestroyPalette fn
 */
typedef struct _DD_DESTROYPALETTEDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    PDD_PALETTE_GLOBAL          lpDDPalette;    // palette struct
    HRESULT                     ddRVal;         // return value
    VOID*                       DestroyPalette; // Unused: Win95 compatibility
} DD_DESTROYPALETTEDATA;

/*
 * structure for passing information to DDHAL SetEntries fn
 */
typedef struct _DD_SETENTRIESDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    PDD_PALETTE_GLOBAL          lpDDPalette;    // palette struct
    DWORD                       dwBase;         // base palette index
    DWORD                       dwNumEntries;   // number of palette entries
    LPPALETTEENTRY              lpEntries;      // color table
    HRESULT                     ddRVal;         // return value
    VOID*                       SetEntries;     // Unused: Win95 compatibility
} DD_SETENTRIESDATA;

/****************************************************************************
 *
 * DDHAL structures for Driver Object callbacks
 *
 ***************************************************************************/

typedef DDSURFACEDESC* PDD_SURFACEDESC;

/*
 * structure for passing information to DDHAL CreateSurface fn
 */
typedef struct _DD_CREATESURFACEDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    PDD_SURFACEDESC             lpDDSurfaceDesc;// description of surface being created
    PDD_SURFACE_LOCAL           *lplpSList;     // list of created surface objects
    DWORD                       dwSCnt;         // number of surfaces in SList
    HRESULT                     ddRVal;         // return value
    VOID*                       CreateSurface;  // Unused: Win95 compatibility
} DD_CREATESURFACEDATA;

/*
 * structure for passing information to DDHAL CanCreateSurface fn
 */
typedef struct _DD_CANCREATESURFACEDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;                   // driver struct
    PDD_SURFACEDESC             lpDDSurfaceDesc;        // description of surface being created
    DWORD                       bIsDifferentPixelFormat;// pixel format differs from primary surface
    HRESULT                     ddRVal;                 // return value
    VOID*                       CanCreateSurface;       // Unused: Win95 compatibility
} DD_CANCREATESURFACEDATA;

/*
 * structure for passing information to DDHAL CreatePalette fn
 */
typedef struct _DD_CREATEPALETTEDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    PDD_PALETTE_GLOBAL          lpDDPalette;    // ddraw palette struct
    LPPALETTEENTRY              lpColorTable;   // colors to go in palette
    HRESULT                     ddRVal;         // return value
    VOID*                       CreatePalette;  // Unused: Win95 compatibility
    BOOL                        is_excl;        // process has exclusive mode
} DD_CREATEPALETTEDATA;

/*
 * Return if the vertical blank is in progress
 */
#define DDWAITVB_I_TESTVB                       0x80000006l

/*
 * structure for passing information to DDHAL WaitForVerticalBlank fn
 */
typedef struct _DD_WAITFORVERTICALBLANKDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    DWORD                       dwFlags;        // flags
    DWORD                       bIsInVB;        // is in vertical blank
    DWORD                       hEvent;         // event
    HRESULT                     ddRVal;         // return value
    VOID*                       WaitForVerticalBlank; // Unused: Win95 compatibility
} DD_WAITFORVERTICALBLANKDATA;

/*
 * structure for passing information to DDHAL driver SetColorKey fn
 */
typedef struct _DD_DRVSETCOLORKEYDATA
{
    PDD_SURFACE_LOCAL           lpDDSurface;    // surface struct
    DWORD                       dwFlags;        // flags
    DDCOLORKEY                  ckNew;          // new color key
    HRESULT                     ddRVal;         // return value
    VOID*                       SetColorKey;    // Unused: Win95 compatibility
} DD_DRVSETCOLORKEYDATA;

/*
 * structure for passing information to DDHAL GetScanLine fn
 */
typedef struct _DD_GETSCANLINEDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    DWORD                       dwScanLine;     // returned scan line
    HRESULT                     ddRVal;         // return value
    VOID*                       GetScanLine;    // Unused: Win95 compatibility
} DD_GETSCANLINEDATA;

/*
 * structure for passing information to DDHAL MapMemory fn
 */
typedef struct _DD_MAPMEMORYDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    BOOL                        bMap;           // TRUE if map; FALSe if un-map
    HANDLE                      hProcess;       // process handle
    FLATPTR                     fpProcess;      // returned address in process' address space
    HRESULT                     ddRVal;         // return value
} DD_MAPMEMORYDATA;

/****************************************************************************
 *
 * DDHAL structures for VideoPort callbacks
 *
 ***************************************************************************/

/*
 * structure for passing information to DDHAL CanCreateVideoPort fn
 */
typedef struct _DD_CANCREATEVPORTDATA
{
    PDD_DIRECTDRAW_LOCAL        lpDD;               // driver struct
    LPDDVIDEOPORTDESC           lpDDVideoPortDesc;
    HRESULT                     ddRVal;             // return value
    VOID*                       CanCreateVideoPort; // Unused: Win95 compatibility
} DD_CANCREATEVPORTDATA;

/*
 * structure for passing information to DDHAL CreateVideoPort fn
 */
typedef struct _DD_CREATEVPORTDATA
{
    PDD_DIRECTDRAW_LOCAL        lpDD;              // driver struct
    LPDDVIDEOPORTDESC           lpDDVideoPortDesc;
    PDD_VIDEOPORT_LOCAL         lpVideoPort;       // Video port created
    HRESULT                     ddRVal;            // return value
    VOID*                       CreateVideoPort;   // Unused: Win95 compatibility
} DD_CREATEVPORTDATA;

/*
 * structure for passing information to DDHAL FlipVideoPort fn
 */
typedef struct _DD_FLIPVPORTDATA
{
    PDD_DIRECTDRAW_LOCAL        lpDD;          // driver struct
    PDD_VIDEOPORT_LOCAL         lpVideoPort;   // Video port object
    PDD_SURFACE_LOCAL           lpSurfCurr;    // current surface
    PDD_SURFACE_LOCAL           lpSurfTarg;    // target surface
    HRESULT                     ddRVal;        // return value
    VOID*                       FlipVideoPort; // Unused: Win95 compatibility
} DD_FLIPVPORTDATA;

/*
 * structure for passing information to DDHAL GetVideoPortBandwidth fn
 */
typedef struct _DD_GETVPORTBANDWIDTHDATA
{
    PDD_DIRECTDRAW_LOCAL        lpDD;                  // driver struct
    PDD_VIDEOPORT_LOCAL         lpVideoPort;           // Video port object
    LPDDPIXELFORMAT             lpddpfFormat;          // Format for bandwidth
    DWORD                       dwWidth;
    DWORD                       dwHeight;
    DWORD                       dwFlags;               // Prescale factor for bandwidth
    LPDDVIDEOPORTBANDWIDTH      lpBandwidth;           // Returned bandwidth parameters
    HRESULT                     ddRVal;                // return value
    VOID*                       GetVideoPortBandwidth; // Unused: Win95 compatibility
} DD_GETVPORTBANDWIDTHDATA;

/*
 * structure for passing information to DDHAL GetVideoPortInputFormats fn
 */
typedef struct _DD_GETVPORTINPUTFORMATDATA
{
    PDD_DIRECTDRAW_LOCAL        lpDD;                     // driver struct
    PDD_VIDEOPORT_LOCAL         lpVideoPort;              // Video port object
    DWORD                       dwFlags;                  // VBI, regular, or both
    LPDDPIXELFORMAT             lpddpfFormat;             // Array of formats
    DWORD                       dwNumFormats;             // # of formats in array
    HRESULT                     ddRVal;                   // return value
    VOID*                       GetVideoPortInputFormats; // Unused: Win95 compatibility
} DD_GETVPORTINPUTFORMATDATA;

/*
 * structure for passing information to DDHAL GetVideoPortOutputFormats fn
 */
typedef struct _DD_GETVPORTOUTPUTFORMATDATA
{
    PDD_DIRECTDRAW_LOCAL        lpDD;                     // driver struct
    PDD_VIDEOPORT_LOCAL         lpVideoPort;              // Video port object
    DWORD                       dwFlags;                  // VBI, regular, or both
    LPDDPIXELFORMAT             lpddpfInputFormat;        // Input format
    LPDDPIXELFORMAT             lpddpfOutputFormats;      // Array of output formats
    DWORD                       dwNumFormats;             // # of formats in array
    HRESULT                     ddRVal;                   // return value
    VOID*                       GetVideoPortInputFormats; // Unused: Win95 compatibility
} DD_GETVPORTOUTPUTFORMATDATA;

/*
 * structure for passing information to DDHAL GetVideoPortField fn
 */
typedef struct _DD_GETVPORTFIELDDATA
{
    PDD_DIRECTDRAW_LOCAL        lpDD;              // driver struct
    PDD_VIDEOPORT_LOCAL         lpVideoPort;       // Video port object
    BOOL                        bField;            // TRUE if even
    HRESULT                     ddRVal;            // return value
    VOID*                       GetVideoPortField; // Unused: Win95 compatibility
} DD_GETVPORTFIELDDATA;

/*
 * structure for passing information to DDHAL GetVideoPortLine fn
 */
typedef struct _DD_GETVPORTLINEDATA
{
    PDD_DIRECTDRAW_LOCAL        lpDD;             // driver struct
    PDD_VIDEOPORT_LOCAL         lpVideoPort;      // Video port object
    DWORD                       dwLine;           // Current line counter
    HRESULT                     ddRVal;           // return value
    VOID*                       GetVideoPortLine; // Unused: Win95 compatibility
} DD_GETVPORTLINEDATA;

/*
 * structure for passing information to DDHAL GetVideoPortConnectInfo fn
 */
typedef struct _DD_GETVPORTCONNECTDATA
{
    PDD_DIRECTDRAW_LOCAL        lpDD;                    // driver struct
    DWORD                       dwPortId;                // ID of desired video port
    LPDDVIDEOPORTCONNECT        lpConnect;               // Array of DDVIDEOPORTCONNECT structures
    DWORD                       dwNumEntries;            // # of structures in array
    HRESULT                     ddRVal;                  // return value
    VOID*                       GetVideoPortConnectInfo; // Unused: Win95 compatibility
} DD_GETVPORTCONNECTDATA;

/*
 * structure for passing information to DDHAL DestroyVideoPort fn
 */
typedef struct _DD_DESTROYVPORTDATA
{
    PDD_DIRECTDRAW_LOCAL        lpDD;             // driver struct
    PDD_VIDEOPORT_LOCAL         lpVideoPort;      // Video port object
    HRESULT                     ddRVal;           // return value
    VOID*                       DestroyVideoPort; // Unused: Win95 compatibility
} DD_DESTROYVPORTDATA;

/*
 * structure for passing information to DDHAL GetVideoPortFlipStatus fn
 */
typedef struct _DD_GETVPORTFLIPSTATUSDATA
{
    PDD_DIRECTDRAW_LOCAL        lpDD;                   // driver struct
    FLATPTR                     fpSurface;              // surface struct
    HRESULT                     ddRVal;                 // return value
    VOID*                       GetVideoPortFlipStatus; // Unused: Win95 compatibility
} DD_GETVPORTFLIPSTATUSDATA;

typedef DDVIDEOPORTINFO*   PDD_VIDEOPORTINFO;
/*
 * structure for passing information to DDHAL UpdateVideoPort fn
 */
typedef struct _DD_UPDATEVPORTDATA
{
    PDD_DIRECTDRAW_LOCAL        lpDD;             // driver struct
    PDD_VIDEOPORT_LOCAL         lpVideoPort;      // Video port object
    PDD_SURFACE_INT            *lplpDDSurface;    // surface struct
    PDD_SURFACE_INT            *lplpDDVBISurface; // VBI surface structure
    PDD_VIDEOPORTINFO           lpVideoInfo;      // Video information
    DWORD                       dwFlags;          // DDRAWI_VPORTSTART, DDRAWI_VPORTSTOP, DDRAWI_VPORTUPDATE
    DWORD                       dwNumAutoflip;    // # of autoflip surfaces. If > 1, lpDDSurface is an array.
    DWORD                       dwNumVBIAutoflip; // # of autoflip surfaces. If > 1, lpDDVBISurface is an array.
    HRESULT                     ddRVal;           // return value
    VOID*                       UpdateVideoPort;  // Unused: Win95 compatibility
} DD_UPDATEVPORTDATA;

#define DDRAWI_VPORTSTART       0x0001
#define DDRAWI_VPORTSTOP        0x0002
#define DDRAWI_VPORTUPDATE      0x0003

/*
 * structure for passing information to DDHAL WaitForVideoPortSync fn
 */
typedef struct _DD_WAITFORVPORTSYNCDATA
{
    PDD_DIRECTDRAW_LOCAL        lpDD;            // driver struct
    PDD_VIDEOPORT_LOCAL         lpVideoPort;     // Video port object
    DWORD                       dwFlags;         // DDVPEVENT_XXXX
    DWORD                       dwLine;
    DWORD                       dwTimeOut;       // Max time to wait before returning
    HRESULT                     ddRVal;          // return value
    VOID*                       UpdateVideoPort; // Unused: Win95 compatibility
} DD_WAITFORVPORTSYNCDATA;

/*
 * structure for passing information to DDHAL GetVideoSignalStatus fn
 */
typedef struct _DD_GETVPORTSIGNALDATA
{
    PDD_DIRECTDRAW_LOCAL        lpDD;                 // driver struct
    PDD_VIDEOPORT_LOCAL         lpVideoPort;          // Video port object
    DWORD                       dwStatus;             // Video signal status
    HRESULT                     ddRVal;               // return value
    VOID*                       GetVideoSignalStatus; // Unused: Win95 compatibility
} DD_GETVPORTSIGNALDATA;

/*
 * structure for passing information to DDHAL GetVideoSignalStatus fn
 */
typedef struct _DD_VPORTCOLORDATA
{
    PDD_DIRECTDRAW_LOCAL        lpDD;         // driver struct
    PDD_VIDEOPORT_LOCAL         lpVideoPort;  // Video port object
    DWORD                       dwFlags;      // Video signal status
    LPDDCOLORCONTROL            lpColorData;
    HRESULT                     ddRVal;       // return value
    VOID*                       ColorControl; // Unused: Win95 compatibility
} DD_VPORTCOLORDATA;

#define DDRAWI_VPORTGETCOLOR    0x0001
#define DDRAWI_VPORTSETCOLOR    0x0002

/****************************************************************************
 *
 * DDHAL structures for Color Control callbacks
 *
 ***************************************************************************/

/*
 * structure for passing information to DDHAL ColorControl fn
 */
typedef struct _DD_COLORCONTROLDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    PDD_SURFACE_LOCAL           lpDDSurface;    // surface
    LPDDCOLORCONTROL            lpColorData;    // color control information
    DWORD                       dwFlags;        // DDRAWI_GETCOLOR/DDRAWI_SETCOLOR
    HRESULT                     ddRVal;         // return value
    VOID*                       ColorControl;   // Unused: Win95 compatibility
} DD_COLORCONTROLDATA;

#define DDRAWI_GETCOLOR         0x0001
#define DDRAWI_SETCOLOR         0x0002

/****************************************************************************
 *
 * DDHAL structure for GetDriverData callback
 *
 ***************************************************************************/

typedef struct _DD_GETDRIVERINFODATA {

    // Input fields filled in by DirectDraw

    VOID*                       dhpdev;         // Driver context
    DWORD                       dwSize;         // Size of this structure
    DWORD                       dwFlags;        // Flags
    GUID                        guidInfo;       // GUID that DirectX is querying for
    DWORD                       dwExpectedSize; // Size of callbacks structure expected by DirectDraw.
    PVOID                       lpvData;        // Buffer that will receive the requested data

    // Output fields filled in by driver

    DWORD                       dwActualSize;   // Size of callbacks structure expected by driver
    HRESULT                     ddRVal;         // Return value from driver

} DD_GETDRIVERINFODATA;

/****************************************************************************
 *
 * DDHAL structure for misc. driver callbacks
 *
 ***************************************************************************/

/*
 * structure for passing information to DDHAL GetAvailDriverMemory fn
 */
typedef struct _DD_GETAVAILDRIVERMEMORYDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;            // driver struct
    DDSCAPS                     DDSCaps;         // caps for type of surface memory
    DWORD                       dwTotal;         // total memory for this kind of surface
    DWORD                       dwFree;          // free memory for this kind of surface
    HRESULT                     ddRVal;          // return value
    VOID*                       GetAvailDriverMemory; // Unused: Win95 compatibility
} DD_GETAVAILDRIVERMEMORYDATA;


/****************************************************************************
 *
 * DDHAL structures for NT callbacks
 *
 ***************************************************************************/

/*
 * structure for passing information to DDHAL FreeDriverMemory fn
 */
typedef struct _DD_FREEDRIVERMEMORYDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;            // driver struct
    PDD_SURFACE_LOCAL           lpDDSurface;     // surface object trying to be created
    HRESULT                     ddRVal;          // return value
    VOID*                       FreeDriverMemory;// Unused: Win95 compatibility
} DD_FREEDRIVERMEMORYDATA;

/*
 * structure for passing information to DDHAL SetExclusiveMode fn
 */
typedef struct _DD_SETEXCLUSIVEMODEDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    DWORD                       dwEnterExcl;    // TRUE if entering exclusive mode, FALSE is leaving
    DWORD                       dwReserved;     // reserved for future use
    HRESULT                     ddRVal;         // return value
    VOID*                       SetExclusiveMode; // Unused: Win95 compatibility
} DD_SETEXCLUSIVEMODEDATA;

/*
 * structure for passing information to DDHAL FlipToGDISurface fn
 */
typedef struct _DD_FLIPTOGDISURFACEDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    DWORD                       dwToGDI;        // TRUE if flipping to the GDI surface, FALSE if flipping away
    DWORD                       dwReserved;     // reserved for future use
    HRESULT                     ddRVal;         // return value
    VOID*                       FlipToGDISurface; // Unused: Win95 compatibility
} DD_FLIPTOGDISURFACEDATA;

/****************************************************************************
 *
 * DDHAL structure for kernel callbacks
 *
 ***************************************************************************/

/*
 * structure for passing information to DDHAL SyncSurfaceData fn
 */
typedef struct _DD_SYNCSURFACEDATA
{
    PDD_DIRECTDRAW_LOCAL   lpDD;        // driver struct
    PDD_SURFACE_LOCAL      lpDDSurface; // Surface to sync with
    DWORD       dwSurfaceOffset;        // Offset in frame buffer of surface
    ULONG_PTR    fpLockPtr;              // Surface lock ptr
    LONG        lPitch;                 // Surface pitch
    DWORD       dwOverlayOffset;        // Added to dwSurfaceOffset for origin, clipping, etc.
    ULONG       dwDriverReserved1;      // Reserved for the HAL
    ULONG       dwDriverReserved2;      // Reserved for the HAL
    ULONG       dwDriverReserved3;      // Reserved for the HAL
    ULONG       dwDriverReserved4;      // Reserved for the HAL
    HRESULT     ddRVal;
} DD_SYNCSURFACEDATA;

/*
 * structure for passing information to DDHAL SyncVideoPortData fn
 */
typedef struct _DD_SYNCVIDEOPORTDATA
{
    PDD_DIRECTDRAW_LOCAL    lpDD;       // driver struct
    PDD_VIDEOPORT_LOCAL     lpVideoPort;// Video port object
    DWORD       dwOriginOffset;         // Start address relative to surface
    DWORD       dwHeight;               // Height of total video region (per field)
    DWORD       dwVBIHeight;            // Height of VBI region (per field)
    ULONG       dwDriverReserved1;      // Reserved for the HAL
    ULONG       dwDriverReserved2;      // Reserved for the HAL
    ULONG       dwDriverReserved3;      // Reserved for the HAL
    HRESULT     ddRVal;
} DD_SYNCVIDEOPORTDATA;

/****************************************************************************
 *
 * DDHAL structure for motion comp callbacks
 *
 ***************************************************************************/

/*
 * structure for passing information to DDHAL GetMoCompGuids
 */
typedef struct _DD_GETMOCOMPGUIDSDATA
{
    PDD_DIRECTDRAW_LOCAL      lpDD;
    DWORD                     dwNumGuids;
    GUID*                     lpGuids;
    HRESULT                   ddRVal;
} DD_GETMOCOMPGUIDSDATA;

/*
 * structure for passing information to DDHAL GetMoCompFormats
 */
typedef struct _DD_GETMOCOMPFORMATSDATA
{
    PDD_DIRECTDRAW_LOCAL      lpDD;
    GUID*                     lpGuid;
    DWORD                     dwNumFormats;
    LPDDPIXELFORMAT           lpFormats;
    HRESULT                   ddRVal;
} DD_GETMOCOMPFORMATSDATA;

/*
 * structure for passing information to DDHAL CreateMoComp
 */
typedef struct _DD_CREATEMOCOMPDATA
{
    PDD_DIRECTDRAW_LOCAL      lpDD;
    PDD_MOTIONCOMP_LOCAL      lpMoComp;
    GUID*                     lpGuid;
    DWORD                     dwUncompWidth;
    DWORD                     dwUncompHeight;
    DDPIXELFORMAT             ddUncompPixelFormat;
    LPVOID                    lpData;
    DWORD                     dwDataSize;
    HRESULT                   ddRVal;
} DD_CREATEMOCOMPDATA;

/*
 * structure for passing information to DDHAL GetMoCompBuffInfo
 */
typedef struct _DDCOMPBUFFERINFO
{
    DWORD                     dwSize;             // [in]   size of the struct
    DWORD                     dwNumCompBuffers;   // [out]  number of buffers required for compressed data
    DWORD                     dwWidthToCreate;    // [out]    Width of surface to create
    DWORD                     dwHeightToCreate;   // [out]    Height of surface to create
    DWORD                     dwBytesToAllocate;  // [out]    Total number of bytes used by each surface
    DDSCAPS2                  ddCompCaps;         // [out]    caps to create surfaces to store compressed data
    DDPIXELFORMAT             ddPixelFormat;      // [out]  format to create surfaces to store compressed data
} DDCOMPBUFFERINFO, *LPDDCOMPBUFFERINFO;

typedef struct _DD_GETMOCOMPCOMPBUFFDATA
{
    PDD_DIRECTDRAW_LOCAL      lpDD;
    GUID*                     lpGuid;
    DWORD                     dwWidth;            // [in]   width of uncompressed data
    DWORD                     dwHeight;           // [in]   height of uncompressed data
    DDPIXELFORMAT             ddPixelFormat;      // [in]   pixel-format of uncompressed data
    DWORD                     dwNumTypesCompBuffs;// [in/out] number of memory types required for comp buffers
    LPDDCOMPBUFFERINFO        lpCompBuffInfo;     // [in]   driver supplied info regarding comp buffers (allocated by client)
    HRESULT                   ddRVal;             // [out]
} DD_GETMOCOMPCOMPBUFFDATA;

/*
 * structure for passing information to DDHAL GetMoCompBuffInfo
 */
typedef struct _DD_GETINTERNALMOCOMPDATA
{
    PDD_DIRECTDRAW_LOCAL      lpDD;
    GUID*                     lpGuid;
    DWORD                     dwWidth;            // [in]   width of uncompressed data
    DWORD                     dwHeight;           // [in]   height of uncompressed data
    DDPIXELFORMAT             ddPixelFormat;      // [in]   pixel-format of uncompressed data
    DWORD                     dwScratchMemAlloc;  // [out]  amount of scratch memory will the hal allocate for its private use
    HRESULT                   ddRVal;             // [out]
} DD_GETINTERNALMOCOMPDATA;

/*
 * structure for passing information to DDHAL BeginMoCompFrame
 */
typedef struct _DD_BEGINMOCOMPFRAMEDATA
{
    PDD_DIRECTDRAW_LOCAL      lpDD;
    PDD_MOTIONCOMP_LOCAL      lpMoComp;
    PDD_SURFACE_LOCAL         lpDestSurface;        // [in]  destination buffer in which to decoding this frame
    DWORD                     dwInputDataSize;      // [in]  size of other misc input data to begin frame
    LPVOID                    lpInputData;          // [in]  pointer to misc input data
    DWORD                     dwOutputDataSize;     // [in]  size of other misc output data to begin frame
    LPVOID                    lpOutputData;         // [in]  pointer to output misc data (allocated by client)
    HRESULT                   ddRVal;               // [out]
} DD_BEGINMOCOMPFRAMEDATA;

/*
 * structure for passing information to DDHAL EndMoCompFrame
 */
typedef struct _DD_ENDMOCOMPFRAMEDATA
{
    PDD_DIRECTDRAW_LOCAL      lpDD;
    PDD_MOTIONCOMP_LOCAL      lpMoComp;
    LPVOID                    lpInputData;
    DWORD                     dwInputDataSize;
    HRESULT                   ddRVal;
} DD_ENDMOCOMPFRAMEDATA;

/*
 * structure for passing information to DDHAL RenderMoComp
 */
typedef struct _DDMOCOMPBUFFERINFO
{
    DWORD                     dwSize;         // [in]    size of the struct
    PDD_SURFACE_LOCAL         lpCompSurface;  // [in]    pointer to buffer containing compressed data
    DWORD                     dwDataOffset;   // [in]    offset of relevant data from the beginning of buffer
    DWORD                     dwDataSize;     // [in]    size of relevant data
    LPVOID                    lpPrivate;      // Reserved by DirectDraw
} DDMOCOMPBUFFERINFO, *LPDDMOCOMPBUFFERINFO;

typedef struct _DD_RENDERMOCOMPDATA
{
    PDD_DIRECTDRAW_LOCAL      lpDD;
    PDD_MOTIONCOMP_LOCAL      lpMoComp;
    DWORD                     dwNumBuffers;     // [in]  Number of entries in the lpMacroBlockInfo array
    LPDDMOCOMPBUFFERINFO      lpBufferInfo;     // [in]  Surfaces containing macro block info
    DWORD                     dwFunction;       // [in]  Function
    LPVOID                    lpInputData;
    DWORD                     dwInputDataSize;
    LPVOID                    lpOutputData;
    DWORD                     dwOutputDataSize;
    HRESULT                   ddRVal;           // [out]
} DD_RENDERMOCOMPDATA;

/*
 * structure for passing information to DDHAL QueryMoCompStatus
 */
typedef struct _DD_QUERYMOCOMPSTATUSDATA
{
    PDD_DIRECTDRAW_LOCAL      lpDD;
    PDD_MOTIONCOMP_LOCAL      lpMoComp;
    PDD_SURFACE_LOCAL         lpSurface;        // [in]  Surface being queried
    DWORD                     dwFlags;          // [in]  DDMCQUERY_XXX flags
    HRESULT                   ddRVal;            // [out]
} DD_QUERYMOCOMPSTATUSDATA;

#define DDMCQUERY_READ          0x00000001

/*
 * structure for passing information to DDHAL DestroyVideo
 */
typedef struct _DD_DESTROYMOCOMPDATA
{
    PDD_DIRECTDRAW_LOCAL      lpDD;
    PDD_MOTIONCOMP_LOCAL      lpMoComp;
    HRESULT                   ddRVal;
} DD_DESTROYMOCOMPDATA;


/****************************************************************************
 *
 * DDHAL structures for Miscellaneous2 callbacks
 *
 ***************************************************************************/
// This DDI is called by the kernel only.
typedef struct _DD_CREATESURFACEEXDATA
{
    DWORD                       dwFlags;
    PDD_DIRECTDRAW_LOCAL        lpDDLcl;        // driver struct
    PDD_SURFACE_LOCAL           lpDDSLcl;       // created surface
                                                // objects
    HRESULT                     ddRVal;         // return value
} DD_CREATESURFACEEXDATA;

// This DDI is used by both ddraw and d3d to obtain information from
// the driver.
typedef struct _DD_GETDRIVERSTATEDATA
{
    DWORD                       dwFlags;        // Flags to indicate the data
                                                // required
    union
    {
        PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
        DWORD_PTR                   dwhContext;     // d3d context
    };
    LPDWORD                     lpdwStates;     // ptr to the state data
                                                // to be filled in by the
                                                // driver
    DWORD                       dwLength;
    HRESULT                     ddRVal;         // return value
} DD_GETDRIVERSTATEDATA;

typedef struct _DD_DESTROYDDLOCALDATA
{
    DWORD dwFlags;
    PDD_DIRECTDRAW_LOCAL pDDLcl;
    HRESULT  ddRVal;
} DD_DESTROYDDLOCALDATA;


#ifdef __cplusplus
};
#endif

#endif  // GUID_DEFS_ONLY

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\public\oak\inc\dxmini.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dxmini.h
 *  Content:    Miniport support for DirectDraw DXAPI.  This file is
 *              analagous to Win95's ddkmmini.h.
 *
 ***************************************************************************/

#ifndef __DXMINI_INCLUDED__
#define __DXMINI_INCLUDED__

DEFINE_GUID(GUID_DxApi, 0x8a79bef0, 0xb915, 0x11d0, 0x91, 0x44, 0x08, 0x00, 0x36, 0xd2, 0xef, 0x02);

#ifndef GUID_DEFS_ONLY
/*============================================================================
 *
 * MDL structure for handling pagelocked memory.  This is copied from WDM.H
 *
 *==========================================================================*/

#ifndef MDL_MAPPING_FLAGS

    typedef struct _MDL {
        struct _MDL *MdlNext;
        short MdlSize;
        short MdlFlags;
        struct _EPROCESS *Process;
        ULONG *lpMappedSystemVa;
        ULONG *lpStartVa;
        ULONG ByteCount;
        ULONG ByteOffset;
    } MDL;
    typedef MDL *PMDL;

    #define MDL_MAPPED_TO_SYSTEM_VA     0x0001
    #define MDL_PAGES_LOCKED            0x0002
    #define MDL_SOURCE_IS_NONPAGED_POOL 0x0004
    #define MDL_ALLOCATED_FIXED_SIZE    0x0008
    #define MDL_PARTIAL                 0x0010
    #define MDL_PARTIAL_HAS_BEEN_MAPPED 0x0020
    #define MDL_IO_PAGE_READ            0x0040
    #define MDL_WRITE_OPERATION         0x0080
    #define MDL_PARENT_MAPPED_SYSTEM_VA 0x0100
    #define MDL_LOCK_HELD               0x0200
    #define MDL_SCATTER_GATHER_VA       0x0400
    #define MDL_IO_SPACE                0x0800
    #define MDL_NETWORK_HEADER          0x1000
    #define MDL_MAPPING_CAN_FAIL        0x2000
    #define MDL_ALLOCATED_MUST_SUCCEED  0x4000
    #define MDL_64_BIT_VA               0x8000

    #define MDL_MAPPING_FLAGS (MDL_MAPPED_TO_SYSTEM_VA     | \
                           MDL_PAGES_LOCKED            | \
                           MDL_SOURCE_IS_NONPAGED_POOL | \
                           MDL_PARTIAL_HAS_BEEN_MAPPED | \
                           MDL_PARENT_MAPPED_SYSTEM_VA | \
                           MDL_LOCK_HELD               | \
                           MDL_SYSTEM_VA               | \
                           MDL_IO_SPACE )
#endif

/*============================================================================
 *
 * Error values that may be returned by the miniport
 *
 *==========================================================================*/

#define DX_OK                                   0x0
#define DXERR_UNSUPPORTED                       0x80004001
#define DXERR_GENERIC                           0x80004005
#define DXERR_OUTOFCAPS                         0x88760168

/*============================================================================
 *
 * Structures maintained by DirectDraw
 *
 *==========================================================================*/

#define DDOVER_AUTOFLIP                       	0x00100000l
#define DDOVER_BOB                       	0x00200000l
#define DDOVER_OVERRIDEBOBWEAVE			0x00400000l
#define DDOVER_INTERLEAVED			0x00800000l

//
// Data for every DXAPI surface
//

typedef struct _DDSURFACEDATA {
    DWORD       ddsCaps;                // Ring 3 creation caps
    DWORD       dwSurfaceOffset;        // Offset in frame buffer of surface
    ULONG_PTR    fpLockPtr;              // Surface lock ptr
    DWORD       dwWidth;                // Surface width
    DWORD       dwHeight;               // Surface height
    LONG        lPitch;                 // Surface pitch
    DWORD       dwOverlayFlags;         // DDOVER_XX flags
    DWORD       dwOverlayOffset;        // Offset in frame buffer of overlay
    DWORD       dwOverlaySrcWidth;	// Src width of overlay
    DWORD       dwOverlaySrcHeight;	// Src height of overlay
    DWORD       dwOverlayDestWidth;	// Dest width of overlay
    DWORD       dwOverlayDestHeight;	// Dest height of overlay
    DWORD	dwVideoPortId;		// ID of video port (-1 if not connected to a video port)
    DWORD       dwFormatFlags;
    DWORD       dwFormatFourCC;
    DWORD       dwFormatBitCount;
    DWORD       dwRBitMask;
    DWORD       dwGBitMask;
    DWORD       dwBBitMask;
    ULONG       dwDriverReserved1;      // Reserved for the HAL/Miniport
    ULONG       dwDriverReserved2;      // Reserved for the HAL/Miniport
    ULONG       dwDriverReserved3;      // Reserved for the HAL/Miniport
    ULONG       dwDriverReserved4;      // Reserved for the HAL/Miniport
} DDSURFACEDATA, *LPDDSURFACEDATA;

//
// Data for every DXAPI video port
//

typedef struct DDVIDEOPORTDATA {
    DWORD       dwVideoPortId;          // ID of video port (0 - MaxVideoPorts-1)
    DWORD       dwVPFlags;              // Video port DDVP_ option flags
    DWORD       dwOriginOffset;         // Start address relative to surface
    DWORD       dwHeight;               // Height of total video region (per field)
    DWORD       dwVBIHeight;            // Height of VBI region (per field)
    ULONG       dwDriverReserved1;      // Reserved for the HAL/Miniport
    ULONG       dwDriverReserved2;      // Reserved for the HAL/Miniport
    ULONG       dwDriverReserved3;      // Reserved for the HAL/Miniport
} DDVIDEOPORTDATA, *LPDDVIDEOPORTDATA;


/*============================================================================
 *
 * Structures used to communicate with the Miniport
 *
 *==========================================================================*/

typedef struct _DX_IRQDATA {
    DWORD       dwIrqFlags;             // DDIRQ_ flags ORed in by miniport
} DX_IRQDATA, *PDX_IRQDATA;

typedef VOID (*PDX_IRQCALLBACK)(PDX_IRQDATA pIrqData);

#define DDIRQ_DISPLAY_VSYNC			0x00000001l
#define DDIRQ_BUSMASTER                         0x00000002l
#define DDIRQ_VPORT0_VSYNC			0x00000004l
#define DDIRQ_VPORT0_LINE			0x00000008l
#define DDIRQ_VPORT1_VSYNC			0x00000010l
#define DDIRQ_VPORT1_LINE			0x00000020l
#define DDIRQ_VPORT2_VSYNC			0x00000040l
#define DDIRQ_VPORT2_LINE			0x00000080l
#define DDIRQ_VPORT3_VSYNC			0x00000100l
#define DDIRQ_VPORT3_LINE			0x00000200l
#define DDIRQ_VPORT4_VSYNC			0x00000400l
#define DDIRQ_VPORT4_LINE			0x00000800l
#define DDIRQ_VPORT5_VSYNC			0x00001000l
#define DDIRQ_VPORT5_LINE			0x00002000l
#define DDIRQ_VPORT6_VSYNC			0x00004000l
#define DDIRQ_VPORT6_LINE			0x00008000l
#define DDIRQ_VPORT7_VSYNC			0x00010000l
#define DDIRQ_VPORT7_LINE			0x00020000l
#define DDIRQ_VPORT8_VSYNC			0x00040000l
#define DDIRQ_VPORT8_LINE			0x00080000l
#define DDIRQ_VPORT9_VSYNC			0x00010000l
#define DDIRQ_VPORT9_LINE			0x00020000l

// output from DxGetIrqInfo
typedef struct _DDGETIRQINFO {
    DWORD	dwFlags;
} DDGETIRQINFO, *PDDGETIRQINFO;
#define IRQINFO_HANDLED		0x01	// Miniport is managing IRQ
#define IRQINFO_NOTHANDLED	0x02	// Not supported on NT

// input to DxEnableIrq
typedef struct _DDENABLEIRQINFO {
    DWORD           dwIRQSources;
    DWORD           dwLine;             // Line for DDIRQ_VPORTx_LINE interrupt
    PDX_IRQCALLBACK IRQCallback;	// Miniport calls this when IRQ happens
    PDX_IRQDATA     lpIRQData;          // Parameter to be passed to IRQCallback
} DDENABLEIRQINFO, *PDDENABLEIRQINFO;

// input to DxSkipNextField
typedef struct _DDSKIPNEXTFIELDINFO {
    LPDDVIDEOPORTDATA   lpVideoPortData;
    DWORD               dwSkipFlags;
} DDSKIPNEXTFIELDINFO, *PDDSKIPNEXTFIELDINFO;

#define DDSKIP_SKIPNEXT                 1
#define DDSKIP_ENABLENEXT               2

// intput to DxBobNextField
typedef struct _DDBOBNEXTFIELDINFO {
    LPDDSURFACEDATA     lpSurface;
} DDBOBNEXTFIELDINFO, *PDDBOBNEXTFIELDINFO;

// intput to DxSetState
typedef struct _DDSETSTATEININFO {
    LPDDSURFACEDATA     lpSurfaceData;
    LPDDVIDEOPORTDATA   lpVideoPortData;
} DDSETSTATEININFO, *PDDSETSTATEININFO;

// output from DxSetState
typedef struct _DDSETSTATEOUTINFO {
    BOOL                bSoftwareAutoflip;
    DWORD               dwSurfaceIndex;
    DWORD               dwVBISurfaceIndex;
} DDSETSTATEOUTINFO, *PDDSETSTATEOUTINFO;

// input to DxLock
typedef struct _DDLOCKININFO {
    LPDDSURFACEDATA     lpSurfaceData;
} DDLOCKININFO, *PDDLOCKININFO;

// output from DxLock
typedef struct _DDLOCKOUTINFO {
    ULONG_PTR            dwSurfacePtr;
} DDLOCKOUTINFO, *PDDLOCKOUTINFO;

// input to DxFlipOverlay
typedef struct _DDFLIPOVERLAYINFO {
    LPDDSURFACEDATA     lpCurrentSurface;
    LPDDSURFACEDATA     lpTargetSurface;
    DWORD               dwFlags;
} DDFLIPOVERLAYINFO, *PDDFLIPOVERLAYINFO;

// intput to DxFlipVideoPort
typedef struct _DDFLIPVIDEOPORTINFO {
    LPDDVIDEOPORTDATA   lpVideoPortData;
    LPDDSURFACEDATA     lpCurrentSurface;
    LPDDSURFACEDATA     lpTargetSurface;
    DWORD               dwFlipVPFlags;
} DDFLIPVIDEOPORTINFO, *PDDFLIPVIDEOPORTINFO;

#define DDVPFLIP_VIDEO                  0x00000001l
#define DDVPFLIP_VBI                    0x00000002l

// input to DxGetPolarity
typedef struct _DDGETPOLARITYININFO {
    LPDDVIDEOPORTDATA   lpVideoPortData;
} DDGETPOLARITYININFO, *PDDGETPOLARITYININFO;

// output from DxGetPolarity
typedef struct _DDGETPOLARITYOUTINFO {
    DWORD               bPolarity;
} DDGETPOLARITYOUTINFO, *PDDGETPOLARITYOUTINFO;

// input to DxGetCurrentAutoflipSurface
typedef struct _DDGETCURRENTAUTOFLIPININFO {
    LPDDVIDEOPORTDATA   lpVideoPortData;
} DDGETCURRENTAUTOFLIPININFO, *PDDGETCURRENTAUTOFLIPININFO;

// output from DxGetCurrentAutoflipSurface
typedef struct _DDGETCURRENTAUTOFLIPOUTINFO {
    DWORD               dwSurfaceIndex;
    DWORD               dwVBISurfaceIndex;
} DDGETCURRENTAUTOFLIPOUTINFO, *PDDGETCURRENTAUTOFLIPOUTINFO;

// input to DxGetPreviousAutoflipSurface
typedef struct _DDGETPREVIOUSAUTOFLIPININFO {
    LPDDVIDEOPORTDATA   lpVideoPortData;
} DDGETPREVIOUSAUTOFLIPININFO, *PDDGETPREVIOUSAUTOFLIPININFO;

// output from DxGetPreviousAutoflipSurface
typedef struct _DDGETPREVIOUSAUTOFLIPOUTINFO {
    DWORD               dwSurfaceIndex;
    DWORD               dwVBISurfaceIndex;
} DDGETPREVIOUSAUTOFLIPOUTINFO, *PDDGETPREVIOUSAUTOFLIPOUTINFO;

// intput to DxTransfer
typedef struct _DDTRANSFERININFO {
    LPDDSURFACEDATA	lpSurfaceData;
    DWORD		dwStartLine;
    DWORD 		dwEndLine;
    ULONG_PTR   dwTransferID;
    DWORD 		dwTransferFlags;
    PMDL  		lpDestMDL;
} DDTRANSFERININFO, *PDDTRANSFERININFO;

#define DDTRANSFER_SYSTEMMEMORY		0x00000001
#define DDTRANSFER_NONLOCALVIDMEM	0x00000002
#define DDTRANSFER_INVERT		0x00000004
#define DDTRANSFER_CANCEL		0x00000080
#define DDTRANSFER_HALFLINES		0x00000100

// output from DxTransfer
typedef struct _DDTRANSFEROUTINFO {
    DWORD dwBufferPolarity;
} DDTRANSFEROUTINFO, *PDDTRANSFEROUTINFO;

// output from DxGetTransferStatus
typedef struct _DDGETTRANSFERSTATUSOUTINFO {
    DWORD_PTR dwTransferID;
} DDGETTRANSFERSTATUSOUTINFO, *PDDGETTRANSFEROUTINFO;

/*============================================================================
 *
 * DXAPI function prototypes
 *
 *==========================================================================*/

typedef DWORD (*PDX_GETIRQINFO)(PVOID,PVOID,PDDGETIRQINFO);
typedef DWORD (*PDX_ENABLEIRQ)(PVOID,PDDENABLEIRQINFO,PVOID);
typedef DWORD (*PDX_SKIPNEXTFIELD)(PVOID,PDDSKIPNEXTFIELDINFO,PVOID);
typedef DWORD (*PDX_BOBNEXTFIELD)(PVOID,PDDBOBNEXTFIELDINFO,PVOID);
typedef DWORD (*PDX_SETSTATE)(PVOID,PDDSETSTATEININFO,PDDSETSTATEOUTINFO);
typedef DWORD (*PDX_LOCK)(PVOID,PDDLOCKININFO,PDDLOCKOUTINFO);
typedef DWORD (*PDX_FLIPOVERLAY)(PVOID,PDDFLIPOVERLAYINFO,PVOID);
typedef DWORD (*PDX_FLIPVIDEOPORT)(PVOID,PDDFLIPVIDEOPORTINFO,PVOID);
typedef DWORD (*PDX_GETPOLARITY)(PVOID,PDDGETPOLARITYININFO,PDDGETPOLARITYOUTINFO);
typedef DWORD (*PDX_GETCURRENTAUTOFLIP)(PVOID,PDDGETCURRENTAUTOFLIPININFO,PDDGETCURRENTAUTOFLIPOUTINFO);
typedef DWORD (*PDX_GETPREVIOUSAUTOFLIP)(PVOID,PDDGETPREVIOUSAUTOFLIPININFO,PDDGETPREVIOUSAUTOFLIPOUTINFO);
typedef DWORD (*PDX_TRANSFER)(PVOID,PDDTRANSFERININFO,PDDTRANSFEROUTINFO);
typedef DWORD (*PDX_GETTRANSFERSTATUS)(PVOID,PVOID,PDDGETTRANSFEROUTINFO);

/*============================================================================
 *
 * HAL table filled in by the miniport and called by DirectDraw
 *
 *==========================================================================*/

#define DXAPI_HALVERSION 0x0001

typedef struct _DXAPI_INTERFACE {

    USHORT                  Size;
    USHORT                  Version;
    PVOID                   Context;
    PVOID                   InterfaceReference;
    PVOID                   InterfaceDereference;
    PDX_GETIRQINFO          DxGetIrqInfo;
    PDX_ENABLEIRQ           DxEnableIrq;
    PDX_SKIPNEXTFIELD       DxSkipNextField;
    PDX_BOBNEXTFIELD        DxBobNextField;
    PDX_SETSTATE            DxSetState;
    PDX_LOCK                DxLock;
    PDX_FLIPOVERLAY         DxFlipOverlay;
    PDX_FLIPVIDEOPORT       DxFlipVideoPort;
    PDX_GETPOLARITY         DxGetPolarity;
    PDX_GETCURRENTAUTOFLIP  DxGetCurrentAutoflip;
    PDX_GETPREVIOUSAUTOFLIP DxGetPreviousAutoflip;
    PDX_TRANSFER	    DxTransfer;
    PDX_GETTRANSFERSTATUS   DxGetTransferStatus;

} DXAPI_INTERFACE, *PDXAPI_INTERFACE;

#endif  // GUID_DEFS_ONLY

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\public\oak\inc\gldrv.h ===
/*++ BUILD Version: 0001

Copyright (c) 1985-94, Microsoft Corporation

Module Name:

    gldrv.h

Abstract:

    Private entry points, defines and types for Installable OpenGL DDI.

--*/

#ifndef _GLDRV_
#define _GLDRV_

typedef struct _GLDISPATCHTABLE {
    void      (APIENTRY *glNewList                )( GLuint list, GLenum mode );
    void      (APIENTRY *glEndList                )( void );
    void      (APIENTRY *glCallList               )( GLuint list );
    void      (APIENTRY *glCallLists              )( GLsizei n, GLenum type, const GLvoid *lists );
    void      (APIENTRY *glDeleteLists            )( GLuint list, GLsizei range );
    GLuint    (APIENTRY *glGenLists               )( GLsizei range );
    void      (APIENTRY *glListBase               )( GLuint base );
    void      (APIENTRY *glBegin                  )( GLenum mode );
    void      (APIENTRY *glBitmap                 )( GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *bitmap );
    void      (APIENTRY *glColor3b                )( GLbyte red, GLbyte green, GLbyte blue );
    void      (APIENTRY *glColor3bv               )( const GLbyte *v );
    void      (APIENTRY *glColor3d                )( GLdouble red, GLdouble green, GLdouble blue );
    void      (APIENTRY *glColor3dv               )( const GLdouble *v );
    void      (APIENTRY *glColor3f                )( GLfloat red, GLfloat green, GLfloat blue );
    void      (APIENTRY *glColor3fv               )( const GLfloat *v );
    void      (APIENTRY *glColor3i                )( GLint red, GLint green, GLint blue );
    void      (APIENTRY *glColor3iv               )( const GLint *v );
    void      (APIENTRY *glColor3s                )( GLshort red, GLshort green, GLshort blue );
    void      (APIENTRY *glColor3sv               )( const GLshort *v );
    void      (APIENTRY *glColor3ub               )( GLubyte red, GLubyte green, GLubyte blue );
    void      (APIENTRY *glColor3ubv              )( const GLubyte *v );
    void      (APIENTRY *glColor3ui               )( GLuint red, GLuint green, GLuint blue );
    void      (APIENTRY *glColor3uiv              )( const GLuint *v );
    void      (APIENTRY *glColor3us               )( GLushort red, GLushort green, GLushort blue );
    void      (APIENTRY *glColor3usv              )( const GLushort *v );
    void      (APIENTRY *glColor4b                )( GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha );
    void      (APIENTRY *glColor4bv               )( const GLbyte *v );
    void      (APIENTRY *glColor4d                )( GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha );
    void      (APIENTRY *glColor4dv               )( const GLdouble *v );
    void      (APIENTRY *glColor4f                )( GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha );
    void      (APIENTRY *glColor4fv               )( const GLfloat *v );
    void      (APIENTRY *glColor4i                )( GLint red, GLint green, GLint blue, GLint alpha );
    void      (APIENTRY *glColor4iv               )( const GLint *v );
    void      (APIENTRY *glColor4s                )( GLshort red, GLshort green, GLshort blue, GLshort alpha );
    void      (APIENTRY *glColor4sv               )( const GLshort *v );
    void      (APIENTRY *glColor4ub               )( GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha );
    void      (APIENTRY *glColor4ubv              )( const GLubyte *v );
    void      (APIENTRY *glColor4ui               )( GLuint red, GLuint green, GLuint blue, GLuint alpha );
    void      (APIENTRY *glColor4uiv              )( const GLuint *v );
    void      (APIENTRY *glColor4us               )( GLushort red, GLushort green, GLushort blue, GLushort alpha );
    void      (APIENTRY *glColor4usv              )( const GLushort *v );
    void      (APIENTRY *glEdgeFlag               )( GLboolean flag );
    void      (APIENTRY *glEdgeFlagv              )( const GLboolean *flag );
    void      (APIENTRY *glEnd                    )( void );
    void      (APIENTRY *glIndexd                 )( GLdouble c );
    void      (APIENTRY *glIndexdv                )( const GLdouble *c );
    void      (APIENTRY *glIndexf                 )( GLfloat c );
    void      (APIENTRY *glIndexfv                )( const GLfloat *c );
    void      (APIENTRY *glIndexi                 )( GLint c );
    void      (APIENTRY *glIndexiv                )( const GLint *c );
    void      (APIENTRY *glIndexs                 )( GLshort c );
    void      (APIENTRY *glIndexsv                )( const GLshort *c );
    void      (APIENTRY *glNormal3b               )( GLbyte nx, GLbyte ny, GLbyte nz );
    void      (APIENTRY *glNormal3bv              )( const GLbyte *v );
    void      (APIENTRY *glNormal3d               )( GLdouble nx, GLdouble ny, GLdouble nz );
    void      (APIENTRY *glNormal3dv              )( const GLdouble *v );
    void      (APIENTRY *glNormal3f               )( GLfloat nx, GLfloat ny, GLfloat nz );
    void      (APIENTRY *glNormal3fv              )( const GLfloat *v );
    void      (APIENTRY *glNormal3i               )( GLint nx, GLint ny, GLint nz );
    void      (APIENTRY *glNormal3iv              )( const GLint *v );
    void      (APIENTRY *glNormal3s               )( GLshort nx, GLshort ny, GLshort nz );
    void      (APIENTRY *glNormal3sv              )( const GLshort *v );
    void      (APIENTRY *glRasterPos2d            )( GLdouble x, GLdouble y );
    void      (APIENTRY *glRasterPos2dv           )( const GLdouble *v );
    void      (APIENTRY *glRasterPos2f            )( GLfloat x, GLfloat y );
    void      (APIENTRY *glRasterPos2fv           )( const GLfloat *v );
    void      (APIENTRY *glRasterPos2i            )( GLint x, GLint y );
    void      (APIENTRY *glRasterPos2iv           )( const GLint *v );
    void      (APIENTRY *glRasterPos2s            )( GLshort x, GLshort y );
    void      (APIENTRY *glRasterPos2sv           )( const GLshort *v );
    void      (APIENTRY *glRasterPos3d            )( GLdouble x, GLdouble y, GLdouble z );
    void      (APIENTRY *glRasterPos3dv           )( const GLdouble *v );
    void      (APIENTRY *glRasterPos3f            )( GLfloat x, GLfloat y, GLfloat z );
    void      (APIENTRY *glRasterPos3fv           )( const GLfloat *v );
    void      (APIENTRY *glRasterPos3i            )( GLint x, GLint y, GLint z );
    void      (APIENTRY *glRasterPos3iv           )( const GLint *v );
    void      (APIENTRY *glRasterPos3s            )( GLshort x, GLshort y, GLshort z );
    void      (APIENTRY *glRasterPos3sv           )( const GLshort *v );
    void      (APIENTRY *glRasterPos4d            )( GLdouble x, GLdouble y, GLdouble z, GLdouble w );
    void      (APIENTRY *glRasterPos4dv           )( const GLdouble *v );
    void      (APIENTRY *glRasterPos4f            )( GLfloat x, GLfloat y, GLfloat z, GLfloat w );
    void      (APIENTRY *glRasterPos4fv           )( const GLfloat *v );
    void      (APIENTRY *glRasterPos4i            )( GLint x, GLint y, GLint z, GLint w );
    void      (APIENTRY *glRasterPos4iv           )( const GLint *v );
    void      (APIENTRY *glRasterPos4s            )( GLshort x, GLshort y, GLshort z, GLshort w );
    void      (APIENTRY *glRasterPos4sv           )( const GLshort *v );
    void      (APIENTRY *glRectd                  )( GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2 );
    void      (APIENTRY *glRectdv                 )( const GLdouble *v1, const GLdouble *v2 );
    void      (APIENTRY *glRectf                  )( GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2 );
    void      (APIENTRY *glRectfv                 )( const GLfloat *v1, const GLfloat *v2 );
    void      (APIENTRY *glRecti                  )( GLint x1, GLint y1, GLint x2, GLint y2 );
    void      (APIENTRY *glRectiv                 )( const GLint *v1, const GLint *v2 );
    void      (APIENTRY *glRects                  )( GLshort x1, GLshort y1, GLshort x2, GLshort y2 );
    void      (APIENTRY *glRectsv                 )( const GLshort *v1, const GLshort *v2 );
    void      (APIENTRY *glTexCoord1d             )( GLdouble s );
    void      (APIENTRY *glTexCoord1dv            )( const GLdouble *v );
    void      (APIENTRY *glTexCoord1f             )( GLfloat s );
    void      (APIENTRY *glTexCoord1fv            )( const GLfloat *v );
    void      (APIENTRY *glTexCoord1i             )( GLint s );
    void      (APIENTRY *glTexCoord1iv            )( const GLint *v );
    void      (APIENTRY *glTexCoord1s             )( GLshort s );
    void      (APIENTRY *glTexCoord1sv            )( const GLshort *v );
    void      (APIENTRY *glTexCoord2d             )( GLdouble s, GLdouble t );
    void      (APIENTRY *glTexCoord2dv            )( const GLdouble *v );
    void      (APIENTRY *glTexCoord2f             )( GLfloat s, GLfloat t );
    void      (APIENTRY *glTexCoord2fv            )( const GLfloat *v );
    void      (APIENTRY *glTexCoord2i             )( GLint s, GLint t );
    void      (APIENTRY *glTexCoord2iv            )( const GLint *v );
    void      (APIENTRY *glTexCoord2s             )( GLshort s, GLshort t );
    void      (APIENTRY *glTexCoord2sv            )( const GLshort *v );
    void      (APIENTRY *glTexCoord3d             )( GLdouble s, GLdouble t, GLdouble r );
    void      (APIENTRY *glTexCoord3dv            )( const GLdouble *v );
    void      (APIENTRY *glTexCoord3f             )( GLfloat s, GLfloat t, GLfloat r );
    void      (APIENTRY *glTexCoord3fv            )( const GLfloat *v );
    void      (APIENTRY *glTexCoord3i             )( GLint s, GLint t, GLint r );
    void      (APIENTRY *glTexCoord3iv            )( const GLint *v );
    void      (APIENTRY *glTexCoord3s             )( GLshort s, GLshort t, GLshort r );
    void      (APIENTRY *glTexCoord3sv            )( const GLshort *v );
    void      (APIENTRY *glTexCoord4d             )( GLdouble s, GLdouble t, GLdouble r, GLdouble q );
    void      (APIENTRY *glTexCoord4dv            )( const GLdouble *v );
    void      (APIENTRY *glTexCoord4f             )( GLfloat s, GLfloat t, GLfloat r, GLfloat q );
    void      (APIENTRY *glTexCoord4fv            )( const GLfloat *v );
    void      (APIENTRY *glTexCoord4i             )( GLint s, GLint t, GLint r, GLint q );
    void      (APIENTRY *glTexCoord4iv            )( const GLint *v );
    void      (APIENTRY *glTexCoord4s             )( GLshort s, GLshort t, GLshort r, GLshort q );
    void      (APIENTRY *glTexCoord4sv            )( const GLshort *v );
    void      (APIENTRY *glVertex2d               )( GLdouble x, GLdouble y );
    void      (APIENTRY *glVertex2dv              )( const GLdouble *v );
    void      (APIENTRY *glVertex2f               )( GLfloat x, GLfloat y );
    void      (APIENTRY *glVertex2fv              )( const GLfloat *v );
    void      (APIENTRY *glVertex2i               )( GLint x, GLint y );
    void      (APIENTRY *glVertex2iv              )( const GLint *v );
    void      (APIENTRY *glVertex2s               )( GLshort x, GLshort y );
    void      (APIENTRY *glVertex2sv              )( const GLshort *v );
    void      (APIENTRY *glVertex3d               )( GLdouble x, GLdouble y, GLdouble z );
    void      (APIENTRY *glVertex3dv              )( const GLdouble *v );
    void      (APIENTRY *glVertex3f               )( GLfloat x, GLfloat y, GLfloat z );
    void      (APIENTRY *glVertex3fv              )( const GLfloat *v );
    void      (APIENTRY *glVertex3i               )( GLint x, GLint y, GLint z );
    void      (APIENTRY *glVertex3iv              )( const GLint *v );
    void      (APIENTRY *glVertex3s               )( GLshort x, GLshort y, GLshort z );
    void      (APIENTRY *glVertex3sv              )( const GLshort *v );
    void      (APIENTRY *glVertex4d               )( GLdouble x, GLdouble y, GLdouble z, GLdouble w );
    void      (APIENTRY *glVertex4dv              )( const GLdouble *v );
    void      (APIENTRY *glVertex4f               )( GLfloat x, GLfloat y, GLfloat z, GLfloat w );
    void      (APIENTRY *glVertex4fv              )( const GLfloat *v );
    void      (APIENTRY *glVertex4i               )( GLint x, GLint y, GLint z, GLint w );
    void      (APIENTRY *glVertex4iv              )( const GLint *v );
    void      (APIENTRY *glVertex4s               )( GLshort x, GLshort y, GLshort z, GLshort w );
    void      (APIENTRY *glVertex4sv              )( const GLshort *v );
    void      (APIENTRY *glClipPlane              )( GLenum plane, const GLdouble *equation );
    void      (APIENTRY *glColorMaterial          )( GLenum face, GLenum mode );
    void      (APIENTRY *glCullFace               )( GLenum mode );
    void      (APIENTRY *glFogf                   )( GLenum pname, GLfloat param );
    void      (APIENTRY *glFogfv                  )( GLenum pname, const GLfloat *params );
    void      (APIENTRY *glFogi                   )( GLenum pname, GLint param );
    void      (APIENTRY *glFogiv                  )( GLenum pname, const GLint *params );
    void      (APIENTRY *glFrontFace              )( GLenum mode );
    void      (APIENTRY *glHint                   )( GLenum target, GLenum mode );
    void      (APIENTRY *glLightf                 )( GLenum light, GLenum pname, GLfloat param );
    void      (APIENTRY *glLightfv                )( GLenum light, GLenum pname, const GLfloat *params );
    void      (APIENTRY *glLighti                 )( GLenum light, GLenum pname, GLint param );
    void      (APIENTRY *glLightiv                )( GLenum light, GLenum pname, const GLint *params );
    void      (APIENTRY *glLightModelf            )( GLenum pname, GLfloat param );
    void      (APIENTRY *glLightModelfv           )( GLenum pname, const GLfloat *params );
    void      (APIENTRY *glLightModeli            )( GLenum pname, GLint param );
    void      (APIENTRY *glLightModeliv           )( GLenum pname, const GLint *params );
    void      (APIENTRY *glLineStipple            )( GLint factor, GLushort pattern );
    void      (APIENTRY *glLineWidth              )( GLfloat width );
    void      (APIENTRY *glMaterialf              )( GLenum face, GLenum pname, GLfloat param );
    void      (APIENTRY *glMaterialfv             )( GLenum face, GLenum pname, const GLfloat *params );
    void      (APIENTRY *glMateriali              )( GLenum face, GLenum pname, GLint param );
    void      (APIENTRY *glMaterialiv             )( GLenum face, GLenum pname, const GLint *params );
    void      (APIENTRY *glPointSize              )( GLfloat size );
    void      (APIENTRY *glPolygonMode            )( GLenum face, GLenum mode );
    void      (APIENTRY *glPolygonStipple         )( const GLubyte *mask );
    void      (APIENTRY *glScissor                )( GLint x, GLint y, GLsizei width, GLsizei height );
    void      (APIENTRY *glShadeModel             )( GLenum mode );
    void      (APIENTRY *glTexParameterf          )( GLenum target, GLenum pname, GLfloat param );
    void      (APIENTRY *glTexParameterfv         )( GLenum target, GLenum pname, const GLfloat *params );
    void      (APIENTRY *glTexParameteri          )( GLenum target, GLenum pname, GLint param );
    void      (APIENTRY *glTexParameteriv         )( GLenum target, GLenum pname, const GLint *params );
    void      (APIENTRY *glTexImage1D             )( GLenum target, GLint level, GLint components, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels );
    void      (APIENTRY *glTexImage2D             )( GLenum target, GLint level, GLint components, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels );
    void      (APIENTRY *glTexEnvf                )( GLenum target, GLenum pname, GLfloat param );
    void      (APIENTRY *glTexEnvfv               )( GLenum target, GLenum pname, const GLfloat *params );
    void      (APIENTRY *glTexEnvi                )( GLenum target, GLenum pname, GLint param );
    void      (APIENTRY *glTexEnviv               )( GLenum target, GLenum pname, const GLint *params );
    void      (APIENTRY *glTexGend                )( GLenum coord, GLenum pname, GLdouble param );
    void      (APIENTRY *glTexGendv               )( GLenum coord, GLenum pname, const GLdouble *params );
    void      (APIENTRY *glTexGenf                )( GLenum coord, GLenum pname, GLfloat param );
    void      (APIENTRY *glTexGenfv               )( GLenum coord, GLenum pname, const GLfloat *params );
    void      (APIENTRY *glTexGeni                )( GLenum coord, GLenum pname, GLint param );
    void      (APIENTRY *glTexGeniv               )( GLenum coord, GLenum pname, const GLint *params );
    void      (APIENTRY *glFeedbackBuffer         )( GLsizei size, GLenum type, GLfloat *buffer );
    void      (APIENTRY *glSelectBuffer           )( GLsizei size, GLuint *buffer );
    GLint     (APIENTRY *glRenderMode             )( GLenum mode );
    void      (APIENTRY *glInitNames              )( void );
    void      (APIENTRY *glLoadName               )( GLuint name );
    void      (APIENTRY *glPassThrough            )( GLfloat token );
    void      (APIENTRY *glPopName                )( void );
    void      (APIENTRY *glPushName               )( GLuint name );
    void      (APIENTRY *glDrawBuffer             )( GLenum mode );
    void      (APIENTRY *glClear                  )( GLbitfield mask );
    void      (APIENTRY *glClearAccum             )( GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha );
    void      (APIENTRY *glClearIndex             )( GLfloat c );
    void      (APIENTRY *glClearColor             )( GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha );
    void      (APIENTRY *glClearStencil           )( GLint s );
    void      (APIENTRY *glClearDepth             )( GLclampd depth );
    void      (APIENTRY *glStencilMask            )( GLuint mask );
    void      (APIENTRY *glColorMask              )( GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha );
    void      (APIENTRY *glDepthMask              )( GLboolean flag );
    void      (APIENTRY *glIndexMask              )( GLuint mask );
    void      (APIENTRY *glAccum                  )( GLenum op, GLfloat value );
    void      (APIENTRY *glDisable                )( GLenum cap );
    void      (APIENTRY *glEnable                 )( GLenum cap );
    void      (APIENTRY *glFinish                 )( void );
    void      (APIENTRY *glFlush                  )( void );
    void      (APIENTRY *glPopAttrib              )( void );
    void      (APIENTRY *glPushAttrib             )( GLbitfield mask );
    void      (APIENTRY *glMap1d                  )( GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points );
    void      (APIENTRY *glMap1f                  )( GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points );
    void      (APIENTRY *glMap2d                  )( GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points );
    void      (APIENTRY *glMap2f                  )( GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points );
    void      (APIENTRY *glMapGrid1d              )( GLint un, GLdouble u1, GLdouble u2 );
    void      (APIENTRY *glMapGrid1f              )( GLint un, GLfloat u1, GLfloat u2 );
    void      (APIENTRY *glMapGrid2d              )( GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2 );
    void      (APIENTRY *glMapGrid2f              )( GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2 );
    void      (APIENTRY *glEvalCoord1d            )( GLdouble u );
    void      (APIENTRY *glEvalCoord1dv           )( const GLdouble *u );
    void      (APIENTRY *glEvalCoord1f            )( GLfloat u );
    void      (APIENTRY *glEvalCoord1fv           )( const GLfloat *u );
    void      (APIENTRY *glEvalCoord2d            )( GLdouble u, GLdouble v );
    void      (APIENTRY *glEvalCoord2dv           )( const GLdouble *u );
    void      (APIENTRY *glEvalCoord2f            )( GLfloat u, GLfloat v );
    void      (APIENTRY *glEvalCoord2fv           )( const GLfloat *u );
    void      (APIENTRY *glEvalMesh1              )( GLenum mode, GLint i1, GLint i2 );
    void      (APIENTRY *glEvalPoint1             )( GLint i );
    void      (APIENTRY *glEvalMesh2              )( GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2 );
    void      (APIENTRY *glEvalPoint2             )( GLint i, GLint j );
    void      (APIENTRY *glAlphaFunc              )( GLenum func, GLclampf ref );
    void      (APIENTRY *glBlendFunc              )( GLenum sfactor, GLenum dfactor );
    void      (APIENTRY *glLogicOp                )( GLenum opcode );
    void      (APIENTRY *glStencilFunc            )( GLenum func, GLint ref, GLuint mask );
    void      (APIENTRY *glStencilOp              )( GLenum fail, GLenum zfail, GLenum zpass );
    void      (APIENTRY *glDepthFunc              )( GLenum func );
    void      (APIENTRY *glPixelZoom              )( GLfloat xfactor, GLfloat yfactor );
    void      (APIENTRY *glPixelTransferf         )( GLenum pname, GLfloat param );
    void      (APIENTRY *glPixelTransferi         )( GLenum pname, GLint param );
    void      (APIENTRY *glPixelStoref            )( GLenum pname, GLfloat param );
    void      (APIENTRY *glPixelStorei            )( GLenum pname, GLint param );
    void      (APIENTRY *glPixelMapfv             )( GLenum map, GLint mapsize, const GLfloat *values );
    void      (APIENTRY *glPixelMapuiv            )( GLenum map, GLint mapsize, const GLuint *values );
    void      (APIENTRY *glPixelMapusv            )( GLenum map, GLint mapsize, const GLushort *values );
    void      (APIENTRY *glReadBuffer             )( GLenum mode );
    void      (APIENTRY *glCopyPixels             )( GLint x, GLint y, GLsizei width, GLsizei height, GLenum type );
    void      (APIENTRY *glReadPixels             )( GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels );
    void      (APIENTRY *glDrawPixels             )( GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels );
    void      (APIENTRY *glGetBooleanv            )( GLenum pname, GLboolean *params );
    void      (APIENTRY *glGetClipPlane           )( GLenum plane, GLdouble *equation );
    void      (APIENTRY *glGetDoublev             )( GLenum pname, GLdouble *params );
    GLenum    (APIENTRY *glGetError               )( void );
    void      (APIENTRY *glGetFloatv              )( GLenum pname, GLfloat *params );
    void      (APIENTRY *glGetIntegerv            )( GLenum pname, GLint *params );
    void      (APIENTRY *glGetLightfv             )( GLenum light, GLenum pname, GLfloat *params );
    void      (APIENTRY *glGetLightiv             )( GLenum light, GLenum pname, GLint *params );
    void      (APIENTRY *glGetMapdv               )( GLenum target, GLenum query, GLdouble *v );
    void      (APIENTRY *glGetMapfv               )( GLenum target, GLenum query, GLfloat *v );
    void      (APIENTRY *glGetMapiv               )( GLenum target, GLenum query, GLint *v );
    void      (APIENTRY *glGetMaterialfv          )( GLenum face, GLenum pname, GLfloat *params );
    void      (APIENTRY *glGetMaterialiv          )( GLenum face, GLenum pname, GLint *params );
    void      (APIENTRY *glGetPixelMapfv          )( GLenum map, GLfloat *values );
    void      (APIENTRY *glGetPixelMapuiv         )( GLenum map, GLuint *values );
    void      (APIENTRY *glGetPixelMapusv         )( GLenum map, GLushort *values );
    void      (APIENTRY *glGetPolygonStipple      )( GLubyte *mask );
    const GLubyte * (APIENTRY *glGetString        )( GLenum name );
    void      (APIENTRY *glGetTexEnvfv            )( GLenum target, GLenum pname, GLfloat *params );
    void      (APIENTRY *glGetTexEnviv            )( GLenum target, GLenum pname, GLint *params );
    void      (APIENTRY *glGetTexGendv            )( GLenum coord, GLenum pname, GLdouble *params );
    void      (APIENTRY *glGetTexGenfv            )( GLenum coord, GLenum pname, GLfloat *params );
    void      (APIENTRY *glGetTexGeniv            )( GLenum coord, GLenum pname, GLint *params );
    void      (APIENTRY *glGetTexImage            )( GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels );
    void      (APIENTRY *glGetTexParameterfv      )( GLenum target, GLenum pname, GLfloat *params );
    void      (APIENTRY *glGetTexParameteriv      )( GLenum target, GLenum pname, GLint *params );
    void      (APIENTRY *glGetTexLevelParameterfv )( GLenum target, GLint level, GLenum pname, GLfloat *params );
    void      (APIENTRY *glGetTexLevelParameteriv )( GLenum target, GLint level, GLenum pname, GLint *params );
    GLboolean (APIENTRY *glIsEnabled              )( GLenum cap );
    GLboolean (APIENTRY *glIsList                 )( GLuint list );
    void      (APIENTRY *glDepthRange             )( GLclampd zNear, GLclampd zFar );
    void      (APIENTRY *glFrustum                )( GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar );
    void      (APIENTRY *glLoadIdentity           )( void );
    void      (APIENTRY *glLoadMatrixf            )( const GLfloat *m );
    void      (APIENTRY *glLoadMatrixd            )( const GLdouble *m );
    void      (APIENTRY *glMatrixMode             )( GLenum mode );
    void      (APIENTRY *glMultMatrixf            )( const GLfloat *m );
    void      (APIENTRY *glMultMatrixd            )( const GLdouble *m );
    void      (APIENTRY *glOrtho                  )( GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar );
    void      (APIENTRY *glPopMatrix              )( void );
    void      (APIENTRY *glPushMatrix             )( void );
    void      (APIENTRY *glRotated                )( GLdouble angle, GLdouble x, GLdouble y, GLdouble z );
    void      (APIENTRY *glRotatef                )( GLfloat angle, GLfloat x, GLfloat y, GLfloat z );
    void      (APIENTRY *glScaled                 )( GLdouble x, GLdouble y, GLdouble z );
    void      (APIENTRY *glScalef                 )( GLfloat x, GLfloat y, GLfloat z );
    void      (APIENTRY *glTranslated             )( GLdouble x, GLdouble y, GLdouble z );
    void      (APIENTRY *glTranslatef             )( GLfloat x, GLfloat y, GLfloat z );
    void      (APIENTRY *glViewport               )( GLint x, GLint y, GLsizei width, GLsizei height );
    // OpenGL version 1.0 entries end here

    // OpenGL version 1.1 entries begin here
    void      (APIENTRY *glArrayElement           )(GLint i);
    void      (APIENTRY *glBindTexture            )(GLenum target, GLuint texture);
    void      (APIENTRY *glColorPointer           )(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
    void      (APIENTRY *glDisableClientState     )(GLenum array);
    void      (APIENTRY *glDrawArrays             )(GLenum mode, GLint first, GLsizei count);
    void      (APIENTRY *glDrawElements           )(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices);
    void      (APIENTRY *glEdgeFlagPointer        )(GLsizei stride, const GLvoid *pointer);
    void      (APIENTRY *glEnableClientState      )(GLenum array);
    void      (APIENTRY *glIndexPointer           )(GLenum type, GLsizei stride, const GLvoid *pointer);
    void      (APIENTRY *glIndexub                )(GLubyte c);
    void      (APIENTRY *glIndexubv               )(const GLubyte *c);
    void      (APIENTRY *glInterleavedArrays      )(GLenum format, GLsizei stride, const GLvoid *pointer);
    void      (APIENTRY *glNormalPointer          )(GLenum type, GLsizei stride, const GLvoid *pointer);
    void      (APIENTRY *glPolygonOffset          )(GLfloat factor, GLfloat units);
    void      (APIENTRY *glTexCoordPointer        )(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
    void      (APIENTRY *glVertexPointer          )(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
    GLboolean (APIENTRY *glAreTexturesResident    )(GLsizei n, const GLuint *textures, GLboolean *residences);
    void      (APIENTRY *glCopyTexImage1D         )(GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLint border);
    void      (APIENTRY *glCopyTexImage2D         )(GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
    void      (APIENTRY *glCopyTexSubImage1D      )(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
    void      (APIENTRY *glCopyTexSubImage2D      )(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
    void      (APIENTRY *glDeleteTextures         )(GLsizei n, const GLuint *textures);
    void      (APIENTRY *glGenTextures            )(GLsizei n, GLuint *textures);
    void      (APIENTRY *glGetPointerv            )(GLenum pname, GLvoid* *params);
    GLboolean (APIENTRY *glIsTexture              )(GLuint texture);
    void      (APIENTRY *glPrioritizeTextures     )(GLsizei n, const GLuint *textures, const GLclampf *priorities);
    void      (APIENTRY *glTexSubImage1D          )(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels);
    void      (APIENTRY *glTexSubImage2D          )(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
    void      (APIENTRY *glPopClientAttrib        )(void);
    void      (APIENTRY *glPushClientAttrib       )(GLbitfield mask);
} GLDISPATCHTABLE, *PGLDISPATCHTABLE;

// OpenGL Client/Driver Procedure Table.

typedef struct _GLCLTPROCTABLE {
    int             cEntries;           // Number of function entries in table
    GLDISPATCHTABLE glDispatchTable;    // OpenGL function dispatch table
} GLCLTPROCTABLE, *PGLCLTPROCTABLE;

// Number of entries expected for various versions of OpenGL
#define OPENGL_VERSION_100_ENTRIES      306
#define OPENGL_VERSION_110_ENTRIES      336

// Driver GLRC handle.

typedef ULONG DHGLRC;

// SetProcTable function prototype for DrvSetContext.

typedef VOID (APIENTRY *PFN_SETPROCTABLE)(PGLCLTPROCTABLE);

// DrvSetCallbackProcs prototypes
typedef VOID   (APIENTRY *PFN_SETCURRENTVALUE)(VOID *pv);
typedef VOID  *(APIENTRY *PFN_GETCURRENTVALUE)(VOID);
typedef DHGLRC (APIENTRY *PFN_GETDHGLRC)(HGLRC hrc);

// Driver context function prototypes.

BOOL            APIENTRY DrvCopyContext(DHGLRC, DHGLRC, UINT);
DHGLRC          APIENTRY DrvCreateContext(HDC);
DHGLRC          APIENTRY DrvCreateLayerContext(HDC, int);
BOOL            APIENTRY DrvDeleteContext(DHGLRC);
PGLCLTPROCTABLE APIENTRY DrvSetContext(HDC,DHGLRC,PFN_SETPROCTABLE);
BOOL            APIENTRY DrvReleaseContext(DHGLRC);
BOOL            APIENTRY DrvValidateVersion(ULONG);
BOOL		APIENTRY DrvShareLists(DHGLRC, DHGLRC);
PROC            APIENTRY DrvGetProcAddress(LPCSTR);
VOID            APIENTRY DrvSetCallbackProcs(INT, PROC *);
BOOL            APIENTRY DrvDescribeLayerPlane(HDC, INT, INT, UINT,
                                               LPLAYERPLANEDESCRIPTOR);
INT             APIENTRY DrvSetLayerPaletteEntries(HDC, INT, INT, INT,
                                                   CONST COLORREF *);
INT             APIENTRY DrvGetLayerPaletteEntries(HDC, INT, INT, INT,
                                                   COLORREF *);
BOOL            APIENTRY DrvRealizeLayerPalette(HDC, INT, BOOL);
BOOL            APIENTRY DrvSwapLayerBuffers(HDC, UINT);

#if WINVER >= 0x500

typedef struct IDirectDrawSurface *LPDIRECTDRAWSURFACE;
typedef struct _DDSURFACEDESC *LPDDSURFACEDESC;

DHGLRC          APIENTRY DrvCreateDirectDrawContext(HDC, LPDIRECTDRAWSURFACE,
                                                    int);
int             APIENTRY DrvEnumTextureFormats(int, LPDDSURFACEDESC);
BOOL            APIENTRY DrvBindDirectDrawTexture(LPDIRECTDRAWSURFACE);
DWORD           APIENTRY DrvSwapMultipleBuffers(UINT cBuffers,
                                                CONST WGLSWAP *pgswap);

#endif // WINVER >= 0x500

// Input structure for OPENGL_CMD ExtEscape.

typedef struct _WNDOBJ WNDOBJ;
typedef struct _XLATEOBJ XLATEOBJ;

typedef struct _OPENGLCMD
{
    ULONG    ulSubEsc;
    FLONG    fl;
    WNDOBJ   *pwo;
    XLATEOBJ *pxo;
} OPENGLCMD, *POPENGLCMD;

#if WINVER >= 0x500

#define OPENGLCMD_MAXMULTI WGL_SWAPMULTIPLE_MAX

typedef struct _OPENGLCMDMULTI
{
    ULONG ulSubEsc;
    FLONG fl;
    ULONG cMulti;
    XLATEOBJ *pxo;
} OPENGLCMDMULTI, *POPENGLCMDMULTI;

#endif // WINVER >= 0x500

// Flags for OPENGL_CMD ExtEscape.

#define OGLCMD_NEEDWNDOBJ       0x01
#define OGLCMD_NEEDXLATEOBJ     0x02

#if WINVER >= 0x500
#define OGLCMD_MULTIWNDOBJ      0x04
#endif // WINVER >= 0x500

// OPENGL_GETINFO ExtEscape sub-escape numbers.  They are defined by Microsoft.

#define OPENGL_GETINFO_DRVNAME  0

// Input structure for OPENGL_GETINFO ExtEscape.

typedef struct _OPENGLGETINFO
{
    ULONG   ulSubEsc;
} OPENGLGETINFO, *POPENGLGETINFO;

// Input structure for OPENGL_GETINFO_DRVNAME ExtEscape.

typedef struct _GLDRVNAME
{
    OPENGLGETINFO   oglget;
} GLDRVNAME, *PGLDRVNAME;

// Output structure for OPENGL_GETINFO_DRVNAME ExtEscape.

typedef struct _GLDRVNAMERET
{
    ULONG   ulVersion;              // must be 1 for this version
    ULONG   ulDriverVersion;        // driver specific version number
    WCHAR   awch[MAX_PATH+1];
} GLDRVNAMERET, *PGLDRVNAMERET;

#endif /* _GLDRV_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\public\oak\inc\kbd.h ===
/****************************** Module Header ******************************\
* Module Name: kbd.h
*
* Copyright (c) 1985-91, Microsoft Corporation
*
* Keyboard table values that form the basis for languages and keyboard types.
* The basis is US, kbd type 4 - all others are a variation on this.
* This file is included by all kbd**.h files.
*
* History:
* 10-Jan-1991 GregoryW
* 23-Apr-1991 IanJa         VSC_TO_VK _* macros from oemtab.c
\***************************************************************************/

#ifndef _KBD_
#define _KBD_

/****************************************************************************\
*
* Keyboard Layers.   Used in kdb??.dll and in usersrv.dll
*
\****************************************************************************/

/*
 * Key Event (KE) structure
 * Stores a Virtual Key event
 */
typedef struct tagKE {
    union {
        BYTE bScanCode;    // Virtual Scan Code (Set 1)
        WCHAR wchInjected; // Unicode char from SendInput()
    };
    USHORT usFlaggedVk;    // Vk | Flags
    DWORD  dwTime;         // time in milliseconds
} KE, *PKE;

typedef BOOL (* KEPROC)(PKE pKe);

/*
 * KE.usFlaggedVk values, also used in the keyboard layer tables.
 */
#define KBDEXT        (USHORT)0x0100
#define KBDMULTIVK    (USHORT)0x0200
#define KBDSPECIAL    (USHORT)0x0400
#define KBDNUMPAD     (USHORT)0x0800
#define KBDUNICODE    (USHORT)0x1000
#define KBDINJECTEDVK (USHORT)0x2000
#define KBDBREAK      (USHORT)0x8000

/*
 * Key message lParam bits
 */
#define EXTENDED_BIT   0x01000000
#define DONTCARE_BIT   0x02000000
#define FAKE_KEYSTROKE 0x02000000
#define ALTNUMPAD_BIT  0x04000000 // copied from windows\inc\wincon.w

/*
 * Keyboard Shift State defines. These correspond to the bit mask defined
 * by the VkKeyScan() API.
 */
#define KBDBASE        0
#define KBDSHIFT       1
#define KBDCTRL        2
#define KBDALT         4
// three symbols KANA, ROYA, LOYA are for FE
#define KBDKANA        8
#define KBDROYA        0x10
#define KBDLOYA        0x20
#define KBDGRPSELTAP   0x80

/*
 * Handy diacritics
 */
#define GRAVE           0x0300
#define ACUTE           0x0301
#define CIRCUMFLEX      0x0302
#define TILDE           0x0303
#define MACRON          0x0304
#define OVERSCORE       0x0305
#define BREVE           0x0306
#define DOT_ABOVE       0x0307
#define UMLAUT          0x0308
#define DIARESIS        UMLAUT
#define HOOK_ABOVE      0x0309
#define RING            0x030A
#define DOUBLE_ACUTE    0x030B
#define HACEK           0x030C

#define CEDILLA         0x0327
#define OGONEK          0x0328
#define TONOS           0x0384
#define DIARESIS_TONOS  0x0385


#define wszGRAVE           L"\x0300"
#define wszACUTE           L"\x0301"
#define wszCIRCUMFLEX      L"\x0302"
#define wszTILDE           L"\x0303"
#define wszMACRON          L"\x0304"
#define wszOVERSCORE       L"\x0305"
#define wszBREVE           L"\x0306"
#define wszDOT_ABOVE       L"\x0307"
#define wszUMLAUT          L"\x0308"
#define wszHOOK_ABOVE      L"\x0309"
#define wszRING            L"\x030A"
#define wszDOUBLE_ACUTE    L"\x030B"
#define wszHACEK           L"\x030C"

#define wszCEDILLA         L"\x0327"
#define wszOGONEK          L"\x0328"
#define wszTONOS           L"\x0384"
#define wszDIARESIS_TONOS  L"\x0385"

#define IDS_FROM_SCANCODE(prefix, base) \
        (0xc000 + ((0x ## prefix) >= 0xE0 ? 0x100 : 0) + (0x ## base))

/***************************************************************************\
* MODIFIER KEYS
*
* All keyboards have "Modifier" keys which are used to alter the behaviour of
* some of the other keys.  These shifter keys are usually:
*   Shift  (left and/or right Shift key)
*   Ctrl   (left and/or right Ctrl key)
*   Alt    (left and/or right Alt key)
*   AltGr  (right Alt key only)
*
* NOTE:
*   All keyboards use the Shift key.
*   All keyboards use a Ctrl key to generate ASCII control characters.
*   All keyboards with a number pad use the Alt key and the NumPad to
*     generate characters by number.
*   Keyboards using AltGr as a Modifier Key usually translate the Virtual
*     ScanCode to Virtual Keys VK_CTRL + VK_ALT at input time: the Modifier
*     tables should be written to treat Ctrl + Alt as a valid shifter
*     key combination in these cases.
*
* By holding down 0 or more of these Modifier keys, a "shift state" is
* obtained : the shift state may affect the translation of Virtual Scancodes
* to Virtual Keys and/or the translation of Virtuals Key to Characters.
*
* EXAMPLES:
*
* Each key on a particular keyboard may be marked with up to five different
* characters in five different positions:
*
*              .-------.
*             /|       |\
*            : | 2   4 | :
*            | |       | |
*            | |       | |
*            | | 1   3 | |
*            | |_______| |
*            | /       \ |
*            |/    5    \|
*            `-----------'
*
* A key may also be able to generate a character that is not marked on it:
* these are ASCII Control chars, lower-case letters and/or "invisible keys".
*                                                  .-------.
*      An example of an "Invisible Key":          /|       |\
*                                                : | >     | :
*  The German M24 keyboard 2 should produce the  | |       | |
*  '|' character when ALT SHIFT is is held down  | |       | |
*  while the '<' key (shown here) is pressed:    | | <   \ | |
*  This keyboard has four other invisible        | |_______| |
*  characters.  France, Italy and Spain also     | /       \ |
*  support invisible characters on the M24       |/         \|
*  Keyboard 2 with ALT SHIFT depressed.          `-----------'
*
* The keyboard table must list the keys that contribute to it's shift state,
* and indicate which combinations are valid.  This is done with
*    aCharModifiers[]  - convert combinations of Modifier Keys to Bitmasks.
* and
*    aModification[];  - convert Modifier Bitmasks to enumerated Modifications
*
* AN EXAMPLE OF VALID AND INVALID MODIFIER KEY COMBINATIONS
*
*    The US English keyboard has 3 Modifier keys:
*      Shift (left or right); Ctrl (left or right); and Alt (left or right).
*
*    The only valid combinations of these Modifier Keys are:
*      none pressed      : Character at position (1) on the key.
*      Shift             : Character at position (2) on the key.
*      Ctrl              : Ascii Control characters
*      Shift + Ctrl      : Ascii Control characters
*      Alt               : Character-by-number on the numpad
*
*    The invalid combinations (that do not generate any characters) are:
*      Shift + Alt
*      Alt + Ctrl
*      Shift + Alt + Ctrl
*
* Something (???) :
* -----------------
*      Modifier keys              Character produced
*      -------------------------  ------------------
*   0  No shifter key depressed   position 1
*   1  Shift key is depressed     position 2
*   2  AltGr (r.h. Alt) depressed position 4 or 5 (whichever is marked)
*
* However, note that 3 shifter keys (SHIFT, can be combined in a
* characters, depending on the Keyboards
* Consider the following keyboards:
*
*     .-------.            STRANGE KBD         PECULIAR KBD
*    /|       |\           ==================  ==================
*   : | 2   4 | :    1   -
*   | |       | |    2   - SHIFT               SHIFT
*   | |       | |    3   - MENU                MENU
*   | | 1   3 | |    4   - SHIFT + MENU        SHIFT + MENU
*   | |_______| |    5   -    no such keys     CTRL  + MENU
*   | /       \ |
*   |/    5    \|
*   `-----------'
* Both STRANGE and PECULIAR keyboards could have aVkToBits[] =
*   { VK_SHIFT  , KBDSHIFT }, // 0x01
*   { VK_CONTROL, KBDCTRL  }, // 0x02
*   { VK_MENU   , KBDALT   }, // 0x04
*   { 0,          0        }
*
* The STRANGE keyboard has 4 distinct shift states, while the PECULIAR kbd
* has 5.  However, note that 3 shifter bits can be combined in a
* total of 2^3 == 8 ways.  Each such combination must be related to one (or
* none) of the enumerated shift states.
* Each shifter key combination can be represented by three binary bits:
*  Bit 0  is set if VK_SHIFT is down
*  Bit 1  is set if VK_CONTROL is down
*  Bit 2  is set if VK_MENU is down
*
* Example: If the STRANGE keyboard generates no characters in combination
* when just the ALT key is held down, nor when the SHIFT, CTRL and ALT keys
* are all held down, then the tables might look like this:
*
*                                VK_MENU,
*                        VK_CTRL,                    0
*    };
*    aModification[] = {
*        0,            //   0       0       0     = 000  <none>
*        1,            //   0       0       1     = 001  SHIFT
*        SHFT_INVALID, //   0       1       0     = 010  ALT
*        2,            //   0       1       1     = 011  SHIFT ALT
*        3,            //   1       0       0     = 100  CTRL
*        4,            //   1       0       1     = 101  SHIFT CTRL
*        5,            //   1       1       0     = 110  CTRL ALT
*        SHFT_INVALID  //   1       1       1     = 111  SHIFT CTRL ALT
*    };
*
*
\***************************************************************************/

/***************************************************************************\
* VK_TO_BIT - associate a Virtual Key with a Modifier bitmask.
*
* Vk        - the Virtual key (eg: VK_SHIFT, VK_RMENU, VK_CONTROL etc.)
*             Special Values:
*                0        null terminator
* ModBits   - a combination of KBDALT, KBDCTRL, KBDSHIFT and kbd-specific bits
*             Any kbd-specific shift bits must be the lowest-order bits other
*             than KBDSHIFT, KBDCTRL and KBDALT (0, 1 & 2)
*
* Those languages that use AltGr (VK_RMENU) to shift keys convert it to
* CTRL+ALT with the KBDSPECIAL bit in the ausVK[] entry for VK_RMENU
* and by having an entry in aVkToPfnOem[] to simulate the right Vk sequence.
*
\***************************************************************************/
typedef struct {
    BYTE Vk;
    BYTE ModBits;
} VK_TO_BIT, *PVK_TO_BIT;

/***************************************************************************\
* pModNumber  - a table to map shift bits to enumerated shift states
*
* Table attributes: Ordered table
*
* Maps all possible shifter key combinations to an enumerated shift state.
* The size of the table depends on the value of the highest order bit used
* in aCharModifiers[*].ModBits
*
* Special values for aModification[*]
*   SHFT_INVALID - no characters produced with this shift state.
LATER: (ianja) no SHFT_CTRL - control characters encoded in tables like others
*   SHFT_CTRL    - standard control character production (all keyboards must
*                  be able to produce CTRL-C == 0x0003 etc.)
*   Other        - enumerated shift state (not less than 0)
*
* This table is indexed by the Modifier Bits to obtain an Modification Number.
*
*                        CONTROL MENU SHIFT
*
*    aModification[] = {
*        0,            //   0     0     0     = 000  <none>
*        1,            //   0     0     1     = 001  SHIFT
*        SHFT_INVALID, //   0     1     0     = 010  ALT
*        2,            //   0     1     1     = 011  SHIFT ALT
*        3,            //   1     0     0     = 100  CTRL
*        4,            //   1     0     1     = 101  SHIFT CTRL
*        5,            //   1     1     0     = 110  CTRL ALT
*        SHFT_INVALID  //   1     1     1     = 111  SHIFT CTRL ALT
*    };
*
\***************************************************************************/
typedef struct {
    PVK_TO_BIT pVkToBit;     // Virtual Keys -> Mod bits
    WORD       wMaxModBits;  // max Modification bit combination value
    BYTE       ModNumber[];  // Mod bits -> Modification Number
} MODIFIERS, *PMODIFIERS;

WORD GetModifierBits(PMODIFIERS pModifiers, LPBYTE afKeyState);
WORD GetModificationNumber(PMODIFIERS pModifiers, WORD wModBits);

// FE Modifiers_VK
extern PMODIFIERS gpModifiers_VK;
extern MODIFIERS Modifiers_VK_STANDARD;
extern MODIFIERS Modifiers_VK_IBM02;

#define SHFT_INVALID 0x0F

/***************************************************************************\
* apulCvt_VK[] - obtain VK translation table from shift state
*     A VK translation table is used to change the value of the Virtual Key
*     according to the shift state.   OEM only (not locale-specific)
\***************************************************************************/
extern PULONG *gapulCvt_VK;
extern ULONG *gapulCvt_VK_101[];
extern ULONG *gapulCvt_VK_84[];
// gapulCvt_VK_IBM02[] is for FE
extern ULONG *gapulCvt_VK_IBM02[];

/***************************************************************************\
* awNumPadCvt[]   - Translate cursor movement keys to numpad keys
\***************************************************************************/
extern MODIFIERS Modifiers_VK;
extern BYTE aVkNumpad[];

/***************************************************************************\
* VSC_VK     - Associate a Virtual Scancode with a Virtual Key
*  Vsc - Virtual Scancode
*  Vk  - Virtual Key | flags
* Used by VKFromVSC() for scancodes prefixed 0xE0 or 0xE1
\***************************************************************************/
typedef struct _VSC_VK {
    BYTE Vsc;
    USHORT Vk;
} VSC_VK, *PVSC_VK;

/***************************************************************************\
* VK_VSC     - Associate a Virtual Key with a Virtual Scancode
*  Vk  - Virtual Key
*  Vsc - Virtual Scancode
* Used by MapVirtualKey for Virtual Keys not appearing in ausVK[]
\***************************************************************************/
typedef struct _VK_VSC {
    BYTE Vk;
    BYTE Vsc;
} VK_VSC, *PVK_VSC;

/***************************************************************************\
*
* VK_TO_WCHARS<n> - Associate a Virtual Key with <n> UNICODE characters
*
* VirtualKey  - The Virtual Key.
* wch[]       - An array of characters, one for each shift state that
*               applies to the specified Virtual Key.
*
* Special values for VirtualKey:
*    -1        - This entry contains dead chars for the previous entry
*    0         - Terminates a VK_TO_WCHARS[] table
*
* Special values for Attributes:
*    CAPLOK    - The CAPS-LOCK key affects this key like SHIFT
*    SGCAPS    - CapsLock uppercases the unshifted char (Swiss-German)
*
* Special values for wch[*]:
*    WCH_NONE  - No character is generated by pressing this key with the
*                current shift state.
*    WCH_DEAD  - The character is a dead-key: the next VK_TO_WCHARS[] entry
*                will contain the values of the dead characters (diaresis)
*                that can be produced by the Virtual Key.
*    WCH_LGTR  - The character is a ligature.  The characters generated by
*                this keystroke are found in the ligature table.
*
\***************************************************************************/
#define WCH_NONE 0xF000
#define WCH_DEAD 0xF001
#define WCH_LGTR 0xF002

#define CAPLOK      0x01
#define SGCAPS      0x02
#define CAPLOKALTGR 0x04
// KANALOK is for FE
#define KANALOK     0x08
#define GRPSELTAP   0x80

/*
 * Macro for VK to WCHAR with "n" shift states
 */
#define TYPEDEF_VK_TO_WCHARS(n) typedef struct _VK_TO_WCHARS##n {  \
                                    BYTE  VirtualKey;      \
                                    BYTE  Attributes;      \
                                    WCHAR wch[n];          \
                                } VK_TO_WCHARS##n, *PVK_TO_WCHARS##n;

/*
 * To facilitate coding the table scanning routine.
 */

/*
 * Table element types (for various numbers of shift states), used
 * to facilitate static initializations of tables.
 * VK_TO_WCHARS1 and PVK_TO_WCHARS1 may be used as the generic type
 */
TYPEDEF_VK_TO_WCHARS(1) // VK_TO_WCHARS1, *PVK_TO_WCHARS1;
TYPEDEF_VK_TO_WCHARS(2) // VK_TO_WCHARS2, *PVK_TO_WCHARS2;
TYPEDEF_VK_TO_WCHARS(3) // VK_TO_WCHARS3, *PVK_TO_WCHARS3;
TYPEDEF_VK_TO_WCHARS(4) // VK_TO_WCHARS4, *PVK_TO_WCHARS4;
TYPEDEF_VK_TO_WCHARS(5) // VK_TO_WCHARS5, *PVK_TO_WCHARS5;
TYPEDEF_VK_TO_WCHARS(6) // VK_TO_WCHARS6, *PVK_TO_WCHARS5;
TYPEDEF_VK_TO_WCHARS(7) // VK_TO_WCHARS7, *PVK_TO_WCHARS7;
// these three (8,9,10) are for FE
TYPEDEF_VK_TO_WCHARS(8) // VK_TO_WCHARS8, *PVK_TO_WCHARS8;
TYPEDEF_VK_TO_WCHARS(9) // VK_TO_WCHARS9, *PVK_TO_WCHARS9;
TYPEDEF_VK_TO_WCHARS(10) // VK_TO_WCHARS10, *PVK_TO_WCHARS10;

/***************************************************************************\
*
* VK_TO_WCHAR_TABLE - Describe a table of VK_TO_WCHARS1
*
* pVkToWchars     - points to the table.
* nModifications  - the number of shift-states supported by this table.
*                   (this is the number of elements in pVkToWchars[*].wch[])
*
* A keyboard may have several such tables: all keys with the same number of
*    shift-states are grouped together in one table.
*
* Special values for pVktoWchars:
*     NULL     - Terminates a VK_TO_WCHAR_TABLE[] list.
*
\***************************************************************************/

typedef struct _VK_TO_WCHAR_TABLE {
    PVK_TO_WCHARS1 pVkToWchars;
    BYTE           nModifications;
    BYTE           cbSize;
} VK_TO_WCHAR_TABLE, *PVK_TO_WCHAR_TABLE;

/***************************************************************************\
*
* Dead Key (diaresis) tables
*
* LATER IanJa: supplant by an NLS API that composes Diacritic+Base -> WCHAR
*
\***************************************************************************/
typedef struct {
    DWORD  dwBoth;  // diacritic & char
    WCHAR  wchComposed;
    USHORT uFlags;
} DEADKEY, *PDEADKEY;

#define DEADTRANS(ch, accent, comp, flags) { MAKELONG(ch, accent), comp, flags}

/*
 * Bit values for uFlags
 */
#define DKF_DEAD  0x0001

/***************************************************************************\
*
* Ligature table
*
\***************************************************************************/
/*
 * Macro for ligature with "n" characters
 */
#define TYPEDEF_LIGATURE(n) typedef struct _LIGATURE##n {     \
                                    BYTE  VirtualKey;         \
                                    WORD  ModificationNumber; \
                                    WCHAR wch[n];             \
                                } LIGATURE##n, *PLIGATURE##n;

/*
 * To facilitate coding the table scanning routine.
 */

/*
 * Table element types (for various numbers of ligatures), used
 * to facilitate static initializations of tables.
 *
 * LIGATURE1 and PLIGATURE1 are used as the generic type
 */
TYPEDEF_LIGATURE(1) // LIGATURE1, *PLIGATURE1;
TYPEDEF_LIGATURE(2) // LIGATURE2, *PLIGATURE2;
TYPEDEF_LIGATURE(3) // LIGATURE3, *PLIGATURE3;
TYPEDEF_LIGATURE(4) // LIGATURE4, *PLIGATURE4;
TYPEDEF_LIGATURE(5) // LIGATURE5, *PLIGATURE5;

/***************************************************************************\
* VSC_LPWSTR - associate a Virtual Scancode with a Text string
*
* Uses:
*   GetKeyNameText(), aKeyNames[]  Map virtual scancode to name of key
*
\***************************************************************************/
typedef struct {
    BYTE   vsc;
    LPWSTR pwsz;
} VSC_LPWSTR, *PVSC_LPWSTR;

/*
 * Along with ligature support we're adding a proper version number.
 * The previous version number (actually just unused bits...) was
 * always zero.  The version number will live in the high word of
 * fLocaleFlags.
 */
#define KBD_VERSION         1
#define GET_KBD_VERSION(p)  (HIWORD((p)->fLocaleFlags))

/*
 * Attributes such as AltGr, LRM_RLM, ShiftLock are stored in the the low word
 * of fLocaleFlags (layout specific) or in gdwKeyboardAttributes (all layouts)
 */
#define KLLF_ALTGR       0x0001
#define KLLF_SHIFTLOCK   0x0002
#define KLLF_LRM_RLM     0x0004

/*
 * Some attributes are per-layout (specific to an individual layout), some
 * attributes are per-user (apply globally to all layouts).  Some are both.
 */
#define KLLF_LAYOUT_ATTRS (KLLF_SHIFTLOCK | KLLF_ALTGR | KLLF_LRM_RLM)
#define KLLF_GLOBAL_ATTRS (KLLF_SHIFTLOCK)

/*
 * Flags passed in to the KeyboardLayout API (KLF_*) as can be converted to
 * internal (KLLF_*) attributes:
 */
#define KLL_ATTR_FROM_KLF(x)         ((x) >> 15)
#define KLL_LAYOUT_ATTR_FROM_KLF(x)  (KLL_ATTR_FROM_KLF(x) & KLLF_LAYOUT_ATTRS)
#define KLL_GLOBAL_ATTR_FROM_KLF(x)  (KLL_ATTR_FROM_KLF(x) & KLLF_GLOBAL_ATTRS)

/*
 * If KLF_SHIFTLOCK & KLF_LRM_RLM are defined, we can check the KLLF_* values
 */
#ifdef KLF_SHIFTLOCK
#if KLLF_SHIFTLOCK != KLL_ATTR_FROM_KLF(KLF_SHIFTLOCK)
    #error KLLF_SHIFTLOCK != KLL_ATTR_FROM_KLF(KLF_SHIFTLOCK)
#endif
#endif // KLF_SHIFTLOCK
#ifdef KLF_LRM_RLM
#if KLLF_LRM_RLM != KLL_ATTR_FROM_KLF(KLF_LRM_RLM)
    #error KLLF_LRM_RLM != KLL_ATTR_FROM_KLF(KLF_LRM_RLM)
#endif
#endif // KLF_LRM_RLM

/***************************************************************************\
* KBDTABLES
*
* This structure describes all the tables that implement the keyboard layer.
*
* When switching to a new layer, we get a new KBDTABLES structure: all key
* processing tables are accessed indirectly through this structure.
*
\***************************************************************************/

typedef struct tagKbdLayer {
    /*
     * Modifier keys
     */
    PMODIFIERS pCharModifiers;

    /*
     * Characters
     */
    VK_TO_WCHAR_TABLE *pVkToWcharTable;  // ptr to tbl of ptrs to tbl

    /*
     * Diacritics
     */
    PDEADKEY pDeadKey;

    /*
     * Names of Keys
     */
    VSC_LPWSTR *pKeyNames;
    VSC_LPWSTR *pKeyNamesExt;
    LPWSTR     *pKeyNamesDead;

    /*
     * Scan codes to Virtual Keys
     */
    USHORT *pusVSCtoVK;
    BYTE    bMaxVSCtoVK;
    PVSC_VK pVSCtoVK_E0;  // Scancode has E0 prefix
    PVSC_VK pVSCtoVK_E1;  // Scancode has E1 prefix

    /*
     * Locale-specific special processing
     */
    DWORD fLocaleFlags;

    /*
     * Ligatures
     */
    BYTE       nLgMax;
    BYTE       cbLgEntry;
    PLIGATURE1 pLigature;
} KBDTABLES, *PKBDTABLES;

/*
 * OEM-specific special processing (keystroke simulators and filters)
 */
extern KEPROC aKEProcOEM[];

/*
 * FarEast-specific special...
 */
typedef struct _VK_FUNCTION_PARAM {
    BYTE  NLSFEProcIndex;
    ULONG NLSFEProcParam;
} VK_FPARAM, *PVK_FPARAM;

typedef struct _VK_TO_FUNCTION_TABLE {
    BYTE Vk;
    BYTE NLSFEProcType;
    BYTE NLSFEProcCurrent;
    // Index[0] : Base
    // Index[1] : Shift
    // Index[2] : Control
    // Index[3] : Shift+Control
    // Index[4] : Alt
    // Index[5] : Shift+Alt
    // Index[6] : Control+Alt
    // Index[7] : Shift+Control+Alt
    BYTE NLSFEProcSwitch;   // 8 bits
    VK_FPARAM NLSFEProc[8];
    VK_FPARAM NLSFEProcAlt[8];
} VK_F, *PVK_F;

typedef struct tagKbdNlsLayer {
    USHORT OEMIdentifier;
    USHORT LayoutInformation;
    UINT  NumOfVkToF;
    VK_F   *pVkToF;
    //
    // The pusMouseVKey array provides a translation from the virtual key
    // value to an index.  The index is used to select the appropriate
    // routine to process the virtual key, as well as to select extra
    // information that is used by this routine during its processing.
    // If this value is NULL, following default will be used.
    //
    // ausMouseVKey[] = {
    //     VK_CLEAR,           // Numpad 5: Click active button
    //     VK_PRIOR,           // Numpad 9: Up & Right
    //     VK_NEXT,            // Numpad 3: Down & Right
    //     VK_END,             // Numpad 1: Down & Left
    //     VK_HOME,            // Numpad 7: Up & Left
    //     VK_LEFT,            // Numpad 4: Left
    //     VK_UP,              // Numpad 8: Up
    //     VK_RIGHT,           // Numpad 6: Right
    //     VK_DOWN,            // Numpad 2: Down
    //     VK_INSERT,          // Numpad 0: Active button down
    //     VK_DELETE,          // Numpad .: Active button up
    //     VK_MULTIPLY,        // Numpad *: Select both buttons
    //     VK_ADD,             // Numpad +: Double click active button
    //     VK_SUBTRACT,        // Numpad -: Select right button
    //     VK_DEVIDE|KBDEXT,   // Numpad /: Select left button
    //     VK_NUMLOCK|KBDEXT}; // Num Lock
    //
    INT     NumOfMouseVKey;
    USHORT *pusMouseVKey;
} KBDNLSTABLES, *PKBDNLSTABLES;

//
// OEM Ids - KBDNLSTABLES.OEMIdentifier
//
// PSS ID Number: Q130054
// Article last modified on 05-16-1995
//
// 3.10 1.20 | 3.50 1.20
// WINDOWS   | WINDOWS NT
//
// ---------------------------------------------------------------------
// The information in this article applies to:
// - Microsoft Windows Software Development Kit (SDK) for Windows
//   version 3.1
// - Microsoft Win32 Software Development Kit (SDK) version 3.5
// - Microsoft Win32s version 1.2
// ---------------------------------------------------------------------
// SUMMARY
// =======
// Because of the variety of computer manufacturers (NEC, Fujitsu, IBMJ, and
// so on) in Japan, sometimes Windows-based applications need to know which
// OEM (original equipment manufacturer) manufactured the computer that is
// running the application. This article explains how.
//
// MORE INFORMATION
// ================
// There is no documented way to detect the manufacturer of the computer that
// is currently running an application. However, a Windows-based application
// can detect the type of OEM Windows by using the return value of the
// GetKeyboardType() function.
//
// If an application uses the GetKeyboardType API, it can get OEM ID by
// specifying "1" (keyboard subtype) as argument of the function. Each OEM ID
// is listed here:
//
// OEM Windows       OEM ID
// ------------------------------
// Microsoft         00H (DOS/V)
// all AX            01H
// EPSON             04H
// Fujitsu           05H
// IBMJ              07H
// Matsushita        0AH
// NEC               0DH
// Toshiba           12H
//
// Application programs can use these OEM IDs to distinguish the type of OEM
// Windows. Note, however, that this method is not documented, so Microsoft
// may not support it in the future version of Windows.
//
// As a rule, application developers should write hardware-independent code,
// especially when making Windows-based applications. If they need to make a
// hardware-dependent application, they must prepare the separated program
// file for each different hardware architecture.
//
// Additional reference words: 3.10 1.20 3.50 1.20 kbinf
// KBCategory: kbhw
// KBSubcategory: wintldev
// =============================================================================
// Copyright Microsoft Corporation 1995.
//
#define NLSKBD_OEM_MICROSOFT          0x00
#define NLSKBD_OEM_AX                 0x01
#define NLSKBD_OEM_EPSON              0x04
#define NLSKBD_OEM_FUJITSU            0x05
#define NLSKBD_OEM_IBM                0x07
#define NLSKBD_OEM_MATSUSHITA         0x0A
#define NLSKBD_OEM_NEC                0x0D
#define NLSKBD_OEM_TOSHIBA            0x12
#define NLSKBD_OEM_DEC                0x18 // only NT
//
// Microsoft (default) - keyboards hardware/layout
//
#define MICROSOFT_KBD_101_TYPE           0
#define MICROSOFT_KBD_AX_TYPE            1
#define MICROSOFT_KBD_106_TYPE           2
#define MICROSOFT_KBD_002_TYPE           3
#define MICROSOFT_KBD_001_TYPE           4
#define MICROSOFT_KBD_FUNC              12
//
// AX consortium - keyboards hardware/layout
//
#define AX_KBD_DESKTOP_TYPE              1
//
// Fujitsu - keyboards hardware/layout
//
#define FMR_KBD_JIS_TYPE                 0
#define FMR_KBD_OASYS_TYPE               1
#define FMV_KBD_OASYS_TYPE               2
//
// NEC - keyboards hardware/layout
//
#define NEC_KBD_NORMAL_TYPE              1
#define NEC_KBD_N_MODE_TYPE              2
#define NEC_KBD_H_MODE_TYPE              3
#define NEC_KBD_LAPTOP_TYPE              4
#define NEC_KBD_106_TYPE                 5
//
// Toshiba - keyboards hardware/layout
//
#define TOSHIBA_KBD_DESKTOP_TYPE        13
#define TOSHIBA_KBD_LAPTOP_TYPE         15
//
// DEC - keyboards hardware/layout
//
#define DEC_KBD_ANSI_LAYOUT_TYPE         1 // only NT
#define DEC_KBD_JIS_LAYOUT_TYPE          2 // only NT

//
// Keyboard layout information - KBDNLSTABLE.LayoutInformation
//

//
// If this flag is on, System sends notification to keyboard
// drivers (leyout/kernel mode). when IME (Input-Mehod-Editor)
// status become changed.
//
#define NLSKBD_INFO_SEND_IME_NOTIFICATION  0x0001

//
// If this flag is on, System will use VK_HOME/VK_KANA instead of
// VK_NUMLOCK/VK_SCROLL for Accessibility toggle keys.
// + Typically, NEC PC-9800 Series will use this bit, because
//   they does not have 'NumLock' and 'ScrollLock' keys.
//
#define NLSKBD_INFO_ACCESSIBILITY_KEYMAP   0x0002

//
// If this flag is on, System will return 101 or 106 Japanese
// keyboard type/subtype id, when GetKeyboardType() is called.
//
#define NLSKBD_INFO_EMURATE_101_KEYBOARD   0x0010
#define NLSKBD_INFO_EMURATE_106_KEYBOARD   0x0020

//
// Keyboard layout function types
//
// - VK_F.NLSFEProcType
//
#define KBDNLS_TYPE_NULL      0
#define KBDNLS_TYPE_NORMAL    1
#define KBDNLS_TYPE_TOGGLE    2

//
// - VK_F.NLSFEProcCurrent
//
#define KBDNLS_INDEX_NORMAL   1
#define KBDNLS_INDEX_ALT      2

//
// - VK_F.NLSFEProc[]
//
#define KBDNLS_NULL             0 // Invalid function
#define KBDNLS_NOEVENT          1 // Drop keyevent
#define KBDNLS_SEND_BASE_VK     2 // Send Base VK_xxx
#define KBDNLS_SEND_PARAM_VK    3 // Send Parameter VK_xxx
#define KBDNLS_KANALOCK         4 // VK_KANA (with hardware lock)
#define KBDNLS_ALPHANUM         5 // VK_DBE_ALPHANUMERIC
#define KBDNLS_HIRAGANA         6 // VK_DBE_HIRAGANA
#define KBDNLS_KATAKANA         7 // VK_DBE_KATAKANA
#define KBDNLS_SBCSDBCS         8 // VK_DBE_SBCSCHAR/VK_DBE_DBCSCHAR
#define KBDNLS_ROMAN            9 // VK_DBE_ROMAN/VK_DBE_NOROMAN
#define KBDNLS_CODEINPUT       10 // VK_DBE_CODEINPUT/VK_DBE_NOCODEINPUT
#define KBDNLS_HELP_OR_END     11 // VK_HELP or VK_END [NEC PC-9800 Only]
#define KBDNLS_HOME_OR_CLEAR   12 // VK_HOME or VK_CLEAR [NEC PC-9800 Only]
#define KBDNLS_NUMPAD          13 // VK_NUMPAD? for Numpad key [NEC PC-9800 Only]
#define KBDNLS_KANAEVENT       14 // VK_KANA [Fujitsu FMV oyayubi Only]
#define KBDNLS_CONV_OR_NONCONV 15 // VK_CONVERT and VK_NONCONVERT [Fujitsu FMV oyayubi Only]

typedef BOOL (* NLSKEPROC)(PKE pKe, ULONG_PTR dwExtraInfo, ULONG dwParam);
typedef BOOL (* NLSVKFPROC)(PVK_F pVkToF, PKE pKe, ULONG_PTR dwExtraInfo);

//
// Keyboard Type = 7 : Japanese Keyboard
// Keyboard Type = 8 : Korean Keyboard
//
#define JAPANESE_KEYBOARD(Id)  ((Id).Type == 7)
#define KOREAN_KEYBOARD(Id)    ((Id).Type == 8)

// Fujitsu Oyayubi-shift keyboard
#define FUJITSU_KBD_CONSOLE(Id)  (JAPANESE_KEYBOARD(Id) && \
                                  (Id).Subtype == ((NLSKBD_OEM_FUJITSU<<4)|FMV_KBD_OASYS_TYPE))
        // This number 0x00020002 is registered in registry key as
        // HKLM\System\CurrentControlSet\Control\Terminal Server\KeyboardType Mapping\JPN
#define FUJITSU_KBD_REMOTE(Id)   (JAPANESE_KEYBOARD(Id) && \
                                  (Id).SubType == 0x00020002)

#define KBD_LAYOUT_LANG(hkl)    (LOBYTE(LOWORD(HandleToUlong(hkl))))

#define JAPANESE_KBD_LAYOUT(hkl)    (KBD_LAYOUT_LANG(hkl) == LANG_JAPANESE)
#define KOREAN_KBD_LAYOUT(hkl)      (KBD_LAYOUT_LANG(hkl) == LANG_KOREAN)

//
// NLS Keyboard functions
//
VOID NlsKbdInitializePerSystem(VOID);
VOID NlsKbdSendIMENotification(DWORD dwImeOpen, DWORD dwImeConversion);

// end of FE specific

/***************************************************************************\
* Macros for ausVK[] values (used below)
*
* These macros prefix each argument with VK_ to produce the name of a Virtual
* Key defined in "winuser.h" (eg: ESCAPE becomes VK_ESCAPE).
\***************************************************************************/
#ifndef KBD_TYPE
#define KBD_TYPE 4
#endif

/*
 * _NE() selects the Virtual Key according to keyboard type
 */
#if   (KBD_TYPE == 1)
#define _NE(v1,v2,v3,v4,v5,v6) (VK_##v1)
#elif (KBD_TYPE == 2)
#define _NE(v1,v2,v3,v4,v5,v6) (VK_##v2)
#elif (KBD_TYPE == 3)
#define _NE(v1,v2,v3,v4,v5,v6) (VK_##v3)
#elif (KBD_TYPE == 4)
#define _NE(v1,v2,v3,v4,v5,v6) (VK_##v4)
#elif (KBD_TYPE == 5)
#define _NE(v1,v2,v3,v4,v5,v6) (VK_##v5)
#elif (KBD_TYPE == 6)
#define _NE(v1,v2,v3,v4,v5,v6) (VK_##v6)
#elif (KBD_TYPE == 7)
#define _NE(v7,v8,v16,v10,v11,v12,v13) (VK_##v7)
#elif (KBD_TYPE == 8)
#define _NE(v7,v8,v16,v10,v11,v12,v13) (VK_##v8)
#elif (KBD_TYPE == 10)
#define _NE(v7,v8,v16,v10,v11,v12,v13) (VK_##v10)
#elif (KBD_TYPE == 11)
#define _NE(v7,v8,v16,v10,v11,v12,v13) (VK_##v11)
#elif (KBD_TYPE == 12)
#define _NE(v7,v8,v16,v10,v11,v12,v13) (VK_##v12)
#elif (KBD_TYPE == 13)
#define _NE(v7,v8,v16,v10,v11,v12,v13) (VK_##v13)
#elif (KBD_TYPE == 16)
#define _NE(v7,v8,v16,v10,v11,v12,v13) (VK_##v16)
#elif (KBD_TYPE == 20)
#define _NE(v20,v21,v22)           (VK_##v20)
#elif (KBD_TYPE == 21)
#define _NE(v20,v21,v22)           (VK_##v21)
#elif (KBD_TYPE == 22)
#define _NE(v20,v21,v22)           (VK_##v22)
#elif (KBD_TYPE == 30)
#define _NE(v30,v33,v34)           (VK_##v30)
#elif (KBD_TYPE == 33)
#define _NE(v30,v33,v34)           (VK_##v33)
#elif (KBD_TYPE == 34)
#define _NE(v30,v33,v34)           (VK_##v34)
#elif (KBD_TYPE == 40)
#define _NE(v40,v41)               (VK_##v40)
#elif (KBD_TYPE == 41)
#define _NE(v40,v41)               (VK_##v41)
#endif

/*
 * _EQ() selects the same Virtual Key for all keyboard types
 */
#if   (KBD_TYPE <= 6)
#define _EQ(         v4      ) (VK_##v4)
#elif (KBD_TYPE >= 7) && (KBD_TYPE <= 16)
#define _EQ(   v8            ) (VK_##v8)
#elif (KBD_TYPE > 20) && (KBD_TYPE <= 22)
#define _EQ(v20              ) (VK_##v20)
#elif (KBD_TYPE >= 30) && (KBD_TYPE <= 34)
#define _EQ(         v30     ) (VK_##v30)
#elif (KBD_TYPE == 37)
#define _EQ(         v37     ) (VK_##v37)
#elif (KBD_TYPE >= 40) && (KBD_TYPE <= 41)
#define _EQ( v40             ) (VK_##v40)
#endif

/*
 * A bit of trickery for virtual key names 'A' to 'Z' and '0' to '9' so
 * that they are not converted to a VK_* name.
 * With this macro, VK_'A' equates to 'A' etc.
 */
#define VK_
#define VK__none_   0xFF
#define VK_ABNT_C1  0xC1
#define VK_ABNT_C2  0xC2

#if (KBD_TYPE <= 6)
/***************************************************************************\
* T** - Values for ausVK[] (Virtual Scan Code to Virtual Key conversion)
*
* These values are for Scancode Set 3 and the USA.
* Other languages substitute their own values where required (files kbd**.h)
*
* Six sets of keyboards are supported, according to KBD_TYPE:
*
* KBD_TYPE   Keyboard (examples)
* ========   =======================================================
*    1       AT&T '301' & '302'; Olivetti 83-key; PC-XT 84-key; etc.
*    2       Olivetti M24 102-key
*    3       HP Vectra (DIN); Olivetti 86-key; etc.
*    4 *     Enhanced 101/102-key; Olivetti A; etc.
*    5       Nokia (Ericsson) type 5 (1050, etc.)
*    6       Nokia (Ericsson) type 6 (9140)
*
* * If KBD_TYPE is not defined, the default is type 4.
*
* KB3270 comments refers to KB 3270 keyboards in native emulation mode (DIP
* switches all OFF), and the Scancode Map used to convert its scancodes to
* standard scancode set 1.
*    KB3270 <= 57      - this entry is reached by mapping from scancode 0x57
*                        to an arbitrary scancode: the VK is what counts
*    KB3270 => HOME    - this scancode is mapped to the scancode for VK_HOME
*    KB3270            - no mapping involved, a scancode for KB3270 only
*
* _EQ() : all keyboard types have the same virtual key for this scancode
* _NE() : different virtual keys for this scancode, depending on kbd type
*
*     +------+ +--------+--------+--------+--------+--------+--------+
*     | Scan | |  kbd   |  kbd   |  kbd   |  kbd   |  kbd   |  kbd   |
*     | code | | type 1 | type 2 | type 3 | type 4 | type 5 | type 6 |
\****+-------+-+--------+--------+--------+--------+--------+--------+******/
#define T00 _EQ(                           _none_                    )
#define T01 _EQ(                           ESCAPE                    )
#define T02 _EQ(                           '1'                       )
#define T03 _EQ(                           '2'                       )
#define T04 _EQ(                           '3'                       )
#define T05 _EQ(                           '4'                       )
#define T06 _EQ(                           '5'                       )
#define T07 _EQ(                           '6'                       )
#define T08 _EQ(                           '7'                       )
#define T09 _EQ(                           '8'                       )
#define T0A _EQ(                           '9'                       )
#define T0B _EQ(                           '0'                       )
#define T0C _EQ(                           OEM_MINUS                 )
#define T0D _NE(OEM_PLUS,OEM_4,   OEM_PLUS,OEM_PLUS,OEM_PLUS,OEM_PLUS)
#define T0E _EQ(                           BACK                      )
#define T0F _EQ(                           TAB                       )
#define T10 _EQ(                           'Q'                       )
#define T11 _EQ(                           'W'                       )
#define T12 _EQ(                           'E'                       )
#define T13 _EQ(                           'R'                       )
#define T14 _EQ(                           'T'                       )
#define T15 _EQ(                           'Y'                       )
#define T16 _EQ(                           'U'                       )
#define T17 _EQ(                           'I'                       )
#define T18 _EQ(                           'O'                       )
#define T19 _EQ(                           'P'                       )
#define T1A _NE(OEM_4,   OEM_6,   OEM_4,   OEM_4,   OEM_4,   OEM_4   )
#define T1B _NE(OEM_6,   OEM_1,   OEM_6,   OEM_6,   OEM_6,   OEM_6   )
#define T1C _EQ(                           RETURN                    )
#define T1D _EQ(                           LCONTROL                  )
#define T1E _EQ(                           'A'                       )
#define T1F _EQ(                           'S'                       )
#define T20 _EQ(                           'D'                       )
#define T21 _EQ(                           'F'                       )
#define T22 _EQ(                           'G'                       )
#define T23 _EQ(                           'H'                       )
#define T24 _EQ(                           'J'                       )
#define T25 _EQ(                           'K'                       )
#define T26 _EQ(                           'L'                       )
#define T27 _NE(OEM_1,   OEM_PLUS,OEM_1,   OEM_1,   OEM_1,   OEM_1   )
#define T28 _NE(OEM_7,   OEM_3,   OEM_7,   OEM_7,   OEM_3,   OEM_3   )
#define T29 _NE(OEM_3,   OEM_7,   OEM_3,   OEM_3,   OEM_7,   OEM_7   )
#define T2A _EQ(                           LSHIFT                    )
#define T2B _EQ(                           OEM_5                     )
#define T2C _EQ(                           'Z'                       )
#define T2D _EQ(                           'X'                       )
#define T2E _EQ(                           'C'                       )
#define T2F _EQ(                           'V'                       )
#define T30 _EQ(                           'B'                       )
#define T31 _EQ(                           'N'                       )
#define T32 _EQ(                           'M'                       )
#define T33 _EQ(                           OEM_COMMA                 )
#define T34 _EQ(                           OEM_PERIOD                )
#define T35 _EQ(                           OEM_2                     )
#define T36 _EQ(                           RSHIFT                    )
#define T37 _EQ(                           MULTIPLY                  )
#define T38 _EQ(                           LMENU                     )
#define T39 _EQ(                           ' '                       )
#define T3A _EQ(                           CAPITAL                   )
#define T3B _EQ(                           F1                        )
#define T3C _EQ(                           F2                        )
#define T3D _EQ(                           F3                        )
#define T3E _EQ(                           F4                        )
#define T3F _EQ(                           F5                        )
#define T40 _EQ(                           F6                        )
#define T41 _EQ(                           F7                        )
#define T42 _EQ(                           F8                        )
#define T43 _EQ(                           F9                        )
#define T44 _EQ(                           F10                       )
#define T45 _EQ(                           NUMLOCK                   )
#define T46 _EQ(                           SCROLL                    )
#define T47 _EQ(                           HOME                      )
#define T48 _EQ(                           UP                        )
#define T49 _EQ(                           PRIOR                     )
#define T4A _EQ(                           SUBTRACT                  )
#define T4B _EQ(                           LEFT                      )
#define T4C _EQ(                           CLEAR                     )
#define T4D _EQ(                           RIGHT                     )
#define T4E _EQ(                           ADD                       )
#define T4F _EQ(                           END                       )
#define T50 _EQ(                           DOWN                      )
#define T51 _EQ(                           NEXT                      )
#define T52 _EQ(                           INSERT                    )
#define T53 _EQ(                           DELETE                    )
#define T54 _EQ(                           SNAPSHOT                  )
#define T55 _EQ(                           _none_                    ) // KB3270 => DOWN
#define T56 _NE(OEM_102, HELP,    OEM_102, OEM_102, _none_,  OEM_PA2 ) // KB3270 => LEFT
#define T57 _NE(F11,     RETURN,  F11,     F11,     _none_,  HELP    ) // KB3270 => ZOOM
#define T58 _NE(F12,     LEFT,    F12,     F12,     _none_,  OEM_102 ) // KB3270 => HELP
#define T59 _EQ(                           CLEAR                     )
#define T5A _EQ(                           OEM_WSCTRL                )// WSCtrl
#define T5B _EQ(                           OEM_FINISH                )// Finish
#define T5C _EQ(                           OEM_JUMP                  )// Jump
#define T5D _EQ(                           EREOF                     )
#define T5E _EQ(                           OEM_BACKTAB               ) // KB3270 <= 7E
#define T5F _EQ(                           OEM_AUTO                  ) // KB3270
#define T60 _EQ(                           _none_                    )
#define T61 _EQ(                           _none_                    )
#define T62 _EQ(                           ZOOM                      ) // KB3270 <= 57
#define T63 _EQ(                           HELP                      ) // KB3270 <= 58
#define T64 _EQ(                           F13                       )
#define T65 _EQ(                           F14                       )
#define T66 _EQ(                           F15                       )
#define T67 _EQ(                           F16                       )
#define T68 _EQ(                           F17                       )
#define T69 _EQ(                           F18                       )
#define T6A _EQ(                           F19                       )
#define T6B _EQ(                           F20                       )
#define T6C _EQ(                           F21                       )
#define T6D _EQ(                           F22                       )
#define T6E _EQ(                           F23                       )
#define T6F _EQ(                           OEM_PA3                   ) // KB3270
#define T70 _EQ(                           _none_                    )
#define T71 _EQ(                           OEM_RESET                 ) // KB3270
#define T72 _EQ(                           _none_                    )
#define T73 _EQ(                           ABNT_C1                   )
#define T74 _EQ(                           _none_                    )
#define T75 _EQ(                           _none_                    ) // KB3270 => RETURN
#define T76 _EQ(                           F24                       )
#define T77 _EQ(                           _none_                    ) // KB3270 => HOME
#define T78 _EQ(                           _none_                    ) // KB3270 => UP
#define T79 _EQ(                           _none_                    ) // KB3270 => DELETE
#define T7A _EQ(                           _none_                    ) // KB3270 => INSERT
#define T7B _EQ(                           OEM_PA1                   ) // KB3270
#define T7C _EQ(                           TAB                       ) // KB3270 => TAB
#define T7D _EQ(                           _none_                    ) // KB3270 => RIGHT
#define T7E _EQ(                           ABNT_C2                   ) // KB3270 => BACKTAB
#define T7F _EQ(                           OEM_PA2                   ) // KB3270

#define X10 _EQ(                           MEDIA_PREV_TRACK          ) // SpeedRacer
#define X19 _EQ(                           MEDIA_NEXT_TRACK          ) // SpeedRacer
#define X1C _EQ(                           RETURN                    )
#define X1D _EQ(                           RCONTROL                  )
#define X20 _EQ(                           VOLUME_MUTE               ) // SpeedRacer
#define X21 _EQ(                           LAUNCH_APP2               ) // SpeedRacer (Calculator?)
#define X22 _EQ(                           MEDIA_PLAY_PAUSE          ) // SpeedRacer
#define X24 _EQ(                           MEDIA_STOP                ) // SpeedRacer
#define X2E _EQ(                           VOLUME_DOWN               ) // SpeedRacer
#define X30 _EQ(                           VOLUME_UP                 ) // SpeedRacer
#define X32 _EQ(                           BROWSER_HOME              ) // SpeedRacer
#define X35 _EQ(                           DIVIDE                    )
#define X37 _EQ(                           SNAPSHOT                  )
#define X38 _EQ(                           RMENU                     )
#define X46 _EQ(                           CANCEL                    )
#define X47 _EQ(                           HOME                      )
#define X48 _EQ(                           UP                        )
#define X49 _EQ(                           PRIOR                     )
#define X4B _EQ(                           LEFT                      )
#define X4D _EQ(                           RIGHT                     )
#define X4F _EQ(                           END                       )
#define X50 _EQ(                           DOWN                      )
#define X51 _NE(NEXT,    F1,      NEXT,    NEXT,    _none_, OEM_PA2  )
#define X52 _EQ(                           INSERT                    )
#define X53 _EQ(                           DELETE                    )
#define X5B _EQ(                           LWIN                      )
#define X5C _EQ(                           RWIN                      )
#define X5D _EQ(                           APPS                      )
#define X5E _EQ(                           POWER                     )
#define X5F _EQ(                           SLEEP                     ) // SpeedRacer
#define X65 _EQ(                           BROWSER_SEARCH            ) // SpeedRacer
#define X66 _EQ(                           BROWSER_FAVORITES         ) // SpeedRacer
#define X67 _EQ(                           BROWSER_REFRESH           ) // SpeedRacer
#define X68 _EQ(                           BROWSER_STOP              ) // SpeedRacer
#define X69 _EQ(                           BROWSER_FORWARD           ) // SpeedRacer
#define X6A _EQ(                           BROWSER_BACK              ) // SpeedRacer
#define X6B _EQ(                           LAUNCH_APP1               ) // SpeedRacer (my computer?)
#define X6C _EQ(                           LAUNCH_MAIL               ) // SpeedRacer
#define X6D _EQ(                           LAUNCH_MEDIA_SELECT       ) // SpeedRacer


        /*
         * The break key is sent to us as E1,LCtrl,NumLock
         * We must convert the E1+LCtrl to BREAK, then ignore the Numlock
         */
#define Y1D _EQ(                           PAUSE                     )

#elif (KBD_TYPE >= 7) && (KBD_TYPE <= 16)
/***********************************************************************************\
* T** - Values for ausVK[] (Virtual Scan Code to Virtual Key conversion)
*
* Three sets of keyboards are supported, according to KBD_TYPE:
*
* KBD_TYPE   Keyboard (examples)
* ========   =====================================
*    7       Japanese IBM type 002 keyboard.
*    8 *     Japanese OADG (106) keyboard.
*   10       Korean 101 (type A) keyboard.
*   11       Korean 101 (type B) keyboard.
*   12       Korean 101 (type C) keyboard.
*   13       Korean 103 keyboard.
*   16       Japanese AX keyboard.
*
*     +------+ +----------+----------+----------+----------+----------+----------+----------+
*     | Scan | |   kbd    |   kbd    |   kbd    |   kbd    |   kbd    |   kbd    |   kbd    |
*     | code | |  type 7  |  type 8  |  type 16 |  type 10 |  type 11 |  type 12 |  type 13 |
\****+-------+-+----------+----------+----------+----------+----------+----------+----------+*/
#define T00 _EQ(           _none_                                                           )
#define T01 _EQ(           ESCAPE                                                           )
#define T02 _EQ(           '1'                                                              )
#define T03 _EQ(           '2'                                                              )
#define T04 _EQ(           '3'                                                              )
#define T05 _EQ(           '4'                                                              )
#define T06 _EQ(           '5'                                                              )
#define T07 _EQ(           '6'                                                              )
#define T08 _EQ(           '7'                                                              )
#define T09 _EQ(           '8'                                                              )
#define T0A _EQ(           '9'                                                              )
#define T0B _EQ(           '0'                                                              )
#define T0C _EQ(           OEM_MINUS                                                        )
#define T0D _NE(OEM_7,     OEM_7,     OEM_PLUS,  OEM_PLUS,  OEM_PLUS,  OEM_PLUS,  OEM_PLUS  )
#define T0E _EQ(           BACK                                                             )
#define T0F _EQ(           TAB                                                              )
#define T10 _EQ(           'Q'                                                              )
#define T11 _EQ(           'W'                                                              )
#define T12 _EQ(           'E'                                                              )
#define T13 _EQ(           'R'                                                              )
#define T14 _EQ(           'T'                                                              )
#define T15 _EQ(           'Y'                                                              )
#define T16 _EQ(           'U'                                                              )
#define T17 _EQ(           'I'                                                              )
#define T18 _EQ(           'O'                                                              )
#define T19 _EQ(           'P'                                                              )
#define T1A _NE(OEM_4,     OEM_3,     OEM_4,     OEM_4,     OEM_4,     OEM_4,     OEM_4     )
#define T1B _NE(OEM_6,     OEM_4,     OEM_6,     OEM_6,     OEM_6,     OEM_6,     OEM_6     )
#define T1C _EQ(           RETURN                                                           )
#define T1D _EQ(           LCONTROL                                                         )
#define T1E _EQ(           'A'                                                              )
#define T1F _EQ(           'S'                                                              )
#define T20 _EQ(           'D'                                                              )
#define T21 _EQ(           'F'                                                              )
#define T22 _EQ(           'G'                                                              )
#define T23 _EQ(           'H'                                                              )
#define T24 _EQ(           'J'                                                              )
#define T25 _EQ(           'K'                                                              )
#define T26 _EQ(           'L'                                                              )
#define T27 _NE(OEM_PLUS,  OEM_PLUS,  OEM_1,     OEM_1,     OEM_1,     OEM_1,     OEM_1     )
#define T28 _NE(OEM_1,     OEM_1,     OEM_7,     OEM_7,     OEM_7,     OEM_7,     OEM_7     )
#define T29 _NE(OEM_3,     DBE_SBCSCHAR,OEM_3,   OEM_3,     OEM_3,     OEM_3,     OEM_3     )
#define T2A _EQ(           LSHIFT                                                           )
#define T2B _NE(OEM_5,     OEM_6,     OEM_5,     OEM_5,     OEM_5,     OEM_5,     OEM_5     )
#define T2C _EQ(           'Z'                                                              )
#define T2D _EQ(           'X'                                                              )
#define T2E _EQ(           'C'                                                              )
#define T2F _EQ(           'V'                                                              )
#define T30 _EQ(           'B'                                                              )
#define T31 _EQ(           'N'                                                              )
#define T32 _EQ(           'M'                                                              )
#define T33 _EQ(           OEM_COMMA                                                        )
#define T34 _EQ(           OEM_PERIOD                                                       )
#define T35 _EQ(           OEM_2                                                            )
#define T36 _EQ(           RSHIFT                                                           )
#define T37 _EQ(           MULTIPLY                                                         )
#define T38 _EQ(           LMENU                                                            )
#define T39 _EQ(           ' '                                                              )
#define T3A _NE(DBE_ALPHANUMERIC,DBE_ALPHANUMERIC,CAPITAL,CAPITAL,CAPITAL,CAPITAL,CAPITAL   )
#define T3B _EQ(           F1                                                               )
#define T3C _EQ(           F2                                                               )
#define T3D _EQ(           F3                                                               )
#define T3E _EQ(           F4                                                               )
#define T3F _EQ(           F5                                                               )
#define T40 _EQ(           F6                                                               )
#define T41 _EQ(           F7                                                               )
#define T42 _EQ(           F8                                                               )
#define T43 _EQ(           F9                                                               )
#define T44 _EQ(           F10                                                              )
#define T45 _EQ(           NUMLOCK                                                          )
#define T46 _EQ(           SCROLL                                                           )
#define T47 _EQ(           HOME                                                             )
#define T48 _EQ(           UP                                                               )
#define T49 _EQ(           PRIOR                                                            )
#define T4A _EQ(           SUBTRACT                                                         )
#define T4B _EQ(           LEFT                                                             )
#define T4C _EQ(           CLEAR                                                            )
#define T4D _EQ(           RIGHT                                                            )
#define T4E _EQ(           ADD                                                              )
#define T4F _EQ(           END                                                              )
#define T50 _EQ(           DOWN                                                             )
#define T51 _EQ(           NEXT                                                             )
#define T52 _EQ(           INSERT                                                           )
#define T53 _EQ(           DELETE                                                           )
#define T54 _EQ(           SNAPSHOT                                                         )
#define T55 _EQ(           _none_                                                           )
#define T56 _NE(_none_,    _none_,    OEM_102,   OEM_102,   OEM_102,   OEM_102,   OEM_102   )
#define T57 _EQ(           F11                                                              )
#define T58 _EQ(           F12                                                              )
#define T59 _EQ(           CLEAR                                                            )
#define T5A _NE(NONAME,    NONAME,    NONCONVERT,OEM_WSCTRL,OEM_WSCTRL,OEM_WSCTRL,OEM_WSCTRL)
#define T5B _NE(NONAME,    NONAME,    CONVERT,   OEM_FINISH,OEM_FINISH,OEM_FINISH,OEM_FINISH)
#define T5C _NE(NONAME,    NONAME,    OEM_AX,    OEM_JUMP,  OEM_JUMP,  OEM_JUMP,  OEM_JUMP  )
#define T5D _EQ(           EREOF                                                            )
#define T5E _NE(_none_,    _none_,    _none_,    OEM_BACKTAB,OEM_BACKTAB,OEM_BACKTAB,OEM_BACKTAB)
#define T5F _NE(NONAME,    NONAME,    NONAME,    OEM_AUTO,  OEM_AUTO,  OEM_AUTO,  OEM_AUTO  )
#define T60 _EQ(           _none_                                                           )
#define T61 _NE(_none_,    _none_,    _none_,    ZOOM,      ZOOM,      ZOOM,      ZOOM      )
#define T62 _NE(_none_,    _none_,    _none_,    HELP,      HELP,      HELP,      HELP      )
#define T63 _EQ(           _none_                                                           )
#define T64 _EQ(           F13                                                              )
#define T65 _EQ(           F14                                                              )
#define T66 _EQ(           F15                                                              )
#define T67 _EQ(           F16                                                              )
#define T68 _EQ(           F17                                                              )
#define T69 _EQ(           F18                                                              )
#define T6A _EQ(           F19                                                              )
#define T6B _EQ(           F20                                                              )
#define T6C _EQ(           F21                                                              )
#define T6D _EQ(           F22                                                              )
#define T6E _EQ(           F23                                                              )
#define T6F _NE(_none_,    _none_,    _none_,    OEM_PA3,   OEM_PA3,   OEM_PA3,   OEM_PA3   )
#define T70 _NE(DBE_KATAKANA,DBE_HIRAGANA,_none_,_none_,    _none_,    _none_,    _none_    )
#define T71 _NE(_none_,    _none_,    _none_,    OEM_RESET, OEM_RESET, OEM_RESET, OEM_RESET )
#define T72 _EQ(           _none_                                                           )
#define T73 _NE(OEM_102,   OEM_102,   _none_,    ABNT_C1,   ABNT_C1,   ABNT_C1,   ABNT_C1   )
#define T74 _EQ(           _none_                                                           )
#define T75 _EQ(           _none_                                                           )
#define T76 _EQ(           F24                                                              )
#define T77 _NE(DBE_SBCSCHAR,_none_,  _none_,    _none_,    _none_,    _none_,    _none_    )
#define T78 _EQ(           _none_                                                           )
#define T79 _NE(CONVERT,   CONVERT,   _none_,    _none_,    _none_,    _none_,    _none_    )
#define T7A _EQ(           _none_                                                           )
#define T7B _NE(NONCONVERT,NONCONVERT,_none_,    OEM_PA1,   OEM_PA1,   OEM_PA1,   OEM_PA1   )
#define T7C _EQ(           TAB                                                              )
#define T7D _NE(_none_,    OEM_5,     _none_,    _none_,    _none_,    _none_,    _none_    )
#define T7E _EQ(           ABNT_C2                                                          )
#define T7F _EQ(           OEM_PA2                                                          )

#define X10 _EQ(           MEDIA_PREV_TRACK                                                 ) // SpeedRacer
#define X19 _EQ(           MEDIA_NEXT_TRACK                                                 ) // SpeedRacer
#define X1C _EQ(           RETURN                                                           )
#define X1D _NE(RCONTROL,  RCONTROL,DBE_KATAKANA,HANJA,     HANGEUL,   RCONTROL,  RCONTROL  )
#define X20 _EQ(           VOLUME_MUTE                                                      ) // SpeedRacer
#define X21 _EQ(           LAUNCH_APP2                                                      ) // SpeedRacer
#define X22 _EQ(           MEDIA_PLAY_PAUSE                                                 ) // SpeedRacer
#define X24 _EQ(           MEDIA_STOP                                                       ) // SpeedRacer
#define X2E _EQ(           VOLUME_DOWN                                                      ) // SpeedRacer
#define X30 _EQ(           VOLUME_UP                                                        ) // SpeedRacer
#define X32 _EQ(           BROWSER_HOME                                                     ) // SpeedRacer
#define X33 _NE(OEM_8,     _none_,    _none_,    _none_,    _none_,    _none_,    _none_    )
#define X35 _EQ(           DIVIDE                                                           )
#define X37 _EQ(           SNAPSHOT                                                         )
#define X38 _NE(DBE_HIRAGANA,RMENU,   KANJI,     HANGEUL,   HANJA,     RMENU,     RMENU     )
#define X42 _EQ(           _none_                                                           )
#define X43 _EQ(           _none_                                                           )
#define X44 _EQ(           _none_                                                           )
#define X46 _EQ(           CANCEL                                                           )
#define X47 _EQ(           HOME                                                             )
#define X48 _EQ(           UP                                                               )
#define X49 _EQ(           PRIOR                                                            )
#define X4B _EQ(           LEFT                                                             )
#define X4D _EQ(           RIGHT                                                            )
#define X4F _EQ(           END                                                              )
#define X50 _EQ(           DOWN                                                             )
#define X51 _EQ(           NEXT                                                             )
#define X52 _EQ(           INSERT                                                           )
#define X53 _EQ(           DELETE                                                           )
#define X5B _EQ(           LWIN                                                             )
#define X5C _EQ(           RWIN                                                             )
#define X5D _EQ(           APPS                                                             )
#define X5E _EQ(           POWER                                                            )
#define X5F _EQ(           SLEEP                                                            )
#define X65 _EQ(           BROWSER_SEARCH                                                   ) // SpeedRacer
#define X66 _EQ(           BROWSER_FAVORITES                                                ) // SpeedRacer
#define X67 _EQ(           BROWSER_REFRESH                                                  ) // SpeedRacer
#define X68 _EQ(           BROWSER_STOP                                                     ) // SpeedRacer
#define X69 _EQ(           BROWSER_FORWARD                                                  ) // SpeedRacer
#define X6A _EQ(           BROWSER_BACK                                                     ) // SpeedRacer
#define X6B _EQ(           LAUNCH_APP1                                                      ) // SpeedRacer
#define X6C _EQ(           LAUNCH_MAIL                                                      ) // SpeedRacer
#define X6D _EQ(           LAUNCH_MEDIA_SELECT                                              ) // SpeedRacer
#define XF1 _NE(_none_,    _none_,    _none_,    HANJA,     HANJA,     HANJA,     HANJA     )
#define XF2 _NE(_none_,    _none_,    _none_,    HANGEUL,   HANGEUL,   HANGEUL,   HANGEUL   )

        /*
         * The break key is sent to us as E1,LCtrl,NumLock
         * We must convert the E1+LCtrl to BREAK, then ignore the Numlock
         */
#define Y1D _EQ(           PAUSE                                                            )

#elif (KBD_TYPE > 20) && (KBD_TYPE <= 22)
/***********************************************************************\
* T** - Values for ausVK[] (Virtual Scan Code to Virtual Key conversion)
*
* Three sets of keyboards are supported, according to KBD_TYPE:
*
* KBD_TYPE   Keyboard (examples)
* ========   =====================================
*   20       Fujitsu FMR JIS keyboard.
*   21       Fujitsu FMR OYAYUBI keyboard.
*   22 *     Fujitsu FMV OYAYUBI keyboard.
*
*     +------+ +----------+----------+----------+
*     | Scan | |  kbd     |  kbd     |  kbd     |
*     | code | | type 20  | type 21  | type 22  |
\****+-------+-+----------+----------+----------+***********************/
#define T00 _EQ(                      _none_    )
#define T01 _EQ(                      ESCAPE    )
#define T02 _EQ(                      '1'       )
#define T03 _EQ(                      '2'       )
#define T04 _EQ(                      '3'       )
#define T05 _EQ(                      '4'       )
#define T06 _EQ(                      '5'       )
#define T07 _EQ(                      '6'       )
#define T08 _EQ(                      '7'       )
#define T09 _EQ(                      '8'       )
#define T0A _EQ(                      '9'       )
#define T0B _EQ(                      '0'       )
#define T0C _EQ(                      OEM_MINUS )
#define T0D _EQ(                      OEM_7     )
#define T0E _NE(OEM_5,     OEM_5,     BACK      )
#define T0F _NE(BACK,      BACK,      TAB       )
#define T10 _NE(TAB,       TAB,       'Q'       )
#define T11 _NE('Q',       'Q',       'W'       )
#define T12 _NE('W',       'W',       'E'       )
#define T13 _NE('E',       'E',       'R'       )
#define T14 _NE('R',       'R',       'T'       )
#define T15 _NE('T',       'T',       'Y'       )
#define T16 _NE('Y',       'Y',       'U'       )
#define T17 _NE('U',       'U',       'I'       )
#define T18 _NE('I',       'I',       'O'       )
#define T19 _NE('O',       'O',       'P'       )
#define T1A _NE('P',       'P',       OEM_3     )
#define T1B _NE(OEM_3,     OEM_3,     OEM_4     )
#define T1C _NE(OEM_4,     OEM_4,     RETURN    )
#define T1D _NE(RETURN,    RETURN,    LCONTROL  )
#define T1E _EQ(                      'A'       )
#define T1F _EQ(                      'S'       )
#define T20 _EQ(                      'D'       )
#define T21 _EQ(                      'F'       )
#define T22 _EQ(                      'G'       )
#define T23 _EQ(                      'H'       )
#define T24 _EQ(                      'J'       )
#define T25 _EQ(                      'K'       )
#define T26 _EQ(                      'L'       )
#define T27 _EQ(                      OEM_PLUS  )
#define T28 _EQ(                      OEM_1     )
#define T29 _NE(OEM_6,     OEM_6,     DBE_SBCSCHAR)
#define T2A _NE('Z',       'Z',       LSHIFT    )
#define T2B _NE('X',       'X',       OEM_6     )
#define T2C _NE('C',       'C',       'Z'       )
#define T2D _NE('V',       'V',       'X'       )
#define T2E _NE('B',       'B',       'C'       )
#define T2F _NE('N',       'N',       'V'       )
#define T30 _NE('M',       'M',       'B'       )
#define T31 _NE(OEM_COMMA, OEM_COMMA, 'N'       )
#define T32 _NE(OEM_PERIOD,OEM_PERIOD,'M'       )
#define T33 _NE(OEM_2,     OEM_2,     OEM_COMMA )
#define T34 _NE(OEM_8,     OEM_8,     OEM_PERIOD)
#define T35 _NE(' ',       ' ',       OEM_2     )
#define T36 _NE(MULTIPLY,  MULTIPLY,  RSHIFT    )
#define T37 _NE(DIVIDE,    DIVIDE,    MULTIPLY  )
#define T38 _NE(ADD,       ADD,       LMENU     )
#define T39 _NE(SUBTRACT,  SUBTRACT,  ' '       )
#define T3A _NE(NUMPAD7,   NUMPAD7,   DBE_ALPHANUMERIC)
#define T3B _NE(NUMPAD8,   NUMPAD8,   F1        )
#define T3C _NE(NUMPAD9,   NUMPAD9,   F2        )
#define T3D _NE(EQUAL,     EQUAL,     F3        )
#define T3E _NE(NUMPAD4,   NUMPAD4,   F4        )
#define T3F _NE(NUMPAD5,   NUMPAD5,   F5        )
#define T40 _NE(NUMPAD6,   NUMPAD6,   F6        )
#define T41 _NE(SEPARATOR, SEPARATOR, F7        )
#define T42 _NE(NUMPAD1,   NUMPAD1,   F8        )
#define T43 _NE(NUMPAD2,   NUMPAD2,   F9        )
#define T44 _NE(NUMPAD3,   NUMPAD3,   F10       )
#define T45 _NE(RETURN,    RETURN,    NUMLOCK   )
#define T46 _NE(NUMPAD0,   NUMPAD0,   SCROLL    )
#define T47 _NE(DECIMAL,   DECIMAL,   HOME      )
#define T48 _NE(INSERT,    INSERT,    UP        )
#define T49 _NE(OEM_00,    OEM_00,    PRIOR     )
#define T4A _NE(OEM_000,   OEM_000,   SUBTRACT  )
#define T4B _NE(DELETE,    DELETE,    LEFT      )
#define T4C _NE(_none_,    _none_,    CLEAR     )
#define T4D _NE(UP,        UP,        RIGHT     )
#define T4E _NE(HOME,      HOME,      ADD       )
#define T4F _NE(LEFT,      LEFT,      END       )
#define T50 _EQ(                      DOWN      )
#define T51 _NE(RIGHT,     RIGHT,     NEXT      )
#define T52 _NE(LCONTROL,  LCONTROL,  INSERT    )
#define T53 _NE(LSHIFT,    LSHIFT,    DELETE    )
#define T54 _NE(_none_,    _none_,    SNAPSHOT  )
#define T55 _NE(CAPITAL,   _none_,    _none_    )
#define T56 _NE(DBE_HIRAGANA,_none_,  _none_    )
#define T57 _NE(NONCONVERT,NONCONVERT,F11       )
#define T58 _NE(CONVERT,   CONVERT,   F12       )
#define T59 _NE(KANJI,     KANJI,     CLEAR     )
#define T5A _NE(DBE_KATAKANA,_none_,  NONAME    )
#define T5B _NE(F12,       F12,       NONAME    )
#define T5C _NE(LMENU,     LMENU,     NONAME    )
#define T5D _NE(F1,        F1,        EREOF     )
#define T5E _NE(F2,        F2,        _none_    )
#define T5F _NE(F3,        F3,        NONAME    )
#define T60 _NE(F4,        F4,        _none_    )
#define T61 _NE(F5,        F5,        _none_    )
#define T62 _NE(F6,        F6,        _none_    )
#define T63 _NE(F7,        F7,        _none_    )
#define T64 _NE(F8,        F8,        F13       )
#define T65 _NE(F9,        F9,        F14       )
#define T66 _NE(F10,       F10,       F15       )
#define T67 _NE(_none_,    OEM_LOYA,  F16       )
#define T68 _NE(_none_,    OEM_ROYA,  F17       )
#define T69 _NE(F11,       F11,       F18       )
#define T6A _NE(_none_,    DBE_ALPHANUMERIC,F19 )
#define T6B _NE(OEM_JISHO, OEM_JISHO, F20       )
#define T6C _NE(OEM_MASSHOU,OEM_MASSHOU,F21     )
#define T6D _NE(_none_,    _none_,    F22       )
#define T6E _NE(PRIOR,     PRIOR,     F23       )
#define T6F _NE(_none_,    DBE_KATAKANA,_none_  )
#define T70 _NE(NEXT,      NEXT,      DBE_HIRAGANA)
#define T71 _EQ(                      _none_    )
#define T72 _NE(CANCEL,    CANCEL,    _none_    )
#define T73 _NE(EXECUTE,   EXECUTE,   OEM_102   )
#define T74 _NE(F13,       F13,       _none_    )
#define T75 _NE(F14,       F14,       _none_    )
#define T76 _NE(F15,       F15,       F24       )
#define T77 _NE(F16,       F16,       _none_    )
#define T78 _NE(CLEAR,     CLEAR,     _none_    )
#define T79 _NE(HELP,      HELP,      CONVERT   )
#define T7A _NE(END,       END,       _none_    )
#define T7B _NE(SCROLL,    SCROLL,    NONCONVERT)
#define T7C _NE(PAUSE,     PAUSE,     TAB       )
#define T7D _NE(SNAPSHOT,  SNAPSHOT,  OEM_5     )
#define T7E _NE(_none_,    _none_,    ABNT_C2   )
#define T7F _NE(_none_,    _none_,    OEM_PA2   )

#define X1C _NE(_none_,    _none_,    RETURN    )
#define X1D _NE(_none_,    _none_,    RCONTROL  )
#define X33 _EQ(                      _none_    )
#define X35 _NE(_none_,    _none_,    DIVIDE    )
#define X37 _NE(_none_,    _none_,    SNAPSHOT  )
#define X38 _NE(_none_,    _none_,    RMENU     )
#define X42 _EQ(                      _none_    )
#define X43 _EQ(                      _none_    )
#define X44 _EQ(                      _none_    )
#define X46 _NE(_none_,    _none_,    CANCEL    )
#define X47 _NE(_none_,    _none_,    HOME      )
#define X48 _NE(_none_,    _none_,    UP        )
#define X49 _NE(_none_,    _none_,    PRIOR     )
#define X4B _NE(_none_,    _none_,    LEFT      )
#define X4D _NE(_none_,    _none_,    RIGHT     )
#define X4F _NE(_none_,    _none_,    END       )
#define X50 _NE(_none_,    _none_,    DOWN      )
#define X51 _NE(_none_,    _none_,    NEXT      )
#define X52 _NE(_none_,    _none_,    INSERT    )
#define X53 _NE(_none_,    _none_,    DELETE    )
#define X5B _NE(_none_,    _none_,    LWIN      )
#define X5C _NE(_none_,    _none_,    RWIN      )
#define X5D _NE(_none_,    _none_,    APPS      )
#define X5E _EQ(                      POWER     )
#define X5F _EQ(                      SLEEP     )
#define X60 _NE(SCROLL,    SCROLL,    _none_    )
#define X61 _NE(HOME,      HOME,      _none_    )
#define X62 _NE(END,       END,       _none_    )
#define X63 _EQ(                      _none_    )
#define X64 _EQ(                      _none_    )
#define X65 _EQ(                      _none_    )
#define X66 _EQ(                      _none_    )
#define X6D _NE(OEM_TOUROKU,OEM_TOUROKU,_none_  )
#define X71 _NE(DBE_SBCSCHAR,DBE_SBCSCHAR,_none_)
#define X74 _EQ(                      _none_    )
#define X75 _EQ(                      _none_    )
#define X76 _EQ(                      _none_    )
#define X77 _EQ(                      _none_    )
#define X78 _EQ(                      _none_    )
#define X79 _EQ(                      _none_    )
#define X7A _EQ(                      _none_    )
#define X7B _EQ(                      _none_    )

        /*
         * The break key is sent to us as E1,LCtrl,NumLock
         * We must convert the E1+LCtrl to BREAK, then ignore the Numlock
         * which must be ignored.  Alternatively, translate Ctrl-Numlock
         * to break, but don't let the CTRL through as a WM_KEYUP/DOWN) ?
         */
#define Y1D _EQ(              PAUSE             )

#elif (KBD_TYPE >= 30) && (KBD_TYPE <= 34)
/***********************************************************************\
* T** - Values for ausVK[] (Virtual Scan Code to Virtual Key conversion)
*
* Three sets of keyboards are supported, according to KBD_TYPE:
*
* KBD_TYPE   Keyboard (examples)
* ========   =====================================
*   30 *     NEC PC-9800 Normal Keyboard.
*   31       NEC PC-9800 Document processor Keyboard.  - not supported on NT5
*   32       NEC PC-9800 106 Keyboard. - same as KBD_TYPE 8
*   33       NEC PC-9800 for Hydra: PC-9800 Keyboard on Windows NT 5.0.
*            NEC PC-98NX for Hydra: PC-9800 Keyboard on Windows 95/NT.
*   34       NEC PC-9800 for Hydra: PC-9800 Keyboard on Windows NT 3.51/4.0.
*
*     +------+ +----------+----------+----------+
*     | Scan | |   kbd    |   kbd    |   kbd    |
*     | code | |  type 30 |  type 33 |  type 34 |
\****+-------+-+----------+----------+----------+***********************/
#define T00 _EQ(_none_                          )
#define T01 _EQ(ESCAPE                          )
#define T02 _EQ('1'                             )
#define T03 _EQ('2'                             )
#define T04 _EQ('3'                             )
#define T05 _EQ('4'                             )
#define T06 _EQ('5'                             )
#define T07 _EQ('6'                             )
#define T08 _EQ('7'                             )
#define T09 _EQ('8'                             )
#define T0A _EQ('9'                             )
#define T0B _EQ('0'                             )
#define T0C _EQ(OEM_MINUS                       )
#define T0D _NE(OEM_7,     OEM_7,     OEM_PLUS  )
#define T0E _EQ(BACK                            )
#define T0F _EQ(TAB                             )
#define T10 _EQ('Q'                             )
#define T11 _EQ('W'                             )
#define T12 _EQ('E'                             )
#define T13 _EQ('R'                             )
#define T14 _EQ('T'                             )
#define T15 _EQ('Y'                             )
#define T16 _EQ('U'                             )
#define T17 _EQ('I'                             )
#define T18 _EQ('O'                             )
#define T19 _EQ('P'                             )
#define T1A _NE(OEM_3,     OEM_3,     OEM_4     )
#define T1B _NE(OEM_4,     OEM_4,     OEM_6     )
#define T1C _EQ(RETURN                          )
#define T1D _EQ(LCONTROL                        )
#define T1E _EQ('A'                             )
#define T1F _EQ('S'                             )
#define T20 _EQ('D'                             )
#define T21 _EQ('F'                             )
#define T22 _EQ('G'                             )
#define T23 _EQ('H'                             )
#define T24 _EQ('J'                             )
#define T25 _EQ('K'                             )
#define T26 _EQ('L'                             )
#define T27 _NE(OEM_PLUS,  OEM_PLUS,  OEM_1     )
#define T28 _NE(OEM_1,     OEM_1,     OEM_7     )
#define T29 _NE(DBE_SBCSCHAR, \
                           DBE_SBCSCHAR, \
                                      OEM_3     )
#define T2A _EQ(LSHIFT                          )
#define T2B _NE(OEM_6,     OEM_6,     OEM_5     )
#define T2C _EQ('Z'                             )
#define T2D _EQ('X'                             )
#define T2E _EQ('C'                             )
#define T2F _EQ('V'                             )
#define T30 _EQ('B'                             )
#define T31 _EQ('N'                             )
#define T32 _EQ('M'                             )
#define T33 _EQ(OEM_COMMA                       )
#define T34 _EQ(OEM_PERIOD                      )
#define T35 _EQ(OEM_2                           )
#define T36 _EQ(RSHIFT                          )
#define T37 _EQ(MULTIPLY                        )
#define T38 _EQ(LMENU                           )
#define T39 _EQ(' '                             )
#define T3A _EQ(CAPITAL                         )
#define T3B _EQ(F1                              )
#define T3C _EQ(F2                              )
#define T3D _EQ(F3                              )
#define T3E _EQ(F4                              )
#define T3F _EQ(F5                              )
#define T40 _EQ(F6                              )
#define T41 _EQ(F7                              )
#define T42 _EQ(F8                              )
#define T43 _EQ(F9                              )
#define T44 _EQ(F10                             )
#define T45 _EQ(NUMLOCK                         )
#define T46 _EQ(SCROLL                          )
#define T47 _EQ(HOME                            )
#define T48 _EQ(UP                              )
#define T49 _EQ(PRIOR                           )
#define T4A _EQ(SUBTRACT                        )
#define T4B _EQ(LEFT                            )
#define T4C _EQ(CLEAR                           )
#define T4D _EQ(RIGHT                           )
#define T4E _EQ(ADD                             )
#define T4F _EQ(END                             )
#define T50 _EQ(DOWN                            )
#define T51 _EQ(NEXT                            )
#define T52 _EQ(INSERT                          )
#define T53 _EQ(DELETE                          )
#define T54 _EQ(SNAPSHOT                        )
#define T55 _NE(_none_,    _none_,    OEM_8     )
#define T56 _EQ(_none_                          )
#define T57 _EQ(F11                             )
#define T58 _EQ(F12                             )
#define T59 _EQ(OEM_NEC_EQUAL                   )
#define T5A _NE(NONAME,    NONAME,    NONCONVERT)
#define T5B _NE(_none_,    _none_,    NONAME    )
#define T5C _EQ(SEPARATOR                       )
#define T5D _EQ(F13                             )
#define T5E _EQ(F14                             )
#define T5F _EQ(F15                             )
#define T60 _EQ(_none_                          )
#define T61 _EQ(_none_                          )
#define T62 _EQ(_none_                          )
#define T63 _EQ(_none_                          )
#define T64 _NE(_none_,    _none_,    F13       )
#define T65 _NE(_none_,    _none_,    F14       )
#define T66 _NE(_none_,    _none_,    F15       )
#define T67 _NE(_none_,    _none_,    F16       )
#define T68 _NE(_none_,    _none_,    F17       )
#define T69 _NE(_none_,    _none_,    F18       )
#define T6A _NE(_none_,    _none_,    F19       )
#define T6B _NE(_none_,    _none_,    F20       )
#define T6C _NE(_none_,    _none_,    F21       )
#define T6D _NE(_none_,    _none_,    F22       )
#define T6E _NE(_none_,    _none_,    F23       )
#define T6F _EQ(_none_                          )
#define T70 _NE(KANA,      KANA,      DBE_HIRAGANA)
#define T71 _EQ(_none_                          )
#define T72 _EQ(_none_                          )
#define T73 _NE(OEM_8,     OEM_8,     _none_    )
#define T74 _NE(_none_,    OEM_NEC_EQUAL, \
                                      _none_    )
#define T75 _NE(_none_,    SEPARATOR, _none_    )
#define T76 _NE(_none_,    _none_,    F24       )
#define T77 _NE(_none_,    _none_,    DBE_SBCSCHAR)
#define T78 _EQ(_none_                          )
#define T79 _EQ(CONVERT                         )
#define T7A _EQ(_none_                          )
#define T7B _EQ(NONCONVERT                      )
#define T7C _NE(TAB,       _none_,    _none_    )
#define T7D _NE(OEM_5,     OEM_5,     _none_    )
#define T7E _NE(ABNT_C2,   ABNT_C2,   _none_    )
#define T7F _NE(OEM_PA2,   OEM_PA2,   _none_    )

#define X1C _EQ(RETURN                          )
#define X1D _NE(RCONTROL,  RCONTROL,  KANA      )
#define X33 _EQ(_none_                          )
#define X35 _EQ(DIVIDE                          )
#define X37 _EQ(SNAPSHOT                        )
#define X38 _NE(_none_,    _none_,    KANJI     )
#define X42 _NE(_none_,    _none_,    RCONTROL  )
#define X43 _NE(_none_,    _none_,    RMENU     )
#define X44 _EQ(_none_                          )
#define X46 _EQ(CANCEL                          )
#define X47 _EQ(HOME                            )
#define X48 _EQ(UP                              )
#define X49 _EQ(PRIOR                           )
#define X4B _EQ(LEFT                            )
#define X4D _EQ(RIGHT                           )
#define X4F _EQ(END                             )
#define X50 _EQ(DOWN                            )
#define X51 _EQ(NEXT                            )
#define X52 _EQ(INSERT                          )
#define X53 _EQ(DELETE                          )
#define X5B _EQ(LWIN                            )
#define X5C _EQ(RWIN                            )
#define X5D _EQ(APPS                            )
#define X5E _EQ(POWER                           )
#define X5F _EQ(SLEEP                           )
#define X60 _EQ(_none_                          )
#define X61 _EQ(_none_                          )
#define X62 _EQ(_none_                          )
#define X63 _EQ(_none_                          )
#define X64 _EQ(_none_                          )
#define X65 _EQ(_none_                          )
#define X66 _EQ(_none_                          )
#define X6D _EQ(_none_                          )
#define X71 _EQ(_none_                          )
#define X74 _EQ(_none_                          )
#define X75 _EQ(_none_                          )
#define X76 _EQ(_none_                          )
#define X77 _EQ(_none_                          )
#define X78 _EQ(_none_                          )
#define X79 _EQ(_none_                          )
#define X7A _EQ(_none_                          )
#define X7B _EQ(_none_                          )
        /*
         * The break key is sent to us as E1,LCtrl,NumLock
         * We must convert the E1+LCtrl to BREAK, then ignore the Numlock
         * which must be ignored.  Alternatively, translate Ctrl-Numlock
         * to break, but don't let the CTRL through as a WM_KEYUP/DOWN) ?
         */
#define Y1D _EQ(PAUSE                          )

#elif (KBD_TYPE == 37)
/***********************************************************************\
* T** - Values for ausVK[] (Virtual Scan Code to Virtual Key conversion)
*
* Three sets of keyboards are supported, according to KBD_TYPE:
*
* KBD_TYPE   Keyboard (examples)
* ========   =====================================
*   37 *     NEC PC-9800 for Hydra: PC-9800 Keyboard on Windows 95.
*
*     +------+ +----------+
*     | Scan | |   kbd    |
*     | code | |  type 37 |
\****+-------+-+----------+*********************************************/
#define T00 _EQ(ESCAPE    )
#define T01 _EQ('1'       )
#define T02 _EQ('2'       )
#define T03 _EQ('3'       )
#define T04 _EQ('4'       )
#define T05 _EQ('5'       )
#define T06 _EQ('6'       )
#define T07 _EQ('7'       )
#define T08 _EQ('8'       )
#define T09 _EQ('9'       )
#define T0A _EQ('0'       )
#define T0B _EQ(OEM_MINUS )
#define T0C _EQ(OEM_7     )
#define T0D _EQ(OEM_5     )
#define T0E _EQ(BACK      )
#define T0F _EQ(TAB       )
#define T10 _EQ('Q'       )
#define T11 _EQ('W'       )
#define T12 _EQ('E'       )
#define T13 _EQ('R'       )
#define T14 _EQ('T'       )
#define T15 _EQ('Y'       )
#define T16 _EQ('U'       )
#define T17 _EQ('I'       )
#define T18 _EQ('O'       )
#define T19 _EQ('P'       )
#define T1A _EQ(OEM_3     )
#define T1B _EQ(OEM_4     )
#define T1C _EQ(RETURN    )
#define T1D _EQ('A'       )
#define T1E _EQ('S'       )
#define T1F _EQ('D'       )
#define T20 _EQ('F'       )
#define T21 _EQ('G'       )
#define T22 _EQ('H'       )
#define T23 _EQ('J'       )
#define T24 _EQ('K'       )
#define T25 _EQ('L'       )
#define T26 _EQ(OEM_PLUS  )
#define T27 _EQ(OEM_1     )
#define T28 _EQ(OEM_6     )
#define T29 _EQ('Z'       )
#define T2A _EQ('X'       )
#define T2B _EQ('C'       )
#define T2C _EQ('V'       )
#define T2D _EQ('B'       )
#define T2E _EQ('N'       )
#define T2F _EQ('M'       )
#define T30 _EQ(OEM_COMMA )
#define T31 _EQ(OEM_PERIOD)
#define T32 _EQ(OEM_2     )
#define T33 _EQ(OEM_8     )
#define T34 _EQ(' '       )
#define T35 _EQ(CONVERT   )
#define T36 _EQ(NEXT      )
#define T37 _EQ(PRIOR     )
#define T38 _EQ(INSERT    )
#define T39 _EQ(DELETE    )
#define T3A _EQ(UP        )
#define T3B _EQ(LEFT      )
#define T3C _EQ(RIGHT     )
#define T3D _EQ(DOWN      )
#define T3E _EQ(HOME      )
#define T3F _EQ(END       )
#define T40 _EQ(SUBTRACT  )
#define T41 _EQ(DIVIDE    )
#define T42 _EQ(NUMPAD7   )
#define T43 _EQ(NUMPAD8   )
#define T44 _EQ(NUMPAD9   )
#define T45 _EQ(MULTIPLY  )
#define T46 _EQ(NUMPAD4   )
#define T47 _EQ(NUMPAD5   )
#define T48 _EQ(NUMPAD6   )
#define T49 _EQ(ADD       )
#define T4A _EQ(NUMPAD1   )
#define T4B _EQ(NUMPAD2   )
#define T4C _EQ(NUMPAD3   )
#define T4D _EQ(OEM_NEC_EQUAL)
#define T4E _EQ(NUMPAD0   )
#define T4F _EQ(SEPARATOR )
#define T50 _EQ(DECIMAL   )
#define T51 _EQ(NONCONVERT)
#define T52 _EQ(F11       )
#define T53 _EQ(F12       )
#define T54 _EQ(F13       )
#define T55 _EQ(F14       )
#define T56 _EQ(F15       )
#define T57 _EQ(_none_    )
#define T58 _EQ(_none_    )
#define T59 _EQ(_none_    )
#define T5A _EQ(_none_    )
#define T5B _EQ(_none_    )
#define T5C _EQ(RETURN    )
#define T5D _EQ(_none_    )
#define T5E _EQ(_none_    )
#define T5F _EQ(_none_    )
#define T60 _EQ(CANCEL    )
#define T61 _EQ(SNAPSHOT  )
#define T62 _EQ(F1        )
#define T63 _EQ(F2        )
#define T64 _EQ(F3        )
#define T65 _EQ(F4        )
#define T66 _EQ(F5        )
#define T67 _EQ(F6        )
#define T68 _EQ(F7        )
#define T69 _EQ(F8        )
#define T6A _EQ(F9        )
#define T6B _EQ(F10       )
#define T6C _EQ(_none_    )
#define T6D _EQ(_none_    )
#define T6E _EQ(_none_    )
#define T6F _EQ(_none_    )
#define T70 _EQ(LSHIFT    )
#define T71 _EQ(CAPITAL   )
#define T72 _EQ(KANA      )
#define T73 _EQ(LMENU     )
#define T74 _EQ(LCONTROL  )
#define T75 _EQ(_none_    )
#define T76 _EQ(_none_    )
#define T77 _EQ(LWIN      )
#define T78 _EQ(RWIN      )
#define T79 _EQ(APPS      )
#define T7A _EQ(_none_    )
#define T7B _EQ(_none_    )
#define T7C _EQ(_none_    )
#define T7D _EQ(RSHIFT    )
#define T7E _EQ(ABNT_C2   )
#define T7F _EQ(OEM_PA2   )

        /*
         * The break key is sent to us as E1,LCtrl,NumLock
         * We must conevrt the E1+LCtrl to BREAK, then ignore the Numlock
         * which must be ignored.  Alternatively, translate Ctrl-Numlock
         * to break, but don't let the CTRL through as a WM_KEYUP/DOWN) ?
         */
#define Y1D _EQ(PAUSE    )

#elif (KBD_TYPE >= 40) && (KBD_TYPE <= 41)
/***********************************************************************\
* T** - Values for ausVK[] (Virtual Scan Code to Virtual Key conversion)
*
* Two sets of keyboards are supported, according to KBD_TYPE:
*
* KBD_TYPE   Keyboard (examples)
* ========   =====================================
*   40 *     DEC LK411-JJ (JIS  layout) keyboard
*   41       DEC LK411-AJ (ANSI layout) keyboard
*
*     +------+ +-----------+-----------+
*     | Scan | |    kbd    |    kbd    |
*     | code | |  LK411-JJ |  LK411-AJ |
\*****+------+-+-----------+-----------+********************************/
#define T00 _EQ(        _none_            )
#define T01 _EQ(        ESCAPE            )
#define T02 _EQ(        '1'               )
#define T03 _EQ(        '2'               )
#define T04 _EQ(        '3'               )
#define T05 _EQ(        '4'               )
#define T06 _EQ(        '5'               )
#define T07 _EQ(        '6'               )
#define T08 _EQ(        '7'               )
#define T09 _EQ(        '8'               )
#define T0A _EQ(        '9'               )
#define T0B _EQ(        '0'               )
#define T0C _EQ(        OEM_MINUS         )
#define T0D _NE( OEM_7,      OEM_PLUS     ) // "^"/"="
#define T0E _EQ(        BACK              )
#define T0F _EQ(        TAB               )
#define T10 _EQ(        'Q'               )
#define T11 _EQ(        'W'               )
#define T12 _EQ(        'E'               )
#define T13 _EQ(        'R'               )
#define T14 _EQ(        'T'               )
#define T15 _EQ(        'Y'               )
#define T16 _EQ(        'U'               )
#define T17 _EQ(        'I'               )
#define T18 _EQ(        'O'               )
#define T19 _EQ(        'P'               )
#define T1A _NE( OEM_3,      OEM_4        ) // "@"/"["
#define T1B _NE( OEM_4,      OEM_6        ) // "["/"]"
#define T1C _EQ(        RETURN            )
#define T1D _EQ(        LCONTROL          )
#define T1E _EQ(        'A'               )
#define T1F _EQ(        'S'               )
#define T20 _EQ(        'D'               )
#define T21 _EQ(        'F'               )
#define T22 _EQ(        'G'               )
#define T23 _EQ(        'H'               )
#define T24 _EQ(        'J'               )
#define T25 _EQ(        'K'               )
#define T26 _EQ(        'L'               )
#define T27 _NE( OEM_PLUS,   OEM_1        ) // ";"
#define T28 _NE( OEM_1,      OEM_7        ) // ":"/"'"
#define T29 _NE( _none_,     DBE_SBCSCHAR ) // LK411AJ uses "<>" as SBCS/DBCS key
#define T2A _EQ(        LSHIFT            )
#define T2B _NE( OEM_6,      OEM_5        ) // "]"/"\"
#define T2C _EQ(        'Z'               )
#define T2D _EQ(        'X'               )
#define T2E _EQ(        'C'               )
#define T2F _EQ(        'V'               )
#define T30 _EQ(        'B'               )
#define T31 _EQ(        'N'               )
#define T32 _EQ(        'M'               )
#define T33 _EQ(        OEM_COMMA         )
#define T34 _EQ(        OEM_PERIOD        )
#define T35 _EQ(        OEM_2             ) // "/"
#define T36 _EQ(        RSHIFT            )
#define T37 _EQ(        MULTIPLY          ) // PF3 : "*"
#define T38 _EQ(        LMENU             ) // Alt(Left)
#define T39 _EQ(        ' '               ) // Space
#define T3A _EQ(        CAPITAL           ) // LOCK : Caps Lock
#define T3B _EQ(        F1                )
#define T3C _EQ(        F2                )
#define T3D _EQ(        F3                )
#define T3E _EQ(        F4                )
#define T3F _EQ(        F5                )
#define T40 _EQ(        F6                )
#define T41 _EQ(        F7                )
#define T42 _EQ(        F8                )
#define T43 _EQ(        F9                )
#define T44 _EQ(        F10               )
#define T45 _EQ(        NUMLOCK           ) // PF1 : Num Lock
#define T46 _EQ(        SCROLL            ) // F19 : Scroll Lock
#define T47 _EQ(        HOME              ) // KP7 : Home
#define T48 _EQ(        UP                ) // KP8 : Up
#define T49 _EQ(        PRIOR             ) // KP9 : Page Up
#define T4A _EQ(        SUBTRACT          ) // PF4 : "-"
#define T4B _EQ(        LEFT              ) // KP4 : Left
#define T4C _EQ(        CLEAR             ) // KP5 : Clear
#define T4D _EQ(        RIGHT             ) // KP6 : Right
#define T4E _EQ(        ADD               ) // KP, : Add
#define T4F _EQ(        END               ) // KP1 : End
#define T50 _EQ(        DOWN              ) // KP2 : Down
#define T51 _EQ(        NEXT              ) // KP3 : Next
#define T52 _EQ(        INSERT            ) // KP0 : Ins
#define T53 _EQ(        DELETE            ) // KP. : Del
#define T54 _EQ(        SNAPSHOT          )
#define T55 _EQ(        _none_            )
#define T56 _EQ(        _none_            )
#define T57 _EQ(        F11               )
#define T58 _EQ(        F12               )
#define T59 _EQ(        _none_            )
#define T5A _EQ(        _none_            )
#define T5B _EQ(        _none_            )
#define T5C _EQ(        _none_            )
#define T5D _EQ(        _none_            )
#define T5E _EQ(        _none_            )
#define T5F _EQ(        _none_            )
#define T60 _EQ(        _none_            )
#define T61 _EQ(        _none_            )
#define T62 _EQ(        _none_            )
#define T63 _EQ(        _none_            )
#define T64 _EQ(        _none_            )
#define T65 _EQ(        _none_            )
#define T66 _EQ(        _none_            )
#define T67 _EQ(        _none_            )
#define T68 _EQ(        _none_            )
#define T69 _EQ(        _none_            )
#define T6A _EQ(        _none_            )
#define T6B _EQ(        _none_            )
#define T6C _EQ(        _none_            )
#define T6D _EQ(        _none_            )
#define T6E _EQ(        _none_            )
#define T6F _EQ(        _none_            )
#define T70 _EQ(       DBE_HIRAGANA       ) // Hiragana/Katakana
#define T71 _EQ(        _none_            )
#define T72 _EQ(        _none_            )
#define T73 _NE( OEM_102,     _none_      ) // LK411JJ, Katakana "Ro"
#define T74 _EQ(        _none_            )
#define T75 _EQ(        _none_            )
#define T76 _EQ(        _none_            )
#define T77 _EQ(        _none_            )
#define T78 _EQ(        _none_            )
#define T79 _EQ(        CONVERT           ) // Henkan
#define T7A _EQ(        _none_            )
#define T7B _EQ(        NONCONVERT        ) // Mu-Henkan
#define T7C _EQ(        _none_            )
#define T7D _NE( OEM_5,       _none_      ) // LK411JJ, Yen(Back-slash)
#define T7E _EQ(        _none_            )
#define T7F _EQ(        _none_            )

#define X0F _EQ(        KANA              ) // Kana
#define X1C _EQ(        RETURN            ) // Enter
#define X1D _EQ(        RCONTROL          ) // Comp : Right Control
#define X33 _EQ(        _none_            )
#define X35 _EQ(        DIVIDE            ) // PF2: "/"
#define X37 _EQ(        SNAPSHOT          ) // F18: PrintScreen
#define X38 _EQ(        RMENU             ) // Alt(Right)
#define X3D _EQ(        F13               )
#define X3E _EQ(        F14               )
#define X3F _EQ(        F15               ) // Help : F15
#define X40 _EQ(        F16               ) // Do :   F16
#define X41 _EQ(        F17               )
#define X42 _EQ(        _none_            )
#define X43 _EQ(        _none_            )
#define X44 _EQ(        _none_            )
#define X46 _EQ(        CANCEL            )
#define X47 _EQ(        HOME              ) // Find : HOME
#define X48 _EQ(        UP                )
#define X49 _EQ(        PRIOR             ) // Prev : PageUp
#define X4B _EQ(        LEFT              )
#define X4D _EQ(        RIGHT             )
#define X4E _EQ(        ADD               ) // KP- (Minus but "Add")
#define X4F _EQ(        END               ) // Select : END
#define X50 _EQ(        DOWN              )
#define X51 _EQ(        NEXT              ) // Next : PageDown
#define X52 _EQ(        INSERT            )
#define X53 _EQ(        DELETE            ) // Remove
#define X5B _EQ(        _none_            )
#define X5C _EQ(        _none_            )
#define X5D _EQ(        _none_            )
#define X5E _EQ(        POWER             )
#define X5F _EQ(        SLEEP             )
        /*
         * The break key is sent to us as E1,LCtrl,NumLock
         * We must convert the E1+LCtrl to BREAK, then ignore the Numlock
         */
#define Y1D _EQ(        PAUSE             )

#endif // KBD_TYPE

#define SCANCODE_LSHIFT      0x2A
#define SCANCODE_RSHIFT      0x36
#define SCANCODE_CTRL        0x1D
#define SCANCODE_ALT         0x38
#define SCANCODE_SIMULATED   (FAKE_KEYSTROKE >> 16)

#define SCANCODE_NUMPAD_FIRST 0x47
#define SCANCODE_NUMPAD_LAST  0x52

#define SCANCODE_LWIN         0x5B
#define SCANCODE_RWIN         0x5C

#define SCANCODE_THAI_LAYOUT_TOGGLE 0x29

/*
 * Hydra FarEast
 */

/*
 * Structure for client keyboard information
 */
typedef struct _CLIENTKEYBOARDTYPE {
    ULONG Type;
    ULONG SubType;
    ULONG FunctionKey;
} CLIENTKEYBOARDTYPE, *PCLIENTKEYBOARDTYPE;


#endif // _KBD_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\public\oak\inc\mcdrv.h ===
/******************************Module*Header*******************************\
* Module Name: mcdrv.h
*
* Server-side data structure for MCD driver interface.  These structures and
* values are used by the MCD driver to process calls made to the driver.
*
* Copyright (c) 1996-1997 Microsoft Corporation
*
\**************************************************************************/

#ifndef _MCDRV_H
#define _MCDRV_H

//
// The MCD version is defaulted to the most conservative version number.
// Override these defines if you wish to compile a driver with different
// version information.
//

#ifndef MCD_VER_MAJOR
#define MCD_VER_MAJOR               1
#endif

#ifndef MCD_VER_MINOR
#define MCD_VER_MINOR               0
#endif

#define MCD_MAX_USER_CLIP_PLANES    6

#define MCDRV_MEM_BUSY              1
#define MCDRV_MEM_NOT_BUSY          2

typedef ENUMRECTS MCDENUMRECTS;
typedef HANDLE MCDHANDLE;
typedef float MCDFLOAT;
typedef double MCDDOUBLE;

#define MCDENGDLLNAME	"MCDSRV32.DLL"
#define MCDFUNCS 3076

#define MCDRV_MEM_DMA   0x0001

#define MCDRV_TEXTURE_RESIDENT	0x0001

typedef struct _MCDRIVERINFO {
    ULONG verMajor;
    ULONG verMinor;
    ULONG verDriver;
    CHAR  idStr[200];
    ULONG drvMemFlags;
    ULONG drvBatchMemSizeMax;
} MCDDRIVERINFO;

typedef struct _MCDWINDOW
{
    RECTL clientRect;               // Rectangle describing current window
                                    //   client area
    RECTL clipBoundsRect;           // Bounding rectangle for the individual
                                    //   clipping rectangles
    MCDENUMRECTS *pClip;            // List of rectangles describing the
                                    //   current clip region intersected
                                    //   with the current scissors rectangle
    MCDENUMRECTS *pClipUnscissored; // Unscissored version of above
    VOID *pvUser;
} MCDWINDOW;

// Rendering context

// MCD context createFlags:
//
// MCDCONTEXT_SWAPSYNC          If set, synchronize MCDrvSwap to VSYNC
//                              for a tearless swap (if possible).
//
// MCDCONTEXT_IO_PRIORITY       If set, allow OpenGL to have a higher priority
//                              on the bus (if possible, let OpenGL "hog" the
//                              bus).
//

#define MCDCONTEXT_SWAPSYNC         0x00000001
#define MCDCONTEXT_IO_PRIORITY      0x00000002

typedef struct _MCDRC
{
    LONG iPixelFormat;              // Pixel format for the RC
    LONG iLayerPlane;               // Layer plane for the RC
    ULONG createFlags;              // Creation flags
    ULONG userFlags;                // User-specified flags
    VOID *pvUser;                   // User-specified pointer for expansion
} MCDRC;


#define MCDRCINFO_NOVIEWPORTADJUST   0x0001
#define MCDRCINFO_Y_LOWER_LEFT       0x0002
#define MCDRCINFO_DEVCOLORSCALE      0x0004
#define MCDRCINFO_DEVZSCALE          0x0008

// If set the system provides state updates
// with fine-grained state updates rather
// than through RENDERSTATE.  This is
// required if the driver exports
// MCDrvProcess.
#define MCDRCINFO_FINE_GRAINED_STATE 0x0010

typedef struct _MCRCINFO
{
    ULONG requestFlags;
    MCDFLOAT redScale;
    MCDFLOAT greenScale;
    MCDFLOAT blueScale;
    MCDFLOAT alphaScale;
    MCDDOUBLE zScale;               // This is a double to preserve accuracy
    ULONG depthBufferMax;
    LONG viewportXAdjust;
    LONG viewportYAdjust;
    ULONG reserved[12];
} MCDRCINFO;


// MCD pixel format descriptor

typedef struct _MCDPIXELFORMAT {
    WORD  nSize;
    DWORD dwFlags;                  // Any combination of:
                                    //
                                    //      PFD_DOUBLEBUFFER
                                    //      PFD_NEED_PALETTE
                                    //      PFD_NEED_SYSTEM_PALETTE
                                    //      PFD_SWAP_EXCHANGE
                                    //      PFD_SWAP_COPY
                                    //      PFD_SWAP_LAYER_BUFFERS

    BYTE  iPixelType;               // One of the following:
                                    //
                                    //      PFD_TYPE_RGBA
                                    //      PFD_TYPE_COLORINDEX

    BYTE  cColorBits;
    BYTE  cRedBits;
    BYTE  cRedShift;
    BYTE  cGreenBits;
    BYTE  cGreenShift;
    BYTE  cBlueBits;
    BYTE  cBlueShift;
    BYTE  cAlphaBits;
    BYTE  cAlphaShift;
    BYTE  cDepthBits;               // Number of significant depth bits
    BYTE  cDepthShift;
    BYTE  cDepthBufferBits;         // Element size of depth buffer
                                    // (eg, a depth buffer with cDepthBits = 24
                                    // might have a cDepthBufferBits = 32)
    BYTE  cStencilBits;
    BYTE  cOverlayPlanes;           // Count of up to 15 overlay planes
    BYTE  cUnderlayPlanes;          // Count of up to 15 underlay planes
    DWORD dwTransparentColor;       // If there is an underlay plane, specifies
                                    // transparent color or index.
} MCDPIXELFORMAT;

// MCD layer plane descriptor

typedef struct _MCDLAYERPLANE {
    WORD  nSize;
    WORD  nVersion;
    DWORD dwFlags;                  // Any combination of:
                                    //
                                    //      LPD_SUPPORT_OPENGL
                                    //      LPD_SUPPORT_GDI
                                    //      LPD_DOUBLEBUFFER
                                    //      LPD_STEREO
                                    //      LPD_SWAP_EXCHANGE
                                    //      LPD_SWAP_COPY
                                    //      LPD_TRANSPARANT
                                    //      LPD_SHARE_DEPTH
                                    //      LPD_SHARE_STENCIL
                                    //      LPD_SHARE_ACCUM

    BYTE  iPixelType;               // One of the following:
                                    //
                                    //      LPD_TYPE_RGBA
                                    //      LPD_TYPE_COLORINDEX

    BYTE  cColorBits;
    BYTE  cRedBits;
    BYTE  cRedShift;
    BYTE  cGreenBits;
    BYTE  cGreenShift;
    BYTE  cBlueBits;
    BYTE  cBlueShift;
    BYTE  cAlphaBits;
    BYTE  cAlphaShift;
    BYTE  cAuxBuffers;
    BYTE  iLayerPlane;
    COLORREF crTransparent;

} MCDLAYERPLANE;


//
// Basic rendering types:
//

typedef struct _MCDCOLOR {
    MCDFLOAT r, g, b, a;
} MCDCOLOR;

typedef struct _MCDCOORD {
    MCDFLOAT x, y, z, w;
} MCDCOORD;


//
// Texture structures:
//

typedef struct __MCDMIPMAPLEVEL {
    UCHAR *pTexels;                     // pointer to client texture data
    LONG width, height;
    LONG widthImage, heightImage;       // Image dimensions without the border
    MCDFLOAT widthImagef, heightImagef; // Floatin-point versions of above
    LONG widthLog2, heightLog2;         // Log2 of above
    LONG border;                        // Border size
    LONG requestedFormat;               // Requested internal format
    LONG baseFormat;                    // Base format
    LONG internalFormat;                // Actual internal format

    LONG redSize;                       // Component resolution
    LONG greenSize;
    LONG blueSize;
    LONG alphaSize;
    LONG luminanceSize;
    LONG intensitySize;

    ULONG reserved;

} MCDMIPMAPLEVEL;

typedef struct __MCDTEXTURESTATE {

    ULONG sWrapMode;                    // Wrap modes
    ULONG tWrapMode;

    ULONG minFilter;                    // Min/mag filters               
    ULONG magFilter;

    MCDCOLOR borderColor;               // Border color

} MCDTEXTURESTATE;

typedef struct __MCDTEXTUREOBJSTATE {
    ULONG name;                         // "name" of texture object
    MCDFLOAT priority;                  // priority of the texture object
} MCDTEXTUREOBJSTATE;

typedef struct __MCDTEXTUREDATA {
    MCDTEXTURESTATE textureState;
    MCDTEXTUREOBJSTATE textureObjState;
    MCDMIPMAPLEVEL *level;
    ULONG textureDimension;

    // Support for texture palettes:

    ULONG paletteSize;
    RGBQUAD *paletteData;
    ULONG paletteBaseFormat;            // Type of palette data
    ULONG paletteRequestedFormat;

} MCDTEXTUREDATA;

typedef struct _MCDTEXTURE {
    MCDTEXTUREDATA *pMCDTextureData;
    VOID *pSurface;
    ULONG createFlags;
    ULONG_PTR textureKey;       // Must be filled in by the driver
    ULONG userFlags;
    VOID *pvUser;
} MCDTEXTURE;


//
// Memory block.
//

typedef struct _MCDMEM {
    ULONG memSize;
    ULONG createFlags;
    UCHAR *pMemBase;
    ULONG userFlags;
    VOID *pvUser;
} MCDMEM;


//
// Generic description prefix for any state change.
//

typedef struct _MCDSTATE_PREFIX {
    ULONG state;
    ULONG size;
} MCDSTATE_PREFIX;

typedef struct _MCDSTATE {
    ULONG state;
    ULONG size;
    ULONG stateValue;
} MCDSTATE;

#define MCD_RENDER_STATE                0
#define MCD_PIXEL_STATE                 1
#define MCD_SCISSOR_RECT_STATE          2
#define MCD_TEXENV_STATE                3
#define MCD_ENABLE_STATE                4
#define MCD_TEXTURE_ENABLE_STATE        5
#define MCD_FOG_STATE                   6
#define MCD_SHADEMODEL_STATE            7
#define MCD_POINTDRAW_STATE             8
#define MCD_LINEDRAW_STATE              9
#define MCD_POLYDRAW_STATE              10
#define MCD_ALPHATEST_STATE             11
#define MCD_DEPTHTEST_STATE             12
#define MCD_BLEND_STATE                 13
#define MCD_LOGICOP_STATE               14
#define MCD_FRAMEBUF_STATE              15
#define MCD_LIGHT_MODEL_STATE           16
#define MCD_HINT_STATE                  17
#define MCD_CLIP_STATE                  18
#define MCD_STENCILTEST_STATE           19

//
// MCDSTATE_RENDER is derived from the MCDSTATE_PREFIX structure and is used
// to pass all MCD rendering state (MCDRENDERSTATE) in a single command
// via MCDrvState.
//
// State field names are derived from the GLenum constant names by removing
// the GL_ prefix, replacing the "_" separators with case changes, and
// adding the "Enable" suffix to state enables.
//
// For example:
//
//  GL_FOG_COLOR    becomes     fogColor
//  GL_POINT_SMOOTH becomes     pointSmoothEnable
//
// In addition, there are few multiple values that are accessed via a single
// GLenum.  For example, GL_POLYGON_MODE returns both a front and a back
// polygon mode, so:
//
//  GL_POLYGON_MODE becomes     polygonModeFront *and* polygonModeBack
//

// Enable flags for enables field in MCDRENDERSTATE

#define MCD_ALPHA_TEST_ENABLE                  (1 <<  0)
#define MCD_BLEND_ENABLE                       (1 <<  1)
#define MCD_INDEX_LOGIC_OP_ENABLE              (1 <<  2)
#define MCD_DITHER_ENABLE                      (1 <<  3)
#define MCD_DEPTH_TEST_ENABLE                  (1 <<  4)
#define MCD_FOG_ENABLE                         (1 <<  5)
#define MCD_LIGHTING_ENABLE                    (1 <<  6)
#define MCD_COLOR_MATERIAL_ENABLE              (1 <<  7)
#define MCD_LINE_STIPPLE_ENABLE                (1 <<  8)
#define MCD_LINE_SMOOTH_ENABLE                 (1 <<  9)
#define MCD_POINT_SMOOTH_ENABLE                (1 << 10)
#define MCD_POLYGON_SMOOTH_ENABLE              (1 << 11)
#define MCD_CULL_FACE_ENABLE                   (1 << 12)
#define MCD_POLYGON_STIPPLE_ENABLE             (1 << 13)
#define MCD_SCISSOR_TEST_ENABLE                (1 << 14)
#define MCD_STENCIL_TEST_ENABLE                (1 << 15)
#define MCD_TEXTURE_1D_ENABLE                  (1 << 16)
#define MCD_TEXTURE_2D_ENABLE                  (1 << 17)
#define MCD_TEXTURE_GEN_S_ENABLE               (1 << 18)
#define MCD_TEXTURE_GEN_T_ENABLE               (1 << 19)
#define MCD_TEXTURE_GEN_R_ENABLE               (1 << 20)
#define MCD_TEXTURE_GEN_Q_ENABLE               (1 << 21)
#define MCD_NORMALIZE_ENABLE                   (1 << 22)
#define MCD_AUTO_NORMAL_ENABLE                 (1 << 23) // Not currently used
#define MCD_POLYGON_OFFSET_POINT_ENABLE        (1 << 24)
#define MCD_POLYGON_OFFSET_LINE_ENABLE         (1 << 25)
#define MCD_POLYGON_OFFSET_FILL_ENABLE         (1 << 26)
#define MCD_COLOR_LOGIC_OP_ENABLE              (1 << 27)
#define MCD_SPECULAR_FOG_ENABLE                (1 << 29)

typedef struct _MCDRENDERSTATE {

    // state enables

    ULONG enables;

    // texture state

    BOOL textureEnabled;

    // fog state

    MCDCOLOR fogColor;
    MCDFLOAT fogIndex;
    MCDFLOAT fogDensity;
    MCDFLOAT fogStart;
    MCDFLOAT fogEnd;
    ULONG fogMode;

    // shading model state

    ULONG shadeModel;

    // point drawing state

    MCDFLOAT pointSize;

    // line drawing state

    MCDFLOAT lineWidth;
    USHORT lineStipplePattern;
    SHORT lineStippleRepeat;

    // polygon drawing state

    ULONG cullFaceMode;
    ULONG frontFace;
    ULONG polygonModeFront;
    ULONG polygonModeBack;
    BYTE polygonStipple[4*32];
    MCDFLOAT zOffsetFactor;
    MCDFLOAT zOffsetUnits;

    // stencil test state

    BOOL stencilTestFunc;
    USHORT stencilMask;
    USHORT stencilRef;
    ULONG stencilFail;
    ULONG stencilDepthFail;
    ULONG stencilDepthPass;

    // alpha test state

    ULONG alphaTestFunc;
    MCDFLOAT alphaTestRef;

    // depth test state

    ULONG depthTestFunc;

    // blend state

    ULONG blendSrc;
    ULONG blendDst;

    // logic op state

    ULONG logicOpMode;

    // frame buffer control state

    ULONG drawBuffer;
    ULONG indexWritemask;
    BOOL colorWritemask[4];
    BOOL depthWritemask;      // Called mask, but really a write enable
    USHORT stencilWritemask;
    MCDCOLOR colorClearValue;
    MCDFLOAT indexClearValue;
    MCDDOUBLE depthClearValue;
    USHORT stencilClearValue;

    // lighting

    BOOL twoSided;

    // clipping control

    MCDCOORD userClipPlanes[MCD_MAX_USER_CLIP_PLANES];

    // hints

    ULONG perspectiveCorrectionHint;
    ULONG pointSmoothHint;
    ULONG lineSmoothHint;
    ULONG polygonSmoothHint;
    ULONG fogHint;

} MCDRENDERSTATE;

typedef struct _MCDSTATE_RENDER {
    ULONG    state;     // must be MCD_RENDER_STATE
    ULONG    size;      // must be sizeof(MCDSTATE_RENDER)
    MCDRENDERSTATE allState;
} MCDSTATE_RENDER;

//
// MCDSTATEPIXEL is a variant of the MCDSTATE structure that is used
// to pass all pixel state (MCDPIXELSTATE) in a single command
// via MCDrvState.
//
// Note: for MCDrvDrawPixels, the MCDUNPACK structure can be overridden by
// the packed parameter to the function.  If set, the source of the data is
// a display list and the structure of the data for that call may be assumed
// to be:
//
//      swapEndian = FALSE
//      lsbFirst   = FALSE
//      lineLength = width (from MCDrvDrawPixels parameter list)
//      skipLines  = 0
//      skipPixels = 0
//      alignment  = 1
//

typedef struct _MCDPIXELTRANSFER {
    MCDFLOAT redScale, greenScale, blueScale, alphaScale, depthScale;
    MCDFLOAT redbias, greenBias, blueBias, aalphaBias, depthBias;
    MCDFLOAT zoomX;
    MCDFLOAT zoomY;

    LONG indexShift;
    LONG indexOffset;

    BOOL mapColor;
    BOOL mapStencil;
} MCDPIXELTRANSFER;

typedef struct _MCDPIXELPACK {
    BYTE swapEndian;
    BYTE lsbFirst;

    LONG lineLength;
    LONG skipLines;
    LONG skipPixels;
    LONG alignment;
    LONG lReserved;
} MCDPIXELPACK;

typedef struct _MCDPIXELUNPACK {
    BYTE swapEndian;
    BYTE lsbFirst;

    LONG lineLength;
    LONG skipLines;
    LONG skipPixels;
    LONG alignment;
    LONG lReserved;
} MCDPIXELUNPACK;

typedef struct _MCDPIXELSTATE {
    MCDPIXELTRANSFER pixelTransferModes;
    MCDPIXELPACK pixelPackModes;
    MCDPIXELUNPACK pixelUnpackModes;
    ULONG readBuffer;
    MCDCOORD rasterPos;
} MCDPIXELSTATE;

typedef struct _MCDSTATE_PIXEL {
    ULONG    state;     // must be MCD_PIXEL_STATE
    ULONG    size;      // must be sizeof(MCDSTATE_PIXEL)
    MCDPIXELSTATE pixelState;
} MCDSTATE_PIXEL;

//
// MCDSTATE_SCISSOR_RECT is a variant of the MCDSTATE structure
// that is used to pass the scissor rectangle to the MCD driver
// via MCDrvState.
//

typedef struct _MCDSTATE_SCISSOR_RECT {
    ULONG   state;      // must be MCD_SCISSOR_RECT_STATE
    ULONG   size;       // must be sizeof(MCDSTATE_SCISSOR_RECT)
    RECTL   scissorRect;
} MCDSTATE_SCISSOR_RECT;

//
// MCDSTATE_TEXENV is a variant of the MCDSTATE structure that is
// used to pass the texture environment state to the MCD driver
// via MCDrvState.
//

typedef struct _MCDTEXENVSTATE {
    ULONG    texEnvMode;
    MCDCOLOR texEnvColor;
} MCDTEXENVSTATE;

typedef struct _MCDSTATE_TEXENV {
    ULONG   state;      // must be MCD_TEXENV_STATE
    ULONG   size;       // must be sizeof(MCDSTATE_TEXENV)
    MCDTEXENVSTATE texEnvState;
} MCDSTATE_TEXENV;

//
// MCDVIEWPORT is used to pass viewport state to the MCD driver
// via MCDrvViewport.

typedef struct _MCDVIEWPORT {
    MCDFLOAT xScale, xCenter;
    MCDFLOAT yScale, yCenter;
    MCDFLOAT zScale, zCenter;
} MCDVIEWPORT;

//
// Fine-grained state updates.  Sent to a driver only if
// MCDRCINFO_FINE_GRAINED_STATE was returned on context creation.
//

// Enable state.
typedef struct _MCDENABLESTATE {
    ULONG enables;
} MCDENABLESTATE;

// Texture enable state.  Different from plain enables in that it
// indicates whether all texturing state is consistent and ready for
// texturing.
typedef struct _MCDTEXTUREENABLESTATE {
    BOOL textureEnabled;
} MCDTEXTUREENABLESTATE;

// Fog state.
typedef struct _MCDFOGSTATE {
    MCDCOLOR fogColor;
    MCDFLOAT fogIndex;
    MCDFLOAT fogDensity;
    MCDFLOAT fogStart;
    MCDFLOAT fogEnd;
    ULONG fogMode;
} MCDFOGSTATE;

// Shading model state.
typedef struct _MCDSHADELMODELSTATE {
    ULONG shadeModel;
} MCDSHADEMODELSTATE;

// Point drawing state.
typedef struct _MCDPOINTDRAWSTATE {
    MCDFLOAT pointSize;
} MCDPOINTDRAWSTATE;

// Line drawing state.
typedef struct _MCDLINEDRAWSTATE {
    MCDFLOAT lineWidth;
    USHORT lineStipplePattern;
    SHORT lineStippleRepeat;
} MCDLINEDRAWSTATE;

// Polygon drawing state.
typedef struct _MCDPOLYDRAWSTATE {
    ULONG cullFaceMode;
    ULONG frontFace;
    ULONG polygonModeFront;
    ULONG polygonModeBack;
    BYTE polygonStipple[4*32];
    MCDFLOAT zOffsetFactor;
    MCDFLOAT zOffsetUnits;
} MCDPOLYDRAWSTATE;

// Alpha test state.
typedef struct _MCDALPHATESTSTATE {
    ULONG alphaTestFunc;
    MCDFLOAT alphaTestRef;
} MCDALPHATESTSTATE;

// Depth test state.
typedef struct _MCDDEPTHTESTSTATE {
    ULONG depthTestFunc;
} MCDDEPTHTESTSTATE;

// Blend state.
typedef struct _MCDBLENDSTATE {
    ULONG blendSrc;
    ULONG blendDst;
} MCDBLENDSTATE;

// Logic op state.
typedef struct _MCDLOGICOPSTATE {
    ULONG logicOpMode;
} MCDLOGICOPSTATE;

// Frame buffer control state.
typedef struct _MCDFRAMEBUFSTATE {
    ULONG drawBuffer;
    ULONG indexWritemask;
    BOOL colorWritemask[4];
    BOOL depthWritemask;      // Called mask, but really a write enable.
    USHORT stencilWritemask;
    MCDCOLOR colorClearValue;
    MCDFLOAT indexClearValue;
    MCDDOUBLE depthClearValue;
    USHORT stencilClearValue;
} MCDFRAMEBUFSTATE;

// Light model state.
typedef struct _MCDLIGHTMODELSTATE {
    MCDCOLOR ambient;           // Scaled
    BOOL localViewer;
    BOOL twoSided;
} MCDLIGHTMODELSTATE;

// Hint state.
typedef struct _MCDHINTSTATE {
    ULONG perspectiveCorrectionHint;
    ULONG pointSmoothHint;
    ULONG lineSmoothHint;
    ULONG polygonSmoothHint;
    ULONG fogHint;
} MCDHINTSTATE;

// Clipping state.
typedef struct _MCDCLIPSTATE {
    ULONG userClipEnables;
    // Given by program
    MCDCOORD userClipPlanes[MCD_MAX_USER_CLIP_PLANES];
    // userClipPlanes transformed by modelview inverse
    MCDCOORD userClipPlanesInv[MCD_MAX_USER_CLIP_PLANES];
} MCDCLIPSTATE;

// Stencil test state.
typedef struct _MCDSTENCILTESTSTATE {
    BOOL stencilTestFunc;
    USHORT stencilMask;
    USHORT stencilRef;
    ULONG stencilFail;
    ULONG stencilDepthFail;
    ULONG stencilDepthPass;
} MCDSTENCILTESTSTATE;
        

//
// MCDBUF.bufFlags flags:
//
// MCDBUF_ENABLED       If set, direct buffer access is enabled (i.e., the
//                      bufOffset and bufStride values are valid and may
//                      be used to access the buffer).
//
// MCDBUF_NOCLIP        If set, indicates that clipping is not required
//                      for the current state of the window.
//

#define MCDBUF_ENABLED  0x00000001
#define MCDBUF_NOCLIP   0x00000002

typedef struct _MCDBUF {
    ULONG bufFlags;
    LONG  bufOffset;        // offset relative to beginning of framebuffer
    LONG  bufStride;
} MCDBUF;

typedef struct _MCDBUFFERS {
    MCDBUF mcdFrontBuf;
    MCDBUF mcdBackBuf;
    MCDBUF mcdDepthBuf;
} MCDBUFFERS;

//
// MCD surface flags:
//
// MCDSURFACE_HWND

#define MCDSURFACE_HWND             0x00000001

typedef struct _MCDSURFACE {
    MCDWINDOW *pWnd;                // Region support
    SURFOBJ *pso;
    WNDOBJ *pwo;
    ULONG reserved[4];
    ULONG surfaceFlags;
} MCDSURFACE;

#define MCDSPAN_FRONT   1
#define MCDSPAN_BACK    2
#define MCDSPAN_DEPTH   3

typedef struct _MCDSPAN {
    LONG x;
    LONG y;
    LONG numPixels;
    ULONG type;
    VOID *pPixels;
} MCDSPAN;

//
// MCDrvSwap flags
//

#define MCDSWAP_MAIN_PLANE      0x00000001
#define MCDSWAP_OVERLAY1        0x00000002
#define MCDSWAP_OVERLAY2        0x00000004
#define MCDSWAP_OVERLAY3        0x00000008
#define MCDSWAP_OVERLAY4        0x00000010
#define MCDSWAP_OVERLAY5        0x00000020
#define MCDSWAP_OVERLAY6        0x00000040
#define MCDSWAP_OVERLAY7        0x00000080
#define MCDSWAP_OVERLAY8        0x00000100
#define MCDSWAP_OVERLAY9        0x00000200
#define MCDSWAP_OVERLAY10       0x00000400
#define MCDSWAP_OVERLAY11       0x00000800
#define MCDSWAP_OVERLAY12       0x00001000
#define MCDSWAP_OVERLAY13       0x00002000
#define MCDSWAP_OVERLAY14       0x00004000
#define MCDSWAP_OVERLAY15       0x00008000
#define MCDSWAP_UNDERLAY1       0x00010000
#define MCDSWAP_UNDERLAY2       0x00020000
#define MCDSWAP_UNDERLAY3       0x00040000
#define MCDSWAP_UNDERLAY4       0x00080000
#define MCDSWAP_UNDERLAY5       0x00100000
#define MCDSWAP_UNDERLAY6       0x00200000
#define MCDSWAP_UNDERLAY7       0x00400000
#define MCDSWAP_UNDERLAY8       0x00800000
#define MCDSWAP_UNDERLAY9       0x01000000
#define MCDSWAP_UNDERLAY10      0x02000000
#define MCDSWAP_UNDERLAY11      0x04000000
#define MCDSWAP_UNDERLAY12      0x08000000
#define MCDSWAP_UNDERLAY13      0x10000000
#define MCDSWAP_UNDERLAY14      0x20000000
#define MCDSWAP_UNDERLAY15      0x40000000


//
// Clip codes:
//

#define MCD_CLIP_LEFT           0x00000001
#define MCD_CLIP_RIGHT          0x00000002
#define MCD_CLIP_BOTTOM         0x00000004
#define MCD_CLIP_TOP            0x00000008
#define MCD_CLIP_NEAR           0x00000010
#define MCD_CLIP_FAR            0x00000020
#define MCD_CLIP_MASK           0x0000003f

//
// Vertex flags:
//

#define MCDVERTEX_EDGEFLAG              0x00000001

//
// Color indices:
//

#define MCDVERTEX_FRONTFACE     0
#define MCDVERTEX_BACKFACE      1

//
// Note: vertex colors are scaled to the color depths reported in the
// pixel format.
//

typedef struct _MCDVERTEX {

    ULONG flags;                // vertex flags
    MCDCOLOR *pColor;           // pointer to active vertex color
    ULONG clipCode;             // clip code
    MCDFLOAT fog;               // fog value (0..1)
    MCDCOORD clipCoord;         // clip-space coordinate
    MCDCOORD windowCoord;       // window coordinate
    MCDCOORD texCoord;          // texture coordinate
    MCDCOORD normal;            // vertex normal
    MCDCOLOR colors[2];         // front and back vertex colors
    MCDCOORD eyeCoord;          // eye coordinate
} MCDVERTEX;

typedef struct _MCDCOMMAND MCDCOMMAND;

#define MCDCOMMAND_RESET_STIPPLE        0x00004000
#define MCDCOMMAND_RENDER_PRIMITIVE     0x00008000
#define MCDCOMMAND_SAME_COLOR           0x00040000

typedef struct _MCDCOMMAND {
    ULONG flags;                // flags for this command
    MCDVERTEX *pEndVertex;
    ULONG reserved2;
    ULONG reserved3;
    ULONG reserved4;
    ULONG reserved5;
    MCDVERTEX *pStartVertex;
    ULONG reserved7;
    ULONG reserved8;
    MCDVERTEX *pVertexBuffer;
    ULONG reserved10;
    ULONG reserved11;
    ULONG reserved12;
    ULONG reserved13;
    ULONG reserved14;
    ULONG command;              // primitive type or command (GL_TRIANGLES, etc.)
    ULONG clipCodes;
    ULONG reserved17;
    ULONG reserved18;
    MCDCOMMAND *pNextCmd;
    ULONG numIndices;
    UCHAR *pIndices;
    ULONG reserved22;
    ULONG textureKey;
} MCDCOMMAND;


// MCDDRIVER structure containing driver functions

typedef LONG     (*MCDRVDESCRIBEPIXELFORMATFUNC)(MCDSURFACE *pMCDSurface, LONG iPixelFormat,
                                                 ULONG nBytes, MCDPIXELFORMAT *pMCDPixelFmt, ULONG flags);
typedef BOOL     (*MCDRVDESCRIBELAYERPLANEFUNC)(MCDSURFACE *pMCDSurface, LONG iPixelFormat,
                                                LONG iLayerPlane, ULONG nBytes, MCDLAYERPLANE *pMCDLayerPlane,
                                                ULONG flags);
typedef LONG     (*MCDRVSETLAYERPALETTEFUNC)(MCDSURFACE *pMCDSurface, LONG iLayerPlane, BOOL bRealize, LONG cEntries, COLORREF *pcr);
typedef BOOL     (*MCDRVINFOFUNC)(MCDSURFACE *pMCDSurface, MCDDRIVERINFO *pMCDDriverInfo);
typedef ULONG    (*MCDRVCREATECONTEXTFUNC)(MCDSURFACE *pMCDSurface, MCDRC *pRc, MCDRCINFO *pDrvRcInfo);
typedef ULONG    (*MCDRVDELETECONTEXTFUNC)(MCDRC *pRc, DHPDEV dhpdev);
typedef ULONG    (*MCDRVCREATETEXTUREFUNC)(MCDSURFACE *pMCDSurface, MCDRC *pRc, MCDTEXTURE *pTex);
typedef ULONG    (*MCDRVUPDATESUBTEXTUREFUNC)(MCDSURFACE *pMCDSurface, MCDRC *pRc, MCDTEXTURE *pTex, 
                                              ULONG lod, RECTL *pRect);
typedef ULONG    (*MCDRVUPDATETEXTUREPALETTEFUNC)(MCDSURFACE *pMCDSurface, MCDRC *pRc, MCDTEXTURE *pTex, 
                                                  ULONG start, ULONG numEntries);
typedef ULONG    (*MCDRVUPDATETEXTUREPRIORITYFUNC)(MCDSURFACE *pMCDSurface, MCDRC *pRc, MCDTEXTURE *pTex);
typedef ULONG    (*MCDRVUPDATETEXTURESTATEFUNC)(MCDSURFACE *pMCDSurface, MCDRC *pRc, MCDTEXTURE *pTex);
typedef ULONG    (*MCDRVTEXTURESTATUSFUNC)(MCDSURFACE *pMCDSurface, MCDRC *pRc, MCDTEXTURE *pTex);
typedef ULONG    (*MCDRVDELETETEXTUREFUNC)(MCDTEXTURE *pTex, DHPDEV dhpdev);
typedef ULONG    (*MCDRVCREATEMEMFUNC)(MCDSURFACE *pMCDSurface, MCDMEM *pMCDMem);
typedef ULONG    (*MCDRVDELETEMEMFUNC)(MCDMEM *pMCDMem, DHPDEV dhpdev);
typedef ULONG_PTR (*MCDRVDRAWFUNC)(MCDSURFACE *pMCDSurface, MCDRC *pRc, MCDMEM *pMCDExecMem, UCHAR *pStart, UCHAR *pEnd);
typedef ULONG    (*MCDRVCLEARFUNC)(MCDSURFACE *pMCDSurface, MCDRC *pRc, ULONG buffers);
typedef ULONG    (*MCDRVSWAPFUNC)(MCDSURFACE *pMCDSurface, ULONG flags);
typedef ULONG    (*MCDRVSTATEFUNC)(MCDSURFACE *pMCDSurface, MCDRC *pRc, MCDMEM *pMCDMem,
                                   UCHAR *pStart, LONG length, ULONG numStates);
typedef ULONG    (*MCDRVVIEWPORTFUNC)(MCDSURFACE *pMCDSurface, MCDRC *pRc, MCDVIEWPORT *pMCDViewport);
typedef HDEV     (*MCDRVGETHDEVFUNC)(MCDSURFACE *pMCDSurface);
typedef ULONG    (*MCDRVSPANFUNC)(MCDSURFACE *pMCDSurface, MCDRC *pRc, MCDMEM *pMCDMem,
                                  MCDSPAN *pMCDSpan, BOOL bRead);
typedef VOID     (*MCDRVTRACKWINDOWFUNC)(WNDOBJ *pWndObj, MCDWINDOW *pMCDWnd, ULONG flags);
typedef ULONG    (*MCDRVGETBUFFERSFUNC)(MCDSURFACE *pMCDSurface, MCDRC *pRc, MCDBUFFERS *pMCDBuffers);
typedef ULONG    (*MCDRVALLOCBUFFERSFUNC)(MCDSURFACE *pMCDSurface, MCDRC *pRc);
typedef ULONG    (*MCDRVBINDCONTEXTFUNC)(MCDSURFACE *pMCDSurface, MCDRC *pRc);
typedef ULONG    (*MCDRVSYNCFUNC)(MCDSURFACE *pMCDSurface, MCDRC *pRc);
typedef ULONG    (*MCDRVDRAWPIXELS)(MCDSURFACE *pMcdSurface, MCDRC *pRc,
                                    ULONG width, ULONG height, ULONG format,
                                    ULONG type, VOID *pPixels, BOOL packed);
typedef ULONG    (*MCDRVREADPIXELS)(MCDSURFACE *pMcdSurface, MCDRC *pRc,
                                    LONG x, LONG y, ULONG width, ULONG height, ULONG format,
                                    ULONG type, VOID *pPixels);
typedef ULONG    (*MCDRVCOPYPIXELS)(MCDSURFACE *pMcdSurface, MCDRC *pRc,
                                    LONG x, LONG y, ULONG width, ULONG height, ULONG type);
typedef ULONG    (*MCDRVPIXELMAP)(MCDSURFACE *pMcdSurface, MCDRC *pRc,
                                  ULONG mapType, ULONG mapSize, VOID *pMap);

#define MCDDRIVER_V10_SIZE      (sizeof(ULONG)+31*sizeof(void *))

typedef struct _MCDDRIVER {
    ULONG                           ulSize;
    MCDRVDESCRIBEPIXELFORMATFUNC    pMCDrvDescribePixelFormat;
    MCDRVDESCRIBELAYERPLANEFUNC     pMCDrvDescribeLayerPlane;
    MCDRVSETLAYERPALETTEFUNC        pMCDrvSetLayerPalette;
    MCDRVINFOFUNC                   pMCDrvInfo;
    MCDRVCREATECONTEXTFUNC          pMCDrvCreateContext;
    MCDRVDELETECONTEXTFUNC          pMCDrvDeleteContext;
    MCDRVBINDCONTEXTFUNC            pMCDrvBindContext;
    MCDRVCREATETEXTUREFUNC          pMCDrvCreateTexture;
    MCDRVDELETETEXTUREFUNC          pMCDrvDeleteTexture;
    MCDRVUPDATESUBTEXTUREFUNC       pMCDrvUpdateSubTexture;
    MCDRVUPDATETEXTUREPALETTEFUNC   pMCDrvUpdateTexturePalette;
    MCDRVUPDATETEXTUREPRIORITYFUNC  pMCDrvUpdateTexturePriority;
    MCDRVUPDATETEXTURESTATEFUNC     pMCDrvUpdateTextureState;
    MCDRVTEXTURESTATUSFUNC          pMCDrvTextureStatus;
    MCDRVCREATEMEMFUNC              pMCDrvCreateMem;
    MCDRVDELETEMEMFUNC              pMCDrvDeleteMem;
    MCDRVDRAWFUNC                   pMCDrvDraw;
    MCDRVCLEARFUNC                  pMCDrvClear;
    MCDRVSWAPFUNC                   pMCDrvSwap;
    MCDRVSTATEFUNC                  pMCDrvState;
    MCDRVVIEWPORTFUNC               pMCDrvViewport;
    MCDRVGETHDEVFUNC                pMCDrvGetHdev;
    MCDRVSPANFUNC                   pMCDrvSpan;
    MCDRVTRACKWINDOWFUNC            pMCDrvTrackWindow;
    MCDRVALLOCBUFFERSFUNC           pMCDrvAllocBuffers;
    MCDRVGETBUFFERSFUNC             pMCDrvGetBuffers;
    MCDRVSYNCFUNC                   pMCDrvSync;
    MCDRVDRAWPIXELS                 pMCDrvDrawPixels;
    MCDRVREADPIXELS                 pMCDrvReadPixels;
    MCDRVCOPYPIXELS                 pMCDrvCopyPixels;
    MCDRVPIXELMAP                   pMCDrvPixelMap;
} MCDDRIVER;


// Top-level (global) driver functions established at DLL initialization time
// through MCD initialization. All other driver functions are obtained through
// the MCDrvGetEntryPoints funtion:

typedef BOOL  (*MCDRVGETENTRYPOINTSFUNC)(MCDSURFACE *pMCDSurface,
                                         MCDDRIVER *pMCDDriver);

typedef struct _MCDGLOBALDRIVERFUNCS {
    ULONG ulSize;
    MCDRVGETENTRYPOINTSFUNC     pMCDrvGetEntryPoints;
} MCDGLOBALDRIVERFUNCS;

// MCD Server engine functions:

#define MCDENGINITFUNCNAME              "MCDEngInit"
#define MCDENGINITEXFUNCNAME            "MCDEngInitEx"
#define MCDENGUNINITFUNCNAME            "MCDEngUninit"
#define MCDENGESCFILTERNAME             "MCDEngEscFilter"
#define MCDENGSETMEMSTATUSNAME          "MCDEngSetMemStatus"

typedef BOOL (WINAPI *MCDENGINITFUNC)(SURFOBJ *pso, 
                                      MCDRVGETENTRYPOINTSFUNC);
typedef BOOL (WINAPI *MCDENGINITEXFUNC)(SURFOBJ *pso,
                                        MCDGLOBALDRIVERFUNCS *pMCDGlobalDriverFuncs,
                                        void *pReserved);

typedef void (WINAPI *MCDENGUNINITFUNC)(SURFOBJ *pso);

typedef BOOL (WINAPI *MCDENGESCFILTERFUNC)(SURFOBJ *pso, ULONG iEsc,
                                           ULONG cjIn, VOID *pvIn,
                                           ULONG cjOut, VOID *pvOut, 
                                           ULONG *pRetVal);

typedef BOOL (WINAPI *MCDENGSETMEMSTATUSFUNC)(MCDMEM *pMCDMem, ULONG status);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\public\oak\inc\prcomoem.h ===
/*++

Copyright (c) 1996-1997 Microsoft Corporation

Module Name:

    prcomoem.h

Abstract:

    Interface declaration for Windows NT printer driver OEM plugins

--*/


#ifndef _PRCOMOEM_H_
#define _PRCOMOEM_H_


//
// This file has to be included after printoem.h. We also need to inlude
// objbase.h or comcat.h from sdk\inc.
//

//
// Each dll/exe must initialize the GUIDs once.If you are not using precompiled
// headers for the file(s) which initializes the GUIDs, define INITGUID before
// including objbase.h.
//

//
// Class ID for OEM rendering component. All OEM rendering plugin need to use this ID.
//
// {6d6abf26-9f38-11d1-882a-00c04fb961ec}
//

DEFINE_GUID(CLSID_OEMRENDER, 0x6d6abf26, 0x9f38, 0x11d1, 0x88, 0x2a, 0x00, 0xc0, 0x4f, 0xb9, 0x61, 0xec);

//
// Class ID for OEM UI component. All OEM UI plugin need to use this ID.
//
// {abce80d7-9f46-11d1-882a-00c04fb961ec}
//

DEFINE_GUID(CLSID_OEMUI, 0xabce80d7, 0x9f46, 0x11d1, 0x88, 0x2a, 0x00, 0xc0, 0x4f, 0xb9, 0x61, 0xec);

//
// Interface ID for IPrintOemCommon Interface
//
// {7f42285e-91d5-11d1-8820-00c04fb961ec}
//

DEFINE_GUID(IID_IPrintOemCommon, 0x7f42285e, 0x91d5, 0x11d1, 0x88, 0x20, 0x00, 0xc0, 0x4f, 0xb9, 0x61, 0xec);

//
// Interface ID for IPrintOemEngine Interface
//
// {63d17590-91d8-11d1-8820-00c04fb961ec}
//

DEFINE_GUID(IID_IPrintOemEngine, 0x63d17590, 0x91d8, 0x11d1, 0x88, 0x20, 0x00, 0xc0, 0x4f, 0xb9, 0x61, 0xec);

//
// Interface ID for IPrintOemUI Interface
//
// {C6A7A9D0-774C-11d1-947F-00A0C90640B8}
//

DEFINE_GUID(IID_IPrintOemUI, 0xc6a7a9d0, 0x774c, 0x11d1, 0x94, 0x7f, 0x0, 0xa0, 0xc9, 0x6, 0x40, 0xb8);

//
// Interface ID for IPrintOemDriverUI interface
//
// {92B05D50-78BC-11d1-9480-00A0C90640B8}
//

DEFINE_GUID(IID_IPrintOemDriverUI, 0x92b05d50, 0x78bc, 0x11d1, 0x94, 0x80, 0x0, 0xa0, 0xc9, 0x6, 0x40, 0xb8);

//
// Interface ID for IPrintOemPS Interface
//
// {688342b5-8e1a-11d1-881f-00c04fb961ec}
//

DEFINE_GUID(IID_IPrintOemPS, 0x688342b5, 0x8e1a, 0x11d1, 0x88, 0x1f, 0x00, 0xc0, 0x4f, 0xb9, 0x61, 0xec);

//
// Interface ID for IPrintOemDriverPS interface
//
// {d90060c7-8e1a-11d1-881f-00c04fb961ec}
//

DEFINE_GUID(IID_IPrintOemDriverPS, 0xd90060c7, 0x8e1a, 0x11d1, 0x88, 0x1f, 0x00, 0xc0, 0x4f, 0xb9, 0x61, 0xec);

//
// Interface ID for IPrintOemUni Interface
//
// {D67EBBF0-78BF-11d1-9480-00A0C90640B8}
//

DEFINE_GUID(IID_IPrintOemUni, 0xd67ebbf0, 0x78bf, 0x11d1, 0x94, 0x80, 0x0, 0xa0, 0xc9, 0x6, 0x40, 0xb8);

//
// Interface ID for IPrintOemDriverUni interface
//
// {D67EBBF1-78BF-11d1-9480-00A0C90640B8}
//

DEFINE_GUID(IID_IPrintOemDriverUni, 0xd67ebbf1, 0x78bf, 0x11d1, 0x94, 0x80, 0x0, 0xa0, 0xc9, 0x6, 0x40, 0xb8);

#undef IUnknown

#ifdef __cplusplus
extern "C" {
#endif

//
//****************************************************************************
//  IPrintOemCommon interface
//****************************************************************************
//


#undef INTERFACE
#define INTERFACE IPrintOemCommon
DECLARE_INTERFACE_(IPrintOemCommon, IUnknown)
{
    //
    // IUnknown methods
    //

    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    //
    // IPrintOemCommon methods
    //

    //
    // Method for getting OEM related information
    //

    STDMETHOD(GetInfo) (THIS_   DWORD   dwMode,
                                PVOID   pBuffer,
                                DWORD   cbSize,
                                PDWORD  pcbNeeded) PURE;
    //
    // Method for OEM private devmode handling
    //

    STDMETHOD(DevMode) (THIS_   DWORD       dwMode,
                                POEMDMPARAM pOemDMParam) PURE;
};

#ifndef KERNEL_MODE

//
// Definitions used by user interface module only.
// Make sure the macro KERNEL_MODE is not defined.
//

//
//****************************************************************************
//  IPrintOemUI interface
//****************************************************************************
//


#undef INTERFACE
#define INTERFACE IPrintOemUI
DECLARE_INTERFACE_(IPrintOemUI, IPrintOemCommon)
{
    //
    // IUnknown methods
    //

    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj)PURE;
    STDMETHOD_(ULONG, AddRef) (THIS)PURE;
    STDMETHOD_(ULONG, Release) (THIS)PURE;

    //
    // IPrintOemCommon methods
    //

    //
    // Method for getting OEM related information
    //

    STDMETHOD(GetInfo) (THIS_   DWORD   dwMode,
                                PVOID   pBuffer,
                                DWORD   cbSize,
                                PDWORD  pcbNeeded) PURE;
    //
    // Method for OEM private devmode handling
    //

    STDMETHOD(DevMode) (THIS_   DWORD       dwMode,
                                POEMDMPARAM pOemDMParam) PURE;

    //
    // IPrintOemUI methods
    //

    //
    // Method for publishing Driver interface.
    //

    STDMETHOD(PublishDriverInterface) (THIS_ IUnknown *pIUnknown) PURE;


    //
    // CommonUIProp
    //

    STDMETHOD(CommonUIProp) (THIS_
            DWORD  dwMode,
            POEMCUIPPARAM   pOemCUIPParam
            )PURE;

    //
    // DocumentPropertySheets
    //

    STDMETHOD(DocumentPropertySheets) (THIS_
            PPROPSHEETUI_INFO   pPSUIInfo,
            LPARAM              lParam
            )PURE;

    //
    // DevicePropertySheets
    //

    STDMETHOD(DevicePropertySheets) (THIS_
            PPROPSHEETUI_INFO   pPSUIInfo,
            LPARAM              lParam
            )PURE;


    //
    // DevQueryPrintEx
    //

    STDMETHOD(DevQueryPrintEx) (THIS_
            POEMUIOBJ               poemuiobj,
            PDEVQUERYPRINT_INFO     pDQPInfo,
            PDEVMODE                pPublicDM,
            PVOID                   pOEMDM
            )PURE;

    //
    // DeviceCapabilities
    //

    STDMETHOD(DeviceCapabilities) (THIS_
            POEMUIOBJ   poemuiobj,
            HANDLE      hPrinter,
            PWSTR       pDeviceName,
            WORD        wCapability,
            PVOID       pOutput,
            PDEVMODE    pPublicDM,
            PVOID       pOEMDM,
            DWORD       dwOld,
            DWORD       *dwResult
            )PURE;

    //
    // UpgradePrinter
    //

    STDMETHOD(UpgradePrinter) (THIS_
            DWORD   dwLevel,
            PBYTE   pDriverUpgradeInfo
            )PURE;

    //
    // PrinterEvent
    //

    STDMETHOD(PrinterEvent) (THIS_
            PWSTR   pPrinterName,
            INT     iDriverEvent,
            DWORD   dwFlags,
            LPARAM  lParam
            )PURE;

    //
    // DriverEvent
    //

    STDMETHOD(DriverEvent) (THIS_
            DWORD   dwDriverEvent,
            DWORD   dwLevel,
            LPBYTE  pDriverInfo,
            LPARAM  lParam
            )PURE;

    //
    // QueryColorProfile
    //

    STDMETHOD(QueryColorProfile) (THIS_
            HANDLE      hPrinter,
            POEMUIOBJ   poemuiobj,
            PDEVMODE    pPublicDM,
            PVOID       pOEMDM,
            ULONG       ulReserved,
            VOID       *pvProfileData,
            ULONG      *pcbProfileData,
            FLONG      *pflProfileData
            )PURE;

    //
    // FontInstallerDlgProc
    //

    STDMETHOD(FontInstallerDlgProc) (THIS_
            HWND    hWnd,
            UINT    usMsg,
            WPARAM  wParam,
            LPARAM  lParam
            )PURE;

    //
    // UpdateExternalFonts
    //

    STDMETHOD(UpdateExternalFonts) (THIS_
            HANDLE  hPrinter,
            HANDLE  hHeap,
            PWSTR   pwstrCartridges
           )PURE;


};


//
//****************************************************************************
//  IPrintOemDriverUI interface
//****************************************************************************
//


#undef INTERFACE
#define INTERFACE IPrintOemDriverUI
DECLARE_INTERFACE_(IPrintOemDriverUI, IUnknown)
{
    //
    // IUnknown methods
    //

    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj)PURE;
    STDMETHOD_(ULONG, AddRef) (THIS)PURE;
    STDMETHOD_(ULONG, Release) (THIS)PURE;

    //
    // IPrintOemDriverUI methods
    //

    //
    // Helper function to get driver settings
    //

    STDMETHOD(DrvGetDriverSetting) (THIS_
                        PVOID   pci,
                        PCSTR   Feature,
                        PVOID   pOutput,
                        DWORD   cbSize,
                        PDWORD  pcbNeeded,
                        PDWORD  pdwOptionsReturned
                        )PURE;

    //
    // Helpder function to allow OEM plugins upgrade private registry
    // settings. This function should be called only by OEM's UpgradePrinter()
    //

    STDMETHOD(DrvUpgradeRegistrySetting) (THIS_
                        HANDLE   hPrinter,
                        PCSTR    pFeature,
                        PCSTR    pOption
                        )PURE;

    //
    // Helper function to allow OEM plugins to update the driver UI
    // settings and show constraints. This function should be called only when
    // the UI is present.
    //

    STDMETHOD(DrvUpdateUISetting) (THIS_
                        PVOID    pci,
                        PVOID    pOptItem,
                        DWORD    dwPreviousSelection,
                        DWORD    dwMode
                        )PURE;

};

#else   // KERNEL_MODE

//
// Definitions used by rendering module only.
// Make sure the macro KERNEL_MODE is defined.
//

//
//****************************************************************************
//  IPrintOemEngine interface
//****************************************************************************
//


#undef INTERFACE
#define INTERFACE IPrintOemEngine
DECLARE_INTERFACE_(IPrintOemEngine, IPrintOemCommon)
{
    //
    // IUnknown methods
    //

    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    //
    // IPrintOemCommon methods
    //

    //
    // Method for getting OEM related information
    //

    STDMETHOD(GetInfo) (THIS_   DWORD   dwMode,
                                PVOID   pBuffer,
                                DWORD   cbSize,
                                PDWORD  pcbNeeded) PURE;
    //
    // Method for OEM private devmode handling
    //

    STDMETHOD(DevMode) (THIS_   DWORD       dwMode,
                                POEMDMPARAM pOemDMParam) PURE;

    //
    // IPrintOemEngine methods
    //

    //
    // Method for OEM to specify DDI hook out
    //

    STDMETHOD(EnableDriver)  (THIS_   DWORD           DriverVersion,
                                      DWORD           cbSize,
                                      PDRVENABLEDATA  pded) PURE;

    //
    // Method to notify OEM plugin that it is no longer required
    //

    STDMETHOD(DisableDriver) (THIS) PURE;

    //
    // Method for OEM to contruct its own PDEV
    //

    STDMETHOD(EnablePDEV)    (THIS_   PDEVOBJ         pdevobj,
                                      PWSTR           pPrinterName,
                                      ULONG           cPatterns,
                                      HSURF          *phsurfPatterns,
                                      ULONG           cjGdiInfo,
                                      GDIINFO        *pGdiInfo,
                                      ULONG           cjDevInfo,
                                      DEVINFO        *pDevInfo,
                                      DRVENABLEDATA  *pded,
                                      OUT PDEVOEM    *pDevOem) PURE;

    //
    // Method for OEM to free any resource associated with its PDEV
    //

    STDMETHOD(DisablePDEV)   (THIS_   PDEVOBJ         pdevobj) PURE;

    //
    // Method for OEM to transfer from old PDEV to new PDEV
    //

    STDMETHOD(ResetPDEV)     (THIS_   PDEVOBJ         pdevobjOld,
                                      PDEVOBJ         pdevobjNew) PURE;
};

//
//****************************************************************************
//  IPrintOemPS interface
//****************************************************************************
//


#undef INTERFACE
#define INTERFACE IPrintOemPS
DECLARE_INTERFACE_(IPrintOemPS, IPrintOemEngine)
{
    //
    // IUnknown methods
    //

    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    //
    // IPrintOemCommon methods
    //

    //
    // Method for getting OEM related information
    //

    STDMETHOD(GetInfo) (THIS_   DWORD   dwMode,
                                PVOID   pBuffer,
                                DWORD   cbSize,
                                PDWORD  pcbNeeded) PURE;
    //
    // Method for OEM private devmode handling
    //

    STDMETHOD(DevMode) (THIS_   DWORD       dwMode,
                                POEMDMPARAM pOemDMParam) PURE;

    //
    // IPrintOemEngine methods
    //

    //
    // Method for OEM to specify DDI hook out
    //

    STDMETHOD(EnableDriver)  (THIS_   DWORD           DriverVersion,
                                      DWORD           cbSize,
                                      PDRVENABLEDATA  pded) PURE;

    //
    // Method to notify OEM plugin that it is no longer required
    //

    STDMETHOD(DisableDriver) (THIS) PURE;

    //
    // Method for OEM to construct its own PDEV
    //

    STDMETHOD(EnablePDEV)    (THIS_   PDEVOBJ         pdevobj,
                                      PWSTR           pPrinterName,
                                      ULONG           cPatterns,
                                      HSURF          *phsurfPatterns,
                                      ULONG           cjGdiInfo,
                                      GDIINFO        *pGdiInfo,
                                      ULONG           cjDevInfo,
                                      DEVINFO        *pDevInfo,
                                      DRVENABLEDATA  *pded,
                                      OUT PDEVOEM    *pDevOem) PURE;

    //
    // Method for OEM to free any resource associated with its PDEV
    //

    STDMETHOD(DisablePDEV)   (THIS_   PDEVOBJ         pdevobj) PURE;

    //
    // Method for OEM to transfer from old PDEV to new PDEV
    //

    STDMETHOD(ResetPDEV)     (THIS_   PDEVOBJ         pdevobjOld,
                                      PDEVOBJ         pdevobjNew) PURE;

    //
    // IPrintOemPS methods
    //

    //
    // Method for publishing Driver interface.
    //

    STDMETHOD(PublishDriverInterface)(THIS_  IUnknown *pIUnknown) PURE;

    //
    // Method for OEM to generate output at specific injection point
    //

    STDMETHOD(Command) (THIS_   PDEVOBJ     pdevobj,
                                DWORD       dwIndex,
                                PVOID       pData,
                                DWORD       cbSize,
                                OUT DWORD   *pdwResult) PURE;
};


//
//****************************************************************************
//  IPrintOemDriverPS interface
//****************************************************************************
//


#undef INTERFACE
#define INTERFACE IPrintOemDriverPS
DECLARE_INTERFACE_(IPrintOemDriverPS, IUnknown)
{
    //
    // IUnknown methods
    //

    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    //
    // IPrintOemDriverPS methods
    //

    //
    // Method for OEM to get driver settings
    //

    STDMETHOD(DrvGetDriverSetting) (THIS_   PVOID   pdriverobj,
                                            PCSTR   Feature,
                                            PVOID   pOutput,
                                            DWORD   cbSize,
                                            PDWORD  pcbNeeded,
                                            PDWORD  pdwOptionsReturned) PURE;

    //
    // Method for OEM to write to spooler buffer
    //

    STDMETHOD(DrvWriteSpoolBuf)(THIS_       PDEVOBJ     pdevobj,
                                            PVOID       pBuffer,
                                            DWORD       cbSize,
                                            OUT DWORD   *pdwResult) PURE;
};


//
//****************************************************************************
//  IPrintOemUni interface
//****************************************************************************
//

#undef INTERFACE
#define INTERFACE IPrintOemUni
DECLARE_INTERFACE_(IPrintOemUni, IPrintOemEngine)
{

    //
    // IUnknown methods
    //

    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    //
    // IPrintOemCommon methods
    //

    //
    // Method for getting OEM related information
    //

    STDMETHOD(GetInfo) (THIS_   DWORD   dwMode,
                                PVOID   pBuffer,
                                DWORD   cbSize,
                                PDWORD  pcbNeeded) PURE;
    //
    // Method for OEM private devmode handling
    //

    STDMETHOD(DevMode) (THIS_   DWORD       dwMode,
                                POEMDMPARAM pOemDMParam) PURE;

    //
    // IPrintOemEngine methods
    //

    //
    // Method for OEM to specify DDI hook out
    //

    STDMETHOD(EnableDriver)  (THIS_   DWORD           DriverVersion,
                                      DWORD           cbSize,
                                      PDRVENABLEDATA  pded) PURE;

    //
    // Method to notify OEM plugin that it is no longer required
    //

    STDMETHOD(DisableDriver) (THIS) PURE;

    //
    // Method for OEM to construct its own PDEV
    //

    STDMETHOD(EnablePDEV)    (THIS_   PDEVOBJ         pdevobj,
                                      PWSTR           pPrinterName,
                                      ULONG           cPatterns,
                                      HSURF          *phsurfPatterns,
                                      ULONG           cjGdiInfo,
                                      GDIINFO        *pGdiInfo,
                                      ULONG           cjDevInfo,
                                      DEVINFO        *pDevInfo,
                                      DRVENABLEDATA  *pded,
                                      OUT PDEVOEM    *pDevOem) PURE;

    //
    // Method for OEM to free any resource associated with its PDEV
    //

    STDMETHOD(DisablePDEV)   (THIS_   PDEVOBJ         pdevobj) PURE;

    //
    // Method for OEM to transfer from old PDEV to new PDEV
    //

    STDMETHOD(ResetPDEV)     (THIS_   PDEVOBJ         pdevobjOld,
                                      PDEVOBJ         pdevobjNew) PURE;

    //
    // Method for publishing Driver interface.
    //

    STDMETHOD(PublishDriverInterface)(THIS_ IUnknown *pIUnknown) PURE;

    //
    // Method for getting OEM implemented methods.
    // Returns S_OK if the given method is implemented.
    // Returns S_FALSE if the given method is not implemented.
    //
    //

    STDMETHOD(GetImplementedMethod) (THIS_  PSTR    pMethodName) PURE;

    //
    // DriverDMS
    //

    STDMETHOD(DriverDMS)(THIS_  PVOID   pDevObj,
                                PVOID   pBuffer,
                                DWORD   cbSize,
                                PDWORD  pcbNeeded) PURE;

    //
    // CommandCallback
    //

    STDMETHOD(CommandCallback)(THIS_    PDEVOBJ     pdevobj,
                                        DWORD       dwCallbackID,
                                        DWORD       dwCount,
                                        PDWORD      pdwParams,
                                        OUT INT     *piResult) PURE;


    //
    // ImageProcessing
    //

    STDMETHOD(ImageProcessing)(THIS_    PDEVOBJ             pdevobj,
                                        PBYTE               pSrcBitmap,
                                        PBITMAPINFOHEADER   pBitmapInfoHeader,
                                        PBYTE               pColorTable,
                                        DWORD               dwCallbackID,
                                        PIPPARAMS           pIPParams,
                                        OUT PBYTE           *ppbResult) PURE;

    //
    // FilterGraphics
    //

    STDMETHOD(FilterGraphics) (THIS_    PDEVOBJ     pdevobj,
                                        PBYTE       pBuf,
                                        DWORD       dwLen) PURE;

    //
    // Compression
    //

    STDMETHOD(Compression)(THIS_    PDEVOBJ     pdevobj,
                                    PBYTE       pInBuf,
                                    PBYTE       pOutBuf,
                                    DWORD       dwInLen,
                                    DWORD       dwOutLen,
                                    OUT INT     *piResult) PURE;

    //
    // HalftonePattern
    //

    STDMETHOD(HalftonePattern) (THIS_   PDEVOBJ     pdevobj,
                                        PBYTE       pHTPattern,
                                        DWORD       dwHTPatternX,
                                        DWORD       dwHTPatternY,
                                        DWORD       dwHTNumPatterns,
                                        DWORD       dwCallbackID,
                                        PBYTE       pResource,
                                        DWORD       dwResourceSize) PURE;

    //
    // MemoryUsage
    //

    STDMETHOD(MemoryUsage) (THIS_   PDEVOBJ         pdevobj,
                                    POEMMEMORYUSAGE pMemoryUsage) PURE;

    //
    // TTYGetInfo
    //

    STDMETHOD(TTYGetInfo)(THIS_     PDEVOBJ     pdevobj,
                                    DWORD       dwInfoIndex,
                                    PVOID       pOutputBuf,
                                    DWORD       dwSize,
                                    DWORD       *pcbcNeeded
                                    ) PURE;
    //
    // DownloadFontheader
    //

    STDMETHOD(DownloadFontHeader)(THIS_     PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            OUT DWORD   *pdwResult) PURE;

    //
    // DownloadCharGlyph
    //

    STDMETHOD(DownloadCharGlyph)(THIS_      PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            HGLYPH      hGlyph,
                                            PDWORD      pdwWidth,
                                            OUT DWORD   *pdwResult) PURE;


    //
    // TTDownloadMethod
    //

    STDMETHOD(TTDownloadMethod)(THIS_       PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            OUT DWORD   *pdwResult) PURE;

    //
    // OutputCharStr
    //

    STDMETHOD(OutputCharStr)(THIS_      PDEVOBJ     pdevobj,
                                        PUNIFONTOBJ pUFObj,
                                        DWORD       dwType,
                                        DWORD       dwCount,
                                        PVOID       pGlyph) PURE;

    //
    // SendFontCmd
    //


    STDMETHOD(SendFontCmd)(THIS_    PDEVOBJ      pdevobj,
                                    PUNIFONTOBJ  pUFObj,
                                    PFINVOCATION pFInv) PURE;

    //
    // TextOutAsBitmap
    //

    STDMETHOD(TextOutAsBitmap)(THIS_        SURFOBJ    *pso,
                                            STROBJ     *pstro,
                                            FONTOBJ    *pfo,
                                            CLIPOBJ    *pco,
                                            RECTL      *prclExtra,
                                            RECTL      *prclOpaque,
                                            BRUSHOBJ   *pboFore,
                                            BRUSHOBJ   *pboOpaque,
                                            POINTL     *pptlOrg,
                                            MIX         mix) PURE;
};


//
//****************************************************************************
//  IPrintOemDriverUni interface
//****************************************************************************
//

#undef INTERFACE
#define INTERFACE IPrintOemDriverUni
DECLARE_INTERFACE_(IPrintOemDriverUni, IUnknown)
{
    //
    // IUnknown methods
    //

    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    //
    // IPrintOemDriverUni methods
    //

    //
    // Function to get driver settings
    //

    STDMETHOD(DrvGetDriverSetting) (THIS_   PVOID   pdriverobj,
                                            PCSTR   Feature,
                                            PVOID   pOutput,
                                            DWORD   cbSize,
                                            PDWORD  pcbNeeded,
                                            PDWORD  pdwOptionsReturned) PURE;

    //
    // Common to both Unidrv & Pscript
    //

    STDMETHOD(DrvWriteSpoolBuf)(THIS_       PDEVOBJ     pdevobj,
                                            PVOID       pBuffer,
                                            DWORD       cbSize,
                                            OUT DWORD   *pdwResult) PURE;

    //
    // Unidrv specific XMoveTo and YMoveTo. Returns E_NOT_IMPL in Pscript
    //

    STDMETHOD(DrvXMoveTo)(THIS_     PDEVOBJ     pdevobj,
                                    INT         x,
                                    DWORD       dwFlags,
                                    OUT INT     *piResult) PURE;

    STDMETHOD(DrvYMoveTo)(THIS_     PDEVOBJ     pdevobj,
                                    INT         y,
                                    DWORD       dwFlags,
                                    OUT INT     *piResult) PURE;
    //
    // Unidrv specific. To get the standard variable value.
    //

    STDMETHOD(DrvGetStandardVariable)(THIS_     PDEVOBJ     pdevobj,
                                                DWORD       dwIndex,
                                                PVOID       pBuffer,
                                                DWORD       cbSize,
                                                PDWORD      pcbNeeded) PURE;

//
// Unidrv specific.  To Provide OEM plugins access to GPD data.
//


    STDMETHOD (DrvGetGPDData)(THIS_  PDEVOBJ     pdevobj,
    DWORD       dwType,     // Type of the data
    PVOID         pInputData,   // reserved. Should be set to 0
    PVOID          pBuffer,     // Caller allocated Buffer to be copied
    DWORD       cbSize,     // Size of the buffer
    PDWORD      pcbNeeded   // New Size of the buffer if needed.
    ) PURE;


    //
    // Unidrv specific. To do the TextOut.
    //

    STDMETHOD(DrvUniTextOut)(THIS_    SURFOBJ    *pso,
                                            STROBJ     *pstro,
                                            FONTOBJ    *pfo,
                                            CLIPOBJ    *pco,
                                            RECTL      *prclExtra,
                                            RECTL      *prclOpaque,
                                            BRUSHOBJ   *pboFore,
                                            BRUSHOBJ   *pboOpaque,
                                            POINTL     *pptlBrushOrg,
                                            MIX         mix) PURE;

    //
    //   Warning!!!  new method!!  must place at end of
    //   interface - else major incompatibility with previous oem plugins
    //

    STDMETHOD(DrvWriteAbortBuf)(THIS_       PDEVOBJ     pdevobj,
                                            PVOID       pBuffer,
                                            DWORD       cbSize,
                                            DWORD       dwWait  //  pause data transmission for this many millisecs.
                                            ) PURE;


};

#endif  // !KERNEL_MODE

#ifdef __cplusplus
}
#endif

#endif  // !_PRCOMOEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\public\oak\inc\printoem.h ===
/*++

Copyright (c) 1996-1997 Microsoft Corporation

Module Name:

    printoem.h

Abstract:

    Declarations for Windows NT printer driver OEM plugins

--*/


#ifndef _PRINTOEM_
#define _PRINTOEM_

#ifdef __cplusplus
extern "C" {
#endif

//
// Current OEM plugin interface version number
//

#define PRINTER_OEMINTF_VERSION 0x00010000

#define OEM_MODE_PUBLISHER     0x00000001

typedef struct _PUBLISHERINFO {

    DWORD dwMode;           // flags for publisher
    WORD  wMinoutlinePPEM;  // min size to download as Type1
    WORD  wMaxbitmapPPEM;   // max size to download as Type3

} PUBLISHERINFO, *PPUBLISHERINFO;

#define OEMGI_GETSIGNATURE        1
#define OEMGI_GETINTERFACEVERSION 2
#define OEMGI_GETVERSION          3
#define OEMGI_GETPUBLISHERINFO    4

//
// OEMGetInfo
//
BOOL APIENTRY
OEMGetInfo(
    IN  DWORD  dwMode,
    OUT PVOID  pBuffer,
    IN  DWORD  cbSize,
    OUT PDWORD pcbNeeded
    );

BOOL APIENTRY
OEMDriverDMS(
    PVOID    pDevObj,
    PVOID    pBuffer,
    DWORD    cbSize,
    PDWORD   pcbNeeded
    );


//
// OEMDevMode
//

#define OEMDM_SIZE     1
#define OEMDM_DEFAULT  2
#define OEMDM_CONVERT  3
#define OEMDM_MERGE    4

typedef struct _OEMDMPARAM {

    DWORD    cbSize;        // size of OEM_DEVMODEPARAM
    PVOID    pdriverobj;    // reference to driver data structure
    HANDLE   hPrinter;      // PRINTER handle
    HANDLE   hModule;       // OEM module handle
    PDEVMODE pPublicDMIn;   // public devmode in
    PDEVMODE pPublicDMOut;  // public devmode out
    PVOID    pOEMDMIn;      // OEM private devmode in
    PVOID    pOEMDMOut;     // OEM private devmode out
    DWORD    cbBufSize;     // output size of pOEMDMOut buffer

} OEMDMPARAM, *POEMDMPARAM;

typedef struct _OEM_DMEXTRAHEADER {

    DWORD   dwSize;         // size of OEM extra data
    DWORD   dwSignature;    // Unique OEM signature
    DWORD   dwVersion;      // OEM DLL version number

} OEM_DMEXTRAHEADER, *POEM_DMEXTRAHEADER;

//
// USERDATA for OPTITEM.UserData
//

typedef struct _USERDATA {

    DWORD       dwSize;                 // Size of this structure
    ULONG_PTR    dwItemID;               // XXX_ITEM or pointer to FEATURE
    PSTR        pKeyWordName;           // Keyword name
    DWORD       dwReserved[8];
} USERDATA, *PUSERDATA;


BOOL APIENTRY
OEMDevMode(
    DWORD       dwMode,
    POEMDMPARAM pOemDMParam
    );

//
// Callback function provided by the driver to
// allow OEM plugins access/set/update to driver private settings
//

typedef BOOL (APIENTRY *PFN_DrvGetDriverSetting)(
        PVOID   pdriverobj,
        PCSTR   Feature,
        PVOID   pOutput,
        DWORD   cbSize,
        PDWORD  pcbNeeded,
        PDWORD  pdwOptionsReturned
        );

//
// Callback function provided by the driver to
// allow OEM plugins upgrade private registry settings. This
// function is called only at OEMDrvUpgradeDriver
//

typedef BOOL (APIENTRY *PFN_DrvUpgradeRegistrySetting)(
        HANDLE   hPrinter,
        PCSTR    pFeature,
        PCSTR    pOption
        );

//
// Callback function provided by the driver UI to
// allow OEM plugins to update the driver UI settings and
// shows constraint. This function is called only when the UI is present.
//

typedef BOOL (APIENTRY *PFN_DrvUpdateUISetting)(
        PVOID    pdriverobj,
        PVOID    pOptItem,
        DWORD    dwPreviousSelection,
        DWORD    dwMode
        );



// Predefined feature indices used for accessing driver private settings

#define OEMGDS_MIN_DOCSTICKY        1
#define OEMGDS_PSDM_FLAGS           1       // DWORD - misc. flag bits
#define OEMGDS_PSDM_DIALECT         2       // INT - PS output option
#define OEMGDS_PSDM_TTDLFMT         3       // INT - TrueType font downloading option
#define OEMGDS_PSDM_NUP             4       // INT - N-up option
#define OEMGDS_PSDM_PSLEVEL         5       // INT - target language level
#define OEMGDS_PSDM_CUSTOMSIZE      6       // 5*DWORD - custom page size parameters

#define OEMGDS_UNIDM_GPDVER         0x4000  // WORD - GPD Version
#define OEMGDS_UNIDM_FLAGS          0x4001  // DWORD - misc flag bits

// Indices for private devmode fields - start at 0x4000

#define OEMGDS_MIN_PRINTERSTICKY    0x8000
#define OEMGDS_PRINTFLAGS           0x8000  // DWORD - misc. flag bits
#define OEMGDS_FREEMEM              0x8001  // DWORD - amount of VM, ps only
#define OEMGDS_JOBTIMEOUT           0x8002  // DWORD - job timeout, ps only
#define OEMGDS_WAITTIMEOUT          0x8003  // DWORD - wait timeout, ps only
#define OEMGDS_PROTOCOL             0x8004  // WORD - output protocol, ps only
#define OEMGDS_MINOUTLINE           0x8005  // WORD - min outline font size, ps only
#define OEMGDS_MAXBITMAP            0x8006  // WORD - max bitmap font size, ps only

#define OEMGDS_MAX                  0x10000


//   dwType  flags for use with     STDMETHOD (DrvGetGPDData)
#define         GPD_OEMCUSTOMDATA       1


/*******************************************************************************
 *
 * Definitions used by kernel-mode rendering module only:
 *  Make sure the macro KERNEL_MODE is defined and
 *  the header file winddi.h is included before this file.
 */

#ifdef KERNEL_MODE

//
// OEMEnableDriver
//

BOOL APIENTRY
OEMEnableDriver(
    DWORD           dwOemIntfVersion,
    DWORD           cbSize,
    PDRVENABLEDATA  pded
    );

typedef struct _DEVOBJ *PDEVOBJ;
typedef PVOID PDEVOEM;

typedef DWORD (APIENTRY *PFN_DrvWriteSpoolBuf)(
    PDEVOBJ pdevobj,
    PVOID   pBuffer,
    DWORD   cbSize
    );

typedef DWORD (APIENTRY *PFN_DrvWriteAbortBuf)(
    PDEVOBJ pdevobj,
    PVOID   pBuffer,
    DWORD   cbSize,
    DWORD       dwWait

    );

typedef INT (APIENTRY *PFN_DrvXMoveTo)(
    PDEVOBJ pdevobj,
    INT     x,
    DWORD   dwFlags
    );

typedef INT (APIENTRY *PFN_DrvYMoveTo)(
    PDEVOBJ pdevobj,
    INT     y,
    DWORD   dwFlags
    );

typedef BOOL (APIENTRY *PFN_DrvGetStandardVariable)(
    PDEVOBJ pdevobj,
    DWORD   dwIndex,
    PVOID   pBuffer,
    DWORD   cbSize,
    PDWORD  pcbNeeded
    );

typedef enum _STDVARIABLEINDEX{

        SVI_NUMDATABYTES,          // "NumOfDataBytes"
        SVI_WIDTHINBYTES,          // "RasterDataWidthInBytes"
        SVI_HEIGHTINPIXELS,        // "RasterDataHeightInPixels"
        SVI_COPIES,                // "NumOfCopies"
        SVI_PRINTDIRECTION,        // "PrintDirInCCDegrees"
        SVI_DESTX,                 // "DestX"
        SVI_DESTY,                 // "DestY"
        SVI_DESTXREL,              // "DestXRel"
        SVI_DESTYREL,              // "DestYRel"
        SVI_LINEFEEDSPACING,       // "LinefeedSpacing"
        SVI_RECTXSIZE,             // "RectXSize"
        SVI_RECTYSIZE,             // "RectYSize"
        SVI_GRAYPERCENT,           // "GrayPercentage"
        SVI_NEXTFONTID,            // "NextFontID"
        SVI_NEXTGLYPH,             // "NextGlyph"
        SVI_PHYSPAPERLENGTH,       // "PhysPaperLength"
        SVI_PHYSPAPERWIDTH,        // "PhysPaperWidth"
        SVI_FONTHEIGHT,            // "FontHeight"
        SVI_FONTWIDTH,             // "FontWidth"
        SVI_FONTMAXWIDTH,             // "FontMaxWidth"
        SVI_FONTBOLD,              // "FontBold"
        SVI_FONTITALIC,            // "FontItalic"
        SVI_FONTUNDERLINE,         // "FontUnderline"
        SVI_FONTSTRIKETHRU,        // "FontStrikeThru"
        SVI_CURRENTFONTID,         // "CurrentFontID"
        SVI_TEXTYRES,              // "TextYRes"
        SVI_TEXTXRES,              // "TextXRes"
// #ifdef  BETA2
        SVI_GRAPHICSYRES,              // "GraphicsYRes"
        SVI_GRAPHICSXRES,              // "GraphicsXRes"
// #endif
        SVI_ROP3,                  // "Rop3"
        SVI_REDVALUE,              // "RedValue"
        SVI_GREENVALUE,            // "GreenValue"
        SVI_BLUEVALUE,             // "BlueValue"
        SVI_PALETTEINDEXTOPROGRAM, // "PaletteIndexToProgram"
        SVI_CURRENTPALETTEINDEX,   // "CurrentPaletteIndex"
        SVI_PATTERNBRUSH_TYPE,     // "PatternBrushType"
        SVI_PATTERNBRUSH_ID,       // "PatternBrushID"
        SVI_PATTERNBRUSH_SIZE,     // "PatternBrushSize"
        SVI_CURSORORIGINX,           //  "CursorOriginX"
        SVI_CURSORORIGINY,           //  "CursorOriginY"
                //  this is in MasterUnits and in the coordinates of the currently selected orientation.
                //  this value is defined as ImageableOrigin - CursorOrigin

        SVI_MAX             //  Just a placeholder do not use.
}STDVARIABLEINDEX;






typedef BOOL (APIENTRY *PFN_DrvUnidriverTextOut)(
    SURFOBJ    *pso,
    STROBJ     *pstro,
    FONTOBJ    *pfo,
    CLIPOBJ    *pco,
    RECTL      *prclExtra,
    RECTL      *prclOpaque,
    BRUSHOBJ   *pboFore,
    BRUSHOBJ   *pboOpaque,
    POINTL     *pptlBrushOrg,
    MIX         mix
    );

//
// bit fields defined for dwFlags
//
// Note:  The following Bit values are reserved for an internal use!
//  0x4000
//  0x8000 
// 
//
#define MV_UPDATE       0x0001
#define MV_RELATIVE     0x0002
#define MV_GRAPHICS     0x0004
#define MV_PHYSICAL     0x0008
#define MV_SENDXMOVECMD     0x0010
#define MV_SENDYMOVECMD     0x0020

typedef struct _DRVPROCS {

    PFN_DrvWriteSpoolBuf    DrvWriteSpoolBuf;   // common to both pscript and unidrv
    PFN_DrvXMoveTo          DrvXMoveTo;         // unidrv specific
    PFN_DrvYMoveTo          DrvYMoveTo;         // unidrv specific
    PFN_DrvGetDriverSetting DrvGetDriverSetting;// common to both pscript and unidrv
    PFN_DrvGetStandardVariable BGetStandardVariable; // unidrv specific
    PFN_DrvUnidriverTextOut    DrvUnidriverTextOut;  // unidrv specific
    PFN_DrvWriteAbortBuf    DrvWriteAbortBuf;   // unidrv specific

} DRVPROCS, *PDRVPROCS;

typedef struct _DEVOBJ {

    DWORD       dwSize;       // size of DEVOBJ structure
    PDEVOEM     pdevOEM;      // pointer to OEM's device data
    HANDLE      hEngine;      // GDI handle for current printer
    HANDLE      hPrinter;     // spooler handle for current printer
    HANDLE      hOEM;         // handle to OEM dll
    PDEVMODE    pPublicDM;    // public devmode
    PVOID       pOEMDM;       // OEM private devmode
    PDRVPROCS   pDrvProcs;    // pointer to kernel mode helper function table

} DEVOBJ;

//
// OEMDisableDriver
//

VOID APIENTRY
OEMDisableDriver(
    VOID
    );

//
// OEMEnablePDEV
//

PDEVOEM APIENTRY
OEMEnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR           pPrinterName,
    ULONG           cPatterns,
    HSURF          *phsurfPatterns,
    ULONG           cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG           cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded
    );

//
// OEMDisablePDEV
//

VOID APIENTRY
OEMDisablePDEV(
    PDEVOBJ pdevobj
    );

//
// OEMResetPDEV
//

BOOL APIENTRY
OEMResetPDEV(
    PDEVOBJ pdevobjOld,
    PDEVOBJ pdevobjNew
    );

//
// OEMCommand - PSCRIPT only
//

DWORD APIENTRY
OEMCommand(
    PDEVOBJ pdevobj,
    DWORD   dwIndex,
    PVOID   pData,
    DWORD   cbSize
    );

INT APIENTRY
OEMCommandCallback(
    PDEVOBJ         pdevobj,
    DWORD           dwCallbackID,
    DWORD           dwCount,
    PDWORD          pdwParams
    );

//
// OEMImageProcessing - UNIDRV only
//

typedef struct {
    DWORD dwSize;
    POINT ptOffset;
    PSTR  pHalftoneOption;
    BOOL  bBanding;
    BOOL  bBlankBand;
} IPPARAMS, *PIPPARAMS;

PBYTE APIENTRY
OEMImageProcessing(
    PDEVOBJ     pdevobj,
    PBYTE       pSrcBitmap,
    PBITMAPINFOHEADER pBitmapInfoHeader,
    PBYTE       pColorTable,
    DWORD       dwCallbackID,
    PIPPARAMS   pIPParams
    );

//
// OEMFilterGraphics - UNIDRV only
//

BOOL APIENTRY
OEMFilterGraphics(
    PDEVOBJ pdevobj,
    PBYTE   pBuf,
    DWORD   dwLen
    );

//
// OEMCompression - UNIDRV only
//
INT APIENTRY
OEMCompression(
    PDEVOBJ pdevobj,
    PBYTE   pInBuf,
    PBYTE   pOutBuf,
    DWORD   dwInLen,
    DWORD   dwOutLen
    );

//
// OEMHalftone - UNIDRV only
//

BOOL APIENTRY
OEMHalftonePattern(
    PDEVOBJ pdevobj,
    PBYTE   pHTPattern,
    DWORD   dwHTPatternX,
    DWORD   dwHTPatternY,
    DWORD   dwHTNumPatterns,
    DWORD   dwCallbackID,
    PBYTE   pResource,
    DWORD   dwResourceSize
    );

//
// OEMMemoryUsage - UNIDRV only
//

typedef struct {
    DWORD   dwFixedMemoryUsage;
    DWORD   dwPercentMemoryUsage;
    DWORD   dwMaxBandSize;
} OEMMEMORYUSAGE, *POEMMEMORYUSAGE;

VOID APIENTRY
OEMMemoryUsage(
    PDEVOBJ pdevobj,
    POEMMEMORYUSAGE pMemoryUsage
    );

//
// OEMTTYGetInfo - UNIDRV only
//
INT APIENTRY
OEMTTYGetInfo(
    PDEVOBJ pdevobj,
    DWORD   dwInfoIndex,
    PVOID   pOutputBuf,
    DWORD   dwSize,
    DWORD   *pcbcNeeded
    );

#define OEMTTY_INFO_MARGINS     1
#define OEMTTY_INFO_CODEPAGE    2
#define OEMTTY_INFO_NUM_UFMS    3
#define OEMTTY_INFO_UFM_IDS     4

//
// UNIDRV font callback
//

typedef BOOL (*PFNGETINFO)(struct _UNIFONTOBJ*, DWORD, PVOID, DWORD, PDWORD);

typedef struct _UNIFONTOBJ {
    ULONG       ulFontID;
    DWORD       dwFlags;     // General flags
    IFIMETRICS *pIFIMetrics; // Pointer to IFIMETRICS
    PFNGETINFO  pfnGetInfo;  // Pointer to UNIFONTOBJ_GetInfo callback
} UNIFONTOBJ, *PUNIFONTOBJ;

//
// UNIFONTOBJ.dwFlags
//

#define UFOFLAG_TTFONT               0x00000001
#define UFOFLAG_TTDOWNLOAD_BITMAP    0x00000002
#define UFOFLAG_TTDOWNLOAD_TTOUTLINE 0x00000004

//
// UNIFONTOBJ callback ID
//

#define UFO_GETINFO_FONTOBJ     1
#define UFO_GETINFO_GLYPHSTRING 2
#define UFO_GETINFO_GLYPHBITMAP 3
#define UFO_GETINFO_GLYPHWIDTH  4
#define UFO_GETINFO_MEMORY      5
#define UFO_GETINFO_STDVARIABLE 6

//
// UFO_GETINFO_FONTOBJ callback structure
//

typedef struct _GETINFO_FONTOBJ {
    DWORD    dwSize;   // Size of this structure
    FONTOBJ *pFontObj; // Pointer to the FONTOBJ
} GETINFO_FONTOBJ, *PGETINFO_FONTOBJ;

//
// UFO_GETINFO_FONTOBJ callback structure
//

typedef struct _GETINFO_GLYPHSTRING {
    DWORD dwSize;    // Size of this structure
    DWORD dwCount;   // Count of glyphs in pGlyphIn
    DWORD dwTypeIn;  // Glyph type of pGlyphIn, TYPE_GLYPHID/TYPE_HANDLE.
    PVOID pGlyphIn;  // Pointer to the input glyph string
    DWORD dwTypeOut; // Glyph type of pGlyphOut, TYPE_UNICODE/TYPE_TRANSDATA.
    PVOID pGlyphOut; // Pointer to the output glyph string
    DWORD dwGlyphOutSize; // The size of pGlyphOut buffer
} GETINFO_GLYPHSTRING, *PGETINFO_GLYPHSTRING;

//
// UFO_GETINFO_GLYPHBITMAP
//

typedef struct _GETINFO_GLYPHBITMAP {
    DWORD       dwSize;    // Size of this structure
    HGLYPH      hGlyph;    // Glyph hangle passed in OEMDownloadCharGlyph
    GLYPHDATA *pGlyphData; // Pointer to the GLYPHDATA data structure
} GETINFO_GLYPHBITMAP, *PGETINFO_GLYPHBITMAP;

//
// UFO_GETINFO_GLYPHWIDTH
//

typedef struct _GETINFO_GLYPHWIDTH {
    DWORD dwSize;  // Size of this structure
    DWORD dwType;  // Type of glyph stirng in pGlyph, TYPE_GLYPHHANDLE/GLYPHID.
    DWORD dwCount; // Count of glyph in pGlyph
    PVOID pGlyph;  // Pointer to a glyph string
    PLONG plWidth; // Pointer to the buffer of width table.
                   // Minidriver has to prepare this.
} GETINFO_GLYPHWIDTH, *PGETINFO_GLYPHWIDTH;

//
// UFO_GETINFO_MEMORY
//

typedef struct _GETINFO_MEMORY {
    DWORD dwSize;
    DWORD dwRemainingMemory;
} GETINFO_MEMORY, PGETINFO_MEMROY;

//
// UFO_GETINFO_STDVARIABLE
//
// OEM DLL has to prepare all StdVar buffer and set ID in dwStdVarID.
//

typedef struct _GETINFO_STDVAR {
    DWORD dwSize;
    DWORD dwNumOfVariable;
    struct {
        DWORD dwStdVarID;
        LONG  lStdVariable;
    } StdVar[1];
} GETINFO_STDVAR, *PGETINFO_STDVAR;


#define FNT_INFO_PRINTDIRINCCDEGREES  0 // PrintDirInCCDegrees
#define FNT_INFO_GRAYPERCENTAGE       1 // GrayPercentage
#define FNT_INFO_NEXTFONTID           2 // NextfontID
#define FNT_INFO_NEXTGLYPH            3 // NextGlyph
#define FNT_INFO_FONTHEIGHT           4 // FontHeight
#define FNT_INFO_FONTWIDTH            5 // FontWidth
#define FNT_INFO_FONTBOLD             6 // FontBold
#define FNT_INFO_FONTITALIC           7 // FontItalic
#define FNT_INFO_FONTUNDERLINE        8 // FontUnderline
#define FNT_INFO_FONTSTRIKETHRU       9 // FontStrikeThru
#define FNT_INFO_CURRENTFONTID       10 // Current
#define FNT_INFO_TEXTYRES            11 // TextYRes
#define FNT_INFO_TEXTXRES            12 // TextXRes
#define FNT_INFO_FONTMAXWIDTH        13 // FontMaxWidth
#define FNT_INFO_MAX                 14

//
// OEMDownloadFontheader - UNIDRV only
//

DWORD APIENTRY
OEMDownloadFontHeader(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj
    );

//
// OEMDownloadCharGlyph - UNIDRV only
//

DWORD APIENTRY
OEMDownloadCharGlyph(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    HGLYPH      hGlyph,
    PDWORD      pdwWidth
    );

//
// OEMTTDownloadMethod - UNIDRV only
//

DWORD APIENTRY
OEMTTDownloadMethod(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj
    );

#define TTDOWNLOAD_DONTCARE  0
#define TTDOWNLOAD_GRAPHICS  1
#define TTDOWNLOAD_BITMAP    2
#define TTDOWNLOAD_TTOUTLINE 3

//
// OEMOutputCharStr - UNIDRV only
//

VOID APIENTRY
OEMOutputCharStr(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    DWORD       dwType,
    DWORD       dwCount,
    PVOID       pGlyph
    );

#define TYPE_UNICODE      1
#define TYPE_TRANSDATA    2
#define TYPE_GLYPHHANDLE  3
#define TYPE_GLYPHID      4

//
// OEMSendFontCmd - UNIDRV only
//

typedef struct _FINVOCATION {
    DWORD dwCount;    // Size of command
    PBYTE pubCommand; // Pointer to font selection command
} FINVOCATION, *PFINVOCATION;

VOID APIENTRY
OEMSendFontCmd(
    PDEVOBJ      pdevobj,
    PUNIFONTOBJ  pUFObj,
    PFINVOCATION pFInv
    );

//
// OEMTextOutAsBitmap - UNIDRV only
//
BOOL APIENTRY
OEMTextOutAsBitmap(
    SURFOBJ    *pso,
    STROBJ     *pstro,
    FONTOBJ    *pfo,
    CLIPOBJ    *pco,
    RECTL      *prclExtra,
    RECTL      *prclOpaque,
    BRUSHOBJ   *pboFore,
    BRUSHOBJ   *pboOpaque,
    POINTL     *pptlOrg,
    MIX         mix
    );

//
// OEMBitBlt
//

BOOL APIENTRY
OEMBitBlt(
    SURFOBJ        *psoTrg,
    SURFOBJ        *psoSrc,
    SURFOBJ        *psoMask,
    CLIPOBJ        *pco,
    XLATEOBJ       *pxlo,
    RECTL          *prclTrg,
    POINTL         *pptlSrc,
    POINTL         *pptlMask,
    BRUSHOBJ       *pbo,
    POINTL         *pptlBrush,
    ROP4            rop4
    );

//
// OEMStretchBlt
//

BOOL APIENTRY
OEMStretchBlt(
    SURFOBJ         *psoDest,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlHTOrg,
    RECTL           *prclDest,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG            iMode
    );

//
// OEMCopyBits
//

BOOL APIENTRY
OEMCopyBits(
    SURFOBJ        *psoDest,
    SURFOBJ        *psoSrc,
    CLIPOBJ        *pco,
    XLATEOBJ       *pxlo,
    RECTL          *prclDest,
    POINTL         *pptlSrc
    );

//
// OEMTextOut
//

BOOL APIENTRY
OEMTextOut(
    SURFOBJ    *pso,
    STROBJ     *pstro,
    FONTOBJ    *pfo,
    CLIPOBJ    *pco,
    RECTL      *prclExtra,
    RECTL      *prclOpaque,
    BRUSHOBJ   *pboFore,
    BRUSHOBJ   *pboOpaque,
    POINTL     *pptlOrg,
    MIX         mix
    );

//
// OEMStrokePath
//

BOOL APIENTRY
OEMStrokePath(
    SURFOBJ    *pso,
    PATHOBJ    *ppo,
    CLIPOBJ    *pco,
    XFORMOBJ   *pxo,
    BRUSHOBJ   *pbo,
    POINTL     *pptlBrushOrg,
    LINEATTRS  *plineattrs,
    MIX         mix
    );

//
// OEMFillPath
//

BOOL APIENTRY
OEMFillPath(
    SURFOBJ    *pso,
    PATHOBJ    *ppo,
    CLIPOBJ    *pco,
    BRUSHOBJ   *pbo,
    POINTL     *pptlBrushOrg,
    MIX         mix,
    FLONG       flOptions
    );

//
// OEMStrokeAndFillPath
//

BOOL APIENTRY
OEMStrokeAndFillPath(
    SURFOBJ    *pso,
    PATHOBJ    *ppo,
    CLIPOBJ    *pco,
    XFORMOBJ   *pxo,
    BRUSHOBJ   *pboStroke,
    LINEATTRS  *plineattrs,
    BRUSHOBJ   *pboFill,
    POINTL     *pptlBrushOrg,
    MIX         mixFill,
    FLONG       flOptions
    );

//
// OEMRealizeBrush
//

BOOL APIENTRY
OEMRealizeBrush(
    BRUSHOBJ   *pbo,
    SURFOBJ    *psoTarget,
    SURFOBJ    *psoPattern,
    SURFOBJ    *psoMask,
    XLATEOBJ   *pxlo,
    ULONG       iHatch
    );

//
// OEMStartPage
//

BOOL APIENTRY
OEMStartPage(
    SURFOBJ    *pso
    );

//
// OEMSendPage
//

BOOL APIENTRY
OEMSendPage(
    SURFOBJ    *pso
    );

//
// OEMEscape
//

ULONG APIENTRY
OEMEscape(
    SURFOBJ    *pso,
    ULONG       iEsc,
    ULONG       cjIn,
    PVOID       pvIn,
    ULONG       cjOut,
    PVOID       pvOut
    );

//
// OEMStartDoc
//

BOOL APIENTRY
OEMStartDoc(
    SURFOBJ    *pso,
    PWSTR       pwszDocName,
    DWORD       dwJobId
    );

//
// OEMEndDoc
//

BOOL APIENTRY
OEMEndDoc(
    SURFOBJ    *pso,
    FLONG       fl
    );

//
// OEMQueryFont
//

PIFIMETRICS APIENTRY
OEMQueryFont(
    DHPDEV      dhpdev,
    ULONG       iFile,
    ULONG       iFace,
    ULONG      *pid
    );

//
// OEMQueryFontTree
//

PVOID APIENTRY
OEMQueryFontTree(
    DHPDEV      dhpdev,
    ULONG       iFile,
    ULONG       iFace,
    ULONG       iMode,
    ULONG      *pid
    );

//
// OEMQueryFontData
//

LONG APIENTRY
OEMQueryFontData(
    DHPDEV      dhpdev,
    FONTOBJ    *pfo,
    ULONG       iMode,
    HGLYPH      hg,
    GLYPHDATA  *pgd,
    PVOID       pv,
    ULONG       cjSize
    );

//
// OEMQueryAdvanceWidths
//

BOOL APIENTRY
OEMQueryAdvanceWidths(
    DHPDEV      dhpdev,
    FONTOBJ    *pfo,
    ULONG       iMode,
    HGLYPH     *phg,
    PVOID       pvWidths,
    ULONG       cGlyphs
    );

//
// OEMFontManagement
//

ULONG APIENTRY
OEMFontManagement(
    SURFOBJ    *pso,
    FONTOBJ    *pfo,
    ULONG       iMode,
    ULONG       cjIn,
    PVOID       pvIn,
    ULONG       cjOut,
    PVOID       pvOut
    );

//
// OEMGetGlyphMode
//

ULONG APIENTRY
OEMGetGlyphMode(
    DHPDEV      dhpdev,
    FONTOBJ    *pfo
    );

BOOL APIENTRY
OEMNextBand(
    SURFOBJ *pso,
    POINTL *pptl
    );

BOOL APIENTRY
OEMStartBanding(
    SURFOBJ *pso,
    POINTL *pptl
    );

ULONG APIENTRY
OEMDitherColor(
    DHPDEV  dhpdev,
    ULONG   iMode,
    ULONG   rgbColor,
    ULONG  *pulDither
    );

BOOL APIENTRY
OEMPaint(
    SURFOBJ         *pso,
    CLIPOBJ         *pco,
    BRUSHOBJ        *pbo,
    POINTL          *pptlBrushOrg,
    MIX             mix
    );

BOOL APIENTRY
OEMLineTo(
    SURFOBJ    *pso,
    CLIPOBJ    *pco,
    BRUSHOBJ   *pbo,
    LONG        x1,
    LONG        y1,
    LONG        x2,
    LONG        y2,
    RECTL      *prclBounds,
    MIX         mix
    );

#ifndef WINNT_40

//
// OEMStretchBltROP
//

BOOL APIENTRY
OEMStretchBltROP(
    SURFOBJ         *psoDest,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlHTOrg,
    RECTL           *prclDest,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG            iMode,
    BRUSHOBJ        *pbo,
    ROP4             rop4
    );

//
// OEMPlgBlt
//

BOOL APIENTRY
OEMPlgBlt(
    SURFOBJ         *psoDst,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlBrushOrg,
    POINTFIX        *pptfixDest,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG           iMode
    );

//
// OEMAlphaBlend
//

BOOL APIENTRY
OEMAlphaBlend(
    SURFOBJ    *psoDest,
    SURFOBJ    *psoSrc,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    RECTL      *prclDest,
    RECTL      *prclSrc,
    BLENDOBJ   *pBlendObj
    );

//
// OEMGradientFill
//

BOOL APIENTRY
OEMGradientFill(
    SURFOBJ    *psoDest,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    TRIVERTEX  *pVertex,
    ULONG       nVertex,
    PVOID       pMesh,
    ULONG       nMesh,
    RECTL      *prclExtents,
    POINTL     *pptlDitherOrg,
    ULONG       ulMode
    );

//
// OEMIcmCreateTransform
//

HANDLE APIENTRY
OEMIcmCreateColorTransform(
    DHPDEV           dhpdev,
    LPLOGCOLORSPACEW pLogColorSpace,
    PVOID            pvSourceProfile,
    ULONG            cjSourceProfile,
    PVOID            pvDestProfile,
    ULONG            cjDestProfile,
    PVOID            pvTargetProfile,
    ULONG            cjTargetProfile,
    DWORD            dwReserved
    );

//
// OEMIcmDeleteTransform
//

BOOL APIENTRY
OEMIcmDeleteColorTransform(
    DHPDEV dhpdev,
    HANDLE hcmXform
    );

//
// OEMQueryDeviceSupport
//

BOOL APIENTRY
OEMQueryDeviceSupport(
    SURFOBJ    *pso,
    XLATEOBJ   *pxlo,
    XFORMOBJ   *pxo,
    ULONG      iType,
    ULONG      cjIn,
    PVOID      pvIn,
    ULONG      cjOut,
    PVOID      pvOut
    );

//
// OEMTransparentBlt
//

BOOL APIENTRY
OEMTransparentBlt(
    SURFOBJ    *psoDst,
    SURFOBJ    *psoSrc,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    RECTL      *prclDst,
    RECTL      *prclSrc,
    ULONG      iTransColor,
    ULONG      ulReserved
    );

#endif // !WINNT_40

//
// Function prototype define's for the driver hooks.
//
// NOTE: These are only needed for NT4. For NT5, they are defined in winddi.h.
//

#ifdef WINNT_40

typedef BOOL (APIENTRY  *LPFNDLLINITIALIZE)(
    ULONG           ulReason
    );

typedef BOOL (APIENTRY *PFN_DrvBitBlt)(
    SURFOBJ        *psoTrg,
    SURFOBJ        *psoSrc,
    SURFOBJ        *psoMask,
    CLIPOBJ        *pco,
    XLATEOBJ       *pxlo,
    RECTL          *prclTrg,
    POINTL         *pptlSrc,
    POINTL         *pptlMask,
    BRUSHOBJ       *pbo,
    POINTL         *pptlBrush,
    ROP4            rop4
    );

typedef BOOL (APIENTRY *PFN_DrvStretchBlt)(
    SURFOBJ         *psoDest,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlHTOrg,
    RECTL           *prclDest,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG            iMode
    );

typedef BOOL (APIENTRY *PFN_DrvCopyBits)(
    SURFOBJ        *psoDest,
    SURFOBJ        *psoSrc,
    CLIPOBJ        *pco,
    XLATEOBJ       *pxlo,
    RECTL          *prclDest,
    POINTL         *pptlSrc
    );

typedef BOOL (APIENTRY *PFN_DrvTextOut)(
    SURFOBJ    *pso,
    STROBJ     *pstro,
    FONTOBJ    *pfo,
    CLIPOBJ    *pco,
    RECTL      *prclExtra,
    RECTL      *prclOpaque,
    BRUSHOBJ   *pboFore,
    BRUSHOBJ   *pboOpaque,
    POINTL     *pptlOrg,
    MIX         mix
    );

typedef BOOL (APIENTRY *PFN_DrvStrokePath)(
    SURFOBJ    *pso,
    PATHOBJ    *ppo,
    CLIPOBJ    *pco,
    XFORMOBJ   *pxo,
    BRUSHOBJ   *pbo,
    POINTL     *pptlBrushOrg,
    LINEATTRS  *plineattrs,
    MIX         mix
    );

typedef BOOL (APIENTRY *PFN_DrvFillPath)(
    SURFOBJ    *pso,
    PATHOBJ    *ppo,
    CLIPOBJ    *pco,
    BRUSHOBJ   *pbo,
    POINTL     *pptlBrushOrg,
    MIX         mix,
    FLONG       flOptions
    );

typedef BOOL (APIENTRY *PFN_DrvStrokeAndFillPath)(
    SURFOBJ    *pso,
    PATHOBJ    *ppo,
    CLIPOBJ    *pco,
    XFORMOBJ   *pxo,
    BRUSHOBJ   *pboStroke,
    LINEATTRS  *plineattrs,
    BRUSHOBJ   *pboFill,
    POINTL     *pptlBrushOrg,
    MIX         mixFill,
    FLONG       flOptions
    );

typedef BOOL (APIENTRY *PFN_DrvRealizeBrush)(
    BRUSHOBJ   *pbo,
    SURFOBJ    *psoTarget,
    SURFOBJ    *psoPattern,
    SURFOBJ    *psoMask,
    XLATEOBJ   *pxlo,
    ULONG       iHatch
    );

typedef BOOL (APIENTRY *PFN_DrvStartPage)(
    SURFOBJ    *pso
    );

typedef BOOL (APIENTRY *PFN_DrvSendPage)(
    SURFOBJ    *pso
    );

typedef ULONG (APIENTRY *PFN_DrvEscape)(
    SURFOBJ    *pso,
    ULONG       iEsc,
    ULONG       cjIn,
    PVOID       pvIn,
    ULONG       cjOut,
    PVOID       pvOut
    );

typedef BOOL (APIENTRY *PFN_DrvStartDoc)(
    SURFOBJ    *pso,
    PWSTR       pwszDocName,
    DWORD       dwJobId
    );

typedef BOOL (APIENTRY *PFN_DrvEndDoc)(
    SURFOBJ    *pso,
    FLONG       fl
    );

typedef PIFIMETRICS (APIENTRY *PFN_DrvQueryFont)(
    DHPDEV      dhpdev,
    ULONG_PTR    iFile,
    ULONG       iFace,
    ULONG      *pid
    );

typedef PVOID (APIENTRY *PFN_DrvQueryFontTree)(
    DHPDEV      dhpdev,
    ULONG_PTR    iFile,
    ULONG       iFace,
    ULONG       iMode,
    ULONG      *pid
    );

typedef LONG (APIENTRY *PFN_DrvQueryFontData)(
    DHPDEV      dhpdev,
    FONTOBJ    *pfo,
    ULONG       iMode,
    HGLYPH      hg,
    GLYPHDATA  *pgd,
    PVOID       pv,
    ULONG       cjSize
    );

typedef BOOL (APIENTRY *PFN_DrvQueryAdvanceWidths)(
    DHPDEV      dhpdev,
    FONTOBJ    *pfo,
    ULONG       iMode,
    HGLYPH     *phg,
    PVOID       pvWidths,
    ULONG       cGlyphs
    );

typedef ULONG (APIENTRY *PFN_DrvFontManagement)(
    SURFOBJ    *pso,
    FONTOBJ    *pfo,
    ULONG       iMode,
    ULONG       cjIn,
    PVOID       pvIn,
    ULONG       cjOut,
    PVOID       pvOut
    );

typedef ULONG (APIENTRY *PFN_DrvGetGlyphMode)(
    DHPDEV      dhpdev,
    FONTOBJ    *pfo
    );

typedef BOOL (APIENTRY *PFN_DrvNextBand)(
    SURFOBJ *pso,
    POINTL *pptl
    );

typedef BOOL (APIENTRY *PFN_DrvStartBanding)(
    SURFOBJ *pso,
    POINTL *pptl
    );

typedef ULONG (APIENTRY *PFN_DrvDitherColor)(
    DHPDEV  dhpdev,
    ULONG   iMode,
    ULONG   rgbColor,
    ULONG  *pulDither
    );

typedef BOOL (APIENTRY *PFN_DrvPaint)(
    SURFOBJ         *pso,
    CLIPOBJ         *pco,
    BRUSHOBJ        *pbo,
    POINTL          *pptlBrushOrg,
    MIX             mix
    );

typedef BOOL (APIENTRY *PFN_DrvLineTo)(
    SURFOBJ    *pso,
    CLIPOBJ    *pco,
    BRUSHOBJ   *pbo,
    LONG        x1,
    LONG        y1,
    LONG        x2,
    LONG        y2,
    RECTL      *prclBounds,
    MIX         mix
    );

#endif // WINNT_40

#endif // KERNEL_MODE


/*******************************************************************************
 *
 * Definitions used by user-mode UI module only:
 *  Make sure the macro KERNEL_MODE is NOT defined and
 *  the header file winddiui.h is included before this file.
 *
 */

#ifndef KERNEL_MODE

//
// Reference to driver data structure. This is passed to
// most of the OEM UI DLL entrypoints.
//

typedef struct _OEMUIPROCS {

    PFN_DrvGetDriverSetting DrvGetDriverSetting;
    PFN_DrvUpdateUISetting  DrvUpdateUISetting;

} OEMUIPROCS, *POEMUIPROCS;

typedef struct _OEMUIOBJ {

    DWORD       cbSize;             // size of this structure
    POEMUIPROCS pOemUIProcs;        // pointer to user mode helper function table

} OEMUIOBJ, *POEMUIOBJ;


//
// OEMCommonUIProp
//

typedef struct _OEMCUIPPARAM *POEMCUIPPARAM;
typedef LONG (APIENTRY *OEMCUIPCALLBACK)(PCPSUICBPARAM, POEMCUIPPARAM);

typedef struct _OEMCUIPPARAM {

    DWORD           cbSize;         // size of this structure
    POEMUIOBJ       poemuiobj;      // reference to driver data structure
    HANDLE          hPrinter;       // handle to the current printer
    PWSTR           pPrinterName;   // name of current printer
    HANDLE          hModule;        // instance handle to OEM DLL
    HANDLE          hOEMHeap;       // handle to the OEM memory heap
    PDEVMODE        pPublicDM;      // public devmode
    PVOID           pOEMDM;         // OEM private devmode
    DWORD           dwFlags;        // misc. flag bits
    POPTITEM        pDrvOptItems;   // pointer to driver items
    DWORD           cDrvOptItems;   // number of driver items
    POPTITEM        pOEMOptItems;   // pointer to OEM items
    DWORD           cOEMOptItems;   // number of OEM items
    PVOID           pOEMUserData;   // pointer to OEM private data
    OEMCUIPCALLBACK  OEMCUIPCallback; // address of callback function

} OEMCUIPPARAM;

BOOL APIENTRY
OEMCommonUIProp(
    DWORD           dwMode,
    POEMCUIPPARAM   pOemCUIPParam
    );

//
// OEMCommonUIProp dwMode parameter value
//
#define OEMCUIP_DOCPROP       1
#define OEMCUIP_PRNPROP       2

//
// OEMDocumentPropertySheets
//

LRESULT APIENTRY
OEMDocumentPropertySheets(
    PPROPSHEETUI_INFO pPSUIInfo,
    LPARAM            lParam
    );

//
// OEMDevicePropertySheets
//

LRESULT APIENTRY
OEMDevicePropertySheets(
    PPROPSHEETUI_INFO pPSUIInfo,
    LPARAM            lParam
    );

//
// pPSUIInfo->lParamInit is a pointer to _OEMUIPSPARAM structure defined below.
//
typedef struct _OEMUIPSPARAM {

    DWORD           cbSize;         // size of this structure
    POEMUIOBJ       poemuiobj;      // reference to driver data structure
    HANDLE          hPrinter;       // handle to the current printer
    PWSTR           pPrinterName;   // name of current printer
    HANDLE          hModule;        // instance handle to OEM DLL
    HANDLE          hOEMHeap;       // handle to the OEM memory heap
    PDEVMODE        pPublicDM;      // public devmode
    PVOID           pOEMDM;         // OEM private devmode
    PVOID           pOEMUserData;   // pointer to OEM private data
    DWORD           dwFlags;        // misc. flag bits
    PVOID           pOemEntry;

} OEMUIPSPARAM, *POEMUIPSPARAM;

//
// OEMDevQueryPrintEx
//

BOOL APIENTRY
OEMDevQueryPrintEx(
    POEMUIOBJ           poemuiobj,
    PDEVQUERYPRINT_INFO pDQPInfo,
    PDEVMODE            pPublicDM,
    PVOID               pOEMDM
    );

//
// OEMDeviceCapabilities
//

DWORD APIENTRY
OEMDeviceCapabilities(
    POEMUIOBJ   poemuiobj,
    HANDLE      hPrinter,
    PWSTR       pDeviceName,
    WORD        wCapability,
    PVOID       pOutput,
    PDEVMODE    pPublicDM,
    PVOID       pOEMDM,
    DWORD       dwLastResult
    );

//
// OEMUpgradePrinter
//

BOOL APIENTRY
OEMUpgradePrinter(
    DWORD   dwLevel,
    PBYTE   pDriverUpgradeInfo
    );

//
// OEMUpgradeRegistry
//

BOOL APIENTRY
OEMUpgradeRegistry(
    DWORD   dwLevel,
    PBYTE   pDriverUpgradeInfo,
    PFN_DrvUpgradeRegistrySetting pfnUpgrade
    );


//
// OEMPrinterEvent
//

BOOL APIENTRY
OEMPrinterEvent(
    PWSTR   pPrinterName,
    INT     iDriverEvent,
    DWORD   dwFlags,
    LPARAM  lParam
    );

//
// OEMDriverEvent
//

BOOL APIENTRY
OEMPDriverEvent(
    DWORD   dwDriverEvent,
    DWORD   dwLevel,
    LPBYTE  pDriverInfo,
    LPARAM  lParam
    );


//
// OEMQueryColorProfile
//

BOOL APIENTRY
OEMQueryColorProfile(
    HANDLE      hPrinter,
    POEMUIOBJ   poemuiobj,
    PDEVMODE    pPublicDM,
    PVOID       pOEMDM,
    ULONG       ulQueryMode,
    VOID       *pvProfileData,
    ULONG      *pcbProfileData,
    FLONG      *pflProfileData
    );

//
// Font Installer dialog proc
//

INT_PTR CALLBACK
OEMFontInstallerDlgProc(
    HWND    hWnd,
    UINT    usMsg,
    WPARAM  wParam,
    LPARAM  lParam
    );


BOOL CALLBACK
OEMUpdateExternalFonts(
    HANDLE  hPrinter,
    HANDLE  hHeap,
    PWSTR   pwstrCartridges
   );


#endif // !KERNEL_MODE

#ifdef __cplusplus
}
#endif

#endif  // !_PRINTOEM_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\public\oak\inc\prntfont.h ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    prntfont.h

Abstract:

    Declarations for Windows NT printer driver font metrics and glyphset data
    *.UFF, *.UFM and *.GTT file data structure definition

--*/

#ifndef _PRNTFONT_H_
#define _PRNTFONT_H_



//
//
// F O N T  M E T R I C S  ( U F M )
//
//

//
// NOTE: To include this header file, it is necessary to include 
//       winddi.h, that has a definition of IFIMETRICS, FD_KERNINGPAIR
//
//


//
// UNIFM
//
// Universal printer driver (UNIDRV) font file header.
//

#define UNIFM_VERSION_1_0 0x00010000

typedef struct _UNIFM_HDR
{
    DWORD      dwSize;             // a total size of this font file
    DWORD      dwVersion;          // a version number of this font file
    ULONG      ulDefaultCodepage;  // this font's default codepage
    LONG       lGlyphSetDataRCID;  // a resource ID of GLYPHDATA
    DWORD      loUnidrvInfo;       // offset to UNIDRVINFO
    DWORD      loIFIMetrics;       // offset to IFIMETRICS
    DWORD      loExtTextMetric;    // offset to EXTTEXTMETRIC
    DWORD      loWidthTable;       // offset to WIDTHTABLE
    DWORD      loKernPair;         // offset to KERNPAIR
    DWORD      dwReserved[2];
} UNIFM_HDR, *PUNIFM_HDR;

#define GET_UNIDRVINFO(pUFM)    \
        ((PUNIDRVINFO)((PBYTE)(pUFM) + (pUFM)->loUnidrvInfo))
#define GET_IFIMETRICS(pUFM)    \
        ((IFIMETRICS*)((PBYTE)(pUFM) + (pUFM)->loIFIMetrics))
#define GET_EXTTEXTMETRIC(pUFM) \
        ((EXTTEXTMETRIC*)((PBYTE)(pUFM) + (pUFM)->loExtTextMetric))
#define GET_WIDTHTABLE(pUFM)    \
        ((PWIDTHTABLE)((PBYTE)(pUFM) + (pUFM)->loWidthTable))
#define GET_KERNDATA(pUFM)      \
        ((PKERNDATA)((PBYTE)(pUFM) + (pUFM)->loKernPair))

//
// UNIDRVINFO
//
// UNIDRVINFO is used to define printer specific information.
//

typedef struct _INVOC {
        DWORD  dwCount;     // the number of bytes in the invocation string
        DWORD  loOffset;    // byte-offset to the beginning of the array
} INVOC, *PINVOC;

typedef struct _UNIDRVINFO
{
    DWORD   dwSize;
    DWORD   flGenFlags;
    WORD    wType;
    WORD    fCaps;
    WORD    wXRes;
    WORD    wYRes;
    short   sYAdjust;
    short   sYMoved;
    WORD    wPrivateData; 
    short   sShift; 
    INVOC   SelectFont;
    INVOC   UnSelectFont;
    WORD    wReserved[4];
}  UNIDRVINFO, *PUNIDRVINFO;

#define GET_SELECT_CMD(pUni)    \
        ((PCHAR)(pUni) + (pUni)->SelectFont.loOffset)
#define GET_UNSELECT_CMD(pUni)  \
        ((PCHAR)(pUni) + (pUni)->UnSelectFont.loOffset)

//
// flGenFlags
//

#define UFM_SOFT        0x00000001 // Softfont, thus needs downloading 
#define UFM_CART        0x00000002 // This is a cartridge font
#define UFM_SCALABLE    0x00000004 // Font is scalable

//
// wType
//

#define DF_TYPE_HPINTELLIFONT         0     // HP's Intellifont
#define DF_TYPE_TRUETYPE              1     // HP's PCLETTO fonts on LJ4
#define DF_TYPE_PST1                  2     // Lexmark PPDS scalable fonts
#define DF_TYPE_CAPSL                 3     // Canon CAPSL scalable fonts
#define DF_TYPE_OEM1                  4     // OEM scalable font type 1
#define DF_TYPE_OEM2                  5     // OEM scalable font type 2

//
// fCaps
//

#define DF_NOITALIC             0x0001  // Cannot italicize via FONTSIMULATION
#define DF_NOUNDER              0x0002  // Cannot underline via FONTSIMULATION
#define DF_XM_CR                0x0004  // send CR after using this font
#define DF_NO_BOLD              0x0008  // Cannot bold via FONTSIMULATION
#define DF_NO_DOUBLE_UNDERLINE  0x0010  // Cannot double underline via 
                                        // FONTSIMU ATION
#define DF_NO_STRIKETHRU        0x0020  // Cannot strikethru via FONTSIMULATION
#define DF_BKSP_OK              0x0040  // Can use backspace char, see spec 
                                        // for details

//
// EXTTEXTMETRIC
//
// The EXTTEXTMETRIC structure provides extended-metric information for a font. 
// All the measurements are given in the specified units, 
// regardless of the current mapping mode of the display context.
//

#ifndef _EXTTEXTMETRIC_
#define _EXTTEXTMETRIC_

typedef struct _EXTTEXTMETRIC
    {
    short   emSize;
    short   emPointSize;
    short   emOrientation;
    short   emMasterHeight;
    short   emMinScale;
    short   emMaxScale;
    short   emMasterUnits;
    short   emCapHeight;
    short   emXHeight;
    short   emLowerCaseAscent;
    short   emLowerCaseDescent;
    short   emSlant;
    short   emSuperScript;
    short   emSubScript;
    short   emSuperScriptSize;
    short   emSubScriptSize;
    short   emUnderlineOffset;
    short   emUnderlineWidth;
    short   emDoubleUpperUnderlineOffset;
    short   emDoubleLowerUnderlineOffset;
    short   emDoubleUpperUnderlineWidth;
    short   emDoubleLowerUnderlineWidth;
    short   emStrikeOutOffset;
    short   emStrikeOutWidth;
    WORD    emKernPairs;
    WORD    emKernTracks;
} EXTTEXTMETRIC, *PEXTTEXTMETRIC;

#endif // _EXTTEXTMETRIC_


//
// WIDTHTABLE
//
// This data structure represents the character width table. 
// This width table is a continuous GLYPHHANDLE base, 
// not Unicode nor codepage/character code base. 
// GLYPHANDLE information is in the GLYPHDATA.
//

typedef struct _WIDTHRUN
{
    WORD    wStartGlyph;       // index of the first glyph handle
    WORD    wGlyphCount;       // number of glyphs covered
    DWORD   loCharWidthOffset; // glyph width table
} WIDTHRUN, *PWIDTHRUN;

typedef struct _WIDTHTABLE
{
    DWORD   dwSize;        // the size of this structure including every run
    DWORD   dwRunNum;      // the number of widthrun
    WIDTHRUN WidthRun[1];  // width run array
} WIDTHTABLE, *PWIDTHTABLE;

//
// The array has wGlyphCount elements and each element is the char width 
// for a single glyph. The first width corresponds to glyph index wStartGlyph 
// and so on. The byte offset is relative to the beginning of WIDTHTABLE
// structure and must be WORD-aligned.
// In case of Western device font, proportional font has all varibal pitch
// characters. This means that dwRunNum is set to 1 and loCharWidthOffset
// would be an offset from the top of WIDTHTABLE to a width vector of all 
// characters.
// In case of Far Eastern device font, basically IFIMETRICS.fwdAveCharWidth and
// IFIMETRICS.fwdMaxCharWidth are used for single byte and double byte character
// width. If a font is proportional, a UFM has a WIDTHTABLE which represents
// only the proportional pitch characters. Other characters use fdwAveCharWidth
// and fwdMaxCharInc for single and double byte characters.
//

//
// KERNDATA
// This data structure represents kerning pair information.
// This kerning pair table is a Unicode base.
//

typedef struct _KERNDATA
{
    DWORD dwSize;               // the size of this structure including array
    DWORD dwKernPairNum;        // the number of kerning pair
    FD_KERNINGPAIR KernPair[1]; // FD_KERNINGPAIR array
} KERNDATA, *PKERNDATA;



//
//
// G L Y P H  S E T D A T A  ( G T T )
//
//

//
// UNI_GLYPHSETDATA
//
// GLYPHSETDATA data structure represents a character encoding information 
// of printer device font. 
//

typedef struct _UNI_GLYPHSETDATA {
        DWORD   dwSize;
        DWORD   dwVersion;
        DWORD   dwFlags;
        LONG    lPredefinedID;
        DWORD   dwGlyphCount;
        DWORD   dwRunCount;
        DWORD   loRunOffset;
        DWORD   dwCodePageCount;
        DWORD   loCodePageOffset;
        DWORD   loMapTableOffset;
        DWORD   dwReserved[2];
} UNI_GLYPHSETDATA, *PUNI_GLYPHSETDATA;

#define UNI_GLYPHSETDATA_VERSION_1_0    0x00010000

#define GET_GLYPHRUN(pGTT)     \
    ((PGLYPHRUN) ((PBYTE)(pGTT) + ((PUNI_GLYPHSETDATA)pGTT)->loRunOffset))
#define GET_CODEPAGEINFO(pGTT) \
    ((PUNI_CODEPAGEINFO) ((PBYTE)(pGTT) + ((PUNI_GLYPHSETDATA)pGTT)->loCodePageOffset))
#define GET_MAPTABLE(pGTT) \
    ((PMAPTABLE) ((PBYTE)(pGTT) + ((PUNI_GLYPHSETDATA)pGTT)->loMapTableOffset))

//
// UNI_CODEPAGEINFO
//
// This UNI_CODEPAGEINFO dats structure has a list of Codepage values 
// which are supported by this UNI_GLYPHSETDATA.
//

typedef struct _UNI_CODEPAGEINFO {
    DWORD dwCodePage;
    INVOC SelectSymbolSet;
    INVOC UnSelectSymbolSet;
} UNI_CODEPAGEINFO, *PUNI_CODEPAGEINFO;

//
// GLYPHRUN
//
// GLYPHRUN dats structure represents the conversion table from Unicode to 
// UNI_GLYPHSETDATA specific glyph handle. Glyph handle is continuous number 
// starting from zero.
//

typedef struct _GLYPHRUN {
    WCHAR   wcLow;
    WORD    wGlyphCount;
} GLYPHRUN, *PGLYPHRUN;


//
// MAPTABLE and TRANSDATA
//
// This MAPTABLE data structure represents a conversion table fron glyph handle
// to codepage/character code.
//

typedef struct _TRANSDATA {
    BYTE  ubCodePageID; // Codepage index to CODEPAGENFO data structure array
    BYTE  ubType;       // a type of TRANSDATA
    union
    {
        SHORT   sCode;
        BYTE    ubCode;
        BYTE    ubPairs[2];
    } uCode;
} TRANSDATA, *PTRANSDATA;

typedef struct _MAPTABLE {
    DWORD     dwSize;     // the size of MAPTABLE including TRANSDATA array
    DWORD     dwGlyphNum; // the number of glyphs supported in MAPTABLE
    TRANSDATA Trans[1];   // an array of TRANSDATA
} MAPTABLE, *PMAPTABLE;

//
// ubType flags
//
// One of following three can be specified for the type of uCode.
//

#define MTYPE_FORMAT_MASK 0x07
#define MTYPE_COMPOSE   0x01 // wCode is an array of 16-bit offsets from the
                             // beginning of the MAPTABLE pointing to the
                             // strings to use for translation.
                             // bData representes thelength of the translated
                             // string.
#define MTYPE_DIRECT    0x02 // wCode is a byte data of one-to-one translation
#define MTYPE_PAIRED    0x04 // wCode contains a word data to emit.

//
// One of following tow can be specified for Far East multibyte character.
//

#define MTYPE_DOUBLEBYTECHAR_MASK   0x18
#define MTYPE_SINGLE    0x08 // wCode contains a single byte character code in
                             // multi byte character string.
#define MTYPE_DOUBLE    0x10 // wCode contains a double byte character code in
                             // multi byte character string.
//
// One of following three can be specified for replace/add/disable system 
// predefined GTT.
//

#define MTYPE_PREDEFIN_MASK   0xe0
#define MTYPE_REPLACE   0x20 // wCode contains a data to replace predefined one.
#define MTYPE_ADD       0x40 // wCode contains a data to add to predefiend one.
#define MTYPE_DISABLE   0x80 // wCode contains a data to remove from predefined.


//
// System predefined character conversion
//
// UNIDRV is going to support  following system predefined character conversion.
// By speciffying these number in UNIFM.dwGlyphSetDataRCID;
//

#define CC_NOPRECNV 0x0000FFFF // Not use predefined

//
// ANSI
//

#define CC_CP437   -1 // Unicode to IBM Codepage 437
#define CC_CP850   -2 // Unicode to IBM Codepage 850
#define CC_CP863   -3 // Unicode to IBM Codepage 863

//
// Far East
//

#define CC_BIG5     -10 // Unicode to Chinese Big 5. Codepage 950.
#define CC_ISC      -11 // Unicode to Korean Industrial Standard. Codepage 949.
#define CC_JIS      -12 // Unicode to JIS X0208. Codepage 932.
#define CC_JIS_ANK  -13 // Unicode to JIS X0208 except ANK. Codepage 932.
#define CC_NS86     -14 // Big-5 to National Standstand conversion. Codepage 950
#define CC_TCA      -15 // Big-5 to Taipei Computer Association. Codepage 950.
#define CC_GB2312   -16 // Unicode to GB2312. Codepage 936
#define CC_SJIS     -17 // Unicode to Shift-JIS. Codepage 932.
#define CC_WANSUNG  -18 // Unicode to Extented Wansung. Codepage 949.


//
//
// U N I V E R S A L  F O N T  F O R M A T  ( U F F )
//
//

//
// Font file header
//

typedef struct _UFF_FILEHEADER {
    DWORD       dwSignature;            // File magic number
    DWORD       dwVersion;              // UFF file format version number
    DWORD       dwSize;                 // Size of this structure

    DWORD       nFonts;                 // Count of fonts in directory
    DWORD       nGlyphSets;             // Count of glyph set data
    DWORD       nVarData;               // Count of variable data

    DWORD       offFontDir;             // Offset of font directory
    DWORD       dwFlags;                // Miscellaneous flags
    DWORD       dwReserved[4];          // Reserved, set to zero
} UFF_FILEHEADER, *PUFF_FILEHEADER;

//
// Values used in the file header
//

#define UFF_FILE_MAGIC      '1FFU'
#define UFF_VERSION_NUMBER  0x00010001

#define FONT_DIR_SORTED     0x00000001

//
// Font directory structure
//

typedef struct _UFF_FONTDIRECTORY {
    DWORD       dwSignature;            // Signature of font metrics record
    WORD        wSize;                  // Size of this structure
    WORD        wFontID;                // Unique font ID
    SHORT       sGlyphID;               // Associated glyph ID. 0 is default.
                                        // -ve values are predefined IDs
    WORD        wFlags;                 // Miscellaneous flags
    DWORD       dwInstallerSig;         // Signature of installer that installed this font
    DWORD       offFontName;            // Offset to name of font
    DWORD       offCartridgeName;       // Offset to name of font cartridge
    DWORD       offFontData;            // Offset to font data record
    DWORD       offGlyphData;           // Offset to glyph set data
    DWORD       offVarData;             // Offset to softfont data
} UFF_FONTDIRECTORY, *PUFF_FONTDIRECTORY;

#define FONT_REC_SIG            'CERF'  // font metrics record signature

#define WINNT_INSTALLER_SIG     'IFTN'  // NT font installer

//
// Flags used in font directory
//

#define FONT_FL_UFM             0x0001
#define FONT_FL_IFI             0x0002
#define FONT_FL_SOFTFONT        0x0004
#define FONT_FL_PERMANENT_SF    0x0008
#define FONT_FL_DEVICEFONT      0x0010
#define FONT_FL_GLYPHSET_GTT    0x0020
#define FONT_FL_GLYPHSET_RLE    0x0040
#define FONT_FL_RESERVED        0x8000

//
// Data header
//

typedef struct _DATA_HEADER {
    DWORD       dwSignature;            // Signature of data type
    WORD        wSize;                  // Size of this structure
    WORD        wDataID;                // Identifier number for data
    DWORD       dwDataSize;             // Size of data excluding structure
    DWORD       dwReserved;             // Reserved, set to zero
} DATA_HEADER, *PDATA_HEADER;

//
// Data signatures
//

#define DATA_UFM_SIG        'MFUD'
#define DATA_IFI_SIG        'IFID'
#define DATA_GTT_SIG        'TTGD'
#define DATA_CTT_SIG        'TTCD'
#define DATA_VAR_SIG        'RAVD'

//
// Structure passed to font installer dialog proc through LPARAM
//

typedef struct _OEMFONTINSTPARAM {
    DWORD   cbSize;
    HANDLE  hPrinter;
    HANDLE  hModule;
    HANDLE  hHeap;
    DWORD   dwFlags;
    PWSTR   pFontInstallerName;
} OEMFONTINSTPARAM, *POEMFONTINSTPARAM;

#define FG_CANCHANGE        0x00080    // Have access to change data

#define WM_FI_FILENAME      900        // To get the font installer name.



#endif //_PRNTFONT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\public\oak\inc\winddi.h ===
/*++

Copyright (c) 1985-1999, Microsoft Corporation

Module Name:

    winddi.h

Abstract:

    Private entry points, defines and types for Windows NT GDI device
    driver interface.

--*/

#ifndef _WINDDI_
#define _WINDDI_

//
// GUID definitions for use with kernel-mode GDI drivers
//

#ifndef _NO_DDRAWINT_NO_COM

#ifndef EXTERN_C
    #ifdef __cplusplus
        #define EXTERN_C    extern "C"
    #else // !defined(__cplusplus)
        #define EXTERN_C    extern
    #endif // !defined(__cplusplus)
#endif // !defined(EXTERN_C)

#ifndef DEFINE_GUID
#ifndef INITGUID
#define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
    EXTERN_C const GUID FAR name
#else // !defined(INITGUID)

#define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
        EXTERN_C const GUID name \
                = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }
#endif // !defined(INITGUID)
#endif // !defined(DEFINE_GUID)

#ifndef DEFINE_GUIDEX
    #define DEFINE_GUIDEX(name) EXTERN_C const CDECL GUID name
#endif // !defined(DEFINE_GUIDEX)

#ifndef STATICGUIDOF
    #define STATICGUIDOF(guid) STATIC_##guid
#endif // !defined(STATICGUIDOF)

#ifndef GUID_DEFINED
    #define GUID_DEFINED
    typedef struct _GUID {
        ULONG   Data1;
        USHORT  Data2;
        USHORT  Data3;
        UCHAR   Data4[8];
    } GUID;
#endif // !defined(GUID_DEFINED)

#ifndef IsEqualGUID
    #define IsEqualGUID(guid1, guid2) \
        (!memcmp((guid1), (guid2), sizeof(GUID)))
#endif // !defined(IsEqualGUID)

#ifndef IsEqualIID
    #define IsEqualIID IsEqualGUID
#endif // !defined(IsEqualIID)

#endif // !defined(_NO_DDRAWINT_NO_COM)

//
// Standard DirectX HAL includes
//

#include <ddrawint.h>
#include <d3dnthal.h>

#ifdef __cplusplus
extern "C" {
#endif


//
// drivers and other components that include this should NOT include
// windows.h  They should be system conponents that only use GDI internals
// and therefore only include wingdi.h
//

#if defined(_X86_) && !defined(USERMODE_DRIVER) && !defined(BUILD_WOW6432)
//
// x86 does not support floating-point instruction in the kernel mode,
// the floating-point data would like be handled 32bits value as double words.
//
typedef DWORD FLOATL;
#else
//
// Any platform that has support for floats in the kernel
//
typedef FLOAT FLOATL;
#endif // _X86_

typedef LONG	    PTRDIFF;
typedef PTRDIFF    *PPTRDIFF;
typedef LONG        FIX;
typedef FIX        *PFIX;
typedef ULONG       ROP4;
typedef ULONG       MIX;
typedef ULONG       HGLYPH;
typedef HGLYPH     *PHGLYPH;
#define HGLYPH_INVALID ((HGLYPH)-1)

typedef ULONG           IDENT;

//
// handles for font file and font context objects
//

typedef ULONG_PTR HFF;
typedef ULONG_PTR HFC;
#define HFF_INVALID ((HFF) 0)
#define HFC_INVALID ((HFC) 0)

#define FD_ERROR  0xFFFFFFFF
#define DDI_ERROR 0xFFFFFFFF

typedef struct _POINTE      /* pte  */
{
    FLOATL x;
    FLOATL y;
} POINTE, *PPOINTE;

typedef union _FLOAT_LONG
{
    FLOATL   e;
    LONG     l;
} FLOAT_LONG, *PFLOAT_LONG;

typedef struct  _POINTFIX
{
    FIX   x;
    FIX   y;
} POINTFIX, *PPOINTFIX;

typedef struct _RECTFX
{
    FIX   xLeft;
    FIX   yTop;
    FIX   xRight;
    FIX   yBottom;
} RECTFX, *PRECTFX;


DECLARE_HANDLE(HBM);
DECLARE_HANDLE(HDEV);
DECLARE_HANDLE(HSURF);
DECLARE_HANDLE(DHSURF);
DECLARE_HANDLE(DHPDEV);
DECLARE_HANDLE(HDRVOBJ);

#define LTOFX(x)            ((x)<<4)

#define FXTOL(x)            ((x)>>4)
#define FXTOLFLOOR(x)       ((x)>>4)
#define FXTOLCEILING(x)     ((x + 0x0F)>>4)
#define FXTOLROUND(x)       ((((x) >> 3) + 1) >> 1)

// context information

typedef struct _FD_XFORM {
    FLOATL eXX;
    FLOATL eXY;
    FLOATL eYX;
    FLOATL eYY;
} FD_XFORM, *PFD_XFORM;


typedef struct _FD_DEVICEMETRICS {       // devm
    FLONG  flRealizedType;
    POINTE pteBase;
    POINTE pteSide;
    LONG   lD;
    FIX    fxMaxAscender;
    FIX    fxMaxDescender;
    POINTL ptlUnderline1;
    POINTL ptlStrikeOut;
    POINTL ptlULThickness;
    POINTL ptlSOThickness;
    ULONG  cxMax;                      // max pel width of bitmaps

// the fields formerly in REALIZE_EXTRA as well as some new fields:

    ULONG cyMax;      // did not use to be here
    ULONG cjGlyphMax; // (cxMax + 7)/8 * cyMax, or at least it should be

    FD_XFORM  fdxQuantized;
    LONG      lNonLinearExtLeading;
    LONG      lNonLinearIntLeading;
    LONG      lNonLinearMaxCharWidth;
    LONG      lNonLinearAvgCharWidth;

// some new fields

    LONG      lMinA;
    LONG      lMinC;
    LONG      lMinD;

    LONG      alReserved[1]; // just in case we need it.

} FD_DEVICEMETRICS, *PFD_DEVICEMETRICS;

typedef struct _LIGATURE { /* lig */
        ULONG culSize;
        LPWSTR pwsz;
        ULONG chglyph;
        HGLYPH ahglyph[1];
} LIGATURE, *PLIGATURE;

typedef struct _FD_LIGATURE {
        ULONG culThis;
        ULONG ulType;
        ULONG cLigatures;
        LIGATURE alig[1];
} FD_LIGATURE;


// glyph handle must be 32 bit


// signed 16 bit integer type denoting number of FUnit's

typedef SHORT FWORD;

// point in the 32.32 bit precission

typedef struct _POINTQF    // ptq
{
    LARGE_INTEGER x;
    LARGE_INTEGER y;
} POINTQF, *PPOINTQF;

//. Structures


//     devm.flRealizedType flags

// FDM_TYPE_ZERO_BEARINGS           // all glyphs have zero a and c spaces

// the following two features refer to all glyphs in this font realization

// FDM_TYPE_CHAR_INC_EQUAL_BM_BASE  // base width == cx for horiz, == cy for vert.
// FDM_TYPE_MAXEXT_EQUAL_BM_SIDE    // side width == cy for horiz, == cx for vert.

#define FDM_TYPE_BM_SIDE_CONST          0x00000001
#define FDM_TYPE_MAXEXT_EQUAL_BM_SIDE   0x00000002
#define FDM_TYPE_CHAR_INC_EQUAL_BM_BASE 0x00000004
#define FDM_TYPE_ZERO_BEARINGS          0x00000008
#define FDM_TYPE_CONST_BEARINGS         0x00000010


// structures for describing a supported set of glyphs in a font

typedef struct _WCRUN {
    WCHAR   wcLow;        // lowest character in run  inclusive
    USHORT  cGlyphs;      // wcHighInclusive = wcLow + cGlyphs - 1;
    HGLYPH *phg;          // pointer to an array of cGlyphs HGLYPH's
} WCRUN, *PWCRUN;

// If phg is set to (HGLYPH *)NULL, for all wc's in this particular run
// the handle can be computed as simple zero extension:
//        HGLYPH hg = (HGLYPH) wc;
//
// If phg is not NULL, memory pointed to by phg, allocated by the driver,
// WILL NOT MOVE.


typedef struct _FD_GLYPHSET {
    ULONG    cjThis;           // size of this structure in butes
    FLONG    flAccel;          // accel flags, bits to be explained below
    ULONG    cGlyphsSupported; // sum over all wcrun's of wcrun.cGlyphs
    ULONG    cRuns;
    WCRUN    awcrun[1];        // an array of cRun WCRUN structures
} FD_GLYPHSET, *PFD_GLYPHSET;

typedef struct _FD_GLYPHATTR {
    ULONG    cjThis;           // size of this structure in butes
    ULONG    cGlyphs;
    ULONG    iMode;
    BYTE     aGlyphAttr[1];    // an array of byte
} FD_GLYPHATTR, *PFD_GLYPHATTR;

// If GS_UNICODE_HANDLES  bit is set,
// for ALL WCRUNS in this FD_GLYPHSET the handles are
// obtained by zero extending unicode code points of
// the corresponding supported glyphs, i.e. all gs.phg's are NULL

#define GS_UNICODE_HANDLES      0x00000001

// If GS_8BIT_HANDLES bit is set, all handles are in 0-255 range.
// This is just an ansi font then and we are really making up all
// the unicode stuff about this font.

#define GS_8BIT_HANDLES         0x00000002

// all handles fit in 16 bits.
// to 8 bit handles as it should.

#define GS_16BIT_HANDLES        0x00000004


// ligatures


typedef struct _FD_KERNINGPAIR {
    WCHAR  wcFirst;
    WCHAR  wcSecond;
    FWORD  fwdKern;
} FD_KERNINGPAIR;

// IFIMETRICS constants

#define FM_VERSION_NUMBER                   0x0

//
// IFIMETRICS::fsType flags
//
#define FM_TYPE_LICENSED                    0x2
#define FM_READONLY_EMBED                   0x4
#define FM_EDITABLE_EMBED                   0x8
#define FM_NO_EMBEDDING                     FM_TYPE_LICENSED

//
// IFIMETRICS::flInfo flags
//
#define FM_INFO_TECH_TRUETYPE               0x00000001
#define FM_INFO_TECH_BITMAP                 0x00000002
#define FM_INFO_TECH_STROKE                 0x00000004
#define FM_INFO_TECH_OUTLINE_NOT_TRUETYPE   0x00000008
#define FM_INFO_ARB_XFORMS                  0x00000010
#define FM_INFO_1BPP                        0x00000020
#define FM_INFO_4BPP                        0x00000040
#define FM_INFO_8BPP                        0x00000080
#define FM_INFO_16BPP                       0x00000100
#define FM_INFO_24BPP                       0x00000200
#define FM_INFO_32BPP                       0x00000400
#define FM_INFO_INTEGER_WIDTH               0x00000800
#define FM_INFO_CONSTANT_WIDTH              0x00001000
#define FM_INFO_NOT_CONTIGUOUS              0x00002000
#define FM_INFO_TECH_MM                     0x00004000
#define FM_INFO_RETURNS_OUTLINES            0x00008000
#define FM_INFO_RETURNS_STROKES             0x00010000
#define FM_INFO_RETURNS_BITMAPS             0x00020000
#define FM_INFO_DSIG                        0x00040000 // FM_INFO_UNICODE_COMPLIANT
#define FM_INFO_RIGHT_HANDED                0x00080000
#define FM_INFO_INTEGRAL_SCALING            0x00100000
#define FM_INFO_90DEGREE_ROTATIONS          0x00200000
#define FM_INFO_OPTICALLY_FIXED_PITCH       0x00400000
#define FM_INFO_DO_NOT_ENUMERATE            0x00800000
#define FM_INFO_ISOTROPIC_SCALING_ONLY      0x01000000
#define FM_INFO_ANISOTROPIC_SCALING_ONLY    0x02000000
#define FM_INFO_TECH_CFF                    0x04000000
#define FM_INFO_FAMILY_EQUIV                0x08000000
#define FM_INFO_DBCS_FIXED_PITCH            0x10000000
#define FM_INFO_NONNEGATIVE_AC              0x20000000
#define FM_INFO_IGNORE_TC_RA_ABLE           0x40000000
#define FM_INFO_TECH_TYPE1                  0x80000000

// max number of charsets supported in a tt font, 16 according to win95 guys

#define MAXCHARSETS 16

//
// IFIMETRICS::ulPanoseCulture
//
#define  FM_PANOSE_CULTURE_LATIN     0x0


//
// IFMETRICS::fsSelection flags
//
#define  FM_SEL_ITALIC          0x0001
#define  FM_SEL_UNDERSCORE      0x0002
#define  FM_SEL_NEGATIVE        0x0004
#define  FM_SEL_OUTLINED        0x0008
#define  FM_SEL_STRIKEOUT       0x0010
#define  FM_SEL_BOLD            0x0020
#define  FM_SEL_REGULAR         0x0040

//
// The FONTDIFF structure contains all of the fields that could
// possibly change under simulation
//
typedef struct _FONTDIFF {
    BYTE   jReserved1;      // 0x0
    BYTE   jReserved2;      // 0x1
    BYTE   jReserved3;      // 0x2
    BYTE   bWeight;         // 0x3  Panose Weight
    USHORT usWinWeight;     // 0x4
    FSHORT fsSelection;     // 0x6
    FWORD  fwdAveCharWidth; // 0x8
    FWORD  fwdMaxCharInc;   // 0xA
    POINTL ptlCaret;        // 0xC
} FONTDIFF;

typedef struct _FONTSIM {
    PTRDIFF  dpBold;       // offset from beginning of FONTSIM to FONTDIFF
    PTRDIFF  dpItalic;     // offset from beginning of FONTSIM to FONTDIFF
    PTRDIFF  dpBoldItalic; // offset from beginning of FONTSIM to FONTDIFF
} FONTSIM;


typedef struct _IFIMETRICS {
    ULONG    cjThis;           // includes attached information
    ULONG    cjIfiExtra;       // sizeof IFIEXTRA if any, formerly ulVersion
    PTRDIFF  dpwszFamilyName;
    PTRDIFF  dpwszStyleName;
    PTRDIFF  dpwszFaceName;
    PTRDIFF  dpwszUniqueName;
    PTRDIFF  dpFontSim;
    LONG     lEmbedId;
    LONG     lItalicAngle;
    LONG     lCharBias;

// dpCharSet field replaced alReserved[0].
// If the 3.51 pcl minidrivers are still to work on NT 4.0 this field must not
// move because they will have 0 at this position.

    PTRDIFF  dpCharSets;            // only used if > 1 charset supported
    BYTE     jWinCharSet;           // as in LOGFONT::lfCharSet
    BYTE     jWinPitchAndFamily;    // as in LOGFONT::lfPitchAndFamily
    USHORT   usWinWeight;           // as in LOGFONT::lfWeight
    ULONG    flInfo;                // see above
    USHORT   fsSelection;           // see above
    USHORT   fsType;                // see above
    FWORD    fwdUnitsPerEm;         // em height
    FWORD    fwdLowestPPEm;         // readable limit
    FWORD    fwdWinAscender;
    FWORD    fwdWinDescender;
    FWORD    fwdMacAscender;
    FWORD    fwdMacDescender;
    FWORD    fwdMacLineGap;
    FWORD    fwdTypoAscender;
    FWORD    fwdTypoDescender;
    FWORD    fwdTypoLineGap;
    FWORD    fwdAveCharWidth;
    FWORD    fwdMaxCharInc;
    FWORD    fwdCapHeight;
    FWORD    fwdXHeight;
    FWORD    fwdSubscriptXSize;
    FWORD    fwdSubscriptYSize;
    FWORD    fwdSubscriptXOffset;
    FWORD    fwdSubscriptYOffset;
    FWORD    fwdSuperscriptXSize;
    FWORD    fwdSuperscriptYSize;
    FWORD    fwdSuperscriptXOffset;
    FWORD    fwdSuperscriptYOffset;
    FWORD    fwdUnderscoreSize;
    FWORD    fwdUnderscorePosition;
    FWORD    fwdStrikeoutSize;
    FWORD    fwdStrikeoutPosition;
    BYTE     chFirstChar;           // for win 3.1 compatibility
    BYTE     chLastChar;            // for win 3.1 compatibility
    BYTE     chDefaultChar;         // for win 3.1 compatibility
    BYTE     chBreakChar;           // for win 3.1 compatibility
    WCHAR    wcFirstChar;           // lowest supported code in Unicode set
    WCHAR    wcLastChar;            // highest supported code in Unicode set
    WCHAR    wcDefaultChar;
    WCHAR    wcBreakChar;
    POINTL   ptlBaseline;           //
    POINTL   ptlAspect;             // designed aspect ratio (bitmaps)
    POINTL   ptlCaret;              // points along caret
    RECTL    rclFontBox;            // bounding box for all glyphs (font space)
    BYTE     achVendId[4];          // as per TrueType
    ULONG    cKerningPairs;
    ULONG    ulPanoseCulture;
    PANOSE   panose;

#if defined(_WIN64)

    //
    // IFIMETRICS must begin on a 64-bit boundary
    //

    PVOID    Align;

#endif

} IFIMETRICS, *PIFIMETRICS;


// rather than adding the fields of IFIEXTRA  to IFIMETRICS itself
// we add them as a separate structure. This structure, if present at all,
// lies below IFIMETRICS in memory.
// If IFIEXTRA is present at all, ifi.cjIfiExtra (formerly ulVersion)
// will contain size of IFIEXTRA including any reserved fields.
// That way ulVersion = 0 (NT 3.51 or less) printer minidrivers
// will work with NT 4.0.

typedef struct _IFIEXTRA
{
    ULONG    ulIdentifier;   // used for Type 1 fonts only
    PTRDIFF  dpFontSig;      // nontrivial for tt only, at least for now.
    ULONG    cig;            // maxp->numGlyphs, # of distinct glyph indicies
    PTRDIFF  dpDesignVector; // offset to design vector for mm instances
    PTRDIFF  dpAxesInfoW;    // offset to full axes info for base mm font
    ULONG    aulReserved[1]; // in case we need even more stuff in the future
} IFIEXTRA, *PIFIEXTRA;

#define SIZEOFDV(cAxes) (offsetof(DESIGNVECTOR,dvValues) + (cAxes)*sizeof(LONG))
#define SIZEOFAXIW(cAxes) (offsetof(AXESLISTW,axlAxisInfo) + (cAxes)*sizeof(AXISINFOW))
#define SIZEOFAXIA(cAxes) (offsetof(AXESLISTA,axlAxisInfo) + (cAxes)*sizeof(AXISINFOA))

/**************************************************************************\
 *
\**************************************************************************/

/* OpenGL DDI ExtEscape escape numbers (4352 - 4607) */

#define OPENGL_CMD      4352        /* for OpenGL ExtEscape */
#define OPENGL_GETINFO  4353        /* for OpenGL ExtEscape */
#define WNDOBJ_SETUP    4354        /* for live video ExtEscape */

#define DDI_DRIVER_VERSION     0x00020000
#define DDI_DRIVER_VERSION_NT4 0x00020000
#define DDI_DRIVER_VERSION_SP3 0x00020003
#define DDI_DRIVER_VERSION_NT5 0x00030000

#define GDI_DRIVER_VERSION 0x4000   /* for NT version 4.0.00 */

typedef LONG_PTR (APIENTRY *PFN)();

typedef struct  _DRVFN  /* drvfn */
{
    ULONG   iFunc;
    PFN     pfn;
} DRVFN, *PDRVFN;

/* Required functions           */

#define INDEX_DrvEnablePDEV                      0L
#define INDEX_DrvCompletePDEV                    1L
#define INDEX_DrvDisablePDEV                     2L
#define INDEX_DrvEnableSurface                   3L
#define INDEX_DrvDisableSurface                  4L

/* Other functions              */

#define INDEX_DrvAssertMode                      5L
#define INDEX_DrvOffset                          6L     // Obsolete
#define INDEX_DrvResetPDEV                       7L
#define INDEX_DrvDisableDriver                   8L
#define INDEX_DrvCreateDeviceBitmap             10L
#define INDEX_DrvDeleteDeviceBitmap             11L
#define INDEX_DrvRealizeBrush                   12L
#define INDEX_DrvDitherColor                    13L
#define INDEX_DrvStrokePath                     14L
#define INDEX_DrvFillPath                       15L
#define INDEX_DrvStrokeAndFillPath              16L
#define INDEX_DrvPaint                          17L
#define INDEX_DrvBitBlt                         18L
#define INDEX_DrvCopyBits                       19L
#define INDEX_DrvStretchBlt                     20L
#define INDEX_DrvSetPalette                     22L
#define INDEX_DrvTextOut                        23L
#define INDEX_DrvEscape                         24L
#define INDEX_DrvDrawEscape                     25L
#define INDEX_DrvQueryFont                      26L
#define INDEX_DrvQueryFontTree                  27L
#define INDEX_DrvQueryFontData                  28L
#define INDEX_DrvSetPointerShape                29L
#define INDEX_DrvMovePointer                    30L
#define INDEX_DrvLineTo                         31L
#define INDEX_DrvSendPage                       32L
#define INDEX_DrvStartPage                      33L
#define INDEX_DrvEndDoc                         34L
#define INDEX_DrvStartDoc                       35L
#define INDEX_DrvGetGlyphMode                   37L
#define INDEX_DrvSynchronize                    38L
#define INDEX_DrvSaveScreenBits                 40L
#define INDEX_DrvGetModes                       41L
#define INDEX_DrvFree                           42L
#define INDEX_DrvDestroyFont                    43L
#define INDEX_DrvQueryFontCaps                  44L
#define INDEX_DrvLoadFontFile                   45L
#define INDEX_DrvUnloadFontFile                 46L
#define INDEX_DrvFontManagement                 47L
#define INDEX_DrvQueryTrueTypeTable             48L
#define INDEX_DrvQueryTrueTypeOutline           49L
#define INDEX_DrvGetTrueTypeFile                50L
#define INDEX_DrvQueryFontFile                  51L
#define INDEX_DrvMovePanning                    52L
#define INDEX_DrvQueryAdvanceWidths             53L
#define INDEX_DrvSetPixelFormat                 54L
#define INDEX_DrvDescribePixelFormat            55L
#define INDEX_DrvSwapBuffers                    56L
#define INDEX_DrvStartBanding                   57L
#define INDEX_DrvNextBand                       58L
#define INDEX_DrvGetDirectDrawInfo              59L
#define INDEX_DrvEnableDirectDraw               60L
#define INDEX_DrvDisableDirectDraw              61L
#define INDEX_DrvQuerySpoolType                 62L
#define INDEX_DrvIcmCreateColorTransform        64L
#define INDEX_DrvIcmDeleteColorTransform        65L
#define INDEX_DrvIcmCheckBitmapBits             66L
#define INDEX_DrvIcmSetDeviceGammaRamp          67L
#define INDEX_DrvGradientFill                   68L
#define INDEX_DrvStretchBltROP                  69L
#define INDEX_DrvPlgBlt                         70L
#define INDEX_DrvAlphaBlend                     71L
#define INDEX_DrvSynthesizeFont                 72L
#define INDEX_DrvGetSynthesizedFontFiles        73L
#define INDEX_DrvTransparentBlt                 74L
#define INDEX_DrvQueryPerBandInfo               75L
#define INDEX_DrvQueryDeviceSupport             76L

#define INDEX_DrvReserved1                      77L
#define INDEX_DrvReserved2                      78L
#define INDEX_DrvReserved3                      79L
#define INDEX_DrvReserved4                      80L
#define INDEX_DrvReserved5                      81L
#define INDEX_DrvReserved6                      82L
#define INDEX_DrvReserved7                      83L
#define INDEX_DrvReserved8                      84L

#define INDEX_DrvDeriveSurface                  85L
#define INDEX_DrvQueryGlyphAttrs                86L
#define INDEX_DrvNotify                         87L
#define INDEX_DrvSynchronizeSurface             88L

/* The total number of dispatched functions */

#define INDEX_LAST                              89L

typedef struct  tagDRVENABLEDATA
{
    ULONG   iDriverVersion;
    ULONG   c;
    DRVFN  *pdrvfn;
} DRVENABLEDATA, *PDRVENABLEDATA;

typedef struct  tagDEVINFO
{
    FLONG       flGraphicsCaps;
    LOGFONTW    lfDefaultFont;
    LOGFONTW    lfAnsiVarFont;
    LOGFONTW    lfAnsiFixFont;
    ULONG       cFonts;
    ULONG       iDitherFormat;
    USHORT      cxDither;
    USHORT      cyDither;
    HPALETTE    hpalDefault;
    FLONG       flGraphicsCaps2;
} DEVINFO, *PDEVINFO;

// flGraphicsCaps flags for DEVINFO:

#define GCAPS_BEZIERS           0x00000001
#define GCAPS_GEOMETRICWIDE     0x00000002
#define GCAPS_ALTERNATEFILL     0x00000004
#define GCAPS_WINDINGFILL       0x00000008
#define GCAPS_HALFTONE          0x00000010
#define GCAPS_COLOR_DITHER      0x00000020
#define GCAPS_HORIZSTRIKE       0x00000040      // Obsolete
#define GCAPS_VERTSTRIKE        0x00000080      // Obsolete
#define GCAPS_OPAQUERECT        0x00000100
#define GCAPS_VECTORFONT        0x00000200
#define GCAPS_MONO_DITHER       0x00000400
#define GCAPS_ASYNCCHANGE       0x00000800      // Obsolete
#define GCAPS_ASYNCMOVE         0x00001000
#define GCAPS_DONTJOURNAL       0x00002000
#define GCAPS_DIRECTDRAW        0x00004000      // Obsolete
#define GCAPS_ARBRUSHOPAQUE     0x00008000
#define GCAPS_PANNING           0x00010000
#define GCAPS_HIGHRESTEXT       0x00040000
#define GCAPS_PALMANAGED        0x00080000
#define GCAPS_DITHERONREALIZE   0x00200000
#define GCAPS_NO64BITMEMACCESS  0x00400000      // Obsolete
#define GCAPS_FORCEDITHER       0x00800000
#define GCAPS_GRAY16            0x01000000
#define GCAPS_ICM               0x02000000
#define GCAPS_CMYKCOLOR         0x04000000
#define GCAPS_LAYERED           0x08000000
#define GCAPS_ARBRUSHTEXT       0x10000000
#define GCAPS_SCREENPRECISION   0x20000000
#define GCAPS_FONT_RASTERIZER   0x40000000      // the device has built in tt rasterizer
#define GCAPS_NUP               0x80000000

// flGraphicsCaps2 flags for DEVINFO:

#define GCAPS2_JPEGSRC          0x00000001
#define GCAPS2_xxxx             0x00000002
#define GCAPS2_PNGSRC           0x00000008
#define GCAPS2_CHANGEGAMMARAMP  0x00000010
#define GCAPS2_ALPHACURSOR      0x00000020
#define GCAPS2_SYNCFLUSH        0x00000040
#define GCAPS2_SYNCTIMER        0x00000080
#define GCAPS2_ICD_MULTIMON     0x00000100

typedef struct  _LINEATTRS
{
    FLONG       fl;
    ULONG       iJoin;
    ULONG       iEndCap;
    FLOAT_LONG  elWidth;
    FLOATL      eMiterLimit;
    ULONG       cstyle;
    PFLOAT_LONG pstyle;
    FLOAT_LONG  elStyleState;
} LINEATTRS, *PLINEATTRS;

#define LA_GEOMETRIC        0x00000001
#define LA_ALTERNATE        0x00000002
#define LA_STARTGAP         0x00000004
#define LA_STYLED           0x00000008

#define JOIN_ROUND          0L
#define JOIN_BEVEL          1L
#define JOIN_MITER          2L

#define ENDCAP_ROUND        0L
#define ENDCAP_SQUARE       1L
#define ENDCAP_BUTT         2L

typedef LONG  LDECI4;

typedef struct _XFORML {
    FLOATL  eM11;
    FLOATL  eM12;
    FLOATL  eM21;
    FLOATL  eM22;
    FLOATL  eDx;
    FLOATL  eDy;
} XFORML, *PXFORML;

typedef struct _CIECHROMA
{
    LDECI4   x;
    LDECI4   y;
    LDECI4   Y;
}CIECHROMA;

typedef struct _COLORINFO
{
    CIECHROMA  Red;
    CIECHROMA  Green;
    CIECHROMA  Blue;
    CIECHROMA  Cyan;
    CIECHROMA  Magenta;
    CIECHROMA  Yellow;
    CIECHROMA  AlignmentWhite;

    LDECI4  RedGamma;
    LDECI4  GreenGamma;
    LDECI4  BlueGamma;

    LDECI4  MagentaInCyanDye;
    LDECI4  YellowInCyanDye;
    LDECI4  CyanInMagentaDye;
    LDECI4  YellowInMagentaDye;
    LDECI4  CyanInYellowDye;
    LDECI4  MagentaInYellowDye;
}COLORINFO, *PCOLORINFO;

// Allowed values for GDIINFO.ulPrimaryOrder.

#define PRIMARY_ORDER_ABC       0
#define PRIMARY_ORDER_ACB       1
#define PRIMARY_ORDER_BAC       2
#define PRIMARY_ORDER_BCA       3
#define PRIMARY_ORDER_CBA       4
#define PRIMARY_ORDER_CAB       5

// Allowed values for GDIINFO.ulHTPatternSize.

#define HT_PATSIZE_2x2          0
#define HT_PATSIZE_2x2_M        1
#define HT_PATSIZE_4x4          2
#define HT_PATSIZE_4x4_M        3
#define HT_PATSIZE_6x6          4
#define HT_PATSIZE_6x6_M        5
#define HT_PATSIZE_8x8          6
#define HT_PATSIZE_8x8_M        7
#define HT_PATSIZE_10x10        8
#define HT_PATSIZE_10x10_M      9
#define HT_PATSIZE_12x12        10
#define HT_PATSIZE_12x12_M      11
#define HT_PATSIZE_14x14        12
#define HT_PATSIZE_14x14_M      13
#define HT_PATSIZE_16x16        14
#define HT_PATSIZE_16x16_M      15
#define HT_PATSIZE_SUPERCELL    16
#define HT_PATSIZE_SUPERCELL_M  17
#define HT_PATSIZE_USER         18
#define HT_PATSIZE_MAX_INDEX    HT_PATSIZE_USER
#define HT_PATSIZE_DEFAULT      HT_PATSIZE_SUPERCELL_M

#define HT_USERPAT_CX_MIN       4
#define HT_USERPAT_CX_MAX       256
#define HT_USERPAT_CY_MIN       4
#define HT_USERPAT_CY_MAX       256


// Allowed values for GDIINFO.ulHTOutputFormat.

#define HT_FORMAT_1BPP          0
#define HT_FORMAT_4BPP          2
#define HT_FORMAT_4BPP_IRGB     3
#define HT_FORMAT_8BPP          4
#define HT_FORMAT_16BPP         5
#define HT_FORMAT_24BPP         6
#define HT_FORMAT_32BPP         7


// Allowed values for GDIINFO.flHTFlags.

#define HT_FLAG_SQUARE_DEVICE_PEL       0x00000001
#define HT_FLAG_HAS_BLACK_DYE           0x00000002
#define HT_FLAG_ADDITIVE_PRIMS          0x00000004
#define HT_FLAG_USE_8BPP_BITMASK        0x00000008
#define HT_FLAG_INK_HIGH_ABSORPTION     0x00000010
#define HT_FLAG_INK_ABSORPTION_INDICES  0x00000060
#define HT_FLAG_DO_DEVCLR_XFORM         0x00000080
#define HT_FLAG_OUTPUT_CMY              0x00000100
#define HT_FLAG_PRINT_DRAFT_MODE        0x00000200
#define HT_FLAG_8BPP_CMY332_MASK        0xFF000000

#define MAKE_CMYMASK_BYTE(c,m,y)    ((BYTE)(((BYTE)(c) & 0x07) << 5) |      \
                                     (BYTE)(((BYTE)(m) & 0x07) << 2) |      \
                                     (BYTE)((BYTE)(y) & 0x03))

#define MAKE_CMY332_MASK(c,m,y)     ((DWORD)(((DWORD)(c) & 0x07) << 29) |   \
                                     (DWORD)(((DWORD)(m) & 0x07) << 26) |   \
                                     (DWORD)(((DWORD)(y) & 0x03) << 24))


#define HT_FLAG_INK_ABSORPTION_IDX0     0x00000000
#define HT_FLAG_INK_ABSORPTION_IDX1     0x00000020
#define HT_FLAG_INK_ABSORPTION_IDX2     0x00000040
#define HT_FLAG_INK_ABSORPTION_IDX3     0x00000060

#define HT_FLAG_HIGHEST_INK_ABSORPTION  (HT_FLAG_INK_HIGH_ABSORPTION    |   \
                                         HT_FLAG_INK_ABSORPTION_IDX3)
#define HT_FLAG_HIGHER_INK_ABSORPTION   (HT_FLAG_INK_HIGH_ABSORPTION    |   \
                                         HT_FLAG_INK_ABSORPTION_IDX2)
#define HT_FLAG_HIGH_INK_ABSORPTION     (HT_FLAG_INK_HIGH_ABSORPTION    |   \
                                         HT_FLAG_INK_ABSORPTION_IDX1)
#define HT_FLAG_NORMAL_INK_ABSORPTION   HT_FLAG_INK_ABSORPTION_IDX0
#define HT_FLAG_LOW_INK_ABSORPTION      (HT_FLAG_INK_ABSORPTION_IDX1)
#define HT_FLAG_LOWER_INK_ABSORPTION    (HT_FLAG_INK_ABSORPTION_IDX2)
#define HT_FLAG_LOWEST_INK_ABSORPTION   (HT_FLAG_INK_ABSORPTION_IDX3)

// Allowed values for GDIINFO.ulPhysicalPixelCharacteristics

#define PPC_DEFAULT                        0x0
#define PPC_UNDEFINED                      0x1
#define PPC_RGB_ORDER_VERTICAL_STRIPES     0x2
#define PPC_BGR_ORDER_VERTICAL_STRIPES     0x3
#define PPC_RGB_ORDER_HORIZONTAL_STRIPES   0x4
#define PPC_BGR_ORDER_HORIZONTAL_STRIPES   0x5

// GDIINFO.ulPhysicalPixelGamma should be set either to the scaled
// gamma (x1000) of the physical pixel or one of the following
// values.  For example, a 2.2 gamma would be represented as 2200

#define PPG_DEFAULT                        0
#define PPG_SRGB                           1

//
// HT_FLAG_DO_DEVCLR_XFORM flag specified devices and/or drivers are required
// gdi halftone to do a device transform when ICM is off, the device transform
// take a input RGB value and map it to the device color space to produced
// perceived density same as input RGB color values.  This flag only valid if
// it is a printer device surface and its format is 16bpp or 24bpp.
//
// ** If devices are additive and/or device surface is 1bpp, 4bpp or 8bpp, then
//    gdi halftone will always performed device transform regardless the
//    setting of HT_FLAG_DO_DEVCLR_XFORM flag.
//
// HT_FLAG_8BPP_CMY332_MASK - define the bit mask for 8-bpp format halftone
// palette, this palette only used if a HT_FORMAT_8BPP is specified in
// flHTOutputFormat and HT_FLAG_USE_8BPP_BITMASK bit is set in the flHTFlags.
// if HT_FLAG_USE_8BPP_BITMAP is not set then a standard NT4.0 8-bpp format is
// assumed.  The format of 8BPP is set per PDEV, it cannot be changed after
// the pDEV is created.
//
// To set HT_FLAG_8BPP_CMY332_MASK, macro MAKE_CMY332_MASK() can be used.  When
// specified, the bit mask cover total of 8 bits area which describe the
// highest of level of CYAN, MAGENTA and YELLOW primary color, the maximum of
// Cyan is 3 bits (7 levels), Magenta is 3 bits (7 levels) and Yellow is 2 bit
// (3 levels).
//
//  0xE0000000  -- Cyan Bits (3 bits, 0 to 7 levels)
//  0x1C000000  -- Magenta Bits (3 bits, 0 to 7 levels)
//  0x03000000  -- Yellow Bits (2 bits, 0 to 3 levels)
//
//  a 0x6F000000 specified Cyan=3 levels, Magenta=3 levels, Yellow=3 levels
//  a 0xFF000000 specified Cyan=7 levels, Magenta=7 levels, Yellow=3 levels
//  a 0x25000000 specified Cyan=1 level,  Magenta=1 level,  Yellow=1 level,
//  is same as using CMY 4bpp
//
//  if any of Cyan, Magenta, Yellow level bits is 0 (zero) then it specified
//  8bpp output format is 256 level gray scale with index 0 equal to WHITE and
//  index 255 equal to BLACK,
//
//  The Palette indics are arranged as CMY entries with CYAN at highest bit
//  numbers and YELLOW at lowest bit number as shown below for palette indics
//  bit's (8 bit) definition.
//
//  Pallete Index BIT#:     7   6   5   4   3   2   1   0
//                          |       |   |       |   |   |
//                          +---C---+   +---M---+   +-Y-+
//                            0xe0         0x1c      0x03
//
//  If a primray color level in an index is greater than the prmary color
//  levels then it is eqaul to the maximum primary color level, for example
//  if C=7 (0xe0), and Cyan level only 5 then level 6 and 7 are same as 5
//
//  To retrieve the palette definition for 8bpp format, use
//
//  LONG APIENTRY
//  HT_Get8BPPMaskPalette(PPALETTEENTRY pPaletteEntry,
//                        BOOL          Use8BPPMaskPal,
//                        BYTE          CMYMask,
//                        USHORT        RedGamma,
//                        USHORT        GreenGamma,
//                        USHORT        BlueGamma);
//
//  pPaletteEntry   - Pointer to the PALETTEENTRY, if NULL it return palette
//                    count needed
//
//  Use8BPPmaskPal  - FALSE if a NT4.0 standard 8bpp palette requested, FALSE
//                    if a CMYMask 8bpp mask palette is needed.
//
//  CMYMask         - CMY bit mask for CMY as defined above.  This must be the
//                    same primary level as defined in GDIInfo.flHTFlags.
//                    It should be same as ((GDIInfo.flHTFlags >> 24) & 0xFF).
//                    The CMYMask also can be specified using predefined macro
//                    MAKS_CMYMASK_BYTE(cLevel, mLevel, yLevel)
//
//  RedGamma        - Red gamma if Use8BPPMaskPal is FALSE, Cyan gamma
//                    if Use8BPPMaskPal is TRUE
//
//  GreenGamma      - Green gamma if Use8BPPMaskPal is FALSE, Magenta gamma
//                    if Use8BPPMaskPal is TRUE
//
//  BlueGamma       - Blue gamma if Use8BPPMaskPal is FALSE, Yellow gamma
//                    if Use8BPPMaskPal is TRUE
//


typedef struct _GDIINFO
{
    ULONG ulVersion;
    ULONG ulTechnology;
    ULONG ulHorzSize;
    ULONG ulVertSize;
    ULONG ulHorzRes;
    ULONG ulVertRes;
    ULONG cBitsPixel;
    ULONG cPlanes;
    ULONG ulNumColors;
    ULONG flRaster;
    ULONG ulLogPixelsX;
    ULONG ulLogPixelsY;
    ULONG flTextCaps;

    ULONG ulDACRed;
    ULONG ulDACGreen;
    ULONG ulDACBlue;

    ULONG ulAspectX;
    ULONG ulAspectY;
    ULONG ulAspectXY;

    LONG  xStyleStep;
    LONG  yStyleStep;
    LONG  denStyleStep;

    POINTL ptlPhysOffset;
    SIZEL  szlPhysSize;

    ULONG ulNumPalReg;

// These fields are for halftone initialization.

    COLORINFO ciDevice;
    ULONG     ulDevicePelsDPI;
    ULONG     ulPrimaryOrder;
    ULONG     ulHTPatternSize;
    ULONG     ulHTOutputFormat;
    ULONG     flHTFlags;

    ULONG ulVRefresh;
    ULONG ulBltAlignment;

    ULONG ulPanningHorzRes;
    ULONG ulPanningVertRes;
    ULONG xPanningAlignment;
    ULONG yPanningAlignment;

// The following fields are for user defined halftone dither patterns.  These
// fields are only checked if ulHTPatternSize is eqaul to HT_PATSIZE_USER.
//
// The user defined pHTPatA, pHTPatB, pHTPatC pointers correspond to the primary
// color order defined in ulPrimaryOrder as PRIMARY_ORDER_xxx.
//
// The size of halftone dither pattern must range from 4 to 256.  For each
// dither pattern, pHTPatA, pHTPatB, pHTPatC must point to a
// valid byte array of (cxHTPat x cyHTPat) size.  pHTPatA, pHTPatB and
// pHTPatC may point to the same dither pattern array.
//
// Each byte threshold within the dither pattern defines the additive
// intensity threshold of pixels.  A zero threshold value indicates the pixel
// location is ignored (always black), while 1 to 255 threshold values give the
// dither pattern 255 level of grays.

    ULONG   cxHTPat;    // cxHTPat must range from 4-256
    ULONG   cyHTPat;    // cyHTPat must range from 4-256
    LPBYTE  pHTPatA;    // for Primary Color Order A
    LPBYTE  pHTPatB;    // for Primary Color Order B
    LPBYTE  pHTPatC;    // for Primary Color Order C

// Shade and blend caps

    ULONG   flShadeBlend;

    ULONG   ulPhysicalPixelCharacteristics;
    ULONG   ulPhysicalPixelGamma;

} GDIINFO, *PGDIINFO;

/*
 * User objects
 */

typedef struct _BRUSHOBJ
{
    ULONG  iSolidColor;
    PVOID  pvRbrush;
    FLONG  flColorType;
} BRUSHOBJ;

//
// BRUSHOBJ::flColorType
//
#define BR_DEVICE_ICM    0x01
#define BR_HOST_ICM      0x02
#define BR_CMYKCOLOR     0x04

typedef struct _CLIPOBJ
{
    ULONG   iUniq;
    RECTL   rclBounds;
    BYTE    iDComplexity;
    BYTE    iFComplexity;
    BYTE    iMode;
    BYTE    fjOptions;
} CLIPOBJ;

typedef struct _DRIVEROBJ DRIVEROBJ;

typedef BOOL (CALLBACK * FREEOBJPROC)(DRIVEROBJ *pDriverObj);

typedef struct _DRIVEROBJ
{
    PVOID       pvObj;
    FREEOBJPROC pFreeProc;
    HDEV        hdev;
    DHPDEV      dhpdev;
} DRIVEROBJ;

typedef struct _FONTOBJ
{
    ULONG      iUniq;
    ULONG      iFace;
    ULONG      cxMax;
    FLONG      flFontType;
    ULONG_PTR   iTTUniq;
    ULONG_PTR   iFile;
    SIZE       sizLogResPpi;
    ULONG      ulStyleSize;
    PVOID      pvConsumer;
    PVOID      pvProducer;
} FONTOBJ;

typedef struct _BLENDOBJ
{
    BLENDFUNCTION BlendFunction;
}BLENDOBJ,*PBLENDOBJ;

typedef BYTE GAMMA_TABLES[2][256];

//
// FONTOBJ::flFontType
//
#define FO_TYPE_RASTER   RASTER_FONTTYPE     /* 0x1 */
#define FO_TYPE_DEVICE   DEVICE_FONTTYPE     /* 0x2 */
#define FO_TYPE_TRUETYPE TRUETYPE_FONTTYPE   /* 0x4 */
#define FO_TYPE_OPENTYPE OPENTYPE_FONTTYPE   /* 0X8 */

#define FO_SIM_BOLD      0x00002000
#define FO_SIM_ITALIC    0x00004000
#define FO_EM_HEIGHT     0x00008000
#define FO_GRAY16        0x00010000          /* [1] */
#define FO_NOGRAY16      0x00020000          /* [1] */
#define FO_NOHINTS       0x00040000          /* [3] */
#define FO_NO_CHOICE     0x00080000          /* [3] */

// new accelerators so that printer drivers  do not need to look to ifimetrics

#define FO_CFF            0x00100000
#define FO_POSTSCRIPT     0x00200000
#define FO_MULTIPLEMASTER 0x00400000
#define FO_VERT_FACE      0x00800000
#define FO_DBCS_FONT      0X01000000

/**************************************************************************\
*
*   [1]
*
*   If the FO_GRAY16 flag is set then the bitmaps of the font
*   are 4-bit per pixel blending (alpha) values. A value of zero
*   means that the the resulting pixel should be equal to the
*   background color. If the value of the alpha value is k != 0
*   then the resulting pixel must be:
*
*       c0 = background color
*       c1 = foreground color
*       b  = blending value = (k+1)/16  // {k = 1,2,..,15}
*       b  = 0 (k = 0)
*       d0 = gamma[c0], d1 = gamma[c1]  // luminance components
*       d = (1 - b)*d0 + b*d1           // blended luminance
*       c = lambda[d]                   // blended device voltage
*
*   where gamma[] takes a color component from application space
*   to CIE space and labmda[] takes a color from CIE space to
*   device color space
*
*   GDI will set this bit if it request a font be gray scaled
*   to 16 values then GDI will set FO_GRAY16 upon entry to
*   DrvQueryFontData().  If the font driver cannot (or will
*   not) grayscale a particular realization of a font then the
*   font provider will zero out FO_GRAY16  and set FO_NOGRAY16
*   to inform GDI that
*   the gray scaling request cannot (or should not) be
*   satisfied.
*
*   [2]
*
*   The FO_NOHINTS indicates that hints were not used in the formation
*   of the glyph images. GDI will set this bit to request that hinting
*   be supressed. The font provider will set this bit accroding to the
*   rendering scheme that it used in generating the glyph image.
*
*   [3]
*
*   The FO_NO_CHOICE flag indicates that the flags FO_GRAY16 and
*   FO_NOHINTS must be obeyed if at all possible.
*
\**************************************************************************/

typedef struct _PALOBJ
{
    ULONG   ulReserved;
} PALOBJ;

typedef struct _PATHOBJ
{
    FLONG   fl;
    ULONG   cCurves;
} PATHOBJ;

typedef struct _SURFOBJ
{
    DHSURF  dhsurf;
    HSURF   hsurf;
    DHPDEV  dhpdev;
    HDEV    hdev;
    SIZEL   sizlBitmap;
    ULONG   cjBits;
    PVOID   pvBits;
    PVOID   pvScan0;
    LONG    lDelta;
    ULONG   iUniq;
    ULONG   iBitmapFormat;
    USHORT  iType;
    USHORT  fjBitmap;
} SURFOBJ;

typedef struct _WNDOBJ
{
    CLIPOBJ  coClient;
    PVOID    pvConsumer;
    RECTL    rclClient;
    SURFOBJ *psoOwner;
} WNDOBJ, *PWNDOBJ;

typedef struct _XFORMOBJ
{
    ULONG ulReserved;
} XFORMOBJ;

typedef struct _XLATEOBJ
{
    ULONG   iUniq;
    FLONG   flXlate;
    USHORT  iSrcType;               // Obsolete
    USHORT  iDstType;               // Obsolete
    ULONG   cEntries;
    ULONG  *pulXlate;
} XLATEOBJ;

/*
 * BRUSHOBJ callbacks
 */

PVOID APIENTRY BRUSHOBJ_pvAllocRbrush(
    BRUSHOBJ *pbo,
    ULONG     cj
    );

PVOID APIENTRY BRUSHOBJ_pvGetRbrush(
    BRUSHOBJ *pbo
    );

ULONG APIENTRY BRUSHOBJ_ulGetBrushColor(
    BRUSHOBJ *pbo
    );

HANDLE APIENTRY BRUSHOBJ_hGetColorTransform(
    BRUSHOBJ *pbo
    );

/*
 * CLIPOBJ callbacks
 */

#define DC_TRIVIAL      0
#define DC_RECT         1
#define DC_COMPLEX      3

#define FC_RECT         1
#define FC_RECT4        2
#define FC_COMPLEX      3

#define TC_RECTANGLES   0
#define TC_PATHOBJ      2

#define OC_BANK_CLIP    1       // Obsolete

#define CT_RECTANGLES   0L

#define CD_RIGHTDOWN    0L
#define CD_LEFTDOWN     1L
#define CD_RIGHTUP      2L
#define CD_LEFTUP       3L
#define CD_ANY          4L

#define CD_LEFTWARDS    1L
#define CD_UPWARDS      2L

typedef struct _ENUMRECTS
{
    ULONG       c;
    RECTL       arcl[1];
} ENUMRECTS;

ULONG APIENTRY CLIPOBJ_cEnumStart(
    CLIPOBJ *pco,
    BOOL     bAll,
    ULONG    iType,
    ULONG    iDirection,
    ULONG    cLimit
    );

BOOL APIENTRY CLIPOBJ_bEnum(
    CLIPOBJ *pco,
    ULONG    cj,
    ULONG   *pul
    );

PATHOBJ* APIENTRY CLIPOBJ_ppoGetPath(
    CLIPOBJ* pco
    );

/*
 *   FONTOBJ callbacks
 */

typedef struct _GLYPHBITS
{
    POINTL      ptlOrigin;
    SIZEL       sizlBitmap;
    BYTE        aj[1];
} GLYPHBITS;

#define FO_HGLYPHS          0L
#define FO_GLYPHBITS        1L
#define FO_PATHOBJ          2L

#define FD_NEGATIVE_FONT    1L

#define FO_DEVICE_FONT      1L
#define FO_OUTLINE_CAPABLE  2L

typedef union _GLYPHDEF
{
    GLYPHBITS  *pgb;
    PATHOBJ    *ppo;
} GLYPHDEF;

typedef struct _GLYPHPOS    /* gp */
{
    HGLYPH      hg;
    GLYPHDEF   *pgdf;
    POINTL      ptl;
} GLYPHPOS,*PGLYPHPOS;


// individual glyph data

// r is a unit vector along the baseline in device coordinates.
// s is a unit vector in the ascent direction in device coordinates.
// A, B, and C, are simple tranforms of the notional space versions into
// (28.4) device coordinates.  The dot products of those vectors with r
// are recorded here.  Note that the high words of ptqD are also 28.4
// device coordinates.  The low words provide extra accuracy.

// THE STRUCTURE DIFFERS IN ORDERING FROM NT 3.51 VERSION OF THE STRUCTURE.
// ptqD has been moved to the bottom.
// This requires only recompile of all the drivers.

typedef struct _GLYPHDATA {
        GLYPHDEF gdf;               // pointer to GLYPHBITS or to PATHOBJ
        HGLYPH   hg;                // glyhp handle
        FIX      fxD;               // Character increment amount: D*r.
        FIX      fxA;               // Prebearing amount: A*r.
        FIX      fxAB;              // Advancing edge of character: (A+B)*r.
        FIX      fxInkTop;          // Baseline to inkbox top along s.
        FIX      fxInkBottom;       // Baseline to inkbox bottom along s.
        RECTL    rclInk;            // Ink box with sides parallel to x,y axes
        POINTQF  ptqD;              // Character increment vector: D=A+B+C.
} GLYPHDATA;


// flAccel flags for STROBJ

// SO_FLAG_DEFAULT_PLACEMENT // defult inc vectors used to position chars
// SO_HORIZONTAL             // "left to right" or "right to left"
// SO_VERTICAL               // "top to bottom" or "bottom to top"
// SO_REVERSED               // set if horiz & "right to left" or if vert &  "bottom to top"
// SO_ZERO_BEARINGS          // all glyphs have zero a and c spaces
// SO_CHAR_INC_EQUAL_BM_BASE // base == cx for horiz, == cy for vert.
// SO_MAXEXT_EQUAL_BM_SIDE   // side == cy for horiz, == cx for vert.

// do not substitute device font for tt font even if device font sub table
// tells the driver this should be done

// SO_DO_NOT_SUBSTITUTE_DEVICE_FONT

#define SO_FLAG_DEFAULT_PLACEMENT        0x00000001
#define SO_HORIZONTAL                    0x00000002
#define SO_VERTICAL                      0x00000004
#define SO_REVERSED                      0x00000008
#define SO_ZERO_BEARINGS                 0x00000010
#define SO_CHAR_INC_EQUAL_BM_BASE        0x00000020
#define SO_MAXEXT_EQUAL_BM_SIDE          0x00000040
#define SO_DO_NOT_SUBSTITUTE_DEVICE_FONT 0x00000080
#define SO_GLYPHINDEX_TEXTOUT            0x00000100
#define SO_ESC_NOT_ORIENT                0x00000200
#define SO_DXDY                          0x00000400
#define SO_CHARACTER_EXTRA               0x00000800
#define SO_BREAK_EXTRA                   0x00001000

typedef struct _STROBJ
{
    ULONG     cGlyphs;     // # of glyphs to render
    FLONG     flAccel;     // accel flags
    ULONG     ulCharInc;   // non-zero only if fixed pitch font, equal to advanced width.
    RECTL     rclBkGround; // bk ground  rect of the string in device coords
    GLYPHPOS *pgp;         // If non-NULL then has all glyphs.
    LPWSTR    pwszOrg;     // pointer to original unicode string.
} STROBJ;

typedef struct _FONTINFO /* fi */
{
    ULONG   cjThis;
    FLONG   flCaps;
    ULONG   cGlyphsSupported;
    ULONG   cjMaxGlyph1;
    ULONG   cjMaxGlyph4;
    ULONG   cjMaxGlyph8;
    ULONG   cjMaxGlyph32;
} FONTINFO, *PFONTINFO;

ULONG APIENTRY FONTOBJ_cGetAllGlyphHandles(
    FONTOBJ *pfo,
    HGLYPH  *phg
    );

VOID APIENTRY FONTOBJ_vGetInfo(
    FONTOBJ  *pfo,
    ULONG     cjSize,
    FONTINFO *pfi
    );

ULONG APIENTRY FONTOBJ_cGetGlyphs(
    FONTOBJ *pfo,
    ULONG    iMode,
    ULONG    cGlyph,
    HGLYPH  *phg,
    PVOID   *ppvGlyph
    );

GAMMA_TABLES* APIENTRY FONTOBJ_pGetGammaTables(
    FONTOBJ *pfo
    );

XFORMOBJ * APIENTRY FONTOBJ_pxoGetXform(
    FONTOBJ *pfo
    );

IFIMETRICS * APIENTRY FONTOBJ_pifi(
    FONTOBJ *pfo
    );

FD_GLYPHSET * APIENTRY FONTOBJ_pfdg(
    FONTOBJ *pfo
    );

PVOID APIENTRY FONTOBJ_pvTrueTypeFontFile(
    FONTOBJ *pfo,
    ULONG   *pcjFile
    );

PBYTE APIENTRY FONTOBJ_pjOpenTypeTablePointer (
    FONTOBJ *pfo,
    ULONG    ulTag,
    ULONG   *pcjTable
    );

LPWSTR APIENTRY FONTOBJ_pwszFontFilePaths (
    FONTOBJ *pfo,
    ULONG   *pcwc
    );

// for now only one mode is defined for glyph attributes

#define FO_ATTR_MODE_ROTATE         1

PFD_GLYPHATTR APIENTRY FONTOBJ_pQueryGlyphAttrs(
    FONTOBJ       *pfo,
    ULONG          iMode
    );

/*
 * PALOBJ callbacks
 */

#define PAL_INDEXED       0x00000001
#define PAL_BITFIELDS     0x00000002
#define PAL_RGB           0x00000004
#define PAL_BGR           0x00000008
#define PAL_CMYK          0x00000010

ULONG APIENTRY PALOBJ_cGetColors(
    PALOBJ *ppalo,
    ULONG   iStart,
    ULONG   cColors,
    ULONG  *pulColors
    );

/*
 * PATHOBJ callbacks
 */

#define PO_BEZIERS          0x00000001
#define PO_ELLIPSE          0x00000002
#define PO_ALL_INTEGERS     0x00000004
#define PO_ENUM_AS_INTEGERS 0x00000008

#define PD_BEGINSUBPATH   0x00000001
#define PD_ENDSUBPATH     0x00000002
#define PD_RESETSTYLE     0x00000004
#define PD_CLOSEFIGURE    0x00000008
#define PD_BEZIERS        0x00000010
#define PD_ALL           (PD_BEGINSUBPATH | \
                          PD_ENDSUBPATH   | \
                          PD_RESETSTYLE   | \
                          PD_CLOSEFIGURE  | \
                          PD_BEZIERS)

typedef struct  _PATHDATA
{
    FLONG    flags;
    ULONG    count;
    POINTFIX *pptfx;
} PATHDATA, *PPATHDATA;

typedef struct  _RUN
{
    LONG    iStart;
    LONG    iStop;
} RUN, *PRUN;

typedef struct  _CLIPLINE
{
    POINTFIX ptfxA;
    POINTFIX ptfxB;
    LONG    lStyleState;
    ULONG   c;
    RUN     arun[1];
} CLIPLINE, *PCLIPLINE;

VOID APIENTRY PATHOBJ_vEnumStart(
    PATHOBJ *ppo
    );

BOOL APIENTRY PATHOBJ_bEnum(
    PATHOBJ  *ppo,
    PATHDATA *ppd
    );

VOID APIENTRY PATHOBJ_vEnumStartClipLines(
    PATHOBJ   *ppo,
    CLIPOBJ   *pco,
    SURFOBJ   *pso,
    LINEATTRS *pla
    );

BOOL APIENTRY PATHOBJ_bEnumClipLines(
    PATHOBJ  *ppo,
    ULONG     cb,
    CLIPLINE *pcl
    );

BOOL APIENTRY PATHOBJ_bMoveTo(
    PATHOBJ    *ppo,
    POINTFIX    ptfx
    );

BOOL APIENTRY PATHOBJ_bPolyLineTo(
    PATHOBJ   *ppo,
    POINTFIX  *pptfx,
    ULONG      cptfx
    );

BOOL APIENTRY PATHOBJ_bPolyBezierTo(
    PATHOBJ   *ppo,
    POINTFIX  *pptfx,
    ULONG      cptfx
    );

BOOL APIENTRY PATHOBJ_bCloseFigure(
    PATHOBJ *ppo
    );

VOID APIENTRY PATHOBJ_vGetBounds(
    PATHOBJ *ppo,
    PRECTFX prectfx
    );

/*
 * STROBJ callbacks
 */

VOID APIENTRY STROBJ_vEnumStart(
    STROBJ *pstro
    );

BOOL APIENTRY STROBJ_bEnum(
    STROBJ    *pstro,
    ULONG     *pc,
    PGLYPHPOS *ppgpos
    );

BOOL APIENTRY STROBJ_bEnumPositionsOnly(
    STROBJ    *pstro,
    ULONG     *pc,
    PGLYPHPOS *ppgpos
    );

DWORD APIENTRY STROBJ_dwGetCodePage(
    STROBJ  *pstro
    );

FIX APIENTRY STROBJ_fxCharacterExtra(
    STROBJ  *pstro
    );

FIX APIENTRY STROBJ_fxBreakExtra(
    STROBJ  *pstro
    );

BOOL APIENTRY STROBJ_bGetAdvanceWidths(
    STROBJ   *pso,
    ULONG     iFirst,
    ULONG     c,
    POINTQF  *pptqD
    );


#define SGI_EXTRASPACE 0

/*
 * SURFOBJ callbacks
 */

#define STYPE_BITMAP    0L
#define STYPE_DEVICE    1L
#define STYPE_DEVBITMAP 3L

#define BMF_1BPP       1L
#define BMF_4BPP       2L
#define BMF_8BPP       3L
#define BMF_16BPP      4L
#define BMF_24BPP      5L
#define BMF_32BPP      6L
#define BMF_4RLE       7L
#define BMF_8RLE       8L
#define BMF_JPEG       9L
#define BMF_PNG       10L

#define BMF_TOPDOWN    0x0001
#define BMF_NOZEROINIT 0x0002
#define BMF_DONTCACHE  0x0004
#define BMF_USERMEM    0x0008
#define BMF_KMSECTION  0x0010
#define BMF_NOTSYSMEM  0x0020
#define BMF_WINDOW_BLT 0x0040

/*
 * XFORMOBJ callbacks
 */

#define GX_IDENTITY     0L
#define GX_OFFSET       1L
#define GX_SCALE        2L
#define GX_GENERAL      3L

#define XF_LTOL         0L
#define XF_INV_LTOL     1L
#define XF_LTOFX        2L
#define XF_INV_FXTOL    3L

ULONG APIENTRY XFORMOBJ_iGetXform(
    XFORMOBJ *pxo,
    XFORML   *pxform
    );

BOOL APIENTRY XFORMOBJ_bApplyXform(
    XFORMOBJ *pxo,
    ULONG     iMode,
    ULONG     cPoints,
    PVOID     pvIn,
    PVOID     pvOut
    );

HANDLE APIENTRY XFORMOBJ_cmGetTransform(
    XFORMOBJ *pxo
    );

/*
 * XLATEOBJ callbacks
 */

#define XO_TRIVIAL      0x00000001
#define XO_TABLE        0x00000002
#define XO_TO_MONO      0x00000004
#define XO_FROM_CMYK    0x00000008
#define XO_DEVICE_ICM   0x00000010 // ICM on Device
#define XO_HOST_ICM     0x00000020 // ICM on Engine/Apps

#define XO_SRCPALETTE    1
#define XO_DESTPALETTE   2
#define XO_DESTDCPALETTE 3
#define XO_SRCBITFIELDS  4
#define XO_DESTBITFIELDS 5

ULONG APIENTRY XLATEOBJ_iXlate(
    XLATEOBJ *pxlo,
    ULONG iColor
    );

ULONG * APIENTRY XLATEOBJ_piVector(
    XLATEOBJ *pxlo
    );

ULONG APIENTRY XLATEOBJ_cGetPalette(
    XLATEOBJ *pxlo,
    ULONG     iPal,
    ULONG     cPal,
    ULONG    *pPal
    );

HANDLE APIENTRY XLATEOBJ_hGetColorTransform(
    XLATEOBJ *pxlo
    );

/*
 * Engine callbacks - error logging
 */

#ifdef USERMODE_DRIVER

#define EngGetLastError     GetLastError
#define EngSetLastError     SetLastError

#else // !USERMODE_DRIVER

VOID APIENTRY EngSetLastError(ULONG);
ULONG APIENTRY EngGetLastError();

#endif // !USERMODE_DRIVER

/*
 * Engine callbacks - Surfaces
 */

#define HOOK_BITBLT                     0x00000001
#define HOOK_STRETCHBLT                 0x00000002
#define HOOK_PLGBLT                     0x00000004
#define HOOK_TEXTOUT                    0x00000008
#define HOOK_PAINT                      0x00000010      // Obsolete
#define HOOK_STROKEPATH                 0x00000020
#define HOOK_FILLPATH                   0x00000040
#define HOOK_STROKEANDFILLPATH          0x00000080
#define HOOK_LINETO                     0x00000100
#define HOOK_COPYBITS                   0x00000400
#define HOOK_MOVEPANNING                0x00000800      // Obsolete
#define HOOK_SYNCHRONIZE                0x00001000
#define HOOK_STRETCHBLTROP              0x00002000
#define HOOK_SYNCHRONIZEACCESS          0x00004000      // Obsolete
#define HOOK_TRANSPARENTBLT             0x00008000
#define HOOK_ALPHABLEND                 0x00010000
#define HOOK_GRADIENTFILL               0x00020000
#define HOOK_FLAGS                      0x0003b5ff

HBITMAP APIENTRY EngCreateBitmap(
    SIZEL sizl,
    LONG  lWidth,
    ULONG iFormat,
    FLONG fl,
    PVOID pvBits
    );

HSURF APIENTRY EngCreateDeviceSurface(
    DHSURF dhsurf,
    SIZEL sizl,
    ULONG iFormatCompat
    );

HBITMAP APIENTRY EngCreateDeviceBitmap(
    DHSURF dhsurf,
    SIZEL sizl,
    ULONG iFormatCompat
    );

BOOL APIENTRY EngDeleteSurface(
    HSURF hsurf
    );

SURFOBJ * APIENTRY EngLockSurface(
    HSURF hsurf
    );

VOID APIENTRY EngUnlockSurface(
    SURFOBJ *pso
    );

BOOL APIENTRY EngEraseSurface(
    SURFOBJ *pso,
    RECTL   *prcl,
    ULONG    iColor
    );

BOOL APIENTRY EngAssociateSurface(
    HSURF hsurf,
    HDEV  hdev,
    FLONG flHooks
    );

#define MS_NOTSYSTEMMEMORY  0x0001
#define MS_SHAREDACCESS     0x0002


BOOL APIENTRY EngModifySurface(
    HSURF   hsurf,
    HDEV    hdev,
    FLONG   flHooks,
    FLONG   flSurface,
    DHSURF  dhsurf,
    VOID*   pvScan0,
    LONG    lDelta,
    VOID*   pvReserved
    );

BOOL APIENTRY EngMarkBandingSurface(
    HSURF hsurf
    );

BOOL APIENTRY EngCheckAbort(
    SURFOBJ *pso
    );

/*
 * Engine callbacks - Paths
 */

PATHOBJ * APIENTRY EngCreatePath();

VOID APIENTRY EngDeletePath(
    PATHOBJ *ppo
    );

/*
 * Engine callbacks - Palettes
 */

HPALETTE APIENTRY EngCreatePalette(
    ULONG  iMode,
    ULONG  cColors,
    ULONG *pulColors,
    FLONG  flRed,
    FLONG  flGreen,
    FLONG  flBlue
    );

ULONG APIENTRY EngQueryPalette(
    HPALETTE    hpal,
    ULONG      *piMode,
    ULONG       cColors,
    ULONG      *pulColors);

BOOL APIENTRY EngDeletePalette(
    HPALETTE hpal
    );

/*
 * Engine callbacks - Clipping
 */

CLIPOBJ * APIENTRY EngCreateClip();

VOID APIENTRY EngDeleteClip(
    CLIPOBJ *pco
    );

/*
 * Function prototypes
 */

//
// User-mode printer driver information-query entrypoint
//

BOOL APIENTRY
APIENTRY
DrvQueryDriverInfo(
    DWORD   dwMode,
    PVOID   pBuffer,
    DWORD   cbBuf,
    PDWORD  pcbNeeded
    );

#define DRVQUERY_USERMODE   1


// These are the only EXPORTED functions for ANY driver

BOOL APIENTRY DrvEnableDriver(
    ULONG          iEngineVersion,
    ULONG          cj,
    DRVENABLEDATA *pded
    );

/*
 * Driver functions
 */

VOID APIENTRY  DrvDisableDriver();

DHPDEV APIENTRY DrvEnablePDEV(
    DEVMODEW *pdm,
    LPWSTR    pwszLogAddress,
    ULONG     cPat,
    HSURF    *phsurfPatterns,
    ULONG     cjCaps,
    ULONG    *pdevcaps,
    ULONG     cjDevInfo,
    DEVINFO  *pdi,
    HDEV      hdev,
    LPWSTR    pwszDeviceName,
    HANDLE    hDriver
    );

#define HS_DDI_MAX 6

BOOL APIENTRY DrvResetPDEV(
    DHPDEV dhpdevOld,
    DHPDEV dhpdevNew
    );

VOID APIENTRY DrvCompletePDEV(
    DHPDEV dhpdev,
    HDEV hdev
    );

BOOL APIENTRY DrvOffset(        // Obsolete
    SURFOBJ* pso,
    LONG x,
    LONG y,
    FLONG flReserved
    );

HSURF APIENTRY DrvEnableSurface(
    DHPDEV dhpdev
    );

VOID APIENTRY DrvSynchronize(
    DHPDEV dhpdev,
    RECTL *prcl
    );

VOID APIENTRY DrvDisableSurface(
    DHPDEV dhpdev
    );

VOID APIENTRY DrvDisablePDEV(
    DHPDEV dhpdev
    );

/* DrvSaveScreenBits - iMode definitions */

#define SS_SAVE    0
#define SS_RESTORE 1
#define SS_FREE    2

ULONG_PTR APIENTRY DrvSaveScreenBits(
    SURFOBJ  *pso,
    ULONG    iMode,
    ULONG_PTR ident,
    RECTL    *prcl
    );

/*
 * Desktops
 */

BOOL APIENTRY DrvAssertMode(
    DHPDEV dhpdev,
    BOOL   bEnable
    );

ULONG APIENTRY DrvGetModes(
    HANDLE    hDriver,
    ULONG     cjSize,
    DEVMODEW *pdm
    );

VOID APIENTRY DrvMovePanning(
    LONG    x,
    LONG    y,
    FLONG   fl
    );

BOOL APIENTRY DrvPlgBlt(
    SURFOBJ         *psoTrg,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMsk,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlBrushOrg,
    POINTFIX        *pptfx,
    RECTL           *prcl,
    POINTL          *pptl,
    ULONG            iMode
    );


/*
 * Bitmaps
 */

HBITMAP APIENTRY DrvCreateDeviceBitmap(
    DHPDEV dhpdev,
    SIZEL  sizl,
    ULONG  iFormat
    );

VOID APIENTRY DrvDeleteDeviceBitmap(
    DHSURF dhsurf
    );

/*
 * Palettes
 */

BOOL APIENTRY DrvSetPalette(
    DHPDEV  dhpdev,
    PALOBJ *ppalo,
    FLONG   fl,
    ULONG   iStart,
    ULONG   cColors
    );

/*
 * Brushes
 */

#define DM_DEFAULT    0x00000001
#define DM_MONOCHROME 0x00000002

#define DCR_SOLID       0
#define DCR_DRIVER      1
#define DCR_HALFTONE    2

ULONG APIENTRY DrvDitherColor(
    DHPDEV dhpdev,
    ULONG  iMode,
    ULONG  rgb,
    ULONG *pul
    );

BOOL APIENTRY DrvRealizeBrush(
    BRUSHOBJ *pbo,
    SURFOBJ  *psoTarget,
    SURFOBJ  *psoPattern,
    SURFOBJ  *psoMask,
    XLATEOBJ *pxlo,
    ULONG    iHatch
    );

#define RB_DITHERCOLOR 0x80000000L


/*
 * Fonts
 */

PIFIMETRICS APIENTRY DrvQueryFont(
    DHPDEV    dhpdev,
    ULONG_PTR  iFile,
    ULONG     iFace,
    ULONG     *pid
    );

// #define QFT_UNICODE     0L
#define QFT_LIGATURES       1L
#define QFT_KERNPAIRS       2L
#define QFT_GLYPHSET        3L

PVOID APIENTRY DrvQueryFontTree(
    DHPDEV    dhpdev,
    ULONG_PTR  iFile,
    ULONG     iFace,
    ULONG     iMode,
    ULONG     *pid
    );

#define QFD_GLYPHANDBITMAP    1L
#define QFD_GLYPHANDOUTLINE   2L
#define QFD_MAXEXTENTS        3L
#define QFD_TT_GLYPHANDBITMAP 4L
#define QFD_TT_GRAY1_BITMAP   5L
#define QFD_TT_GRAY2_BITMAP   6L
#define QFD_TT_GRAY4_BITMAP   8L
#define QFD_TT_GRAY8_BITMAP   9L

#define QFD_TT_MONO_BITMAP QFD_TT_GRAY1_BITMAP

LONG APIENTRY DrvQueryFontData(
    DHPDEV      dhpdev,
    FONTOBJ    *pfo,
    ULONG       iMode,
    HGLYPH      hg,
    GLYPHDATA  *pgd,
    PVOID       pv,
    ULONG       cjSize
    );

VOID APIENTRY DrvFree(
PVOID   pv,
ULONG   id);

VOID APIENTRY DrvDestroyFont(
FONTOBJ *pfo);

// Capability flags for DrvQueryCaps.

#define QC_OUTLINES             0x00000001
#define QC_1BIT                 0x00000002
#define QC_4BIT                 0x00000004

//
// This is a mask of the capabilites of a font provider that can return more
// than just glyph metrics (i.e., bitmaps and/or outlines).  If a driver has
// one or more of these capabilities, then it is FONT DRIVER.
//
// Drivers should only set individual bits. GDI will check if any are turned on
// using this define.
//

#define QC_FONTDRIVERCAPS   ( QC_OUTLINES | QC_1BIT | QC_4BIT )

LONG APIENTRY DrvQueryFontCaps(
    ULONG   culCaps,
    ULONG  *pulCaps
    );

// fStatus is a new flag NT 5.0

#define FF_SIGNATURE_VERIFIED 0x1
#define FF_IGNORED_SIGNATURE  0x2

ULONG_PTR APIENTRY DrvLoadFontFile(
    ULONG     cFiles,  // number of font files associated with this font
    ULONG_PTR  *piFile,  // handles for individual files, cFiles of them
    PVOID     *ppvView, // array of cFiles views
    ULONG     *pcjView, // array of their sizes
    DESIGNVECTOR *pdv, // only non null for mm instances
    ULONG     ulLangID,
    ULONG     ulFastCheckSum
    );

BOOL APIENTRY DrvUnloadFontFile(
    ULONG_PTR   iFile
    );

LONG APIENTRY DrvQueryTrueTypeTable(
    ULONG_PTR   iFile,
    ULONG      ulFont,
    ULONG      ulTag,
    PTRDIFF    dpStart,
    ULONG      cjBuf,
    BYTE       *pjBuf,
    PBYTE      *ppjTable,
    ULONG      *pcjTable
    );

BOOL APIENTRY DrvQueryAdvanceWidths(
    DHPDEV   dhpdev,
    FONTOBJ *pfo,
    ULONG    iMode,
    HGLYPH  *phg,
    PVOID    pvWidths,
    ULONG    cGlyphs
    );

// Values for iMode

#define QAW_GETWIDTHS       0
#define QAW_GETEASYWIDTHS   1

// values for bMetricsOnly. even though declared as BOOL
// by adding TTO_QUBICS, this is becoming a flag field.
// For versions of NT 4.0 and earlier, this value is always
// set to zero by GDI.

#define TTO_METRICS_ONLY 1
#define TTO_QUBICS       2
#define TTO_UNHINTED     4

LONG APIENTRY DrvQueryTrueTypeOutline(
    DHPDEV      dhpdev,
    FONTOBJ    *pfo,
    HGLYPH      hglyph,
    BOOL        bMetricsOnly,
    GLYPHDATA  *pgldt,
    ULONG       cjBuf,
    TTPOLYGONHEADER *ppoly
    );

PVOID APIENTRY DrvGetTrueTypeFile (
    ULONG_PTR   iFile,
    ULONG      *pcj
    );

// values for ulMode:

#define QFF_DESCRIPTION     1L
#define QFF_NUMFACES        2L

LONG APIENTRY DrvQueryFontFile(
    ULONG_PTR   iFile,
    ULONG      ulMode,
    ULONG      cjBuf,
    ULONG      *pulBuf
    );

/*
 * BitBlt
 */

BOOL APIENTRY DrvBitBlt(
    SURFOBJ  *psoTrg,
    SURFOBJ  *psoSrc,
    SURFOBJ  *psoMask,
    CLIPOBJ  *pco,
    XLATEOBJ *pxlo,
    RECTL    *prclTrg,
    POINTL   *pptlSrc,
    POINTL   *pptlMask,
    BRUSHOBJ *pbo,
    POINTL   *pptlBrush,
    ROP4      rop4
    );

BOOL APIENTRY DrvStretchBlt(
    SURFOBJ         *psoDest,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlHTOrg,
    RECTL           *prclDest,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG            iMode
    );

BOOL APIENTRY DrvStretchBltROP(
    SURFOBJ         *psoDest,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlHTOrg,
    RECTL           *prclDest,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG            iMode,
    BRUSHOBJ        *pbo,
    DWORD            rop4
    );

BOOL APIENTRY DrvAlphaBlend(
    SURFOBJ       *psoDest,
    SURFOBJ       *psoSrc,
    CLIPOBJ       *pco,
    XLATEOBJ      *pxlo,
    RECTL         *prclDest,
    RECTL         *prclSrc,
    BLENDOBJ      *pBlendObj
    );

BOOL APIENTRY DrvGradientFill(
    SURFOBJ         *psoDest,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    TRIVERTEX       *pVertex,
    ULONG            nVertex,
    PVOID            pMesh,
    ULONG            nMesh,
    RECTL           *prclExtents,
    POINTL          *pptlDitherOrg,
    ULONG            ulMode
    );

BOOL APIENTRY DrvTransparentBlt(
    SURFOBJ    *psoDst,
    SURFOBJ    *psoSrc,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    RECTL      *prclDst,
    RECTL      *prclSrc,
    ULONG      iTransColor,
    ULONG      ulReserved
);

BOOL APIENTRY DrvCopyBits(
    SURFOBJ  *psoDest,
    SURFOBJ  *psoSrc,
    CLIPOBJ  *pco,
    XLATEOBJ *pxlo,
    RECTL    *prclDest,
    POINTL   *pptlSrc
    );

/*
 * Text Output
 */

BOOL APIENTRY DrvTextOut(
    SURFOBJ  *pso,
    STROBJ   *pstro,
    FONTOBJ  *pfo,
    CLIPOBJ  *pco,
    RECTL    *prclExtra,        // Obsolete, always NULL
    RECTL    *prclOpaque,
    BRUSHOBJ *pboFore,
    BRUSHOBJ *pboOpaque,
    POINTL   *pptlOrg,
    MIX       mix
    );

/*
 * Graphics Output
 */

BOOL APIENTRY DrvLineTo(
    SURFOBJ   *pso,
    CLIPOBJ   *pco,
    BRUSHOBJ  *pbo,
    LONG       x1,
    LONG       y1,
    LONG       x2,
    LONG       y2,
    RECTL     *prclBounds,
    MIX        mix
    );

BOOL APIENTRY DrvStrokePath(
    SURFOBJ   *pso,
    PATHOBJ   *ppo,
    CLIPOBJ   *pco,
    XFORMOBJ  *pxo,
    BRUSHOBJ  *pbo,
    POINTL    *pptlBrushOrg,
    LINEATTRS *plineattrs,
    MIX        mix
    );

#define FP_ALTERNATEMODE    1L
#define FP_WINDINGMODE      2L

BOOL APIENTRY DrvFillPath(
    SURFOBJ  *pso,
    PATHOBJ  *ppo,
    CLIPOBJ  *pco,
    BRUSHOBJ *pbo,
    POINTL   *pptlBrushOrg,
    MIX       mix,
    FLONG     flOptions
    );

BOOL APIENTRY DrvStrokeAndFillPath(
    SURFOBJ   *pso,
    PATHOBJ   *ppo,
    CLIPOBJ   *pco,
    XFORMOBJ  *pxo,
    BRUSHOBJ  *pboStroke,
    LINEATTRS *plineattrs,
    BRUSHOBJ  *pboFill,
    POINTL    *pptlBrushOrg,
    MIX        mixFill,
    FLONG      flOptions
    );

BOOL APIENTRY DrvPaint(
    SURFOBJ  *pso,
    CLIPOBJ  *pco,
    BRUSHOBJ *pbo,
    POINTL   *pptlBrushOrg,
    MIX       mix
    );

/*
 * Pointers
 */

#define SPS_ERROR               0
#define SPS_DECLINE             1
#define SPS_ACCEPT_NOEXCLUDE    2
#define SPS_ACCEPT_EXCLUDE      3               // Obsolete

#define SPS_CHANGE        0x00000001L
#define SPS_ASYNCCHANGE   0x00000002L           // Obsolete
#define SPS_ANIMATESTART  0x00000004L
#define SPS_ANIMATEUPDATE 0x00000008L
#define SPS_ALPHA         0x00000010L

ULONG APIENTRY DrvSetPointerShape(
    SURFOBJ  *pso,
    SURFOBJ  *psoMask,
    SURFOBJ  *psoColor,
    XLATEOBJ *pxlo,
    LONG      xHot,
    LONG      yHot,
    LONG      x,
    LONG      y,
    RECTL    *prcl,
    FLONG     fl
    );

VOID APIENTRY DrvMovePointer(
    SURFOBJ  *pso,
    LONG      x,
    LONG      y,
    RECTL    *prcl
    );

/*
 * Printing
 */

BOOL APIENTRY DrvSendPage(
    SURFOBJ *pso
    );

BOOL APIENTRY DrvStartPage(
    SURFOBJ *pso
    );

ULONG APIENTRY DrvEscape(
    SURFOBJ *pso,
    ULONG    iEsc,
    ULONG    cjIn,
    PVOID    pvIn,
    ULONG    cjOut,
    PVOID    pvOut
    );

BOOL  APIENTRY DrvStartDoc(
    SURFOBJ *pso,
    LPWSTR   pwszDocName,
    DWORD    dwJobId
    );

#define ED_ABORTDOC    1

BOOL APIENTRY DrvEndDoc(
    SURFOBJ *pso,
    FLONG fl
    );

BOOL APIENTRY DrvQuerySpoolType(
    DHPDEV,
    LPWSTR
    );

ULONG APIENTRY DrvDrawEscape(
    SURFOBJ *pso,
    ULONG    iEsc,
    CLIPOBJ *pco,
    RECTL   *prcl,
    ULONG    cjIn,
    PVOID    pvIn
    );

ULONG APIENTRY DrvGetGlyphMode(
    DHPDEV,
    FONTOBJ *
    );

ULONG APIENTRY DrvFontManagement(
    SURFOBJ *pso,
    FONTOBJ *pfo,
    ULONG    iMode,
    ULONG    cjIn,
    PVOID    pvIn,
    ULONG    cjOut,
    PVOID    pvOut
    );

BOOL APIENTRY DrvStartBanding(
    SURFOBJ *pso,
    POINTL *pptl
    );

BOOL APIENTRY DrvNextBand(
    SURFOBJ *pso,
    POINTL *pptl
    );

typedef struct _PERBANDINFO
{
    BOOL  bRepeatThisBand;
    SIZEL szlBand;
    ULONG ulHorzRes;
    ULONG ulVertRes;
} PERBANDINFO, *PPERBANDINFO;

ULONG APIENTRY DrvQueryPerBandInfo(
    SURFOBJ *pso,
    PERBANDINFO *pbi
    );

/*
 * DirectDraw
 */

BOOL APIENTRY DrvEnableDirectDraw(
    DHPDEV                  dhpdev,
    DD_CALLBACKS           *pCallBacks,
    DD_SURFACECALLBACKS    *pSurfaceCallBacks,
    DD_PALETTECALLBACKS    *pPaletteCallBacks
    );

VOID APIENTRY DrvDisableDirectDraw(
    DHPDEV  dhpdev
    );

BOOL APIENTRY DrvGetDirectDrawInfo(
    DHPDEV        dhpdev,
    DD_HALINFO   *pHalInfo,
    DWORD        *pdwNumHeaps,
    VIDEOMEMORY  *pvmList,
    DWORD        *pdwNumFourCCCodes,
    DWORD        *pdwFourCC
    );

HBITMAP APIENTRY DrvDeriveSurface(
    DD_DIRECTDRAW_GLOBAL   *pDirectDraw,
    DD_SURFACE_LOCAL       *pSurface
    );

/*
 * ICM (Image Color Matching)
 */

HANDLE APIENTRY DrvIcmCreateColorTransform(
    DHPDEV           dhpdev,
    LPLOGCOLORSPACEW pLogColorSpace,
    PVOID            pvSourceProfile,
    ULONG            cjSourceProfile,
    PVOID            pvDestProfile,
    ULONG            cjDestProfile,
    PVOID            pvTargetProfile,
    ULONG            cjTargetProfile,
    DWORD            dwReserved
    );

BOOL APIENTRY DrvIcmDeleteColorTransform(
    DHPDEV dhpdev,
    HANDLE hcmXform
    );

BOOL APIENTRY DrvIcmCheckBitmapBits(
    DHPDEV   dhpdev,
    HANDLE   hColorTransform,
    SURFOBJ *pso,
    PBYTE    paResults
    );

typedef struct _GAMMARAMP {
    WORD Red[256];
    WORD Green[256];
    WORD Blue[256];
} GAMMARAMP, *PGAMMARAMP;

BOOL APIENTRY DrvIcmSetDeviceGammaRamp(
    DHPDEV  dhpdev,
    ULONG   iFormat,
    LPVOID  lpRamp
    );

#define IGRF_RGB_256BYTES  0 /* Obsolate */
#define IGRF_RGB_256WORDS  1 /* Same GammaRampArray format as Win95/98 DDI */

/*
 * Query miscellaneous driver support
 */

BOOL APIENTRY DrvQueryDeviceSupport(
    SURFOBJ *pso,
    XLATEOBJ *pxlo,
    XFORMOBJ *pxo,
    ULONG iType,
    ULONG cjIn,
    PVOID pvIn,
    ULONG cjOut,
    PVOID pvOut);

#define QDS_CHECKJPEGFORMAT     0
#define QDS_CHECKPNGFORMAT      1

VOID APIENTRY DrvSynchronizeSurface(
    SURFOBJ *pso,
    RECTL   *prcl,
    FLONG    fl
);

#define DSS_TIMER_EVENT        0x0001
#define DSS_FLUSH_EVENT        0x0002

VOID APIENTRY DrvNotify(
    SURFOBJ *pso,
    ULONG    iType,
    PVOID    pvData);

#define DN_ACCELERATION_LEVEL     1
#define DN_DEVICE_ORIGIN          2
#define DN_SLEEP_MODE             3
#define DN_DRAWING_BEGIN          4

/*
 * Engine callbacks - tracking clip region changes
 */

#define WOC_RGN_CLIENT_DELTA    0x0001
#define WOC_RGN_CLIENT          0x0002
#define WOC_RGN_SURFACE_DELTA   0x0004
#define WOC_RGN_SURFACE         0x0008
#define WOC_CHANGED             0x0010
#define WOC_DELETE              0x0020
#define WOC_DRAWN               0x0040
#define WOC_SPRITE_OVERLAP      0x0080
#define WOC_SPRITE_NO_OVERLAP   0x0100

typedef VOID (CALLBACK * WNDOBJCHANGEPROC)(WNDOBJ *pwo, FLONG fl);

#define WO_RGN_CLIENT_DELTA     0x0001
#define WO_RGN_CLIENT           0x0002
#define WO_RGN_SURFACE_DELTA    0x0004
#define WO_RGN_SURFACE          0x0008
#define WO_RGN_UPDATE_ALL       0x0010
#define WO_RGN_WINDOW           0x0020
#define WO_DRAW_NOTIFY          0x0040
#define WO_SPRITE_NOTIFY        0x0080
#define WO_RGN_DESKTOP_COORD    0x0100

WNDOBJ * APIENTRY EngCreateWnd(
    SURFOBJ         *pso,
    HWND             hwnd,
    WNDOBJCHANGEPROC pfn,
    FLONG            fl,
    int              iPixelFormat
    );

VOID APIENTRY EngDeleteWnd(
    WNDOBJ  *pwo
    );

ULONG APIENTRY WNDOBJ_cEnumStart(
    WNDOBJ  *pwo,
    ULONG    iType,
    ULONG    iDirection,
    ULONG    cLimit
    );

BOOL APIENTRY WNDOBJ_bEnum(
    WNDOBJ  *pwo,
    ULONG    cj,
    ULONG   *pul
    );

VOID APIENTRY WNDOBJ_vSetConsumer(
    WNDOBJ  *pwo,
    PVOID    pvConsumer
    );

/*
 * Engine callbacks - tracking driver managed resources
 */

HDRVOBJ APIENTRY EngCreateDriverObj(
    PVOID pvObj,
    FREEOBJPROC pFreeObjProc,
    HDEV hdev
    );

BOOL APIENTRY EngDeleteDriverObj(
    HDRVOBJ hdo,
    BOOL bCallBack,
    BOOL bLocked
    );

DRIVEROBJ* APIENTRY EngLockDriverObj(
    HDRVOBJ hdo
    );

BOOL APIENTRY EngUnlockDriverObj(
    HDRVOBJ hdo
    );

/*
 * Engine callback - return current process handle.
 */

HANDLE APIENTRY EngGetProcessHandle();

/*
 * Engine callback - return current thread id
 */

HANDLE APIENTRY EngGetCurrentThreadId();

/*
 * Engine callback - return current process id
 */

HANDLE APIENTRY EngGetCurrentProcessId();

/*
 * Pixel formats
 */

BOOL APIENTRY DrvSetPixelFormat(
    SURFOBJ *pso,
    LONG     iPixelFormat,
    HWND     hwnd
    );

LONG APIENTRY DrvDescribePixelFormat(
    DHPDEV   dhpdev,
    LONG     iPixelFormat,
    ULONG    cjpfd,
    PIXELFORMATDESCRIPTOR *ppfd
    );

/*
 * Swap buffers
 */

BOOL APIENTRY DrvSwapBuffers(
    SURFOBJ *pso,
    WNDOBJ  *pwo
    );

/*
 * Function prototypes - Engine Simulations
 */

BOOL APIENTRY EngBitBlt(
    SURFOBJ  *psoTrg,
    SURFOBJ  *psoSrc,
    SURFOBJ  *psoMask,
    CLIPOBJ  *pco,
    XLATEOBJ *pxlo,
    RECTL    *prclTrg,
    POINTL   *pptlSrc,
    POINTL   *pptlMask,
    BRUSHOBJ *pbo,
    POINTL   *pptlBrush,
    ROP4      rop4
    );

BOOL APIENTRY EngLineTo(
    SURFOBJ   *pso,
    CLIPOBJ   *pco,
    BRUSHOBJ  *pbo,
    LONG       x1,
    LONG       y1,
    LONG       x2,
    LONG       y2,
    RECTL     *prclBounds,
    MIX        mix
    );

BOOL APIENTRY EngStretchBlt(
    SURFOBJ         *psoDest,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlHTOrg,
    RECTL           *prclDest,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG            iMode
    );

BOOL APIENTRY EngStretchBltROP(
    SURFOBJ         *psoDest,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlHTOrg,
    RECTL           *prclDest,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG            iMode,
    BRUSHOBJ        *pbo,
    DWORD            rop4
    );

BOOL APIENTRY EngAlphaBlend(
    SURFOBJ       *psoDest,
    SURFOBJ       *psoSrc,
    CLIPOBJ       *pco,
    XLATEOBJ      *pxlo,
    RECTL         *prclDest,
    RECTL         *prclSrc,
    BLENDOBJ      *pBlendObj
    );

BOOL APIENTRY EngGradientFill(
    SURFOBJ         *psoDest,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    TRIVERTEX       *pVertex,
    ULONG            nVertex,
    PVOID            pMesh,
    ULONG            nMesh,
    RECTL           *prclExtents,
    POINTL          *pptlDitherOrg,
    ULONG            ulMode
    );

BOOL APIENTRY EngTransparentBlt(
    SURFOBJ    *psoDst,
    SURFOBJ    *psoSrc,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    RECTL      *prclDst,
    RECTL      *prclSrc,
    ULONG      iTransColor,
    ULONG      ulReserved
    );

BOOL APIENTRY EngTextOut(
    SURFOBJ  *pso,
    STROBJ   *pstro,
    FONTOBJ  *pfo,
    CLIPOBJ  *pco,
    RECTL    *prclExtra,
    RECTL    *prclOpaque,
    BRUSHOBJ *pboFore,
    BRUSHOBJ *pboOpaque,
    POINTL   *pptlOrg,
    MIX       mix
    );

BOOL APIENTRY EngStrokePath(
    SURFOBJ   *pso,
    PATHOBJ   *ppo,
    CLIPOBJ   *pco,
    XFORMOBJ  *pxo,
    BRUSHOBJ  *pbo,
    POINTL    *pptlBrushOrg,
    LINEATTRS *plineattrs,
    MIX        mix
    );

BOOL APIENTRY EngFillPath(
    SURFOBJ  *pso,
    PATHOBJ  *ppo,
    CLIPOBJ  *pco,
    BRUSHOBJ *pbo,
    POINTL   *pptlBrushOrg,
    MIX       mix,
    FLONG     flOptions
    );

BOOL APIENTRY EngStrokeAndFillPath(
    SURFOBJ   *pso,
    PATHOBJ   *ppo,
    CLIPOBJ   *pco,
    XFORMOBJ  *pxo,
    BRUSHOBJ  *pboStroke,
    LINEATTRS *plineattrs,
    BRUSHOBJ  *pboFill,
    POINTL    *pptlBrushOrg,
    MIX        mixFill,
    FLONG      flOptions
    );

BOOL APIENTRY EngPaint(
    SURFOBJ  *pso,
    CLIPOBJ  *pco,
    BRUSHOBJ *pbo,
    POINTL   *pptlBrushOrg,
    MIX       mix
    );

BOOL APIENTRY EngCopyBits(
    SURFOBJ  *psoDest,
    SURFOBJ  *psoSrc,
    CLIPOBJ  *pco,
    XLATEOBJ *pxlo,
    RECTL    *prclDest,
    POINTL   *pptlSrc
    );

ULONG APIENTRY EngSetPointerShape(
    SURFOBJ  *pso,
    SURFOBJ  *psoMask,
    SURFOBJ  *psoColor,
    XLATEOBJ *pxlo,
    LONG      xHot,
    LONG      yHot,
    LONG      x,
    LONG      y,
    RECTL    *prcl,
    FLONG     fl
    );

VOID APIENTRY EngMovePointer(
    SURFOBJ  *pso,
    LONG      x,
    LONG      y,
    RECTL    *prcl
    );

BOOL APIENTRY EngPlgBlt(
    SURFOBJ         *psoTrg,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMsk,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlBrushOrg,
    POINTFIX        *pptfx,
    RECTL           *prcl,
    POINTL          *pptl,
    ULONG            iMode
    );

ULONG APIENTRY EngDitherColor(
    HDEV   hdev,
    ULONG  iMode,
    ULONG  rgb,
    ULONG *pul
    );

//
// Sprite control
//

#define ECS_TEARDOWN    0x0001
#define ECS_REDRAW      0x0002

BOOL APIENTRY EngControlSprites(
    WNDOBJ  *pwo,
    FLONG    fl
    );


//
// Halftone releated APIs
//

LONG APIENTRY HT_ComputeRGBGammaTable(
    USHORT  GammaTableEntries,
    USHORT  GammaTableType,
    USHORT  RedGamma,
    USHORT  GreenGamma,
    USHORT  BlueGamma,
    LPBYTE  pGammaTable
    );

LONG APIENTRY HT_Get8BPPFormatPalette(
    LPPALETTEENTRY  pPaletteEntry,
    USHORT          RedGamma,
    USHORT          GreenGamma,
    USHORT          BlueGamma
    );

LONG APIENTRY HT_Get8BPPMaskPalette(
    LPPALETTEENTRY  pPaletteEntry,
    BOOL            Use8BPPMaskPal,
    BYTE            CMYMask,
    USHORT          RedGamma,
    USHORT          GreenGamma,
    USHORT          BlueGamma
    );

typedef struct _DEVHTINFO {
    DWORD       HTFlags;
    DWORD       HTPatternSize;
    DWORD       DevPelsDPI;
    COLORINFO   ColorInfo;
    } DEVHTINFO, *PDEVHTINFO;

#define DEVHTADJF_COLOR_DEVICE      0x00000001
#define DEVHTADJF_ADDITIVE_DEVICE   0x00000002

typedef struct _DEVHTADJDATA {
    DWORD       DeviceFlags;
    DWORD       DeviceXDPI;
    DWORD       DeviceYDPI;
    PDEVHTINFO  pDefHTInfo;
    PDEVHTINFO  pAdjHTInfo;
    } DEVHTADJDATA, *PDEVHTADJDATA;

LONG
APIENTRY
HTUI_DeviceColorAdjustment(
    LPSTR           pDeviceName,
    PDEVHTADJDATA   pDevHTAdjData
    );


//
// General support APIS
//

VOID APIENTRY EngDebugBreak(
    VOID
    );

VOID APIENTRY EngDebugPrint(
    PCHAR StandardPrefix,
    PCHAR DebugMessage,
    va_list ap
    );

VOID APIENTRY EngQueryPerformanceCounter(
    LONGLONG  *pPerformanceCount
    );

VOID APIENTRY EngQueryPerformanceFrequency(
    LONGLONG  *pFrequency
    );

BOOL APIENTRY EngSetPointerTag(
    HDEV       hdev,
    SURFOBJ   *psoMask,
    SURFOBJ   *psoColor,
    XLATEOBJ  *pxlo,
    FLONG      fl
    );

//
// Kernel mode memory operations
//

#define FL_ZERO_MEMORY      0x00000001

#ifdef USERMODE_DRIVER

#define EngAllocMem(flags, cj, tag) ((PVOID) GlobalAlloc(((flags) & FL_ZERO_MEMORY) ? GPTR : GMEM_FIXED, cj))
#define EngFreeMem(p)               GlobalFree((HGLOBAL) (p))
#define EngAllocUserMem(cj, tag)    ((PVOID) GlobalAlloc(GMEM_FIXED,cj))
#define EngFreeUserMem(p)           GlobalFree((HGLOBAL) (p))
#define EngAllocPrivateUserMem( psl, cj, tag) ((PVOID) GlobalAlloc(GMEM_FIXED,cj))
#define EngFreePrivateUserMem( psl, p)        GlobalFree((HGLOBAL) (p))
#define EngMulDiv                   MulDiv

#else // !USERMODE_DRIVER

PVOID APIENTRY EngAllocMem(
    ULONG Flags,
    ULONG MemSize,
    ULONG Tag
    );

VOID APIENTRY EngFreeMem(
    PVOID Mem
    );

PVOID APIENTRY EngAllocUserMem(
    SIZE_T cj,
    ULONG tag
    );

VOID APIENTRY EngFreeUserMem(
    PVOID pv
    );

PVOID APIENTRY EngAllocPrivateUserMem( 
    PDD_SURFACE_LOCAL psl,
    SIZE_T cj,
    ULONG tag
    );

VOID
EngFreePrivateUserMem( 
    PDD_SURFACE_LOCAL psl,
    PVOID pv
    );


int APIENTRY EngMulDiv(
    int a,
    int b,
    int c
    );

#endif // !USERMODE_DRIVER

//
// User mode memory Operations
//

VOID APIENTRY EngProbeForRead(
    PVOID Address,
    ULONG Length,
    ULONG Alignment
    );

VOID APIENTRY EngProbeForReadAndWrite(
    PVOID Address,
    ULONG Length,
    ULONG Alignment
    );

HANDLE APIENTRY EngSecureMem(
    PVOID Address,
    ULONG Length
    );

VOID APIENTRY EngUnsecureMem(
    HANDLE hSecure
    );

DWORD APIENTRY EngDeviceIoControl(
    HANDLE hDevice,
    DWORD dwIoControlCode,
    LPVOID lpInBuffer,
    DWORD nInBufferSize,
    LPVOID lpOutBuffer,
    DWORD nOutBufferSize,
    LPDWORD lpBytesReturned
    );

//
// Loading drivers and gettings entry points from them
//

#ifdef USERMODE_DRIVER

#define EngLoadImage(filename)               ((HANDLE) LoadLibraryW(filename))
#define EngFindImageProcAddress(h, procname) ((PVOID) GetProcAddress(h, procname))
#define EngUnloadImage(h)                    FreeLibrary((HMODULE) (h))

#else // !USERMODE_DRIVER

HANDLE APIENTRY EngLoadImage(
    LPWSTR pwszDriver
    );

PVOID APIENTRY EngFindImageProcAddress(
    HANDLE hModule,
    LPSTR lpProcName
    );

VOID APIENTRY EngUnloadImage(
    HANDLE hModule
    );

PVOID APIENTRY EngMapModule(
    HANDLE h,
    PULONG pSize
    );

#endif // !USERMODE_DRIVER


//
// callback for extra PDEV information
//

LPWSTR APIENTRY EngGetPrinterDataFileName(
    HDEV hdev
    );

LPWSTR APIENTRY EngGetDriverName(
    HDEV hdev
    );

typedef struct _TYPE1_FONT
{
    HANDLE  hPFM;
    HANDLE  hPFB;
    ULONG   ulIdentifier;
} TYPE1_FONT;


BOOL APIENTRY EngGetType1FontList(
    HDEV            hdev,
    TYPE1_FONT      *pType1Buffer,
    ULONG           cjType1Buffer,
    PULONG          pulLocalFonts,
    PULONG          pulRemoteFonts,
    LARGE_INTEGER   *pLastModified
    );

//
// Manipulating resource sections
//

HANDLE APIENTRY EngLoadModule(
    LPWSTR pwsz
    );

PVOID APIENTRY EngFindResource(
    HANDLE h,
    int    iName,
    int    iType,
    PULONG pulSize
    );

VOID APIENTRY EngFreeModule(
    HANDLE h
    );

BOOL
APIENTRY
EngDeleteFile (
    LPWSTR  pwszFileName
    );

PVOID
APIENTRY
EngMapFile(
    LPWSTR      pwsz,
    ULONG       cjSize,
    ULONG_PTR  *piFile
    );


BOOL
APIENTRY
EngUnmapFile (
     ULONG_PTR iFile
     );
//
// FontFile Callbacks
//

VOID APIENTRY EngUnmapFontFile(
    ULONG_PTR iFile
    );

BOOL APIENTRY EngMapFontFile(
    ULONG_PTR  iFile,
    PULONG *ppjBuf,
    ULONG  *pcjBuf
    );

VOID APIENTRY EngUnmapFontFileFD(
    ULONG_PTR iFile
    );

BOOL APIENTRY EngMapFontFileFD(
    ULONG_PTR  iFile,
    PULONG *ppjBuf,
    ULONG  *pcjBuf
    );

BOOL APIENTRY EngLpkInstalled();

//
// Semaphores
//

DECLARE_HANDLE(HSEMAPHORE);

HSEMAPHORE APIENTRY EngCreateSemaphore(
    VOID
    );

VOID APIENTRY EngAcquireSemaphore(
    HSEMAPHORE hsem
    );

VOID APIENTRY EngReleaseSemaphore(
    HSEMAPHORE hsem
    );

VOID APIENTRY EngDeleteSemaphore(
    HSEMAPHORE hsem
    );

//
// Semaphore wrapper with a reference count for thread-safe creation and
// destruction.  Data must be created zero-filled.
//
// Use EngAcquire/ReleaseSemaphore on hsem for access protection.
//

typedef struct _ENGSAFESEMAPHORE
{
    HSEMAPHORE hsem;
    LONG lCount;
} ENGSAFESEMAPHORE;

BOOL APIENTRY EngInitializeSafeSemaphore(
    ENGSAFESEMAPHORE *pssem
    );

VOID APIENTRY EngDeleteSafeSemaphore(
    ENGSAFESEMAPHORE *pssem
    );

VOID APIENTRY EngMultiByteToUnicodeN(
    LPWSTR UnicodeString,
    ULONG MaxBytesInUnicodeString,
    PULONG BytesInUnicodeString,
    PCHAR MultiByteString,
    ULONG BytesInMultiByteString
    );

VOID APIENTRY EngUnicodeToMultiByteN(
    PCHAR MultiByteString,
    ULONG MaxBytesInMultiByteString,
    PULONG BytesInMultiByteString,
    PWSTR UnicodeString,
    ULONG BytesInUnicodeString
    );

// for the spooler

#ifdef USERMODE_DRIVER

#define EngWritePrinter     WritePrinter
#define EngGetPrinter       GetPrinter
#define EngGetPrinterDriver GetPrinterDriver
#define EngGetPrinterData   GetPrinterData
#define EngSetPrinterData   SetPrinterData
#define EngEnumForms        EnumForms
#define EngGetForm          GetForm

#else // !USERMODE_DRIVER

BOOL APIENTRY EngGetPrinterDriver(
    HANDLE  hPrinter,
    LPWSTR  pEnvironment,
    DWORD   dwLevel,
    BYTE   *lpbDrvInfo,
    DWORD   cbBuf,
    DWORD  *pcbNeeded
    );

DWORD APIENTRY EngGetPrinterData(
    HANDLE   hPrinter,
    LPWSTR    pValueName,
    LPDWORD  pType,
    LPBYTE   pData,
    DWORD    nSize,
    LPDWORD  pcbNeeded
    );

DWORD APIENTRY EngSetPrinterData(
    HANDLE   hPrinter,
    LPWSTR   pType,
    DWORD    dwType,
    LPBYTE   lpbPrinterData,
    DWORD    cjPrinterData
    );

BOOL APIENTRY EngGetForm(
    HANDLE  hPrinter,
    LPWSTR   pFormName,
    DWORD   Level,
    LPBYTE  pForm,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
    );

BOOL APIENTRY EngWritePrinter(
    HANDLE  hPrinter,
    LPVOID  pBuf,
    DWORD   cbBuf,
    LPDWORD pcWritten
    );

BOOL APIENTRY EngGetPrinter(
    HANDLE  hPrinter,
    DWORD   dwLevel,
    LPBYTE  pPrinter,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
    );

BOOL APIENTRY EngEnumForms(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pForm,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
    );

#endif // !USERMODE_DRIVER


ULONG APIENTRY EngEscape(
    HANDLE   hPrinter,
    ULONG    iEsc,
    ULONG    cjIn,
    PVOID    pvIn,
    ULONG    cjOut,
    PVOID    pvOut
    );

#if defined(_X86_) && !defined(USERMODE_DRIVER)

    typedef struct _FLOATOBJ
    {
        ULONG ul1;
        ULONG ul2;
    } FLOATOBJ, *PFLOATOBJ;

    VOID APIENTRY FLOATOBJ_SetFloat(PFLOATOBJ,FLOATL);
    VOID APIENTRY FLOATOBJ_SetLong(PFLOATOBJ,LONG);

    LONG APIENTRY FLOATOBJ_GetFloat(PFLOATOBJ);
    LONG APIENTRY FLOATOBJ_GetLong(PFLOATOBJ);

    VOID APIENTRY FLOATOBJ_AddFloat(PFLOATOBJ,FLOATL);
    VOID APIENTRY FLOATOBJ_AddLong(PFLOATOBJ,LONG);
    VOID APIENTRY FLOATOBJ_Add(PFLOATOBJ,PFLOATOBJ);

    VOID APIENTRY FLOATOBJ_SubFloat(PFLOATOBJ,FLOATL);
    VOID APIENTRY FLOATOBJ_SubLong(PFLOATOBJ,LONG);
    VOID APIENTRY FLOATOBJ_Sub(PFLOATOBJ,PFLOATOBJ);

    VOID APIENTRY FLOATOBJ_MulFloat(PFLOATOBJ,FLOATL);
    VOID APIENTRY FLOATOBJ_MulLong(PFLOATOBJ,LONG);
    VOID APIENTRY FLOATOBJ_Mul(PFLOATOBJ,PFLOATOBJ);

    VOID APIENTRY FLOATOBJ_DivFloat(PFLOATOBJ,FLOATL);
    VOID APIENTRY FLOATOBJ_DivLong(PFLOATOBJ,LONG);
    VOID APIENTRY FLOATOBJ_Div(PFLOATOBJ,PFLOATOBJ);

    VOID APIENTRY FLOATOBJ_Neg(PFLOATOBJ);

    BOOL APIENTRY FLOATOBJ_EqualLong(PFLOATOBJ,LONG);
    BOOL APIENTRY FLOATOBJ_GreaterThanLong(PFLOATOBJ,LONG);
    BOOL APIENTRY FLOATOBJ_LessThanLong(PFLOATOBJ,LONG);

    BOOL APIENTRY FLOATOBJ_Equal(PFLOATOBJ,PFLOATOBJ);
    BOOL APIENTRY FLOATOBJ_GreaterThan(PFLOATOBJ,PFLOATOBJ);
    BOOL APIENTRY FLOATOBJ_LessThan(PFLOATOBJ,PFLOATOBJ);

#else

    // any platform that has support for floats in the kernel

    typedef FLOAT FLOATOBJ;
    typedef FLOAT *PFLOATOBJ;

    #define   FLOATOBJ_SetFloat(pf,f)       {*(pf) = (f);           }
    #define   FLOATOBJ_SetLong(pf,l)        {*(pf) = (FLOAT)(l);    }

    #define   FLOATOBJ_GetFloat(pf)         *((PULONG)pf)
    #define   FLOATOBJ_GetLong(pf)          (LONG)*(pf)

    #define   FLOATOBJ_AddFloat(pf,f)       {*(pf) += f;            }
    #define   FLOATOBJ_AddLong(pf,l)        {*(pf) += (LONG)(l);    }
    #define   FLOATOBJ_Add(pf,pf1)          {*(pf) += *(pf1);       }

    #define   FLOATOBJ_SubFloat(pf,f)       {*(pf) -= f;            }
    #define   FLOATOBJ_SubLong(pf,l)        {*(pf) -= (LONG)(l);    }
    #define   FLOATOBJ_Sub(pf,pf1)          {*(pf) -= *(pf1);       }

    #define   FLOATOBJ_MulFloat(pf,f)       {*(pf) *= f;            }
    #define   FLOATOBJ_MulLong(pf,l)        {*(pf) *= (LONG)(l);    }
    #define   FLOATOBJ_Mul(pf,pf1)          {*(pf) *= *(pf1);       }

    #define   FLOATOBJ_DivFloat(pf,f)       {*(pf) /= f;            }
    #define   FLOATOBJ_DivLong(pf,l)        {*(pf) /= (LONG)(l);    }
    #define   FLOATOBJ_Div(pf,pf1)          {*(pf) /= *(pf1);       }

    #define   FLOATOBJ_Neg(pf)              {*(pf) = -*(pf);        }

    #define   FLOATOBJ_EqualLong(pf,l)          (*(pf) == (FLOAT)(l))
    #define   FLOATOBJ_GreaterThanLong(pf,l)    (*(pf) >  (FLOAT)(l))
    #define   FLOATOBJ_LessThanLong(pf,l)       (*(pf) <  (FLOAT)(l))

    #define   FLOATOBJ_Equal(pf,pf1)            (*(pf) == *(pf1))
    #define   FLOATOBJ_GreaterThan(pf,pf1)      (*(pf) >  *(pf1))
    #define   FLOATOBJ_LessThan(pf,pf1)         (*(pf) <  *(pf1))

#endif // _FLOATOBJ_

#if defined(USERMODE_DRIVER)

typedef XFORML FLOATOBJ_XFORM ;
typedef XFORML *PFLOATOBJ_XFORM;
typedef XFORML FAR *LPFLOATOBJ_XFORM;

#define XFORMOBJ_iGetFloatObjXform XFORMOBJ_iGetXform

#else

typedef struct  tagFLOATOBJ_XFORM
{
    FLOATOBJ eM11;
    FLOATOBJ eM12;
    FLOATOBJ eM21;
    FLOATOBJ eM22;
    FLOATOBJ eDx;
    FLOATOBJ eDy;
} FLOATOBJ_XFORM, *PFLOATOBJ_XFORM, FAR *LPFLOATOBJ_XFORM;

ULONG APIENTRY XFORMOBJ_iGetFloatObjXform(
    XFORMOBJ *pxo,
    FLOATOBJ_XFORM * pfxo
    );

#endif


// SORT specific defines

typedef int (__cdecl *SORTCOMP)(const void *pv1, const void *pv2);

VOID APIENTRY EngSort(
    PBYTE pjBuf,
    ULONG c,
    ULONG cjElem,
    SORTCOMP pfnComp
    );

typedef struct _ENG_TIME_FIELDS {
    USHORT usYear;        // range [1601...]
    USHORT usMonth;       // range [1..12]
    USHORT usDay;         // range [1..31]
    USHORT usHour;        // range [0..23]
    USHORT usMinute;      // range [0..59]
    USHORT usSecond;      // range [0..59]
    USHORT usMilliseconds;// range [0..999]
    USHORT usWeekday;     // range [0..6] == [Sunday..Saturday]
} ENG_TIME_FIELDS, *PENG_TIME_FIELDS;

VOID APIENTRY EngQueryLocalTime(
    PENG_TIME_FIELDS
    );

FD_GLYPHSET* APIENTRY EngComputeGlyphSet(
    INT nCodePage,
    INT nFirstChar,
    INT cChars
    );

INT APIENTRY EngMultiByteToWideChar(
    UINT CodePage,
    LPWSTR WideCharString,
    INT BytesInWideCharString,
    LPSTR MultiByteString,
    INT BytesInMultiByteString
    );

INT APIENTRY EngWideCharToMultiByte(
    UINT CodePage,
    LPWSTR WideCharString,
    INT BytesInWideCharString,
    LPSTR MultiByteString,
    INT BytesInMultiByteString
    );

VOID APIENTRY EngGetCurrentCodePage(
    PUSHORT OemCodePage,
    PUSHORT AnsiCodePage
    );

HANDLE APIENTRY EngLoadModuleForWrite(
    LPWSTR pwsz,
    ULONG  cjSizeOfModule
    );

LARGE_INTEGER APIENTRY EngQueryFileTimeStamp (
    LPWSTR  pwsz
    );

BOOL APIENTRY EngGetFileChangeTime(
    HANDLE          h,
    LARGE_INTEGER   *pChangeTime
    );

BOOL APIENTRY EngGetFilePath(
    IN  HANDLE h ,
    OUT WCHAR (*pDest)[MAX_PATH+1]
    );

ULONG APIENTRY EngSaveFloatingPointState(
    VOID   *pBuffer,
    ULONG   cjBufferSize
    );

BOOL APIENTRY EngRestoreFloatingPointState(
    VOID   *pBuffer
    );

//
// DirectDraw surface locking
//

PDD_SURFACE_LOCAL APIENTRY EngLockDirectDrawSurface(
        HANDLE hSurface
        );

BOOL APIENTRY EngUnlockDirectDrawSurface(
        PDD_SURFACE_LOCAL pSurface
        );

//
//  Engine Event support.
//

//
//  Opaque type for event objects.
//

typedef struct _PENG_EVENT * PEVENT;

//
//  This routine can only be called on PEVENTS returned from EngCreateEvent()
//  and must not be called on PEVENTs returned from EngMapEvent().
//

BOOL APIENTRY EngDeleteEvent(
    IN  PEVENT  pEngEvent
    );

BOOL APIENTRY EngCreateEvent(
    OUT PEVENT *ppEngEvent
    );

//
//  This routine must be called by Display driver process terminate. This routine can only
//  be called on pEvent PEVENTs returned by EngMapEvent(). It must not be called on
//  pEvents returned via EngCreateEvent(). It must not be called in the PDRVCLEANPROC typed
//  below
//

BOOL APIENTRY EngUnmapEvent(
    IN  HDRVOBJ pDrvObj
    );

//
//      PDRVCLEANPROC   pDrvCleanProc    - Pointer to function to be called
//          when the process in whose context this event was mapped
//          terminates. It is a requirement that EngUnmapEvent not be called
//          in this routine.
//

typedef BOOLEAN (APIENTRY *PDRVCLEANPROC)(
    PVOID pDriverCleanupContext
    );

//
//  Can be called by Display driver. This routine returns a valid HDRVOBJ if
//  successful, NULL otherwise.
//
//  Arguments:
//      HDEV            hDev             - Device handle.
//      HANDLE          hUserObject      - user mode HANDLE to event.
//      PEVENT        * ppEvent          - Pointer to ENG_EVENT to be filled.
//          No waiting is allowed on mapped events.
//      PDRVCLEANPROC   pDrvCleanProc    - Pointer to function to be called
//          when the process in whose context this event was mapped
//          terminates. It is a requirement that EngUnmapEvent not be called
//          in this routine.
//      PVOID           pCleanupContext    - Pointer to driver managed resource
//          passed to pEventDeleteProc at process termination.
//
//  Returns:
//      HDRVOBJ - a handle to a DRVOBJ. Important: if the driver wishes to do
//      cleanup itself, it must call EngUnmapEvent on the HDRVOBJ returned
//      from this routine.
//

HDRVOBJ APIENTRY EngMapEvent(
    IN  HDEV            hDev,
    IN  HANDLE          hUserObject,
    OUT PEVENT        * ppEvent,
    IN  PDRVCLEANPROC   pDrvUnmapProc,
    IN  PVOID           pDrvUnmapContext
    );

//
//  May be called by Display driver. Can only be called on events created by
//  the Display driver, not on mapped events. Returns TRUE if successful,
//  FALSE otherwise. FALSE indicates an invalid parameter, which must not
//  be used again.
//

BOOL APIENTRY EngWaitForSingleObject(
    IN  PEVENT          pEngEvent,
    IN  PLARGE_INTEGER  pTimeOut
    );

//
//  PUBLIC, called by Display driver.
//  Private info: Basically a wrapper for KeSetEvent(). Can be called on
//  created or mapped events. Returns TRUE if successful, FALSE otherwise.
//  FALSE indicates an invalid parameter, which must not be used again.
//

BOOL APIENTRY EngSetEvent(
    IN  PEVENT          pEngEvent
    );


//
// Querying of system attributes.
//

typedef enum _ENG_SYSTEM_ATTRIBUTE {
    EngProcessorFeature = 1,
    EngNumberOfProcessors,
    EngOptimumAvailableUserMemory,
    EngOptimumAvailableSystemMemory,
} ENG_SYSTEM_ATTRIBUTE;

#define QSA_MMX 0x00000100

BOOL APIENTRY
EngQuerySystemAttribute(
    ENG_SYSTEM_ATTRIBUTE CapNum,
    PDWORD pCapability);

#define ENG_FNT_CACHE_READ_FAULT    0x1
#define ENG_FNT_CACHE_WRITE_FAULT   0x2

PVOID APIENTRY  EngFntCacheLookUp(ULONG FastCheckSum, ULONG * pulSize);
PVOID APIENTRY  EngFntCacheAlloc(ULONG FastCheckSum, ULONG ulSize);

VOID  APIENTRY  EngFntCacheFault(ULONG ulFastCheckSum, ULONG iFaultMode);

typedef enum _ENG_DEVICE_ATTRIBUTE {
    QDA_RESERVED = 0,
    QDA_ACCELERATION_LEVEL = 1
} ENG_DEVICE_ATTRIBUTE;

BOOL APIENTRY
EngQueryDeviceAttribute(
    HDEV                    hdev,
    ENG_DEVICE_ATTRIBUTE    devAttr,
    VOID *                  pvIn,
    ULONG                   ulInSize,
    VOID *                  pvOUt,
    ULONG                   ulOutSize);

typedef struct
{
   DWORD nSize;
   HDC   hdc;
   PBYTE pvEMF;
   PBYTE pvCurrentRecord;
} EMFINFO, *PEMFINFO;

BOOL APIENTRY
EngQueryEMFInfo(
    HDEV              hdev,
    EMFINFO           *pEMFInfo);

//
// EngProcessorFeature
//

//
// EngNumberOfProcessors
//
// Number of active processors in the machine.
//

//
// EngOptimumAvailableUserMemory
//
// Optimum amount of user-mode memory available to avoid paging.
// Returns the number of bytes for the optimum allocation size
// Memory is allocated via EngAllocUserMem.
//

//
// EngOptimumAvailableSystemMemory
//
// Optimum amount of system memory available to avoid paging.
// Returns the number of bytes for the optimum allocation size.
// Memory is allocated via EngAllocMem.
//

//
// DDI entrypoint function prototypes
//

typedef BOOL   (APIENTRY *PFN_DrvEnableDriver)(ULONG,ULONG,PDRVENABLEDATA);
typedef DHPDEV (APIENTRY *PFN_DrvEnablePDEV) (PDEVMODEW,LPWSTR,ULONG,HSURF*,ULONG,GDIINFO*,ULONG,PDEVINFO,HDEV,LPWSTR,HANDLE);
typedef VOID   (APIENTRY *PFN_DrvCompletePDEV)(DHPDEV,HDEV);
typedef VOID   (APIENTRY *PFN_DrvDisablePDEV)(DHPDEV);
typedef VOID   (APIENTRY *PFN_DrvSynchronize)(DHPDEV,RECTL *);
typedef HSURF  (APIENTRY *PFN_DrvEnableSurface)(DHPDEV);
typedef VOID   (APIENTRY *PFN_DrvDisableDriver)(VOID);
typedef VOID   (APIENTRY *PFN_DrvDisableSurface)(DHPDEV);
typedef BOOL   (APIENTRY *PFN_DrvAssertMode)(DHPDEV, BOOL);
typedef BOOL   (APIENTRY *PFN_DrvTextOut)(SURFOBJ *,STROBJ *,FONTOBJ *,CLIPOBJ *,RECTL *,RECTL *,BRUSHOBJ *,BRUSHOBJ *,POINTL *,MIX);
typedef BOOL   (APIENTRY *PFN_DrvStretchBlt)(SURFOBJ *,SURFOBJ *,SURFOBJ *,CLIPOBJ *,XLATEOBJ *,COLORADJUSTMENT *,POINTL *,RECTL *,RECTL *,POINTL *,ULONG);
typedef BOOL   (APIENTRY *PFN_DrvStretchBltROP)(SURFOBJ *,SURFOBJ *,SURFOBJ *,CLIPOBJ *,XLATEOBJ *,COLORADJUSTMENT *,POINTL *,RECTL *,RECTL *,POINTL *,ULONG, BRUSHOBJ *,ROP4);
typedef BOOL   (APIENTRY *PFN_DrvTransparentBlt)(SURFOBJ *, SURFOBJ *, CLIPOBJ *, XLATEOBJ *, RECTL *, RECTL *, ULONG, ULONG);
typedef BOOL   (APIENTRY *PFN_DrvPlgBlt)(SURFOBJ *,SURFOBJ *,SURFOBJ *,CLIPOBJ *,XLATEOBJ *,COLORADJUSTMENT *,POINTL *,POINTFIX *,RECTL *,POINTL *,ULONG);
typedef BOOL   (APIENTRY *PFN_DrvBitBlt)(SURFOBJ *,SURFOBJ *,SURFOBJ *,CLIPOBJ *,XLATEOBJ *,RECTL *,POINTL *,POINTL *,BRUSHOBJ *,POINTL *,ROP4);
typedef BOOL   (APIENTRY *PFN_DrvRealizeBrush)(BRUSHOBJ *,SURFOBJ *,SURFOBJ *,SURFOBJ *,XLATEOBJ *,ULONG);
typedef BOOL   (APIENTRY *PFN_DrvCopyBits)(SURFOBJ *,SURFOBJ *,CLIPOBJ *,XLATEOBJ *,RECTL *,POINTL *);
typedef ULONG  (APIENTRY *PFN_DrvDitherColor)(DHPDEV, ULONG, ULONG, ULONG *);
typedef HBITMAP (APIENTRY *PFN_DrvCreateDeviceBitmap)(DHPDEV, SIZEL, ULONG);
typedef VOID   (APIENTRY *PFN_DrvDeleteDeviceBitmap)(DHSURF);
typedef BOOL   (APIENTRY *PFN_DrvSetPalette)(DHPDEV, PALOBJ *, FLONG, ULONG, ULONG);
typedef ULONG  (APIENTRY *PFN_DrvEscape)(SURFOBJ *, ULONG, ULONG, PVOID, ULONG, PVOID);
typedef ULONG  (APIENTRY *PFN_DrvDrawEscape)(SURFOBJ *, ULONG, CLIPOBJ *, RECTL *, ULONG, PVOID);
typedef PIFIMETRICS (APIENTRY *PFN_DrvQueryFont)(DHPDEV, ULONG_PTR, ULONG, ULONG *);
typedef PVOID  (APIENTRY *PFN_DrvQueryFontTree)(DHPDEV, ULONG_PTR, ULONG, ULONG, ULONG *);
typedef LONG   (APIENTRY *PFN_DrvQueryFontData)(DHPDEV, FONTOBJ *, ULONG, HGLYPH, GLYPHDATA *, PVOID, ULONG);
typedef VOID   (APIENTRY *PFN_DrvFree)(PVOID, ULONG);
typedef VOID   (APIENTRY *PFN_DrvDestroyFont)(FONTOBJ *);
typedef LONG   (APIENTRY *PFN_DrvQueryFontCaps)(ULONG, ULONG *);
typedef HFF    (APIENTRY *PFN_DrvLoadFontFile)(ULONG, ULONG_PTR *, PVOID *, ULONG *, DESIGNVECTOR *, ULONG, ULONG);
typedef BOOL   (APIENTRY *PFN_DrvUnloadFontFile)(ULONG_PTR);
typedef ULONG  (APIENTRY *PFN_DrvSetPointerShape)(SURFOBJ *, SURFOBJ *, SURFOBJ *,XLATEOBJ *,LONG,LONG,LONG,LONG,RECTL *,FLONG);
typedef VOID   (APIENTRY *PFN_DrvMovePointer)(SURFOBJ *pso,LONG x,LONG y,RECTL *prcl);
typedef BOOL   (APIENTRY *PFN_DrvSendPage)(SURFOBJ *);
typedef BOOL   (APIENTRY *PFN_DrvStartPage)(SURFOBJ *pso);
typedef BOOL   (APIENTRY *PFN_DrvStartDoc)(SURFOBJ *pso, LPWSTR pwszDocName, DWORD dwJobId);
typedef BOOL   (APIENTRY *PFN_DrvEndDoc)(SURFOBJ *pso, FLONG fl);
typedef BOOL   (APIENTRY *PFN_DrvQuerySpoolType)(DHPDEV dhpdev, LPWSTR pwchType);
typedef BOOL   (APIENTRY *PFN_DrvLineTo)(SURFOBJ *,CLIPOBJ *,BRUSHOBJ *,LONG,LONG,LONG,LONG,RECTL *,MIX);
typedef BOOL   (APIENTRY *PFN_DrvStrokePath)(SURFOBJ *,PATHOBJ *,CLIPOBJ *,XFORMOBJ *,BRUSHOBJ *,POINTL *,LINEATTRS *,MIX);
typedef BOOL   (APIENTRY *PFN_DrvFillPath)(SURFOBJ *,PATHOBJ *,CLIPOBJ *,BRUSHOBJ *,POINTL *,MIX,FLONG);
typedef BOOL   (APIENTRY *PFN_DrvStrokeAndFillPath)(SURFOBJ *,PATHOBJ *,CLIPOBJ *,XFORMOBJ *,BRUSHOBJ *,LINEATTRS *,BRUSHOBJ *,POINTL *,MIX,FLONG);
typedef BOOL   (APIENTRY *PFN_DrvPaint)(SURFOBJ *,CLIPOBJ *,BRUSHOBJ *,POINTL *,MIX);
typedef ULONG  (APIENTRY *PFN_DrvGetGlyphMode)(DHPDEV dhpdev,FONTOBJ *pfo);
typedef BOOL   (APIENTRY *PFN_DrvResetPDEV)(DHPDEV dhpdevOld, DHPDEV dhpdevNew);
typedef ULONG_PTR  (APIENTRY *PFN_DrvSaveScreenBits)(SURFOBJ *, ULONG, ULONG_PTR, RECTL *);
typedef ULONG  (APIENTRY *PFN_DrvGetModes)(HANDLE, ULONG, DEVMODEW *);
typedef LONG   (APIENTRY *PFN_DrvQueryTrueTypeTable)(ULONG_PTR, ULONG, ULONG, PTRDIFF, ULONG, BYTE *, PBYTE *, ULONG *);
typedef LONG   (APIENTRY *PFN_DrvQueryTrueTypeSection)(ULONG, ULONG, ULONG, HANDLE *, PTRDIFF *);
typedef LONG   (APIENTRY *PFN_DrvQueryTrueTypeOutline)(DHPDEV, FONTOBJ *, HGLYPH, BOOL, GLYPHDATA *, ULONG, TTPOLYGONHEADER *);
typedef PVOID  (APIENTRY *PFN_DrvGetTrueTypeFile)(ULONG_PTR, ULONG *);
typedef LONG   (APIENTRY *PFN_DrvQueryFontFile)(ULONG_PTR, ULONG, ULONG, ULONG *);
typedef PFD_GLYPHATTR   (APIENTRY *PFN_DrvQueryGlyphAttrs)(FONTOBJ *, ULONG );
typedef BOOL   (APIENTRY *PFN_DrvQueryAdvanceWidths)(DHPDEV,FONTOBJ *,ULONG,HGLYPH *,PVOID,ULONG);
typedef ULONG  (APIENTRY *PFN_DrvFontManagement)(SURFOBJ *,FONTOBJ *,ULONG,ULONG,PVOID,ULONG,PVOID);
typedef BOOL   (APIENTRY *PFN_DrvSetPixelFormat)(SURFOBJ *,LONG,HWND);
typedef LONG   (APIENTRY *PFN_DrvDescribePixelFormat)(DHPDEV,LONG,ULONG,PIXELFORMATDESCRIPTOR *);
typedef BOOL   (APIENTRY *PFN_DrvSwapBuffers)(SURFOBJ *, WNDOBJ *);
typedef BOOL   (APIENTRY *PFN_DrvStartBanding)(SURFOBJ *, POINTL *ppointl);
typedef BOOL   (APIENTRY *PFN_DrvNextBand)(SURFOBJ *, POINTL *ppointl);
typedef BOOL   (APIENTRY *PFN_DrvQueryPerBandInfo)(SURFOBJ *,PERBANDINFO *);
typedef BOOL   (APIENTRY *PFN_DrvEnableDirectDraw)(DHPDEV, DD_CALLBACKS *,DD_SURFACECALLBACKS *, DD_PALETTECALLBACKS *);
typedef VOID   (APIENTRY *PFN_DrvDisableDirectDraw)(DHPDEV);
typedef BOOL   (APIENTRY *PFN_DrvGetDirectDrawInfo)(DHPDEV, DD_HALINFO *, DWORD *, VIDEOMEMORY *, DWORD *, DWORD *);
typedef HANDLE (APIENTRY *PFN_DrvIcmCreateColorTransform)(DHPDEV,LPLOGCOLORSPACEW,LPVOID,ULONG,LPVOID,ULONG,LPVOID,ULONG,DWORD);
typedef BOOL   (APIENTRY *PFN_DrvIcmDeleteColorTransform)(DHPDEV,HANDLE);
typedef BOOL   (APIENTRY *PFN_DrvIcmCheckBitmapBits)(DHPDEV,HANDLE,SURFOBJ *,PBYTE);
typedef BOOL   (APIENTRY *PFN_DrvIcmSetDeviceGammaRamp)(DHPDEV,ULONG,LPVOID);
typedef BOOL   (APIENTRY *PFN_DrvAlphaBlend)(SURFOBJ*,SURFOBJ*,CLIPOBJ*,XLATEOBJ*,PRECTL,PRECTL,BLENDOBJ *);
typedef BOOL   (APIENTRY *PFN_DrvGradientFill)(SURFOBJ*,CLIPOBJ*,XLATEOBJ*,TRIVERTEX*,ULONG,PVOID,ULONG,RECTL *,POINTL *,ULONG);
typedef BOOL   (APIENTRY *PFN_DrvQueryDeviceSupport)(SURFOBJ*,XLATEOBJ*,XFORMOBJ*,ULONG,ULONG,PVOID,ULONG,PVOID);
typedef HBITMAP (APIENTRY *PFN_DrvDeriveSurface)(DD_DIRECTDRAW_GLOBAL*,DD_SURFACE_LOCAL*);
typedef VOID   (APIENTRY *PFN_DrvSynchronizeSurface)(SURFOBJ*, RECTL*, FLONG);
typedef VOID   (APIENTRY *PFN_DrvNotify)(SURFOBJ*, ULONG, PVOID);

#ifdef __cplusplus
}  // extern "C"
#endif

#endif  //  _WINDDI_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\public\oak\inc\winddiui.h ===
/********************************************************************

    WinDDiUi.h -- Header file for the UI portion of printer drivers.

    Copyright (c) 1995 1996, Microsoft Corp.
    All rights reserved.

********************************************************************/

#ifndef _WINDDIUI_
#define _WINDDIUI_

#include <compstui.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef struct _PRINTPROCESSOR_CAPS_1 {
    DWORD     dwLevel;
    DWORD     dwNupOptions;
    DWORD     dwPageOrderFlags;
    DWORD     dwNumberOfCopies;
} PRINTPROCESSOR_CAPS_1, *PPRINTPROCESSOR_CAPS_1;

//
// DrvDevicePropertySheets replace previous version of PrinterProperties
//

LONG
DrvDevicePropertySheets(
    PPROPSHEETUI_INFO   pPSUIInfo,
    LPARAM              lParam
    );

typedef struct _DEVICEPROPERTYHEADER {
    WORD    cbSize;
    WORD    Flags;
    HANDLE  hPrinter;
    LPTSTR  pszPrinterName;
} DEVICEPROPERTYHEADER, *PDEVICEPROPERTYHEADER;

#define DPS_NOPERMISSION    0x0001


//
// For document properties replace DocumentProperties.
//
// Note: if pPSUIInfo is NULL then the call need not to display any dialog
//       boxes (Ignored the DC_PROMPT bit in the fMode, the lParam in this case
//       is a pointer to DOCUMENTPROPERTYHEADER
//

LONG
DrvDocumentPropertySheets(
    PPROPSHEETUI_INFO   pPSUIInfo,
    LPARAM              lParam
    );

typedef struct _DOCUMENTPROPERTYHEADER {
    WORD        cbSize;
    WORD        Reserved;
    HANDLE      hPrinter;
    LPTSTR      pszPrinterName;
    PDEVMODE    pdmIn;
    PDEVMODE    pdmOut;
    DWORD       cbOut;
    DWORD       fMode;
} DOCUMENTPROPERTYHEADER, *PDOCUMENTPROPERTYHEADER;

#define DM_ADVANCED         0x10
#define DM_NOPERMISSION     0x20
#define DM_USER_DEFAULT     0x40


// Devmode conversion function used by GetPrinter and SetPrinter

BOOL
DrvConvertDevMode(
    LPTSTR   pPrinterName,
    PDEVMODE pdmIn,
    PDEVMODE pdmOut,
    PLONG    pcbNeeded,
    DWORD    fMode
    );

#define CDM_CONVERT         0x01
#define CDM_CONVERT351      0x02
#define CDM_DRIVER_DEFAULT  0x04


//
// This is for DevQueryPrintEx()
//

typedef struct _DEVQUERYPRINT_INFO {
    WORD    cbSize;         // size of this structure in bytes
    WORD    Level;          // Level of this info, 1 for this version
    HANDLE  hPrinter;       // handle to the printer for the query
    DEVMODE *pDevMode;      // pointer to the DEVMODE for this job.
    LPTSTR  pszErrorStr;    // pointer to the error string buffer.
    DWORD   cchErrorStr;    // count characters of pwErrorStr passed.
    DWORD   cchNeeded;      // count characters of pwErrorStr needed.
    } DEVQUERYPRINT_INFO, *PDEVQUERYPRINT_INFO;

BOOL
DevQueryPrintEx(
    PDEVQUERYPRINT_INFO pDQPInfo
    );

//
// This for the DrvUpgradePrinter
//

typedef struct _DRIVER_UPGRADE_INFO_1 {
    LPTSTR  pPrinterName;
    LPTSTR  pOldDriverDirectory;
} DRIVER_UPGRADE_INFO_1, *PDRIVER_UPGRADE_INFO_1;

typedef struct _DRIVER_UPGRADE_INFO_2 {
    LPTSTR   pPrinterName;
    LPTSTR   pOldDriverDirectory;
    DWORD    cVersion;
    LPTSTR   pName;
    LPTSTR   pEnvironment;
    LPTSTR   pDriverPath;
    LPTSTR   pDataFile;
    LPTSTR   pConfigFile;
    LPTSTR   pHelpFile;
    LPTSTR   pDependentFiles;
    LPTSTR   pMonitorName;
    LPTSTR   pDefaultDataType;
    LPTSTR   pszzPreviousNames;
} DRIVER_UPGRADE_INFO_2, *PDRIVER_UPGRADE_INFO_2;
    
BOOL
DrvUpgradePrinter(
    DWORD   Level,
    LPBYTE  pDriverUpgradeInfo
    );

//
// DrvDocumentEvent
//
//
//  Defines and proto-types for hooking GDI printer management functions
//
//  return values: -1 means error, 0 means not supported function
//
//  CreateDCPre must return > 0 or none of the others will be called.
//
//
//  CREATEDCPRE
//      return failure from CreateDC if this fails, CREATEDCPOST not called
//      bIC - TRUE if came from CreateIC
//      output devmode - this is the devmode that actualy gets passed to the
//      server side driver.  Any data needed in EnablePDEV should be passed
//      as part of the DriverExtra.
//
//  CREATEDCPOST
//      return value is ignored
//      the hdc will be 0 if something failed since CREATEDCPRE
//      The input buffer contains a pointer to the devmode returned in the
//      CREATEDCPRE output buffer
//
//  RESETDCPRE
//      return failure from ResetDC if this fails, CREATEDCPOST not called
//
//  RESETDCPOST
//      return value is ignored
//
//  STARTDOCPRE
//      return failure form StartDoc if this fails, driver not called
//
//  STARTDOCPOST
//      return failure form StartDoc if this fails, driver already called.
//      AbortDoc() called.
//
//  STARTPAGE
//      return failure form EndPage if this fails, driver not called
//
//  ENDPAGE
//      return value is ignored, DrvEndPage always called
//
//  ENDDOCPRE
//      return value is ignored, DrvEndDoc always called
//
//  ENDDOCPOST
//      return value is ignored, DrvEndDoc has alreadybeen called
//
//  ABORTDOC
//      return value is ignored
//
//  DELETEDC
//      return value is ignored
//
//  EXTESCAPE
//      return value is ignored
//      The input buffer includes the ExtEscape escape value, size of input
//      buffer to ExtEscape and the input buffer passed in.
//      The output buffer is just the buffer that was passed to ExtEscape
//
//  DOCUMENTEVENT_SPOOLED
//      This flag is added to the iEsc value if the document is being spooled
//      to a metafile rather than going direct.  Note that if this bit is set
//
//

#define DOCUMENTEVENT_EVENT(iEsc) (LOWORD(iEsc))
#define DOCUMENTEVENT_FLAGS(iEsc) (HIWORD(iEsc))

//
// Escape codes for DrvDocumentEvent
//

#define DOCUMENTEVENT_FIRST         1   // Inclusive lower bound
#define DOCUMENTEVENT_CREATEDCPRE   1   // in-pszDriver, pszDevice, pdm, bIC, out-ppdm
#define DOCUMENTEVENT_CREATEDCPOST  2   // in-ppdm
#define DOCUMENTEVENT_RESETDCPRE    3   // in-pszDriver, pszDevice, pdm, out-ppdm
#define DOCUMENTEVENT_RESETDCPOST   4   // in-ppdm
#define DOCUMENTEVENT_STARTDOC      5   // none
#define DOCUMENTEVENT_STARTDOCPRE   5   // none
#define DOCUMENTEVENT_STARTPAGE     6   // none
#define DOCUMENTEVENT_ENDPAGE       7   // none
#define DOCUMENTEVENT_ENDDOC        8   // none
#define DOCUMENTEVENT_ENDDOCPRE     8   // none
#define DOCUMENTEVENT_ABORTDOC      9   // none
#define DOCUMENTEVENT_DELETEDC     10   // none
#define DOCUMENTEVENT_ESCAPE       11   // in-iEsc, cjInBuf, inBuf, out-outBuf
#define DOCUMENTEVENT_ENDDOCPOST   12   // none
#define DOCUMENTEVENT_STARTDOCPOST 13   // none
#define DOCUMENTEVENT_LAST         14   // Non-inclusive upper bound

#define DOCUMENTEVENT_SPOOLED   0x10000

//
// Return values for DrvDocumentEvent
//

#define DOCUMENTEVENT_SUCCESS     1
#define DOCUMENTEVENT_UNSUPPORTED 0
#define DOCUMENTEVENT_FAILURE     -1

int
DrvDocumentEvent(
    HANDLE  hPrinter,
    HDC     hdc,
    int     iEsc,
    ULONG   cbIn,
    PULONG  pbIn,
    ULONG   cbOut,
    PULONG  pbOut
);


//
// DrvPrinterEvent
//
//
//    DrvPrinterEvent are called by the print subsystem when events
//    happen that might be of interest to a printer driver
//    The only event which should be implemented in the driver
//    is PRITNER_EVENT_INITIALIZE so that default settings are created
//    for the printer.
//
// PRINTER_EVENT_ADD_CONNECTION
//        return value ignored
//        Called after a successful AddPrinterConnection API
//        in the context of the calling app
//        lParam NULL
//
// PRINTER_EVENT_DELETE_CONNECTION
//        return value ignored
//        Called Before DeletePrinterConnect API
//        in the context of the calling app
//        lParam NULL
//
// PRINTER_EVENT_INITIALIZE
//        Called when a printer is created for the driver to
//        initialize its registry settings
//        Called in the spooler process
//        lParam NULL
//
// PRINTER_EVENT_DELETE
//        Called when a printer is about to be deleted
//        Called in the spooler process
//        lParam NULL
//
// PRINTER_EVENT_CACHE_REFRESH
//        return value ignored
//        called in spooler process
//        No UI
//        called when spooler detects that something has
//        changed in the workstaion cache or when establishing
//        the cache.
//        allows driver to update any private cache data
//        ( such as font files etc. )
//
// PRINTER_EVENT_CACHE_DELETE
//        return value ignored
//        called in spooler process
//        No UI
//        called when spooler is deleting a cached printer
//        allows printer driver to delete anything it has
//        cached
//
// PRINTER_EVENT_FLAG_NO_UI
//        Do not bring up UI when this flag it ON
//

//
// DrvPrinterEvent DriverEvent code
//

#define PRINTER_EVENT_ADD_CONNECTION            1
#define PRINTER_EVENT_DELETE_CONNECTION         2
#define PRINTER_EVENT_INITIALIZE                3
#define PRINTER_EVENT_DELETE                    4
#define PRINTER_EVENT_CACHE_REFRESH             5
#define PRINTER_EVENT_CACHE_DELETE              6

//
// DrvPrinterEvent Flags
//

#define PRINTER_EVENT_FLAG_NO_UI        0x00000001


BOOL
DrvPrinterEvent(
    LPWSTR  pPrinterName,
    int     DriverEvent,
    DWORD   Flags,
    LPARAM  lParam
);

//
// DrvDriverEvent is called when any version of the printer driver is deleted.
//
#define DRIVER_EVENT_INITIALIZE        0x00000001
#define DRIVER_EVENT_DELETE            0x00000002

BOOL
DrvDriverEvent(
    DWORD   dwDriverEvent,
    DWORD   dwLevel,
    LPBYTE  pDriverInfo,
    LPARAM  lParam
);

// Print processor capabilities for the driver.
#define BORDER_PRINT                   0x00000000        // default
#define NO_BORDER_PRINT                0x00000001

#define NORMAL_PRINT                   0x00000000        // default
#define REVERSE_PRINT                  0x00000001
#define BOOKLET_PRINT                  0x00000002

#define NO_COLOR_OPTIMIZATION          0x00000000        // default
#define COLOR_OPTIMIZATION             0x00000001

typedef struct _ATTRIBUTE_INFO_1 {
    DWORD    dwJobNumberOfPagesPerSide;
    DWORD    dwDrvNumberOfPagesPerSide;
    DWORD    dwNupBorderFlags;
    DWORD    dwJobPageOrderFlags;
    DWORD    dwDrvPageOrderFlags;
    DWORD    dwJobNumberOfCopies;
    DWORD    dwDrvNumberOfCopies;
} ATTRIBUTE_INFO_1, *PATTRIBUTE_INFO_1;

typedef struct _ATTRIBUTE_INFO_2 {
    DWORD    dwJobNumberOfPagesPerSide;
    DWORD    dwDrvNumberOfPagesPerSide;
    DWORD    dwNupBorderFlags;
    DWORD    dwJobPageOrderFlags;
    DWORD    dwDrvPageOrderFlags;
    DWORD    dwJobNumberOfCopies;
    DWORD    dwDrvNumberOfCopies;
    DWORD    dwColorOptimization;           // Added for monochrome optimization
} ATTRIBUTE_INFO_2, *PATTRIBUTE_INFO_2;

typedef struct _ATTRIBUTE_INFO_3 {
    DWORD    dwJobNumberOfPagesPerSide;
    DWORD    dwDrvNumberOfPagesPerSide;
    DWORD    dwNupBorderFlags;
    DWORD    dwJobPageOrderFlags;
    DWORD    dwDrvPageOrderFlags;
    DWORD    dwJobNumberOfCopies;
    DWORD    dwDrvNumberOfCopies;
    DWORD    dwColorOptimization;           // Added for monochrome optimization
    short    dmPrintQuality;                // Added for monochrome optimization
    short    dmYResolution;                 // Added for monochrome optimization
} ATTRIBUTE_INFO_3, *PATTRIBUTE_INFO_3;


//
// DrvQueryJobAttributes is called by the spooler(print processor) to get information
// about the printing options used with the job. These options include N-up and reverse
// order printing.
//
BOOL
DrvQueryJobAttributes(
    HANDLE      hPrinter,
    PDEVMODE    pDevMode,
    DWORD       dwLevel,
    LPBYTE      lpAttributeInfo
);

//
// DrvQueryColorProfile is called by the GDI (graphics device interface) to get information
// about the default color profile for the given DEVMODE, used with ICM (image color
// management).
//
BOOL
DrvQueryColorProfile(
    HANDLE      hPrinter,
    PDEVMODEW   pdevmode,
    ULONG       ulQueryMode,
    VOID       *pvProfileData,
    ULONG      *pcbProfileData,
    FLONG      *pflProfileData
);

// The value for ulQueryMode
#define QCP_DEVICEPROFILE   0x0000
#define QCP_SOURCEPROFILE   0x0001

// The flags for pflProfileData.
#define QCP_PROFILEMEMORY  0x0001 // The pvProfileData points the color profile data itself.
#define QCP_PROFILEDISK    0x0002 // The pvProfileData points the color profile file name in Unicode.

//
//  User Mode Printer Driver DLL,
//
//  Note on hPrinter passed into DrvSplStartDoc() and subsequent
//  DrvSplxxx calls
//
//
//  A. If you have DrvSplxxxx calls in separate DLL and link it with
//     spoolss.lib.
//
//      * The hPrinter will be valid for any call to the spooler, such as
//        WritePrinter(), GetPrinterData()
//
//      * To do this you must
//
//          1. Have separate DLL for all DrvSplxxx functions.
//          2. Put this DLL name into your dependency files (inf).
//          3. link to spoolss.lib rather than winspool.lib
//          4. Use SetPrinterData() with SPLPRINTER_USER_MODE_PRINTER_DRIVER
//             as key name, and this DLL name as data.
//          5. Call any spooler functions linked from spoolss.lib
//
//
//
//  B. If you have DrvSplxxx calls located in your printer driver UI DLL and
//     linked with winspool.lib
//
//      * The hPrinter is NOT valid for any spooler calls, such as
//        WritePrinter(), GetPrinterData() from within the DrvSplxxx driver
//        functions.
//
//      * To do any spooler call from inside of DrvSplxxxx function you must
//        do the following
//
//          1. hSpoolSS = LoadLibrary("spoolss.dll");
//          2. pfn = GetProcAddress("WritePrinter") or whatever the spooler
//             functions you wish to call
//          3. Call the pfn function pointer returned from GetProcAddress()
//          4. FreeLibrary(hSpoolSS);
//
//
//  The A method is recommended.
//
//
//  If a UserModePrinterDriver DLL is created the following routines are
//  required or optional
//
//  Required Routines
//      DrvSplStartDoc
//      DrvSplWritePrinter
//      DrvSplEndDoc
//      DrvSplClose
//
//
//  Optional Routines
//      DrvSplStart
//      DrvSplEndPage
//      DrvSplAbort
//
//


HANDLE
DrvSplStartDoc(
    HANDLE  hPrinter,
    DWORD   JobId
);


BOOL
DrvSplWritePrinter(
    HANDLE  hDriver,
    LPVOID  pBuf,
    DWORD   cbBuf,
    LPDWORD pcWritten
);

VOID
DrvSplEndDoc(
    HANDLE  hDriver
);


VOID
DrvSplClose(
    HANDLE  hDriver
);


BOOL
DrvSplStartPage(
    HANDLE  hDriver
);

BOOL
DrvSplEndPage(
    HANDLE  hDriver
);

VOID
DrvSplAbort(
    HANDLE  hDriver
);



//
//  Printer Attribute
//  Use with SetPrinterData to define UMPD.DLL
//

#define SPLPRINTER_USER_MODE_PRINTER_DRIVER     TEXT("SPLUserModePrinterDriver")


#ifdef __cplusplus
}
#endif

#endif  /* !_WINDDIUI_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\public\oak\inc\minidrv.h ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    minidrv.h

Abstract:

    Common header file for Plug-in minidrivers.

Environment:

    Windows NT printer drivers

Revision History:


--*/


#ifndef _MINIDRV_H_
#define _MINIDRV_H_

#include <stddef.h>
#include <stdlib.h>

#include <objbase.h>

#include <stdarg.h>
#include <windef.h>
#include <winerror.h>
#include <winbase.h>
#include <wingdi.h>
#include <winddi.h>
#include <tchar.h>
#include <excpt.h>

//
// defined(KERNEL_MODE) Rendering module DLL in either kernel mode or user mode.
// defined(KERNEL_MODE) & defined(USERMODE_DRIVER) User mode rendering DLL
// !defined(KERNEL_MODE) UI module
//

#if defined(KERNEL_MODE) && !defined(USERMODE_DRIVER)
// Kernel mode rendering DLL
#include "winsplkm.h"
#else
// User mode DLL
#include <winspool.h>
#endif

#if !defined(KERNEL_MODE)
// UI DLL
#include <windows.h>
#include <compstui.h>
#include <winddiui.h>
#endif

#if defined(USERMODE_DRIVER) || !defined(KERNEL_MODE)
// UI DLL or User mode rendering DLL
#include <stdio.h>
#endif

#ifdef __cplusplus
extern "C" {
#endif


#ifdef WINNT_40
//
// The LONG_PTR is guaranteed to be the same size as a pointer.  Its
// size with change with pointer size (32/64).  It should be used
// anywhere that a pointer is cast to an integer type. ULONG_PTR is
//

typedef long LONG_PTR, *PLONG_PTR;
typedef unsigned long ULONG_PTR, *PULONG_PTR;
typedef int INT_PTR, *PINT_PTR;
typedef unsigned int UINT_PTR, *PUINT_PTR;
typedef ULONG_PTR DWORD_PTR, *PDWORD_PTR;


#define HandleToUlong( h ) ((ULONG) (h) )
#define PtrToUlong( p )    ((ULONG) (p) )
#define PtrToLong( p )     ((LONG) (p) )
#define PtrToUshort( p )   ((unsigned short) (p) )
#define PtrToShort( p )    ((short) (p) )

#define GWLP_USERDATA       GWL_USERDATA
#define DWLP_USER           DWL_USER
#define DWLP_MSGRESULT      0
#define SetWindowLongPtr    SetWindowLong
#define GetWindowLongPtr    GetWindowLong

#endif // WINNT_40

#include <printoem.h>
#include <prntfont.h>

//
// These macros are used for debugging purposes. They expand
// to white spaces on a free build. Here is a brief description
// of what they do and how they are used:
//
// giDebugLevel
//  Global variable which set the current debug level to control
//  the amount of debug messages emitted.
//
// VERBOSE(msg)
//  Display a message if the current debug level is <= DBG_VERBOSE.
//
// TERSE(msg)
//  Display a message if the current debug level is <= DBG_TERSE.
//
// WARNING(msg)
//  Display a message if the current debug level is <= DBG_WARNING.
//  The message format is: WRN filename (linenumber): message
//
// ERR(msg)
//  Similiar to WARNING macro above - displays a message
//  if the current debug level is <= DBG_ERROR.
//
// ASSERT(cond)
//  Verify a condition is true. If not, force a breakpoint.
//
// ASSERTMSG(cond, msg)
//  Verify a condition is true. If not, display a message and
//  force a breakpoint.
//
// RIP(msg)
//  Display a message and force a breakpoint.
//
// Usage:
//  These macros require extra parantheses for the msg argument
//  example, ASSERTMSG(x > 0, ("x is less than 0\n"));
//           WARNING(("App passed NULL pointer, ignoring...\n"));
//

#define DBG_VERBOSE 1
#define DBG_TERSE   2
#define DBG_WARNING 3
#define DBG_ERROR   4
#define DBG_RIP     5

#if DBG

extern INT giDebugLevel;

#if defined(KERNEL_MODE) && !defined(USERMODE_DRIVER)

extern VOID DbgPrint(PCSTR, ...);
#define DbgBreakPoint EngDebugBreak

#else

extern ULONG _cdecl DbgPrint(PCSTR, ...);
extern VOID DbgBreakPoint(VOID);

#endif

#define DBGMSG(level, prefix, msg) { \
            if (giDebugLevel <= (level)) { \
                DbgPrint("%s %s (%d): ", prefix, __FILE__, __LINE__); \
                DbgPrint msg; \
            } \
        }

#define DBGPRINT(level, msg) { \
            if (giDebugLevel <= (level)) { \
                DbgPrint msg; \
            } \
        }

#define VERBOSE(msg) DBGPRINT(DBG_VERBOSE, msg)
#define TERSE(msg) DBGPRINT(DBG_TERSE, msg)
#define WARNING(msg) DBGMSG(DBG_WARNING, "WRN", msg)
#define ERR(msg) DBGMSG(DBG_ERROR, "ERR", msg)

#ifndef __MDT__                 // Don't redefine ASSERT when included in MINIDEV.EXE.
#define ASSERT(cond) { \
            if (! (cond)) { \
                RIP(("\n")); \
            } \
        }
#endif

#define ASSERTMSG(cond, msg) { \
            if (! (cond)) { \
                RIP(msg); \
            } \
        }

#define RIP(msg) { \
            DBGMSG(DBG_RIP, "RIP", msg); \
            DbgBreakPoint(); \
        }


#else // !DBG

#define VERBOSE(msg)
#define TERSE(msg)
#define WARNING(msg)
#define ERR(msg)

#ifndef __MDT__                 // Don't redefine ASSERT when included in MINIDEV.EXE.
#define ASSERT(cond)
#endif

#define ASSERTMSG(cond, msg)
#define RIP(msg)
#define DBGMSG(level, prefix, msg)
#define DBGPRINT(level, msg)

#endif

//
// The following macros let you enable tracing on per-file and per-function level.
// To use these macros in a file, here is what you should do:
//
// At the beginning of the file (after header includes):
//
//  Define a bit constant for each function you want to trace
//  Add the following line
//      DEFINE_FUNCTION_TRACE_FLAGS(flags);
//  where flags is a bit-wise OR of the functions you want to trace, e.g.
//      TRACE_FLAG_FUNC1 | TRACE_FLAG_FUNC2 | ...
//
//  To generate trace inside each function you want to trace, use:
//      FUNCTION_TRACE(FunctionTraceFlag, (args));
//

#if DBG

#define DEFINE_FUNCTION_TRACE_FLAGS(flags) \
        static DWORD gdwFunctionTraceFlags = (flags)

#define FUNCTION_TRACE(flag, args) { \
            if (gdwFunctionTraceFlags & (flag)) { \
                DbgPrint args; \
            } \
        }

#else // !DBG

#define DEFINE_FUNCTION_TRACE_FLAGS(flags)
#define FUNCTION_TRACE(flag, args)

#endif // !DBG


//
// Memory allocation function macros
//
#define MemAlloc(size)      ((PVOID) LocalAlloc(LMEM_FIXED, (size)))
#define MemAllocZ(size)     ((PVOID) LocalAlloc(LPTR, (size)))
#define MemFree(p)          { if (p) LocalFree((HLOCAL) (p)); }


//
// DBCS CharSet handling macros
//
//
// 128: SHIFTJIS_CHARSET
// 129: HANGEUL_CHARSET
// 130: JOHAB_CHARSET (defined if WINVER >= 0x0400)
// 134: GB2312_CHARSET
// 136: CHINESEBIG5_CHARSET

#define IS_DBCSCHARSET(j) \
    (((j) == SHIFTJIS_CHARSET)    || \
    ((j) == HANGEUL_CHARSET)     || \
    ((j) == JOHAB_CHARSET)       || \
    ((j) == GB2312_CHARSET)      || \
    ((j) == CHINESEBIG5_CHARSET))

//  932: Japan
//  936: Chinese (PRC, Singapore)
//  949: Korean
//  950: Chinese (Taiwan Region, Hong Kong S.A.R., P.R.C.)
// 1361: Korean (Johab)

#define IS_DBCSCODEPAGE(j) \
    (((j) == 932)   || \
    ((j) == 936)   || \
    ((j) == 949)   || \
    ((j) == 950)   || \
    ((j) == 1361))


//
//  The following are the resource types used in minidrivers and
//  used in the .rc file.
//

#define RC_TABLES      257
#define RC_FONT        258
#define RC_TRANSTAB    259

//
// 5.0 resource types
//

#define RC_UFM         260
#define RC_GTT         261
#define RC_HTPATTERN   264
//
// Internal resource type
//

#define RC_FD_GLYPHSET 262

#ifdef __cplusplus
}
#endif

#endif //_MINIDRV_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\public\sdk\inc\accprov.h ===
//+-------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993-1999.
//
//  File:        accprov.h
//
//  Contents:    public provider independent access control header file
//
//  History:     8-94        Created         DaveMont
//
//--------------------------------------------------------------------
#ifndef __ACCPROV_H__
#define __ACCPROV_H__

#if _MSC_VER > 1000
#pragma once
#endif

#include <windows.h>
#include <accctrl.h>

#ifdef __cplusplus
extern "C" {
#endif

//
// Flags
//
#define ACTRL_CAP_NONE              0x00000000L // No special capabilities
#define ACTRL_CAP_KNOWS_SIDS        0x00000001L // Understands/handles SIDS
#define ACTRL_CAP_SUPPORTS_HANDLES  0x00000002L // Does handle based calls

#define ACTRL_CLASS_GENERAL         0x00000000L // Capabilities class

//
// interfaces...
//

//
// Capabilities
//
VOID
WINAPI
AccProvGetCapabilities(IN  ULONG   fClass,
                       OUT PULONG  pulCaps);

typedef VOID (WINAPI *pfAccProvGetCaps) (ULONG  fClass,
                                         PULONG pulCaps);


//
// Accessibility
//
DWORD
WINAPI
AccProvIsObjectAccessible(IN  LPCWSTR           pwszObjectPath,
                          IN  SE_OBJECT_TYPE    ObjType);

DWORD
WINAPI
AccProvHandleIsObjectAccessible(IN  HANDLE          hObject,
                                IN  SE_OBJECT_TYPE  ObjType);

typedef DWORD (WINAPI *pfAccProvObjAccess)
                                    (LPCWSTR            pwszObjectPath,
                                     SE_OBJECT_TYPE     ObjectType);

typedef DWORD (WINAPI *pfAccProvHandleObjAccess)
                                    (HANDLE             hObject,
                                     SE_OBJECT_TYPE     ObjectType);



//
// Access / auditing requests
//
DWORD
WINAPI
AccProvGrantAccessRights(IN  LPCWSTR                pwszPath,
                         IN  SE_OBJECT_TYPE         ObjectType,
                         IN  PACTRL_ACCESS          pAccessList,
                         IN  PACTRL_AUDIT           pAuditList,
                         IN  PACTRL_OVERLAPPED      pOverlapped);

DWORD
WINAPI
AccProvGrantHandleAccessRights(IN  HANDLE               hObject,
                               IN  SE_OBJECT_TYPE       ObjectType,
                               IN  PACTRL_ACCESS        pAccessList,
                               IN  PACTRL_AUDIT         pAuditList,
                               IN  PACTRL_OVERLAPPED    pOverlapped);

typedef DWORD (WINAPI *pfAccProvAddRights) (LPCWSTR              lpObject,
                                           SE_OBJECT_TYPE       ObjectType,
                                           PACTRL_ACCESS        pAccessList,
                                           PACTRL_AUDIT         pAuditList,
                                           PACTRL_OVERLAPPED    pOverlapped);
typedef DWORD (WINAPI *pfAccProvHandleAddRights) (
                                           HANDLE              hObject,
                                           SE_OBJECT_TYPE       ObjectType,
                                           PACTRL_ACCESS        pAccessList,
                                           PACTRL_AUDIT         pAuditList,
                                           PACTRL_OVERLAPPED    pOverlapped);


DWORD
WINAPI
AccProvSetAccessRights(IN  LPCWSTR              pwszPath,
                       IN  SE_OBJECT_TYPE       ObjectType,
                       IN  SECURITY_INFORMATION SecurityInfo,
                       IN  PACTRL_ACCESS        pAccessList,
                       IN  PACTRL_AUDIT         pAuditList,
                       IN  PTRUSTEE             pOwner,
                       IN  PTRUSTEE             pGroup,
                       IN  PACTRL_OVERLAPPED    pOverlapped);

DWORD
WINAPI
AccProvHandleSetAccessRights(IN  HANDLE               hObject,
                             IN  SE_OBJECT_TYPE       ObjectType,
                             IN  SECURITY_INFORMATION SecurityInfo,
                             IN  PACTRL_ACCESS        pAccessList,
                             IN  PACTRL_AUDIT         pAuditList,
                             IN  PTRUSTEE             pOwner,
                             IN  PTRUSTEE             pGroup,
                             IN  PACTRL_OVERLAPPED    pOverlapped);

typedef DWORD (WINAPI *pfAccProvSetRights) (LPCWSTR              lpObject,
                                           SE_OBJECT_TYPE       ObjectType,
                                           SECURITY_INFORMATION SecurityInfo,
                                           PACTRL_ACCESS        pAccessList,
                                           PACTRL_AUDIT         pAuditList,
                                           PTRUSTEE             pOwner,
                                           PTRUSTEE             pGroup,
                                           PACTRL_OVERLAPPED    pOverlapped);

typedef DWORD (WINAPI *pfAccProvHandleSetRights) (
                                           HANDLE               hObject,
                                           SE_OBJECT_TYPE       ObjectType,
                                           SECURITY_INFORMATION SecurityInfo,
                                           PACTRL_ACCESS        pAccessList,
                                           PACTRL_AUDIT         pAuditList,
                                           PTRUSTEE             pOwner,
                                           PTRUSTEE             pGroup,
                                           PACTRL_OVERLAPPED    pOverlapped);





DWORD
WINAPI
AccProvRevokeAccessRights(IN  LPCWSTR           pwszPath,
                          IN  SE_OBJECT_TYPE    ObjectType,
                          IN  LPCWSTR           pwszProperty,
                          IN  ULONG             cTrustees,
                          IN  PTRUSTEE          prgTrustees,
                          IN  PACTRL_OVERLAPPED pOverlapped);

DWORD
WINAPI
AccProvHandleRevokeAccessRights(IN  HANDLE              hObject,
                                IN  SE_OBJECT_TYPE      ObjectType,
                                IN  LPCWSTR             pwszProperty,
                                IN  ULONG               cTrustees,
                                IN  PTRUSTEE            prgTrustees,
                                IN  PACTRL_OVERLAPPED   pOverlapped);

DWORD
WINAPI
AccProvRevokeAuditRights(IN  LPCWSTR            pwszPath,
                         IN  SE_OBJECT_TYPE     ObjectType,
                         IN  LPCWSTR            pwszProperty,
                         IN  ULONG              cTrustees,
                         IN  PTRUSTEE           prgTrustees,
                         IN  PACTRL_OVERLAPPED  pOverlapped);

DWORD
WINAPI
AccProvHandleRevokeAuditRights(IN  HANDLE               hObject,
                               IN  SE_OBJECT_TYPE       ObjectType,
                               IN  LPCWSTR              pwszProperty,
                               IN  ULONG                cTrustees,
                               IN  PTRUSTEE             prgTrustees,
                               IN  PACTRL_OVERLAPPED    pOverlapped);


typedef DWORD (WINAPI *pfAccProvRevoke) (LPCWSTR            lpObject,
                                         SE_OBJECT_TYPE     ObjectType,
                                         LPCWSTR            pwszProperty,
                                         ULONG              cTrustees,
                                         PTRUSTEE           pTrusteeList,
                                         PACTRL_OVERLAPPED  pOverlapped);


typedef DWORD (WINAPI *pfAccProvHandleRevoke) (
                                         HANDLE             hObject,
                                         SE_OBJECT_TYPE     ObjectType,
                                         LPCWSTR            pwszProperty,
                                         ULONG              cTrustees,
                                         PTRUSTEE           pTrusteeList,
                                         PACTRL_OVERLAPPED  pOverlapped);


DWORD
WINAPI
AccProvGetAllRights(IN  LPCWSTR             pwszPath,
                    IN  SE_OBJECT_TYPE      ObjectType,
                    IN  LPCWSTR             pwszProperty,
                    OUT PACTRL_ACCESS      *ppAccessList,
                    OUT PACTRL_AUDIT       *ppAuditList,
                    OUT PTRUSTEE           *ppOwner,
                    OUT PTRUSTEE           *ppGroup);

DWORD
WINAPI
AccProvHandleGetAllRights(IN  HANDLE              hObject,
                          IN  SE_OBJECT_TYPE      ObjectType,
                          IN  LPCWSTR             pwszProperty,
                          OUT PACTRL_ACCESS      *ppAccessList,
                          OUT PACTRL_AUDIT       *ppAuditList,
                          OUT PTRUSTEE           *ppOwner,
                          OUT PTRUSTEE           *ppGroup);


typedef DWORD (WINAPI *pfAccProvGetRights) (LPCWSTR             lpObject,
                                            SE_OBJECT_TYPE      ObjectType,
                                            LPCWSTR             pwszProperty,
                                            PACTRL_ACCESS      *ppAccessList,
                                            PACTRL_AUDIT       *ppAuditList,
                                            PTRUSTEE           *ppOwner,
                                            PTRUSTEE           *ppGroup);

typedef DWORD (WINAPI *pfAccProvHandleGetRights) (
                                            HANDLE              hObject,
                                            SE_OBJECT_TYPE      ObjectType,
                                            LPCWSTR             pwszProperty,
                                            PACTRL_ACCESS      *ppAccessList,
                                            PACTRL_AUDIT       *ppAuditList,
                                            PTRUSTEE           *ppOwner,
                                            PTRUSTEE           *ppGroup);


//
// Access/Audit results
//
DWORD
WINAPI
AccProvGetTrusteesAccess(IN LPCWSTR             pwszPath,
                         IN SE_OBJECT_TYPE      ObjectType,
                         IN PTRUSTEE            pTrustee,
                         IN OUT PTRUSTEE_ACCESS pTrusteeAccess);

DWORD
WINAPI
AccProvHandleGetTrusteesAccess(IN HANDLE              hObject,
                               IN SE_OBJECT_TYPE      ObjectType,
                               IN PTRUSTEE            pTrustee,
                               IN OUT PTRUSTEE_ACCESS pTrusteeAccess);

typedef DWORD   (WINAPI *pfAccProvTrusteeAccess)
                                          (LPCWSTR            pwszPath,
                                           SE_OBJECT_TYPE     ObjectType,
                                           PTRUSTEE           pTrustee,
                                           PTRUSTEE_ACCESS    pTrusteeAccess);

typedef DWORD   (WINAPI *pfAccProvHandleTrusteeAccess)
                                          (HANDLE             hObject,
                                           SE_OBJECT_TYPE     ObjectType,
                                           PTRUSTEE           pTrustee,
                                           PTRUSTEE_ACCESS    pTrusteeAccess);

DWORD
WINAPI
AccProvIsAccessAudited(IN  LPCWSTR          pwszPath,
                       IN  SE_OBJECT_TYPE   ObjectType,
                       IN  LPCWSTR          pwszProperty,
                       IN  PTRUSTEE         pTrustee,
                       IN  ACCESS_RIGHTS    AuditRights,
                       OUT PBOOL            pfAuditedSuccess,
                       OUT PBOOL            pfAuditedFailure);

DWORD
WINAPI
AccProvHandleIsAccessAudited(IN  HANDLE           hObject,
                             IN  SE_OBJECT_TYPE   ObjectType,
                             IN  LPCWSTR          pwszProperty,
                             IN  PTRUSTEE         pTrustee,
                             IN  ACCESS_RIGHTS    AuditRights,
                             OUT PBOOL            pfAuditedSuccess,
                             OUT PBOOL            pfAuditedFailure);


typedef DWORD (WINAPI *pfAccProvAccessAudit)
                                     (LPCWSTR           pwszObjectPath,
                                      SE_OBJECT_TYPE    ObjectType,
                                      LPCWSTR           pwszProperty,
                                      TRUSTEE           Trustee,
                                      ACCESS_RIGHTS     ulRequestedRights,
                                      PBOOL             pfAuditedSuccess,
                                      PBOOL             pfAuditedFailure);

typedef DWORD (WINAPI *pfAccProvHandleAccessAudit)
                                     (HANDLE            hObject,
                                      SE_OBJECT_TYPE    ObjectType,
                                      LPCWSTR           pwszProperty,
                                      TRUSTEE           Trustee,
                                      ACCESS_RIGHTS     ulRequestedRights,
                                      PBOOL             pfAuditedSuccess,
                                      PBOOL             pfAuditedFailure);


DWORD
WINAPI
AccProvGetAccessInfoPerObjectType(IN   LPCWSTR               lpObject,
                                  IN   SE_OBJECT_TYPE        ObjectType,
                                  IN   LPCWSTR               lpProperty,
                                  OUT  PULONG                pcEntries,
                                  OUT  PACTRL_ACCESS_INFO   *ppAccessInfoList,
                                  OUT  PULONG                pcRights,
                                  OUT  PACTRL_CONTROL_INFOW *ppRightsList,
                                  OUT  PULONG                pfAccessFlags);
DWORD
WINAPI
AccProvHandleGetAccessInfoPerObjectType(
                                   IN   HANDLE                hObject,
                                   IN   SE_OBJECT_TYPE        ObjectType,
                                   IN   LPCWSTR               lpProperty,
                                   OUT  PULONG                pcEntries,
                                   OUT  PACTRL_ACCESS_INFO   *ppAccessInfoList,
                                   OUT  PULONG                pcRights,
                                   OUT  PACTRL_CONTROL_INFOW *ppRightsList,
                                   OUT  PULONG                pfAccessFlags);


typedef DWORD   (WINAPI *pfAccProvGetObjTypeInfo)
                                      (LPCWSTR               lpObject,
                                       SE_OBJECT_TYPE        ObjectType,
                                       LPCWSTR               lpObjType,
                                       PULONG                pcEntries,
                                       PACTRL_ACCESS_INFO   *ppAccessInfoList,
                                       PULONG                pcRights,
                                       PACTRL_CONTROL_INFO  *ppRightsList,
                                       PULONG                pfAccessFlags);

typedef DWORD   (WINAPI *pfAccProvHandleGetObjTypeInfo)
                                      (HANDLE                hObject,
                                       SE_OBJECT_TYPE        ObjectType,
                                       LPCWSTR               lpObjType,
                                       PULONG                pcEntries,
                                       PACTRL_ACCESS_INFO   *ppAccessInfoList,
                                       PULONG                pcRights,
                                       PACTRL_CONTROL_INFO  *ppRightsList,
                                       PULONG                pfAccessFlags);

//
// Control functions
//
DWORD
WINAPI
AccProvCancelOperation(IN   PACTRL_OVERLAPPED   pOverlapped);

typedef DWORD  (WINAPI *pfAccProvCancelOp) (PACTRL_OVERLAPPED   pOverlapped);


DWORD
WINAPI
AccProvGetOperationResults(IN   PACTRL_OVERLAPPED   pOverlapped,
                           OUT  PDWORD              pResults,
                           OUT  PDWORD              pcProcessed);

typedef DWORD   (WINAPI *pfAccProvGetResults)
                                            (PACTRL_OVERLAPPED  pOverlapped,
                                             PDWORD             pResults,
                                             PDWORD             pcProcessed);


#ifdef __cplusplus
}
#endif
#endif // __ACCPROV_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\public\oak\inc\winsplp.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    WinSplp.h

Abstract:

    Internal Header file for Print APIs

Author:

Revision History:

--*/

#ifndef _WINSPLP_
#define _WINSPLP_

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */


#define PRINTER_NOTIFY_STATUS_ENDPOINT 1
#define PRINTER_NOTIFY_STATUS_POLL     2
#define PRINTER_NOTIFY_STATUS_INFO     4


#define ROUTER_UNKNOWN      0
#define ROUTER_SUCCESS      1
#define ROUTER_STOP_ROUTING 2


typedef struct _PRINTER_NOTIFY_INIT {
    DWORD Size;
    DWORD Reserved;
    DWORD PollTime;
} PRINTER_NOTIFY_INIT, *PPRINTER_NOTIFY_INIT, *LPPRINTER_NOTIFY_INIT;

typedef struct _SPLCLIENT_INFO_1{
    DWORD       dwSize;
    LPWSTR      pMachineName;
    LPWSTR      pUserName;
    DWORD       dwBuildNum;
    DWORD       dwMajorVersion;
    DWORD       dwMinorVersion;
    WORD        wProcessorArchitecture;
} SPLCLIENT_INFO_1, *PSPLCLIENT_INFO_1, *LPSPLCLIENT_INFO_1;

// This definition is used in the private spooler RPC interface (RpcSplOpenPrinter)
// The handle returned in the struct is the Server Side hPrinter which will used in
// making direct API calls from the client to the server side w/o the overhead of
// RPC. The performance boost is observed mainly in calls to Read/WritePrinter made from
// within the spooler (gdi32.dll during playback)

typedef struct _SPLCLIENT_INFO_2{
    ULONG_PTR      hSplPrinter;      // Server side handle to be used for direct calls
} SPLCLIENT_INFO_2, *PSPLCLIENT_INFO_2, *LPSPLCLIENT_INFO_2;

typedef struct _PRINTPROVIDOR {

   BOOL (*fpOpenPrinter)(LPWSTR   pPrinterName,
                         LPHANDLE phPrinter,
                         LPPRINTER_DEFAULTS pDefault);

   BOOL (*fpSetJob)(HANDLE hPrinter,
                    DWORD JobId,
                    DWORD Level,
                    LPBYTE pJob,
                    DWORD Command);

   BOOL (*fpGetJob)(HANDLE   hPrinter,
                    DWORD    JobId,
                    DWORD    Level,
                    LPBYTE   pJob,
                    DWORD    cbBuf,
                    LPDWORD  pcbNeeded);

   BOOL (*fpEnumJobs)(HANDLE  hPrinter,
                      DWORD   FirstJob,
                      DWORD   NoJobs,
                      DWORD   Level,
                      LPBYTE  pJob,
                      DWORD   cbBuf,
                      LPDWORD pcbNeeded,
                      LPDWORD pcReturned);

   HANDLE (*fpAddPrinter)(LPWSTR  pName,
                          DWORD   Level,
                          LPBYTE  pPrinter);

   BOOL (*fpDeletePrinter)(HANDLE   hPrinter);

   BOOL (*fpSetPrinter)(HANDLE  hPrinter,
                        DWORD   Level,
                        LPBYTE  pPrinter,
                        DWORD   Command);

   BOOL (*fpGetPrinter)(HANDLE  hPrinter,
                        DWORD   Level,
                        LPBYTE  pPrinter,
                        DWORD   cbBuf,
                        LPDWORD pcbNeeded);

   BOOL (*fpEnumPrinters)(DWORD   Flags,
                          LPWSTR  Name,
                          DWORD   Level,
                          LPBYTE  pPrinterEnum,
                          DWORD   cbBuf,
                          LPDWORD pcbNeeded,
                          LPDWORD pcReturned);

   BOOL (*fpAddPrinterDriver)(LPWSTR  pName,
                              DWORD   Level,
                              LPBYTE  pDriverInfo);

   BOOL (*fpEnumPrinterDrivers)(LPWSTR  pName,
                                LPWSTR  pEnvironment,
                                DWORD   Level,
                                LPBYTE  pDriverInfo,
                                DWORD   cbBuf,
                                LPDWORD pcbNeeded,
                                LPDWORD pcReturned);

   BOOL (*fpGetPrinterDriver)(HANDLE  hPrinter,
                              LPWSTR  pEnvironment,
                              DWORD   Level,
                              LPBYTE  pDriverInfo,
                              DWORD   cbBuf,
                              LPDWORD pcbNeeded);

   BOOL (*fpGetPrinterDriverDirectory)(LPWSTR  pName,
                                       LPWSTR  pEnvironment,
                                       DWORD   Level,
                                       LPBYTE  pDriverDirectory,
                                       DWORD   cbBuf,
                                       LPDWORD pcbNeeded);

   BOOL (*fpDeletePrinterDriver)(LPWSTR   pName,
                                 LPWSTR   pEnvironment,
                                 LPWSTR   pDriverName);

   BOOL (*fpAddPrintProcessor)(LPWSTR  pName,
                               LPWSTR  pEnvironment,
                               LPWSTR  pPathName,
                               LPWSTR  pPrintProcessorName);

   BOOL (*fpEnumPrintProcessors)(LPWSTR  pName,
                                 LPWSTR  pEnvironment,
                                 DWORD   Level,
                                 LPBYTE  pPrintProcessorInfo,
                                 DWORD   cbBuf,
                                 LPDWORD pcbNeeded,
                                 LPDWORD pcReturned);

   BOOL (*fpGetPrintProcessorDirectory)(LPWSTR  pName,
                                        LPWSTR  pEnvironment,
                                        DWORD   Level,
                                        LPBYTE  pPrintProcessorInfo,
                                        DWORD   cbBuf,
                                        LPDWORD pcbNeeded);

   BOOL (*fpDeletePrintProcessor)(LPWSTR  pName,
                                  LPWSTR  pEnvironment,
                                  LPWSTR  pPrintProcessorName);

   BOOL (*fpEnumPrintProcessorDatatypes)(LPWSTR  pName,
                                         LPWSTR  pPrintProcessorName,
                                         DWORD   Level,
                                         LPBYTE  pDataypes,
                                         DWORD   cbBuf,
                                         LPDWORD pcbNeeded,
                                         LPDWORD pcReturned);

   DWORD (*fpStartDocPrinter)(HANDLE  hPrinter,
                             DWORD   Level,
                             LPBYTE  pDocInfo);

   BOOL (*fpStartPagePrinter)(HANDLE  hPrinter);

   BOOL (*fpWritePrinter)(HANDLE  hPrinter,
                          LPVOID  pBuf,
                          DWORD   cbBuf,
                          LPDWORD pcWritten);

   BOOL (*fpEndPagePrinter)(HANDLE   hPrinter);

   BOOL (*fpAbortPrinter)(HANDLE   hPrinter);

   BOOL (*fpReadPrinter)(HANDLE  hPrinter,
                         LPVOID  pBuf,
                         DWORD   cbBuf,
                         LPDWORD pNoBytesRead);

   BOOL (*fpEndDocPrinter)(HANDLE   hPrinter);

   BOOL (*fpAddJob)(HANDLE  hPrinter,
                    DWORD   Level,
                    LPBYTE  pData,
                    DWORD   cbBuf,
                    LPDWORD pcbNeeded);

   BOOL (*fpScheduleJob)(HANDLE  hPrinter,
                         DWORD   JobId);

   DWORD (*fpGetPrinterData)(HANDLE   hPrinter,
                             LPWSTR   pValueName,
                             LPDWORD  pType,
                             LPBYTE   pData,
                             DWORD    nSize,
                             LPDWORD  pcbNeeded);

   DWORD (*fpSetPrinterData)(HANDLE  hPrinter,
                             LPWSTR  pValueName,
                             DWORD   Type,
                             LPBYTE  pData,
                             DWORD   cbData);

   DWORD (*fpWaitForPrinterChange)(HANDLE hPrinter, DWORD Flags);

   BOOL (*fpClosePrinter)(HANDLE hPrinter);

   BOOL (*fpAddForm)(HANDLE  hPrinter,
                     DWORD   Level,
                     LPBYTE  pForm);

   BOOL (*fpDeleteForm)(HANDLE  hPrinter,
                        LPWSTR  pFormName);

   BOOL (*fpGetForm)(HANDLE  hPrinter,
                     LPWSTR  pFormName,
                     DWORD   Level,
                     LPBYTE  pForm,
                     DWORD   cbBuf,
                     LPDWORD pcbNeeded);

   BOOL (*fpSetForm)(HANDLE  hPrinter,
                     LPWSTR  pFormName,
                     DWORD   Level,
                     LPBYTE  pForm);

   BOOL (*fpEnumForms)(HANDLE  hPrinter,
                       DWORD   Level,
                       LPBYTE  pForm,
                       DWORD   cbBuf,
                       LPDWORD pcbNeeded,
                       LPDWORD pcReturned);

   BOOL (*fpEnumMonitors)(LPWSTR  pName,
                          DWORD   Level,
                          LPBYTE  pMonitors,
                          DWORD   cbBuf,
                          LPDWORD pcbNeeded,
                          LPDWORD pcReturned);

   BOOL (*fpEnumPorts)(LPWSTR  pName,
                       DWORD   Level,
                       LPBYTE  pPorts,
                       DWORD   cbBuf,
                       LPDWORD pcbNeeded,
                       LPDWORD pcReturned);

   BOOL (*fpAddPort)(LPWSTR  pName,
                     HWND    hWnd,
                     LPWSTR  pMonitorName);

   BOOL (*fpConfigurePort)(LPWSTR  pName,
                           HWND    hWnd,
                           LPWSTR  pPortName);

   BOOL (*fpDeletePort)(LPWSTR  pName,
                        HWND    hWnd,
                        LPWSTR  pPortName);

   HANDLE (*fpCreatePrinterIC)(HANDLE  hPrinter,
                               LPDEVMODEW   pDevMode);

   BOOL (*fpPlayGdiScriptOnPrinterIC)(HANDLE  hPrinterIC,
                                      LPBYTE  pIn,
                                      DWORD   cIn,
                                      LPBYTE  pOut,
                                      DWORD   cOut,
                                      DWORD   ul);

   BOOL (*fpDeletePrinterIC)(HANDLE  hPrinterIC);

   BOOL (*fpAddPrinterConnection)(LPWSTR  pName);

   BOOL (*fpDeletePrinterConnection)(LPWSTR pName);

   DWORD (*fpPrinterMessageBox)(HANDLE  hPrinter,
                                DWORD   Error,
                                HWND    hWnd,
                                LPWSTR  pText,
                                LPWSTR  pCaption,
                                DWORD   dwType);

   BOOL (*fpAddMonitor)(LPWSTR  pName,
                        DWORD   Level,
                        LPBYTE  pMonitorInfo);

   BOOL (*fpDeleteMonitor)(LPWSTR  pName,
                           LPWSTR  pEnvironment,
                           LPWSTR  pMonitorName);

   BOOL (*fpResetPrinter)(HANDLE hPrinter,
                          LPPRINTER_DEFAULTS pDefault);

   BOOL (*fpGetPrinterDriverEx)(HANDLE  hPrinter,
                              LPWSTR  pEnvironment,
                              DWORD   Level,
                              LPBYTE  pDriverInfo,
                              DWORD   cbBuf,
                              LPDWORD pcbNeeded,
                              DWORD   dwClientMajorVersion,
                              DWORD   dwClientMinorVersion,
                              PDWORD  pdwServerMajorVersion,
                              PDWORD  pdwServerMinorVersion);

   BOOL (*fpFindFirstPrinterChangeNotification)(
            HANDLE hPrinter,
            DWORD fdwFlags,
            DWORD fdwOptions,
            HANDLE hNotify,
            PDWORD pfdwStatus,
            PVOID pPrinterNotifyOptions,
            PVOID pPrinterNotifyInit);

   BOOL (*fpFindClosePrinterChangeNotification)(HANDLE hPrinter);


   BOOL (*fpAddPortEx)(LPWSTR   pName,
                       DWORD    Level,
                       LPBYTE   lpBuffer,
                       LPWSTR   lpMonitorName);

   BOOL (*fpShutDown)(LPVOID pvReserved);

   BOOL (*fpRefreshPrinterChangeNotification)(HANDLE hPrinter,
                                              DWORD  Reserved,
                                              PVOID pvReserved,
                                              PVOID pPrinterNotifyInfo);

   BOOL (*fpOpenPrinterEx)(LPWSTR     pPrinterName,
                           LPHANDLE   phPrinter,
                           LPPRINTER_DEFAULTS pDefault,
                           LPBYTE     pClientInfo,
                           DWORD      Level);

   HANDLE (*fpAddPrinterEx)(LPWSTR  pName,
                            DWORD   Level,
                            LPBYTE  pPrinter,
                            LPBYTE  pClientInfo,
                            DWORD   ClientInfoLevel);

   BOOL (*fpSetPort)(LPWSTR     pName,
                     LPWSTR     pPortName,
                     DWORD      Level,
                     LPBYTE     pPortInfo);

   DWORD (*fpEnumPrinterData)(HANDLE   hPrinter,
                              DWORD    dwIndex,
                              LPWSTR   pValueName,
                              DWORD    cbValueName,
                              LPDWORD  pcbValueName,
                              LPDWORD  pType,
                              LPBYTE   pData,
                              DWORD    cbData,
                              LPDWORD  pcbData);

   DWORD (*fpDeletePrinterData)(HANDLE   hPrinter,
                                LPWSTR   pValueName);

   DWORD (*fpClusterSplOpen)( LPCTSTR pszServer,
                              LPCTSTR pszResource,
                              PHANDLE phSpooler,
                              LPCTSTR pszName,
                              LPCTSTR pszAddress );


   DWORD (*fpClusterSplClose)( HANDLE hSpooler );

   DWORD (*fpClusterSplIsAlive)( HANDLE hSpooler );

   DWORD (*fpSetPrinterDataEx)(  HANDLE  hPrinter,
                                 LPCWSTR pKeyName,
                                 LPCWSTR pValueName,
                                 DWORD   Type,
                                 LPBYTE  pData,
                                 DWORD   cbData);

   DWORD (*fpGetPrinterDataEx)(HANDLE   hPrinter,
                               LPCWSTR  pKeyName,
                               LPCWSTR  pValueName,
                               LPDWORD  pType,
                               LPBYTE   pData,
                               DWORD    nSize,
                               LPDWORD  pcbNeeded);

   DWORD (*fpEnumPrinterDataEx)(  HANDLE  hPrinter,
                                  LPCWSTR pKeyName,
                                  LPBYTE  pEnumValues,
                                  DWORD   cbEnumValues,
                                  LPDWORD pcbEnumValues,
                                  LPDWORD pnEnumValues);

   DWORD (*fpEnumPrinterKey)( HANDLE   hPrinter,
                              LPCWSTR  pKeyName,
                              LPWSTR   pSubkey,
                              DWORD    cbSubkey,
                              LPDWORD  pcbSubkey);

   DWORD (*fpDeletePrinterDataEx)(  HANDLE  hPrinter,
                                    LPCWSTR pKeyName,
                                    LPCWSTR pValueName);

   DWORD (*fpDeletePrinterKey)(  HANDLE  hPrinter,
                                 LPCWSTR pKeyName);

   BOOL (*fpSeekPrinter)( HANDLE hPrinter,
                          LARGE_INTEGER liDistanceToMove,
                          PLARGE_INTEGER pliNewPointer,
                          DWORD dwMoveMethod,
                          BOOL bWrite );

   BOOL (*fpDeletePrinterDriverEx)(LPWSTR   pName,
                                   LPWSTR   pEnvironment,
                                   LPWSTR   pDriverName,
                                   DWORD    dwDeleteFlag,
                                   DWORD    dwVersionNum);

   BOOL (*fpAddPerMachineConnection)(LPCWSTR    pServer,
                                     LPCWSTR    pPrinterName,
                                     LPCWSTR    pPrintServer,
                                     LPCWSTR    pProvider);

   BOOL (*fpDeletePerMachineConnection)(LPCWSTR   pServer,
                                        LPCWSTR   pPrinterName);

   BOOL (*fpEnumPerMachineConnections)(LPCWSTR    pServer,
                                       LPBYTE     pPrinterEnum,
                                       DWORD      cbBuf,
                                       LPDWORD    pcbNeeded,
                                       LPDWORD    pcReturned);

   BOOL (*fpXcvData)(   HANDLE  hXcv,
                        LPCWSTR pszDataName,
                        PBYTE   pInputData,
                        DWORD   cbInputData,
                        PBYTE   pOutputData,
                        DWORD   cbOutputData,
                        PDWORD  pcbOutputNeeded,
                        PDWORD  pdwStatus
                        );

   BOOL (*fpAddPrinterDriverEx)(LPWSTR  pName,
                                DWORD   Level,
                                LPBYTE  pDriverInfo,
                                DWORD   dwFileCopyFlags);

   BOOL (*fpSplReadPrinter)(HANDLE hPrinter,
                            LPBYTE *pBuf,
                            DWORD  cbBuf);

   BOOL (*fpDriverUnloadComplete)(LPWSTR  pDriverFile);

   BOOL (*fpGetSpoolFileInfo)(HANDLE    hPrinter,
                              LPWSTR    *pSpoolDir,
                              LPHANDLE  phFile,
                              HANDLE    hSpoolerProcess,
                              HANDLE    hAppProcess);

   BOOL (*fpCommitSpoolData)(HANDLE  hPrinter,
                             DWORD   cbCommit);

   BOOL (*fpCloseSpoolFileHandle)(HANDLE  hPrinter);

   BOOL (*fpFlushPrinter)(HANDLE  hPrinter,
                          LPBYTE  pBuf,
                          DWORD   cbBuf,
                          LPDWORD pcWritten,
                          DWORD   cSleep);

} PRINTPROVIDOR, *LPPRINTPROVIDOR;

BOOL
InitializePrintProvidor(
   LPPRINTPROVIDOR  pPrintProvidor,
   DWORD    cbPrintProvidor,
   LPWSTR   pFullRegistryPath
);

typedef struct _PRINTPROCESSOROPENDATA {
    PDEVMODE  pDevMode;
    LPWSTR    pDatatype;
    LPWSTR    pParameters;
    LPWSTR    pDocumentName;
    DWORD     JobId;
    LPWSTR    pOutputFile;
    LPWSTR    pPrinterName;
} PRINTPROCESSOROPENDATA, *PPRINTPROCESSOROPENDATA, *LPPRINTPROCESSOROPENDATA;

HANDLE
OpenPrintProcessor(
    LPWSTR  pPrinterName,
    PPRINTPROCESSOROPENDATA pPrintProcessorOpenData
);

BOOL
PrintDocumentOnPrintProcessor(
    HANDLE  hPrintProcessor,
    LPWSTR  pDocumentName
);

BOOL
ClosePrintProcessor(
    HANDLE  hPrintProcessor
);

BOOL
ControlPrintProcessor(
    HANDLE  hPrintProcessor,
    DWORD   Command
);

DWORD
GetPrintProcessorCapabilities(
    LPTSTR   pValueName,
    DWORD    dwAttributes,
    LPBYTE   pData,
    DWORD    nSize,
    LPDWORD  pcbNeeded
);

BOOL
InitializeMonitor(
    LPWSTR  pRegistryRoot
);

BOOL
OpenPort(
    LPWSTR  pName,
    PHANDLE pHandle
);

BOOL
WritePort(
    HANDLE  hPort,
    LPBYTE  pBuffer,
    DWORD   cbBuf,
    LPDWORD pcbWritten
);

BOOL
ReadPort(
    HANDLE hPort,
    LPBYTE pBuffer,
    DWORD  cbBuffer,
    LPDWORD pcbRead
);

BOOL
ClosePort(
    HANDLE  hPort
);


BOOL
XcvOpenPort(
    LPCWSTR pszObject,
    ACCESS_MASK GrantedAccess,
    PHANDLE phXcv
);

DWORD
XcvDataPort(
    HANDLE  hXcv,
    LPCWSTR pszDataName,
    PBYTE   pInputData,
    DWORD   cbInputData,
    PBYTE   pOutputData,
    DWORD   cbOutputData,
    PDWORD  pcbOutputNeeded
);

BOOL
XcvClosePort(
    HANDLE  hXcv
);


BOOL
AddPortUI
(
    PCWSTR  pszServer,
    HWND    hWnd,
    PCWSTR  pszMonitorNameIn,
    PWSTR  *ppszPortNameOut
);

BOOL
ConfigurePortUI
(
    PCWSTR pszServer,
    HWND   hWnd,
    PCWSTR pszPortName
);

BOOL
DeletePortUI
(
    PCWSTR pszServer,
    HWND   hWnd,
    PCWSTR pszPortName
);


BOOL
SplDeleteSpoolerPortStart(
    PCWSTR pPortName
);

BOOL
SplDeleteSpoolerPortEnd(
    PCWSTR pName,
    BOOL   bDeletePort
);

typedef struct _MONITORREG {

    DWORD cbSize;

    LONG
    (WINAPI *fpCreateKey)(
        HANDLE hcKey,
        LPCTSTR pszSubKey,
        DWORD dwOptions,
        REGSAM samDesired,
        PSECURITY_ATTRIBUTES pSecurityAttributes,
        PHANDLE phckResult,
        PDWORD pdwDisposition,
        HANDLE hSpooler
        );

    LONG
    (WINAPI *fpOpenKey)(
        HANDLE hcKey,
        LPCTSTR pszSubKey,
        REGSAM samDesired,
        PHANDLE phkResult,
        HANDLE hSpooler
        );

    LONG
    (WINAPI *fpCloseKey)(
        HANDLE hcKey,
        HANDLE hSpooler
        );

    LONG
    (WINAPI *fpDeleteKey)(
        HANDLE hcKey,
        LPCTSTR pszSubKey,
        HANDLE hSpooler
        );

    LONG
    (WINAPI *fpEnumKey)(
        HANDLE hcKey,
        DWORD dwIndex,
        LPTSTR pszName,
        PDWORD pcchName,
        PFILETIME pftLastWriteTime,
        HANDLE hSpooler
        );

    LONG
    (WINAPI *fpQueryInfoKey)(
        HANDLE hcKey,
        PDWORD pcSubKeys,
        PDWORD pcbKey,
        PDWORD pcValues,
        PDWORD pcbValue,
        PDWORD pcbData,
        PDWORD pcbSecurityDescriptor,
        PFILETIME pftLastWriteTime,
        HANDLE hSpooler
        );

    LONG
    (WINAPI *fpSetValue)(
        HANDLE hcKey,
        LPCTSTR pszValue,
        DWORD dwType,
        const BYTE* pData,
        DWORD cbData,
        HANDLE hSpooler
        );

    LONG
    (WINAPI *fpDeleteValue)(
        HANDLE hcKey,
        LPCTSTR pszValue,
        HANDLE hSpooler
        );

    LONG
    (WINAPI *fpEnumValue)(
        HANDLE hcKey,
        DWORD dwIndex,
        LPTSTR pszValue,
        PDWORD pcbValue,
        PDWORD pType,
        PBYTE pData,
        PDWORD pcbData,
        HANDLE hSpooler
        );

    LONG
    (WINAPI *fpQueryValue)(
        HANDLE hcKey,
        LPCTSTR pszValue,
        PDWORD pType,
        PBYTE pData,
        PDWORD pcbData,
        HANDLE hSpooler
        );

} MONITORREG, *PMONITORREG;


typedef struct _MONITORINIT {
    DWORD cbSize;
    HANDLE hSpooler;
    HANDLE hckRegistryRoot;
    PMONITORREG pMonitorReg;
    BOOL bLocal;
    LPCWSTR pszServerName;
} MONITORINIT, *PMONITORINIT;


typedef struct _MONITOR
{
    BOOL (WINAPI *pfnEnumPorts)
    (
    LPWSTR   pName,
    DWORD   Level,
    LPBYTE  pPorts,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
    );

    BOOL (WINAPI *pfnOpenPort)
    (
    LPWSTR  pName,
    PHANDLE pHandle
    );

    BOOL (WINAPI *pfnOpenPortEx)
    (
    LPWSTR  pPortName,
    LPWSTR  pPrinterName,
    PHANDLE pHandle,
    struct _MONITOR FAR *pMonitor
    );


    BOOL (WINAPI *pfnStartDocPort)
    (
    HANDLE  hPort,
    LPWSTR  pPrinterName,
    DWORD   JobId,
    DWORD   Level,
    LPBYTE  pDocInfo
    );

    BOOL (WINAPI *pfnWritePort)
    (
    HANDLE  hPort,
    LPBYTE  pBuffer,
    DWORD   cbBuf,
    LPDWORD pcbWritten
    );

    BOOL (WINAPI *pfnReadPort)
    (
    HANDLE hPort,
    LPBYTE pBuffer,
    DWORD  cbBuffer,
    LPDWORD pcbRead
    );

    BOOL (WINAPI *pfnEndDocPort)
    (
    HANDLE   hPort
    );

    BOOL (WINAPI *pfnClosePort)
    (
        HANDLE  hPort
    );

    BOOL (WINAPI *pfnAddPort)
    (
    LPWSTR   pName,
    HWND    hWnd,
    LPWSTR   pMonitorName
    );

    BOOL (WINAPI *pfnAddPortEx)
    (
    LPWSTR   pName,
    DWORD    Level,
    LPBYTE   lpBuffer,
    LPWSTR   lpMonitorName
    );

    BOOL (WINAPI *pfnConfigurePort)
    (
    LPWSTR   pName,
    HWND  hWnd,
    LPWSTR pPortName
    );

    BOOL (WINAPI *pfnDeletePort)
    (
    LPWSTR  pName,
    HWND    hWnd,
    LPWSTR  pPortName
    );

    BOOL (WINAPI *pfnGetPrinterDataFromPort)
    (
    HANDLE  hPort,
    DWORD   ControlID,
    LPWSTR  pValueName,
    LPWSTR  lpInBuffer,
    DWORD   cbInBuffer,
    LPWSTR  lpOutBuffer,
    DWORD   cbOutBuffer,
    LPDWORD lpcbReturned
    );

    BOOL (WINAPI *pfnSetPortTimeOuts)
    (
    HANDLE  hPort,
    LPCOMMTIMEOUTS lpCTO,
    DWORD   reserved    // must be set to 0
    );

    BOOL (WINAPI *pfnXcvOpenPort)
    (
    LPCWSTR pszObject,
    ACCESS_MASK GrantedAccess,
    PHANDLE phXcv
    );

    DWORD (WINAPI *pfnXcvDataPort)
    (
    HANDLE  hXcv,
    LPCWSTR pszDataName,
    PBYTE   pInputData,
    DWORD   cbInputData,
    PBYTE   pOutputData,
    DWORD   cbOutputData,
    PDWORD  pcbOutputNeeded
    );

    BOOL (WINAPI *pfnXcvClosePort)
    (
    HANDLE  hXcv
    );

} MONITOR, FAR *LPMONITOR;

typedef struct _MONITOREX
{
    DWORD       dwMonitorSize;
    MONITOR     Monitor;

} MONITOREX, FAR *LPMONITOREX;


typedef struct _MONITOR2
{
    DWORD cbSize;
    BOOL (WINAPI *pfnEnumPorts)
    (
    HANDLE  hMonitor,
    LPWSTR  pName,
    DWORD   Level,
    LPBYTE  pPorts,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
    );

    BOOL (WINAPI *pfnOpenPort)
    (
    HANDLE  hMonitor,
    LPWSTR  pName,
    PHANDLE pHandle
    );

    BOOL (WINAPI *pfnOpenPortEx)
    (
    HANDLE  hMonitor,
    HANDLE  hMonitorPort,
    LPWSTR  pPortName,
    LPWSTR  pPrinterName,
    PHANDLE pHandle,
    struct _MONITOR2 FAR *pMonitor2
    );


    BOOL (WINAPI *pfnStartDocPort)
    (
    HANDLE  hPort,
    LPWSTR  pPrinterName,
    DWORD   JobId,
    DWORD   Level,
    LPBYTE  pDocInfo
    );

    BOOL (WINAPI *pfnWritePort)
    (
    HANDLE  hPort,
    LPBYTE  pBuffer,
    DWORD   cbBuf,
    LPDWORD pcbWritten
    );

    BOOL (WINAPI *pfnReadPort)
    (
    HANDLE hPort,
    LPBYTE pBuffer,
    DWORD  cbBuffer,
    LPDWORD pcbRead
    );

    BOOL (WINAPI *pfnEndDocPort)
    (
    HANDLE   hPort
    );

    BOOL (WINAPI *pfnClosePort)
    (
    HANDLE  hPort
    );

    BOOL (WINAPI *pfnAddPort)
    (
    HANDLE   hMonitor,
    LPWSTR   pName,
    HWND     hWnd,
    LPWSTR   pMonitorName
    );

    BOOL (WINAPI *pfnAddPortEx)
    (
    HANDLE   hMonitor,
    LPWSTR   pName,
    DWORD    Level,
    LPBYTE   lpBuffer,
    LPWSTR   lpMonitorName
    );

    BOOL (WINAPI *pfnConfigurePort)
    (
    HANDLE  hMonitor,
    LPWSTR  pName,
    HWND    hWnd,
    LPWSTR  pPortName
    );

    BOOL (WINAPI *pfnDeletePort)
    (
    HANDLE  hMonitor,
    LPWSTR  pName,
    HWND    hWnd,
    LPWSTR  pPortName
    );

    BOOL (WINAPI *pfnGetPrinterDataFromPort)
    (
    HANDLE  hPort,
    DWORD   ControlID,
    LPWSTR  pValueName,
    LPWSTR  lpInBuffer,
    DWORD   cbInBuffer,
    LPWSTR  lpOutBuffer,
    DWORD   cbOutBuffer,
    LPDWORD lpcbReturned
    );

    BOOL (WINAPI *pfnSetPortTimeOuts)
    (
    HANDLE  hPort,
    LPCOMMTIMEOUTS lpCTO,
    DWORD   reserved    // must be set to 0
    );

    BOOL (WINAPI *pfnXcvOpenPort)
    (
    HANDLE  hMonitor,
    LPCWSTR pszObject,
    ACCESS_MASK GrantedAccess,
    PHANDLE phXcv
    );

    DWORD (WINAPI *pfnXcvDataPort)
    (
    HANDLE  hXcv,
    LPCWSTR pszDataName,
    PBYTE   pInputData,
    DWORD   cbInputData,
    PBYTE   pOutputData,
    DWORD   cbOutputData,
    PDWORD  pcbOutputNeeded
    );

    BOOL (WINAPI *pfnXcvClosePort)
    (
    HANDLE  hXcv
    );

    VOID (WINAPI *pfnShutdown)
    (
    HANDLE hMonitor
    );

} MONITOR2, *PMONITOR2, FAR *LPMONITOR2;


typedef struct _MONITORUI
{
    DWORD   dwMonitorUISize;

    BOOL (WINAPI *pfnAddPortUI)
    (
        PCWSTR pszServer,
        HWND   hWnd,
        PCWSTR pszMonitorNameIn,
        PWSTR  *ppszPortNameOut
    );

    BOOL (WINAPI *pfnConfigurePortUI)
    (
        PCWSTR  pName,
        HWND    hWnd,
        PCWSTR  pPortName
    );

    BOOL (WINAPI *pfnDeletePortUI)
    (
        PCWSTR pszServer,
        HWND   hWnd,
        PCWSTR pszPortName
    );

} MONITORUI, FAR *PMONITORUI;


HANDLE
CreatePrinterIC(
    HANDLE  hPrinter,
    LPDEVMODEW  pDevMode
);

BOOL
PlayGdiScriptOnPrinterIC(
    HANDLE  hPrinterIC,
    LPBYTE  pIn,
    DWORD   cIn,
    LPBYTE  pOut,
    DWORD   cOut,
    DWORD   ul
);

BOOL
DeletePrinterIC(
    HANDLE  hPrinterIC
);

BOOL
DevQueryPrint(
    HANDLE      hPrinter,
    LPDEVMODE   pDevMode,
    DWORD      *pResID
);

HANDLE
RevertToPrinterSelf(
    VOID
);

BOOL
ImpersonatePrinterClient(
    HANDLE  hToken
);

BOOL
ReplyPrinterChangeNotification(
    HANDLE hNotify,
    DWORD fdwFlags,
    PDWORD pdwResult,
    PVOID pPrinterNotifyInfo
);

BOOL
PartialReplyPrinterChangeNotification(
    HANDLE hNotify,
    PPRINTER_NOTIFY_INFO_DATA pInfoDataSrc
);

PPRINTER_NOTIFY_INFO
RouterAllocPrinterNotifyInfo(
    DWORD cPrinterNotifyInfoData
);

BOOL
RouterFreePrinterNotifyInfo(
    PPRINTER_NOTIFY_INFO pInfo
);


#define PRINTER_NOTIFY_INFO_DATA_COMPACT 1

BOOL
AppendPrinterNotifyInfoData(
    PPRINTER_NOTIFY_INFO pInfoDest,
    PPRINTER_NOTIFY_INFO_DATA pInfoDataSrc,
    DWORD fdwFlags
);


DWORD
CallRouterFindFirstPrinterChangeNotification(
    HANDLE hPrinter,
    DWORD fdwFlags,
    DWORD fdwOptions,
    HANDLE hNotify,
    PVOID pvReserved);

BOOL
ProvidorFindFirstPrinterChangeNotification(
    HANDLE hPrinter,
    DWORD fdwFlags,
    DWORD fdwOptions,
    HANDLE hNotify,
    PVOID pvReserved0,
    PVOID pvReserved1);

BOOL
ProvidorFindClosePrinterChangeNotification(
    HANDLE hPrinter);



BOOL
SpoolerFindFirstPrinterChangeNotification(
    HANDLE hPrinter,
    DWORD fdwFlags,
    DWORD fdwOptions,
    PHANDLE phEvent,
    PVOID pPrinterNotifyOptions,
    PVOID pvReserved);

BOOL
SpoolerFindNextPrinterChangeNotification(
    HANDLE hPrinter,
    LPDWORD pfdwChange,
    PVOID pvReserved0,
    PVOID ppPrinterNotifyInfo);

VOID
SpoolerFreePrinterNotifyInfo(
    PPRINTER_NOTIFY_INFO pInfo);

BOOL
SpoolerFindClosePrinterChangeNotification(
    HANDLE hPrinter);

LPMONITOR2
WINAPI
InitializePrintMonitor2(
    PMONITORINIT pMonitorInit,
    PHANDLE phMonitor
);

BOOL
WINAPI
InitializeMonitorEx(
    LPWSTR      pRegistryRoot,
    LPMONITOR   pMonitor
);

LPMONITOREX
WINAPI
InitializePrintMonitor(
    LPWSTR      pRegistryRoot
);

PMONITORUI
WINAPI
InitializePrintMonitorUI(
    VOID
);


//
//  The following is added for new point-and-print support which allows
//  specific files to be associated with a print queue (instead of a printer
//  driver) using SetPrinterDataEx under the key "CopyFiles"
//
#define COPYFILE_EVENT_SET_PRINTER_DATAEX           1
#define COPYFILE_EVENT_DELETE_PRINTER               2
#define COPYFILE_EVENT_ADD_PRINTER_CONNECTION       3
#define COPYFILE_EVENT_DELETE_PRINTER_CONNECTION    4
#define COPYFILE_EVENT_FILES_CHANGED                5


BOOL
WINAPI
SpoolerCopyFileEvent(
    LPWSTR  pszPrinterName,
    LPWSTR  pszKey,
    DWORD   dwCopyFileEvent
    );

#define COPYFILE_FLAG_CLIENT_SPOOLER            0x00000001
#define COPYFILE_FLAG_SERVER_SPOOLER            0x00000002


DWORD
WINAPI
GenerateCopyFilePaths(
    IN      LPCWSTR     pszPrinterName,
    IN      LPCWSTR     pszDirectory,
    IN      LPBYTE      pSplClientInfo,
    IN      DWORD       dwLevel,
    IN OUT  LPWSTR      pszSourceDir,
    IN OUT  LPDWORD     pcchSourceDirSize,
    IN OUT  LPWSTR      pszTargetDir,
    IN OUT  LPDWORD     pcchTargetDirSize,
    IN      DWORD       dwFlags
    );


#ifdef __cplusplus
}                   /* End of extern "C" { */
#endif              /* __cplusplus */

#endif // _WINSPLP_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\public\oak\inc\winppi.h ===
/*++ 
Copyright (c) 1985-1999, Microsoft Corporation
All rights reserved

Module Name:

    winppi.h

Abstract:

    Procedure declarations, constant definitions and macros for the GDI
    component.

--*/
#ifndef _WINPPI_
#define _WINPPI_

typedef int (CALLBACK* EMFPLAYPROC)( HDC, INT, HANDLE );

#define  EMF_PP_COLOR_OPTIMIZATION  0x01

HANDLE WINAPI GdiGetSpoolFileHandle(
    LPWSTR     pwszPrinterName,
    LPDEVMODEW pDevmode,
    LPWSTR     pwszDocName);

BOOL WINAPI GdiDeleteSpoolFileHandle(
    HANDLE     SpoolFileHandle);

DWORD WINAPI GdiGetPageCount(
    HANDLE     SpoolFileHandle);

HDC WINAPI GdiGetDC(
    HANDLE     SpoolFileHandle);

HANDLE WINAPI GdiGetPageHandle(
    HANDLE     SpoolFileHandle,
    DWORD      Page,
    LPDWORD    pdwPageType);

BOOL WINAPI GdiStartDocEMF(
    HANDLE     SpoolFileHandle,
    DOCINFOW   *pDocInfo);

BOOL WINAPI GdiStartPageEMF(
    HANDLE     SpoolFileHandle);

BOOL WINAPI GdiPlayPageEMF(
    HANDLE     SpoolFileHandle,
    HANDLE     hemf,
    RECT       *prectDocument,
    RECT       *prectBorder,
    RECT       *prectClip);

BOOL WINAPI GdiEndPageEMF(
    HANDLE     SpoolFileHandle,
    DWORD      dwOptimization);

BOOL WINAPI GdiEndDocEMF(
    HANDLE     SpoolFileHandle);

BOOL WINAPI GdiGetDevmodeForPage(
    HANDLE     SpoolFileHandle,
    DWORD      dwPageNumber,
    PDEVMODEW  *pCurrDM,
    PDEVMODEW  *pLastDM);

BOOL WINAPI GdiResetDCEMF(
    HANDLE     SpoolFileHandle,
    PDEVMODEW  pCurrDM);

#endif /* _WINPPI_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\public\sdk\inc\activeds.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996-1999
//
//  File:       ads.h
//
//  Contents:   Master include file for Ole Ds
//
//  Notes:      All Ole Ds client applications must include this file. This
//              provides access to the primary Ole Ds interfaces, the error
//              codes, and function prototypes for the Ole Ds helper apis.
//
//----------------------------------------------------------------------------

#if _MSC_VER > 1000
#pragma once
#endif

//
// Interface definitions and well known GUIDS for Ole Ds
//

#include "iads.h"


//
// Helper function prototypes for Ole Ds
//

#include "adshlp.h"

//
// Error codes for Ole Ds - generated from ..\..\errmsg
//

#include "adserr.h"

//
// Globally accessible GUIDS
//

#include "adsiid.h"

//
// Status codes for ads objects
//

#include "adssts.h"

//
// Schema class names and other schema related definitions
//

#include "adsnms.h"


//
// Definitions in the OLE DB provider for ADSI
//

#include "adsdb.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\public\sdk\inc\aclui.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994-1999.
//
//  File:       aclui.h
//
//  Contents:   Definitions and prototypes for the ACLUI.DLL
//
//---------------------------------------------------------------------------

#ifndef _ACLUI_H_
#define _ACLUI_H_

#if _MSC_VER > 1000
#pragma once
#endif

#include <objbase.h>
#include <commctrl.h>   // for HPROPSHEETPAGE


#if !defined(_ACLUI_)
#define ACLUIAPI    DECLSPEC_IMPORT WINAPI
#else
#define ACLUIAPI    WINAPI
#endif

#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */

//
// ISecurityInformation interface
//
//  Methods:
//
//     GetObjectInformation - Allows UI to determine type of object being
//       edited.  Also allows determining if object is a container.
//
//     GetSecurity - Allows retrieving of ACLs from the original object
//                       NOTE: ACLUI will LocalFree the security descriptor
//                       returned by GetSecurity.
//     SetSecurity - Allows setting of the ACLs on the original object
//
//     GetAccessRights - For retrieving the list of rights allowed
//              on this object.
//
//     MapGeneric - For mapping generic rights to standard & specific rights
//
//     GetInheritTypes - For retrieving the list of possible sub-object types
//              for a container.
//
//     PropertySheetCallback - A method which is called back during the various
//              security UI property pages so that specialized work can be
//              done.  Similar to PropSheetPageProc.  If uMsg == PSPCB_CREATE,
//              then any error return value other than E_NOTIMPL will abort
//              the creation of that page.  The type of page being created or
//              destroyed is indicated by the uPage parameter.
//

typedef struct _SI_OBJECT_INFO
{
    DWORD       dwFlags;
    HINSTANCE   hInstance;          // resources (e.g. strings) reside here
    LPWSTR      pszServerName;      // must be present
    LPWSTR      pszObjectName;      // must be present
    LPWSTR      pszPageTitle;       // only valid if SI_PAGE_TITLE is set
    GUID        guidObjectType;     // only valid if SI_OBJECT_GUID is set
} SI_OBJECT_INFO, *PSI_OBJECT_INFO;

// SI_OBJECT_INFO flags
#define SI_EDIT_PERMS       0x00000000L // always implied
#define SI_EDIT_OWNER       0x00000001L
#define SI_EDIT_AUDITS      0x00000002L
#define SI_CONTAINER        0x00000004L
#define SI_READONLY         0x00000008L
#define SI_ADVANCED         0x00000010L
#define SI_RESET            0x00000020L
#define SI_OWNER_READONLY   0x00000040L
#define SI_EDIT_PROPERTIES  0x00000080L
#define SI_OWNER_RECURSE    0x00000100L
#define SI_NO_ACL_PROTECT   0x00000200L
#define SI_NO_TREE_APPLY    0x00000400L
#define SI_PAGE_TITLE       0x00000800L
#define SI_SERVER_IS_DC     0x00001000L
#define SI_RESET_DACL_TREE  0x00004000L
#define SI_RESET_SACL_TREE  0x00008000L
#define SI_OBJECT_GUID      0x00010000L

#define SI_EDIT_ALL     (SI_EDIT_PERMS | SI_EDIT_OWNER | SI_EDIT_AUDITS)


typedef struct _SI_ACCESS
{
    const GUID *pguid;
    ACCESS_MASK mask;
    LPCWSTR     pszName;            // may be resource ID
    DWORD       dwFlags;
} SI_ACCESS, *PSI_ACCESS;

// SI_ACCESS flags
#define SI_ACCESS_SPECIFIC  0x00010000L
#define SI_ACCESS_GENERAL   0x00020000L
#define SI_ACCESS_CONTAINER 0x00040000L // general access, container-only
#define SI_ACCESS_PROPERTY  0x00080000L
// ACE inheritance flags (CONTAINER_INHERIT_ACE, etc.) may also be set.
// They will be used as the inheritance when an access is turned on.

typedef struct _SI_INHERIT_TYPE
{
    const GUID *pguid;
    ULONG       dwFlags;
    LPCWSTR     pszName;            // may be resource ID
} SI_INHERIT_TYPE, *PSI_INHERIT_TYPE;

// SI_INHERIT_TYPE flags are a combination of INHERIT_ONLY_ACE,
// CONTAINER_INHERIT_ACE, and OBJECT_INHERIT_ACE.

typedef enum _SI_PAGE_TYPE
{
    SI_PAGE_PERM=0,
    SI_PAGE_ADVPERM,
    SI_PAGE_AUDIT,
    SI_PAGE_OWNER,
} SI_PAGE_TYPE;

// Message to PropertySheetPageCallback (in addition to
// PSPCB_CREATE and PSPCB_RELEASE)
#define PSPCB_SI_INITDIALOG	(WM_USER + 1)


#undef INTERFACE
#define INTERFACE   ISecurityInformation
DECLARE_INTERFACE_(ISecurityInformation, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** ISecurityInformation methods ***
    STDMETHOD(GetObjectInformation) (THIS_ PSI_OBJECT_INFO pObjectInfo ) PURE;
    STDMETHOD(GetSecurity) (THIS_ SECURITY_INFORMATION RequestedInformation,
                            PSECURITY_DESCRIPTOR *ppSecurityDescriptor,
                            BOOL fDefault ) PURE;
    STDMETHOD(SetSecurity) (THIS_ SECURITY_INFORMATION SecurityInformation,
                            PSECURITY_DESCRIPTOR pSecurityDescriptor ) PURE;
    STDMETHOD(GetAccessRights) (THIS_ const GUID* pguidObjectType,
                                DWORD dwFlags, // SI_EDIT_AUDITS, SI_EDIT_PROPERTIES
                                PSI_ACCESS *ppAccess,
                                ULONG *pcAccesses,
                                ULONG *piDefaultAccess ) PURE;
    STDMETHOD(MapGeneric) (THIS_ const GUID *pguidObjectType,
                           UCHAR *pAceFlags,
                           ACCESS_MASK *pMask) PURE;
    STDMETHOD(GetInheritTypes) (THIS_ PSI_INHERIT_TYPE *ppInheritTypes,
                                ULONG *pcInheritTypes ) PURE;
    STDMETHOD(PropertySheetPageCallback)(THIS_ HWND hwnd, UINT uMsg, SI_PAGE_TYPE uPage ) PURE;
};
typedef ISecurityInformation *LPSECURITYINFO;

#undef INTERFACE
#define INTERFACE   ISecurityInformation2
DECLARE_INTERFACE_(ISecurityInformation2, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** ISecurityInformation2 methods ***
    STDMETHOD_(BOOL,IsDaclCanonical) (THIS_ IN PACL pDacl) PURE;
    STDMETHOD(LookupSids) (THIS_ IN ULONG cSids, IN PSID *rgpSids, OUT LPDATAOBJECT *ppdo) PURE;
};
typedef ISecurityInformation2 *LPSECURITYINFO2;

// HGLOBAL containing SID_INFO_LIST returned by ISecurityInformation2::LookupSids
#define CFSTR_ACLUI_SID_INFO_LIST   TEXT("CFSTR_ACLUI_SID_INFO_LIST")

// Data structures corresponding to CFSTR_ACLUI_SID_INFO_LIST
typedef struct _SID_INFO
{
    PSID    pSid;
    PWSTR   pwzCommonName;
    PWSTR   pwzClass;       // Used for selecting icon, e.g. "User" or "Group"
    PWSTR   pwzUPN;         // Optional, may be NULL
} SID_INFO, *PSID_INFO;
typedef struct _SID_INFO_LIST
{
    ULONG       cItems;
    SID_INFO    aSidInfo[ANYSIZE_ARRAY];
} SID_INFO_LIST, *PSID_INFO_LIST;


// {965FC360-16FF-11d0-91CB-00AA00BBB723}
EXTERN_GUID(IID_ISecurityInformation, 0x965fc360, 0x16ff, 0x11d0, 0x91, 0xcb, 0x0, 0xaa, 0x0, 0xbb, 0xb7, 0x23);
// {c3ccfdb4-6f88-11d2-a3ce-00c04fb1782a}
EXTERN_GUID(IID_ISecurityInformation2, 0xc3ccfdb4, 0x6f88, 0x11d2, 0xa3, 0xce, 0x0, 0xc0, 0x4f, 0xb1, 0x78, 0x2a);

HPROPSHEETPAGE ACLUIAPI CreateSecurityPage( LPSECURITYINFO psi );
BOOL ACLUIAPI EditSecurity( HWND hwndOwner, LPSECURITYINFO psi );

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif  /* _ACLUI_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\public\sdk\inc\af_irda.h ===
//
// Winsock1.1, IrDA1.1, WindowsNT5.0, Windows98 and WindowsCE1.0.
// Define one of _WIN32_WINNT, _WIN32_WINDOWS, _WIN32_WCE.
//  Copyright (C) Microsoft Corporation, 1994-1999.
//

#ifndef __AFIRDA__
#define __AFIRDA__

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _WINSOCKAPI_
typedef unsigned char   u_char;
typedef unsigned short  u_short;
typedef unsigned int    u_int;
typedef unsigned long   u_long;
#endif

#define WINDOWS_AF_IRDA         26
#define WINDOWS_PF_IRDA         WINDOWS_AF_IRDA

#define WCE_AF_IRDA             22
#define WCE_PF_IRDA             WCE_AF_IRDA


#if   defined(_WIN32_WINNT) || defined(_WIN32_WINDOWS)
#ifndef AF_IRDA
#define AF_IRDA	                WINDOWS_AF_IRDA
#endif
#define IRDA_PROTO_SOCK_STREAM  1
#elif defined(_WIN32_WCE)
#define AF_IRDA	                WCE_AF_IRDA
#else
#pragma message("One of _WIN32_WINNT | _WIN32_WINDOWS | _WIN32_WCE must be defined.")
#endif

#define PF_IRDA                 AF_IRDA

                            // WINNT, WIN98, WINCE
#define SOL_IRLMP		        0x00FF

#define IRLMP_ENUMDEVICES       0x00000010
#define IRLMP_IAS_SET           0x00000011
#define IRLMP_IAS_QUERY         0x00000012

                            // WINNT, WINCE
#define IRLMP_SEND_PDU_LEN      0x00000013
#define IRLMP_EXCLUSIVE_MODE    0x00000014
#define IRLMP_IRLPT_MODE        0x00000015
#define IRLMP_9WIRE_MODE        0x00000016

                            // WIN98
#define IRLMP_TINYTP_MODE       0x00000017
#define IRLMP_PARAMETERS		0x00000018
#define	IRLMP_DISCOVERY_MODE	0x00000019

                            // WINCE
#define IRLMP_SHARP_MODE        0x00000020

#if defined(_WIN32_WINNT)   // WSAIoctl for lazy discovery
#define SIO_LAZY_DISCOVERY  _IOR('t', 127, u_long)	
#endif

#define IAS_ATTRIB_NO_CLASS     0x00000010
#define IAS_ATTRIB_NO_ATTRIB    0x00000000
#define IAS_ATTRIB_INT          0x00000001
#define IAS_ATTRIB_OCTETSEQ     0x00000002
#define IAS_ATTRIB_STR          0x00000003

#define	IAS_MAX_USER_STRING		256
#define	IAS_MAX_OCTET_STRING	1024
#define IAS_MAX_CLASSNAME		64
#define IAS_MAX_ATTRIBNAME		256

                            // WINNT, WIN98
enum
{
  LM_HB_Extension =             128,    // Any hint byte

  LM_HB1_PnP =                  1,      // First hint byte
  LM_HB1_PDA_Palmtop =          2,
  LM_HB1_Computer =             4,
  LM_HB1_Printer =              8,
  LM_HB1_Modem =                16,
  LM_HB1_Fax =                  32,
  LM_HB1_LANAccess =            64,

  LM_HB2_Telephony =            1,      // Second hint byte
  LM_HB2_FileServer =           2,
};

#define LmCharSetASCII          0
#define LmCharSetISO_8859_1     1
#define LmCharSetISO_8859_2     2
#define LmCharSetISO_8859_3     3
#define LmCharSetISO_8859_4     4
#define LmCharSetISO_8859_5     5
#define LmCharSetISO_8859_6     6
#define LmCharSetISO_8859_7     7
#define LmCharSetISO_8859_8     8
#define LmCharSetISO_8859_9     9
#define LmCharSetUNICODE        0xff

                            // WIN98
typedef u_long LM_BAUD_RATE;

#define  LM_BAUD_1200           1200
#define  LM_BAUD_2400           2400
#define  LM_BAUD_9600           9600
#define  LM_BAUD_19200          19200
#define  LM_BAUD_38400          38400
#define  LM_BAUD_57600          57600
#define  LM_BAUD_115200         115200
#define  LM_BAUD_576K           576000
#define  LM_BAUD_1152K          1152000
#define  LM_BAUD_4M             4000000

typedef struct
{
    u_long          nTXDataBytes;   // Max tx data bytes per packet
    u_long          nRXDataBytes;   // Max rx data bytes per packet
    LM_BAUD_RATE    nBaudRate;      // Negotiated baud rate
    u_long          thresholdTime;  // Threshold (ms)
    u_long          discTime;       // Disconnect (ms)
    u_short         nMSLinkTurn;    // Link turn around (ms)
    u_char          nTXPackets;     // Number packets in transmit window
    u_char          nRXPackets;     // Number packets in receive window
} LM_IRPARMS,*PLM_IRPARMS;

typedef struct _SOCKADDR_IRDA
{
	u_short irdaAddressFamily;
	u_char  irdaDeviceID[4];
	char	irdaServiceName[25];
} SOCKADDR_IRDA, *PSOCKADDR_IRDA, FAR *LPSOCKADDR_IRDA;

typedef struct _WINDOWS_IRDA_DEVICE_INFO
{
	u_char  irdaDeviceID[4];
	char	irdaDeviceName[22];
	u_char	irdaDeviceHints1;
	u_char  irdaDeviceHints2;
	u_char  irdaCharSet;
} WINDOWS_IRDA_DEVICE_INFO, *PWINDOWS_IRDA_DEVICE_INFO, FAR *LPWINDOWS_IRDA_DEVICE_INFO;

typedef struct _WCE_IRDA_DEVICE_INFO
{
	u_char  irdaDeviceID[4];
	char	irdaDeviceName[22];
    u_char  Reserved[2];
} WCE_IRDA_DEVICE_INFO, *PWCE_IRDA_DEVICE_INFO;

#if   defined(_WIN32_WINNT) || defined(_WIN32_WINDOWS)
typedef WINDOWS_IRDA_DEVICE_INFO    IRDA_DEVICE_INFO, *PIRDA_DEVICE_INFO, FAR *LPIRDA_DEVICE_INFO;
#elif defined(_WIN32_WCE)
typedef WCE_IRDA_DEVICE_INFO        IRDA_DEVICE_INFO, *PIRDA_DEVICE_INFO;
#else
#pragma message("One of _WIN32_WINNT | _WIN32_WINDOWS | _WIN32_WCE must be defined.")
#endif

typedef struct _WINDOWS_DEVICELIST
{
	ULONG                       numDevice;
	WINDOWS_IRDA_DEVICE_INFO    Device[1];
} WINDOWS_DEVICELIST, *PWINDOWS_DEVICELIST, FAR *LPWINDOWS_DEVICELIST;

typedef struct _WCE_DEVICELIST
{
	ULONG                       numDevice;
	WCE_IRDA_DEVICE_INFO        Device[1];
} WCE_DEVICELIST, *PWCE_DEVICELIST;

#if   defined(_WIN32_WINNT) || defined(_WIN32_WINDOWS)
typedef WINDOWS_DEVICELIST      DEVICELIST, *PDEVICELIST, FAR *LPDEVICELIST;
#elif defined(_WIN32_WCE)
typedef WCE_DEVICELIST          DEVICELIST, *PDEVICELIST;
#else
#pragma message("One of _WIN32_WINNT | _WIN32_WINDOWS | _WIN32_WCE must be defined.")
#endif

typedef struct _WINDOWS_IAS_SET
{
    char    irdaClassName[IAS_MAX_CLASSNAME];
    char    irdaAttribName[IAS_MAX_ATTRIBNAME];
    u_long	irdaAttribType;
    union
    {
        LONG irdaAttribInt;
        struct
        {
            u_short	Len;
            u_char	OctetSeq[IAS_MAX_OCTET_STRING];
        } irdaAttribOctetSeq;
        struct
        {
            u_char	Len;
            u_char	CharSet;
            u_char	UsrStr[IAS_MAX_USER_STRING];
		} irdaAttribUsrStr;
    } irdaAttribute;
} WINDOWS_IAS_SET, *PWINDOWS_IAS_SET, FAR *LPWINDOWS_IAS_SET;

typedef struct _WINDOWS_IAS_QUERY
{
	u_char	irdaDeviceID[4];
    char    irdaClassName[IAS_MAX_CLASSNAME];
    char    irdaAttribName[IAS_MAX_ATTRIBNAME];
    u_long	irdaAttribType;
    union
    {
        LONG irdaAttribInt;
        struct
        {
            u_long  Len;
            u_char  OctetSeq[IAS_MAX_OCTET_STRING];
        } irdaAttribOctetSeq;
        struct
        {
            u_long  Len;
            u_long	CharSet;
            u_char	UsrStr[IAS_MAX_USER_STRING];
        } irdaAttribUsrStr;
    } irdaAttribute;
} WINDOWS_IAS_QUERY, *PWINDOWS_IAS_QUERY, FAR *LPWINDOWS_IAS_QUERY;

typedef struct _WCE_IAS_SET
{
    char    irdaClassName[61];
    char    irdaAttribName[61];
    u_short irdaAttribType;
    union
    {
        int irdaAttribInt;
        struct
        {
            int     Len;
            u_char  OctetSeq[1];
            u_char  Reserved[3];
        } irdaAttribOctetSeq;
        struct
        {
            int     Len;
            u_char  CharSet;
            u_char  UsrStr[1];
            u_char  Reserved[2];
        } irdaAttribUsrStr;
    } irdaAttribute;
} WCE_IAS_SET, *PWCE_IAS_SET;

typedef struct _WCE_IAS_QUERY
{
	u_char  irdaDeviceID[4];
    char    irdaClassName[61];
    char    irdaAttribName[61];
    u_short irdaAttribType;
    union
    {
        int irdaAttribInt;
        struct
        {
            int     Len;
            u_char  OctetSeq[1];
            u_char  Reserved[3];
        } irdaAttribOctetSeq;
        struct
        {
            int     Len;
            u_char  CharSet;
            u_char  UsrStr[1];
            u_char  Reserved[2];
        } irdaAttribUsrStr;
    } irdaAttribute;
} WCE_IAS_QUERY, *PWCE_IAS_QUERY;

#if   defined(_WIN32_WINNT) || defined(_WIN32_WINDOWS)
typedef WINDOWS_IAS_SET         IAS_SET, *PIAS_SET, FAR *LPIASSET;
typedef WINDOWS_IAS_QUERY       IAS_QUERY, *PIAS_QUERY, FAR *LPIASQUERY;
#elif defined(_WIN32_WCE)
typedef WCE_IAS_SET             IAS_SET, *PIAS_SET;
typedef WCE_IAS_QUERY           IAS_QUERY, *PIAS_QUERY, FAR *LPIASQUERY;
#else
#pragma message("One of _WIN32_WINNT | _WIN32_WINDOWS | _WIN32_WCE must be defined.")
#endif

#endif // __AFIRDA__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\public\sdk\inc\adptif.h ===
/*++

Copyright (c) 1995-1999  Microsoft Corporation

Module Name:


Abstract:
	Router interface with IPX stack (to be replaced by WinSock 2.0)


Author:

	Vadim Eydelman

Revision History:

--*/
#ifndef _IPX_ADAPTER_
#define _IPX_ADAPTER_

#if _MSC_VER > 1000
#pragma once
#endif

typedef struct _ADDRESS_RESERVED {
	UCHAR			Reserved[28];
} ADDRESS_RESERVED, *PADDRESS_RESERVED;

/*++

        C r e a t e S o c k e t P o r t

Routine Description:

	Creates port to communicate over IPX socket with direct access to NIC

Arguments:
	Socket	- IPX socket number to use (network byte order)

Return Value:
	Handle to communication port that provides NIC oriented interface
	to IPX stack.  Returns INVALID_HANDLE_VALUE if port can not be opened

--*/
HANDLE WINAPI
CreateSocketPort (
	IN USHORT	Socket
);

/*++

        D e l e t e S o c k e t P o r t

Routine Description:

	Cancel all the outstandng requests and dispose of all the resources
	allocated for communication port

Arguments:

	Handle	- Handle to communication port to be disposed of

Return Value:

	NO_ERROR - success
	Windows error code - operation failed
--*/
DWORD WINAPI
DeleteSocketPort (
	IN HANDLE	Handle
);

/*++

        I p x R e c v P a c k e t

Routine Description:

	Enqueue request to receive IPX packet.

Arguments:
	Handle			- Handle to socket port to use
	IpxPacket		- buffer for ipx packet (complete with header)
	IpxPacketLength - length of the buffer
	pReserved		- buffer to exchange NIC information with IPX stack
					(current implementation requires that memory allocated
					for this buffer is immediately followed by the
					IpxPacket buffer)
	lpOverlapped	- structure to be used for async IO, fields are set
					as follows:
						Internal		- Reserved, must be 0
						InternalHigh	- Reserved, must be 0
						Offset			- Reserved, must be 0
						OffsetHigh		- Reserved, must be 0
						hEvent			- event to be signalled when IO
										completes or NULL if CompletionRoutine
										is to be called
	CompletionRoutine -  to be called when IO operation is completes

Return Value:

	NO_ERROR		- if lpOverlapped->hEvent!=NULL, then receive has
					successfully completed (do not need to wait on event,
					however it will be signalled anyway), otherwise,
					receive operation has started and completion routine will
					be called when done (possibly it has been called even
					before this routine returned)
	ERROR_IO_PENDING - only returned if lpOverlapped->hEvent!=NULL and
					receive could not be completed immediately, event will
					be signalled when operation is done:
					call GetOverlapedResult to retrieve result of
					the operation
	other (windows error code) - operation could not be started
					(completion routine won't be called/event won't be
					signalled)
--*/
DWORD WINAPI
IpxRecvPacket (
	IN HANDLE 							Handle,
	OUT PUCHAR 							IpxPacket,
	IN ULONG							IpxPacketLength,
	OUT PADDRESS_RESERVED				lpReserved,
	IN LPOVERLAPPED						lpOverlapped,
	IN LPOVERLAPPED_COMPLETION_ROUTINE	CompletionRoutine
);

/* Use this to retrieve NIC index once IO completes */
#define  GetNicIdx(pReserved)	((ULONG)*((USHORT *)(pReserved+2)))


/*++

        I p x S e n d P a c k e t

Routine Description:

	Enqueue request to send IPX packet.

Arguments:

	Handle			- Handle to socket port to use
	AdapterIdx		- NIC index on which to send
	IpxPacket		- IPX packet complete with header
	IpxPacketLength - length of the packet
	pReserved		- buffer to exchange NIC info with IPX stack
	lpOverlapped	- structure to be used for async IO, fields are set
					as follows:
						Internal		- Reserved, must be 0
						InternalHigh	- Reserved, must be 0
						Offset			- Reserved, must be 0
						OffsetHigh		- Reserved, must be 0
						hEvent			- event to be signalled when IO
										completes or NULL if CompletionRoutine
										is to be called
	CompletionRoutine -  to be called when IO operation is completes

Return Value:

	NO_ERROR		- if lpOverlapped->hEvent!=NULL, then send has
					successfully completed (do not need to wait on event,
					however it will be signalled anyway), otherwise,
					send operation has started and completion routine will
					be called when done (possibly it has been called even
					before this routine returned)
	ERROR_IO_PENDING - only returned if lpOverlapped->hEvent!=NULL and
					send could not be completed immediately, event will
					be signalled when operation is done:
					call GetOverlapedResult to retrieve result of
					the operation
	other (windows error code) - operation could not be started
					(completion routine won't be called/event won't be
					signalled)

--*/
DWORD WINAPI
IpxSendPacket (
	IN HANDLE							Handle,
	IN ULONG							AdapterIdx,
	IN PUCHAR							IpxPacket,
	IN ULONG							IpxPacketLength,
	IN PADDRESS_RESERVED				lpReserved,
	IN LPOVERLAPPED						lpOverlapped,
	IN LPOVERLAPPED_COMPLETION_ROUTINE	CompletionRoutine
);

#endif // _IPX_ADAPTER_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\public\sdk\inc\activscp.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0266 */
/* at Fri May 21 21:54:26 1999
 */
/* Compiler settings for activscp.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __activscp_h__
#define __activscp_h__

/* Forward Declarations */ 

#ifndef __IActiveScriptSite_FWD_DEFINED__
#define __IActiveScriptSite_FWD_DEFINED__
typedef interface IActiveScriptSite IActiveScriptSite;
#endif 	/* __IActiveScriptSite_FWD_DEFINED__ */


#ifndef __IActiveScriptError_FWD_DEFINED__
#define __IActiveScriptError_FWD_DEFINED__
typedef interface IActiveScriptError IActiveScriptError;
#endif 	/* __IActiveScriptError_FWD_DEFINED__ */


#ifndef __IActiveScriptSiteWindow_FWD_DEFINED__
#define __IActiveScriptSiteWindow_FWD_DEFINED__
typedef interface IActiveScriptSiteWindow IActiveScriptSiteWindow;
#endif 	/* __IActiveScriptSiteWindow_FWD_DEFINED__ */


#ifndef __IActiveScriptSiteInterruptPoll_FWD_DEFINED__
#define __IActiveScriptSiteInterruptPoll_FWD_DEFINED__
typedef interface IActiveScriptSiteInterruptPoll IActiveScriptSiteInterruptPoll;
#endif 	/* __IActiveScriptSiteInterruptPoll_FWD_DEFINED__ */


#ifndef __IActiveScript_FWD_DEFINED__
#define __IActiveScript_FWD_DEFINED__
typedef interface IActiveScript IActiveScript;
#endif 	/* __IActiveScript_FWD_DEFINED__ */


#ifndef __IActiveScriptParse_FWD_DEFINED__
#define __IActiveScriptParse_FWD_DEFINED__
typedef interface IActiveScriptParse IActiveScriptParse;
#endif 	/* __IActiveScriptParse_FWD_DEFINED__ */


#ifndef __IActiveScriptParseProcedureOld_FWD_DEFINED__
#define __IActiveScriptParseProcedureOld_FWD_DEFINED__
typedef interface IActiveScriptParseProcedureOld IActiveScriptParseProcedureOld;
#endif 	/* __IActiveScriptParseProcedureOld_FWD_DEFINED__ */


#ifndef __IActiveScriptParseProcedure_FWD_DEFINED__
#define __IActiveScriptParseProcedure_FWD_DEFINED__
typedef interface IActiveScriptParseProcedure IActiveScriptParseProcedure;
#endif 	/* __IActiveScriptParseProcedure_FWD_DEFINED__ */


#ifndef __IActiveScriptParseProcedure2_FWD_DEFINED__
#define __IActiveScriptParseProcedure2_FWD_DEFINED__
typedef interface IActiveScriptParseProcedure2 IActiveScriptParseProcedure2;
#endif 	/* __IActiveScriptParseProcedure2_FWD_DEFINED__ */


#ifndef __IActiveScriptEncode_FWD_DEFINED__
#define __IActiveScriptEncode_FWD_DEFINED__
typedef interface IActiveScriptEncode IActiveScriptEncode;
#endif 	/* __IActiveScriptEncode_FWD_DEFINED__ */


#ifndef __IActiveScriptHostEncode_FWD_DEFINED__
#define __IActiveScriptHostEncode_FWD_DEFINED__
typedef interface IActiveScriptHostEncode IActiveScriptHostEncode;
#endif 	/* __IActiveScriptHostEncode_FWD_DEFINED__ */


#ifndef __IBindEventHandler_FWD_DEFINED__
#define __IBindEventHandler_FWD_DEFINED__
typedef interface IBindEventHandler IBindEventHandler;
#endif 	/* __IBindEventHandler_FWD_DEFINED__ */


#ifndef __IActiveScriptStats_FWD_DEFINED__
#define __IActiveScriptStats_FWD_DEFINED__
typedef interface IActiveScriptStats IActiveScriptStats;
#endif 	/* __IActiveScriptStats_FWD_DEFINED__ */


#ifndef __IActiveScriptProperty_FWD_DEFINED__
#define __IActiveScriptProperty_FWD_DEFINED__
typedef interface IActiveScriptProperty IActiveScriptProperty;
#endif 	/* __IActiveScriptProperty_FWD_DEFINED__ */


#ifndef __ITridentEventSink_FWD_DEFINED__
#define __ITridentEventSink_FWD_DEFINED__
typedef interface ITridentEventSink ITridentEventSink;
#endif 	/* __ITridentEventSink_FWD_DEFINED__ */


/* header files for imported files */
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_activscp_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// ActivScp.h
//=--------------------------------------------------------------------------=
// (C) Copyright 1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
#pragma comment(lib,"uuid.lib")
//
// Declarations for ActiveX Scripting host applications and script engines.
//

#ifndef __ActivScp_h
#define __ActivScp_h

/* GUIDs
 ********/

#ifndef _NO_SCRIPT_GUIDS
// {F0B7A1A1-9847-11cf-8F20-00805F2CD064}
DEFINE_GUID(CATID_ActiveScript, 0xf0b7a1a1, 0x9847, 0x11cf, 0x8f, 0x20, 0x0, 0x80, 0x5f, 0x2c, 0xd0, 0x64);

// {F0B7A1A2-9847-11cf-8F20-00805F2CD064}
DEFINE_GUID(CATID_ActiveScriptParse, 0xf0b7a1a2, 0x9847, 0x11cf, 0x8f, 0x20, 0x0, 0x80, 0x5f, 0x2c, 0xd0, 0x64);

// {F0B7A1A3-9847-11cf-8F20-00805F2CD064}
DEFINE_GUID(CATID_ActiveScriptEncode, 0xf0b7a1a3, 0x9847, 0x11cf, 0x8f, 0x20, 0x0, 0x80, 0x5f, 0x2c, 0xd0, 0x64);

// {BB1A2AE1-A4F9-11cf-8F20-00805F2CD064}
DEFINE_GUID(IID_IActiveScript, 0xbb1a2ae1, 0xa4f9, 0x11cf, 0x8f, 0x20, 0x0, 0x80, 0x5f, 0x2c, 0xd0, 0x64);

// {BB1A2AE2-A4F9-11cf-8F20-00805F2CD064}
DEFINE_GUID(IID_IActiveScriptParse, 0xbb1a2ae2, 0xa4f9, 0x11cf, 0x8f, 0x20, 0x0, 0x80, 0x5f, 0x2c, 0xd0, 0x64);

// {BB1A2AE3-A4F9-11cf-8F20-00805F2CD064}
DEFINE_GUID(IID_IActiveScriptEncode, 0xbb1a2ae3, 0xa4f9, 0x11cf, 0x8f, 0x20, 0x0, 0x80, 0x5f, 0x2c, 0xd0, 0x64);

// {BEE9B76E-CFE3-11d1-B747-00C04FC2B085}
DEFINE_GUID(IID_IActiveScriptHostEncode, 0xbee9b76e, 0xcfe3, 0x11d1, 0xb7, 0x47, 0x0, 0xc0, 0x4f, 0xc2, 0xb0, 0x85);

// {1CFF0050-6FDD-11d0-9328-00A0C90DCAA9}
DEFINE_GUID(IID_IActiveScriptParseProcedureOld, 0x1cff0050, 0x6fdd, 0x11d0, 0x93, 0x28, 0x0, 0xa0, 0xc9, 0xd, 0xca, 0xa9);

// {AA5B6A80-B834-11d0-932F-00A0C90DCAA9}
DEFINE_GUID(IID_IActiveScriptParseProcedure, 0xaa5b6a80, 0xb834, 0x11d0, 0x93, 0x2f, 0x0, 0xa0, 0xc9, 0xd, 0xca, 0xa9);

// {71EE5B20-FB04-11d1-B3A8-00A0C911E8B2}
DEFINE_GUID(IID_IActiveScriptParseProcedure2, 0x71ee5b20, 0xfb04, 0x11d1, 0xb3, 0xa8, 0x0, 0xa0, 0xc9, 0x11, 0xe8, 0xb2);

// {DB01A1E3-A42B-11cf-8F20-00805F2CD064}
DEFINE_GUID(IID_IActiveScriptSite, 0xdb01a1e3, 0xa42b, 0x11cf, 0x8f, 0x20, 0x0, 0x80, 0x5f, 0x2c, 0xd0, 0x64);

// {D10F6761-83E9-11cf-8F20-00805F2CD064}
DEFINE_GUID(IID_IActiveScriptSiteWindow, 0xd10f6761, 0x83e9, 0x11cf, 0x8f, 0x20, 0x0, 0x80, 0x5f, 0x2c, 0xd0, 0x64);

// {539698A0-CDCA-11CF-A5EB-00AA0047A063}
DEFINE_GUID(IID_IActiveScriptSiteInterruptPoll, 0x539698a0, 0xcdca, 0x11cf, 0xa5, 0xeb, 0x00, 0xaa, 0x00, 0x47, 0xa0, 0x63);

// {EAE1BA61-A4ED-11cf-8F20-00805F2CD064}
DEFINE_GUID(IID_IActiveScriptError, 0xeae1ba61, 0xa4ed, 0x11cf, 0x8f, 0x20, 0x0, 0x80, 0x5f, 0x2c, 0xd0, 0x64);

// {63CDBCB0-C1B1-11d0-9336-00A0C90DCAA9}
DEFINE_GUID(IID_IBindEventHandler, 0x63cdbcb0, 0xc1b1, 0x11d0, 0x93, 0x36, 0x0, 0xa0, 0xc9, 0xd, 0xca, 0xa9);

// {B8DA6310-E19B-11d0-933C-00A0C90DCAA9}
DEFINE_GUID(IID_IActiveScriptStats, 0xb8da6310, 0xe19b, 0x11d0, 0x93, 0x3c, 0x0, 0xa0, 0xc9, 0xd, 0xca, 0xa9);

// {4954E0D0-FBC7-11D1-8410-006008C3FBFC}
DEFINE_GUID(IID_IActiveScriptProperty, 0x4954E0D0, 0xFBC7, 0x11D1, 0x84, 0x10, 0x00, 0x60, 0x08, 0xC3, 0xFB, 0xFC);

// {1DC9CA50-06EF-11d2-8415-006008C3FBFC}
DEFINE_GUID(IID_ITridentEventSink, 0x1dc9ca50, 0x6ef, 0x11d2, 0x84, 0x15, 0x0, 0x60, 0x8, 0xc3, 0xfb, 0xfc);

#endif // _NO_SCRIPT_GUIDS

// Constants used by ActiveX Scripting:
//

/* IActiveScript::AddNamedItem() input flags */

#define SCRIPTITEM_ISVISIBLE            0x00000002
#define SCRIPTITEM_ISSOURCE             0x00000004
#define SCRIPTITEM_GLOBALMEMBERS        0x00000008
#define SCRIPTITEM_ISPERSISTENT         0x00000040
#define SCRIPTITEM_CODEONLY             0x00000200
#define SCRIPTITEM_NOCODE               0x00000400

#define SCRIPTITEM_ALL_FLAGS            (SCRIPTITEM_ISSOURCE | \
                                         SCRIPTITEM_ISVISIBLE | \
                                         SCRIPTITEM_ISPERSISTENT | \
                                         SCRIPTITEM_GLOBALMEMBERS | \
                                         SCRIPTITEM_NOCODE | \
                                         SCRIPTITEM_CODEONLY)

/* IActiveScript::AddTypeLib() input flags */

#define SCRIPTTYPELIB_ISCONTROL         0x00000010
#define SCRIPTTYPELIB_ISPERSISTENT      0x00000040
#define SCRIPTTYPELIB_ALL_FLAGS         (SCRIPTTYPELIB_ISCONTROL | SCRIPTTYPELIB_ISPERSISTENT)

/* IActiveScriptParse::AddScriptlet() and IActiveScriptParse::ParseScriptText() input flags */

#define SCRIPTTEXT_DELAYEXECUTION       0x00000001
#define SCRIPTTEXT_ISVISIBLE            0x00000002
#define SCRIPTTEXT_ISEXPRESSION         0x00000020
#define SCRIPTTEXT_ISPERSISTENT         0x00000040
#define SCRIPTTEXT_HOSTMANAGESSOURCE    0x00000080
#define SCRIPTTEXT_ALL_FLAGS            (SCRIPTTEXT_DELAYEXECUTION | \
                                         SCRIPTTEXT_ISVISIBLE | \
                                         SCRIPTTEXT_ISEXPRESSION | \
                                         SCRIPTTEXT_ISPERSISTENT | \
                                         SCRIPTTEXT_HOSTMANAGESSOURCE)

/* IActiveScriptParseProcedure::ParseProcedureText() input flags */

#define SCRIPTPROC_ISEXPRESSION         0x00000020
#define SCRIPTPROC_HOSTMANAGESSOURCE    0x00000080
#define SCRIPTPROC_IMPLICIT_THIS        0x00000100
#define SCRIPTPROC_IMPLICIT_PARENTS     0x00000200
#define SCRIPTPROC_ALL_FLAGS            (SCRIPTPROC_HOSTMANAGESSOURCE | \
                                         SCRIPTPROC_ISEXPRESSION | \
                                         SCRIPTPROC_IMPLICIT_THIS | \
                                         SCRIPTPROC_IMPLICIT_PARENTS)

/* IActiveScriptSite::GetItemInfo() input flags */

#define SCRIPTINFO_IUNKNOWN             0x00000001
#define SCRIPTINFO_ITYPEINFO            0x00000002
#define SCRIPTINFO_ALL_FLAGS            (SCRIPTINFO_IUNKNOWN | \
                                         SCRIPTINFO_ITYPEINFO)

/* IActiveScript::Interrupt() Flags */

#define SCRIPTINTERRUPT_DEBUG           0x00000001
#define SCRIPTINTERRUPT_RAISEEXCEPTION  0x00000002
#define SCRIPTINTERRUPT_ALL_FLAGS       (SCRIPTINTERRUPT_DEBUG | \
                                         SCRIPTINTERRUPT_RAISEEXCEPTION)

/* IActiveScriptStats::GetStat() values */

#define SCRIPTSTAT_STATEMENT_COUNT       1
#define SCRIPTSTAT_INSTRUCTION_COUNT     2
#define SCRIPTSTAT_INTSTRUCTION_TIME     3
#define SCRIPTSTAT_TOTAL_TIME            4

/* IActiveScriptEncode::AddSection() input flags */

#define SCRIPT_ENCODE_SECTION         0x00000001

#define SCRIPT_ENCODE_DEFAULT_LANGUAGE        0x00000001

/* Properties for IActiveScriptProperty */
#define SCRIPTPROP_NAME                     0x00000000
#define SCRIPTPROP_MAJORVERSION             0x00000001
#define SCRIPTPROP_MINORVERSION             0x00000002
#define SCRIPTPROP_BUILDNUMBER              0x00000003

#define SCRIPTPROP_DELAYEDEVENTSINKING      0x00001000
#define SCRIPTPROP_CATCHEXCEPTION           0x00001001

#define SCRIPTPROP_DEBUGGER                 0x00001100
#define SCRIPTPROP_JITDEBUG                 0x00001101

// These properties are defined and available, but are not
// officially supported.
#define SCRIPTPROP_HACK_FIBERSUPPORT        0x70000000
#define SCRIPTPROP_HACK_TRIDENTEVENTSINK    0x70000001

typedef 
enum tagSCRIPTSTATE
    {	SCRIPTSTATE_UNINITIALIZED	= 0,
	SCRIPTSTATE_INITIALIZED	= 5,
	SCRIPTSTATE_STARTED	= 1,
	SCRIPTSTATE_CONNECTED	= 2,
	SCRIPTSTATE_DISCONNECTED	= 3,
	SCRIPTSTATE_CLOSED	= 4
    }	SCRIPTSTATE;


/* script thread state values */

typedef 
enum tagSCRIPTTHREADSTATE
    {	SCRIPTTHREADSTATE_NOTINSCRIPT	= 0,
	SCRIPTTHREADSTATE_RUNNING	= 1
    }	SCRIPTTHREADSTATE;


/* Thread IDs */

typedef DWORD SCRIPTTHREADID;


#define SCRIPTTHREADID_CURRENT  ((SCRIPTTHREADID)-1)
#define SCRIPTTHREADID_BASE     ((SCRIPTTHREADID)-2)
#define SCRIPTTHREADID_ALL      ((SCRIPTTHREADID)-3)

/* Structures */

/* Interfaces
 *************/











extern RPC_IF_HANDLE __MIDL_itf_activscp_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_activscp_0000_v0_0_s_ifspec;

#ifndef __IActiveScriptSite_INTERFACE_DEFINED__
#define __IActiveScriptSite_INTERFACE_DEFINED__

/* interface IActiveScriptSite */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveScriptSite;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DB01A1E3-A42B-11cf-8F20-00805F2CD064")
    IActiveScriptSite : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetLCID( 
            /* [out] */ LCID __RPC_FAR *plcid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetItemInfo( 
            /* [in] */ LPCOLESTR pstrName,
            /* [in] */ DWORD dwReturnMask,
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppiunkItem,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppti) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDocVersionString( 
            /* [out] */ BSTR __RPC_FAR *pbstrVersion) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnScriptTerminate( 
            /* [in] */ const VARIANT __RPC_FAR *pvarResult,
            /* [in] */ const EXCEPINFO __RPC_FAR *pexcepinfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnStateChange( 
            /* [in] */ SCRIPTSTATE ssScriptState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnScriptError( 
            /* [in] */ IActiveScriptError __RPC_FAR *pscripterror) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnEnterScript( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnLeaveScript( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveScriptSiteVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IActiveScriptSite __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IActiveScriptSite __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IActiveScriptSite __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLCID )( 
            IActiveScriptSite __RPC_FAR * This,
            /* [out] */ LCID __RPC_FAR *plcid);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetItemInfo )( 
            IActiveScriptSite __RPC_FAR * This,
            /* [in] */ LPCOLESTR pstrName,
            /* [in] */ DWORD dwReturnMask,
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppiunkItem,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppti);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDocVersionString )( 
            IActiveScriptSite __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstrVersion);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnScriptTerminate )( 
            IActiveScriptSite __RPC_FAR * This,
            /* [in] */ const VARIANT __RPC_FAR *pvarResult,
            /* [in] */ const EXCEPINFO __RPC_FAR *pexcepinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnStateChange )( 
            IActiveScriptSite __RPC_FAR * This,
            /* [in] */ SCRIPTSTATE ssScriptState);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnScriptError )( 
            IActiveScriptSite __RPC_FAR * This,
            /* [in] */ IActiveScriptError __RPC_FAR *pscripterror);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnEnterScript )( 
            IActiveScriptSite __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnLeaveScript )( 
            IActiveScriptSite __RPC_FAR * This);
        
        END_INTERFACE
    } IActiveScriptSiteVtbl;

    interface IActiveScriptSite
    {
        CONST_VTBL struct IActiveScriptSiteVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveScriptSite_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActiveScriptSite_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActiveScriptSite_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActiveScriptSite_GetLCID(This,plcid)	\
    (This)->lpVtbl -> GetLCID(This,plcid)

#define IActiveScriptSite_GetItemInfo(This,pstrName,dwReturnMask,ppiunkItem,ppti)	\
    (This)->lpVtbl -> GetItemInfo(This,pstrName,dwReturnMask,ppiunkItem,ppti)

#define IActiveScriptSite_GetDocVersionString(This,pbstrVersion)	\
    (This)->lpVtbl -> GetDocVersionString(This,pbstrVersion)

#define IActiveScriptSite_OnScriptTerminate(This,pvarResult,pexcepinfo)	\
    (This)->lpVtbl -> OnScriptTerminate(This,pvarResult,pexcepinfo)

#define IActiveScriptSite_OnStateChange(This,ssScriptState)	\
    (This)->lpVtbl -> OnStateChange(This,ssScriptState)

#define IActiveScriptSite_OnScriptError(This,pscripterror)	\
    (This)->lpVtbl -> OnScriptError(This,pscripterror)

#define IActiveScriptSite_OnEnterScript(This)	\
    (This)->lpVtbl -> OnEnterScript(This)

#define IActiveScriptSite_OnLeaveScript(This)	\
    (This)->lpVtbl -> OnLeaveScript(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IActiveScriptSite_GetLCID_Proxy( 
    IActiveScriptSite __RPC_FAR * This,
    /* [out] */ LCID __RPC_FAR *plcid);


void __RPC_STUB IActiveScriptSite_GetLCID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveScriptSite_GetItemInfo_Proxy( 
    IActiveScriptSite __RPC_FAR * This,
    /* [in] */ LPCOLESTR pstrName,
    /* [in] */ DWORD dwReturnMask,
    /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppiunkItem,
    /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppti);


void __RPC_STUB IActiveScriptSite_GetItemInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveScriptSite_GetDocVersionString_Proxy( 
    IActiveScriptSite __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pbstrVersion);


void __RPC_STUB IActiveScriptSite_GetDocVersionString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveScriptSite_OnScriptTerminate_Proxy( 
    IActiveScriptSite __RPC_FAR * This,
    /* [in] */ const VARIANT __RPC_FAR *pvarResult,
    /* [in] */ const EXCEPINFO __RPC_FAR *pexcepinfo);


void __RPC_STUB IActiveScriptSite_OnScriptTerminate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveScriptSite_OnStateChange_Proxy( 
    IActiveScriptSite __RPC_FAR * This,
    /* [in] */ SCRIPTSTATE ssScriptState);


void __RPC_STUB IActiveScriptSite_OnStateChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveScriptSite_OnScriptError_Proxy( 
    IActiveScriptSite __RPC_FAR * This,
    /* [in] */ IActiveScriptError __RPC_FAR *pscripterror);


void __RPC_STUB IActiveScriptSite_OnScriptError_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveScriptSite_OnEnterScript_Proxy( 
    IActiveScriptSite __RPC_FAR * This);


void __RPC_STUB IActiveScriptSite_OnEnterScript_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveScriptSite_OnLeaveScript_Proxy( 
    IActiveScriptSite __RPC_FAR * This);


void __RPC_STUB IActiveScriptSite_OnLeaveScript_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActiveScriptSite_INTERFACE_DEFINED__ */


#ifndef __IActiveScriptError_INTERFACE_DEFINED__
#define __IActiveScriptError_INTERFACE_DEFINED__

/* interface IActiveScriptError */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveScriptError;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EAE1BA61-A4ED-11cf-8F20-00805F2CD064")
    IActiveScriptError : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetExceptionInfo( 
            /* [out] */ EXCEPINFO __RPC_FAR *pexcepinfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSourcePosition( 
            /* [out] */ DWORD __RPC_FAR *pdwSourceContext,
            /* [out] */ ULONG __RPC_FAR *pulLineNumber,
            /* [out] */ LONG __RPC_FAR *plCharacterPosition) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSourceLineText( 
            /* [out] */ BSTR __RPC_FAR *pbstrSourceLine) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveScriptErrorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IActiveScriptError __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IActiveScriptError __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IActiveScriptError __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetExceptionInfo )( 
            IActiveScriptError __RPC_FAR * This,
            /* [out] */ EXCEPINFO __RPC_FAR *pexcepinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSourcePosition )( 
            IActiveScriptError __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwSourceContext,
            /* [out] */ ULONG __RPC_FAR *pulLineNumber,
            /* [out] */ LONG __RPC_FAR *plCharacterPosition);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSourceLineText )( 
            IActiveScriptError __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstrSourceLine);
        
        END_INTERFACE
    } IActiveScriptErrorVtbl;

    interface IActiveScriptError
    {
        CONST_VTBL struct IActiveScriptErrorVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveScriptError_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActiveScriptError_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActiveScriptError_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActiveScriptError_GetExceptionInfo(This,pexcepinfo)	\
    (This)->lpVtbl -> GetExceptionInfo(This,pexcepinfo)

#define IActiveScriptError_GetSourcePosition(This,pdwSourceContext,pulLineNumber,plCharacterPosition)	\
    (This)->lpVtbl -> GetSourcePosition(This,pdwSourceContext,pulLineNumber,plCharacterPosition)

#define IActiveScriptError_GetSourceLineText(This,pbstrSourceLine)	\
    (This)->lpVtbl -> GetSourceLineText(This,pbstrSourceLine)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IActiveScriptError_GetExceptionInfo_Proxy( 
    IActiveScriptError __RPC_FAR * This,
    /* [out] */ EXCEPINFO __RPC_FAR *pexcepinfo);


void __RPC_STUB IActiveScriptError_GetExceptionInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveScriptError_GetSourcePosition_Proxy( 
    IActiveScriptError __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwSourceContext,
    /* [out] */ ULONG __RPC_FAR *pulLineNumber,
    /* [out] */ LONG __RPC_FAR *plCharacterPosition);


void __RPC_STUB IActiveScriptError_GetSourcePosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveScriptError_GetSourceLineText_Proxy( 
    IActiveScriptError __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pbstrSourceLine);


void __RPC_STUB IActiveScriptError_GetSourceLineText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActiveScriptError_INTERFACE_DEFINED__ */


#ifndef __IActiveScriptSiteWindow_INTERFACE_DEFINED__
#define __IActiveScriptSiteWindow_INTERFACE_DEFINED__

/* interface IActiveScriptSiteWindow */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveScriptSiteWindow;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D10F6761-83E9-11cf-8F20-00805F2CD064")
    IActiveScriptSiteWindow : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetWindow( 
            /* [out] */ HWND __RPC_FAR *phwnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnableModeless( 
            /* [in] */ BOOL fEnable) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveScriptSiteWindowVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IActiveScriptSiteWindow __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IActiveScriptSiteWindow __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IActiveScriptSiteWindow __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetWindow )( 
            IActiveScriptSiteWindow __RPC_FAR * This,
            /* [out] */ HWND __RPC_FAR *phwnd);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnableModeless )( 
            IActiveScriptSiteWindow __RPC_FAR * This,
            /* [in] */ BOOL fEnable);
        
        END_INTERFACE
    } IActiveScriptSiteWindowVtbl;

    interface IActiveScriptSiteWindow
    {
        CONST_VTBL struct IActiveScriptSiteWindowVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveScriptSiteWindow_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActiveScriptSiteWindow_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActiveScriptSiteWindow_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActiveScriptSiteWindow_GetWindow(This,phwnd)	\
    (This)->lpVtbl -> GetWindow(This,phwnd)

#define IActiveScriptSiteWindow_EnableModeless(This,fEnable)	\
    (This)->lpVtbl -> EnableModeless(This,fEnable)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IActiveScriptSiteWindow_GetWindow_Proxy( 
    IActiveScriptSiteWindow __RPC_FAR * This,
    /* [out] */ HWND __RPC_FAR *phwnd);


void __RPC_STUB IActiveScriptSiteWindow_GetWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveScriptSiteWindow_EnableModeless_Proxy( 
    IActiveScriptSiteWindow __RPC_FAR * This,
    /* [in] */ BOOL fEnable);


void __RPC_STUB IActiveScriptSiteWindow_EnableModeless_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActiveScriptSiteWindow_INTERFACE_DEFINED__ */


#ifndef __IActiveScriptSiteInterruptPoll_INTERFACE_DEFINED__
#define __IActiveScriptSiteInterruptPoll_INTERFACE_DEFINED__

/* interface IActiveScriptSiteInterruptPoll */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveScriptSiteInterruptPoll;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("539698A0-CDCA-11CF-A5EB-00AA0047A063")
    IActiveScriptSiteInterruptPoll : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE QueryContinue( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveScriptSiteInterruptPollVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IActiveScriptSiteInterruptPoll __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IActiveScriptSiteInterruptPoll __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IActiveScriptSiteInterruptPoll __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryContinue )( 
            IActiveScriptSiteInterruptPoll __RPC_FAR * This);
        
        END_INTERFACE
    } IActiveScriptSiteInterruptPollVtbl;

    interface IActiveScriptSiteInterruptPoll
    {
        CONST_VTBL struct IActiveScriptSiteInterruptPollVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveScriptSiteInterruptPoll_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActiveScriptSiteInterruptPoll_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActiveScriptSiteInterruptPoll_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActiveScriptSiteInterruptPoll_QueryContinue(This)	\
    (This)->lpVtbl -> QueryContinue(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IActiveScriptSiteInterruptPoll_QueryContinue_Proxy( 
    IActiveScriptSiteInterruptPoll __RPC_FAR * This);


void __RPC_STUB IActiveScriptSiteInterruptPoll_QueryContinue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActiveScriptSiteInterruptPoll_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_activscp_0249 */
/* [local] */ 

typedef IActiveScriptSite *PIActiveScriptSite;


extern RPC_IF_HANDLE __MIDL_itf_activscp_0249_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_activscp_0249_v0_0_s_ifspec;

#ifndef __IActiveScript_INTERFACE_DEFINED__
#define __IActiveScript_INTERFACE_DEFINED__

/* interface IActiveScript */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveScript;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BB1A2AE1-A4F9-11cf-8F20-00805F2CD064")
    IActiveScript : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetScriptSite( 
            /* [in] */ IActiveScriptSite __RPC_FAR *pass) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetScriptSite( 
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetScriptState( 
            /* [in] */ SCRIPTSTATE ss) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetScriptState( 
            /* [out] */ SCRIPTSTATE __RPC_FAR *pssState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddNamedItem( 
            /* [in] */ LPCOLESTR pstrName,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddTypeLib( 
            /* [in] */ REFGUID rguidTypeLib,
            /* [in] */ DWORD dwMajor,
            /* [in] */ DWORD dwMinor,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetScriptDispatch( 
            /* [in] */ LPCOLESTR pstrItemName,
            /* [out] */ IDispatch __RPC_FAR *__RPC_FAR *ppdisp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentScriptThreadID( 
            /* [out] */ SCRIPTTHREADID __RPC_FAR *pstidThread) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetScriptThreadID( 
            /* [in] */ DWORD dwWin32ThreadId,
            /* [out] */ SCRIPTTHREADID __RPC_FAR *pstidThread) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetScriptThreadState( 
            /* [in] */ SCRIPTTHREADID stidThread,
            /* [out] */ SCRIPTTHREADSTATE __RPC_FAR *pstsState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InterruptScriptThread( 
            /* [in] */ SCRIPTTHREADID stidThread,
            /* [in] */ const EXCEPINFO __RPC_FAR *pexcepinfo,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IActiveScript __RPC_FAR *__RPC_FAR *ppscript) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveScriptVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IActiveScript __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IActiveScript __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IActiveScript __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetScriptSite )( 
            IActiveScript __RPC_FAR * This,
            /* [in] */ IActiveScriptSite __RPC_FAR *pass);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetScriptSite )( 
            IActiveScript __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetScriptState )( 
            IActiveScript __RPC_FAR * This,
            /* [in] */ SCRIPTSTATE ss);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetScriptState )( 
            IActiveScript __RPC_FAR * This,
            /* [out] */ SCRIPTSTATE __RPC_FAR *pssState);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Close )( 
            IActiveScript __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddNamedItem )( 
            IActiveScript __RPC_FAR * This,
            /* [in] */ LPCOLESTR pstrName,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddTypeLib )( 
            IActiveScript __RPC_FAR * This,
            /* [in] */ REFGUID rguidTypeLib,
            /* [in] */ DWORD dwMajor,
            /* [in] */ DWORD dwMinor,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetScriptDispatch )( 
            IActiveScript __RPC_FAR * This,
            /* [in] */ LPCOLESTR pstrItemName,
            /* [out] */ IDispatch __RPC_FAR *__RPC_FAR *ppdisp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCurrentScriptThreadID )( 
            IActiveScript __RPC_FAR * This,
            /* [out] */ SCRIPTTHREADID __RPC_FAR *pstidThread);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetScriptThreadID )( 
            IActiveScript __RPC_FAR * This,
            /* [in] */ DWORD dwWin32ThreadId,
            /* [out] */ SCRIPTTHREADID __RPC_FAR *pstidThread);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetScriptThreadState )( 
            IActiveScript __RPC_FAR * This,
            /* [in] */ SCRIPTTHREADID stidThread,
            /* [out] */ SCRIPTTHREADSTATE __RPC_FAR *pstsState);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InterruptScriptThread )( 
            IActiveScript __RPC_FAR * This,
            /* [in] */ SCRIPTTHREADID stidThread,
            /* [in] */ const EXCEPINFO __RPC_FAR *pexcepinfo,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IActiveScript __RPC_FAR * This,
            /* [out] */ IActiveScript __RPC_FAR *__RPC_FAR *ppscript);
        
        END_INTERFACE
    } IActiveScriptVtbl;

    interface IActiveScript
    {
        CONST_VTBL struct IActiveScriptVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveScript_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActiveScript_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActiveScript_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActiveScript_SetScriptSite(This,pass)	\
    (This)->lpVtbl -> SetScriptSite(This,pass)

#define IActiveScript_GetScriptSite(This,riid,ppvObject)	\
    (This)->lpVtbl -> GetScriptSite(This,riid,ppvObject)

#define IActiveScript_SetScriptState(This,ss)	\
    (This)->lpVtbl -> SetScriptState(This,ss)

#define IActiveScript_GetScriptState(This,pssState)	\
    (This)->lpVtbl -> GetScriptState(This,pssState)

#define IActiveScript_Close(This)	\
    (This)->lpVtbl -> Close(This)

#define IActiveScript_AddNamedItem(This,pstrName,dwFlags)	\
    (This)->lpVtbl -> AddNamedItem(This,pstrName,dwFlags)

#define IActiveScript_AddTypeLib(This,rguidTypeLib,dwMajor,dwMinor,dwFlags)	\
    (This)->lpVtbl -> AddTypeLib(This,rguidTypeLib,dwMajor,dwMinor,dwFlags)

#define IActiveScript_GetScriptDispatch(This,pstrItemName,ppdisp)	\
    (This)->lpVtbl -> GetScriptDispatch(This,pstrItemName,ppdisp)

#define IActiveScript_GetCurrentScriptThreadID(This,pstidThread)	\
    (This)->lpVtbl -> GetCurrentScriptThreadID(This,pstidThread)

#define IActiveScript_GetScriptThreadID(This,dwWin32ThreadId,pstidThread)	\
    (This)->lpVtbl -> GetScriptThreadID(This,dwWin32ThreadId,pstidThread)

#define IActiveScript_GetScriptThreadState(This,stidThread,pstsState)	\
    (This)->lpVtbl -> GetScriptThreadState(This,stidThread,pstsState)

#define IActiveScript_InterruptScriptThread(This,stidThread,pexcepinfo,dwFlags)	\
    (This)->lpVtbl -> InterruptScriptThread(This,stidThread,pexcepinfo,dwFlags)

#define IActiveScript_Clone(This,ppscript)	\
    (This)->lpVtbl -> Clone(This,ppscript)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IActiveScript_SetScriptSite_Proxy( 
    IActiveScript __RPC_FAR * This,
    /* [in] */ IActiveScriptSite __RPC_FAR *pass);


void __RPC_STUB IActiveScript_SetScriptSite_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveScript_GetScriptSite_Proxy( 
    IActiveScript __RPC_FAR * This,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);


void __RPC_STUB IActiveScript_GetScriptSite_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveScript_SetScriptState_Proxy( 
    IActiveScript __RPC_FAR * This,
    /* [in] */ SCRIPTSTATE ss);


void __RPC_STUB IActiveScript_SetScriptState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveScript_GetScriptState_Proxy( 
    IActiveScript __RPC_FAR * This,
    /* [out] */ SCRIPTSTATE __RPC_FAR *pssState);


void __RPC_STUB IActiveScript_GetScriptState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveScript_Close_Proxy( 
    IActiveScript __RPC_FAR * This);


void __RPC_STUB IActiveScript_Close_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveScript_AddNamedItem_Proxy( 
    IActiveScript __RPC_FAR * This,
    /* [in] */ LPCOLESTR pstrName,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IActiveScript_AddNamedItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveScript_AddTypeLib_Proxy( 
    IActiveScript __RPC_FAR * This,
    /* [in] */ REFGUID rguidTypeLib,
    /* [in] */ DWORD dwMajor,
    /* [in] */ DWORD dwMinor,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IActiveScript_AddTypeLib_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveScript_GetScriptDispatch_Proxy( 
    IActiveScript __RPC_FAR * This,
    /* [in] */ LPCOLESTR pstrItemName,
    /* [out] */ IDispatch __RPC_FAR *__RPC_FAR *ppdisp);


void __RPC_STUB IActiveScript_GetScriptDispatch_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveScript_GetCurrentScriptThreadID_Proxy( 
    IActiveScript __RPC_FAR * This,
    /* [out] */ SCRIPTTHREADID __RPC_FAR *pstidThread);


void __RPC_STUB IActiveScript_GetCurrentScriptThreadID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveScript_GetScriptThreadID_Proxy( 
    IActiveScript __RPC_FAR * This,
    /* [in] */ DWORD dwWin32ThreadId,
    /* [out] */ SCRIPTTHREADID __RPC_FAR *pstidThread);


void __RPC_STUB IActiveScript_GetScriptThreadID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveScript_GetScriptThreadState_Proxy( 
    IActiveScript __RPC_FAR * This,
    /* [in] */ SCRIPTTHREADID stidThread,
    /* [out] */ SCRIPTTHREADSTATE __RPC_FAR *pstsState);


void __RPC_STUB IActiveScript_GetScriptThreadState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveScript_InterruptScriptThread_Proxy( 
    IActiveScript __RPC_FAR * This,
    /* [in] */ SCRIPTTHREADID stidThread,
    /* [in] */ const EXCEPINFO __RPC_FAR *pexcepinfo,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IActiveScript_InterruptScriptThread_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveScript_Clone_Proxy( 
    IActiveScript __RPC_FAR * This,
    /* [out] */ IActiveScript __RPC_FAR *__RPC_FAR *ppscript);


void __RPC_STUB IActiveScript_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActiveScript_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_activscp_0250 */
/* [local] */ 

typedef IActiveScript *PIActiveScript;


extern RPC_IF_HANDLE __MIDL_itf_activscp_0250_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_activscp_0250_v0_0_s_ifspec;

#ifndef __IActiveScriptParse_INTERFACE_DEFINED__
#define __IActiveScriptParse_INTERFACE_DEFINED__

/* interface IActiveScriptParse */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveScriptParse;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BB1A2AE2-A4F9-11cf-8F20-00805F2CD064")
    IActiveScriptParse : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InitNew( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddScriptlet( 
            /* [in] */ LPCOLESTR pstrDefaultName,
            /* [in] */ LPCOLESTR pstrCode,
            /* [in] */ LPCOLESTR pstrItemName,
            /* [in] */ LPCOLESTR pstrSubItemName,
            /* [in] */ LPCOLESTR pstrEventName,
            /* [in] */ LPCOLESTR pstrDelimiter,
            /* [in] */ DWORD dwSourceContextCookie,
            /* [in] */ ULONG ulStartingLineNumber,
            /* [in] */ DWORD dwFlags,
            /* [out] */ BSTR __RPC_FAR *pbstrName,
            /* [out] */ EXCEPINFO __RPC_FAR *pexcepinfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ParseScriptText( 
            /* [in] */ LPCOLESTR pstrCode,
            /* [in] */ LPCOLESTR pstrItemName,
            /* [in] */ IUnknown __RPC_FAR *punkContext,
            /* [in] */ LPCOLESTR pstrDelimiter,
            /* [in] */ DWORD dwSourceContextCookie,
            /* [in] */ ULONG ulStartingLineNumber,
            /* [in] */ DWORD dwFlags,
            /* [out] */ VARIANT __RPC_FAR *pvarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pexcepinfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveScriptParseVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IActiveScriptParse __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IActiveScriptParse __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IActiveScriptParse __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InitNew )( 
            IActiveScriptParse __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddScriptlet )( 
            IActiveScriptParse __RPC_FAR * This,
            /* [in] */ LPCOLESTR pstrDefaultName,
            /* [in] */ LPCOLESTR pstrCode,
            /* [in] */ LPCOLESTR pstrItemName,
            /* [in] */ LPCOLESTR pstrSubItemName,
            /* [in] */ LPCOLESTR pstrEventName,
            /* [in] */ LPCOLESTR pstrDelimiter,
            /* [in] */ DWORD dwSourceContextCookie,
            /* [in] */ ULONG ulStartingLineNumber,
            /* [in] */ DWORD dwFlags,
            /* [out] */ BSTR __RPC_FAR *pbstrName,
            /* [out] */ EXCEPINFO __RPC_FAR *pexcepinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ParseScriptText )( 
            IActiveScriptParse __RPC_FAR * This,
            /* [in] */ LPCOLESTR pstrCode,
            /* [in] */ LPCOLESTR pstrItemName,
            /* [in] */ IUnknown __RPC_FAR *punkContext,
            /* [in] */ LPCOLESTR pstrDelimiter,
            /* [in] */ DWORD dwSourceContextCookie,
            /* [in] */ ULONG ulStartingLineNumber,
            /* [in] */ DWORD dwFlags,
            /* [out] */ VARIANT __RPC_FAR *pvarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pexcepinfo);
        
        END_INTERFACE
    } IActiveScriptParseVtbl;

    interface IActiveScriptParse
    {
        CONST_VTBL struct IActiveScriptParseVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveScriptParse_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActiveScriptParse_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActiveScriptParse_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActiveScriptParse_InitNew(This)	\
    (This)->lpVtbl -> InitNew(This)

#define IActiveScriptParse_AddScriptlet(This,pstrDefaultName,pstrCode,pstrItemName,pstrSubItemName,pstrEventName,pstrDelimiter,dwSourceContextCookie,ulStartingLineNumber,dwFlags,pbstrName,pexcepinfo)	\
    (This)->lpVtbl -> AddScriptlet(This,pstrDefaultName,pstrCode,pstrItemName,pstrSubItemName,pstrEventName,pstrDelimiter,dwSourceContextCookie,ulStartingLineNumber,dwFlags,pbstrName,pexcepinfo)

#define IActiveScriptParse_ParseScriptText(This,pstrCode,pstrItemName,punkContext,pstrDelimiter,dwSourceContextCookie,ulStartingLineNumber,dwFlags,pvarResult,pexcepinfo)	\
    (This)->lpVtbl -> ParseScriptText(This,pstrCode,pstrItemName,punkContext,pstrDelimiter,dwSourceContextCookie,ulStartingLineNumber,dwFlags,pvarResult,pexcepinfo)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IActiveScriptParse_InitNew_Proxy( 
    IActiveScriptParse __RPC_FAR * This);


void __RPC_STUB IActiveScriptParse_InitNew_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveScriptParse_AddScriptlet_Proxy( 
    IActiveScriptParse __RPC_FAR * This,
    /* [in] */ LPCOLESTR pstrDefaultName,
    /* [in] */ LPCOLESTR pstrCode,
    /* [in] */ LPCOLESTR pstrItemName,
    /* [in] */ LPCOLESTR pstrSubItemName,
    /* [in] */ LPCOLESTR pstrEventName,
    /* [in] */ LPCOLESTR pstrDelimiter,
    /* [in] */ DWORD dwSourceContextCookie,
    /* [in] */ ULONG ulStartingLineNumber,
    /* [in] */ DWORD dwFlags,
    /* [out] */ BSTR __RPC_FAR *pbstrName,
    /* [out] */ EXCEPINFO __RPC_FAR *pexcepinfo);


void __RPC_STUB IActiveScriptParse_AddScriptlet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveScriptParse_ParseScriptText_Proxy( 
    IActiveScriptParse __RPC_FAR * This,
    /* [in] */ LPCOLESTR pstrCode,
    /* [in] */ LPCOLESTR pstrItemName,
    /* [in] */ IUnknown __RPC_FAR *punkContext,
    /* [in] */ LPCOLESTR pstrDelimiter,
    /* [in] */ DWORD dwSourceContextCookie,
    /* [in] */ ULONG ulStartingLineNumber,
    /* [in] */ DWORD dwFlags,
    /* [out] */ VARIANT __RPC_FAR *pvarResult,
    /* [out] */ EXCEPINFO __RPC_FAR *pexcepinfo);


void __RPC_STUB IActiveScriptParse_ParseScriptText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActiveScriptParse_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_activscp_0251 */
/* [local] */ 


typedef IActiveScriptParse *PIActiveScriptParse;



extern RPC_IF_HANDLE __MIDL_itf_activscp_0251_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_activscp_0251_v0_0_s_ifspec;

#ifndef __IActiveScriptParseProcedureOld_INTERFACE_DEFINED__
#define __IActiveScriptParseProcedureOld_INTERFACE_DEFINED__

/* interface IActiveScriptParseProcedureOld */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveScriptParseProcedureOld;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1CFF0050-6FDD-11d0-9328-00A0C90DCAA9")
    IActiveScriptParseProcedureOld : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ParseProcedureText( 
            /* [in] */ LPCOLESTR pstrCode,
            /* [in] */ LPCOLESTR pstrFormalParams,
            /* [in] */ LPCOLESTR pstrItemName,
            /* [in] */ IUnknown __RPC_FAR *punkContext,
            /* [in] */ LPCOLESTR pstrDelimiter,
            /* [in] */ DWORD dwSourceContextCookie,
            /* [in] */ ULONG ulStartingLineNumber,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDispatch __RPC_FAR *__RPC_FAR *ppdisp) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveScriptParseProcedureOldVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IActiveScriptParseProcedureOld __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IActiveScriptParseProcedureOld __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IActiveScriptParseProcedureOld __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ParseProcedureText )( 
            IActiveScriptParseProcedureOld __RPC_FAR * This,
            /* [in] */ LPCOLESTR pstrCode,
            /* [in] */ LPCOLESTR pstrFormalParams,
            /* [in] */ LPCOLESTR pstrItemName,
            /* [in] */ IUnknown __RPC_FAR *punkContext,
            /* [in] */ LPCOLESTR pstrDelimiter,
            /* [in] */ DWORD dwSourceContextCookie,
            /* [in] */ ULONG ulStartingLineNumber,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDispatch __RPC_FAR *__RPC_FAR *ppdisp);
        
        END_INTERFACE
    } IActiveScriptParseProcedureOldVtbl;

    interface IActiveScriptParseProcedureOld
    {
        CONST_VTBL struct IActiveScriptParseProcedureOldVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveScriptParseProcedureOld_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActiveScriptParseProcedureOld_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActiveScriptParseProcedureOld_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActiveScriptParseProcedureOld_ParseProcedureText(This,pstrCode,pstrFormalParams,pstrItemName,punkContext,pstrDelimiter,dwSourceContextCookie,ulStartingLineNumber,dwFlags,ppdisp)	\
    (This)->lpVtbl -> ParseProcedureText(This,pstrCode,pstrFormalParams,pstrItemName,punkContext,pstrDelimiter,dwSourceContextCookie,ulStartingLineNumber,dwFlags,ppdisp)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IActiveScriptParseProcedureOld_ParseProcedureText_Proxy( 
    IActiveScriptParseProcedureOld __RPC_FAR * This,
    /* [in] */ LPCOLESTR pstrCode,
    /* [in] */ LPCOLESTR pstrFormalParams,
    /* [in] */ LPCOLESTR pstrItemName,
    /* [in] */ IUnknown __RPC_FAR *punkContext,
    /* [in] */ LPCOLESTR pstrDelimiter,
    /* [in] */ DWORD dwSourceContextCookie,
    /* [in] */ ULONG ulStartingLineNumber,
    /* [in] */ DWORD dwFlags,
    /* [out] */ IDispatch __RPC_FAR *__RPC_FAR *ppdisp);


void __RPC_STUB IActiveScriptParseProcedureOld_ParseProcedureText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActiveScriptParseProcedureOld_INTERFACE_DEFINED__ */


#ifndef __IActiveScriptParseProcedure_INTERFACE_DEFINED__
#define __IActiveScriptParseProcedure_INTERFACE_DEFINED__

/* interface IActiveScriptParseProcedure */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveScriptParseProcedure;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AA5B6A80-B834-11d0-932F-00A0C90DCAA9")
    IActiveScriptParseProcedure : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ParseProcedureText( 
            /* [in] */ LPCOLESTR pstrCode,
            /* [in] */ LPCOLESTR pstrFormalParams,
            /* [in] */ LPCOLESTR pstrProcedureName,
            /* [in] */ LPCOLESTR pstrItemName,
            /* [in] */ IUnknown __RPC_FAR *punkContext,
            /* [in] */ LPCOLESTR pstrDelimiter,
            /* [in] */ DWORD dwSourceContextCookie,
            /* [in] */ ULONG ulStartingLineNumber,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDispatch __RPC_FAR *__RPC_FAR *ppdisp) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveScriptParseProcedureVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IActiveScriptParseProcedure __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IActiveScriptParseProcedure __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IActiveScriptParseProcedure __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ParseProcedureText )( 
            IActiveScriptParseProcedure __RPC_FAR * This,
            /* [in] */ LPCOLESTR pstrCode,
            /* [in] */ LPCOLESTR pstrFormalParams,
            /* [in] */ LPCOLESTR pstrProcedureName,
            /* [in] */ LPCOLESTR pstrItemName,
            /* [in] */ IUnknown __RPC_FAR *punkContext,
            /* [in] */ LPCOLESTR pstrDelimiter,
            /* [in] */ DWORD dwSourceContextCookie,
            /* [in] */ ULONG ulStartingLineNumber,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDispatch __RPC_FAR *__RPC_FAR *ppdisp);
        
        END_INTERFACE
    } IActiveScriptParseProcedureVtbl;

    interface IActiveScriptParseProcedure
    {
        CONST_VTBL struct IActiveScriptParseProcedureVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveScriptParseProcedure_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActiveScriptParseProcedure_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActiveScriptParseProcedure_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActiveScriptParseProcedure_ParseProcedureText(This,pstrCode,pstrFormalParams,pstrProcedureName,pstrItemName,punkContext,pstrDelimiter,dwSourceContextCookie,ulStartingLineNumber,dwFlags,ppdisp)	\
    (This)->lpVtbl -> ParseProcedureText(This,pstrCode,pstrFormalParams,pstrProcedureName,pstrItemName,punkContext,pstrDelimiter,dwSourceContextCookie,ulStartingLineNumber,dwFlags,ppdisp)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IActiveScriptParseProcedure_ParseProcedureText_Proxy( 
    IActiveScriptParseProcedure __RPC_FAR * This,
    /* [in] */ LPCOLESTR pstrCode,
    /* [in] */ LPCOLESTR pstrFormalParams,
    /* [in] */ LPCOLESTR pstrProcedureName,
    /* [in] */ LPCOLESTR pstrItemName,
    /* [in] */ IUnknown __RPC_FAR *punkContext,
    /* [in] */ LPCOLESTR pstrDelimiter,
    /* [in] */ DWORD dwSourceContextCookie,
    /* [in] */ ULONG ulStartingLineNumber,
    /* [in] */ DWORD dwFlags,
    /* [out] */ IDispatch __RPC_FAR *__RPC_FAR *ppdisp);


void __RPC_STUB IActiveScriptParseProcedure_ParseProcedureText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActiveScriptParseProcedure_INTERFACE_DEFINED__ */


#ifndef __IActiveScriptParseProcedure2_INTERFACE_DEFINED__
#define __IActiveScriptParseProcedure2_INTERFACE_DEFINED__

/* interface IActiveScriptParseProcedure2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveScriptParseProcedure2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("71EE5B20-FB04-11d1-B3A8-00A0C911E8B2")
    IActiveScriptParseProcedure2 : public IActiveScriptParseProcedure
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IActiveScriptParseProcedure2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IActiveScriptParseProcedure2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IActiveScriptParseProcedure2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IActiveScriptParseProcedure2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ParseProcedureText )( 
            IActiveScriptParseProcedure2 __RPC_FAR * This,
            /* [in] */ LPCOLESTR pstrCode,
            /* [in] */ LPCOLESTR pstrFormalParams,
            /* [in] */ LPCOLESTR pstrProcedureName,
            /* [in] */ LPCOLESTR pstrItemName,
            /* [in] */ IUnknown __RPC_FAR *punkContext,
            /* [in] */ LPCOLESTR pstrDelimiter,
            /* [in] */ DWORD dwSourceContextCookie,
            /* [in] */ ULONG ulStartingLineNumber,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDispatch __RPC_FAR *__RPC_FAR *ppdisp);
        
        END_INTERFACE
    } IActiveScriptParseProcedure2Vtbl;

    interface IActiveScriptParseProcedure2
    {
        CONST_VTBL struct IActiveScriptParseProcedure2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveScriptParseProcedure2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActiveScriptParseProcedure2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActiveScriptParseProcedure2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActiveScriptParseProcedure2_ParseProcedureText(This,pstrCode,pstrFormalParams,pstrProcedureName,pstrItemName,punkContext,pstrDelimiter,dwSourceContextCookie,ulStartingLineNumber,dwFlags,ppdisp)	\
    (This)->lpVtbl -> ParseProcedureText(This,pstrCode,pstrFormalParams,pstrProcedureName,pstrItemName,punkContext,pstrDelimiter,dwSourceContextCookie,ulStartingLineNumber,dwFlags,ppdisp)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IActiveScriptParseProcedure2_INTERFACE_DEFINED__ */


#ifndef __IActiveScriptEncode_INTERFACE_DEFINED__
#define __IActiveScriptEncode_INTERFACE_DEFINED__

/* interface IActiveScriptEncode */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveScriptEncode;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BB1A2AE3-A4F9-11cf-8F20-00805F2CD064")
    IActiveScriptEncode : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EncodeSection( 
            /* [in] */ LPCOLESTR pchIn,
            /* [in] */ DWORD cchIn,
            /* [out][in] */ LPOLESTR pchOut,
            /* [in] */ DWORD cchOut,
            /* [out][in] */ DWORD __RPC_FAR *pcchRet) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DecodeScript( 
            /* [in] */ LPCOLESTR pchIn,
            /* [in] */ DWORD cchIn,
            /* [out][in] */ LPOLESTR pchOut,
            /* [in] */ DWORD cchOut,
            /* [out][in] */ DWORD __RPC_FAR *pcchRet) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEncodeProgId( 
            /* [out][in] */ BSTR __RPC_FAR *pbstrOut) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveScriptEncodeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IActiveScriptEncode __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IActiveScriptEncode __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IActiveScriptEncode __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EncodeSection )( 
            IActiveScriptEncode __RPC_FAR * This,
            /* [in] */ LPCOLESTR pchIn,
            /* [in] */ DWORD cchIn,
            /* [out][in] */ LPOLESTR pchOut,
            /* [in] */ DWORD cchOut,
            /* [out][in] */ DWORD __RPC_FAR *pcchRet);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DecodeScript )( 
            IActiveScriptEncode __RPC_FAR * This,
            /* [in] */ LPCOLESTR pchIn,
            /* [in] */ DWORD cchIn,
            /* [out][in] */ LPOLESTR pchOut,
            /* [in] */ DWORD cchOut,
            /* [out][in] */ DWORD __RPC_FAR *pcchRet);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEncodeProgId )( 
            IActiveScriptEncode __RPC_FAR * This,
            /* [out][in] */ BSTR __RPC_FAR *pbstrOut);
        
        END_INTERFACE
    } IActiveScriptEncodeVtbl;

    interface IActiveScriptEncode
    {
        CONST_VTBL struct IActiveScriptEncodeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveScriptEncode_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActiveScriptEncode_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActiveScriptEncode_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActiveScriptEncode_EncodeSection(This,pchIn,cchIn,pchOut,cchOut,pcchRet)	\
    (This)->lpVtbl -> EncodeSection(This,pchIn,cchIn,pchOut,cchOut,pcchRet)

#define IActiveScriptEncode_DecodeScript(This,pchIn,cchIn,pchOut,cchOut,pcchRet)	\
    (This)->lpVtbl -> DecodeScript(This,pchIn,cchIn,pchOut,cchOut,pcchRet)

#define IActiveScriptEncode_GetEncodeProgId(This,pbstrOut)	\
    (This)->lpVtbl -> GetEncodeProgId(This,pbstrOut)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IActiveScriptEncode_EncodeSection_Proxy( 
    IActiveScriptEncode __RPC_FAR * This,
    /* [in] */ LPCOLESTR pchIn,
    /* [in] */ DWORD cchIn,
    /* [out][in] */ LPOLESTR pchOut,
    /* [in] */ DWORD cchOut,
    /* [out][in] */ DWORD __RPC_FAR *pcchRet);


void __RPC_STUB IActiveScriptEncode_EncodeSection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveScriptEncode_DecodeScript_Proxy( 
    IActiveScriptEncode __RPC_FAR * This,
    /* [in] */ LPCOLESTR pchIn,
    /* [in] */ DWORD cchIn,
    /* [out][in] */ LPOLESTR pchOut,
    /* [in] */ DWORD cchOut,
    /* [out][in] */ DWORD __RPC_FAR *pcchRet);


void __RPC_STUB IActiveScriptEncode_DecodeScript_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveScriptEncode_GetEncodeProgId_Proxy( 
    IActiveScriptEncode __RPC_FAR * This,
    /* [out][in] */ BSTR __RPC_FAR *pbstrOut);


void __RPC_STUB IActiveScriptEncode_GetEncodeProgId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActiveScriptEncode_INTERFACE_DEFINED__ */


#ifndef __IActiveScriptHostEncode_INTERFACE_DEFINED__
#define __IActiveScriptHostEncode_INTERFACE_DEFINED__

/* interface IActiveScriptHostEncode */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveScriptHostEncode;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BEE9B76E-CFE3-11d1-B747-00C04FC2B085")
    IActiveScriptHostEncode : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EncodeScriptHostFile( 
            /* [in] */ BSTR bstrInFile,
            /* [out][in] */ BSTR __RPC_FAR *pbstrOutFile,
            /* [in] */ unsigned long cFlags,
            /* [in] */ BSTR bstrDefaultLang) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveScriptHostEncodeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IActiveScriptHostEncode __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IActiveScriptHostEncode __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IActiveScriptHostEncode __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EncodeScriptHostFile )( 
            IActiveScriptHostEncode __RPC_FAR * This,
            /* [in] */ BSTR bstrInFile,
            /* [out][in] */ BSTR __RPC_FAR *pbstrOutFile,
            /* [in] */ unsigned long cFlags,
            /* [in] */ BSTR bstrDefaultLang);
        
        END_INTERFACE
    } IActiveScriptHostEncodeVtbl;

    interface IActiveScriptHostEncode
    {
        CONST_VTBL struct IActiveScriptHostEncodeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveScriptHostEncode_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActiveScriptHostEncode_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActiveScriptHostEncode_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActiveScriptHostEncode_EncodeScriptHostFile(This,bstrInFile,pbstrOutFile,cFlags,bstrDefaultLang)	\
    (This)->lpVtbl -> EncodeScriptHostFile(This,bstrInFile,pbstrOutFile,cFlags,bstrDefaultLang)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IActiveScriptHostEncode_EncodeScriptHostFile_Proxy( 
    IActiveScriptHostEncode __RPC_FAR * This,
    /* [in] */ BSTR bstrInFile,
    /* [out][in] */ BSTR __RPC_FAR *pbstrOutFile,
    /* [in] */ unsigned long cFlags,
    /* [in] */ BSTR bstrDefaultLang);


void __RPC_STUB IActiveScriptHostEncode_EncodeScriptHostFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActiveScriptHostEncode_INTERFACE_DEFINED__ */


#ifndef __IBindEventHandler_INTERFACE_DEFINED__
#define __IBindEventHandler_INTERFACE_DEFINED__

/* interface IBindEventHandler */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IBindEventHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("63CDBCB0-C1B1-11d0-9336-00A0C90DCAA9")
    IBindEventHandler : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE BindHandler( 
            /* [in] */ LPCOLESTR pstrEvent,
            /* [in] */ IDispatch __RPC_FAR *pdisp) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBindEventHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IBindEventHandler __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IBindEventHandler __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IBindEventHandler __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BindHandler )( 
            IBindEventHandler __RPC_FAR * This,
            /* [in] */ LPCOLESTR pstrEvent,
            /* [in] */ IDispatch __RPC_FAR *pdisp);
        
        END_INTERFACE
    } IBindEventHandlerVtbl;

    interface IBindEventHandler
    {
        CONST_VTBL struct IBindEventHandlerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBindEventHandler_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBindEventHandler_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBindEventHandler_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IBindEventHandler_BindHandler(This,pstrEvent,pdisp)	\
    (This)->lpVtbl -> BindHandler(This,pstrEvent,pdisp)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IBindEventHandler_BindHandler_Proxy( 
    IBindEventHandler __RPC_FAR * This,
    /* [in] */ LPCOLESTR pstrEvent,
    /* [in] */ IDispatch __RPC_FAR *pdisp);


void __RPC_STUB IBindEventHandler_BindHandler_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBindEventHandler_INTERFACE_DEFINED__ */


#ifndef __IActiveScriptStats_INTERFACE_DEFINED__
#define __IActiveScriptStats_INTERFACE_DEFINED__

/* interface IActiveScriptStats */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveScriptStats;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B8DA6310-E19B-11d0-933C-00A0C90DCAA9")
    IActiveScriptStats : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetStat( 
            /* [in] */ DWORD stid,
            /* [out] */ ULONG __RPC_FAR *pluHi,
            /* [out] */ ULONG __RPC_FAR *pluLo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatEx( 
            /* [in] */ REFGUID guid,
            /* [out] */ ULONG __RPC_FAR *pluHi,
            /* [out] */ ULONG __RPC_FAR *pluLo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResetStats( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveScriptStatsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IActiveScriptStats __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IActiveScriptStats __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IActiveScriptStats __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStat )( 
            IActiveScriptStats __RPC_FAR * This,
            /* [in] */ DWORD stid,
            /* [out] */ ULONG __RPC_FAR *pluHi,
            /* [out] */ ULONG __RPC_FAR *pluLo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStatEx )( 
            IActiveScriptStats __RPC_FAR * This,
            /* [in] */ REFGUID guid,
            /* [out] */ ULONG __RPC_FAR *pluHi,
            /* [out] */ ULONG __RPC_FAR *pluLo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ResetStats )( 
            IActiveScriptStats __RPC_FAR * This);
        
        END_INTERFACE
    } IActiveScriptStatsVtbl;

    interface IActiveScriptStats
    {
        CONST_VTBL struct IActiveScriptStatsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveScriptStats_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActiveScriptStats_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActiveScriptStats_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActiveScriptStats_GetStat(This,stid,pluHi,pluLo)	\
    (This)->lpVtbl -> GetStat(This,stid,pluHi,pluLo)

#define IActiveScriptStats_GetStatEx(This,guid,pluHi,pluLo)	\
    (This)->lpVtbl -> GetStatEx(This,guid,pluHi,pluLo)

#define IActiveScriptStats_ResetStats(This)	\
    (This)->lpVtbl -> ResetStats(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IActiveScriptStats_GetStat_Proxy( 
    IActiveScriptStats __RPC_FAR * This,
    /* [in] */ DWORD stid,
    /* [out] */ ULONG __RPC_FAR *pluHi,
    /* [out] */ ULONG __RPC_FAR *pluLo);


void __RPC_STUB IActiveScriptStats_GetStat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveScriptStats_GetStatEx_Proxy( 
    IActiveScriptStats __RPC_FAR * This,
    /* [in] */ REFGUID guid,
    /* [out] */ ULONG __RPC_FAR *pluHi,
    /* [out] */ ULONG __RPC_FAR *pluLo);


void __RPC_STUB IActiveScriptStats_GetStatEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveScriptStats_ResetStats_Proxy( 
    IActiveScriptStats __RPC_FAR * This);


void __RPC_STUB IActiveScriptStats_ResetStats_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActiveScriptStats_INTERFACE_DEFINED__ */


#ifndef __IActiveScriptProperty_INTERFACE_DEFINED__
#define __IActiveScriptProperty_INTERFACE_DEFINED__

/* interface IActiveScriptProperty */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveScriptProperty;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4954E0D0-FBC7-11D1-8410-006008C3FBFC")
    IActiveScriptProperty : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [in] */ DWORD dwProperty,
            /* [in] */ VARIANT __RPC_FAR *pvarIndex,
            /* [out] */ VARIANT __RPC_FAR *pvarValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProperty( 
            /* [in] */ DWORD dwProperty,
            /* [in] */ VARIANT __RPC_FAR *pvarIndex,
            /* [in] */ VARIANT __RPC_FAR *pvarValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveScriptPropertyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IActiveScriptProperty __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IActiveScriptProperty __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IActiveScriptProperty __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProperty )( 
            IActiveScriptProperty __RPC_FAR * This,
            /* [in] */ DWORD dwProperty,
            /* [in] */ VARIANT __RPC_FAR *pvarIndex,
            /* [out] */ VARIANT __RPC_FAR *pvarValue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProperty )( 
            IActiveScriptProperty __RPC_FAR * This,
            /* [in] */ DWORD dwProperty,
            /* [in] */ VARIANT __RPC_FAR *pvarIndex,
            /* [in] */ VARIANT __RPC_FAR *pvarValue);
        
        END_INTERFACE
    } IActiveScriptPropertyVtbl;

    interface IActiveScriptProperty
    {
        CONST_VTBL struct IActiveScriptPropertyVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveScriptProperty_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActiveScriptProperty_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActiveScriptProperty_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActiveScriptProperty_GetProperty(This,dwProperty,pvarIndex,pvarValue)	\
    (This)->lpVtbl -> GetProperty(This,dwProperty,pvarIndex,pvarValue)

#define IActiveScriptProperty_SetProperty(This,dwProperty,pvarIndex,pvarValue)	\
    (This)->lpVtbl -> SetProperty(This,dwProperty,pvarIndex,pvarValue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IActiveScriptProperty_GetProperty_Proxy( 
    IActiveScriptProperty __RPC_FAR * This,
    /* [in] */ DWORD dwProperty,
    /* [in] */ VARIANT __RPC_FAR *pvarIndex,
    /* [out] */ VARIANT __RPC_FAR *pvarValue);


void __RPC_STUB IActiveScriptProperty_GetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveScriptProperty_SetProperty_Proxy( 
    IActiveScriptProperty __RPC_FAR * This,
    /* [in] */ DWORD dwProperty,
    /* [in] */ VARIANT __RPC_FAR *pvarIndex,
    /* [in] */ VARIANT __RPC_FAR *pvarValue);


void __RPC_STUB IActiveScriptProperty_SetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActiveScriptProperty_INTERFACE_DEFINED__ */


#ifndef __ITridentEventSink_INTERFACE_DEFINED__
#define __ITridentEventSink_INTERFACE_DEFINED__

/* interface ITridentEventSink */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITridentEventSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1DC9CA50-06EF-11d2-8415-006008C3FBFC")
    ITridentEventSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE FireEvent( 
            /* [in] */ LPCOLESTR pstrEvent,
            /* [in] */ DISPPARAMS __RPC_FAR *pdp,
            /* [out] */ VARIANT __RPC_FAR *pvarRes,
            /* [out] */ EXCEPINFO __RPC_FAR *pei) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITridentEventSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITridentEventSink __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITride