   fDirty = ppbentry->fDirty = TRUE;
            }
        }

        if ((dwErr = ReadLong( h, RFS_SECTION,
                KEY_BaseProtocol,
                (LONG* )&ppbentry->dwBaseProtocol )) != 0)
        {
            break;
        }

        if ((dwErr = ReadLong( h, RFS_SECTION,
                KEY_VpnStrategy,
                (LONG* )&ppbentry->dwVpnStrategy )) != 0)
        {
            break;
        }

#if AMB
        if ((dwErr = ReadLong( h, RFS_SECTION,
                KEY_Authentication,
                (LONG* )&ppbentry->dwAuthentication )) != 0)
        {
            break;
        }
#endif

        if ((dwErr = ReadLong( h, RFS_SECTION,
                KEY_ExcludedProtocols,
                (LONG * )&ppbentry->dwfExcludedProtocols )) != 0)
        {
            break;
        }

#if AMB
        // Automatically mark all installed protocols on AMB-only entries as
        // "excluded for PPP connections".
        //
        if (ppbentry->dwAuthentication == AS_AmbOnly
            || (ppbentry->dwBaseProtocol == BP_Ppp
                && (dwfInstalledProtocols
                    & ~(ppbentry->dwfExcludedProtocols)) == 0))
        {
            ppbentry->dwBaseProtocol = BP_Ras;
            ppbentry->dwfExcludedProtocols = 0;
            fDirty = ppbentry->fDirty = TRUE;
        }
#else
        // AMB support deprecated, see NarenG.  If old AMB entry, set framing
        // and authentication strategy back to defaults.  If calling a non-PPP
        // (NT 3.1 or WFW server) it still won't work, but at least this fixes
        // someone who accidently chose AMB.
        //
        if (ppbentry->dwBaseProtocol == BP_Ras)
        {
            ppbentry->dwBaseProtocol = BP_Ppp;
        }

#endif

        if ((dwErr = ReadFlag( h, RFS_SECTION,
                KEY_LcpExtensions,
                &ppbentry->fLcpExtensions )) != 0)
        {
            break;
        }

        if ((dwErr = ReadLong( h, RFS_SECTION,
                KEY_DataEncryption,
                &ppbentry->dwDataEncryption )) != 0)
        {
            break;
        }

        if (fOldPhonebook)
        {
            ppbentry->fSwCompression = !fDisableSwCompression;
        }
        else
        {
            if ((dwErr = ReadFlag( h, RFS_SECTION,
                    KEY_SwCompression,
                    &ppbentry->fSwCompression )) != 0)
            {
                break;
            }
        }

        fOldUseDialingRules = (BOOL )-1;
        if ((dwErr = ReadFlag( h, RFS_SECTION,
                KEY_UseCountryAndAreaCodes,
                &fOldUseDialingRules )) != 0)
        {
            break;
        }

        if (fOldUseDialingRules != (BOOL )-1)
        {
            fOldPhoneNumberParts = TRUE;

            if ((dwErr = ReadString( h, pDupTFromA, RFS_SECTION,
                    KEY_AreaCode,
                    &pszOldAreaCode )) != 0)
            {
                break;
            }

            if ((dwErr = ReadLong( h, RFS_SECTION,
                    KEY_CountryID,
                    &dwOldCountryID )) != 0)
            {
                break;
            }

            if ((dwErr = ReadLong( h, RFS_SECTION,
                    KEY_CountryCode,
                    &dwOldCountryCode )) != 0)
            {
                break;
            }
        }

        if ((dwErr = ReadFlag( h, RFS_SECTION,
                KEY_NegotiateMultilinkAlways,
                &ppbentry->fNegotiateMultilinkAlways )) != 0)
        {
            break;
        }

        if ((dwErr = ReadFlag( h, RFS_SECTION,
                KEY_SkipNwcWarning,
                &ppbentry->fSkipNwcWarning )) != 0)
        {
            break;
        }

        if ((dwErr = ReadFlag( h, RFS_SECTION,
                KEY_SkipDownLevelDialog,
                &ppbentry->fSkipDownLevelDialog )) != 0)
        {
            break;
        }

        if ((dwErr = ReadFlag( h, RFS_SECTION,
                KEY_SkipDoubleDialDialog,
                &ppbentry->fSkipDoubleDialDialog )) != 0)
        {
            break;
        }

        if ((dwErr = ReadLong( h, RFS_SECTION,
                KEY_DialMode,
                (LONG* )&ppbentry->dwDialMode )) != 0)
        {
            break;
        }

        if ((dwErr = ReadLong( h, RFS_SECTION,
                KEY_DialPercent,
                (LONG* )&ppbentry->dwDialPercent )) != 0)
        {
            break;
        }

        if ((dwErr = ReadLong( h, RFS_SECTION,
                KEY_DialSeconds,
                (LONG* )&ppbentry->dwDialSeconds )) != 0)
        {
            break;
        }

        if ((dwErr = ReadLong( h, RFS_SECTION,
                KEY_HangUpPercent,
                (LONG* )&ppbentry->dwHangUpPercent )) != 0)
        {
            break;
        }

        if ((dwErr = ReadLong( h, RFS_SECTION,
                KEY_HangUpSeconds,
                (LONG* )&ppbentry->dwHangUpSeconds )) != 0)
        {
            break;
        }

        if ((dwErr = ReadLong( h, RFS_SECTION,
                KEY_OverridePref,
                (LONG* )&ppbentry->dwfOverridePref )) != 0)
        {
            break;
        }

        if ((dwErr = ReadLong( h, RFS_SECTION,
                KEY_RedialAttempts,
                (LONG* )&ppbentry->dwRedialAttempts )) != 0)
        {
            break;
        }

        if ((dwErr = ReadLong( h, RFS_SECTION,
                KEY_RedialSeconds,
                (LONG* )&ppbentry->dwRedialSeconds )) != 0)
        {
            break;
        }

        if ((dwErr = ReadLong( h, RFS_SECTION,
                KEY_IdleDisconnectSeconds,
                &ppbentry->lIdleDisconnectSeconds )) != 0)
        {
            break;
        }

        // If this "idle seconds" is non-zero set it's override bit
        // explicitly.  This is necessary for this field only, because it
        // existed in entries created before the override bits were
        // implemented.
        //
        if (ppbentry->lIdleDisconnectSeconds != 0)
        {
            ppbentry->dwfOverridePref |= RASOR_IdleDisconnectSeconds;
        }

        if ((dwErr = ReadFlag(
                h, RFS_SECTION, KEY_RedialOnLinkFailure,
                &ppbentry->fRedialOnLinkFailure )) != 0)
        {
            break;
        }

        if ((dwErr = ReadLong( h, RFS_SECTION,
                KEY_CallbackMode,
                (LONG* )&ppbentry->dwCallbackMode )) != 0)
        {
            break;
        }

        if ((dwErr = ReadString( h, pDupTFromA, RFS_SECTION,
                KEY_CustomDialDll,
                &ppbentry->pszCustomDialDll )) != 0)
        {
            break;
        }

        if ((dwErr = ReadString( h, pDupTFromA, RFS_SECTION,
                KEY_CustomDialFunc,
                &ppbentry->pszCustomDialFunc )) != 0)
        {
            break;
        }

        if ((dwErr = ReadString( h, pDupTFromA, RFS_SECTION,
                KEY_CustomDialerName,
                &ppbentry->pszCustomDialerName )) != 0)
        {
            break;
        }

        if ((dwErr = ReadFlag(
                h, RFS_SECTION, KEY_AuthenticateServer,
                &ppbentry->fAuthenticateServer )) != 0)
        {
            break;
        }

        if ((dwErr = ReadFlag(
                h, RFS_SECTION, KEY_ShareMsFilePrint,
                &ppbentry->fShareMsFilePrint )) != 0)
        {
            break;
        }

        if ((dwErr = ReadFlag(
                h, RFS_SECTION, KEY_BindMsNetClient,
                &ppbentry->fBindMsNetClient )) != 0)
        {
            break;
        }

        {
            ppbentry->fSharedPhoneNumbers = (BOOL )-1;

            if ((dwErr = ReadFlag(
                    h, RFS_SECTION, KEY_SharedPhoneNumbers,
                    &ppbentry->fSharedPhoneNumbers )) != 0)
            {
                break;
            }
        }

        if ((dwErr = ReadFlag(
                h, RFS_SECTION, KEY_GlobalDeviceSettings,
                &ppbentry->fGlobalDeviceSettings)) != 0)
        {
            break;
        }

        if ((dwErr = ReadString( h, pDupTFromA, RFS_SECTION,
                KEY_PrerequisiteEntry,
                &ppbentry->pszPrerequisiteEntry )) != 0)
        {
            break;
        }

        if ((dwErr = ReadString( h, pDupTFromA, RFS_SECTION,
                KEY_PrerequisitePbk,
                &ppbentry->pszPrerequisitePbk )) != 0)
        {
            break;
        }

        if ((dwErr = ReadString( h, pDupTFromA, RFS_SECTION,
                KEY_PreferredPort,
                &ppbentry->pszPreferredPort )) != 0)
        {
            break;
        }

        if ((dwErr = ReadString( h, pDupTFromA, RFS_SECTION,
                KEY_PreferredDevice,
                &ppbentry->pszPreferredDevice )) != 0)
        {
            break;
        }

        //For XPSP1 664578, .Net 639551
        if ((dwErr = ReadLong( h, RFS_SECTION,
                KEY_PreferredBps,
                &ppbentry->dwPreferredBps)) != 0)
        {
            return dwErr;
        }
        
        if ((dwErr = ReadFlag( h, RFS_SECTION,
                KEY_PreferredHwFlow,
                &ppbentry->fPreferredHwFlow)) != 0)
        {
            return dwErr;
        }

        if ((dwErr = ReadFlag( h, RFS_SECTION,
                KEY_PreferredEc,
                &ppbentry->fPreferredEc)) != 0)
        {
            return dwErr;
        }

        if ((dwErr = ReadFlag( h, RFS_SECTION,
                KEY_PreferredEcc,
                &ppbentry->fPreferredEcc)) != 0)
        {
            return dwErr;
        }
        

        if ((dwErr = ReadLong( h, RFS_SECTION,
                KEY_PreferredSpeaker,
                &ppbentry->fPreferredSpeaker)) != 0)
        {
            return dwErr;
        }

        
        //For whistler bug 402522
        //
        if ((dwErr = ReadLong( h,  RFS_SECTION,
                KEY_PreferredModemProtocol,
                &ppbentry->dwPreferredModemProtocol)) != 0)
        {
            break;
        }



        if ((dwErr = ReadFlag(
                h, RFS_SECTION, KEY_PreviewUserPw,
                &ppbentry->fPreviewUserPw )) != 0)
        {
            break;
        }

        if ((dwErr = ReadFlag(
                h, RFS_SECTION, KEY_PreviewDomain,
                &ppbentry->fPreviewDomain )) != 0)
        {
            break;
        }

        if ((dwErr = ReadFlag(
                h, RFS_SECTION, KEY_PreviewPhoneNumber,
                &ppbentry->fPreviewPhoneNumber )) != 0)
        {
            break;
        }

        if ((dwErr = ReadFlag(
                h, RFS_SECTION, KEY_ShowDialingProgress,
                &ppbentry->fShowDialingProgress )) != 0)
        {
            break;
        }

        if ((dwErr = ReadFlag(
                h, RFS_SECTION, KEY_ShowMonitorIconInTaskBar,
                &ppbentry->fShowMonitorIconInTaskBar )) != 0)
        {
            break;
        }

        if ((dwErr = ReadLong( h, RFS_SECTION,
                KEY_CustomAuthKey,
                (LONG* )&ppbentry->dwCustomAuthKey )) != 0)
        {
            break;
        }

        if ((dwErr = ReadBinary( h, RFS_SECTION, KEY_CustomAuthData,
                &ppbentry->pCustomAuthData,
                &ppbentry->cbCustomAuthData )) != 0)
        {
            break;
        }

        if (fOldPhonebook)
        {
            // Look for the old PPP keys.
            //
            if (ppbentry->dwBaseProtocol == BP_Ppp)
            {
                if ((dwErr = ReadLong(
                        h, RFS_SECTION, KEY_PppTextAuthentication,
                        &ppbentry->dwAuthRestrictions )) != 0)
                {
                    break;
                }

                if ((dwErr = ReadFlag(
                        h, RFS_SECTION, KEY_PppIpPrioritizeRemote,
                        &ppbentry->fIpPrioritizeRemote )) != 0)
                {
                    break;
                }

                if ((dwErr = ReadFlag(
                        h, RFS_SECTION, KEY_PppIpVjCompression,
                        &ppbentry->fIpHeaderCompression )) != 0)
                {
                    break;
                }

                if ((dwErr = ReadString( h, pDupTFromA, RFS_SECTION,
                        KEY_PppIpAddress, &ppbentry->pszIpAddress )) != 0)
                {
                    break;
                }

                if ((dwErr = ReadLong( h, RFS_SECTION,
                        KEY_PppIpAddressSource,
                        &ppbentry->dwIpAddressSource )) != 0)
                {
                    break;
                }

                if ((dwErr = ReadString( h, pDupTFromA, RFS_SECTION,
                        KEY_PppIpDnsAddress,
                        &ppbentry->pszIpDnsAddress )) != 0)
                {
                    break;
                }

                if ((dwErr = ReadString( h, pDupTFromA, RFS_SECTION,
                        KEY_PppIpDns2Address,
                        &ppbentry->pszIpDns2Address )) != 0)
                {
                    break;
                }

                if ((dwErr = ReadString( h, pDupTFromA, RFS_SECTION,
                        KEY_PppIpWinsAddress,
                        &ppbentry->pszIpWinsAddress )) != 0)
                {
                    break;
                }

                if ((dwErr = ReadString( h, pDupTFromA, RFS_SECTION,
                        KEY_PppIpWins2Address,
                        &ppbentry->pszIpWins2Address )) != 0)
                {
                    break;
                }

                if ((dwErr = ReadLong( h, RFS_SECTION,
                        KEY_PppIpNameSource,
                        &ppbentry->dwIpNameSource )) != 0)
                {
                    break;
                }
            }

            // Look for the old SLIP keys.
            //
            if (ppbentry->dwBaseProtocol == BP_Slip)
            {
                if ((dwErr = ReadFlag( h, RFS_SECTION,
                        KEY_SlipHeaderCompression,
                        &ppbentry->fIpHeaderCompression )) != 0)
                {
                    break;
                }

                if ((dwErr = ReadFlag( h, RFS_SECTION,
                        KEY_SlipPrioritizeRemote,
                        &ppbentry->fIpPrioritizeRemote )) != 0)
                {
                    break;
                }

                if ((dwErr = ReadLong( h, RFS_SECTION,
                        KEY_SlipFrameSize, &ppbentry->dwFrameSize )) != 0)
                {
                    break;
                }

                if ((dwErr = ReadString( h, pDupTFromA, RFS_SECTION,
                        KEY_SlipIpAddress, &ppbentry->pszIpAddress )) != 0)
                {
                    break;
                }
            }

            if ((dwErr = ReadString( h, pDupTFromA, RFS_SECTION,
                    KEY_User, &ppbentry->pszOldUser )) != 0)
            {
                break;
            }

            if ((dwErr = ReadString( h, pDupTFromA, RFS_SECTION,
                    KEY_Domain, &ppbentry->pszOldDomain )) != 0)
            {
                break;
            }
        }
        else
        {
            // Look for the new IP names.
            //
            if ((dwErr = ReadLong(
                    h, RFS_SECTION, KEY_AuthRestrictions,
                    &ppbentry->dwAuthRestrictions )) != 0)
            {
                break;
            }

            if ((dwErr = ReadLong(
                    h, RFS_SECTION, KEY_TypicalAuth,
                    &ppbentry->dwTypicalAuth )) != 0)
            {
                break;
            }

            if ((dwErr = ReadFlag(
                    h, RFS_SECTION, KEY_IpPrioritizeRemote,
                    &ppbentry->fIpPrioritizeRemote )) != 0)
            {
                break;
            }

            if ((dwErr = ReadFlag(
                    h, RFS_SECTION, KEY_IpHeaderCompression,
                    &ppbentry->fIpHeaderCompression )) != 0)
            {
                break;
            }

            if ((dwErr = ReadString( h, pDupTFromA, RFS_SECTION,
                    KEY_IpAddress, &ppbentry->pszIpAddress )) != 0)
            {
                break;
            }

            if ((dwErr = ReadString( h, pDupTFromA, RFS_SECTION,
                    KEY_IpDnsAddress,
                    &ppbentry->pszIpDnsAddress )) != 0)
            {
                break;
            }

            if ((dwErr = ReadString( h, pDupTFromA, RFS_SECTION,
                    KEY_IpDns2Address,
                    &ppbentry->pszIpDns2Address )) != 0)
            {
                break;
            }

            if ((dwErr = ReadString( h, pDupTFromA, RFS_SECTION,
                    KEY_IpWinsAddress,
                    &ppbentry->pszIpWinsAddress )) != 0)
            {
                break;
            }

            if ((dwErr = ReadString( h, pDupTFromA, RFS_SECTION,
                    KEY_IpWins2Address,
                    &ppbentry->pszIpWins2Address )) != 0)
            {
                break;
            }

            if ((dwErr = ReadLong( h, RFS_SECTION,
                    KEY_IpAddressSource,
                    &ppbentry->dwIpAddressSource )) != 0)
            {
                break;
            }

            if ((dwErr = ReadLong( h, RFS_SECTION,
                    KEY_IpNameSource,
                    &ppbentry->dwIpNameSource )) != 0)
            {
                break;
            }

            if ((dwErr = ReadLong( h, RFS_SECTION,
                    KEY_IpFrameSize, &ppbentry->dwFrameSize )) != 0)
            {
                break;
            }

            if ((dwErr = ReadLong( h, RFS_SECTION,
                    KEY_IpDnsFlags, &ppbentry->dwIpDnsFlags )) != 0)
            {
                break;
            }

            if ((dwErr = ReadLong( h, RFS_SECTION,
                    KEY_IpNbtFlags, &ppbentry->dwIpNbtFlags )) != 0)
            {
                break;
            }

            // Whistler bug 300933
            //
            if ((dwErr = ReadLong( h, RFS_SECTION,
                    KEY_TcpWindowSize, &ppbentry->dwTcpWindowSize )) != 0)
            {
                break;
            }

            // Read the use flags
            //
            if ((dwErr = ReadLong( h, RFS_SECTION,
                    KEY_UseFlags,
                    (LONG* )&ppbentry->dwUseFlags )) != 0)
            {
                break;
            }

            //Add an IPSecFlags for whistler bug 193987 gangz
            //
            if ((dwErr = ReadLong( h, RFS_SECTION,
                    KEY_IpSecFlags,
                    (LONG* )&ppbentry->dwIpSecFlags )) != 0)
            {
                break;
            }

            if ((dwErr = ReadString( h, pDupTFromA, RFS_SECTION,
                    KEY_IpDnsSuffix,
                    &ppbentry->pszIpDnsSuffix )) != 0)
            {
                break;
            }
        }

        // Read the NETCOMPONENTS items.
        //
        ReadNetComponents( h, ppbentry->pdtllistNetComponents );

        // MEDIA subsections.
        //
        fFoundMedia = FALSE;

        //Load system ports into pdtllistPorts
        //
        if (!pdtllistPorts)
        {
            dwErr = LoadPortsList2( (fRouter)
                                  ? (pFile->hConnection)
                                  : NULL,
                                  &pdtllistPorts,
                                  fRouter );

            if (dwErr != 0)
            {
                break;
            }
        }

        //Loop over each media (media + device) section in a connectoid section
        //
        for (;;)
        {
            TCHAR* pszDevice;
            PBPORT* ppbport;

            if (!RasfileFindNextLine( h, RFL_GROUP, RFS_SECTION )
                || !IsMediaLine( (CHAR* )RasfileGetLine( h ) ))
            {
                if (fFoundMedia)
                {
                    // Out of media groups, i.e. "links", but found at least
                    // one.  This is the successful exit case.
                    //
                    break;
                }

                // First subsection MUST be a MEDIA subsection.  Delete
                // non-conforming entries as invalid.
                //
                TRACE( "No media section?" );
                DeleteCurrentSection( h );
                fSectionDeleted = TRUE;
                DtlRemoveNode( pFile->pdtllistEntries, pdtlnodeEntry );
                DestroyEntryNode( pdtlnodeEntry );
                break;
            }

            // Create a default link node and add it to the list.
            //
            if (!(pdtlnodeLink = CreateLinkNode()))
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            DtlAddNodeLast( ppbentry->pdtllistLinks, pdtlnodeLink );
            ppblink = (PBLINK* )DtlGetData( pdtlnodeLink );

            RasfileGetKeyValueFields( h, NULL, szValue );
            TRACE1( "Reading media group \"%s\"", szValue );

            if ((dwErr = ReadString( h, pDupTFromA, RFS_GROUP,
                    KEY_Port, &ppblink->pbport.pszPort )) != 0)
            {
                break;
            }

            //
            // If this is a Direct Connect Entry default the entry type
            // of the port to some direct connect device. We will default
            // to Parallel port. In the case of a Broadband entry default
            // to PPPoE.
            //
            if(RASET_Direct == ppbentry->dwType)
            {
                ppblink->pbport.pbdevicetype = PBDT_Parallel;
            }
            else if (RASET_Broadband == ppbentry->dwType)
            {
                ppblink->pbport.pbdevicetype = PBDT_PPPoE;
            }

            if (!ppblink->pbport.pszPort)
            {
                // No port.  Blow away corrupt section and go on to the next
                // one.
                //
                TRACE( "No port key? (section deleted)" );
                dwErr = 0;
                DeleteCurrentSection( h );
                fSectionDeleted = TRUE;
                DtlRemoveNode( pFile->pdtllistEntries, pdtlnodeEntry );
                DestroyEntryNode( pdtlnodeEntry );
                break;
            }

            {
                pszDevice = NULL;
                if ((dwErr = ReadString(
                        h, pDupTFromA, RFS_GROUP, KEY_Device,
                        &pszDevice )) != 0)
                {
                    break;
                }

                ppblink->pbport.pszDevice = pszDevice;
                TRACE1( "%s link format", (pszDevice) ? "New" : "Old" );
            }

            TRACEW1( "Port=%s", ppblink->pbport.pszPort );

            //
            // pmay: 226594
            //
            // If the device is one of them magic nt4-style null modems,
            // upgrade it to a null modem and update the entry type.
            //
            if ((pszDevice) &&
                (_tcsstr(
                    pszDevice,
                    TEXT("Dial-Up Networking Serial Cable between 2 PCs")))
               )
            {
                ppbport = PpbportFromNullModem(
                    pdtllistPorts,
                    ppblink->pbport.pszPort,
                    ppblink->pbport.pszDevice );

                if (ppbport != NULL)
                {
                    ChangeEntryType( ppbentry, RASET_Direct );
                    fDirty = ppbentry->fDirty = TRUE;
                }
            }

            //
            // Otherwise, match the port up with the device name.
            //
            else
            {
                ppbport = PpbportFromPortAndDeviceName(
                    pdtllistPorts,
                    ppblink->pbport.pszPort,
                    ppblink->pbport.pszDevice );
            }

            if ( ( ppbport ) &&
                 ( PbportTypeMatchesEntryType(ppbport, ppbentry) ) )
            {
                if (lstrcmp( ppbport->pszPort, ppblink->pbport.pszPort ) != 0)
                {
                    // The phonebook had an old-style port name.  Mark the
                    // entry for update with the new port name format.
                    //
                    TRACEW1( "Port=>%s", ppblink->pbport.pszPort );
                    fDirty = ppbentry->fDirty = TRUE;
                }

                dwErr = CopyToPbport( &ppblink->pbport, ppbport );
                if (dwErr != 0)
                {
                    break;
                }
            }
            else
            {
                // If no port is matched, it could be a vpn or isdn from a
                // nt4 upgrade We haven't changed anything else in nt5. Check
                // for these cases and upgrade the port.
                //
                ppbport = PpbportFromNT4PortandDevice(
                            pdtllistPorts,
                            ppblink->pbport.pszPort,
                            ppblink->pbport.pszDevice);

                if(     (NULL != ppbport)                            
                    &&  (PbportTypeMatchesEntryType(ppbport, ppbentry)))
                {
                    fDirty = ppbentry->fDirty = TRUE;
                    dwErr = CopyToPbport(&ppblink->pbport, ppbport);

                    if(dwErr != 0)
                    {
                        break;
                    }
                }
                else
                {

                    TRACE( "Port not configured" );
                    ppblink->pbport.fConfigured = FALSE;

                    // Assign unconfigured port the media we read earlier.
                    //
                    Free0( ppblink->pbport.pszMedia );
                    ppblink->pbport.pszMedia = pDupTFromA( szValue );
                    if (!ppblink->pbport.pszMedia)
                    {
                        dwErr = ERROR_NOT_ENOUGH_MEMORY;
                        break;
                    }
                }
            }

            if ((!ppbport)                                      || 
                (ppblink->pbport.pbdevicetype == PBDT_Modem)    ||
                (ppblink->pbport.dwFlags & PBP_F_NullModem)
               )
            {
                // pmay: 260579.  dwBps has to be initialized to zero in order
                // for Rao's fix to 106837 (below) to work.
                DWORD dwBps = 0;

                SetDefaultModemSettings( ppblink );

                if ((dwErr = ReadLong( h, RFS_GROUP,
                        KEY_InitBps, &dwBps )) != 0)
                {
                    break;
                }

                // If the phonebook returns a 0 value, the case when the entry
                // is created programmatically, then we stick with the default
                // bps.  RAID nt5 106837.  (RaoS)
                //
                if ( 0 != dwBps )
                {
                    ppblink->dwBps = dwBps;
                }
            }

            // DEVICE subsections.

            // At this point ppblink->pbport contains information from the
            // matching port in the configured port list or defaults with
            // pszMedia and pszDevice filled in.  ReadDeviceList fills in the
            // pbdevicetype, and if it's an unconfigured port, the unimodem or
            // MXS modem flag.
            //
            dwErr = ReadDeviceList(
                h, pDupTFromA, ppbentry, ppblink, !ppbport,
                (fOldPhonebook) ? &fDisableModemSpeaker : NULL );

            if (dwErr == ERROR_CORRUPT_PHONEBOOK)
            {
                // Blow away corrupt section and go on to the next one.
                //
                dwErr = 0;
                DeleteCurrentSection( h );
                fSectionDeleted = TRUE;
                DtlRemoveNode( pFile->pdtllistEntries, pdtlnodeEntry );
                DestroyEntryNode( pdtlnodeEntry );
                break;
            }
            else if (dwErr != 0)
            {
                break;
            }

            if (fOldPhonebook
                && ppbentry->dwBaseProtocol == BP_Slip)
            {
                // Set an after-dial terminal when upgrading old phonebooks.
                // This was implied in the old format.
                //
                TRACE( "Add SLIP terminal" );
                ppbentry->fScriptAfterTerminal = TRUE;
            }

            if (!ppbport)
            {
                DTLNODE* pdtlnode;

                // This is an old-format link not in the list of installed
                // ports.  Change it to the first device of the same device
                // type or to an "unknown" device of that type.  Note this is
                // what converts "Any port".
                //
                //Loop over each loaded System Port
                for (pdtlnode = DtlGetFirstNode( pdtllistPorts );
                     pdtlnode;
                     pdtlnode = DtlGetNextNode( pdtlnode ))
                {
                    ppbport = (PBPORT* )DtlGetData( pdtlnode );
                    
                    // comments for bug 247189  234154   gangz
                    // Look for a system port has a matching pbdevicetype to the
                    // phonebook port 
                    //
                    if (ppbport->pbdevicetype == ppblink->pbport.pbdevicetype)
                    {
                        // Don't convert two links of the entry to use the
                        // same port.  If there aren't enough similar ports,
                        // the overflow will be left "unknown".  (bug 63203).
                        //
                        //Comments for bug 247189 234154      gangz
                        // FILTER DUPE#1    
                        // Look for a system port which is never used by the 
                        // links read before the current one loaded from phonebook
                        // 
                        
                        DTLNODE* pNodeL;

                        for (pNodeL = DtlGetFirstNode( ppbentry->pdtllistLinks );
                             pNodeL;
                             pNodeL = DtlGetNextNode( pNodeL ))
                        {
                            PBLINK* pLink = DtlGetData( pNodeL );

                            {
                                if (
                                    (pLink->pbport.fConfigured) &&  // 373745
                                    (lstrcmp( 
                                        pLink->pbport.pszPort,
                                        ppbport->pszPort ) == 0)
                                   )
                                {
                                    break;
                                }
                            }
                        }

                        if (!pNodeL)
                        {
                             //For whistler bug 247189 234254     gangz
                             //First we create a DUN on Com1 with no modem installed
                             //then create a DCC guest on Com2. A null modem will
                             //be installed on Com2, then this DUN is changed to
                             //be DCC type and also switches to use Com2's null
                             //modem which is only for DCC connections.
                             //
                             //The basic problem is:
                             //We cannot copy a system port just according to its 
                             //pbdevicetype, we should also check its dwType
                             //because     (1) NULL modem is not a modem for DUN, it's just for 
                             //                DCC Connection.
                             //            (2) When creating NULL Modem, its pbdevicetype is 
                             //                assigned to RDT_Modem
                             //  Then, we need also check if the dwType of the 
                             //  system port matches that of phonebook port
                             //
                             //Besides: file.c is in pbk.lib which is linked to both rasdlg.dll 
                             //loaded into explorer and rasapi32.dll hosted by one of the 
                             //svchost.exe!!!

                            if (ppblink->pbport.dwType == ppbport->dwType)
                            {
                                TRACE( "Port converted" );
                                dwErr = CopyToPbport( &ppblink->pbport, ppbport );

                                if ((ppblink->pbport.pbdevicetype == PBDT_Modem) ||
                                    (ppblink->pbport.dwFlags & PBP_F_NullModem)
                                   )
                                {
                                    SetDefaultModemSettings( ppblink );
                                }
                                fDirty = ppbentry->fDirty = TRUE;
                                break;
                            }
                        }//end of  if (!pNodeL) {}
                   }//end of if (ppbport->pbdevicetype == ppblink->pbport.pbdevicetype)
                }//End of //Loop over each loaded System Port

                // pmay: 383038
                // 
                // We only want to fall into the following path if the type
                // is Direct.  Rao checked in the following path with the 
                // intention that a DCC connection not be rolled into a MODEM
                // connection if another DCC device was present on the system.
                //
                if (    (ppbentry->dwType == RASET_Direct)
                    ||  (ppbentry->dwType == RASET_Broadband))
                {
                    // If we don't find a port with the same devicetype try to find
                    // a port with the same entry type
                    //
                    for(pdtlnode = DtlGetFirstNode( pdtllistPorts);
                        pdtlnode;
                        pdtlnode = DtlGetNextNode(pdtlnode))
                    {
                        DWORD dwType;

                        ppbport = (PBPORT *) DtlGetData(pdtlnode);

                        dwType = EntryTypeFromPbport( ppbport );    

                        if(ppbentry->dwType == dwType)
                        {
                            TRACE("Port with same entry type found");
                            dwErr = CopyToPbport(&ppblink->pbport, ppbport);

                            fDirty = ppbentry->fDirty = TRUE;
                            break;
                        }
                    }
                }                    

                if (dwErr != 0)
                {
                    break;
                }
            }

            fFoundMedia = TRUE;
        } //end of Loop over each (media+device) section in a connectoid section

        
        if (dwErr != 0)
        {
            break;
        }

        if (!fSectionDeleted)
        {
            // pmay: 277801
            //
            // At this point, the list of pblinks is read in and ready to go.
            // Apply the "preferred device" logic. (only applies to singlelink)
            //
            if (DtlGetNodes(ppbentry->pdtllistLinks) == 1)
            {
                PBLINK* pLink;
                DTLNODE* pNodeL, *pNodeP;
                
                pNodeL = DtlGetFirstNode( ppbentry->pdtllistLinks );
                pLink = (PBLINK* )DtlGetData( pNodeL );

                // If the preferred device has been assigned, 
                // use it if it exists
                //
                if (ppbentry->pszPreferredDevice && ppbentry->pszPreferredPort)
                {
                    // The current device doesn't match the 
                    // preferred device
                    //
                    if ((pLink->pbport.pszPort == NULL)     ||
                        (pLink->pbport.pszDevice == NULL)   ||
                        (lstrcmpi(
                            pLink->pbport.pszPort, 
                            ppbentry->pszPreferredPort))    ||
                        (lstrcmpi(
                            pLink->pbport.pszDevice, 
                            ppbentry->pszPreferredDevice)))
                    {
                        PBPORT* pPort;
                        
                        // See if the preferred device exists on the 
                        // system
                        //
                        for (pNodeP = DtlGetFirstNode( pdtllistPorts );
                             pNodeP;
                             pNodeP = DtlGetNextNode( pNodeP ))
                        {
                            pPort = (PBPORT*)DtlGetData(pNodeP);

                            // The preferred device is found!  Use it.
                            //
                            if ((pPort->pszPort != NULL)                         &&
                                (pPort->pszDevice != NULL)                       &&
                                (lstrcmpi(
                                    ppbentry->pszPreferredPort, 
                                    pPort->pszPort) == 0)                        &&
                                (lstrcmpi(
                                    ppbentry->pszPreferredDevice, 
                                    pPort->pszDevice) == 0))
                            {
                                dwErr = CopyToPbport(&pLink->pbport, pPort);

                                // For XPSP1 664578, .Net bug 639551          gangz
                                // Add Preferred modem settings
                                pLink->dwBps   = ppbentry->dwPreferredBps;
                                pLink->fHwFlow = ppbentry->fPreferredHwFlow;
                                pLink->fEc     = ppbentry->fPreferredEc;
                                pLink->fEcc    = ppbentry->fPreferredEcc;
                                pLink->fSpeaker = ppbentry->fPreferredSpeaker;
                                
                                //For whistler bug 402522       gangz
                                //Add preferred modem protocol
                                //
                                pLink->dwModemProtocol =
                                        ppbentry->dwPreferredModemProtocol;

                                fDirty = ppbentry->fDirty = TRUE;
                                break;
                            }
                        }
                    }
                }

                // pmay: 401398 -- bug postponed so I'm just commenting this out.
                // 
                // If this is a DCC connection, then it is valid to have the 
                // preferred port set w/o having the prefered device set.  This
                // will be the case for NULL modems that we install.  If the
                // preferred port is set for such a connection, force the current
                // device to resolve to a null modem on that port.
                //  
                //else if (ppbentry->dwType == RASET_Direct)
                //{
                //    if ((ppbentry->pszPreferredPort)    && 
                //        (!ppbentry->pszPreferredDevice) &&
                //        (lstrcmpi(
                //            pLink->pbport.pszPort, 
                //            ppbentry->pszPreferredPort))
                //        )
                //    {
                //        PBPORT* pPort;
                //        
                //        // Attempt to resolve the connection to the 
                //        // correct preferred device.
                //        //
                //        for (pNodeP = DtlGetFirstNode( pdtllistPorts );
                //             pNodeP;
                //             pNodeP = DtlGetNextNode( pNodeP ))
                //        {
                //            pPort = (PBPORT*)DtlGetData(pNodeP);
                //
                //            // The preferred device is found!  Use it.
                //            //
                //            if ((pPort->pszPort != NULL)                   &&
                //                (lstrcmpi(
                //                   ppbentry->pszPreferredPort, 
                //                    pPort->pszPort) == 0)                  &&
                //                (pPort->dwFlags & PBP_F_NullModem))
                //            {
                //                dwErr = CopyToPbport(&pLink->pbport, pPort);
                //                fDirty = ppbentry->fDirty = TRUE;
                //                break;
                //            }
                //        }
                //    }
                //}

                // The preferred device is not configured.  This will only be
                // the case for entries that were created before 277801 was 
                // resolved or for entries that went multilink->singlelink.
                // 
                // Assign the preferred device as the currently selected 
                // device.
                //
                else
                {
                    if (pLink->pbport.pszPort != NULL)   
                    {
                        ppbentry->pszPreferredPort = StrDup(pLink->pbport.pszPort);
                    }
                    if (pLink->pbport.pszDevice != NULL) 
                    {
                        ppbentry->pszPreferredDevice = 
                            StrDup(pLink->pbport.pszDevice);
                    }

                    // For XPSP1 664578, .Net 639551
                    ppbentry->dwPreferredBps    = pLink->dwBps;
                    ppbentry->fPreferredHwFlow  = pLink->fHwFlow;
                    ppbentry->fPreferredEc      = pLink->fEc;
                    ppbentry->fPreferredEcc     = pLink->fEcc;
                    ppbentry->fPreferredSpeaker = pLink->fSpeaker;
                    
                    //For whistler bug 402522
                    //
                    ppbentry->dwPreferredModemProtocol =
                            pLink->dwModemProtocol;

                }
            }

            // Translate old one-per-entry phone number part mapping to the
            // new one-per-phone-number mapping.
            //
            if (fOldPhoneNumberParts)
            {
                DTLNODE* pNodeL;
                DTLNODE* pNodeP;
                PBLINK* pLink;
                PBPHONE* pPhone;

                for (pNodeL = DtlGetFirstNode( ppbentry->pdtllistLinks );
                     pNodeL;
                     pNodeL = DtlGetNextNode( pNodeL ))
                {
                    pLink = (PBLINK* )DtlGetData( pNodeL );

                    for (pNodeP = DtlGetFirstNode( pLink->pdtllistPhones );
                         pNodeP;
                         pNodeP = DtlGetNextNode( pNodeP ))
                    {
                        pPhone = (PBPHONE* )DtlGetData( pNodeP );

                        pPhone->fUseDialingRules = fOldUseDialingRules;
                        Free0( pPhone->pszAreaCode );
                        pPhone->pszAreaCode = StrDup( pszOldAreaCode );
                        pPhone->dwCountryCode = dwOldCountryCode;
                        pPhone->dwCountryID = dwOldCountryID;

                        fDirty = ppbentry->fDirty = TRUE;
                    }
                }

                TRACE( "Phone# parts remapped" );
            }

            // Multiple links only allowed with PPP framing.
            //
            if (ppbentry->dwBaseProtocol != BP_Ppp
                && DtlGetNodes( ppbentry->pdtllistLinks ) > 1)
            {
                TRACE( "Non-PPP multi-link corrected" );
                ppbentry->dwBaseProtocol = BP_Ppp;
                fDirty = ppbentry->fDirty = TRUE;
            }

            // Make sure entry type and dependent settings are appropriate for
            // device list.
            //
            {
                DTLNODE* pdtlnode;
                PBLINK* ppblink;
                DWORD dwType;

                pdtlnode = DtlGetFirstNode( ppbentry->pdtllistLinks );
                if (pdtlnode)
                {
                    ppblink = (PBLINK* )DtlGetData( pdtlnode );
                    ASSERT( ppblink );
                    dwType = EntryTypeFromPbport( &ppblink->pbport );

                    if (    RASET_Internet != ppbentry->dwType
                        &&  dwType != ppbentry->dwType)
                    {
                        TRACE2("Fix entry type, %d to %d",
                            ppbentry->dwType, dwType);
                        ChangeEntryType( ppbentry, dwType );
                        fDirty = ppbentry->fDirty = TRUE;
                    }

                    if(     (NULL != ppblink->pbport.pszDevice)
                        &&  (0 == lstrcmpi(ppblink->pbport.pszDevice,
                                           TEXT("RASPPTPM"))))
                    {
                        TRACE1("Fix pptp device name. %s to "
                               "WAN Miniport (PPTP)",
                               ppblink->pbport.pszDevice);

                        Free(ppblink->pbport.pszDevice);
                        ppblink->pbport.pszDevice =
                            StrDup(TEXT("WAN Miniport (PPTP)"));

                        ppbentry->dwVpnStrategy = VS_Default;

                        fDirty = ppbentry->fDirty = TRUE;
                    }
                }
            }

            // If there was no shared phone number setting (i.e. upgrading an
            // NT4.0 or earlier entry), set the flag on when there is a single
            // link and off otherwise.
            //
            if (ppbentry->fSharedPhoneNumbers == (BOOL )-1)
            {
                ppbentry->fSharedPhoneNumbers =
                    (DtlGetNodes( ppbentry->pdtllistLinks ) <= 1);
                fDirty = ppbentry->fDirty = TRUE;
            }

            // Upgrade the authorization restrictions You'll know if you need
            // to upgrade the dwAuthRestrictions variable because old phone
            // books have this value set to 0 or have some of the bottom 3
            // bits set.
            //
            if ( (ppbentry->dwAuthRestrictions == 0) ||
                 (ppbentry->dwAuthRestrictions & 0x7)  )
            {
                switch (ppbentry->dwAuthRestrictions)
                {
                    case AR_AuthEncrypted:
                    case AR_AuthMsEncrypted:
                    {
                        ppbentry->dwAuthRestrictions = AR_F_TypicalSecure;
                        ppbentry->dwTypicalAuth = TA_Secure;
                        break;
                    }

                    case AR_AuthCustom:
                    {
                        ppbentry->dwAuthRestrictions = AR_F_TypicalCardOrCert;
                        ppbentry->dwTypicalAuth = TA_CardOrCert;
                        break;
                    }

                    case AR_AuthTerminal:
                    case AR_AuthAny:
                    default:
                    {
                        ppbentry->dwAuthRestrictions = AR_F_TypicalUnsecure;
                        ppbentry->dwTypicalAuth = TA_Unsecure;
                        break;
                    }
                }
                TRACE1( "Upgraded dwAuthRestrictions to %x",
                    ppbentry->dwAuthRestrictions);
                fDirty = ppbentry->fDirty = TRUE;
            }

            if ((ppbentry->dwAuthRestrictions & AR_F_AuthW95MSCHAP)
                && !(ppbentry->dwAuthRestrictions & AR_F_AuthMSCHAP))
            {
                TRACE( "W95CHAP removed from dwAuthRestrictions" );
                ppbentry->dwAuthRestrictions &= ~(AR_F_AuthW95MSCHAP);
                fDirty = ppbentry->fDirty = TRUE;
            }

            // Upgrade old data encryption settings.
            //
            switch (ppbentry->dwDataEncryption)
            {
                case DE_Mppe40bit:
                case DE_IpsecDefault:
                case DE_VpnAlways:
                case DE_PhysAlways:
                {
                    ppbentry->dwDataEncryption = DE_Require;
                    fDirty = ppbentry->fDirty = TRUE;
                    break;
                }

                case DE_Mppe128bit:
                {
                    ppbentry->dwDataEncryption = DE_RequireMax;
                    fDirty = ppbentry->fDirty = TRUE;
                    break;
                }
            }

            // 
            // pmay: 233258
            // 
            // Based on registry settings, this entry may need to
            // be modified. (upgrade from nt4)
            //
            if ( fOldPhonebook )
            {
                UpgradeRegistryOptions( (fRouter) ? 
                                        pFile->hConnection
                                        : NULL,
                                        ppbentry );
                                        
                fDirty = ppbentry->fDirty = TRUE;
            }

            // pmay: 422924 
            //
            // Make sure that the network components section is in sync
            // with the values written into fBindMsNetClient and 
            // fShareMsFilePrint
            //
            {
                // If the component is not listed, then the default
                // is checked (on) for both settings. see rasdlg\penettab.c
                //
                BOOL fClient = TRUE, fServer = TRUE;
                BOOL fEnabled;

                // Sync up the ms client value
                //
                if (FIsNetComponentListed(
                        ppbentry, 
                        TEXT("ms_msclient"), 
                        &fEnabled, 
                        NULL))
                {
                    fClient = fEnabled;
                }
                if ((!!fClient) != (!!ppbentry->fBindMsNetClient))
                {
                    ppbentry->fBindMsNetClient = fClient;
                    fDirty = ppbentry->fDirty = TRUE;
                }

                // Sync up the ms server value
                //
                if (FIsNetComponentListed(
                        ppbentry, 
                        TEXT("ms_server"), 
                        &fEnabled, 
                        NULL))
                {
                    fServer = fEnabled;
                }
                if ((!!fServer) != (!!ppbentry->fShareMsFilePrint))
                {
                    ppbentry->fShareMsFilePrint = fServer;
                    fDirty = ppbentry->fDirty = TRUE;
                }
            }

            //
            // pmay: 336150
            //
            // If we translated this entry from ANSI to UTF8, then the 
            // entry name may have changed.  We need to delete the old
            // entry name so that there wont be a duplicate.
            //
            if (dwEncoding == EN_Ansi)
            {   
                TRACE( "Ansi Encoding? (section deleted)" );
                DeleteCurrentSection(h);
                fSectionDeleted = TRUE;
            }

            // pmay: 387941
            // 
            // Prevent connections from sharing credentials.
            //
            if (ppbentry->dwDialParamsUID == 0)
            {
                ppbentry->dwDialParamsUID = GetTickCount() + dwDialUIDOffset;
                dwDialUIDOffset++;
                fDirty = ppbentry->fDirty = TRUE;
            }
        }
        
    }//End of reading each connectoid section in a phonebook file

    if (dwErr != 0)
    {
        if (dwFlags & RPBF_HeadersOnly)
        {
            DtlDestroyList( pFile->pdtllistEntries, DestroyPszNode );
        }
        else if (dwFlags & RPBF_HeaderType)
        {
            DtlDestroyList( pFile->pdtllistEntries, DestroyEntryTypeNode );
        }
        else
        {
            DtlDestroyList( pFile->pdtllistEntries, DestroyEntryNode );
        }
    }
    else if(fDirty)
    {
        WritePhonebookFile( pFile, NULL );
    }

    if (pdtllistPorts)
    {
        DtlDestroyList( pdtllistPorts, DestroyPortNode );
    }

    Free0( pszOldAreaCode );
    Free0( szValue );

    return dwErr;
}

DWORD
ReadFlag(
    IN HRASFILE h,
    IN RFSCOPE rfscope,
    IN CHAR* pszKey,
    OUT BOOL* pfResult )

    // Utility routine to read a flag value from the next line in the scope
    // 'rfscope' with key 'pszKey'.  The result is placed in caller's
    // '*ppszResult' buffer.  The current line is reset to the start of the
    // scope if the call was successful.
    //
    // Returns 0 if successful, or a non-zero error code.  "Not found" is
    // considered successful, in which case '*pfResult' is not changed.
    //
{
    DWORD dwErr;
    LONG lResult = *pfResult;

    dwErr = ReadLong( h, rfscope, pszKey, &lResult );

    if (lResult != (LONG )*pfResult)
    {
        *pfResult = (lResult != 0);
    }

    return dwErr;
}
    
DWORD
ReadLong(
    IN HRASFILE h,
    IN RFSCOPE rfscope,
    IN CHAR* pszKey,
    OUT LONG* plResult )

    // Utility routine to read a long integer value from the next line in the
    // scope 'rfscope' with key 'pszKey'.  The result is placed in caller's
    // '*ppszResult' buffer.  The current line is reset to the start of the
    // scope if the call was successful.
    //
    // Returns 0 if successful, or a non-zero error code.  "Not found" is
    // considered successful, in which case '*plResult' is not changed.
    //
{
    CHAR szValue[ RAS_MAXLINEBUFLEN + 1 ];
    BOOL fFound;

    fFound = RasfileFindNextKeyLine( h, pszKey, rfscope );
    if (!fFound)
    {
        //DbgPrint( "Pbk Perf: seeking back to top of scope to look for '%s'\n",
        //    pszKey );

        RasfileFindFirstLine( h, RFL_ANY, rfscope );
        fFound = RasfileFindNextKeyLine( h, pszKey, rfscope );
    }

    if (fFound)
    {
        if (!RasfileGetKeyValueFields( h, NULL, szValue ))
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        *plResult = atol( szValue );
    }

    return 0;
}


VOID
ReadNetComponents(
    IN HRASFILE h,
    IN DTLLIST* pdtllist )

    // Read the list of networking component key/value pairs from the
    // NETCOMPONENT group into 'pdtllist'.  'H' is the open RAS:FILE handle
    // assumed to be positioned before somewhere before the NETCOMPONENTS
    // group in the entry section.  The RASFILE 'CurLine' is left just after
    // the group.
    //
{
    if (!RasfilePutLineMark( h, MARK_BeginNetComponentsSearch ))
    {
        return;
    }

    if (!RasfileFindNextLine( h, RFL_GROUP, RFS_SECTION )
         || !IsNetComponentsLine( (CHAR* )RasfileGetLine( h ) ))
    {
        // No NetComponents group.  Return 'CurLine' to starting position.
        //
        while (RasfileGetLineMark( h ) != MARK_BeginNetComponentsSearch)
        {
            RasfileFindPrevLine( h, RFL_ANY, RFS_SECTION );
        }

        RasfilePutLineMark( h, 0 );
        return;
    }

    // Found the NETCOMPONENTS group header.
    //
    while (RasfileFindNextLine( h, RFL_ANY, RFS_GROUP ))
    {
        DTLNODE* pdtlnode;
        CHAR szKey[ RAS_MAXLINEBUFLEN + 1 ];
        CHAR szValue[ RAS_MAXLINEBUFLEN + 1 ];
        TCHAR* pszKey;
        TCHAR* pszValue;

        if (!RasfileGetKeyValueFields( h, szKey, szValue ))
        {
            continue;
        }

        pszKey = StrDupTFromA( szKey );
        pszValue = StrDupTFromA( szValue );
        if (pszKey && pszValue)
        {
            pdtlnode = CreateKvNode( pszKey, pszValue );
            if (pdtlnode)
            {
                DtlAddNodeLast( pdtllist, pdtlnode );
            }
        }
        Free0( pszKey );
        Free0( pszValue );
    }
}


DWORD
ReadPhonebookFile(
    IN LPCTSTR pszPhonebookPath,
    IN PBUSER* pUser,
    IN LPCTSTR pszSection,
    IN DWORD dwFlags,
    OUT PBFILE* pFile )

    // Reads the phonebook file into a list of PBENTRY.
    //
    // 'PszPhonebookPath' specifies the full path to the RAS phonebook file,
    // or is NULL indicating the default phonebook should be used.
    //
    // 'PUser' is the user preferences used to determine the default phonebook
    // path or NULL if they should be looked up by this routine.  If
    // 'pszPhonebookPath' is non-NULL 'pUser' is ignored.  Note that caller
    // MUST provide his own 'pUser' in "winlogon" mode.
    //
    // 'PszSection' indicates that only the section named 'pszSection' should
    // be loaded, or is NULL to indicate all sections.
    //
    // 'DwFlags' options: 'RPBF_ReadOnly' causes the file to be opened for
    // reading only.  'RPBF_HeadersOnly' causes only the headers to loaded,
    // and the memory image is parsed into a list of strings, unless the flag
    // 'RPBF_NoList' is specified.
    //
    // 'PFile' is the address of caller's file block.  This routine sets
    // 'pFile->hrasfile' to the handle to the open phonebook, 'pFile->pszPath'
    // to the full path to the file mode, 'pFile->dwPhonebookMode' to the mode
    // of the file, and 'pFile->pdtllistEntries' to the parsed chain of entry
    // blocks.
    //
    // Returns 0 if successful, otherwise a non-0 error code.  On success,
    // caller should eventually call ClosePhonebookFile on the returned
    // PBFILE*.
    //
{
    DWORD dwErr = 0;

    TRACE( "ReadPhonebookFile" );

    pFile->hrasfile = -1;
    pFile->pszPath = NULL;
    pFile->dwPhonebookMode = PBM_System;
    pFile->pdtllistEntries = NULL;

    do
    {
        BOOL  fFileExists;
        TCHAR szFullPath[MAX_PATH + 1];

        if (pszPhonebookPath)
        {
            pFile->dwPhonebookMode =
                (IsPublicPhonebook((TCHAR*)pszPhonebookPath)
                    ? PBM_System : PBM_Alternate);
            pFile->pszPath = StrDup( pszPhonebookPath );
            if (!pFile->pszPath)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }
        }
        else
        {
            BOOL f;

            if (pUser)
            {
                f = GetPhonebookPath(pUser, dwFlags,
                        &pFile->pszPath, &pFile->dwPhonebookMode );
            }
            else
            {
                PBUSER user;

                // Caller didn't provide user preferences but we need them to
                // find the phonebook, so look them up ourselves.  Note that
                // "not winlogon mode" is assumed.
                //
                dwErr = GetUserPreferences( NULL, &user, FALSE );
                if (dwErr != 0)
                {
                    break;
                }

                f = GetPhonebookPath(&user, dwFlags,
                        &pFile->pszPath, &pFile->dwPhonebookMode );

                DestroyUserPreferences( &user );
            }

            if (!f)
            {
                dwErr = ERROR_CANNOT_OPEN_PHONEBOOK;
                break;
            }
        }

        TRACEW1( "path=%s", pFile->pszPath );
        if (GetFullPathName(pFile->pszPath, MAX_PATH, szFullPath, NULL) > 0)
        {
            TRACEW1( "full path=%s", szFullPath );
            Free(pFile->pszPath);
            pFile->pszPath = StrDup(szFullPath);

            if(NULL == pFile->pszPath)
            {
                dwErr = ERROR_CANNOT_OPEN_PHONEBOOK;
                break;
            }
        }

        fFileExists = FFileExists( pFile->pszPath );

        if ((dwFlags & RPBF_NoCreate) && !fFileExists)
        {
            dwErr = ERROR_CANNOT_OPEN_PHONEBOOK;
            break;
        }

        if (!fFileExists)
        {
            // The phonebook file does not exist, so we need to create it.
            //
            HANDLE hFile;
            SECURITY_ATTRIBUTES sa;
            PSECURITY_DESCRIPTOR pSd = NULL;

            // If we are creating the public phonebook file, be sure to
            // create it with a security descriptor that allows it to be
            // read by any authenticated user.  If we don't it may prevent
            // other users from being able to read it.
            //
            if (pFile->dwPhonebookMode == PBM_System)
            {
                dwErr = DwAllocateSecurityDescriptorAllowAccessToWorld(
                            &pSd);
                            
                if (dwErr)
                {
                    break;
                }
            }

            // Be sure that any directories on the path to the phonebook file
            // exist.  Otherwise, CreatFile will fail.
            //
            CreateDirectoriesOnPath(
                pFile->pszPath,
                NULL);

            sa.nLength = sizeof(SECURITY_ATTRIBUTES);
            sa.lpSecurityDescriptor = pSd;
            sa.bInheritHandle = TRUE;

            hFile =
                CreateFile(
                    pFile->pszPath,
                    GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ,
                    &sa,
                    CREATE_ALWAYS,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL );

            Free0(pSd);

            if (hFile == INVALID_HANDLE_VALUE)
            {
                dwErr = ERROR_CANNOT_OPEN_PHONEBOOK;
                break;
            }

            CloseHandle( hFile );

            if (pFile->dwPhonebookMode == PBM_System)
            {
                TRACE( "System phonebook created." );
            }
            else
            {
                TRACE( "User phonebook created." );
            }
        }

        // Load the phonebook file into memory.  In "write" mode, comments are
        // loaded so user's custom comments (if any) will be preserved.
        // Normally, there will be none so this costs nothing in the typical
        // case.
        //
        {
            DWORD dwMode;
            CHAR* pszPathA;

            dwMode = 0;
            if (dwFlags & RPBF_ReadOnly)
            {
                dwMode |= RFM_READONLY;
            }
            else
            {
                dwMode |= RFM_CREATE | RFM_LOADCOMMENTS;
            }

            if (dwFlags & RPBF_HeadersOnly)
            {
                dwMode |= RFM_ENUMSECTIONS;
            }

            // Read the disk file into a linked list of lines.
            //
            pszPathA = StrDupAFromTAnsi( pFile->pszPath );

            if (pszPathA)
            {
                ASSERT( g_hmutexPb );
                WaitForSingleObject( g_hmutexPb, INFINITE );

                pFile->hrasfile = RasfileLoad(
                    pszPathA, dwMode, NULL, IsGroup );

                ReleaseMutex( g_hmutexPb );
            }

            Free0( pszPathA );

            if (pFile->hrasfile == -1)
            {
                dwErr = ERROR_CANNOT_LOAD_PHONEBOOK;
                break;
            }
        }

        // Parse the linked list of lines
        //
        if (!(dwFlags & RPBF_NoList))
        {
            // Read the phonebook file
            //
            dwErr = ReadEntryList( 
                        pFile, 
                        dwFlags, 
                        pszSection );
            if (dwErr != NO_ERROR)
            {
                break;
            }
        }
    }
    while (FALSE);

    if (dwErr != 0)
    {
        //
        // If we failed to read entry lists, ReadEntry*List above would
        // have cleaned the lists. NULL the lists so that ClosePhonebookFile
        // doesn't attempt to free the already freed memory
        //
        pFile->pdtllistEntries = NULL;
        ClosePhonebookFile( pFile );
    }

    TRACE1( "ReadPhonebookFile=%d", dwErr );
    return dwErr;
}


DWORD
ReadPhoneList(
    IN HRASFILE h,
    IN RFSCOPE rfscope,
    OUT DTLLIST** ppdtllist,
    OUT BOOL* pfDirty )

    // Utility routine to read a list of PBPHONE nodes from next lines in the
    // scope 'rfscope'.  The result is placed in the allocated '*ppdtllist'
    // list.  The current line is reset to the start of the scope after the
    // call.  '*pfDirty' is set true if the entry should be re-written.
    //
    // Returns 0 if successful, or a non-zero error code.  "Not found" is
    // considered successful, in which case 'pdtllistResult' is set to an
    // empty list.  Caller is responsible for freeing the returned
    // '*ppdtllist' list.
    //
{
    CHAR szValue[ RAS_MAXLINEBUFLEN + 1 ];
    DTLNODE* pdtlnode;
    PBPHONE* pPhone;
    BOOL fOk;

    // Free existing list, if present.
    //
    if (*ppdtllist)
    {
        DtlDestroyList( *ppdtllist, DestroyPhoneNode );
    }

    if (!(*ppdtllist = DtlCreateList( 0 )))
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    while (RasfileFindNextKeyLine( h, KEY_PhoneNumber, rfscope ))
    {
        fOk = FALSE;

        do
        {
            // Allocate and link a node for the new phone number set.
            //
            pdtlnode = CreatePhoneNode();
            if (!pdtlnode)
            {
                break;
            }

            DtlAddNodeLast( *ppdtllist, pdtlnode );
            pPhone = (PBPHONE* )DtlGetData( pdtlnode );

            // Read the individual fields in the set.
            //
            if (!RasfileGetKeyValueFields( h, NULL, szValue )
                || !(pPhone->pszPhoneNumber = StrDupTFromA( szValue )))
            {
                break;
            }

            if (RasfileFindNextKeyLine( h, KEY_AreaCode, rfscope ))
            {
                if (!RasfileGetKeyValueFields( h, NULL, szValue )
                    || !(pPhone->pszAreaCode = StrDupTFromA( szValue )))
                {
                    break;
                }
            }

            if (RasfileFindNextKeyLine( h, KEY_CountryCode, rfscope ))
            {
                DWORD dwCountryCode;

                if (!RasfileGetKeyValueFields( h, NULL, szValue ))
                {
                    break;
                }

                dwCountryCode = atol( szValue );
                if (dwCountryCode > 0)
                {
                    pPhone->dwCountryCode = dwCountryCode;
                }
                else
                {
                    *pfDirty = TRUE;
                }
            }

            if (RasfileFindNextKeyLine( h, KEY_CountryID, rfscope ))
            {
                DWORD dwCountryID;

                if (!RasfileGetKeyValueFields( h, NULL, szValue ))
                {
                    break;
                }

                dwCountryID = atol( szValue );
                if (dwCountryID > 0)
                {
                    pPhone->dwCountryID = dwCountryID;
                }
                else
                {
                    *pfDirty = TRUE;
                }
            }

            if (RasfileFindNextKeyLine( h, KEY_UseDialingRules, rfscope ))
            {
                if (!RasfileGetKeyValueFields( h, NULL, szValue ))
                {
                    break;
                }

                pPhone->fUseDialingRules = !!(atol( szValue ));
            }

            if (RasfileFindNextKeyLine( h, KEY_Comment, rfscope ))
            {
                if (!RasfileGetKeyValueFields( h, NULL, szValue )
                    || !(pPhone->pszComment = StrDupTFromA( szValue )))
                {
                    break;
                }
            }

            fOk = TRUE;

        }
        while (FALSE);

        if (!fOk)
        {
            // One of the allocations failed.  Clean up.
            //
            DtlDestroyList( *ppdtllist, DestroyPhoneNode );
            *ppdtllist = NULL;
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    return 0;
}


DWORD
ReadString(
    IN HRASFILE h,
    IN STRDUP_T_FROM_A_FUNC pStrDupTFromA,
    IN RFSCOPE rfscope,
    IN CHAR* pszKey,
    OUT TCHAR** ppszResult )

    // Utility routine to read a string value from the next line in the scope
    // 'rfscope' with key 'pszKey'.  The result is placed in the allocated
    // '*ppszResult' buffer.  The current line is reset to the start of the
    // scope if the call was successful.
    //
    // Returns 0 if successful, or a non-zero error code.  "Not found" is
    // considered successful, in which case '*ppszResult' is not changed.
    // Caller is responsible for freeing the returned '*ppszResult' buffer.
    //
{
    CHAR szValue[ RAS_MAXLINEBUFLEN + 1 ];
    BOOL fFound;

    fFound = RasfileFindNextKeyLine( h, pszKey, rfscope );
    if (!fFound)
    {
        //DbgPrint( "Pbk Perf: seeking back to top of scope to look for '%s'\n",
        //    pszKey );

        RasfileFindFirstLine( h, RFL_ANY, rfscope );
        fFound = RasfileFindNextKeyLine( h, pszKey, rfscope );
    }

    if (fFound)
    {
        if (!RasfileGetKeyValueFields( h, NULL, szValue )
            || !(*ppszResult = pStrDupTFromA( szValue )))
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    return 0;
}


DWORD
ReadStringList(
    IN HRASFILE h,
    IN RFSCOPE rfscope,
    IN CHAR* pszKey,
    OUT DTLLIST** ppdtllistResult )

    // Utility routine to read a list of string values from next lines in the
    // scope 'rfscope' with key 'pszKey'.  The result is placed in the
    // allocated '*ppdtllistResult' list.  The current line is reset to the
    // start of the scope after the call.
    //
    // Returns 0 if successful, or a non-zero error code.  "Not found" is
    // considered successful, in which case 'pdtllistResult' is set to an
    // empty list.  Caller is responsible for freeing the returned
    // '*ppdtllistResult' list.
    //
{
    CHAR szValue[ RAS_MAXLINEBUFLEN + 1 ];

    // Free existing list, if present.
    //
    if (*ppdtllistResult)
    {
        DtlDestroyList( *ppdtllistResult, DestroyPszNode );
        *ppdtllistResult = NULL;
    }

    if (!(*ppdtllistResult = DtlCreateList( 0 )))
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    while (RasfileFindNextKeyLine( h, pszKey, rfscope ))
    {
        TCHAR* psz;
        DTLNODE* pdtlnode;

        if (!RasfileGetKeyValueFields( h, NULL, szValue )
            || !(psz = StrDupTFromA( szValue )))
        {
            DtlDestroyList( *ppdtllistResult, DestroyPszNode );
            *ppdtllistResult = NULL;
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        if (!(pdtlnode = DtlCreateNode( psz, 0 )))
        {
            Free( psz );
            DtlDestroyList( *ppdtllistResult, DestroyPszNode );
            *ppdtllistResult = NULL;
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        DtlAddNodeLast( *ppdtllistResult, pdtlnode );
    }

    return 0;
}

VOID
TerminatePbk(
    void )

    // Terminate  the PBK library.  This routine should be called after all
    // PBK library access is complete.  See also InitializePbk.
    //
{
    if (g_hmutexPb)
    {
        CloseHandle( g_hmutexPb );
    }
}

DWORD
WritePhonebookFile(
    IN PBFILE* pFile,
    IN LPCTSTR pszSectionToDelete )

    // Write out any dirty globals or entries in 'pFile'.  The
    // 'pszSectionToDelete' indicates a section to delete or is NULL.
    //
    // Returns 0 if successful, otherwise a non-zero error code.
    //
{
    DWORD dwErr;
    HRASFILE h = pFile->hrasfile;

    TRACE( "WritePhonebookFile" );

    if (pszSectionToDelete)
    {
        CHAR* pszSectionToDeleteA;

        pszSectionToDeleteA = StrDupAFromT( pszSectionToDelete );
        if (!pszSectionToDeleteA)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        if (RasfileFindSectionLine( h, pszSectionToDeleteA, TRUE ))
        {
            DeleteCurrentSection( h );
        }

        Free( pszSectionToDeleteA );
    }

    dwErr = ModifyEntryList( pFile );
    if (dwErr != 0)
    {
        return dwErr;
    }

    {
        BOOL f;

        ASSERT( g_hmutexPb );
        WaitForSingleObject( g_hmutexPb, INFINITE );

        f = RasfileWrite( h, NULL );

        ReleaseMutex( g_hmutexPb );

        if (!f)
        {
            return ERROR_CANNOT_WRITE_PHONEBOOK;
        }
    }

    return 0;
}

DWORD
DwReadEntryFromPhonebook(LPCTSTR pszPhonebook,
                         LPCTSTR pszEntry,
                         DWORD   dwFlags,
                         DTLNODE **ppdtlnode,
                         PBFILE  *pFile)

// Reads the entry node from the name and the phoenbook
// file specified. 'pszPhonebook' can be NULL.
//
{
    DWORD   dwErr     = SUCCESS;
    DTLNODE *pdtlnode = NULL;

    dwErr = ReadPhonebookFile(
              pszPhonebook,
              NULL,
              NULL,
              dwFlags,
              pFile);

    if (SUCCESS != dwErr)
    {
        dwErr = ERROR_CANNOT_OPEN_PHONEBOOK;
    }
    else
    {
        //
        // Find the specified phonebook entry.
        //
        pdtlnode = EntryNodeFromName(
                     pFile->pdtllistEntries,
                     pszEntry);

    }

    if(     (SUCCESS == dwErr)
        &&  (NULL == pdtlnode))
    {

        ClosePhonebookFile(pFile);

        dwErr = ERROR_CANNOT_FIND_PHONEBOOK_ENTRY;
    }

    *ppdtlnode = pdtlnode;

    return dwErr;
}

DWORD
DwFindEntryInPersonalPhonebooks(LPCTSTR pszEntry,
                                PBFILE  *pFile,
                                DWORD   dwFlags,
                                DTLNODE **ppdtlnode,
                                BOOL    fLegacy)

// Tries to find the entry specified by pszEntry in the
// pbk files located in the users profile if fLegacy is
// false. Otherwise it looks in pbks in System32\Ras for
// the entry.
//
{
    DWORD dwErr = SUCCESS;

    //
    // consider allocing the paths below.
    // Too much on the stack otherwise.
    //
    TCHAR szFilePath[MAX_PATH + 1];
    TCHAR szFileName[MAX_PATH + 1];
    BOOL  fFirstTime = TRUE;

    WIN32_FIND_DATA wfdData;

    HANDLE hFindFile = INVALID_HANDLE_VALUE;

    ZeroMemory((PBYTE) szFilePath, sizeof(szFilePath));
    ZeroMemory((PBYTE) szFileName, sizeof(szFileName));

#if DBG
    ASSERT(NULL != ppdtlnode);
#endif

    *ppdtlnode = NULL;

    //
    // Get the personal phonebook directory if its not
    // legacy
    //
    if(fLegacy)
    {
        UINT cch = GetSystemDirectory(szFileName, MAX_PATH + 1);

        if (    (cch == 0)
            ||  (cch > (MAX_PATH - (5 + 8 + 1 + 3))))
        {
            goto done;
        }

        lstrcat(szFileName, TEXT("\\Ras\\"));
    }
    else if(!GetPhonebookDirectory(PBM_Personal,
                              szFileName))
    {
        dwErr = ERROR_CANNOT_OPEN_PHONEBOOK;
        goto done;
    }

    if(lstrlen(szFilePath) > (MAX_PATH - lstrlen(TEXT("*.pbk"))))
    {   
        dwErr = ERROR_CANNOT_OPEN_PHONEBOOK;
        goto done;
    }   

    wsprintf(szFilePath,
             TEXT("%s%s"),
             szFileName,
             TEXT("*.pbk"));


    //
    // Look for files with .pbk extension in this
    // directory.
    //
    while(SUCCESS == dwErr)
    {
        if(INVALID_HANDLE_VALUE == hFindFile)
        {
            hFindFile = FindFirstFile(szFilePath,
                                      &wfdData);

            if(INVALID_HANDLE_VALUE == hFindFile)
            {
                dwErr = GetLastError();
                break;
            }
        }
        else
        {
            if(!FindNextFile(hFindFile,
                             &wfdData))
            {
                dwErr = GetLastError();
                break;
            }
        }

        if(FILE_ATTRIBUTE_DIRECTORY & wfdData.dwFileAttributes)
        {
            continue;
        }

        if(lstrlen(wfdData.cFileName) > (MAX_PATH - lstrlen(szFileName)))
        {
            //
            // Modify RAS code to take into account file names
            // larger than MAX_PATH.
            //
            dwErr = ERROR_CANNOT_OPEN_PHONEBOOK;
            goto done;
        }

        //
        // Construct full path name to the pbk file
        //
        wsprintf(szFilePath,
                 TEXT("%s\\%s"),
                 szFileName,
                 wfdData.cFileName);

        //
        // Ignore the phonebook if its router.pbk
        //
        if(     (fLegacy)
            &&  (IsRouterPhonebook(szFilePath)))
        {
            continue;
        }

        dwErr = DwReadEntryFromPhonebook(szFilePath,
                                         pszEntry,
                                         dwFlags,
                                         ppdtlnode,
                                         pFile);

        if(     (SUCCESS == dwErr)
            &&  (NULL != *ppdtlnode))
        {
            break;
        }
        else
        {
            //
            // For some reason we were not able to
            // read the entry - entry not there,
            // failed to open the phonebook. In all
            // error cases try to open the next pbk
            // file.
            //
            dwErr = SUCCESS;
        }
    }

done:

    if(NULL == *ppdtlnode)
    {
        dwErr = ERROR_CANNOT_FIND_PHONEBOOK_ENTRY;
    }

    if(INVALID_HANDLE_VALUE != hFindFile)
    {
        FindClose(hFindFile);
    }

    return dwErr;
}

DWORD
DwEnumeratePhonebooksFromDirectory(
    TCHAR *pszDir,
    DWORD dwFlags,
    PBKENUMCALLBACK pfnCallback,
    VOID *pvContext
    )
{
    DWORD dwErr = SUCCESS;

    //
    // consider allocing the paths below.
    // Too much on the stack otherwise.
    //
    TCHAR szFilePath[MAX_PATH + 1];
    BOOL  fFirstTime = TRUE;
    PBFILE file;

    WIN32_FIND_DATA wfdData;

    HANDLE hFindFile = INVALID_HANDLE_VALUE;

    if(NULL == pszDir)
    {
        dwErr = E_INVALIDARG;
        goto done;
    }

    ZeroMemory((PBYTE) szFilePath, sizeof(szFilePath));

    wsprintf(szFilePath,
             TEXT("%s%s"),
             pszDir,
             TEXT("*.pbk"));

    //
    // Look for files with .pbk extension in this
    // directory.
    //
    while(SUCCESS == dwErr)
    {
        if(INVALID_HANDLE_VALUE == hFindFile)
        {
            hFindFile = FindFirstFile(szFilePath,
                                      &wfdData);

            if(INVALID_HANDLE_VALUE == hFindFile)
            {
                dwErr = GetLastError();
                break;
            }
        }
        else
        {
            if(!FindNextFile(hFindFile,
                             &wfdData))
            {
                dwErr = GetLastError();
                break;
            }
        }

        if(FILE_ATTRIBUTE_DIRECTORY & wfdData.dwFileAttributes)
        {
            continue;
        }

        wsprintf(szFilePath,
                 TEXT("%s%s"),
                 pszDir,
                 wfdData.cFileName);

        //
        // Ignore the phonebook if its router.pbk
        //
        if(IsRouterPhonebook(szFilePath))
        {
            continue;
        }

        dwErr = ReadPhonebookFile(
                        szFilePath,
                        NULL,
                        NULL,
                        dwFlags,
                        &file);

        if(SUCCESS == dwErr)
        {
            //
            // Call back
            //
            pfnCallback(&file, pvContext);

            ClosePhonebookFile(&file);
        }
        else
        {
            dwErr = SUCCESS;
        }
    }

done:

    if(     (ERROR_NO_MORE_FILES == dwErr)
        ||  (ERROR_FILE_NOT_FOUND == dwErr))
    {
        dwErr = ERROR_SUCCESS;
    }

    if(INVALID_HANDLE_VALUE != hFindFile)
    {
        FindClose(hFindFile);
    }

    return dwErr;
}


DWORD
GetPbkAndEntryName(
    IN  LPCTSTR          pszPhonebook,
    IN  LPCTSTR          pszEntry,
    IN  DWORD            dwFlags,
    OUT PBFILE           *pFile,
    OUT DTLNODE          **ppdtlnode)

// Finds the phonebook entrynode given the entryname.
// The node is returned in 'ppdtlnode'. If 'pszPhonebook'
// is NULL, All Users phonebook is searched first for the
// entry and if its not found there, Phonebooks in the per
// user profile are searched for the entry. 'pFile' on return
// from this function contains the open phonebook containing
// the entry specified by pszEntry. Note: if there are
// mutiple entries with the same name across phonebooks, the
// entry correspoding the first phonebook enumerated is returned.
//
{
    DWORD dwErr = SUCCESS;
    DTLNODE *pdtlnode = NULL;
    TCHAR* szPathBuf = NULL;

    TRACE("GetPbkAndEntryName");

    //
    // Do some parameter validation
    //
    if(     (NULL == pszEntry)
        ||  (NULL == ppdtlnode)
        ||  (NULL == pFile))
    {
        dwErr = E_INVALIDARG;
        goto done;
    }

    if (! (szPathBuf = (TCHAR*) Malloc((MAX_PATH + 1) * sizeof(TCHAR))))
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto done;
    }

    // XP 426903
    //
    // On consumer platforms, we default to looking at all-user connections
    // even if the current user is not an admin.
    //
    if ((NULL == pszPhonebook) && (IsConsumerPlatform()))
    {
        dwFlags |= RPBF_AllUserPbk;
    }

    //
    // Load the phonebook file.
    //
    dwErr = DwReadEntryFromPhonebook(pszPhonebook,
                                     pszEntry,
                                     dwFlags,
                                     &pdtlnode,
                                     pFile);

    if(     (ERROR_SUCCESS == dwErr)
        ||  (NULL != pszPhonebook))
    {
        if(     (ERROR_SUCCESS != dwErr)
            &&  (NULL != pszPhonebook))
        {
            if(GetPhonebookDirectory(
                            PBM_Alternate,
                            szPathBuf))
            {
                lstrcat(szPathBuf, TEXT("rasphone.pbk"));
                
                if(0 == lstrcmpi(szPathBuf, pszPhonebook))
                {
                    //
                    // some one is passing the legacy
                    // phonebook path exclusively, check
                    // to see if the entry is in the
                    // all-users phonebook. NetScape does
                    // the following which requires this
                    // workaround: Creates an entry with
                    // NULL pbk path so the entry gets
                    // created in all-users. Then passes
                    // %windir%\system32\ras\rasphone.pbk
                    // explicitly to find the entry - and
                    // because of the system pbk change in
                    // nt5 this doesn't work unless we do
                    // the hack below.
                    //
                    dwErr = DwReadEntryFromPhonebook(
                                    NULL,
                                    pszEntry,
                                    dwFlags,
                                    &pdtlnode,
                                    pFile);

                    if(ERROR_SUCCESS != dwErr)
                    {
                        dwErr = ERROR_CANNOT_FIND_PHONEBOOK_ENTRY;
                    }
                }
            }
        }
        
        goto done;
    }

    //
    // Try to find the entry in personal phonebooks.
    //
    dwErr = DwFindEntryInPersonalPhonebooks(pszEntry,
                                            pFile,
                                            dwFlags,
                                            &pdtlnode,
                                            FALSE);

    if(ERROR_SUCCESS == dwErr)
    {
        goto done;
    }

    //
    // Try to find the entry in the system32\ras phonebooks.
    //
    dwErr = DwFindEntryInPersonalPhonebooks(pszEntry,
                                            pFile,
                                            dwFlags,
                                            &pdtlnode,
                                            TRUE);
    if(ERROR_SUCCESS == dwErr)
    {
        goto done;
    }
    
    //
    // If the phonebookpath is NULL explicitly try out
    // the public phonebook.
    //
    if(GetPublicPhonebookPath(szPathBuf))
    {
        dwErr = DwReadEntryFromPhonebook(
                                szPathBuf,
                                pszEntry,
                                dwFlags,
                                &pdtlnode,
                                pFile);
    }

    if(ERROR_SUCCESS != dwErr)
    {
        dwErr = ERROR_CANNOT_FIND_PHONEBOOK_ENTRY;
    }

done:

    *ppdtlnode = pdtlnode;

    Free0(szPathBuf);

    TRACE1("GetPbkAndEntryName. rc=0x%x",
           dwErr);

    return dwErr;

}

DWORD
GetFmtServerFromConnection(
    IN HANDLE hConnection,
    IN PWCHAR  pszServerFmt)
{
    PWCHAR pszServer = (PWCHAR) RemoteGetServerName( hConnection );

    if ( pszServer && *pszServer )
    {
        if ( *pszServer == L'\0' )
        {
            wcscpy( pszServerFmt, pszServer );
        }
        else
        {
            pszServerFmt[0] = pszServerFmt[1] = L'\\';
            wcscpy( pszServerFmt + 2, pszServer );
        }
    }
    else
    {
        *pszServerFmt = L'\0';
    }

    return NO_ERROR;
}

DWORD
UpgradeSecureVpnOption( 
    IN HKEY hkMachine,
    IN PBENTRY* pEntry )

// Called to upgrade the "secure vpn" option.  If this was set in 
// nt4, it meant that all vpn entries should use strong encryption.
// If we see this on nt5, then we should for this entry to use
// mschapv2.
//
{
    DWORD dwErr = NO_ERROR;
    HKEY hkValue = NULL;
    DWORD dwType = REG_DWORD, dwSize = sizeof(DWORD), dwValue = 0;

    do 
    {
        // Open the registry key that we're looking at
        //
        dwErr = RegOpenKeyEx(
                    hkMachine,
                    c_pszRegKeySecureVpn,
                    0,
                    KEY_READ,
                    &hkValue);
        if (dwErr != NO_ERROR)
        {
            break;
        }

        // Read in the value
        //
        dwErr = RegQueryValueEx(
                    hkValue,
                    c_pszRegValSecureVpn,
                    NULL,
                    &dwType,
                    (LPBYTE)&dwValue,
                    &dwSize);
        if (dwErr != NO_ERROR)
        {
            break;
        }

        // Set the entry accordingly
        //
        if (dwValue)
        {
            pEntry->dwAuthRestrictions = AR_F_AuthCustom | AR_F_AuthMSCHAP2;
        }
        
        // Delete the registry value
        //
        RegDeleteValue( hkValue, c_pszRegValSecureVpn );
        
    } while (FALSE);        

    // Cleanup
    {
        if (hkValue)
        {
            RegCloseKey (hkValue);
        }
    }

    return dwErr;
}

DWORD
UpgradeForceStrongEncrptionOption( 
    IN HKEY hkMachine,
    IN PBENTRY* pEntry )

// Called to upgrade the "force strong encryption" option.  If this was 
// set in nt4, it meant that all entries that force strong encryption
// should now force strong encryption.
//
{
    DWORD dwErr = NO_ERROR;
    HKEY hkValue = NULL;
    DWORD dwType = REG_DWORD, dwSize = sizeof(DWORD), dwValue = 0;

    do 
    {
        // Open the registry key that we're looking at
        //
        dwErr = RegOpenKeyEx(
                    hkMachine,
                    c_pszRegKeyForceStrongEncryption,
                    0,
                    KEY_READ,
                    &hkValue);
        if (dwErr != NO_ERROR)
        {
            break;
        }

        // Read in the value
        //
        dwErr = RegQueryValueEx(
                    hkValue,
                    c_pszRegValForceStrongEncryption,
                    NULL,
                    &dwType,
                    (LPBYTE)&dwValue,
                    &dwSize);
        if (dwErr != NO_ERROR)
        {
            break;
        }

        // Set the entry accordingly
        //
        if (dwValue)
        {
            if ( pEntry->dwDataEncryption == DE_Require )
            {
                pEntry->dwDataEncryption = DE_RequireMax;
            }
        }

        // Delete the registry value
        //
        RegDeleteValue( hkValue, c_pszRegValForceStrongEncryption );
        
    } while (FALSE);        

    // Cleanup
    {
        if (hkValue)
        {
            RegCloseKey (hkValue);
        }
    }

    return dwErr;
}

DWORD 
UpgradeRegistryOptions(
    IN HANDLE hConnection,
    IN PBENTRY* pEntry )

// Called to upgrade any options in this phonebook entry 
// based on registry settings.
//
{
    WCHAR pszServer[MAX_COMPUTERNAME_LENGTH + 3];
    HKEY hkMachine = NULL;
    DWORD dwErr = NO_ERROR;

    do 
    {
        // Get the formatted server name
        //
        dwErr = GetFmtServerFromConnection(hConnection, pszServer);
        if (dwErr != NO_ERROR)
        {
            break;
        }

        // Connect to the appropriate registry
        //
        dwErr = RegConnectRegistry(
                    (*pszServer) ? pszServer : NULL,
                    HKEY_LOCAL_MACHINE,
                    &hkMachine);
        if (dwErr != NO_ERROR)
        {
            break;
        }
        if (hkMachine == NULL)
        {
            dwErr = ERROR_CAN_NOT_COMPLETE;
            break;
        }

        // Upgrade the various options
        if ( pEntry->dwType == RASET_Vpn )
        {        
            UpgradeSecureVpnOption( hkMachine, pEntry );
        }
        
        UpgradeForceStrongEncrptionOption( hkMachine, pEntry );
        
    } while (FALSE);        

    // Cleanup
    {
        if (hkMachine)
        {
            RegCloseKey (hkMachine);
        }
    }

    return dwErr;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\extapi\src\asyncm.c ===
/* Copyright (c) 1992, Microsoft Corporation, all rights reserved
**
** asyncm.c
** Remote Access External APIs
** Asynchronous state machine mechanism
** Listed alphabetically
**
** This mechanism is designed to encapsulate the "make asynchronous" code
** which will differ for Win32, Win16, and DOS.
**
** 10/12/92 Steve Cobb
*/


#include <extapi.h>

//
// Prototypes for routines only used locally.
//
DWORD AsyncMachineWorker(
    IN OUT LPVOID pThreadArg
    );

BOOL WaitForEvent(
    OUT ASYNCMACHINE **pasyncmachine,
    OUT LPDWORD iEvent
    );

extern CRITICAL_SECTION RasconncbListLock;
extern DTLLIST *PdtllistRasconncb;

//
// The table of active machines and the worker
// thread handle.  The worker thread can only
// handle up to MAX_ASYNC_ITEMS simultaneously.
//
#define MAX_ASYNC_ITEMS (MAXIMUM_WAIT_OBJECTS / 3)

HANDLE              hIoCompletionPort = INVALID_HANDLE_VALUE;
RAS_OVERLAPPED      ovShutdown;
CRITICAL_SECTION    csAsyncLock;
DWORD               dwcAsyncWorkItems;
LIST_ENTRY          AsyncWorkItems;
HANDLE              hAsyncEvent;
HANDLE              hAsyncThread;
HANDLE              hDummyEvent;

VOID
InsertAsyncWorkItem(
    IN ASYNCMACHINE *pasyncmachine
    )
{
    InsertTailList(&AsyncWorkItems, &pasyncmachine->ListEntry);
    dwcAsyncWorkItems++;
}


VOID
RemoveAsyncWorkItem(
    IN ASYNCMACHINE *pasyncmachine
    )
{
    if (!IsListEmpty(&pasyncmachine->ListEntry)) 
    {
        RemoveEntryList(&pasyncmachine->ListEntry);
        
        InitializeListHead(&pasyncmachine->ListEntry);
        
        dwcAsyncWorkItems--;
    }
}


DWORD
AsyncMachineWorker(
    IN OUT LPVOID pThreadArg )

/*++

Routine Description

    Generic worker thread that call's user's OnEvent function
    whenever an event occurs.  'pThreadArg' is the address of
    an ASYNCMACHINE structure containing caller's OnEvent
    function and parameters.

Arguments    

Return Value

    Returns 0 always.
    
--*/
{
    PLIST_ENTRY pEntry;
    ASYNCMACHINE* pasyncmachine;
    DWORD iEvent;

    for (;;)
    {
        //
        // WaitForEvent will return FALSE when there
        // are no items in the queue.
        //
        if (!WaitForEvent(&pasyncmachine, &iEvent))
        {
            break;
        }

        if (pasyncmachine->oneventfunc(
                pasyncmachine, (iEvent == INDEX_Drop) ))
        {
            //
            // Clean up resources.  This must be protected from 
            // interference by RasHangUp.
            //
            RASAPI32_TRACE("Asyncmachine: Cleaning up");
            
            EnterCriticalSection(&csStopLock);
            
            pasyncmachine->cleanupfunc(pasyncmachine);
            
            LeaveCriticalSection(&csStopLock);
        }
    }

    RASAPI32_TRACE("AsyncMachineWorker terminating");

    EnterCriticalSection(&csStopLock);

    EnterCriticalSection(&csAsyncLock);
    
    CloseHandle(hAsyncThread);
    
    CloseHandle(hIoCompletionPort);
    
    hIoCompletionPort = INVALID_HANDLE_VALUE;
    
    hAsyncThread = NULL;
    
    InitializeListHead(&AsyncWorkItems);
    
    LeaveCriticalSection(&csAsyncLock);

    SetEvent( HEventNotHangingUp );
    
    LeaveCriticalSection(&csStopLock);

    return 0;
}


VOID
CloseAsyncMachine(
    IN OUT ASYNCMACHINE* pasyncmachine )

/*++

Routine Description

    Releases resources associated with the asynchronous 
    state machine described in 'pasyncmachine'.

Arguments

Return Value
    
--*/

{
    DWORD dwErr;

    RASAPI32_TRACE("CloseAsyncMachine");

    EnterCriticalSection(&csAsyncLock);

    //
    // Disable the rasman I/O completion
    // port events.
    //
    if (pasyncmachine->hport == INVALID_HPORT)
    {
        dwErr = EnableAsyncMachine(
                  pasyncmachine->hport,
                  pasyncmachine,
                  ASYNC_DISABLE_ALL);
    }                  

    if (pasyncmachine->hDone) 
    {
        SetEvent(pasyncmachine->hDone);
        
        CloseHandle(pasyncmachine->hDone);
        
        pasyncmachine->hDone = NULL;
    }
    
    //
    // Remove the work item from the list of work items.
    // The worker thread will exit when there are no more
    // work items.
    //
    RemoveAsyncWorkItem(pasyncmachine);
    SetEvent(hAsyncEvent);

    LeaveCriticalSection(&csAsyncLock);
}


DWORD
NotifyCaller(
    IN DWORD        dwNotifierType,
    IN LPVOID       notifier,
    IN HRASCONN     hrasconn,
    IN DWORD        dwSubEntry,
    IN ULONG_PTR    dwCallbackId,
    IN UINT         unMsg,
    IN RASCONNSTATE state,
    IN DWORD        dwError,
    IN DWORD        dwExtendedError
    )

/*++

Routine Description

    Notify API caller of a state change event.  If
    the RASDIALFUNC2-style callback returns 0,
    the dial machine will not issue further callbacks
    for this connection.  If it returns 2, then the
    dial machine will re-read the phonebook entry
    for this connection, assuming a field in it has
    been modified.

Arguments

Return Value
    
--*/
{
    DWORD dwNotifyResult = 1;

    RASAPI32_TRACE5("NotifyCaller(nt=0x%x,su=%d,s=%d,e=%d,xe=%d)...",
      dwNotifierType,
      dwSubEntry,
      state,
      dwError,
      dwExtendedError);

    switch (dwNotifierType)
    {
        case 0xFFFFFFFF:
            SendMessage(
                (HWND )notifier, 
                unMsg, 
                (WPARAM )state, 
                (LPARAM )dwError );
            break;

        case 0:
            ((RASDIALFUNC )notifier)(
                (DWORD )unMsg, 
                (DWORD )state, 
                dwError );
            break;

        case 1:
            ((RASDIALFUNC1 )notifier)(
                        hrasconn, 
                        (DWORD )unMsg, 
                        (DWORD )state, 
                        dwError,
                        dwExtendedError 
                        );
            break;

        case 2:

            __try
            {
                dwNotifyResult =
                  ((RASDIALFUNC2)notifier)(
                    dwCallbackId,
                    dwSubEntry,
                    hrasconn,
                    (DWORD)unMsg,
                    (DWORD)state,
                    dwError,
                    dwExtendedError);
            }                
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                DWORD dwExceptionCode = GetExceptionCode();
                
                RASAPI32_TRACE2("NotifyCaller: notifier %p raised "
                        "exception 0x%x", 
                        notifier,
                        dwExceptionCode);

#if DBG
                DebugBreak();                         
#endif
                        
                ASSERT(FALSE);
            }
            
            break;
    }

    RASAPI32_TRACE1("NotifyCaller done (dwNotifyResult=%d)", 
           dwNotifyResult);

    return dwNotifyResult;
}


VOID
SignalDone(
    IN OUT ASYNCMACHINE* pasyncmachine )
/*++

Routine Description

    Triggers the "done with this state" event associated
    with 'pasyncmachine'.

Arguments

Return Value

--*/    
{
    if (hIoCompletionPort == INVALID_HANDLE_VALUE ||
        pasyncmachine->hDone == NULL)
    {
        return;
    }

    RASAPI32_TRACE1(
      "SignalDone: pOverlapped=0x%x",
      &pasyncmachine->OvStateChange);

    pasyncmachine->fSignaled = TRUE;
    if (!PostQueuedCompletionStatus(
          hIoCompletionPort,
          0,
          0,
          (LPOVERLAPPED)&pasyncmachine->OvStateChange))
    {
        pasyncmachine->dwError = GetLastError();
    }
}


VOID
ShutdownAsyncMachine(
    VOID
    )
    
/*++

Routine Description

    Tells the worker thread to shutdown.

Arguments

Return Value

--*/

{
    if (hIoCompletionPort == INVALID_HANDLE_VALUE)
        return;

    RASAPI32_TRACE1(
      "SignalShutdown: pOverlapped=0x%x",
      &ovShutdown);

    PostQueuedCompletionStatus(
      hIoCompletionPort,
      0,
      0,
      (LPOVERLAPPED)&ovShutdown);
}


DWORD
StartAsyncMachine(
    IN OUT ASYNCMACHINE* pasyncmachine,
    IN HRASCONN hrasconn)

/*++ 

Routine Description

    Allocates system resources necessary to run the async
    state machine 'pasyncmachine'.  Caller should fill in
    the oneventfunc and 'pParams' members of 'pasyncmachine'
    before the call.

Arguments

Return Value

    Returns 0 if successful, otherwise a non-0 error code.
    
--*/
{
    DWORD dwThreadId;
    DWORD dwErr = 0;

    RASAPI32_TRACE("StartAsyncMachine");

    pasyncmachine->dwError = 0;
    
    pasyncmachine->hDone = NULL;
    
    pasyncmachine->fSignaled = FALSE;
    
    pasyncmachine->hport = INVALID_HPORT;
    
    pasyncmachine->dwfMode = ASYNC_DISABLE_ALL;
    
    pasyncmachine->OvDrop.RO_EventType = OVEVT_DIAL_DROP;
    
    pasyncmachine->OvDrop.RO_Info = (PVOID)pasyncmachine;

    pasyncmachine->OvDrop.RO_hInfo = hrasconn;
    
    pasyncmachine->OvStateChange.RO_EventType = OVEVT_DIAL_STATECHANGE;
    
    pasyncmachine->OvStateChange.RO_Info = (PVOID)pasyncmachine;

    pasyncmachine->OvStateChange.RO_hInfo = hrasconn;
    
    pasyncmachine->OvPpp.RO_EventType = OVEVT_DIAL_PPP;
    
    pasyncmachine->OvPpp.RO_Info = (PVOID)pasyncmachine;

    pasyncmachine->OvPpp.RO_hInfo = hrasconn;
    
    pasyncmachine->OvLast.RO_EventType = OVEVT_DIAL_LAST;
    
    pasyncmachine->OvLast.RO_Info = (PVOID)pasyncmachine;

    pasyncmachine->OvLast.RO_hInfo = hrasconn;

    do
    {
        //
        // Create the event that is signaled by
        // the dialing machine when the connection
        // is completed.
        //
        if (!(pasyncmachine->hDone = CreateEvent(NULL,
                                                 FALSE,
                                                 FALSE,
                                                 NULL))) 
        {
            dwErr = GetLastError();
            break;
        }

        EnterCriticalSection(&csAsyncLock);
        
        //
        // Insert the work item into the list of
        // work items.
        //
        InsertTailList(&AsyncWorkItems, &pasyncmachine->ListEntry);
        
        dwcAsyncWorkItems++;
        
        //
        // Fork a worker thread if necessary.
        //
        if (hAsyncThread == NULL) 
        {
            //
            // Create the I/O completion port used in the
            // dialing state machine.
            //
            hIoCompletionPort = CreateIoCompletionPort(
                                  INVALID_HANDLE_VALUE,
                                  NULL,
                                  0,
                                  0);
                                  
            if (hIoCompletionPort == NULL)
            {
                dwErr = GetLastError();
                RemoveAsyncWorkItem(pasyncmachine);
                LeaveCriticalSection(&csAsyncLock);
                break;
            }
            
            //
            // Initialize the shutdown overlapped
            // structure used to shutdown the worker
            // thread.
            //
            ovShutdown.RO_EventType = OVEVT_DIAL_SHUTDOWN;

            //
            // Require that any pending HangUp has completed.
            // (This check is actually not required until
            // RasPortOpen, but putting it here confines
            // this whole "not hanging up" business to the
            // async machine routines).
            //
            WaitForSingleObject(HEventNotHangingUp, INFINITE);

            hAsyncThread = CreateThread(
                             NULL,
                             0,
                             AsyncMachineWorker,
                             NULL,
                             0,
                             (LPDWORD )&dwThreadId);
                             
            if (hAsyncThread == NULL) 
            {
                dwErr = GetLastError();
                RemoveAsyncWorkItem(pasyncmachine);
                LeaveCriticalSection(&csAsyncLock);
                break;
            }
        }
        LeaveCriticalSection(&csAsyncLock);
    }
    while (FALSE);

    if (dwErr) 
    {
        CloseHandle(pasyncmachine->hDone);
        pasyncmachine->hDone = NULL;
    }

    return dwErr;
}


VOID
SuspendAsyncMachine(
    IN OUT ASYNCMACHINE* pasyncmachine,
    IN BOOL fSuspended )
{
    if (pasyncmachine->fSuspended != fSuspended) 
    {
        pasyncmachine->fSuspended = fSuspended;
        
        //
        // Restart the async machine again, if necessary.
        //
        if (!fSuspended)
        {
            SignalDone(pasyncmachine);
        }
    }
}


DWORD
ResetAsyncMachine(
    IN OUT ASYNCMACHINE* pasyncmachine
    )
{
    pasyncmachine->dwError = 0;
    return 0;
}


BOOL
StopAsyncMachine(
    IN OUT ASYNCMACHINE* pasyncmachine )

/*++

Routine Description

    Tells the thread captured in 'pasyncmachine' to 
    terminate at the next opportunity.  The call may
    return before the machine actually terminates.

Arguments

Return Value

    Returns true if the machine is running on entry,
    false otherwise.
    
--*/
{
    BOOL fStatus = FALSE;
    DWORD dwErr;

    RASAPI32_TRACE("StopAsyncMachine");

    //
    // Disable the rasman I/O completion
    // port events.
    //
    dwErr = EnableAsyncMachine(
              pasyncmachine->hport,
              pasyncmachine,
              ASYNC_DISABLE_ALL);

    //
    // ...and tell this async machine to stop as
    // soon as possible.
    //
    fStatus = TRUE;

    return fStatus;
}

BOOL
fAsyncMachineRunning(PRAS_OVERLAPPED pRasOverlapped)
{
    RASCONNCB *prasconncb;
    BOOL fAMRunning = FALSE;
    DTLNODE *pdtlnode;

    EnterCriticalSection (  &RasconncbListLock );
    
    for (pdtlnode = DtlGetFirstNode( PdtllistRasconncb );
         pdtlnode;
         pdtlnode = DtlGetNextNode ( pdtlnode ))
    {
        prasconncb = (RASCONNCB*) DtlGetData( pdtlnode );
        
        if (    pRasOverlapped == 
                    &prasconncb->asyncmachine.OvStateChange
            ||  pRasOverlapped == 
                    &prasconncb->asyncmachine.OvDrop
            ||  pRasOverlapped == 
                    &prasconncb->asyncmachine.OvPpp
            ||  pRasOverlapped == 
                    &prasconncb->asyncmachine.OvLast)
        {
            if(     (NULL != pRasOverlapped->RO_Info)
                &&  (   (prasconncb->hrasconn == 
                        (HRASCONN) pRasOverlapped->RO_hInfo)
                    ||  (prasconncb->hrasconnOrig ==
                        (HRASCONN) pRasOverlapped->RO_hInfo)))
            {
                fAMRunning = TRUE;
                break;
            }
        }
    }            
    
    LeaveCriticalSection( &RasconncbListLock );

    if ( !fAMRunning )
    {
        RASAPI32_TRACE("fAsyncMachineRunning: The Asyncmachine"
              " is shutdown");
    }

    return fAMRunning;

    
}

BOOL
WaitForEvent(
    OUT ASYNCMACHINE **pasyncmachine,
    OUT LPDWORD piEvent
    )

/*++    

Routine Description
    Waits for one of the events associated with 
    'pasyncmachine' to be set. The dwError member
    of 'pasyncmachine' is set if an error occurs.

Arguments

Return Value

    Returns the index of the event that occurred.
    
--*/

{
    DWORD       dwcWorkItems,
                dwBytesTransferred;
    ULONG_PTR   ulpCompletionKey;
          
    PRAS_OVERLAPPED pOverlapped;

    RASAPI32_TRACE("WaitForEvent");

again:

    //
    // Wait for an event posted to the
    // I/O completion port.
    //
    if (!GetQueuedCompletionStatus(
           hIoCompletionPort,
           &dwBytesTransferred,
           &ulpCompletionKey,
           (LPOVERLAPPED *)&pOverlapped,
           INFINITE))
    {
        RASAPI32_TRACE1(
          "WaitForEvent: GetQueuedCompletionStatus"
          " failed (dwErr=%d)",
          GetLastError());
          
        return FALSE;
    }

    RASAPI32_TRACE1("WorkerThread: pOverlapped=0x%x",
           pOverlapped);
    
    //
    // make sure that the asyncmachine is running
    //
    if (    pOverlapped != (PRAS_OVERLAPPED) &ovShutdown
        &&  !fAsyncMachineRunning(pOverlapped))
    {
        RASAPI32_TRACE("WaitForEvent: Ignoring this event."
             " Asyncm shutdown. This is bad!!!");

        RASAPI32_TRACE1("WaitForEvent: Received 0x%x after the"
               "the connection was destroyed",
               pOverlapped);
        
        goto again;
    }

    RASAPI32_TRACE1("WorkerThread: type=%d",
            pOverlapped->RO_EventType);
    //
    // Check for shutdown event received.
    //
    
    if (pOverlapped->RO_EventType == OVEVT_DIAL_SHUTDOWN) 
    {
        RASAPI32_TRACE("WaitForEvent: OVTEVT_DIAL_SHUTDOWN "
        "event received");
        
        return FALSE;
    }
    
    *pasyncmachine = (ASYNCMACHINE *)pOverlapped->RO_Info;
    *piEvent = pOverlapped->RO_EventType - OVEVT_DIAL_DROP;

    //
    // Check the merge disconnect flag.  If this
    // is set and the event is a disconnect event,
    // then change the event to be a state change
    // event.  This is used during callback.
    //
    if (    pOverlapped->RO_EventType == OVEVT_DIAL_DROP 
        &&  (*pasyncmachine)->dwfMode == ASYNC_MERGE_DISCONNECT)
    {
        RASAPI32_TRACE1("asyncmachine=0x%x: merging disconnect event",
               *pasyncmachine);

        //
        // just something other than INDEX_Drop
        //           
        *piEvent = *piEvent + 1;
        
        (*pasyncmachine)->dwfMode = ASYNC_ENABLE_ALL;
    }
    else if (pOverlapped->RO_EventType == OVEVT_DIAL_LAST) 
    {
        if ((*pasyncmachine)->fSignaled) 
        {
            RASAPI32_TRACE2("asyncmachine=0x%x: next event will be last"
            " event for hport=%d",
            *pasyncmachine,
            (*pasyncmachine)->hport);
            
            (*pasyncmachine)->OvStateChange.RO_EventType
                                        = OVEVT_DIAL_LAST;
            
            (*pasyncmachine)->fSignaled = FALSE;
        }
        else 
        {
            RASAPI32_TRACE2("asyncmachine=0x%x: last event for hport=%d",
                   *pasyncmachine,
                   (*pasyncmachine)->hport);
                   
            (*pasyncmachine)->freefunc(
                              *pasyncmachine,
                              (*pasyncmachine)->freefuncarg
                              );
        }
        goto again;
    }



    //
    // Clear the signaled flag set in SignalDone().
    //
    if (pOverlapped->RO_EventType == OVEVT_DIAL_STATECHANGE)
    {
        (*pasyncmachine)->fSignaled = FALSE;
    }
    
    if ((*pasyncmachine)->hDone == NULL) 
    {
        RASAPI32_TRACE1(
          "Skipping completed asyncmachine pointer: 0x%x",
          pOverlapped->RO_Info);
          
        goto again;
    }
    
    RASAPI32_TRACE2("Unblock i=%d, h=0x%x",
           *piEvent,
           *pasyncmachine);

    return TRUE;
}


DWORD
EnableAsyncMachine(
    HPORT hport,
    ASYNCMACHINE *pasyncmachine,
    DWORD dwfMode
    )
{
    DWORD dwErr = 0;

    pasyncmachine->dwfMode = dwfMode;
    
    switch (dwfMode) 
    {
    case ASYNC_ENABLE_ALL:
        ASSERT(hIoCompletionPort != INVALID_HANDLE_VALUE);
        
        RASAPI32_TRACE6(
            "EnableAsyncMachine: hport=%d, pasyncmachine=0x%x, "
            "OvDrop=0x%x, OvStateChange=0x%x, OvPpp=0x%x, "
            "OvLast=0x%x", 
            hport,
            pasyncmachine,
            &pasyncmachine->OvDrop,
            &pasyncmachine->OvStateChange,
            &pasyncmachine->OvPpp,

        &pasyncmachine->OvLast);
        
        //
        // Stash away a copy of the hport.
        //
        pasyncmachine->hport = hport;
        
        //
        // Set the I/O completion port associated
        // with this port.  The I/O completion port
        // is used in place of event handles to drive
        // the connection process.
        //
        dwErr = g_pRasSetIoCompletionPort(
                  hport,
                  hIoCompletionPort,
                  &pasyncmachine->OvDrop,
                  &pasyncmachine->OvStateChange,
                  &pasyncmachine->OvPpp,
                  &pasyncmachine->OvLast);
                  
        break;
        
    case ASYNC_MERGE_DISCONNECT:
    
        //
        // Disable the rasman I/O completion
        // port events.  No processing necessary.
        //
        break;
        
    case ASYNC_DISABLE_ALL:
    
        //
        // Disable the rasman I/O completion
        // port events.
        //
        if (pasyncmachine->hport != INVALID_HPORT)
        {
            dwErr = g_pRasSetIoCompletionPort(
                      pasyncmachine->hport,
                      INVALID_HANDLE_VALUE,
                      NULL,
                      NULL,
                      NULL,
                      NULL);
        }
        
        break;
        
    default:
    
        ASSERT(FALSE);
        RASAPI32_TRACE1("EnableAsyncMachine: invalid mode=%d",
               dwfMode);
               
        dwErr = ERROR_INVALID_PARAMETER;
        
        break;
    }

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\common\uiutil\treelist.c ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File:    treelist.c
//
// History:
//  Abolade Gbadegesin   Nov-20-1995    Created.
//
// Implementation routines for TreeList control.
//
// The TreeList control is implemented as a custom control,
// which creates and manages an owner-draw listview.
//============================================================================

#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>

#include <debug.h>
#include <nouiutil.h>
#include <uiutil.h>
#include <list.h>

#include "treelist.h"
#include "tldef.h"


#if 0
#define TLTRACE     (0x80000002)
#else
#define TLTRACE     (0x00000002)
#endif



//----------------------------------------------------------------------------
// Function:    TL_Init
//
// Registers the TreeList window class.
//----------------------------------------------------------------------------

BOOL
TL_Init(
    HINSTANCE hInstance
    ) {

    INT i;
    HICON hicon;
    WNDCLASS wc;

    //
    // do nothing if the class is already registered
    //

    if (GetClassInfo(hInstance, WC_TREELIST, &wc)) {
        return TRUE;
    }


    //
    // setup the wndclass structure, and register
    //

    wc.lpfnWndProc = TL_WndProc;
    wc.hCursor = LoadCursor(hInstance, IDC_ARROW);
    wc.hIcon = NULL;
    wc.lpszMenuName = NULL;
    wc.hInstance = hInstance;
    wc.lpszClassName = WC_TREELIST;
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
    wc.style = CS_DBLCLKS;
    wc.cbWndExtra = sizeof(TL *);
    wc.cbClsExtra = 0;

    return RegisterClass(&wc);
}




//----------------------------------------------------------------------------
// Function:    TL_WndProc
//
// This function handles messages for TreeList windows
//----------------------------------------------------------------------------

LRESULT
CALLBACK
TL_WndProc(
    HWND hwnd,
    UINT uiMsg,
    WPARAM wParam,
    LPARAM lParam
    ) {

    TL *ptl;


    if (NULL == hwnd)
    {
        return (LRESULT)FALSE;
    }

    //
    // attempt to retrieve the data pointer for the window.
    // on WM_NCCREATE, this fails, so we allocate the data.
    //
    
    ptl = TL_GetPtr(hwnd);

    if (ptl == NULL) {

        if (uiMsg != WM_NCCREATE) {
            return DefWindowProc(hwnd, uiMsg, wParam, lParam);
        }


        //
        // allocate a block of memory
        //

        ptl = (TL *)Malloc(sizeof(TL));
        if (ptl == NULL) { return (LRESULT)FALSE; }


        //
        // save the pointer in the window's private bytes
        //

        ptl->hwnd = hwnd;

        //
        //Reset Error code, TL_SetPtr won't reset error code when
        //it succeeds
        //

        SetLastError(0);
        if ((0 == TL_SetPtr(hwnd, ptl)) && (0 != GetLastError()))
        {
            Free(ptl);
            return (LRESULT)FALSE;
        }

        return DefWindowProc(hwnd, uiMsg, wParam, lParam);
    }


    //
    // if the window is being destroyed, free the block allocated
    // and set the private bytes pointer to NULL
    //

    if (uiMsg == WM_NCDESTROY) {
        Free(ptl);
        TL_SetPtr(hwnd, NULL);

        return (LRESULT)0;
    }



    switch (uiMsg) {

        HANDLE_MSG(ptl, WM_CREATE, TL_OnCreate);
        HANDLE_MSG(ptl, WM_DESTROY, TL_OnDestroy);
        HANDLE_MSG(ptl, WM_DRAWITEM, TL_OnDrawItem);
        HANDLE_MSG(ptl, WM_MEASUREITEM, TL_OnMeasureItem);
        HANDLE_MSG(ptl, WM_NOTIFY, TL_OnNotify);

        case WM_ERASEBKGND: {

            TL_OnEraseBackground(ptl, (HDC)wParam);
            return (LRESULT)TRUE;
        }

        case WM_HELP: {

            //
            // change the control-id and HWND for the help to our values
            // and pass the message on to our parent
            //

            HELPINFO *phi = (HELPINFO *)lParam;

            phi->iCtrlId = ptl->iCtrlId;
            phi->hItemHandle = ptl->hwnd;
            return SendMessage(ptl->hwndParent, WM_HELP, 0L, lParam);
        }

        case WM_SYSCOLORCHANGE: {

            //
            // notify the listview window that a color has changed
            //

            TL_CreateTreeImages(ptl);
            FORWARD_WM_SYSCOLORCHANGE(ptl->hwndList, SendMessage);
//            ListView_SetBkColor(ptl->hwndList, GetSysColor(COLOR_WINDOW));
            return (LRESULT)0;
        }

        case WM_SETFOCUS: {

            //
            // if we receive the focus, give it to the listview instead
            //

            SetFocus(ptl->hwndList);
            return (LRESULT)0;
        }


        case WM_WINDOWPOSCHANGED: {
            TL_OnWindowPosChanged(ptl, (WINDOWPOS *)lParam);
            return 0;
        }
        


        //
        // the following cases handle TreeList-defined messages
        //

        case TLM_INSERTITEM: {
            return (LRESULT)TL_OnInsertItem(ptl, (TL_INSERTSTRUCT *)lParam);
        }

        case TLM_DELETEITEM: {
            return (LRESULT)TL_OnDeleteItem(ptl, (HTLITEM)lParam);
        }

        case TLM_DELETEALLITEMS: {
            return (LRESULT)TL_OnDeleteAllItems(ptl);
        }

        case TLM_GETITEM: {
            return (LRESULT)TL_OnGetItem(ptl, (LV_ITEM *)lParam);
        }

        case TLM_SETITEM: {
            return (LRESULT)TL_OnSetItem(ptl, (LV_ITEM *)lParam);
        }

        case TLM_GETITEMCOUNT: {
            return (LRESULT)TL_OnGetItemCount(ptl);
        }

        case TLM_GETNEXTITEM: {
            return (LRESULT)TL_OnGetNextItem(ptl, (UINT)wParam,(HTLITEM)lParam);
        }

        case TLM_EXPAND: {
            return (LRESULT)TL_OnExpand(ptl, (UINT)wParam, (HTLITEM)lParam);
        }

        case TLM_SETIMAGELIST: {
            return (LRESULT)ListView_SetImageList(
                        ptl->hwndList, (HIMAGELIST)lParam, LVSIL_SMALL
                        );
        }

        case TLM_GETIMAGELIST: {
            return (LRESULT)ListView_GetImageList(ptl->hwndList, LVSIL_SMALL);
        }

        case TLM_INSERTCOLUMN: {
            return (LRESULT)TL_OnInsertColumn(
                        ptl, (INT)wParam, (LV_COLUMN *)lParam
                        );
        }

        case TLM_DELETECOLUMN: {
            return (LRESULT)TL_OnDeleteColumn(ptl, (INT)wParam);
        }

        case TLM_SETSELECTION: {
            return (LRESULT)TL_OnSetSelection(ptl, (HTLITEM)lParam);
        }

        case TLM_REDRAW: {
            return (LRESULT)TL_OnRedraw(ptl);
        }

        case TLM_ISITEMEXPANDED: {
            return (LRESULT)TL_IsExpanded((TLITEM *)lParam);
        }

        case TLM_GETCOLUMNWIDTH: {
            return (LRESULT)SendMessage(
                        ptl->hwndList, LVM_GETCOLUMNWIDTH, wParam, lParam
                        );
        }

        case TLM_SETCOLUMNWIDTH: {
            return (LRESULT)SendMessage(
                        ptl->hwndList, LVM_SETCOLUMNWIDTH, wParam, lParam
                        );
        }
    }


    //
    // let the default processing be done
    //

    return DefWindowProc(hwnd, uiMsg, wParam, lParam);
}




//----------------------------------------------------------------------------
// Function:    TL_OnCreate
//
// This is called after WM_CREATE, and it initializes the window structure,
// as well as creating the listview which will contain the items added
//----------------------------------------------------------------------------

BOOL
TL_OnCreate(
    TL *ptl,
    CREATESTRUCT *pcs
    ) {

    RECT rc;
    HD_ITEM hdi;
    HWND hwndList;
    TLITEM *pRoot;
    DWORD dwStyle, dwExStyle;


    //
    // initialize the window structure
    //

    ptl->hbrBk = NULL;
    ptl->hbmp = NULL;
    ptl->hbmpStart = NULL;
    ptl->hbmpMem = NULL;
    ptl->hdcImages = NULL;
    ptl->hwndList = NULL;
    ptl->iCtrlId = PtrToUlong(pcs->hMenu);
    ptl->hwndParent = pcs->hwndParent;
    ptl->nColumns = 0;


    //
    // initialize the invisible root item
    //

    pRoot = &ptl->root;
    pRoot->pParent = NULL;
    pRoot->iLevel = -1;
    pRoot->iIndex = -1;
    pRoot->nChildren = 0;
    pRoot->uiFlag = TLI_EXPANDED;
    pRoot->pszText = TEXT("ROOT");
    InitializeListHead(&pRoot->lhChildren);
    InitializeListHead(&pRoot->lhSubitems);


    //
    // we pass on some of our window style bits to the listview
    // when we create it as our child; we also remove certain styles
    // which are never appropriate for the contained listview
    //

    dwStyle = pcs->style & ~(LVS_TYPESTYLEMASK | LVS_SORTASCENDING |
                             LVS_SORTDESCENDING);
    dwStyle |= WS_CHILD | LVS_REPORT | LVS_SINGLESEL | LVS_OWNERDRAWFIXED;

    dwExStyle = pcs->dwExStyle & ~(WS_EX_CLIENTEDGE | WS_EX_WINDOWEDGE |
                                   WS_EX_STATICEDGE);

    //
    // create the listview window
    //

    GetClientRect(ptl->hwnd, &rc);
    hwndList = CreateWindowEx(
                    dwExStyle, WC_LISTVIEW, NULL, dwStyle,
                    0, 0, rc.right, rc.bottom,
                    ptl->hwnd, NULL, pcs->hInstance, NULL
                    );
    if (hwndList == NULL) { return FALSE; }
//    ListView_SetBkColor(hwndList, GetSysColor(COLOR_WINDOW));

    //
    // We to set the background color to "NONE" to prevent the listview
    // from erasing its background itself. Removing the background color
    // causes the listview to forward its WM_ERASEBKGND messages to its parent,
    // which is our tree-list. We handle the WM_ERASEBKGND messages
    // efficiently by only erasing the background when absolutely necessary,
    // and this eliminates the flicker normally seen when windows are updated
    // frequently.
    //

    ListView_SetBkColor(hwndList, CLR_NONE);

    ptl->hwndList = hwndList;

    return TRUE;
}



//----------------------------------------------------------------------------
// Function:    TL_OnDestroy
//
// Delete all the items in the tree, and free the image bitmap
// used for drawing the tree structure
//----------------------------------------------------------------------------

VOID
TL_OnDestroy(
    TL *ptl
    ) {

    TL_OnDeleteAllItems(ptl);

    if (ptl->hdcImages != NULL) {

        if (ptl->hbmp) {
            SelectObject(ptl->hdcImages, ptl->hbmpStart);
            DeleteObject(ptl->hbmp);
        }

        DeleteDC(ptl->hdcImages);
    }

    if (ptl->hbmpMem) { DeleteObject(ptl->hbmpMem); }
}



//----------------------------------------------------------------------------
// Function:    TL_OnWindowPosChanged
//
// When the window width changes, we destroy our off-screen bitmap.
//----------------------------------------------------------------------------

VOID
TL_OnWindowPosChanged(
    TL *ptl,
    WINDOWPOS *pwp
    ) {

    RECT rc;

    GetClientRect(ptl->hwnd, &rc);

    SetWindowPos(
        ptl->hwndList, ptl->hwnd, 0, 0, rc.right, rc.bottom, pwp->flags
        );
}



//----------------------------------------------------------------------------
// Function:    TL_OnEraseBackground
//
// When we are asked to erase the background, first test to see if
// the update region is completely in the item-area for the listbox. If so,
// we know we'll be called to update each item, so we can ignore this
// request to erase our background.
//----------------------------------------------------------------------------

VOID
TL_OnEraseBackground(
    TL *ptl,
    HDC hdc
    ) {

    RECT rc;
    INT count;
    HBRUSH hbrOld;
    LV_HITTESTINFO lvhi;


    //
    // Retrieve the rectangle to be erased
    //

    GetClipBox(hdc, &rc);

    TRACEX4(
        TLTRACE, "WM_ERASEBKGND:  ClipBox:        (%d, %d) (%d %d)",
        rc.left, rc.top, rc.right, rc.bottom
        );


    //
    // Retrieve the count of listview items.
    // This is necessary because the smooth-scrolling code triggers
    // a repaint inside the ListView_DeleteItem() processing,
    // at which point our indices may be out of sync (i.e. we have more items
    // than the listview).
    // The count retrieved is used to do a sanity-check
    // on the treelist-item indices below.
    //

    count = ListView_GetItemCount(ptl->hwndList);
    TRACEX1(TLTRACE, "WM_ERASEBKGND:  Count:          %d", count);


    //
    // If there are no treelist items, we always have to erase.
    // If there are treelist items, we only have to erase
    // if part of the erase-region lies below our lowest item.
    //

    while (!IsListEmpty(&ptl->root.lhChildren)) { // one-time loop

        RECT rctop;
        INT iTopIndex;
        INT cyUpdate;
        TLITEM *pItem;
        LIST_ENTRY *phead;


        //
        // We need to factor in the height of the header-control, if any;
        // to this end, we get the bounding rectangle of the topmost item
        // visible in the listview, and then we use the top of that item
        // as the basis for our computations below
        //

        iTopIndex = ListView_GetTopIndex(ptl->hwndList);
        TRACEX1(TLTRACE, "WM_ERASEBKGND:  TopIndex:       %d", iTopIndex);

        ListView_GetItemRect(ptl->hwndList, iTopIndex, &rctop, LVIR_BOUNDS);
        TRACEX1(TLTRACE, "WM_ERASEBKGND:  rctop.top:      %d", rctop.top);

        rc.top = rctop.top;


        //
        // If the area to be erased extends further right in the window
        // than our items do, we'll have to erase
        //

        if (rctop.right < rc.right) {

            TRACEX2(
                TLTRACE, "WM_ERASEBKGND:  rctop.right < rc.right (%d < %d)",
                rctop.right, rc.right
                );

            break;
        }


        //
        // Get the total height of the area to be updated;
        // this excludes the area occupied by the header-control.
        //

        cyUpdate = rc.bottom - rctop.top;
        TRACEX1(TLTRACE, "WM_ERASEBKGND:  CyUpdate:       %d", cyUpdate);


        //
        // Get the lowest item; it is the one at the tail of the item-list
        //

        phead = ptl->root.lhChildren.Blink;
        
        pItem = CONTAINING_RECORD(phead, TLITEM, leSiblings);

        TRACEX1(TLTRACE, "WM_ERASEBKGND:  CyItem:         %d", ptl->cyItem);


        //
        // If the lowest item or one of its visible descendants is lower
        // than the bottom of the update region, we don't have to erase;
        // therefore, we walk down the list of the lowest item's descendants,
        // checking each time whether the descendant is lower than the region
        // we've been asked to erase.
        //

        do {

            TRACEX1(
                TLTRACE, "WM_ERASEBKGND:  pItem->iIndex:    %d", pItem->iIndex
                );
    

            //
            // force the erasure if the item's index is higher
            // than the number of listview items
            //

            if (pItem->iIndex >= count) { break; }


            //
            // defer the erasure if the item is lower than the bottom
            // of the update-rect
            //

            if ((pItem->iIndex - iTopIndex + 1) * (INT)ptl->cyItem > cyUpdate) {
                TRACEX(TLTRACE, "WM_ERASEBKGND:   DEFERRING");
                return;
            }


            //
            // move on to the item's lowest child;
            // if it has none, it means the erase-region's lowest edge
            // is lower than our lowest item, and that means
            // that we'll have to erase it now instead of just letting it
            // get updated when we handle the WM_DRAWITEM
            //

            if (IsListEmpty(&pItem->lhChildren)) { pItem = NULL; }
            else {

                phead = pItem->lhChildren.Blink;

                pItem = CONTAINING_RECORD(phead, TLITEM, leSiblings);
            }

        } while (pItem && TL_IsVisible(pItem));

        break;
    }
    


    //
    // One of the points was not on an item, so erase
    //

    TRACEX(TLTRACE, "WM_ERASEBKGND:  ERASING");

    hbrOld = SelectObject(hdc, ptl->hbrBk);
    PatBlt(
        hdc, rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top, PATCOPY
        );
    SelectObject(hdc, hbrOld);
}



//----------------------------------------------------------------------------
// Function:    TL_OnDrawItem
//
// This is called by the listview when an item needs to be drawn.
//----------------------------------------------------------------------------

BOOL
TL_OnDrawItem(
    TL *ptl,
    CONST DRAWITEMSTRUCT *pdis
    ) {


    //
    // make sure this is from our listview
    //

    if (pdis->CtlType != ODT_LISTVIEW) { return FALSE; }

    switch (pdis->itemAction) {

        //
        // currently listviews always send ODA_DRAWENTIRE,
        // but handle all cases anyway
        //

        case ODA_DRAWENTIRE:
        case ODA_FOCUS:
        case ODA_SELECT:
            return TL_DrawItem(ptl, pdis);
    }

    return TRUE;
}



//----------------------------------------------------------------------------
// Function:    TL_DrawItem
//
// This function does the actual drawing for a treelist item
//----------------------------------------------------------------------------

BOOL
TL_DrawItem(
    TL *ptl,
    CONST DRAWITEMSTRUCT *pdis
    ) {

    HDC hdcMem;
    TCHAR *psz;
    RECT rc, rcItem;
    HBITMAP hbmpOld;
    HIMAGELIST himl;
    TLSUBITEM *pSubitem;
    HFONT hfont, hfontOld;
    TLITEM *pItem, *pParent;
    LIST_ENTRY *ple, *phead;
    INT cxIndent, cxImage, cyImage, i, tx, x, y, xcol;



    //
    // the itemData contains the lParam passed in ListView_InsertItem;
    // this lParam is the TLITEM pointer for the tree-item, so we retrieve it
    // and use the information it contains to draw the item
    //

    cxIndent = ptl->cxIndent;
    pItem = (TLITEM *)pdis->itemData;
    rcItem.left = 0; rcItem.top = 0;
    rcItem.right = pdis->rcItem.right - pdis->rcItem.left;
    rcItem.bottom = pdis->rcItem.bottom - pdis->rcItem.top;



    //
    // create a compatible DC
    //

    hdcMem = CreateCompatibleDC(pdis->hDC);

    if(NULL == hdcMem)
    {
        return FALSE;
    }

    if (ptl->hbmpMem) {

        if (rcItem.right > (INT)ptl->cxBmp || rcItem.bottom > (INT)ptl->cyBmp) {
            DeleteObject(ptl->hbmpMem); ptl->hbmpMem = NULL;
        }
    }

    if (!ptl->hbmpMem) {

        ptl->hbmpMem = CreateCompatibleBitmap(
                            pdis->hDC, rcItem.right, rcItem.bottom
                            );

        ptl->cxBmp = rcItem.right;
        ptl->cyBmp = rcItem.bottom;
    }


    hbmpOld = SelectObject(hdcMem, ptl->hbmpMem);

    hfontOld = SelectObject(hdcMem, GetWindowFont(pdis->hwndItem));


    //
    // erase the background
    //

#if 0
    ptl->hbrBk = FORWARD_WM_CTLCOLOREDIT(
                    ptl->hwndParent, hdcMem, ptl->hwnd, SendMessage
                    );
#endif
    FillRect(hdcMem, &rcItem, ptl->hbrBk);


    //
    // set the text background color based on whether or not
    // the item is selected
    //

    if (pdis->itemState & ODS_SELECTED) {
        SetTextColor(hdcMem, GetSysColor(COLOR_HIGHLIGHTTEXT));
        SetBkColor(hdcMem, GetSysColor(COLOR_HIGHLIGHT));
    }
    else {
        SetTextColor(hdcMem, GetSysColor(COLOR_WINDOWTEXT));
        SetBkColor(hdcMem, GetSysColor(COLOR_WINDOW));
    }


    //
    // compute the starting position as a multiple of
    // the  item's level and the indentation per level
    //

    x = rcItem.left + pItem->iLevel * cxIndent;
    y = rcItem.top;

    xcol = rcItem.left + ListView_GetColumnWidth(pdis->hwndItem, 0);
    tx = x;
    x += cxIndent;


    //
    // now draw the item's tree image;
    // only draw as much as will fit in the first column
    //

    if (tx < xcol) {
        BitBlt(
            hdcMem, tx, y, min(cxIndent, xcol - tx), ptl->cyItem,
            ptl->hdcImages, pItem->iImage * cxIndent, 0, SRCCOPY
            );
    }


    //
    // draw the lines going down from the item's ancestors
    // to the item's ancestors' corresponding siblings;
    // in other words, for each ancestor which is not its parent's last child,
    // there should be a line going down from that ancestor to its next sibling
    // and the line will pass through the rows for all of that item's expanded
    // descendants.
    // note that we do not draw lines at the root-level
    //

    pParent = pItem->pParent;
    for (i = pItem->iLevel - 1, tx -= cxIndent; i > 0; i--, tx -= cxIndent) {

        if (tx < xcol &&
            pParent->leSiblings.Flink != &pParent->pParent->lhChildren) {
            BitBlt(
                hdcMem, tx, y, min(cxIndent, xcol - tx), ptl->cyItem,
                ptl->hdcImages, TL_VerticalLine * cxIndent, 0, SRCCOPY
                );
        }

        pParent = pParent->pParent;
    }


    //
    // draw the state image, if there is one,
    // and increment the left position by the width of the image
    //

    himl = ListView_GetImageList(pdis->hwndItem, LVSIL_STATE);

    if (himl != NULL && TL_StateImageValue(pItem)) {
        ImageList_GetIconSize(himl, &cxImage, &cyImage);
        ImageList_Draw(
            himl, TL_StateImageIndex(pItem), hdcMem,
            x, y + (ptl->cyItem - cyImage), ILD_NORMAL
            );

        x += cxImage;
    }


    //
    // draw the image, if there is an image list,
    // and increment the left position by the width of the image
    //

    himl = ListView_GetImageList(pdis->hwndItem, LVSIL_SMALL);
    if (himl != NULL && (pItem->lvi.mask & LVIF_IMAGE)) {
        ImageList_GetIconSize(himl, &cxImage, &cyImage);
        ImageList_Draw(
            himl, pItem->lvi.iImage, hdcMem,
            x, y + (ptl->cyItem - cyImage) / 2, ILD_NORMAL
            );

        x += cxImage;
    }


    //
    // compute the rectangle in the first column
    // which will be the clipping boundary for text
    //

    rc.left = x;
    rc.right = xcol;
    rc.top = rcItem.top;
    rc.bottom = rcItem.bottom;


    //
    // draw the first column's text
    //

    if (pItem->lvi.mask & LVIF_TEXT) {

        //
        // center the text vertically in the item-rectangle
        //

        psz = Ellipsisize(hdcMem, pItem->pszText, rc.right - rc.left, 0);
        ExtTextOut(
            hdcMem, rc.left + 2, rc.top + (ptl->cyItem - ptl->cyText) / 2,
            ETO_CLIPPED | ETO_OPAQUE, &rc, psz ? psz : pItem->pszText,
            lstrlen(psz ? psz : pItem->pszText), NULL
            );
        Free0(psz);
    }



    //
    // draw the subitems' texts
    //

    i = 1;
    phead = &pItem->lhSubitems;
    for (ple = phead->Flink; ple != phead; ple = ple->Flink) {

        pSubitem = (TLSUBITEM *)CONTAINING_RECORD(ple, TLSUBITEM, leItems);


        //
        // we need to draw blank texts for subitems which have not been set;
        // this enables us to save memory on items which don't have
        // certain subitems set
        //

        for ( ; i < pSubitem->iSubItem; i++) {
            rc.left = rc.right;
            rc.right = rc.left + ListView_GetColumnWidth(pdis->hwndItem, i);
    
            ExtTextOut(
                hdcMem, rc.left + 2, rc.top + (ptl->cyItem - ptl->cyText) / 2,
                ETO_CLIPPED | ETO_OPAQUE, &rc, TEXT(""), 0, NULL
                );
        }


        //
        // now draw the text for the current item
        //

        rc.left = rc.right;
        rc.right = rc.left + ListView_GetColumnWidth(
                                pdis->hwndItem, pSubitem->iSubItem
                                );

        psz = Ellipsisize(hdcMem, pSubitem->pszText, rc.right - rc.left, 0);
        ExtTextOut(
            hdcMem, rc.left + 2, rc.top + (ptl->cyItem - ptl->cyText) / 2,
            ETO_CLIPPED | ETO_OPAQUE, &rc, psz ? psz : pSubitem->pszText,
            lstrlen(psz ? psz : pSubitem->pszText), NULL
            );
        Free0(psz);

        ++i;
    }


    //
    // we need to draw blank texts for subitems which have not been set
    //

    for ( ; i < (INT)ptl->nColumns; i++) {
        rc.left = rc.right;
        rc.right = rc.left + ListView_GetColumnWidth(pdis->hwndItem, i);

        ExtTextOut(
            hdcMem, rc.left + 2, rc.top + (ptl->cyItem - ptl->cyText) / 2,
            ETO_CLIPPED | ETO_OPAQUE, &rc, TEXT(""), 0, NULL
            );
    }


    //
    // restore the original background and text color
    //

#if 0
    if (pdis->itemState & ODS_SELECTED) {
        SetTextColor(pdis->hDC, GetSysColor(COLOR_WINDOWTEXT));
        SetBkColor(pdis->hDC, GetSysColor(COLOR_WINDOW));
    }
#endif


    //
    // draw the focus rectangle if necessary
    //

    if (pdis->itemState & ODS_FOCUS) {
        rc = rcItem;
        rc.left = min(x, xcol);
        DrawFocusRect(hdcMem, &rc);
    }


    //
    // Blt the changes to the screen DC
    //

    BitBlt(
        pdis->hDC, pdis->rcItem.left, pdis->rcItem.top, rcItem.right,
        rcItem.bottom, hdcMem, rcItem.left, rcItem.top, SRCCOPY
        );

    SelectObject(hdcMem, hbmpOld);
    SelectObject(hdcMem, hfontOld);

    DeleteDC(hdcMem);

    return TRUE;
}



//----------------------------------------------------------------------------
// Function:    TL_OnMeasureItem
//
// This is called by the listview when it needs to know
// the height of each item; we use this opportunity to rebuild
// the bitmap which holds images used for drawing tree lines.
//
// TODO: the listview currently seems to ignore the value we set,
// and instead uses the height of a small icon (SM_CYSMICON).
//----------------------------------------------------------------------------

VOID
TL_OnMeasureItem(
    TL *ptl,
    MEASUREITEMSTRUCT *pmis
    ) {

    HDC hdc;
    INT cyIcon;
    HFONT hfont;
    TEXTMETRIC tm;
    HWND hwndList;

    if (pmis->CtlType != ODT_LISTVIEW) { return; }

    //
    // retrieve the  listview, its font, and its device context
    //

    hwndList = GetDlgItem(ptl->hwnd, pmis->CtlID);

    hfont = GetWindowFont(hwndList);

    hdc = GetDC(hwndList);

    if(NULL == hdc)
    {
        return;
    }

    SelectObject(hdc, hfont);


    //
    // get the height of the listview's font
    //

    if (!GetTextMetrics(hdc, &tm)) 
    { 
        ReleaseDC(hwndList, hdc);
        return; 
    }

    ptl->cyText = tm.tmHeight;
    pmis->itemHeight = ptl->cyText;


    //
    // make sure the item height is at least as high as a small icon
    //

    cyIcon = GetSystemMetrics(SM_CYSMICON);
    if (pmis->itemHeight < (UINT)cyIcon) {
        pmis->itemHeight = cyIcon;
    }

    pmis->itemHeight += GetSystemMetrics(SM_CYBORDER);
#if 0
    pmis->itemHeight = (pmis->itemHeight + 1) & ~1;
#endif
    ptl->cyItem = pmis->itemHeight;
    ptl->cxIndent = GetSystemMetrics(SM_CXSMICON);

    ReleaseDC(hwndList, hdc);


    //
    // rebuild the images used in drawing tree lines
    //

    TL_CreateTreeImages(ptl);
}



//----------------------------------------------------------------------------
// Function:    TL_CreateColorBitmap
// 
// Utility function fro creating a color bitmap
//----------------------------------------------------------------------------

HBITMAP
TL_CreateColorBitmap(
    INT cx,
    INT cy
    ) {

    HDC hdc;
    HBITMAP hbmp;

    hdc = GetDC(NULL);

    if(NULL == hdc)
    {
        return NULL;
    }
    
    hbmp = CreateCompatibleBitmap(hdc, cx, cy);
    ReleaseDC(NULL, hdc);

    return hbmp;
}



//----------------------------------------------------------------------------
// Function:    TL_CreateTreeImages
//
// This function builds a list of images which are scaled to
// the height of each item in the tree. The appearance of the images
// is shown in ASCII text in the code below
//----------------------------------------------------------------------------

VOID
TL_CreateTreeImages(
    TL *ptl
    ) {

    HDC hdc;
    RECT rc;
    HBITMAP hbmpOld;
    INT cxIndent, x, c, xmid, ymid;
    HBRUSH hbrOld, hbrGrayText, hbrWinText;


    //
    // invalidate the listview's client area, to force a redraw
    //

    if (ptl->hwndList != NULL) { InvalidateRect(ptl->hwndList, NULL, TRUE); }


    //
    // create a device context if necessary
    //

    if (ptl->hdcImages == NULL) {
        ptl->hdcImages = CreateCompatibleDC(NULL);

        if(NULL == ptl->hdcImages)
        {
            return;
        }
    }


    hdc = ptl->hdcImages;
    cxIndent = ptl->cxIndent;

    ptl->hbrBk = FORWARD_WM_CTLCOLOREDIT(
                    ptl->hwndParent, hdc, ptl->hwnd, SendMessage
                    );

    //
    // create the bitmap to be used
    //

    hbmpOld = ptl->hbmp;
    ptl->hbmp = TL_CreateColorBitmap(TL_ImageCount * cxIndent, ptl->cyItem);
    if (hbmpOld == NULL) {
        ptl->hbmpStart = SelectObject(hdc, ptl->hbmp);
    }
    else {
        SelectObject(hdc, ptl->hbmp);
        DeleteObject(hbmpOld);
    }


    //
    // retreive system color brushes for drawing the tree images
    //

    hbrWinText = GetSysColorBrush(COLOR_WINDOWTEXT);
    hbrGrayText = GetSysColorBrush(COLOR_GRAYTEXT);

    hbrOld = SelectObject(hdc, hbrGrayText);

    rc.top = 0; rc.bottom = ptl->cyItem;
    rc.left = 0; rc.right = TL_ImageCount * cxIndent;


    //
    // fill the image with the background color
    //

    FillRect(hdc, &rc, ptl->hbrBk);

    xmid = cxIndent / 2;
    ymid = ((ptl->cyItem / 2) + 1) & ~1;

    c = min(xmid, ymid) / 2;


    //   |
    //   |

    x = TL_VerticalLine * cxIndent;
    TL_DottedLine(hdc, x + xmid, 0, ptl->cyItem, TRUE);


    //
    //   ---
    //

    x = TL_RootChildless * cxIndent;
    TL_DottedLine(hdc, x + xmid, ymid, cxIndent - xmid, FALSE);


    //
    //  +-+
    //  |+|--
    //  +-+
    //

    x = TL_RootParentCollapsed * cxIndent;
    TL_DottedLine(hdc, x + xmid, ymid, cxIndent - xmid, FALSE);
    TL_DrawButton(
        hdc, x + xmid, ymid, c, hbrWinText, hbrGrayText, ptl->hbrBk, TRUE
        );


    //
    //  +-+
    //  |-|--
    //  +-+
    //

    x = TL_RootParentExpanded * cxIndent;
    SelectObject(hdc, hbrGrayText);
    TL_DottedLine(hdc, x + xmid, ymid, cxIndent - xmid, FALSE);
    TL_DrawButton(
        hdc, x + xmid, ymid, c, hbrWinText, hbrGrayText, ptl->hbrBk, FALSE
        );


    //
    //   |
    //   +--
    //   |
    //

    x = TL_MidChildless * cxIndent;
    SelectObject(hdc, hbrGrayText);
    TL_DottedLine(hdc, x + xmid, 0, ptl->cyItem, TRUE);
    TL_DottedLine(hdc, x + xmid, ymid, cxIndent - xmid, FALSE);


    //
    //   |
    //  +-+
    //  |+|--
    //  +-+
    //   |
    //

    x = TL_MidParentCollapsed * cxIndent;
    TL_DottedLine(hdc, x + xmid, 0, ptl->cyItem, TRUE);
    TL_DottedLine(hdc, x + xmid, ymid, cxIndent - xmid, FALSE);
    TL_DrawButton(
        hdc, x + xmid, ymid, c, hbrWinText, hbrGrayText, ptl->hbrBk, TRUE
        );


    //
    //   |
    //  +-+
    //  |-|--
    //  +-+
    //   |
    //

    x = TL_MidParentExpanded * cxIndent;
    SelectObject(hdc, hbrGrayText);
    TL_DottedLine(hdc, x + xmid, 0, ptl->cyItem, TRUE);
    TL_DottedLine(hdc, x + xmid, ymid, cxIndent - xmid, FALSE);
    TL_DrawButton(
        hdc, x + xmid, ymid, c, hbrWinText, hbrGrayText, ptl->hbrBk, FALSE
        );


    //
    //   |
    //   +--
    //    

    x = TL_EndChildless * cxIndent;
    SelectObject(hdc, hbrGrayText);
    TL_DottedLine(hdc, x + xmid, 0, ymid, TRUE);
    TL_DottedLine(hdc, x + xmid, ymid, cxIndent - xmid, FALSE);


    //
    //   |
    //  +-+
    //  |+|--
    //  +-+
    //

    x = TL_EndParentCollapsed * cxIndent;
    TL_DottedLine(hdc, x + xmid, 0, ymid, TRUE);
    TL_DottedLine(hdc, x + xmid, ymid, cxIndent - xmid, FALSE);
    TL_DrawButton(
        hdc, x + xmid, ymid, c, hbrWinText, hbrGrayText, ptl->hbrBk, TRUE
        );


    //
    //   |
    //  +-+
    //  |-|--
    //  +-+
    //

    x = TL_EndParentExpanded * cxIndent;
    SelectObject(hdc, hbrGrayText);
    TL_DottedLine(hdc, x + xmid, 0, ymid, TRUE);
    TL_DottedLine(hdc, x + xmid, ymid, cxIndent - xmid, FALSE);
    TL_DrawButton(
        hdc, x + xmid, ymid, c, hbrWinText, hbrGrayText, ptl->hbrBk, FALSE
        );

    if (hbrOld != NULL) {
        SelectObject(hdc, hbrOld);
    }

    DeleteObject(hbrGrayText);
    DeleteObject(hbrWinText);

}



//----------------------------------------------------------------------------
// Function:    TL_DottedLine
//
// Draws a dotted line eiter vertically or horizontally,
// with the specified dimension as its length.
//----------------------------------------------------------------------------

VOID
TL_DottedLine(
    HDC hdc,
    INT x,
    INT y,
    INT dim,
    BOOL fVertical
    ) {

    for ( ; dim > 0; dim -= 2) {

        PatBlt(hdc, x, y, 1, 1, PATCOPY);

        if (fVertical) {
            y += 2;
        }
        else {
            x += 2;
        }
    }
}



//----------------------------------------------------------------------------
// Function:    TL_DrawButton
//
// Draws a button with a plus or a minus, centered at the given location
//----------------------------------------------------------------------------

VOID
TL_DrawButton(
    HDC hdc,
    INT x,
    INT y,
    INT dim,
    HBRUSH hbrSign,
    HBRUSH hbrBox,
    HBRUSH hbrBk,
    BOOL bCollapsed
    ) {

    int n;
    int p = (dim * 7) / 10;

    n = p * 2 + 1;

    //
    // first fill with the background color
    //

    SelectObject(hdc, hbrBk);
    PatBlt(hdc, x - dim, y - dim, dim * 2, dim * 2, PATCOPY);


    //
    // draw the sign
    //

    SelectObject(hdc, hbrSign);

    if (p >= 5) {

        PatBlt(hdc, x - p, y - 1, n, 3, PATCOPY);

        if (bCollapsed) {
            PatBlt(hdc, x - 1, y - p, 3, n, PATCOPY);
        }

        SelectObject(hdc, hbrBk);
        p--;
        n -= 2;
    }

    PatBlt(hdc, x - p, y, n, 1, PATCOPY);
    if (bCollapsed) {
        PatBlt(hdc, x, y - p, 1, n, PATCOPY);
    }

    n = dim * 2 + 1;


    //
    // draw the box around the sign
    // 

    SelectObject(hdc, hbrBox);

    PatBlt(hdc, x - dim, y - dim, n, 1, PATCOPY);
    PatBlt(hdc, x - dim, y - dim, 1, n, PATCOPY);
    PatBlt(hdc, x - dim, y + dim, n, 1, PATCOPY);
    PatBlt(hdc, x + dim, y - dim, 1, n, PATCOPY);
}



//----------------------------------------------------------------------------
// Function:    TL_UpdateListIndices
//
// This function updates the indices for all items in the tree
// which are visually below the specified item pStart, assuming that
// the list index for pStart is correct. Consider the case
// in the diagram below:
//
//      -- child 1
//      |   |- child 1,1
//      |   -- child 1,2
//      |- child 2
//      -- child 3
//      |   |- child 3,1
//      |   |   |- child 3,1,1
//      |   |   -- child 3,1,2
//      |   |- child 3,2
//      |   -- child 3,3
//      -- child 4
//
// Suppose that pStart points to "child 3,1". To set the indices,
// we first update the indices for all descendants of pStart,
// and then we update the indices for the siblings of pStart's ancestors
// which are after pStart's ancestors in the tree.
//----------------------------------------------------------------------------

VOID
TL_UpdateListIndices(
    TL *ptl,
    TLITEM *pStart
    ) {

    INT iIndex;

    iIndex = pStart->iIndex;

    if (pStart->nChildren > 0) {

        //
        // if the item is visible, set its index;
        // otherwise pass in NULL to set its index
        // and that of its descendants to -1
        //

        if (TL_IsExpanded(pStart) &&
            (pStart == &ptl->root || TL_IsVisible(pStart))) {
            TL_UpdateDescendantIndices(ptl, pStart, &iIndex);
        }
        else {
            TL_UpdateDescendantIndices(ptl, pStart, NULL);
        }
    }


    if (pStart->pParent != NULL) {
        TL_UpdateAncestorIndices(ptl, pStart, &iIndex);
    }

    ptl->root.iIndex = -1;
}



//----------------------------------------------------------------------------
// Function:    TL_UpdateDescendantIndices
//
// This function updates the indices of the descendants
// of the item specified. An item is not considered to be
// a descendant of itself.
//----------------------------------------------------------------------------

VOID
TL_UpdateDescendantIndices(
    TL *ptl,
    TLITEM *pStart,
    INT *piIndex
    ) {

    //
    // go through list of children setting indices
    //

    TLITEM *pItem;
    LIST_ENTRY *ple;

    for (ple = pStart->lhChildren.Flink;
         ple != &pStart->lhChildren; ple = ple->Flink) {

        pItem = (TLITEM *)CONTAINING_RECORD(ple, TLITEM, leSiblings);


        //
        // set the index of the child
        //

        pItem->iIndex = (piIndex ? ++(*piIndex) : -1);
   

        //
        // set the indices of the child's descendants
        //

        if (pItem->nChildren > 0) {

            //
            // if the item is visible, set its index;
            // otherwise pass in NULL to set its index
            // and that of its descendants to -1
            //

            if (TL_IsExpanded(pItem) && TL_IsVisible(pItem)) {
                TL_UpdateDescendantIndices(ptl, pItem, piIndex);
            }
            else {
                TL_UpdateDescendantIndices(ptl, pItem, NULL);
            }
        }
    }
}



//----------------------------------------------------------------------------
// Function:    TL_UpdateAncestorIndices
//
// This function updates the indices of the items which are
// visually below the specified item in the listview.
//----------------------------------------------------------------------------

VOID
TL_UpdateAncestorIndices(
    TL *ptl,
    TLITEM *pStart,
    INT *piIndex
    ) {

    TLITEM *pItem;
    LIST_ENTRY *ple;


    //
    // first set inidices for the siblings beneath this item;
    // note that we begin walking the siblings AFTER the item passed in,
    //

    for (ple = pStart->leSiblings.Flink;
         ple != &pStart->pParent->lhChildren;
         ple = ple->Flink) {

        pItem = (TLITEM *)CONTAINING_RECORD(ple, TLITEM, leSiblings);


        //
        // set the index for the sibling
        //

        pItem->iIndex = (piIndex ? ++(*piIndex) : -1);

        if (pItem->nChildren > 0) {

            //
            // if the item is visible, set its index;
            // otherwise pass in NULL to set its index
            // and that of its descendants to -1
            //

            if (TL_IsExpanded(pItem) && TL_IsVisible(pItem)) {
                TL_UpdateDescendantIndices(ptl, pItem, piIndex);
            }
            else {
                TL_UpdateDescendantIndices(ptl, pItem, NULL);
            }
        }
    }


    //
    // now set indices for the parent siblings which are beneath the parent
    //
    // TODO - OPTIMIZATION: this is post-recursion and therefore, it can 
    // be replaced by a loop, which at the very least would save stack 
    // space
    //

    if (pStart->pParent->pParent != NULL) {
        TL_UpdateAncestorIndices(ptl, pStart->pParent, piIndex);
    }
}



//----------------------------------------------------------------------------
// Function:    TL_NotifyParent
//
// Forwards a notification to the treelist's parent
//----------------------------------------------------------------------------

BOOL
TL_NotifyParent(
    TL *ptl,
    NMHDR *pnmh
    ) {

    return (BOOL)SendMessage(
                ptl->hwndParent, WM_NOTIFY, (WPARAM)ptl->hwnd, (LPARAM)pnmh
                );
}



//----------------------------------------------------------------------------
// Function:    TL_OnNotify
//
// Handles notifications from the listview window and its header control
//----------------------------------------------------------------------------

LRESULT
TL_OnNotify(
    TL *ptl,
    INT iCtrlId,
    NMHDR *pnmh
    ) {

    NMHDR nmh;
    TLITEM *pItem;


    //
    // notify parent of the message
    //

    if (TL_NotifyParent(ptl, pnmh)) { return FALSE; }



    switch (pnmh->code) {

        case HDN_ENDTRACK: {

            //
            // we need to redraw ourselves, AFTER the header resets;
            // hence the use of PostMessage instead of SendMessage
            //

            PostMessage(ptl->hwnd, TLM_REDRAW, (WPARAM)0, (LPARAM)0);
            return FALSE;
        }

        case NM_CLICK:
        case NM_DBLCLK: {

            //
            // do a hit-test;
            //

            POINT pt;
            INT iLeft; 
            LV_ITEM lvi;
            LV_HITTESTINFO lvhi;

            if (!GetCursorPos(&lvhi.pt)) { return FALSE; }
            ScreenToClient(ptl->hwndList, &lvhi.pt);

            if (ListView_HitTest(ptl->hwndList, &lvhi) == -1) { return FALSE; }

            if (!(lvhi.flags & LVHT_ONITEM)) { return FALSE; }


            //
            // see which part of the item was clicked
            //

            if (!ListView_GetItemPosition(ptl->hwndList, lvhi.iItem, &pt)) {
                return FALSE;
            }


            //
            // retrieve the item clicked
            //

            lvi.iItem = lvhi.iItem;
            lvi.iSubItem = 0;
            lvi.mask = LVIF_PARAM;
            if (!ListView_GetItem(ptl->hwndList, &lvi)) { return FALSE; }

            pItem = (TLITEM *)lvi.lParam;


            //
            // compute the position of the item's tree image
            //

            iLeft = pItem->iLevel * ptl->cxIndent;


            if (lvhi.pt.x > (pt.x + iLeft)) {

                //
                // the hit was to the right of the item's tree image
                //

                if (lvhi.pt.x < (pt.x + iLeft + (INT)ptl->cxIndent)) {

                    //
                    // the hit was on the item's tree image
                    //

                    if (pItem->nChildren > 0) {

                        //
                        // the +/- button was clicked, toggle expansion
                        //

                        return TL_OnExpand(ptl, TLE_TOGGLE, (HTLITEM)pItem);
                    }
                }
                else {
    
                    //
                    // the hit was on the item's state icon, image, or text
                    //


                    //
                    // see if the parent wants to handle it
                    //

                    nmh.code = pnmh->code;
                    nmh.idFrom = 0;
                    nmh.hwndFrom = ptl->hwnd;

                    TL_NotifyParent(ptl, &nmh);
                    if (nmh.idFrom != 0) { return TRUE; }


                    if (pnmh->code == NM_DBLCLK && pItem->nChildren > 0) {

                        //
                        // the item was double-clicked, toggle expansion
                        //

                        return TL_OnExpand(
                                    ptl, TLE_TOGGLE, (HTLITEM)pItem
                                    );
                    }
                }
            }
    
            return FALSE;
        }

        case NM_RETURN: {

            //
            // get current selection;
            // if a parent item, toggle expand-state
            //

            LV_ITEM lvi;

            lvi.iItem = ListView_GetNextItem(ptl->hwndList, -1, LVNI_SELECTED);
            if (lvi.iItem == -1) { return FALSE; }

            lvi.iSubItem = 0;
            lvi.mask = LVIF_PARAM;
            if (!ListView_GetItem(ptl->hwndList, &lvi)) { return FALSE; }

            pItem = (TLITEM *)lvi.lParam;

            if (pItem->nChildren > 0) {

                //
                // the item has children, toggle expand state
                //

                return TL_OnExpand(ptl, TLE_TOGGLE, (HTLITEM)pItem);
            }

            return FALSE;
        }

        case LVN_KEYDOWN: {

            //
            // get key pressed and current selection;
            // if a parent item and key is '+', expand;
            // if key is '-' or left key, collapse
            // if key is VK_RIGHT, expand and move to first child;
            // if key is VK_LEFT, collapse parent and move to parent
            //

            LV_ITEM lvi;
            LV_KEYDOWN *plvk;

            plvk = (LV_KEYDOWN *)pnmh;

            switch (plvk->wVKey) {

                case VK_RIGHT:
                case VK_ADD: {
    
                    //
                    // retrieve the item
                    //

                    lvi.iItem = ListView_GetNextItem(
                                    ptl->hwndList, -1, LVNI_SELECTED
                                    );
                    if (lvi.iItem == -1) { return FALSE; }
        
                    lvi.iSubItem = 0;
                    lvi.mask = LVIF_PARAM;
                    if (!ListView_GetItem(ptl->hwndList, &lvi)) {
                        return FALSE;
                    }
        

                    //
                    // expand the item if it is collapsed
                    //

                    pItem = (TLITEM *)lvi.lParam;

                    if (pItem->nChildren <= 0) { return FALSE; }

                    if (!TL_IsExpanded(pItem)) {
                        return TL_OnExpand(ptl, TLE_EXPAND, (HTLITEM)pItem);
                    }
                    else
                    if (plvk->wVKey == VK_RIGHT) {

                        //
                        // the key was VK_RIGHT,
                        // so we select the item's child
                        //

                        pItem = (TLITEM *)CONTAINING_RECORD(  
                                    pItem->lhChildren.Flink, TLITEM, leSiblings
                                    );

                        if (TL_OnSetSelection(ptl, (HTLITEM)pItem)) {
                            return ListView_EnsureVisible(
                                        ptl->hwndList, pItem->iIndex, FALSE
                                        );
                        }
                    }

                    break;
                }

                case VK_LEFT:
                case VK_SUBTRACT: {
    
                    //
                    // retrieve the current selection
                    //

                    lvi.iItem = ListView_GetNextItem(
                                    ptl->hwndList, -1, LVNI_SELECTED
                                    );
                    if (lvi.iItem == -1) { return FALSE; }
        
                    lvi.iSubItem = 0;
                    lvi.mask = LVIF_PARAM;
                    if (!ListView_GetItem(ptl->hwndList, &lvi)) {
                        return FALSE;
                    }
        

                    //
                    // collapse the item if it is expanded;
                    // otherwise, if the key is VK_LEFT,
                    // select the item's parent
                    //

                    pItem = (TLITEM *)lvi.lParam;

                    if (pItem->nChildren > 0) {
                        return TL_OnExpand(ptl, TLE_COLLAPSE, (HTLITEM)pItem);
                    }
                    else
                    if (plvk->wVKey == VK_LEFT &&
                        pItem->pParent != &ptl->root) {

                        if (TL_OnSetSelection(ptl, (HTLITEM)pItem->pParent)) {
                            return ListView_EnsureVisible(
                                        ptl->hwndList, pItem->pParent->iIndex,
                                        FALSE
                                        );
                        }
                    }

                    break;
                }
            }

            return FALSE;
        }

        case LVN_ITEMCHANGED: {

            NMTREELIST nmtl;
            NM_LISTVIEW *pnmlv;

            pnmlv = (NM_LISTVIEW *)pnmh;

            if ((pnmlv->uChanged & LVIF_STATE)) {
    
                if (pnmlv->uNewState & LVIS_SELECTED) {

                    //
                    // the new state is selected;
                    // notify the parent that the selection has changed
                    //
        
                    nmtl.hdr.hwndFrom = ptl->hwnd;
                    nmtl.hdr.code = TLN_SELCHANGED;
                    nmtl.hItem = (HTLITEM)pnmlv->lParam;
                    nmtl.lParam = ((TLITEM *)nmtl.hItem)->lParam;
    
                    return TL_NotifyParent(ptl, (NMHDR *)&nmtl);
                }
            }

            return FALSE;
        }

        case LVN_DELETEITEM: {

            INT iItem;
            LV_ITEM lvi;
            TLITEM *pNext;
            NM_LISTVIEW *pnmlv;

            //
            // get the item which is selected
            //

            pnmlv = (NM_LISTVIEW *)pnmh;

            iItem = ListView_GetNextItem(ptl->hwndList, -1, LVNI_SELECTED);

            if (iItem != -1) { return FALSE; }


            //
            // the deleted item was selected,
            // so select another item
            //

            lvi.mask = LVIF_PARAM;
            lvi.iItem = pnmlv->iItem;
            lvi.iSubItem = 0;
            if (!ListView_GetItem(ptl->hwndList, &lvi)) { return FALSE; }


            pItem = (TLITEM *)lvi.lParam;


            //
            // choose sibling item before this one
            //

            pNext = (TLITEM *)TL_OnGetNextItem(
                        ptl, TLGN_PREVSIBLING, (HTLITEM)pItem
                        );

            if (pNext == NULL) {

                //
                // that failed, so choose the sibling after this one
                //

                pNext = (TLITEM *)TL_OnGetNextItem(
                            ptl, TLGN_NEXTSIBLING, (HTLITEM)pItem
                            );

                if (pNext == NULL) {

                    //
                    // that failed too, so choose the parent
                    // so long as the parent isn't the root
                    //

                    pNext = pItem->pParent;
                    if (pNext == &ptl->root) { return FALSE; }
                }
            }


            return TL_OnSetSelection(ptl, (HTLITEM)pNext);
        }
    }

    return FALSE;
}



//----------------------------------------------------------------------------
// Function:    TL_UpdateImage
//
// This function updates the tree image for an item 
// when the item's state changes; this is called when an item
// is inserted or deleted, or expanded or collapsed.
// Insertion or deletions can have side-effects, as follows:
//
// (1) an item is inserted as the child of a previously childless item;
//      the parent's image changes to show a collapsed button
//          
// (2) an item is inserted as the last child of a parent which
//      had children; the image of the item which used to be
//      the parent's last child changes:
//          parent              parent
//             -- old     --->      |- old
//                                  -- new
//
// (3) the reverse of case 1, i.e. an item is removed which was
//      the only child of a parent item; the parent's image changes
//      to show that it is childless
//
// (4) the reverse of case 2, i.e. an item is removed which was
//      the last child of a parent which has other children;
//      the image of the item which will now be the last child changes
//
// In all of these cases, the item to which the side-effect occurs
// is written into ppChanged; so the caller can update the image
// for that item as well
//----------------------------------------------------------------------------

VOID
TL_UpdateImage(
    TL *ptl,
    TLITEM *pItem,
    TLITEM **ppChanged
    ) {

    INT iImage;
    TLITEM *pChanged;

    if (ppChanged == NULL) { ppChanged = &pChanged; }

    *ppChanged = NULL;


    //
    // special case for root-level items
    //

    if (pItem->pParent == &ptl->root) {

        if (pItem->nChildren == 0) {
            pItem->iImage = TL_RootChildless;
        }
        else {
            pItem->iImage = TL_IsExpanded(pItem) ? TL_RootParentExpanded
                                                 : TL_RootParentCollapsed;
        }
    }
    else
    if (pItem->leSiblings.Flink == &pItem->pParent->lhChildren) {

        //
        // item is last of its parent's children
        //

        if (pItem->nChildren == 0) {
            pItem->iImage = TL_EndChildless;
        }
        else {
            pItem->iImage = TL_IsExpanded(pItem) ? TL_EndParentExpanded
                                                 : TL_EndParentCollapsed;
        }

        //
        // if this is the only child, the parent was childless and
        // its image should change; otherwise, the child before this one
        // used to be the last child and its image should change
        //

        if (pItem->leSiblings.Blink == &pItem->pParent->lhChildren) {
            *ppChanged = pItem->pParent;
        }
        else {
            *ppChanged = (TLITEM *)CONTAINING_RECORD(
                            pItem->leSiblings.Blink, TLITEM, leSiblings
                            );
        }
    }
    else {

        //
        // item is not last of its parent's children
        //

        if (pItem->nChildren == 0) {
            pItem->iImage = TL_MidChildless;
        }
        else {
            pItem->iImage = TL_IsExpanded(pItem) ? TL_MidParentExpanded
                                                 : TL_MidParentCollapsed;
        }
    }
    
    return;
}



//----------------------------------------------------------------------------
// Function:    TL_OnInsertItem
//
// Inserts an item with the properties specified in the given LV_ITEM,
// and returns a handle to the item inserted
//----------------------------------------------------------------------------

HTLITEM
TL_OnInsertItem(
    TL *ptl,
    TL_INSERTSTRUCT *ptlis
    ) {

    LV_ITEM *plvi;
    LIST_ENTRY *ple, *phead;
    BOOL bParentVisible;
    TLITEM *pItem, *pChanged, *pTemp;

    if (ptlis == NULL) { return NULL; }


    //
    // set up the new item
    //

    pItem = (TLITEM *)Malloc(sizeof(TLITEM));
    if (pItem == NULL) { return NULL; }

    ZeroMemory(pItem, sizeof(TLITEM));

    if (ptlis->plvi->mask & LVIF_TEXT) {
        pItem->pszText = StrDup(ptlis->plvi->pszText);
        if (pItem->pszText == NULL) {
            Free(pItem); return NULL;
        }
    }


    //
    // set up the private members
    //

    pItem->uiFlag = 0;
    pItem->nChildren = 0;
    InitializeListHead(&pItem->lhSubitems);
    InitializeListHead(&pItem->lhChildren);
    pItem->pParent = (TLITEM *)ptlis->hParent;
    if (pItem->pParent == NULL) {
        pItem->pParent = &ptl->root;
    }
    ++pItem->pParent->nChildren;
    pItem->iLevel = pItem->pParent->iLevel + 1;


    //
    // set up the listview item
    //

    plvi = ptlis->plvi;
    pItem->lvi = *plvi;

    pItem->lParam = plvi->lParam;
    pItem->lvi.lParam = (LPARAM)pItem;
    pItem->lvi.pszText = pItem->pszText;
    pItem->lvi.mask |= LVIF_PARAM;


    //
    // insert this item amongst its siblings
    //

    // switch (PtrToUlong(ptlis->hInsertAfter)) {

    if(ptlis->hInsertAfter == TLI_FIRST)
    {

        InsertHeadList(&pItem->pParent->lhChildren, &pItem->leSiblings);
    }
    else if (ptlis->hInsertAfter == TLI_LAST)
    {

        InsertTailList(&pItem->pParent->lhChildren, &pItem->leSiblings);
    }
    else if (ptlis->hInsertAfter == TLI_SORT)
    {

        phead = &pItem->pParent->lhChildren;

        for (ple = phead->Flink; ple != phead; ple = ple->Flink) {
            pTemp = (TLITEM *)CONTAINING_RECORD(ple, TLITEM, leSiblings);
            if (lstrcmp(pItem->pszText, pTemp->pszText) < 0) {
                break;
            }
        }

        InsertTailList(ple, &pItem->leSiblings);

    }
    else
    {

        TLITEM *pPrev;

        pPrev = (TLITEM *)ptlis->hInsertAfter;

        InsertHeadList(&pPrev->leSiblings, &pItem->leSiblings);
    }
    //}



    //
    // set the item's image. if this was inserted
    // as the last child, we need to change the image
    // for the original last child, if any; otherwise,
    // if this is the first child of its parent, the image
    // for the parent must be changed
    //

    TL_UpdateImage(ptl, pItem, &pChanged);
    if (pChanged != NULL) { TL_UpdateImage(ptl, pChanged, NULL); }


    if (pItem->pParent != &ptl->root && !TL_IsVisible(pItem->pParent)) {
        pItem->iIndex = -1;
    }
    else {

        //
        // the item's parent is visible;
        // update the indices after the item's parent
        //

        TL_UpdateListIndices(ptl, pItem->pParent);


        //
        // insert the item in the list if its parent is expanded
        //

        if (TL_IsExpanded(pItem->pParent)) {

            INT iItem, iCol;

            //
            // In owner-draw mode, there is a bug in the listview code
            // where if an item has the focus but is not selected,
            // and then a new item is inserted above it and selected,
            // the focus rectangle remains on the item which had the focus
            //
            // To work around this, clear the focus if it is on the item
            // below the item just inserted
            //

            iItem = ListView_GetNextItem(ptl->hwndList, -1, LVNI_FOCUSED);


            pItem->lvi.iItem = pItem->iIndex;
            pItem->lvi.iSubItem = 0;
            ListView_InsertItem(ptl->hwndList, &pItem->lvi);


            //
            // if the item below this had the focus, clear the focus
            //

            if (iItem != -1 && iItem >= pItem->iIndex) {

                ListView_SetItemState(
                    ptl->hwndList, -1, 0, LVNI_FOCUSED
                    );
            }


            //
            // There is a bug in the listview code which shows up
            // when an item is inserted with no subitem,
            // and than an item is inserted above it with a subitem.
            // When a third item is inserted at the bottom of the list,
            // the insertion fails because there are now three items but
            // the last subitem belongs to item 1.
            //  (See cairoshl\commctrl\listview.c, ListView_OnInsertItem())
            //
            // We get around this by setting blank text for each column
            //

            for (iCol = 1; iCol < (INT)ptl->nColumns; iCol++) {
                ListView_SetItemText(
                    ptl->hwndList, pItem->iIndex, iCol, TEXT("")
                    );
            }

    
            //
            // redraw the changed item as well
            //

            if (pChanged != NULL) {
    
                pChanged->lvi.iItem = pChanged->iIndex;
                ListView_RedrawItems(
                    ptl->hwndList, pChanged->lvi.iItem, pChanged->lvi.iItem
                    );
            }


        }
        else
        if (pChanged != NULL && pChanged == pItem->pParent) {
    
            //
            // the parent is visible, and it has changed, so redraw it
            //

            ListView_RedrawItems(
                ptl->hwndList, pChanged->iIndex, pChanged->iIndex
                );
        }
    }

    return (HTLITEM)pItem;
}



//----------------------------------------------------------------------------
// Function:    TL_OnDeleteItem
//
// Removes the item with the specified handle from the treelist.
//----------------------------------------------------------------------------

BOOL
TL_OnDeleteItem(
    TL *ptl,
    HTLITEM hItem
    ) {

    TLITEM *pItem, *pChanged, *pParent;

    pItem = (TLITEM *)hItem;
    pParent = pItem->pParent;


    //
    // if the item is visible and expanded,
    // collapse it to simplify the deletion
    //

    if (TL_IsVisible(pItem) && TL_IsExpanded(pItem)) {
        TL_OnExpand(ptl, TLE_COLLAPSE, hItem);
    }


    //
    // see if there is a sibling after this item.
    // if there is, nothing changes when the item is deleted
    //
    pChanged = TL_OnGetNextItem(ptl, TLGN_NEXTSIBLING, (HTLITEM)pItem);

    if (pChanged != NULL) { pChanged = NULL; }
    else {

        //
        // this item is the last of its parent's children, so the change
        // is to the item's previous sibling, if any
        //

        pChanged = TL_OnGetNextItem(ptl, TLGN_PREVSIBLING, (HTLITEM)pItem);

        if (pChanged == NULL) {

            //
            // this item is its parent's only child, so the change 
            // is to the item's parent
            //

            if (pParent != &ptl->root) { pChanged = pParent; }
        }
    }
        

    //
    // delete the item and its descendants
    //

    TL_DeleteAndNotify(ptl, pItem);


    //
    // if there was a side-effect, update the affected item
    //

    if (pChanged != NULL) { TL_UpdateImage(ptl, pChanged, NULL); }


    //
    // update the indices of the items below the deleted item
    //

    TL_UpdateListIndices(ptl, pParent);

    return TRUE;
}



//----------------------------------------------------------------------------
// Function:    TL_DeleteAndNotify
//
// This function performs a recursive deletion on a subtree,
// notifying the treelist's parent as each item is removed
//----------------------------------------------------------------------------

VOID
TL_DeleteAndNotify(
    TL *ptl,
    TLITEM *pItem
    ) {

    NMTREELIST nmtl;
    TLSUBITEM *pSubitem;
    LIST_ENTRY *ple, *phead;
    TLITEM *pChild, *pChanged;


    //
    // do deletions on all descendants first
    // note that the entry will be removed inside the recursive call,
    // hence we walk the last be always picking off its head
    //

    phead = &pItem->lhChildren;
    for (ple = phead->Flink; ple != phead; ple = phead->Flink) {

        pChild = (TLITEM *)CONTAINING_RECORD(ple, TLITEM, leSiblings);

        TL_DeleteAndNotify(ptl, pChild);
    }


    //
    // notify the owner before completing the deletion
    //

    nmtl.hdr.hwndFrom = ptl->hwnd;
    nmtl.hdr.code = TLN_DELETEITEM;
    nmtl.hItem = (HTLITEM)pItem;
    nmtl.lParam = pItem->lParam;
    TL_NotifyParent(ptl, (NMHDR *)&nmtl);



    //
    // remove the entry from the listview if it is visible
    //

    if (TL_IsVisible(pItem)) {
        ListView_DeleteItem(ptl->hwndList, pItem->iIndex);
    }


    //
    // remove the entry from the list of its siblings
    //

    RemoveEntryList(&pItem->leSiblings);
    --pItem->pParent->nChildren;
    if (pItem->pParent->nChildren == 0 && pItem->pParent != &ptl->root) {
        pItem->pParent->uiFlag &= ~TLI_EXPANDED;
    }


    //
    // free the memory used by all its subitems, and free this item itself
    //

    while (!IsListEmpty(&pItem->lhSubitems)) {

        ple = RemoveHeadList(&pItem->lhSubitems);

        pSubitem = (TLSUBITEM *)CONTAINING_RECORD(ple, TLSUBITEM, leItems);

        Free0(pSubitem->pszText);
        Free(pSubitem);
    }

    Free0(pItem->pszText);
    Free(pItem);
}



//----------------------------------------------------------------------------
// Function:    TL_OnDeleteAllItems
//
// This function handles the case of deleting all items in the tree.
//----------------------------------------------------------------------------

BOOL
TL_OnDeleteAllItems(
    TL *ptl
    ) {

    LIST_ENTRY *ple, *phead;
    TLITEM *pItem, *pParent;
    
    ListView_DeleteAllItems(ptl->hwndList);

    phead = &ptl->root.lhChildren;

    for (ple = phead->Flink; ple != phead; ple = phead->Flink) {

        pItem = (TLITEM *)CONTAINING_RECORD(ple, TLITEM, leSiblings);

        TL_DeleteAndNotify(ptl, pItem);
    }

    return TRUE;
}



//----------------------------------------------------------------------------
// Function:    TL_OnGetItem
//
// This function is called to retrieve a specific item from the treelist
//----------------------------------------------------------------------------

BOOL
TL_OnGetItem(
    TL *ptl,
    LV_ITEM *plvi
    ) {

    PTSTR psz;
    TLITEM *pItem;
    TLSUBITEM *pSubitem;
    LIST_ENTRY *ple, *phead;

    psz = NULL;
    pItem = (TLITEM *)UlongToPtr(plvi->iItem);


    //
    // get a pointer to the text for the item (or subitem)
    //

    if (plvi->iSubItem == 0) {
        psz = pItem->pszText;
    }
    else
    if (plvi->mask & LVIF_TEXT) {

        phead = &pItem->lhSubitems;

        for (ple = phead->Flink; ple != phead; ple = ple->Flink) {

            pSubitem = (TLSUBITEM *)CONTAINING_RECORD(ple, TLSUBITEM, leItems);
            if (pSubitem->iSubItem == plvi->iSubItem) {
                psz = pSubitem->pszText; break;
            }
        }

        if (psz == NULL) { return FALSE; }
    }
        

    //
    // retrieve the fields requested
    //

    if (plvi->mask & LVIF_TEXT) {
        lstrcpyn(plvi->pszText, psz, plvi->cchTextMax);
    }

    if (plvi->mask & LVIF_IMAGE) {
        plvi->iImage = pItem->lvi.iImage;
    }

    if (plvi->mask & LVIF_PARAM) {
        plvi->lParam = pItem->lParam;
    }

    if (plvi->mask & LVIF_STATE) {
        plvi->state = pItem->lvi.state;
    }

    return TRUE;
}



//----------------------------------------------------------------------------
// Function:    TL_OnSetItem
//
// This function changes a specific item (or subitem).
//----------------------------------------------------------------------------

BOOL
TL_OnSetItem(
    TL *ptl,
    LV_ITEM *plvi
    ) {

    PTSTR *psz;
    UINT uiMask;
    BOOL bSuccess;
    TLITEM *pItem;
    TLSUBITEM *pSubitem;
    LIST_ENTRY *ple, *phead;

    psz = NULL;
    uiMask = 0;
    pItem = (TLITEM *)UlongToPtr(plvi->iItem);

    //
    // retrieve the text pointer for the item (or subitem)
    //

    if (plvi->iSubItem == 0) {
        psz = &pItem->pszText;
    }
    else 
    if (plvi->mask & LVIF_TEXT) {

        //
        // search for the specified subitem
        //

        phead = &pItem->lhSubitems;

        for (ple = phead->Flink; ple != phead; ple = ple->Flink) {

            pSubitem = (TLSUBITEM *)CONTAINING_RECORD(ple, TLSUBITEM, leItems);
            if (pSubitem->iSubItem > plvi->iSubItem) {
                break;
            }
            else
            if (pSubitem->iSubItem == plvi->iSubItem) {
                psz = &pSubitem->pszText; break;
            }
        }

        if (psz == NULL) { 

            //
            // create a new subitem
            //

            pSubitem = (TLSUBITEM *)Malloc(sizeof(TLSUBITEM));
            if (pSubitem == NULL) { return FALSE; }

            InsertTailList(ple, &pSubitem->leItems);

            pSubitem->iSubItem = plvi->iSubItem;
            pSubitem->pszText = NULL;
            psz = &pSubitem->pszText;
        }
    }


    //
    // update the fields to be changed
    //

    if (plvi->mask & LVIF_TEXT) {
        PTSTR pszTemp;

        uiMask |= LVIF_TEXT;
        pszTemp = StrDup(plvi->pszText);
        if (!pszTemp) { return FALSE; }
        Free0(*psz); *psz = pszTemp;
    }

    if (plvi->mask & LVIF_IMAGE) {
        uiMask |= LVIF_IMAGE;
        pItem->lvi.iImage = plvi->iImage;
    }

    if (plvi->mask & LVIF_PARAM) {
        pItem->lParam = plvi->lParam;
    }

    if (plvi->mask & LVIF_STATE) {
        uiMask |= LVIF_STATE;
        pItem->lvi.stateMask = plvi->stateMask;
        pItem->lvi.state = plvi->state;
    }

    bSuccess = TRUE;
    pItem->lvi.mask |= uiMask;


    //
    // update the item's appearance if it is visible
    //

    if (TL_IsVisible(pItem)) {

        UINT uiOldMask = pItem->lvi.mask;

        pItem->lvi.mask = uiMask;

        if(NULL != psz)
        {
            pItem->lvi.pszText = *psz;
        }
        
        pItem->lvi.iSubItem = plvi->iSubItem;

        bSuccess = ListView_SetItem(ptl->hwndList, &pItem->lvi);
        if (bSuccess) {
            ListView_RedrawItems(ptl->hwndList, pItem->iIndex, pItem->iIndex);
        }

        pItem->lvi.mask = uiOldMask;
        pItem->lvi.pszText = pItem->pszText;
        pItem->lvi.iSubItem = 0;
    }

    return bSuccess;
}



//----------------------------------------------------------------------------
// Function:    TL_GetItemCount
//
// This function retrieves a count of the items in the treelist
//----------------------------------------------------------------------------

UINT
TL_OnGetItemCount(
    TL *ptl
    ) {

    INT iCount = 0;

    //
    // count the items in the subtree rooted at the invisible root,
    // and decrement by one to exclude the root itself
    //

    TL_CountItems(&ptl->root, &iCount);

    return (UINT)(iCount - 1);
}



//----------------------------------------------------------------------------
// Function:    TL_CountItems
//
// This function recursively counts the items in the specified subtree
//----------------------------------------------------------------------------

VOID
TL_CountItems(
    TLITEM *pParent,
    INT *piCount
    ) {

    TLITEM *pItem;
    LIST_ENTRY *ple, *phead;

    ++(*piCount);

    phead = &pParent->lhChildren;

    for (ple = phead->Flink; ple != phead; ple = ple->Flink) {
        pItem = (TLITEM *)CONTAINING_RECORD(ple, TLITEM, leSiblings);

        TL_CountItems(pItem, piCount);
    }

    return;
}



//----------------------------------------------------------------------------
// Function:    TL_OnGetNextItem
//
// This function retrieves an item with a given property,
// or relative to a specified item
//----------------------------------------------------------------------------

HTLITEM
TL_OnGetNextItem(
    TL *ptl,
    UINT uiFlag,
    HTLITEM hItem
    ) {

    TLITEM *pItem;
    LIST_ENTRY *ple, *phead;

    pItem = (TLITEM *)hItem;

    switch (uiFlag) {

        case TLGN_FIRST: {

            if (IsListEmpty(&ptl->root.lhChildren)) {
                return NULL;
            }

            ple = ptl->root.lhChildren.Flink;

            return (HTLITEM)CONTAINING_RECORD(ple, TLITEM, leSiblings);
        }

        case TLGN_PARENT: {
            if (pItem->pParent == &ptl->root) {
                return NULL;
            }

            return (HTLITEM)pItem->pParent;
        }

        case TLGN_CHILD: {

            if (IsListEmpty(&pItem->lhChildren)) {
                return NULL;
            }

            ple = pItem->lhChildren.Flink;

            return (HTLITEM)CONTAINING_RECORD(ple, TLITEM, leSiblings);
        }

        case TLGN_NEXTSIBLING: {

            phead = &pItem->pParent->lhChildren;

            ple = pItem->leSiblings.Flink;
            if (ple == phead) { return NULL; }

            return (HTLITEM)CONTAINING_RECORD(ple, TLITEM, leSiblings);
        }

        case TLGN_PREVSIBLING: {

            phead = &pItem->pParent->lhChildren;

            ple = pItem->leSiblings.Blink;
            if (ple == phead) { return NULL; }

            return (HTLITEM)CONTAINING_RECORD(ple, TLITEM, leSiblings);
        }

        case TLGN_ENUMERATE: {
    
            TLITEM *pNext;

            if (pItem == NULL) {
                return TL_OnGetNextItem(ptl, TLGN_FIRST, NULL);
            }

            pNext = (TLITEM *)TL_OnGetNextItem(ptl, TLGN_CHILD, hItem);

            if (pNext == NULL) {

                pNext = TL_OnGetNextItem(ptl, TLGN_NEXTSIBLING, hItem);

                if (pNext == NULL) {

                    for (pItem = pItem->pParent;
                         pItem != &ptl->root; pItem = pItem->pParent) {
                        pNext = TL_OnGetNextItem(
                                    ptl, TLGN_NEXTSIBLING, (HTLITEM)pItem
                                    );
                        if (pNext != NULL) { break; }
                    }
                }
            }

            return pNext;
        }

        case TLGN_SELECTION: {

            INT iItem;
            LV_ITEM lvi;

            iItem = ListView_GetNextItem(ptl->hwndList, -1, LVNI_SELECTED);
            if (iItem == -1) {

                iItem = ListView_GetNextItem(ptl->hwndList, -1, LVNI_FOCUSED);

                if (iItem == -1)  { return NULL; }
            }

            lvi.iItem = iItem;
            lvi.iSubItem = 0;
            lvi.mask = LVIF_PARAM;

            if (!ListView_GetItem(ptl->hwndList, &lvi)) { return NULL; }

            return (HTLITEM)lvi.lParam;
        }
    }

    return NULL;
}



//----------------------------------------------------------------------------
// Function:    TL_OnExpand
//
// This is called to expand or collapse an item,
// or to toggle the expand-state of an item
//----------------------------------------------------------------------------

BOOL
TL_OnExpand(
    TL *ptl,
    UINT uiFlag,
    HTLITEM hItem
    ) {

    TLITEM *pItem;
    BOOL bSuccess;

    pItem = (TLITEM *)hItem;

    if (pItem->uiFlag & TLI_EXPANDED) {

        // item is expanded already, do nothing
        if (uiFlag == TLE_EXPAND) {
            return TRUE;
        }

        bSuccess = TL_ItemCollapse(ptl, pItem);
    }
    else {

        // item is collapsed already, do nothing
        if (uiFlag == TLE_COLLAPSE) {
            return TRUE;
        }

        bSuccess = TL_ItemExpand(ptl, pItem);
    }


    //
    // update the list indices and redraw the item expanded/collapsed
    //

    if (bSuccess) {
        ListView_RedrawItems(ptl->hwndList, pItem->iIndex, pItem->iIndex);
    }

    return bSuccess;
}



//----------------------------------------------------------------------------
// Function:    TL_ItemCollapse
//
// Collapses an item
//----------------------------------------------------------------------------

BOOL
TL_ItemCollapse(
    TL *ptl,
    TLITEM *pItem
    ) {

    INT i, iItem;
    TLITEM *pChild;
    LIST_ENTRY *ple, *phead;


    if (pItem->nChildren == 0 || !TL_IsExpanded(pItem)) { return FALSE; }


    //
    // first collapse all descendants;
    // note that this is done in reverse order,
    // so that the indices of the higher items remain valid
    // while the lower ones are being removed
    //

    phead = &pItem->lhChildren;

    for (ple = phead->Blink; ple != phead; ple = ple->Blink) {
        pChild = (TLITEM *)CONTAINING_RECORD(ple, TLITEM, leSiblings);
        TL_ItemCollapse(ptl, pChild);
    }


    //
    // delete all this item's children (they are now collapsed);
    // since the listview shifts items up when an item is deleted,
    // we delete items n through m by deleting item n (m-n)+1 times
    //

    iItem = pItem->iIndex;

    for (i = 0; i < (INT)pItem->nChildren; i++) {
        ListView_DeleteItem(ptl->hwndList, iItem + 1);
    }

    pItem->uiFlag &= ~TLI_EXPANDED;

    TL_UpdateImage(ptl, pItem, NULL);
    TL_UpdateListIndices(ptl, pItem);

    return TRUE;
}



//----------------------------------------------------------------------------
// Function:    TL_ItemExpand
//
// Expands an item
//----------------------------------------------------------------------------

BOOL
TL_ItemExpand(
    TL *ptl,
    TLITEM *pItem
    ) {

    INT i;
    TLITEM *pChild;
    TLSUBITEM *pSubitem;
    LIST_ENTRY *ple, *phead, *ples, *psubhead;


    if (pItem->nChildren == 0 || TL_IsExpanded(pItem)) { return FALSE; }


    //
    // update the expand-state and image for the item,
    // and then recompute the indices of its children
    //

    pItem->uiFlag |= TLI_EXPANDED;
    TL_UpdateImage(ptl, pItem, NULL);
    TL_UpdateListIndices(ptl, pItem);


    //
    // insert items below this one;
    // we also need to set the sub-item text for each inserted item
    //

    phead = &pItem->lhChildren;

    for (ple = phead->Flink; ple != phead; ple = ple->Flink) {

        pChild = (TLITEM *)CONTAINING_RECORD(ple, TLITEM, leSiblings);

        pChild->lvi.iItem = pChild->iIndex;
        pChild->lvi.iSubItem = 0;

        TL_UpdateImage(ptl, pChild, NULL);

        ListView_InsertItem(ptl->hwndList, &pChild->lvi);

        psubhead = &pChild->lhSubitems;

        i = 1;
        for (ples = psubhead->Flink; ples != psubhead; ples = ples->Flink) {

            pSubitem = (TLSUBITEM *)CONTAINING_RECORD(ples, TLSUBITEM, leItems);

            for ( ; i < pSubitem->iSubItem; i++) {
                ListView_SetItemText(
                    ptl->hwndList, pChild->iIndex, i, TEXT("")
                    );
            }

            ListView_SetItemText(
                ptl->hwndList, pChild->iIndex, pSubitem->iSubItem,
                pSubitem->pszText
                );

            ++i;
        }

        for ( ; i < (INT)ptl->nColumns; i++) {
            ListView_SetItemText(
                ptl->hwndList, pChild->iIndex, i, TEXT("")
                );
        }
    }

    return TRUE;
}



//----------------------------------------------------------------------------
// Function:    TL_OnInsertColumn
//
// Inserts a column. Memory for subitem's is not allocated until
// the subitems' texts aer actually set in TL_OnSetItem
//----------------------------------------------------------------------------

INT
TL_OnInsertColumn(
    TL *ptl,
    INT iCol,
    LV_COLUMN *pCol
    ) {

    if ((iCol = ListView_InsertColumn(ptl->hwndList, iCol, pCol)) != -1) {
        ++ptl->nColumns;
    }

    return iCol;
}



//----------------------------------------------------------------------------
// Function:    TL_OnDeleteColumn
//
// Deletes a column, and removes all subitems corresponding to the column
//----------------------------------------------------------------------------

BOOL
TL_OnDeleteColumn(
    TL *ptl,
    INT iCol
    ) {


    TLITEM *pItem;
    TLSUBITEM *pSubitem;
    LIST_ENTRY *ple, *phead;

    if (!ListView_DeleteColumn(ptl->hwndList, iCol)) {
        return FALSE;
    }

    --ptl->nColumns;


    //
    // delete the subitems which correspond to this column
    //

    pItem = NULL;

    while (pItem = TL_Enumerate(ptl, pItem)) {

        phead = &pItem->lhSubitems;

        for (ple = phead->Flink; ple != phead; ple = ple->Flink) {

            pSubitem = (TLSUBITEM *)CONTAINING_RECORD(ple, TLSUBITEM, leItems);

            if (pSubitem->iSubItem > iCol) {

                //
                // the column was never set, so do nothing
                //

                break;
            }
            else
            if (pSubitem->iSubItem == iCol) {

                RemoveEntryList(&pSubitem->leItems);

                Free0(pSubitem->pszText);
                Free(pSubitem);
                break;
            }
        }
    }

    return TRUE;
}



//----------------------------------------------------------------------------
// Function:    TL_OnSetSelection
//
// Changes the currently selected treelist item
//----------------------------------------------------------------------------

BOOL
TL_OnSetSelection(
    TL *ptl,
    HTLITEM hItem
    ) {

    TLITEM *pItem;

    pItem = (TLITEM *)hItem;
    if (!TL_IsVisible(pItem)) { return FALSE; }

    ListView_SetItemState(
        ptl->hwndList, pItem->iIndex,
        LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED
        );

    return TRUE;
}



//----------------------------------------------------------------------------
// Function:    TL_OnRedraw
//
// Forces a redraw of the treelist by invalidating its entire client area
//----------------------------------------------------------------------------

BOOL
TL_OnRedraw(
    TL *ptl
    ) {

    InvalidateRect(ptl->hwndList, NULL, TRUE);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\extapi\src\api.c ===
/* Copyright (c) 1992, Microsoft Corporation, all rights reserved
**
** api.c
** Remote Access External APIs
** Non-RasDial API routines
**
** 10/12/92 Steve Cobb
*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <extapi.h>
#include <tapi.h>
#include <raseapif.h>

//
// CCP Option types
//
#define RAS_CCP_OPTION_MSPPC        18

// MSKK NaotoN Appended to support DBCS handling 11/23/93
//
//#ifdef  DBCS
#include <mbstring.h>
//#endif

//
// Version for TAPI APIs.
//
#define TAPIVERSION 0x10004

//
// Eap registry key/value paths
//
#define EAP_REGBASE                 TEXT("System\\CurrentControlSet\\Services\\Rasman\\PPP\\EAP")
#define EAP_REGINVOKE_NAMEDLG       TEXT("InvokeUsernameDialog")
#define EAP_REGIDENTITY_PATH        TEXT("IdentityPath")

//
// RasEapGetIdentity, RasEapFreeMemory in the EAP dll
//
#define EAP_RASEAPGETIDENTITY       "RasEapGetIdentity"
#define EAP_RASEAPFREEMEMORY        "RasEapFreeMemory"
typedef DWORD (APIENTRY * RASEAPGETIDENTITY)(
    DWORD,
    HWND,
    DWORD,
    const WCHAR*,
    const WCHAR*,
    PBYTE,
    DWORD,
    PBYTE,
    DWORD,
    PBYTE*,
    DWORD*,
    WCHAR**
);
typedef DWORD (APIENTRY * RASEAPFREEMEMORY)(
    PBYTE
);

//
// AutoDial registry key/value paths.
//
#define AUTODIAL_REGBASE           TEXT("Software\\Microsoft\\RAS AutoDial")
#define AUTODIAL_REGADDRESSBASE    TEXT("Addresses")
#define AUTODIAL_REGNETWORKBASE    TEXT("Networks")
#define AUTODIAL_REGNETWORKID      TEXT("NextId")
#define AUTODIAL_REGENTRYBASE      TEXT("Entries")
#define AUTODIAL_REGCONTROLBASE    TEXT("Control")
#define AUTODIAL_REGDISABLEDBASE   TEXT("Control\\Locations")
#define AUTODIAL_REGDEFAULT        TEXT("Default")

#define AUTODIAL_REGNETWORKVALUE   TEXT("Network")
#define AUTODIAL_REGDEFINTERNETVALUE TEXT("DefaultInternet")
#define AUTODIAL_REGFLAGSVALUE     TEXT("Flags")

//
// Autodial parameter registry keys.
//
#define MaxAutodialParams   5
struct AutodialParamRegKeys
{
    LPTSTR szKey;       // registry key name
    DWORD dwType;       // registry key type
    DWORD dwSize;       // default size
} AutodialParamRegKeys[MaxAutodialParams] =
{
    {TEXT("DisableConnectionQuery"),    REG_DWORD,      sizeof (DWORD)},
    {TEXT("LoginSessionDisable"),       REG_DWORD,      sizeof (DWORD)},
    {TEXT("SavedAddressesLimit"),       REG_DWORD,      sizeof (DWORD)},
    {TEXT("FailedConnectionTimeout"),   REG_DWORD,      sizeof (DWORD)},
    {TEXT("ConnectionQueryTimeout"),    REG_DWORD,      sizeof (DWORD)}
};

DWORD 
DwRenameDefaultConnection(
    LPCWSTR lpszPhonebook,
    LPCWSTR lpszOldEntry,
    LPCWSTR lpszNewEntry);

BOOL
CaseInsensitiveMatch(
    IN LPCWSTR pszStr1,
    IN LPCWSTR pszStr2
    );

DWORD
CallRasEntryDlgW(
    IN     LPCWSTR       pszPhonebook,
    IN     LPCWSTR       pszEntry,
    IN OUT RASENTRYDLGW* pInfo )

/*++

Routine Decriptions:

    Load and call RasEntryDlg with caller's parameters.

Arguments:

Return Value:

    Returns 0 if successful, otherwise a non-0 error code.

--*/

{
    DWORD   dwErr;
    HMODULE h;

    DWORD (*pRasEntryDlgW)(
        IN     LPCWSTR       pszPhonebook,
        IN     LPCWSTR       pszEntry,
        IN OUT RASENTRYDLGW* pInfo );

    h = LoadLibrary( TEXT("RASDLG.DLL") );

    if (!h)
    {
        return GetLastError();
    }

    pRasEntryDlgW = (VOID* )GetProcAddress( h, "RasEntryDlgW" );
    if (pRasEntryDlgW)
    {
        (*pRasEntryDlgW)( pszPhonebook, pszEntry, pInfo );
        dwErr = pInfo->dwError;
    }
    else
    {
        dwErr = GetLastError();
    }

    FreeLibrary( h );
    return dwErr;
}


DWORD APIENTRY
RasCreatePhonebookEntryW(
    IN HWND     hwnd,
    IN LPCWSTR  lpszPhonebook )

/*++

Routine Description:

    Pops up a dialog (owned by window 'hwnd') to create
    a new phonebook entry in phonebook 'lpszPhonebook'.
    'lpszPhonebook' may be NULL to indicate the default
    phonebook should be used.

Arguments:


Return Value:
    Returns 0 if successful, otherwise a non-0 error code.

--*/

{
    RASENTRYDLGW info;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    if (DwRasInitializeError)
    {
        return DwRasInitializeError;
    }

    ZeroMemory( &info, sizeof(info) );
    info.dwSize = sizeof(info);
    info.hwndOwner = hwnd;
    info.dwFlags = RASEDFLAG_NewEntry;

    return CallRasEntryDlgW( lpszPhonebook, NULL, &info );
}


DWORD APIENTRY
RasCreatePhonebookEntryA(
    IN HWND   hwnd,
    IN LPCSTR lpszPhonebook )

/*++

Routine Description:

    Pops up a dialog (owned by window 'hwnd') to create
    a new phonebook entry in phonebook 'lpszPhonebook'.
    'lpszPhonebook' may be NULL to indicate the default
    phonebook should be used.

Arguments:

Return Value:

    Returns 0 if successful, otherwise a non-0 error code.

--*/
{
    NTSTATUS status;
    DWORD dwErr;
    WCHAR szPhonebookW[MAX_PATH];

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    //
    // Convert the lpszPhonebook string to Unicode.
    //
    if (lpszPhonebook != NULL)
    {
        strncpyAtoWAnsi(szPhonebookW, lpszPhonebook, MAX_PATH);
    }

    //
    // Call the W version to do the work.
    //
    dwErr = RasCreatePhonebookEntryW(
              hwnd,
              lpszPhonebook != NULL ? szPhonebookW : NULL);

    return dwErr;
}


DWORD APIENTRY
RasEditPhonebookEntryW(
    IN HWND     hwnd,
    IN LPCWSTR  lpszPhonebook,
    IN LPCWSTR  lpszEntryName )

/*++

Routine Description:

    Pops up a dialog (owned by window 'hwnd') to edit
    phonebook entry 'lpszEntryName' from phonebook
    'lpszPhonebook'.  'lpszPhonebook' may be NULL to
    indicate the default phonebook should be used.

Arguments:

Return Value:

    Returns 0 if successful, otherwise a non-0
    error code.

--*/
{
    RASENTRYDLGW info;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    if (DwRasInitializeError)
    {
        return DwRasInitializeError;
    }

    //
    // Validate parameters.
    //
    if (lpszEntryName == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    ZeroMemory( &info, sizeof(info) );
    info.dwSize = sizeof(info);
    info.hwndOwner = hwnd;

    return CallRasEntryDlgW( lpszPhonebook, lpszEntryName, &info );
}


DWORD APIENTRY
RasEditPhonebookEntryA(
    IN HWND   hwnd,
    IN LPCSTR lpszPhonebook,
    IN LPCSTR lpszEntryName )

/*++

Routine Description:

    Pops up a dialog (owned by window 'hwnd') to edit
    phonebook entry 'lpszEntryName' from phonebook
    'lpszPhonebook'.  'lpszPhonebook' may be NULL to
    indicate the default phonebook should be used.

Arguments:


Return Value:
    Returns 0 if successful, otherwise a non-0
    error code.

--*/
{
    NTSTATUS status;
    DWORD dwErr;
    WCHAR szPhonebookW[MAX_PATH],
          szEntryNameW[RAS_MaxEntryName + 1];

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    //
    // Convert the lpszPhonebook string to Unicode.
    //
    if (lpszPhonebook != NULL)
    {
        strncpyAtoWAnsi(szPhonebookW,
                    lpszPhonebook,
                    MAX_PATH);
    }

    //
    // Convert the lpszEntry to Unicode.
    //
    if (lpszEntryName != NULL)
    {
        strncpyAtoWAnsi(szEntryNameW,
                    lpszEntryName,
                    RAS_MaxEntryName + 1);
    }

    //
    // Call the W version to do the work.
    //
    dwErr = RasEditPhonebookEntryW(
              hwnd,
              lpszPhonebook != NULL ? szPhonebookW : NULL,
              lpszEntryName != NULL ? szEntryNameW : NULL);

    return dwErr;
}


DWORD APIENTRY
RasEnumConnectionsW(
    OUT    LPRASCONNW lprasconn,
    IN OUT LPDWORD    lpcb,
    OUT    LPDWORD    lpcConnections )

/*++

Routine Description:

    Enumerate active RAS connections.  'lprasconn' is
    caller's buffer to receive the array of RASCONN
    structures.  'lpcb' is the size of caller's buffer
    on entry and is set to the number of bytes required
    for all information on exit.  '*lpcConnections' is
    set to the number of elements in the returned array.

Arguments:

Return Value:

    Returns 0 if successful, otherwise a non-0 error code.
--*/

{
    DWORD        dwErr;
    HCONN        *lpconns = NULL, *lpconn;
    DWORD        dwcbConnections, dwcConnections;
    DWORD        i, j;
    DWORD        dwSize, dwInBufSize;
    BOOL         fV351;
    BOOL         fV400;
    BOOL         fV401;
    BOOL         fV500;
    BOOL         fV501;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    RASAPI32_TRACE("RasEnumConnectionsW");

    // Check parameters.
    //
    if (    !lprasconn
        || (    lprasconn->dwSize != sizeof(RASCONNW)
            &&  lprasconn->dwSize != sizeof(RASCONNW_V500)
            &&  lprasconn->dwSize != sizeof(RASCONNW_V401))
            &&  lprasconn->dwSize != sizeof(RASCONNW_V400)
            &&  lprasconn->dwSize != sizeof(RASCONNW_V351))
    {
        return ERROR_INVALID_SIZE;
    }

    fV351 = (lprasconn->dwSize == sizeof(RASCONNW_V351));
    fV400 = (lprasconn->dwSize == sizeof(RASCONNW_V400));
    fV401 = (lprasconn->dwSize == sizeof(RASCONNW_V401));
    fV500 = (lprasconn->dwSize == sizeof(RASCONNW_V500));
    fV501 = (lprasconn->dwSize == sizeof(RASCONNW));

    if (    lpcb == NULL
        ||  lpcConnections == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Save the byte count passed in for checks later.
    // Initialize the return values.
    //
    dwInBufSize = *lpcb;
    *lpcConnections = 0;
    *lpcb = 0;

    // If rasman is not running, we don't need to do anything.  (No
    // connections to enumerate if rasman is not running.)
    // We only need to check if the service is running if we think it
    // might not be; and it might not be if FRasInitialized is FALSE.
    // If FRasInitialized were TRUE, we know it would be running because
    // it means we started it.
    //
    if (!FRasInitialized && !IsRasmanServiceRunning())
    {
        return 0;
    }

    dwErr = LoadRasmanDllAndInit();

    if (dwErr)
    {
        return dwErr;
    }

    if (DwRasInitializeError != 0)
    {
        return DwRasInitializeError;
    }

    //
    // Get a list of active connection
    // handles from rasman.
    //
    dwErr = g_pRasConnectionEnum(
              NULL,
              NULL,
              &dwcbConnections,
              &dwcConnections);

    if (dwErr != 0)
    {
        return dwErr;
    }

    do
    {
        if(NULL != lpconns)
        {
            Free(lpconns);
            lpconns = NULL;
        }

        if(!dwcConnections)
        {
            return 0;
        }
        
        lpconns = Malloc(dwcbConnections);

        if (lpconns == NULL)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        dwErr = g_pRasConnectionEnum(
                  NULL,
                  lpconns,
                  &dwcbConnections,
                  &dwcConnections);

    } while (ERROR_BUFFER_TOO_SMALL == dwErr);

    if (dwErr)
    {
        Free(lpconns);
        return dwErr;
    }

    //
    // Now loop again, filling in caller's buffer.
    //
    dwSize = lprasconn->dwSize;

    for (i = 0, j = 0; i < dwcConnections; i++)
    {
        RASMAN_PORT *lpPorts;
        RASMAN_INFO *pinfo = NULL;
        DWORD dwcbPorts, dwcPorts;

        //
        // Get the ports associated with the
        // connection.
        //
        dwcbPorts = dwcPorts = 0;

        lpPorts = NULL;

        // memset(&info, '\0', sizeof (info));

        dwErr = g_pRasEnumConnectionPorts(NULL,
                                          lpconns[i],
                                          NULL,
                                          &dwcbPorts,
                                          &dwcPorts);

        if (    dwErr == ERROR_BUFFER_TOO_SMALL
            &&  dwcPorts)
        {
            lpPorts = Malloc(dwcbPorts);
            if (lpPorts == NULL)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            dwErr = g_pRasEnumConnectionPorts(NULL,
                                              lpconns[i],
                                              lpPorts,
                                              &dwcbPorts,
                                              &dwcPorts);
            if (dwErr)
            {
                Free(lpPorts);
                break;
            }

            pinfo = Malloc(sizeof(RASMAN_INFO));
            if(NULL == pinfo)
            {
                Free(lpPorts);
                break;
            }

            ZeroMemory(pinfo, sizeof(RASMAN_INFO));
            
            dwErr = g_pRasGetInfo(NULL,
                                  lpPorts->P_Handle,
                                  pinfo);
            if (dwErr)
            {
                Free(lpPorts);
                Free(pinfo);
                break;
            }

            RASAPI32_TRACE1("RasEnumConnectionsW: PhoneEntry=%s",
                   pinfo->RI_PhoneEntry);
        }
        else
        {
            RASAPI32_TRACE1(
              "RasEnumConnectionsW: hrasconn=0x%x: orphaned"
              " connection",
              lpconns[i]);
            continue;
        }

        //
        // Check to see if we are going to overflow the
        // caller's buffer.
        //
        if ((j + 1) * dwSize > dwInBufSize)
        {
            *lpcConnections = dwcConnections;

            *lpcb = *lpcConnections * dwSize;

            dwErr = ERROR_BUFFER_TOO_SMALL;

            if (lpPorts != NULL)
            {
                Free(lpPorts);
            }

            if(pinfo != NULL)
            {
                Free(pinfo);
            }

            break;
        }

        //
        // Fill in caller's buffer entry.
        //
        // Note: Assumption is made here that the V351 and
        //       V400 structures are a subset of the V401
        //       structure.
        //
        lprasconn->hrasconn = (HRASCONN)lpconns[i];
        if (pinfo->RI_PhoneEntry[ 0 ] == '.')
        {
            if (fV351)
            {
                memset(
                  lprasconn->szEntryName,
                  '\0',
                  (RAS_MaxEntryName_V351 + 1) * sizeof (WCHAR));

                strncpyAtoW(
                  lprasconn->szEntryName,
                  pinfo->RI_PhoneEntry,
                  RAS_MaxEntryName_V351);
            }
            else
            {
                //
                // In the V40 structures the phonenumber
                // never needs truncation.
                //
                strncpyAtoW(lprasconn->szEntryName,
                           pinfo->RI_PhoneEntry,
                           sizeof(lprasconn->szEntryName) / sizeof(WCHAR));
            }
        }
        else
        {
            if (fV351)
            {
                memset(
                  lprasconn->szEntryName,
                  '\0',
                  (RAS_MaxEntryName_V351 + 1)
                  * sizeof (WCHAR));

                strncpyAtoW(
                  lprasconn->szEntryName,
                  pinfo->RI_PhoneEntry,
                  RAS_MaxEntryName_V351);
            }
            else
            {
                //
                // In the V40 structures the entry name
                // never needs truncation.
                //
                strncpyAtoW(lprasconn->szEntryName,
                           pinfo->RI_PhoneEntry,
                           sizeof(lprasconn->szEntryName) / sizeof(WCHAR));
            }
        }

        //
        // Set the V401 fields.
        //
        if (    !fV351
            &&  !fV400)
        {
            strncpyAtoW(lprasconn->szPhonebook,
                       pinfo->RI_Phonebook,
                       sizeof(lprasconn->szPhonebook) / sizeof(WCHAR));

            lprasconn->dwSubEntry = pinfo->RI_SubEntry;
        }

        if (!fV351)
        {
            //
            // The attached device name and type are
            // included in the V400+ version of the
            // structure.
            //
            *lprasconn->szDeviceName = L'\0';
            *lprasconn->szDeviceType = L'\0';

            if (lpPorts != NULL)
            {
                // strcpyAtoW(lprasconn->szDeviceName,
                //           lpPorts->P_DeviceName);

                RasGetUnicodeDeviceName(lpPorts->P_Handle,
                                        lprasconn->szDeviceName);

                strncpyAtoW(lprasconn->szDeviceType,
                           lpPorts->P_DeviceType,
                           sizeof(lprasconn->szDeviceType) / sizeof(WCHAR));
            }
        }

        //
        // Set V500 fields
        //
        if (!fV351 && !fV400 && !fV401)
        {
            memcpy(&lprasconn->guidEntry,
                   &pinfo->RI_GuidEntry,
                   sizeof(GUID));
        }

        //
        // Set V501 fields
        //
        if(!fV351 && !fV400 && !fV401 && !fV500)
        {
            LUID luid;
            DWORD dwSizeLuid = sizeof(LUID);
            
            (void) g_pRasGetConnectionUserData(
                      (HCONN)lprasconn->hrasconn,
                      CONNECTION_LUID_INDEX,
                      (BYTE *) &lprasconn->luid,
                      &dwSizeLuid);

            //
            //  Zero the flags and then OR on the appropriate
            //  flags.
            //
            lprasconn->dwFlags = 0;

            if(pinfo->RI_dwFlags & RASMAN_DEFAULT_CREDS)
            {
                lprasconn->dwFlags |= RASCF_GlobalCreds;
            }                

            if(IsPublicPhonebook(lprasconn->szPhonebook))
            {
                lprasconn->dwFlags |= RASCF_AllUsers;
            }
        }

        if (fV351)
        {
            lprasconn =
                (RASCONNW* )(((CHAR* )lprasconn)
                + sizeof(RASCONNW_V351));
        }
        else if (fV400)
        {
            lprasconn =
                (RASCONNW* )(((CHAR* )lprasconn)
                + sizeof(RASCONNW_V400));
        }
        else if (fV401)
        {
            lprasconn =
                (RASCONNW*)  (((CHAR* )lprasconn)
                + sizeof(RASCONNW_V401));
        }
        else if (fV500)
        {
            lprasconn =
                (RASCONNW*)  (((CHAR* )lprasconn)
                + sizeof(RASCONNW_V500));
        }
        else
        {
            ++lprasconn;
        }

        //
        // Update the callers byte count and connection
        // count as we go.
        //
        j++;
        *lpcConnections = j;
        *lpcb = *lpcConnections * dwSize;

        //
        // Free the port structure associated with
        // the connection.
        //
        if (lpPorts != NULL)
        {
            Free(lpPorts);
        }

        if(pinfo != NULL)
        {
            Free(pinfo);
        }
    }

    Free(lpconns);
    return dwErr;
}


DWORD APIENTRY
RasEnumConnectionsA(
    OUT    LPRASCONNA lprasconn,
    IN OUT LPDWORD    lpcb,
    OUT    LPDWORD    lpcConnections )
{
    DWORD dwErr;
    DWORD cConnections;
    DWORD cb = 0;
    BOOL fV400;
    BOOL fV401;
    BOOL fV500;
    BOOL fV501;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    if (    lpcb == NULL
        ||  lpcConnections == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Verify caller's buffer version.
    //
    if (!lprasconn
        || (    lprasconn->dwSize != sizeof(RASCONNA)
            &&  lprasconn->dwSize != sizeof(RASCONNA_V500)
            &&  lprasconn->dwSize != sizeof(RASCONNA_V401)            
            &&  lprasconn->dwSize != sizeof(RASCONNA_V400)
            &&  lprasconn->dwSize != sizeof(RASCONNA_V351)))
    {
        return ERROR_INVALID_SIZE;
    }

    fV400 = (lprasconn->dwSize == sizeof(RASCONNA_V400));
    fV401 = (lprasconn->dwSize == sizeof(RASCONNA_V401));
    fV500 = (lprasconn->dwSize == sizeof(RASCONNA_V500));
    fV501 = (lprasconn->dwSize == sizeof(RASCONNA));

    if (lprasconn->dwSize == sizeof(RASCONNA_V351))
    {
        RASCONNW_V351* prasconnw = NULL;

        //
        // Allocate Unicode buffer big enough to hold
        // the same number of connections as caller's
        // unicode buffer.
        //
        cb =   (*lpcb / sizeof(RASCONNA_V351))
             * sizeof(RASCONNW_V351);

        prasconnw = (RASCONNW_V351* )
                    Malloc( (UINT )(cb + sizeof(DWORD)) );

        if (!prasconnw)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        prasconnw->dwSize = sizeof(RASCONNW_V351);

        //
        // Call the Unicode version to do all the work.
        //
        if (!lpcConnections)
        {
            lpcConnections = &cConnections;
        }

        dwErr = RasEnumConnectionsW(
                    (RASCONNW* )prasconnw,
                    &cb,
                    lpcConnections
                    );

        //
        // Copy results to caller's Ansi buffer.
        //
        if (dwErr == 0)
        {
            DWORD i;

            for (i = 0; i < *lpcConnections; ++i)
            {
                RASCONNW_V351* prasconnwTmp =
                                    &prasconnw[i];

                RASCONNA_V351* prasconnaTmp =
                            &((RASCONNA_V351*)lprasconn)[i];

                prasconnaTmp->dwSize = sizeof(RASCONNA_V351);
                prasconnaTmp->hrasconn = prasconnwTmp->hrasconn;

                strncpyWtoAAnsi(
                  prasconnaTmp->szEntryName,
                  prasconnwTmp->szEntryName,
                  sizeof(prasconnaTmp->szEntryName));
            }
        }

        if (prasconnw)
        {
            Free( prasconnw );
        }
    }
    else
    {
        RASCONNW* prasconnw = NULL;

        //
        // Allocate Unicode buffer big enough to hold the
        // same number of connections as caller's Ansi buffer.
        //
        if(fV501)
        {
            cb = (*lpcb / sizeof(RASCONNA))
                * sizeof(RASCONNW);
        }
        else if(fV500)
        {
            cb = (*lpcb / sizeof(RASCONNA_V500))
                * sizeof(RASCONNW);
        }
        else if (fV401)
        {
            cb = (*lpcb / sizeof(RASCONNA_V401))
                 * sizeof(RASCONNW);
        }
        else if (fV400)
        {
            cb =   (*lpcb / sizeof(RASCONNA_V400))
                 * sizeof(RASCONNW);
        }

        prasconnw = (RASCONNW* ) Malloc(
                (UINT )(cb + sizeof(DWORD))
                );

        if (!prasconnw)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        prasconnw->dwSize = sizeof(RASCONNW);

        //
        // Call the Unicode version to do all the work.
        //
        if (!lpcConnections)
        {
            lpcConnections = &cConnections;
        }

        dwErr = RasEnumConnectionsW(prasconnw,
                                    &cb,
                                    lpcConnections );

        //
        // Copy results to caller's Ansi buffer.
        //
        if (dwErr == 0)
        {
            DWORD i;

            for (i = 0; i < *lpcConnections; ++i)
            {
                RASCONNW* prasconnwTmp = &prasconnw[ i ];

                if (fV501)
                {
                    RASCONNA *prasconnaTmp = &lprasconn[i];
                    
                    prasconnaTmp->dwSize = sizeof(RASCONNA);

                    prasconnaTmp->hrasconn =
                            prasconnwTmp->hrasconn;

                    strncpyWtoAAnsi(
                      prasconnaTmp->szEntryName,
                      prasconnwTmp->szEntryName,
                      sizeof(prasconnaTmp->szEntryName));

                    strncpyWtoAAnsi(
                      prasconnaTmp->szDeviceType,
                      prasconnwTmp->szDeviceType,
                      sizeof(prasconnaTmp->szDeviceType));

                    strncpyWtoAAnsi(
                      prasconnaTmp->szDeviceName,
                      prasconnwTmp->szDeviceName,
                      sizeof(prasconnaTmp->szDeviceName));

                    strncpyWtoAAnsi(
                      prasconnaTmp->szPhonebook,
                      prasconnwTmp->szPhonebook,
                      sizeof(prasconnaTmp->szPhonebook));

                    prasconnaTmp->dwSubEntry =
                            prasconnwTmp->dwSubEntry;

                    memcpy(&prasconnaTmp->guidEntry,
                           &prasconnwTmp->guidEntry,
                           sizeof(GUID));

                    prasconnaTmp->dwFlags = prasconnwTmp->dwFlags;
                    CopyMemory(&prasconnaTmp->luid, &prasconnwTmp->luid,
                                sizeof(LUID));

                }
                else if (fV500)
                {
                    RASCONNA_V500* prasconnaTmp = &((RASCONNA_V500 *)
                                                        lprasconn)[i];

                    prasconnaTmp->dwSize = sizeof(RASCONNA_V500);

                    prasconnaTmp->hrasconn =
                            prasconnwTmp->hrasconn;

                    strncpyWtoAAnsi(
                      prasconnaTmp->szEntryName,
                      prasconnwTmp->szEntryName,
                      sizeof(prasconnaTmp->szEntryName));

                    strncpyWtoAAnsi(
                      prasconnaTmp->szDeviceType,
                      prasconnwTmp->szDeviceType,
                      sizeof(prasconnaTmp->szDeviceType));

                    strncpyWtoAAnsi(
                      prasconnaTmp->szDeviceName,
                      prasconnwTmp->szDeviceName,
                      sizeof(prasconnaTmp->szDeviceName));

                    strncpyWtoAAnsi(
                      prasconnaTmp->szPhonebook,
                      prasconnwTmp->szPhonebook,
                      sizeof(prasconnaTmp->szPhonebook));

                    prasconnaTmp->dwSubEntry =
                            prasconnwTmp->dwSubEntry;

                    memcpy(&prasconnaTmp->guidEntry,
                           &prasconnwTmp->guidEntry,
                           sizeof(GUID));
                }

                else if (fV401)
                {
                    RASCONNA_V401 *prasconnaTmp = &((RASCONNA_V401 *)
                                                    lprasconn)[i];

                    prasconnaTmp->dwSize = sizeof(RASCONNA_V401);

                    prasconnaTmp->hrasconn =
                            prasconnwTmp->hrasconn;

                    strncpyWtoAAnsi(
                      prasconnaTmp->szEntryName,
                      prasconnwTmp->szEntryName,
                      sizeof(prasconnaTmp->szEntryName));

                    strncpyWtoAAnsi(
                      prasconnaTmp->szDeviceType,
                      prasconnwTmp->szDeviceType,
                      sizeof(prasconnaTmp->szDeviceType));

                    strncpyWtoAAnsi(
                      prasconnaTmp->szDeviceName,
                      prasconnwTmp->szDeviceName,
                      sizeof(prasconnaTmp->szDeviceName));

                    strncpyWtoAAnsi(
                      prasconnaTmp->szPhonebook,
                      prasconnwTmp->szPhonebook,
                      sizeof(prasconnaTmp->szPhonebook));

                    prasconnaTmp->dwSubEntry =
                            prasconnwTmp->dwSubEntry;

                }
                else
                {
                    RASCONNA_V400* prasconnaTmp =
                            &((RASCONNA_V400* )lprasconn)[i];

                    prasconnaTmp->dwSize = sizeof(RASCONNA_V400);

                    prasconnaTmp->hrasconn = prasconnwTmp->hrasconn;

                    strncpyWtoAAnsi(
                      prasconnaTmp->szEntryName,
                      prasconnwTmp->szEntryName,
                      sizeof(prasconnaTmp->szEntryName));

                    strncpyWtoAAnsi(
                      prasconnaTmp->szDeviceType,
                      prasconnwTmp->szDeviceType,
                      sizeof(prasconnaTmp->szDeviceType));

                    strncpyWtoAAnsi(
                      prasconnaTmp->szDeviceName,
                      prasconnwTmp->szDeviceName,
                      sizeof(prasconnaTmp->szDeviceName));
                }
            }
        }

        if (prasconnw)
        {
            Free( prasconnw );
        }
    }

    //
    // In all cases, *lpcb should be updated
    // with the correct size.
    //
    *lpcb = *lpcConnections * lprasconn->dwSize;

    return dwErr;
}


DWORD APIENTRY
RasEnumEntriesW(
    IN     LPCWSTR         reserved,
    IN     LPCWSTR         lpszPhonebookPath,
    OUT    LPRASENTRYNAMEW lprasentryname,
    IN OUT LPDWORD         lpcb,
    OUT    LPDWORD         lpcEntries )

/*++

Routine Description:

    Enumerates all entries in the phone book.  'reserved'
    will eventually contain the name or path to the address
    book.  For now, it should always be NULL.  'lpszPhonebookPath'
    is the full path to the phone book file, or NULL, indicating
    that the default phonebook on the local machine should be
    used.  'lprasentryname' is caller's buffer to receive the
    array of RASENTRYNAME structures.  'lpcb' is the size in
    bytes of caller's buffer on entry and the size in bytes
    required for all information on exit.  '*lpcEntries'
    is set to the number of elements in the returned array.

Arguments:

Return Value:

    Returns 0 if successful, otherwise a non-0 error code.

--*/

{
    DWORD    dwErr = ERROR_SUCCESS;
    PBFILE   pbfile;
    DTLNODE  *dtlnode;
    PBENTRY  *pEntry;
    DWORD    dwInBufSize;
    BOOL     fV351;
    BOOL     fStatus;
    DWORD    cEntries;
    DWORD    dwSize;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    RASAPI32_TRACE("RasEnumEntriesW");

    if (reserved)
    {
        return ERROR_NOT_SUPPORTED;
    }

    if (!lpcb)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (    !lprasentryname
        || (    lprasentryname->dwSize
                != sizeof(RASENTRYNAMEW)
            &&  lprasentryname->dwSize
                != sizeof(RASENTRYNAMEW_V401)
            &&  lprasentryname->dwSize
                != sizeof(RASENTRYNAMEW_V351)))
    {
        return ERROR_INVALID_SIZE;
    }

    if (!lpcEntries)
    {
        lpcEntries = &cEntries;
    }

    dwSize = lprasentryname->dwSize;

    if(lpszPhonebookPath)
    {
        dwErr = DwEnumEntriesFromPhonebook(
                                lpszPhonebookPath,
                                (LPBYTE) lprasentryname,
                                lpcb,
                                lpcEntries,
                                dwSize,
                                (IsPublicPhonebook(
                                    (LPTSTR) lpszPhonebookPath))
                                ? REN_AllUsers
                                : REN_User,
                                FALSE);
        goto done;
    }
    else
    {
        LPRASENTRYNAMEW lpRenName = lprasentryname;
        DWORD dwcb = *lpcb;
        DWORD dwcEntries;
        DWORD dwcbLeft = *lpcb;

        DWORD dwErrSav = SUCCESS;

        *lpcb = 0;
        *lpcEntries = 0;

        //
        // Enumerate entries from all pbk files in
        // All Users
        //
        dwErr = DwEnumEntriesForPbkMode(REN_AllUsers,
                                        (LPBYTE) lprasentryname,
                                        &dwcb,
                                        &dwcEntries,
                                        dwSize,
                                        FALSE);

        if(     dwErr
            &&  ERROR_BUFFER_TOO_SMALL != dwErr)
        {
            goto done;
        }

        if(ERROR_BUFFER_TOO_SMALL == dwErr)
        {
            dwErrSav = dwErr;
            dwcbLeft = 0;
        }
        else
        {
            (BYTE*)lprasentryname += (dwcEntries * dwSize);
            dwcbLeft -= ((dwcbLeft >= dwcb) ? dwcb : 0);
        }

        *lpcb += dwcb;
        dwcb = dwcbLeft;

        if(lpcEntries)
        {
            *lpcEntries = dwcEntries;
        }

        dwcEntries = 0;

        //
        // Enumerate entries from all pbk files in
        // users profile
        //
        dwErr = DwEnumEntriesForPbkMode(REN_User,
                                        (LPBYTE) lprasentryname,
                                        &dwcb,
                                        &dwcEntries,
                                        dwSize,
                                        FALSE);
        if(     dwErr
            &&  ERROR_BUFFER_TOO_SMALL != dwErr)
        {
            goto done;
        }
        else if (SUCCESS == dwErr)
        {
            dwErr = dwErrSav;
        }

        *lpcb += dwcb;

        if(lpcEntries)
        {
            *lpcEntries += dwcEntries;
        }
    }

done:
    return dwErr;
}


DWORD APIENTRY
RasEnumEntriesA(
    IN     LPCSTR         reserved,
    IN     LPCSTR         lpszPhonebookPath,
    OUT    LPRASENTRYNAMEA lprasentryname,
    IN OUT LPDWORD        lpcb,
    OUT    LPDWORD        lpcEntries )
{
    DWORD          dwErr;
    WCHAR          szPhonebookW[MAX_PATH];
    NTSTATUS       ntstatus;
    DWORD          cEntries = 0;
    DWORD          cb;

    UNREFERENCED_PARAMETER(reserved);

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    //
    // Verify caller's buffer version.
    //
    if (    !lprasentryname
        || (    lprasentryname->dwSize
                != sizeof(RASENTRYNAMEA)
            &&  lprasentryname->dwSize
                != sizeof(RASENTRYNAMEA_V401)
            &&  lprasentryname->dwSize
                != sizeof(RASENTRYNAMEA_V351)))
    {
        return ERROR_INVALID_SIZE;
    }

    if (reserved)
    {
        return ERROR_NOT_SUPPORTED;
    }

    if (!lpcb)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (!lpcEntries)
    {
        lpcEntries = &cEntries;
    }

    //
    // Make Unicode version of caller's string argument.
    //
    if (lpszPhonebookPath != NULL)
    {
        strncpyAtoWAnsi(szPhonebookW,
                    lpszPhonebookPath,
                    MAX_PATH);
    }

    if (lprasentryname->dwSize == sizeof(RASENTRYNAMEA_V351))
    {
        RASENTRYNAMEW_V351* prasentrynamew = NULL;

        //
        // Allocate Unicode buffer big enough to hold the
        // same number of entries as caller's Ansi buffer.
        //
        cb =  (*lpcb  / sizeof(RASENTRYNAMEA_V351))
            * sizeof(RASENTRYNAMEW_V351);

        prasentrynamew =
            (RASENTRYNAMEW_V351* )Malloc(
                            (UINT )(cb + sizeof(DWORD))
                            );

        if (!prasentrynamew)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        prasentrynamew->dwSize = sizeof(RASENTRYNAMEW_V351);

        //
        // Call the Unicode version to do all the work.
        //
        dwErr = RasEnumEntriesW(
            NULL,
            lpszPhonebookPath != NULL ? szPhonebookW : NULL,
            (RASENTRYNAMEW* )prasentrynamew, &cb, lpcEntries );

        //
        // Copy results to caller's unicode buffer.
        //
        if (dwErr == 0)
        {
            DWORD i;

            for (i = 0; i < *lpcEntries; ++i)
            {
                RASENTRYNAMEW_V351* prasentrynamewTmp =
                                        &prasentrynamew[i];

                RASENTRYNAMEA_V351* prasentrynameaTmp =
                    &((RASENTRYNAMEA_V351* )lprasentryname)[i];

                prasentrynameaTmp->dwSize =
                                sizeof(RASENTRYNAMEA_V351);

                strncpyWtoAAnsi(
                  prasentrynameaTmp->szEntryName,
                  prasentrynamewTmp->szEntryName,
                  sizeof(prasentrynameaTmp->szEntryName));
            }
        }

        if (prasentrynamew)
        {
            Free( prasentrynamew );
        }
    }
    else
    {
        RASENTRYNAMEW* prasentrynamew = NULL;

        //
        // Allocate Unicode buffer big enough to hold the
        // same number of entries as caller's Ansi buffer.
        //
        if(lprasentryname->dwSize == sizeof(RASENTRYNAMEA))
        {
            cb =  (*lpcb  / sizeof(RASENTRYNAMEA))
                * sizeof(RASENTRYNAMEW);
        }
        else
        {
            cb =  (*lpcb / sizeof(RASENTRYNAMEA_V401))
                * sizeof(RASENTRYNAMEW_V401);
        }

        prasentrynamew =
            (RASENTRYNAMEW* )Malloc(
                        (UINT )(cb + sizeof(DWORD))
                        );

        if (!prasentrynamew)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        if(lprasentryname->dwSize == sizeof(RASENTRYNAMEA))
        {
            prasentrynamew->dwSize = sizeof(RASENTRYNAMEW);
        }
        else
        {
            prasentrynamew->dwSize =
                            sizeof(RASENTRYNAMEW_V401);
        }

        //
        // Call the Unicode version to do all the work.
        //
        dwErr = RasEnumEntriesW(
            NULL,
            lpszPhonebookPath != NULL ? szPhonebookW : NULL,
            prasentrynamew, &cb, lpcEntries );

        //
        // Copy results to caller's Ansi buffer.
        //
        if (dwErr == 0)
        {
            DWORD i;
            DWORD dwSize = lprasentryname->dwSize;
            LPBYTE lpBufA = (LPBYTE) lprasentryname;
            LPBYTE lpBufW = (LPBYTE) prasentrynamew;

            for (i = 0; i < *lpcEntries; ++i)
            {
                if(sizeof(RASENTRYNAMEA_V401) == dwSize)
                {
                    ((RASENTRYNAMEA_V401 *) lpBufA)->dwSize =
                                      sizeof(RASENTRYNAMEA_V401);

                    strncpyWtoAAnsi(
                      ((RASENTRYNAMEA_V401 *)lpBufA)->szEntryName,
                      ((RASENTRYNAMEW_V401 *)lpBufW)->szEntryName,
                      sizeof(((RASENTRYNAMEA_V401 *)lpBufA)->szEntryName));

                      lpBufA += sizeof(RASENTRYNAMEA_V401);
                      lpBufW += sizeof(RASENTRYNAMEW_V401);
                }
                else
                {
                    ((RASENTRYNAMEA *) lpBufA)->dwSize =
                                      sizeof(RASENTRYNAMEA);

                    strncpyWtoAAnsi(
                      ((RASENTRYNAMEA *)lpBufA)->szEntryName,
                      ((RASENTRYNAMEW *)lpBufW)->szEntryName,
                      sizeof(((RASENTRYNAMEA *)lpBufA)->szEntryName));

                    //
                    // if this is nt5 copy the phonebook name
                    // and the flags
                    //
                    strncpyWtoAAnsi(
                        ((RASENTRYNAMEA *)lpBufA)->szPhonebookPath,
                        ((RASENTRYNAMEW *)lpBufW)->szPhonebookPath,
                        sizeof(((RASENTRYNAMEA *)lpBufA)->szPhonebookPath));

                    ((RASENTRYNAMEA *)lpBufA)->dwFlags
                            = ((RASENTRYNAMEW *)lpBufW)->dwFlags;

                    lpBufA += sizeof(RASENTRYNAMEA);
                    lpBufW += sizeof(RASENTRYNAMEW);

                }
            }
        }

        if (prasentrynamew)
        {
            Free( prasentrynamew );
        }
    }

    //
    // In all cases, *lpcb should be updated
    // with the correct size.
    //
    *lpcb = *lpcEntries * lprasentryname->dwSize;

    return dwErr;
}


DWORD APIENTRY
RasGetConnectStatusW(
    IN  HRASCONN         hrasconn,
    OUT LPRASCONNSTATUSW lprasconnstatus )

/*++

Routine Description:

    Reports the current status of the connection
    associated with handle 'hrasconn', returning
    the information in caller's 'lprasconnstatus'
    buffer.

Arguments:

Return Value:

    Returns 0 if successful, otherwise a non-0
    error code.

--*/
{
    DWORD       dwErr, dwSize;
    DWORD       i, dwcbPorts = 0, dwcPorts = 0;
    RASMAN_PORT *lpPorts;
    RASMAN_INFO info;
    RASCONNCB   *prasconncb;
    HPORT       hport;
    BOOL        fV351;
    BOOL        fV400;
    BOOL        fFound;
    WCHAR        szDeviceType[RAS_MaxDeviceType + 1];
    WCHAR        szDeviceName[RAS_MaxDeviceName + 1];
    DWORD       dwSubEntry;
    BOOL        fPort;
    TCHAR*      pszDeviceType = NULL;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    RASAPI32_TRACE("RasGetConnectStatusW");

    dwErr = LoadRasmanDllAndInit();

    if (dwErr)
    {
        return dwErr;
    }

    if (DwRasInitializeError != 0)
    {
        return DwRasInitializeError;
    }

    if (    !lprasconnstatus
        || (    lprasconnstatus->dwSize
                != sizeof(RASCONNSTATUSW)
            &&  lprasconnstatus->dwSize
                != sizeof(RASCONNSTATUSW_V351)
            &&  lprasconnstatus->dwSize
                != sizeof(RASCONNSTATUSW_V400)))
    {
        return ERROR_INVALID_SIZE;
    }
    if (hrasconn == 0)
    {
        return ERROR_INVALID_HANDLE;
    }

    fV351 = (lprasconnstatus->dwSize ==
            sizeof(RASCONNSTATUSW_V351));

    fV400 = (lprasconnstatus->dwSize ==
             sizeof(RASCONNSTATUSW_V400));

    //
    // Get the subentry index encoded in the
    // connection handle, if any.
    //
    // If fPort is TRUE, then we always return
    // 0, setting a RASCS_Disconnected state
    // upon error.
    //
    fPort = IS_HPORT(hrasconn);

    dwSubEntry = SubEntryFromConnection(&hrasconn);

    if (!dwSubEntry)
    {
        return ERROR_INVALID_HANDLE;
    }

    //
    // Get the list of ports in this
    // connection from rasman.
    //
    dwErr = g_pRasEnumConnectionPorts(
              NULL,
              (HCONN)hrasconn,
              NULL,
              &dwcbPorts,
              &dwcPorts);

    if (    dwErr != ERROR_BUFFER_TOO_SMALL
        ||  !dwcPorts)
    {
        if (fPort)
        {
            goto discon;
        }

        return ERROR_INVALID_HANDLE;
    }

    lpPorts = Malloc(dwcbPorts);

    if (lpPorts == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    dwErr = g_pRasEnumConnectionPorts(
              NULL,
              (HCONN)hrasconn,
              lpPorts,
              &dwcbPorts,
              &dwcPorts);

    if (dwErr)
    {
        Free(lpPorts);

        if (fPort)
        {
            goto discon;
        }

        return ERROR_INVALID_HANDLE;
    }

    //
    // Get the device type and name
    // associated with the subentry.
    //
    fFound = FALSE;
    for (i = 0; i < dwcPorts; i++)
    {
        dwErr = g_pRasGetInfo(NULL,
                              lpPorts[i].P_Handle,
                              &info);

        if (dwErr || info.RI_SubEntry != dwSubEntry)
        {
            continue;
        }

        fFound = TRUE;

        hport = lpPorts[i].P_Handle;

        pszDeviceType = pszDeviceTypeFromRdt(lpPorts->P_rdtDeviceType);

        if(NULL == pszDeviceType)
        {
            //
            // default to modem
            //
            wcscpy(szDeviceType, TEXT("modem"));
        }
        else
        {
            lstrcpyn(
                szDeviceType,
                pszDeviceType,
                sizeof(szDeviceType) / sizeof(WCHAR));

            Free(pszDeviceType);
        }

        RasGetUnicodeDeviceName(lpPorts[i].P_Handle, szDeviceName);
        
        break;
    }
    Free(lpPorts);

    //
    // If the port is not found in the connection,
    // then it must be disconnected.
    //
    if (!fFound)
    {
discon:
        RASAPI32_TRACE("RasGetConnectStatus: subentry not found");
        lprasconnstatus->rasconnstate = RASCS_Disconnected;
        lprasconnstatus->dwError = 0;
        return 0;
    }

    //
    // Get the connection state and error
    // associated with the subentry.
    //
    dwSize = sizeof (lprasconnstatus->rasconnstate);
    dwErr = g_pRasGetPortUserData(
              hport,
              PORT_CONNSTATE_INDEX,
              (PBYTE)&lprasconnstatus->rasconnstate,
              &dwSize);

    if (dwErr)
    {
        return dwErr;
    }

    //
    // If the port is disconnected, then we have
    // to determine whether the connection is
    // waiting for callback.
    //
    if (    info.RI_ConnState == DISCONNECTED

        &&  lprasconnstatus->rasconnstate
            < RASCS_PrepareForCallback

        &&  lprasconnstatus->rasconnstate
            > RASCS_WaitForCallback)
    {
        lprasconnstatus->rasconnstate = RASCS_Disconnected;
    }

    dwSize = sizeof (lprasconnstatus->dwError);
    dwErr = g_pRasGetPortUserData(
              hport,
              PORT_CONNERROR_INDEX,
              (PBYTE)&lprasconnstatus->dwError,
              &dwSize);

    if (dwErr)
    {
        return dwErr;
    }

    //
    // Report RasDial connection states, but notice special
    // case where the line has disconnected since connecting.
    //
    // Note: Assumption is made here that the V351 structure
    // is a subset of the V40 structure with extra bytes
    // added to the last field in V40, i.e. szDeviceName.
    //
    if (    lprasconnstatus->rasconnstate == RASCS_Connected
        &&  info.RI_ConnState == DISCONNECTED)
    {
        lprasconnstatus->rasconnstate = RASCS_Disconnected;

        lprasconnstatus->dwError =
            ErrorFromDisconnectReason( info.RI_DisconnectReason );
    }

    //
    // If both the info.RI_Device*Connecting values are
    // valid, then we use those, otherwise we use the
    // info.P_Device* values we retrieved above.
    //
    if (lprasconnstatus->rasconnstate < RASCS_Connected)
    {
        DWORD dwTypeSize, dwNameSize;

        dwTypeSize = sizeof (szDeviceType);
        dwNameSize = sizeof (szDeviceName);
        szDeviceType[0] = szDeviceName[0] = L'\0';

        if (    !g_pRasGetPortUserData(
                    hport,
                    PORT_DEVICETYPE_INDEX,
                    (PCHAR)szDeviceType,
                    &dwTypeSize)
            &&
                !g_pRasGetPortUserData(
                    hport,
                    PORT_DEVICENAME_INDEX,
                    (PCHAR)szDeviceName,
                    &dwNameSize)

            &&    wcslen(szDeviceType)
            &&    wcslen(szDeviceName))
        {
            RASAPI32_TRACE2(
              "RasGetConnectStatus: read device (%S,%S) "
              "from port user data",
              szDeviceType,
              szDeviceName);
        }
    }

    //
    // For pptp connections, there are no intermediate
    // device types
    //
    else if (   strlen(info.RI_DeviceConnecting)

            &&  strlen(info.RI_DeviceTypeConnecting)

            &&  (RDT_X25 == RAS_DEVICE_CLASS(info.RI_rdtDeviceType)))
    {
        strncpyAtoW(szDeviceType,
                   info.RI_DeviceTypeConnecting,
                   sizeof(szDeviceType) / sizeof(WCHAR));

        strncpyAtoW(szDeviceName,
                   info.RI_DeviceConnecting,
                   sizeof(szDeviceName) / sizeof(WCHAR));
    }

    //
    // Don't overwrite the devicename if its a switch.
    // In the case of a switch the devicename is actually
    // the name of script file.
    //
    if(CaseInsensitiveMatch(szDeviceType, L"switch") == FALSE)
    {
        RasGetUnicodeDeviceName(hport, szDeviceName);
    }

    if (fV351)
    {
        memset(
          lprasconnstatus->szDeviceName,
          '\0',
          RAS_MaxDeviceName_V351 * sizeof (WCHAR) );

        wcsncpy(
          lprasconnstatus->szDeviceName,
          szDeviceName,
          RAS_MaxDeviceName_V351);
    }
    else
    {
        lstrcpyn(lprasconnstatus->szDeviceName,
                 szDeviceName,
                 sizeof(lprasconnstatus->szDeviceName) / sizeof(WCHAR));
    }

    lstrcpyn(lprasconnstatus->szDeviceType,
             szDeviceType,
             sizeof(lprasconnstatus->szDeviceType) / sizeof(WCHAR));

    //
    // Copy the phone number for the V401
    // version of the structure.
    //
    if (    !fV351
        &&  !fV400)
    {
        dwSize = sizeof (lprasconnstatus->szPhoneNumber);

        *lprasconnstatus->szPhoneNumber = L'\0';

        if (!g_pRasGetPortUserData(
              hport,
              PORT_PHONENUMBER_INDEX,
              (PCHAR)lprasconnstatus->szPhoneNumber,
              &dwSize))
        {
            RASAPI32_TRACE1(
              "RasGetConnectStatus: read phonenumber "
              "%S from port user data",
              lprasconnstatus->szPhoneNumber);
        }
    }

    return 0;
}


DWORD APIENTRY
RasGetConnectStatusA(
    IN  HRASCONN         hrasconn,
    OUT LPRASCONNSTATUSA lprcss )
{
    RASCONNSTATUSW rcsw;
    DWORD          dwErr;
    BOOL           fV351;
    BOOL           fV400;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    //
    // Verify caller's buffer version.
    //
    if (    !lprcss
        ||  (   lprcss->dwSize != sizeof(RASCONNSTATUSA)
            &&  lprcss->dwSize != sizeof(RASCONNSTATUSA_V351)
            &&  lprcss->dwSize != sizeof(RASCONNSTATUSA_V400)))
    {
        return ERROR_INVALID_SIZE;
    }

    fV351 = (lprcss->dwSize == sizeof(RASCONNSTATUSA_V351));
    fV400 = (lprcss->dwSize == sizeof(RASCONNSTATUSA_V400));

    ZeroMemory(&rcsw, sizeof(RASCONNSTATUSW));

    rcsw.dwSize = sizeof(RASCONNSTATUSW);

    //
    // Call the ANSI version to do all the work.
    //
    dwErr = RasGetConnectStatusW( hrasconn, &rcsw );

    if (dwErr != 0)
    {
        return dwErr;
    }

    //
    // Copy results to caller's unicode buffer.
    //
    lprcss->rasconnstate = rcsw.rasconnstate;
    lprcss->dwError = rcsw.dwError;

    strncpyWtoA(
        lprcss->szDeviceType,
        rcsw.szDeviceType,
        sizeof(lprcss->szDeviceType));

    if (fV351)
    {
        RASCONNSTATUSA_V351 *prcss = (RASCONNSTATUSA_V351 *)lprcss;

        strncpyWtoAAnsi(
            prcss->szDeviceName,
            rcsw.szDeviceName,
            sizeof(prcss->szDeviceName));
    }
    else
    {
        strncpyWtoAAnsi(
            lprcss->szDeviceName,
            rcsw.szDeviceName,
            sizeof(lprcss->szDeviceName));
    }

    if (dwErr)
    {
        return dwErr;
    }

    if (    !fV351
        &&  !fV400)
    {
        strncpyWtoAAnsi(
            lprcss->szPhoneNumber,
            rcsw.szPhoneNumber,
            sizeof(lprcss->szPhoneNumber));
    }

    return 0;
}


DWORD APIENTRY
RasGetEntryHrasconnW(
    IN  LPCWSTR             pszPhonebook,
    IN  LPCWSTR             pszEntry,
    OUT LPHRASCONN          lphrasconn )

/*++

Routine Description:

    Retrieves the current 'HRASCONN' of the connection
    identified by 'pszPhonebook' and 'pszEntry', if connected.

Arguments:

Return Value:

    Returns 0 if successful, otherwise a non-0
    error code.

--*/

{
    DWORD dwErr;
    HRASCONN hrasconn;
    CHAR szPhonebookA[MAX_PATH],
         szEntryNameA[RAS_MaxEntryName + 1];

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    RASAPI32_TRACE("RasGetEntryHrasconn");

    //
    // Verify parameters
    //
    if (!pszEntry || !lphrasconn)
    {
        return ERROR_INVALID_PARAMETER;
    }

    dwErr = LoadRasmanDllAndInit();

    if (dwErr)
    {
        return dwErr;
    }

    if (DwRasInitializeError != 0)
    {
        return DwRasInitializeError;
    }

    //
    // Convert the pszPhonebook string to ANSI.
    //
    if (pszPhonebook)
    {
        strncpyWtoA(szPhonebookA, pszPhonebook, MAX_PATH);
    }
    else
    {
        TCHAR* pszPath;

        if (!GetDefaultPhonebookPath(0, &pszPath))
        {
            return ERROR_CANNOT_OPEN_PHONEBOOK;
        }

        strncpyTtoA(szPhonebookA, pszPath, MAX_PATH);
        Free(pszPath);
    }

    //
    // Convert the lpszEntry string to ANSI.
    //
    strncpyWtoA(szEntryNameA, pszEntry, RAS_MaxEntryName + 1);

    //
    // Map the phonebook entry to an hrasconn, if possible.
    //
    dwErr = g_pRasGetHConnFromEntry(
                (HCONN*)lphrasconn,
                szPhonebookA,
                szEntryNameA
                );
    return dwErr;
}


DWORD APIENTRY
RasGetEntryHrasconnA(
    IN  LPCSTR              pszPhonebook,
    IN  LPCSTR              pszEntry,
    OUT LPHRASCONN          lphrasconn )

/*++

Routine Description:

    Retrieves the current 'HRASCONN' of the connection
    identified by 'pszPhonebook' and 'pszEntry', if connected.

Arguments:

Return Value:

    Returns 0 if successful, otherwise a non-0
    error code.

--*/

{
    DWORD dwErr;
    HRASCONN hrasconn;
    CHAR szPhonebookA[MAX_PATH + 1];

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    RASAPI32_TRACE("RasGetEntryConnectStatusA");

    //
    // Verify parameters
    //
    if (!pszEntry || !lphrasconn)
    {
        return ERROR_INVALID_PARAMETER;
    }

    dwErr = LoadRasmanDllAndInit();

    if (dwErr)
    {
        return dwErr;
    }

    if (DwRasInitializeError != 0)
    {
        return DwRasInitializeError;
    }

    //
    // Construct the phonebook path, if necessary
    //
    if (pszPhonebook)
    {
        strncpy(szPhonebookA, pszPhonebook, MAX_PATH);
    }
    else
    {
        TCHAR* pszPath;

        if (!GetDefaultPhonebookPath(0, &pszPath))
        {
            return ERROR_CANNOT_OPEN_PHONEBOOK;
        }

        strncpyTtoA(szPhonebookA, pszPath, MAX_PATH);
        Free(pszPath);
    }

    //
    // Map the phonebook entry to an hrasconn, if possible.
    //
    dwErr = g_pRasGetHConnFromEntry(
                (HCONN*)lphrasconn,
                szPhonebookA,
                (CHAR*)pszEntry
                );
    return dwErr;
}


VOID APIENTRY
RasGetConnectResponse(
    IN  HRASCONN hrasconn,
    OUT CHAR*    pszConnectResponse )

/*++

Routine Description:

    Loads caller's '*pszConnectResponse' buffer with the
    connect response from the attached modem or "" if
    none is available.  Caller's buffer should be at
    least RAS_MaxConnectResponse + 1 bytes long.

Arguments:

Return Value:

--*/
{
    DWORD dwErr,
          dwcbPorts = 0,
          dwcPorts = 0,
          dwSize;

    RASMAN_PORT *lpPorts;
    HPORT hport;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    RASAPI32_TRACE("RasGetConnectResponseA");

    //
    // Initialize return value.
    //
    *pszConnectResponse = '\0';

    dwErr = LoadRasmanDllAndInit();
    if (dwErr)
    {
        return;
    }

    if (DwRasInitializeError != 0)
    {
        return;
    }

    //
    // First, we need to get the first port
    // in the connection.
    //
    if (IS_HPORT(hrasconn))
    {
        hport = HRASCONN_TO_HPORT(hrasconn);
    }
    else
    {
        dwErr = g_pRasEnumConnectionPorts(
                                NULL,
                                (HCONN)hrasconn,
                                NULL,
                                &dwcbPorts,
                                &dwcPorts);

        if (    dwErr != ERROR_BUFFER_TOO_SMALL
            ||  !dwcPorts)
        {
            return;
        }

        lpPorts = Malloc(dwcbPorts);
        if (lpPorts == NULL)
        {
            return;
        }

        dwErr = g_pRasEnumConnectionPorts(
                                NULL,
                                (HCONN)hrasconn,
                                lpPorts,
                                &dwcbPorts,
                                &dwcPorts);

        if (    dwErr
            ||  !dwcPorts)
        {
            Free(lpPorts);
            return;
        }

        hport = lpPorts[0].P_Handle;
        Free(lpPorts);
    }

    //
    // Next, read the connection response for the port.
    //
    dwSize = RAS_MaxConnectResponse + 1;

    dwErr = g_pRasGetPortUserData(
              hport,
              PORT_CONNRESPONSE_INDEX,
              pszConnectResponse,
              &dwSize);

    if (dwErr)
    {
        *pszConnectResponse = '\0';
    }
}


DWORD APIENTRY
RasGetEntryDialParamsA(
    IN  LPCSTR           lpszPhonebook,
    OUT LPRASDIALPARAMSA lprasdialparams,
    OUT LPBOOL           lpfPassword )

/*++

Routine Description:
    Retrieves cached RASDIALPARAM information.

Arguments:

Return Value:
    Returns 0 if successful, otherwise a non-0 error code.

--*/
{
    NTSTATUS status;
    DWORD dwErr, dwcb;
    RASDIALPARAMSW rasdialparamsW;
    WCHAR szPhonebookW[MAX_PATH];

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    //
    // Verify parameters.
    //
    if (    lprasdialparams == NULL
        ||  lpfPassword == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (    lprasdialparams->dwSize != sizeof (RASDIALPARAMSA)
        &&  lprasdialparams->dwSize != sizeof (RASDIALPARAMSA_V351)
        &&  lprasdialparams->dwSize != sizeof (RASDIALPARAMSA_V400))
    {
        return ERROR_INVALID_SIZE;
    }

    //
    // Convert the lpszPhonebook string to Unicode.
    //
    if (lpszPhonebook != NULL)
    {
        strncpyAtoWAnsi(szPhonebookW,
                    lpszPhonebook,
                    MAX_PATH);
    }

    //
    // Copy the entry name from the user's A buffer into
    // the W buffer, taking into account the version
    // of the structure the user passed in.
    //
    rasdialparamsW.dwSize = sizeof (RASDIALPARAMSW);

    if (lprasdialparams->dwSize ==
                        sizeof (RASDIALPARAMSA_V351))
    {
        RASDIALPARAMSA_V351 *prdp =
                (RASDIALPARAMSA_V351 *)lprasdialparams;

        strncpyAtoWAnsi(rasdialparamsW.szEntryName,
                   prdp->szEntryName,
                   sizeof(rasdialparamsW.szEntryName) / sizeof(WCHAR));
    }
    else
    {
        strncpyAtoWAnsi(rasdialparamsW.szEntryName,
                   lprasdialparams->szEntryName,
                   sizeof(rasdialparamsW.szEntryName) / sizeof(WCHAR));
    }

    //
    // Call the W version to do the work.
    //
    dwErr = RasGetEntryDialParamsW(
              lpszPhonebook != NULL
              ? szPhonebookW : NULL,
              &rasdialparamsW,
              lpfPassword);
    if (dwErr)
    {
        goto done;
    }

    //
    // Copy over the rest of the fields to the
    // user's A buffer, taking into account the
    // version of the structure the user passed
    // in.
    //
    if (lprasdialparams->dwSize == sizeof (RASDIALPARAMSA_V351))
    {
        RASDIALPARAMSA_V351 *prdp =
                    (RASDIALPARAMSA_V351 *)lprasdialparams;

        WCHAR szBuf[RAS_MaxCallbackNumber_V351 + 1];

        strncpyWtoAAnsi(prdp->szPhoneNumber,
                   rasdialparamsW.szPhoneNumber,
                   sizeof(prdp->szPhoneNumber));

        //
        // The szCallbackNumber field is smaller
        // in the V351 version, therefore the extra
        // copy step.
        //
        wcsncpy(
          szBuf,
          rasdialparamsW.szCallbackNumber,
          RAS_MaxCallbackNumber_V351);

        strncpyWtoAAnsi(
            prdp->szCallbackNumber,
            szBuf,
            sizeof(prdp->szCallbackNumber));

        strncpyWtoAAnsi(prdp->szUserName,
                   rasdialparamsW.szUserName,
                   sizeof(prdp->szUserName));

        strncpyWtoAAnsi(prdp->szPassword,
                   rasdialparamsW.szPassword,
                   sizeof(prdp->szPassword));

        strncpyWtoAAnsi(prdp->szDomain,
                   rasdialparamsW.szDomain,
                   sizeof(prdp->szDomain));
    }
    else
    {
        strncpyWtoAAnsi(lprasdialparams->szPhoneNumber,
                   rasdialparamsW.szPhoneNumber,
                   sizeof(lprasdialparams->szPhoneNumber));

        strncpyWtoAAnsi(lprasdialparams->szCallbackNumber,
                   rasdialparamsW.szCallbackNumber,
                   sizeof(lprasdialparams->szCallbackNumber));

        strncpyWtoAAnsi(lprasdialparams->szUserName,
                   rasdialparamsW.szUserName,
                   sizeof(lprasdialparams->szUserName));

        strncpyWtoAAnsi(lprasdialparams->szPassword,
                   rasdialparamsW.szPassword,
                   sizeof(lprasdialparams->szPassword));

        strncpyWtoAAnsi(lprasdialparams->szDomain,
                   rasdialparamsW.szDomain,
                   sizeof(lprasdialparams->szDomain));

        if (lprasdialparams->dwSize ==
                        sizeof (RASDIALPARAMSA))
        {
            lprasdialparams->dwSubEntry =
                        rasdialparamsW.dwSubEntry;
        }
    }

done:
    return dwErr;
}


DWORD APIENTRY
RasGetEntryDialParamsW(
    IN  LPCWSTR          lpszPhonebook,
    OUT LPRASDIALPARAMSW lprasdialparams,
    OUT LPBOOL           lpfPassword )

/*++

Routine Description:
    Retrieves cached RASDIALPARAM information.

Arguments:

Return Value:
    Returns 0 if successful, otherwise a non-0 error code.

--*/
{
    DWORD dwErr;
    PBFILE pbfile;
    DTLNODE *pdtlnode = NULL;
    PBENTRY *pEntry;
    DWORD dwMask;
    RAS_DIALPARAMS dialparams;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    RASAPI32_TRACE("RasGetEntryDialParamsA");

    dwErr = LoadRasmanDllAndInit();
    if (dwErr)
    {
        return dwErr;
    }

    if (DwRasInitializeError)
    {
        return DwRasInitializeError;
    }

    //
    // Validate parameters.
    //
    if (    lprasdialparams == NULL
        ||  lpfPassword == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (    lprasdialparams->dwSize !=
            sizeof (RASDIALPARAMSW)

        &&  lprasdialparams->dwSize !=
            sizeof (RASDIALPARAMSW_V351)

        &&  lprasdialparams->dwSize !=
            sizeof (RASDIALPARAMSW_V400))
    {
        return ERROR_INVALID_SIZE;
    }

    //
    // Load the phonebook file.
    //
#ifdef PBCS
    EnterCriticalSection(&PhonebookLock);
#endif

    pbfile.hrasfile = -1;

    dwErr = GetPbkAndEntryName(
                lpszPhonebook,
                lprasdialparams->szEntryName,
                RPBF_NoCreate,
                &pbfile,
                &pdtlnode);

    if(SUCCESS != dwErr)
    {
        goto done;
    }

    pEntry = (PBENTRY *)DtlGetData(pdtlnode);
    ASSERT(pEntry);

    //
    // Set the appropriate flags to get all
    // the fields.
    //
    dwMask =    DLPARAMS_MASK_PHONENUMBER
            |   DLPARAMS_MASK_CALLBACKNUMBER
            |   DLPARAMS_MASK_USERNAME
            |   DLPARAMS_MASK_PASSWORD
            |   DLPARAMS_MASK_DOMAIN
            |   DLPARAMS_MASK_SUBENTRY
            |   DLPARAMS_MASK_OLDSTYLE;

    //
    // Get the dial parameters from rasman.
    //
    dwErr = g_pRasGetDialParams(
                pEntry->dwDialParamsUID,
                &dwMask,
                &dialparams);

    if (dwErr)
    {
        return dwErr;
    }

    //
    // Convert from the rasman dialparams
    // to the rasapi32 dialparams, taking
    // into account which version of the
    // structure the user passed in.
    //
    if (lprasdialparams->dwSize ==
        sizeof (RASDIALPARAMSW_V351))
    {
        RASDIALPARAMSW_V351 *prdp =
            (RASDIALPARAMSW_V351 *)lprasdialparams;

        lstrcpyn(prdp->szPhoneNumber,
                 dialparams.DP_PhoneNumber,
                 sizeof(prdp->szPhoneNumber) / sizeof(WCHAR));

        wcsncpy(prdp->szCallbackNumber,
                dialparams.DP_CallbackNumber,
                RAS_MaxCallbackNumber_V351);

        lstrcpyn(prdp->szUserName,
                 dialparams.DP_UserName,
                 sizeof(prdp->szUserName) / sizeof(WCHAR));

        lstrcpyn(prdp->szPassword,
                 dialparams.DP_Password,
                 sizeof(prdp->szPassword) / sizeof(WCHAR));

        lstrcpyn(prdp->szDomain,
                 dialparams.DP_Domain,
                 sizeof(prdp->szDomain) / sizeof(WCHAR));
    }
    else
    {
        //
        // V400 and V401 structures only differ by the
        // the addition of the dwSubEntry field, which
        // we test at the end.
        //
        lstrcpyn(lprasdialparams->szPhoneNumber,
                 dialparams.DP_PhoneNumber,
                 sizeof(lprasdialparams->szPhoneNumber) / sizeof(WCHAR));

        lstrcpyn(lprasdialparams->szCallbackNumber,
                 dialparams.DP_CallbackNumber,
                 sizeof(lprasdialparams->szCallbackNumber) / sizeof(WCHAR));

        lstrcpyn(lprasdialparams->szUserName,
                 dialparams.DP_UserName,
                 sizeof(lprasdialparams->szUserName) / sizeof(WCHAR));

        lstrcpyn(lprasdialparams->szPassword,
                 dialparams.DP_Password,
                 sizeof(lprasdialparams->szPassword) / sizeof(WCHAR));

        lstrcpyn(lprasdialparams->szDomain,
                 dialparams.DP_Domain,
                 sizeof(lprasdialparams->szDomain) / sizeof(WCHAR));

        if (lprasdialparams->dwSize ==
                    sizeof (RASDIALPARAMSW))
        {
            lprasdialparams->dwSubEntry =
                        dialparams.DP_SubEntry;
        }
    }

    //
    // If we got the rest of the parameters,
    // then copy the entry name.
    //
    wcsncpy(
      lprasdialparams->szEntryName,
      pEntry->pszEntryName,
      (lprasdialparams->dwSize ==
       sizeof (RASDIALPARAMSW_V351))
       ? RAS_MaxEntryName_V351
       : RAS_MaxEntryName);

    //
    // Set the lpfPassword flag if
    // we successfully retrieved the
    // password.
    //
    *lpfPassword =  (dwMask & DLPARAMS_MASK_PASSWORD)
                    ? TRUE
                    : FALSE;

done:

    //
    // Clean up.
    //
    ClosePhonebookFile(&pbfile);

#ifdef PBCS
    LeaveCriticalSection(&PhonebookLock);
#endif

    return dwErr;
}


DWORD APIENTRY
RasGetErrorStringW(
    IN  UINT  ResourceId,
    OUT LPWSTR lpszString,
    IN  DWORD InBufSize )

/*++

Routine Description:

    Load caller's buffer 'lpszString' of length 'InBufSize'
    with the resource string associated with ID 'ResourceId'.

Arguments:

Return Value:

    Returns 0 if successful, otherwise a non-0 error code.

--*/
{
    DWORD dwErr = 0;
    HINSTANCE hMsgDll;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    if (    (   (  ResourceId < RASBASE
                ||  ResourceId > RASBASEEND)

            &&  (   ResourceId < ROUTEBASE
                ||  ResourceId > ROUTEBASEEND))

        || !lpszString )
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (InBufSize == 1)
    {
        //
        // strange case, but a bug was filed...
        //
        lpszString[ 0 ] = L'\0';

        return ERROR_INSUFFICIENT_BUFFER;
    }

    //
    // Load the error message DLL.
    //
    hMsgDll = LoadLibrary(MSGDLLPATH);
    if (hMsgDll == NULL)
    {
        return GetLastError();
    }

    if (!FormatMessageW(
          FORMAT_MESSAGE_FROM_HMODULE,
          hMsgDll,
          ResourceId,
          0,
          lpszString,
          InBufSize,
          NULL))
    {
       dwErr = GetLastError();
    }

    FreeLibrary(hMsgDll);
    return dwErr;
}


DWORD APIENTRY
RasGetErrorStringA(
    IN  UINT   ResourceId,
    OUT LPSTR lpszString,
    IN  DWORD  InBufSize )

/*++

Routine Description:

    Load caller's buffer 'lpszString' of length
    'InBufSize' with the resource string
    associated with ID 'ResourceId'.

Arguments:

Return Value:

    Returns 0 if successful, otherwise a non-0
    error code.

--*/
{
    DWORD  dwErr = 0;
    HINSTANCE hMsgDll;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    if (    (   (  ResourceId < RASBASE
                ||  ResourceId > RASBASEEND)

            &&  (   ResourceId < ROUTEBASE
                ||  ResourceId > ROUTEBASEEND))

        || !lpszString )
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (InBufSize == 1)
    {
        //
        // strange case, but a bug was filed...
        //
        lpszString[ 0 ] = '\0';
        return ERROR_INSUFFICIENT_BUFFER;
    }

    //
    // Load the error message DLL.
    //
    hMsgDll = LoadLibrary(MSGDLLPATH);
    if (hMsgDll == NULL)
    {
        return GetLastError();
    }

    if (!FormatMessageA(
          FORMAT_MESSAGE_FROM_HMODULE,
          hMsgDll,
          ResourceId,
          0,
          lpszString,
          InBufSize,
          NULL))
    {
       dwErr = GetLastError();
    }

    return dwErr;
}


HPORT APIENTRY
RasGetHport(
    IN HRASCONN hrasconn )

/*++

Routine Description:

Arguments:

Return value

    Return the HPORT associated with the 'hrasconn'
    or INVALID_HANDLE_VALUE on error.

--*/
{
    DWORD dwErr, dwcbPorts = 0, dwcPorts = 0;
    RASMAN_PORT *lpPorts;
    HPORT hport;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    RASAPI32_TRACE("RasGetHport");

    dwErr = LoadRasmanDllAndInit();
    if (dwErr)
    {
        return INVALID_HPORT;
    }

    if (DwRasInitializeError)
    {
        return INVALID_HPORT;
    }

    if (IS_HPORT(hrasconn))
    {
        hport = HRASCONN_TO_HPORT(hrasconn);
    }
    else
    {
        //
        // Get the list of ports from rasman
        // and get the handle of the 0th port.
        //
        dwErr = g_pRasEnumConnectionPorts(
                  NULL,
                  (HCONN)hrasconn,
                  NULL,
                  &dwcbPorts,
                  &dwcPorts);

        if (    dwErr != ERROR_BUFFER_TOO_SMALL
            ||  !dwcPorts)
        {
            return INVALID_HPORT;
        }

        lpPorts = Malloc(dwcbPorts);
        if (lpPorts == NULL)
        {
            return INVALID_HPORT;
        }

        dwErr = g_pRasEnumConnectionPorts(
                  NULL,
                  (HCONN)hrasconn,
                  lpPorts,
                  &dwcbPorts,
                  &dwcPorts);

        if (    dwErr
            ||  !dwcPorts)
        {
            hport = INVALID_HPORT;
        }
        else
        {
            hport = lpPorts[0].P_Handle;
        }

        Free(lpPorts);
    }

    return hport;
}

DWORD 
DwGetReplyMessage(HRASCONN hrasconn,
                  WCHAR *pszReplyMessage,
                  DWORD cbBuf)
{
    DWORD dwErr;
    DWORD dwReplySize = 0;
    BYTE *pbReply = NULL;

    ASSERT(NULL != pszReplyMessage);

    pszReplyMessage[0] = L'\0';

    dwErr = g_pRasGetConnectionUserData(
              (HCONN)hrasconn,
              CONNECTION_PPPREPLYMESSAGE_INDEX,
              pbReply,
              &dwReplySize);

    if(     (ERROR_BUFFER_TOO_SMALL != dwErr)
        ||  (dwReplySize > cbBuf))
    {
        if(dwReplySize > cbBuf)
        {
            ERROR_BUFFER_TOO_SMALL;
        }
        
        goto done;
    }

    pbReply = LocalAlloc(LPTR,
                         dwReplySize);

    if(NULL == pbReply)
    {
        dwErr = GetLastError();
        goto done;
    }

    dwErr = g_pRasGetConnectionUserData(
                (HCONN) hrasconn,
                CONNECTION_PPPREPLYMESSAGE_INDEX,
                pbReply,
                &dwReplySize);

    if(SUCCESS != dwErr)
    {
        goto done;
    }

    //
    // convert the ansi string to unicode and return
    //
    strncpyAtoWAnsi(pszReplyMessage, (CHAR *) pbReply, cbBuf);

done:

    if(NULL != pbReply)
    {
        LocalFree(pbReply);
    }

    return dwErr;
    
}


DWORD APIENTRY
RasGetProjectionInfoW(
    HRASCONN        hrasconn,
    RASPROJECTION   rasprojection,
    LPVOID          lpprojection,
    LPDWORD         lpcb )

/*++

Routine Description:

    Loads caller's buffer '*lpprojection' with the
    data structure corresponding to the protocol
    'rasprojection' on 'hrasconn'.  On entry '*lpcp'
    indicates the size of caller's buffer.  On exit
    it contains the size of buffer required to hold
    all projection information.

Arguments:

Return Value:
    Returns 0 if successful, otherwise a non-zero
    error code.

--*/
{
    DWORD dwErr, dwSubEntry;

    DWORD dwPppSize, dwAmbSize, dwSlipSize;

    NETBIOS_PROJECTION_RESULT ambProj;

    PPP_PROJECTION_RESULT pppProj;

    RASSLIPW slipProj;

    PBYTE pBuf;


    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    RASAPI32_TRACE1("RasGetProjectionInfoW(0x%x)",
           rasprojection);

    dwErr = LoadRasmanDllAndInit();
    if (dwErr)
    {
        return dwErr;
    }

    if (DwRasInitializeError != 0)
    {
        return DwRasInitializeError;
    }

    if (hrasconn == 0)
    {
        return ERROR_INVALID_HANDLE;
    }

    //
    // Get the subentry associated with this
    // connection, if specified.
    //
    dwSubEntry = SubEntryFromConnection(&hrasconn);

    if (!dwSubEntry)
    {
        return ERROR_INVALID_HANDLE;
    }

    //
    // Get the projection results from rasman.
    //
    dwPppSize = sizeof (pppProj);

    dwErr = g_pRasGetConnectionUserData(
              (HCONN)hrasconn,
              CONNECTION_PPPRESULT_INDEX,
              (PBYTE)&pppProj,
              &dwPppSize);

    if (dwErr)
    {
        return dwErr;
    }

    dwAmbSize = sizeof (ambProj);

    dwErr = g_pRasGetConnectionUserData(
              (HCONN)hrasconn,
              CONNECTION_AMBRESULT_INDEX,
              (PBYTE)&ambProj,
              &dwAmbSize);

    if (dwErr)
    {
        return dwErr;
    }

    dwSlipSize = sizeof (slipProj);

    dwErr = g_pRasGetConnectionUserData(
              (HCONN)hrasconn,
              CONNECTION_SLIPRESULT_INDEX,
              (PBYTE)&slipProj,
              &dwSlipSize);

    if (dwErr)
    {
        return dwErr;
    }

    //
    // Verify parameters.
    //
    if (    !lpcb
        ||  (   *lpcb > 0
            &&  !lpprojection))
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (    rasprojection != RASP_Amb
        &&  rasprojection != RASP_Slip
        &&  rasprojection != RASP_PppNbf
        &&  rasprojection != RASP_PppIpx
        &&  rasprojection != RASP_PppIp
        &&  rasprojection != RASP_PppLcp
        &&  rasprojection != RASP_PppCcp)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // ZeroMemory(lpprojection, *lpcb);

    if (rasprojection == RASP_PppNbf)
    {
        RASPPPNBFW*       pnbf;
        PPP_NBFCP_RESULT* ppppnbf;
        HPORT hport;

        if (    pppProj.nbf.dwError ==
                ERROR_PPP_NO_PROTOCOLS_CONFIGURED
            ||  dwPppSize != sizeof (pppProj))
        {
            return ERROR_PROTOCOL_NOT_CONFIGURED;
        }

        pnbf = (RASPPPNBFW* )lpprojection;
        ppppnbf = &pppProj.nbf;

        if (    (NULL == pnbf)
            ||  (*lpcb < pnbf->dwSize))
        {
            *lpcb = sizeof (RASPPPNBFW);

            return ERROR_BUFFER_TOO_SMALL;
        }

        if (pnbf->dwSize != sizeof(RASPPPNBFW))
        {
            return ERROR_INVALID_SIZE;
        }

        pnbf->dwError = ppppnbf->dwError;

        pnbf->dwNetBiosError = ppppnbf->dwNetBiosError;

        strncpyAtoW(
            pnbf->szNetBiosError,
            ppppnbf->szName,
            sizeof(pnbf->szNetBiosError) / sizeof(WCHAR));

        lstrcpyn(
            pnbf->szWorkstationName,
            ppppnbf->wszWksta,
            sizeof(pnbf->szWorkstationName) / sizeof(WCHAR));

        dwErr = SubEntryPort(hrasconn, dwSubEntry, &hport);

        if (dwErr)
        {
            return dwErr;
        }

        dwErr = GetAsybeuiLana(hport, &pnbf->bLana);

        if (dwErr)
        {
            return dwErr;
        }
    }
    else if (rasprojection == RASP_PppIpx)
    {
        RASPPPIPXW*       pipx;
        PPP_IPXCP_RESULT* ppppipx;

        if (    pppProj.ipx.dwError ==
                ERROR_PPP_NO_PROTOCOLS_CONFIGURED
            ||  dwPppSize != sizeof (pppProj))
        {
            return ERROR_PROTOCOL_NOT_CONFIGURED;
        }

        pipx = (RASPPPIPXW* )lpprojection;
        ppppipx = &pppProj.ipx;

        if (    (NULL != pipx)
            &&  (pipx->dwSize != sizeof(RASPPPIPXW)))
        {
            return ERROR_INVALID_SIZE;
        }

        if (    (NULL == pipx)
            ||  (*lpcb < pipx->dwSize))
        {
            *lpcb = sizeof(RASPPPIPXW);
            return ERROR_BUFFER_TOO_SMALL;
        }

        pipx->dwError = ppppipx->dwError;

        ConvertIpxAddressToString( ppppipx->bLocalAddress,
                                   pipx->szIpxAddress );
    }
    else if (rasprojection == RASP_PppIp)
    {
        RASPPPIPW*       pip;
        PPP_IPCP_RESULT* ppppip;

        if (    pppProj.ip.dwError ==
                ERROR_PPP_NO_PROTOCOLS_CONFIGURED
            ||  dwPppSize != sizeof (pppProj))
        {
            return ERROR_PROTOCOL_NOT_CONFIGURED;
        }

        pip = (RASPPPIPW* )lpprojection;
        ppppip = &pppProj.ip;

        if (    (NULL != pip)
            &&  (pip->dwSize != sizeof(RASPPPIPW))
            &&  (pip->dwSize != sizeof(RASPPPIPW_V35))
            &&  (pip->dwSize != sizeof(RASPPPIPW_V401)))
        {
            return ERROR_INVALID_SIZE;
        }

        if (    (NULL == pip)
            ||  (*lpcb < pip->dwSize))
        {
            if(NULL != pip)
            {
                *lpcb = pip->dwSize;
            }
            else
            {
                *lpcb = sizeof(RASPPPIPW);
            }
            
            return ERROR_BUFFER_TOO_SMALL;
        }

        //
        // The dumb case where caller's buffer is bigger
        // than the old structure, smaller than the new
        // structure, but dwSize asks for the new
        // structure.
        //
        if (    pip->dwSize == sizeof(RASPPPIPW)
            && *lpcb < sizeof(RASPPPIPW))
        {
            *lpcb = sizeof(RASPPPIPW);
            return ERROR_BUFFER_TOO_SMALL;
        }

        pip->dwError = ppppip->dwError;

        ConvertIpAddressToString(ppppip->dwLocalAddress,
                                 pip->szIpAddress );

        if (pip->dwSize >= sizeof(RASPPPIPW_V401))
        {
            //
            // The server address was added late in the
            // NT 3.51 cycle and is not reported to NT
            // 3.5 or earlier NT 3.51 clients.
            //

            ConvertIpAddressToString( ppppip->dwRemoteAddress,
                                      pip->szServerIpAddress );
        }

        if (pip->dwSize == sizeof(RASPPPIPW))
        {
            if (ppppip->fReceiveVJHCompression)
            {
                pip->dwOptions = RASIPO_VJ;
            }
            else
            {
                pip->dwOptions = 0;
            }

            if (ppppip->fSendVJHCompression)
            {
                pip->dwServerOptions = RASIPO_VJ;
            }
            else
            {
                pip->dwServerOptions = 0;
            }
        }
    }
    else if (rasprojection == RASP_PppLcp)
    {
        RASPPPLCP*      plcp;
        PPP_LCP_RESULT* pppplcp;

        if (dwPppSize != sizeof (pppProj))
        {
            return ERROR_PROTOCOL_NOT_CONFIGURED;
        }

        plcp = (RASPPPLCP* )lpprojection;
        pppplcp = &pppProj.lcp;

        if (    (NULL != plcp)
            &&  (plcp->dwSize != sizeof(RASPPPLCP))
            &&  (plcp->dwSize != sizeof(RASPPPLCP_V401)))
        {
            return ERROR_INVALID_SIZE;
        }

        if (    (NULL == plcp)
            ||  (*lpcb < plcp->dwSize))
        {
            if(NULL != plcp)
            {
                *lpcb = plcp->dwSize;
            }
            else
            {
                *lpcb = sizeof(RASPPPLCP);
            }
            
            return ERROR_BUFFER_TOO_SMALL;
        }

        plcp->fBundled = (pppplcp->hportBundleMember
                          != INVALID_HPORT);

        if(sizeof(RASPPPLCP) == plcp->dwSize)
        {
            //
            // Copy the additional fields if its NT5
            //

            plcp->dwOptions = 0;
            plcp->dwServerOptions = 0;

            if (pppplcp->dwLocalOptions & PPPLCPO_PFC)
            {
                plcp->dwOptions |= RASLCPO_PFC;
            }

            if (pppplcp->dwLocalOptions & PPPLCPO_ACFC)
            {
                plcp->dwOptions |= RASLCPO_ACFC;
            }

            if (pppplcp->dwLocalOptions & PPPLCPO_SSHF)
            {
                plcp->dwOptions |= RASLCPO_SSHF;
            }

            if (pppplcp->dwLocalOptions & PPPLCPO_DES_56)
            {
                plcp->dwOptions |= RASLCPO_DES_56;
            }

            if (pppplcp->dwLocalOptions & PPPLCPO_3_DES)
            {
                plcp->dwOptions |= RASLCPO_3_DES;
            }

            plcp->dwAuthenticationProtocol =
                    pppplcp->dwLocalAuthProtocol;

            plcp->dwAuthenticationData =
                    pppplcp->dwLocalAuthProtocolData;

            plcp->dwEapTypeId = pppplcp->dwLocalEapTypeId;

            if (pppplcp->dwRemoteOptions & PPPLCPO_PFC)
            {
                plcp->dwServerOptions |= RASLCPO_PFC;
            }

            if (pppplcp->dwRemoteOptions & PPPLCPO_ACFC)
            {
                plcp->dwServerOptions |= RASLCPO_ACFC;
            }

            if (pppplcp->dwRemoteOptions & PPPLCPO_SSHF)
            {
                plcp->dwServerOptions |= RASLCPO_SSHF;
            }

            if (pppplcp->dwRemoteOptions & PPPLCPO_DES_56)
            {
                plcp->dwServerOptions |= RASLCPO_DES_56;
            }

            if (pppplcp->dwRemoteOptions & PPPLCPO_3_DES)
            {
                plcp->dwServerOptions |= RASLCPO_3_DES;
            }

            plcp->dwServerAuthenticationProtocol =
                    pppplcp->dwRemoteAuthProtocol;

            plcp->dwServerAuthenticationData =
                    pppplcp->dwRemoteAuthProtocolData;

            plcp->dwServerEapTypeId = pppplcp->dwRemoteEapTypeId;

            //
            // Set the Terminate Reasons to 0 for now
            // They don't make sense since if PPP terminates
            // the line will go down and this api will fail.
            //
            plcp->dwTerminateReason = 0;
            plcp->dwServerTerminateReason = 0;


            dwErr = DwGetReplyMessage(hrasconn,
                                      plcp->szReplyMessage,
                                      RAS_MaxReplyMessage);
            plcp->dwError = 0;

            if(pppplcp->dwLocalFramingType & PPP_MULTILINK_FRAMING)
            {
                plcp->fMultilink = 1;
            }
            else
            {
                plcp->fMultilink = 0;
            }
        }
    }
    else if (rasprojection == RASP_Amb)
    {
        RASAMBW*                   pamb;
        NETBIOS_PROJECTION_RESULT* pCbAmb;
        HPORT hport;

        if (ambProj.Result == ERROR_PROTOCOL_NOT_CONFIGURED)
        {
            return ERROR_PROTOCOL_NOT_CONFIGURED;
        }

        pamb = (RASAMBW* )lpprojection;
        pCbAmb = &ambProj;

        if (    (NULL != pamb)
            &&  (pamb->dwSize != sizeof(RASAMBW)))
        {
            return ERROR_INVALID_SIZE;
        }

        if (    (NULL == pamb)
            ||  (*lpcb < pamb->dwSize))
        {
            *lpcb = sizeof(RASAMBW);
            return ERROR_BUFFER_TOO_SMALL;
        }

        pamb->dwError = pCbAmb->Result;

        strncpyAtoW(pamb->szNetBiosError,
                   pCbAmb->achName,
                   sizeof(pamb->szNetBiosError) / sizeof(WCHAR));

        dwErr = SubEntryPort(hrasconn,
                             dwSubEntry,
                             &hport);

        if (dwErr)
        {
            return dwErr;
        }

        dwErr = GetAsybeuiLana(hport, &pamb->bLana);

        if (dwErr)
        {
            return dwErr;
        }
    }
    else if (rasprojection == RASP_PppCcp)
    {
        RASPPPCCP*          pCcp;
        PPP_CCP_RESULT*     pPppCcp;

        if (    pppProj.ccp.dwError ==
                ERROR_PPP_NO_PROTOCOLS_CONFIGURED
            ||  dwPppSize != sizeof (pppProj))
        {
            return ERROR_PROTOCOL_NOT_CONFIGURED;
        }

        pCcp = (RASPPPCCP* )lpprojection;
        pPppCcp = &pppProj.ccp;

        if(     (NULL != pCcp)
            &&  (sizeof(RASPPPCCP) != pCcp->dwSize))
        {
            return ERROR_INVALID_SIZE;
        }

        if(     (NULL == pCcp)
            ||  (*lpcb < pCcp->dwSize))
        {
            if(NULL != pCcp)
            {
            *lpcb = pCcp->dwSize;
            }
            else
            {
                *lpcb = sizeof(RASPPPCCP);
            }
            
            return ERROR_BUFFER_TOO_SMALL;
        }

        pCcp->dwError = pPppCcp->dwError;

        //
        // Initialize everything to 0
        //
        pCcp->dwOptions = 
        pCcp->dwServerOptions =
        pCcp->dwCompressionAlgorithm = 
        pCcp->dwServerCompressionAlgorithm = 0;

        if(RAS_CCP_OPTION_MSPPC == pPppCcp->dwSendProtocol)
        {
            if(pPppCcp->dwSendProtocolData & MSTYPE_COMPRESSION)
            {
                pCcp->dwOptions |= RASCCPO_Compression;
            }

            if(pPppCcp->dwSendProtocolData & MSTYPE_HISTORYLESS)
            {
                pCcp->dwOptions |= RASCCPO_HistoryLess;
            }

            if(   pPppCcp->dwSendProtocolData
                & (   MSTYPE_ENCRYPTION_40F
                    | MSTYPE_ENCRYPTION_40))
            {
                pCcp->dwOptions |= RASCCPO_Encryption40bit;
            }
            else if(pPppCcp->dwSendProtocolData & MSTYPE_ENCRYPTION_56)
            {
                pCcp->dwOptions |= RASCCPO_Encryption56bit;
            }
            else if(pPppCcp->dwSendProtocolData & MSTYPE_ENCRYPTION_128)
            {
                pCcp->dwOptions |= RASCCPO_Encryption128bit;
            }

            if(0 != pCcp->dwOptions)
            {
                //
                // Set the MPPC bit only if some bits are set for
                // dwOptions. Otherwise setting MPPC doesn't make
                // sense since we couldn't have negotiated
                // compression
                //
                pCcp->dwCompressionAlgorithm = RASCCPCA_MPPC;
            }
        }

        if(RAS_CCP_OPTION_MSPPC == pPppCcp->dwReceiveProtocol)
        {
            if(pPppCcp->dwReceiveProtocolData & MSTYPE_COMPRESSION)
            {
                pCcp->dwServerOptions |= RASCCPO_Compression;
            }

            if(pPppCcp->dwReceiveProtocolData & MSTYPE_HISTORYLESS)
            {
                pCcp->dwServerOptions |= RASCCPO_HistoryLess;
            }

            if(   pPppCcp->dwReceiveProtocolData
                & (   MSTYPE_ENCRYPTION_40F
                    | MSTYPE_ENCRYPTION_40))
            {
                pCcp->dwServerOptions |= RASCCPO_Encryption40bit;
            }
            else if(pPppCcp->dwReceiveProtocolData & MSTYPE_ENCRYPTION_56)
            {
                pCcp->dwServerOptions |= RASCCPO_Encryption56bit;
            }
            else if(pPppCcp->dwReceiveProtocolData & MSTYPE_ENCRYPTION_128)
            {
                pCcp->dwServerOptions |= RASCCPO_Encryption128bit;
            }

            if(0 != pCcp->dwServerOptions)
            {
                //
                // Set the MPPC bit only if some bits are set for
                // dwOptions. Otherwise setting MPPC doesn't make
                // sense since we couldn't have negotiated
                // compression
                //
                pCcp->dwServerCompressionAlgorithm = RASCCPCA_MPPC;
            }
        }
    }
    else
    {
        //
        // if (rasprojection == RASP_Slip)
        //
        if (    slipProj.dwError ==
                ERROR_PROTOCOL_NOT_CONFIGURED
            ||  dwSlipSize != sizeof (slipProj))
        {
            return ERROR_PROTOCOL_NOT_CONFIGURED;
        }

        if (*lpcb < sizeof (RASSLIPW))
        {
            *lpcb = sizeof (RASSLIPW);
            return ERROR_BUFFER_TOO_SMALL;
        }

        memcpy(lpprojection,
               &slipProj,
               sizeof (RASSLIPW));
    }

    return 0;
}


DWORD
RasGetProjectionInfoA(
    HRASCONN        hrasconn,
    RASPROJECTION   rasprojection,
    LPVOID          lpprojection,
    LPDWORD         lpcb )
{
    DWORD dwErr = 0, dwcb;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    if (    !lpcb
        || (    *lpcb > 0
            &&  !lpprojection))
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (    rasprojection != RASP_Amb
        &&  rasprojection != RASP_Slip
        &&  rasprojection != RASP_PppNbf
        &&  rasprojection != RASP_PppIpx
        &&  rasprojection != RASP_PppIp
        &&  rasprojection != RASP_PppLcp
        &&  rasprojection != RASP_PppCcp)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (rasprojection == RASP_PppNbf)
    {
        RASPPPNBFW  nbf;
        RASPPPNBFA* pnbf = (RASPPPNBFA* )lpprojection;;

        if (pnbf->dwSize != sizeof(RASPPPNBFA))
        {
            return ERROR_INVALID_SIZE;
        }

        if (*lpcb < pnbf->dwSize)
        {
            *lpcb = sizeof(RASPPPNBFA);
            return ERROR_BUFFER_TOO_SMALL;
        }

        nbf.dwSize = sizeof(nbf);
        dwcb = sizeof (nbf);
        dwErr = RasGetProjectionInfoW(hrasconn,
                                      rasprojection,
                                      &nbf, &dwcb );
        *lpcb = pnbf->dwSize;

        if (dwErr == 0)
        {
            pnbf->dwError = nbf.dwError;
            pnbf->dwNetBiosError =  nbf.dwNetBiosError;

            strncpyWtoAAnsi(pnbf->szNetBiosError,
                       nbf.szNetBiosError,
                       sizeof(pnbf->szNetBiosError));

            strncpyWtoAAnsi(pnbf->szWorkstationName,
                       nbf.szWorkstationName,
                       sizeof(pnbf->szWorkstationName));
        }
    }
    else if (rasprojection == RASP_PppIpx)
    {
        RASPPPIPXW  ipx;
        RASPPPIPXA* pipx = (RASPPPIPXA* )lpprojection;;

        if (pipx->dwSize != sizeof(RASPPPIPXA))
        {
            return ERROR_INVALID_SIZE;
        }

        if (*lpcb < pipx->dwSize)
        {
            *lpcb = sizeof(RASPPPIPXA);
            return ERROR_BUFFER_TOO_SMALL;
        }

        ipx.dwSize = sizeof(ipx);
        dwcb = sizeof (ipx);

        dwErr = RasGetProjectionInfoW(hrasconn,
                                      rasprojection,
                                      &ipx,
                                      &dwcb );
        *lpcb = pipx->dwSize;

        if (dwErr == 0)
        {
            pipx->dwError = ipx.dwError;
            strncpyWtoAAnsi(pipx->szIpxAddress,
                       ipx.szIpxAddress,
                       sizeof(pipx->szIpxAddress));
        }
    }
    else if (rasprojection == RASP_PppIp)
    {
        RASPPPIPW  ip;
        RASPPPIPA* pip = (RASPPPIPA* )lpprojection;;

        if (    pip->dwSize != sizeof(RASPPPIPA)
            &&  pip->dwSize != sizeof(RASPPPIPA_V35)
            &&  pip->dwSize != sizeof(RASPPPIPA_V401))
        {
            return ERROR_INVALID_SIZE;
        }

        if (*lpcb < pip->dwSize)
        {
            *lpcb = pip->dwSize;
            return ERROR_BUFFER_TOO_SMALL;
        }

        //
        // The dumb case where caller's buffer is bigger
        // than the old structure, smaller than the new
        // structure, but dwSize asks for the new
        // structure.
        //
        if (    pip->dwSize == sizeof(RASPPPIPA)
            && *lpcb < sizeof(RASPPPIPA))
        {
            *lpcb = sizeof(RASPPPIPA);
            return ERROR_BUFFER_TOO_SMALL;
        }

        ip.dwSize = sizeof(ip);

        dwcb = sizeof (ip);

        dwErr = RasGetProjectionInfoW(hrasconn,
                                      rasprojection,
                                      &ip,
                                      &dwcb );
        *lpcb = pip->dwSize;

        if (dwErr == 0)
        {
            pip->dwError = ip.dwError;
            strncpyWtoAAnsi(
                pip->szIpAddress,
                ip.szIpAddress,
                sizeof(pip->szIpAddress));

            if (dwErr == 0)
            {
                if (pip->dwSize >= sizeof(RASPPPIPA_V401))
                {
                    //
                    // The server address was added late in
                    // the NT 3.51 cycle and is not reported
                    // to NT 3.5 or earlier NT 3.51
                    // clients.
                    //
                    strncpyWtoAAnsi(pip->szServerIpAddress,
                               ip.szServerIpAddress,
                               sizeof(pip->szServerIpAddress));
                }

                if (pip->dwSize >= sizeof(RASPPPIPA))
                {
                    pip->dwOptions = ip.dwOptions;
                    pip->dwServerOptions = ip.dwServerOptions;
                }
            }
        }
    }
    else if (rasprojection == RASP_PppLcp)
    {
        RASPPPLCPW  ppplcp;
        RASPPPLCPA* pppplcp = (RASPPPLCPA* )lpprojection;

        if (*lpcb < sizeof(RASPPPLCPA))
        {
            *lpcb = sizeof(RASPPPLCPA);
            return ERROR_BUFFER_TOO_SMALL;
        }

        if (pppplcp->dwSize != sizeof(RASPPPLCPA))
        {
            return ERROR_INVALID_SIZE;
        }

        ppplcp.dwSize = sizeof(RASPPPLCPW);

        dwcb = sizeof(RASPPPLCPW);

        dwErr = RasGetProjectionInfoW(
                                hrasconn,
                                rasprojection,
                                &ppplcp,
                                &dwcb );
        *lpcb = sizeof(RASPPPLCPA);

        if (dwErr == 0)
        {
            pppplcp->fBundled =     ppplcp.fBundled;
            pppplcp->dwError =      ppplcp.dwError;
            pppplcp->dwOptions = ppplcp.dwOptions;
            pppplcp->dwAuthenticationProtocol =
                                    ppplcp.dwAuthenticationProtocol;
            pppplcp->dwAuthenticationData =
                                    ppplcp.dwAuthenticationData;
            pppplcp->dwEapTypeId = ppplcp.dwEapTypeId;
            pppplcp->dwServerOptions = ppplcp.dwServerOptions;
            pppplcp->dwServerAuthenticationProtocol =
                                    ppplcp.dwServerAuthenticationProtocol;
            pppplcp->dwServerAuthenticationData =
                                    ppplcp.dwServerAuthenticationData;
            pppplcp->dwServerEapTypeId = ppplcp.dwServerEapTypeId;
            pppplcp->dwTerminateReason =
                                    ppplcp.dwTerminateReason;
            pppplcp->dwServerTerminateReason =
                                    ppplcp.dwServerTerminateReason;
            pppplcp->fMultilink =   ppplcp.fMultilink;

            strncpyWtoAAnsi(pppplcp->szReplyMessage,
                       ppplcp.szReplyMessage,
                       sizeof(pppplcp->szReplyMessage));
        }
    }
    else if (rasprojection == RASP_Amb)
    {
        RASAMBW  amb;
        RASAMBA* pamb = (RASAMBA* )lpprojection;

        if (pamb->dwSize != sizeof(RASAMBA))
        {
            return ERROR_INVALID_SIZE;
        }

        if (*lpcb < pamb->dwSize)
        {
            *lpcb = sizeof(RASAMBA);
            return ERROR_BUFFER_TOO_SMALL;
        }

        amb.dwSize = sizeof(amb);

        dwcb = sizeof (amb);

        dwErr = RasGetProjectionInfoW(hrasconn,
                                      rasprojection,
                                      &amb,
                                      &dwcb );
        *lpcb = pamb->dwSize;

        if (dwErr == 0)
        {
            pamb->dwError = amb.dwError;
            strncpyWtoAAnsi(pamb->szNetBiosError,
                       amb.szNetBiosError,
                       sizeof(pamb->szNetBiosError));
        }
    }
    else if (rasprojection == RASP_PppCcp)
    {
        dwErr = RasGetProjectionInfoW(
                                hrasconn,
                                rasprojection,
                                (RASPPPCCP *)
                                lpprojection,
                                lpcb);
    }
    else
    {
        //
        // if (rasprojection == RASP_Slip)
        //
        RASSLIPW  slip;
        RASSLIPA* pslip = (RASSLIPA* )lpprojection;

        if (pslip->dwSize != sizeof(RASSLIPA))
        {
            return ERROR_INVALID_SIZE;
        }

        if (*lpcb < pslip->dwSize)
        {
            *lpcb = sizeof(RASSLIPA);
            return ERROR_BUFFER_TOO_SMALL;
        }

        slip.dwSize = sizeof(slip);

        dwcb = sizeof (slip);

        dwErr = RasGetProjectionInfoW(hrasconn,
                                      rasprojection,
                                      &slip,
                                      &dwcb );
        *lpcb = pslip->dwSize;

        if (dwErr == 0)
        {
            pslip->dwError = slip.dwError;
            strncpyWtoAAnsi(pslip->szIpAddress,
                       slip.szIpAddress,
                       sizeof(pslip->szIpAddress));
        }
    }

    return dwErr;
}

DWORD DwHangUpConnection(HRASCONN hRasconn)
{
    DWORD dwErr = SUCCESS;
    DWORD dwRef;
    DWORD dwLastError = SUCCESS;

    RASAPI32_TRACE1("(HUC) RasRefConnection(FALSE), 0x%x ...",
            hRasconn);

    dwErr = g_pRasRefConnection((HCONN) hRasconn,
                                FALSE,
                                &dwRef);

    RASAPI32_TRACE3("(HUC) RasRefConnection(FALSE), "
            "0x%x. ref=%d, rc=%d",
            hRasconn,
            dwRef,
            dwErr );

    if(ERROR_SUCCESS != dwErr)
    {
        dwLastError = dwErr;
    }

    if (0 == dwRef)
    {
        //
        // Destroy the entire connection.
        //
        RASAPI32_TRACE1("(HU) RasDestroyConnection(%d)...",
                hRasconn);

        dwErr = g_pRasDestroyConnection((HCONN)hRasconn);

        RASAPI32_TRACE1("(HU) RasDestroyConnection done(%d)",
                dwErr);

        if(ERROR_SUCCESS != dwErr)
        {
            dwLastError = dwErr;
        }
    }

    if(     (ERROR_SUCCESS == dwErr)
        &&  (ERROR_SUCCESS != dwLastError))
    {
        dwErr = dwLastError;
    }

    return dwErr;
}


DWORD APIENTRY
RasHangUpW(
    IN HRASCONN hrasconn )

/*++

Routine Description:
    Hang up the connection associated with handle 'hrasconn'.

Arguments:

Return Value:
 Returns 0 if successful, otherwise a non-0 error code.

--*/
{
    DWORD dwErr = 0;
    RASCONNCB* prasconncb;
    HRASCONN hConnPrereq = NULL;
    DWORD dwLastError = ERROR_SUCCESS;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    RASAPI32_TRACE("RasHangUpW");

    //
    // Note: This stuff happens in the clean up routine if
    //       RasHangUp is called while the async machine
    //       is running.  That lets this routine return
    //       before the machine stops...very important because
    //       it allows the RasDial caller to call RasHangUp
    //       inside a RasDial callback function without
    //       deadlock.
    //
    //
    dwErr = LoadRasmanDllAndInit();
    if (dwErr)
    {
        return dwErr;
    }

    if (DwRasInitializeError != 0)
    {
        return DwRasInitializeError;
    }

    if (hrasconn == 0)
    {
        return ERROR_INVALID_HANDLE;
    }

    EnterCriticalSection(&csStopLock);

    //
    // If this is a port-based HRASCONN, then
    // stop the async machine associated with
    // the particular subentry.  If this is a
    // connection-based HRASCONN, then stop
    // all async machines associated with this
    // HRASCONN.
    //
    if (IS_HPORT(hrasconn))
    {
        HPORT hport = HRASCONN_TO_HPORT(hrasconn);
        DWORD dwSubEntry;
        DWORD i, dwcbPorts, dwcPorts;

        dwSubEntry = SubEntryFromConnection(&hrasconn);

        if (hrasconn == 0)
        {
            dwErr = ERROR_INVALID_HANDLE;
            goto done;
        }

        RASAPI32_TRACE1("(HU) RasEnumConnectionPorts..",
               hrasconn);

        dwcbPorts = dwcPorts = 0;
        dwErr = g_pRasEnumConnectionPorts(
                    NULL,
                    (HCONN)hrasconn,
                    NULL,
                    &dwcbPorts,
                    &dwcPorts);

        RASAPI32_TRACE1("(HU) RasEnumConnectionPorts. 0x%x",
               dwErr);

        if(ERROR_BUFFER_TOO_SMALL == dwErr)
        {
            dwErr = ERROR_SUCCESS;
        }
        else if(ERROR_SUCCESS != dwErr)
        {
            dwLastError = dwErr;
        }

        //
        // if this is the last port in this connection
        // then deref the connection in rasman.
        //
        if(1 == dwcPorts)
        {
            DWORD dwRef;

            dwErr = g_pRasFindPrerequisiteEntry(
                                (HCONN) hrasconn,
                                (HCONN *) &hConnPrereq);
            RASAPI32_TRACE2("(HU) g_pRasFindPrequisiteEntry(%x). 0x%x",
                    hrasconn,
                    dwErr);

            dwErr = g_pRasRefConnection((HCONN) hrasconn,
                                        FALSE,
                                        &dwRef);

            RASAPI32_TRACE2("(HU) g_pRasRefConnection(%x). 0x%x",
                    hrasconn,
                    dwErr);

            if(ERROR_SUCCESS != dwErr)
            {
                dwLastError = dwErr;
            }
        }

        //
        // mark this connection as Terminated to
        // prevent rasdial machine from starting
        // the connection after the link connection
        // has been Terminated
        //
        prasconncb = ValidateHrasconn2(hrasconn,
                                       dwSubEntry);

        if (NULL != prasconncb)
        {
            prasconncb->fTerminated = TRUE;
        }

        //
        // Disconnect the port associated with this
        // subentry. This is a synchronous call
        //
        RASAPI32_TRACE1("(HU) RasPortDisconnect(%d)...", hport);

        dwErr = g_pRasPortDisconnect(hport,
                                     INVALID_HANDLE_VALUE);

        RASAPI32_TRACE1("(HU) RasPortDisconnect(%d)", dwErr);

        if(ERROR_SUCCESS != dwErr)
        {
            dwLastError = dwErr;
        }

        //
        // Close the port associated with this subentry.
        //
        RASAPI32_TRACE1("(HU) RasPortClose(%d)...", hport);

        dwErr = g_pRasPortClose(hport);

        RASAPI32_TRACE1("(HU) RasPortClose(%d)", dwErr);

        if(ERROR_SUCCESS != dwErr)
        {
            dwLastError = dwErr;
        }

        //
        // HangUp Prereq connection if any
        //
        if(hConnPrereq)
        {
            dwErr = DwHangUpConnection(hConnPrereq);
        }
    }
    else
    {
        DTLNODE *pdtlnode;
        DWORD   dwRef;
        DWORD   dwCount;
        CHAR    szPhonebookPath[MAX_PATH + 1];
        CHAR    szEntryName[MAX_ENTRYNAME_SIZE + 1];

        //
        // Check to see if we need to call the custom hangup
        // function. And if so call the customhangup fn. and
        // bail. Notice we become reentrant since the custom
        // hangup function call can call this function again.
        //
        dwErr = g_pRasReferenceCustomCount((HCONN) hrasconn,
                                           FALSE,
                                           szPhonebookPath,
                                           szEntryName,
                                           &dwCount);

        if(ERROR_SUCCESS != dwErr)
        {
            goto done;
        }

        if(dwCount > 0)
        {
            RASAPI32_TRACE1("RasHangUp: Calling Custom hangup for 0x%x",
                   hrasconn);
            //
            // Call the custom dll entry point and bail
            //
            dwErr = DwCustomHangUp(szPhonebookPath,
                                   szEntryName,
                                   hrasconn);

            RASAPI32_TRACE1("RasHangUp: Custom hangup returned %d",
                   dwErr);

            goto done;
        }

        //
        // mark all links in this connection as Terminated
        // to prevent rasdial machine from trying to
        // connect on these links after the connection
        // has been Terminated.
        //
        EnterCriticalSection(&RasconncbListLock);

        for (pdtlnode = DtlGetFirstNode(PdtllistRasconncb);
             pdtlnode != NULL;
             pdtlnode = DtlGetNextNode(pdtlnode))
        {
            prasconncb = DtlGetData(pdtlnode);
            ASSERT(prasconncb);
            if ((HRASCONN)prasconncb->hrasconn == hrasconn)
            {
                prasconncb->fTerminated = TRUE;
            }
        }

        LeaveCriticalSection(&RasconncbListLock);

        //
        // Check to see if this has a prerequisite connection
        //
        RASAPI32_TRACE1("(HU) RasFindPrerequisiteEntry, 0x%x",
                hrasconn);

        dwErr = g_pRasFindPrerequisiteEntry(
                                (HCONN) hrasconn,
                                (HCONN *) &hConnPrereq);

        RASAPI32_TRACE3("(HU) RasFindPrerequisiteEntry, 0x%x. "
                "hConnPrereq=0x%x, rc=%d",
                hrasconn,
                hConnPrereq,
                dwErr);

        //
        // HangUp the connection. This will bring down the
        // the prerequisite connection if required in rasman.
        //
        dwErr = DwHangUpConnection(hrasconn);

        //
        // HangUp Prereq connection if any
        //
        if(hConnPrereq)
        {
            dwErr = DwHangUpConnection(hConnPrereq);
        }


    }

    if(     (ERROR_SUCCESS == dwErr)
        &&  (ERROR_SUCCESS != dwLastError))
    {
        dwErr = dwLastError;
    }

done:
    LeaveCriticalSection(&csStopLock);
    return (dwErr == ERROR_ACCESS_DENIED)
            ? ERROR_HANGUP_FAILED
            : dwErr;
}


DWORD APIENTRY
RasHangUpA(
    HRASCONN hrasconn )
{
    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    return RasHangUpW( hrasconn );
}


DWORD APIENTRY
RasSetEntryDialParamsW(
    IN LPCWSTR          lpszPhonebook,
    IN LPRASDIALPARAMSW lprasdialparams,
    IN BOOL             fRemovePassword )

/*++

Routine Description:
    Sets cached RASDIALPARAM information.

Arguments:

Return Value:
    Returns 0 if successful, otherwise a non-0 error code.

--*/
{
    DWORD dwErr;
    PBFILE pbfile;
    DTLNODE *pdtlnode;
    PBENTRY *pEntry;
    DWORD dwMask;
    RAS_DIALPARAMS dialparams;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    RASAPI32_TRACE("RasSetEntryDialParamsW");

    dwErr = LoadRasmanDllAndInit();
    if (dwErr)
    {
        return dwErr;
    }

    if (DwRasInitializeError)
    {
        return DwRasInitializeError;
    }

    //
    // Validate parameters.
    //
    if (lprasdialparams == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (    lprasdialparams->dwSize !=
            sizeof (RASDIALPARAMSW)

        &&  lprasdialparams->dwSize !=
            sizeof (RASDIALPARAMSW_V351)

        &&  lprasdialparams->dwSize !=
            sizeof (RASDIALPARAMSW_V400))
    {
        return ERROR_INVALID_SIZE;
    }

    //
    // Load the phonebook file.
    //
#ifdef PBCS
    EnterCriticalSection(&PhonebookLock);
#endif

	ZeroMemory(&pbfile, sizeof(pbfile));
    pbfile.hrasfile = -1;

    dwErr = GetPbkAndEntryName(
                lpszPhonebook,
                lprasdialparams->szEntryName,
                RPBF_NoCreate,
                &pbfile,
                &pdtlnode);

    if(SUCCESS != dwErr)
    {
        goto done;
    }

    //
    // Get the dialparams UID corresponding to the
    // entry.  The phonebook library guarantees this
    // value to be unique.
    //
    pEntry = (PBENTRY *)DtlGetData(pdtlnode);

    //
    // Set the dial parameters in rasman.
    // If the caller wants to clear the password
    // we have to do that in a separate rasman
    // call.
    //
    dwMask =    DLPARAMS_MASK_PHONENUMBER
            |   DLPARAMS_MASK_CALLBACKNUMBER
            |   DLPARAMS_MASK_USERNAME
            |   DLPARAMS_MASK_DOMAIN
            |   DLPARAMS_MASK_SUBENTRY
            |   DLPARAMS_MASK_OLDSTYLE;

    if (!fRemovePassword)
    {
        dwMask |= DLPARAMS_MASK_PASSWORD;
    }

    dwErr = SetEntryDialParamsUID(
              pEntry->dwDialParamsUID,
              dwMask,
              lprasdialparams,
              FALSE);
    if (dwErr)
    {
        goto done;
    }

    if (fRemovePassword)
    {
        dwMask =    DLPARAMS_MASK_PASSWORD
                |   DLPARAMS_MASK_OLDSTYLE;

        dwErr = SetEntryDialParamsUID(
                  pEntry->dwDialParamsUID,
                  dwMask,
                  lprasdialparams,
                  TRUE);

        if (dwErr)
        {
            goto done;
        }
    }

    //
    // Write out the phonebook file.
    //
    dwErr = WritePhonebookFile(&pbfile, NULL);

done:
    //
    // Clean up.
    //
    ClosePhonebookFile(&pbfile);

#ifdef PBCS
    LeaveCriticalSection(&PhonebookLock);
#endif

    return dwErr;
}


DWORD APIENTRY
RasSetEntryDialParamsA(
    IN LPCSTR           lpszPhonebook,
    IN LPRASDIALPARAMSA lprasdialparams,
    IN BOOL             fRemovePassword )

/*++

Routine Description:
    Sets cached RASDIALPARAM information.

Arguments:

Return Value:
    Returns 0 if successful, otherwise a non-0
    error code.

--*/

{
    NTSTATUS status;
    DWORD dwErr, dwcb;
    RASDIALPARAMSW rasdialparamsW;
    WCHAR szPhonebookW[MAX_PATH];

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    //
    // Verify parameters.
    //
    if (lprasdialparams == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (    lprasdialparams->dwSize !=
            sizeof (RASDIALPARAMSA)

        &&  lprasdialparams->dwSize !=
            sizeof (RASDIALPARAMSA_V351)

        &&  lprasdialparams->dwSize !=
            sizeof (RASDIALPARAMSA_V400))
    {
        return ERROR_INVALID_SIZE;
    }

    //
    // Convert the lpszPhonebook string to Unicode.
    //
    if (lpszPhonebook != NULL)
    {
        strncpyAtoWAnsi(szPhonebookW,
                    lpszPhonebook,
                    MAX_PATH);
    }

    //
    // Copy the fields from the A buffer into
    // the user's W buffer, taking into account
    // the version of the structure the user
    // passed in.
    //
    rasdialparamsW.dwSize = sizeof (RASDIALPARAMSW);

    if (lprasdialparams->dwSize ==
        sizeof (RASDIALPARAMSA_V351))
    {
        RASDIALPARAMSA_V351 *prdp =
            (RASDIALPARAMSA_V351 *)lprasdialparams;

        strncpyAtoWAnsi(rasdialparamsW.szEntryName,
                   prdp->szEntryName,
                   sizeof(rasdialparamsW.szEntryName) / sizeof(WCHAR));

        strncpyAtoWAnsi(rasdialparamsW.szPhoneNumber,
                   prdp->szPhoneNumber,
                   sizeof(rasdialparamsW.szPhoneNumber) / sizeof(WCHAR));

        strncpyAtoWAnsi(rasdialparamsW.szCallbackNumber,
                   prdp->szCallbackNumber,
                   sizeof(rasdialparamsW.szCallbackNumber) / sizeof(WCHAR));

        strncpyAtoWAnsi(rasdialparamsW.szUserName,
                   prdp->szUserName,
                   sizeof(rasdialparamsW.szUserName) / sizeof(WCHAR));

        strncpyAtoWAnsi(rasdialparamsW.szPassword,
                   prdp->szPassword,
                   sizeof(rasdialparamsW.szPassword) / sizeof(WCHAR));

        strncpyAtoWAnsi(rasdialparamsW.szDomain,
                   prdp->szDomain,
                   sizeof(rasdialparamsW.szDomain) / sizeof(WCHAR));
    }
    else
    {
        strncpyAtoWAnsi(rasdialparamsW.szEntryName,
                   lprasdialparams->szEntryName,
                   sizeof(rasdialparamsW.szEntryName) / sizeof(WCHAR));

        strncpyAtoWAnsi(rasdialparamsW.szPhoneNumber,
                   lprasdialparams->szPhoneNumber,
                   sizeof(rasdialparamsW.szPhoneNumber) / sizeof(WCHAR));

        strncpyAtoWAnsi(rasdialparamsW.szCallbackNumber,
                   lprasdialparams->szCallbackNumber,
                   sizeof(rasdialparamsW.szCallbackNumber) / sizeof(WCHAR));

        strncpyAtoWAnsi(rasdialparamsW.szUserName,
                   lprasdialparams->szUserName,
                   sizeof(rasdialparamsW.szUserName) / sizeof(WCHAR));

        strncpyAtoWAnsi(rasdialparamsW.szPassword,
                   lprasdialparams->szPassword,
                   sizeof(rasdialparamsW.szPassword) / sizeof(WCHAR));

        strncpyAtoWAnsi(rasdialparamsW.szDomain,
                   lprasdialparams->szDomain,
                   sizeof(rasdialparamsW.szDomain) / sizeof(WCHAR));
    }

    if (lprasdialparams->dwSize == sizeof (RASDIALPARAMSA))
    {
        rasdialparamsW.dwSubEntry =
            lprasdialparams->dwSubEntry;
    }
    else
    {
        rasdialparamsW.dwSubEntry = 1;
    }

    //
    // Call the W version to do the work.
    //
    dwErr = RasSetEntryDialParamsW(
              lpszPhonebook != NULL
              ? szPhonebookW
              : NULL,
              &rasdialparamsW,
              fRemovePassword);

    return dwErr;
}


DWORD APIENTRY
RasSetOldPassword(
    IN HRASCONN hrasconn,
    IN CHAR*    pszPassword )

/*++

Routine Description:
    Allows user to explicitly set the "old" password prior to
    resuming a RasDial session paused due to password expiration.
    This allows change password to successfully complete in the
    "automatically use current username/password" case, where
    user has not already entered his clear text password.
    The clear text password is required to change the password.


Arguments:


Return Value
    Returns 0 if successful, otherwise a non-0 error code.

Notes:
    Change password for the auto-logon case was broken in NT31
    and NT35 and this is a somewhat hackish fix that avoids
    changing the published RAS APIs which will still work as
    before and as documented for the non-auto-logon cases.
    Otherwise public structures would need to to be reved
    introducing backward compatibility issues that just
    aren't worth it for this obscure problem.  This issue
    should be addressed in the next RAS API functionality
    update.

--*/
{
    RASCONNCB* prasconncb;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    RASAPI32_TRACE("RasSetOldPassword");

    prasconncb = ValidateHrasconn( hrasconn );

    if (!prasconncb)
    {
        return ERROR_INVALID_HANDLE;
    }

    strncpyAtoW(
        prasconncb->szOldPassword,
        pszPassword,
        sizeof(prasconncb->szOldPassword) / sizeof(WCHAR));

    EncodePasswordW(prasconncb->szOldPassword);

    prasconncb->fOldPasswordSet = TRUE;

    return 0;
}


DWORD APIENTRY
RasEnumDevicesW(
    OUT    LPRASDEVINFOW lpRasDevInfo,
    IN OUT LPDWORD lpdwcb,
    OUT    LPDWORD lpdwcDevices
    )
{
    DWORD dwErr, dwSize;
    DWORD dwPorts;
    DWORD i,j = 0;
    RASMAN_PORT *pports, *pport;
    DWORD dwCallOutPorts = 0;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    RASAPI32_TRACE("RasEnumDevicesW");

    dwErr = LoadRasmanDllAndInit();
    if (dwErr)
    {
        return dwErr;
    }

    if (DwRasInitializeError)
    {
        return DwRasInitializeError;
    }

    //
    // Verify parameters.
    //
    if (    lpRasDevInfo != NULL
        &&  lpRasDevInfo->dwSize != sizeof (RASDEVINFOW))
    {
        return ERROR_INVALID_SIZE;
    }

    if (    lpdwcb == NULL
        ||  lpdwcDevices == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (    lpRasDevInfo != NULL
        && *lpdwcb < lpRasDevInfo->dwSize)
    {
        return ERROR_BUFFER_TOO_SMALL;
    }

    //
    // Get the port information from RASMAN.
    //
    dwErr = GetRasPorts(NULL, &pports, &dwPorts);

    if (dwErr)
    {
        return dwErr;
    }

    //
    // We want to enum only call out devices.
    // - RAID BUG 85434
    //

    for (i = 0, pport = pports; i < dwPorts; i++, pport++)
    {
        if ( pport->P_ConfiguredUsage & CALL_OUT )
        {
            dwCallOutPorts += 1;
        }
    }

    //
    // Make sure the caller's buffer is large enough.
    //
    dwSize = dwCallOutPorts * sizeof (RASDEVINFOW);

    if (    lpRasDevInfo == NULL
        ||  *lpdwcb < dwSize)
    {

        Free(pports);

        *lpdwcb         = dwSize;
        *lpdwcDevices   = dwCallOutPorts;

        return ERROR_BUFFER_TOO_SMALL;
    }

    *lpdwcb         = dwSize;
    *lpdwcDevices   = dwCallOutPorts;

    //
    // Enumerate the ports and fill in the user's buffer.
    //
    for (i = 0, pport = pports; i < dwPorts; i++, pport++)
    {

        TCHAR szDeviceType[RAS_MaxDeviceType + 1];

        TCHAR szDeviceName[RAS_MaxDeviceName + 1];

        TCHAR szNewDeviceName[RAS_MaxDeviceName + 1];

        TCHAR szPortName[MAX_PORT_NAME];

        TCHAR *pszDeviceType = NULL;

        //
        // Skip the ports that are not CALL_OUT
        //
        if ( ( pport->P_ConfiguredUsage & CALL_OUT ) == 0 )
        {
            continue;
        }

        lpRasDevInfo[j].dwSize = sizeof (RASDEVINFOW);

        pszDeviceType = pszDeviceTypeFromRdt(
                            pport->P_rdtDeviceType);

        if(NULL != pszDeviceType)
        {

            lstrcpyn(lpRasDevInfo[j].szDeviceType,
                    pszDeviceType,
                    sizeof(lpRasDevInfo[j].szDeviceType) / sizeof(WCHAR));

            Free(pszDeviceType);                           
        }
        else
        {
            strncpyAtoTAnsi(lpRasDevInfo[j].szDeviceType,
                           pport->P_DeviceType,
                           sizeof(lpRasDevInfo[j].szDeviceType) /
                             sizeof(WCHAR));
        }

        _tcslwr(lpRasDevInfo[j].szDeviceType);

        strncpyAtoTAnsi(szDeviceName,
                   pport->P_DeviceName,
                   sizeof(szDeviceName) / sizeof(WCHAR));

        strncpyAtoTAnsi(szPortName,
                   pport->P_PortName,
                   sizeof(szPortName) / sizeof(WCHAR));

        SetDevicePortName(szDeviceName,
                          szPortName,
                          szNewDeviceName);

        strncpyTtoWAnsi(lpRasDevInfo[j].szDeviceName,
                   szNewDeviceName,
                   sizeof(lpRasDevInfo[j].szDeviceName) / sizeof(WCHAR));

        RasGetUnicodeDeviceName(pport->P_Handle,
                                lpRasDevInfo[j].szDeviceName);

        j += 1;
    }

    Free(pports);

    return 0;
}


DWORD APIENTRY
RasEnumDevicesA(
    OUT LPRASDEVINFOA lpRasDevInfo,
    IN OUT LPDWORD lpdwcb,
    OUT LPDWORD lpdwcDevices
    )
{
    DWORD dwcb, dwErr, i;
    LPRASDEVINFOW lpRasDevInfoW = NULL;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    //
    // Verify parameters.
    //
    if (    lpRasDevInfo != NULL
        &&  lpRasDevInfo->dwSize != sizeof (RASDEVINFOA))
    {
        return ERROR_INVALID_SIZE;
    }

    if (    lpdwcb == NULL
        ||  lpdwcDevices == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (    lpRasDevInfo != NULL
        && *lpdwcb < lpRasDevInfo->dwSize)
    {
        return ERROR_BUFFER_TOO_SMALL;
    }

    //
    // Allocate the same number of entries
    // in the W buffer as the user passed
    // in with the A buffer.
    //
    dwcb =    (*lpdwcb / sizeof (RASDEVINFOA))
            * sizeof (RASDEVINFOW);

    if (lpRasDevInfo != NULL)
    {
        lpRasDevInfoW = (LPRASDEVINFOW)Malloc(dwcb);

        if (lpRasDevInfoW == NULL)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        lpRasDevInfoW->dwSize = sizeof (RASDEVINFOW);
    }

    //
    // Call the W version to do the work.
    //
    dwErr = RasEnumDevicesW(lpRasDevInfoW,
                            &dwcb,
                            lpdwcDevices);
    if (    !dwErr
        &&  lpRasDevInfo != NULL)
    {
        //
        // Copy the strings to the user's buffer.
        //
        for (i = 0; i < *lpdwcDevices; i++)
        {
            lpRasDevInfo[i].dwSize = sizeof (LPRASDEVINFOA);

            strncpyWtoAAnsi(lpRasDevInfo[i].szDeviceType,
                       lpRasDevInfoW[i].szDeviceType,
                       sizeof(lpRasDevInfo[i].szDeviceType));

            strncpyWtoAAnsi(lpRasDevInfo[i].szDeviceName,
                       lpRasDevInfoW[i].szDeviceName,
                       sizeof(lpRasDevInfo[i].szDeviceName));
        }
    }

    *lpdwcb = *lpdwcDevices * sizeof (RASDEVINFOA);

    //
    // Free the W buffer.
    //
    Free(lpRasDevInfoW);

    return dwErr;
}


DWORD APIENTRY
RasGetCountryInfoW(
    IN OUT LPRASCTRYINFOW lpRasCtryInfo,
    IN OUT LPDWORD lpdwcb
    )
{
    DWORD dwErr, dwcb, dwcbOrig;
    LINECOUNTRYLIST lineCountryList;

    LPLINECOUNTRYLIST lpLineCountryList = NULL;

    LPLINECOUNTRYENTRY lpLineCountryEntry;

    PWCHAR pEnd, lpszCountryName;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    RASAPI32_TRACE("RasGetCountryInfoW");

    //
    // Verify parameters.
    //
    if (    lpRasCtryInfo == NULL
        ||  lpdwcb == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (    (*lpdwcb < sizeof(RASCTRYINFOW))
        ||  (lpRasCtryInfo->dwSize != sizeof (RASCTRYINFOW)))
    {
        return ERROR_INVALID_SIZE;
    }

    //
    // dwCountryId cannot be 0, since that tells
    // TAPI to return the entire table.  We only
    // want to return one structure at a time.
    //
    if (lpRasCtryInfo->dwCountryID == 0)
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Call TAPI to get the size of
    // the buffer needed.
    //
    RtlZeroMemory(&lineCountryList,
                  sizeof (lineCountryList));

    lineCountryList.dwTotalSize =
            sizeof (lineCountryList);

    dwErr = lineGetCountry(
              lpRasCtryInfo->dwCountryID,
              TAPIVERSION,
              &lineCountryList);
    //
    // The spec says if the dwCountryID is
    // invalid, return ERROR_INVALID_PARAMETER.
    //
    if (    dwErr
        || !lineCountryList.dwNeededSize)
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Allocate the buffer required.
    //
    lpLineCountryList = Malloc(
            lineCountryList.dwNeededSize
            );

    if (lpLineCountryList == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Initialize the new buffer and
    // make the call again to get the
    // real information.
    //
    lpLineCountryList->dwTotalSize =
            lineCountryList.dwNeededSize;

    dwErr = lineGetCountry(
              lpRasCtryInfo->dwCountryID,
              TAPIVERSION,
              lpLineCountryList);
    if (dwErr)
    {
        goto done;
    }

    lpLineCountryEntry =   (LPLINECOUNTRYENTRY)
                           ((ULONG_PTR)lpLineCountryList
                         + lpLineCountryList->dwCountryListOffset);

    //
    // Determine if the user's buffer is large enough.
    //
    dwcb = sizeof (RASCTRYINFOW) +
             ((lpLineCountryEntry->dwCountryNameSize + 1)
             * sizeof (WCHAR));

    if (*lpdwcb < dwcb)
    {
        dwErr = ERROR_BUFFER_TOO_SMALL;
    }

    //
    // Save off the size that the caller passed for use in the copy below
    //
    dwcbOrig = *lpdwcb;
    *lpdwcb = dwcb;
    if (dwErr)
    {
        goto done;
    }

    //
    // Fill in the user's buffer with the
    // necessary information.
    //
    lpRasCtryInfo->dwSize = sizeof (RASCTRYINFOW);

    lpRasCtryInfo->dwNextCountryID =
        lpLineCountryEntry->dwNextCountryID;

    lpRasCtryInfo->dwCountryCode =
        lpLineCountryEntry->dwCountryCode;

    pEnd = (PWCHAR)((ULONG_PTR)lpRasCtryInfo
                    + sizeof (RASCTRYINFOW));

    lpRasCtryInfo->dwCountryNameOffset =
                        (DWORD)((ULONG_PTR) pEnd - (ULONG_PTR) lpRasCtryInfo);

    lpszCountryName = (PWCHAR)((ULONG_PTR)lpLineCountryList
                    + lpLineCountryEntry->dwCountryNameOffset);

    lstrcpyn(
        (WCHAR*)pEnd,
        (WCHAR*)lpszCountryName,
        (INT )(((PWCHAR )lpRasCtryInfo + dwcbOrig) - pEnd));
done:

    if(NULL != lpLineCountryList)
    {
        Free(lpLineCountryList);
    }
    return dwErr;
}


DWORD APIENTRY
RasGetCountryInfoA(
    OUT LPRASCTRYINFOA lpRasCtryInfo,
    OUT LPDWORD lpdwcb
    )
{
    DWORD dwErr, dwcb, dwcbOrig;
    LPRASCTRYINFOW lpRasCtryInfoW;
    PCHAR pszCountryName;
    PWCHAR pwszCountryName;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    //
    // Verify parameters.
    //
    if (    lpRasCtryInfo == NULL
        ||  lpdwcb == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (lpRasCtryInfo->dwSize != sizeof (RASCTRYINFOA))
    {
        return ERROR_INVALID_SIZE;
    }

    //
    // Determine the number of bytes
    // we should allocate for the W buffer.
    // Convert the size of the extra bytes
    // at the end from A to W.
    //
    if (*lpdwcb >= sizeof (RASCTRYINFOA))
    {
        dwcb =    sizeof (RASCTRYINFOW)
                + ( (*lpdwcb - sizeof (RASCTRYINFOA))
                   * sizeof (WCHAR));
    }
    else
    {
        dwcb = sizeof (RASCTRYINFOW);
    }

    lpRasCtryInfoW = (LPRASCTRYINFOW) Malloc(dwcb);

    if (lpRasCtryInfoW == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Call the W version to do all the work.
    //
    lpRasCtryInfoW->dwSize = sizeof (RASCTRYINFOW);

    lpRasCtryInfoW->dwCountryID =
                lpRasCtryInfo->dwCountryID;

    dwErr = RasGetCountryInfoW(lpRasCtryInfoW, &dwcb);

    if (!dwcb)
    {
        *lpdwcb = 0;
        goto done;
    }

    //
    // Set *lpdwcb before we return on any error.
    //
    dwcb =    sizeof (RASCTRYINFOA)
            + ((dwcb - sizeof (RASCTRYINFOW)) / sizeof (WCHAR));

    if (*lpdwcb < dwcb)
    {
        dwErr = ERROR_BUFFER_TOO_SMALL;
    }

    //
    // Save off the size that the caller passed for use in the copy below
    //
    dwcbOrig = *lpdwcb;
    *lpdwcb = dwcb;
    if (dwErr)
    {
        goto done;
    }

    //
    // Copy the fields from the W buffer
    // to the A buffer.
    //
    lpRasCtryInfo->dwSize = sizeof (RASCTRYINFOA);

    lpRasCtryInfo->dwNextCountryID =
            lpRasCtryInfoW->dwNextCountryID;

    lpRasCtryInfo->dwCountryCode =
            lpRasCtryInfoW->dwCountryCode;

    //
    // Note the next 3 statements assumes the
    // W and A structure sizes are the same!
    //
    lpRasCtryInfo->dwCountryNameOffset =
        lpRasCtryInfoW->dwCountryNameOffset;

    pszCountryName =
      (PCHAR)((ULONG_PTR)lpRasCtryInfo
      + lpRasCtryInfo->dwCountryNameOffset);

    pwszCountryName =
      (PWCHAR)((ULONG_PTR)lpRasCtryInfoW
      + lpRasCtryInfoW->dwCountryNameOffset);

    strncpyWtoAAnsi(
        pszCountryName,
        pwszCountryName,
        (INT )(((PCHAR )lpRasCtryInfo + dwcbOrig) - pszCountryName));

done:
    Free(lpRasCtryInfoW);
    return dwErr;
}


DWORD APIENTRY
RasGetEntryPropertiesA(
    IN     LPCSTR       lpszPhonebook,
    IN     LPCSTR       lpszEntry,
    OUT    LPRASENTRYA  lpRasEntry,
    IN OUT LPDWORD      lpcbRasEntry,
    OUT    LPBYTE       lpbDeviceConfig,
    IN OUT LPDWORD      lpcbDeviceConfig
    )
{
    NTSTATUS status;

    DWORD dwcb, dwErr;

    LPRASENTRYW lpRasEntryW = NULL;

    WCHAR szPhonebookW[MAX_PATH],
          szEntryNameW[RAS_MaxEntryName + 1];

    BOOL fv50 = TRUE;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    //
    // Verify parameters.
    //
    if (lpcbRasEntry == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (    (lpRasEntry != NULL)
        &&  (lpRasEntry->dwSize != sizeof (RASENTRYA))
        &&  (lpRasEntry->dwSize != sizeof (RASENTRYA_V500))
        &&  (lpRasEntry->dwSize != sizeof (RASENTRYA_V401))
        &&  (lpRasEntry->dwSize != sizeof (RASENTRYA_V400)))
    {
        return ERROR_INVALID_SIZE;
    }

    if (    lpRasEntry != NULL
        &&  *lpcbRasEntry < lpRasEntry->dwSize)
    {
        return ERROR_BUFFER_TOO_SMALL;
    }

    if (    (lpRasEntry != NULL)
        &&  (   (sizeof(RASENTRYA_V401) == lpRasEntry->dwSize)
            ||  (sizeof(RASENTRYA_V400) == lpRasEntry->dwSize)))
    {
        fv50 = FALSE;
    }

    //
    // Convert the lpszPhonebook string to Unicode.
    //
    if (lpszPhonebook != NULL)
    {
        strncpyAtoWAnsi(szPhonebookW,
                    lpszPhonebook,
                    MAX_PATH);
    }

    //
    // Convert the lpszEntry string to Unicode.
    //
    if (lpszEntry != NULL)
    {
        strncpyAtoWAnsi(szEntryNameW,
                    lpszEntry,
                    RAS_MaxEntryName + 1);
    }

    //
    // Determine the size of the W buffer
    // by calculating how many extra CHARs
    // the caller appended onto the end of the
    // A buffer for the alternate phone numbers.
    //
    if (*lpcbRasEntry < sizeof (RASENTRYA))
    {
        dwcb = sizeof (RASENTRYA);
    }
    else
    {
        dwcb = *lpcbRasEntry;
    }

    dwcb = sizeof (RASENTRYW)
         + ((dwcb - sizeof (RASENTRYA)) * sizeof (WCHAR));

    if (lpRasEntry != NULL)
    {
        lpRasEntryW = (LPRASENTRYW)Malloc(dwcb);

        if (lpRasEntryW == NULL)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        //
        // Initialize the W buffer.
        //
        lpRasEntryW->dwSize = sizeof (RASENTRYW);
    }

    //
    // Call the W version to do the work.
    //
    dwErr = RasGetEntryPropertiesW(
              (lpszPhonebook != NULL) ? szPhonebookW : NULL,
              (lpszEntry != NULL) ? szEntryNameW : NULL,
              lpRasEntryW,
              &dwcb,
              lpbDeviceConfig,
              lpcbDeviceConfig);

    if (    !dwErr
        &&  lpRasEntry != NULL)
    {
        //
        // Copy the fields from the W buffer into
        // the user's A buffer.
        //
        lpRasEntry->dwfOptions = lpRasEntryW->dwfOptions;

        lpRasEntry->dwCountryID = lpRasEntryW->dwCountryID;

        lpRasEntry->dwCountryCode = lpRasEntryW->dwCountryCode;

        lpRasEntry->ipaddr = lpRasEntryW->ipaddr;

        lpRasEntry->ipaddrDns = lpRasEntryW->ipaddrDns;

        lpRasEntry->ipaddrDnsAlt = lpRasEntryW->ipaddrDnsAlt;

        lpRasEntry->ipaddrWins = lpRasEntryW->ipaddrWins;

        lpRasEntry->ipaddrWinsAlt = lpRasEntryW->ipaddrWinsAlt;

        lpRasEntry->dwFrameSize = lpRasEntryW->dwFrameSize;

        lpRasEntry->dwfNetProtocols = lpRasEntryW->dwfNetProtocols;

        lpRasEntry->dwFramingProtocol = lpRasEntryW->dwFramingProtocol;

        strncpyWtoAAnsi(lpRasEntry->szScript,
                   lpRasEntryW->szScript,
                   sizeof(lpRasEntry->szScript));

        strncpyWtoAAnsi(lpRasEntry->szX25PadType,
                   lpRasEntryW->szX25PadType,
                   sizeof(lpRasEntry->szX25PadType));

        strncpyWtoAAnsi(lpRasEntry->szX25Address,
                   lpRasEntryW->szX25Address,
                   sizeof(lpRasEntry->szX25Address));

        strncpyWtoAAnsi(lpRasEntry->szX25Facilities,
                   lpRasEntryW->szX25Facilities,
                   sizeof(lpRasEntry->szX25Facilities));

        strncpyWtoAAnsi(lpRasEntry->szX25UserData,
                   lpRasEntryW->szX25UserData,
                   sizeof(lpRasEntry->szX25UserData));

        strncpyWtoAAnsi(lpRasEntry->szAutodialDll,
                   lpRasEntryW->szAutodialDll,
                   sizeof(lpRasEntry->szAutodialDll));

        strncpyWtoAAnsi(lpRasEntry->szAutodialFunc,
                   lpRasEntryW->szAutodialFunc,
                   sizeof(lpRasEntry->szAutodialFunc));

        strncpyWtoAAnsi(lpRasEntry->szAreaCode,
                   lpRasEntryW->szAreaCode,
                   sizeof(lpRasEntry->szAreaCode));

        strncpyWtoAAnsi(lpRasEntry->szLocalPhoneNumber,
                   lpRasEntryW->szLocalPhoneNumber,
                   sizeof(lpRasEntry->szLocalPhoneNumber));

        strncpyWtoAAnsi(lpRasEntry->szDeviceType,
                   lpRasEntryW->szDeviceType,
                   sizeof(lpRasEntry->szDeviceType));

        strncpyWtoAAnsi(lpRasEntry->szDeviceName,
                   lpRasEntryW->szDeviceName,
                   sizeof(lpRasEntry->szDeviceName));

        if (fv50)
        {
            //
            // Guid
            //
            lpRasEntry->guidId = lpRasEntryW->guidId;

            //
            // Entry Type
            //
            lpRasEntry->dwType = lpRasEntryW->dwType;

            //
            // Encryption Type
            //
            lpRasEntry->dwEncryptionType =
                lpRasEntryW->dwEncryptionType;

            //
            // CustomAuthKey for EAP
            //
            if(lpRasEntry->dwfOptions & RASEO_RequireEAP)
            {
                lpRasEntry->dwCustomAuthKey =
                    lpRasEntryW->dwCustomAuthKey;
            }

            //
            // Custom dial dll
            //
            strncpyWtoAAnsi(lpRasEntry->szCustomDialDll,
                       lpRasEntryW->szCustomDialDll,
                       sizeof(lpRasEntry->szCustomDialDll));

            //
            // Entry Properties
            //
            lpRasEntry->dwVpnStrategy = lpRasEntryW->dwVpnStrategy;
        }
        else
        {
            //
            // Zero out the nt5 flags
            //
            lpRasEntry->dwfOptions &= ~(  RASEO_RequireEAP
                                        | RASEO_RequirePAP
                                        | RASEO_RequireSPAP
                                        | RASEO_PreviewPhoneNumber
                                        | RASEO_SharedPhoneNumbers
                                        | RASEO_PreviewUserPw
                                        | RASEO_PreviewDomain
                                        | RASEO_ShowDialingProgress
                                        | RASEO_Custom);

        }

        if(lpRasEntry->dwSize == sizeof(RASENTRYA))
        {
            lpRasEntry->dwfOptions2 = lpRasEntryW->dwfOptions2;
            strncpyWtoAAnsi(lpRasEntry->szDnsSuffix,
                           lpRasEntryW->szDnsSuffix,
                           sizeof(lpRasEntry->szDnsSuffix));
            lpRasEntry->dwTcpWindowSize = lpRasEntryW->dwTcpWindowSize;                           

            strncpyWtoAAnsi(lpRasEntry->szPrerequisitePbk,
                            lpRasEntryW->szPrerequisitePbk,
                            sizeof(lpRasEntry->szPrerequisitePbk));

            strncpyWtoAAnsi(lpRasEntry->szPrerequisiteEntry,
                            lpRasEntryW->szPrerequisiteEntry,
                            sizeof(lpRasEntry->szPrerequisiteEntry));

            lpRasEntry->dwRedialCount = lpRasEntryW->dwRedialCount; 
            lpRasEntry->dwRedialPause = lpRasEntryW->dwRedialPause;
        }

        //
        // Copy the alternate phone numbers to the
        // user's buffer, if any.
        //
        if (lpRasEntryW->dwAlternateOffset)
        {
            DWORD dwcbPhoneNumber;

            PCHAR pszPhoneNumber;

            WCHAR UNALIGNED *pwszPhoneNumber;

            lpRasEntry->dwAlternateOffset = sizeof (RASENTRYA);

            pwszPhoneNumber =
              (PWCHAR)((ULONG_PTR)lpRasEntryW +
                lpRasEntryW->dwAlternateOffset);

            pszPhoneNumber =
              (PCHAR)((ULONG_PTR)lpRasEntry +
                lpRasEntry->dwAlternateOffset);

            while (*pwszPhoneNumber != L'\0')
            {
                WCHAR *pwsz = strdupWU(pwszPhoneNumber);

                if (pwsz == NULL)
                {
                    dwErr = GetLastError();
                    goto done;
                }

                dwcbPhoneNumber = wcslen(pwsz);

                strncpyWtoAAnsi(
                    pszPhoneNumber,
                    pwsz,
                    (INT )(((PCHAR )lpRasEntry + *lpcbRasEntry) -
                        pszPhoneNumber));

                Free(pwsz);

                pwszPhoneNumber += dwcbPhoneNumber + 1;

                pszPhoneNumber += dwcbPhoneNumber + 1;
            }

            //
            // Add another null to terminate
            // the list.
            //
            *pszPhoneNumber = '\0';
        }
        else
        {
            lpRasEntry->dwAlternateOffset = 0;
        }

        //
        // Copy the following fields only for
        // a V401 structure or higher
        //
        if (    (lpRasEntry->dwSize == sizeof (RASENTRYA))
            ||  (lpRasEntry->dwSize == sizeof (RASENTRYA_V500))
            ||  (lpRasEntry->dwSize == sizeof (RASENTRYA_V401)))
        {
            lpRasEntry->dwSubEntries = lpRasEntryW->dwSubEntries;

            lpRasEntry->dwDialMode = lpRasEntryW->dwDialMode;

            lpRasEntry->dwDialExtraPercent =
                        lpRasEntryW->dwDialExtraPercent;

            lpRasEntry->dwDialExtraSampleSeconds =
                    lpRasEntryW->dwDialExtraSampleSeconds;

            lpRasEntry->dwHangUpExtraPercent =
                        lpRasEntryW->dwHangUpExtraPercent;

            lpRasEntry->dwHangUpExtraSampleSeconds =
                    lpRasEntryW->dwHangUpExtraSampleSeconds;

            lpRasEntry->dwIdleDisconnectSeconds =
                    lpRasEntryW->dwIdleDisconnectSeconds;
        }

    }

    //
    // Perform the inverse calculation we did
    // above to translate the A size from the W
    // size.
    //
done:
    *lpcbRasEntry = sizeof (RASENTRYA) +
                ((dwcb - sizeof (RASENTRYW)) / sizeof (WCHAR));
    //
    // Free the temporary W buffers.
    //
    Free(lpRasEntryW);

    return dwErr;
}


DWORD APIENTRY
RasGetEntryPropertiesW(
    IN     LPCWSTR      lpszPhonebook,
    IN     LPCWSTR      lpszEntry,
    OUT    LPRASENTRYW  lpRasEntry,
    IN OUT LPDWORD      lpcbRasEntry,
    OUT    LPBYTE       lpbDeviceConfig,
    IN OUT LPDWORD      lpcbDeviceConfig
    )
{
    DWORD   dwErr;
    PBFILE  pbfile;
    DTLNODE *pdtlnode = NULL;
    PBENTRY *pEntry;
    BOOLEAN fLoaded = FALSE;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    RASAPI32_TRACE("RasGetEntryPropertiesW");

    dwErr = LoadRasmanDllAndInit();
    if (dwErr)
    {
        return dwErr;
    }

    if (DwRasInitializeError)
    {
        return DwRasInitializeError;
    }

    //
    // Validate parameters.
    //
    if (lpcbRasEntry == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (    (lpRasEntry != NULL)
        &&  (lpRasEntry->dwSize != sizeof (RASENTRYW))
        &&  (lpRasEntry->dwSize != sizeof (RASENTRYW_V500))
        &&  (lpRasEntry->dwSize != sizeof (RASENTRYW_V401))
        &&  (lpRasEntry->dwSize != sizeof (RASENTRYW_V400)))
    {
        return ERROR_INVALID_SIZE;
    }

    if (    (lpRasEntry != NULL)
        &&  (*lpcbRasEntry < lpRasEntry->dwSize))
    {
        return ERROR_BUFFER_TOO_SMALL;
    }

	ZeroMemory(&pbfile, sizeof(pbfile));
    pbfile.hrasfile = -1;

    //
    // Initialize return value if supplied.
    //
    if (lpcbDeviceConfig != NULL)
    {
        *lpcbDeviceConfig = 0;
    }

    if (    (lpszEntry == NULL)
        ||  (*lpszEntry == '\0'))
    {
        //
        // If lpszEntry is NULL, initialize an
        // entry with defaults.  Othersize, look
        // up the entry.
        //
        pdtlnode = CreateEntryNode(TRUE);

        if (pdtlnode == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto done;
        }
    }
    else
    {
        //
        // Load the phonebook file.
        //
#ifdef PBCS
        EnterCriticalSection(&PhonebookLock);
#endif

        dwErr = GetPbkAndEntryName(
                        lpszPhonebook,
                        lpszEntry,
                        RPBF_NoCreate,
                        &pbfile,
                        &pdtlnode);

        if(SUCCESS != dwErr)
        {
            goto done;
        }

        fLoaded = TRUE;
    }
    
    pEntry = (PBENTRY *)DtlGetData(pdtlnode);

    //
    // Convert the PBENTRY into a RASENTRY.
    //
    dwErr = PhonebookEntryToRasEntry(
              pEntry,
              lpRasEntry,
              lpcbRasEntry,
              lpbDeviceConfig,
              lpcbDeviceConfig);

done:
    //
    // Clean up.
    //
    if (fLoaded)
    {
        ClosePhonebookFile(&pbfile);

#ifdef PBCS
        LeaveCriticalSection(&PhonebookLock);
#endif

    }
    return dwErr;
}


DWORD APIENTRY
RasSetEntryPropertiesW(
    IN LPCWSTR      lpszPhonebook,
    IN LPCWSTR      lpszEntry,
    IN LPRASENTRYW  lpRasEntry,
    IN DWORD        dwcbRasEntry,
    IN LPBYTE       lpbDeviceConfig,
    IN DWORD        dwcbDeviceConfig
    )
{
    DWORD dwErr;
    PBFILE pbfile;
    DTLNODE *pdtlnode;
    PBENTRY *pEntry;
    BOOL fCreated = FALSE;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    ZeroMemory(&pbfile, sizeof(pbfile));
    pbfile.hrasfile = -1;

    RASAPI32_TRACE("RasSetEntryPropertiesW");

    dwErr = LoadRasmanDllAndInit();
    if (dwErr)
    {
        return dwErr;
    }

    if (DwRasInitializeError)
    {
        return DwRasInitializeError;
    }

    //
    // Validate parameters.
    //
    if (lpRasEntry == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (    (lpRasEntry->dwSize != sizeof (RASENTRYW))
        &&  (lpRasEntry->dwSize != sizeof (RASENTRYW_V500))
        &&  (lpRasEntry->dwSize != sizeof (RASENTRYW_V401))
        &&  (lpRasEntry->dwSize != sizeof (RASENTRYW_V400)))
        
    {
        return ERROR_INVALID_SIZE;
    }

    if (dwcbRasEntry < lpRasEntry->dwSize)
    {
        return ERROR_BUFFER_TOO_SMALL;
    }

    //
    // Load the phonebook file.
    //
#ifdef PBCS
    EnterCriticalSection(&PhonebookLock);
#endif

    dwErr = GetPbkAndEntryName(
                    lpszPhonebook,
                    lpszEntry,
                    0,
                    &pbfile,
                    &pdtlnode);

    if(     (SUCCESS != dwErr)
        &&  (ERROR_CANNOT_FIND_PHONEBOOK_ENTRY != dwErr))
    {
        return dwErr;
    }

    if (pdtlnode != NULL)
    {
        DTLNODE *pdtlnodeNew;

        pdtlnodeNew = DuplicateEntryNode(pdtlnode);

        DtlRemoveNode(pbfile.pdtllistEntries, pdtlnode);

        DestroyEntryNode(pdtlnode);

        pdtlnode = pdtlnodeNew;
    }
    else
    {   
        DWORD dwPbkFlags = 0;

        if ((NULL == lpszPhonebook) && IsConsumerPlatform())
        {
            dwPbkFlags |= RPBF_AllUserPbk;
        }
        
        dwErr = ReadPhonebookFile(lpszPhonebook,
                          NULL,
                          NULL,
                          dwPbkFlags,
                          &pbfile);

        if(dwErr)
        {
            return ERROR_CANNOT_OPEN_PHONEBOOK;
        }
        
        pdtlnode = CreateEntryNode(TRUE);

        fCreated = TRUE;
    }

    if (pdtlnode == NULL)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto done;
    }

    //
    // Add the node to the list of entries.
    //
    DtlAddNodeLast(pbfile.pdtllistEntries, pdtlnode);

    pEntry = (PBENTRY *)DtlGetData(pdtlnode);

    ASSERT(pEntry);

    //
    // Convert the RASENTRY to a PBENTRY.
    //
    dwErr = RasEntryToPhonebookEntry(
              lpszEntry,
              lpRasEntry,
              dwcbRasEntry,
              lpbDeviceConfig,
              dwcbDeviceConfig,
              pEntry);
    if (dwErr)
    {
        goto done;
    }

    //
    // Write out the phonebook file.
    //
    dwErr = WritePhonebookFile(&pbfile, NULL);

    if(ERROR_SUCCESS == dwErr)
    {
        dwErr = DwSendRasNotification(
                    (fCreated)
                    ? ENTRY_ADDED
                    : ENTRY_MODIFIED,
                    pEntry,
                    pbfile.pszPath,
                    NULL);

        dwErr = ERROR_SUCCESS;
    }

done:
    //
    // Clean up.
    //
    ClosePhonebookFile(&pbfile);

#ifdef PBCS
    LeaveCriticalSection(&PhonebookLock);
#endif

    return dwErr;
}


DWORD APIENTRY
RasSetEntryPropertiesA(
    IN LPCSTR       lpszPhonebook,
    IN LPCSTR       lpszEntry,
    IN LPRASENTRYA  lpRasEntry,
    IN DWORD        dwcbRasEntry,
    IN LPBYTE       lpbDeviceConfig,
    IN DWORD        dwcbDeviceConfig
    )
{
    NTSTATUS    status;
    DWORD       dwErr,
                dwcb;
    LPRASENTRYW lpRasEntryW;
    WCHAR       szPhonebookW[MAX_PATH],
                szEntryNameW[RAS_MaxEntryName + 1];

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    //
    // Verify parameters.
    //
    if (lpRasEntry == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (    (lpRasEntry->dwSize != sizeof (RASENTRYA))
        &&  (lpRasEntry->dwSize != sizeof (RASENTRYA_V500))
        &&  (lpRasEntry->dwSize != sizeof (RASENTRYA_V401))
        &&  (lpRasEntry->dwSize != sizeof (RASENTRYA_V400)))
    {
        return ERROR_INVALID_SIZE;
    }

    if (dwcbRasEntry < lpRasEntry->dwSize)
    {
        return ERROR_BUFFER_TOO_SMALL;
    }

    //
    // We don't handle the device
    // configuration parameters yet.
    //
    UNREFERENCED_PARAMETER(lpbDeviceConfig);
    UNREFERENCED_PARAMETER(dwcbDeviceConfig);

    //
    // Convert the lpszPhonebook string to
    // Unicode.
    //
    if (lpszPhonebook != NULL)
    {
        strncpyAtoWAnsi(szPhonebookW,
                    lpszPhonebook,
                    MAX_PATH);
    }

    //
    // Convert the lpszEntry string to Unicode.
    //
    if (lpszEntry == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    strncpyAtoWAnsi(szEntryNameW,
                lpszEntry,
                RAS_MaxEntryName + 1);

    //
    // Determine the size of the W buffer
    // by calculating how many extra CHARs
    // the caller appended onto the end of the
    // A buffer for the alternate phone numbers.
    //
    dwcb =    sizeof (RASENTRYW)
            +
             ( (dwcbRasEntry - lpRasEntry->dwSize)
             * sizeof (WCHAR));

    if (lpRasEntry != NULL)
    {
        lpRasEntryW = (LPRASENTRYW)Malloc(dwcb);

        if (lpRasEntryW == NULL)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        //
        // ZeroMem the rasentryw structure
        //
        ZeroMemory(lpRasEntryW, dwcb);

        //
        // Initialize the W buffer.
        //
        lpRasEntryW->dwSize = sizeof (RASENTRYW);
    }

    //
    // Copy the fields from the A buffer into
    // the user's W buffer.
    //
    lpRasEntryW->dwSize = sizeof (RASENTRYW);

    lpRasEntryW->dwfOptions = lpRasEntry->dwfOptions;

    lpRasEntryW->dwCountryID = lpRasEntry->dwCountryID;

    lpRasEntryW->dwCountryCode = lpRasEntry->dwCountryCode;

    lpRasEntryW->ipaddr = lpRasEntry->ipaddr;

    lpRasEntryW->ipaddrDns = lpRasEntry->ipaddrDns;

    lpRasEntryW->ipaddrDnsAlt = lpRasEntry->ipaddrDnsAlt;

    lpRasEntryW->ipaddrWins = lpRasEntry->ipaddrWins;

    lpRasEntryW->ipaddrWinsAlt = lpRasEntry->ipaddrWinsAlt;

    lpRasEntryW->dwFrameSize = lpRasEntry->dwFrameSize;

    lpRasEntryW->dwfNetProtocols = lpRasEntry->dwfNetProtocols;

    lpRasEntryW->dwFramingProtocol = lpRasEntry->dwFramingProtocol;

    strncpyAtoWAnsi(lpRasEntryW->szScript,
               lpRasEntry->szScript,
               sizeof(lpRasEntryW->szScript) / sizeof(WCHAR));

    strncpyAtoWAnsi(lpRasEntryW->szX25PadType,
               lpRasEntry->szX25PadType,
               sizeof(lpRasEntryW->szX25PadType) / sizeof(WCHAR));

    strncpyAtoWAnsi(lpRasEntryW->szX25Address,
               lpRasEntry->szX25Address,
               sizeof(lpRasEntryW->szX25Address) / sizeof(WCHAR));

    strncpyAtoWAnsi(lpRasEntryW->szX25Facilities,
               lpRasEntry->szX25Facilities,
               sizeof(lpRasEntryW->szX25Facilities) / sizeof(WCHAR));

    strncpyAtoWAnsi(lpRasEntryW->szX25UserData,
               lpRasEntry->szX25UserData,
               sizeof(lpRasEntryW->szX25UserData) / sizeof(WCHAR));

    strncpyAtoWAnsi(lpRasEntryW->szAutodialDll,
               lpRasEntry->szAutodialDll,
               sizeof(lpRasEntryW->szAutodialDll) / sizeof(WCHAR));

    strncpyAtoWAnsi(lpRasEntryW->szAutodialFunc,
               lpRasEntry->szAutodialFunc,
               sizeof(lpRasEntryW->szAutodialFunc) / sizeof(WCHAR));

    strncpyAtoWAnsi(lpRasEntryW->szAreaCode,
               lpRasEntry->szAreaCode,
               sizeof(lpRasEntryW->szAreaCode) / sizeof(WCHAR));

    strncpyAtoWAnsi(lpRasEntryW->szLocalPhoneNumber,
               lpRasEntry->szLocalPhoneNumber,
               sizeof(lpRasEntryW->szLocalPhoneNumber) / sizeof(WCHAR));

    strncpyAtoWAnsi(lpRasEntryW->szDeviceType,
               lpRasEntry->szDeviceType,
               sizeof(lpRasEntryW->szDeviceType) / sizeof(WCHAR));

    strncpyAtoWAnsi(lpRasEntryW->szDeviceName,
               lpRasEntry->szDeviceName,
               sizeof(lpRasEntryW->szDeviceName) / sizeof(WCHAR));

    //
    // Copy the alternate phone numbers to the
    // A buffer, if any.
    //
    if (lpRasEntry->dwAlternateOffset)
    {
        DWORD dwcbPhoneNumber;
        PCHAR pszPhoneNumber;
        WCHAR UNALIGNED *pwszPhoneNumber;

        lpRasEntryW->dwAlternateOffset = sizeof (RASENTRYW);

        pszPhoneNumber = (PCHAR)((ULONG_PTR)lpRasEntry
                       + lpRasEntry->dwAlternateOffset);

        pwszPhoneNumber = (PWCHAR)((ULONG_PTR)lpRasEntryW
                        + lpRasEntryW->dwAlternateOffset);

        while (*pszPhoneNumber != '\0')
        {
            WCHAR *psz;

            dwcbPhoneNumber = strlen(pszPhoneNumber);

            //
            // Extra steps necessary to copy to an
            // unaligned target.
            //
            psz = strdupAtoWAnsi(pszPhoneNumber);
            if (psz == NULL)
            {
                dwErr = GetLastError();
                goto done;
            }

            RtlCopyMemory(
              pwszPhoneNumber,
              psz,
              (dwcbPhoneNumber + 1) * sizeof (WCHAR));
            Free(psz);

            pwszPhoneNumber += dwcbPhoneNumber + 1;
            pszPhoneNumber += dwcbPhoneNumber + 1;
        }

        //
        // Add another null to terminate
        // the list.
        //
        *pwszPhoneNumber = L'\0';
    }
    else
    {
        lpRasEntryW->dwAlternateOffset = 0;
    }

    //
    // Copy the following fields only for
    // a V401 structure.
    //
    if (    lpRasEntry->dwSize == sizeof (RASENTRYA)
        ||  lpRasEntry->dwSize == sizeof ( RASENTRYA_V401 ))
    {
        lpRasEntryW->dwDialMode = lpRasEntry->dwDialMode;

        lpRasEntryW->dwDialExtraPercent =
                        lpRasEntry->dwDialExtraPercent;

        lpRasEntryW->dwDialExtraSampleSeconds =
                    lpRasEntry->dwDialExtraSampleSeconds;

        lpRasEntryW->dwHangUpExtraPercent =
                    lpRasEntry->dwHangUpExtraPercent;

        lpRasEntryW->dwHangUpExtraSampleSeconds =
                lpRasEntry->dwHangUpExtraSampleSeconds;

        lpRasEntryW->dwIdleDisconnectSeconds =
                lpRasEntry->dwIdleDisconnectSeconds;
    }

    //
    // Copy the following fields only for V500 structures
    //
    if (    (lpRasEntry->dwSize == sizeof(RASENTRYA_V500))
        ||  (lpRasEntry->dwSize == sizeof(RASENTRYA)))
    {
        //
        // Entry type
        //
        lpRasEntryW->dwType = lpRasEntry->dwType;

        //
        // dwCustomAuthKey
        //
        lpRasEntryW->dwCustomAuthKey = lpRasEntry->dwCustomAuthKey;

        lpRasEntryW->guidId = lpRasEntry->guidId;

        //
        // Encryption type
        //
        lpRasEntryW->dwEncryptionType =
                lpRasEntry->dwEncryptionType;

        //
        // Custom Dial Dll
        //
        strncpyAtoWAnsi(lpRasEntryW->szCustomDialDll,
                   lpRasEntry->szCustomDialDll,
                   sizeof(lpRasEntryW->szCustomDialDll) / sizeof(WCHAR));

        //
        // vpn strategy
        //
        lpRasEntryW->dwVpnStrategy = lpRasEntry->dwVpnStrategy;

    }

    if(lpRasEntry->dwSize == sizeof(RASENTRYA))
    {
        //
        // Set the additional options bits
        //
        lpRasEntryW->dwfOptions2 = lpRasEntry->dwfOptions2;

        strncpyAtoWAnsi(lpRasEntryW->szDnsSuffix,
                       lpRasEntry->szDnsSuffix,
                       sizeof(lpRasEntryW->szDnsSuffix) / sizeof(WCHAR));

        lpRasEntryW->dwTcpWindowSize = lpRasEntry->dwTcpWindowSize;                       
        
        strncpyAtoWAnsi(lpRasEntryW->szPrerequisitePbk,
                       lpRasEntry->szPrerequisitePbk,
                       sizeof(lpRasEntryW->szPrerequisitePbk) / sizeof(WCHAR));

        strncpyAtoWAnsi(lpRasEntryW->szPrerequisiteEntry,
                       lpRasEntry->szPrerequisiteEntry,
                       sizeof(lpRasEntryW->szPrerequisiteEntry) /
                         sizeof(WCHAR));

        lpRasEntryW->dwRedialCount = lpRasEntry->dwRedialCount;
        lpRasEntryW->dwRedialPause = lpRasEntry->dwRedialPause;

    }

    //
    // Call the W version to do the work.
    //
    dwErr = RasSetEntryPropertiesW(
                (lpszPhonebook != NULL)
              ? szPhonebookW
              : NULL,
                (lpszEntry != NULL)
              ? szEntryNameW
              : NULL,
              lpRasEntryW,
              dwcb,
              lpbDeviceConfig,
              dwcbDeviceConfig);
    //
    // Free the temporary W buffers.
    //
done:
    Free(lpRasEntryW);

    return dwErr;
}


DWORD APIENTRY
RasRenameEntryW(
    IN LPCWSTR lpszPhonebook,
    IN LPCWSTR lpszOldEntry,
    IN LPCWSTR lpszNewEntry
    )
{
    DWORD dwErr;
    PBFILE pbfile;
    DTLNODE *pdtlnode;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    RASAPI32_TRACE("RasRenameEntryW");

    dwErr = LoadRasmanDllAndInit();
    if (dwErr)
    {
        return dwErr;
    }

    if (DwRasInitializeError)
    {
        return DwRasInitializeError;
    }

    //
    // Check the entry names.
    //
    if (    lpszOldEntry == NULL
        ||  lpszNewEntry == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if(lstrlen(lpszNewEntry) > RAS_MaxEntryName)
    {
        return ERROR_INVALID_NAME;
    }

    //
    // Load the phonebook file.
    //
#ifdef PBCS
    EnterCriticalSection(&PhonebookLock);
#endif

    ZeroMemory(&pbfile, sizeof(pbfile));
    pbfile.hrasfile = -1;

    // 196460: (shaunco) Allow changing the case of an entry name.
    // Before, we'd fail with ERROR_ALREADY_EXISTS.
    //
    if (0 != lstrcmpi(lpszNewEntry, lpszOldEntry))
    {
        dwErr = GetPbkAndEntryName(
                        lpszPhonebook,
                        lpszNewEntry,
                        RPBF_NoCreate,
                        &pbfile,
                        &pdtlnode);

        if(SUCCESS == dwErr)
        {
            dwErr = ERROR_ALREADY_EXISTS;
            goto done;
        }
    }

    dwErr = GetPbkAndEntryName(
                    lpszPhonebook,
                    lpszOldEntry,
                    RPBF_NoCreate,
                    &pbfile,
                    &pdtlnode);

    if(ERROR_SUCCESS != dwErr)
    {
        goto done;
    }

    //
    // Rename the entry.
    //
    dwErr = RenamePhonebookEntry(
              &pbfile,
              lpszOldEntry,
              lpszNewEntry,
              pdtlnode);

    if (dwErr)
    {
        goto done;
    }

    //
    // Write out the phonebook file.
    //
    dwErr = WritePhonebookFile(&pbfile,
                               lpszOldEntry);
    if (dwErr)
    {
        goto done;
    }

    // Update the default connection if this is it
    //
    // Ignore the error.  It is non-critical
    //
    dwErr = DwRenameDefaultConnection(
                lpszPhonebook,
                lpszOldEntry,
                lpszNewEntry);
    dwErr = ERROR_SUCCESS;                
        
done:
    //
    // Clean up.
    //
    ClosePhonebookFile(&pbfile);

#ifdef PBCS
    LeaveCriticalSection(&PhonebookLock);
#endif

    return dwErr;
}


DWORD APIENTRY
RasRenameEntryA(
    IN LPCSTR lpszPhonebook,
    IN LPCSTR lpszOldEntry,
    IN LPCSTR lpszNewEntry
    )
{
    NTSTATUS        status;
    DWORD           dwErr;
    ANSI_STRING     ansiString;
    UNICODE_STRING  phonebookString,
                    oldEntryString,
                    newEntryString;
    WCHAR           szPhonebookW[MAX_PATH];
    WCHAR           szOldEntryNameW[RAS_MaxEntryName + 1];
    WCHAR           szNewEntryNameW[RAS_MaxEntryName + 1];

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    //
    // Validate parameters.
    //
    if (    lpszOldEntry == NULL
        ||  lpszNewEntry == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Convert the lpszPhonebook string to Unicode.
    //
    if (lpszPhonebook != NULL)
    {
        strncpyAtoWAnsi(szPhonebookW,
                    lpszPhonebook,
                    MAX_PATH);
    }

    //
    // Convert the lpszOldEntry to Unicode.
    //
    strncpyAtoWAnsi(szOldEntryNameW,
                lpszOldEntry,
                RAS_MaxEntryName + 1);

    //
    // Convert the lpszNewEntry to Unicode.
    //
    strncpyAtoWAnsi(szNewEntryNameW,
                lpszNewEntry,
                RAS_MaxEntryName + 1);

    //
    // Call the W version to do the work.
    //
    dwErr = RasRenameEntryW(
              lpszPhonebook != NULL
              ? szPhonebookW
              : NULL,
              szOldEntryNameW,
              szNewEntryNameW);

    return dwErr;
}


DWORD APIENTRY
RasDeleteEntryW(
    IN LPCWSTR lpszPhonebook,
    IN LPCWSTR lpszEntry
    )
{
    DWORD dwErr;
    PBFILE pbfile;
    DTLNODE *pdtlnode;
    PBENTRY *pEntry;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    RASAPI32_TRACE("RasDeleteEntryW");

    dwErr = LoadRasmanDllAndInit();
    if (dwErr)
    {
        return dwErr;
    }

    if (DwRasInitializeError)
    {
        return DwRasInitializeError;
    }

    //
    // Verify parameters.
    //
    if (lpszEntry == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Load the phonebook file.
    //
#ifdef PBCS
    EnterCriticalSection(&PhonebookLock);
#endif

    ZeroMemory(&pbfile, sizeof(pbfile));
    pbfile.hrasfile = -1;

    dwErr = GetPbkAndEntryName(
                    lpszPhonebook,
                    lpszEntry,
                    RPBF_NoCreate,
                    &pbfile,
                    &pdtlnode);

    if(SUCCESS != dwErr)
    {
        goto done;
    }

    //
    // Remove this entry.
    //
    DtlRemoveNode(pbfile.pdtllistEntries, pdtlnode);

    //
    // Write out the phonebook file.
    //
    pEntry = (PBENTRY *)DtlGetData(pdtlnode);

    dwErr = WritePhonebookFile(&pbfile,
                              pEntry->pszEntryName);

    if (dwErr)
    {
        goto done;
    }

    //
    // Delete any home networking information associated with
    // this entry. Any errors that may occur are not fatal.
    //
    {
        HMODULE hHNetCfg;
        FARPROC pHNetDeleteRasConnection;

        hHNetCfg = LoadLibraryW(L"hnetcfg");

        if (NULL != hHNetCfg)
        {
            pHNetDeleteRasConnection =
                GetProcAddress(hHNetCfg, "HNetDeleteRasConnection");

            if (NULL != pHNetDeleteRasConnection)
            {
                (VOID)(*pHNetDeleteRasConnection)(pEntry->pGuid);
            }

            FreeLibrary(hHNetCfg);
        }
    }

    //
    // Delete the dialparams we store in lsa for this entry
    //
    dwErr = g_pRasSetDialParams(
              pEntry->dwDialParamsUID,
              DLPARAMS_MASK_DELETE | DLPARAMS_MASK_OLDSTYLE,
              NULL,
              FALSE);

    if(ERROR_SUCCESS != dwErr)
    {
        //
        // This is not fatal
        //
        RASAPI32_TRACE("RasSetDialParams(DLPARAMS_MASK_DELETE) failed");
    }

    dwErr = RasSetKey(
                NULL,
                pEntry->pGuid,
                DLPARAMS_MASK_PRESHAREDKEY,
                0, NULL);

    if(ERROR_SUCCESS != dwErr)
    {
        RASAPI32_TRACE1("RasSetKey returned error %d", dwErr);
    }
    

    if(     (NULL != pEntry->pszCustomDialerName)
      &&    (TEXT('\0') != pEntry->pszCustomDialerName[0]))
    {
        //
        // Notify Custom Dlls of the delete so that they can
        // clean up their state. First check to see if the
        // dll is a valid dll.
        //
        dwErr = DwCustomDeleteEntryNotify(
                                pbfile.pszPath,
                                lpszEntry,
                                pEntry->pszCustomDialerName);

        dwErr = NO_ERROR;
    }
    
    dwErr = DwSendRasNotification(ENTRY_DELETED,
                                  pEntry,
                                  pbfile.pszPath,
                                  NULL);

    dwErr = ERROR_SUCCESS;

    DestroyEntryNode(pdtlnode);

done:

    //
    // Clean up.
    //
    ClosePhonebookFile(&pbfile);

#ifdef PBCS
    LeaveCriticalSection(&PhonebookLock);
#endif

    return dwErr;
}


DWORD APIENTRY
RasDeleteEntryA(
    IN LPCSTR lpszPhonebook,
    IN LPCSTR lpszEntry
    )
{
    NTSTATUS status;
    DWORD    dwErr;
    WCHAR    szPhonebookW[MAX_PATH],
             szEntryNameW[RAS_MaxEntryName + 1];

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    //
    // Validate parameters.
    //
    if (lpszEntry == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Convert the lpszPhonebook string to Unicode.
    //
    if (lpszPhonebook != NULL)
    {
        strncpyAtoWAnsi(szPhonebookW,
                    lpszPhonebook,
                    MAX_PATH);
    }

    //
    // Convert the lpszEntry to Unicode.
    //
    strncpyAtoWAnsi(szEntryNameW,
                lpszEntry,
                RAS_MaxEntryName + 1);

    //
    // Call the W version to do the work.
    //
    dwErr = RasDeleteEntryW(
              lpszPhonebook != NULL
              ? szPhonebookW
              : NULL,
              szEntryNameW);

    return dwErr;
}


DWORD APIENTRY
RasValidateEntryNameW(
    IN LPCWSTR lpszPhonebook,
    IN LPCWSTR lpszEntry
    )
{
    DWORD dwErr;
    PBFILE pbfile;
    DTLNODE *pdtlnode;
    PBENTRY *pEntry;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    RASAPI32_TRACE("RasValidateEntryNameW");

    dwErr = LoadRasmanDllAndInit();
    if (dwErr)
    {
        return dwErr;
    }

    if (DwRasInitializeError)
    {
        return DwRasInitializeError;
    }

    //
    // Verify parameters.
    //
    if (lpszEntry == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    ZeroMemory(&pbfile, sizeof(pbfile));
    pbfile.hrasfile = -1;
    
    dwErr = GetPbkAndEntryName(
                    lpszPhonebook,
                    lpszEntry,
                    RPBF_NoCreate,
                    &pbfile,
                    &pdtlnode);

    if(     (SUCCESS == dwErr)
        &&  (NULL != pdtlnode))
    {
        dwErr = ERROR_ALREADY_EXISTS;
        goto done;
    }

    if(     (NULL == pdtlnode)
        &&  (ERROR_SUCCESS != dwErr)
        &&  (NULL != lpszPhonebook)
        &&  (ERROR_SUCCESS != ReadPhonebookFile(
                lpszPhonebook,
                NULL,
                lpszEntry,
                RPBF_NoCreate,
                &pbfile)))
    {
        dwErr = ERROR_CANNOT_OPEN_PHONEBOOK;
        goto done;
    }

    //
    // Validate the entry name.
    //
    dwErr = ValidateEntryName(lpszEntry)
            ? 0
            : ERROR_INVALID_NAME;

done:
    //
    // Clean up.
    //
    ClosePhonebookFile(&pbfile);

#ifdef PBCS
    LeaveCriticalSection(&PhonebookLock);
#endif

    return dwErr;
}


DWORD APIENTRY
RasValidateEntryNameA(
    IN LPCSTR lpszPhonebook,
    IN LPCSTR lpszEntry
    )
{
    NTSTATUS status;
    DWORD    dwErr;
    WCHAR    szPhonebookW[MAX_PATH],
             szEntryNameW[RAS_MaxEntryName + 1];

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    //
    // Validate parameters.
    //
    if (lpszEntry == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Convert the lpszPhonebook string to Unicode.
    //
    if (lpszPhonebook != NULL)
    {
        strncpyAtoWAnsi(szPhonebookW,
                    lpszPhonebook,
                    MAX_PATH);
    }

    //
    // Convert the lpszEntry to Unicode.
    //
    strncpyAtoWAnsi(szEntryNameW,
                lpszEntry,
                RAS_MaxEntryName + 1);

    //
    // Call the W version to do the work.
    //
    dwErr = RasValidateEntryNameW(
              lpszPhonebook != NULL
              ? szPhonebookW
              : NULL,
              szEntryNameW);

    return dwErr;
}


DWORD APIENTRY
RasGetSubEntryHandleW(
    IN HRASCONN hrasconn,
    IN DWORD dwSubEntry,
    OUT LPHRASCONN lphrasconn
    )
{
    DWORD dwErr;
    HPORT hport = NULL;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    RASAPI32_TRACE("RasGetSubEntryHandleW");

    dwErr = LoadRasmanDllAndInit();

    if (dwErr)
    {
        return dwErr;
    }

    if (DwRasInitializeError)
    {
        return DwRasInitializeError;
    }

    dwErr = SubEntryPort(hrasconn, dwSubEntry, &hport);
    if (dwErr)
    {
        return (dwErr != ERROR_PORT_NOT_OPEN ?
                ERROR_NO_MORE_ITEMS :
                ERROR_PORT_NOT_OPEN);
    }

    //
    // If we successfully get the port handle, we return
    // the encoded port handle as the subentry handle.
    // All RAS APIs that accept an HRASCONN
    // also check for an encoded HPORT.
    //
    *lphrasconn = HPORT_TO_HRASCONN(hport);

    return 0;
}


DWORD APIENTRY
RasGetSubEntryHandleA(
    IN HRASCONN hrasconn,
    IN DWORD dwSubEntry,
    OUT LPHRASCONN lphrasconn
    )
{
    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    return RasGetSubEntryHandleW(hrasconn,
                                 dwSubEntry,
                                 lphrasconn);
}


DWORD APIENTRY
RasConnectionNotificationW(
    IN HRASCONN hrasconn,
    IN HANDLE hEvent,
    IN DWORD dwfEvents
    )
{
    DWORD dwErr;
    HCONN hconn;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    dwErr = LoadRasmanDllAndInit();
    if (dwErr)
    {
        return dwErr;
    }

    if (DwRasInitializeError)
    {
        return DwRasInitializeError;
    }

    hconn = IS_HPORT(hrasconn) ?
              (HCONN)HRASCONN_TO_HPORT(hrasconn) :
              (HCONN)hrasconn;

    return g_pRasAddNotification(
                            hconn,
                            hEvent,
                            dwfEvents);
}


DWORD APIENTRY
RasConnectionNotificationA(
    IN HRASCONN hrasconn,
    IN HANDLE hEvent,
    IN DWORD dwfEvents
    )
{
    return RasConnectionNotificationW(
                                hrasconn,
                                hEvent,
                                dwfEvents);
}


DWORD APIENTRY
RasGetSubEntryPropertiesA(
    IN LPCSTR lpszPhonebook,
    IN LPCSTR lpszEntry,
    IN DWORD dwSubEntry,
    OUT LPRASSUBENTRYA lpRasSubEntry,
    IN OUT LPDWORD lpcbRasSubEntry,
    OUT LPBYTE lpbDeviceConfig,
    IN OUT LPDWORD lpcbDeviceConfig
    )
{
    NTSTATUS    status;
    DWORD       dwcb,
                dwErr;

    LPRASSUBENTRYW lpRasSubEntryW = NULL;

    WCHAR szPhonebookW[MAX_PATH],
          szEntryNameW[RAS_MaxEntryName + 1];

    DWORD dwSize;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    //
    // Verify parameters.
    //
    if (lpcbRasSubEntry == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (    (lpRasSubEntry != NULL)
        &&  (sizeof (RASSUBENTRYA) !=
            lpRasSubEntry->dwSize))
    {
        return ERROR_INVALID_SIZE;
    }

    //
    // Convert the lpszPhonebook string to Unicode.
    //
    if (lpszPhonebook != NULL)
    {
        strncpyAtoWAnsi(szPhonebookW,
                    lpszPhonebook,
                    MAX_PATH);
    }

    //
    // Convert the lpszEntry string to Unicode.
    //
    if (lpszEntry == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    strncpyAtoWAnsi(szEntryNameW,
                lpszEntry,
                RAS_MaxEntryName + 1);

    //
    // Determine the size of the W buffer
    // by calculating how many extra CHARs
    // the caller appended onto the end of the
    // A buffer for the alternate phone numbers.
    //
    if (*lpcbRasSubEntry < sizeof (RASSUBENTRYA))
    {
        dwcb = sizeof (RASSUBENTRYA);
    }
    else
    {
        dwcb = *lpcbRasSubEntry;
    }

    dwcb =    sizeof (RASSUBENTRYW)
            + ((dwcb - sizeof(RASSUBENTRYA)) * sizeof (WCHAR));

    if (lpRasSubEntry != NULL)
    {
        lpRasSubEntryW = (LPRASSUBENTRYW)Malloc(dwcb);

        if (lpRasSubEntryW == NULL)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        //
        // Initialize the W buffer.
        //
        lpRasSubEntryW->dwSize = sizeof (RASSUBENTRYW);
    }


    //
    // Call the W version to do the work.
    //
    dwErr = RasGetSubEntryPropertiesW(
              lpszPhonebook != NULL ? szPhonebookW : NULL,
              szEntryNameW,
              dwSubEntry,
              lpRasSubEntryW,
              &dwcb,
              lpbDeviceConfig,
              lpcbDeviceConfig);

    if (!dwErr && lpRasSubEntry != NULL)
    {
        //
        // Copy the fields from the W buffer into
        // the user's A buffer.
        //
        lpRasSubEntry->dwfFlags = lpRasSubEntryW->dwfFlags;

        strncpyWtoAAnsi(lpRasSubEntry->szLocalPhoneNumber,
                   lpRasSubEntryW->szLocalPhoneNumber,
                   sizeof(lpRasSubEntry->szLocalPhoneNumber));

        strncpyWtoAAnsi(lpRasSubEntry->szDeviceType,
                   lpRasSubEntryW->szDeviceType,
                   sizeof(lpRasSubEntry->szDeviceType));

        strncpyWtoAAnsi(lpRasSubEntry->szDeviceName,
                   lpRasSubEntryW->szDeviceName,
                   sizeof(lpRasSubEntry->szDeviceName));

        //
        // Copy the alternate phone numbers to the
        // user's buffer, if any.
        //
        if (lpRasSubEntryW->dwAlternateOffset)
        {
            DWORD dwcbPhoneNumber;
            PCHAR pszPhoneNumber;
            WCHAR UNALIGNED *pwszPhoneNumber;

            lpRasSubEntry->dwAlternateOffset =
                            sizeof (RASSUBENTRYA);

            pwszPhoneNumber =
              (PWCHAR)((ULONG_PTR)lpRasSubEntryW +
                lpRasSubEntryW->dwAlternateOffset);

            pszPhoneNumber =
              (PCHAR)((ULONG_PTR)lpRasSubEntry +
                lpRasSubEntry->dwAlternateOffset);

            while (*pwszPhoneNumber != L'\0')
            {
                WCHAR *pwsz = strdupWU(pwszPhoneNumber);

                //
                // Extra steps necessary to copy from
                // an unaligned target.
                //
                if (pwsz == NULL)
                {
                    dwErr = GetLastError();
                    goto done;
                }

                dwcbPhoneNumber = wcslen(pwsz);
                strncpyWtoAAnsi(
                    pszPhoneNumber,
                    pwsz,
                    (INT )(((PCHAR )lpRasSubEntry + *lpcbRasSubEntry) -
                        pszPhoneNumber));
                Free(pwsz);

                pwszPhoneNumber += dwcbPhoneNumber + 1;
                pszPhoneNumber += dwcbPhoneNumber + 1;
            }

            //
            // Add another null to terminate
            // the list.
            //
            *pszPhoneNumber = '\0';
        }
        else
        {
            lpRasSubEntry->dwAlternateOffset = 0;
        }
    }

    //
    // Perform the inverse calculation we did
    // above to translate the A size from the W
    // size.
    //
done:
    *lpcbRasSubEntry =   sizeof (RASSUBENTRYA)
                       + ((dwcb - sizeof (RASSUBENTRYW))
                       / sizeof (WCHAR));

    //
    // Free the temporary W buffers.
    //
    Free(lpRasSubEntryW);

    RASAPI32_TRACE2("done. *lpcb=%d,dwerr=%d",
           *lpcbRasSubEntry,
           dwErr );

    return dwErr;
}


DWORD APIENTRY
RasGetSubEntryPropertiesW(
    IN  LPCWSTR         lpszPhonebook,
    IN  LPCWSTR         lpszEntry,
    IN  DWORD           dwSubEntry,
    OUT LPRASSUBENTRYW  lpRasSubEntry,
    IN  OUT LPDWORD     lpcbRasSubEntry,
    OUT LPBYTE          lpbDeviceConfig,
    IN  OUT LPDWORD     lpcbDeviceConfig
    )
{
    DWORD dwErr;
    PBFILE pbfile;
    DTLNODE *pdtlnode = NULL;
    PBENTRY *pEntry;
    PBLINK *pLink;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    RASAPI32_TRACE("RasGetSubEntryPropertiesW");

    dwErr = LoadRasmanDllAndInit();
    if (dwErr)
    {
        return dwErr;
    }

    if (DwRasInitializeError)
    {
        return DwRasInitializeError;
    }

    //
    // Validate parameters.
    //
    if (    lpcbRasSubEntry == NULL
        ||  !dwSubEntry)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (    lpRasSubEntry != NULL
        &&  lpRasSubEntry->dwSize != sizeof (RASSUBENTRYW))
    {
        return ERROR_INVALID_SIZE;
    }

    //
    // Load the phonebook file.
    //
#ifdef PBCS
    EnterCriticalSection(&PhonebookLock);
#endif
    
    ZeroMemory(&pbfile, sizeof(PBFILE));    //for bug170548
    pbfile.hrasfile = -1;

    dwErr = GetPbkAndEntryName(
                lpszPhonebook,
                lpszEntry,
                RPBF_NoCreate,
                &pbfile,
                &pdtlnode);

    if(SUCCESS != dwErr)
    {
        goto done;
    }

    pEntry = (PBENTRY *)DtlGetData(pdtlnode);

    //
    // Get the subentry specified.
    //
    pdtlnode = DtlNodeFromIndex(
                 pEntry->pdtllistLinks,
                 dwSubEntry - 1);

    //
    // If the subentry doesn't exist, then
    // return an error.
    //
    if (pdtlnode == NULL)
    {
        dwErr = ERROR_CANNOT_FIND_PHONEBOOK_ENTRY;
        goto done;
    }

    pLink = (PBLINK *)DtlGetData(pdtlnode);
    ASSERT(pLink);

    //
    // Convert the PBLINK into a RASSUBENTRY.
    //
    dwErr = PhonebookLinkToRasSubEntry(
              pLink,
              lpRasSubEntry,
              lpcbRasSubEntry,
              lpbDeviceConfig,
              lpcbDeviceConfig);

done:

    //
    // Clean up.
    //
    ClosePhonebookFile(&pbfile);

#ifdef PBCS
    LeaveCriticalSection(&PhonebookLock);
#endif

    return dwErr;
}


DWORD APIENTRY
RasSetSubEntryPropertiesW(
    IN LPCWSTR lpszPhonebook,
    IN LPCWSTR lpszEntry,
    IN DWORD dwSubEntry,
    IN LPRASSUBENTRYW lpRasSubEntry,
    IN DWORD dwcbRasSubEntry,
    IN LPBYTE lpbDeviceConfig,
    IN DWORD dwcbDeviceConfig
    )
{
    DWORD dwErr, dwSubEntries;
    PBFILE pbfile;
    DTLNODE *pdtlnode = NULL;
    PBENTRY *pEntry;
    PBLINK *pLink;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    RASAPI32_TRACE("RasSetSubEntryPropertiesW");

    dwErr = LoadRasmanDllAndInit();
    if (dwErr)
    {
        return dwErr;
    }

    if (DwRasInitializeError)
    {
        return DwRasInitializeError;
    }

    //
    // Validate parameters.
    //
    if (lpRasSubEntry == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (lpRasSubEntry->dwSize != sizeof (RASSUBENTRYW))
    {
        return ERROR_INVALID_SIZE;
    }

    if (dwcbRasSubEntry < lpRasSubEntry->dwSize)
    {
        return ERROR_BUFFER_TOO_SMALL;
    }

    //
    // Load the phonebook file.
    //
#ifdef PBCS
    EnterCriticalSection(&PhonebookLock);
#endif

    ZeroMemory(&pbfile, sizeof(pbfile));
    pbfile.hrasfile = -1;

    dwErr = GetPbkAndEntryName(
                        lpszPhonebook,
                        lpszEntry,
                        0,
                        &pbfile,
                        &pdtlnode);

    if(SUCCESS != dwErr)
    {
        goto done;
    }

    pEntry = (PBENTRY *)DtlGetData(pdtlnode);
    ASSERT(pEntry);

    //
    // Get the subentry specified.
    //
    dwSubEntries = DtlGetNodes(pEntry->pdtllistLinks);

    if (dwSubEntry <= dwSubEntries)
    {
        pdtlnode = DtlNodeFromIndex(
                     pEntry->pdtllistLinks,
                     dwSubEntry - 1);

        //
        // If the subentry doesn't exist, then
        // return an error.
        //
        if (pdtlnode == NULL)
        {
            dwErr = ERROR_CANNOT_FIND_PHONEBOOK_ENTRY;
            goto done;
        }
    }
    else if (dwSubEntry == dwSubEntries + 1)
    {
        //
        // Create a new link node and add it
        // to the tail of the links.
        //
        pdtlnode = CreateLinkNode();
        DtlAddNodeLast(pEntry->pdtllistLinks, pdtlnode);
    }
    else
    {
        dwErr = ERROR_CANNOT_FIND_PHONEBOOK_ENTRY;
        goto done;
    }

    pLink = (PBLINK *)DtlGetData(pdtlnode);

    ASSERT(pLink);

    //
    //
    // Convert the RASENTRY to a PBENTRY.
    //
    dwErr = RasSubEntryToPhonebookLink(
              pEntry,
              lpRasSubEntry,
              dwcbRasSubEntry,
              lpbDeviceConfig,
              dwcbDeviceConfig,
              pLink);
    if (dwErr)
    {
        goto done;
    }

    //
    // Write out the phonebook file.
    //
    dwErr = WritePhonebookFile(&pbfile, NULL);

done:
    //
    // Clean up.
    //
    ClosePhonebookFile(&pbfile);
#ifdef PBCS
    LeaveCriticalSection(&PhonebookLock);
#endif
    return dwErr;
}


DWORD APIENTRY
RasSetSubEntryPropertiesA(
    IN  LPCSTR          lpszPhonebook,
    IN  LPCSTR          lpszEntry,
    IN  DWORD           dwSubEntry,
    OUT LPRASSUBENTRYA  lpRasSubEntry,
    IN  DWORD           dwcbRasSubEntry,
    IN  LPBYTE          lpbDeviceConfig,
    IN  DWORD           dwcbDeviceConfig
    )
{
    NTSTATUS    status;
    DWORD       dwErr,
                dwcb;

    LPRASSUBENTRYW lpRasSubEntryW;

    WCHAR szPhonebookW[MAX_PATH],
          szEntryNameW[RAS_MaxEntryName + 1];

    DWORD   dwSize;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    //
    // Verify parameters.
    //
    if (lpRasSubEntry == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (sizeof (RASSUBENTRYA) !=
        lpRasSubEntry->dwSize)
    {
        return ERROR_INVALID_SIZE;
    }

    if (dwcbRasSubEntry < lpRasSubEntry->dwSize)
    {
        return ERROR_BUFFER_TOO_SMALL;
    }

    //
    // Convert the lpszPhonebook string to Unicode.
    //
    if (lpszPhonebook != NULL)
    {
        strncpyAtoWAnsi(szPhonebookW,
                    lpszPhonebook,
                    MAX_PATH);
    }

    //
    // Convert the lpszEntry string to Unicode.
    //
    if (lpszEntry == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    strncpyAtoWAnsi(szEntryNameW,
                lpszEntry,
                RAS_MaxEntryName + 1);

    //
    // Determine the size of the W buffer
    // by calculating how many extra CHARs
    // the caller appended onto the end of the
    // A buffer for the alternate phone numbers.
    //
    dwcb = sizeof (RASSUBENTRYW)
         + ((dwcbRasSubEntry - sizeof(RASSUBENTRYA))
         * sizeof (WCHAR));

    if (lpRasSubEntry != NULL)
    {
        lpRasSubEntryW = (LPRASSUBENTRYW)Malloc(dwcb);

        if (lpRasSubEntryW == NULL)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        //
        // Initialize the W buffer.
        //
        lpRasSubEntryW->dwSize = sizeof (RASSUBENTRYW);
    }

    //
    // Copy the fields from the A buffer into
    // the user's W buffer.
    //
    lpRasSubEntryW->dwSize = sizeof (RASSUBENTRYW);

    lpRasSubEntryW->dwfFlags = lpRasSubEntry->dwfFlags;

    strncpyAtoWAnsi(lpRasSubEntryW->szLocalPhoneNumber,
               lpRasSubEntry->szLocalPhoneNumber,
               sizeof(lpRasSubEntryW->szLocalPhoneNumber) / sizeof(WCHAR));

    strncpyAtoWAnsi(lpRasSubEntryW->szDeviceType,
               lpRasSubEntry->szDeviceType,
               sizeof(lpRasSubEntryW->szDeviceType) / sizeof(WCHAR));

    strncpyAtoWAnsi(lpRasSubEntryW->szDeviceName,
               lpRasSubEntry->szDeviceName,
               sizeof(lpRasSubEntryW->szDeviceName) / sizeof(WCHAR));

    //
    // Copy the alternate phone numbers to the
    // A buffer, if any.
    //
    if (lpRasSubEntry->dwAlternateOffset)
    {
        DWORD dwcbPhoneNumber;

        PCHAR pszPhoneNumber;

        WCHAR UNALIGNED *pwszPhoneNumber;

        lpRasSubEntryW->dwAlternateOffset = sizeof (RASSUBENTRYW);

        pszPhoneNumber = (PCHAR)((ULONG_PTR)lpRasSubEntry
                       + lpRasSubEntry->dwAlternateOffset);

        pwszPhoneNumber = (PWCHAR)((ULONG_PTR)lpRasSubEntryW
                        + lpRasSubEntryW->dwAlternateOffset);

        while (*pszPhoneNumber != '\0')
        {
            WCHAR *psz;

            dwcbPhoneNumber = strlen(pszPhoneNumber);

            //
            // Extra steps necessary to copy to an
            // unaligned target.
            //
            psz = strdupAtoWAnsi(pszPhoneNumber);

            if (psz == NULL)
            {
                dwErr = GetLastError();
                goto done;
            }

            RtlCopyMemory(
              pwszPhoneNumber,
              psz,
              (dwcbPhoneNumber + 1) * sizeof (WCHAR));
            Free(psz);

            pwszPhoneNumber += dwcbPhoneNumber + 1;
            pszPhoneNumber += dwcbPhoneNumber + 1;
        }

        //
        // Add another null to terminate
        // the list.
        //
        *pwszPhoneNumber = L'\0';
    }
    else
    {
        lpRasSubEntryW->dwAlternateOffset = 0;
    }

    //
    // Call the A version to do the work.
    //
    dwErr = RasSetSubEntryPropertiesW(
              lpszPhonebook != NULL ? szPhonebookW : NULL,
              szEntryNameW,
              dwSubEntry,
              lpRasSubEntryW,
              dwcb,
              lpbDeviceConfig,
              dwcbDeviceConfig);
    //
    // Free the temporary W buffers.
    //
done:
    Free(lpRasSubEntryW);

    return dwErr;
}


DWORD APIENTRY
RasGetCredentialsW(
    IN  LPCWSTR           lpszPhonebook,
    IN  LPCWSTR           lpszEntry,
    OUT LPRASCREDENTIALSW lpRasCredentials
    )
{
    DWORD dwErr;
    PBFILE pbfile;
    DTLNODE *pdtlnode = NULL;
    PBENTRY *pEntry = NULL;
    DWORD dwMask;
    RAS_DIALPARAMS dialparams;
    BOOL fPbk = FALSE;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    RASAPI32_TRACE("RasGetCredentialsW");

    dwErr = LoadRasmanDllAndInit();
    if (dwErr)
    {
        return dwErr;
    }

    if (DwRasInitializeError)
    {
        return DwRasInitializeError;
    }

    //
    // Validate parameters.
    //
    if (lpRasCredentials == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (lpRasCredentials->dwSize
        != sizeof (RASCREDENTIALSW))
    {
        return ERROR_INVALID_SIZE;
    }

    if(     ((lpRasCredentials->dwMask & RASCM_PreSharedKey)
        &&  (lpRasCredentials->dwMask != RASCM_PreSharedKey))
        ||  ((lpRasCredentials->dwMask & RASCM_DDMPreSharedKey)
        &&  (lpRasCredentials->dwMask != RASCM_DDMPreSharedKey))
        ||  ((lpRasCredentials->dwMask & RASCM_ServerPreSharedKey)
        &&  (lpRasCredentials->dwMask != RASCM_ServerPreSharedKey)))
    {
        return ERROR_INVALID_PARAMETER;
    }
    

    //
    // Load the phonebook file.
    //
#ifdef PBCS
    EnterCriticalSection(&PhonebookLock);
#endif

    ZeroMemory(&pbfile, sizeof(pbfile));
    pbfile.hrasfile = -1;

    if(0 == (RASCM_ServerPreSharedKey & lpRasCredentials->dwMask))
    {
        dwErr = GetPbkAndEntryName(
                            lpszPhonebook,
                            lpszEntry,
                            RPBF_NoCreate,
                            &pbfile,
                            &pdtlnode);

        if(SUCCESS != dwErr)
        {
            goto done;
        }

        fPbk = TRUE;

        pEntry = (PBENTRY *)DtlGetData(pdtlnode);
        ASSERT(pEntry);
    }

    // Set the appropriate flags to get the requested fields.
    //
    // (SteveC) Changed to include "old-style" bit so that Set/GetCredentials
    //    and Get/SetDialParams share the same data store.  See bug 335748,.
    //
    dwMask = lpRasCredentials->dwMask | DLPARAMS_MASK_OLDSTYLE;

    if(     (lpRasCredentials->dwMask & RASCM_PreSharedKey)
        ||  (lpRasCredentials->dwMask & RASCM_DDMPreSharedKey)
        ||  (lpRasCredentials->dwMask & RASCM_ServerPreSharedKey))
    {
        DWORD cbkey = (PWLEN + 1) * sizeof(WCHAR);
        
        dwMask = DLPARAMS_MASK_PRESHAREDKEY;
        if(lpRasCredentials->dwMask & RASCM_DDMPreSharedKey)
        {
            dwMask = DLPARAMS_MASK_DDM_PRESHAREDKEY;
        }
        else if(lpRasCredentials->dwMask & RASCM_ServerPreSharedKey)
        {
            dwMask = DLPARAMS_MASK_SERVER_PRESHAREDKEY;
        }
        
        dwErr = RasGetKey(
                    NULL,
                    (NULL != pEntry)
                    ? pEntry->pGuid
                    : NULL,
                    dwMask,
                    &cbkey,
                    (BYTE *) lpRasCredentials->szPassword);

        if(ERROR_SUCCESS != dwErr)
        {
            lpRasCredentials->dwMask = 0;
        }
        
        goto done;
    }

    if(dwMask & RASCM_DefaultCreds)
    {
        dwMask |= DLPARAMS_MASK_DEFAULT_CREDS;
    }

    //
    // Get the dial parameters from rasman.
    //
    dwErr = g_pRasGetDialParams(pEntry->dwDialParamsUID,
                                &dwMask,
                                &dialparams);
    if (dwErr)
    {
        goto done;
    }

    //
    // Copy the fields back to the
    // lpRasCredentials structure.
    //
    lpRasCredentials->dwMask = dwMask;

    if(lpRasCredentials->dwMask & DLPARAMS_MASK_DEFAULT_CREDS)
    {
        lpRasCredentials->dwMask &= ~DLPARAMS_MASK_DEFAULT_CREDS;
        lpRasCredentials->dwMask |= RASCM_DefaultCreds;

#if DBG
        if(!IsPublicPhonebook(pbfile.pszPath))
        {
            DbgPrint("RasGetCredentials was set for a per-user"
                    " phonebook %ws\n",pbfile.pszPath);
                    
            ASSERT(FALSE);
        }
#endif
    }

    if (dwMask & DLPARAMS_MASK_USERNAME)
    {
        lstrcpyn(lpRasCredentials->szUserName,
                 dialparams.DP_UserName,
                 sizeof(lpRasCredentials->szUserName) / sizeof(WCHAR));
    }
    else
    {
        *lpRasCredentials->szUserName = L'\0';
    }

    if (   (dwMask & DLPARAMS_MASK_PASSWORD)
        || (dwMask & DLPARAMS_MASK_PRESHAREDKEY)
        || (dwMask & DLPARAMS_MASK_SERVER_PRESHAREDKEY))
    {
        lstrcpyn(lpRasCredentials->szPassword,
                 dialparams.DP_Password,
                 sizeof(lpRasCredentials->szPassword) / sizeof(WCHAR));
    }
    else
    {
        *lpRasCredentials->szPassword = L'\0';
    }

    if (dwMask & DLPARAMS_MASK_DOMAIN)
    {
        lstrcpyn(lpRasCredentials->szDomain,
                 dialparams.DP_Domain,
                 sizeof(lpRasCredentials->szDomain) / sizeof(WCHAR));
    }
    else
    {
        *lpRasCredentials->szDomain = L'\0';
    }

done:
    //
    // Clean up.
    //
    if(fPbk)
    {
        ClosePhonebookFile(&pbfile);
    }
#ifdef PBCS
    LeaveCriticalSection(&PhonebookLock);
#endif
    return dwErr;
}


DWORD APIENTRY
RasGetCredentialsA(
    IN  LPCSTR              lpszPhonebook,
    IN  LPCSTR              lpszEntry,
    OUT LPRASCREDENTIALSA   lpRasCredentials
    )
{
    NTSTATUS        status;
    DWORD           dwErr;
    RASCREDENTIALSW rascredentialsW;

    WCHAR szPhonebookW[MAX_PATH],
          szEntryNameW[RAS_MaxEntryName + 1];

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    //
    // Verify parameters.
    //
    if (lpRasCredentials == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (lpRasCredentials->dwSize
        != sizeof (RASCREDENTIALSA))
    {
        return ERROR_INVALID_SIZE;
    }

    //
    // Convert the lpszPhonebook string to Unicode.
    //
    if (lpszPhonebook != NULL)
    {
        strncpyAtoWAnsi(szPhonebookW,
                    lpszPhonebook,
                    MAX_PATH);
    }

    //
    // Convert the lpszEntry string to Unicode.
    //
    if (lpszEntry != NULL)
    {
        strncpyAtoWAnsi(szEntryNameW,
                    lpszEntry,
                    RAS_MaxEntryName + 1);
    }

    //
    // Copy the entry name from the user's A buffer into
    // the W buffer, taking into account the version
    // of the structure the user passed in.
    //
    rascredentialsW.dwSize = sizeof (RASCREDENTIALSW);
    rascredentialsW.dwMask = lpRasCredentials->dwMask;

    //
    // Call the W version to do the work.
    //
    dwErr = RasGetCredentialsW(
              lpszPhonebook != NULL ? szPhonebookW : NULL,
              lpszEntry != NULL ? szEntryNameW : NULL,
              &rascredentialsW);
    if (dwErr)
    {
        goto done;
    }

    //
    // Copy over the fields to the
    // user's A buffer.
    //
    lpRasCredentials->dwMask = rascredentialsW.dwMask;
    if (rascredentialsW.dwMask & RASCM_UserName)
    {
        strncpyWtoAAnsi(lpRasCredentials->szUserName,
                   rascredentialsW.szUserName,
                   sizeof(lpRasCredentials->szUserName));
    }
    else
    {
        *lpRasCredentials->szUserName = '\0';
    }

    if (    (rascredentialsW.dwMask & RASCM_Password)
        ||  (rascredentialsW.dwMask & RASCM_PreSharedKey)
        ||  (rascredentialsW.dwMask & RASCM_DDMPreSharedKey))
    {
        strncpyWtoAAnsi(lpRasCredentials->szPassword,
                   rascredentialsW.szPassword,
                   sizeof(lpRasCredentials->szPassword));
    }
    else
    {
        *lpRasCredentials->szPassword = '\0';
    }

    if (rascredentialsW.dwMask & RASCM_Domain)
    {
        strncpyWtoAAnsi(lpRasCredentials->szDomain,
                   rascredentialsW.szDomain,
                   sizeof(lpRasCredentials->szDomain));
    }
    else
    {
        *lpRasCredentials->szDomain = '\0';
    }

done:
    return dwErr;
}


DWORD APIENTRY
RasSetCredentialsW(
    IN LPCWSTR           lpszPhonebook,
    IN LPCWSTR           lpszEntry,
    IN LPRASCREDENTIALSW lpRasCredentials,
    IN BOOL              fDelete
    )
{
    DWORD       dwErr;
    PBFILE      pbfile;
    DTLNODE     *pdtlnode;
    PBENTRY     *pEntry = NULL;
    BOOL        fPbk = FALSE;

    RAS_DIALPARAMS dialparams;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    RASAPI32_TRACE("RasSetCredentialsW");

    dwErr = LoadRasmanDllAndInit();
    if (dwErr)
    {
        return dwErr;
    }

    if (DwRasInitializeError)
    {
        return DwRasInitializeError;
    }

    //
    // Validate parameters.
    //
    if (    (lpRasCredentials == NULL)
        ||  ((lpRasCredentials->dwMask & RASCM_PreSharedKey)
            && (lpRasCredentials->dwMask != RASCM_PreSharedKey))
        ||  ((lpRasCredentials->dwMask & RASCM_DDMPreSharedKey)
            && (lpRasCredentials->dwMask != RASCM_DDMPreSharedKey))
        ||  ((lpRasCredentials->dwMask & RASCM_ServerPreSharedKey)
            && (lpRasCredentials->dwMask != RASCM_ServerPreSharedKey)))
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (lpRasCredentials->dwSize != sizeof (RASCREDENTIALSW))
    {
        return ERROR_INVALID_SIZE;
    }

    //
    // Load the phonebook file.
    //
#ifdef PBCS
    EnterCriticalSection(&PhonebookLock);
#endif

    ZeroMemory(&pbfile, sizeof(pbfile));
    pbfile.hrasfile = -1;

    if(0 == (lpRasCredentials->dwMask & RASCM_ServerPreSharedKey))
    {
        dwErr = GetPbkAndEntryName(
                        lpszPhonebook,
                        lpszEntry,
                        0,
                        &pbfile,
                        &pdtlnode);

        if(SUCCESS != dwErr)
        {
            goto done;
        }

        fPbk = TRUE;

        if(     (lpRasCredentials->dwMask & RASCM_DefaultCreds)
            &&  (!IsPublicPhonebook(pbfile.pszPath)))
        {
            RASAPI32_TRACE("RasSetCredentials: Attempting to set a defaultpw on"
                  " per user phonebook. ACCESS_DENIED");

            dwErr = ERROR_ACCESS_DENIED;
            goto done;
        }

        //
        // Get the dialparams UID corresponding to the
        // entry.  The phonebook library guarantees this
        // value to be unique.
        //
        pEntry = (PBENTRY *)DtlGetData(pdtlnode);
        ASSERT(pEntry);
    }

    if(     (lpRasCredentials->dwMask & RASCM_PreSharedKey)
        ||  (lpRasCredentials->dwMask & RASCM_DDMPreSharedKey)
        ||  (lpRasCredentials->dwMask & RASCM_ServerPreSharedKey))
    {

        DWORD dwMask = DLPARAMS_MASK_PRESHAREDKEY;
        DWORD cbkey = 
            (fDelete)
            ? 0
            : (wcslen(lpRasCredentials->szPassword) + 1) * sizeof(WCHAR);
        
        if(lpRasCredentials->dwMask & RASCM_DDMPreSharedKey)
        {
            dwMask = DLPARAMS_MASK_DDM_PRESHAREDKEY;
        }
        else if(lpRasCredentials->dwMask & RASCM_ServerPreSharedKey)
        {
            dwMask = DLPARAMS_MASK_SERVER_PRESHAREDKEY;
        }
    
        dwErr = RasSetKey(NULL,
                         (NULL != pEntry)
                         ? pEntry->pGuid
                         : NULL,
                         dwMask,
                         cbkey,
                         (BYTE *) lpRasCredentials->szPassword);

        goto done;
                          
    }

    //
    // Copy the fields from lpRasCredentials
    // into the rasman structure.
    //
    dialparams.DP_Uid = pEntry->dwDialParamsUID;

    lstrcpyn(dialparams.DP_UserName,
           lpRasCredentials->szUserName,
           sizeof(dialparams.DP_UserName) / sizeof(WCHAR));

    lstrcpyn(dialparams.DP_Password,
           lpRasCredentials->szPassword,
           sizeof(dialparams.DP_Password) / sizeof(WCHAR));

    lstrcpyn(dialparams.DP_Domain,
           lpRasCredentials->szDomain,
           sizeof(dialparams.DP_Domain) / sizeof(WCHAR));

    if(lpRasCredentials->dwMask & RASCM_DefaultCreds)
    {
        lpRasCredentials->dwMask &= ~(RASCM_DefaultCreds);
        lpRasCredentials->dwMask |= DLPARAMS_MASK_DEFAULT_CREDS;
    }

    //
    // Or mask with delete flag so that the whole record
    // is removed from lsa for this connectoid. This will
    // break legacy usage of RasSetEntryDialParams but we
    // really want to discourage users from using that api.
    // 
    if(     fDelete
        &&  ((lpRasCredentials->dwMask & (~DLPARAMS_MASK_DEFAULT_CREDS)) == 
                (RASCM_Domain | RASCM_Password | RASCM_UserName)))
    {
        lpRasCredentials->dwMask |= DLPARAMS_MASK_DELETE; 
    }

    //
    // Set the dial parameters in rasman.
    //
    // (SteveC) Changed to include "old-style" bit so that Set/GetCredentials
    //    and Get/SetDialParams share the same data store.  See bug 335748,.
    //
    dwErr = g_pRasSetDialParams(
              pEntry->dwDialParamsUID,
              lpRasCredentials->dwMask | DLPARAMS_MASK_OLDSTYLE,
              &dialparams,
              fDelete);

    if (dwErr)
    {
        goto done;
    }

done:
    //
    // Clean up.
    //
    if(fPbk)
    {
        ClosePhonebookFile(&pbfile);
    }

#ifdef PBCS
    LeaveCriticalSection(&PhonebookLock);
#endif

    return dwErr;
}


DWORD APIENTRY
RasSetCredentialsA(
    IN LPCSTR lpszPhonebook,
    IN LPCSTR lpszEntry,
    IN LPRASCREDENTIALSA lpRasCredentials,
    IN BOOL fDelete
    )
{
    NTSTATUS    status;
    DWORD       dwErr;

    RASCREDENTIALSW rascredentialsW;

    WCHAR szPhonebookW[MAX_PATH],
          szEntryNameW[RAS_MaxEntryName + 1];

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    //
    // Verify parameters.
    //
    if (lpRasCredentials == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (lpRasCredentials->dwSize != sizeof (RASCREDENTIALSA))
    {
        return ERROR_INVALID_SIZE;
    }

    //
    // Convert the lpszPhonebook string to Unicode.
    //
    if (lpszPhonebook != NULL)
    {
        strncpyAtoWAnsi(szPhonebookW,
                    lpszPhonebook,
                    MAX_PATH);
    }

    //
    // Convert the lpszEntry string to Unicode.
    //
    if (lpszEntry != NULL)
    {
        strncpyAtoWAnsi(szEntryNameW,
                    lpszEntry,
                    RAS_MaxEntryName + 1);
    }

    //
    // Copy the fields from the A buffer into
    // the user's W buffer.
    //
    rascredentialsW.dwSize = sizeof (RASCREDENTIALSW);

    rascredentialsW.dwMask = lpRasCredentials->dwMask;

    strncpyAtoWAnsi(rascredentialsW.szUserName,
              lpRasCredentials->szUserName,
              sizeof(rascredentialsW.szUserName) / sizeof(WCHAR));

    strncpyAtoWAnsi(rascredentialsW.szPassword,
               lpRasCredentials->szPassword,
               sizeof(rascredentialsW.szPassword) / sizeof(WCHAR));

    strncpyAtoWAnsi(rascredentialsW.szDomain,
               lpRasCredentials->szDomain,
               sizeof(rascredentialsW.szDomain) / sizeof(WCHAR));

    //
    // Call the W version to do the work.
    //
    dwErr = RasSetCredentialsW(
              lpszPhonebook != NULL ? szPhonebookW : NULL,
              lpszEntry != NULL ? szEntryNameW : NULL,
              &rascredentialsW,
              fDelete);

    return dwErr;
}


DWORD
NewAutodialNetwork(
    IN HKEY hkeyBase,
    OUT LPWSTR *lppszNetwork
    )
{
    HKEY hkeyNetworks, hkeyNetwork;
    DWORD dwErr, dwType, dwSize, dwDisp, dwNextId;
    LPWSTR lpszNetwork = NULL;

    //
    // Open the Networks section of the registry.
    //
    dwErr = RegCreateKeyEx(
              hkeyBase,
              AUTODIAL_REGNETWORKBASE,
              0,
              NULL,
              REG_OPTION_NON_VOLATILE,
              KEY_ALL_ACCESS,
              NULL,
              &hkeyNetworks,
              &dwDisp);
    if (dwErr)
    {
        return dwErr;
    }

    //
    // Read the next network number.
    //
    dwSize = sizeof (DWORD);
    dwErr = RegQueryValueEx(
              hkeyNetworks,
              AUTODIAL_REGNETWORKID,
              NULL,
              &dwType,
              (PVOID)&dwNextId,
              &dwSize);
    if (dwErr)
    {
        dwNextId = 0;
    }

    //
    // Create a new network key.
    //
    lpszNetwork = Malloc((wcslen(L"NETWORK") + 16) * sizeof (WCHAR));
    if (lpszNetwork == NULL)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto done;
    }

    wsprintf(lpszNetwork, L"NETWORK%d", dwNextId);
    dwErr = RegCreateKeyEx(
              hkeyNetworks,
              lpszNetwork,
              0,
              NULL,
              REG_OPTION_NON_VOLATILE,
              KEY_ALL_ACCESS,
              NULL,
              &hkeyNetwork,
              &dwDisp);

    RegCloseKey(hkeyNetwork);

    //
    // Update the next network number.
    //
    dwNextId++;

    dwErr = RegSetValueEx(
              hkeyNetworks,
              AUTODIAL_REGNETWORKID,
              0,
              REG_DWORD,
              (LPBYTE)&dwNextId,
              sizeof (DWORD));
    if (dwErr)
    {
        goto done;
    }

done:
    RegCloseKey(hkeyNetworks);
    if (dwErr)
    {
        if (lpszNetwork != NULL)
        {
            Free(lpszNetwork);
            lpszNetwork = NULL;
        }
    }

    *lppszNetwork = lpszNetwork;

    return dwErr;
}


DWORD
AutodialEntryToNetwork(
    IN  HKEY    hkeyBase,
    IN  LPWSTR  lpszEntry,
    IN  BOOLEAN fCreate,
    OUT LPWSTR  *lppszNetwork
    )
{
    HKEY hkeyEntries;

    DWORD dwErr,
          dwType,
          dwSize,
          dwDisp;

    LPWSTR lpszNetwork = NULL;

    //
    // Open the Entries section of the registry.
    //
    dwErr = RegCreateKeyEx(
              hkeyBase,
              AUTODIAL_REGENTRYBASE,
              0,
              NULL,
              REG_OPTION_NON_VOLATILE,
              KEY_ALL_ACCESS,
              NULL,
              &hkeyEntries,
              &dwDisp);
    if (dwErr)
    {
        goto done;
    }

    //
    // Attempt to read the entry.
    //
    dwErr = RegQueryValueEx(
              hkeyEntries,
              lpszEntry,
              NULL,
              &dwType,
              NULL,
              &dwSize);
    if (dwErr)
    {
        //
        // If we shouldn't create a new network,
        // then it's an error.
        //
        if (!fCreate)
        {
            goto done;
        }

        //
        // If the entry doesn't exist, we have
        // to create a new network and map it to
        // the entry.
        //
        dwErr = NewAutodialNetwork(hkeyBase,
                &lpszNetwork);

        //
        // Map the entry to the new network.
        //
        dwErr = RegSetValueEx(
                  hkeyEntries,
                  lpszEntry,
                  0,
                  REG_SZ,
                  (LPBYTE)lpszNetwork,
                  (wcslen(lpszNetwork) + 1) * sizeof (WCHAR));

        if (dwErr)
        {
            goto done;
        }
    }
    else
    {
        //
        // The entry does exist.  Simply read it.
        //
        lpszNetwork = Malloc(dwSize + sizeof (WCHAR));
        if (lpszNetwork == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto done;
        }

        RtlZeroMemory(lpszNetwork,
                      dwSize + sizeof (WCHAR));

        dwErr = RegQueryValueEx(
                  hkeyEntries,
                  lpszEntry,
                  NULL,
                  &dwType,
                  (PVOID)lpszNetwork,
                  &dwSize);
        if (dwErr)
        {
            goto done;
        }
    }

done:
    RegCloseKey(hkeyEntries);
    if (dwErr)
    {
        if (lpszNetwork != NULL)
        {
            Free(lpszNetwork);
            lpszNetwork = NULL;
        }
    }
    *lppszNetwork = lpszNetwork;

    return dwErr;
}

DWORD
DwOpenUsersRegistry(HKEY *phkey, BOOL *pfClose)
{
    DWORD dwErr = ERROR_SUCCESS;
    
    if(IsRasmanProcess())
    {
        dwErr = RtlOpenCurrentUser(
                            KEY_ALL_ACCESS,
                            phkey);

        *pfClose = TRUE;                            
    }
    else
    {
        *phkey = HKEY_CURRENT_USER;

        *pfClose = FALSE;
    }

    return dwErr;
}


DWORD WINAPI
RasAutodialEntryToNetwork(
    IN      LPWSTR  lpszEntry,
    OUT     LPWSTR  lpszNetwork,
    IN OUT  LPDWORD lpdwcbNetwork
    )
{
    DWORD dwErr, dwcbTmpNetwork;
    HKEY hkeyBase;
    LPWSTR lpszTmpNetwork;
    HKEY hkcu;
    BOOL fClose;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    //
    // Verify parameter.
    //
    if (lpszEntry == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    dwErr = DwOpenUsersRegistry(&hkcu, &fClose);

    if(ERROR_SUCCESS != dwErr)
    {
        return dwErr;
    }

    //
    // Open the root registry key.
    //
    dwErr = RegOpenKeyEx(
              hkcu,
              AUTODIAL_REGBASE,
              0,
              KEY_ALL_ACCESS,
              &hkeyBase);
    if (dwErr)
    {
        return dwErr;
    }

    //
    // Call internal routine to do the work.
    //
    dwErr = AutodialEntryToNetwork(hkeyBase,
                                   lpszEntry,
                                   FALSE,
                                   &lpszTmpNetwork);
    if (dwErr)
    {
        goto done;
    }

    dwcbTmpNetwork = (wcslen(lpszTmpNetwork) + 1)
                    * sizeof (WCHAR);

    if (    lpszNetwork == NULL
        || *lpdwcbNetwork < dwcbTmpNetwork)
    {
        *lpdwcbNetwork = dwcbTmpNetwork;
        goto done;
    }

    lstrcpyn(lpszNetwork, lpszTmpNetwork, *lpdwcbNetwork);
    *lpdwcbNetwork = dwcbTmpNetwork;

done:

    if(fClose)
    {
        NtClose(hkcu);
    }
    
    if (lpszTmpNetwork != NULL)
    {
        Free(lpszTmpNetwork);
    }

    RegCloseKey(hkeyBase);

    return dwErr;
}


LPWSTR
FormatKey(
    IN LPCWSTR lpszBase,
    IN LPCWSTR lpszKey
    )
{
    LPWSTR lpsz;

    lpsz = Malloc((wcslen(lpszBase)
            + wcslen(lpszKey) + 2) * sizeof (WCHAR));

    if (lpsz == NULL)
    {
        return NULL;
    }

    wsprintf(lpsz, L"%s\\%s", lpszBase, lpszKey);

    return lpsz;
}


DWORD
AddAutodialEntryToNetwork(
    IN HKEY     hkeyBase,
    IN LPWSTR   lpszNetwork,
    IN DWORD    dwDialingLocation,
    IN LPWSTR   lpszEntry
    )
{
    HKEY hkeyNetwork = NULL,
         hkeyEntries = NULL;

    DWORD dwErr,
          dwcb,
          dwDisp;

    LPWSTR  lpszNetworkKey;
    TCHAR   szLocationKey[16];

    //
    // Construct the network key.
    //
    lpszNetworkKey = FormatKey(AUTODIAL_REGNETWORKBASE,
                               lpszNetwork);

    if (lpszNetworkKey == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Open the lpszNetwork network subkey in the
    // Networks section of the registry.
    //
    dwErr = RegOpenKeyEx(
              hkeyBase,
              lpszNetworkKey,
              0,
              KEY_ALL_ACCESS,
              &hkeyNetwork);

    if (dwErr)
    {
        goto done;
    }

    //
    // Open the Entries section of the registry,
    // so we can inverse map the entry to the network.
    //
    dwErr = RegCreateKeyEx(
              hkeyBase,
              AUTODIAL_REGENTRYBASE,
              0,
              NULL,
              REG_OPTION_NON_VOLATILE,
              KEY_ALL_ACCESS,
              NULL,
              &hkeyEntries,
              &dwDisp);
    if (dwErr)
    {
        goto done;
    }

    //
    // Format the dialing location as a string
    // for the key value.
    //
    wsprintf(szLocationKey,
             L"%d",
             dwDialingLocation);

    //
    // Add the dialing location and entry
    // to this subkey.
    //
    dwErr = RegSetValueEx(
              hkeyNetwork,
              szLocationKey,
              0,
              REG_SZ,
              (LPBYTE)lpszEntry,
              (wcslen(lpszEntry) + 1) * sizeof (WCHAR));
    if (dwErr)
    {
        goto done;
    }

    //
    // Also write the inverse mapping in the
    // entries section of the registry.
    //
    dwErr = RegSetValueEx(
              hkeyEntries,
              lpszEntry,
              0,
              REG_SZ,
              (LPBYTE)lpszNetwork,
              (wcslen(lpszNetwork) + 1) * sizeof (WCHAR));
    if (dwErr)
    {
        goto done;
    }

done:
    if (hkeyNetwork != NULL)
    {
        RegCloseKey(hkeyNetwork);
    }

    if (hkeyEntries != NULL)
    {
        RegCloseKey(hkeyEntries);
    }

    Free(lpszNetworkKey);

    return dwErr;
}


DWORD
AutodialAddressToNetwork(
    IN  HKEY    hkeyBase,
    IN  LPCWSTR lpszAddress,
    OUT LPWSTR  *lppszNetwork
    )
{
    HKEY hkeyAddress;

    DWORD dwErr,
          dwDisp,
          dwType,
          dwSize;

    LPWSTR lpszAddressKey = NULL,
           lpszNetwork = NULL;

    //
    // Construct the registry key path.
    //
    lpszAddressKey = FormatKey(AUTODIAL_REGADDRESSBASE,
                               lpszAddress);

    if (lpszAddressKey == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Open the address key.
    //
    dwErr = RegOpenKeyEx(
              hkeyBase,
              lpszAddressKey,
              0,
              KEY_ALL_ACCESS,
              &hkeyAddress);
    if (dwErr)
    {
        LocalFree(lpszAddressKey);
        return dwErr;
    }

    //
    // Read the address key.
    //
    dwErr = RegQueryValueEx(
              hkeyAddress,
              AUTODIAL_REGNETWORKVALUE,
              NULL,
              &dwType,
              NULL,
              &dwSize);
    if (dwErr)
    {
        goto done;
    }

    lpszNetwork = Malloc(dwSize + sizeof (WCHAR));
    if (lpszNetwork == NULL)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto done;
    }

    RtlZeroMemory(lpszNetwork, dwSize + sizeof (WCHAR));
    dwErr = RegQueryValueEx(
              hkeyAddress,
              AUTODIAL_REGNETWORKVALUE,
              NULL,
              &dwType,
              (PVOID)lpszNetwork,
              &dwSize);
    if (dwErr)
    {
        goto done;
    }

done:
    RegCloseKey(hkeyAddress);
    if (lpszAddressKey != NULL)
    {
        Free(lpszAddressKey);
    }

    if (dwErr)
    {
        if (lpszNetwork != NULL)
        {
            Free(lpszNetwork);
            lpszNetwork = NULL;
        }
    }
    *lppszNetwork = lpszNetwork;

    return dwErr;
}


DWORD WINAPI
RasAutodialAddressToNetwork(
    IN  LPWSTR  lpszAddress,
    OUT LPWSTR  lpszNetwork,
    IN  OUT     LPDWORD lpdwcbNetwork
    )
{
    DWORD dwErr,
          dwcbTmpNetwork;

    HKEY hkeyBase = NULL;

    HKEY hkcu;

    LPTSTR lpszTmpNetwork = NULL;

    BOOL fClose;

    //
    // Verify parameter.
    //
    if (lpszAddress == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    dwErr = DwOpenUsersRegistry(&hkcu, &fClose);

    if(ERROR_SUCCESS != dwErr)
    {
        return dwErr;
    }

    //
    // Open the root registry key.
    //
    dwErr = RegOpenKeyEx(
              hkcu,
              AUTODIAL_REGBASE,
              0,
              KEY_ALL_ACCESS,
              &hkeyBase);
    if (dwErr)
    {
        goto done;
    }

    //
    // Call internal routine to do the work.
    //
    dwErr = AutodialAddressToNetwork(
              hkeyBase,
              lpszAddress,
              &lpszTmpNetwork);
    if (dwErr)
    {
        goto done;
    }

    dwcbTmpNetwork = (wcslen(lpszTmpNetwork) + 1) * sizeof (WCHAR);

    if (    lpszNetwork == NULL
        ||  *lpdwcbNetwork < dwcbTmpNetwork)
    {
        *lpdwcbNetwork = dwcbTmpNetwork;
        goto done;
    }

    lstrcpyn(lpszNetwork, lpszTmpNetwork, *lpdwcbNetwork);
    *lpdwcbNetwork = dwcbTmpNetwork;

done:

    if(fClose)
    {
        NtClose(hkcu);
    }

    if (lpszTmpNetwork != NULL)
    {
        Free(lpszTmpNetwork);
    }

    if(NULL != hkeyBase)
    {
        RegCloseKey(hkeyBase);
    }

    return dwErr;
}

DWORD
RasDefIntConnOpenKey(
    IN BOOL fRead,
    OUT PHKEY phkSettings)
{
    DWORD dwErr = NO_ERROR, dwDisp;
    HKEY hkRoot = NULL, hkAutodial = NULL;
    BOOL fCloseRoot = FALSE;

    BOOL fPersonal = !IsConsumerPlatform();
    
    do
    {
        // Get a reference to the correct index into the registry
        //
        if (fPersonal)
        {
            dwErr = DwOpenUsersRegistry(&hkRoot, &fCloseRoot);
            if (dwErr != NO_ERROR)
            {
                break;
            }
        }
        else
        {
            hkRoot = HKEY_LOCAL_MACHINE;
        }

        //
        // Open the autodial registry key.
        //
        dwErr = RegCreateKeyEx(
                  hkRoot,
                  AUTODIAL_REGBASE,
                  0,
                  NULL,
                  REG_OPTION_NON_VOLATILE,
                  (fRead) ? 
                    (KEY_READ | KEY_CREATE_SUB_KEY) : 
                    (KEY_READ | KEY_WRITE),
                  NULL,
                  &hkAutodial,
                  &dwDisp);
        if (dwErr)
        {
            if ((fRead) && (ERROR_ACCESS_DENIED == dwErr))
            {
                // XP 313846
                //
                // If we are opening the key for read access, it may not be necessary 
                // to have the KEY_CREATE_SUB_KEY permission.  By attempting to open
                // without it, we allow "limited" users to read the default connection
                // setting which they could do with regedit anyway.  They just wont
                // be able to set the default connection.
                //
                dwErr = RegCreateKeyEx(
                          hkRoot,
                          AUTODIAL_REGBASE,
                          0,
                          NULL,
                          REG_OPTION_NON_VOLATILE,
                          KEY_READ,
                          NULL,
                          &hkAutodial,
                          &dwDisp);
                if (dwErr)
                {
                    break;
                }
            }                
            else
            {
                break;
            }
        }

        //
        // Open the settings registry key.
        //
        dwErr = RegCreateKeyEx(
                  hkAutodial,
                  AUTODIAL_REGDEFAULT,
                  0,
                  NULL,
                  REG_OPTION_NON_VOLATILE,
                  (fRead) ? 
                    (KEY_READ) : 
                    (KEY_READ | KEY_WRITE),
                  NULL,
                  phkSettings,
                  &dwDisp);
        if (dwErr)
        {
            break;
        }
    } while (FALSE);

    // Cleanup
    {
        if (hkRoot && fCloseRoot)
        {   
            RegCloseKey(hkRoot);
        }
        if (hkAutodial)
        {
            RegCloseKey(hkAutodial);
        }
    }

    return dwErr;
}

DWORD
RasDefIntConnReadName(
    IN LPRASAUTODIALENTRYW pAdEntry)
{
    DWORD dwErr = NO_ERROR, dwType, dwSize;
    HKEY hkSettings = NULL;

    do
    {
        // Open the key
        //
        dwErr = RasDefIntConnOpenKey(TRUE, &hkSettings);
        if (dwErr != NO_ERROR)
        {
            break;
        }

        // Read the name
        //
        dwType = REG_SZ;
        dwSize = sizeof(pAdEntry->szEntry);
        dwErr = RegQueryValueEx(
                    hkSettings,
                    AUTODIAL_REGDEFINTERNETVALUE,
                    NULL,
                    &dwType,
                    (LPBYTE)pAdEntry->szEntry,
                    &dwSize);
                    
        // Make sure the registry hasn't been tampered with and
        // that we got a valid name back.
        //
        if ((dwErr == NO_ERROR) && 
            (dwType != REG_SZ) || (dwSize == 0))
        {
            dwErr = ERROR_FILE_NOT_FOUND;
            break;
        }
        
    } while (FALSE);

    if (hkSettings)
    {
        RegCloseKey(hkSettings);
    }

    return dwErr;
}


// Populates the autodial entry structure with default connection 
// information.  Returns per-user default connections if configured,
// global default connections otherwise.  Returns ERROR_NOT_FOUND if 
// no default connections are configured
//
DWORD
RasDefIntConnGet(
    IN LPRASAUTODIALENTRYW pAdEntry)
{
    return RasDefIntConnReadName(pAdEntry);
}

// Configures the default connection according to the autodial entry
// structure.
//
DWORD
RasDefIntConnSet(
    IN  LPRASAUTODIALENTRYW pAdEntry,
    IN  LPRASAUTODIALENTRYW pAdEntryOld,
    OUT PBOOL pfDelete)
{
    DWORD dwErr = NO_ERROR;
    HKEY hkSettings = NULL;
    BOOL fDelete = FALSE;

    *pfDelete = FALSE;
    
    do
    {
        // Determine whether the default connection is being deleted
        //
        fDelete = lstrlen(pAdEntry->szEntry) == 0;

        // Open the default connection key
        //
        dwErr = RasDefIntConnOpenKey(FALSE, &hkSettings);
        if (dwErr)
        {
            break;
        }
    
        // Get the old value -- ignore any error, not critical
        //
        dwErr = RasDefIntConnReadName(pAdEntryOld);
        dwErr = NO_ERROR;
        
        // Save or delete the settings
        //
        if (fDelete)
        {
            dwErr = RegDeleteValue(
                        hkSettings,
                        AUTODIAL_REGDEFINTERNETVALUE);
        }
        else
        {
            dwErr = RegSetValueEx(
                        hkSettings,
                        AUTODIAL_REGDEFINTERNETVALUE,
                        0,
                        REG_SZ,
                        (CONST BYTE*)pAdEntry->szEntry,
                        (lstrlen(pAdEntry->szEntry) + 1) * sizeof(WCHAR));
        }
        if (dwErr)
        {
            break;
        }

        *pfDelete = fDelete;
        
    } while (FALSE);

    // Cleanup
    {
        if (hkSettings)
        {
            RegCloseKey(hkSettings);
        }
    }

    return dwErr;
}

// 
// Sends an autodial change notification
//
DWORD
RasDefIntConnNotify(
    IN LPRASAUTODIALENTRYW pAdEntryNew,
    IN LPRASAUTODIALENTRYW pAdEntryOld,
    IN BOOL fDelete)
{ 
    DWORD dwErr = NO_ERROR;
    PBFILE pbFile;
    DTLNODE* pNode = NULL;
    BOOL fLoaded = FALSE;
    PBENTRY* pEntry = NULL;
    RASAUTODIALENTRYW* pAdEntry = NULL;

    if (! IsRasmanServiceRunning())
    {
        return NO_ERROR;   
    }

    dwErr = LoadRasmanDll();
    if (NO_ERROR != dwErr)
    {
        return dwErr;
    }

    // Initialize
    //
    ZeroMemory(&pbFile, sizeof(pbFile));
    pbFile.hrasfile = -1;

#ifdef PBCS
        EnterCriticalSection(&PhonebookLock);
#endif

    do
    {
        // We notify about the new entry when it 
        // is being set.  We notify about the old
        // entry when it is being cleared.
        //
        pAdEntry = (fDelete) ? pAdEntryOld : pAdEntryNew;
    
        // Find the phonebook entry
        //
        dwErr = GetPbkAndEntryName(
                    NULL, 
                    pAdEntry->szEntry, 
                    RPBF_NoCreate, 
                    &pbFile, 
                    &pNode);

        if( SUCCESS != dwErr )
        {
            break;
        }

        fLoaded = TRUE;
        pEntry = (PBENTRY *) DtlGetData(pNode);

        // Send the notification
        //
        dwErr = DwSendRasNotification(
                    ENTRY_AUTODIAL,
                    pEntry,
                    pbFile.pszPath,
                    (HANDLE)&fDelete);
    
        dwErr = NO_ERROR;
    
    } while (FALSE);

    // Cleanup
    //
    if (fLoaded)
    {
        ClosePhonebookFile(&pbFile);
    }

#ifdef PBCS
            LeaveCriticalSection(&PhonebookLock);
#endif

    return dwErr;
}    

DWORD APIENTRY
RasGetAutodialAddressW(
    IN      LPCWSTR             lpszAddress,
    OUT     LPDWORD             lpdwReserved,
    IN OUT  LPRASAUTODIALENTRYW lpRasAutodialEntries,
    IN OUT  LPDWORD             lpdwcbRasAutodialEntries,
    OUT     LPDWORD             lpdwcRasAutodialEntries
    )
{
    HKEY hkeyBase = NULL,
         hkeyNetwork = NULL;

    HKEY hkcu;         

    DWORD dwErr,
          dwNumSubKeys,
          dwMaxSubKeyLen,
          dwMaxClassLen;

    DWORD dwNumValues,
          dwMaxValueLen,
          dwMaxValueData,
          dwSecDescLen;

    DWORD dwcb,
          i,
          j = 0,
          dwType;

    DWORD dwcbLocation,
          dwcbEntry;

    FILETIME ftLastWriteTime;

    LPWSTR lpszNetworkKey = NULL,
           lpszLocation = NULL;

    LPWSTR lpszEntry = NULL,
           lpszNetwork = NULL;

    BOOL fClose;           

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    RASAPI32_TRACE("RasGetAutodialAddressW");
    //
    // Verify parameters.
    //
    if (    lpdwReserved != NULL
        ||  lpdwcbRasAutodialEntries == NULL
        ||  lpdwcRasAutodialEntries == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (    lpRasAutodialEntries != NULL
        &&  lpRasAutodialEntries->dwSize
            != sizeof (RASAUTODIALENTRYW))
    {
        return ERROR_INVALID_SIZE;
    }

    if (lpRasAutodialEntries == NULL)
    {
        *lpdwcbRasAutodialEntries =
         *lpdwcRasAutodialEntries = 0;
    }

    // If the lpszAddress parameter is null, then we are getting the 
    // default Internet connection.  
    //
    if (lpszAddress == NULL)
    {
        RASAUTODIALENTRYW Entry;

        // Validate the size of the buffer passed in
        //
        if (   (NULL != lpRasAutodialEntries)
            && (sizeof(Entry) > *lpdwcbRasAutodialEntries))
        {
            *lpdwcbRasAutodialEntries = sizeof(Entry);
            *lpdwcRasAutodialEntries = 1;
            return ERROR_BUFFER_TOO_SMALL;
        }

        ZeroMemory(&Entry, sizeof(Entry));
        Entry.dwSize = sizeof(Entry);

        // Read the default Internet connection
        //
        dwErr = RasDefIntConnGet(&Entry);

        // If there is no default connection configured,
        // then report this to the user
        //
        if (dwErr == ERROR_FILE_NOT_FOUND)
        {
            *lpdwcbRasAutodialEntries =
                 *lpdwcRasAutodialEntries = 0;
                 
            return NO_ERROR;                
        }
        else if (dwErr != NO_ERROR)
        {
            return dwErr;
        }

        // Report that there is a default internet connection
        //
        *lpdwcbRasAutodialEntries = sizeof(Entry);
        *lpdwcRasAutodialEntries = 1;

        // Deal with the optional buffer parameter
        //
        if (lpRasAutodialEntries == NULL)
        {
            return ERROR_BUFFER_TOO_SMALL;
        }

        // Return the appropriate autodial structure
        //
        CopyMemory(lpRasAutodialEntries, &Entry, sizeof(Entry));
    
        return NO_ERROR;
    }

    dwErr = DwOpenUsersRegistry(&hkcu, &fClose);

    if(ERROR_SUCCESS != dwErr)
    {
        return dwErr;
    }

    //
    // Open the root registry key.
    //
    dwErr = RegOpenKeyEx(
              hkcu,
              AUTODIAL_REGBASE,
              0,
              KEY_ALL_ACCESS,
              &hkeyBase);

    if (dwErr)
    {
        goto done;
    }

    //
    // Get the network name associated with the
    // address.  The entries and dialing locations
    // are stored under the network.
    //
    dwErr = AutodialAddressToNetwork(hkeyBase,
                                     lpszAddress,
                                     &lpszNetwork);
    if (dwErr)
    {
        goto done;
    }

    //
    // Construct the registry key path.
    //
    lpszNetworkKey = FormatKey(AUTODIAL_REGNETWORKBASE,
                               lpszNetwork);

    if (lpszNetworkKey == NULL)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto done;
    }

    //
    // Open the registry.
    //
    dwErr = RegOpenKeyEx(
              hkeyBase,
              lpszNetworkKey,
              0,
              KEY_READ,
              &hkeyNetwork);
    if (dwErr)
    {
        goto done;
    }

    //
    // Determine the number of dialing location values.
    //
    dwErr = RegQueryInfoKey(
              hkeyNetwork,
              NULL,
              NULL,
              NULL,
              &dwNumSubKeys,
              &dwMaxSubKeyLen,
              &dwMaxClassLen,
              &dwNumValues,
              &dwMaxValueLen,
              &dwMaxValueData,
              &dwSecDescLen,
              &ftLastWriteTime);
    if (    dwErr
        || !dwNumValues)
    {
        goto done;
    }

    //
    // Verify the user's buffer is big enough
    //
    dwcb = dwNumValues * sizeof (RASAUTODIALENTRYW);
    if (*lpdwcbRasAutodialEntries < dwcb)
    {
        dwErr = ERROR_BUFFER_TOO_SMALL;
        j = dwNumValues;
        goto done;
    }

    //
    // Allocate a buffer large enough to hold
    // the longest dialing location value.
    //
    lpszLocation = Malloc((dwMaxValueLen + 1)
                          * sizeof (WCHAR));

    if (lpszLocation == NULL)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto done;
    }

    //
    // Allocate a buffer large enough to hold
    // the longest entry name.
    //
    lpszEntry = Malloc(dwMaxValueData + 1);
    if (lpszEntry == NULL)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto done;
    }

    if (lpRasAutodialEntries != NULL)
    {
        for (i = 0, j = 0; i < dwNumValues; i++)
        {
            //
            // Read the location value.
            //
            dwcbLocation = dwMaxValueLen + 1;

            dwcbEntry = dwMaxValueData + 1;

            RtlZeroMemory(lpszEntry, dwMaxValueData + 1);

            dwErr = RegEnumValue(
                      hkeyNetwork,
                      i,
                      lpszLocation,
                      &dwcbLocation,
                      NULL,
                      NULL,
                      (PVOID)lpszEntry,
                      &dwcbEntry);
            if (dwErr)
            {
                goto done;
            }

            //
            // Enter the dialing location and
            // entry into the user's buffer.
            //
            lpRasAutodialEntries[j].dwSize =
                        sizeof (RASAUTODIALENTRYW);

            lpRasAutodialEntries[j].dwFlags = 0;

            lpRasAutodialEntries[j].dwDialingLocation =
                                    _wtol(lpszLocation);

            lstrcpyn(lpRasAutodialEntries[j].szEntry,
                     lpszEntry,
                     sizeof(lpRasAutodialEntries[j].szEntry) / sizeof(WCHAR));

            j++;
        }
    }

done:
    //
    // Set return sizes and count.
    //
    *lpdwcbRasAutodialEntries = j * sizeof (RASAUTODIALENTRYW);
    *lpdwcRasAutodialEntries = j;

    //
    // Free resources.
    //
    if (hkeyBase != NULL)
    {
        RegCloseKey(hkeyBase);
    }

    if (hkeyNetwork != NULL)
    {
        RegCloseKey(hkeyNetwork);
    }

    if (lpszNetworkKey != NULL)
    {
        Free(lpszNetworkKey);
    }

    if (lpszLocation != NULL)
    {
        Free(lpszLocation);
    }

    if (lpszNetwork != NULL)
    {
        Free(lpszNetwork);
    }

    if (lpszEntry != NULL)
    {
        Free(lpszEntry);
    }

    if(fClose)
    {
        NtClose(hkcu);
    }

    return dwErr;
}


DWORD APIENTRY
RasGetAutodialAddressA(
    IN      LPCSTR              lpszAddress,
    OUT     LPDWORD             lpdwReserved,
    IN OUT  LPRASAUTODIALENTRYA lpRasAutodialEntries,
    IN OUT  LPDWORD             lpdwcbRasAutodialEntries,
    OUT     LPDWORD             lpdwcRasAutodialEntries
    )
{
    NTSTATUS status;

    DWORD dwErr,
          dwcEntries,
          dwcb = 0,
          i;

    PWCHAR lpszAddressW = NULL;

    LPRASAUTODIALENTRYW lpRasAutodialEntriesW = NULL;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    //
    // Verify parameters.
    //
    if (    lpdwcbRasAutodialEntries == NULL
        ||  lpdwcRasAutodialEntries == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (    lpRasAutodialEntries != NULL
        &&  lpRasAutodialEntries->dwSize
            != sizeof (RASAUTODIALENTRYA))
    {
        return ERROR_INVALID_SIZE;
    }

    //
    // Convert the address to Unicode.
    //
    if (lpszAddress)
    {
        lpszAddressW = strdupAtoWAnsi(lpszAddress);
        if (lpszAddressW == NULL)
        {
            return GetLastError();
        }
    }        

    //
    // Allocate an W buffer as to fit the same
    // number of entries as the user's A buffer.
    //
    dwcEntries = *lpdwcbRasAutodialEntries
               / sizeof (RASAUTODIALENTRYA);

    dwcb = dwcEntries * sizeof (RASAUTODIALENTRYW);

    if (    lpRasAutodialEntries != NULL
        &&  dwcb)
    {
        lpRasAutodialEntriesW =
            (LPRASAUTODIALENTRYW)Malloc(dwcb);

        if (lpRasAutodialEntriesW == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto done;
        }

        lpRasAutodialEntriesW->dwSize =
                sizeof (RASAUTODIALENTRYW);
    }
    else
    {
        dwcEntries = dwcb = 0;
    }

    //
    // Call the W version to do the work.
    //
    dwErr = RasGetAutodialAddressW(
              lpszAddressW,
              lpdwReserved,
              lpRasAutodialEntriesW,
              &dwcb,
              lpdwcRasAutodialEntries);
    if (dwErr)
    {
        goto done;
    }

    //
    // Copy the W buffer back to the user's A buffer.
    //
    if (lpRasAutodialEntries != NULL)
    {
        for (i = 0; i < *lpdwcRasAutodialEntries; i++)
        {
            lpRasAutodialEntries[i].dwSize =
                        sizeof (RASAUTODIALENTRYA);

            lpRasAutodialEntries[i].dwFlags = 
              lpRasAutodialEntriesW[i].dwFlags;

            lpRasAutodialEntries[i].dwDialingLocation =
              lpRasAutodialEntriesW[i].dwDialingLocation;

            strncpyWtoAAnsi(
              lpRasAutodialEntries[i].szEntry,
              lpRasAutodialEntriesW[i].szEntry,
              sizeof(lpRasAutodialEntries[i].szEntry));
        }
    }

done:
    //
    // Set return sizes.
    //
    *lpdwcbRasAutodialEntries = *lpdwcRasAutodialEntries
                                * sizeof (RASAUTODIALENTRYA);

    //
    // Free resources
    //
    if (lpszAddressW != NULL)
    {
        Free(lpszAddressW);
    }

    if (lpRasAutodialEntriesW != NULL)
    {
        Free(lpRasAutodialEntriesW);
    }

    return dwErr;
}


DWORD APIENTRY
RasSetAutodialAddressW(
    IN LPCWSTR              lpszAddress,
    IN DWORD                dwReserved,
    IN LPRASAUTODIALENTRYW  lpRasAutodialEntries,
    IN DWORD                dwcbRasAutodialEntries,
    IN DWORD                dwcRasAutodialEntries
    )
{
    HKEY hkeyBase = NULL,
         hkeyAddress = NULL,
         hkeyNetwork = NULL;

    HKEY hkcu;         

    BOOL fClose;

    DWORD dwErr,
          dwcbNetworkKey;

    DWORD dwNumSubKeys,
          dwMaxSubKeyLen,
          dwMaxClassLen;

    DWORD dwNumValues,
          dwMaxValueLen,
          dwMaxValueData,
          dwSecDescLen;

    DWORD i,
          j = 0,
          dwSize,
          dwDisp;

    FILETIME ftLastWriteTime;

    LPWSTR lpszAddressKey = NULL,
           lpszNetwork = NULL;

    LPWSTR lpszNetworkKey = NULL,
           lpszLocation = NULL;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    RASAPI32_TRACE("RasSetAutodialAddressW");

    //
    // Verify parameters.
    //
    if (dwReserved != 0)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (    lpRasAutodialEntries != NULL
        &&  lpRasAutodialEntries->dwSize !=
            sizeof (RASAUTODIALENTRYW))
    {
        return ERROR_INVALID_SIZE;
    }

    if (!dwcbRasAutodialEntries != !dwcRasAutodialEntries)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // If the lpszAddress parameter is null, then we are setting the 
    // default Internet connection.  
    //
    if (lpszAddress == NULL)
    {
        RASAUTODIALENTRYW adEntryOld;   // previously set entry
        BOOL fDelete;

        // There is exactly 1 default connection
        //
        if (dwcRasAutodialEntries != 1)
        {
            return ERROR_INVALID_PARAMETER;
        }

        // Initialize
        //
        ZeroMemory(&adEntryOld, sizeof(adEntryOld));
        adEntryOld.dwSize = sizeof(adEntryOld);
        fDelete = FALSE;

        // Set the new default connection
        //
        dwErr = RasDefIntConnSet(lpRasAutodialEntries, &adEntryOld, &fDelete);
        if (dwErr == NO_ERROR)
        {
            // Tell the world that autodial settings have changed
            //
            // Ignore the error -- it is non-critical.
            //
            dwErr = RasDefIntConnNotify(
                        lpRasAutodialEntries, 
                        &adEntryOld, 
                        fDelete);
            dwErr = NO_ERROR;
        }

        return dwErr;
    }

    //
    // Create the name of the address key.
    //
    lpszAddressKey = FormatKey(AUTODIAL_REGADDRESSBASE,
                               lpszAddress);

    if (lpszAddressKey == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    dwErr = DwOpenUsersRegistry(&hkcu, &fClose);

    if(ERROR_SUCCESS != dwErr)
    {   
        goto done;
    }

    //
    // Open the root registry key.
    //
    dwErr = RegCreateKeyEx(
              hkcu,
              AUTODIAL_REGBASE,
              0,
              NULL,
              REG_OPTION_NON_VOLATILE,
              KEY_ALL_ACCESS,
              NULL,
              &hkeyBase,
              &dwDisp);
    if (dwErr)
    {
        goto done;
    }

    //
    // If lpRasAutodialEntries = NULL, the user
    // wants to delete the address key.
    //
    if (    lpRasAutodialEntries == NULL
        &&  !dwcbRasAutodialEntries
        &&  !dwcRasAutodialEntries)
    {
        //
        // Delete the address subkey.
        //
        dwErr = RegDeleteKey(hkeyBase, lpszAddressKey);
        goto done;
    }

    //
    // Open the address key in the registry.
    //
    dwErr = RegCreateKeyEx(
              hkeyBase,
              lpszAddressKey,
              0,
              NULL,
              REG_OPTION_NON_VOLATILE,
              KEY_ALL_ACCESS,
              NULL,
              &hkeyAddress,
              &dwDisp);
    if (dwErr)
    {
        goto done;
    }

    //
    // Do some miscellaneous parameter checking.
    //
    if (    lpRasAutodialEntries != NULL
        &&  (   !dwcbRasAutodialEntries
            ||  !dwcRasAutodialEntries
            ||  dwcbRasAutodialEntries <
                  dwcRasAutodialEntries
                * lpRasAutodialEntries->dwSize))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto done;
    }

    //
    // Get the network name associated with the
    // address.  The entries and dialing locations
    // are stored under the network.
    //
    dwErr = AutodialAddressToNetwork(hkeyBase,
                                    lpszAddress,
                                    &lpszNetwork);
    if (dwErr)
    {
        //
        // There is no network associated with
        // the address.  Create one now.
        //
        dwErr = AutodialEntryToNetwork(
                  hkeyBase,
                  lpRasAutodialEntries[0].szEntry,
                  TRUE,
                  &lpszNetwork);
        if (dwErr)
        {
            goto done;
        }

        //
        // Write the network value of the address.
        //
        dwErr = RegSetValueEx(
                  hkeyAddress,
                  AUTODIAL_REGNETWORKVALUE,
                  0,
                  REG_SZ,
                  (LPBYTE)lpszNetwork,
                  (wcslen(lpszNetwork) + 1) * sizeof (WCHAR));
        if (dwErr)
        {
            goto done;
        }
    }

    //
    // Set the entries the user has passed in.
    //
    for (i = 0; i < dwcRasAutodialEntries; i++)
    {
        dwErr = AddAutodialEntryToNetwork(
                  hkeyBase,
                  lpszNetwork,
                  lpRasAutodialEntries[i].dwDialingLocation,
                  lpRasAutodialEntries[i].szEntry);

        if (dwErr)
        {
            goto done;
        }
    }

done:
    //
    // Free resources.
    //
    if (hkeyBase != NULL)
    {
        RegCloseKey(hkeyBase);
    }

    if (hkeyAddress != NULL)
    {
        RegCloseKey(hkeyAddress);
    }

    if (hkeyNetwork != NULL)
    {
        RegCloseKey(hkeyNetwork);
    }

    if (lpszNetworkKey != NULL)
    {
        Free(lpszNetworkKey);
    }

    if (lpszAddressKey != NULL)
    {
        Free(lpszAddressKey);
    }

    if (lpszNetwork != NULL)
    {
        Free(lpszNetwork);
    }

    if (lpszLocation != NULL)
    {
        Free(lpszLocation);
    }

    if(fClose)
    {
        NtClose(hkcu);
    }

    return dwErr;
}


DWORD APIENTRY
RasSetAutodialAddressA(
    IN LPCSTR lpszAddress,
    IN DWORD dwReserved,
    IN LPRASAUTODIALENTRYA lpRasAutodialEntries,
    IN DWORD dwcbRasAutodialEntries,
    IN DWORD dwcRasAutodialEntries
    )
{
    NTSTATUS status;

    DWORD dwErr,
          dwcEntries,
          dwcb = 0,
          i;

    PWCHAR lpszAddressW;

    LPRASAUTODIALENTRYW lpRasAutodialEntriesW = NULL;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    //
    // Verify parameters.
    //
    if (    lpRasAutodialEntries != NULL
        &&  lpRasAutodialEntries->dwSize
            != sizeof (RASAUTODIALENTRYA))
    {
        return ERROR_INVALID_SIZE;
    }

    if (!dwcbRasAutodialEntries != !dwcRasAutodialEntries)
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Convert the address to Unicode.
    //
    if (lpszAddress)
    {
        lpszAddressW = strdupAtoWAnsi(lpszAddress);
    }
    else
    {
        lpszAddressW = NULL;
    }
    if (lpszAddress != NULL && lpszAddressW == NULL)
    {
        return GetLastError();
    }

    if (lpRasAutodialEntries != NULL)
    {
        //
        // Allocate an W buffer as to fit the same
        // number of entries as the user's A buffer.
        //
        dwcEntries =   dwcbRasAutodialEntries
                     / sizeof (RASAUTODIALENTRYA);

        dwcb = dwcEntries * sizeof (RASAUTODIALENTRYW);
        if (!dwcb)
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto done;
        }

        lpRasAutodialEntriesW = (LPRASAUTODIALENTRYW)Malloc(dwcb);
        if (lpRasAutodialEntriesW == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto done;
        }

        //
        // Copy the user's A buffer into the W buffer.
        //
        for (i = 0; i < dwcRasAutodialEntries; i++)
        {
            lpRasAutodialEntriesW[i].dwSize = sizeof (RASAUTODIALENTRYW);
            lpRasAutodialEntriesW[i].dwFlags = 
              lpRasAutodialEntries[i].dwFlags;
            lpRasAutodialEntriesW[i].dwDialingLocation =
              lpRasAutodialEntries[i].dwDialingLocation;

            strncpyAtoWAnsi(
              lpRasAutodialEntriesW[i].szEntry,
              lpRasAutodialEntries[i].szEntry,
              sizeof(lpRasAutodialEntriesW[i].szEntry) / sizeof(WCHAR));
        }
    }

    //
    // Call the W version to do the work.
    //
    dwErr = RasSetAutodialAddressW(
              lpszAddressW,
              dwReserved,
              lpRasAutodialEntriesW,
              dwcb,
              dwcRasAutodialEntries);
    if (dwErr)
    {
        goto done;
    }

done:
    //
    // Free resources
    //
    if (lpszAddressW != NULL)
    {
        Free(lpszAddressW);
    }

    if (lpRasAutodialEntriesW != NULL)
    {
        Free(lpRasAutodialEntriesW);
    }

    return dwErr;
}


DWORD APIENTRY
RasEnumAutodialAddressesW(
    OUT     LPWSTR *lppRasAutodialAddresses,
    IN OUT  LPDWORD lpdwcbRasAutodialAddresses,
    OUT     LPDWORD lpdwcRasAutodialAddresses)
{
    HKEY hkeyBase,
         hkeyAddresses = NULL;

    HKEY hkcu;         

    BOOL fClose;

    DWORD dwErr,
          dwNumSubKeys,
          dwMaxSubKeyLen,
          dwMaxClassLen;

    DWORD dwNumValues,
          dwMaxValueLen,
          dwMaxValueData,
          dwSecDescLen;

    DWORD i,
          j = 0,
          dwDisp,
          dwSize,
          dwTotalSize = 0,
          dwCopyRemain = 0;

    FILETIME ftLastWriteTime;

    LPWSTR lpszAddress = NULL,
           lpszBuf,
           *lppAddresses = NULL;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    RASAPI32_TRACE("RasEnumAutodialAddressesW");

    //
    // Verify parameters.
    //
    if (    lpdwcbRasAutodialAddresses == NULL
        ||  lpdwcRasAutodialAddresses == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    dwErr = DwOpenUsersRegistry(&hkcu, &fClose);

    if(ERROR_SUCCESS != dwErr)
    {   
        return dwErr;
    }

    //
    // Open the registry.
    //
    dwErr = RegOpenKeyEx(
              hkcu,
              AUTODIAL_REGBASE,
              0,
              KEY_READ,
              &hkeyBase);
    if (dwErr)
    {
        dwErr = 0;
        goto done;
    }

    dwErr = RegOpenKeyEx(
              hkeyBase,
              AUTODIAL_REGADDRESSBASE,
              0,
              KEY_READ,
              &hkeyAddresses);

    RegCloseKey(hkeyBase);

    if (dwErr)
    {
        dwErr = 0;
        goto done;
    }

    //
    // Determine the number of address subkeys.
    //
    dwErr = RegQueryInfoKey(
              hkeyAddresses,
              NULL,
              NULL,
              NULL,
              &dwNumSubKeys,
              &dwMaxSubKeyLen,
              &dwMaxClassLen,
              &dwNumValues,
              &dwMaxValueLen,
              &dwMaxValueData,
              &dwSecDescLen,
              &ftLastWriteTime);

    if (    dwErr
        ||  !dwNumSubKeys)
    {
        goto done;
    }

    //
    // Allocate a buffer large enough to hold
    // a pointer to each of the subkeys.
    //
    dwTotalSize = dwNumSubKeys * sizeof (LPWSTR);
    lppAddresses = Malloc(dwTotalSize);

    if (lppAddresses == NULL)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto done;
    }

    ZeroMemory(lppAddresses, dwTotalSize);

    //
    // Allocate a buffer large enough to hold
    // the longest address value.
    //
    lpszAddress = Malloc((dwMaxSubKeyLen + 1) * sizeof (WCHAR));
    if (lpszAddress == NULL)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto done;
    }

    for (i = 0, j = 0; i < dwNumSubKeys; i++)
    {
        dwSize = dwMaxSubKeyLen + 1;
        dwErr = RegEnumKey(
                  hkeyAddresses,
                  i,
                  lpszAddress,
                  dwSize);
        if (dwErr)
        {
            continue;
        }

        lppAddresses[j++] = strdupW(lpszAddress);
        dwTotalSize += (dwSize + 1) * sizeof (WCHAR);
    }

    //
    // Now we can check to see if the user's
    // buffer is large enough.
    //
    if (    lppRasAutodialAddresses == NULL
        ||  *lpdwcbRasAutodialAddresses < dwTotalSize)
    {
        dwErr = ERROR_BUFFER_TOO_SMALL;
        goto done;
    }

    //
    // Copy the pointers and the strings to the
    // user's buffer.
    //
    lpszBuf = (LPWSTR)&lppRasAutodialAddresses[j];

    //
    // So that we don't over overrun the caller's buffer we need to keep track
    // of how much we have copied.
    //
    dwCopyRemain = *lpdwcbRasAutodialAddresses;

    for (i = 0; i < j; i++)
    {
        DWORD dwTempSize;

        lppRasAutodialAddresses[i] = lpszBuf;
        dwTempSize = wcslen(lppAddresses[i]);

        lstrcpyn(
            lpszBuf,
            lppAddresses[i],
            dwCopyRemain);

        lpszBuf += dwTempSize + 1;
        dwCopyRemain -= dwTempSize;

        if (dwCopyRemain < 1)
        {
            break;
        }
    }

done:
    //
    // Set return sizes and count.
    //
    *lpdwcbRasAutodialAddresses = dwTotalSize;
    *lpdwcRasAutodialAddresses = j;

    //
    // Free resources.
    //
    if (hkeyAddresses != NULL)
    {
        RegCloseKey(hkeyAddresses);
    }

    if(fClose)
    {
        NtClose(hkcu);
    }

    //
    // Free the array of LPWSTRs.
    //
    if (lppAddresses != NULL)
    {
        for (i = 0; i < dwNumSubKeys; i++)
        {
            if (lppAddresses[i] != NULL)
            {
                Free(lppAddresses[i]);
            }
        }
        Free(lppAddresses);
    }
    Free0(lpszAddress);

    return dwErr;
}


DWORD APIENTRY
RasEnumAutodialAddressesA(
    OUT     LPSTR   *lppRasAutodialAddresses,
    IN OUT  LPDWORD lpdwcbRasAutodialAddresses,
    OUT     LPDWORD lpdwcRasAutodialAddresses
    )
{
    DWORD dwErr,
          dwcb,
          dwcAddresses = 0,
          dwcbAddresses = 0,
          i,
          dwCopyRemain = 0;

    LPWSTR *lppRasAutodialAddressesW = NULL;

    LPSTR lpszAddress;

    //
    // Verify parameters.
    //
    if (    lpdwcbRasAutodialAddresses == NULL
        ||  lpdwcRasAutodialAddresses == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Call the W version to determine
    // how big the W buffer should be.
    //
    dwErr = RasEnumAutodialAddressesW(NULL,
                                      &dwcb,
                                      &dwcAddresses);

    if (    dwErr
        &&  dwErr != ERROR_BUFFER_TOO_SMALL)
    {
        return dwErr;
    }

    //
    // Now we can figure out if the user's A
    // buffer is big enough.
    //
    dwcbAddresses = dwcb - (dwcAddresses * sizeof (LPWSTR));
    if (    lppRasAutodialAddresses == NULL
        ||  *lpdwcbRasAutodialAddresses <
            (dwcAddresses * sizeof (LPSTR)
            + (dwcbAddresses / sizeof (WCHAR))))
    {
        dwErr = ERROR_BUFFER_TOO_SMALL;
        goto done;
    }

    //
    // Allocate an W buffer as specified by
    // the W call.
    //
    lppRasAutodialAddressesW = (LPWSTR *)Malloc(dwcb);
    if (lppRasAutodialAddressesW == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Call the W version again to get
    // the actual list of addresses.
    //
    dwErr = RasEnumAutodialAddressesW(
              lppRasAutodialAddressesW,
              &dwcb,
              &dwcAddresses);
    if (dwErr)
    {
        goto done;
    }

    //
    // So that we don't over overrun the caller's buffer we need to keep track
    // of how much we have copied.
    //
    dwCopyRemain = *lpdwcbRasAutodialAddresses;

    //
    // Copy the W addresses back into the user's
    // A buffer.
    //
    lpszAddress = (LPSTR)&lppRasAutodialAddresses[dwcAddresses];
    for (i = 0; i < dwcAddresses; i++)
    {
        DWORD dwTempSize;

        lppRasAutodialAddresses[i] = lpszAddress;
        dwTempSize = wcslen(lppRasAutodialAddressesW[i]);

        strncpyWtoAAnsi(
            lpszAddress,
            lppRasAutodialAddressesW[i],
            dwCopyRemain);

        lpszAddress += dwTempSize + 1;
        dwCopyRemain -= dwTempSize;

        if (dwCopyRemain < 1)
        {
            break;
        }
    }

done:
    //
    // Set return size and count.
    //
    *lpdwcbRasAutodialAddresses =
      (dwcAddresses * sizeof (LPSTR))
      + (dwcbAddresses / sizeof (WCHAR));

    *lpdwcRasAutodialAddresses = dwcAddresses;

    //
    // Free resources.
    //
    if (lppRasAutodialAddressesW != NULL)
    {
        Free(lppRasAutodialAddressesW);
    }

    return dwErr;
}


DWORD APIENTRY
RasSetAutodialEnableW(
    IN DWORD dwDialingLocation,
    IN BOOL fEnabled
    )
{
    HKEY    hkeyBase,
            hkeyDisabled = NULL;

    DWORD   dwcb,
            dwErr,
            dwDisp;

    BOOL fClose;            

    WCHAR   szLocation[16];
    DWORD   dwfEnabled = (DWORD)!fEnabled;

    HKEY hkcu;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    RASAPI32_TRACE("RasSetAutodialEnableW");

    dwErr = DwOpenUsersRegistry(&hkcu, &fClose);

    if(ERROR_SUCCESS != dwErr)
    {
        return dwErr;
    }

    //
    // Open the registry.
    //
    dwErr = RegCreateKeyEx(
              hkcu,
              AUTODIAL_REGBASE,
              0,
              NULL,
              REG_OPTION_NON_VOLATILE,
              KEY_ALL_ACCESS,
              NULL,
              &hkeyBase,
              &dwDisp);
    if (dwErr)
    {
        goto done;
    }

    dwErr = RegCreateKeyEx(
              hkeyBase,
              AUTODIAL_REGDISABLEDBASE,
              0,
              NULL,
              REG_OPTION_NON_VOLATILE,
              KEY_ALL_ACCESS,
              NULL,
              &hkeyDisabled,
              &dwDisp);

    RegCloseKey(hkeyBase);

    if (dwErr)
    {
        goto done;
    }

    //
    // Set the value.
    //
    wsprintf(szLocation, L"%d", dwDialingLocation);
    dwErr = RegSetValueEx(
              hkeyDisabled,
              szLocation,
              0,
              REG_DWORD,
              (LPBYTE)&dwfEnabled,
              sizeof (DWORD));

    if (dwErr)
    {
        goto done;
    }

done:

    if(NULL != hkeyDisabled)
    {
        //
        // Free resources.
        //
        RegCloseKey(hkeyDisabled);
    }

    if(fClose)
    {
        NtClose(hkcu);
    }

    return dwErr;
}


DWORD APIENTRY
RasSetAutodialEnableA(
    IN DWORD dwDialingLocation,
    IN BOOL fEnabled
    )
{
    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    return RasSetAutodialEnableW(dwDialingLocation, fEnabled);
}


DWORD APIENTRY
RasGetAutodialEnableW(
    IN  DWORD dwDialingLocation,
    OUT LPBOOL lpfEnabled
    )
{
    HKEY    hkeyBase = NULL,
            hkeyDisabled = NULL;

    HKEY    hkcu;            
    DWORD   dwcb,
            dwErr,
            dwDisp,
            dwType = REG_DWORD,
            dwSize;

    WCHAR szLocation[16];

    DWORD dwfDisabled = 0;

    BOOL fClose;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    RASAPI32_TRACE("RasGetAutodialEnableW");
    //
    // Verify parameters.
    //
    if (lpfEnabled == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    dwErr = DwOpenUsersRegistry(&hkcu, &fClose);

    if(ERROR_SUCCESS != dwErr)
    {   
        return dwErr;
    }

    //
    // Open the registry.
    //
    dwErr = RegOpenKeyEx(
              hkcu,
              AUTODIAL_REGBASE,
              0,
              KEY_READ,
              &hkeyBase);

    if (dwErr)
    {
        goto done;
    }

    dwErr = RegOpenKeyEx(
              hkeyBase,
              AUTODIAL_REGDISABLEDBASE,
              0,
              KEY_READ,
              &hkeyDisabled);

    RegCloseKey(hkeyBase);

    if (dwErr)
    {
        goto done;
    }

    //
    // Get the value.
    //
    wsprintf(szLocation,
             L"%d",
             dwDialingLocation);

    dwSize = sizeof (DWORD);

    dwErr = RegQueryValueEx(
              hkeyDisabled,
              szLocation,
              NULL,
              &dwType,
              (PVOID)&dwfDisabled,
              &dwSize);

    if (dwErr)
    {
        goto done;
    }

    //
    // Verify type of value read from
    // the registry.  If it's not a
    // DWORD, then set it to the default
    // value.
    //
    if (dwType != REG_DWORD)
    {
        dwfDisabled = 0;
    }

done:
    //
    // Free resources.
    //
    if (hkeyDisabled != NULL)
    {
        RegCloseKey(hkeyDisabled);
    }

    *lpfEnabled = !(BOOLEAN)dwfDisabled;

    if(fClose)
    {
        NtClose(hkcu);
    }

    return 0;
}


DWORD APIENTRY
RasGetAutodialEnableA(
    IN DWORD dwDialingLocation,
    OUT LPBOOL lpfEnabled
    )
{
    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    return RasGetAutodialEnableW(
                    dwDialingLocation,
                    lpfEnabled);
}


DWORD
SetDefaultDword(
    IN DWORD dwValue,
    OUT LPVOID lpvValue,
    OUT LPDWORD lpdwcbValue
    )
{
    DWORD dwOrigSize;
    LPDWORD lpdwValue;

    dwOrigSize = *lpdwcbValue;

    *lpdwcbValue = sizeof (DWORD);

    if (dwOrigSize < sizeof (DWORD))
    {
        return ERROR_BUFFER_TOO_SMALL;
    }

    lpdwValue = (LPDWORD)lpvValue;

    *lpdwValue = dwValue;

    return 0;
}


DWORD
AutodialParamSetDefaults(
    IN DWORD dwKey,
    OUT LPVOID lpvValue,
    OUT LPDWORD lpdwcbValue
    )
{
    DWORD dwErr;

    if (    lpvValue == NULL
        ||  lpdwcbValue == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    switch (dwKey)
    {
    case RASADP_DisableConnectionQuery:
        dwErr = SetDefaultDword(0, lpvValue, lpdwcbValue);
        break;

    case RASADP_LoginSessionDisable:
        dwErr = SetDefaultDword(0, lpvValue, lpdwcbValue);
        break;

    case RASADP_SavedAddressesLimit:
        dwErr = SetDefaultDword(100, lpvValue, lpdwcbValue);
        break;

    case RASADP_FailedConnectionTimeout:
        dwErr = SetDefaultDword(5, lpvValue, lpdwcbValue);
        break;

    //Set this timeout to be 60 seconds for whistler bug 336524
    //
    case RASADP_ConnectionQueryTimeout:
        dwErr = SetDefaultDword(60, lpvValue, lpdwcbValue);
        break;

    default:
        dwErr = ERROR_INVALID_PARAMETER;
        break;
    }

    return dwErr;
}


DWORD
VerifyDefaultDword(
    IN LPVOID lpvValue,
    IN LPDWORD lpdwcbValue
    )
{
    if (lpvValue == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    return (*lpdwcbValue == sizeof (DWORD) ? 0 : ERROR_INVALID_SIZE);
}


DWORD
AutodialVerifyParam(
    IN DWORD dwKey,
    IN LPVOID lpvValue,
    OUT LPDWORD lpdwType,
    IN OUT LPDWORD lpdwcbValue
    )
{
    DWORD dwErr;

    switch (dwKey)
    {
    case RASADP_DisableConnectionQuery:
        *lpdwType = REG_DWORD;
        dwErr = VerifyDefaultDword(lpvValue, lpdwcbValue);
        break;

    case RASADP_LoginSessionDisable:
        *lpdwType = REG_DWORD;
        dwErr = VerifyDefaultDword(lpvValue, lpdwcbValue);
        break;

    case RASADP_SavedAddressesLimit:
        *lpdwType = REG_DWORD;
        dwErr = VerifyDefaultDword(lpvValue, lpdwcbValue);
        break;

    case RASADP_FailedConnectionTimeout:
        *lpdwType = REG_DWORD;
        dwErr = VerifyDefaultDword(lpvValue, lpdwcbValue);
        break;

    case RASADP_ConnectionQueryTimeout:
        *lpdwType = REG_DWORD;
        dwErr = VerifyDefaultDword(lpvValue, lpdwcbValue);
        break;

    default:
        dwErr = ERROR_INVALID_PARAMETER;
        break;
    }

    return dwErr;
}


DWORD APIENTRY
RasSetAutodialParamW(
    IN DWORD dwKey,
    IN LPVOID lpvValue,
    IN DWORD dwcbValue
    )
{
    HKEY hkeyBase,
         hkeyControl = NULL;

    HKEY hkcu;         

    LPWSTR lpszKey;

    DWORD dwErr,
          dwType,
          dwDisp;

    BOOL fClose;          

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    RASAPI32_TRACE("RasSetAutodialParamW");

    dwErr = AutodialVerifyParam(dwKey,
                                lpvValue,
                                &dwType,
                                &dwcbValue);

    if (dwErr)
    {
        return dwErr;
    }

    dwErr = DwOpenUsersRegistry(&hkcu, &fClose);

    if(ERROR_SUCCESS != dwErr)
    {
        return dwErr;
    }

    //
    // Open the registry.
    //
    dwErr = RegCreateKeyEx(
              hkcu,
              AUTODIAL_REGBASE,
              0,
              NULL,
              REG_OPTION_NON_VOLATILE,
              KEY_ALL_ACCESS,
              NULL,
              &hkeyBase,
              &dwDisp);

    if (dwErr)
    {
        goto done;
    }

    dwErr = RegCreateKeyEx(
              hkeyBase,
              AUTODIAL_REGCONTROLBASE,
              0,
              NULL,
              REG_OPTION_NON_VOLATILE,
              KEY_ALL_ACCESS,
              NULL,
              &hkeyControl,
              &dwDisp);

    RegCloseKey(hkeyBase);

    if (dwErr)
    {
        goto done;
    }

    //
    // Set the value.
    //
    dwErr = RegSetValueEx(
              hkeyControl,
              AutodialParamRegKeys[dwKey].szKey,
              0,
              dwType,
              (LPBYTE)lpvValue,
              dwcbValue);
    //
    // Free resources.
    //
done:
    if (hkeyControl != NULL)
        RegCloseKey(hkeyControl);

    if(fClose)
    {
        NtClose(hkcu);
    }

    return dwErr;
}


DWORD APIENTRY
RasSetAutodialParamA(
    IN DWORD    dwKey,
    IN LPVOID   lpvValue,
    IN DWORD    dwcbValue
    )
{
    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    return RasSetAutodialParamW(dwKey,
                                lpvValue,
                                dwcbValue);
}


DWORD APIENTRY
RasGetAutodialParamW(
    IN  DWORD   dwKey,
    OUT LPVOID  lpvValue,
    OUT LPDWORD lpdwcbValue
    )
{
    HKEY hkeyBase, hkeyControl = NULL;
    DWORD dwErr, dwType;
    HKEY hkcu;
    BOOL fClose;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    RASAPI32_TRACE("RasGetAutodialParamW");

    //
    // Verify parameters.
    //
    if (    lpvValue == NULL
        ||  lpdwcbValue == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Initialize the return value with the default.
    //
    dwErr = AutodialParamSetDefaults(dwKey,
                                     lpvValue,
                                     lpdwcbValue);
    if (dwErr)
    {
        return dwErr;
    }

    dwErr = DwOpenUsersRegistry(&hkcu, &fClose);

    if(ERROR_SUCCESS != dwErr)
    {
        return dwErr;
    }

    //
    // Open the registry.
    //
    dwErr = RegOpenKeyEx(
              hkcu,
              AUTODIAL_REGBASE,
              0,
              KEY_READ,
              &hkeyBase);

    if (dwErr)
    {
        goto done;
    }

    dwErr = RegOpenKeyEx(
              hkeyBase,
              AUTODIAL_REGCONTROLBASE,
              0,
              KEY_READ,
              &hkeyControl);

    RegCloseKey(hkeyBase);

    if (dwErr)
    {
        goto done;
    }

    dwErr = RegQueryValueEx(
              hkeyControl,
              AutodialParamRegKeys[dwKey].szKey,
              NULL,
              &dwType,
              lpvValue,
              lpdwcbValue);

    if (dwErr)
    {
        goto done;
    }

done:
    //
    // Free resources.
    //
    if (hkeyControl != NULL)
    {
        RegCloseKey(hkeyControl);
    }

    if(fClose)
    {
        NtClose(hkcu);
    }

    return 0;
}


DWORD APIENTRY
RasGetAutodialParamA(
    IN  DWORD   dwKey,
    OUT LPVOID  lpvValue,
    OUT LPDWORD lpdwcbValue
    )
{
    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    return RasGetAutodialParamW(dwKey,
                                lpvValue,
                                lpdwcbValue);
}


/*++

Routine Description:

    Will return phonebook entry information not returned by any
    other rasapis. This is needed by DDM to do redial on link
    failure etc.
    This call lives in rasapi.dll instead of DDM because calls
    to the phonebook library pull in a lot of static library code
    and since rasapi already links to this code and DDM loads
    rasapi.dll it is more efficient to put it here.
    This call is private. The prototype is defined in DDM. This is
    called only by DDM.

Arguments:

Return Value:

            NO_ERROR         - Success
            Non-zero returns - Failure

--*/

DWORD
DDMGetPhonebookInfo(
    LPWSTR  lpwsPhonebookName,
    LPWSTR  lpwsPhonebookEntry,
    LPDWORD lpdwNumSubEntries,
    LPDWORD lpdwNumRedialAttempts,
    LPDWORD lpdwNumSecondsBetweenAttempts,
    BOOL *  lpfRedialOnLinkFailure,
    CHAR *  szzPppParameters,
    LPDWORD lpdwMode
)
{
    DWORD      dwRetCode = NO_ERROR;
    PBFILE     file;
    PBENTRY*   pEntry = NULL;
    DTLNODE*   pNode  = NULL;
    BOOL       fIpPrioritizeRemote = TRUE;
    BOOL       fIpVjCompression  = TRUE;
    DWORD      dwIpAddressSource = PBUFVAL_ServerAssigned;
    CHAR*      pszIpAddress      = NULL;
    DWORD      dwIpNameSource    = PBUFVAL_ServerAssigned;
    CHAR*      pszIpDnsAddress   = NULL;
    CHAR*      pszIpDns2Address  = NULL;
    CHAR*      pszIpWinsAddress  = NULL;
    CHAR*      pszIpWins2Address = NULL;
    CHAR*      pszIpDnsSuffix    = NULL;

    
    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    dwRetCode = LoadRasmanDllAndInit();

    if (dwRetCode)
    {
        return dwRetCode;
    }

    if (DwRasInitializeError)
    {
        return DwRasInitializeError;
    }

    dwRetCode = ReadPhonebookFile( lpwsPhonebookName,
                                   NULL,
                                   lpwsPhonebookEntry,
                                   RPBF_ReadOnly, &file );
    if (dwRetCode != NO_ERROR)
    {
        return( dwRetCode );
    }

    if ((pNode = DtlGetFirstNode(file.pdtllistEntries)) == NULL)
    {
        return(ERROR_CANNOT_FIND_PHONEBOOK_ENTRY);
    }

    if ((pEntry = (PBENTRY* )DtlGetData(pNode)) == NULL)
    {
        return( ERROR_CANNOT_FIND_PHONEBOOK_ENTRY );
    }

    *lpdwNumSubEntries              = DtlGetNodes(pEntry->pdtllistLinks);
    *lpdwNumRedialAttempts          = pEntry->dwRedialAttempts;
    *lpdwNumSecondsBetweenAttempts  = pEntry->dwRedialSeconds;
    *lpfRedialOnLinkFailure         = pEntry->fRedialOnLinkFailure;
    *lpdwMode                       = pEntry->dwDialMode;
    

    ClearParamBuf( szzPppParameters );

    fIpPrioritizeRemote = pEntry->fIpPrioritizeRemote;

    AddFlagToParamBuf(
            szzPppParameters, PBUFKEY_IpPrioritizeRemote,
            fIpPrioritizeRemote );

    fIpVjCompression = pEntry->fIpHeaderCompression;

    AddFlagToParamBuf(
            szzPppParameters, PBUFKEY_IpVjCompression,
            fIpVjCompression );

    dwIpAddressSource = pEntry->dwIpAddressSource;

    AddLongToParamBuf(
            szzPppParameters, PBUFKEY_IpAddressSource,
            (LONG )dwIpAddressSource );

    pszIpAddress = strdupWtoA(pEntry->pszIpAddress);

    AddStringToParamBuf(
            szzPppParameters, PBUFKEY_IpAddress, pszIpAddress );

    Free(pszIpAddress);

    dwIpNameSource = pEntry->dwIpNameSource;

    AddLongToParamBuf(
            szzPppParameters, PBUFKEY_IpNameAddressSource,
            (LONG )dwIpNameSource );

    pszIpDnsAddress = strdupWtoA(pEntry->pszIpDnsAddress);

    AddStringToParamBuf(
            szzPppParameters, PBUFKEY_IpDnsAddress,
            pszIpDnsAddress );

    Free(pszIpDnsAddress);

    pszIpDns2Address = strdupWtoA(pEntry->pszIpDns2Address);

    AddStringToParamBuf(
            szzPppParameters, PBUFKEY_IpDns2Address,
            pszIpDns2Address );

    Free(pszIpDns2Address);

    pszIpWinsAddress = strdupWtoA(pEntry->pszIpWinsAddress);

    AddStringToParamBuf(
            szzPppParameters, PBUFKEY_IpWinsAddress,
            pszIpWinsAddress );

    Free(pszIpWinsAddress);

    pszIpWins2Address = strdupWtoA(pEntry->pszIpWins2Address);

    AddStringToParamBuf(
            szzPppParameters, PBUFKEY_IpWins2Address,
            pszIpWins2Address );

    Free(pszIpWins2Address);

    AddLongToParamBuf(
        szzPppParameters,
        PBUFKEY_IpDnsFlags,
        (LONG )pEntry->dwIpDnsFlags);

    pszIpDnsSuffix = strdupWtoA(pEntry->pszIpDnsSuffix);

    AddStringToParamBuf(
        szzPppParameters,
        PBUFKEY_IpDnsSuffix,
        pszIpDnsSuffix);

    Free(pszIpDnsSuffix);

    ClosePhonebookFile( &file );

    return( NO_ERROR );
}


DWORD APIENTRY
RasIsRouterConnection(
    IN HRASCONN hrasconn
    )
{
    DWORD dwErr;
    DWORD i, dwcbPorts, dwcPorts;
    RASMAN_PORT *lpPorts;
    RASMAN_INFO info;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    //
    // Get the ports associated with the
    // connection.
    //
    dwcbPorts = dwcPorts = 0;
    dwErr = g_pRasEnumConnectionPorts(NULL,
                                      (HCONN)hrasconn,
                                      NULL,
                                      &dwcbPorts,
                                      &dwcPorts);

    //
    // If there are no ports associated with
    // the connection then return ERROR_NO_MORE_ITEMS.
    //
    if (    (   !dwErr
            &&  !dwcPorts)
        ||  dwErr != ERROR_BUFFER_TOO_SMALL)
    {
        return 0;
    }

    lpPorts = Malloc(dwcbPorts);
    if (lpPorts == NULL)
    {
        return 0;
    }

    dwErr = g_pRasEnumConnectionPorts(NULL,
                                      (HCONN)hrasconn,
                                      lpPorts,
                                      &dwcbPorts,
                                      &dwcPorts);
    if (dwErr)
    {
        Free(lpPorts);
        return 0;
    }

    //
    // Enumerate the ports associated with
    // the connection to find the requested
    // subentry.
    //
    dwErr = g_pRasGetInfo(NULL,
                          lpPorts[0].P_Handle,
                          &info);
    if (dwErr)
    {
        Free(lpPorts);
        return 0;
    }

    //
    // Free resources.
    //
    Free(lpPorts);

    return (info.RI_CurrentUsage & CALL_ROUTER) ? 1 : 0;
}

DWORD APIENTRY
RasInvokeEapUI(
        HRASCONN            hRasConn,
        DWORD               dwSubEntry,
        LPRASDIALEXTENSIONS lpRasDialExtensions,
        HWND                hwnd
        )
{
    DWORD dwErr = 0;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    if(     0 == hRasConn
        ||  NULL == lpRasDialExtensions)
    {
        dwErr = ERROR_INVALID_HANDLE;
        goto done;
    }

    if (sizeof (RASDIALEXTENSIONS) != lpRasDialExtensions->dwSize)
    {
        dwErr = ERROR_INVALID_SIZE;
        goto done;
    }

    //
    // Call the function that does all the work
    //
    dwErr = InvokeEapUI(hRasConn,
                        dwSubEntry,
                        lpRasDialExtensions,
                        hwnd);

done:
    return dwErr;
}

DWORD APIENTRY
RasGetLinkStatistics(
        HRASCONN    hRasConn,
        DWORD       dwSubEntry,
        RAS_STATS   *lpStatistics
        )
{
    DWORD dwErr = SUCCESS;
    HPORT hPort;
    DWORD dwSize;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    if(     0 == hRasConn
        ||  0 == dwSubEntry
        ||  NULL == lpStatistics
        ||  (sizeof(RAS_STATS) != lpStatistics->dwSize))
    {
        dwErr = E_INVALIDARG;
        goto done;
    }

#if DBG
    ASSERT(sizeof(RAS_STATS) ==
           sizeof(DWORD) * (MAX_STATISTICS_EXT + 3));
#endif

    dwErr = LoadRasmanDllAndInit();

    if (dwErr)
    {
        goto done;
    }

    if (DwRasInitializeError)
    {
        dwErr = DwRasInitializeError;
        goto done;
    }

    //
    // Get statistics corresponding to this subentry
    //
    dwErr = g_pRasLinkGetStatistics(
                        NULL,
                        (HCONN) hRasConn,
                        dwSubEntry,
                        (LPBYTE)
                        &(lpStatistics->dwBytesXmited)
                        );

    if(SUCCESS != dwErr)
    {
        RASAPI32_TRACE1("RasLinkGetStatistics: failed to get "
                "statistics. %d",
                dwErr);

        goto done;
    }

done:

    return dwErr;

}

DWORD APIENTRY
RasGetConnectionStatistics(
        HRASCONN    hRasConn,
        RAS_STATS   *lpStatistics
        )
{
    DWORD dwErr = SUCCESS;
    HPORT hPort;
    DWORD dwSize;
    DWORD dwSubEntry;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    if(     0 == hRasConn
        ||  NULL == lpStatistics
        ||  (sizeof(RAS_STATS) != lpStatistics->dwSize))
    {
        dwErr = E_INVALIDARG;
        goto done;
    }

#if DBG
    ASSERT(sizeof(RAS_STATS) ==
           sizeof(DWORD) * (MAX_STATISTICS_EXT + 3));
#endif

    dwErr = LoadRasmanDllAndInit();

    if (dwErr)
    {
        goto done;
    }

    if (DwRasInitializeError)
    {
        return DwRasInitializeError;
    }

    //
    // Get the connection statistics
    //
    dwErr = g_pRasConnectionGetStatistics(
                        NULL,
                        (HCONN) hRasConn,
                        (LPBYTE)
                        &(lpStatistics->dwBytesXmited));

    if(SUCCESS != dwErr)
    {
        RASAPI32_TRACE1("RasGetConnectionStatistics: failed "
               "to get stats. %d",
               dwErr);

        goto done;
    }


done:
    return dwErr;
}

DWORD APIENTRY
RasClearLinkStatistics(
            HRASCONN    hRasConn,
            DWORD       dwSubEntry
            )
{
    DWORD dwErr = SUCCESS;
    HPORT hPort;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    dwErr = LoadRasmanDllAndInit();

    if (dwErr)
    {
        goto done;
    }

    if (DwRasInitializeError)
    {
        dwErr = DwRasInitializeError;
        goto done;
    }

    //
    // Get the port
    //
    dwErr = SubEntryPort(hRasConn,
                         dwSubEntry,
                         &hPort);
    if(SUCCESS != dwErr)
    {
        RASAPI32_TRACE1("RasClearLinkStatistics: failed to "
               "get port. %d",
               dwErr);

        goto done;
    }

    //
    // Clear stats
    //
    dwErr = g_pRasPortClearStatistics(NULL, hPort);

    if(SUCCESS != dwErr)
    {
        RASAPI32_TRACE1("RasClearLinkStatistics: failed to "
                "clear stats. %d",
                dwErr);

        goto done;
    }

done:
    return dwErr;
}

DWORD APIENTRY
RasClearConnectionStatistics(
                    HRASCONN hRasConn
                    )
{
    DWORD dwErr = SUCCESS;
    HPORT hPort;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    dwErr = LoadRasmanDllAndInit();

    if (dwErr)
    {
        goto done;
    }

    if (DwRasInitializeError)
    {
        dwErr = DwRasInitializeError;
        goto done;
    }

    dwErr = g_pRasGetHportFromConnection(
                            NULL,
                            (HCONN) hRasConn,
                            &hPort
                            );

    if(SUCCESS != dwErr)
    {
        RASAPI32_TRACE1("RasClearConnectionStatistics: "
               "failed to clear stats. %d",
                dwErr);

        goto done;
    }

    //
    // Clear stats
    //
    dwErr = g_pRasBundleClearStatistics(NULL, hPort);
    if(SUCCESS != dwErr)
    {
        RASAPI32_TRACE1("RasClearConnectionStatistics: "
               "failed to clear stats.  %d",
               dwErr);

        goto done;
    }

done:
    return dwErr;
}



DWORD APIENTRY
RasGetEapUserDataW(HANDLE  hToken,
                   LPCWSTR pszPhonebook,
                   LPCWSTR pszEntry,
                   BYTE    *pbEapData,
                   DWORD   *pdwSizeofEapData)
{
    DWORD dwErr = ERROR_SUCCESS;

    PBFILE pbfile;

    DTLNODE *pdtlnode = NULL;

    PBENTRY *pEntry = NULL;

    STARTUPINFO startupinfo;

    BOOL fRouter = FALSE;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    RASAPI32_TRACE("RasGetEapUserDataW");

    ZeroMemory(&pbfile, sizeof(PBFILE));    //for bug170547
    pbfile.hrasfile = -1;
    
    dwErr = LoadRasmanDllAndInit();

    if (dwErr)
    {
        goto done;
    }

    if (DwRasInitializeError)
    {
        dwErr = DwRasInitializeError;
        goto done;
    }

    //
    // Validate parameters
    //
    if (NULL == pdwSizeofEapData)
    {
        dwErr = E_INVALIDARG;
        goto done;
    }

    /*
    GetStartupInfo(&startupinfo) ;

    if (NULL != (wcsstr (startupinfo.lpTitle,
                        TEXT("svchost.exe"))))
    {
        fRouter = TRUE;
    }
    */

    //
    // Load the phonebook file.
    //
#ifdef PBCS
    EnterCriticalSection(&PhonebookLock);
#endif


    dwErr = GetPbkAndEntryName(
                    pszPhonebook,
                    pszEntry,
                    RPBF_NoCreate,
                    &pbfile,
                    &pdtlnode);

    if(SUCCESS != dwErr)
    {
        goto done;
    }

    pEntry = (PBENTRY *)DtlGetData(pdtlnode);

    ASSERT(pEntry);

    fRouter = IsRouterPhonebook(pszPhonebook);

    //
    // Ask rasman to do the work.
    //
    dwErr = g_pRasGetEapUserInfo(
                        hToken,
                        pbEapData,
                        pdwSizeofEapData,
                        pEntry->pGuid,
                        fRouter,
                        pEntry->dwCustomAuthKey);

done:

    //
    // Clean up.
    //
    ClosePhonebookFile(&pbfile);

#ifdef PBCS
    LeaveCriticalSection(&PhonebookLock);
#endif

    RASAPI32_TRACE1("RasGetEapUserDataW. 0x%x",
            dwErr);

    return dwErr;
}

DWORD APIENTRY
RasSetEapUserDataW(HANDLE  hToken,
                   LPCWSTR pszPhonebook,
                   LPCWSTR pszEntry,
                   BYTE    *pbEapData,
                   DWORD   dwSizeofEapData)
{
    DWORD dwErr  = ERROR_SUCCESS;
    BOOL  fClear = FALSE;

    PBFILE pbfile;

    DTLNODE *pdtlnode = NULL;

    PBENTRY *pEntry = NULL;

    STARTUPINFO startupinfo;

    BOOL fRouter = FALSE;

    BOOL fPbkOpened = FALSE;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    RASAPI32_TRACE("RasSetEapUserDataW");

    dwErr = LoadRasmanDllAndInit();

    if (dwErr)
    {
        goto done;
    }

    if (DwRasInitializeError)
    {
        dwErr = DwRasInitializeError;
        goto done;
    }

    //
    // Validate parameters
    //
    if (    (0 == dwSizeofEapData)
        ||  (NULL == pbEapData))
    {
        fClear = TRUE;
    }

    /*
    GetStartupInfo(&startupinfo) ;

    if (NULL != (wcsstr (startupinfo.lpTitle,
                         TEXT("svchost.exe"))))
    {
        fRouter = TRUE;
    }

    */

    //
    // Load the phonebook file.
    //
#ifdef PBCS
    EnterCriticalSection(&PhonebookLock);
#endif

    pbfile.hrasfile = -1;

    dwErr = GetPbkAndEntryName(
                        pszPhonebook,
                        pszEntry,
                        RPBF_NoCreate,
                        &pbfile,
                        &pdtlnode);

    if(SUCCESS != dwErr)
    {
        goto done;
    }

    fPbkOpened = TRUE;

    pEntry = (PBENTRY *)DtlGetData(pdtlnode);

    ASSERT(pEntry);

    fRouter = IsRouterPhonebook(pszPhonebook);

    //
    // Ask rasman to do the work.
    //
    dwErr = g_pRasSetEapUserInfo(
                        hToken,
                        pEntry->pGuid,
                        pbEapData,
                        dwSizeofEapData,
                        fClear,
                        fRouter,
                        pEntry->dwCustomAuthKey);

done:

    if(fPbkOpened)
    {
        //
        // Clean up.
        //
        ClosePhonebookFile(&pbfile);
    }

#ifdef PBCS
    LeaveCriticalSection(&PhonebookLock);
#endif

    RASAPI32_TRACE1("RasSetEapUserDataW. 0x%x",
            dwErr);

    return dwErr;
}

DWORD APIENTRY
RasGetEapUserDataA(HANDLE hToken,
                   LPCSTR pszPhonebook,
                   LPCSTR pszEntry,
                   BYTE   *pbEapData,
                   DWORD  *pdwSizeofEapData)
{
    DWORD dwErr = ERROR_SUCCESS;

    WCHAR szPhonebookW[MAX_PATH];

    WCHAR szEntryNameW[RAS_MaxEntryName + 1];

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    if(NULL == pdwSizeofEapData)
    {
        dwErr = E_INVALIDARG;
        goto done;
    }

    //
    // Convert the lpszPhonebook string to Unicode.
    //
    if (pszPhonebook != NULL)
    {
        strncpyAtoWAnsi(szPhonebookW,
                    pszPhonebook,
                    MAX_PATH);
    }

    //
    // Convert the lpszEntry string to Unicode.
    //
    if (pszEntry != NULL)
    {
        strncpyAtoWAnsi(szEntryNameW,
                    pszEntry,
                    RAS_MaxEntryName + 1);
    }

    dwErr = RasGetEapUserDataW(
                     hToken,
                       (NULL != pszPhonebook)
                     ? szPhonebookW
                     : NULL,
                       (NULL != pszEntry)
                     ? szEntryNameW
                     : NULL,
                     pbEapData,
                     pdwSizeofEapData);

done:

    return dwErr;

}

DWORD APIENTRY
RasSetEapUserDataA(HANDLE hToken,
                   LPCSTR pszPhonebook,
                   LPCSTR pszEntry,
                   BYTE   *pbEapData,
                   DWORD  dwSizeofEapData)
{
    DWORD dwErr = ERROR_SUCCESS;

    WCHAR szPhonebookW[MAX_PATH];

    WCHAR szEntryNameW[RAS_MaxEntryName + 1];

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    //
    // Convert the pszPhonebook string to Unicode.
    //
    if (pszPhonebook != NULL)
    {
        strncpyAtoWAnsi(szPhonebookW,
                    pszPhonebook,
                    MAX_PATH);
    }

    //
    // Convert the pszEntry string to Unicode.
    //
    if (pszEntry != NULL)
    {
        strncpyAtoWAnsi(szEntryNameW,
                    pszEntry,
                    RAS_MaxEntryName + 1);
    }

    dwErr = RasSetEapUserDataW(
                     hToken,
                       (NULL != pszPhonebook)
                     ? szPhonebookW
                     : NULL,
                       (NULL != pszEntry)
                     ? szEntryNameW
                     : NULL,
                     pbEapData,
                     dwSizeofEapData);

    return dwErr;
}

DWORD APIENTRY
RasGetCustomAuthDataW(
            LPCWSTR pszPhonebook,
            LPCWSTR pszEntry,
            BYTE    *pbCustomAuthData,
            DWORD   *pdwSizeofCustomAuthData)
{
    DWORD dwErr = ERROR_SUCCESS;

    PBFILE pbfile;

    DTLNODE *pdtlnode = NULL;

    PBENTRY *pEntry = NULL;

    DWORD cbCustomAuthData;
    DWORD cbData = 0;
    PBYTE pbData = NULL;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    RASAPI32_TRACE("RasGetCustomAuthDataW");

    dwErr = LoadRasmanDllAndInit();

    ZeroMemory(&pbfile, sizeof(PBFILE));

    pbfile.hrasfile = -1;

    if (dwErr)
    {
        goto done;
    }

    if (DwRasInitializeError)
    {
        dwErr = DwRasInitializeError;
        goto done;
    }

    //
    // Validate parameters
    //
    if (NULL == pdwSizeofCustomAuthData)
    {
        dwErr = E_INVALIDARG;
        goto done;
    }

    cbCustomAuthData = *pdwSizeofCustomAuthData;

    dwErr = GetPbkAndEntryName(
                    pszPhonebook,
                    pszEntry,
                    RPBF_NoCreate,
                    &pbfile,
                    &pdtlnode);

    if(SUCCESS != dwErr)
    {
        goto done;
    }

    pEntry = (PBENTRY *)DtlGetData(pdtlnode);

    ASSERT(pEntry);

    dwErr = DwGetCustomAuthData(pEntry,
                                &cbData,
                                &pbData);

    if(SUCCESS != dwErr)
    {
        goto done;
    }

    *pdwSizeofCustomAuthData = cbData;

    if(     (cbCustomAuthData < cbData)
        ||  (NULL == pbCustomAuthData))
    {
        dwErr = ERROR_BUFFER_TOO_SMALL;
        goto done;
    }

    memcpy(pbCustomAuthData,
           pbData,
           *pdwSizeofCustomAuthData);

done:

    //
    // Clean up.
    //
    ClosePhonebookFile(&pbfile);

    RASAPI32_TRACE1("RasGetCustomAuthDataW. 0x%x",
            dwErr);

    return dwErr;
}

DWORD APIENTRY
RasSetCustomAuthDataW(
        LPCWSTR pszPhonebook,
        LPCWSTR pszEntry,
        BYTE    *pbCustomAuthData,
        DWORD   cbCustomAuthData
        )
{
    DWORD dwErr = ERROR_SUCCESS;

    PBFILE pbfile;

    DTLNODE *pdtlnode = NULL;

    PBENTRY *pEntry = NULL;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    RASAPI32_TRACE("RasSetCustomAuthDataW");

    ZeroMemory(&pbfile, sizeof(PBFILE));

    pbfile.hrasfile = -1;

    dwErr = LoadRasmanDllAndInit();

    if (dwErr)
    {
        goto done;
    }

    if (DwRasInitializeError)
    {
        dwErr = DwRasInitializeError;
        goto done;
    }

    dwErr = GetPbkAndEntryName(
                        pszPhonebook,
                        pszEntry,
                        RPBF_NoCreate,
                        &pbfile,
                        &pdtlnode);

    if(SUCCESS != dwErr)
    {
        goto done;
    }

    pEntry = (PBENTRY *)DtlGetData(pdtlnode);

    ASSERT(pEntry);

    /*
    if(NULL != pEntry->pCustomAuthData)
    {
        Free(pEntry->pCustomAuthData);
        pEntry->pCustomAuthData = NULL;
        pEntry->cbCustomAuthData = 0;
    }


    if(NULL != pbCustomAuthData)
    {
        pEntry->pCustomAuthData = Malloc(cbCustomAuthData);
        if(NULL == pEntry->pCustomAuthData)
        {
            dwErr = GetLastError();
            goto done;
        }

        pEntry->cbCustomAuthData = cbCustomAuthData;
        memcpy(pEntry->pCustomAuthData,
               pbCustomAuthData,
               pEntry->cbCustomAuthData);
    }
    */

    dwErr = DwSetCustomAuthData(
                pEntry,
                cbCustomAuthData,
                pbCustomAuthData);

    if(ERROR_SUCCESS != dwErr)
    {
        goto done;
    }

    pEntry->fDirty = TRUE;

    WritePhonebookFile(&pbfile, NULL);

done:

    //
    // Clean up.
    //
    ClosePhonebookFile(&pbfile);

    RASAPI32_TRACE1("RasSetCustomAuthDataW. 0x%x",
            dwErr);

    return dwErr;
}

DWORD APIENTRY
RasGetCustomAuthDataA(
        LPCSTR pszPhonebook,
        LPCSTR pszEntry,
        BYTE   *pbCustomAuthData,
        DWORD  *pdwSizeofCustomAuthData)
{
    DWORD dwErr = ERROR_SUCCESS;

    WCHAR szPhonebookW[MAX_PATH];

    WCHAR szEntryNameW[RAS_MaxEntryName + 1];

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    if(NULL == pdwSizeofCustomAuthData)
    {
        dwErr = E_INVALIDARG;
        goto done;
    }

    //
    // Convert the lpszPhonebook string to Unicode.
    //
    if (pszPhonebook != NULL)
    {
        strncpyAtoWAnsi(szPhonebookW,
                    pszPhonebook,
                    MAX_PATH);
    }

    //
    // Convert the lpszEntry string to Unicode.
    //
    if (pszEntry != NULL)
    {
        strncpyAtoWAnsi(szEntryNameW,
                    pszEntry,
                    RAS_MaxEntryName + 1);
    }

    dwErr = RasGetCustomAuthDataW(
                       (NULL != pszPhonebook)
                     ? szPhonebookW
                     : NULL,
                       (NULL != pszEntry)
                     ? szEntryNameW
                     : NULL,
                     pbCustomAuthData,
                     pdwSizeofCustomAuthData);

done:

    return dwErr;

}

DWORD APIENTRY
RasSetCustomAuthDataA(
        LPCSTR pszPhonebook,
        LPCSTR pszEntry,
        BYTE   *pbCustomAuthData,
        DWORD  dwSizeofCustomAuthData
        )
{
    DWORD dwErr = ERROR_SUCCESS;

    WCHAR szPhonebookW[MAX_PATH];

    WCHAR szEntryNameW[RAS_MaxEntryName + 1];

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    //
    // Convert the pszPhonebook string to Unicode.
    //
    if (pszPhonebook != NULL)
    {
        strncpyAtoWAnsi(szPhonebookW,
                    pszPhonebook,
                    MAX_PATH);
    }

    //
    // Convert the pszEntry string to Unicode.
    //
    if (pszEntry != NULL)
    {
        strncpyAtoWAnsi(szEntryNameW,
                    pszEntry,
                    RAS_MaxEntryName + 1);
    }

    dwErr = RasSetCustomAuthDataW(
                       (NULL != pszPhonebook)
                     ? szPhonebookW
                     : NULL,
                       (NULL != pszEntry)
                     ? szEntryNameW
                     : NULL,
                     pbCustomAuthData,
                     dwSizeofCustomAuthData
                     );

    return dwErr;
}


DWORD APIENTRY
RasQueryRedialOnLinkFailure(
                    LPCTSTR pszPhonebook,
                    LPCTSTR pszEntry,
                    BOOL   *pfEnabled)
{
    DWORD dwErr = SUCCESS;
    PBFILE file;
    PBENTRY *pEntry;
    DTLNODE *pdtlnode;

    file.hrasfile = -1;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    if(NULL == pfEnabled)
    {
        dwErr = E_INVALIDARG;
        goto done;
    }

    *pfEnabled = FALSE;

    dwErr = GetPbkAndEntryName(pszPhonebook,
                               pszEntry,
                               0,
                               &file,
                               &pdtlnode);

    if(SUCCESS != dwErr)
    {
        goto done;
    }

    pEntry = (PBENTRY *) DtlGetData(pdtlnode);

    *pfEnabled = pEntry->fRedialOnLinkFailure;

    ClosePhonebookFile(&file);

done:
    return dwErr;
}

DWORD APIENTRY
RasGetEapUserIdentityW(
    IN      LPCWSTR                 pszPhonebook,
    IN      LPCWSTR                 pszEntry,
    IN      DWORD                   dwFlags,
    IN      HWND                    hwnd,
    OUT     LPRASEAPUSERIDENTITYW*  ppRasEapUserIdentity
)
{
    DWORD       dwErr               = ERROR_SUCCESS;
    PBFILE      pbfile;
    DTLNODE*    pdtlnode            = NULL;
    PBENTRY*    pEntry              = NULL;
    HKEY        hkeyBase            = NULL;
    HKEY        hkeyEap             = NULL;
    BYTE*       pbDataIn            = NULL;
    BYTE*       pbDataOut           = NULL;
    WCHAR*      pwszIdentity        = NULL;
    WCHAR*      pwszDllPath         = NULL;
    HINSTANCE   hInstanceDll        = NULL;
    DWORD       cbDataIn            = 0;
    WCHAR       szEapNumber[20];
    DWORD       dwValue;
    DWORD       dwSize;
    DWORD       cbDataOut;
    RASEAPGETIDENTITY   pRasEapGetIdentity = NULL;
    RASEAPFREEMEMORY    pRasEapFreeMemory  = NULL;
    DWORD       cbCustomData;
    PBYTE       pbCustomData;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    RASAPI32_TRACE("RasGetEapUserIdentityW");

    if (NULL == ppRasEapUserIdentity)
    {
        return(ERROR_INVALID_ADDRESS);
    }

    *ppRasEapUserIdentity = NULL;

    dwErr = LoadRasmanDllAndInit();

    if (dwErr)
    {
        return(dwErr);
    }

    if (DwRasInitializeError)
    {
        return(DwRasInitializeError);
    }

    //
    // Load the phonebook file.
    //
#ifdef PBCS
    EnterCriticalSection(&PhonebookLock);
#endif

    ZeroMemory(&pbfile, sizeof(PBFILE));

    pbfile.hrasfile = -1;

    dwErr = GetPbkAndEntryName(
                    pszPhonebook,
                    pszEntry,
                    RPBF_NoCreate,
                    &pbfile,
                    &pdtlnode);

    if (SUCCESS != dwErr)
    {
        goto done;
    }

    pEntry = (PBENTRY *)DtlGetData(pdtlnode);

    ASSERT(pEntry);

    if (!(pEntry->dwAuthRestrictions & AR_F_AuthEAP))
    {
        dwErr = ERROR_INVALID_FUNCTION_FOR_ENTRY;
        goto done;
    }

    //
    // Convert the EAP number to a string
    //
    _itow(pEntry->dwCustomAuthKey, szEapNumber, 10);

    //
    // Open the registry.
    //
    dwErr = RegOpenKeyEx(
              HKEY_LOCAL_MACHINE,
              EAP_REGBASE,
              0,
              KEY_READ,
              &hkeyBase);

    if (dwErr)
    {
        goto done;
    }

    //
    // Open the registry.
    //
    dwErr = RegOpenKeyEx(
              hkeyBase,
              szEapNumber,
              0,
              KEY_READ,
              &hkeyEap);

    if (dwErr)
    {
        goto done;
    }

    //
    // Does this EAP support RasEapGetIdentity?
    //
    dwSize = sizeof(dwValue);

    dwErr = RegQueryValueEx(
                hkeyEap,
                EAP_REGINVOKE_NAMEDLG,
                NULL,
                NULL,
                (BYTE*)&dwValue,
                &dwSize);

    if (   (dwErr)
        || (dwValue != 0))
    {
        dwErr = ERROR_INVALID_FUNCTION_FOR_ENTRY;
        goto done;
    }

    //
    // Get the per user data size
    //
    dwSize = 0;

    dwErr = RasGetEapUserDataW(
                NULL,
                pszPhonebook,
                pszEntry,
                NULL,
                &dwSize);

    if (dwErr == ERROR_BUFFER_TOO_SMALL)
    {
        pbDataIn = Malloc(dwSize);

        if(NULL == pbDataIn)
        {
            dwErr = GetLastError();
            goto done;
        }

        //
        // Get the per user data
        //
        dwErr = RasGetEapUserDataW(
                    NULL,
                    pszPhonebook,
                    pszEntry,
                    pbDataIn,
                    &dwSize);

        if (dwErr != NO_ERROR)
        {
            goto done;
        }

        cbDataIn = dwSize;
    }
    else if (NO_ERROR != dwErr)
    {
        goto done;
    }

    //
    // Get the EAP dll's path ...
    //
    dwErr = GetRegExpandSz(
                hkeyEap,
                EAP_REGIDENTITY_PATH,
                &pwszDllPath);

    if (dwErr != 0)
    {
        goto done;
    }

    //
    // ... and load it
    //
    hInstanceDll = LoadLibrary(pwszDllPath);

    if (NULL == hInstanceDll)
    {
        dwErr = GetLastError();
        goto done;
    }

    //
    // Get the function pointer to call
    //
    pRasEapGetIdentity = (RASEAPGETIDENTITY) GetProcAddress(
                                hInstanceDll,
                                EAP_RASEAPGETIDENTITY);
    pRasEapFreeMemory = (RASEAPFREEMEMORY) GetProcAddress(
                                hInstanceDll,
                                EAP_RASEAPFREEMEMORY);

    if (   (NULL == pRasEapGetIdentity)
        || (NULL == pRasEapFreeMemory))
    {
        dwErr = GetLastError();
        goto done;
    }

    //
    // Get the data from the EAP dll
    //
    if (dwFlags & RASEAPF_NonInteractive)
    {
        hwnd = NULL;
    }

    if (IsRouterPhonebook(pszPhonebook))
    {
        dwFlags |= RAS_EAP_FLAG_ROUTER;
    }

    dwErr = DwGetCustomAuthData(
                    pEntry,
                    &cbCustomData,
                    &pbCustomData);

    if(ERROR_SUCCESS != dwErr)
    {
        goto done;
    }

    dwErr = pRasEapGetIdentity(
                pEntry->dwCustomAuthKey,
                hwnd,
                dwFlags,
                pszPhonebook,
                pszEntry,
                pbCustomData,
                cbCustomData,
                pbDataIn,
                cbDataIn,
                &pbDataOut,
                &cbDataOut,
                &pwszIdentity);

    if (dwErr != NO_ERROR)
    {
        goto done;
    }

    //
    // Allocate the structure.
    //
    *ppRasEapUserIdentity = Malloc(sizeof(RASEAPUSERIDENTITYW) - 1 + cbDataOut);

    if (NULL == *ppRasEapUserIdentity)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto done;
    }

    wcsncpy((*ppRasEapUserIdentity)->szUserName, pwszIdentity, UNLEN);
    (*ppRasEapUserIdentity)->szUserName[UNLEN] = 0;
    (*ppRasEapUserIdentity)->dwSizeofEapInfo = cbDataOut;
    CopyMemory((*ppRasEapUserIdentity)->pbEapInfo, pbDataOut, cbDataOut);

done:

    //
    // Clean up.
    //
    ClosePhonebookFile(&pbfile);

#ifdef PBCS
    LeaveCriticalSection(&PhonebookLock);
#endif

    if (NULL != hkeyBase)
    {
        RegCloseKey(hkeyBase);
    }

    if (NULL != hkeyEap)
    {
        RegCloseKey(hkeyEap);
    }

    if (NULL != pbDataIn)
    {
        Free(pbDataIn);
    }

    if (NULL != pwszDllPath)
    {
        Free(pwszDllPath);
    }

    if (NULL != pRasEapFreeMemory)
    {
        if (NULL != pbDataOut)
        {
            pRasEapFreeMemory(pbDataOut);
        }

        if (NULL != pwszIdentity)
        {
            pRasEapFreeMemory((BYTE*)pwszIdentity);
        }
    }

    if (NULL != hInstanceDll)
    {
        FreeLibrary(hInstanceDll);
    }

    RASAPI32_TRACE1("RasGetEapUserIdentityW. 0x%x", dwErr);

    return dwErr;
}

DWORD APIENTRY
RasGetEapUserIdentityA(
    IN      LPCSTR                  pszPhonebook,
    IN      LPCSTR                  pszEntry,
    IN      DWORD                   dwFlags,
    IN      HWND                    hwnd,
    OUT     LPRASEAPUSERIDENTITYA*  ppRasEapUserIdentity
)
{
    DWORD                   dwErr                               = ERROR_SUCCESS;
    WCHAR                   szPhonebookW[MAX_PATH];
    WCHAR                   szEntryNameW[RAS_MaxEntryName + 1];
    LPRASEAPUSERIDENTITYW   pRasEapUserIdentityW                = NULL;
    DWORD                   dwSizeofEapInfo;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    if (NULL == ppRasEapUserIdentity)
    {
        return(ERROR_INVALID_ADDRESS);
    }

    *ppRasEapUserIdentity = NULL;

    //
    // Convert the pszPhonebook string to Unicode.
    //
    if (pszPhonebook != NULL)
    {
        strncpyAtoWAnsi(szPhonebookW,
                    pszPhonebook,
                    MAX_PATH);
    }

    //
    // Convert the pszEntry string to Unicode.
    //
    if (pszEntry != NULL)
    {
        strncpyAtoWAnsi(szEntryNameW,
                    pszEntry,
                    RAS_MaxEntryName + 1);
    }

    //
    // Call the W version to do all the work.
    //
    dwErr = RasGetEapUserIdentityW(
                       (NULL != pszPhonebook)
                     ? szPhonebookW
                     : NULL,
                       (NULL != pszEntry)
                     ? szEntryNameW
                     : NULL,
                     dwFlags,
                     hwnd,
                     &pRasEapUserIdentityW);

    if (dwErr != NO_ERROR)
    {
        goto done;
    }

    //
    // Allocate the structure.
    //
    dwSizeofEapInfo = pRasEapUserIdentityW->dwSizeofEapInfo;
    *ppRasEapUserIdentity = Malloc(
                    sizeof(RASEAPUSERIDENTITYA) - 1 + dwSizeofEapInfo);

    if (NULL == *ppRasEapUserIdentity)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto done;
    }

    //
    // Copy the fields from the W buffer
    // to the A buffer.
    //

    strncpyWtoAAnsi((*ppRasEapUserIdentity)->szUserName,
               pRasEapUserIdentityW->szUserName,
               sizeof((*ppRasEapUserIdentity)->szUserName));
    (*ppRasEapUserIdentity)->dwSizeofEapInfo = dwSizeofEapInfo;
    CopyMemory((*ppRasEapUserIdentity)->pbEapInfo,
               pRasEapUserIdentityW->pbEapInfo,
               dwSizeofEapInfo);

done:

    if (NULL != pRasEapUserIdentityW)
    {
        Free(pRasEapUserIdentityW);
    }

    return dwErr;
}

VOID APIENTRY
RasFreeEapUserIdentityW(
    IN  LPRASEAPUSERIDENTITYW   pRasEapUserIdentity
)
{
    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    if (NULL != pRasEapUserIdentity)
    {
        Free(pRasEapUserIdentity);
    }
}

VOID APIENTRY
RasFreeEapUserIdentityA(
    IN  LPRASEAPUSERIDENTITYA   pRasEapUserIdentity
)
{
    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    if (NULL != pRasEapUserIdentity)
    {
        Free(pRasEapUserIdentity);
    }
}

DWORD APIENTRY
RasDeleteSubEntryW(
        LPCWSTR pszPhonebook,
        LPCWSTR pszEntry,
        DWORD   dwSubEntryId)
{
    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    return DwDeleteSubEntry(
                pszPhonebook,
                pszEntry,
                dwSubEntryId);
}

DWORD APIENTRY
RasDeleteSubEntryA(
        LPCSTR pszPhonebook,
        LPCSTR pszEntry,
        DWORD  dwSubEntryId)
{
    WCHAR wszPhonebook[MAX_PATH + 1];
    WCHAR wszEntry[RAS_MaxEntryName + 1];

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    if(     (NULL == pszEntry)
        ||  (0 == dwSubEntryId))
    {
        return E_INVALIDARG;
    }

    if(NULL != pszPhonebook)
    {
        strncpyAtoWAnsi(wszPhonebook,   
                        pszPhonebook,
                        MAX_PATH);
    }

    strncpyAtoWAnsi(wszEntry,
                    pszEntry,
                    RAS_MaxEntryName);

    return RasDeleteSubEntryW(
                (NULL != pszPhonebook) ? wszPhonebook : NULL,
                wszEntry,
                dwSubEntryId);
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\extapi\src\asyncm.h ===
/* Copyright (c) 1992, Microsoft Corporation, all rights reserved
**
** asyncm.h
** Remote Access External APIs
** Asyncronous state machine mechanism definitions
**
** 10/12/92 Steve Cobb
*/

#ifndef _ASYNCM_H_
#define _ASYNCM_H_


/* Defines an OnEvent function which is supplied by caller in the ASYNCMACHINE
** structure passed to StartAsyncMachine.  The first argument is actually an
** ASYNCMACHINE* but there's a chicken and egg definition problem with
** ONEVENTFUNC and ASYNCMACHINE that's most easily solved by caller casting
** the passed argument.  The second argument is true if a "drop" event has
** occurred, false if a "done" event has occurred.
**
** Caller's ONEVENTFUNC function is called once on each AsyncMachineEvent and
** should return as soon as possible.  Before returning caller's function should
** either call SignalDone or call an asynchronous RAS Manager call passing the
** hEvent member for notification.  On each call caller's function should check
** the 'dwError' member of ASYNCMACHINE before further processing to detect
** errors in the asynch machine mechanism.
**
** Caller's function should return true to quit, false to go on to the next
** state.
*/
typedef BOOL (*ONEVENTFUNC)( LPVOID, BOOL );

/* Defines a clean up function that is called just before exitting the async
** machine.
*/
typedef VOID (*CLEANUPFUNC)( LPVOID );

//
// Defines a free function that deallocates memory associated
// with the connection after the final event is read from the
// I/O completion port.
//
typedef VOID (*FREEFUNC)(LPVOID, LPVOID);

/* This structure is used to pass arguments into the asynchronous loop
** (squeezes more than one argument thru the one-argument thread interface on
** Win32).  Caller must fill in the 'oneventfunc' and 'cleanupfunc', and
** 'pParam' (passed to both calls, i.e. a control block) before calling
** StartAsyncMachine.  Thereafter, only the interface calls and macros should
** be used.
**
** There are three overlapped structures used in I/O completion port
** processing between rasapi32 and rasman.  OvDrop is the overlapped
** structure passed when rasman signals a port disconnect event.
** OvStateChange is the overlapped structure signaled both by rasapi32
** and rasman on the completion of rasdial state machine transitions.
** OvPpp is the overlapped structure signaled by rasman when a new PPP
** event arrives, and RasPppGetInfo can be called to return the event.
**
** 'dwError' is set non-0 if an system error occurs in the async machine
** mechanism.
**
** 'fQuitAsap' is indicates that the thread is being terminated by other than
** reaching a terminal state, i.e. by RasHangUp.
*/
#define INDEX_Drop      0

#define ASYNCMACHINE struct tagASYNCMACHINE

ASYNCMACHINE
{
    LIST_ENTRY  ListEntry;
    ONEVENTFUNC oneventfunc;
    CLEANUPFUNC cleanupfunc;
    VOID*       pParam;
    FREEFUNC    freefunc;
    LPVOID      freefuncarg;
    DWORD       dwError;
    //BOOL        fQuitAsap;
    BOOL        fSuspended;
    HANDLE      hDone;
    //
    // The following fields are used
    // by the async machine worker
    // thread to process I/O completion
    // packets.
    //
    BOOL        fSignaled;
    HPORT       hport;
    DWORD       dwfMode;
    HRASCONN    hRasconn;
    RAS_OVERLAPPED OvDrop;
    RAS_OVERLAPPED OvStateChange;
    RAS_OVERLAPPED OvPpp;
    RAS_OVERLAPPED OvLast;
};


//
// Flags to dwfMode parameter of EnableAsyncMachine().
//
#define ASYNC_ENABLE_ALL            0
#define ASYNC_MERGE_DISCONNECT      1
#define ASYNC_DISABLE_ALL           2

/* Function prototypes
*/
VOID  CloseAsyncMachine( ASYNCMACHINE* pasyncmachine );
DWORD NotifyCaller( DWORD dwNotifierType, LPVOID notifier,
          HRASCONN hrasconn, DWORD dwSubEntry, ULONG_PTR dwCallbackId,
          UINT unMsg, RASCONNSTATE state, DWORD dwError,
          DWORD dwExtendedError );
VOID  SignalDone( ASYNCMACHINE* pasyncmachine );
DWORD StartAsyncMachine( ASYNCMACHINE* pasyncmachine, HRASCONN hRasconn );
VOID  SuspendAsyncMachine( ASYNCMACHINE* pasyncmachine, BOOL fSuspended );
DWORD ResetAsyncMachine( ASYNCMACHINE *pasyncmachine );
BOOL  StopAsyncMachine( ASYNCMACHINE* pasyncmachine );
DWORD EnableAsyncMachine(HPORT, ASYNCMACHINE* pasyncmachine, DWORD dwfMode);
VOID  ShutdownAsyncMachine(VOID);

#endif /* _ASYNCM_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\extapi\src\eapui.c ===
/*++

Copyright (c) 1995, Microsoft Corporation, all rights reserved

Module Name:

    eapui.c

Abstract:

    this file contains code to Invoke the eapui from registry

Author:    

    Rao Salapaka 11/03/97 

Revision History:    

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <extapi.h>
#include "extapi.h"
#include "rasauth.h"
#include "raseapif.h"

typedef DWORD (APIENTRY * PEAPINVOKEINTERACTIVEUI)(
                                           DWORD,
                                           HWND,
                                           PBYTE,
                                           DWORD,
                                           PBYTE *,
                                           DWORD *);

typedef DWORD (APIENTRY * PEAPFREEMEMORY)(
                                           PBYTE);

LONG
lrGetMaxSubkeyLength( HKEY hkey, DWORD *pdwMaxSubkeyLen )
{
    LONG        lr = ERROR_SUCCESS;
    FILETIME    ft;

    lr = RegQueryInfoKey( hkey,
                          NULL, NULL, NULL, NULL,
                          pdwMaxSubkeyLen,
                          NULL, NULL, NULL, NULL,
                          NULL, &ft);
    return lr;
}

DWORD
DwGetDllPath(DWORD dwEapTypeId, LPTSTR *ppszDllPath)
{
    LONG        lr              = ERROR_SUCCESS;
    LPTSTR      pszSubkeyName   = NULL;
    DWORD       dwMaxSubkeyLen;
    HKEY        hkey            = NULL;
    DWORD       dwIndex         = 0;
    DWORD       dwType, dwSize;
    DWORD       dwTypeId;
    LPTSTR      pszDllPath;
    TCHAR       szEapPath[64]   = {0};
    TCHAR       szEapId[12]     = {0};

    //
    // Create the path to the eap key we 
    // are interested in
    //
    _snwprintf(szEapPath,
               (sizeof(szEapPath) / sizeof(TCHAR)) - 1,
               TEXT("%s\\%s"), 
               RAS_EAP_REGISTRY_LOCATION, 
               _ultow(dwEapTypeId, szEapId, 10));

    //
    // Open the eap key
    //
    if (lr = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                          szEapPath,
                          0,
                          KEY_READ,
                          &hkey))
    {
        RASAPI32_TRACE1(
            "failed to open eap key %S. 0x%0x",
            szEapPath);
            
        RASAPI32_TRACE1("rc=0x%08x", lr);
            
        goto done;            
    }

    dwSize = 0;
    
    //
    // Get the size of the dll path
    //
    if(lr = RegQueryValueEx(
                        hkey,
                        RAS_EAP_VALUENAME_INTERACTIVEUI,
                        NULL,
                        &dwType,
                        NULL,
                        &dwSize))
    {
        RASAPI32_TRACE1("RegQ failed. for InteractiveUI. 0x%x",
               lr);
               
        goto done;
        
    }

    //
    // Allocate and get the dll name
    //
    pszDllPath = LocalAlloc(LPTR, dwSize);
    if(NULL == pszDllPath)
    {
        lr = (LONG) GetLastError();
        
        RASAPI32_TRACE2("Failed to allocate size %d. rc=0x%x",
               dwSize,
               lr);

        goto done;               
    }

    if (lr = RegQueryValueEx(
                        hkey,
                        RAS_EAP_VALUENAME_INTERACTIVEUI,
                        NULL,
                        &dwType,
                        (PBYTE) pszDllPath,
                        &dwSize))
    {
    
        RASAPI32_TRACE1("RegQ failed. for InteractiveUI. 0x%x",
               lr);
               
        goto done;
    }

    //
    // Expand the dllpath
    //
    lr = (LONG) DwGetExpandedDllPath(pszDllPath,
                                     ppszDllPath);
    
done:

    if (pszSubkeyName)
    {
        LocalFree(pszSubkeyName);
    }

    if (hkey)
    {
        RegCloseKey(hkey);
    }

    return (DWORD) lr;
}

DWORD
DwLoadEapDllAndGetEntryPoints( 
        DWORD                       dwEapTypeId,
        PEAPINVOKEINTERACTIVEUI     *ppfnInvoke,
        PEAPFREEMEMORY              *ppfnFree,
        HINSTANCE                   *phlib
        )
{
    HKEY        hkey                = NULL;
    LPTSTR      pszDllPath          = NULL;
    LPTSTR      pszExpandedDllPath  = NULL;
    DWORD       dwErr;
    DWORD       dwSize;
    DWORD       dwType;
    HINSTANCE   hlib = NULL;

    dwErr = DwGetDllPath(dwEapTypeId, &pszDllPath);

    if (dwErr)
    {
        RASAPI32_TRACE1("GetDllPath failed. %d", dwErr);

        goto done;
    }

    //
    // Load lib and get the entrypoints
    //
    hlib = LoadLibrary(pszDllPath);

    if (NULL == hlib)
    {
        dwErr = GetLastError();
        
        RASAPI32_TRACE1("Failed to load %S", pszDllPath);
        
        RASAPI32_TRACE1("dwErr=%d", dwErr);
        
        goto done;
    }

    if (    !((*ppfnInvoke) = (PEAPINVOKEINTERACTIVEUI)
                              GetProcAddress(
                                hlib, 
                                "RasEapInvokeInteractiveUI"))
                
        ||  !((*ppfnFree ) = (PEAPFREEMEMORY)
                             GetProcAddress(
                                hlib, 
                                "RasEapFreeMemory")))
    {
        dwErr = GetLastError();
        
        RASAPI32_TRACE1("failed to get entrypoint. rc=%d", dwErr);

        FreeLibrary(hlib);
        
        hlib = NULL;
        
        goto done;
    }
                                             
done:

    *phlib = hlib;

    if ( pszDllPath )
    {
        LocalFree(pszDllPath);
    }

    return dwErr;
}

DWORD
DwCallEapUIEntryPoint(s_InvokeEapUI *pInfo, HWND hWnd )
{
    DWORD                       dwErr;
    PEAPINVOKEINTERACTIVEUI     pfnEapInvokeInteractiveUI;
    PEAPFREEMEMORY              pfnEapFreeMemory;
    HINSTANCE                   hlib;
    PBYTE                       pUIData = NULL;
    DWORD                       dwSizeOfUIData;

    dwErr = DwLoadEapDllAndGetEntryPoints(
                            pInfo->dwEapTypeId,
                            &pfnEapInvokeInteractiveUI,
                            &pfnEapFreeMemory,
                            &hlib);

    if (dwErr)
    {
        RASAPI32_TRACE1("DwLoadEapDllAndGetEntryPoints failed. %d",
                dwErr);

        goto done;                
    }

    //
    // Bringup the ui
    //
    dwErr = (*pfnEapInvokeInteractiveUI)(
                            pInfo->dwEapTypeId,
                            hWnd,
                            pInfo->pUIContextData,
                            pInfo->dwSizeOfUIContextData,
                            &pUIData,
                            &dwSizeOfUIData
                            );
    if (dwErr)
    {
        RASAPI32_TRACE1("pfnEapInvokeInteractiveUI failed. %d",
                dwErr);
                
        goto done;                
    }

    //
    // free the context we passed to the dll
    //
    LocalFree(pInfo->pUIContextData);

    //
    // Allocate a new buffer to hold the user data
    //
    pInfo->pUIContextData = LocalAlloc(LPTR,
                                       dwSizeOfUIData);

    if (    (NULL == pInfo->pUIContextData)
        &&  (0 != dwSizeOfUIData))
    {
        dwErr = GetLastError();
        
        RASAPI32_TRACE2("DwCallEapUIEntryPoint: failed to"
               " allocate size %d. rc=%d",
               dwSizeOfUIData,
               dwErr);
               
        goto done;                            
    }

    //
    // fill in the new information
    //
    memcpy( pInfo->pUIContextData,
            pUIData,
            dwSizeOfUIData);
            
    pInfo->dwSizeOfUIContextData = dwSizeOfUIData;            

done:

    if (pUIData)
    {
        pfnEapFreeMemory(
                    pUIData
                    );
    }

    if (hlib)
    {
        FreeLibrary(hlib);
    }

    return dwErr;
}


BOOL
InvokeEapUI( HRASCONN            hConn, 
             DWORD               dwSubEntry, 
             LPRASDIALEXTENSIONS lpExtensions, 
             HWND                hWnd)
{
    s_InvokeEapUI *pInfo;
    PBYTE       pbEapUIData;
    DWORD       dwErr = 0;

    RASAPI32_TRACE("InvokeEapUI...");

    pInfo = LocalAlloc(LPTR, sizeof(s_InvokeEapUI));
    
    if (NULL == pInfo)
    {

        dwErr = GetLastError();
        
        RASAPI32_TRACE2("InvokeEapUI: Failed to allocate size %d. %d",
                sizeof(s_InvokeEapUI),
                dwErr);

        goto done;                
    }
    
    //
    // Get the size of eap information
    //
    RASAPI32_TRACE("InvokeEapUI: RasPppGetEapInfo...");
    
    dwErr = g_pRasPppGetEapInfo(
                    (HCONN) hConn, 
                    dwSubEntry, 
                    &pInfo->dwContextId,
                    &pInfo->dwEapTypeId,
                    &pInfo->dwSizeOfUIContextData,
                    NULL);
                              
    RASAPI32_TRACE1("InvokeEapUI: RasPppGetEapInfo done. %d", dwErr);

    if (    ERROR_BUFFER_TOO_SMALL != dwErr
        &&  ERROR_SUCCESS != dwErr)
    {
        RASAPI32_TRACE("InvokeEapUI: RasPppGetEapInfo failed.");
        
        goto done;
    }

    if(ERROR_BUFFER_TOO_SMALL == dwErr)
    {
        pInfo->pUIContextData = LocalAlloc(
                                    LPTR,
                                    pInfo->dwSizeOfUIContextData);

        if (    NULL == pInfo->pUIContextData
            &&  0 != pInfo->dwSizeOfUIContextData)
        {
            dwErr = GetLastError();
            
            RASAPI32_TRACE2("InvokeEapUI: Failed to allocate size %d. %d",
                    pInfo->dwSizeOfUIContextData,
                    dwErr);

            goto done;                
        }

        //
        // Get the eap information
        //
        RASAPI32_TRACE("InvokeEapUI: RasPppGetEapInfo...");

        dwErr = g_pRasPppGetEapInfo(
                            (HCONN) hConn,
                            dwSubEntry,
                            &pInfo->dwContextId,
                            &pInfo->dwEapTypeId,
                            &pInfo->dwSizeOfUIContextData,
                            pInfo->pUIContextData);

        RASAPI32_TRACE1("InvokeEapUI: RasPppGetEapInfo done. %d",
                dwErr);

        if ( 0 != dwErr)
        {
            RASAPI32_TRACE("InvokeEapUI: RasPppGetEapInfo failed.");
            goto done;
        }
    }

    dwErr = DwCallEapUIEntryPoint(pInfo, hWnd);

    if (dwErr)
    {
        RASAPI32_TRACE1("InvokeEapUI: DwCallEapUIEntryPoint returned %d",
               dwErr);

        goto done;                
    }

    lpExtensions->reserved1 = (ULONG_PTR) pInfo;

done:
    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\extapi\src\dll.c ===
/* Copyright (c) 1992, Microsoft Corporation, all rights reserved
**
** dll.c
** Remote Access External APIs
** DLL entry point
**
** 10/12/92 Steve Cobb
*/


#define DEBUGGLOBALS
#include <extapi.h>


// Delay load support
//
#include <delayimp.h>

EXTERN_C
FARPROC
WINAPI
DelayLoadFailureHook (
    UINT            unReason,
    PDelayLoadInfo  pDelayInfo
    );

PfnDliHook __pfnDliFailureHook = DelayLoadFailureHook;


//
// Global variables.
//
HINSTANCE hModule;
DTLLIST* PdtllistRasconncb;
DWORD DwfInstalledProtocols = (DWORD)-1;
CRITICAL_SECTION RasconncbListLock;
CRITICAL_SECTION csStopLock;
#ifdef PBCS
CRITICAL_SECTION PhonebookLock;
#endif
HANDLE HEventNotHangingUp;
DWORD DwRasInitializeError;

//
// dhcp.dll entry points
//
DHCPNOTIFYCONFIGCHANGE PDhcpNotifyConfigChange;

//
// rasiphlp.dll entry points
//
HELPERSETDEFAULTINTERFACENET PHelperSetDefaultInterfaceNet;

//
// mprapi.dll entry points
//
MPRADMINISSERVICERUNNING PMprAdminIsServiceRunning;

//
// rascauth.dll entry points
//
AUTHCALLBACK g_pAuthCallback;
AUTHCHANGEPASSWORD g_pAuthChangePassword;
AUTHCONTINUE g_pAuthContinue;
AUTHGETINFO g_pAuthGetInfo;
AUTHRETRY g_pAuthRetry;
AUTHSTART g_pAuthStart;
AUTHSTOP g_pAuthStop;

//
// rasscript.dll entry points
//
RASSCRIPTEXECUTE g_pRasScriptExecute;

//
// rasshare.lib declaratiosn
//
extern BOOL CsDllMain(DWORD fdwReason);

//
// rasscrpt.lib declaration
//
BOOL 
WINAPI
RasScriptDllMain(
    IN      HINSTANCE   hinstance,
    IN      DWORD       dwReason,
    IN      PVOID       pUnused);

//
// External variables.
//

BOOL
DllMain(
    HANDLE hinstDll,
    DWORD  fdwReason,
    LPVOID lpReserved )

    /* This routine is called by the system on various events such as the
    ** process attachment and detachment.  See Win32 DllEntryPoint
    ** documentation.
    **
    ** Returns true if successful, false otherwise.
    */
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        DisableThreadLibraryCalls(hinstDll);

        hModule = hinstDll;

        //
        // Load the rasman/raspi32 function pointers
        // used by the nouiutil library.
        //
        if (LoadRasapi32Dll())
            return FALSE;

        /* Create the list of connection control blocks.
        */
        if (!(PdtllistRasconncb = DtlCreateList( 0 )))
            return FALSE;

        /* Create the control block list mutex.
        */
        InitializeCriticalSection(&RasconncbListLock);

        /* Create the thread stopping mutex.
        */
        InitializeCriticalSection(&csStopLock);

#ifdef PBCS
        /* Initialize the phonebook critical section.
        */
        InitializeCriticalSection(&PhonebookLock);
#endif
        /* Initialize the Phonebook library.
        */
        if (InitializePbk() != 0)
            return FALSE;

        /* Create the "hung up port will be available" event.
        */
        if (!(HEventNotHangingUp = CreateEvent( NULL, TRUE, TRUE, NULL )))
            return FALSE;

        //
        // Create a dummy event that is not used so
        // we can pass a valid event handle to rasman
        // for connect, listen, and disconnect operations.
        //
        if (!(hDummyEvent = CreateEvent( NULL, FALSE, FALSE, NULL )))
            return FALSE;

        //
        // Create the async machine global mutex.
        //
        InitializeCriticalSection(&csAsyncLock);
        if (!(hAsyncEvent = CreateEvent(NULL, TRUE, TRUE, NULL))) {
            return FALSE;
        }
        InitializeListHead(&AsyncWorkItems);

        //
        // Initialize the connection sharing module
        //

        if (!CsDllMain(fdwReason))
            return FALSE;

        //
        // Initialize the ras script library
        //

        if (! RasScriptDllMain(hinstDll, fdwReason, lpReserved))
            return FALSE;
    }
    else if (fdwReason == DLL_PROCESS_DETACH)
    {
        //
        // Shutdown the ras script module
        //
        
        RasScriptDllMain(hinstDll, fdwReason, lpReserved);

        //
        // Shutdown the connection sharing module.
        //

        CsDllMain(fdwReason);

        if (PdtllistRasconncb)
            DtlDestroyList(PdtllistRasconncb, DtlDestroyNode);

        if (HEventNotHangingUp)
            CloseHandle( HEventNotHangingUp );

        /* Unload nouiutil entrypoints.
        */
        UnloadRasapi32Dll();
        UnloadRasmanDll();

        /* Uninitialize the Phonebook library.
        */
        TerminatePbk();

        //
        // Unload any other DLLs we've
        // dynamically loaded.
        //
        UnloadDlls();

        RasApiDebugTerm();
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\extapi\src\msgstub.c ===
#include <extapi.h>
#include <stdlib.h>
#include <winreg.h>
#include <pbk.h>

extern HANDLE hInstance;

char*
StringFromMsgid(
    MSGID msgid )
{
    char *buf;

    buf = Malloc(256);
    if (buf == NULL)
        return NULL;
    *buf = '\0';
    LoadString(hModule, msgid, buf, 256);
    //
    // If the LoadString failed, provide some defaults.
    //
    if (!lstrlen(buf)) {
        switch (msgid) {
        case MSGID_None:
            lstrcpy(buf, "None");
            break;
        case MSGID_AnyModem:
            lstrcpy(buf, "Any modem port");
            break;
        case MSGID_AnyX25:
            lstrcpy(buf, "Any X.25 port");
            break;
        case MSGID_Terminal:
            lstrcpy(buf, "Terminal");
            break;
        }
    }

    return buf;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\extapi\src\rasdial.c ===
/* Copyright (c) 1992, Microsoft Corporation, all rights reserved
**
** rasdial.c
** Remote Access External APIs
** RasDial API and subroutines
**
** 10/12/92 Steve Cobb
**
** CODEWORK:
**
**   * Strange error codes may be returned if the phonebook entry (or caller's
**     overrides) do not match the port configuration, e.g. if a modem entry
**     refers to a port configured for local PAD.  Should add checks to give
**     better error codes in this case.
*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <extapi.h>
#include <stdlib.h>

#include <lmwksta.h>
#include <lmapibuf.h>
#include <winsock.h>

#define SECS_ListenTimeout  120
#define SECS_ConnectTimeout 120

extern BOOL g_FRunningInAppCompatMode;

VOID            StartSubentries(RASCONNCB *prasconncb);

VOID            SuspendSubentries(RASCONNCB *prasconncb);

VOID            ResumeSubentries(RASCONNCB *prasconncb);

BOOLEAN         IsSubentriesSuspended(RASCONNCB *prasconncb);

VOID            RestartSubentries(RASCONNCB *prasconncb);

VOID            SyncDialParamsSubentries(RASCONNCB *prasconncb);

VOID            SetSubentriesBundled(RASCONNCB *prasconncb);

RASCONNSTATE    MapSubentryState(RASCONNCB *prasconncb);

VOID            RasDialTryNextAddress(IN RASCONNCB** pprasconncb);

DWORD           LoadMprApiDll();

BOOL            CaseInsensitiveMatch(IN LPCWSTR pszStr1, IN LPCWSTR pszStr2);

DWORD APIENTRY
RasDialA(
    IN  LPRASDIALEXTENSIONS lpextensions,
    IN  LPCSTR              lpszPhonebookPath,
    IN  LPRASDIALPARAMSA    lprdp,
    IN  DWORD               dwNotifierType,
    IN  LPVOID              notifier,
    OUT LPHRASCONN          lphrasconn )
{
    RASDIALPARAMSW  rdpw;
    ANSI_STRING     ansiString;
    UNICODE_STRING  unicodeString;
    NTSTATUS        ntstatus = STATUS_SUCCESS;
    DWORD           dwErr;

    if (    !lprdp
        ||  !lphrasconn)
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Verify caller's buffer version.
    //
    if (    !lprdp
        || (    lprdp->dwSize != sizeof(RASDIALPARAMSA)
            &&  lprdp->dwSize != sizeof(RASDIALPARAMSA_V351)
            &&  lprdp->dwSize != sizeof(RASDIALPARAMSA_V400)
            &&  lprdp->dwSize != sizeof(RASDIALPARAMSA_WINNT35J)))
    {
        return ERROR_INVALID_SIZE;
    }

    //
    // Make Unicode buffer version of caller's RASDIALPARAMS.
    //
    rdpw.dwSize = sizeof(RASDIALPARAMSW);

    if (lprdp->dwSize == sizeof(RASDIALPARAMSA))
    {
        strncpyAtoWAnsi(rdpw.szEntryName,
                    lprdp->szEntryName,
                    sizeof(rdpw.szEntryName) / sizeof(WCHAR));

        strncpyAtoWAnsi(rdpw.szPhoneNumber,
                    lprdp->szPhoneNumber,
                    sizeof(rdpw.szPhoneNumber) / sizeof(WCHAR));

        strncpyAtoWAnsi(rdpw.szCallbackNumber,
                    lprdp->szCallbackNumber,
                    sizeof(rdpw.szCallbackNumber) / sizeof(WCHAR));

        strncpyAtoWAnsi(rdpw.szUserName,
                    lprdp->szUserName,
                    sizeof(rdpw.szUserName) / sizeof(WCHAR));

        strncpyAtoWAnsi(rdpw.szPassword,
                    lprdp->szPassword,
                    sizeof(rdpw.szPassword) / sizeof(WCHAR));

        strncpyAtoWAnsi(rdpw.szDomain,
                    lprdp->szDomain,
                    sizeof(rdpw.szDomain) / sizeof(WCHAR));

        rdpw.dwSubEntry     = lprdp->dwSubEntry;
        rdpw.dwCallbackId   = lprdp->dwCallbackId;

    }

    else if (lprdp->dwSize == sizeof(RASDIALPARAMSA_V400))
    {
        RASDIALPARAMSA_V400* prdp = (RASDIALPARAMSA_V400* )lprdp;

        strncpyAtoWAnsi(rdpw.szEntryName,
                    prdp->szEntryName,
                    sizeof(rdpw.szEntryName) / sizeof(WCHAR));

        strncpyAtoWAnsi(rdpw.szPhoneNumber,
                    prdp->szPhoneNumber,
                    sizeof(rdpw.szPhoneNumber) / sizeof(WCHAR));

        strncpyAtoWAnsi(rdpw.szCallbackNumber,
                    prdp->szCallbackNumber,
                    sizeof(rdpw.szCallbackNumber) / sizeof(WCHAR));

        strncpyAtoWAnsi(rdpw.szUserName,
                    prdp->szUserName,
                    sizeof(rdpw.szUserName) / sizeof(WCHAR));

        strncpyAtoWAnsi(rdpw.szPassword,
                    prdp->szPassword,
                    sizeof(rdpw.szPassword) / sizeof(WCHAR));

        strncpyAtoWAnsi(rdpw.szDomain,
                    prdp->szDomain,
                    sizeof(rdpw.szDomain) / sizeof(WCHAR));

        rdpw.dwSubEntry     = 0;
        rdpw.dwCallbackId   = 0;

    }

    else if (lprdp->dwSize == sizeof (RASDIALPARAMSA_WINNT35J))
    {
        RASDIALPARAMSA_WINNT35J* prdp =
                (RASDIALPARAMSA_WINNT35J *)lprdp;

        strncpyAtoWAnsi(rdpw.szEntryName,
                     prdp->szEntryName,
                     RAS_MaxEntryName_V351 + 1);

        strncpyAtoWAnsi(rdpw.szPhoneNumber,
                    prdp->szPhoneNumber,
                    sizeof(rdpw.szPhoneNumber) / sizeof(WCHAR));

        strncpyAtoWAnsi(rdpw.szCallbackNumber,
                     prdp->szCallbackNumber,
                     RAS_MaxCallbackNumber_V351 + 1);

        strncpyAtoWAnsi(rdpw.szUserName,
                    prdp->szUserName,
                    sizeof(rdpw.szUserName) / sizeof(WCHAR));

        strncpyAtoWAnsi(rdpw.szPassword,
                    prdp->szPassword,
                    sizeof(rdpw.szPassword) / sizeof(WCHAR));

        strncpyAtoWAnsi(rdpw.szDomain,
                    prdp->szDomain,
                    sizeof(rdpw.szDomain) / sizeof(WCHAR));

        rdpw.dwSubEntry     = 0;
        rdpw.dwCallbackId   = 0;

    }

    else
    {
        RASDIALPARAMSA_V351* prdp = (RASDIALPARAMSA_V351* )lprdp;

        strncpyAtoWAnsi(rdpw.szEntryName,
                     prdp->szEntryName,
                     RAS_MaxEntryName_V351 + 1);

        strncpyAtoWAnsi(rdpw.szPhoneNumber,
                    prdp->szPhoneNumber,
                    sizeof(rdpw.szPhoneNumber) / sizeof(WCHAR));

        strncpyAtoWAnsi(rdpw.szCallbackNumber,
                     prdp->szCallbackNumber,
                     RAS_MaxCallbackNumber_V351 + 1);

        strncpyAtoWAnsi(rdpw.szUserName,
                    prdp->szUserName,
                    sizeof(rdpw.szUserName) / sizeof(WCHAR));

        strncpyAtoWAnsi(rdpw.szPassword,
                    prdp->szPassword,
                    sizeof(rdpw.szPassword) / sizeof(WCHAR));

        strncpyAtoWAnsi(rdpw.szDomain,
                    prdp->szDomain,
                    sizeof(rdpw.szDomain) / sizeof(WCHAR));

        rdpw.dwSubEntry     = 0;
        rdpw.dwCallbackId   = 0;
    }

    //
    // Make Unicode version of caller's string argument.
    //
    if (lpszPhonebookPath)
    {
        RtlInitAnsiString(&ansiString, lpszPhonebookPath);

        RtlInitUnicodeString(&unicodeString, NULL);

        ntstatus = RtlAnsiStringToUnicodeString(&unicodeString,
                                                &ansiString,
                                                TRUE );
    }

    if (!NT_SUCCESS(ntstatus))
    {
        return RtlNtStatusToDosError(ntstatus);
    }

    //
    // Call the Unicode version to do all the work.
    //
    dwErr = RasDialW(lpextensions,
                     (lpszPhonebookPath)
                     ? unicodeString.Buffer
                     : NULL,
                     (RASDIALPARAMSW* )&rdpw,
                     dwNotifierType,
                     notifier,
                     lphrasconn);


    if (lpszPhonebookPath)
    {
        RtlFreeUnicodeString( &unicodeString );
    }

    return dwErr;
}


DWORD APIENTRY
RasDialW(
    IN  LPRASDIALEXTENSIONS lpextensions,
    IN  LPCWSTR             lpszPhonebookPath,
    IN  LPRASDIALPARAMSW    lpparams,
    IN  DWORD               dwNotifierType,
    IN  LPVOID              notifier,
    OUT LPHRASCONN          lphrasconn )

/*++

Routine Description:

        Establish a connection with a RAS server.  The call is
        asynchronous, i.e. it returns before the connection is
        actually established.  The status may be monitored with
        RasConnectStatus and/or by specifying a callback/window
        to receive notification events/messages.

Arguments:

        lpextensions - is caller's extensions structure, used to
                       select advanced options and enable extended
                       features, or NULL indicating default values
                       should be used for all extensions.

        lpszPhonebookPath - is the full path to the phonebook file
                            or NULL indicating that the default
                            phonebook on the local machine should
                            be used.

        lpparams - is caller's buffer containing a description of the
                   connection to be established.

        dwNotifierType - defines the form of 'notifier'.

                0xFFFFFFFF:  'notifier' is a HWND to receive
                              notification messages
                0            'notifier' is a RASDIALFUNC callback
                1            'notifier' is a RASDIALFUNC1 callback
                2            'notifier' is a RASDIALFUNC2 callback

        notifier - may be NULL for no notification (synchronous
                   operation), in which case 'dwNotifierType' is
                   ignored.

        *lphrasconn -  is set to the RAS connection handle associated
                       with the new connection on successful return.

Return Value:

        Returns 0 if successful, otherwise a non-0 error code.

--*/
{
    DWORD           dwErr;
    DWORD           dwfOptions          = 0;
    ULONG_PTR       reserved            = 0;
    HWND            hwndParent          = NULL;
    RASDIALPARAMSW  params;
    BOOL            fEnableMultilink    = FALSE;
    ULONG_PTR        reserved1           = 0;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    RASAPI32_TRACE("RasDialW...");

    if (    !lpparams
        ||  !lphrasconn)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (    (   lpparams->dwSize != sizeof( RASDIALPARAMSW )
            &&  lpparams->dwSize != sizeof( RASDIALPARAMSW_V351 )
            &&  lpparams->dwSize != sizeof( RASDIALPARAMSW_V400 ))
        ||  (   lpextensions
            &&  lpextensions->dwSize != sizeof(RASDIALEXTENSIONS)
            &&  lpextensions->dwSize != sizeof(RASDIALEXTENSIONS_401)))
    {
        return ERROR_INVALID_SIZE;
    }

    if (    NULL != notifier
        &&  0 != dwNotifierType
        &&  1 != dwNotifierType
        &&  2 != dwNotifierType
        &&  0xFFFFFFFF != dwNotifierType)
    {
        return ERROR_INVALID_PARAMETER;
    }

    dwErr = LoadRasmanDllAndInit();

    if (dwErr)
    {
        return dwErr;
    }

    if (DwRasInitializeError != 0)
    {
        return DwRasInitializeError;
    }

    if (lpextensions)
    {
        hwndParent  = lpextensions->hwndParent;
        dwfOptions  = lpextensions->dwfOptions;
        reserved    = lpextensions->reserved;

        if (lpextensions->dwSize == sizeof (RASDIALEXTENSIONS))
        {
            reserved1 = lpextensions->reserved1;
        }
        else
        {
            //
            // This should tell us that that this
            // is most likely an nt4 client.
            //
            reserved1 = 0xFFFFFFFF;
        }
    }

    //
    // Make a copy of caller's parameters so we can fill in
    // any "*" callback number or domain from the phonebook
    // without changing caller's "input" buffer.  Eliminate
    // the V401 vs V400 vs V351 issue while we're at it.
    //
    if (lpparams->dwSize == sizeof(RASDIALPARAMSW_V351))
    {
        //
        // Convert the V351 structure to a V401 version.
        //
        RASDIALPARAMSW_V351* prdp = (RASDIALPARAMSW_V351* )lpparams;

        params.dwSize = sizeof(RASDIALPARAMSW);

        lstrcpyn(params.szEntryName,
                 prdp->szEntryName,
                 sizeof(params.szEntryName) / sizeof(WCHAR));

        lstrcpyn(params.szPhoneNumber,
                 prdp->szPhoneNumber,
                 sizeof(params.szPhoneNumber) / sizeof(WCHAR));

        lstrcpyn(params.szCallbackNumber,
                 prdp->szCallbackNumber,
                 sizeof(params.szCallbackNumber) / sizeof(WCHAR));

        lstrcpyn(params.szUserName,
                 prdp->szUserName,
                 sizeof(params.szUserName) / sizeof(WCHAR));

        lstrcpyn(params.szPassword,
                 prdp->szPassword,
                 sizeof(params.szPassword) / sizeof(WCHAR));

        lstrcpyn(params.szDomain,
                 prdp->szDomain,
                 sizeof(params.szDomain) / sizeof(WCHAR));

        params.dwSubEntry = 0;
    }
    else if (lpparams->dwSize == sizeof(RASDIALPARAMSW_V400))
    {
        //
        // Convert the V400 structure to a V401 version.
        //
        RASDIALPARAMSW_V400* prdp = (RASDIALPARAMSW_V400* )lpparams;

        params.dwSize = sizeof(RASDIALPARAMSW);

        lstrcpyn(params.szEntryName,
                 prdp->szEntryName,
                 sizeof(params.szEntryName) / sizeof(WCHAR));

        lstrcpyn(params.szPhoneNumber,
                 prdp->szPhoneNumber,
                 sizeof(params.szPhoneNumber) / sizeof(WCHAR));

        lstrcpyn(params.szCallbackNumber,
                 prdp->szCallbackNumber,
                 sizeof(params.szCallbackNumber) / sizeof(WCHAR));

        lstrcpyn(params.szUserName,
                 prdp->szUserName,
                 sizeof(params.szUserName) / sizeof(WCHAR));

        lstrcpyn(params.szPassword,
                 prdp->szPassword,
                 sizeof(params.szPassword) / sizeof(WCHAR));

        lstrcpyn(params.szDomain,
                 prdp->szDomain,
                 sizeof(params.szDomain) / sizeof(WCHAR));

        params.dwSubEntry = 0;
    }
    else
    {
        memcpy( &params,
                lpparams,
                sizeof(params) );

        fEnableMultilink = TRUE;
    }

    //
    // no need to pass dwfOptions, reserved
    // reserved1 parameters since lpextensions is
    // being passed into this call anyway - bug filed
    // already on this.
    //
    dwErr = _RasDial(lpszPhonebookPath,
                     dwfOptions,
                     fEnableMultilink,
                     reserved,
                     &params,
                     hwndParent,
                     dwNotifierType,
                     notifier,
                     reserved1,
                     lpextensions,
                     lphrasconn);

    WipePasswordW( params.szPassword );

    RASAPI32_TRACE1("RasDialA done(%d)", dwErr);

    return dwErr;
}


RASCONNCB *
CreateConnectionBlock(
    IN RASCONNCB *pPrimary
    )
{
    DTLNODE* pdtlnode = DtlCreateSizedNode(sizeof(RASCONNCB), 0);
    RASCONNCB *prasconncb;

    if (!pdtlnode)
    {
        return NULL;
    }

    EnterCriticalSection(&RasconncbListLock);

    DtlAddNodeFirst(PdtllistRasconncb, pdtlnode);

    LeaveCriticalSection(&RasconncbListLock);

    prasconncb                  = (RASCONNCB *)
                                  DtlGetData( pdtlnode );

    prasconncb->asyncmachine.freefuncarg = pdtlnode;
    prasconncb->psyncResult     = NULL;
    prasconncb->fTerminated     = FALSE;
    prasconncb->dwDeviceLineCounter = 0;

    prasconncb->fDialSingleLink = FALSE;

    prasconncb->fRasdialRestart = FALSE;

    prasconncb->fTryNextLink = TRUE;

    if (pPrimary != NULL)
    {
        //
        // Copy most of the values from the primary.
        //
        prasconncb->hrasconn                = pPrimary->hrasconn;
        prasconncb->rasconnstate            = 0;
        prasconncb->rasconnstateNext        = 0;
        prasconncb->dwError                 = 0;
        prasconncb->dwExtendedError         = 0;
        prasconncb->dwSavedError            = 0;
        prasconncb->pEntry                  = pPrimary->pEntry;
        prasconncb->hport                   = INVALID_HPORT;
        prasconncb->hportBundled            = INVALID_HPORT;

        lstrcpyn(prasconncb->szUserKey,
                 pPrimary->szUserKey,
                 sizeof(prasconncb->szUserKey) / sizeof(WCHAR));

        prasconncb->reserved                = pPrimary->reserved;
        prasconncb->dwNotifierType          = pPrimary->dwNotifierType;
        prasconncb->notifier                = pPrimary->notifier;
        prasconncb->hwndParent              = pPrimary->hwndParent;
        prasconncb->unMsg                   = pPrimary->unMsg;
        prasconncb->pEntry                  = pPrimary->pEntry;

        memcpy( &prasconncb->pbfile,
                &pPrimary->pbfile,
                sizeof (prasconncb->pbfile));

        memcpy( &prasconncb->rasdialparams,
                &pPrimary->rasdialparams,
                sizeof (RASDIALPARAMS));

        prasconncb->fAllowPause             = pPrimary->fAllowPause;
        prasconncb->fPauseOnScript          = pPrimary->fPauseOnScript;
        prasconncb->fDefaultEntry           = pPrimary->fDefaultEntry;
        prasconncb->fDisableModemSpeaker    = pPrimary->fDisableModemSpeaker;
        prasconncb->fDisableSwCompression   = pPrimary->fDisableSwCompression;
        prasconncb->dwUserPrefMode          = pPrimary->dwUserPrefMode;
        prasconncb->fUsePrefixSuffix        = pPrimary->fUsePrefixSuffix;
        prasconncb->fNoClearTextPw          = pPrimary->fNoClearTextPw;
        prasconncb->fRequireEncryption      = pPrimary->fRequireEncryption;
        prasconncb->fLcpExtensions          = pPrimary->fLcpExtensions;
        prasconncb->dwfPppProtocols         = pPrimary->dwfPppProtocols;

        memcpy( prasconncb->szzPppParameters,
                pPrimary->szzPppParameters,
                sizeof (prasconncb->szzPppParameters));

        lstrcpyn(prasconncb->szOldPassword,
                 pPrimary->szOldPassword,
                 sizeof(prasconncb->szOldPassword) / sizeof(WCHAR));

        prasconncb->fRetryAuthentication        = pPrimary->fRetryAuthentication;
        prasconncb->fMaster                     = FALSE;
        prasconncb->dwfSuspended                = pPrimary->dwfSuspended;
        prasconncb->fStopped                    = FALSE;
        prasconncb->fCleanedUp                  = FALSE;
        prasconncb->fDeleted                    = FALSE;
        prasconncb->fOldPasswordSet             = pPrimary->fOldPasswordSet;
        prasconncb->fUpdateCachedCredentials    = pPrimary->fUpdateCachedCredentials;
#if AMB
        prasconncb->dwAuthentication            = pPrimary->dwAuthentication;
#endif
        prasconncb->fPppMode                    = pPrimary->fPppMode;
        prasconncb->fUseCallbackDelay           = pPrimary->fUseCallbackDelay;
        prasconncb->wCallbackDelay              = pPrimary->wCallbackDelay;
        prasconncb->fIsdn                       = pPrimary->fIsdn;
        prasconncb->fModem                      = pPrimary->fModem;
        prasconncb->asyncmachine.oneventfunc    = pPrimary->asyncmachine.oneventfunc;
        prasconncb->asyncmachine.cleanupfunc    = pPrimary->asyncmachine.cleanupfunc;
        prasconncb->asyncmachine.freefunc       = pPrimary->asyncmachine.freefunc;
        prasconncb->asyncmachine.pParam         = (VOID* )prasconncb;
        prasconncb->dwIdleDisconnectSeconds     = pPrimary->dwIdleDisconnectSeconds;
        prasconncb->fPppEapMode                 = pPrimary->fPppEapMode;

        {
            DWORD dwVpnProts;

            for(dwVpnProts = 0;
                dwVpnProts < NUMVPNPROTS;
                dwVpnProts ++)
            {
                prasconncb->ardtVpnProts[dwVpnProts] =
                    pPrimary->ardtVpnProts[dwVpnProts];
            }
        }

        prasconncb->dwCurrentVpnProt = pPrimary->dwCurrentVpnProt;

        //
        // Copy eapinfo if present
        //
        if(0 != pPrimary->RasEapInfo.dwSizeofEapInfo)
        {
            prasconncb->RasEapInfo.pbEapInfo =
                LocalAlloc(LPTR,
                           pPrimary->RasEapInfo.dwSizeofEapInfo);

            if(NULL == prasconncb->RasEapInfo.pbEapInfo)
            {
                DeleteRasconncbNode(prasconncb);
                return NULL;
            }

            prasconncb->RasEapInfo.dwSizeofEapInfo =
                pPrimary->RasEapInfo.dwSizeofEapInfo;

            memcpy(prasconncb->RasEapInfo.pbEapInfo,
                   pPrimary->RasEapInfo.pbEapInfo,
                   prasconncb->RasEapInfo.dwSizeofEapInfo);
        } else {
            prasconncb->RasEapInfo.pbEapInfo = NULL;
            prasconncb->RasEapInfo.dwSizeofEapInfo = 0;
        }

        //
        // Initialize the state machine for
        // this connection block.
        //
        if (StartAsyncMachine(&prasconncb->asyncmachine,
                            prasconncb->hrasconn))
        {
            DeleteRasconncbNode( prasconncb );
            return NULL;
        }

        //
        // Link together all connection blocks
        // for the same entry.
        //
        prasconncb->fMultilink  = pPrimary->fMultilink;
        prasconncb->fBundled    = FALSE;

        InsertTailList( &pPrimary->ListEntry,
                        &prasconncb->ListEntry);
    }
    else
    {
        prasconncb->pbfile.hrasfile = -1;
        
        InitializeListHead(&prasconncb->ListEntry);

        InitializeListHead(&prasconncb->asyncmachine.ListEntry);

        prasconncb->asyncmachine.hport = INVALID_HPORT;
    }

    return prasconncb;
}


VOID
AssignVpnProtsOrder(RASCONNCB *prasconncb)
{
    DWORD dwVpnStrategy = prasconncb->pEntry->dwVpnStrategy;
    DWORD dwVpnProt;

    RASDEVICETYPE ardtDefaultOrder[NUMVPNPROTS] =
                        {
                            RDT_Tunnel_L2tp,
                            RDT_Tunnel_Pptp,
                        };

    RASDEVICETYPE *prdtVpnProts = prasconncb->ardtVpnProts;

    //
    // Initialize the vpn prot order to default.
    //
    for(dwVpnProt = 0;
        dwVpnProt < NUMVPNPROTS;
        dwVpnProt++)
    {
        prdtVpnProts[dwVpnProt]
            = ardtDefaultOrder[dwVpnProt];
    }

    switch (dwVpnStrategy & 0x0000FFFF)
    {
        case VS_Default:
        {
            break;
        }

        case VS_PptpOnly:
        {
            prdtVpnProts[0] = RDT_Tunnel_Pptp;

            for(dwVpnProt = 1;
                dwVpnProt < NUMVPNPROTS;
                dwVpnProt ++)
            {
                prdtVpnProts[dwVpnProt] = -1;
            }

            break;
        }

        case VS_L2tpOnly:
        {
            prdtVpnProts[0] = RDT_Tunnel_L2tp;

            for(dwVpnProt = 1;
                dwVpnProt < NUMVPNPROTS;
                dwVpnProt ++)
            {
                prdtVpnProts[dwVpnProt] = -1;
            }

            break;
        }

        case VS_PptpFirst:
        {
            DWORD dwSaveProt = prdtVpnProts[0];

            for(dwVpnProt = 0;
                dwVpnProt < NUMVPNPROTS;
                dwVpnProt ++)
            {
                if(RDT_Tunnel_Pptp == prdtVpnProts[dwVpnProt])
                {
                    break;
                }
            }

            ASSERT(dwVpnProt != NUMVPNPROTS);

            prdtVpnProts[0] = RDT_Tunnel_Pptp;
            prdtVpnProts[dwVpnProt] = dwSaveProt;

            break;
        }

        case VS_L2tpFirst:
        {
            DWORD dwSaveProt = prdtVpnProts[0];

            for(dwVpnProt = 0;
                dwVpnProt < NUMVPNPROTS;
                dwVpnProt ++)
            {
                if(RDT_Tunnel_L2tp == prdtVpnProts[dwVpnProt])
                {
                    break;
                }
            }

            ASSERT(dwVpnProt != NUMVPNPROTS);

            prdtVpnProts[0] = RDT_Tunnel_L2tp;
            prdtVpnProts[dwVpnProt] = dwSaveProt;

            break;

        }

        default:
        {
#if DBG
            ASSERT(FALSE);
#endif
            break;
        }
    }
}

VOID SetUpdateCachedCredentialsFlag(RASCONNCB *prasconncb,
                              RASDIALPARAMS *prasdialparams)
{
    DWORD dwErr = ERROR_SUCCESS;
    
    //
    // If the user is logged into the same domain
    // as he is dialing into, note this fact so 
    // that we can update cached credentials.
    //
    WKSTA_USER_INFO_1* pwkui1 = NULL;

    dwErr = NetWkstaUserGetInfo(NULL,
                                1, (LPBYTE *) &pwkui1);

    if(     (ERROR_SUCCESS == dwErr)
        &&  (prasconncb->dwUserPrefMode != UPM_Logon))
    {
        if(     (   (TEXT('\0') != prasdialparams->szDomain[0])
                &&  (0 == lstrcmpi(prasdialparams->szDomain,
                        pwkui1->wkui1_logon_domain)))
            ||  (   (TEXT('\0')== prasdialparams->szDomain[0])
                &&  prasconncb->pEntry->fAutoLogon))
        {                                            
            if(         ((TEXT('\0') != 
                            prasdialparams->szUserName[0])
                    &&  (0 == 
                            lstrcmpi(prasdialparams->szUserName,
                                    pwkui1->wkui1_username))
                ||      ((TEXT('\0') == 
                                prasdialparams->szUserName[0])
                    &&  prasconncb->pEntry->fAutoLogon)))
            {
                prasconncb->fUpdateCachedCredentials = TRUE;
            }
        }
        
        NetApiBufferFree(pwkui1);
    }
}
                                

DWORD
_RasDial(
    IN    LPCTSTR             lpszPhonebookPath,
    IN    DWORD               dwfOptions,
    IN    BOOL                fEnableMultilink,
    IN    ULONG_PTR           reserved,
    IN    RASDIALPARAMS*      prasdialparams,
    IN    HWND                hwndParent,
    IN    DWORD               dwNotifierType,
    IN    LPVOID              notifier,
    IN    ULONG_PTR           reserved1,
    IN    RASDIALEXTENSIONS   *lpExtensions,
    IN OUT LPHRASCONN         lphrasconn )

/*++

 Routine Description:

        Core RasDial routine called with dial params
        converted to V40 and structure sizes are
        already verified.

        Otherwise, like RasDial.

Arguments:

Return Value:

--*/
{
    DWORD        dwErr;
    BOOL         fAllowPause = (dwfOptions & RDEOPT_PausedStates)
                             ? TRUE : FALSE;
    RASCONNCB*   prasconncb;
    RASCONNSTATE rasconnstate;
    HRASCONN     hrasconn = *lphrasconn;
    BOOL         fNewEntry;
    HANDLE       hDone;
    PDWORD       pdwSubEntryInfo = NULL;
    DWORD        dwSubEntries;
    DWORD        dwEntryAlreadyConnected = 0;
    
    RASAPI32_TRACE1("_RasDial(%S)", (*lphrasconn) 
                            ? TEXT("resume") 
                            : TEXT("start"));

    if (DwRasInitializeError != 0)
    {
        return DwRasInitializeError;
    }

    fNewEntry = FALSE;

    if (    hrasconn
        && (prasconncb = ValidatePausedHrasconn(hrasconn)))
    {
        //
        // Restarting an existing connection after a pause state...
        // Set the appropriate resume state for the paused state.
        //
        switch (prasconncb->rasconnstate)
        {
            case RASCS_Interactive:
                rasconnstate = RASCS_DeviceConnected;
                break;

            case RASCS_RetryAuthentication:
            {
                SetUpdateCachedCredentialsFlag(prasconncb, prasdialparams);
                //
                // Whistler bug: 345824 Include Windows logon domain not
                // enabled on a VPN connection
                //
                if ( ( prasdialparams ) && ( prasconncb->pEntry ) &&
                     ( 0 < lstrlen ( prasdialparams->szDomain ) ) &&
                     ( !prasconncb->pEntry->fPreviewDomain ) )
                {
                    prasconncb->pEntry->fPreviewDomain = TRUE;
                    prasconncb->pEntry->fDirty = TRUE;
                }

                /*
                //
                // If user is resuming from a retry where where
                // he tried a new password on an "authenticate
                // with current username/pw" entry, note this
                // so the cached logon credentials can be
                // updated as soon as server tells us the
                // re-authentication succeeded.
                //
                if (    prasconncb->rasdialparams.szUserName[0]
                        == TEXT('\0')
                    &&  0 == lstrcmp(
                                 prasconncb->rasdialparams.szDomain,
                                 prasdialparams->szDomain))
                {
                    //
                    // Must look up the logged on user's name since
                    // "" username cannot be used by caller where
                    // auto-logon password is overridden
                    // (what a pain).
                    //
                    DWORD dwErr;
                    WKSTA_USER_INFO_1* pwkui1 = NULL;

                    dwErr = NetWkstaUserGetInfo(NULL,
                                                1,
                                                (LPBYTE* )&pwkui1);

                    if (dwErr == 0)
                    {
                        TCHAR szLoggedOnUser[ UNLEN + 1 ];

                        strncpyWtoT(    szLoggedOnUser,
                                        pwkui1->wkui1_username,
                                        UNLEN + 1 );

                        if (lstrcmp(
                                szLoggedOnUser,
                                prasdialparams->szUserName ) == 0)
                        {
                            prasconncb->fUpdateCachedCredentials = TRUE;
                        }
                        
                        NetApiBufferFree( pwkui1 );
                }
                    else
                    {
                        RASAPI32_TRACE1("NetWkstaUserGetInfo done(%d)", dwErr);
                    }

                }

                */

                rasconnstate = RASCS_AuthRetry;
                break;
            }

            case RASCS_InvokeEapUI:
            {

#if DBG
                ASSERT(     0xFFFFFFFF != reserved1
                        &&  0 != reserved1 );
#endif

                //
                // Save the context that will be passed to ppp
                // in RASCS_AuthRetry state
                //
                prasconncb->reserved1 = reserved1;

                rasconnstate = RASCS_AuthRetry;
                break;

            }

            case RASCS_CallbackSetByCaller:
                rasconnstate = RASCS_AuthCallback;
                break;

            case RASCS_PasswordExpired:
            {
                //
                // If the user is logged into the same domain
                // as he is dialing into, note this fact so 
                // that we can update cached credentials.
                //
                WKSTA_USER_INFO_1* pwkui1 = NULL;

                //
                // If the user didn't set the old password with the
                // RasSetOldPassword call, then give old behavior,
                // i.e. implicitly use the password previously
                // entered.
                //
                if (!prasconncb->fOldPasswordSet)
                {
                    lstrcpyn(prasconncb->szOldPassword,
                             prasconncb->rasdialparams.szPassword,
                             sizeof(prasconncb->szOldPassword) / sizeof(WCHAR));
                }

                SetUpdateCachedCredentialsFlag(prasconncb, prasdialparams);

                /*
                //
                // If user is resuming after changing the password
                // of the currently logged on user, note this so
                // the cached logon credentials can be updated
                // as soon as server tells us the password
                // change succeeded.
                //
                if (prasconncb->rasdialparams.szUserName[0]
                                    == '\0')
                {
                    prasconncb->fUpdateCachedCredentials = TRUE;
                }
                */

                rasconnstate = RASCS_AuthChangePassword;
                break;
            }

            default:

                //
                // The entry is not in the paused state.  Assume
                // it's an NT 3.1 caller would didn't figure out
                // to set the HRASCONN to NULL before starting
                // up.  (The NT 3.1 docs did not make it
                // absolutely clear that the inital handle
                // should be NULL)
                //
                fNewEntry = TRUE;
        }

        RASAPI32_TRACE1( "fUpdateCachedCredentials=%d",
                prasconncb->fUpdateCachedCredentials);
    }
    else if (   (NULL != hrasconn)
            &&  !g_FRunningInAppCompatMode)
    {
        return ERROR_NO_CONNECTION;
    }
    else
    {
        fNewEntry = TRUE;
    }


    if (fNewEntry)
    {
        DTLNODE         *pdtlnode;
        DWORD           dwMask;
        RAS_DIALPARAMS  dialparams;
        LONG            dwIdleDisconnectSeconds;

        //
        // If this is being called from the custom dialer
        // and there is no entry name return an error.
        //
        if(     (dwfOptions & RDEOPT_CustomDial)
            &&  TEXT('\0') == prasdialparams->szEntryName[0])
        {
            return ERROR_CANNOT_DO_CUSTOMDIAL;
        }

        //
        // Starting a new connection...
        // Create an empty control block and link it into the
        // global list of control blocks.  The HRASCONN is
        // really the address of a control block.
        //
        prasconncb = CreateConnectionBlock(NULL);

        if (prasconncb == NULL)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        //
        // Open the phonebook and find the entry,
        // if specified.
        //
        if (prasdialparams->szEntryName[0] != TEXT('\0'))
        {
            //
            // We can't specify the entry name here because
            // we might have to write the phonebook file at
            // the end, and the phonebook library doesn't
            // support this.
            //
            dwErr = GetPbkAndEntryName(
                            lpszPhonebookPath,
                            prasdialparams->szEntryName,
                            RPBF_NoCreate 
                            |((dwfOptions & RDEOPT_Router) 
                            ? RPBF_Router : 0 ),
                            &prasconncb->pbfile,
                            &pdtlnode);

            if(SUCCESS != dwErr)
            {
                DeleteRasconncbNode(prasconncb);
                return dwErr;
            }
        }
        else
        {

            pdtlnode = CreateEntryNode(TRUE);

            if (pdtlnode == NULL)
            {
                RASAPI32_TRACE("CreateEntryNode returned NULL");

                DeleteRasconncbNode(prasconncb);

                return ERROR_NOT_ENOUGH_MEMORY;
            }

        }

        prasconncb->pEntry = (PBENTRY *)DtlGetData(pdtlnode);
        ASSERT(prasconncb->pEntry);

        //
        // if a custom dialer is specified and this is not
        // being called from the custom dialer, it means
        // that it is being called from rasapi - RasDial
        // directly. Do the custom dial with no ui in that
        // case
        //
        if(     (NULL != prasconncb->pEntry->pszCustomDialerName)
            &&  (TEXT('\0') != prasconncb->pEntry->pszCustomDialerName[0])
            &&  (0 == (RDEOPT_CustomDial & dwfOptions)))
        {

            CHAR *pszSysPbk = NULL;

            //
            // Dup the phonebook file path if its not specified
            //
            if(NULL == lpszPhonebookPath)
            {
                pszSysPbk = strdupTtoA(prasconncb->pbfile.pszPath);
                if(NULL == pszSysPbk)
                {
                    DeleteRasconncbNode(prasconncb);
                    return ERROR_NOT_ENOUGH_MEMORY;
                }
            }

            //
            // Delete the rasconncb we created for this connection
            //
            DeleteRasconncbNode(prasconncb);

            dwErr = DwCustomDial(lpExtensions,
                                 lpszPhonebookPath,
                                 pszSysPbk,
                                 prasdialparams,
                                 dwNotifierType,
                                 notifier,
                                 lphrasconn);

            if(pszSysPbk)
            {
                Free(pszSysPbk);
            }

            return dwErr;
        }

        prasconncb->fBundled = FALSE;        
        
        //
        // Look up the subentry.
        //
        if ( prasconncb->pEntry->dwDialMode == RASEDM_DialAsNeeded )
        {
            prasconncb->fDialSingleLink = TRUE;

            dwSubEntries = 
                DtlGetNodes(prasconncb->pEntry->pdtllistLinks);

            if (    0 == prasdialparams->dwSubEntry
                ||  prasdialparams->dwSubEntry > dwSubEntries )
            {
                prasdialparams->dwSubEntry = 1;
            }
        }
        else if (    (prasconncb->pEntry->dwDialMode == RASEDM_DialAll)
                 &&  (0 == prasdialparams->dwSubEntry))
        {
            prasdialparams->dwSubEntry = 1;
        }
        else
        {
            dwSubEntries =
                DtlGetNodes(prasconncb->pEntry->pdtllistLinks);

            if (    0 == prasdialparams->dwSubEntry
                ||  prasdialparams->dwSubEntry > dwSubEntries )
            {
                prasdialparams->dwSubEntry = 1;
            }
            else
            {
                HRASCONN hConnEntry = NULL;
                CHAR *pszPbook = NULL;
                CHAR *pszentry = NULL;

                if(NULL != lpszPhonebookPath)
                {
                    pszPbook = strdupTtoA(lpszPhonebookPath);

                }
                else
                {
                    pszPbook = strdupTtoA(prasconncb->pbfile.pszPath);
                }

                if(NULL == pszPbook)
                {
                    DeleteRasconncbNode(prasconncb);
                    return ERROR_NOT_ENOUGH_MEMORY;
                }
                
                pszentry = strdupTtoA(prasdialparams->szEntryName);

                if(NULL == pszentry)
                {
                    Free0(pszPbook);
                    DeleteRasconncbNode(prasconncb);
                    return ERROR_NOT_ENOUGH_MEMORY;
                }

                //
                // A valid subentry was specified. In this case
                // override the RASEDM_DialAll and dial only the
                // subentry specified.
                //
                prasconncb->fDialSingleLink = TRUE;
                // prasconncb->fMultilink = TRUE;

                //
                // Also check to see if this entry is already connected
                // i.e some other subentry in this entry is already up
                // and mark this entry as bundled if it is.
                //
                if(ERROR_SUCCESS == g_pRasGetHConnFromEntry(
                                &hConnEntry,
                                pszPbook,
                                pszentry))
                {
                    RASAPI32_TRACE2("Marking subentry %d as bundled because"
                    " the connection %ws is areadly up",
                    prasdialparams->dwSubEntry,
                    prasdialparams->szEntryName);
                    
                    prasconncb->fBundled = TRUE;
                }

                Free0(pszPbook);
                Free(pszentry);
                                
            }
        }

        RASAPI32_TRACE1("looking up subentry %d",
                prasdialparams->dwSubEntry);

        pdtlnode = DtlNodeFromIndex(
                    prasconncb->pEntry->pdtllistLinks,
                    prasdialparams->dwSubEntry - 1);

        //
        // If the subentry doesn't exist, then
        // return an error.
        //
        if (pdtlnode == NULL)
        {
            DeleteRasconncbNode(prasconncb);
            return ERROR_CANNOT_FIND_PHONEBOOK_ENTRY;
        }

        prasconncb->pLink = (PBLINK *)DtlGetData(pdtlnode);
        ASSERT(prasconncb->pLink);

        //
        // Finish setting up the default phonebook entry.
        //
        if (prasdialparams->szEntryName[0] == TEXT('\0'))
        {
            DTLLIST *pdtllistPorts;
            PBPORT *pPort;

            dwErr = LoadPortsList(&pdtllistPorts);

            if (dwErr)
            {
                DeleteRasconncbNode(prasconncb);

                return dwErr;
            }

            //
            // Set the default entry to reference
            // the first device.
            //
            pdtlnode = DtlNodeFromIndex(pdtllistPorts, 0);

            if (pdtlnode == NULL)
            {
                DtlDestroyList(pdtllistPorts, DestroyPortNode);

                DeleteRasconncbNode(prasconncb);

                return ERROR_PORT_NOT_AVAILABLE;
            }

            pPort = (PBPORT *)DtlGetData(pdtlnode);
            ASSERT(pPort);

            dwErr = CopyToPbport(&prasconncb->pLink->pbport,
                                    pPort);

            if (dwErr)
            {
                DtlDestroyList(pdtllistPorts, DestroyPortNode);

                DeleteRasconncbNode(prasconncb);

                return dwErr;
            }

            DtlDestroyList(pdtllistPorts, DestroyPortNode);
        }

        //
        // Read the stashed information about this
        // entry to get the default domain.
        //
        dwMask = DLPARAMS_MASK_DOMAIN | DLPARAMS_MASK_OLDSTYLE;

        dwErr = g_pRasGetDialParams(
                    prasconncb->pEntry->dwDialParamsUID,
                    &dwMask,
                    &dialparams);

        if (    !dwErr
            &&  (dwMask & DLPARAMS_MASK_DOMAIN))
        {
            strncpyWtoT(
                prasconncb->szDomain,
                dialparams.DP_Domain,
                sizeof(prasconncb->szDomain) / sizeof(TCHAR));
        }

        //
        // Now get user preferences.
        //
        if (dwfOptions & RDEOPT_IgnoreModemSpeaker)
        {
            prasconncb->fDisableModemSpeaker =
              (dwfOptions & RDEOPT_SetModemSpeaker)
              ? FALSE : TRUE;
        }
        else
        {
            prasconncb->fDisableModemSpeaker =
                        (prasconncb->pLink != NULL) ?
                         !prasconncb->pLink->fSpeaker :
                         FALSE;
        }

        if (dwfOptions & RDEOPT_IgnoreSoftwareCompression)
        {
            prasconncb->fDisableSwCompression =
              !(dwfOptions & RDEOPT_SetSoftwareCompression);
        }
        else
        {
            prasconncb->fDisableSwCompression =
                            (prasconncb->pEntry != NULL)
                            ? !prasconncb->pEntry->fSwCompression
                            :  FALSE;
        }

        if (dwfOptions & RDEOPT_Router)
        {
            prasconncb->dwUserPrefMode = UPM_Router;
        }
        else if (dwfOptions & RDEOPT_NoUser)
        {
            prasconncb->dwUserPrefMode = UPM_Logon;
        }
        else
        {
            prasconncb->dwUserPrefMode = UPM_Normal;
        }

        if(dwfOptions & RDEOPT_UseCustomScripting)
        {
            prasconncb->fUseCustomScripting = TRUE;
        }

        //
        // Only enable prefix/suffix when there is no
        // override phone number.
        //
        prasconncb->fUsePrefixSuffix =
                        ((dwfOptions & RDEOPT_UsePrefixSuffix)
                    &&  (*prasdialparams->szPhoneNumber == '\0'))
                        ? TRUE
                        : FALSE;

        //
        // Set the handle NULL in case the user passed in an
        // invalid non-NULL handle, on the initial dial.
        //
        hrasconn = 0;

        prasconncb->fAlreadyConnected = FALSE;

        {
            CHAR szPhonebookPath [MAX_PATH];
            CHAR szEntryName [MAX_ENTRYNAME_SIZE];
            CHAR szRefEntryName[MAX_ENTRYNAME_SIZE];
            CHAR szRefPhonebookPath[MAX_PATH];

            dwSubEntries =
                    DtlGetNodes(prasconncb->pEntry->pdtllistLinks);

            pdwSubEntryInfo = LocalAlloc (
                                LPTR,
                                dwSubEntries * sizeof(DWORD));

            if (NULL == pdwSubEntryInfo)
            {
                DeleteRasconncbNode (prasconncb);
                return ERROR_NOT_ENOUGH_MEMORY;
            }

            strncpyTtoA(szPhonebookPath,
                       prasconncb->pbfile.pszPath,
                       sizeof(szPhonebookPath));

            strncpyTtoA(szEntryName,
                       prasconncb->pEntry->pszEntryName,
                       sizeof(szEntryName));

            if(prasconncb->pEntry->pszPrerequisiteEntry)
            {
                strncpyTtoA(szRefEntryName,
                           prasconncb->pEntry->pszPrerequisiteEntry,
                           sizeof(szRefEntryName));
            }
            else
            {
                *szRefEntryName = '\0';
            }

            if(prasconncb->pEntry->pszPrerequisitePbk)
            {
                strncpyTtoA(szRefPhonebookPath,
                           prasconncb->pEntry->pszPrerequisitePbk,
                           sizeof(szRefPhonebookPath));
            }
            else
            {
                *szRefPhonebookPath = '\0';
            }

            RASAPI32_TRACE("RasCreateConnection...");

            dwErr = g_pRasCreateConnection(
                                &prasconncb->hrasconn,
                                dwSubEntries,
                                &dwEntryAlreadyConnected,
                                pdwSubEntryInfo,
                                (prasconncb->fDialSingleLink)
                                ? RASEDM_DialAsNeeded
                                : prasconncb->pEntry->dwDialMode,
                                prasconncb->pEntry->pGuid,
                                szPhonebookPath,
                                szEntryName,
                                szRefPhonebookPath,
                                szRefEntryName);

            RASAPI32_TRACE3(
              "RasCreateConnection(%d) hrasconn=%d, "
              "ConnectionAlreadyPresent=%d",
              dwErr,
              prasconncb->hrasconn,
              dwEntryAlreadyConnected);

            if(RCS_CONNECTING == (RASMAN_CONNECTION_STATE)
                                 dwEntryAlreadyConnected)
            {
                RASAPI32_TRACE("Entry is already in the process of"
                      " connecting");

                dwErr = ERROR_DIAL_ALREADY_IN_PROGRESS;

                if(NULL != pdwSubEntryInfo)
                {
                    LocalFree(pdwSubEntryInfo);
                    pdwSubEntryInfo = NULL;
                }

                DeleteRasconncbNode(prasconncb);
                return dwErr;
            }

            if (    NO_ERROR == dwErr
                &&  pdwSubEntryInfo[0])
            {
                prasconncb->fAlreadyConnected = TRUE;
            }
        }

        if (dwErr)
        {
            if (pdwSubEntryInfo)
            {
                LocalFree (pdwSubEntryInfo);
                pdwSubEntryInfo = NULL;
            }

            DeleteRasconncbNode(prasconncb);
            return dwErr;
        }

        hrasconn = (HRASCONN)prasconncb->hrasconn;
        rasconnstate = 0;

        prasconncb->hport           = INVALID_HPORT;

        prasconncb->dwNotifierType  = dwNotifierType;

        prasconncb->notifier        = notifier;

        prasconncb->hwndParent      = hwndParent;

        prasconncb->reserved        = reserved;

        prasconncb->fAllowPause     = fAllowPause;

        prasconncb->fPauseOnScript  =
                    (dwfOptions & RDEOPT_PausedStates)
                     ? TRUE : FALSE;

        if(     (NULL != lpExtensions)
            &&  (sizeof(RASDIALEXTENSIONS) == lpExtensions->dwSize)
            &&  (0 != lpExtensions->RasEapInfo.dwSizeofEapInfo))
        {
            //
            // Make a local copy of this buffer. This is not
            // very optimized but the user of this api may
            // not know when to free this pointer.
            //
            prasconncb->RasEapInfo.pbEapInfo =
                LocalAlloc(
                    LPTR,
                    lpExtensions->RasEapInfo.dwSizeofEapInfo);

            if(NULL == prasconncb->RasEapInfo.pbEapInfo)
            {
                dwErr = GetLastError();
                if (pdwSubEntryInfo)
                {
                    LocalFree (pdwSubEntryInfo);
                    pdwSubEntryInfo = NULL;
                }

                DeleteRasconncbNode(prasconncb);
                return dwErr;
            }

            prasconncb->RasEapInfo.dwSizeofEapInfo =
                lpExtensions->RasEapInfo.dwSizeofEapInfo;

            memcpy(prasconncb->RasEapInfo.pbEapInfo,
                   lpExtensions->RasEapInfo.pbEapInfo,
                   prasconncb->RasEapInfo.dwSizeofEapInfo);

        }
        else
        {
            prasconncb->RasEapInfo.dwSizeofEapInfo = 0;
            prasconncb->RasEapInfo.pbEapInfo = NULL;
        }

        if (dwNotifierType == 0xFFFFFFFF)
        {
            prasconncb->unMsg = RegisterWindowMessageA(RASDIALEVENT);

            if (prasconncb->unMsg == 0)
            {
                prasconncb->unMsg = WM_RASDIALEVENT;
            }
        }
        else
        {
            prasconncb->unMsg = WM_RASDIALEVENT;
        }

        prasconncb->fDefaultEntry =
            (prasdialparams->szEntryName[0] == TEXT('\0'));

        prasconncb->szOldPassword[ 0 ]          = TEXT('\0');
        prasconncb->fRetryAuthentication        = FALSE;
        prasconncb->fMaster                     = FALSE;
        prasconncb->dwfSuspended                = SUSPEND_Start;
        prasconncb->fStopped                    = FALSE;
        prasconncb->fCleanedUp                  = FALSE;
        prasconncb->fDeleted                    = FALSE;
        prasconncb->fOldPasswordSet             = FALSE;
        prasconncb->fUpdateCachedCredentials    = FALSE;
        prasconncb->fPppEapMode                 = FALSE;

        //
        // Create the correct avpnprotsarray
        //
        AssignVpnProtsOrder(prasconncb);

        prasconncb->dwCurrentVpnProt = 0;

        /*
        if (    prasconncb->fDialSingleLink
            ||  (prasconncb->pEntry->dwDialMode
            == RASEDM_DialAsNeeded))
        {
            prasconncb->fMultilink = TRUE;
        }
        else
        {
            prasconncb->fMultilink = FALSE;
        }
        */

        // prasconncb->fBundled = FALSE;

        //
        // Get the idle disconnect timeout.  If there is a
        // timeout specified in the entry, then use it;
        // otherwise, get the one specified in the user
        // preferences.
        //
        dwIdleDisconnectSeconds = 0;

        if ((prasconncb->pEntry->dwfOverridePref
                 & RASOR_IdleDisconnectSeconds))
        {
            if(0 == prasconncb->pEntry->lIdleDisconnectSeconds)
            {
                dwIdleDisconnectSeconds = 0xFFFFFFFF;
            }
            else
            {
                dwIdleDisconnectSeconds =
                    (DWORD) prasconncb->pEntry->lIdleDisconnectSeconds;
            }
        }
        else
        {
            PBUSER pbuser;

            dwErr = GetUserPreferences(NULL,
                                      &pbuser,
                                      prasconncb->dwUserPrefMode);

            RASAPI32_TRACE2("GetUserPreferences(%d), "
                    "dwIdleDisconnectSeconds=%d",
                    dwErr,
                    pbuser.dwIdleDisconnectSeconds);

            if (dwErr)
            {
                if ( pdwSubEntryInfo )
                {
                    LocalFree ( pdwSubEntryInfo );
                }

                g_pRasRefConnection(prasconncb->hrasconn,
                                    FALSE,
                                    NULL);

                DeleteRasconncbNode(prasconncb);

                return dwErr;
            }

            dwIdleDisconnectSeconds = pbuser.dwIdleDisconnectSeconds;
            DestroyUserPreferences(&pbuser);
        }

/*
        //
        // Round the idle disconnect seconds to minutes.
        //
        if (dwIdleDisconnectSeconds)
        {
            prasconncb->dwIdleDisconnectMinutes =
              (dwIdleDisconnectSeconds + 59) / 60;
        }

        RASAPI32_TRACE1("dwIdleDisconnectMinutes=%d",
                  prasconncb->dwIdleDisconnectMinutes);

*/        

        if(dwIdleDisconnectSeconds)
        {
            prasconncb->dwIdleDisconnectSeconds =
                            dwIdleDisconnectSeconds;
        }

        RASAPI32_TRACE1("dwIdleDisconnectSeconds=%d",
                prasconncb->dwIdleDisconnectSeconds);

        if (!dwEntryAlreadyConnected)
        {
            // If the connection is not already up
            // Initialize projection information so we
            // get consistent results during the dialing
            // process.
            //
            memset(&prasconncb->PppProjection,
                '\0', sizeof(prasconncb->PppProjection));

            prasconncb->PppProjection.nbf.dwError       =

                prasconncb->PppProjection.ipx.dwError   =

                prasconncb->PppProjection.ip.dwError    =
                            ERROR_PPP_NO_PROTOCOLS_CONFIGURED;

            prasconncb->hportBundled = INVALID_HPORT;

            memset(&prasconncb->AmbProjection,
                  '\0',
                  sizeof (prasconncb->AmbProjection));

            prasconncb->AmbProjection.Result =
                                    ERROR_PROTOCOL_NOT_CONFIGURED;

            memset(&prasconncb->SlipProjection,
                  '\0',
                  sizeof (prasconncb->SlipProjection));

            prasconncb->SlipProjection.dwError =
                                    ERROR_PROTOCOL_NOT_CONFIGURED;

            RASAPI32_TRACE("SaveProjectionResults...");

            dwErr = SaveProjectionResults(prasconncb);

            RASAPI32_TRACE1("SaveProjectionResults(%d)", dwErr);
        }

    }  // if (fNewEntry)

    //
    // Set/update RASDIALPARAMS for the connection.  Can't just
    // read from caller's buffer since the call is asynchronous.
    // If we are restarting RasDial, then we need to save the
    // subentry away and restore it after the memcpy because
    // it may have been 0 in the caller's original version.
    //
    {
        DWORD dwSubEntry;

        if (!fNewEntry)
        {
            dwSubEntry = prasconncb->rasdialparams.dwSubEntry;
        }

        memcpy(&prasconncb->rasdialparams,
              prasdialparams,
              prasdialparams->dwSize);

        if (!fNewEntry)
        {
            prasconncb->rasdialparams.dwSubEntry = dwSubEntry;

            //
            // Update the rasdialparams for all the subentries.
            //
            SyncDialParamsSubentries(prasconncb);
        }
    }

    EncodePassword(prasconncb->rasdialparams.szPassword);

    //
    // Initialize the state machine.  If the state is non-0 we
    // are resuming from a paused state, the machine is
    // already in place (blocked) and just the next
    // state need be set.
    //
    prasconncb->rasconnstateNext = rasconnstate;

    //
    // Enter CriticalSection here so that the async worker thread
    // is not stopped before we are done with our initialization
    // of the link.
    //
    EnterCriticalSection(&csStopLock);

    if (rasconnstate == 0)
    {
        if (    prasconncb->fDefaultEntry
            &&  prasconncb->rasdialparams.szPhoneNumber[0]
                == TEXT('\0'))
        {
            if (pdwSubEntryInfo)
            {
                LocalFree (pdwSubEntryInfo);
            }

            g_pRasRefConnection(prasconncb->hrasconn,
                                FALSE, NULL);

            //
            // No phone number or entry name...gotta
            // have one or the other.
            //
            DeleteRasconncbNode(prasconncb);
            LeaveCriticalSection(&csStopLock);
            return ERROR_CANNOT_FIND_PHONEBOOK_ENTRY;
        }

        //
        // Read the PPP-related fields from the phonebook
        // entry (or set defaults if default entry).
        //
        if ((dwErr = ReadPppInfoFromEntry(prasconncb)) != 0)
        {
            if (pdwSubEntryInfo)
            {
                LocalFree (pdwSubEntryInfo);
            }

            g_pRasRefConnection(prasconncb->hrasconn, FALSE, NULL);

            DeleteRasconncbNode(prasconncb);

            LeaveCriticalSection(&csStopLock);

            return dwErr;
        }

        prasconncb->asyncmachine.oneventfunc =
                            (ONEVENTFUNC )OnRasDialEvent;

        prasconncb->asyncmachine.cleanupfunc =
                            (CLEANUPFUNC )RasDialCleanup;

        prasconncb->asyncmachine.freefunc =
                            (FREEFUNC) RasDialFinalCleanup;

        prasconncb->asyncmachine.pParam =
                            (VOID* )prasconncb;

        prasconncb->rasconnstate = 0;

        if (0 !=
            (dwErr =
                StartAsyncMachine(&prasconncb->asyncmachine,
                                   prasconncb->hrasconn)))
        {
            if (pdwSubEntryInfo)
            {
                LocalFree (pdwSubEntryInfo);
            }

            g_pRasRefConnection(prasconncb->hrasconn,
                                FALSE, NULL);

            DeleteRasconncbNode(prasconncb);

            LeaveCriticalSection(&csStopLock);

            return dwErr;
        }

    }

    *lphrasconn = hrasconn;

    dwSubEntries = DtlGetNodes(prasconncb->pEntry->pdtllistLinks);

    if(prasconncb->pEntry->dwDialMode != 0)
    {
        if(dwSubEntries > 1)
        {
            prasconncb->fMultilink = TRUE;
        }
        else
        {
            prasconncb->fMultilink = FALSE;
        }
    }
    else
    {
        prasconncb->fMultilink = FALSE;
    }

    //
    // If this is a multilinked subentry, then create
    // separate connection blocks for each subentry.
    // The async machine will multiplex its work over
    // all connection blocks in round-robin order.
    //
    if (    fNewEntry
        &&  prasconncb->pEntry->dwDialMode == RASEDM_DialAll
        &&  fEnableMultilink
        &&  !prasconncb->fDialSingleLink)
    {
        DTLNODE     *pdtlnode;
        RASCONNCB   *prasconncb2;
        DWORD       *pdwSubentryInfo = NULL;

        DWORD       i;

        /*                    

        if (1 == dwSubEntries)
        {
            //
            // If there is only one link in the bundle don't
            // multilink.
            //
            prasconncb->fMultilink = FALSE;
        }

        */


        for (i = 1; i < dwSubEntries; i++)
        {

            RASAPI32_TRACE1("Creating connection block for subentry %d",
                  i + 1);

            prasconncb2 = CreateConnectionBlock(prasconncb);

            if (prasconncb2 == NULL)
            {
                if (pdwSubEntryInfo)
                {
                    LocalFree (pdwSubEntryInfo);
                }

                DeleteRasconncbNode(prasconncb);

                LeaveCriticalSection(&csStopLock);

                return ERROR_NOT_ENOUGH_MEMORY;
            }

            //
            // Look up the subentry.
            //
            pdtlnode = DtlNodeFromIndex(
                        prasconncb->pEntry->pdtllistLinks,
                        i);

            ASSERT(pdtlnode);
            prasconncb2->pLink = (PBLINK *)
                                 DtlGetData(pdtlnode);

            ASSERT(prasconncb->pLink);
            prasconncb2->rasdialparams.dwSubEntry = i + 1;

            if (dwEntryAlreadyConnected)
            {
                if (pdwSubEntryInfo[i])
                {
                    prasconncb2->fAlreadyConnected = TRUE;
                }
                else
                {
                    prasconncb2->fAlreadyConnected = FALSE;
                }
            }
        }
    }

    //
    // Start all the state machines at the same time.
    //
    StartSubentries(prasconncb);
    hDone = prasconncb->asyncmachine.hDone;

    if (pdwSubEntryInfo)
    {
        LocalFree (pdwSubEntryInfo);
    }

    if(NULL == notifier)
    {
        prasconncb->psyncResult = &dwErr;
    }

    LeaveCriticalSection(&csStopLock);

    //
    // If caller provided a notifier then return, i.e.
    // operate asynchronously. Otherwise, operate
    // synchronously (from caller's point of view).
    //
    if (notifier)
    {
        return 0;
    }
    else
    {
        //
        // Moved the cleanup of prasconncb in the synchronous
        // case to the Asyncmachine worker thread. prasconncb
        // is freed when the waitfor... returns.
        //
        RASAPI32_TRACE("_RasDial: Waiting for async worker to terminate...");

        WaitForSingleObject(hDone, INFINITE);

        RASAPI32_TRACE("_RasDial: Async worker terminated");

        return dwErr;
    }
}


DWORD
OnRasDialEvent(
    IN ASYNCMACHINE* pasyncmachine,
    IN BOOL          fDropEvent )

/*++

Routine Description:

        Called by asynchronous state machine whenever one of the
        events is signalled.  'pasyncmachine' is the address of
        the async machine.'fDropEvent' is true if the "connection
        dropped" event occurred,otherwise the "state done" event
        occurred.

Arguments:

Return Value:

        Returns true to end the state machine, false to continue.

--*/
{
    DWORD      dwErr;
    RASCONNCB* prasconncb = (RASCONNCB* )pasyncmachine->pParam;
    BOOL       fPortClose = FALSE;

    //
    // Detect errors that may have occurred.
    //
    if (fDropEvent)
    {
        //
        // Connection dropped notification received.
        //
        RASMAN_INFO info;

        RASAPI32_TRACE("Link dropped!");

        prasconncb->rasconnstate = RASCS_Disconnected;

        if(     (SUCCESS == prasconncb->dwSavedError)
            ||  (PENDING == prasconncb->dwSavedError))
        {            
            prasconncb->dwError = ERROR_DISCONNECTION;
        }
        else
        {
            prasconncb->dwError = prasconncb->dwSavedError;
        }

        //
        // Convert the reason the line was dropped into a more
        // specific error code if available.
        //
        RASAPI32_TRACE("RasGetInfo...");

        dwErr = g_pRasGetInfo( NULL,
                               prasconncb->hport,
                               &info );

        RASAPI32_TRACE1("RasGetInfo done(%d)", dwErr);

        if (    (dwErr == 0)
            &&  (SUCCESS == prasconncb->dwError))
        {
            prasconncb->dwError =
                ErrorFromDisconnectReason(info.RI_DisconnectReason);

#ifdef AMB
            if (    prasconncb->fPppMode
                &&  prasconncb->fIsdn
                &&  prasconncb->dwAuthentication == AS_PppThenAmb
                &&  prasconncb->dwError == ERROR_REMOTE_DISCONNECTION
                &&  !prasconncb->fMultilink)
            {
                //
                // This is what happens when PPP ISDN tries to talk
                // to a down-level server.  The ISDN frame looks
                // enough like a PPP frame to the old ISDN driver
                // that it gets passed to the old server who sees
                // it's not AMB and drops the line. We do *not*
                // do this with multilink connections.
                //
                RASAPI32_TRACE("PPP ISDN disconnected, try AMB");

                prasconncb->dwRestartOnError = RESTART_DownLevelIsdn;
                prasconncb->fPppMode = FALSE;
            }
#endif
        }
        else if(ERROR_PORT_NOT_OPEN == dwErr)
        {
            if(0 != info.RI_LastError)
            {
                RASAPI32_TRACE1("Port was close because of %d",
                       info.RI_LastError);

                prasconncb->dwError = info.RI_LastError;
                dwErr = info.RI_LastError;
            }
        }
    }
    else if (pasyncmachine->dwError != 0)
    {
        RASAPI32_TRACE("Async machine error!");

        //
        // A system call in the async machine mechanism failed.
        //
        prasconncb->dwError = pasyncmachine->dwError;
    }
    else if (prasconncb->dwError == PENDING)
    {
        prasconncb->dwError = 0;

        if (prasconncb->hport != INVALID_HPORT)
        {
            RASMAN_INFO info;

            RASAPI32_TRACE("RasGetInfo...");

            dwErr = g_pRasGetInfo( NULL,
                                   prasconncb->hport,
                                   &info );

            RASAPI32_TRACE1("RasGetInfo done(%d)", dwErr);

            if (    (dwErr != 0)
                ||  ((dwErr = info.RI_LastError) != 0))
            {
                if(ERROR_PORT_NOT_OPEN == dwErr)
                {
                    //
                    // Try to find out why this
                    // port was disconnected.
                    //
                    if(0 != info.RI_LastError)
                    {
#if DBG
                        RASAPI32_TRACE1("Mapping Async err to"
                               " lasterror=%d",
                               info.RI_LastError);
#endif
                        dwErr = info.RI_LastError;
                    }
                }

                //
                // A pending RAS Manager call failed.
                //
                prasconncb->dwError = dwErr;

                RASAPI32_TRACE1("Async failure=%d", dwErr);

                //
                // if the rasdial machine is waiting for this
                // device to be connected or a listen to be
                // posted and the async operation failed
                // in rasman, close the port after notifying the
                // clients that the connect or the post listen
                // failed.
                //
                if (    RASCS_WaitForCallback
                        == prasconncb->rasconnstate
                    ||  RASCS_ConnectDevice
                        == prasconncb->rasconnstate)
                {
                    RASAPI32_TRACE2("RDM: Marking port %d for closure in "
                           "RASCS = %d",
                           prasconncb->hport,
                           prasconncb->rasconnstate);

                    fPortClose = TRUE;
                }
            }
        }
    }
    else if (       (prasconncb->dwError != 0)
                &&  (prasconncb->rasconnstate == RASCS_OpenPort)
                &&  (INVALID_HPORT != prasconncb->hport))
    {
        RASAPI32_TRACE2("RDM: Marking port %d for closure in "
               "RASCS = %d!!!!!",
               prasconncb->hport,
               prasconncb->rasconnstate);

        fPortClose = TRUE;
    }

    if (prasconncb->dwError == 0)
    {
        //
        // Last state completed cleanly so move to next state.
        //
        if ( prasconncb->fAlreadyConnected )
        {
            RASAPI32_TRACE("OnRasDialEvent: Setting state to connected - "
                  "is already connected!");

            prasconncb->rasconnstate = RASCS_Connected;
        }
        else
        {
            prasconncb->rasconnstate =
                    prasconncb->rasconnstateNext;

        }
    }
    else if (   (RASET_Vpn == prasconncb->pEntry->dwType)
            &&  (RASCS_DeviceConnected > prasconncb->rasconnstate)
            &&  (prasconncb->iAddress < prasconncb->cAddresses)
            &&  (NULL != prasconncb->pAddresses)
            &&  (prasconncb->dwError != ERROR_NO_CERTIFICATE)
            &&  (prasconncb->dwError != ERROR_OAKLEY_NO_CERT)
            &&  (prasconncb->dwError != ERROR_CERT_FOR_ENCRYPTION_NOT_FOUND)
            &&  (prasconncb->hport != INVALID_HPORT))
    {
        EnterCriticalSection(&csStopLock);

        RasDialTryNextAddress(&prasconncb);

        LeaveCriticalSection(&csStopLock);
    }
    else if (prasconncb->dwRestartOnError != 0)
    {
        //
        // Last state failed, but we're in "restart on error"
        // mode so we can attempt to restart.
        //
        EnterCriticalSection(&csStopLock);

        //
        // Don't attempt to try other numbers if the port
        // failed to open.
        // BUG 84132.
        //
        ASSERT(NULL != prasconncb->pLink);

        //
        // Don't try alternate phone numbers (hunt) in
        // the following cases:
        // 1. if the port didn't open successfully
        // 2. if the user has disabled this in the phone
        //    book - TryNextAlternateOnFail=0 in the phone
        //    book for this entry.
        // 3. if an override phone number is specified - from
        //    the ui this can happen if the user either picked
        //    different phonenumber from the drop down list
        //    than the one displayed originally or modified
        //    the originally displayed number.
        //
        if (    prasconncb->hport != INVALID_HPORT
            &&  prasconncb->pLink->fTryNextAlternateOnFail
            &&  TEXT('\0')
                == prasconncb->rasdialparams.szPhoneNumber[0])
        {
            RasDialRestart(&prasconncb);
        }
        else
        {
            RASAPI32_TRACE1 ("Not Restarting rasdial as port is not open. %d",
                     prasconncb->dwError);
        }

        LeaveCriticalSection(&csStopLock);
    }

    //
    // If we failed before or at the DeviceConnect
    // state and if the dialMode is set to try next
    // link , try to dial the next link. Skip dial 
    // next link for VPN and DCC devices. It doesn't
    // make much sense to dial next link for these
    // devices.
    //
    if(     0 != prasconncb->dwError
        &&  RASCS_DeviceConnected > prasconncb->rasconnstate
        &&  RASET_Vpn != prasconncb->pEntry->dwType
        &&  RASET_Direct != prasconncb->pEntry->dwType
        &&  !prasconncb->fDialSingleLink
        &&  prasconncb->fTryNextLink
        &&  !prasconncb->fTerminated)
        // &&  0 == prasconncb->pEntry->dwDialMode)
    {
        //
        // Get a lock so that prasconncb is not blown
        // away from under us - by HangUp for example
        //
        EnterCriticalSection(&csStopLock);

        RasDialTryNextLink(&prasconncb);

        LeaveCriticalSection(&csStopLock);
    }

    if(     0 != prasconncb->dwError
        &&  RASCS_DeviceConnected > prasconncb->rasconnstate
        &&  RASET_Vpn == prasconncb->pEntry->dwType)
    {
        EnterCriticalSection(&csStopLock);

        RasDialTryNextVpnDevice(&prasconncb);

        LeaveCriticalSection(&csStopLock);
    }

    if (    prasconncb->rasconnstate == RASCS_Connected
        &&  !prasconncb->fAlreadyConnected)
    {

        BOOL fPw = FALSE;

        //
        // If we are dialing a single-link entry that gets
        // bundled with another entry, then we haven't saved
        // the projection information yet.  The restriction
        // on this behavior is that the connection to which
        // this connection is getting bundled must already
        // have projection information.  This is not guaranteed
        // if both entries are being dialed simultaneously.
        // It is assumed this is not the case.  We fail the
        // bundled connection if we cannot get the projection
        // information on the first try.
        //
        if (    !prasconncb->fMultilink 
            &&   prasconncb->hportBundled != INVALID_HPORT)
        {
            RASMAN_INFO info;
            DWORD dwSize;

            //
            // The new connection was bundled with an existing
            // connection.  Retrieve the PPP projection
            // information for the connection to which it was
            // bundled and duplicate it for the new
            // connection.
            //
            RASAPI32_TRACE1(
              "Single link entry bundled to hport %d",
              prasconncb->hportBundled);
            //
            // Get the projection information
            // for the connection to which this
            // port was bundled.
            //
            dwErr = g_pRasGetInfo(
                      NULL,
                      prasconncb->hportBundled,
                      &info);
            //
            // If we can't get the projection information
            // for the bundled port, then we need to
            // terminate this link.
            //
            if (dwErr)
            {
                RASAPI32_TRACE2("RasGetInfo, hport=%d, failed. rc=0x%x",
                       prasconncb->hportBundled,
                       dwErr);

                       
                prasconncb->dwError =
                        ERROR_PPP_NO_PROTOCOLS_CONFIGURED;

                goto update;
            }

            dwSize = sizeof (prasconncb->PppProjection);

            dwErr = g_pRasGetConnectionUserData(
                      info.RI_ConnectionHandle,
                      CONNECTION_PPPRESULT_INDEX,
                      (PBYTE)&prasconncb->PppProjection,
                      &dwSize);

            if (dwErr)
            {
                RASAPI32_TRACE2("RasGetConnectionUserData, hport=%d failed. rc=0x%x",
                      info.RI_ConnectionHandle,
                      dwErr);
                prasconncb->dwError = ERROR_PPP_NO_PROTOCOLS_CONFIGURED;
                goto update;
            }

            //
            // Save the projection results.
            //
            RASAPI32_TRACE("SaveProjectionResults...");
            dwErr = SaveProjectionResults(prasconncb);
            RASAPI32_TRACE1("SaveProjectionResults(%d)", dwErr);
        }

        //
        // Check to see if the connection happened using the
        // credentials in the default store. If it did then
        // don't save anything in the users store in lsa.
        //
        {
            DWORD rc = ERROR_SUCCESS;
            RAS_DIALPARAMS dialparams;            
            DWORD dwMask;

            ZeroMemory(&dialparams, sizeof(RAS_DIALPARAMS));

            dwMask = DLPARAMS_MASK_USERNAME
                   | DLPARAMS_MASK_DOMAIN
                   | DLPARAMS_MASK_PASSWORD;

            rc = g_pRasGetDialParams(
                        prasconncb->pEntry->dwDialParamsUID,
                        &dwMask,
                        &dialparams);

            if(     (ERROR_SUCCESS == rc)
                &&  (   (dwMask & DLPARAMS_MASK_DEFAULT_CREDS)
                    ||  (dwMask & DLPARAMS_MASK_PASSWORD)))
            {
                fPw = TRUE;
            }
        }


        //
        // For entries that authenticate with the
        // current username/password, we only save
        // the domain.  Otherwise, we save everything.
        //
        if (    !fPw
            &&  !prasconncb->fRetryAuthentication)
        {
            DWORD dwMask;

            DecodePassword(prasconncb->rasdialparams.szPassword);

            if (prasconncb->pEntry->fAutoLogon)
            {
                dwMask =    DLPARAMS_MASK_PHONENUMBER
                        |   DLPARAMS_MASK_CALLBACKNUMBER
                        |   DLPARAMS_MASK_USERNAME
                        |   DLPARAMS_MASK_PASSWORD
                        |   DLPARAMS_MASK_DOMAIN
                        |   DLPARAMS_MASK_SUBENTRY
                        |   DLPARAMS_MASK_OLDSTYLE;

                (void)SetEntryDialParamsUID(
                        prasconncb->pEntry->dwDialParamsUID,
                        dwMask,
                        &prasconncb->rasdialparams,
                        TRUE);

                dwMask =    DLPARAMS_MASK_DOMAIN
                        |   DLPARAMS_MASK_OLDSTYLE;

                (void)SetEntryDialParamsUID(
                        prasconncb->pEntry->dwDialParamsUID,
                        dwMask,
                        &prasconncb->rasdialparams,
                        FALSE);
            }
            else
            {
                // Note: DLPARAMS_MASK_PASSWORD removed as it has been decided
                //       that "automatically" saving it here without user's
                //       input is too big a security hole for NT.  This is a
                //       small incompatibility with Win9x, which really should
                //       also make this change.
                //
                dwMask =    DLPARAMS_MASK_PHONENUMBER
                        |   DLPARAMS_MASK_CALLBACKNUMBER
                        |   DLPARAMS_MASK_USERNAME
                        |   DLPARAMS_MASK_DOMAIN
                        |   DLPARAMS_MASK_SUBENTRY
                        |   DLPARAMS_MASK_OLDSTYLE;

                (void)SetEntryDialParamsUID(
                        prasconncb->pEntry->dwDialParamsUID,
                        dwMask,
                        &prasconncb->rasdialparams,
                        FALSE);
            }

            EncodePassword(prasconncb->rasdialparams.szPassword);
        }

        if (!prasconncb->fDefaultEntry)
        {
            PBLINK *pLink = prasconncb->pLink;

            //
            // Reorder the hunt group order if the
            // entry specifies it. 
            //
            if (    pLink->fPromoteAlternates
                &&  DtlGetNodes(pLink->pdtllistPhones) > 1)
            {
                DTLNODE *pdtlnode = DtlNodeFromIndex(
                                      pLink->pdtllistPhones,
                                      prasconncb->iPhoneNumber);

                RASAPI32_TRACE1(
                  "Promoting hunt group number index %d to top",
                  prasconncb->iPhoneNumber);
                DtlRemoveNode(
                  pLink->pdtllistPhones,
                  pdtlnode);
                DtlAddNodeFirst(
                  pLink->pdtllistPhones,
                  pdtlnode);
                prasconncb->pEntry->fDirty = TRUE;
            }

            //
            // Write the phonebook out if we had to
            // modify it during the dialing process.
            // Ignore errors if we get them.  Note
            // the phonebook entry could become dirty
            // from SetAuthentication() or the code
            // above.
            //
            if (prasconncb->pEntry->fDirty)
            {
                RASAPI32_TRACE("Writing phonebook");
                (void)WritePhonebookFile(&prasconncb->pbfile,
                                         NULL);
            }
        }
    }

    //
    // Update the connection states in rasman.
    //

update:

    if (prasconncb->hport != INVALID_HPORT)
    {
        RASCONNSTATE rasconnstate;
        //
        // If we are not the last subentry in the connection
        // then only report RASCS_SubEntryConnected state.
        //
        rasconnstate = prasconncb->rasconnstate;
        RASAPI32_TRACE1("setting rasman state to %d",
                rasconnstate);

        dwErr = g_pRasSetPortUserData(
                  prasconncb->hport,
                  PORT_CONNSTATE_INDEX,
                  (PBYTE)&rasconnstate,
                  sizeof (rasconnstate));

        dwErr = g_pRasSetPortUserData(
                  prasconncb->hport,
                  PORT_CONNERROR_INDEX,
                  (PBYTE)&prasconncb->dwError,
                  sizeof (prasconncb->dwError));
    }
    //
    // Inform rasman that the connection
    // has been authenticated.
    //
    if (    (MapSubentryState(prasconncb) 
            == RASCS_Connected) 
        ||  (MapSubentryState(prasconncb)
            == RASCS_SubEntryConnected))
    {
        RASAPI32_TRACE("RasSignalNewConnection...");
        dwErr = g_pRasSignalNewConnection(
                    (HCONN)prasconncb->hrasconn);

        RASAPI32_TRACE1("RasSignalNewConnection(%d)", dwErr);
    }

    //
    // Notify caller's app of change in state.
    //
    if (prasconncb->notifier)
    {
        DWORD dwNotifyResult;
        RASCONNSTATE rasconnstate =
                MapSubentryState(prasconncb);

        DTLNODE *pdtlnode;

        if (    RASCS_AuthRetry != rasconnstate
            ||  !prasconncb->fPppEapMode)
        {
            dwNotifyResult =
              NotifyCaller(
                prasconncb->dwNotifierType,
                prasconncb->notifier,
                (HRASCONN)prasconncb->hrasconn,
                prasconncb->rasdialparams.dwSubEntry,
                prasconncb->rasdialparams.dwCallbackId,
                prasconncb->unMsg,
                rasconnstate,
                prasconncb->dwError,
                prasconncb->dwExtendedError);

            switch (dwNotifyResult)
            {
            case 0:
                RASAPI32_TRACE1(
                  "Discontinuing callbacks for hrasconn 0x%x",
                  prasconncb->hrasconn);

                //
                // If the notifier procedure returns FALSE, then
                // we discontinue all callbacks for this
                // connection.
                //
                EnterCriticalSection(&RasconncbListLock);
                for (pdtlnode = DtlGetFirstNode(PdtllistRasconncb);
                     pdtlnode;
                     pdtlnode = DtlGetNextNode(pdtlnode))
                {
                    RASCONNCB *prasconncbTmp = DtlGetData(pdtlnode);

                    ASSERT(prasconncbTmp);

                    if(prasconncbTmp->hrasconn
                        == prasconncb->hrasconn)
                    {
                        prasconncbTmp->notifier = NULL;

                        RASAPI32_TRACE2(
                           "Cleared notifier for hrasconn 0x%x "
                           "subentry %d",
                            prasconncbTmp->hrasconn,
                            prasconncbTmp->rasdialparams.dwSubEntry);
                    }

                }
                LeaveCriticalSection(&RasconncbListLock);

                break;

            case 2:
                RASAPI32_TRACE1(
                  "Reloading phonebook entry for hrasconn 0x%x",
                  prasconncb->hrasconn);


                ReloadRasconncbEntry(prasconncb);

                break;

            default:
                // no special handling required
                break;
            }
        }
    }

    if (fPortClose)
    {
        DWORD dwErrT;

        EnterCriticalSection(&csStopLock);

        if (RASCS_ConnectDevice
                == prasconncb->rasconnstate)
        {
            RASMAN_INFO ri;

            dwErrT = g_pRasGetInfo(
                        NULL,
                        prasconncb->hport,
                        &ri);

            RASAPI32_TRACE2("RDM: RasGetInfo, port=%d returned %d",
                    prasconncb->hport,
                    dwErrT);

            if(   (ERROR_SUCCESS == dwErrT)
                &&  (0 == (ri.RI_CurrentUsage & CALL_IN)))
            {                
            
            
                RASAPI32_TRACE1("RDM: DisconnectPort %d...",
                        prasconncb->hport);

                dwErrT = RasPortDisconnect(
                                prasconncb->hport,
                                INVALID_HANDLE_VALUE );

                RASAPI32_TRACE1("RDM: DisconnectPort comleted. %d",
                        dwErrT);
            }                    
        }

        RASAPI32_TRACE1("RDM: PortClose %d ...",
                prasconncb->hport);

        dwErrT = g_pRasPortClose(prasconncb->hport);

        RASAPI32_TRACE2("RDM: PortClose %d Completed. %d",
                prasconncb->hport, dwErrT);

        LeaveCriticalSection( &csStopLock );

    }


    //
    // If we're connected or a fatal error occurs or user
    // hung up, the state machine will end.
    //
    if (    prasconncb->rasconnstate & RASCS_DONE
        ||  prasconncb->dwError != 0
        || (    fDropEvent
            &&  !IsListEmpty(&prasconncb->ListEntry)))
    {
        RASAPI32_TRACE2(
          "Quitting s=%d,e=%d",
          prasconncb->rasconnstate,
          prasconncb->dwError);

        //
        // If the first link fails during a multilink
        // connection during PPP authentication phase,
        // then other links are currently suspeneded,
        // and must be restarted.
        //
        if (IsSubentriesSuspended(prasconncb))
        {
            RASAPI32_TRACE("resetting remaining subentries");
            RestartSubentries(prasconncb);
        }

        return TRUE;
    }

    if (!(prasconncb->rasconnstate & RASCS_PAUSED))
    {
        //
        // Execute the next state and block waiting for
        // it to finish.  This is not done if paused
        // because user will eventually call RasDial
        // to resume and unblock via the _RasDial
        // kickstart.
        //
        prasconncb->rasconnstateNext =
            RasDialMachine(
                prasconncb->rasconnstate,
                prasconncb,
                hDummyEvent,
                hDummyEvent );

    }

    return FALSE;
}


VOID
RasDialCleanup(
    IN ASYNCMACHINE* pasyncmachine )

/*++

Routine Description:

        Called by async machine just before exiting.

Arguments:

Return Value:

--*/
{
    DWORD      dwErr;
    DTLNODE*   pdtlnode;
    RASCONNCB* prasconncb = (RASCONNCB* )pasyncmachine->pParam;
    RASCONNCB* prasconncbTmp;
    HCONN      hconn = prasconncb->hrasconn;

    RASAPI32_TRACE("RasDialCleanup...");

    EnterCriticalSection(&RasconncbListLock);

    for (pdtlnode = DtlGetFirstNode( PdtllistRasconncb );
         pdtlnode;
         pdtlnode = DtlGetNextNode( pdtlnode ))
    {
        prasconncbTmp = (RASCONNCB* )DtlGetData( pdtlnode );

        ASSERT(prasconncbTmp);

        if (    prasconncbTmp == prasconncb
            &&  !prasconncbTmp->fCleanedUp)
        {
            CleanUpRasconncbNode(pdtlnode);
            break;
        }
    }

    LeaveCriticalSection(&RasconncbListLock);

    RASAPI32_TRACE("RasDialCleanUp done.");
}


VOID
RasDialFinalCleanup(
    IN ASYNCMACHINE* pasyncmachine,
    DTLNODE *pdtlnode
    )
{
    RASCONNCB* prasconncb = (RASCONNCB* )pasyncmachine->pParam;

    RASAPI32_TRACE1("RasDialFinalCleanup: deallocating prasconncb=0x%x",
            prasconncb);

    EnterCriticalSection(&csStopLock);

    //
    // Make sure the connection block is
    // off the list.
    //
    DeleteRasconncbNode(prasconncb);

    //
    // Finally free the connection block.
    //
    FinalCleanUpRasconncbNode(pdtlnode);

    LeaveCriticalSection(&csStopLock);
}


DWORD
ComputeLuid(
    PLUID pLuid
    )

/*++

Routine Description:

        Compute a LUID for RasPppStart.  This code was
        stolen from rasppp.

Arguments:

Return Value:

--*/

{
    HANDLE           hToken = NULL;
    TOKEN_STATISTICS TokenStats;
    DWORD            TokenStatsSize;
    DWORD            dwErr = ERROR_SUCCESS;
    
    //
    // Salamonian code to get LUID for authentication.
    // This is only required for "auto-logon"
    // authentication.
    //
    if (!OpenProcessToken(GetCurrentProcess(),
                          TOKEN_QUERY,
                          &hToken))
    {
        dwErr = GetLastError();
        goto done;
    }

    if (!GetTokenInformation(hToken,
                             TokenStatistics,
                             &TokenStats,
                             sizeof(TOKEN_STATISTICS),
                             &TokenStatsSize))
    {
        dwErr = GetLastError();
        goto done;
    }

    //
    // "This will tell us if there was an API failure
    // (means our buffer wasn't big enough)"
    //
    if (TokenStatsSize > sizeof(TOKEN_STATISTICS))
    {
        dwErr = GetLastError();
        goto done;
    }

    *pLuid = TokenStats.AuthenticationId;

done:
    if(NULL != hToken)
    {
        CloseHandle(hToken);
    }
    
    return dwErr;
}

VOID
SaveVpnStrategyInformation(RASCONNCB *prasconncb)
{
    DWORD dwVpnStrategy = prasconncb->pEntry->dwVpnStrategy;
    DWORD dwCurrentProt = prasconncb->dwCurrentVpnProt;

    RASAPI32_TRACE("SaveVpnStrategyInformation...");

    if(     (VS_PptpOnly == (dwVpnStrategy & 0x0000FFFF))
        ||  (VS_L2tpOnly == (dwVpnStrategy & 0x0000FFFF)))
    {
        goto done;
    }

    ASSERT(dwCurrentProt < NUMVPNPROTS);

    switch (prasconncb->ardtVpnProts[dwCurrentProt])
    {
        case RDT_Tunnel_Pptp:
        {
            RASAPI32_TRACE1("Saving %d as the vpn strategy",
                   VS_PptpFirst);

            prasconncb->pEntry->dwVpnStrategy = VS_PptpFirst;
            break;
        }

        case RDT_Tunnel_L2tp:
        {
            RASAPI32_TRACE1("Saving %d as the vpn strategy",
                   VS_L2tpFirst);

            prasconncb->pEntry->dwVpnStrategy = VS_L2tpFirst;
            break;
        }

        default:
        {
            ASSERT(FALSE);
        }
    }

    //
    // Dirty the entry so that this entry is saved
    // in OnRasDialEvent..
    //
    prasconncb->pEntry->fDirty = TRUE;

done:

    RASAPI32_TRACE("SaveVpnStrategyInformation done");

    return;
}

DWORD
DwPppSetCustomAuthData(RASCONNCB *prasconncb)
{
    DWORD retcode = SUCCESS;
    PBYTE pbBuffer = NULL;
    DWORD dwSize = 0;

    //
    // Get the connectiondata thats stashed away
    // in rasman
    //
    retcode = RasGetPortUserData(
                    prasconncb->hport,
                    PORT_CUSTOMAUTHDATA_INDEX,
                    NULL,
                    &dwSize);

    if(ERROR_BUFFER_TOO_SMALL != retcode)
    {
        goto done;
    }

    pbBuffer = Malloc(dwSize);

    if(NULL == pbBuffer)
    {
        retcode = GetLastError();
        goto done;
    }

    retcode = RasGetPortUserData(
                    prasconncb->hport,
                    PORT_CUSTOMAUTHDATA_INDEX,
                    pbBuffer,
                    &dwSize);

    if(SUCCESS != retcode)
    {
        goto done;
    }

    /*
    //
    // Free previous custom auth stuff if we have it.
    //
    Free0(prasconncb->pEntry->pCustomAuthData);
    

    //
    // Save the customauthdata
    //
    prasconncb->pEntry->cbCustomAuthData = dwSize;
    prasconncb->pEntry->pCustomAuthData = pbBuffer;
    */

    retcode = DwSetCustomAuthData(
            prasconncb->pEntry,
            dwSize,
            pbBuffer);

    if(ERROR_SUCCESS != retcode)
    {
        goto done;
    }
    
    prasconncb->pEntry->fDirty = TRUE;

done:

    if (pbBuffer)
    {
        Free(pbBuffer);
    }
    return retcode;
}

VOID
UpdateCachedCredentials(IN RASCONNCB* prasconncb)
{
    //
    //  Make sure we have a non-NULL pointer and that
    //  we are not operating at WinLogon (which the UPM_Logon
    //  signifies).
    //
    if (prasconncb  && (prasconncb->dwUserPrefMode != UPM_Logon))
    {
        DWORD dwIgnoredErr = 0;
        CHAR szUserNameA[UNLEN + 1] = {0};
        CHAR szPasswordA[PWLEN + 1] = {0};
        CHAR szDomainA[2* (DNLEN + 1)] = {0};

        RASAPI32_TRACE("RasSetCachedCredentials...");

        DecodePassword(
            prasconncb->rasdialparams.szPassword
            );

        strncpyTtoAAnsi(
            szUserNameA,
            prasconncb->rasdialparams.szUserName,
            sizeof(szUserNameA));

        strncpyTtoAAnsi(
            szPasswordA,
            prasconncb->rasdialparams.szPassword,
            sizeof(szPasswordA));

        strncpyTtoAAnsi(
            szDomainA,
            prasconncb->rasdialparams.szDomain,
            sizeof(szDomainA));

        dwIgnoredErr = g_pRasSetCachedCredentials(
            szUserNameA,
            szDomainA,
            szPasswordA);

        EncodePassword(
            prasconncb->rasdialparams.szPassword
            );

        RASAPI32_TRACE1("RasSetCachedCredentials done($%x)",
               dwIgnoredErr);

        prasconncb->fUpdateCachedCredentials = FALSE;
    }
}

RASCONNSTATE
RasDialMachine(
    IN RASCONNSTATE rasconnstate,
    IN RASCONNCB*   prasconncb,
    IN HANDLE       hEventAuto,
    IN HANDLE       hEventManual )

/*++

Routine Description:

        Executes 'rasconnstate'.  This routine always results
        in a "done" event on completion of each state, either
        directly (before returning) or by passing off the
        event to an asynchronous RAS Manager call.


Arguments:

        prasconncb - is the address of the control block.

        hEventAuto - is the auto-reset "done" event for passing
                     to asynchronous RAS Manager and Auth calls.

        hEventManual - is the manual-reset "done" event for
                       passing to asynchronous RasPpp calls.

Return Value:

        Returns the state that will be entered when/if the
        "done" event occurs and indicates success.

--*/

{
    DWORD        dwErr = 0;

    DWORD        dwExtErr = 0;

    BOOL         fAsyncState = FALSE;

    PBENTRY      *pEntry = prasconncb->pEntry;

    RASCONNSTATE rasconnstateNext = 0;

    RAS_CONNECTIONPARAMS params;

    BOOL         fEnteredCS = FALSE;

    switch (rasconnstate)
    {
        case RASCS_OpenPort:
        {
            RASAPI32_TRACE("RASCS_OpenPort");

            //
            // At this point, the current line in the HRASFILE
            // is assumed to be the section header of the
            // selected entry (or fDefaultEntry is true).
            // Set the domain parameter to the one in the
            // phonebook if caller does not specify a
            // domain or specifies "*".
            //
            if (    !prasconncb->fDefaultEntry
                &&  (   prasconncb->rasdialparams.szDomain[0]
                        == TEXT(' ')
                    ||  prasconncb->rasdialparams.szDomain[0]
                        == TEXT('*')))
            {
                lstrcpyn(prasconncb->rasdialparams.szDomain,
                         prasconncb->szDomain,
                         sizeof(prasconncb->rasdialparams.szDomain) /
                            sizeof(WCHAR));
            }

            //
            // check to see if the connection has already been
            // hung. If so then rasdialmachine is trying to dial a
            // connection which has already been hung. bail.
            //
            EnterCriticalSection(&csStopLock);

            fEnteredCS = TRUE;

            if (prasconncb->fTerminated)
            {
                dwErr = ERROR_PORT_NOT_AVAILABLE;

                RASAPI32_TRACE1(
                    "RasdialMachine: Trying to connect a "
                    "terminated connection!!. dwErr = %d",
                     dwErr);

                break;
            }

            //
            // Open the port including "any port" cases.
            //
            if ((dwErr = DwOpenPort(prasconncb)) != 0)
            {
                //
                // Copy the saved error if we couldn't open
                // the port
                //
                if(     ERROR_PORT_NOT_AVAILABLE == dwErr
                    &&  ERROR_SUCCESS != prasconncb->dwSavedError)
                {
                    dwErr = prasconncb->dwSavedError;
                    prasconncb->dwError = dwErr;
                }

                break;
             }

            //
            // Save the dialparamsuid with the port so that
            // rasman can get the password if required to
            // pass to ppp
            //
            RASAPI32_TRACE1("RasSetPortUserData(dialparamsuid) for %d",
                    prasconncb->hport);

            dwErr = RasSetPortUserData(
                prasconncb->hport,
                PORT_DIALPARAMSUID_INDEX,
                (PBYTE) &prasconncb->pEntry->dwDialParamsUID,
                sizeof(DWORD));

            RASAPI32_TRACE1("RasSetPortUserData returned %x", dwErr);
             

            //
            // Enable rasman events for this port.
            //
            if ((dwErr = EnableAsyncMachine(
                           prasconncb->hport,
                           &prasconncb->asyncmachine,
                           ASYNC_ENABLE_ALL)) != 0)
            {
                break;
            }

            //
            //Set the media parameters.
            //
            if ((dwErr = SetMediaParams(prasconncb)) != 0)
            {
                break;
            }

            //
            // Set the connection parameters for
            // bandwidth-on-demand, idle disconnect,
            // and redial-on-link-failure in rasman.
            //
            dwErr = ReadConnectionParamsFromEntry(prasconncb,
                                                  &params);
            if (dwErr)
            {
                break;
            }

            RASAPI32_TRACE("RasSetConnectionParams...");

            dwErr = g_pRasSetConnectionParams(prasconncb->hrasconn,
                                              &params);


            if (dwErr)
            {
                /*
                DWORD dwSavedErr = dwErr;

                //
                // It is possible we can fail the
                // RasSetConnectionParams call because
                // the caller has invoked RasHangUp in
                // another thread.  If this happens,
                // then neither the RasHangUp invoked
                // by the caller or the subsequent call
                // to RasDestroyConnection in
                // RasDialCleanUp will close
                // the port.  We close the
                // port here.
                //
                RASAPI32_TRACE1("RasPortClose(%d)...", prasconncb->hport);

                dwErr = g_pRasPortClose(prasconncb->hport);

                RASAPI32_TRACE1("RasPortClose(%d)", dwErr);

                //
                // Set dwErr back to the original error.
                //
                dwErr = dwSavedErr;

                */

                RASAPI32_TRACE1("RasSetConnectionParams(%d)", dwErr);

                break;

            }
            RASAPI32_TRACE1("RasSetConnectionParams(%d)", dwErr);

            //
            // Associate the port with the new connection
            // in rasman.
            //
            RASAPI32_TRACE2(
              "RasAddConnectionPort(%S,%d)...",
              prasconncb->szUserKey,
              prasconncb->rasdialparams.dwSubEntry);

            dwErr = g_pRasAddConnectionPort(
                      prasconncb->hrasconn,
                      prasconncb->hport,
                      prasconncb->rasdialparams.dwSubEntry);

            RASAPI32_TRACE1("RasAddConnectionPort(%d)", dwErr);

            if (dwErr)
            {
                break;
            }

            rasconnstateNext = RASCS_PortOpened;

            break;
        }

        case RASCS_PortOpened:
        {
            RASAPI32_TRACE("RASCS_PortOpened");

            //
            // Construct the phone number here so it
            // is available in the RASCS_ConnectDevice
            // state.
            //
            dwErr = ConstructPhoneNumber(prasconncb);
            if (dwErr)
            {
                break;
            }

            //
            // Loop connecting devices until there
            // are no more left.
            //
            rasconnstateNext =
                (   (prasconncb->fDefaultEntry
                ||  FindNextDevice(prasconncb)))
                    ? RASCS_ConnectDevice
                    : RASCS_AllDevicesConnected;
            break;
        }

        case RASCS_ConnectDevice:
        {
            TCHAR szType[ RAS_MAXLINEBUFLEN + 1 ];
            TCHAR szName[ RAS_MAXLINEBUFLEN + 1 ];
            BOOL fTerminal = FALSE;

            RASAPI32_TRACE("RASCS_ConnectDevice");

            if(     (prasconncb->pEntry->dwType == RASET_Vpn)
                &&  (0 == prasconncb->cAddresses))
            {
                CHAR *pszPhoneNumberA =
                        strdupTtoA(prasconncb->szPhoneNumber);
                        
                struct in_addr addr;

                if(NULL == pszPhoneNumberA)
                {
                    dwErr = E_OUTOFMEMORY;
                    break;
                }

                if(-1 == inet_addr(pszPhoneNumberA))
                {
                    _strlwr(pszPhoneNumberA);
                    RasSetAddressDisable(prasconncb->szPhoneNumber,
                                       TRUE);
                    
                    dwErr = DwRasGetHostByName(
                                pszPhoneNumberA,
                                &prasconncb->pAddresses,
                                &prasconncb->cAddresses);
                    
                    RasSetAddressDisable(prasconncb->szPhoneNumber,
                                       FALSE);

                    if(ERROR_SUCCESS != dwErr)
                    {
                        Free0(pszPhoneNumberA);
                        break;
                    }

                    prasconncb->iAddress = 1;                        
                    
                    RASAPI32_TRACE2("DwRasGetHostByName returned"
                        " cAddresses=%d for %ws",
                        prasconncb->cAddresses,
                        prasconncb->szPhoneNumber);

                }
                else
                {
                    prasconncb->pAddresses = LocalAlloc(LPTR, sizeof(DWORD));
                    if(NULL == prasconncb->pAddresses)
                    {
                        dwErr = GetLastError();

                        RASAPI32_TRACE1("Failed to allocate pAddresses. 0x%x",
                                dwErr);
                        Free0(pszPhoneNumberA);
                        break;                                
                    }

                    *prasconncb->pAddresses = inet_addr(pszPhoneNumberA);
                    prasconncb->cAddresses = 1;
                    prasconncb->iAddress = 1;
                    prasconncb->iAddress = 1;
                }

                Free0(pszPhoneNumberA);
            }

            //
            // Set device parameters for the device currently
            // connecting based on device subsection entries
            // and/or passed API parameters.
            //
            if (prasconncb->fDefaultEntry)
            {
                if ((dwErr =
                    SetDefaultDeviceParams(prasconncb,
                                           szType, szName )) != 0)
                {
                    break;
                }
            }
            else
            {
                if (    (dwErr = SetDeviceParams(
                            prasconncb, szType,
                            szName, &fTerminal )) != 0
                    &&  dwErr != ERROR_DEVICENAME_NOT_FOUND)
                {
                    break;
                }

                RASAPI32_TRACE3(
                  "SetDeviceParams(%S, %S, %d)",
                  szType,
                  szName,
                  fTerminal);

            }

            if (CaseInsensitiveMatch(szType, TEXT(MXS_MODEM_TXT)) == TRUE)
            {
                //
                // For modem's, get the callback delay from RAS
                // Manager and store in control block for use by
                // Authentication.
                //
                CHAR szTypeA[RAS_MaxDeviceType + 1];
                CHAR szNameA[RAS_MaxDeviceName + 1];
                CHAR* pszValue = NULL;
                LONG  lDelay = -1;

                strncpyTtoA(szTypeA, szType, sizeof(szTypeA));

                strncpyTtoA(szNameA, szName, sizeof(szNameA));

                if (GetRasDeviceString(
                            prasconncb->hport,
                            szTypeA, szNameA,
                            MXS_CALLBACKTIME_KEY,
                            &pszValue, XLATE_None ) == 0)
                {
                    lDelay = atol( pszValue );
                    Free( pszValue );
                }

                if (lDelay > 0)
                {
                    prasconncb->fUseCallbackDelay = TRUE;
                    prasconncb->wCallbackDelay = (WORD )lDelay;
                }

                prasconncb->fModem = TRUE;
            }
            else if (CaseInsensitiveMatch(szType, TEXT(ISDN_TXT)) == TRUE)
            {
                //
                // Need to know this for the PppThenAmb down-level
                // ISDN case.
                //
                prasconncb->fIsdn = TRUE;
                prasconncb->fUseCallbackDelay = TRUE;
                prasconncb->wCallbackDelay = 10;
            }

            //
            // The special switch name, "Terminal", sends the user
            // into interactive mode.
            //
            if (    (fTerminal)
                &&  (   (prasconncb->pEntry->dwCustomScript != 1)
                    ||  (!prasconncb->fUseCustomScripting)))
            {
                if (prasconncb->fAllowPause)
                {
                    rasconnstateNext = RASCS_Interactive;
                }
                else
                {
                    dwErr = ERROR_INTERACTIVE_MODE;
                }

                break;
            }

            //
            // Enable ipsec on the tunnel if its l2tp and
            // requires encryption
            //
            if(     (RASET_Vpn == prasconncb->pEntry->dwType)
                //&&  (prasconncb->pEntry->dwDataEncryption != DE_None)
                &&  (prasconncb->dwCurrentVpnProt < NUMVPNPROTS)
                &&  (RDT_Tunnel_L2tp == prasconncb->ardtVpnProts[
                                    prasconncb->dwCurrentVpnProt]))
            {
                DWORD dwStatus = ERROR_SUCCESS;
                RAS_L2TP_ENCRYPTION eDataEncryption = 0;
                
                if(DE_Require == 
                        prasconncb->pEntry->dwDataEncryption)
                {
                    eDataEncryption = RAS_L2TP_REQUIRE_ENCRYPTION;
                }
                else if (DE_RequireMax == 
                            prasconncb->pEntry->dwDataEncryption)
                {
                    eDataEncryption = RAS_L2TP_REQUIRE_MAX_ENCRYPTION;
                }
                else if(DE_IfPossible == 
                            prasconncb->pEntry->dwDataEncryption)
                {
                    eDataEncryption = RAS_L2TP_OPTIONAL_ENCRYPTION;
                }
                else if(DE_None ==
                            prasconncb->pEntry->dwDataEncryption)
                {
                    eDataEncryption = RAS_L2TP_NO_ENCRYPTION;
                }
                else
                {
                    ASSERT(FALSE);
                }

                //
                // Make the uid available to user so that
                // Presharedkey can be retrieved if required.
                //
                dwErr = RasSetPortUserData(
                    prasconncb->hport,
                    PORT_DIALPARAMSUID_INDEX,
                    (PBYTE) &prasconncb->pEntry->dwDialParamsUID,
                    sizeof(DWORD));
        
                RASAPI32_TRACE1("RasEnableIpSec(%d)..",
                        prasconncb->hport);

                dwErr = g_pRasEnableIpSec(prasconncb->hport,
                                          TRUE,
                                          FALSE,
                                          eDataEncryption);

                RASAPI32_TRACE1("RasEnableIpSec done. %d",
                       dwErr);

                if(     (ERROR_SUCCESS != dwErr)
                    &&  (eDataEncryption != RAS_L2TP_OPTIONAL_ENCRYPTION)
                    &&  (eDataEncryption != RAS_L2TP_NO_ENCRYPTION))
                {
                    break;
                }
                else
                {
                    //
                    // We ignore the error if its optional encryption and
                    // attempt to bring up the l2tp tunnel
                    //
                    dwErr = ERROR_SUCCESS;
                    
                }

                //
                // Do Ike now before we hit l2tp with a linemakecall
                //
                RASAPI32_TRACE1("RasDoIke on hport %d...", prasconncb->hport);
                dwErr = RasDoIke(NULL, prasconncb->hport, &dwStatus);
                RASAPI32_TRACE2("RasDoIke done. Err=0x%x, Status=0x%x",
                       dwErr,
                       dwStatus);

                if(ERROR_SUCCESS == dwErr)
                {
                    dwErr = dwStatus;
                }

                if(ERROR_SUCCESS != dwErr)
                {
                    break;
                }

                /*
                if(     (ERROR_SUCCESS != dwErr)
                    &&  (eDataEncryption != RAS_L2TP_OPTIONAL_ENCRYPTION)
                    &&  (eDataEncryption != RAS_L2TP_NO_ENCRYPTION))
                {
                    break;
                }
                else
                {
                    //
                    // We ignore the error if its optional encryption and
                    // attempt to bring up the l2tp tunnel
                    //
                    dwErr = ERROR_SUCCESS;
                    
                }
                */
            }

            RASAPI32_TRACE2("RasDeviceConnect(%S,%S)...",
                   szType,
                   szName);

            {
                CHAR szTypeA[RAS_MaxDeviceType + 1];
                CHAR szNameA[RAS_MaxDeviceName + 1];

                strncpyTtoA(szTypeA, szType, sizeof(szTypeA));
                strncpyTtoA(szNameA, szName, sizeof(szNameA));
                dwErr = g_pRasDeviceConnect(
                            prasconncb->hport,
                            szTypeA,
                            szNameA,
                            SECS_ConnectTimeout,
                            hEventAuto );
            }

            RASAPI32_TRACE1("RasDeviceConnect done(%d)",
                   dwErr);

            //
            // Mark this as an async operation only if
            // RasDeviceConnect returns PENDING
            //
            if (PENDING == dwErr)
            {
                fAsyncState = TRUE;
            }

            //
            // If RASMAN couldn't find the device and it is a
            // switch device and the name of the switch is an
            // existing disk-file, assume it is a dial-up script.
            //
            if (    (    (dwErr == ERROR_DEVICENAME_NOT_FOUND)
                    &&  (CaseInsensitiveMatch(szType,
                                              TEXT(MXS_SWITCH_TXT)) == TRUE)
                    &&  ((GetFileAttributes(szName) != 0xFFFFFFFF)
                    ||  (prasconncb->fUseCustomScripting))))
            {
                //
                // This is a switch device which RASMAN didn't
                // recognize, and which points to a valid
                // filename. It might be a Dial-Up script,
                // so we process it here
                //

                dwErr = NO_ERROR;
                fAsyncState = FALSE;


                if(     (1 == prasconncb->pEntry->dwCustomScript)
                    &&  (prasconncb->fUseCustomScripting))
                {
                    //
                    // Caller wants to run the custom script for this
                    // entry. Make the call out. Decode the password
                    // we stored before making the call out.
                    //
                    DecodePassword(
                        prasconncb->rasdialparams.szPassword);
                        
                    dwErr = DwCustomTerminalDlg(
                                prasconncb->pbfile.pszPath,
                                prasconncb->hrasconn,
                                prasconncb->pEntry,
                                prasconncb->hwndParent,
                                &prasconncb->rasdialparams,
                                NULL);

                    EncodePassword(
                        prasconncb->rasdialparams.szPassword);

                }
                else if(1 == prasconncb->pEntry->dwCustomScript)
                {
                    dwErr = ERROR_INTERACTIVE_MODE;
                    break;
                }
                
                //
                // If the caller doesn't allow pauses or doesn't
                // want to pause when a script is encountered,
                // handle the script; Otherwise, let the caller
                // process the script.
                //
                else if (    !prasconncb->fAllowPause
                    ||  !prasconncb->fPauseOnScript
                    ||  !fTerminal)
                {
                    //
                    // Caller won't handle script, run it ourselves
                    // and go into "DeviceConnected" mode
                    //

                    CHAR szIpAddress[17] = "";
                    CHAR szUserName[UNLEN+1], szPassword[PWLEN+1];

                    RASDIALPARAMS* pparams =
                                    &prasconncb->rasdialparams;


                    strncpyTtoAAnsi(
                        szUserName,
                        pparams->szUserName,
                        sizeof(szUserName));
                    DecodePassword(pparams->szPassword);
                    strncpyTtoAAnsi(
                        szPassword,
                        pparams->szPassword,
                        sizeof(szPassword));
                    EncodePassword(pparams->szPassword);

                    //
                    // Run the script
                    //
                    dwErr = RasScriptExecute(
                                (HRASCONN)prasconncb->hrasconn,
                                prasconncb->pEntry, szUserName,
                                szPassword, szIpAddress);

                    if (    dwErr == NO_ERROR
                        &&  szIpAddress[0])
                    {
                        Free0(prasconncb->pEntry->pszIpAddress);
                        prasconncb->pEntry->pszIpAddress =
                            strdupAtoT(szIpAddress);
                    }
                }
                else
                {
                    //
                    // Caller will handle script, go into
                    // interactive mode
                    //
                    rasconnstateNext = RASCS_Interactive;
                    break;
                }
            }
            else if (    dwErr != 0
                     &&  dwErr != PENDING)
            {
                break;
            }

            rasconnstateNext = RASCS_DeviceConnected;
            break;
        }

        case RASCS_DeviceConnected:
        {
            RASAPI32_TRACE("RASCS_DeviceConnected");

            //
            // Turn off hunt group functionality.
            //
            prasconncb->dwRestartOnError = 0;
            prasconncb->cPhoneNumbers = 0;

            //
            // Get the modem connect response and stash it in the
            // RASMAN user data.
            //
            if (prasconncb->fModem)
            {
                CHAR szTypeA[RAS_MaxDeviceType + 1],
                     szNameA[RAS_MaxDeviceName + 1];
                CHAR* psz = NULL;

                //
                // Assumption is made here that a modem will never
                // appear in the device chain unless it is the
                // physically attached device (excluding switches).
                //
                strncpyTtoA(szTypeA, prasconncb->szDeviceType, sizeof(szTypeA));

                strncpyTtoA(szNameA, prasconncb->szDeviceName, sizeof(szNameA));

                GetRasDeviceString(
                  prasconncb->hport,
                  szTypeA,
                  szNameA,
                  MXS_MESSAGE_KEY,
                  &psz,
                  XLATE_ErrorResponse );

                if (psz)
                {
                    dwErr = g_pRasSetPortUserData(
                              prasconncb->hport,
                              PORT_CONNRESPONSE_INDEX,
                              psz,
                              strlen(psz) + 1);

                    Free( psz );

                    if (dwErr)
                        break;
                }

                prasconncb->fModem = FALSE;
            }

            if(     (RASET_Vpn == prasconncb->pEntry->dwType)
                &&  (prasconncb->dwCurrentVpnProt < NUMVPNPROTS))
            {
                SaveVpnStrategyInformation(prasconncb);
            }

            rasconnstateNext =
                    (   !prasconncb->fDefaultEntry
                    &&  FindNextDevice(prasconncb))
                        ? RASCS_ConnectDevice
                        : RASCS_AllDevicesConnected;
            break;
        }

        case RASCS_AllDevicesConnected:
        {
            RASAPI32_TRACE("RASCS_AllDevicesConnected");

            RASAPI32_TRACE("RasPortConnectComplete...");

            dwErr = g_pRasPortConnectComplete(prasconncb->hport);

            RASAPI32_TRACE1("RasPortConnectComplete done(%d)", dwErr);

            if (dwErr != 0)
            {
                break;
            }

            {
                TCHAR* pszIpAddress = NULL;
                BOOL   fHeaderCompression = FALSE;
                BOOL   fPrioritizeRemote = TRUE;
                DWORD  dwFrameSize = 0;

                //
                // Scan the phonebook entry to see if this is a
                // SLIP entry and, if so, read the SLIP-related
                // fields.
                //
                if ((dwErr = ReadSlipInfoFromEntry(
                        prasconncb,
                        &pszIpAddress,
                        &fHeaderCompression,
                        &fPrioritizeRemote,
                        &dwFrameSize )) != 0)
                {
                    break;
                }

                if (pszIpAddress)
                {
                    //
                    // It's a SLIP entry.  Set framing based on
                    // user's choice of header compression.
                    //
                    RASAPI32_TRACE1(
                      "RasPortSetFraming(f=%d)...",
                      fHeaderCompression);

                    dwErr = g_pRasPortSetFraming(
                        prasconncb->hport,
                        (fHeaderCompression)
                        ? SLIPCOMP
                        : SLIPCOMPAUTO,
                        NULL, NULL );

                    RASAPI32_TRACE1("RasPortSetFraming done(%d)", dwErr);

                    if (dwErr != 0)
                    {
                        Free( pszIpAddress );
                        break;
                    }

                    //
                    // Tell the TCP/IP components about the SLIP
                    // connection, and activate the route.
                    //
                    dwErr = RouteSlip(
                        prasconncb, pszIpAddress,
                        fPrioritizeRemote,
                        dwFrameSize );

                    if (dwErr)
                    {
                        Free(pszIpAddress);
                        break;
                    }

                    //
                    // Update the projection information.
                    //
                    prasconncb->SlipProjection.dwError = 0;
                    lstrcpyn(
                        prasconncb->SlipProjection.szIpAddress,
                        pszIpAddress,
                        sizeof(prasconncb->SlipProjection.szIpAddress) /
                            sizeof(WCHAR));

                    Free( pszIpAddress );

                    if (dwErr != 0)
                    {
                        break;
                    }

                    //
                    // Copy the IP address into the SLIP
                    // projection results structure.
                    //
                    memset( &prasconncb->PppProjection,
                        '\0', sizeof(prasconncb->PppProjection) );

                    prasconncb->PppProjection.nbf.dwError =
                        prasconncb->PppProjection.ipx.dwError =
                        prasconncb->PppProjection.ip.dwError =
                            ERROR_PPP_NO_PROTOCOLS_CONFIGURED;

                    prasconncb->AmbProjection.Result =
                        ERROR_PROTOCOL_NOT_CONFIGURED;

                    prasconncb->AmbProjection.achName[ 0 ] = '\0';

                    RASAPI32_TRACE("SaveProjectionResults...");
                    dwErr = SaveProjectionResults(prasconncb);
                    RASAPI32_TRACE1("SaveProjectionResults(%d)", dwErr);

                    rasconnstateNext = RASCS_Connected;

                    Sleep(5);

                    break;
                }
            }

            rasconnstateNext = RASCS_Authenticate;
            break;
        }

        case RASCS_Authenticate:
        {
            RASDIALPARAMS* prasdialparams = &prasconncb->rasdialparams;
            LUID luid;

            RASAPI32_TRACE("RASCS_Authenticate");

            if (prasconncb->fPppMode)
            {
                RAS_FRAMING_INFO finfo;
                DWORD dwCallbackMode = 0;
                
                //
                // Set PPP framing.
                //
                memset((char* )&finfo, '\0', sizeof(finfo));

                finfo.RFI_SendACCM = finfo.RFI_RecvACCM =
                                                0xFFFFFFFF;

                finfo.RFI_MaxRSendFrameSize =
                    finfo.RFI_MaxRRecvFrameSize = 1600;

                finfo.RFI_SendFramingBits =
                    finfo.RFI_RecvFramingBits = PPP_FRAMING;

                RASAPI32_TRACE("RasPortSetFramingEx(PPP)...");

                dwErr = g_pRasPortSetFramingEx(prasconncb->hport, &finfo);

                RASAPI32_TRACE1("RasPortSetFramingEx done(%d)", dwErr);

                if (dwErr != 0)
                {
                    break;
                }

                //
                // If we are dialing simultaneous subentries,
                // then we have to synchronize the other subentries
                // with the first subentry to call PppStart.  This
                // is because if there is an authentication retry,
                // we only want the first subentry to get the
                // new credentials, allowing the other subentries
                // to bypass this state and use the new credentials
                // the first time around.
                //
                RASAPI32_TRACE2(
                  "subentry %d has suspend state %d",
                  prasconncb->rasdialparams.dwSubEntry,
                  prasconncb->dwfSuspended);

                if(prasconncb->dwfSuspended == SUSPEND_InProgress)
                {
                    RASAPI32_TRACE1(
                        "subentry %d waiting for authentication",
                        prasconncb->rasdialparams.dwSubEntry);
                        SuspendAsyncMachine(&prasconncb->asyncmachine,
                        TRUE);

                    //
                    // Set the next state to be equivalent
                    // to the current state, and don't let
                    // the client's notifier to be informed.
                    //
                    fAsyncState = TRUE;

                    rasconnstateNext = rasconnstate;
                    break;
                }
                else if (prasconncb->dwfSuspended == SUSPEND_Start)
                {
                    RASAPI32_TRACE1(
                      "subentry %d suspending all other subentries",
                      prasconncb->rasdialparams.dwSubEntry);
                    SuspendSubentries(prasconncb);

                    //
                    // Set this subentry as the master.  It
                    // will be the only subentry to do PPP
                    // authentication while the other subentries
                    // are suspended.
                    prasconncb->fMaster = TRUE;

                    prasconncb->dwfSuspended = SUSPEND_Master;
                }

                //
                // Start PPP authentication.
                // Fill in configuration parameters.
                //
                prasconncb->cinfo.dwConfigMask = 0;
                if (prasconncb->fUseCallbackDelay)
                {
                    prasconncb->cinfo.dwConfigMask
                        |= PPPCFG_UseCallbackDelay;
                }

                if (!prasconncb->fDisableSwCompression)
                {
                    prasconncb->cinfo.dwConfigMask
                        |= PPPCFG_UseSwCompression;
                }

                if (prasconncb->dwfPppProtocols & NP_Nbf)
                {
                    prasconncb->cinfo.dwConfigMask
                        |= PPPCFG_ProjectNbf;
                }

                if (prasconncb->dwfPppProtocols & NP_Ipx)
                {
                    prasconncb->cinfo.dwConfigMask
                        |= PPPCFG_ProjectIpx;
                }

                if (prasconncb->dwfPppProtocols & NP_Ip)
                {
                    prasconncb->cinfo.dwConfigMask
                        |= PPPCFG_ProjectIp;
                }

                //
                // [pmay] derive auth restrictions based on new flags
                //
                if (  prasconncb->pEntry->dwAuthRestrictions
                    & AR_F_AuthPAP)
                {
                    prasconncb->cinfo.dwConfigMask |=
                                PPPCFG_NegotiatePAP;
                }

                if (  prasconncb->pEntry->dwAuthRestrictions
                    & AR_F_AuthSPAP)
                {
                    prasconncb->cinfo.dwConfigMask |=
                                PPPCFG_NegotiateSPAP;
                }

                if (  prasconncb->pEntry->dwAuthRestrictions
                    & AR_F_AuthMD5CHAP)
                {
                    prasconncb->cinfo.dwConfigMask |=
                                PPPCFG_NegotiateMD5CHAP;
                }

                if (  prasconncb->pEntry->dwAuthRestrictions
                    & AR_F_AuthMSCHAP)
                {
                    prasconncb->cinfo.dwConfigMask |=
                                PPPCFG_NegotiateMSCHAP;
                }

                if (  prasconncb->pEntry->dwAuthRestrictions
                    & AR_F_AuthMSCHAP2)
                {
                    prasconncb->cinfo.dwConfigMask |=
                                PPPCFG_NegotiateStrongMSCHAP;
                }

                if ( prasconncb->pEntry->dwAuthRestrictions
                    & AR_F_AuthW95MSCHAP)
                {
                    prasconncb->cinfo.dwConfigMask |=
                                ( PPPCFG_UseLmPassword
                                | PPPCFG_NegotiateMSCHAP) ;
                }
                    

                if (  prasconncb->pEntry->dwAuthRestrictions
                    & AR_F_AuthEAP)
                {
                    prasconncb->cinfo.dwConfigMask |=
                                PPPCFG_NegotiateEAP;
                }

                if (DE_Require == prasconncb->pEntry->dwDataEncryption)
                {
                    if(     (RASET_Vpn != prasconncb->pEntry->dwType)
                        ||  (prasconncb->dwCurrentVpnProt < NUMVPNPROTS))
                    {                                            
                        prasconncb->cinfo.dwConfigMask
                            |= (  PPPCFG_RequireEncryption 
                                | PPPCFG_RequireStrongEncryption);
                    }                                
                                
                }
                else if (DE_RequireMax == prasconncb->pEntry->dwDataEncryption)
                {
                    if(     (RASET_Vpn != prasconncb->pEntry->dwType)
                        ||  (prasconncb->dwCurrentVpnProt < NUMVPNPROTS))
                    {                                            
                        prasconncb->cinfo.dwConfigMask 
                            |= PPPCFG_RequireStrongEncryption;
                    }
                }
                else if(DE_IfPossible == prasconncb->pEntry->dwDataEncryption)
                {
                    prasconncb->cinfo.dwConfigMask
                        &= ~(  PPPCFG_RequireEncryption
                             | PPPCFG_RequireStrongEncryption
                             | PPPCFG_DisableEncryption);
                }
                else if(prasconncb->pEntry->dwDataEncryption == DE_None)
                {
                    prasconncb->cinfo.dwConfigMask
                        |= PPPCFG_DisableEncryption;
                }

                if (prasconncb->fLcpExtensions)
                {
                    prasconncb->cinfo.dwConfigMask
                        |= PPPCFG_UseLcpExtensions;
                }

                if (   prasconncb->fMultilink
                    || prasconncb->pEntry->fNegotiateMultilinkAlways)
                {
                    prasconncb->cinfo.dwConfigMask
                        |= PPPCFG_NegotiateMultilink;
                }

                if (prasconncb->pEntry->fAuthenticateServer)
                {
                    prasconncb->cinfo.dwConfigMask
                        |= PPPCFG_AuthenticatePeer;
                }

                //
                // Set no bits if IfPossible
                //
                /*
                if(prasconncb->pEntry->dwDataEncryption == DE_IfPossible)
                {
                }

                */

                if(RASEDM_DialAsNeeded == prasconncb->pEntry->dwDialMode)
                {
                    if(DtlGetNodes(prasconncb->pEntry->pdtllistLinks) > 1)
                    {
                        prasconncb->cinfo.dwConfigMask
                            |= PPPCFG_NegotiateBacp;
                    }
                }

                if (prasconncb->pEntry->dwfOverridePref 
                    & RASOR_CallbackMode)
                {
                    dwCallbackMode = prasconncb->pEntry->dwCallbackMode;
                }
                else
                {
                    PBUSER pbuser;
                    
                    //
                    // Retrieve this from the user prefs
                    //
                    dwErr = g_pGetUserPreferences(
                                        NULL, 
                                        &pbuser, 
                                        prasconncb->dwUserPrefMode);

                    if(ERROR_SUCCESS != dwErr)
                    {   
                        RASAPI32_TRACE1("GetUserPrefs failed. rc=0x%x",
                               dwErr);

                        break;                               
                    }

                    dwCallbackMode = pbuser.dwCallbackMode;
                    
                    DestroyUserPreferences(&pbuser);
                }
                
                if (CBM_No == dwCallbackMode)
                {
                    prasconncb->cinfo.dwConfigMask
                            |= PPPCFG_NoCallback;
                }

                prasconncb->cinfo.dwCallbackDelay = 
                    (DWORD )prasconncb->wCallbackDelay;


                dwErr = ComputeLuid(&luid);

                if(*prasdialparams->szUserName == TEXT('\0'))
                {
                    if(ERROR_SUCCESS != dwErr)
                    {
                        break;
                    }

                    CopyMemory(&prasconncb->luid, &luid, sizeof(LUID));
                }

                if(ERROR_SUCCESS == dwErr)
                {
                    dwErr = g_pRasSetConnectionUserData(
                                prasconncb->hrasconn,
                                CONNECTION_LUID_INDEX,
                                (PBYTE) &luid,
                                sizeof(LUID));
                }
                
#if 0                
                //
                // Compute a luid for PPP if the
                // szUserName is NULL.
                //
                if (*prasdialparams->szUserName == TEXT('\0'))
                {
                    dwErr = ComputeLuid(&prasconncb->luid);

                    if (dwErr)
                    {
                        break;
                    }
                }

                //
                // Save the dialparamsuid with the port so that
                // rasman can get the password if required to
                // pass to ppp
                //
                RASAPI32_TRACE1("RasSetPortUserData(dialparamsuid) for %d",
                        prasconncb->hport);

                dwErr = RasSetPortUserData(
                    prasconncb->hport,
                    PORT_DIALPARAMSUID_INDEX,
                    (PBYTE) &prasconncb->pEntry->dwDialParamsUID,
                    sizeof(DWORD));

                RASAPI32_TRACE1("RasSetPortUserData returned %x", dwErr);

                //
                // This is not fatal.
                // 
                dwErr = 0;

#endif                
                /*

                if(     (RASET_Vpn == prasconncb->pEntry->dwType)
                    &&  (DE_Require ==
                        & prasconncb->pEntry->dwDataEncryption))
                {
                    prasconncb->cinfo.dwConfigMask |=
                            (   PPPCFG_RequireEncryption
                            |   PPPCFG_RequireStrongEncryption);
                }

                */

                RASAPI32_TRACE1(
                  "RasPppStart(cfg=%d)...",
                  prasconncb->cinfo.dwConfigMask);

                {
                    CHAR szUserNameA[UNLEN + 1],
                         szPasswordA[PWLEN + 1];

                    CHAR szDomainA[2 * (DNLEN + 1)];

                    CHAR szPortNameA[MAX_PORT_NAME + 1];

                    CHAR szPhonebookPath[ MAX_PATH ];

                    CHAR szEntryName[ MAX_ENTRYNAME_SIZE ];

                    CHAR szPhoneNumber[ RAS_MaxPhoneNumber + 1];

                    PPP_BAPPARAMS BapParams;

                    DWORD dwFlags = 0;

                    DWORD cbData = 0;
                    PBYTE pbData = NULL;

                    DWORD dwSubEntries;

                    //
                    // Set PhonebookPath and EntryName in rasman
                    //
                    strncpyTtoAAnsi(
                        szPhonebookPath,
                        prasconncb->pbfile.pszPath,
                        sizeof(szPhonebookPath));

                    strncpyTtoAAnsi(
                        szEntryName,
                        prasconncb->pEntry->pszEntryName,
                        sizeof(szEntryName));

                    strncpyTtoAAnsi(
                        szPhoneNumber,
                        prasconncb->szPhoneNumber,
                        sizeof(szPhoneNumber));

                    RASAPI32_TRACE1(
                        "RasSetRasdialInfo %d...",
                        prasconncb->hport);

                    dwErr = DwGetCustomAuthData(
                                prasconncb->pEntry,
                                &cbData,
                                &pbData);

                    if(ERROR_SUCCESS != dwErr)
                    {
                        RASAPI32_TRACE1("DwGetCustomAuthData failed. 0x%x",
                                dwErr);

                        break; 
                    }

                    dwErr = g_pRasSetRasdialInfo(
                            prasconncb->hport,
                            szPhonebookPath,
                            szEntryName,
                            szPhoneNumber,
                            cbData,
                            pbData);

                    RASAPI32_TRACE2("RasSetRasdialInfo %d done. e = %d",
                                prasconncb->hport, dwErr);

                    if (dwErr)
                    {
                        break;
                    }

                    if(     (prasconncb->pEntry->dwTcpWindowSize >= 0x1000)
                      &&   (prasconncb->pEntry->dwTcpWindowSize <= 0xFFFF))
                    {                      
                        //
                        // Save the tcp window size with rasman
                        //
                        dwErr = g_pRasSetConnectionUserData(
                                    prasconncb->hrasconn,
                                    CONNECTION_TCPWINDOWSIZE_INDEX,
                                    (PBYTE) &prasconncb->pEntry->dwTcpWindowSize,
                                    sizeof(DWORD));
                    }                                
                                

                    if(prasconncb->RasEapInfo.dwSizeofEapInfo)
                    {
                        RASAPI32_TRACE1("RasSetEapLogonInfo %d...",
                                prasconncb->hport);

                        dwErr = g_pRasSetEapLogonInfo(
                                prasconncb->hport,
                                (UPM_Logon == prasconncb->dwUserPrefMode),
                                &prasconncb->RasEapInfo);

                        RASAPI32_TRACE3("RasSetEapLogonInfo %d(upm=%d) done. e=%d",
                                prasconncb->hport,
                                prasconncb->dwUserPrefMode,
                                dwErr);
                    }

                    if(dwErr)
                    {
                        break;
                    }

                    DecodePassword(prasdialparams->szPassword);

                    strncpyTtoAAnsi(
                        szUserNameA,
                        prasdialparams->szUserName,
                        sizeof(szUserNameA));

                    strncpyTtoAAnsi(
                        szPasswordA,
                        prasdialparams->szPassword,
                        sizeof(szPasswordA));

                    strncpyWtoAAnsi(
                        szDomainA,
                        prasdialparams->szDomain,
                        sizeof(szDomainA));

                    if (!pEntry->fAutoLogon
                        && szUserNameA[ 0 ] == '\0'
                        && szPasswordA[ 0 ] == '\0')
                    {
                        if(pEntry->dwType == RASET_Direct)
                        {
                            // Windows9x DCC implements "no password mode"
                            // as doing authentication and checking for 
                            // no password, rather than just not authenti
                            // cating (don't ask me why).  This creates a 
                            // conflict with the RasDial API definition of
                            // empty username and password mapping to "use
                            // Windows credentials".  Workaround that here
                            // by substituting "guest" for the username.
                            //
                            lstrcpyA(szUserNameA, "guest");
                        }
                    }

                    /*

                    // Windows9x DCC implements "no password mode" as doing
                    // authentication and checking for no password, rather
                    // than just not authenticating (don't ask me why).  This
                    // creates a conflict with the RasDial API definition of
                    // empty username and password mapping to "use Windows
                    // credentials".  Workaround that here by substituting
                    // "guest" for the username.
                    //
                    if (pEntry->dwType == RASET_Direct
                        && !pEntry->fAutoLogon
                        && szUserNameA[ 0 ] == '\0'
                        && szPasswordA[ 0 ] == '\0')
                    {
                        lstrcpyA( szUserNameA, "guest" );
                    }

                    */

                    strncpyTtoA(
                        szPortNameA,
                        prasconncb->szPortName,
                        sizeof(szPortNameA));

                    dwSubEntries =
                        DtlGetNodes(prasconncb->pEntry->pdtllistLinks);

                    if(dwSubEntries > 1)
                    {
                        BapParams.dwDialMode =
                            prasconncb->pEntry->dwDialMode;
                    }
                    else
                    {
                        BapParams.dwDialMode = RASEDM_DialAll;
                    }

                    BapParams.dwDialExtraPercent =
                              prasconncb->pEntry->dwDialPercent;

                    BapParams.dwDialExtraSampleSeconds =
                               prasconncb->pEntry->dwDialSeconds;

                    BapParams.dwHangUpExtraPercent =
                               prasconncb->pEntry->dwHangUpPercent;

                    BapParams.dwHangUpExtraSampleSeconds =
                               prasconncb->pEntry->dwHangUpSeconds;

                    if(     ((!prasconncb->pEntry->fShareMsFilePrint)
                         &&   (!prasconncb->pEntry->fBindMsNetClient))
                        ||  (prasconncb->pEntry->dwIpNbtFlags == 0)) 
                    {
                        dwFlags |= PPPFLAGS_DisableNetbt;
                    }

                    dwErr = g_pRasPppStart(
                          prasconncb->hport,
                          szPortNameA,
                          szUserNameA,
                          szPasswordA,
                          szDomainA,
                          &prasconncb->luid,
                          &prasconncb->cinfo,
                          (LPVOID)prasconncb->reserved,
                          prasconncb->szzPppParameters,
                          FALSE,
                          hEventManual,
                          prasconncb->dwIdleDisconnectSeconds,
                          (prasconncb->pEntry->fRedialOnLinkFailure)
                          ? TRUE : FALSE,
                          &BapParams,
                          !(prasconncb->fAllowPause),
                          prasconncb->pEntry->dwCustomAuthKey,
                          dwFlags);

                    EncodePassword(prasdialparams->szPassword);
                }

                RASAPI32_TRACE1("RasPppStart done(%d)", dwErr);
            }
            else
            {
                AUTH_CONFIGURATION_INFO info;

                //
                // Set RAS framing.
                //
                RASAPI32_TRACE("RasPortSetFraming(RAS)...");

                dwErr = g_pRasPortSetFraming(
                    prasconncb->hport, RAS, NULL, NULL );

                RASAPI32_TRACE1("RasPortSetFraming done(%d)", dwErr);

                if (dwErr != 0)
                {
                    break;
                }

                //
                // Load rascauth.dll.
                //
                dwErr = LoadRasAuthDll();
                if (dwErr != 0)
                {
                    break;
                }

                //
                // Start AMB authentication.
                //
                info.Protocol = ASYBEUI;

                info.NetHandle = (DWORD )-1;

                info.fUseCallbackDelay =
                        prasconncb->fUseCallbackDelay;

                info.CallbackDelay =
                        prasconncb->wCallbackDelay;

                info.fUseSoftwareCompression =
                    !prasconncb->fDisableSwCompression;

                info.fForceDataEncryption =
                    prasconncb->fRequireEncryption;

                info.fProjectIp = FALSE;

                info.fProjectIpx = FALSE;

                info.fProjectNbf = TRUE;

                RASAPI32_TRACE("AuthStart...");

                {
                    CHAR szUserNameA[UNLEN + 1],
                         szPasswordA[PWLEN + 1];

                    CHAR szDomainA[2 * (DNLEN + 1)];

                    DecodePassword(prasdialparams->szPassword);

                    strncpyTtoAAnsi(
                        szUserNameA,
                        prasdialparams->szUserName,
                        sizeof(szUserNameA));

                    strncpyTtoAAnsi(
                        szPasswordA,
                        prasdialparams->szPassword,
                        sizeof(szPasswordA));

                    strncpyTtoAAnsi(
                        szDomainA,
                        prasdialparams->szDomain,
                        sizeof(szDomainA));

                    dwErr = g_pAuthStart(
                              prasconncb->hport,
                              szUserNameA,
                              szPasswordA,
                              szDomainA,
                              &info,
                              hEventAuto );

                    EncodePassword(prasdialparams->szPassword);
                }

                RASAPI32_TRACE1("AuthStart done(%d)n", dwErr);

                //
                // In case we failed-over from PPP, make sure
                // the PPP event isn't set.
                //
                ResetEvent(hEventManual);
            }

            if (dwErr != 0)
            {
                break;
            }

            fAsyncState = TRUE;
            rasconnstateNext = RASCS_AuthNotify;
            break;
        }

        case RASCS_AuthNotify:
        {
            if (prasconncb->fPppMode)
            {
                PPP_MESSAGE msg;

                RASAPI32_TRACE("RASCS_AuthNotify");

                RASAPI32_TRACE("RasPppGetInfo...");

                dwErr = g_pRasPppGetInfo(prasconncb->hport, &msg);

                RASAPI32_TRACE2(
                  "RasPppGetInfo done(%d), dwMsgId=%d",
                  dwErr,
                  msg.dwMsgId);

                //
                // If we ever get an error from RasPppGetInfo,
                // it is fatal, and we should report the link
                // as disconnected.
                //
                if (dwErr != 0)
                {
                    RASAPI32_TRACE("RasPppGetInfo failed; terminating link");
                    dwErr = ERROR_REMOTE_DISCONNECTION;
                    break;
                }

                switch (msg.dwMsgId)
                {

                    case PPPMSG_PppDone:
                        rasconnstateNext = RASCS_Authenticated;

                        break;

                    case PPPMSG_PppFailure:
                        dwErr = msg.ExtraInfo.Failure.dwError;

#ifdef AMB
                        if (    prasconncb->dwAuthentication
                                == AS_PppThenAmb
                            &&  dwErr == ERROR_PPP_NO_RESPONSE)
                        {
                            //
                            // Not a PPP server.  Restart
                            // authentiation in AMB mode.
                            //
                            RASAPI32_TRACE("No response, try AMB");

                            //
                            // Terminate the PPP connection since
                            // we are going to now try AMB.
                            //
                            RASAPI32_TRACE("RasPppStop...");

                            dwErr = g_pRasPppStop(prasconncb->hport);

                            RASAPI32_TRACE1("RasPppStop(%d)", dwErr);

                            //
                            // Only failover to AMB for non-multilink
                            // connection attempts.
                            //
                            if (!prasconncb->fMultilink)
                            {
                                dwErr = 0;
                                prasconncb->fPppMode = FALSE;
                                rasconnstateNext = RASCS_Authenticate;
                            }
                            else
                            {
                                dwErr = ERROR_PPP_NO_RESPONSE;
                            }
                            break;
                        }
#endif

                        dwExtErr =
                            msg.ExtraInfo.Failure.dwExtendedError;

                        break;

                    case PPPMSG_AuthRetry:
                        if (prasconncb->fAllowPause)
                        {
                            rasconnstateNext =
                                    RASCS_RetryAuthentication;
                        }
                        else
                        {
                            dwErr = ERROR_AUTHENTICATION_FAILURE;
                        }

                        break;

                   case PPPMSG_Projecting:
                        if (prasconncb->fUpdateCachedCredentials)
                        {
                           //
                           // If we get here, a change-password or
                           // retry-authentication operation
                           // affecting the currently logged
                           // on user's credentials has
                           // succeeded.
                           //
                           UpdateCachedCredentials(prasconncb);
                         }

                         rasconnstateNext = RASCS_AuthProject;
                         break;

                    case PPPMSG_InvokeEapUI:
                    {
                        if (prasconncb->fAllowPause)
                        {
                            rasconnstateNext = RASCS_InvokeEapUI;
                        }
                        else
                        {
                            RASAPI32_TRACE("RDM: Cannot Invoke EapUI if "
                                  "pausedstates are not allowed");

                            dwErr = ERROR_INTERACTIVE_MODE;

                            break;
                        }

                        if (0xFFFFFFFF == prasconncb->reserved1)
                        {
                            RASAPI32_TRACE("RDM: Cannot invoke eap ui for a "
                                  "4.0 app running on nt5");

                            dwErr = ERROR_AUTHENTICATION_FAILURE;

                            break;
                        }

                        prasconncb->fPppEapMode = TRUE;

                        break;
                    }

                    case PPPMSG_ProjectionResult:
                    {
                        //
                        // Stash the full projection result for
                        // retrieval with RasGetProjectionResult.
                        // PPP and AMB are mutually exclusive so
                        // set AMB to "none".
                        //

                        RASAPI32_TRACE(
                        "RASCS_AuthNotify:PPPMSG_ProjectionResult"
                        );

                        prasconncb->AmbProjection.Result =
                            ERROR_PROTOCOL_NOT_CONFIGURED;

                        prasconncb->AmbProjection.achName[0] = '\0';

                        prasconncb->SlipProjection.dwError =

                            ERROR_PROTOCOL_NOT_CONFIGURED;

                        memcpy(
                            &prasconncb->PppProjection,
                            &msg.ExtraInfo.ProjectionResult,
                            sizeof(prasconncb->PppProjection) );

                        RASAPI32_TRACE1(
                            "hportBundleMember=%d",
                            prasconncb->PppProjection.lcp.hportBundleMember);

                        if (prasconncb->PppProjection.lcp.hportBundleMember
                                != INVALID_HPORT)
                        {
                            //
                            // We want caller to be able to determine the
                            // new connection was bundled.  We first save
                            // the hport away for later use.
                            //
                            prasconncb->hportBundled =
                            prasconncb->PppProjection.lcp.hportBundleMember;

                            prasconncb->PppProjection.lcp.hportBundleMember =
                                (HPORT) 1;
                        }
                        else
                        {
                            //
                            // Ansi-ize the NetBIOS name.
                            //
                            // Whistler bug 292981 rasapi32.dll prefast
                            // warnings
                            //
                            OemToCharBuffA(
                                prasconncb->PppProjection.nbf.szName,
                                prasconncb->PppProjection.nbf.szName,
                                strlen(prasconncb->PppProjection.nbf.szName)
                                    + 1 );
                        }

                        RASAPI32_TRACE4(
                          "fPppMode=%d, fBundled=%d, hportBundled=%d, "
                          "hportBundleMember=%d",
                          prasconncb->fPppMode,
                          prasconncb->fBundled,
                          prasconncb->hportBundled,
                          prasconncb->PppProjection.lcp.hportBundleMember);

                        if (prasconncb->PppProjection.lcp.hportBundleMember
                            == INVALID_HPORT)
                        {
                            if (prasconncb->fBundled)
                            {
                                //
                                // If another link has already received
                                // complete projection information, then
                                // the server doesn't support multilink,
                                // and we have to drop the link.
                                //
                                RASAPI32_TRACE(
                                  "Multilink subentry not bundled; "
                                  "terminating link");

                                dwErr = ERROR_REMOTE_DISCONNECTION;

                                break;
                            }
                            else
                            {
                                SetSubentriesBundled(prasconncb);
                                //
                                // Save the projection results in
                                // rasman.
                                //
                                RASAPI32_TRACE("SaveProjectionResults...");
                                dwErr = SaveProjectionResults(prasconncb);
                                RASAPI32_TRACE1(
                                  "SaveProjectionResults(%d)",
                                  dwErr);

                                if (dwErr)
                                {
                                    break;
                                }
                            }
                        }

                        prasconncb->fProjectionComplete = TRUE;
                        rasconnstateNext = RASCS_Projected;
                        break;
                    }

                    case PPPMSG_CallbackRequest:
                        rasconnstateNext = RASCS_AuthCallback;
                        break;

                    case PPPMSG_Callback:
                        rasconnstateNext = RASCS_PrepareForCallback;
                        break;

                    case PPPMSG_ChangePwRequest:
                        if (prasconncb->fAllowPause)
                        {
                            rasconnstateNext = RASCS_PasswordExpired;
                        }
                        else
                        {
                            dwErr = ERROR_PASSWD_EXPIRED;
                        }
                        break;

                    case PPPMSG_LinkSpeed:
                        rasconnstateNext = RASCS_AuthLinkSpeed;
                        break;

                    case PPPMSG_Progress:
                        rasconnstateNext = RASCS_AuthNotify;
                        fAsyncState = TRUE;
                        break;

                    case PPPMSG_SetCustomAuthData:
                    {
                        RASAPI32_TRACE("dwSetcustomAuthData..");
                        dwErr = DwPppSetCustomAuthData(prasconncb);
                        RASAPI32_TRACE1("dwSetCustomAuthData. rc=0x%x",
                                dwErr);
                                
                        //
                        // The error is not fatal.
                        //
                        dwErr = ERROR_SUCCESS;
                        fAsyncState = TRUE;
                        rasconnstateNext = RASCS_AuthNotify;
                        break;
                    }

                    default:

                        //
                        // Should not happen.
                        //
                        RASAPI32_TRACE1("Invalid PPP auth state=%d", msg.dwMsgId);
                        dwErr = ERROR_INVALID_AUTH_STATE;
                        break;
                }
            }
            else
            {
                AUTH_CLIENT_INFO info;

                RASAPI32_TRACE("RASCS_AuthNotify");

                RASAPI32_TRACE("AuthGetInfo...");

                g_pAuthGetInfo( prasconncb->hport, &info );

                RASAPI32_TRACE1("AuthGetInfo done, type=%d", info.wInfoType);

                switch (info.wInfoType)
                {
                    case AUTH_DONE:
                        prasconncb->fServerIsPppCapable =
                            info.DoneInfo.fPppCapable;

                        rasconnstateNext = RASCS_Authenticated;

                        break;

                    case AUTH_RETRY_NOTIFY:
                        if (prasconncb->fAllowPause)
                        {
                            rasconnstateNext = RASCS_RetryAuthentication;
                        }
                        else
                        {
                            dwErr = ERROR_AUTHENTICATION_FAILURE;
                        }

                        break;

                    case AUTH_FAILURE:
                        dwErr = info.FailureInfo.Result;
                        dwExtErr = info.FailureInfo.ExtraInfo;
                        break;

                    case AUTH_PROJ_RESULT:
                    {
                        //
                        // Save the projection result for retrieval
                        // with RasGetProjectionResult.  AMB and PPP
                        // projection are mutually exclusive so set
                        // PPP projection to "none".
                        //
                        memset(
                            &prasconncb->PppProjection, '\0',
                            sizeof(prasconncb->PppProjection) );

                        prasconncb->PppProjection.nbf.dwError =
                            prasconncb->PppProjection.ipx.dwError =
                            prasconncb->PppProjection.ip.dwError =
                                ERROR_PPP_NO_PROTOCOLS_CONFIGURED;

                        prasconncb->SlipProjection.dwError =
                            ERROR_PROTOCOL_NOT_CONFIGURED;

                        if (info.ProjResult.NbProjected)
                        {
                            prasconncb->AmbProjection.Result = 0;
                            prasconncb->AmbProjection.achName[0] = '\0';
                        }
                        else
                        {
                            memcpy(
                                &prasconncb->AmbProjection,
                                &info.ProjResult.NbInfo,
                                sizeof(prasconncb->AmbProjection) );

                            if (prasconncb->AmbProjection.Result == 0)
                            {
                                //
                                // Should not happen according to
                                // MikeSa (but did once).
                                //
                                prasconncb->AmbProjection.Result =
                                    ERROR_UNKNOWN;
                            }
                            else if (prasconncb->AmbProjection.Result
                                     == ERROR_NAME_EXISTS_ON_NET)
                            {
                                //
                                // Ansi-ize the NetBIOS name.
                                //
                                // Whistler bug 292981 rasapi32.dll prefast
                                // warnings
                                //
                                OemToCharBuffA(
                                    prasconncb->AmbProjection.achName,
                                    prasconncb->AmbProjection.achName,
                                    strlen(prasconncb->AmbProjection.achName)
                                        + 1 );
                            }
                        }

                        //
                        // Save the projection results in
                        // rasman.
                        //
                        RASAPI32_TRACE("SaveProjectionResults...");
                        dwErr = SaveProjectionResults(prasconncb);
                        RASAPI32_TRACE1("SaveProjectionResults(%d)", dwErr);

                        if (dwErr)
                        {
                            break;
                        }

                        prasconncb->fProjectionComplete = TRUE;
                        rasconnstateNext = RASCS_Projected;
                        break;
                    }

                    case AUTH_REQUEST_CALLBACK_DATA:
                        rasconnstateNext = RASCS_AuthCallback;
                        break;

                    case AUTH_CALLBACK_NOTIFY:
                        rasconnstateNext = RASCS_PrepareForCallback;
                        break;

                    case AUTH_CHANGE_PASSWORD_NOTIFY:
                        if (prasconncb->fAllowPause)
                            rasconnstateNext = RASCS_PasswordExpired;
                        else
                            dwErr = ERROR_PASSWD_EXPIRED;
                        break;

                    case AUTH_PROJECTING_NOTIFY:
                        rasconnstateNext = RASCS_AuthProject;
                        break;

                    case AUTH_LINK_SPEED_NOTIFY:
                        rasconnstateNext = RASCS_AuthLinkSpeed;
                        break;

                    default:
                        //
                        // Should not happen.
                        //
                        RASAPI32_TRACE1("Invalid AMB auth state=%d",
                                info.wInfoType);

                        dwErr = ERROR_INVALID_AUTH_STATE;
                        break;
                }
            }


            break;
        }

        case RASCS_AuthRetry:
        {
            RASDIALPARAMS* prasdialparams =
                    &prasconncb->rasdialparams;

            RASAPI32_TRACE("RASCS_AuthRetry");

            if (prasconncb->fPppMode)
            {
                if (    0xFFFFFFFF != prasconncb->reserved1
                    &&  0 != prasconncb->reserved1 )
                {
                    s_InvokeEapUI *pInfo = (s_InvokeEapUI *)
                                            prasconncb->reserved1;

                    RASAPI32_TRACE("RasPppSetEapInfo...");

                    //
                    // We came here from RASCS_InvokeEapUI. Set the
                    // information with PPP
                    //
                    dwErr = g_pRasPppSetEapInfo(
                                 prasconncb->hport,
                                 pInfo->dwContextId,
                                 pInfo->dwSizeOfUIContextData,
                                 pInfo->pUIContextData);

                    RASAPI32_TRACE1("RasPppSetEapInfo done(%d)", dwErr);

                    if ( 0 == dwErr )
                    {
                        LocalFree(pInfo->pUIContextData);
                        LocalFree(pInfo);
                    }

                    prasconncb->fPppEapMode = FALSE;

                    prasconncb->reserved1 = 0;
                }
                else
                {

                    CHAR szUserNameA[UNLEN + 1], szPasswordA[PWLEN + 1];
                    CHAR szDomainA[2 * (DNLEN + 1)];

                    RASAPI32_TRACE("RasPppRetry...");
                    DecodePassword(prasdialparams->szPassword);

                    strncpyTtoAAnsi(
                        szUserNameA,
                        prasdialparams->szUserName,
                        sizeof(szUserNameA));

                    strncpyTtoAAnsi(
                        szPasswordA,
                        prasdialparams->szPassword,
                        sizeof(szPasswordA));

                    strncpyTtoAAnsi(
                        szDomainA,
                        prasdialparams->szDomain,
                        sizeof(szDomainA));

                    dwErr = g_pRasPppRetry(
                        prasconncb->hport,
                        szUserNameA,
                        szPasswordA,
                        szDomainA );

                    EncodePassword(prasdialparams->szPassword);

                    RASAPI32_TRACE1("RasPppRetry done(%d)", dwErr);
                }


                if (dwErr != 0)
                {
                    break;
                }
            }
#ifdef AMB
            else
            {
                RASAPI32_TRACE("AuthRetry...");

                {
                    CHAR szUserNameA[UNLEN + 1],
                         szPasswordA[PWLEN + 1];
                    CHAR szDomainA[2 * (DNLEN + 1)];

                    DecodePassword(prasdialparams->szPassword);

                    strncpyTtoAAnsi(
                        szUserNameA,
                        prasdialparams->szUserName,
                        sizeof(szUserNameA));

                    strncpyTtoAAnsi(
                        szPasswordA,
                        prasdialparams->szPassword,
                        sizeof(szPasswordA));

                    strncpyTtoAAnsi(
                        szDomainA,
                        prasdialparams->szDomain,
                        sizeof(szDomainA));

                    g_pAuthRetry(
                        prasconncb->hport,
                        szUserNameA,
                        szPasswordA,
                        szDomainA );

                    EncodePassword(prasdialparams->szPassword);

                }

                RASAPI32_TRACE("AuthRetry done");
            }
#endif

            //
            // Set this flag to prevent us from saving
            // the previous credentials over the new
            // ones the caller may have just set.
            //
            prasconncb->fRetryAuthentication = TRUE;

            fAsyncState = TRUE;
            rasconnstateNext = RASCS_AuthNotify;
            break;
        }

        case RASCS_AuthCallback:
        {
            RASDIALPARAMS* prasdialparams =
                    &prasconncb->rasdialparams;

            RASAPI32_TRACE("RASCS_AuthCallback");

            if (lstrcmp(prasdialparams->szCallbackNumber,
                        TEXT("*") ) == 0)
            {
                PBUSER pbuser;
                DWORD  dwCallbackMode;

                //
                // API caller says he wants to be prompted for a
                // callback number.
                //
                RASAPI32_TRACE("GetUserPreferences");
                dwErr = GetUserPreferences(
                                NULL,
                                &pbuser,
                                prasconncb->dwUserPrefMode);

                RASAPI32_TRACE1("GetUserPreferences=%d", dwErr);

                if (dwErr)
                {
                    break;
                }

                if (prasconncb->pEntry->dwfOverridePref
                    & RASOR_CallbackMode)
                {
                    dwCallbackMode =
                        prasconncb->pEntry->dwCallbackMode;
                }
                else
                {
                    dwCallbackMode = pbuser.dwCallbackMode;
                }

                RASAPI32_TRACE1("dwCallbackMode=%d", dwCallbackMode);

                //
                // Determine the callback number.
                //
                switch (dwCallbackMode)
                {
                case CBM_Yes:
                    if (GetCallbackNumber(prasconncb, &pbuser))
                    {
                        break;
                    }

                    // fall through
                case CBM_No:
                    prasdialparams->szCallbackNumber[0]
                                    = TEXT('\0');
                    break;

                case CBM_Maybe:
                    if (prasconncb->fAllowPause)
                    {
                        rasconnstateNext =
                                RASCS_CallbackSetByCaller;
                    }
                    else
                    {
                        dwErr = ERROR_BAD_CALLBACK_NUMBER;
                    }
                    break;
                }

                //
                // Free user preferences block.
                //
                DestroyUserPreferences(&pbuser);

            }
            if (    !dwErr
                &&  rasconnstateNext != RASCS_CallbackSetByCaller)
            {
                //
                // Send the server the callback number or an empty
                // string to indicate no callback.  Then, re-enter
                // Authenticate state since the server will signal
                // the event again.
                //
                if (prasconncb->fPppMode)
                {
                    RASAPI32_TRACE("RasPppCallback...");

                    {
                        CHAR szCallbackNumberA[RAS_MaxCallbackNumber + 1];

                        strncpyTtoA(
                            szCallbackNumberA,
                            prasdialparams->szCallbackNumber,
                            sizeof(szCallbackNumberA));

                        dwErr = g_pRasPppCallback(
                                  prasconncb->hport,
                                  szCallbackNumberA);
                    }

                    RASAPI32_TRACE1("RasPppCallback done(%d)", dwErr);

                    if (dwErr != 0)
                    {
                        break;
                    }
                }
#ifdef AMB
                else
                {
                    RASAPI32_TRACE("AuthCallback...");

                    {
                        CHAR szCallbackNumberA[RAS_MaxCallbackNumber + 1];

                        strncpyTtoA(szCallbackNumberA,
                                    prasdialparams->szCallbackNumber,
                                    sizeof(szCallbackNumberA));

                        g_pAuthCallback(prasconncb->hport,
                                        szCallbackNumberA);
                    }

                    RASAPI32_TRACE("AuthCallback done");
                }
#endif

                fAsyncState = TRUE;
                rasconnstateNext = RASCS_AuthNotify;
            }

            break;
        }

        case RASCS_AuthChangePassword:
        {
            RASDIALPARAMS* prasdialparams = &prasconncb->rasdialparams;

            RASAPI32_TRACE("RASCS_AuthChangePassword");

            if (prasconncb->fPppMode)
            {
                RASAPI32_TRACE("RasPppChangePassword...");

                {
                    CHAR szUserNameA[UNLEN + 1];
                    CHAR szOldPasswordA[PWLEN + 1], szPasswordA[PWLEN + 1];

                    DecodePassword(prasconncb->szOldPassword);
                    DecodePassword(prasdialparams->szPassword);

                    strncpyTtoAAnsi(
                        szUserNameA,
                        prasdialparams->szUserName,
                        sizeof(szUserNameA));

                    strncpyTtoAAnsi(
                        szOldPasswordA,
                        prasconncb->szOldPassword,
                        sizeof(szOldPasswordA));

                    strncpyTtoAAnsi(
                        szPasswordA,
                        prasdialparams->szPassword,
                        sizeof(szPasswordA));

                    dwErr = g_pRasPppChangePassword(
                              prasconncb->hport,
                              szUserNameA,
                              szOldPasswordA,
                              szPasswordA );

                    EncodePassword(prasconncb->szOldPassword);
                    EncodePassword(prasdialparams->szPassword);
                }

                RASAPI32_TRACE1("RasPppChangePassword done(%d)", dwErr);

                if (dwErr != 0)
                {
                    break;
                }
            }
#ifdef AMB
            else
            {
                RASAPI32_TRACE("AuthChangePassword...");

                {
                    CHAR szUserNameA[UNLEN + 1];
                    CHAR szOldPasswordA[PWLEN + 1],
                         szPasswordA[PWLEN + 1];

                    DecodePassword(
                        prasconncb->szOldPassword
                        );

                    DecodePassword(
                        prasdialparams->szPassword
                        );

                    strncpyTtoAAnsi(szUserNameA,
                               prasdialparams->szUserName,
                               sizeof(szUserNameA));

                    strncpyTtoAAnsi(szOldPasswordA,
                               prasconncb->szOldPassword,
                               sizeof(szOldPasswordA));

                    strncpyTtoAAnsi(szPasswordA,
                               prasdialparams->szPassword,
                               sizeof(szPasswordA));

                    g_pAuthChangePassword(
                        prasconncb->hport,
                        szUserNameA,
                        szOldPasswordA,
                        szPasswordA );

                    EncodePassword(
                        prasconncb->szOldPassword
                        );

                    EncodePassword(
                        prasdialparams->szPassword
                        );
                }

                RASAPI32_TRACE("AuthChangePassword done");
            }
#endif

            fAsyncState = TRUE;
            rasconnstateNext = RASCS_AuthNotify;
            break;
        }

        case RASCS_ReAuthenticate:
        {
            RASDIALPARAMS *prasdialparams =
                    &prasconncb->rasdialparams;

            RASAPI32_TRACE("RASCS_ReAuth...");

            RASAPI32_TRACE("RasPortConnectComplete...");

            dwErr = g_pRasPortConnectComplete(
                                prasconncb->hport
                                );

            RASAPI32_TRACE1("RasPortConnectComplete done(%d)", dwErr);

            if (dwErr != 0)
            {
                break;
            }

            if (prasconncb->fPppMode)
            {
                RASMAN_PPPFEATURES features;

                //
                // Set PPP framing.
                //
                memset( (char* )&features, '\0', sizeof(features) );
                features.ACCM = 0xFFFFFFFF;

                RASAPI32_TRACE("RasPortSetFraming(PPP)...");

                dwErr = g_pRasPortSetFraming(
                            prasconncb->hport,
                            PPP, &features,
                            &features );

                RASAPI32_TRACE1("RasPortSetFraming done(%d)", dwErr);

                //
                // Save the dialparamsuid with the port so that
                // rasman can get the password if required to
                // pass to ppp
                //
                RASAPI32_TRACE1("RasSetPortUserData(reauth,paramsuid) for %d",
                        prasconncb->hport);

                dwErr = RasSetPortUserData(
                    prasconncb->hport,
                    PORT_DIALPARAMSUID_INDEX,
                    (PBYTE) &prasconncb->pEntry->dwDialParamsUID,
                    sizeof(DWORD));

                RASAPI32_TRACE1("RasSetPortUserData returned %x", dwErr);

                //
                // This is not fatal.
                // 
                dwErr = 0;
                
                RASAPI32_TRACE1(
                  "RasPppStart(cfg=%d)...",
                  prasconncb->cinfo.dwConfigMask);

                {
                    CHAR szUserNameA[UNLEN + 1],
                         szPasswordA[PWLEN + 1];

                    CHAR szDomainA[2 * (DNLEN + 1)];

                    CHAR szPortNameA[MAX_PORT_NAME + 1];

                    CHAR szPhonebookPath[ MAX_PATH ];

                    CHAR szEntryName[ MAX_ENTRYNAME_SIZE ];

                    CHAR szPhoneNumber[ RAS_MaxPhoneNumber + 1 ];

                    PPP_BAPPARAMS BapParams;

                    DWORD dwSubEntries;

                    DWORD cbData = 0;
                    PBYTE pbData = NULL;

                    DWORD dwFlags = 0;

                    //
                    // Set PhonebookPath and EntryName in rasman
                    //
                    strncpyTtoAAnsi(
                        szPhonebookPath,
                        prasconncb->pbfile.pszPath,
                        sizeof(szPhonebookPath));

                    strncpyTtoAAnsi(
                        szEntryName,
                        prasconncb->pEntry->pszEntryName,
                        sizeof(szEntryName));

                    strncpyTtoAAnsi(
                        szPhoneNumber,
                        prasconncb->szPhoneNumber,
                        sizeof(szPhoneNumber));

                    RASAPI32_TRACE1("RasSetRasdialInfo %d...",
                           prasconncb->hport);

                    dwErr = DwGetCustomAuthData(
                                prasconncb->pEntry,
                                &cbData,
                                &pbData);

                    if(ERROR_SUCCESS != dwErr)
                    {
                        RASAPI32_TRACE1("DwGetCustomAuthData failed", dwErr);
                        break;
                    }

                    dwErr = g_pRasSetRasdialInfo(
                                prasconncb->hport,
                                szPhonebookPath,
                                szEntryName,
                                szPhoneNumber,
                                cbData,
                                pbData);

                    RASAPI32_TRACE2("RasSetRasdialInfo %d done. e = %d",
                            prasconncb->hport,
                            dwErr);

                    if (dwErr)
                    {
                        break;
                    }

                    if(prasconncb->RasEapInfo.dwSizeofEapInfo)
                    {
                        RASAPI32_TRACE1("RasSetEapLogonInfo %d...",
                                prasconncb->hport);

                        dwErr = g_pRasSetEapLogonInfo(
                                prasconncb->hport,
                                (UPM_Logon == prasconncb->dwUserPrefMode),
                                &prasconncb->RasEapInfo);

                        RASAPI32_TRACE3("RasSetEapLogonInfo %d(upm=%d) done. e=%d",
                                prasconncb->hport,
                                (UPM_Logon == prasconncb->dwUserPrefMode),
                                dwErr);
                    }

                    if(dwErr)
                    {
                        break;
                    }


                    DecodePassword(prasdialparams->szPassword);

                    strncpyTtoAAnsi(
                        szUserNameA,
                        prasdialparams->szUserName,
                        sizeof(szUserNameA));

                    strncpyTtoAAnsi(
                        szPasswordA,
                        prasdialparams->szPassword,
                        sizeof(szPasswordA));

                    strncpyTtoAAnsi(
                        szDomainA,
                        prasdialparams->szDomain,
                        sizeof(szDomainA));

                    if (!pEntry->fAutoLogon
                        && szUserNameA[ 0 ] == '\0'
                        && szPasswordA[ 0 ] == '\0')
                    {
                        if(pEntry->dwType == RASET_Direct)
                        {
                            // Windows9x DCC implements "no password mode"
                            // as doing authentication and checking for 
                            // no password, rather than just not authenti
                            // cating (don't ask me why).  This creates a 
                            // conflict with the RasDial API definition of
                            // empty username and password mapping to "use
                            // Windows credentials".  Workaround that here
                            // by substituting "guest" for the username.
                            //
                            lstrcpyA(szUserNameA, "guest");
                        }
                        
                        if (szDomainA[ 0 ] == '\0')
                        {
                            // default the domain name to the nt logon
                            // domain name if username/pwd/domain are all
                            // "". Bug 337591
                            //
                            WKSTA_USER_INFO_1 *pInfo = NULL;
                            DWORD dwError = SUCCESS;

                            RASAPI32_TRACE("NetWkstaUserGetInfo...");
                            dwError = NetWkstaUserGetInfo(
                                                    NULL,
                                                    1,
                                                    (LPBYTE*) &pInfo);

                            RASAPI32_TRACE1("NetWkstaUserGetInfo. rc=%d",
                                    dwError);

                            if(pInfo)
                            {
                                if(dwError == 0)
                                {
                                    strncpyWtoAAnsi(szDomainA,
                                             pInfo->wkui1_logon_domain,
                                             sizeof(szDomainA));
                                }

                                NetApiBufferFree(pInfo);
                            }
                        }
                    }

                    /*

                    // Windows9x DCC implements "no password mode" as doing
                    // authentication and checking for no password, rather
                    // than just not authenticating (don't ask me why).  This
                    // creates a conflict with the RasDial API definition of
                    // empty username and password mapping to "use Windows
                    // credentials".  Workaround that here by substituting
                    // "guest" for the username.
                    //
                    if (pEntry->dwType == RASET_Direct
                        && !pEntry->fAutoLogon
                        && szUserNameA[ 0 ] == '\0'
                        && szPasswordA[ 0 ] == '\0')
                    {
                        lstrcpyA( szUserNameA, "guest" );
                    }

                    */

                    strncpyTtoA(
                        szPortNameA,
                        prasconncb->szPortName,
                        sizeof(szPortNameA));

                    dwSubEntries = DtlGetNodes (
                                    prasconncb->pEntry->pdtllistLinks
                                    );

                    if ( dwSubEntries > 1 )
                    {
                        BapParams.dwDialMode =
                            prasconncb->pEntry->dwDialMode;
                    }
                    else
                    {
                        BapParams.dwDialMode = RASEDM_DialAll;
                    }

                    BapParams.dwDialExtraPercent =
                                    prasconncb->pEntry->dwDialPercent;

                    BapParams.dwDialExtraSampleSeconds =
                                    prasconncb->pEntry->dwDialSeconds;

                    BapParams.dwHangUpExtraPercent =
                                    prasconncb->pEntry->dwHangUpPercent;

                    BapParams.dwHangUpExtraSampleSeconds =
                                    prasconncb->pEntry->dwHangUpSeconds;

                    if(     (!prasconncb->pEntry->fShareMsFilePrint)
                        &&  (!prasconncb->pEntry->fBindMsNetClient))
                    {
                        dwFlags |= PPPFLAGS_DisableNetbt;
                    }
                    
                    dwErr = g_pRasPppStart(
                              prasconncb->hport,
                              szPortNameA,
                              szUserNameA,
                              szPasswordA,
                              szDomainA,
                              &prasconncb->luid,
                              &prasconncb->cinfo,
                              (LPVOID)prasconncb->reserved,
                              prasconncb->szzPppParameters,
                              TRUE,
                              hEventManual,
                              prasconncb->dwIdleDisconnectSeconds,
                              (prasconncb->pEntry->fRedialOnLinkFailure) ?
                              TRUE : FALSE,
                              &BapParams,
                              !(prasconncb->fAllowPause),
                              prasconncb->pEntry->dwCustomAuthKey,
                              dwFlags);

                    EncodePassword(prasdialparams->szPassword);
                }

                RASAPI32_TRACE1("RasPppStart done(%d)", dwErr);
            }
#ifdef AMB
            else
            {   //
                // Set RAS framing.
                //
                RASAPI32_TRACE("RasPortSetFraming(RAS)...");

                dwErr = g_pRasPortSetFraming(
                    prasconncb->hport, RAS, NULL, NULL );

                RASAPI32_TRACE1("RasPortSetFraming done(%d)", dwErr);
            }
#endif

            if (dwErr != 0)
            {
                break;
            }

            //
            // ...fall thru...
            //
        }

        case RASCS_AuthAck:
        case RASCS_AuthProject:
        case RASCS_AuthLinkSpeed:
        {
            RASDIALPARAMS* prasdialparams = &prasconncb->rasdialparams;

            RASAPI32_TRACE("RASCS_(ReAuth)/AuthAck/Project/Speed");


            if (prasconncb->fPppMode)
            {
                //
                // If we have previously suspended other
                // subentries to wait for a successful PPP
                // authentication, we resume them now.
                //
                if (    prasconncb->dwfSuspended == SUSPEND_Master
                    &&  !IsListEmpty(&prasconncb->ListEntry))
                {
                    ResumeSubentries(prasconncb);
                    prasconncb->dwfSuspended = SUSPEND_Done;
                }
            }
#ifdef AMB
            else
            {
                RASAPI32_TRACE("AuthContinue...");

                g_pAuthContinue( prasconncb->hport );

                RASAPI32_TRACE("AuthContinue done");
            }
#endif

            fAsyncState = TRUE;
            rasconnstateNext = RASCS_AuthNotify;
            break;
        }

        case RASCS_Authenticated:
        {
            RASAPI32_TRACE("RASCS_Authenticated");


#ifdef AMB
            if (    prasconncb->dwAuthentication == AS_PppThenAmb
                && !prasconncb->fPppMode)
            {
                //
                // AMB worked and PPP didn't, so try AMB first next time.
                //
                prasconncb->dwAuthentication = AS_AmbThenPpp;
            }
            else if (   prasconncb->dwAuthentication == AS_AmbThenPpp
                     && (   prasconncb->fPppMode
                         || prasconncb->fServerIsPppCapable))
            {
                //
                // Either PPP worked and AMB didn't, or AMB worked but the
                // server also has PPP.  Try PPP first next time.
                //
                prasconncb->dwAuthentication = AS_PppThenAmb;
            }

            //
            // Write the strategy to the phonebook.
            //
            SetAuthentication(prasconncb,
                    prasconncb->dwAuthentication);
#endif

            rasconnstateNext = RASCS_Connected;

            break;
        }

        case RASCS_PrepareForCallback:
        {
            RASAPI32_TRACE("RASCS_PrepareForCallback");

            dwErr = ResetAsyncMachine(
                    &prasconncb->asyncmachine
                    );

            //
            // Disable the disconnect processing
            // in the async machine, since we don't
            // want to terminate the connection after
            // we disconnect the port below.
            //
            dwErr = EnableAsyncMachine(
                      prasconncb->hport,
                      &prasconncb->asyncmachine,
                      ASYNC_MERGE_DISCONNECT);

            RASAPI32_TRACE("RasPortDisconnect...");

            dwErr = g_pRasPortDisconnect(prasconncb->hport,
                                         INVALID_HANDLE_VALUE );

            RASAPI32_TRACE1("RasPortDisconnect done(%d)", dwErr);

            if(     dwErr != 0
                &&  dwErr != PENDING)
            {
                break;
            }

            fAsyncState = TRUE;
            rasconnstateNext = RASCS_WaitForModemReset;
            break;
        }

        case RASCS_WaitForModemReset:
        {
            DWORD dwDelay = (DWORD )
                            ((prasconncb->wCallbackDelay / 2)
                            * 1000L);

            RASAPI32_TRACE("RASCS_WaitForModemReset");

            if (prasconncb->fUseCallbackDelay)
                Sleep( dwDelay );

            rasconnstateNext = RASCS_WaitForCallback;
            break;
        }

        case RASCS_WaitForCallback:
        {
            RASAPI32_TRACE("RASCS_WaitForCallback");

            RASAPI32_TRACE("RasPortListen...");

            dwErr = g_pRasPortListen(
                        prasconncb->hport,
                        SECS_ListenTimeout,
                        hEventAuto );

            RASAPI32_TRACE1("RasPortListen done(%d)", dwErr);

            if (    dwErr != 0
                &&  dwErr != PENDING)
            {
                break;
            }

            fAsyncState = TRUE;
            rasconnstateNext = RASCS_ReAuthenticate;
            break;
        }

        case RASCS_Projected:
        {
            RASMAN_INFO ri;

            RASAPI32_TRACE("RASCS_Projected");

            RASAPI32_TRACE("RasGetInfo...");

            dwErr = g_pRasGetInfo(NULL,
                                  prasconncb->hport,
                                  &ri);

            RASAPI32_TRACE1("RasGetInfo done(%d)", dwErr);

            if (dwErr)
            {
                break;
            }

            prasconncb->hrasconnOrig = prasconncb->hrasconn;

            prasconncb->hrasconn = ri.RI_ConnectionHandle;

            RASAPI32_TRACE("RasSetConnectionUserData...");

            //
            // Save the fPppMode in rasman.
            //
            dwErr = g_pRasSetConnectionUserData(
                      prasconncb->hrasconn,
                      CONNECTION_PPPMODE_INDEX,
                      (PBYTE)&prasconncb->fPppMode,
                      sizeof (prasconncb->fPppMode));

            RASAPI32_TRACE2(
                "RasSetConnectionUserData done(%d). PppMode=%d",
                dwErr, prasconncb->fPppMode );

            if (dwErr)
            {
                break;
            }

            if (prasconncb->fPppMode)
            {
                //
                // If at least one protocol succeeded, we can
                // continue.
                //
                if (    (prasconncb->PppProjection.lcp.hportBundleMember
                        == (HANDLE) 1)
                    ||  (prasconncb->PppProjection.nbf.dwError == 0)
                    ||  (prasconncb->PppProjection.ipx.dwError == 0)
                    ||  (prasconncb->PppProjection.ip.dwError == 0))
                {
                    fAsyncState = TRUE;
                    rasconnstateNext = RASCS_AuthNotify;

                    break;
                }

                //
                // If none of the protocols succeeded, then
                // we return ERROR_PPP_NO_PROTOCOLS_CONFIGURED,
                // not a protocol-specific error.
                //
                dwErr = ERROR_PPP_NO_PROTOCOLS_CONFIGURED;

            }
#ifdef AMB
            else
            {
                if (prasconncb->AmbProjection.Result == 0)
                {
                    //
                    // Save the projection information to
                    // rasman.
                    //
                    dwErr = SaveProjectionResults(prasconncb);
                    if (dwErr)
                        break;

                    rasconnstateNext = RASCS_AuthAck;
                    break;
                }

                dwErr = prasconncb->AmbProjection.Result;
            }
#endif

            break;
        }

    }


    prasconncb->dwError = dwErr;
    prasconncb->dwExtendedError = dwExtErr;

    RASAPI32_TRACE2("RDM errors=%d,%d", dwErr, dwExtErr);

    if (    !fAsyncState
        &&  !prasconncb->fStopped)
    {
        RASAPI32_TRACE1("RasDialMachine: SignalDone: prasconncb=0x%x",
                prasconncb);

        SignalDone( &prasconncb->asyncmachine );
    }

    if (fEnteredCS)
    {
        LeaveCriticalSection(&csStopLock);
    }

    return rasconnstateNext;
}


VOID
RasDialRestart(
    IN RASCONNCB** pprasconncb )

/*++

Routine Description:

        Called when an error has occurred in 'dwRestartOnError'
        mode. This routine does all cleanup necessary to restart
        the connection in state 0 (or not, as indicated). A new
        prasconncb structure is created here and the members
        copied from the old prasconncb structure. NOTE: The old
        prasconncb structure should be destroyed when the port
        associated with the connection is closed. Do not destr
        oy the old connection here.

Arguments:

Return Value:

--*/
{
    DWORD dwErr;
    RASCONNCB *prasconncbT;
    DTLNODE *pdtlnode;
    RASCONNCB *prasconncb = *pprasconncb;

    RASAPI32_TRACE("RasDialRestart");

    ASSERT(     prasconncb->dwRestartOnError != RESTART_HuntGroup
            ||  prasconncb->cPhoneNumbers>0);

    if (    prasconncb->dwRestartOnError
            == RESTART_DownLevelIsdn
        || (    (prasconncb->dwRestartOnError
                == RESTART_HuntGroup)
            &&  (++prasconncb->iPhoneNumber
                < prasconncb->cPhoneNumbers)))
    {
        if (prasconncb->dwRestartOnError == RESTART_DownLevelIsdn)
        {
            prasconncb->dwRestartOnError = 0;
        }

        RASAPI32_TRACE2(
          "Restart=%d, iPhoneNumber=%d",
          prasconncb->dwRestartOnError,
          prasconncb->iPhoneNumber);

        ASSERT(prasconncb->hport != INVALID_HPORT);

        RASAPI32_TRACE1("(ER) RasPortClose(%d)...", prasconncb->hport);

        dwErr = g_pRasPortClose( prasconncb->hport );

        RASAPI32_TRACE1("(ER) RasPortClose done(%d)", dwErr);

        RASAPI32_TRACE("(ER) RasPppStop...");

        g_pRasPppStop(prasconncb->hport);

        RASAPI32_TRACE("(ER) RasPppStop done");

        prasconncbT = CreateConnectionBlock(prasconncb);
        if (prasconncbT == NULL)
        {
            prasconncb->dwError = ERROR_NOT_ENOUGH_MEMORY;
            return;
        }

        //
        // Look up the subentry.
        //
        pdtlnode = DtlNodeFromIndex(
                     prasconncb->pEntry->pdtllistLinks,
                     prasconncb->rasdialparams.dwSubEntry - 1);

        prasconncbT->pLink = (PBLINK *)DtlGetData(pdtlnode);

        prasconncbT->rasdialparams.dwSubEntry
                = prasconncb->rasdialparams.dwSubEntry;

        prasconncbT->cPhoneNumbers =
                        prasconncb->cPhoneNumbers;

        prasconncbT->iPhoneNumber =
                        prasconncb->iPhoneNumber;

        prasconncbT->fMultilink =
                        prasconncb->fMultilink;

        prasconncbT->fBundled = prasconncb->fBundled;

        prasconncbT->fTerminated =
                        prasconncb->fTerminated;

        prasconncbT->dwRestartOnError =
                        prasconncb->dwRestartOnError;

        prasconncbT->cDevices = prasconncb->cDevices;

        prasconncbT->iDevice = prasconncb->iDevice;

        prasconncbT->hrasconnOrig = prasconncb->hrasconnOrig;

        prasconncbT->dwDeviceLineCounter =
                    prasconncb->dwDeviceLineCounter;

        if(NULL == prasconncb->notifier)                    
        {
            prasconncbT->asyncmachine.hDone = 
                prasconncb->asyncmachine.hDone;

            prasconncbT->psyncResult = prasconncb->psyncResult;                
                
            prasconncb->asyncmachine.hDone = NULL;
            prasconncb->psyncResult = NULL;
        }

        prasconncb->notifier = NULL;

        prasconncb->fRasdialRestart = TRUE;

        RASAPI32_TRACE2(
            "RasdialRestart: Replacing 0x%x with 0x%x",
            prasconncb, prasconncbT);

        prasconncb = prasconncbT;

        prasconncb->hport = INVALID_HPORT;

        prasconncb->dwError = 0;

        dwErr = ResetAsyncMachine(&prasconncb->asyncmachine);

        prasconncb->rasconnstate = 0;

        *pprasconncb = prasconncbT;

    }
}

VOID
RasDialTryNextAddress(
    IN RASCONNCB** pprasconncb )
{
    DWORD dwErr;
    RASCONNCB *prasconncbT;
    DTLNODE *pdtlnode;
    RASCONNCB *prasconncb = *pprasconncb;
    struct in_addr addr;
    // TCHAR *pszPhoneNumber;

    RASAPI32_TRACE("RasDialTryNextAddress");

    RASAPI32_TRACE1(
      "RasDialTryNextAddress, iAddress=%d",
      prasconncb->iAddress);

    ASSERT(RASET_Vpn == prasconncb->pEntry->dwType);      

    ASSERT(prasconncb->hport != INVALID_HPORT);

    RASAPI32_TRACE1("(TryNextAddress) RasPortClose(%d)...",
            prasconncb->hport);

    dwErr = g_pRasPortClose(prasconncb->hport);

    RASAPI32_TRACE1("(TryNextAddress) RasPortClose done(%d)",
            dwErr);

    RASAPI32_TRACE("(TryNextAddress) RasPppStop...");

    g_pRasPppStop(prasconncb->hport);

    RASAPI32_TRACE("(TryNextAddress) RasPppStop done");

    prasconncbT = CreateConnectionBlock(prasconncb);
    if (prasconncbT == NULL)
    {
        prasconncb->dwError = ERROR_NOT_ENOUGH_MEMORY;
        return;
    }

    //
    // copy the new address to the phonenumber field
    //
    
    /*
    addr.s_addr = prasconncb->pAddresses[prasconncb->iAddress];

    pszPhoneNumber = strdupAtoT(
                inet_ntoa(addr));

    lstrcpy(prasconncb->rasdialparams.szPhoneNumber,
            pszPhoneNumber);

    lstrcpy(prasconncbT->szPhoneNumber,
            pszPhoneNumber);

    Free0(pszPhoneNumber);                        

    RASAPI32_TRACE1("(TryNextAddress) trying %ws",
            prasconncbT->szPhoneNumber);

    */            
    prasconncbT->iAddress = prasconncb->iAddress + 1;
    prasconncbT->cAddresses = prasconncb->cAddresses;
    prasconncbT->pAddresses = prasconncb->pAddresses;
    prasconncb->pAddresses = NULL;
    prasconncb->iAddress = prasconncb->cAddresses = 0;

    prasconncbT->pLink = prasconncb->pLink;

    prasconncbT->rasdialparams.dwSubEntry
            = prasconncb->rasdialparams.dwSubEntry;

    prasconncbT->cPhoneNumbers =
                    prasconncb->cPhoneNumbers;

    prasconncbT->iPhoneNumber =
                    prasconncb->iPhoneNumber;

    prasconncbT->fMultilink =
                    prasconncb->fMultilink;

    prasconncbT->fBundled = prasconncb->fBundled;

    prasconncbT->fTerminated =
                    prasconncb->fTerminated;

    prasconncbT->dwRestartOnError =
                    prasconncb->dwRestartOnError;

    prasconncbT->cDevices = prasconncb->cDevices;

    prasconncbT->iDevice = prasconncb->iDevice;

    prasconncbT->hrasconnOrig = prasconncb->hrasconnOrig;

    prasconncbT->dwDeviceLineCounter =
                prasconncb->dwDeviceLineCounter;

    if(NULL == prasconncb->notifier)
    {
        prasconncbT->asyncmachine.hDone = 
                        prasconncb->asyncmachine.hDone;
        prasconncb->asyncmachine.hDone = NULL;

        prasconncbT->psyncResult = prasconncb->psyncResult;
        prasconncb->psyncResult = NULL;
    }

    prasconncb->notifier = NULL;
    
    RASAPI32_TRACE2(
        "RasdialTryNextAddress: Replacing 0x%x with 0x%x",
        prasconncb, prasconncbT);

    prasconncb = prasconncbT;

    prasconncb->hport = INVALID_HPORT;

    prasconncb->dwError = 0;

    dwErr = ResetAsyncMachine(&prasconncb->asyncmachine);

    prasconncb->rasconnstate = 0;

    *pprasconncb = prasconncbT;
}


/*++

Routine Description:

        This function is called when an error occurs in the
        RasDialMachine at or before reaching RASCS_DeviceConnect
        state and if the RDM is in DialMode 0. The next device 
        on the alternates list will be tried only when the 
        PortOpenEx failed for the current device. PortOpenEx 
        failing for a device means that either all the lines on 
        the device are busy or we have already tried all the 
        lines of the device but failed to connect. If PortOpenEx
        passed for the device but we encountered an error at some
        other state, we try to find another line on the device. 
        PortOpenEx will fail now if the device doesn't have any 
        more lines and the next time this function is called it 
        will move on to the next device on the alternates list.

Arguments:

        pprasconncb - This is an in/out parameter. This is address
                      of connectionblock to the connection that
                      failedto connect when in, its the connection
                      block of the new attempt to be made when out.
                      The in prasconncb will be destroyed when the
                      PortClose causes the asyncmachine for that
                      connection to shutdown. If the error occurs
                      in RASCS_PortOpen state, there won't be a
                      PortClose and the prasconncb structure passed
                      can be reused. As this prasconncb is destroyed
                      when PortClose is called, its illegal to
                      destroy the connection block here.

Return Value:

        void

--*/
VOID
RasDialTryNextLink(RASCONNCB **pprasconncb)
{
    DWORD       dwErr         = SUCCESS;
    RASCONNCB   *prasconncb   = *pprasconncb;
    RASCONNCB   *prasconncbT;
    DTLNODE     *pdtlnode;
    PBLINK      *pLink;

    RASAPI32_TRACE("RasDialTryNextLink...");

    //
    // We should not get called here if we are
    // not in "try next link if this link fails"
    // mode
    //
    // ASSERT(0 == prasconncb->pEntry->dwDialMode);

    ASSERT(NULL != prasconncb->pLink);
    ASSERT(NULL != prasconncb->pEntry->pdtllistLinks);

    if(RASEDM_DialAll != prasconncb->pEntry->dwDialMode)
    {
        //
        // Get the next link to dial
        //
        for (pdtlnode = DtlGetFirstNode(prasconncb->pEntry->pdtllistLinks);
             pdtlnode;
             pdtlnode = DtlGetNextNode(pdtlnode))
        {
            if(prasconncb->pLink == (PBLINK *) DtlGetData(pdtlnode))
            {
                break;
            }
        }
        
        ASSERT(NULL != pdtlnode);

        pdtlnode = DtlGetNextNode(pdtlnode);

        if(     NULL == pdtlnode
            &&  INVALID_HPORT == prasconncb->hport)
        {
            //
            // No more links for you!! Come back next dial!
            //
            RASAPI32_TRACE("RasDialTryNextLink: No more links");

            //
            // Restore the saved error if we ran out of
            // links
            //
            if(     (ERROR_PORT_NOT_AVAILABLE ==
                        prasconncb->dwError)

                &&  (0 != prasconncb->dwSavedError))
            {
                prasconncb->dwError = prasconncb->dwSavedError;
            }

            goto done;
        }
    }

    if(INVALID_HPORT != prasconncb->hport)
    {
        prasconncbT = CreateConnectionBlock(prasconncb);
        if (prasconncbT == NULL)
        {
            prasconncb->dwError = ERROR_NOT_ENOUGH_MEMORY;
            goto done;
        }
        
        prasconncbT->pLink = prasconncb->pLink;
    }
    else
    {
        //
        // if we haven't gone past state 0 no point in
        // allocating a new connection block. Goto the
        // next link and restart.
        //
        if(RASEDM_DialAll != prasconncb->pEntry->dwDialMode)
        {
            prasconncb->pLink =
                    (PBLINK *) DtlGetData(pdtlnode);
                    
            //
            // Reset this to 0 so that rasman starts looking
            // for an available line on this device from the
            // start.
            //
            prasconncb->dwDeviceLineCounter = 0;

        }                
        else
        {
            //
            // In the case of dial all, we just increment the
            // counter so that the next link in the device is
            // tried.
            //
            prasconncb->dwDeviceLineCounter += 1;
        }

        ASSERT(NULL != prasconncb->pLink);

        //
        // Save the error we received for the previous
        // try.
        //
        if(PENDING != prasconncb->dwError)
        {
            prasconncb->dwSavedError = prasconncb->dwError;
        }

        prasconncb->dwError = 0;

        goto done;
    }

    //
    // No failures from here. If you add anything that
    // fails beyond this point, Free the connectionblock
    // prasconncbT , if it was allocated , at the exit
    // point done. Note that we move to the next link on
    // the alternates list only if the RasDialMachine
    // encountered a failure in the RASCS_PortOpen state.
    // Otherwise just increment the counter so that rasman
    // tries to open the next line on this device -  which
    // will fail in RASCS_PortOpen state if such a line
    // doesn't exist.
    //
    /*
    if( INVALID_HPORT == prasconncb->hport)
    {
        prasconncbT->pLink = (PBLINK *) DtlGetData(pdtlnode);

        ASSERT(NULL != prasconncbT->pLink);
    }
    else
    {
        prasconncbT->pLink = prasconncb->pLink;
    }

    */

    prasconncbT->rasdialparams.dwSubEntry
                    = prasconncb->rasdialparams.dwSubEntry;

    prasconncbT->cPhoneNumbers = prasconncb->cPhoneNumbers;

    prasconncbT->iPhoneNumber = 0;

    prasconncbT->fMultilink = prasconncb->fMultilink;

    prasconncbT->fBundled = prasconncb->fBundled;

    prasconncbT->fTerminated = prasconncb->fTerminated;

    prasconncbT->dwRestartOnError
                    = prasconncb->dwRestartOnError;

    prasconncbT->cDevices = prasconncb->cDevices;

    prasconncbT->iDevice = prasconncb->iDevice;

    prasconncbT->hrasconnOrig = prasconncb->hrasconnOrig;

    prasconncb->fRasdialRestart = TRUE;
    

    prasconncbT->hport = INVALID_HPORT;

    if(NULL == prasconncb->notifier)
    {
        prasconncbT->asyncmachine.hDone = 
            prasconncb->asyncmachine.hDone;
        prasconncb->asyncmachine.hDone = NULL;

        prasconncbT->psyncResult = prasconncb->psyncResult;
        prasconncb->psyncResult = NULL;
    }

    //
    // Save the error we got for the previous
    // try
    //
    if(PENDING != prasconncb->dwError)
    {
        prasconncbT->dwSavedError =
                prasconncb->dwError;
    }

    prasconncbT->dwError = 0;

    prasconncbT->dwDeviceLineCounter
            = prasconncb->dwDeviceLineCounter + 1;

    dwErr = ResetAsyncMachine(&prasconncbT->asyncmachine);

    prasconncbT->rasconnstate = 0;

    *pprasconncb = prasconncbT;
    RASAPI32_TRACE2(
        "RasdialTryNextLink: Replacing 0x%x with 0x%x",
        prasconncb, prasconncbT);

    //
    // NULL out the notifier for prasconncb - we don't
    // want to call back on this link anymore..
    //
    prasconncb->notifier = NULL;


    if(INVALID_HPORT != prasconncb->hport)
    {

        RASAPI32_TRACE2("RasDialTryNextLink:iDevice=%d,"
                "cDevices=%d",
                prasconncb->iDevice,
                prasconncb->cDevices);

        if(     (prasconncb->rasconnstate >= RASCS_DeviceConnected)
            ||  (prasconncb->iDevice > 1))
        {
            //
            // This means we tried to dial a switch which failed
            // to connect and so we should bring down the modem
            // connection before closing the  port.
            //
            RASAPI32_TRACE1("RasDialTryNextLink: RasPortDisconnect(%d)...",
                    prasconncb->hport);

            dwErr = g_pRasPortDisconnect(prasconncb->hport,
                                         INVALID_HANDLE_VALUE);

            RASAPI32_TRACE1("RasDialTryNextLink: RasPortDisconnect done(%d)",
                    dwErr);
        }                
    
        RASAPI32_TRACE1("RasDialTryNextLink: RasPortClose(%d)...",
                prasconncb->hport);

        dwErr = g_pRasPortClose(prasconncb->hport);

        RASAPI32_TRACE1("RasDialTryNextLink: RasPortClose done(%d)",
               dwErr);

        RASAPI32_TRACE("(ER) RasPppStop...");

        g_pRasPppStop(prasconncb->hport);

        RASAPI32_TRACE("(ER) RasPppStop done");

        //
        // Save the error here - otherwise we may end up giving the
        // horrible ERROR_DISCONNECTION error
        //
        prasconncb->dwSavedError = prasconncb->dwError;
    }


done:

    RASAPI32_TRACE1("RasDialTryNextLink done(%d)", dwErr);

    return;
}


/*++

Routine Description:


Arguments:


Return Value:

        void

--*/
VOID
RasDialTryNextVpnDevice(RASCONNCB **pprasconncb)
{
    DWORD dwErr = SUCCESS;

    RASCONNCB *prasconncb = *pprasconncb;

    RASCONNCB *prasconncbT;

    DTLNODE *pdtlnode;

    CHAR szDeviceName[MAX_DEVICE_NAME + 1];

    RASDEVICETYPE rdt;

    DWORD dwVpnStrategy = prasconncb->pEntry->dwVpnStrategy;

    TCHAR *pszDeviceName = NULL;

    RASAPI32_TRACE("RasDialTryNextVpnDevice...");

    ASSERT(RASET_Vpn == prasconncb->pEntry->dwType);

    ASSERT(prasconncb->dwCurrentVpnProt < NUMVPNPROTS);

    prasconncb->dwCurrentVpnProt += 1;

    //
    // If autodetect mode is not set or if
    // we have already tried both vpn devices
    // quit.
    //
    if(     (VS_PptpOnly == dwVpnStrategy)
        ||  (VS_L2tpOnly == dwVpnStrategy))
    {
        goto done;
    }

    // If we've exhausted all vpn protocols, then send the
    // specific error that explains this to the user
    //
    // Whistler Bug 
    //
    if (prasconncb->dwCurrentVpnProt >= NUMVPNPROTS)
    {
        prasconncb->dwError = dwErr = ERROR_AUTOMATIC_VPN_FAILED;
        goto done;
    }
    
    rdt = prasconncb->ardtVpnProts[prasconncb->dwCurrentVpnProt];

    /*
    //
    // Get the device
    //
    RASAPI32_TRACE1("RasGetDeviceName(%d)..",
           rdt);

    dwErr = g_pRasGetDeviceName(rdt,
                                szDeviceName);

    RASAPI32_TRACE1("RasGetDeviceName. rc=%d",
           dwErr);

    if(ERROR_SUCCESS != dwErr)
    {
        //
        // Clear the error
        //
        prasconncb->dwError = ERROR_SUCCESS;
        goto done;
    }

    pszDeviceName = StrDupTFromA(szDeviceName);

    if(NULL == pszDeviceName)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto done;
    }

    //
    // Set the device
    //
    Free0(prasconncb->pLink->pbport.pszDevice);

    prasconncb->pLink->pbport.pszDevice = pszDeviceName; */

    if(INVALID_HPORT == prasconncb->hport)
    {
        if(PENDING != prasconncb->dwError)
        {
            prasconncb->dwSavedError = prasconncb->dwError;
        }
        prasconncb->dwError = ERROR_SUCCESS;
        goto done;
    }

    prasconncbT = CreateConnectionBlock(prasconncb);

    if (prasconncbT == NULL)
    {
        prasconncb->dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto done;
    }

    //
    // No failures from here. If you add anything that
    // fails beyond this point, Free the connectionblock
    // prasconncbT , if it was allocated , at the exit
    // point done.
    //
    prasconncbT->rasdialparams.dwSubEntry
                    = prasconncb->rasdialparams.dwSubEntry;

    prasconncbT->cPhoneNumbers = prasconncb->cPhoneNumbers;

    prasconncbT->iPhoneNumber = 0;

    prasconncbT->fMultilink = prasconncb->fMultilink;

    prasconncbT->fBundled = prasconncb->fBundled;

    prasconncbT->fTerminated = prasconncb->fTerminated;

    prasconncbT->dwRestartOnError
                    = prasconncb->dwRestartOnError;

    prasconncbT->cDevices = prasconncb->cDevices;

    prasconncbT->iDevice = prasconncb->iDevice;

    prasconncbT->hrasconnOrig = prasconncb->hrasconnOrig;

    prasconncbT->fRasdialRestart = TRUE;

    prasconncbT->hport = INVALID_HPORT;

    prasconncbT->pLink = prasconncb->pLink;

    prasconncbT->cAddresses = prasconncbT->iAddress = 0;
    prasconncbT->pAddresses = NULL;

    if(PENDING != prasconncb->dwError)
    {
        prasconncbT->dwSavedError = prasconncb->dwError;
    }

    if(NULL == prasconncb->notifier)
    {
        prasconncbT->asyncmachine.hDone = 
                            prasconncb->asyncmachine.hDone;
        prasconncb->asyncmachine.hDone = NULL;

        prasconncbT->psyncResult = prasconncb->psyncResult;
        prasconncb->psyncResult = NULL;
    }

    prasconncb->notifier = NULL;
    
    prasconncbT->dwError = 0;

    dwErr = ResetAsyncMachine(&prasconncbT->asyncmachine);

    prasconncbT->rasconnstate = 0;

    *pprasconncb = prasconncbT;

    RASAPI32_TRACE2(
        "RasDialTryNextVpnDevice: Replacing 0x%x with 0x%x",
        prasconncb, prasconncbT);


    if(INVALID_HPORT != prasconncb->hport)
    {
        RASAPI32_TRACE1("RasDialTryNextVpnDevice: RasPortClose(%d)...",
                prasconncb->hport);

        dwErr = g_pRasPortClose(prasconncb->hport);

        RASAPI32_TRACE1("RasDialTryNextVpnDevice: RasPortClose done(%d)",
               dwErr);

        RASAPI32_TRACE("(ER) RasPppStop...");

        g_pRasPppStop(prasconncb->hport);

        RASAPI32_TRACE("(ER) RasPppStop done");
    }


done:

    RASAPI32_TRACE1("RasDialTryNextVpnDevice done(%d)",
           dwErr);

    return;
}

VOID
StartSubentries(
    IN RASCONNCB *prasconncb
    )
{
    PLIST_ENTRY pEntry;

    //
    // Kickstart the async machine for all subentries
    // in a connection.
    //
    RASAPI32_TRACE1(
      "starting subentry %d",
      prasconncb->rasdialparams.dwSubEntry);
    SignalDone(&prasconncb->asyncmachine);

    for (pEntry = prasconncb->ListEntry.Flink;
         pEntry != &prasconncb->ListEntry;
         pEntry = pEntry->Flink)
    {
        RASCONNCB *prcb =
            CONTAINING_RECORD(pEntry, RASCONNCB, ListEntry);

        if (!prcb->fRasdialRestart)
        {
            RASAPI32_TRACE1(
              "starting subentry %d",
              prcb->rasdialparams.dwSubEntry);

            SignalDone(&prcb->asyncmachine);
        }
    }
}


VOID
SuspendSubentries(
    IN RASCONNCB *prasconncb
    )
{
    PLIST_ENTRY pEntry;

    //
    // Suspend all subentries in the connection except
    // for the supplied one.
    //
    for (pEntry = prasconncb->ListEntry.Flink;
         pEntry != &prasconncb->ListEntry;
         pEntry = pEntry->Flink)
    {
        RASCONNCB *prcb =
            CONTAINING_RECORD(pEntry, RASCONNCB, ListEntry);

        if (!prcb->fRasdialRestart)
        {
            RASAPI32_TRACE1(
              "suspending subentry %d",
              prcb->rasdialparams.dwSubEntry);

            prcb->dwfSuspended = SUSPEND_InProgress;
        }
    }
}


BOOLEAN
IsSubentriesSuspended(
    IN RASCONNCB *prasconncb
    )
{
    BOOLEAN fSuspended = FALSE;
    PLIST_ENTRY pEntry;

    for (pEntry = prasconncb->ListEntry.Flink;
         pEntry != &prasconncb->ListEntry;
         pEntry = pEntry->Flink)
    {
        RASCONNCB *prcb =
            CONTAINING_RECORD(pEntry, RASCONNCB, ListEntry);

        fSuspended = (prcb->dwfSuspended == SUSPEND_InProgress);

        if (fSuspended)
        {
            break;
        }
    }

    return fSuspended;
}


VOID
RestartSubentries(
    IN RASCONNCB *prasconncb
    )
{
    PLIST_ENTRY pEntry;

    for (pEntry = prasconncb->ListEntry.Flink;
         pEntry != &prasconncb->ListEntry;
         pEntry = pEntry->Flink)
    {
        RASCONNCB *prcb =
            CONTAINING_RECORD(pEntry, RASCONNCB, ListEntry);

        //
        // Resume the suspended async machines.
        //
        SuspendAsyncMachine(&prcb->asyncmachine, FALSE);

        prcb->dwfSuspended = SUSPEND_Start;

    }
}


VOID
ResumeSubentries(
    IN RASCONNCB *prasconncb
    )
{
    PLIST_ENTRY pEntry;

    //
    // Restart all subentries in the connection except
    // for the supplied one.
    //
    for (pEntry = prasconncb->ListEntry.Flink;
         pEntry != &prasconncb->ListEntry;
         pEntry = pEntry->Flink)
    {
        RASCONNCB *prcb =
            CONTAINING_RECORD(pEntry, RASCONNCB, ListEntry);

        RASAPI32_TRACE1(
          "resuming subentry %d",
          prcb->rasdialparams.dwSubEntry);

        //
        // Resume the suspended async machines.
        //
        SuspendAsyncMachine(&prcb->asyncmachine, FALSE);
        prcb->dwfSuspended = SUSPEND_Done;
    }
}


VOID
SyncDialParamsSubentries(
    IN RASCONNCB *prasconncb
    )
{
    PLIST_ENTRY pEntry;
    DWORD dwSubEntry;

    //
    // Reset the rasdialparams for all subentries except
    // for the supplied one.
    //
    for (pEntry = prasconncb->ListEntry.Flink;
         pEntry != &prasconncb->ListEntry;
         pEntry = pEntry->Flink)
    {
        RASCONNCB *prcb =
            CONTAINING_RECORD(pEntry, RASCONNCB, ListEntry);

        RASAPI32_TRACE1(
          "syncing rasdialparams for subentry %d",
          prcb->rasdialparams.dwSubEntry);

        dwSubEntry = prcb->rasdialparams.dwSubEntry;

        memcpy(
          (CHAR *)&prcb->rasdialparams,
          (CHAR *)&prasconncb->rasdialparams,
          prasconncb->rasdialparams.dwSize);

        prcb->rasdialparams.dwSubEntry = dwSubEntry;

        EncodePassword(prcb->rasdialparams.szPassword);
    }
}


VOID
SetSubentriesBundled(
    IN RASCONNCB *prasconncb
    )
{
    PLIST_ENTRY pEntry;
    HPORT hport;

    RASAPI32_TRACE("SetSubEntriesBundled");

    //
    // Set that we have received full
    // projection information from one
    // of the links.
    //
    prasconncb->fBundled = TRUE;
    for (pEntry = prasconncb->ListEntry.Flink;
         pEntry != &prasconncb->ListEntry;
         pEntry = pEntry->Flink)
    {
        RASCONNCB *prcb =
            CONTAINING_RECORD(pEntry, RASCONNCB, ListEntry);

        prcb->fBundled = TRUE;
    }
}


RASCONNSTATE
MapSubentryState(
    IN RASCONNCB *prasconncb
    )
{
    RASCONNSTATE rasconnstate = prasconncb->rasconnstate;

    if (!IsListEmpty(&prasconncb->ListEntry)) {

        //
        // If there are still subentries attempting to
        // connect, then map the connected/disconnected
        // states into subentry states.
        //
        if (prasconncb->rasconnstate == RASCS_Connected)
        {
            rasconnstate = RASCS_SubEntryConnected;
        }
        else if (prasconncb->rasconnstate == RASCS_Disconnected)
        {
            rasconnstate = RASCS_SubEntryDisconnected;
        }
    }

    return rasconnstate;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\extapi\src\extapi.h ===
/* Copyright (c) 1992, Microsoft Corporation, all rights reserved
**
** extapi.h
** Remote Access External APIs
** Internal header
**
** 10/12/92 Steve Cobb
*/

#ifndef _EXTAPI_H_
#define _EXTAPI_H_

#include <windows.h>
#include <tchar.h>
#include <stdlib.h>
#include <tapi.h>
#include <ras.h>
#include <raserror.h>
#include <mprerror.h>

typedef LONG    APIERR;

#ifdef UNICODE
#include <nouiutil.h>
#else
#define UNICODE
#undef LPTSTR
#define LPTSTR WCHAR*
#undef TCHAR
#define TCHAR WCHAR
#include <nouiutil.h>
#undef TCHAR
#define TCHAR CHAR
#undef LPTSTR
#define LPTSTR CHAR*
#undef UNICODE
#endif

#include <uiip.h>
#include <rasip.h>
#include <clauth.h>
#include <dhcpcapi.h>
#include <rasp.h>

#ifdef UNICODE
#undef UNICODE
#include <rasppp.h>
#define INCL_PARAMBUF
#include <ppputil.h>
#define UNICODE
#else
#include <rasppp.h>
#define INCL_PARAMBUF
#include <ppputil.h>
#endif

#include <rasdlg.h>
#ifdef UNICODE
#include <pbk.h>
#include <phonenum.h>
#else
#define UNICODE
#include <pbk.h>
#include <phonenum.h>
#undef UNICODE
#endif

#include <asyncm.h>
#undef ASSERT
#include <debug.h>
#include <rasscrpt.h>
#include <rasuip.h>
#include "tstr.h"
#include "pwutil.h"

#define RAS_MaxConnectResponse  128
#define RAS_MaxProjections 3

#define RESTART_HuntGroup     0x1
#define RESTART_DownLevelIsdn 0x2

//
// TODO: Remove the maintenance of
// dwAuthentication from rasconncb.
// Putting this in temporarily.
//
#define AS_PppOnly                          2

//
// Multilink suspend states for dwfSuspended field
// in RASCONNCB.
//
#define SUSPEND_Master      0xffffffff
#define SUSPEND_Start       0
#define SUSPEND_InProgress  1
#define SUSPEND_Done        2

//
// Distinguish between connection-based
// and port-based HRASCONNs.
//
#define IS_HPORT(h) ((NULL != h) && (HandleToUlong(h) & 0xffff0000) ? FALSE : TRUE)
#define HPORT_TO_HRASCONN(h)  (HRASCONN)(UlongToPtr(HandleToUlong(h) + 1))
#define HRASCONN_TO_HPORT(h)  (HPORT)UlongToPtr((HandleToUlong(h) - 1))

//
// Debug string macros.
//
#define TRACESTRA(s)    ((s) != NULL ? (s) : "(null)")
#define TRACESTRW(s)    ((s) != NULL ? (s) : L"(null)")

enum _VPNPROTS
{
    PPTP    = 0,
    L2TP,
    NUMVPNPROTS
};

typedef enum _VPNPROTS VPNPROTS;

//-----------------------------------------
// Data Structures
//-----------------------------------------

//
// structure to convey eap information
// between ppp and rasdialmachine
//
typedef struct _INVOKE_EAP_UI
{
    DWORD       dwEapTypeId;
    DWORD       dwContextId;
    DWORD       dwSizeOfUIContextData;
    PBYTE       pUIContextData;

} s_InvokeEapUI;


//
// Connection control block.
//
#define RASCONNCB struct tagRASCONNCB

RASCONNCB
{
    //
    //The rasman connection identifier.
    //
    HCONN hrasconn;

    //
    //These fields are updated continually during state processing.
    //
    RASCONNSTATE rasconnstate;
    RASCONNSTATE rasconnstateNext;
    ASYNCMACHINE asyncmachine;

    DWORD dwError;
    DWORD dwExtendedError;
    DWORD dwRestartOnError;
    DWORD dwSavedError;

    DWORD cAddresses;
    DWORD iAddress;
    DWORD *pAddresses;

    DWORD cPhoneNumbers;
    DWORD iPhoneNumber;

    DWORD cDevices;
    DWORD iDevice;

    //
    // These fields are updated during
    // authentication/projection phase.
    //
    NETBIOS_PROJECTION_RESULT AmbProjection;
    PPP_PROJECTION_RESULT     PppProjection;
    HPORT                     hportBundled;
    RASSLIP                   SlipProjection;
    BOOL                      fProjectionComplete;
    BOOL                      fServerIsPppCapable;

    //
    // These fields are determined when the
    // port is opened in state 0.  States
    // 1-n may assume that the port is open
    // and these fields are set.
    //
    HPORT hport;
    TCHAR  szPortName[ MAX_PORT_NAME + 1 ];
    TCHAR  szDeviceName[ MAX_DEVICE_NAME + 1 ];
    TCHAR  szDeviceType[ MAX_DEVICETYPE_NAME + 1 ];
    TCHAR  szUserKey[(MAX_PHONENUMBER_SIZE        \
                     < MAX_ENTRYNAME_SIZE         \
                     ? MAX_ENTRYNAME_SIZE         \
                     : MAX_PHONENUMBER_SIZE) + 1];

    //
    // These fields are supplied by the API caller or
    // determined by other non-RAS Manager means before
    // the state machine stage.  All states may assume
    // these values have been set.
    //
    ULONG_PTR      reserved;
    ULONG_PTR      reserved1;
    DWORD          dwNotifierType;
    LPVOID         notifier;
    HWND           hwndParent;
    UINT           unMsg;
    PBFILE         pbfile;
    PBENTRY        *pEntry;
    PBLINK         *pLink;
    RASDIALPARAMS  rasdialparams;
    BOOL           fAllowPause;
    BOOL           fDefaultEntry;
    BOOL           fDisableModemSpeaker;
    BOOL           fDisableSwCompression;
    BOOL           fPauseOnScript;
    DWORD          dwUserPrefMode;
    BOOL           fUsePrefixSuffix;
    BOOL           fNoClearTextPw;
    BOOL           fRequireMsChap;
    BOOL           fRequireEncryption;
    BOOL           fLcpExtensions;
    DWORD          dwfPppProtocols;
    CHAR           szzPppParameters[ PARAMETERBUFLEN ];
    TCHAR          szPhoneNumber[RAS_MaxPhoneNumber + 1];
    TCHAR          szDomain[DNLEN + 1];
    TCHAR          szOldPassword[ PWLEN + 1 ];
    BOOL           fOldPasswordSet;
    BOOL           fUpdateCachedCredentials;
    BOOL           fRetryAuthentication;
    BOOL           fMaster;
    DWORD          dwfSuspended;
    BOOL           fStopped;
    BOOL           fCleanedUp;
    BOOL           fDeleted;
    BOOL           fTerminated;
    BOOL           fRasdialRestart;
    BOOL           fAlreadyConnected;
    BOOL           fPppEapMode;
    DWORD          dwDeviceLineCounter;

    //
    // This is the array of vpn protocols
    // to be used while autodetecting.
    //
    RASDEVICETYPE  ardtVpnProts[NUMVPNPROTS];

    //
    // Current vpn protocol being tried.
    //
    DWORD          dwCurrentVpnProt;

    //
    // These fields are determined before state machine stage and updated
    // after a successful authentication.  All states may assume that these
    // values have been set.
    //
#if AMB
    DWORD dwAuthentication;
#endif

    BOOL  fPppMode;

    //
    // These fields are set off by default, then set to non-default states at
    // modem dial time.  They must be stored since they are required by
    // Authentication but are only available before RasPortConnectComplete is
    // called.
    //
    BOOL fUseCallbackDelay;
    WORD wCallbackDelay;

    //
    // This field indicates an ISDN device is in use on the connection.  It is
    // set during device connection for use during authentication.
    //
    BOOL fIsdn;

    //
    // This field indicates a modem device is the last device connected.  It
    // is set during device connection and reset during device connected
    // processing.
    //
    BOOL fModem;

    //
    // This field indicates the operator dial user preference is in effect.
    //  This is determined during ConstructPhoneNumber in RASCS_PortOpened
    //  state.
    //
    BOOL fOperatorDial;

    //
    // These fields apply only to WOW-originated connections.  They are set
    // immediately after RasDialA returns.
    //
    UINT unMsgWow;
    HWND hwndNotifyWow;

    //
    // PPP config information used for continuing a PPP connection.
    //
    PPP_CONFIG_INFO cinfo;
    LUID luid;

    //
    // List of connection blocks for all
    // simultaneously-dialed subentries in a
    // connection.
    //
    BOOL fMultilink;
    BOOL fBundled;
    LIST_ENTRY ListEntry;

    //
    // Idle disconnect timeout.
    //
    DWORD dwIdleDisconnectSeconds;

    // synchronous rasdial result
    LPDWORD psyncResult;

    BOOL fDialSingleLink;

    BOOL fTryNextLink;

    //EapLogon information
    RASEAPINFO RasEapInfo;

    //
    // Flag corresponding to RDEOPT_UseCustomScripting
    //
    BOOL fUseCustomScripting;

    //
    // Original rasconn with which the link was dialed. This might
    // change to the bundles hrasconn in the case when a single
    // link a connected multilinked bundle is brought up. This
    // needs to be maintained because otherwise we cannot accurately
    // determine if the rasconncb is still valid.
    //
    HRASCONN hrasconnOrig;
};


//-----------------------------------------------------
// Global Data
//-----------------------------------------------------

//
// Async worker work list, etc.
//
extern HANDLE hIoCompletionPort;
extern CRITICAL_SECTION csAsyncLock;
extern HANDLE hAsyncEvent;
extern LIST_ENTRY AsyncWorkItems;
extern HANDLE hDummyEvent;

//
// DLL's HINSTANCE stashed at initialization.
//
extern HINSTANCE hModule;

//
// List of currently active connections.
//
extern DTLLIST* PdtllistRasconncb;

//
// Bit field of installed protocols, i.e. VALUE_Nbf,
// VALUE_Ipx, VALUE_Ip.
//
extern DWORD DwfInstalledProtocols;

//
// Used to synchronize access to the list of currently
// active connections.
//
extern CRITICAL_SECTION RasconncbListLock;

//
// Used to synchronize access to thread termination code.
// This is used to prevent RasHangUp and the thread itself
// rom interfering with the others closing the port and
// releasing the control block.  Since the control block
// is released in the protected code the mutex must be
// global.
//
extern CRITICAL_SECTION csStopLock;

#ifdef PBCS
//
// Used to synchronize access to the (currently) global
// phonebook data between multiple threads.
//
extern CRITICAL_SECTION PhonebookLock;
#endif
//
// Used to keep an async machine from starting between return from RasHangUp
// and termination of the hung up thread.  This prevents the "port not
// available" error that might otherwise occur.  That is, it makes RasHangUp
// look synchronous when it's really not.  (The reason it's not is so the
// caller can call RasHangUp from within a RasDial notification, which is the
// only convenient place to do it.) If the event is set it is OK to create a
// machine.
//
extern HANDLE HEventNotHangingUp;

//
// Used to indicate if/how RasInitialize has failed.  This is required since
// there are various things (NCPA running, user didn't reboot after install)
// that can result in RasMan initialization failure and we don't want the user
// to get the ugly system error popup.
//
extern DWORD FRasInitialized;
extern DWORD DwRasInitializeError;

//
// The error message DLL.
//
#define MSGDLLPATH  TEXT("mprmsg.dll")

//
// rasman.dll entry points
//
typedef DWORD (APIENTRY * RASPORTCLOSE)(HPORT);
extern RASPORTCLOSE PRasPortClose;

typedef DWORD (APIENTRY * RASPORTENUM)(PBYTE,
                                       PWORD,
                                       PWORD );
extern RASPORTENUM PRasPortEnum;

typedef DWORD (APIENTRY * RASPORTGETINFO)(HPORT,
                                          PBYTE,
                                          PWORD );
extern RASPORTGETINFO PRasPortGetInfo;

typedef DWORD (APIENTRY * RASPORTSEND)(HPORT,
                                       PBYTE,
                                       WORD);
extern RASPORTSEND PRasPortSend;

typedef DWORD (APIENTRY * RASPORTRECEIVE)(HPORT,
                                          PBYTE,
                                          PWORD,
                                          DWORD,
                                          HANDLE);
extern RASPORTRECEIVE PRasPortReceive;

typedef DWORD (APIENTRY * RASPORTLISTEN)(HPORT,
                                         DWORD,
                                         HANDLE );
extern RASPORTLISTEN PRasPortListen;

typedef DWORD (APIENTRY * RASPORTCONNECTCOMPLETE)(HPORT);
extern RASPORTCONNECTCOMPLETE PRasPortConnectComplete;

typedef DWORD (APIENTRY * RASPORTDISCONNECT)(HPORT,
                                             HANDLE);
extern RASPORTDISCONNECT PRasPortDisconnect;

typedef DWORD (APIENTRY * RASPORTGETSTATISTICS)(HPORT,
                                                PBYTE,
                                                PWORD);
extern RASPORTGETSTATISTICS PRasPortGetStatistics;

typedef DWORD (APIENTRY * RASPORTCLEARSTATISTICS)(HPORT);
extern RASPORTCLEARSTATISTICS PRasPortClearStatistics;

typedef DWORD (APIENTRY * RASDEVICEENUM)(PCHAR,
                                         PBYTE,
                                         PWORD,
                                         PWORD);
extern RASDEVICEENUM PRasDeviceEnum;

typedef DWORD (APIENTRY * RASDEVICEGETINFO)(HPORT,
                                            PCHAR,
                                            PCHAR,
                                            PBYTE,
                                            PWORD);

extern RASDEVICEGETINFO PRasDeviceGetInfo;

typedef DWORD (APIENTRY * RASGETINFO)(HPORT,
                                      RASMAN_INFO*);
extern RASGETINFO PRasGetInfo;

typedef DWORD (APIENTRY * RASGETBUFFER)(PBYTE*,
                                        PWORD);
extern RASGETBUFFER PRasGetBuffer;

typedef DWORD (APIENTRY * RASFREEBUFFER)(PBYTE);
extern RASFREEBUFFER PRasFreeBuffer;

typedef DWORD (APIENTRY * RASREQUESTNOTIFICATION)(HPORT,
                                                  HANDLE);
extern RASREQUESTNOTIFICATION PRasRequestNotification;

typedef DWORD (APIENTRY * RASPORTCANCELRECEIVE)(HPORT);
extern RASPORTCANCELRECEIVE PRasPortCancelReceive;

typedef DWORD (APIENTRY * RASPORTENUMPROTOCOLS)(HPORT,
                                                RAS_PROTOCOLS*,
                                                PWORD);
extern RASPORTENUMPROTOCOLS PRasPortEnumProtocols;

typedef DWORD (APIENTRY * RASPORTSTOREUSERDATA)(HPORT,
                                                PBYTE,
                                                DWORD);
extern RASPORTSTOREUSERDATA PRasPortStoreUserData;

typedef DWORD (APIENTRY * RASPORTRETRIEVEUSERDATA)(HPORT,
                                                   PBYTE,
                                                   DWORD*);
extern RASPORTRETRIEVEUSERDATA PRasPortRetrieveUserData;

typedef DWORD (APIENTRY * RASPORTSETFRAMING)(HPORT,
                                             RAS_FRAMING,
                                             RASMAN_PPPFEATURES*,
                                             RASMAN_PPPFEATURES* );
extern RASPORTSETFRAMING PRasPortSetFraming;

typedef DWORD (APIENTRY * RASPORTSETFRAMINGEX)(HPORT,
                                               RAS_FRAMING_INFO*);
extern RASPORTSETFRAMINGEX PRasPortSetFramingEx;

typedef DWORD (APIENTRY * RASINITIALIZE)();
extern RASINITIALIZE PRasInitialize;

typedef DWORD (APIENTRY * RASSETCACHEDCREDENTIALS)(PCHAR,
                                                   PCHAR,
                                                   PCHAR);

extern RASSETCACHEDCREDENTIALS PRasSetCachedCredentials;

typedef DWORD (APIENTRY * RASGETDIALPARAMS)(DWORD,
                                            LPDWORD,
                                            PRAS_DIALPARAMS);
extern RASGETDIALPARAMS PRasGetDialParams;

typedef DWORD (APIENTRY * RASSETDIALPARAMS)(DWORD,
                                            DWORD,
                                            PRAS_DIALPARAMS,
                                            BOOL);
extern RASSETDIALPARAMS PRasSetDialParams;

typedef DWORD (APIENTRY * RASCREATECONNECTION)(HCONN *);
extern RASCREATECONNECTION PRasCreateConnection;

typedef DWORD (APIENTRY * RASDESTROYCONNECTION)(HCONN);
extern RASDESTROYCONNECTION PRasDestroyConnection;

typedef DWORD (APIENTRY * RASCONNECTIONENUM)(HCONN *,
                                             LPDWORD,
                                             LPDWORD);
extern RASCONNECTIONENUM PRasConnectionEnum;

typedef DWORD (APIENTRY * RASADDCONNECTIONPORT)(HCONN,
                                                HPORT,
                                                DWORD);
extern RASADDCONNECTIONPORT PRasAddConnectionPort;

typedef DWORD (APIENTRY * RASENUMCONNECTIONPORTS)(HCONN,
                                                  RASMAN_PORT *,
                                                  LPDWORD,
                                                  LPDWORD);
extern RASENUMCONNECTIONPORTS PRasEnumConnectionPorts;

typedef DWORD (APIENTRY * RASGETCONNECTIONPARAMS)(HCONN,
                                  PRAS_CONNECTIONPARAMS);
extern RASGETCONNECTIONPARAMS PRasGetConnectionParams;

typedef DWORD (APIENTRY * RASSETCONNECTIONPARAMS)(HCONN,
                                  PRAS_CONNECTIONPARAMS);
extern RASSETCONNECTIONPARAMS PRasSetConnectionParams;

typedef DWORD (APIENTRY * RASGETCONNECTIONUSERDATA)(HCONN,
                                                    DWORD,
                                                    PBYTE,
                                                    LPDWORD);
extern RASGETCONNECTIONUSERDATA PRasGetConnectionUserData;

typedef DWORD (APIENTRY * RASSETCONNECTIONUSERDATA)(HCONN,
                                                    DWORD,
                                                    PBYTE,
                                                    DWORD);
extern RASSETCONNECTIONUSERDATA PRasSetConnectionUserData;

typedef DWORD (APIENTRY * RASGETPORTUSERDATA)(HPORT,
                                              DWORD,
                                              PBYTE,
                                              LPDWORD);
extern RASGETPORTUSERDATA PRasGetPortUserData;

typedef DWORD (APIENTRY * RASSETPORTUSERDATA)(HPORT,
                                              DWORD,
                                              PBYTE,
                                              DWORD);
extern RASSETPORTUSERDATA PRasSetPortUserData;

typedef DWORD (APIENTRY * RASADDNOTIFICATION)(HCONN,
                                              HANDLE,
                                              DWORD);
extern RASADDNOTIFICATION PRasAddNotification;

typedef DWORD (APIENTRY * RASSIGNALNEWCONNECTION)(HCONN);
extern RASSIGNALNEWCONNECTION PRasSignalNewConnection;


/* DHCP.DLL entry points.
*/
typedef DWORD (APIENTRY * DHCPNOTIFYCONFIGCHANGE)(LPWSTR,
                                                  LPWSTR,
                                                  BOOL,
                                                  DWORD,
                                                  DWORD,
                                                  DWORD,
                                                  SERVICE_ENABLE );
extern DHCPNOTIFYCONFIGCHANGE PDhcpNotifyConfigChange;


/* RASIPHLP.DLL entry points.
*/
typedef APIERR (FAR PASCAL * HELPERSETDEFAULTINTERFACENET)(IPADDR,
                                                           BOOL);
extern HELPERSETDEFAULTINTERFACENET PHelperSetDefaultInterfaceNet;

//
// MPRAPI.DLL entry points
//
typedef BOOL (FAR PASCAL * MPRADMINISSERVICERUNNING) (
                                                LPWSTR);


extern MPRADMINISSERVICERUNNING PMprAdminIsServiceRunning;                                                
 
//
// RASCAUTH.DLL entry points.
//
typedef DWORD (FAR PASCAL *AUTHCALLBACK)(HPORT, PCHAR);
extern AUTHCALLBACK g_pAuthCallback;

typedef DWORD (FAR PASCAL *AUTHCHANGEPASSWORD)(HPORT,
                                               PCHAR,
                                               PCHAR,
                                               PCHAR);
extern AUTHCHANGEPASSWORD g_pAuthChangePassword;

typedef DWORD (FAR PASCAL *AUTHCONTINUE)(HPORT);
extern AUTHCONTINUE g_pAuthContinue;

typedef DWORD (FAR PASCAL *AUTHGETINFO)(HPORT,
                                        PAUTH_CLIENT_INFO);
extern AUTHGETINFO g_pAuthGetInfo;

typedef DWORD (FAR PASCAL *AUTHRETRY)(HPORT,
                                      PCHAR,
                                      PCHAR,
                                      PCHAR);
extern AUTHRETRY g_pAuthRetry;

typedef DWORD (FAR PASCAL *AUTHSTART)(HPORT,
                                      PCHAR,
                                      PCHAR,
                                      PCHAR,
                                      PAUTH_CONFIGURATION_INFO,
                                      HANDLE);
extern AUTHSTART g_pAuthStart;

typedef DWORD (FAR PASCAL *AUTHSTOP)(HPORT);
extern AUTHSTOP g_pAuthStop;

//
// RASSCRPT.DLL entry points
//
typedef DWORD (APIENTRY *RASSCRIPTEXECUTE)(HRASCONN,
                                           PBENTRY*,
                                           CHAR*,
                                           CHAR*,
                                           CHAR*);
extern RASSCRIPTEXECUTE g_pRasScriptExecute;

//-------------------------------------------------------
// Function Prototypes
//-------------------------------------------------------

DWORD       RasApiDebugInit();

DWORD       RasApiDebugTerm();

VOID         ReloadRasconncbEntry( RASCONNCB* prasconncb );

VOID         DeleteRasconncbNode( RASCONNCB* prasconncb );

VOID         CleanUpRasconncbNode(DTLNODE *pdtlnode);

VOID         FinalCleanUpRasconncbNode(DTLNODE *pdtlnode);

DWORD        ErrorFromDisconnectReason( RASMAN_DISCONNECT_REASON reason );

IPADDR       IpaddrFromAbcd( TCHAR* pwchIpAddress );

DWORD        LoadDhcpDll();

DWORD        LoadRasAuthDll();

DWORD        LoadRasScriptDll();

DWORD        LoadRasmanDllAndInit();

DWORD        LoadTcpcfgDll();

VOID         UnloadDlls();

DWORD        OnRasDialEvent(ASYNCMACHINE* pasyncmachine,
                            BOOL fDropEvent);

DWORD        OpenMatchingPort(RASCONNCB* prasconncb);

BOOL         FindNextDevice(RASCONNCB *prasconncb);

DWORD        DwOpenPort(RASCONNCB *prasconncb);

DWORD        _RasDial(LPCTSTR,
                      DWORD,
                      BOOL,
                      ULONG_PTR,
                      RASDIALPARAMS*,
                      HWND,
                      DWORD,
                      LPVOID,
                      ULONG_PTR,
                      LPRASDIALEXTENSIONS,
                      LPHRASCONN );

VOID         RasDialCleanup( ASYNCMACHINE* pasyncmachine );

VOID         RasDialFinalCleanup(ASYNCMACHINE* pasyncmachine,
                                 DTLNODE *pdtlnode);

RASCONNSTATE RasDialMachine( RASCONNSTATE rasconnstate,
                             RASCONNCB* prasconncb,
                             HANDLE hEventAuto,
                             HANDLE hEventManual );

VOID         RasDialRestart( RASCONNCB** pprasconncb );

VOID         RasDialTryNextLink(RASCONNCB **pprasconncb);

VOID        RasDialTryNextVpnDevice(RASCONNCB **pprasconncb);

DWORD        ReadPppInfoFromEntry( RASCONNCB* prasconncb );

DWORD        ReadConnectionParamsFromEntry( RASCONNCB* prasconncb,

                 PRAS_CONNECTIONPARAMS pparams );

DWORD        ReadSlipInfoFromEntry(RASCONNCB* prasconncb,
                                   WCHAR** ppwszIpAddress,
                                   BOOL* pfHeaderCompression,
                                   BOOL* pfPrioritizeRemote,
                                   DWORD* pdwFrameSize );

DWORD        SetSlipParams(RASCONNCB* prasconncb);

DWORD        RouteSlip(RASCONNCB* prasconncb,
                       WCHAR* pwszIpAddress,
                       BOOL fPrioritizeRemote,
                       DWORD dwFrameSize );
#if AMB
VOID         SetAuthentication( RASCONNCB* prasconncb,
                                DWORD dwAuthentication );
#endif

DWORD        SetDefaultDeviceParams(RASCONNCB* prasconncb,
                                    TCHAR* pszType,
                                    TCHAR* pszName );

DWORD        GetDeviceParamString(HPORT hport,
                                  TCHAR* pszKey,
                                  TCHAR* pszValue,
                                  TCHAR* pszType,
                                  TCHAR* pszName );

DWORD        SetDeviceParamString(HPORT hport,
                                  TCHAR* pszKey,
                                  TCHAR* pszValue,
                                  TCHAR* pszType,
                                  TCHAR* pszName );

DWORD        SetDeviceParamNumber(HPORT hport,
                                  TCHAR* pszKey,
                                  DWORD dwValue,
                                  TCHAR* pszType,
                                  TCHAR* pszName );

DWORD        SetDeviceParams(RASCONNCB* prasconncb,
                             TCHAR* pszType,
                             TCHAR* pszName,
                             BOOL* pfTerminal);

DWORD        SetMediaParam(HPORT hport,
                           TCHAR* pszKey,
                           TCHAR* pszValue );

DWORD        SetMediaParams(RASCONNCB* prasconncb);

RASCONNCB*   ValidateHrasconn( HRASCONN hrasconn );

RASCONNCB*   ValidateHrasconn2(HRASCONN hrasconn,
                               DWORD dwSubEntry);

RASCONNCB*   ValidatePausedHrasconn(IN HRASCONN hrasconn);

RASCONNCB*   ValidatePausedHrasconnEx(IN HRASCONN hrasconn,
                                      DWORD dwSubEntry);

DWORD        RunApp(LPTSTR lpszApplication,
                    LPTSTR lpszCmdLine);

DWORD        PhonebookEntryToRasEntry(PBENTRY *pEntry,
                                      LPRASENTRY lpRasEntry,
                                      LPDWORD lpdwcb,
                                      LPBYTE lpbDeviceConfig,
                                      LPDWORD lpcbDeviceConfig );

DWORD        RasEntryToPhonebookEntry(LPCTSTR lpszEntry,
                                      LPRASENTRYW lpRasEntry,
                                      DWORD dwcb,
                                      LPBYTE lpbDeviceConfig,
                                      DWORD dwcbDeviceConfig,
                                      PBENTRY *pEntry );

DWORD        PhonebookLinkToRasSubEntry(PBLINK *pLink,
                                        LPRASSUBENTRYW lpRasSubEntry,
                                        LPDWORD lpdwcb,
                                        LPBYTE lpbDeviceConfig,
                                        LPDWORD lpcbDeviceConfig );

DWORD        RasSubEntryToPhonebookLink(PBENTRY *pEntry,
                                        LPRASSUBENTRYW lpRasSubEntry,
                                        DWORD dwcb,
                                        LPBYTE lpbDeviceConfig,
                                        DWORD dwcbDeviceConfig,
                                        PBLINK *pLink );

DWORD        RenamePhonebookEntry(PBFILE *ppbfile,
                                  LPCWSTR lpszOldEntry,
                                  LPCWSTR lpszNewEntry,
                                  DTLNODE *pdtlnode );

DWORD        CopyToAnsi(LPSTR lpszAnsi,
                        LPWSTR lpszUnicode,
                        ULONG ulAnsiMaxSize);

DWORD        CopyToUnicode(LPWSTR lpszUnicode,
                           LPSTR lpszAnsi);

DWORD        SetEntryDialParamsUID(DWORD dwUID,
                                   DWORD dwMask,
                                   LPRASDIALPARAMSW lprasdialparams,
                                   BOOL fDelete);

DWORD        GetEntryDialParamsUID(DWORD dwUID,
                                   LPDWORD lpdwMask,
                                   LPRASDIALPARAMSW lprasdialparams);

DWORD        ConstructPhoneNumber(RASCONNCB *prasconncb);

DWORD        GetAsybeuiLana(HPORT hport,
                            OUT BYTE* pbLana);

DWORD        SubEntryFromConnection(LPHRASCONN lphrasconn);

DWORD        SubEntryPort(HRASCONN hrasconn,
                          DWORD dwSubEntry,
                          HPORT *lphport);

VOID         CloseFailedLinkPorts();

BOOL         GetCallbackNumber(RASCONNCB *prasconncb,
                               PBUSER *ppbuser);

DWORD        SaveProjectionResults(RASCONNCB *prasconncb);

VOID         SetDevicePortName(TCHAR*,
                               TCHAR*,
                               TCHAR*);

VOID         GetDevicePortName(TCHAR*,
                               TCHAR*,
                               TCHAR*);

VOID         ConvertIpxAddressToString(PBYTE,
                                       LPWSTR);

VOID         ConvertIpAddressToString(DWORD,
                                      LPWSTR);

BOOL         InvokeEapUI( HRASCONN            hConn,
                          DWORD               dwSubEntry,
                          LPRASDIALEXTENSIONS lpExtensions,
                          HWND                hWnd);

DWORD        DwEnumEntriesFromPhonebook(
                        LPCWSTR         lpszPhonebookPath,
                        LPBYTE          lprasentryname,
                        LPDWORD         lpcb,
                        LPDWORD         lpcEntries,
                        DWORD           dwSize,
                        DWORD           dwFlags,
                        BOOL            fViewInfo
                        );

DWORD       DwEnumEntriesForPbkMode(
                        DWORD           dwFlags,
                        LPBYTE          lprasentryname,
                        LPDWORD         lpcb,
                        LPDWORD         lpcEntries,
                        DWORD           dwSize,
                        BOOL            fViewInfo
                        );

//
// WOW entry points.
//
DWORD FAR PASCAL RasDialWow(LPSTR lpszPhonebookPath,
                            IN LPRASDIALPARAMSA lpparams,
                            IN HWND hwndNotify,
                            IN DWORD dwRasDialEventMsg,
                            OUT LPHRASCONN lphrasconn );

VOID WINAPI      RasDialFunc1Wow(HRASCONN hrasconn,
                                 UINT unMsg,
                                 RASCONNSTATE rasconnstate,
                                 DWORD dwError,
                                 DWORD dwExtendedError );

DWORD FAR PASCAL RasEnumConnectionsWow(OUT LPRASCONNA lprasconn,
                                       IN OUT LPDWORD lpcb,
                                       OUT LPDWORD lpcConnections);

DWORD FAR PASCAL RasEnumEntriesWow(IN LPSTR reserved,
                                   IN LPSTR lpszPhonebookPath,
                                   OUT LPRASENTRYNAMEA lprasentryname,
                                   IN OUT LPDWORD lpcb,
                                   OUT LPDWORD lpcEntries );

DWORD FAR PASCAL RasGetConnectStatusWow(IN HRASCONN hrasconn,
                        OUT LPRASCONNSTATUSA lprasconnstatus);

DWORD FAR PASCAL RasGetErrorStringWow(IN UINT ResourceId,
                                      OUT LPSTR lpszString,
                                      IN DWORD InBufSize );

DWORD FAR PASCAL RasHangUpWow(IN HRASCONN hrasconn);

DWORD DwCustomHangUp(
            CHAR *lpszPhonebook,
            CHAR *lpszEntryName,
            HRASCONN hRasconn);

DWORD DwCustomDial(LPRASDIALEXTENSIONS lpExtensions,
                   LPCTSTR             lpszPhonebook,
                   CHAR                *pszSystemPbk,
                   LPRASDIALPARAMS     prdp,
                   DWORD               dwNotifierType,
                   LPVOID              pvNotifier,
                   HRASCONN            *phRasConn);


extern DWORD g_dwRasApi32TraceId;

#define RASAPI32_TRACE(a)               TRACE_ID(g_dwRasApi32TraceId, a)
#define RASAPI32_TRACE1(a,b)            TRACE_ID1(g_dwRasApi32TraceId, a,b)
#define RASAPI32_TRACE2(a,b,c)          TRACE_ID2(g_dwRasApi32TraceId, a,b,c)
#define RASAPI32_TRACE3(a,b,c,d)        TRACE_ID3(g_dwRasApi32TraceId, a,b,c,d)
#define RASAPI32_TRACE4(a,b,c,d,e)      TRACE_ID4(g_dwRasApi32TraceId, a,b,c,d,e)
#define RASAPI32_TRACE5(a,b,c,d,e,f)    TRACE_ID5(g_dwRasApi32TraceId, a,b,c,d,e,f)
#define RASAPI32_TRACE6(a,b,c,d,e,f,g)  TRACE_ID6(g_dwRasApi32TraceId, a,b,c,d,e,f,g)


#endif /*_EXTAPI_H_*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\extapi\src\rffile.c ===
/*****************************************************************************
**              Microsoft Rasfile Library
**              Copyright (C) Microsoft Corp., 1992
**
** File Name : rffile.c
**
** Revision History :
**      July 10, 1992   David Kays      Created
**      Dec  12, 1992   Ram   Cherala   Added RFM_KEEPDISKFILEOPEN and support
**                                      code.  This is required to ensure that
**                                      multiple users of rasfile can do file
**                                      operations without any problems.
**
** Description :
**        Rasfile file management routines.
******************************************************************************/

#include "rf.h"

/* Global list of pointers to RASFILE control blocks */
RASFILE  *gpRasfiles[MAX_RASFILES];

/*
 * RasfileLoad :
 *      Loads a file for editing/reading.  Sets the current line to the
 *      first line in the file.
 *
 * Arguments :
 *      lpszPath - full path name for file
 *      dwMode   - mode to open the file
 *              RFM_SYSFORMAT - DOS config.sys style file
 *              RFM_CREATE - create file if it does not exist
 *              RFM_READONLY - open file for reading only
 *              RFM_LOADCOMMENTS - load comments also
 *              RFM_ENUMSECTIONS - load section headers only
 *              RFM_KEEPDISKFILEOPEN - donot close the disk file after read
 *      lpszSection - name of the section to load or NULL for all sections
 *      pfbIsGroup - pointer to user-defined function which returns true
 *                   if a line of text is a group delimiter.
 *
 * Return Value :
 *      A handle to the file if successful, -1 otherwise.
 */

HRASFILE APIENTRY
RasfileLoad( LPCSTR lpszPath, DWORD dwMode,
             LPCSTR lpszSection, PFBISGROUP pfbIsGroup )
{
    DWORD       shflag;
    HRASFILE    hRasfile;
    RASFILE     *pRasfile;
    static BOOL fInited = FALSE;

    if (! fInited)
    {
        memset(gpRasfiles,0,MAX_RASFILES*sizeof(HRASFILE *));
        fInited = TRUE;
    }

    if (lstrlenA(lpszPath) >= MAX_PATH)
        return -1;

    for (hRasfile = 0; hRasfile < MAX_RASFILES; hRasfile++)
        if (! gpRasfiles[hRasfile])
            break;

    if (hRasfile >= MAX_RASFILES)
        return -1;

    if (!(pRasfile = (RASFILE *) Malloc(sizeof(RASFILE))))
        return -1;

    gpRasfiles[hRasfile] = pRasfile;

    pRasfile->dwMode = dwMode;
    if (dwMode & RFM_READONLY)
        shflag = FILE_SHARE_READ | FILE_SHARE_WRITE;  /* read/write access */
    else
        shflag = FILE_SHARE_READ;                     /* deny write access */

    /* if the file doesn't exist and RFM_CREATE is not set then return -1 */
    if (((pRasfile->hFile =
          CreateFileA(lpszPath,GENERIC_READ,shflag,
                      NULL,OPEN_EXISTING,FILE_ATTRIBUTE_READONLY,
                      NULL)) == INVALID_HANDLE_VALUE) &&
        !(dwMode & RFM_CREATE))
    {
        Free(gpRasfiles[hRasfile]);
        gpRasfiles[hRasfile] = NULL;
        return -1;
    }

    /* if the file doesn't exist and RFM_CREATE is set then everything is OK,
        we buffer everything we need in memory and thus we don't need to have
        an empty file hanging around */

    lstrcpynA(pRasfile->szFilename, lpszPath, sizeof(pRasfile->szFilename));
    /* if no specific section is to be loaded, or the Rasfile is new,
        set szSectionName[0] to '\0' */
    if (lpszSection == NULL || dwMode & RFM_ENUMSECTIONS ||
        pRasfile->hFile == INVALID_HANDLE_VALUE)
        pRasfile->szSectionName[0] = '\0';  /* no section name to load */
    else
        lstrcpynA(
            pRasfile->szSectionName,
            lpszSection,
            sizeof(pRasfile->szSectionName));

    pRasfile->pfbIsGroup = pfbIsGroup;
    if (! rasLoadFile(pRasfile))
    {
        Free(gpRasfiles[hRasfile]);
        gpRasfiles[hRasfile] = NULL;
        return -1;
    }
    pRasfile->fDirty = FALSE;

/* RAMC changes begin */

    if (!(dwMode & RFM_KEEPDISKFILEOPEN))
    {
        if (pRasfile->hFile != INVALID_HANDLE_VALUE)
        {
            if (! CloseHandle(pRasfile->hFile))
                return -1;
            pRasfile->hFile = INVALID_HANDLE_VALUE ;
        }
    }

/* RAMC changes end */

    return hRasfile;
}


VOID APIENTRY
RasfileLoadInfo(
               HRASFILE         hrasfile,
               RASFILELOADINFO* pInfo )

/* Loads caller's buffer, 'pInfo' with the original RasfileLoad parameters
** for 'hrasfile'.
*/
{
    RASFILE* prasfile = gpRasfiles[ hrasfile ];

    lstrcpynA(pInfo->szPath, prasfile->szFilename, sizeof(pInfo->szPath));
    pInfo->dwMode = prasfile->dwMode;
    lstrcpynA(
        pInfo->szSection,
        prasfile->szSectionName,
        sizeof(pInfo->szSection));
    pInfo->pfbIsGroup = prasfile->pfbIsGroup;
}


/*
 * RasfileWrite :
 *      Writes the memory image of the file to disk.
 *
 * Arguments :
 *      hrasfile - file handle obtained from RasfileLoad().
 *      lpszPath - full path name of file to write to, or NULL to use
 *                 the same name as was used for RasfileLoad().
 *
 * Return Value :
 *      TRUE if successful, FALSE if not.
 */

BOOL APIENTRY
RasfileWrite( HRASFILE hrasfile, LPCSTR lpszPath )
{
    RASFILE     *pRasfile;

    pRasfile = gpRasfiles[hrasfile];

    /* don't write the file if it was opened for READONLY, or if
        only a single section was loaded */
    if (pRasfile->dwMode & RFM_READONLY ||
        pRasfile->szSectionName[0] != '\0')
        return FALSE;
    if (! pRasfile->fDirty)
        return TRUE;

    return rasWriteFile(pRasfile,lpszPath);
}

/*
 * RasfileClose :
 *      Closes the file and releases all resources.
 *
 * Arguments :
 *      hrasfile - the file handle of the Rasfile to close.
 *
 * Return Value :
 *      TRUE if successful, FALSE if not.
 */

BOOL APIENTRY
RasfileClose( HRASFILE hrasfile )
{
    RASFILE    *pRasfile;
    PLINENODE  lpLineNode;

    pRasfile = gpRasfiles[hrasfile];

    if (pRasfile->hFile != INVALID_HANDLE_VALUE)
        CloseHandle(pRasfile->hFile);

    for (lpLineNode = pRasfile->lpRasLines->next;
        lpLineNode != pRasfile->lpRasLines;)
    {
        Free(lpLineNode->pszLine);
        lpLineNode = lpLineNode->next;
        Free(lpLineNode->prev);
    }

    Free(pRasfile->lpRasLines);
    Free(pRasfile);
    gpRasfiles[hrasfile] = NULL;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\extapi\src\rf.h ===
/*****************************************************************************
**              Microsoft Rasfile Library
**              Copyright (C) Microsoft Corp., 1992
**
** File Name : rf.h
**
** Revision History :
**      July 10, 1992   David Kays      Created
**
** Description :
**      Rasfile file internal header.
******************************************************************************/

#ifndef _RF_
#define _RF_

// Un-comment these, or use C_DEFINES in sources to turn on Unicode
// #define _UNICODE
// #define UNICODE

#include <stdarg.h>     /* For va_list */

#include <excpt.h>      /* for EXCEPTION_DISPOSITION in winbase.h */
#include <windef.h>     /* definition of common types */
#include <winbase.h>    /* win API exports */
#include <winnt.h>      /* definition of string types, e.g. LPSTR */

#ifndef _UNICODE
#include <winnls.h>
#include <mbstring.h>
#define  _MyCMB(_s) ((const unsigned char *)(_s))
#endif

#include <stddef.h>
#include <tchar.h>
#include <stdlib.h>
#include <string.h>
#include <share.h>

#include "rasfile.h"

/* Heap allocation macros allowing easy substitution of alternate heap.  These
** are used by the other utility sections.
*/
#ifndef EXCL_HEAPDEFS
#define Malloc(c)    (void*)GlobalAlloc(0,(c))
#define Realloc(p,c) (void*)GlobalReAlloc((p),(c),GMEM_MOVEABLE)
#define Free(p)      (void*)GlobalFree(p)
#endif

// line tags
typedef BYTE            LineType;
#define TAG_SECTION     RFL_SECTION
#define TAG_HDR_GROUP   RFL_GROUP
#define TAG_BLANK       RFL_BLANK
#define TAG_COMMENT     RFL_COMMENT
#define TAG_KEYVALUE    RFL_KEYVALUE
#define TAG_COMMAND     RFL_COMMAND

// states during file loading
#define SEEK            1
#define FILL            2

// for searching, finding, etc.
#define BEGIN           1
#define END             2
#define NEXT            3
#define PREV            4

#define FORWARD         1
#define BACKWARD        2


//
// RASFILE parameters
//

// Note MAX_RASFILES increased from 10 to 500  12-14-92 perryh

#define MAX_RASFILES        500         // max number of configuration files
#define MAX_LINE_SIZE       RAS_MAXLINEBUFLEN   // max line length
#define TEMP_BUFFER_SIZE    2048        // size of temporary I/O buffer

#define LBRACKETSTR             "["
#define RBRACKETSTR             "]"
#define LBRACKETCHAR            '['
#define RBRACKETCHAR            ']'


//
// line buffer linked list - one linked list per section
//
typedef struct LineNode
{
    struct LineNode *next;
    struct LineNode *prev;
    CHAR            *pszLine;   // char buffer holding the line
    BYTE            mark;       // user defined mark for this line
    LineType        type;       // is this line a comment?
} *PLINENODE;

#define newLineNode()       (PLINENODE) Malloc(sizeof(struct LineNode))

//
// RASFILE control block
//
typedef struct
{
    PLINENODE   lpRasLines;     // list of loaded RASFILE lines
    PLINENODE   lpLine;         // pointer to current line node
    PFBISGROUP  pfbIsGroup;     // user function which determines if
                                //       a line is a group delimiter
    HANDLE      hFile;          // file handle
    DWORD       dwMode;         // file mode bits
    BOOL        fDirty;         // file modified bit
    CHAR        *lpIOBuf;       // temporary I/O buffer
    DWORD       dwIOBufIndex;   // index into temp I/O buffer
    CHAR        szFilename [MAX_PATH];      // full file path name
    CHAR        szSectionName [RAS_MAXSECTIONNAME + 1];     // section to load
} RASFILE;

//
// internal utility routines
//

// list routine
VOID            listInsert(PLINENODE l, PLINENODE elem);

// rffile.c support
BOOL            rasLoadFile( RASFILE * );
LineType        rasParseLineTag( RASFILE *, LPCSTR );
LineType        rasGetLineTag( RASFILE *, LPCSTR );
BOOL            rasInsertLine( RASFILE *, LPCSTR, BYTE, BYTE * );
BOOL            rasWriteFile( RASFILE *, LPCSTR );
BOOL            rasGetFileLine( RASFILE *, LPSTR, DWORD * );
BOOL            rasPutFileLine( HANDLE, LPCSTR );

// rfnav.c support
PLINENODE       rasNavGetStart( RASFILE *, RFSCOPE, BYTE );
BOOL            rasLineInScope( RASFILE *, RFSCOPE );
PLINENODE       rasGetStartLine (RASFILE *, RFSCOPE, BYTE );
BOOL            rasFindLine( HRASFILE , BYTE, RFSCOPE, BYTE, BYTE );
VOID            rasExtractSectionName( LPCSTR, LPSTR );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\extapi\src\rfutil.c ===
/*****************************************************************************
**              Microsoft Rasfile Library
**              Copyright (C) Microsoft Corp., 1992
**
** File Name : rfutil.c
**
** Revision History :
**      July 10, 1992   David Kays      Created
**      Dec  21, 1992   Ram Cherala     Added a check to rasGetFileLine to
**                                      ensure that we terminate if a file
**                                      has no terminating new line. <M001>
**
** Description :
**      Rasfile interal utility routines.
******************************************************************************/

#include "rf.h"
#include "mbstring.h"
#include "raserror.h"

extern RASFILE *gpRasfiles[];

/*
 * rffile.c support routines
 */

VOID
FixCorruptFile(RASFILE *pRasfile)
{
    //
    // If we find a corrupt phonebook, try
    // to rename the phonebook as <filename>.pbk.bad
    // and return an error. This way the next
    // time we start with no phonebook and force
    // the user to create a phonebook.
    //

    if(lstrlenA(pRasfile->szFilename))
    {
        CHAR *pszFileName = NULL;
        DWORD dwSize =
                2 * (lstrlenA(pRasfile->szFilename) + lstrlenA(".bad") + 1);

        pszFileName = (CHAR *) LocalAlloc(LPTR, dwSize);

        if(NULL != pszFileName)
        {
            lstrcpynA(pszFileName, pRasfile->szFilename, dwSize);
            strncat(pszFileName, ".bad", dwSize - strlen(pszFileName));
            
            //
            // We ignore errors here because there's
            // nothing much we can do in error cases.
            //
            if(!DeleteFileA(pszFileName))
            {
                DWORD ret = GetLastError();
            }

            if(!MoveFileA(pRasfile->szFilename, 
                     pszFileName))
            {
                DWORD ret = GetLastError();
            }

            LocalFree(pszFileName);
        }
    }                             
}

/*
 * rasLoadFile :
 *      Loads a Rasfile from disk into memory.  Lines are parsed
 *      and the linked list of RASFILE control block lines is created.
 *
 * Arguments :
 *      pRasfile - pointer to a Rasfile control block
 *
 * Return Value :
 *      TRUE if the file is successfully loaded, FALSE otherwise.
 *
 * Remarks :
 *      Called by API RasfileLoad() only.
 */
BOOL rasLoadFile( RASFILE *pRasfile )
{
    CHAR                szLinebuf[MAX_LINE_SIZE];
    PLINENODE           lpRasLines;
    LineType            tag;
    BYTE                state;
    DWORD               dwErr = ERROR_SUCCESS;

    if (lpRasLines = newLineNode())
        pRasfile->lpRasLines = lpRasLines;
    else
        return FALSE;

    lpRasLines->next = lpRasLines->prev = lpRasLines;

    /* pRasfile->hFile == INVALID_HANDLE_VALUE iff a new Rasfile is loaded */
    if (pRasfile->hFile == INVALID_HANDLE_VALUE)
    {

#if 0
        /* Why return false only in READONLY mode?
        ** If you un-remove this you have to clean up the allocation above.
        */
        if (pRasfile->dwMode & RFM_READONLY)
            return FALSE;
#endif

        pRasfile->lpLine = lpRasLines;
        return TRUE;
    }

    if (pRasfile->dwMode & RFM_SYSFORMAT ||
        pRasfile->szSectionName[0] == '\0')
        state = FILL;   /* loading the whole file, set seek to FILL */
    else
        state = SEEK;   /* loading a single section, must SEEK to find it */

    /* set up temp buffer for file read */
    {
        CHAR* psz = Malloc(TEMP_BUFFER_SIZE);

        if (psz)
            pRasfile->lpIOBuf = psz;
        else
        {
            Free(pRasfile->lpRasLines);
            pRasfile->lpRasLines = NULL;
            return FALSE;
        }
    }

    pRasfile->dwIOBufIndex = TEMP_BUFFER_SIZE;
    for (;;)
    {
        /* get next line from the file */
        if (! rasGetFileLine(pRasfile,szLinebuf, &dwErr))
        {
            if(ERROR_SUCCESS != dwErr)
            {
                Free(pRasfile->lpRasLines);
                pRasfile->lpRasLines = NULL;
                CloseHandle(pRasfile->hFile);
                Free(pRasfile->lpIOBuf);
                    
                if(ERROR_CORRUPT_PHONEBOOK == dwErr)
                {
                    FixCorruptFile(pRasfile);
                }
                
                return FALSE;
            }
            
            break;
        }
        tag = rasParseLineTag(pRasfile,szLinebuf);
        /* finished loading if rasInsertLine() returns TRUE */
        if (rasInsertLine(pRasfile,szLinebuf,tag,&state) == TRUE)
            break;
    }
    pRasfile->lpLine = pRasfile->lpRasLines->next;

    Free(pRasfile->lpIOBuf);

    return TRUE;
}

/*
 * rasParseLineTag :
 *      Calls rasGetLineTag() to determine the tag value for a line,
 *      checks if the line is a GROUP header, then returns the final
 *      tag value for the line.
 *
 * Arguments :
 *      pRasfile - pointer to Rasfile control block
 *      lpszLine - pointer to Rasfile line
 *
 * Return Value :
 *      The tag value for the given line.
 *
 * Remarks :
 *      Called by rasLoadFile() and APIs RasfilePutLineText() and
 *      RasfileInsertLine() only.
 */
LineType rasParseLineTag( RASFILE *pRasfile, LPCSTR lpszLine )
{
    LineType    type;

    type = rasGetLineTag( pRasfile, lpszLine );
    /* check if this line is a GROUP line also */
    if (pRasfile->pfbIsGroup != NULL &&
        (*(pRasfile->pfbIsGroup))(lpszLine))
        return type | TAG_HDR_GROUP;
    else
        return type;
}


/*
 * rasGetLineTag :
 *      Determines the tag value for a line and returns this value.
 *
 * Arguments :
 *      pRasfile - pointer to Rasfile control block
 *      lpszLine - pointer to Rasfile line.
 *
 * Return Value :
 *      The tag value for the given line, excluding the check for a
 *      GROUP line.
 *
 * Remarks :
 *      Called by rasParseLineTag() only.
 */
LineType rasGetLineTag( RASFILE *pRasfile, LPCSTR lpszLine )
{
    LPCSTR      ps;

    ps = lpszLine;
    /* skip white space */
    for (; *ps == ' ' || *ps == '\t' ; ps++)
        ;
    if (*ps == '\0')
        return TAG_BLANK;

    if ((pRasfile->dwMode & RFM_SYSFORMAT) &&
             ((*ps == 'r') || (*ps == 'R') || (*ps == '@')))
    {
        if (*ps == '@')
            /* skip white space */
            for (; *ps == ' ' || *ps == '\t' ; ps++)
                ;
        if (!_strnicmp(ps,"rem ",4))
            return TAG_COMMENT;
    }
    else
    {  /* .ini style */
        if (*ps == ';')
            return TAG_COMMENT;
        if (*ps == LBRACKETCHAR)
            return TAG_SECTION;
    }
    /* already checked for COMMENT or SECTION */
    /* check for KEYVALUE or COMMAND now */
    if (strchr(lpszLine, '='))
        return TAG_KEYVALUE;
    else
        return TAG_COMMAND;
}

/*
 * rasInsertLine :
 *  Inserts the given line into the linked list of Rasfile control block
 *  lines if the given state and line tag match correctly.
 *
 * Arguments :
 *  pRasfile - pointer to Rasfile control block
 *  lpszLine - pointer to Rasfile line which may be inserted
 *  tag      - tag value for lpszLine obtained from rasParseLineTag().
 *  state    - current state of rasLoadFile() :
 *      FILL - the lines of a section (or whole file) are currently
 *              being loaded
 *      SEEK - the correct section to load is currently being searched
 *              for
 *
 * Return Value :
 *  TRUE if the current line was the last Rasfile line to load, FALSE
 *  otherwise.
 *
 * Remarks :
 *  Called by rasLoadFile() only.
 */
BOOL rasInsertLine( RASFILE *pRasfile, LPCSTR lpszLine,
                    BYTE tag, BYTE *state )
{
    PLINENODE    lpLineNode;

    if (tag & TAG_SECTION)
    {
        // if a particular section has been being filled and a new
        // section header is encountered, we're done
        //
        if ((*state == FILL) && (pRasfile->szSectionName[0] != '\0'))
        {
            return TRUE;
        }

        // return if this is not the section we're looking for
        //
        if (pRasfile->szSectionName[0] != '\0')
        {
            // Find the left and right brackets.  Search from the beginning
            // of the line for the left bracket and from the end of the line
            // for the right bracket.
            //
            CHAR* pchLeftBracket  = strchr (lpszLine, LBRACKETCHAR);
            CHAR* pchRightBracket = strrchr(lpszLine, RBRACKETCHAR);

            if (pchLeftBracket && pchRightBracket &&
                (pchLeftBracket < pchRightBracket))
            {
                INT cchSectionName = (INT)(pchRightBracket - pchLeftBracket - 1);

                if (!(cchSectionName == lstrlenA(pRasfile->szSectionName) &&
                     (0 == _strnicmp(pchLeftBracket + 1,
                            pRasfile->szSectionName, cchSectionName))))
                {
                    return FALSE;
                }
            }
        }

        *state = FILL;
    }
    /* for non-section header lines, no action is taken if :
    we're seeking for a section still, we're only enumerating sections, or
    the line is a comment or blank and we're not loading comment lines */
    else if (*state == SEEK ||
             pRasfile->dwMode & RFM_ENUMSECTIONS ||
             (tag & (TAG_COMMENT | TAG_BLANK) &&
              !(pRasfile->dwMode & RFM_LOADCOMMENTS)))
    {
        return FALSE;
    }

    if (!(lpLineNode = newLineNode()))
    {
        return FALSE;
    }

    {
        CHAR* psz = Malloc((lstrlenA(lpszLine) + 1));

        if (psz)
            lpLineNode->pszLine = psz;
        else
        {
            Free(lpLineNode);
            return FALSE;
        }
    }

    pRasfile->lpLine=lpLineNode;

    /* insert the new line to the end of the Rasfile line list */
    listInsert(pRasfile->lpRasLines->prev,lpLineNode);
    lpLineNode->mark = 0;
    lpLineNode->type = tag;

    lstrcpynA(lpLineNode->pszLine, lpszLine, lstrlenA(lpszLine) + 1);

    return FALSE;
}

/*
 * rasWriteFile :
 *      Write the memory image of the given Rasfile to the given
 *      filename or to the original loaded file name if the given
 *      filename is NULL.
 *
 * Arguments :
 *      pRasfile - pointer to Rasfile control block
 *      lpszPath - path name of the file to write to or NULL if the
 *                 same name that was used to load should be used.
 *
 * Return Value :
 *      TRUE if successful, FALSE otherwise.
 *
 * Remarks :
 *      Called by API RasfileWrite() only.
 */
BOOL rasWriteFile( RASFILE *pRasfile, LPCSTR lpszPath )
{
    HANDLE              fhNew;
    PLINENODE           lpLine;

    /* (re)open file for writing/reading */
    if (lpszPath == NULL)
    {
        /* close and re-open same file as empty file for writing */
        if (pRasfile->hFile != INVALID_HANDLE_VALUE &&
            ! CloseHandle(pRasfile->hFile))
            return FALSE;

        if ((fhNew = CreateFileA(pRasfile->szFilename,
                                 GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ,
                                 NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL,
                                 NULL)) == INVALID_HANDLE_VALUE)
        {
            pRasfile->hFile = INVALID_HANDLE_VALUE;
            return FALSE;
        }
    }
    else
    {
        if ((fhNew = CreateFileA(lpszPath,
                                 GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ,
                                 NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL,
                                 NULL)) == INVALID_HANDLE_VALUE)
            return FALSE;
    }


    /* write out file */
    for (lpLine = pRasfile->lpRasLines->next;
        lpLine != pRasfile->lpRasLines;
        lpLine = lpLine->next)
    {
        rasPutFileLine(fhNew,lpLine->pszLine);
    }


    if (lpszPath == NULL)
    {
        if (pRasfile->hFile == INVALID_HANDLE_VALUE)
            CloseHandle( fhNew );
        else
            pRasfile->hFile = fhNew;
    }

    return TRUE;
}

/*
 * rasGetFileLine :
 *      Get the next line of text from the given open Rasfile.
 *
 * Arguments :
 *      pRasfile - pointer to Rasfile control block.
 *      lpLine - buffer to hold the next line
 *
 * Return Value :
 *      TRUE if successful, FALSE if EOF was reached.
 *
 * Comments :
 *      All lines in Rasfile files are assumed to end in a newline (i.e.,
 *      no incomplete lines followed by an EOF
 */
BOOL rasGetFileLine( RASFILE *pRasfile, LPSTR lpLine, DWORD *pErr )
{
    DWORD       dwBytesRead = 0, dwCharsRead = 0;
    DWORD       dwChars = 0;

    for (;;)
    {
        if (pRasfile->dwIOBufIndex == TEMP_BUFFER_SIZE)
        {
            if(!ReadFile(pRasfile->hFile,pRasfile->lpIOBuf,
                     TEMP_BUFFER_SIZE,&dwBytesRead,NULL))
            {
                return FALSE;
            }

            dwCharsRead = dwBytesRead;
            pRasfile->dwIOBufIndex = 0;
            if (dwBytesRead == 0)
                return FALSE;
            if (dwCharsRead < TEMP_BUFFER_SIZE)
                pRasfile->lpIOBuf[dwCharsRead] = '\0';
        }
        if (pRasfile->lpIOBuf[pRasfile->dwIOBufIndex] == '\0')
            return FALSE;

        /* fill lpLine with the next line */
        for (; pRasfile->dwIOBufIndex < TEMP_BUFFER_SIZE ;)
        {
            *lpLine = pRasfile->lpIOBuf[pRasfile->dwIOBufIndex++];
            dwChars += 1;

            if(dwChars >= (MAX_LINE_SIZE - 1))
            {
                *pErr = ERROR_CORRUPT_PHONEBOOK;
                return FALSE;
            }
            
            // replace all CR/LF pairs with null
            if (*lpLine == '\r')
                continue;
            else if (*lpLine == '\n')
            {
                *lpLine = '\0';
                return TRUE;
            }
/*<M001>*/
            else if (*lpLine == '\0')
                return TRUE;
/*<M001>*/
            else
                lpLine++;
        }
        /* possibly continue outer for loop to read a new file block */
    }
}

/*
 * rasPutFileLine :
 *      Write the line of text to the given Rasfile file.
 *
 * Arguments :
 *      hFile - pointer to open file
 *      lpLine - buffer containing the line to write (without newline)
 *
 * Return Value :
 *      TRUE if successful, FALSE otherwise.
 */
BOOL rasPutFileLine( HANDLE hFile, LPCSTR lpLine )
{
    DWORD       dwWritten;
    CHAR        szBuf[2*MAX_LINE_SIZE + 2];

    lstrcpynA(szBuf,lpLine, MAX_LINE_SIZE - 2);
    lstrcatA(szBuf,"\r\n");   // don't forget the CR/LF pair
    WriteFile(hFile,szBuf,lstrlenA(szBuf),&dwWritten,NULL);
    return TRUE;
}

/*
 * rfnav.c support routines
 */

/*
 * rasNavGetStart :
 *      Returns the starting line for a Rasfile find line
 *      search to begin.  Calls rasLineInScope() and rasGetStartLine()
 *      to do all the work.
 *
 * Arguments :
 *      pRasfile - pointer to Rasfile control block
 *      rfscope - the scope in which to look for the start line
 *      place - where in the scope the start line is :
 *              BEGIN - the first line in the scope
 *              END - the last line in the scope
 *              NEXT - the next line in the scope
 *              PREV - the previous line in the scope
 *
 * Return Value :
 *      A valid PLINE if a line at the given place in the given scope
 *      could be found, otherwise NULL.
 *
 * Remarks :
 *      Called by rasFindLine() only.
 */
PLINENODE rasNavGetStart( RASFILE *pRasfile, RFSCOPE rfscope, BYTE place )
{
    PLINENODE           lpNewLine;

    /* check error conditions */
    /* if place is NEXT or PREV, there must be a current line, and the
        next/prev line must be valid */
    if (place == NEXT || place == PREV)
    {
        if (pRasfile->lpLine == pRasfile->lpRasLines)
            return NULL;
        lpNewLine = (place == NEXT) ?
                    pRasfile->lpLine->next : pRasfile->lpLine->prev;
        if (lpNewLine == pRasfile->lpRasLines)
            return NULL;                /* no next or prev line */
    }

    if (! rasLineInScope( pRasfile, rfscope ))
        return NULL;
    return rasGetStartLine( pRasfile, rfscope, place );
}

/*
 * rasLineInScope :
 *      Determines whether the current line for the given Rasfile control
 *      block is currently within the given scope.
 *
 * Arguments :
 *      pRasfile - pointer to Rasfile control block
 *      rfscope - scope to check current line's residence within
 *
 * Return Value :
 *      TRUE if the current line is within the given scope, FALSE otherwise.
 *
 * Remarks :
 *      Called by rasNavGetStart() only.
 */
BOOL rasLineInScope( RASFILE *pRasfile, RFSCOPE rfscope )
{
    PLINENODE   lpLine;
    BYTE        tag;

    if (rfscope == RFS_FILE)
        return TRUE;
    if (pRasfile->lpLine == pRasfile->lpRasLines)
        return FALSE;
    tag = (rfscope == RFS_SECTION) ? TAG_SECTION : TAG_HDR_GROUP;
    for (lpLine = pRasfile->lpLine; lpLine != pRasfile->lpRasLines;
        lpLine = lpLine->prev)
    {
        if (lpLine->type & tag)
            return TRUE;
        /* not in GROUP scope if a new section is encountered first */
        if ((lpLine->type & TAG_SECTION) && (tag == TAG_HDR_GROUP))
            return FALSE;
    }
    return FALSE;
}


/*
 * rasGetStartLine :
 *      Returns the Rasfile line which is in the given place in the
 *      given scope of the Rasfile passed.
 *
 * Arguments :
 *      pRasfile - pointer to Rasfile control block
 *      rfscope -  the scope in which to search for the proper line
 *      place -  which line in the given scope to return
 *
 * Return Value :
 *      A valid PLINE if a line at the given place in the given scope
 *      could be found, otherwise NULL.
 *
 * Remarks :
 *      Called by rasNavGetStart() only.
 */
PLINENODE rasGetStartLine( RASFILE *pRasfile, RFSCOPE rfscope, BYTE place )
{
    PLINENODE   lpLine;
    BYTE        tag;

    tag = (rfscope == RFS_SECTION) ? TAG_SECTION : TAG_SECTION | TAG_HDR_GROUP;
    switch (place)
    {
        case NEXT :
            if (rfscope == RFS_FILE) return pRasfile->lpLine->next;
            /* return NULL if the next line is a line of the given scope */
            else  return (pRasfile->lpLine->next->type & tag) ?
                NULL : pRasfile->lpLine->next;
        case PREV :
            if (rfscope == RFS_FILE) return pRasfile->lpLine->prev;
            /* return NULL if the current line is a line of the given scope */
            else  return (pRasfile->lpLine->type & tag) ?
                NULL : pRasfile->lpLine->prev;
        case BEGIN :
            if (rfscope == RFS_FILE) return pRasfile->lpRasLines->next;
            /* else */
            /* search backward for the correct tag */
            for (lpLine = pRasfile->lpLine;
                !(lpLine->type & tag);
                lpLine = lpLine->prev)
                ;
            return lpLine;
        case END :
            if (rfscope == RFS_FILE) return pRasfile->lpRasLines->prev;
            /* else */
            /* search forward for the correct tag */
            for (lpLine = pRasfile->lpLine->next;
                lpLine != pRasfile->lpRasLines &&
                !(lpLine->type & tag);
                lpLine = lpLine->next)
                ;
            return lpLine->prev;
    }

    return NULL;
}

/*
 * rasFindLine :
 *      Finds a line of the given type in the given scope, starting
 *      at the location in the scope described by 'begin' and searching
 *      in the direction given by 'where'.  Sets the current line to this
 *      line if found.
 *
 * Arguments :
 *      hrasfile - Rasfile handle obtained by call to RasfileLoad()
 *      bType   - the type of line being searched for
 *      rfscope - the scope to in which to search for the line
 *      bStart - where in the given scope to begin the search for a line of
 *              of the given type (see rasNavGetStart()).
 *      bDirection - which direction to make the search in :
 *              FORWARD - check lines following the start line
 *              BACKWARD - check line preceding the start line
 *
 * Return Value :
 *      TRUE if a line of the proper type in the given scope is found
 *      and current line is set to this line, FALSE otherwise.
 *
 * Remarks :
 *      Called by APIs RasfileFindFirstLine(), RasfileFindLastLine(),
 *      RasfileFindNextLine(), and RasfileFindPrevLine() only.
 */
BOOL rasFindLine( HRASFILE hrasfile,  BYTE bType,
                  RFSCOPE rfscope, BYTE bStart, BYTE bDirection )
{
    RASFILE             *pRasfile;
    PLINENODE           lpLine;
    BYTE                tag;

    pRasfile = gpRasfiles[hrasfile];

    if ((lpLine = rasNavGetStart(pRasfile,rfscope,bStart)) == NULL)
        return FALSE;
    tag = (rfscope == RFS_SECTION) ? TAG_SECTION : TAG_SECTION | TAG_HDR_GROUP;

    for (; lpLine != pRasfile->lpRasLines;
        lpLine = (bDirection == BACKWARD ) ?
        lpLine->prev : lpLine->next)
    {
        /* did we find the correct line? */
        if (lpLine->type & bType)
        {
            pRasfile->lpLine = lpLine;
            return TRUE;
        }

        /* backward non-file search ends after we've checked the
           beginning line for the group or section */
        if (rfscope != RFS_FILE && bDirection == BACKWARD &&
            (lpLine->type & tag))
            return FALSE;
        /* forward non-file search ends if the next line is a new
           group header or section, respectively */
        if (rfscope != RFS_FILE && bDirection == FORWARD &&
            (lpLine->next->type & tag))
            return FALSE;
    }
    return FALSE;
}


VOID
rasExtractSectionName(
                     IN  LPCSTR pszSectionLine,
                     OUT LPSTR pszSectionName )

/* Extracts the section name from the []ed line text, 'pszSectionLine',
** and loads it into caller's 'pszSectionName' buffer.
*/
{
    LPCSTR pchAfterLBracket;
    LPCSTR pchLastRBracket;
    LPCSTR psz;

    pchAfterLBracket =
    pszSectionLine + _mbscspn( pszSectionLine, LBRACKETSTR ) + 1;
    pchLastRBracket = NULL;

    for (psz = pchAfterLBracket; *psz; ++psz)
    {
        if (*psz == RBRACKETCHAR)
            pchLastRBracket = psz;
    }

    if (!pchLastRBracket)
        pchLastRBracket = psz;

#ifndef _UNICODE
    for (psz = pchAfterLBracket;
        psz != pchLastRBracket;)
    {
        if (IsDBCSLeadByte(*psz))
        {
            *pszSectionName++ = *psz++;
        }

        *pszSectionName++ = *psz++;
    }

#else
    for (psz = pchAfterLBracket;
        psz != pchLastRBracket;
        *pszSectionName++ = *psz++);
#endif

    *pszSectionName = '\0';
}


/*
 * List routine
 */

/*
 * listInsert :
 *      Inserts an element into a linked list.  Element 'elem' is
 *      inserted after list element 'l'.
 *
 * Arguments :
 *      l - list
 *      elem - element to insert
 *
 * Return Value :
 *      None.
 *
 */
void listInsert( PLINENODE l, PLINENODE elem )
{
    elem->next = l->next;
    elem->prev = l;
    l->next->prev = elem;
    l->next = elem;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\extapi\src\rfedit.c ===
/*****************************************************************************
**              Microsoft Rasfile Library
**              Copyright (C) Microsoft Corp., 1992
**
** File Name : rfedit.c
**
** Revision History :
**      July 10, 1992   David Kays      Created
**
** Description :
**      Rasfile file line editing routines.
******************************************************************************/

#include "rf.h"
#include "mbstring.h"

extern RASFILE *gpRasfiles[];

/*
 * RasfileGetLine :
 *      Returns a readonly pointer to the current line.
 *
 * Arguments :
 *      hrasfile - file handle obtained from RasfileLoad().
 *
 * Return Values :
 *      A valid string pointer if there is a current line, NULL otherwise.
 */
const LPCSTR APIENTRY
RasfileGetLine( HRASFILE hrasfile )
{
    RASFILE     *pRasfile;

    pRasfile = gpRasfiles[hrasfile];

    if (pRasfile->lpLine == pRasfile->lpRasLines)
        return NULL;

    return pRasfile->lpLine->pszLine;
}

/*
 * RasfileGetLineText :
 *      Loads caller's buffer with the text of the current line.
 *
 * Arguments :
 *      hrasfile - file handle obtained from RasfileLoad().
 *      lpszLine - the buffer to load with the current line.
 *
 * Return Values :
 *      TRUE if successful, FALSE otherwise.
 */
BOOL APIENTRY
RasfileGetLineText( HRASFILE hrasfile, LPSTR lpszLine )
{
    RASFILE     *pRasfile;

    pRasfile = gpRasfiles[hrasfile];

    if (pRasfile->lpLine == pRasfile->lpRasLines)
        return FALSE;

    lstrcpynA(lpszLine, pRasfile->lpLine->pszLine, RAS_MAXLINEBUFLEN);
    return TRUE;
}

/*
 * RasfilePutLineText :
 *      Set the text of the current line to the given text.
 *
 * Arguments :
 *      hrasfile - file handle obtained from RasfileLoad().
 *      lpszLine - buffer containing new line text.
 *
 * Return Values :
 *      TRUE if successful, FALSE otherwise.
 */
BOOL APIENTRY
RasfilePutLineText( HRASFILE hrasfile, LPCSTR lpszLine )
{
    RASFILE     *pRasfile;

    pRasfile = gpRasfiles[hrasfile];

    if (lstrlenA(lpszLine) > RAS_MAXLINEBUFLEN)
        return FALSE;
    if (pRasfile->lpLine == pRasfile->lpRasLines)
        return FALSE;

    if (lstrlenA(lpszLine) > lstrlenA(pRasfile->lpLine->pszLine))
    {
        CHAR* psz = Realloc(pRasfile->lpLine->pszLine,
                            lstrlenA(lpszLine) + 1 );
        if (psz)
            pRasfile->lpLine->pszLine=psz;
        else
            return FALSE;
    }

    lstrcpynA(pRasfile->lpLine->pszLine, lpszLine, RAS_MAXLINEBUFLEN);

    pRasfile->lpLine->type = rasParseLineTag(pRasfile,lpszLine);

    pRasfile->fDirty = TRUE;
    return TRUE;
}

/*
 * RasfileGetLineMark :
 *      Returns the user-defined mark value for the current line.
 *
 * Arguments :
 *      hrasfile - file handle obtained from RasfileLoad().
 *
 * Return Values :
 *      The current line's mark value or 0 if there is no current line
 *      or the current line is not marked.
 */
BYTE APIENTRY
RasfileGetLineMark( HRASFILE hrasfile )
{
    RASFILE     *pRasfile;

    pRasfile = gpRasfiles[hrasfile];

    if (pRasfile->lpLine == pRasfile->lpRasLines)
        return FALSE;

    return pRasfile->lpLine->mark;
}

/*
 * RasfilePutLineMark :
 *      Marks the current line with the given number.
 *
 * Arguments :
 *      hrasfile - file handle obtained from RasfileLoad().
 *      bMark - value to mark the current line with.
 *
 * Return Values :
 *      TRUE if successful, FALSE otherwise.
 */
BOOL APIENTRY
RasfilePutLineMark( HRASFILE hrasfile, BYTE bMark )
{
    RASFILE     *pRasfile;

    pRasfile = gpRasfiles[hrasfile];

    if (pRasfile->lpLine == pRasfile->lpRasLines)
        return FALSE;

    pRasfile->lpLine->mark = bMark;
    return TRUE;
}

/*
 * RasfileGetLineType :
 *      Returns the current line's type bit mask.
 *
 * Arguments :
 *      hrasfile - file handle obtained from RasfileLoad().
 *
 * Return Values :
 *      The current line's bit mask if current line is valid, 0 otherwise.
 */
BYTE APIENTRY
RasfileGetLineType( HRASFILE hrasfile )
{
    RASFILE     *pRasfile;

    pRasfile = gpRasfiles[hrasfile];

    if (pRasfile->lpLine == pRasfile->lpRasLines)
        return FALSE;

    return pRasfile->lpLine->type & RFL_ANY;
}

/*
 * RasfileInsertLine :
 *      Inserts a line before or after the current line with the
 *      given text.
 *
 * Arguments :
 *      hrasfile - file handle obtained from RasfileLoad().
 *      lpszLine - the text of the inserted line.
 *      fBefore - TRUE to insert before the current line, FALSE to
 *                insert after the current line.
 *
 * Return Values :
 *      TRUE if successful, FALSE otherwise.
 */
BOOL APIENTRY
RasfileInsertLine( HRASFILE hrasfile, LPCSTR lpszLine, BOOL fBefore )
{
    RASFILE     *pRasfile;
    PLINENODE   lpLineNode;

    pRasfile = gpRasfiles[hrasfile];

    if (!(lpLineNode = newLineNode()))
        return FALSE;

    {
        CHAR* psz = Malloc(lstrlenA(lpszLine) + 1);

        if (psz)
            lpLineNode->pszLine = psz;
        else
        {
            Free(lpLineNode);
            return FALSE;
        }
    }

    lstrcpynA(lpLineNode->pszLine, lpszLine, lstrlenA(lpszLine) + 1);
    lpLineNode->type = rasParseLineTag(pRasfile,lpszLine);
    lpLineNode->mark = 0;

    if (fBefore)
        listInsert(pRasfile->lpLine->prev,lpLineNode);
    else
        listInsert(pRasfile->lpLine,lpLineNode);

    pRasfile->fDirty = TRUE;
    return TRUE;
}

/*
 * RasfileDeleteLine :
 *      Delete the current line.
 *
 * Arguments :
 *      hrasfile - file handle obtained from RasfileLoad().
 *
 * Return Values :
 *      TRUE if successful, FALSE otherwise.
 */
BOOL APIENTRY
RasfileDeleteLine( HRASFILE hrasfile )
{
    RASFILE     *pRasfile;
    PLINENODE   lpOldLine;

    pRasfile = gpRasfiles[hrasfile];

    if (pRasfile->lpLine == pRasfile->lpRasLines)
        return FALSE;

    lpOldLine = pRasfile->lpLine;
    pRasfile->lpLine = lpOldLine->next;

    /* delete lpOldLine from the list of lines */
    lpOldLine->next->prev = lpOldLine->prev;
    lpOldLine->prev->next = lpOldLine->next;
    Free(lpOldLine->pszLine);
    Free(lpOldLine);

    pRasfile->fDirty = TRUE;
    return TRUE;
}

/*
 * RasfileGetSectionName :
 *      Return the current section name in the given buffer.
 *
 * Arguments :
 *      hrasfile - file handle obtained from RasfileLoad().
 *      lpszSectionName - buffer to load the section name into.
 *
 * Return Values :
 *      TRUE if successful, FALSE otherwise.
 */
BOOL APIENTRY
RasfileGetSectionName( HRASFILE hrasfile, LPSTR lpszSectionName )
{
    RASFILE* pRasfile;

    pRasfile = gpRasfiles[ hrasfile ];

    if (pRasfile->lpLine == pRasfile->lpRasLines)
        return FALSE;
    if (!(pRasfile->lpLine->type & TAG_SECTION))
        return FALSE;

    rasExtractSectionName( pRasfile->lpLine->pszLine, lpszSectionName );
    return TRUE;
}

/*
 * RasfilePutSectionName :
 *      Set the current line to a section line of the given name.
 *
 * Arguments :
 *      hrasfile - file handle obtained from RasfileLoad().
 *      lpszSectionName - name of the section.
 *
 * Return Values :
 *      TRUE if successful, FALSE otherwise.
 */
BOOL APIENTRY
RasfilePutSectionName( HRASFILE hrasfile, LPCSTR lpszSectionName )
{
    INT iSize = 0;
    RASFILE     *pRasfile;

    pRasfile = gpRasfiles[hrasfile];

    if (pRasfile->lpLine == pRasfile->lpRasLines)
        return FALSE;

    iSize = lstrlenA(lpszSectionName);

    /* remember to include '[' and ']' in string length for section */
    if ((iSize + 2) > lstrlenA(pRasfile->lpLine->pszLine))
    {
        CHAR* psz = Realloc(pRasfile->lpLine->pszLine,
                            iSize + 3);

        if (psz)
            pRasfile->lpLine->pszLine=psz;
        else
            return FALSE;
    }
    lstrcpynA(pRasfile->lpLine->pszLine, LBRACKETSTR, iSize + 3);

    strncat(
        pRasfile->lpLine->pszLine,
        lpszSectionName,
        (iSize + 3) - strlen(pRasfile->lpLine->pszLine));

    strncat(
        pRasfile->lpLine->pszLine,
        RBRACKETSTR,
        (iSize + 3) - strlen(pRasfile->lpLine->pszLine));

    pRasfile->lpLine->type = TAG_SECTION;

    pRasfile->fDirty = TRUE;
    return TRUE;
}

/*
 * RasfileGetKeyValueFields :
 *      Returns the key and value fields from a KEYVALUE line into the
 *      given buffers.
 *
 * Arguments :
 *      hrasfile - file handle obtained from RasfileLoad().
 *      lpszKey - buffer to load the key into.
 *      lpszValue - buffer to load the value string into.
 *
 * Return Values :
 *      TRUE if successful, FALSE otherwise.
 */
BOOL APIENTRY
RasfileGetKeyValueFields( HRASFILE hrasfile, LPSTR lpszKey, LPSTR lpszValue )
{
    RASFILE     *pRasfile;
    CHAR        *lpszLine;
    CHAR        *pch;
    INT         cchKey;

    pRasfile = gpRasfiles[hrasfile];

    if (pRasfile->lpLine == pRasfile->lpRasLines)
        return FALSE;
    if (!(pRasfile->lpLine->type & TAG_KEYVALUE ))
        return FALSE;

    lpszLine = pRasfile->lpLine->pszLine;

    // skip white space
    //
    while ((*lpszLine == ' ') || (*lpszLine == '\t'))
    {
        lpszLine++;
    }

    // find the position of the first delimiter for keywords
    //
    cchKey = 0;
    pch = lpszLine;
    while ((*pch != '=') && (*pch != ' ') && (*pch != '\t') && *pch)
    {
        pch++;
        cchKey++;
    }

    if (lpszKey != NULL)
    {
        // Copy the key we just identified to the output parameter.
        // Add the extra 1 for the way lstrcpyn works.  (It includes the
        // null terminator it always copies in the count.)
        //
        lstrcpynA(lpszKey, lpszLine, cchKey + 1);
    }

    // find beginning of value string - skip white space and '='
    //
    while ((*pch == ' ') || (*pch == '\t') || (*pch == '='))
    {
        pch++;
    }

    if (lpszValue != NULL)
    {
        lstrcpynA(lpszValue, pch, RAS_MAXLINEBUFLEN);
    }

    return TRUE;
}


/*
 * RasfilePutKeyValueFields :
 *      Sets the current line to a KEYVALUE line with the given key and
 *      value strings.
 *
 * Arguments :
 *      hrasfile - file handle obtained from RasfileLoad().
 *      lpszKey - buffer containing the key string.
 *      lpszValue - buffer containing the value string.
 *
 * Return Values :
 *      TRUE if successful, FALSE otherwise.
 */
BOOL APIENTRY
RasfilePutKeyValueFields( HRASFILE hrasfile, LPCSTR lpszKey, LPCSTR lpszValue )
{
    RASFILE *pRasfile;
    INT     size;

    pRasfile = gpRasfiles[hrasfile];

    if (pRasfile->lpLine == pRasfile->lpRasLines)
        return FALSE;
    if ((size = lstrlenA(lpszKey) + lstrlenA(lpszValue)) > RAS_MAXLINEBUFLEN - 1)
        return FALSE;

    /* remember to include the '=' in string length for key=value string */
    if ((size + 1) > lstrlenA(pRasfile->lpLine->pszLine))
    {
        CHAR* psz=Realloc(pRasfile->lpLine->pszLine,size + 2);

        if (psz)
            pRasfile->lpLine->pszLine=psz;
        else
            return FALSE;
    }
    lstrcpynA(pRasfile->lpLine->pszLine, lpszKey, size + 2);

    strncat(
        pRasfile->lpLine->pszLine,
        "=",
        (size + 2) - strlen(pRasfile->lpLine->pszLine));

    strncat(
        pRasfile->lpLine->pszLine,
        lpszValue,
        (size + 2) - strlen(pRasfile->lpLine->pszLine));

    pRasfile->lpLine->type =
    rasParseLineTag(pRasfile,pRasfile->lpLine->pszLine);

    pRasfile->fDirty = TRUE;
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\extapi\src\rfnav.c ===
/*****************************************************************************
**              Microsoft Rasfile Library
**              Copyright (C) Microsoft Corp., 1992
**
** File Name : rfnav.c
**
** Revision History :
**      July 10, 1992   David Kays      Created
**
** Description :
**      Rasfile file navigation routines.
******************************************************************************/

#include <windows.h>
#include "rf.h"

#include <mbstring.h>
#include "tstr.h"
extern RASFILE *gpRasfiles[];

/*
 * RasfileFindFirstLine :
 *      Sets the current line to the first line of the given type in the
 *      given scope.  If the current line is already at the first line
 *      of the given scope, it is not moved and the call is successful.
 *
 * Arguments :
 *      hrasfile - file handle obtained from RasfileLoad().
 *      bType   - the type(s) of line to search for.
 *      rfscope - the scope of the search.
 *
 * Return Value :
 *      TRUE if successful, FALSE otherwise.
 */
BOOL APIENTRY
RasfileFindFirstLine( HRASFILE hrasfile, BYTE bType, RFSCOPE rfscope )
{
    return rasFindLine(hrasfile,bType,rfscope,BEGIN,FORWARD);
}

/*
 * RasfileFindLastLine :
 *      Sets the current line to the last line of the given type in the
 *      given scope.
 *
 * Arguments :
 *      hrasfile - file handle obtained from RasfileLoad().
 *      bType   - the type(s) of line to search for.
 *      rfscope - the scope of the search.
 *
 * Return Value :
 *      TRUE if successful, FALSE otherwise.
 */
BOOL APIENTRY
RasfileFindLastLine( HRASFILE hrasfile, BYTE bType, RFSCOPE rfscope )
{
    return rasFindLine(hrasfile,bType,rfscope,END,BACKWARD);
}

/*
 * RasfileFindPrevLine :
 *      Sets the current line to the nearest preceding line of the given
 *      type in the given scope.
 *
 * Arguments :
 *      hrasfile - file handle obtained from RasfileLoad().
 *      bType   - the type(s) of line to search for.
 *      rfscope - the scope of the search.
 *
 * Return Value :
 *      TRUE if successful, FALSE otherwise.
 */
BOOL APIENTRY
RasfileFindPrevLine( HRASFILE hrasfile, BYTE bType, RFSCOPE rfscope )
{
    return rasFindLine(hrasfile,bType,rfscope,PREV,BACKWARD);
}

/*
 * RasfileFindNextLine :
 *      Sets the current line to the nearest following line of the given
 *      type in the given scope.
 *
 * Arguments :
 *      hrasfile - file handle obtained from RasfileLoad().
 *      bType   - the type(s) of line to search for.
 *      rfscope - the scope of the search.
 *
 * Return Value :
 *      TRUE if successful, FALSE otherwise.
 */
BOOL APIENTRY
RasfileFindNextLine( HRASFILE hrasfile, BYTE bType, RFSCOPE rfscope )
{
    return rasFindLine(hrasfile,bType,rfscope,NEXT,FORWARD);
}

/*
 * RasfileFindNextKeyLine :
 *  Finds the next key value line in the given scope that matches
 *  he given key.
 *
 * Arguments :
 *  hrasfile - file handle obtained from RasfileLoad().
 *  lpszKey     - the key to search for
 *  rfscope - the scope of the search
 *
 * Return Value :
 *  TRUE if successful, FALSE otherwise.
 */
BOOL APIENTRY
RasfileFindNextKeyLine(HRASFILE hrasfile, LPCSTR lpszKey, RFSCOPE rfscope)
{
    RASFILE     *pRasfile;
    PLINENODE   lpOldLine;
    CHAR        *lpszLine;
    CHAR        *pch;
    size_t      cchKey = lstrlenA(lpszKey);
    size_t      cchToFirstDelim;

    pRasfile = gpRasfiles[hrasfile];

    lpOldLine = pRasfile->lpLine;
    while (1)
    {
        if (!RasfileFindNextLine(hrasfile,RFL_KEYVALUE,rfscope))
            break;

        lpszLine = pRasfile->lpLine->pszLine;

        // skip white space
        //
        while ((*lpszLine == ' ') || (*lpszLine == '\t'))
        {
            lpszLine++;
        }

        // find the position of the first delimiter for keywords
        //
        cchToFirstDelim = 0;
        pch = lpszLine;
        while ((*pch != '=') && (*pch != ' ') && (*pch != '\t') && *pch)
        {
            pch++;
            cchToFirstDelim++;
        }

        if ((cchToFirstDelim == cchKey) &&
            (0 == _strnicmp(lpszLine, lpszKey, cchKey)))
        {
            return TRUE;
        }
        // else continue
    }

    pRasfile->lpLine = lpOldLine;
    return FALSE;
}


/*
 * RasfileFindNextMarkedLine :
 *      Finds the line with the given mark.  The search is started from
 *      the beginning of the file.
 *
 * Arguments :
 *      hrasfile - file handle obtained from RasfileLoad().
 *      bMark - the mark to search for.
 *
 * Return Value :
 *      TRUE if successful, FALSE otherwise.
 */
BOOL APIENTRY
RasfileFindMarkedLine(HRASFILE hrasfile, BYTE bMark)
{
    RASFILE             *pRasfile;
    PLINENODE           lpLineNode;

    pRasfile = gpRasfiles[hrasfile];

    for (lpLineNode = pRasfile->lpRasLines->next;
        lpLineNode != pRasfile->lpRasLines;
        lpLineNode = lpLineNode->next)
    {
        if (lpLineNode->mark == bMark)
        {
            pRasfile->lpLine = lpLineNode;
            return TRUE;
        }
    }

    return FALSE;
}

/*
 * RasfileFindSectionLine :
 *      Finds the next section line that matches the given section name.
 *
 * Arguments :
 *  hrasfile - file handle obtained from RasfileLoad().
 *  lpszSection - the section name to search for.
 *  fStartAtBof - TRUE to indicate that the search should start from
 *                the beginning of the file, FALSE to start from the
 *                current line.
 *
 * Return Value :
 *      TRUE if successful, FALSE otherwise.
 */
BOOL APIENTRY
RasfileFindSectionLine(HRASFILE hrasfile, LPCSTR lpszSection, BOOL fStartAtBof)
{
    RASFILE   *pRasfile;
    PLINENODE lpLine;
    CHAR*      szSection = NULL;
    WCHAR*     pwszGivenSection = NULL;
    WCHAR*     pwszNextSection = NULL;
    BOOL       bRet = FALSE;
    
    pRasfile = gpRasfiles[hrasfile];

    // Allocate buffers from heap.  XP 339346
    //
    szSection = Malloc(MAX_LINE_SIZE * sizeof(CHAR));
    pwszGivenSection = Malloc(MAX_LINE_SIZE * sizeof(WCHAR));
    pwszNextSection = Malloc(MAX_LINE_SIZE * sizeof(WCHAR));

    if (szSection && pwszGivenSection && pwszNextSection)
    {
        strncpyAtoW(pwszGivenSection, lpszSection, MAX_LINE_SIZE);

        for (lpLine = fStartAtBof ? pRasfile->lpRasLines->next : pRasfile->lpLine;
            lpLine != pRasfile->lpRasLines;
            lpLine = lpLine->next)
        {
            if (lpLine->type & TAG_SECTION)
            {
                rasExtractSectionName( lpLine->pszLine, szSection );

                strncpyAtoW(pwszNextSection, szSection, MAX_LINE_SIZE);

                if (_wcsicmp( pwszGivenSection, pwszNextSection ) == 0)
                {
                    pRasfile->lpLine = lpLine;

                    bRet = TRUE;
                    break;
                }

            }
        }
    }        

    // Cleanup
    if (szSection)        
    {
        Free(szSection);
    }        
    if (pwszGivenSection) 
    {
        Free(pwszGivenSection);
    }        
    if (pwszNextSection)  
    {
        Free(pwszNextSection);
    }        

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\extapi\src\tstr.c ===
/*++

Copyright(c) 1995 Microsoft Corporation

MODULE NAME
    tstr.c

ABSTRACT
    String conversion routines

AUTHOR
    Anthony Discolo (adiscolo) 19-Dec-1996

REVISION HISTORY

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <extapi.h>
#include <tapi.h>


CHAR *
strdupA(
    IN LPCSTR psz
    )
{
    INT cb = strlen(psz);
    CHAR *pszNew = NULL;

    if (cb) {
        pszNew = Malloc(cb + 1);
        if (pszNew == NULL) {
            DbgPrint("strdupA: LocalAlloc failed\n");
            return NULL;
        }
        strncpy(pszNew, psz, cb + 1);
    }

    return pszNew;
}


WCHAR *
strdupW(
    IN LPCWSTR psz
    )
{
    INT cb = wcslen(psz);
    WCHAR *pszNew = NULL;

    if (cb) {
        pszNew = Malloc((cb + 1) * sizeof (WCHAR));
        if (pszNew == NULL) {
            DbgPrint("strdupW: LocalAlloc failed\n");
            return NULL;
        }
        lstrcpyn(pszNew, psz, cb + 1);
    }

    return pszNew;
}


CHAR *
StrdupWtoA(
    IN LPCWSTR psz,
    IN DWORD dwCp
    )
{
    CHAR* pszNew = NULL;

    if (psz != NULL) {
        DWORD cb;

        cb = WideCharToMultiByte(dwCp, 0, psz, -1, NULL, 0, NULL, NULL);
        ASSERT(cb);

        pszNew = (CHAR*)Malloc(cb);
        if (pszNew == NULL) {
            TRACE("strdupWtoA: Malloc failed");
            return NULL;
        }

        cb = WideCharToMultiByte(dwCp, 0, psz, -1, pszNew, cb, NULL, NULL);
        if (!cb) {
            Free(pszNew);
            TRACE("strdupWtoA: conversion failed");
            return NULL;
        }
    }

    return pszNew;
}


WCHAR *
StrdupAtoW(
    IN LPCSTR psz,
    IN DWORD dwCp
    )
{
    WCHAR* pszNew = NULL;

    if (psz != NULL) {
        DWORD cb;

        cb = MultiByteToWideChar(dwCp, 0, psz, -1, NULL, 0);
        ASSERT(cb);

        pszNew = Malloc(cb * sizeof(WCHAR));
        if (pszNew == NULL) {
            TRACE("strdupAtoW: Malloc failed");
            return NULL;
        }

        cb = MultiByteToWideChar(dwCp, 0, psz, -1, pszNew, cb);
        if (!cb) {
            Free(pszNew);
            TRACE("strdupAtoW: conversion failed");
            return NULL;
        }
    }

    return pszNew;
}


VOID
StrcpyWtoA(
    OUT CHAR *pszDst,
    IN LPCWSTR pszSrc,
    IN DWORD dwCp
    )
{
    *pszDst = '\0';
    if (pszSrc != NULL) {
        DWORD cb;

        cb = WideCharToMultiByte(dwCp, 0, pszSrc, -1, NULL, 0, NULL, NULL);
        ASSERT(cb);

        cb = WideCharToMultiByte(dwCp, 0, pszSrc, -1, pszDst, cb, NULL, NULL);
        if (!cb)
            TRACE("strcpyWtoA: conversion failed");
    }
}


VOID
StrcpyAtoW(
    OUT WCHAR *pszDst,
    IN LPCSTR pszSrc,
    IN DWORD dwCp
    )
{
    *pszDst = L'\0';
    if (pszSrc != NULL) {
        DWORD cb;

        cb = MultiByteToWideChar(dwCp, 0, pszSrc, -1, NULL, 0);
        ASSERT(cb);

        cb = MultiByteToWideChar(dwCp, 0, pszSrc, -1, pszDst, cb);
        if (!cb)
            TRACE("strcpyAtoW: conversion failed");
    }
}


VOID
StrncpyWtoA(
    OUT CHAR *pszDst,
    IN LPCWSTR pszSrc,
    INT cb,
    DWORD dwCp
    )
{
    *pszDst = '\0';
    if (pszSrc != NULL) {
        if (!WideCharToMultiByte(dwCp, 0, pszSrc, -1, pszDst, cb, NULL, NULL))
            TRACE("strncpyWtoA: conversion failed");
        pszDst[cb-1] = '\0';
    }
}


VOID
StrncpyAtoW(
    OUT WCHAR *pszDst,
    IN LPCSTR pszSrc,
    INT cb,
    DWORD dwCp
    )
{
    *pszDst = L'\0';
    if (pszSrc != NULL) {
        if (!MultiByteToWideChar(dwCp, 0, pszSrc, -1, pszDst, cb))
            TRACE("strncpyAtoW: conversion failed");
        pszDst[cb-1] = L'\0';
    }
}

size_t
wcslenU(
    IN const WCHAR UNALIGNED *pszU
    )
{
    size_t len = 0;

    if (pszU == NULL)
        return 0;
    while (*pszU != L'\0') {
        pszU++;
        len++;
    }
    return len;
}


WCHAR *
strdupWU(
    IN const WCHAR UNALIGNED *pszU
    )
{
    WCHAR *psz;
    DWORD dwcb;

    if (pszU == NULL)
        return NULL;
    dwcb = (wcslenU(pszU) + 1) * sizeof (WCHAR);
    psz = Malloc(dwcb);
    if (psz == NULL)
        return NULL;
    RtlCopyMemory(psz, pszU, dwcb);

    return psz;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\extapi\xlate\dummy.c ===
/* dummy.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\extapi\src\wow.c ===
/* Copyright (c) 1994, Microsoft Corporation, all rights reserved
**
** wow.c
** Remote Access External APIs
** WOW entry points
**
** 04/02/94 Steve Cobb
*/


#include <extapi.h>


DWORD FAR PASCAL
RasDialWow(
    IN  LPSTR            lpszPhonebookPath,
    IN  LPRASDIALPARAMSA lpparams,
    IN  HWND             hwndNotify,
    IN  DWORD            dwRasDialEventMsg,
    OUT LPHRASCONN       lphrasconn )

    /* As for RasDialA except...
    **
    ** 'hwndNotify' identifies the window to receive RasDial event
    ** notifications.  It must not be NULL.
    **
    ** 'dwRasDialEventMsg' is the message number to use for RasDial event
    ** notifications.
    */
{
    DWORD dwErr;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    RASAPI32_TRACE4(
      "RasDialWow(pb=%s,en=%s,h=%p,em=%d)",
      lpszPhonebookPath,
      lpparams->szEntryName,
      hwndNotify,
      dwRasDialEventMsg);

    dwErr = RasDialA(
        NULL, lpszPhonebookPath, lpparams,
        1, RasDialFunc1Wow, lphrasconn );

    if (dwErr == 0)
    {
        /* Set the Win16 notification HWND and message number in the control
        ** block.
        */
        RASCONNCB* prasconncb = ValidateHrasconn( *lphrasconn );

        if(NULL == prasconncb)
        {
            return ERROR_NO_CONNECTION;
        }
        
        prasconncb->hwndNotifyWow = hwndNotify;
        prasconncb->unMsgWow = (UINT )dwRasDialEventMsg;
    }

    return dwErr;
}


VOID WINAPI
RasDialFunc1Wow(
    HRASCONN     hrasconn,
    UINT         unMsg,
    RASCONNSTATE rasconnstate,
    DWORD        dwError,
    DWORD        dwExtendedError )

    /* NT WOW notifier function.  Filters any notifications not expected by
    ** Win16 and passes on the rest.
    */
{
    RASCONNCB* prasconncb;

    RASAPI32_TRACE4("RasDial32WFunc1(h=%d,em=%d,s=%d,e=%d,xe=%d)",
      hrasconn,
      unMsg,
      rasconnstate,
      dwError);
    RASAPI32_TRACE1("RasDial32WFunc1(xe=%d)", dwExtendedError);

    (void )unMsg;
    (void )dwExtendedError;

    if (!(prasconncb = ValidateHrasconn( hrasconn )))
        return;

    /* Wait for RasDialWow to fill in the WOW notification information before
    ** handling the first notification.
    */
    while (!prasconncb->hwndNotifyWow)
        Sleep( 1000L );

    /* Filter the Projected state which is not expected in Win16.
    */
    if (rasconnstate == RASCS_Projected)
        return;

    /* Note: 0xFFFF0000 is what a NULL 16-bit HWND gets mapped to before it is
    **       passed to 32-bit by the generic thunk layer.
    */
    if (prasconncb->hwndNotifyWow != (HWND )INVALID_HANDLE_VALUE)
    {
        /* Pass the notification to Win16.
        */
        RASAPI32_TRACE("Send to Win16...");

        SendMessageA(
            prasconncb->hwndNotifyWow, prasconncb->unMsgWow,
            (WPARAM )rasconnstate, (LPARAM )dwError );

        RASAPI32_TRACE("Send to Win16 done");
    }
}


DWORD FAR PASCAL
RasEnumConnectionsWow(
    OUT    LPRASCONNA lprasconn,
    IN OUT LPDWORD    lpcb,
    OUT    LPDWORD    lpcConnections )

    /* Pass thru with correct call convention.
    */
{
    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    RASAPI32_TRACE("RasEnumConnectionsWow");

    return
        RasEnumConnectionsA(
            lprasconn,
            lpcb,
            lpcConnections );
}


DWORD FAR PASCAL
RasEnumEntriesWow(
    IN     LPSTR           reserved,
    IN     LPSTR           lpszPhonebookPath,
    OUT    LPRASENTRYNAMEA lprasentryname,
    IN OUT LPDWORD         lpcb,
    OUT    LPDWORD         lpcEntries )

    /* Pass thru with correct call convention.
    */
{
    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    RASAPI32_TRACE("RasEnumEntriesWow");

    return
        RasEnumEntriesA(
            reserved,
            lpszPhonebookPath,
            lprasentryname,
            lpcb,
            lpcEntries );
}


DWORD FAR PASCAL
RasGetConnectStatusWow(
    IN  HRASCONN         hrasconn,
    OUT LPRASCONNSTATUSA lprasconnstatus )

    /* Pass thru with correct call convention.
    */
{
    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    RASAPI32_TRACE("RasGetConnectStatusWow");

    return
        RasGetConnectStatusA(
            hrasconn,
            lprasconnstatus );
}


DWORD FAR PASCAL
RasGetErrorStringWow(
    IN  UINT  ResourceId,
    OUT LPSTR lpszString,
    IN  DWORD InBufSize )

    /* Pass thru with correct call convention.
    */
{
    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    RASAPI32_TRACE("RasGetErrorStringWow");

    return
        RasGetErrorStringA(
            ResourceId,
            lpszString,
            InBufSize );
}


DWORD FAR PASCAL
RasHangUpWow(
    IN HRASCONN hrasconn )

    /* Pass thru with correct call convention.
    */
{
    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    RASAPI32_TRACE("RasHangUpWow");

    return
        RasHangUpA(
            hrasconn );
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\extapi\src\tstr.h ===
/*++

Copyright(c) 1995 Microsoft Corporation

MODULE NAME
    tstr.h

ABSTRACT
    String conversion routines

AUTHOR
    Anthony Discolo (adiscolo) 19-Dec-1996

REVISION HISTORY

--*/

#ifndef _TSTR_H_
#define _TSTR_H_

CHAR *
StrdupWtoA(
    IN LPCWSTR psz,
    IN DWORD dwCp
    );

WCHAR *
StrdupAtoW(
    IN LPCSTR psz,
    IN DWORD dwCp
    );

VOID
StrcpyWtoA(
    OUT CHAR *pszDst,
    IN LPCWSTR pszSrc,
    IN DWORD dwCp
    );

VOID
StrcpyAtoW(
    OUT WCHAR *pszDst,
    IN LPCSTR pszSrc,
    IN DWORD dwCp
    );

VOID
StrncpyWtoA(
    OUT CHAR *pszDst,
    IN LPCWSTR pszSrc,
    INT cb,
    IN DWORD dwCp
    );

VOID
StrncpyAtoW(
    OUT WCHAR *pszDst,
    IN LPCSTR pszSrc,
    INT cb,
    IN DWORD dwCp
    );

CHAR *
strdupA(
    IN LPCSTR psz
    );

WCHAR *
strdupW(
    IN LPCWSTR psz
    );

size_t
wcslenU(
    IN const WCHAR UNALIGNED *psz
    );

WCHAR *
strdupWU(
    IN const WCHAR UNALIGNED *psz
    );

// 
// Define string conversion variants for code pages used
// in public RAS api's.
//
#define strdupWtoA(_x) StrdupWtoA((_x), CP_UTF8)
#define strdupAtoW(_x) StrdupAtoW((_x), CP_UTF8)
#define strcpyWtoA(_x, _y) StrcpyWtoA((_x), (_y), CP_UTF8)
#define strcpyAtoW(_x, _y) StrcpyAtoW((_x), (_y), CP_UTF8)
#define strncpyWtoA(_x, _y, _z) StrncpyWtoA((_x), (_y), (_z), CP_UTF8)
#define strncpyAtoW(_x, _y, _z) StrncpyAtoW((_x), (_y), (_z), CP_UTF8)

#define strdupWtoAAnsi(_x) StrdupWtoA((_x), CP_ACP)
#define strdupAtoWAnsi(_x) StrdupAtoW((_x), CP_ACP)
#define strcpyWtoAAnsi(_x, _y) StrcpyWtoA((_x), (_y), CP_ACP)
#define strcpyAtoWAnsi(_x, _y) StrcpyAtoW((_x), (_y), CP_ACP)
#define strncpyWtoAAnsi(_x, _y, _z) StrncpyWtoA((_x), (_y), (_z), CP_ACP)
#define strncpyAtoWAnsi(_x, _y, _z) StrncpyAtoW((_x), (_y), (_z), CP_ACP)

#ifdef UNICODE
#define strdupTtoA      strdupWtoA
#define strdupTtoW      strdupW
#define strdupAtoT      strdupAtoW
#define strdupWtoT      strdupW
#define strcpyTtoA      strcpyWtoA
#define strcpyTtoW      wcscpy
#define strcpyAtoT      strcpyAtoW
#define strcpyWtoT      wcscpy
#define strncpyTtoA     strncpyWtoA
#define strncpyTtoW     wcsncpy
#define strncpyAtoT     strncpyAtoW
#define strncpyWtoT     wcsncpy

#define strdupTtoAAnsi      strdupWtoAAnsi
#define strdupTtoWAnsi      strdupW
#define strdupAtoTAnsi      strdupAtoWAnsi
#define strdupWtoTAnsi      strdupW
#define strcpyTtoAAnsi      strcpyWtoAAnsi
#define strcpyTtoWAnsi      wcscpy
#define strcpyAtoTAnsi      strcpyAtoWAnsi
#define strcpyWtoTAnsi      wcscpy
#define strncpyTtoAAnsi     strncpyWtoAAnsi
#define strncpyTtoWAnsi     wcsncpy
#define strncpyAtoTAnsi     strncpyAtoWAnsi
#define strncpyWtoTAnsi     wcsncpy

#else
#define strdupTtoA      strdupA
#define strdupTtoW      strdupAtoW
#define strdupAtoT      strdupA
#define strdupWtoT      strdupWtoA
#define strcpyTtoA      strcpy
#define strcpyTtoW      strcpyAtoW
#define strcpyAtoT      strcpy
#define strcpyWtoT      strcpyWtoA
#define strncpyTtoA     strncpy
#define strncpyTtoW     strncpyAtoW
#define strncpyAtoT     strncpy
#define strncpyWtoT     strncpyWtoA

#define strdupTtoAAnsi      strdupA
#define strdupTtoWAnsi      strdupAtoWAnsi
#define strdupAtoTAnsi      strdupA
#define strdupWtoTAnsi      strdupWtoAAnsi
#define strcpyTtoAAnsi      strcpy
#define strcpyTtoWAnsi      strcpyAtoWAnsi
#define strcpyAtoTAnsi      strcpy
#define strcpyWtoTAnsi      strcpyWtoAAnsi
#define strncpyTtoAAnsi     strncpy
#define strncpyTtoWAnsi     strncpyAtoWAnsi
#define strncpyAtoTAnsi     strncpy
#define strncpyWtoTAnsi     strncpyWtoAAnsi

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\inc\bpopup.h ===
//============================================================================
// Copyright(c) 1996, Microsoft Corporation
//
// File:    bpopup.h
//
// History:
//  Abolade Gbadegesin      Mar-2-1996      Created.
//
// This file contains public declarations for the Bubble-Popup window class.
// A bubble-popup provides functionality similar to that of a tooltip, 
// in that it displays text for a brief period and then hides itself.
// This class differs in that it uses DrawText for its output, thus allowing
// multi-line text formatted using tabs. Further, the user is required
// to tell the bubble-popup when to show itself.
//
// To create a bubble-popup, call BubblePopup_Create().
// This returns an HWND (to be later destroyed using DestroyWindow()).
// The text of the bubble-popup can be set and retrieved using WM_SETTEXT
// and WM_GETTEXT (and hence the macros {Get,Set}WindowText().
//
// Set the period for which a popup is active by calling BubblePopup_SetTimeout
// and activate the popup by calling BubblePopup_Activate.
// While a popup is activated, changes to its text are reflected immediately.
// If BubblePopup_Activate is called while the popup is already active,
// the countdown (till the window is hidden) is started again.
//============================================================================


#ifndef _BPOPUP_H_
#define _BPOPUP_H_


// Window class name for bubble-popups

#define WC_BUBBLEPOPUP      TEXT("BubblePopup")


// Messages accepted by bubble-popups

#define BPM_FIRST           (WM_USER + 1)
#define BPM_ACTIVATE        (BPM_FIRST + 0)
#define BPM_DEACTIVATE      (BPM_FIRST + 1)
#define BPM_SETTIMEOUT      (BPM_FIRST + 2)

BOOL
BubblePopup_Init(
    IN  HINSTANCE   hinstance
    );

#define BubblePopup_Create(hinstance) \
        CreateWindow( \
            WC_BUBBLEPOPUP, NULL, 0, 0, 0, 0, 0, NULL, 0, (hinstance), NULL \
            )

#define BubblePopup_Activate(hwnd) \
        (VOID)SendMessage((HWND)hwnd, BPM_ACTIVATE, 0, 0)
#define BubblePopup_Deactivate(hwnd) \
        (VOID)SendMessage((HWND)hwnd, BPM_DEACTIVATE, 0, 0)
#define BubblePopup_SetTimeout(hwnd, uiTimeout) \
        (VOID)SendMessage((HWND)hwnd, BPM_SETTIMEOUT, 0,(LPARAM)(UINT)uiTimeout)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\inc\debug.h ===
/* Copyright (c) 1995, Microsoft Corporation, all rights reserved
**
** debug.h
** Debug and tracing macros
**
** 08/24/95 Steve Cobb
**
** To use TRACE/DUMP:
**
**     These calls encapsulate dynamically linking to the tracing utilities in
**     RTUTIL.DLL and provide shortcut macros to access them and to prevent
**     their inclusion in non-DBG builds.
**
**     Before calling any TRACE/DUMP macros call:
**         DEBUGINIT( "YOURMODULE" );
**
**     Use the TRACEx and DUMPx macros to print messages to the log as defined
**     by the associated RTUTIL.DLL routines.  Currently, this code is removed
**     from non-DBG builds.  A few examples:
**
**       TRACE("MyRoutine");
**       TRACE2("MyRoutine=%d,c=%s",dwErr,psz);
**
**     After done calling TRACE/DUMP macros call:
**         DEBUGTERM();
**
**     Exactly one file should have define the debug globals with the
**     following while all other files should include the header without
**     defining the manifest.
**
**         #define DEBUGGLOBALS
**         #include <debug.h>
**
**     Static libraries can safely use TRACE/DUMP without calling DEBUGINIT
**     and DEBUGTERM or defining DEBUGGLOBALS.  If the caller sets up these in
**     his module, the library trace will appear as part of caller's module
**     trace.
**
** To use ASSERT:
**
**     Use ASSERT to assert that a given expression is true, popping up a
**     dialog indicating the file and line number of the ASSERTION if it
**     fails.  It is not necessary to call DEBUGINIT and DEBUGTERM to use
**     ASSERT.  For example:
**
**         hwndOwner = GetParent( hwnd );
**         ASSERT(hwndOwner!=NULL);
*/

#ifndef _DEBUG_H_
#define _DEBUG_H_


#define FREETRACE 1


/*----------------------------------------------------------------------------
** Datatypes and global declarations (defined in debug.c)
**----------------------------------------------------------------------------
*/

#if (DBG || FREETRACE)

extern DWORD g_dwTraceId;

typedef DWORD (APIENTRY * TRACEREGISTEREXA)( LPCSTR, DWORD );
extern TRACEREGISTEREXA g_pTraceRegisterExA;

typedef DWORD (APIENTRY * TRACEDEREGISTERA)( DWORD );
extern TRACEDEREGISTERA g_pTraceDeregisterA;

typedef DWORD (APIENTRY * TRACEDEREGISTEREXA)( DWORD, DWORD );
extern TRACEDEREGISTEREXA g_pTraceDeregisterExA;

typedef DWORD (APIENTRY * TRACEPRINTFA)( DWORD, LPCSTR, ... );
extern TRACEPRINTFA g_pTracePrintfA;

typedef DWORD (APIENTRY * TRACEPRINTFEXA)( DWORD, DWORD, LPCSTR, ... );
extern TRACEPRINTFEXA g_pTracePrintfExA;

typedef DWORD (APIENTRY * TRACEDUMPEXA)( DWORD, DWORD, LPBYTE, DWORD, DWORD, BOOL, LPCSTR );
extern TRACEDUMPEXA g_pTraceDumpExA;

#endif // (DBG || FREETRACE)


/*----------------------------------------------------------------------------
** Macros
**----------------------------------------------------------------------------
*/

/* Debug macros.  This code does not appear in non-DBG builds unless FREETRACE
** is defined.
**
** The trailing number indicates the number of printf arguments in the format
** string.  TRACEW1 accepts a format string containing a single WCHAR*
** argument.  The argument is converted before output so that the output file
** remains entirely ANSI.
*/
#if (DBG || FREETRACE)

#define TRACE(a) \
            if (g_dwTraceId!=-1) g_pTracePrintfA(g_dwTraceId,a)
#define TRACE1(a,b) \
            if (g_dwTraceId!=-1) g_pTracePrintfA(g_dwTraceId,a,b)
#define TRACE2(a,b,c) \
            if (g_dwTraceId!=-1) g_pTracePrintfA(g_dwTraceId,a,b,c)
#define TRACE3(a,b,c,d)\
            if (g_dwTraceId!=-1) g_pTracePrintfA(g_dwTraceId,a,b,c,d)
#define TRACE4(a,b,c,d,e) \
            if (g_dwTraceId!=-1) g_pTracePrintfA(g_dwTraceId,a,b,c,d,e)
#define TRACE5(a,b,c,d,e,f) \
            if (g_dwTraceId!=-1) g_pTracePrintfA(g_dwTraceId,a,b,c,d,e,f)
#define TRACE6(a,b,c,d,e,f,g) \
            if (g_dwTraceId!=-1) g_pTracePrintfA(g_dwTraceId,a,b,c,d,e,f,g)
#define TRACEX(l,a) \
            if (g_dwTraceId!=-1) g_pTracePrintfExA(g_dwTraceId,l,a)
#define TRACEX1(l,a,b) \
            if (g_dwTraceId!=-1) g_pTracePrintfExA(g_dwTraceId,l,a,b)
#define TRACEX2(l,a,b,c) \
            if (g_dwTraceId!=-1) g_pTracePrintfExA(g_dwTraceId,l,a,b,c)
#define TRACEX3(l,a,b,c,d)\
            if (g_dwTraceId!=-1) g_pTracePrintfExA(g_dwTraceId,l,a,b,c,d)
#define TRACEX4(l,a,b,c,d,e) \
            if (g_dwTraceId!=-1) g_pTracePrintfExA(g_dwTraceId,l,a,b,c,d,e)
#define TRACEX5(l,a,b,c,d,e,f) \
            if (g_dwTraceId!=-1) g_pTracePrintfExA(g_dwTraceId,l,a,b,c,d,e,f)
#define TRACEX6(l,a,b,c,d,e,f,h) \
            if (g_dwTraceId!=-1) g_pTracePrintfExA(g_dwTraceId,l,a,b,c,d,e,f,h)
#define TRACE_ID(id,a) \
            if (id != -1) g_pTracePrintfA(id,a)
#define TRACE_ID1(id,a,b) \
            if (id != -1) g_pTracePrintfA(id,a,b)
#define TRACE_ID2(id,a,b,c) \
            if (id != -1) g_pTracePrintfA(id,a,b,c)
#define TRACE_ID3(id,a,b,c,d)\
            if (id != -1) g_pTracePrintfA(id,a,b,c,d)
#define TRACE_ID4(id,a,b,c,d,e) \
            if (id != -1) g_pTracePrintfA(id,a,b,c,d,e)
#define TRACE_ID5(id,a,b,c,d,e,f) \
            if (id != -1) g_pTracePrintfA(id,a,b,c,d,e,f)
#define TRACE_ID6(id,a,b,c,d,e,f,h) \
            if (id != -1) g_pTracePrintfA(id,a,b,c,d,e,f,h)
#define TRACEW1(a,b) \
            if (g_dwTraceId!=-1) TracePrintfW1(a,b)
#define DUMPB(p,c) \
            if (g_dwTraceId!=-1) g_pTraceDumpExA(g_dwTraceId,1,(LPBYTE)p,c,1,1,NULL)
#define DUMPDW(p,c) \
            if (g_dwTraceId!=-1) g_pTraceDumpExA(g_dwTraceId,1,(LPBYTE)p,c,4,1,NULL)
#if defined(ASSERT)
#undef ASSERT
#endif

#if DBG
#define ASSERT(a) \
            if (!(a)) Assert(#a,__FILE__,__LINE__)
#else
#define ASSERT(a)
#endif

#define DEBUGINIT(s) \
            DebugInit(s)
#define DEBUGTERM() \
            DebugTerm()

#else

#define TRACE(a)
#define TRACE1(a,b)
#define TRACE2(a,b,c)
#define TRACE3(a,b,c,d)
#define TRACE4(a,b,c,d,e)
#define TRACE5(a,b,c,d,e,f)
#define TRACE6(a,b,c,d,e,f,g)
#define TRACEX(l,a)
#define TRACEX1(l,a,b)
#define TRACEX2(l,a,b,c)
#define TRACEX3(l,a,b,c,d)
#define TRACEX4(l,a,b,c,d,e)
#define TRACEX5(l,a,b,c,d,e,f)
#define TRACEX6(l,a,b,c,d,e,f,g)
#define TRACEW1(a,b)
#define TRACE_ID(id,a)
#define TRACE_ID1(id,a,b)
#define TRACE_ID2(id,a,b,c)
#define TRACE_ID3(id,a,b,c,d)
#define TRACE_ID4(id,a,b,c,d,e)
#define TRACE_ID5(id,a,b,c,d,e,f)
#define TRACE_ID6(id,a,b,c,d,e,f,h)
#define DUMPB(p,c)
#define DUMPDW(p,c)
#if defined(ASSERT)
#undef ASSERT
#endif
#define ASSERT(a)
#define DEBUGINIT(s)
#define DEBUGTERM()

#endif


/*----------------------------------------------------------------------------
** Prototypes (alphabetically)
**----------------------------------------------------------------------------
*/

DWORD
DebugInitEx(
    IN  CHAR* pszModule,
    OUT LPDWORD lpdwId);

VOID
DebugTermEx(
    OUT LPDWORD lpdwTraceId );

VOID
DebugInit(
    IN CHAR* pszModule );

VOID
DebugTerm(
    void );

VOID
Assert(
    IN const CHAR* pszExpression,
    IN const CHAR* pszFile,
    IN UINT        unLine );

VOID
TracePrintfW1(
    CHAR*  pszFormat,
    TCHAR* psz1 );


#endif // _DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\inc\dtl.h ===
// Copyright (c) 1992, Microsoft Corporation, all rights reserved
//
// dtl.h
// Double-threaded linked list header
//
// 06/28/92 Steve Cobb

#ifndef _DTL_H_
#define _DTL_H_


#include <nouiutil.h>  // Heap definitions

// Forward declarations
//
typedef struct _DTLNODE DTLNODE;
typedef struct _DTLLIST DTLLIST;


// Double-threaded linked list node control block.  There is one node for each
// entry in a list.
//
// Applications should not access this structure directly.
//
typedef struct
_DTLNODE
{
    DTLNODE* pdtlnodePrev; // Address of previous node or NULL if none
    DTLNODE* pdtlnodeNext; // Address of next node or NULL if none
    VOID*    pData;        // Address of user's data
    LONG_PTR lNodeId;      // User-defined node identification code
}
DTLNODE;


// Double-threaded linked list control block.  There is one for each list.
//
// Applications should not access this structure directly.
//
typedef struct
_DTLLIST
{
    DTLNODE* pdtlnodeFirst; // Address of first node or NULL if none
    DTLNODE* pdtlnodeLast;  // Address of last node or NULL if none
    LONG     lNodes;        // Number of nodes in list
    LONG_PTR lListId;       // User-defined list identification code
}
DTLLIST;


// List node duplication function.  See DuplicateList.
//
typedef DTLNODE* (*PDUPNODE)( IN DTLNODE* );

// List node free function.  See FreeList.
//
typedef VOID (*PDESTROYNODE)( IN DTLNODE* );

// List node comparison function.  See MergeSort.
//
typedef IN (*PCOMPARENODE)( IN DTLNODE*, IN DTLNODE* );


// Macros and function prototypes.
//
#define DtlGetData( pdtlnode )        ((pdtlnode)->pData)
#define DtlGetNodeId( pdtlnode )      ((pdtlnode)->lNodeId)
#define DtlGetFirstNode( pdtllist )   ((pdtllist)->pdtlnodeFirst)
#define DtlGetListId( pdtllist )      ((pdtllist)->lListId)
#define DtlGetNextNode( pdtlnode )    ((pdtlnode)->pdtlnodeNext)
#define DtlGetNodes( pdtllist )       ((pdtllist)->lNodes)
#define DtlGetPrevNode( pdtlnode )    ((pdtlnode)->pdtlnodePrev)
#define DtlGetLastNode( pdtllist )    ((pdtllist)->pdtlnodeLast)
#define DtlPutData( pdtlnode, p )     ((pdtlnode)->pData = (p))
#define DtlPutNodeId( pdtlnode, l )   ((pdtlnode)->lNodeId = (LONG )(l))
#define DtlPutListCode( pdtllist, l ) ((pdtllist)->lListId = (LONG )(l))

DTLNODE* DtlAddNodeAfter( DTLLIST*, DTLNODE*, DTLNODE* );
DTLNODE* DtlAddNodeBefore( DTLLIST*, DTLNODE*, DTLNODE* );
DTLNODE* DtlAddNodeFirst( DTLLIST*, DTLNODE* );
DTLNODE* DtlAddNodeLast( DTLLIST*, DTLNODE* );
DTLLIST* DtlCreateList( LONG );
DTLNODE* DtlCreateNode( VOID*, LONG_PTR );
DTLNODE* DtlCreateSizedNode( LONG, LONG_PTR );
VOID     DtlDestroyList( DTLLIST*, PDESTROYNODE );
VOID     DtlDestroyNode( DTLNODE* );
DTLNODE* DtlDeleteNode( DTLLIST*, DTLNODE* );
DTLLIST* DtlDuplicateList( DTLLIST*, PDUPNODE, PDESTROYNODE );
VOID     DtlMergeSort( DTLLIST*, PCOMPARENODE );
VOID     DtlSwapLists( DTLLIST*, DTLLIST* );

DTLNODE* DtlNodeFromIndex( DTLLIST*, LONG );
DTLNODE* DtlRemoveNode( DTLLIST*, DTLNODE* );


#endif // _DTL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\extapi\src\util.c ===
/* Copyright (c) 1992, Microsoft Corporation, all rights reserved
**
** util.c
** Remote Access External APIs
** Utility routines
**
** 10/12/92 Steve Cobb
*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <extapi.h>
#include <stdlib.h>
#include <winreg.h>
#include <winsock.h>
#include <shlobj.h>
#include <rasapip.h>
#include <rtutils.h>

BOOL
CaseInsensitiveMatch(
    IN LPCWSTR pszStr1,
    IN LPCWSTR pszStr2
    );

//
// TRUE when rasman.dll has been
// successfully loaded and initailized.
// See LoadRasmanDllAndInit().
//
DWORD FRasInitialized = FALSE;
BOOL g_FRunningInAppCompatMode = FALSE;

HINSTANCE hinstIpHlp = NULL;
HINSTANCE hinstAuth = NULL;
HINSTANCE hinstScript = NULL;
HINSTANCE hinstMprapi = NULL;

//
// Gurdeepian dword byte-swapping macro.
//
#define net_long(x) (((((unsigned long)(x))&0xffL)<<24) | \
                     ((((unsigned long)(x))&0xff00L)<<8) | \
                     ((((unsigned long)(x))&0xff0000L)>>8) | \
                     ((((unsigned long)(x))&0xff000000L)>>24))

// XP 338217
//
#define Clear0(x) Free0(x); (x)=NULL

// 
// Initializes the ras api logging and debugging facility.  This should be the first
// api called in every function exported from the dll.
//
DWORD g_dwRasApi32TraceId = INVALID_TRACEID;

// XP 395648
//
// We use this global variable to cache whether we are the rasman process so
// that IsRasmanProcess doesn't have to execute for each rasapi.
//
DWORD g_dwIsRasmanProcess = 2;      // 2=don't know, 1=yes, 0=no

DWORD
RasApiDebugInit()
{
    // XP 395648
    //
    // Registering for trace notifications from the rasman process 
    // can leak tokens because of impersonation.
    //
    if (g_dwIsRasmanProcess == 2)
    {
        g_dwIsRasmanProcess = (IsRasmanProcess()) ? 1 : 0;
    }
    
    if (g_dwIsRasmanProcess == 0)
    {
        DebugInitEx("RASAPI32", &g_dwRasApi32TraceId);
    }
    
    return 0;
}

DWORD
RasApiDebugTerm()
{
    // XP 395648
    //
    // Registering for trace notifications from the rasman process 
    // can leak tokens because of impersonation.
    //
    if (g_dwIsRasmanProcess == 2)
    {
        g_dwIsRasmanProcess = (IsRasmanProcess()) ? 1 : 0;
    }
    
    if (g_dwIsRasmanProcess == 0)
    {
        DebugTermEx(&g_dwRasApi32TraceId);
    }
    
    return 0;
}
    
BOOL
FRunningInAppCompatMode()
{
    BOOL fResult = FALSE;
    TCHAR *pszCommandLine = NULL;
    TCHAR *psz;

    pszCommandLine = StrDup(GetCommandLine());

    if(NULL == pszCommandLine)
    {
        goto done;
    }

    psz = pszCommandLine + lstrlen(pszCommandLine);

    while(      (TEXT('\\') != *psz)
            &&  (psz != pszCommandLine))
    {
        psz--;
    }

    if(TEXT('\\') == *psz)
    {
        psz++;
    }

    if(     (TRUE == CaseInsensitiveMatch(psz, TEXT("INETINFO.EXE")))
        ||  (TRUE == CaseInsensitiveMatch(psz, TEXT("WSPSRV.EXE"))))
    {
        fResult = TRUE;
    }

done:

    if(NULL != pszCommandLine)
    {
        Free(pszCommandLine);
    }

    return fResult;
}

                     

VOID
ReloadRasconncbEntry(
    RASCONNCB*  prasconncb )

/*++

Routine Description:

    Reload the phonebook entry for the given RASCONNCB

Arguments:

Return Value:

--*/

{
    DWORD       dwErr;
    DTLNODE*    pdtlnode;
    PLIST_ENTRY pEntry;
    TCHAR*      pszPath;


    //
    // Before we close the phonebook save the
    // path, since we don't have it stored anywhere
    // else.
    //
    pszPath = StrDup(prasconncb->pbfile.pszPath);

    if (pszPath == NULL)
    {
        prasconncb->dwError = ERROR_NOT_ENOUGH_MEMORY;
        return;
    }

    ClosePhonebookFile(&prasconncb->pbfile);

    dwErr = GetPbkAndEntryName(
                    pszPath,
                    prasconncb->rasdialparams.szEntryName,
                    RPBF_NoCreate,
                    &prasconncb->pbfile,
                    &pdtlnode);

    Free(pszPath);

    if(dwErr)
    {
        prasconncb->dwError = dwErr;
        return;
    }

    prasconncb->pEntry = (PBENTRY *)DtlGetData(pdtlnode);
    ASSERT(prasconncb->pEntry);

    //
    // Find the link.
    //
    pdtlnode = DtlNodeFromIndex(
                 prasconncb->pEntry->pdtllistLinks,
                 prasconncb->rasdialparams.dwSubEntry - 1);

    if (pdtlnode == NULL)
    {
        prasconncb->dwError = ERROR_CANNOT_FIND_PHONEBOOK_ENTRY;
        return;
    }

    prasconncb->pLink = (PBLINK *)DtlGetData(pdtlnode);
    ASSERT(prasconncb->pLink);

    //
    // Reset the phonebook entry for all subentries
    // in the connection, since a field in it has
    // changed.
    //
    for (pEntry = prasconncb->ListEntry.Flink;
         pEntry != &prasconncb->ListEntry;
         pEntry = pEntry->Flink)
    {
        RASCONNCB *prcb = CONTAINING_RECORD(pEntry, RASCONNCB, ListEntry);

        //
        // Set the phonebook descriptor.
        //
        memcpy(
          &prcb->pbfile,
          &prasconncb->pbfile,
          sizeof (prcb->pbfile));

        //
        // Set the entry.
        //
        prcb->pEntry = prasconncb->pEntry;

        //
        // Recalculate the link.
        //
        pdtlnode = DtlNodeFromIndex(
                     prcb->pEntry->pdtllistLinks,
                     prcb->rasdialparams.dwSubEntry - 1);

        if (pdtlnode == NULL)
        {
            prasconncb->dwError = ERROR_CANNOT_FIND_PHONEBOOK_ENTRY;
            break;
        }

        prcb->pLink = (PBLINK *)DtlGetData(pdtlnode);
        ASSERT(prcb->pLink);
    }
}


VOID
FinalCleanUpRasconncbNode(
    DTLNODE *pdtlnode
    )
{
    RASCONNCB*  prasconncb          = DtlGetData(pdtlnode);
    RASCONNCB*  prasconncbTmp;
    BOOL        fConnectionPresent  = FALSE;
    DTLNODE*    pdtlnodeTmp;

    RASAPI32_TRACE1(
      "FinalCleanUpRasconncbNode: deallocating prasconncb=0x%x",
      prasconncb);

    EnterCriticalSection(&RasconncbListLock);

    //
    // Make sure the subentry list is empty.
    //
    ASSERT(IsListEmpty(&prasconncb->ListEntry));

    //
    // make sure that we still have the connection block
    //
    for (pdtlnodeTmp = DtlGetFirstNode( PdtllistRasconncb );
         pdtlnodeTmp;
         pdtlnodeTmp = DtlGetNextNode( pdtlnodeTmp ))
    {
        prasconncbTmp = (RASCONNCB* )DtlGetData( pdtlnodeTmp );

        ASSERT(prasconncbTmp);

        if (prasconncbTmp == prasconncb)
        {
            fConnectionPresent = TRUE;
            break;
        }
    }


    if (!fConnectionPresent)
    {
        RASAPI32_TRACE1(
            "FinalCleanupRasconncbNode: connection 0x%x not found",
            prasconncb);

        LeaveCriticalSection(&RasconncbListLock);

        return;
    }

    if(NULL != prasconncb->RasEapInfo.pbEapInfo)
    {
        LocalFree(prasconncb->RasEapInfo.pbEapInfo);
        prasconncb->RasEapInfo.pbEapInfo = NULL;
        prasconncb->RasEapInfo.dwSizeofEapInfo = 0;
    }

    if(NULL != prasconncb->pAddresses)
    {
        LocalFree(prasconncb->pAddresses);
        prasconncb->iAddress = prasconncb->cAddresses = 0;
    }

    //
    // Finally free the connection block.
    //
    pdtlnode = DtlDeleteNode( PdtllistRasconncb, pdtlnode );

    //
    // If there are no more connection blocks
    // on the list, then shutdown the asyncmachine
    // worker thread.
    //
    RASAPI32_TRACE1(
        "FinalCleanUpRasconncbNode: %d nodes remaining",
        DtlGetNodes(PdtllistRasconncb));

    if (!DtlGetNodes(PdtllistRasconncb))
    {
        ShutdownAsyncMachine();
    }

    LeaveCriticalSection(&RasconncbListLock);
}


VOID
DeleteRasconncbNodeCommon(
    IN DTLNODE *pdtlnode
    )
{
    RASCONNCB *prasconncb = (RASCONNCB *)DtlGetData(pdtlnode);

    ASSERT(prasconncb);

    //
    // If we've already deleted this node, then return.
    //
    if (prasconncb->fDeleted)
    {
        return;
    }

    RASAPI32_TRACE1(
        "DeleteRasconncbNodeCommon: prasconncb=0x%x",
        prasconncb);

    WipePassword(prasconncb->rasdialparams.szPassword);

    //
    // If we are the only one using the
    // phonebook structure, close it.
    //
    if (!IsListEmpty(&prasconncb->ListEntry))
    {
        RemoveEntryList(&prasconncb->ListEntry);
        InitializeListHead(&prasconncb->ListEntry);
    }
    else if (!prasconncb->fDefaultEntry)
    {
        ClosePhonebookFile(&prasconncb->pbfile);
    }

    // if this is a synchronous operation, fill in the
    // error
    if (prasconncb->psyncResult)
    {
        *(prasconncb->psyncResult) = prasconncb->dwError;
    }

    //
    // Make sure the async work item is
    // unregistered.
    //
    CloseAsyncMachine( &prasconncb->asyncmachine );

    //
    // Set the deleted flag to prevent us from
    // attempting to delete the node twice.
    //
    prasconncb->fDeleted = TRUE;

    //
    // If there is not yet a port associated with
    // the async machine's connection block, then
    // we free the memory associated with the
    // connection block now.  Otherwise, we have
    // to wait for the asyncmachine worker thread
    // to receive the last I/O completion port event
    // from rasman, at which time the
    // asyncmachine->freefunc is called.
    //
    if (prasconncb->asyncmachine.hport == INVALID_HPORT)
    {
        FinalCleanUpRasconncbNode(pdtlnode);
    }
}


VOID
DeleteRasconncbNode(
    IN RASCONNCB* prasconncb )

/*++

Routine Description:

    Remove 'prasconncb' from the PdtllistRasconncb list
    and release all resources associated with it.

Arguments:

Return Value:

--*/

{
    DWORD       dwErr;
    DTLNODE*    pdtlnode;
    RASCONNCB*  prasconncbTmp;

    EnterCriticalSection(&RasconncbListLock);

    //
    // Enumerate all connections to make sure we
    // are still on the list.
    //
    for (pdtlnode = DtlGetFirstNode( PdtllistRasconncb );
         pdtlnode;
         pdtlnode = DtlGetNextNode( pdtlnode ))
    {
        prasconncbTmp = (RASCONNCB* )DtlGetData( pdtlnode );

        ASSERT(prasconncbTmp);

        if (prasconncbTmp == prasconncb)
        {
            DeleteRasconncbNodeCommon(pdtlnode);
            break;
        }
    }

    LeaveCriticalSection(&RasconncbListLock);
}


VOID
CleanUpRasconncbNode(
    IN DTLNODE *pdtlnode
    )
{
    DWORD dwErr;
    RASCONNCB *prasconncb = (RASCONNCB *)DtlGetData(pdtlnode);

    ASSERT(prasconncb);

    RASAPI32_TRACE("CleanUpRasconncbNode");

    //
    // Stop the async machine before we close the
    // port.
    //
    if (!prasconncb->fStopped)
    {
        prasconncb->fStopped = TRUE;

        StopAsyncMachine(&prasconncb->asyncmachine);

    }

    //
    // rascauth.dll may not have been loaded,
    // so test the function pointer first.
    //
    if (g_pAuthStop != NULL)
    {
        //
        // It is always safe to call AuthStop, i.e. if AuthStart
        // was never called or the HPORT is invalid it may return
        // an error but won't crash.
        //
        RASAPI32_TRACE("(CU) AuthStop...");

        g_pAuthStop( prasconncb->hport );

        RASAPI32_TRACE("(CU) AuthStop done");
    }

    if (prasconncb->dwError)
    {
        RASMAN_INFO info;

        //
        // Stop PPP on error.
        //
        RASAPI32_TRACE("(CU) RasPppStop...");

        g_pRasPppStop(prasconncb->hport);

        RASAPI32_TRACE("(CU) RasPppStop done");

    }

    //
    // Set the flag that notes we've cleaned up
    // this connection block.
    //
    prasconncb->fCleanedUp = TRUE;

    //
    // If there is no user thread waiting
    // for this connection, then free the
    // connection block now.
    //
    DeleteRasconncbNodeCommon(pdtlnode);

    RASAPI32_TRACE("CleanUpRasconncbNode done");
}


DWORD
ErrorFromDisconnectReason(
    IN RASMAN_DISCONNECT_REASON reason )

/*++

Routine Description:

    Converts disconnect reason 'reason' (retrieved from
    RASMAN_INFO) into an equivalent error code. Returns
    the result of the conversion.

Arguments:

Return Value:

--*/

{
    DWORD dwError = ERROR_DISCONNECTION;

    if (reason == REMOTE_DISCONNECTION)
    {
        dwError = ERROR_REMOTE_DISCONNECTION;
    }
    else if (reason == HARDWARE_FAILURE)
    {
        dwError = ERROR_HARDWARE_FAILURE;
    }
    else if (reason == USER_REQUESTED)
    {
        dwError = ERROR_USER_DISCONNECTION;
    }

    return dwError;
}


IPADDR
IpaddrFromAbcd(
    IN TCHAR* pchIpAddress )

/*++

Routine Description:

    Convert caller's a.b.c.d IP address string to the
    numeric equivalent in big-endian, i.e. Motorola format.

Arguments:

Return Value:

    Returns the numeric IP address or 0 if formatted
    incorrectly.

--*/

{
    INT  i;
    LONG lResult = 0;

    for (i = 1; i <= 4; ++i)
    {
        LONG lField = _ttol( pchIpAddress );

        if (lField > 255)
        {
            return (IPADDR )0;
        }

        lResult = (lResult << 8) + lField;

        while (     *pchIpAddress >= TEXT('0')
                &&  *pchIpAddress <= TEXT('9'))
        {
            pchIpAddress++;
        }

        if (    i < 4
            &&  *pchIpAddress != TEXT('.'))
        {
            return (IPADDR )0;
        }

        pchIpAddress++;
    }

    return (IPADDR )(net_long( lResult ));
}


DWORD
LoadRasiphlpDll()

/*++

Routine Description:

    Loads the RASIPHLP.DLL and it's entrypoints.

Arguments:

Return Value:

    Returns 0 if successful, otherwise a non-0
    error code.

--*/

{
    static BOOL fRasiphlpDllLoaded = FALSE;

    if (fRasiphlpDllLoaded)
    {
        return 0;
    }

    if (    !(hinstIpHlp = LoadLibrary( TEXT("RASIPHLP.DLL")))
        ||  !(PHelperSetDefaultInterfaceNet =
                (HELPERSETDEFAULTINTERFACENET )GetProcAddress(
                    hinstIpHlp, "HelperSetDefaultInterfaceNet" )))
    {
        return GetLastError();
    }

    fRasiphlpDllLoaded = TRUE;

    return 0;
}

DWORD
LoadMprApiDll()
{
    static BOOL fMprapiDllLoaded = FALSE;

    if(fMprapiDllLoaded)
    {
        return 0;
    }

    if(     !(hinstMprapi = LoadLibrary(TEXT("mprapi.dll")))
        ||  !(PMprAdminIsServiceRunning =
                (MPRADMINISSERVICERUNNING) GetProcAddress(
                        hinstMprapi, "MprAdminIsServiceRunning")))
    {
        return GetLastError();
    }

    fMprapiDllLoaded = TRUE;

    return 0;
}

DWORD
DwOpenDefaultEntry(RASCONNCB *prasconncb)
{
    DWORD dwErr = SUCCESS;

    dwErr = OpenMatchingPort(prasconncb);

    return dwErr;
}

DWORD
DwGetDeviceName(RASCONNCB *prasconncb,
                CHAR      *pszDeviceName)
{
    DWORD dwErr = ERROR_SUCCESS;

    ASSERT(prasconncb->dwCurrentVpnProt < NUMVPNPROTS);

    RASAPI32_TRACE1("RasGetDeviceName(rdt=%d)...",
          prasconncb->ardtVpnProts[prasconncb->dwCurrentVpnProt]);

    dwErr = g_pRasGetDeviceName(
            prasconncb->ardtVpnProts[prasconncb->dwCurrentVpnProt],
            pszDeviceName);

    RASAPI32_TRACE1("RasGetDeviceName. 0x%x",
           dwErr);

    return dwErr;
}

DWORD
DwOpenPort(RASCONNCB *prasconncb)
{
    DWORD dwErr = SUCCESS;
    DWORD dwFlags = 0;

    RASAPI32_TRACE("DwOpenPort");

    if(     (prasconncb->fDefaultEntry)
        ||  (RASET_Direct == prasconncb->pEntry->dwType))
    {
        //
        // Get all ports and try to open a port
        // of devicetype modem
        //
        dwErr = DwOpenDefaultEntry(prasconncb);

        goto done;
    }

    lstrcpyn(prasconncb->szUserKey,
            prasconncb->pEntry->pszEntryName,
            sizeof(prasconncb->szUserKey) / sizeof(WCHAR));

    //
    // Open any port on the specified device. RasPortOpen
    // will loop over all ports on the device and open
    // one if available.
    //
    if(     UPM_Normal == prasconncb->dwUserPrefMode)
    {
        dwFlags = CALL_OUT;
    }
    else if(UPM_Logon  == prasconncb->dwUserPrefMode)
    {
        dwFlags = CALL_OUT|CALL_LOGON;
    }
    else if(UPM_Router == prasconncb->dwUserPrefMode)
    {
        dwFlags = CALL_ROUTER;

        if(RASET_Broadband == prasconncb->pEntry->dwType)
        {
            dwFlags = CALL_OUTBOUND_ROUTER;
        }
    }

    {
        CHAR szDeviceName[MAX_DEVICE_NAME + 1];

        if(RASET_Vpn == prasconncb->pEntry->dwType)
        {

            dwErr = DwGetDeviceName(prasconncb,
                                    szDeviceName);

            if(ERROR_SUCCESS != dwErr)
            {
                if(     (ERROR_DEVICETYPE_DOES_NOT_EXIST != dwErr)

                    ||  (   ERROR_DEVICETYPE_DOES_NOT_EXIST
                                == dwErr
                        &&  ERROR_SUCCESS
                                == prasconncb->dwSavedError))
                {
                    prasconncb->dwSavedError = dwErr;
                }

                RASAPI32_TRACE1("DwGetDeviceName failed. 0x%x",
                       dwErr);

                goto done;
            }
        }
        else
        {

            strncpyWtoAAnsi(szDeviceName,
                       prasconncb->pLink->pbport.pszDevice,
                       sizeof(szDeviceName));

        }

        //
        // Open the port
        //
        RASAPI32_TRACE2("DwOpenPort: RasPortOpenEx(%s,%d)...",
                szDeviceName,
                prasconncb->dwDeviceLineCounter);

        dwErr = g_pRasPortOpenEx(
                    szDeviceName,
                    prasconncb->dwDeviceLineCounter,
                    &prasconncb->hport,
                    hDummyEvent,
                    &dwFlags);

        RASAPI32_TRACE2("DwOpenPort: RasPortOpenEx done(%d). Flags=0x%x",
                dwErr,
                dwFlags);

        if (dwErr == 0)
        {
            RASMAN_INFO ri;
            
            ZeroMemory(&ri, sizeof(RASMAN_INFO));

            //
            // Get the information on the port we just
            // opened so that we can copy the portname,
            // etc.
            //
            dwErr = g_pRasGetInfo(NULL,
                                  prasconncb->hport,
                                  &ri);

            if(0 != dwErr)
            {
                RASAPI32_TRACE2("DwOpenPort: RasGetInfo(%d) failed with %d",
                        prasconncb->hport, dwErr);

                goto done;
            }

            strncpyAtoTAnsi(
                prasconncb->szPortName,
                ri.RI_szPortName,
                sizeof(prasconncb->szPortName) / sizeof(TCHAR));

            strncpyAtoTAnsi(
                prasconncb->szDeviceType,
                ri.RI_szDeviceType,
                sizeof(prasconncb->szDeviceType) / sizeof(TCHAR));

            strncpyAtoTAnsi(
                prasconncb->szDeviceName,
                ri.RI_szDeviceName,
                sizeof(prasconncb->szDeviceName) / sizeof(TCHAR));

            RASAPI32_TRACE1("DwOpenPort: PortOpened = %S",
                    prasconncb->szPortName);
        }
    }

done:

    if(     (ERROR_NO_MORE_ITEMS == dwErr)
        &&  (ERROR_SUCCESS == prasconncb->dwSavedError)
        &&  (CALL_DEVICE_NOT_FOUND & dwFlags))
    {
        prasconncb->dwSavedError = ERROR_CONNECTING_DEVICE_NOT_FOUND;
    }

    if(     (RASEDM_DialAll == prasconncb->pEntry->dwDialMode)
        &&  (ERROR_NO_MORE_ITEMS == dwErr))
    {
        prasconncb->fTryNextLink = FALSE;
    }

    RASAPI32_TRACE1("DwOpenPort done. %d", dwErr);

    return ( (dwErr) ? ERROR_PORT_NOT_AVAILABLE : 0);
}


DWORD
OpenMatchingPort(
    IN OUT RASCONNCB* prasconncb )

/*++

Routine Description:

    Opens the port indicated in the entry (or default entry)
    and fills in the port related members of the connection
    control block.

Arguments:

Return Value:

    Returns 0 if successful, or a non-0 error code.

--*/

{
    DWORD        dwErr;
    RASMAN_PORT* pports;
    RASMAN_PORT* pport;
    INT          i;
    DWORD        dwPorts;
    TCHAR        szPort[RAS_MAXLINEBUFLEN + 1];
    BOOL         fAny       = FALSE;
    BOOL         fTypeMatch,
                 fPortMatch;
    PBENTRY      *pEntry    = prasconncb->pEntry;
    PBLINK       *pLink     = prasconncb->pLink;
    PBDEVICETYPE pbdtWant;

    RASAPI32_TRACE("OpenMatchingPort");

    if (prasconncb->fDefaultEntry)
    {
        //
        // No phonebook entry.  Default to any modem port
        // and UserKey of ".<phonenumber>".
        //
        fAny        = TRUE;
        szPort[0]   = TEXT('\0');
        pbdtWant    = PBDT_Modem;

        prasconncb->szUserKey[ 0 ] = TEXT('.');

        lstrcpyn(
            prasconncb->szUserKey + 1,
            prasconncb->rasdialparams.szPhoneNumber,
            (sizeof(prasconncb->szUserKey) / sizeof(WCHAR)) - 1);
    }
    else
    {
        //
        // Phonebook entry.  Get the port name and type.
        //
        lstrcpyn(
            prasconncb->szUserKey,
            pEntry->pszEntryName,
            sizeof(prasconncb->szUserKey) / sizeof(WCHAR));

        lstrcpyn(
            szPort,
            pLink->pbport.pszPort,
            sizeof(szPort) / sizeof(TCHAR));

        pbdtWant = pLink->pbport.pbdevicetype;

    }

    prasconncb->fTryNextLink = FALSE;

    dwErr = GetRasPorts(NULL, &pports, &dwPorts );

    if (dwErr != 0)
    {
        return dwErr;
    }

again:

    //
    // Loop thru enumerated ports to find and open a matching one...
    //
    dwErr = ERROR_PORT_NOT_AVAILABLE;

    for (i = 0, pport = pports; i < (INT )dwPorts; ++i, ++pport)
    {
        PBDEVICETYPE pbdt;
        RASMAN_INFO info;

        //
        // Only interested in dial-out or biplex ports,
        // depending on who called us.
        //
        if (    prasconncb->dwUserPrefMode == UPM_Normal
            &&  !(pport->P_ConfiguredUsage & CALL_OUT))
        {
            continue;
        }

        if (    prasconncb->dwUserPrefMode == UPM_Router
            &&  !(pport->P_ConfiguredUsage & CALL_ROUTER))
        {
            continue;
        }

        {
            TCHAR szPortName[MAX_PORT_NAME],
                  szDeviceType[MAX_DEVICETYPE_NAME];

            strncpyAtoT(
                szPortName,
                pport->P_PortName,
                sizeof(szPortName) / sizeof(TCHAR));

            strncpyAtoT(
                szDeviceType,
                pport->P_DeviceType,
                sizeof(szDeviceType) / sizeof(TCHAR));

            pbdt = PbdevicetypeFromPszType(szDeviceType);

            fTypeMatch = (pbdt == pbdtWant);

            fPortMatch = !lstrcmpi(szPortName, szPort);
        }

        //
        // Only interested in dial-out ports if the port is closed.
        // Biplex port Opens, on the other hand, may succeed even
        // if the port is open.
        //
        if (    pport->P_ConfiguredUsage == CALL_OUT
            &&  pport->P_Status != CLOSED)
        {
            continue;
        }

        RASAPI32_TRACE4("OpenMatchingPort: (%d,%d), (%s,%S)",
                pbdt,
                pbdtWant,
                pport->P_PortName,
                szPort);

        //
        // Only interested in devices matching caller's port or
        // of the same type as caller's "any" specification.
        //
        if (    fAny
            && (    !fTypeMatch
                ||  fPortMatch))
        {
            continue;
        }

        if (    !fAny
            &&  !fPortMatch)
        {
            continue;
        }

        dwErr = g_pRasGetInfo( NULL,
                               pport->P_Handle,
                               &info );
        if (    !dwErr
            &&  info.RI_ConnectionHandle != (HCONN)NULL)
        {
            RASAPI32_TRACE("OpenMatchinPort: port in use by another "
                  "connection!");

            dwErr = ERROR_PORT_NOT_AVAILABLE;

            continue;
        }

        //
        // We also don't want to open a port whose
        // state may be changing.
        //
        if (    !dwErr
            &&  info.RI_PortStatus != CLOSED
            &&  info.RI_ConnState != LISTENING)
        {
            RASAPI32_TRACE2(
              "OpenMatchingPort: port state changing: "
              "RI_PortStatus=%d, RI_ConnState=%d",
              info.RI_PortStatus,
              info.RI_ConnState);

            dwErr = ERROR_PORT_NOT_AVAILABLE;

            continue;
        }

        RASAPI32_TRACE1("RasPortOpen(%S)...", szPort);

        dwErr = g_pRasPortOpen(
                pport->P_PortName,
                &prasconncb->hport,
                hDummyEvent );

        RASAPI32_TRACE1("RasPortOpen done(%d)", dwErr);

        if (dwErr == 0)
        {
            strncpyAtoTAnsi(
                prasconncb->szPortName,
                pport->P_PortName,
                sizeof(prasconncb->szPortName) / sizeof(TCHAR));

            strncpyAtoTAnsi(
                prasconncb->szDeviceType,
                pport->P_DeviceType,
                sizeof(prasconncb->szDeviceType) / sizeof(TCHAR));

            strncpyAtoTAnsi(
                prasconncb->szDeviceName,
                pport->P_DeviceName,
                sizeof(prasconncb->szDeviceName) / sizeof(TCHAR));

            break;
        }

        //
        //
        // If we are searching for a particular port,
        // there is no reason to continue.
        //
        if (!fAny)
        {
            break;
        }
    }

    //
    // If we get here, the open was unsuccessful.
    // If this is our first time through, then we
    // reiterate looking for a device of the same
    // type.  If this is not our first time through,
    // then we simply finish our second iteration
    // over the devices.
    // For BAP we don't want to do this - doesn't make
    // sense.
    // For Direct Connect devices, we are looking for
    // the particular port. We don't want to open
    // matching ports..
    //
    if (    (dwErr)
        &&  (!fAny)
        &&  (RASET_Direct != prasconncb->pEntry->dwType)
        &&  (0 == (prasconncb->pEntry->dwDialMode
                   & RASEDM_DialAsNeeded)))
    {
        RASAPI32_TRACE("Starting over looking for any like device");

        fAny = TRUE;

        goto again;
    }

    else if (   dwErr
            &&  (prasconncb->pEntry->dwDialMode
                 & RASEDM_DialAsNeeded))
    {
        RASAPI32_TRACE1(
            "OpenMatchingPort: %d. Not iterating over other ports "
            "because of BAP",
            dwErr);
    }


    Free( pports );

    return dwErr ? ERROR_PORT_NOT_AVAILABLE : 0;
}


DWORD
ReadPppInfoFromEntry(
    IN  RASCONNCB* prasconncb )

/*++

Routine Description:

    Reads PPP information from the current phonebook entry.
    'h' is the handle of the phonebook file.  'prasconncb'
    is the address of the current connection control block.

Arguments:

Return Value:

    Returns 0 if succesful, otherwise a non-0 error code.

--*/

{
    DWORD       dwErr;
    DWORD       dwfExcludedProtocols    = 0;
    DWORD       dwRestrictions          = AR_AuthAny;
    BOOL        fDataEncryption         = FALSE;
    DWORD       dwfInstalledProtocols;
    PBENTRY*    pEntry                  = prasconncb->pEntry;
    BOOL  fIpPrioritizeRemote   = TRUE;
    BOOL  fIpVjCompression      = TRUE;
    DWORD dwIpAddressSource     = PBUFVAL_ServerAssigned;
    CHAR* pszIpAddress          = NULL;
    DWORD dwIpNameSource        = PBUFVAL_ServerAssigned;
    CHAR* pszIpDnsAddress       = NULL;
    CHAR* pszIpDns2Address      = NULL;
    CHAR* pszIpWinsAddress      = NULL;
    CHAR* pszIpWins2Address     = NULL;
    CHAR* pszIpDnsSuffix        = NULL;


    //
    // Get the installed protocols depending on being called
    // from router/client
    //
    if ( prasconncb->dwUserPrefMode & UPM_Router )
    {
        dwfInstalledProtocols =
                GetInstalledProtocolsEx(NULL,
                                        TRUE,
                                        FALSE,
                                        TRUE );
    }
    else
    {
        dwfInstalledProtocols =
                GetInstalledProtocolsEx(NULL,
                                        FALSE,
                                        TRUE,
                                        FALSE);
    }

    if (prasconncb->fDefaultEntry)
    {
        //
        // Set "default entry" defaults.
        //
        prasconncb->dwfPppProtocols = dwfInstalledProtocols;

        prasconncb->fPppMode        = TRUE;

#ifdef AMB
        prasconncb->dwAuthentication = AS_PppThenAmb;
/*#else
        prasconncb->dwAuthentication = AS_PppOnly; */
#endif
        prasconncb->fNoClearTextPw = FALSE;

        prasconncb->fLcpExtensions = TRUE;

        prasconncb->fRequireEncryption = FALSE;
        return 0;
    }

    dwRestrictions = pEntry->dwAuthRestrictions;

    // [pmay] derive auth restrictions based on new flags
    // if (    dwRestrictions == AR_AuthTerminal
    //     &&  !prasconncb->fAllowPause)
    // {
    //     return ERROR_INTERACTIVE_MODE;
    // }

    //
    // PPP LCP extension RFC options enabled.
    //
    prasconncb->fLcpExtensions = pEntry->fLcpExtensions;

    //
    // PPP data encryption required.
    //
    fDataEncryption = (     (pEntry->dwDataEncryption != DE_None)
                        &&  (pEntry->dwDataEncryption != DE_IfPossible));

    // [pmay] derive auth restrictions based on new flags
    prasconncb->fNoClearTextPw = !(dwRestrictions & AR_F_AuthPAP);

    // [pmay] AR_AuthMsEncrypted => only AR_F_MSCHAP is set
    // if (dwRestrictions == AR_AuthMsEncrypted)
    if (    (dwRestrictions & AR_F_AuthMSCHAP)
        &&  (fDataEncryption))
    {
        prasconncb->fRequireEncryption = TRUE;
    }

    if(     (dwRestrictions & AR_F_AuthMSCHAP2)
        &&  (fDataEncryption))
    {
        prasconncb->fRequireEncryption = TRUE;
    }

    //
    // PPP protocols to request is the installed protocols
    // less this entry's excluded protocols.
    //
    dwfExcludedProtocols = pEntry->dwfExcludedProtocols;

    prasconncb->dwfPppProtocols =
        dwfInstalledProtocols & ~(dwfExcludedProtocols);

    /*
    prasconncb->dwAuthentication = AS_PppOnly;
    */

    //
    // Adjust the authentication strategy if indicated.
    //
    if (    prasconncb->dwfPppProtocols == 0
        ||  prasconncb->pEntry->dwBaseProtocol == BP_Ras)
    {

        /*
        if (dwfInstalledProtocols & NP_Nbf)
        {
            prasconncb->dwAuthentication = AS_AmbOnly;
        }
        else
        {
            return ERROR_PPP_NO_PROTOCOLS_CONFIGURED;
        } */

        return ERROR_PPP_NO_PROTOCOLS_CONFIGURED;
    }

#if AMB
    else if (prasconncb->dwAuthentication == (DWORD )-1)
    {
        //
        // Choosing a PPP default.  If NBF is installed,
        // consider AMBs as a possibility.  Otherwise, use
        // PPP only.
        //
        if (dwfInstalledProtocols & NP_Nbf)
        {
            prasconncb->dwAuthentication = AS_PppThenAmb;
        }
        else
        {
            prasconncb->dwAuthentication = AS_PppOnly;
        }
    }
    else if (   prasconncb->dwAuthentication == AS_PppThenAmb
             || prasconncb->dwAuthentication == AS_AmbThenPpp)
    {
        //
        // Using an AMB dependent PPP strategy.  If NBF is
        // not installed, eliminate the AMB dependency.
        //
        if (!(dwfInstalledProtocols & NP_Nbf))
        {
            prasconncb->dwAuthentication = AS_PppOnly;
        }
    }
    else if (prasconncb->dwAuthentication == AS_PppOnly)
    {
        //
        // Using a PPP strategy without considering AMBs.
        // If NBF if installed, add AMBs as a fallback.
        //
        if (dwfInstalledProtocols & NP_Nbf)
        {
            prasconncb->dwAuthentication = AS_PppThenAmb;
        }
    }
#endif

#if 0
    //
    // Check to make sure we haven't specified
    // AMB as the authentication strategy.
    //
    if (    prasconncb->dwAuthentication == AS_PppThenAmb
        ||  prasconncb->dwAuthentication == AS_AmbThenPpp)
    {
        prasconncb->dwAuthentication = AS_PppOnly;
    }
    else if (prasconncb->dwAuthentication == AS_AmbOnly)
        return ERROR_PPP_NO_PROTOCOLS_CONFIGURED;
#endif

    //
    // The starting authentication mode is set to whatever
    // comes first in the specified authentication order.
    //
    /*
    prasconncb->fPppMode =
        (   prasconncb->dwAuthentication != AS_AmbThenPpp
         && prasconncb->dwAuthentication != AS_AmbOnly); */

    prasconncb->fPppMode = TRUE;

    //
    // Load the UI->CP parameter buffer with options we want
    // to pass to the PPP CPs (currently just IPCP).
    //
    do {

        ClearParamBuf( prasconncb->szzPppParameters );

        //
        // PPP protocols to request is the installed protocols
        // less the this entry's excluded protocols.
        //
        fIpPrioritizeRemote = pEntry->fIpPrioritizeRemote;

        AddFlagToParamBuf(
            prasconncb->szzPppParameters,
            PBUFKEY_IpPrioritizeRemote,
            fIpPrioritizeRemote );

        fIpVjCompression = pEntry->fIpHeaderCompression;

        AddFlagToParamBuf(
            prasconncb->szzPppParameters,
            PBUFKEY_IpVjCompression,
            fIpVjCompression );

        dwIpAddressSource = pEntry->dwIpAddressSource;

        AddLongToParamBuf(
            prasconncb->szzPppParameters,
            PBUFKEY_IpAddressSource,
            (LONG )dwIpAddressSource );

        pszIpAddress = strdupWtoA(pEntry->pszIpAddress);

        if(NULL == pszIpAddress)
        {
            break;
        }

        AddStringToParamBuf(
            prasconncb->szzPppParameters,
            PBUFKEY_IpAddress, pszIpAddress );

        //Free(pszIpAddress);

        dwIpNameSource = pEntry->dwIpNameSource;

        AddLongToParamBuf(
            prasconncb->szzPppParameters,
            PBUFKEY_IpNameAddressSource,
            (LONG )dwIpNameSource );

        pszIpDnsAddress = strdupWtoA(pEntry->pszIpDnsAddress);

        if(NULL == pszIpDnsAddress)
        {
            break;
        }

        AddStringToParamBuf(
            prasconncb->szzPppParameters,
            PBUFKEY_IpDnsAddress,
            pszIpDnsAddress );

        //Free(pszIpDnsAddress);

        pszIpDns2Address = strdupWtoA(pEntry->pszIpDns2Address);

        if(NULL == pszIpDns2Address)
        {
            break;
        }

        AddStringToParamBuf(
            prasconncb->szzPppParameters,
            PBUFKEY_IpDns2Address,
            pszIpDns2Address );

        //Free(pszIpDns2Address);

        pszIpWinsAddress = strdupWtoA(pEntry->pszIpWinsAddress);

        if(NULL == pszIpWinsAddress)
        {
            break;
        }

        AddStringToParamBuf(
            prasconncb->szzPppParameters,
            PBUFKEY_IpWinsAddress,
            pszIpWinsAddress );

        //Free(pszIpWinsAddress);

        pszIpWins2Address = strdupWtoA(pEntry->pszIpWins2Address);
    
        if(NULL == pszIpWins2Address)
        {
            break;
        }

        AddStringToParamBuf(
            prasconncb->szzPppParameters,
            PBUFKEY_IpWins2Address,
            pszIpWins2Address );

        //Free(pszIpWins2Address);

        AddLongToParamBuf(
            prasconncb->szzPppParameters,
            PBUFKEY_IpDnsFlags,
            (LONG )prasconncb->pEntry->dwIpDnsFlags);
        
        pszIpDnsSuffix = strdupWtoA(pEntry->pszIpDnsSuffix);

        if(NULL == pszIpDnsSuffix)
        {
            break;
        }

        AddStringToParamBuf(
            prasconncb->szzPppParameters,
            PBUFKEY_IpDnsSuffix,
            pszIpDnsSuffix);

        //Free(pszIpDnsSuffix);

    } while(FALSE);

    Free0(pszIpAddress);
    Free0(pszIpDnsAddress);
    Free0(pszIpDns2Address);
    Free0(pszIpWinsAddress);
    Free0(pszIpWins2Address);
    Free0(pszIpDnsSuffix);

    return 0;
}



DWORD
ReadConnectionParamsFromEntry(
    IN  RASCONNCB* prasconncb,
    OUT PRAS_CONNECTIONPARAMS pparams)

/*++

Routine Description:

   Reads connection management information from the
   current phonebook entry. 'prasconncb' is the address
   of the current connection control block.

Arguments:

Return Value:

   Returns 0 if succesful, otherwise a non-0 error code.

--*/

{
    DWORD dwErr;
    PBENTRY *pEntry = prasconncb->pEntry;

    pparams->CP_ConnectionFlags = 0;

    if(     pEntry->fRedialOnLinkFailure
        &&  (0 == (prasconncb->dwUserPrefMode & UPM_Logon)))
    {
        pparams->CP_ConnectionFlags |= CONNECTION_REDIALONLINKFAILURE;
    }

    if(pEntry->fShareMsFilePrint)
    {
        pparams->CP_ConnectionFlags |= CONNECTION_SHAREFILEANDPRINT;
    }

    if(pEntry->fBindMsNetClient)
    {
        pparams->CP_ConnectionFlags |= CONNECTION_BINDMSNETCLIENT;
    }

    if(pEntry->fUseRasCredentials)
    {
        pparams->CP_ConnectionFlags |= CONNECTION_USERASCREDENTIALS;
    }

    if(pEntry->dwIpSecFlags & AR_F_IpSecPSK)
    {
        pparams->CP_ConnectionFlags |= CONNECTION_USEPRESHAREDKEY;
    }
    
    pparams->CP_IdleDisconnectSeconds =
            (DWORD) pEntry->lIdleDisconnectSeconds;

    strncpyTtoA(
        pparams->CP_Phonebook,
        prasconncb->pbfile.pszPath,
        sizeof(pparams->CP_Phonebook));

    strncpyTtoA(
        pparams->CP_PhoneEntry,
        prasconncb->szUserKey,
        sizeof(pparams->CP_PhoneEntry));

    return 0;
}


DWORD
ReadSlipInfoFromEntry(
    IN  RASCONNCB* prasconncb,
    OUT TCHAR**    ppszIpAddress,
    OUT BOOL*      pfHeaderCompression,
    OUT BOOL*      pfPrioritizeRemote,
    OUT DWORD*     pdwFrameSize )

/*++

Routine Description:

   Only if the entry is a SLIP entry is non-NULL IP
   address returned, in which case the string should
   be freed by the caller.

Arguments:

Return Value:

    Returns 0 if successful, otherwise a non-0 error code.

--*/

{
    PBENTRY *pEntry = prasconncb->pEntry;

    *ppszIpAddress          = NULL;
    *pfHeaderCompression    = FALSE;
    *pdwFrameSize           = 0;

    //
    // If it's a default entry, it's not SLIP.
    //
    if (prasconncb->fDefaultEntry)
    {
        return 0;
    }

    //
    // Find the base protocol.  If it's not SLIP, were done.
    //
    if (pEntry->dwBaseProtocol != BP_Slip)
    {
        return 0;
    }

    //
    // Make sure IP is installed and Terminal mode can be
    // supported as these are required by SLIP.
    //
    if (!(GetInstalledProtocolsEx(
                NULL, FALSE, TRUE, FALSE) & NP_Ip))
    {
        return ERROR_SLIP_REQUIRES_IP;
    }

    //
    // Read SLIP parameters from phonebook entry.
    //
    *pfHeaderCompression    = pEntry->fIpHeaderCompression;
    *pfPrioritizeRemote     = pEntry->fIpPrioritizeRemote;
    *pdwFrameSize           = pEntry->dwFrameSize;
    *ppszIpAddress          = StrDup(pEntry->pszIpAddress);

    return 0;
}


DWORD
RouteSlip(
    IN RASCONNCB* prasconncb,
    IN TCHAR*     pszIpAddress,
    IN BOOL       fPrioritizeRemote,
    IN DWORD      dwFrameSize )

/*++

Routine Description:

    Does all the network setup to activate the SLIP route.

Arguments:

Return Value:

    Returns 0 if successful, otherwise an non-0 error code.

--*/

{
    DWORD            dwErr;
    RASMAN_ROUTEINFO route;
    WCHAR*           pwszRasAdapter;
    IPADDR           ipaddr = IpaddrFromAbcd( pszIpAddress );
    PBENTRY*         pEntry = prasconncb->pEntry;

    //
    // Register SLIP connection with RASMAN so he can
    // disconnect it properly.
    //
    RASAPI32_TRACE("RasPortRegisterSlip...");

    dwErr = g_pRasPortRegisterSlip(
              prasconncb->hport,
              ipaddr,
              dwFrameSize,
              fPrioritizeRemote,
              pEntry->pszIpDnsAddress,
              pEntry->pszIpDns2Address,
              pEntry->pszIpWinsAddress,
              pEntry->pszIpWins2Address);

    RASAPI32_TRACE1("RasPortRegisterSlip done(%d)", dwErr);

    if (dwErr != 0)
    {
        return dwErr;
    }

    return 0;
}

#if AMB
VOID
SetAuthentication(
    IN RASCONNCB* prasconncb,
    IN DWORD      dwAuthentication )

/*++

Routine Description:

    Sets the authentication strategy parameter in the
    phonebook entry to 'dwAuthentication'.  No error
    is returned as it is not considered fatal if this
    "optimization" can't be made.

Arguments:

Return Value:

--*/

{

    if (prasconncb->fDefaultEntry)
    {
        return;
    }

    prasconncb->pEntry->dwAuthentication = dwAuthentication;
    prasconncb->pEntry->fDirty = TRUE;

    return;
}
#endif


DWORD
SetDefaultDeviceParams(
    IN  RASCONNCB* prasconncb,
    OUT TCHAR*      pszType,
    OUT TCHAR*      pszName )

/*++

Routine Description:

    Set the default DEVICE settings, i.e. the phone
    number and modem speaker settings.  'prasconncb'
    is the current connection control block.'pszType'
    and 'pszName' are set to the device type and name
    of the device, i.e. "modem" and "Hayes Smartmodem
    2400".

Arguments:

Return Value:

    Returns 0 or a non-0 error code.

--*/

{
    DWORD dwErr;
    PBLINK* pLink = prasconncb->pLink;

    do
    {
        //
        // Make sure a modem is attached to the port.
        //
        if (CaseInsensitiveMatch(
            prasconncb->szDeviceType,
            TEXT(MXS_MODEM_TXT) ) == FALSE)
        {
            dwErr = ERROR_WRONG_DEVICE_ATTACHED;
            break;
        }

        lstrcpy( pszType, TEXT(MXS_MODEM_TXT) );
        lstrcpyn(
            pszName,
            prasconncb->szDeviceName,
            RAS_MAXLINEBUFLEN + 1);

        //
        // Set the phone number.
        //
        if ((dwErr = SetDeviceParamString(
                prasconncb->hport, TEXT(MXS_PHONENUMBER_KEY),
                prasconncb->rasdialparams.szPhoneNumber,
                pszType, pszName )) != 0)
        {
            break;
        }

        //
        // Set the modem speaker flag.
        //
        if ((dwErr = SetDeviceParamString(
                prasconncb->hport, TEXT(MXS_SPEAKER_KEY),
                (prasconncb->fDisableModemSpeaker)
                ? TEXT("0")
                : TEXT("1"),
                pszType, pszName )) != 0)
        {
            break;
        }

        {
            CHAR szTypeA[RAS_MaxDeviceType + 1];
            BYTE* pBlob;
            DWORD cbBlob;

            //
            // Setup a unimodem blob containing default
            // settings, less any settings that cannot
            // apply to RAS, plus the phonebook settings
            // user has specified, and tell RASMAN to
            // use it.
            //
            strncpyTtoA(szTypeA, pszType, sizeof(szTypeA));

            dwErr = GetRasUnimodemBlob(
                    NULL,
                    prasconncb->hport, szTypeA,
                    &pBlob, &cbBlob );

            if (cbBlob > 0)
            {
                UNIMODEMINFO info;

                info.fHwFlow    = pLink->fHwFlow;
                info.fEc        = pLink->fEc;
                info.fEcc       = pLink->fEcc;
                info.dwBps      = pLink->dwBps;
                info.fSpeaker   = !prasconncb->fDisableModemSpeaker;

                info.fOperatorDial          = FALSE;
                info.fUnimodemPreTerminal   = FALSE;

                UnimodemInfoToBlob( &info, pBlob );

                RASAPI32_TRACE("RasSetDevConfig");

                dwErr = g_pRasSetDevConfig(
                    prasconncb->hport, szTypeA,
                    pBlob, cbBlob );

                RASAPI32_TRACE1("RasSetDevConfig=%d",dwErr);

                Free0( pBlob );
            }

            if (dwErr != 0)
            {
                return dwErr;
            }
        }
    }
    while (FALSE);

    return dwErr;
}


BOOL
FindNextDevice(
    IN RASCONNCB *prasconncb
    )
{
    BOOL        fFound  = FALSE;
    DWORD       dwErr;
    PBENTRY*    pEntry  = prasconncb->pEntry;
    PBLINK*     pLink   = prasconncb->pLink;
    TCHAR       szType[RAS_MaxDeviceType + 1];
    TCHAR       szName[RAS_MaxDeviceName + 1];

    //
    // Get device type from port structure.
    //
    if (prasconncb->iDevice < prasconncb->cDevices)
    {
        //
        // Set default device type and name.
        //
        lstrcpyn(
            szType,
            prasconncb->szDeviceType,
            sizeof(szType) / sizeof(TCHAR));

        lstrcpyn(
            szName,
            prasconncb->szDeviceName,
            sizeof(szName) / sizeof(TCHAR));

        switch (pLink->pbport.pbdevicetype)
        {
        case PBDT_Modem:
        case PBDT_Pad:
        case PBDT_Switch:
            switch (prasconncb->iDevice)
            {
            case 0:
                if (        (pLink->pbport.fScriptBefore
                        ||  pLink->pbport.fScriptBeforeTerminal)
                    && !(pLink->pbport.pbdevicetype == PBDT_Modem)
                    )
                {
                    fFound = TRUE;
                    lstrcpy(szType, TEXT(MXS_SWITCH_TXT));

                    if (pLink->pbport.pszScriptBefore != NULL)
                    {
                        lstrcpyn(
                            szName,
                            pLink->pbport.pszScriptBefore,
                            sizeof(szName) / sizeof(TCHAR));
                    }

                    break;
                }

                // fall through
            case 1:
                if (CaseInsensitiveMatch(
                        prasconncb->szDeviceType,
                        TEXT(MXS_MODEM_TXT)) == TRUE)
                {
                    fFound = TRUE;
                    break;
                }

                // fall through
            case 2:
                if (pEntry->pszX25Network != NULL)
                {
                    lstrcpy(szType, TEXT(MXS_PAD_TXT));
                    fFound = TRUE;
                    break;
                }

                // fall through
            case 3:
                if (    pEntry->fScriptAfter
                    ||  pEntry->fScriptAfterTerminal
                    ||  (1 == pEntry->dwCustomScript))
                {
                    lstrcpy(szType, TEXT(MXS_SWITCH_TXT));

                    if (pEntry->pszScriptAfter != NULL)
                    {
                        lstrcpyn(
                            szName,
                            pEntry->pszScriptAfter,
                            sizeof(szName) / sizeof(TCHAR));
                    }

                    fFound = TRUE;
                    break;
                }

                // fall through
            }
            break;

        case PBDT_Isdn:
            lstrcpy(szType, TEXT(ISDN_TXT));
            fFound = TRUE;
            break;

        case PBDT_X25:
            lstrcpy(szType, TEXT(X25_TXT));
            fFound = TRUE;
            break;

        case PBDT_Irda:
            lstrcpy(szType, RASDT_Irda);

        case PBDT_Vpn:
            lstrcpy(szType, RASDT_Vpn);

            if(prasconncb->iDevice == 0)
                fFound = TRUE;

            break;

        case PBDT_Serial:
            lstrcpy(szType, RASDT_Serial);
            if(prasconncb->iDevice == 0)
                fFound = TRUE;

            break;

        case PBDT_Atm:
            lstrcpy(szType, RASDT_Atm);
            if(prasconncb->iDevice == 0)
                fFound = TRUE;

            break;

        case PBDT_Parallel:
            lstrcpy(szType, RASDT_Parallel);
            if(prasconncb->iDevice == 0)
                fFound = TRUE;

            break;

        case PBDT_Sonet:
            lstrcpy(szType, RASDT_Sonet);
            if(prasconncb->iDevice == 0)
                fFound = TRUE;

            break;

        case PBDT_Sw56:
            lstrcpy(szType, RASDT_SW56);
            if(prasconncb->iDevice == 0)
                fFound = TRUE;

            break;

        case PBDT_FrameRelay:
            lstrcpy(szType, RASDT_FrameRelay);
            if(prasconncb->iDevice == 0)
                fFound = TRUE;

            break;

        case PBDT_PPPoE:
            lstrcpy(szType, RASDT_PPPoE);
            if(prasconncb->iDevice == 0)
                fFound = TRUE;
            break;

        //
        // Fall through is intentional
        //

        default:
            //
            // For the default case, we don't assume a multi stage
            // connect. We can assume there is only one device if
            // its not any of the above PBDT's
            //
            if(prasconncb->iDevice == 0)
            {

                lstrcpyn(
                    szType,
                    pLink->pbport.pszMedia,
                    sizeof(szType) / sizeof(TCHAR));
                
                fFound = TRUE;
            }
            break;
        }
    }

    if (fFound)
    {
        if (pLink->pbport.pbdevicetype == PBDT_Pad)
        {
            if (CaseInsensitiveMatch(
                    pEntry->pszX25Network,
                    TEXT(MXS_PAD_TXT)) == FALSE)
            {
                lstrcpyn(
                    szName,
                    pEntry->pszX25Network,
                    sizeof(szName) / sizeof(TCHAR));
            }
        }

        //
        // Store the device type and name in rasman
        // for the RasGetConnectStatus API.
        //
        //
        RASAPI32_TRACE2("FindNextDevice: (%S, %S)", szType, szName);

        dwErr = g_pRasSetPortUserData(
                  prasconncb->hport,
                  PORT_DEVICETYPE_INDEX,
                  (PCHAR)szType,
                  sizeof (szType));

        dwErr = g_pRasSetPortUserData(
                  prasconncb->hport,
                  PORT_DEVICENAME_INDEX,
                  (PCHAR)szName,
                  sizeof (szName));
    }

    return fFound;
}


DWORD
GetDeviceParamString(
    IN  HPORT   hport,
    IN  TCHAR*  pszKey,
    OUT TCHAR*  pszValue,
    IN  TCHAR*  pszType,
    IN  TCHAR*  pszName
    )

/*++

Routine Description:

    Get device info on port 'hport' with the given
    parameters.

Arguments:

Return Value:

    Returns 0 if successful, otherwise a non-0 error code.

--*/

{
    DWORD              dwErr;
    DWORD              dwSize = 0;
    DWORD              i;
    RASMAN_DEVICEINFO* pinfo;
    RAS_PARAMS*        pparam;

    RASAPI32_TRACE3(
        "RasDeviceGetInfo(%S,%S,%S)...",
        pszKey, pszType, pszName);

    //
    // Initialize output parameter.
    //
    *pszValue = TEXT('\0');

    //
    // Call RasDeviceGetInfo once to get the
    // size of the buffer.
    //
    {
        CHAR szTypeA[MAX_DEVICETYPE_NAME], szNameA[MAX_DEVICE_NAME];

        strncpyTtoA(szTypeA, pszType, sizeof(szTypeA));

        strncpyTtoA(szNameA, pszName, sizeof(szNameA));

        dwErr = g_pRasDeviceGetInfo(
                    NULL,
                    hport,
                    szTypeA,
                    szNameA,
                    NULL,
                    &dwSize );

        if (dwErr != ERROR_BUFFER_TOO_SMALL)
        {
            return dwErr;
        }

        if (!(pinfo = Malloc(dwSize)))
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        //
        // Call RasDeviceGetInfo again with the
        // allocated buffer.
        //
        dwErr = g_pRasDeviceGetInfo(
                    NULL,
                    hport,
                    szTypeA,
                    szNameA,
                    (PCHAR)pinfo,
                    &dwSize );
    }

    if (!dwErr)
    {
        CHAR szKeyA[MAX_PARAM_KEY_SIZE];

        //
        // Search for the specified key.
        //
        strncpyTtoA(szKeyA, pszKey, sizeof(szKeyA));

        for (i = 0, pparam = pinfo->DI_Params;
             i < pinfo->DI_NumOfParams;
             i++, pparam++)
        {
            if (!_stricmp(pparam->P_Key, szKeyA))
            {
                strncpyAtoT(
                    pszValue,
                    pparam->P_Value.String.Data,
                    RAS_MAXLINEBUFLEN);

                break;
            }
        }
    }

    RASAPI32_TRACE1("RasDeviceGetInfo done(%d)\n", dwErr);

    Free( pinfo );

    return dwErr;
}


DWORD
SetDeviceParamString(
    IN HPORT hport,
    IN TCHAR* pszKey,
    IN TCHAR* pszValue,
    IN TCHAR* pszType,
    IN TCHAR* pszName )

/*++

Routine Description:

    Set device info on port 'hport' with the given parameters.

Arguments:

Return Value:

    Returns 0 if successful, otherwise a non-0 error code.

--*/

{
    DWORD              dwErr;
    RASMAN_DEVICEINFO* pinfo;
    RAS_PARAMS*        pparam;

    if (!(pinfo = Malloc(  sizeof(RASMAN_DEVICEINFO)
                         + RAS_MAXLINEBUFLEN )))
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    pinfo->DI_NumOfParams = 1;

    pparam                = pinfo->DI_Params;

    pparam->P_Attributes  = 0;

    pparam->P_Type        = String;

    pparam->P_Value.String.Data = (LPSTR )(pparam + 1);

    strncpyTtoAAnsi(pparam->P_Key, pszKey, sizeof(pparam->P_Key));

    strncpyTtoAAnsi(pparam->P_Value.String.Data, pszValue, RAS_MAXLINEBUFLEN);
    
    pparam->P_Value.String.Length =
                strlen( pparam->P_Value.String.Data ) + 1;

    if(FALSE == CaseInsensitiveMatch(pszKey,TEXT("password")))
    {

        RASAPI32_TRACE2("RasDeviceSetInfo(%S=%S)...",
                pszKey,
                pszValue);

    }

    {
        CHAR szTypeA[RAS_MaxDeviceType + 1],
             szNameA[RAS_MaxDeviceName + 1];

        strncpyTtoAAnsi(szTypeA, pszType, sizeof(szTypeA));
        strncpyTtoAAnsi(szNameA, pszName, sizeof(szNameA));

        dwErr = g_pRasDeviceSetInfo(
                    hport, szTypeA,
                    szNameA, pinfo );
    }

    RASAPI32_TRACE1("RasDeviceSetInfo done(%d)", dwErr);

    Free( pinfo );

    return dwErr;
}


DWORD
SetDeviceParamNumber(
    IN HPORT    hport,
    IN TCHAR*   pszKey,
    IN DWORD    dwValue,
    IN TCHAR*   pszType,
    IN TCHAR*   pszName )

/*++

Routine Description:

    Set device info on port 'hport' with the given parameters.

Arguments:

Return Value:

    Returns 0 if successful, otherwise a non-0 error code.

--*/

{
    DWORD              dwErr;
    RASMAN_DEVICEINFO* pinfo;
    RAS_PARAMS*        pparam;

    if (!(pinfo = Malloc( sizeof(RASMAN_DEVICEINFO) )))
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    pinfo->DI_NumOfParams   = 1;
    pparam                  = pinfo->DI_Params;
    pparam->P_Attributes    = 0;
    pparam->P_Type          = Number;
    pparam->P_Value.Number  = dwValue;

    strncpyTtoA(pparam->P_Key, pszKey, sizeof(pparam->P_Key));

    RASAPI32_TRACE2("RasDeviceSetInfo(%S=%d)...", pszKey, dwValue);

    {
        CHAR szTypeA[MAX_DEVICETYPE_NAME], szNameA[MAX_DEVICE_NAME];

        strncpyTtoA(szTypeA, pszType, sizeof(szTypeA));
        strncpyTtoA(szNameA, pszName, sizeof(szNameA));

        dwErr = g_pRasDeviceSetInfo(
                    hport, szTypeA,
                    szNameA, pinfo );
    }

    RASAPI32_TRACE1("RasDeviceSetInfo done(%d)", dwErr);

    Free( pinfo );

    return dwErr;
}


DWORD
SetDeviceParams(
    IN  RASCONNCB* prasconncb,
    OUT TCHAR*      pszType,
    OUT TCHAR*      pszName,
    OUT BOOL*      pfTerminal )

/*++

Routine Description:

    Set RAS Manager information for each device.  The
    current device is defined by prasconncb->iDevice.
    'prasconncb' is the current connection control block.
    'pszType' and 'pszName' are set to the device type
    and name of the device, i.e. "modem" and "Hayes
    Smartmodem 2400".

Arguments:

Return Value:

    '*pfTerminal' is set true if the device is a switch
    of type "Terminal",false otherwise.

--*/

{
    DWORD              dwErr = 0;
    DWORD              iPhoneNumber = 0;
    RAS_PARAMS*        pparam;
    RASMAN_DEVICEINFO* pdeviceinfo;
    BOOL               fModem;
    BOOL               fIsdn;
    BOOL               fPad;
    BOOL               fSwitch;
    BOOL               fX25;
    PBENTRY*           pEntry = prasconncb->pEntry;
    PBLINK*            pLink = prasconncb->pLink;

    *pfTerminal = FALSE;

    //
    // Default device name is that attached to the port.
    //
    lstrcpyn(pszName, prasconncb->szDeviceName, RAS_MAXLINEBUFLEN + 1);

    switch (pLink->pbport.pbdevicetype)
    {
    case PBDT_Modem:
    case PBDT_Pad:
    case PBDT_Switch:
        switch (prasconncb->iDevice)
        {
        case 0:
            if (    (   pLink->pbport.fScriptBefore
                    ||  pLink->pbport.fScriptBeforeTerminal)
                && !(pLink->pbport.pbdevicetype == PBDT_Modem)
                )
            {

                lstrcpy(pszType, TEXT(MXS_SWITCH_TXT));

                if (pLink->pbport.pszScriptBefore != NULL)
                {
                    lstrcpyn(
                        pszName,
                        pLink->pbport.pszScriptBefore,
                        RAS_MAXLINEBUFLEN + 1);
                }
                prasconncb->iDevice = 1;

                *pfTerminal = (pLink->pbport.fScriptBeforeTerminal);
                break;
            }
            // fall through
        case 1:
            if (CaseInsensitiveMatch(
                    prasconncb->szDeviceType,
                    TEXT(MXS_MODEM_TXT)) == TRUE)
            {
                lstrcpy(pszType, TEXT(MXS_MODEM_TXT));

                prasconncb->iDevice = 2;

                break;
            }
            // fall through
        case 2:
            if (pEntry->pszX25Network != NULL)
            {
                lstrcpy(pszType, TEXT(MXS_PAD_TXT));

                prasconncb->iDevice = 3;

                break;
            }
            // fall through
        case 3:
            if (    pEntry->fScriptAfter
                ||  pEntry->fScriptAfterTerminal
                ||  pEntry->dwCustomScript)
            {
                lstrcpy(pszType, TEXT(MXS_SWITCH_TXT));

                if (pEntry->pszScriptAfter != NULL)
                {
                    lstrcpyn(pszName, pEntry->pszScriptAfter, RAS_MAXLINEBUFLEN + 1);
                }

                prasconncb->iDevice = 4;
                *pfTerminal = pEntry->fScriptAfterTerminal;

                if(pEntry->dwCustomScript == 1)
                {
                    *pfTerminal = TRUE;
                }

                break;
            }
            // fall through
        default:
            return FALSE;
        }
        break;

    case PBDT_Isdn:
        lstrcpy(pszType, TEXT(ISDN_TXT));
        prasconncb->iDevice = 1;
        break;

    case PBDT_X25:
        lstrcpy(pszType, TEXT(X25_TXT));
        prasconncb->iDevice = 1;
        break;

    default:
        lstrcpyn(pszType, pLink->pbport.pszMedia, RAS_MAXLINEBUFLEN + 1);
        prasconncb->iDevice = 1;
        break;
    }

    fModem  = (CaseInsensitiveMatch(
                pszType,
                TEXT(MXS_MODEM_TXT) ) == TRUE);

    fIsdn   = (CaseInsensitiveMatch(
                pszType,
                TEXT(ISDN_TXT) ) == TRUE);

    fPad    = (CaseInsensitiveMatch(
                pszType,
                TEXT(MXS_PAD_TXT) ) == TRUE);

    fSwitch = (CaseInsensitiveMatch(
                pszType,
                TEXT(MXS_SWITCH_TXT) ) == TRUE);

    fX25    = (CaseInsensitiveMatch(
                pszType,
                TEXT(X25_TXT)) == TRUE);

    if (fModem)
    {
        //
        // Make sure a modem is attached to the port.
        //
        if (lstrcmpi( prasconncb->szDeviceType, pszType ) != 0)
        {
            return ERROR_WRONG_DEVICE_ATTACHED;
        }

        //
        // Set the modem speaker flag which is global to all entries.
        //
        if ((dwErr = SetDeviceParamString(
                prasconncb->hport, TEXT(MXS_SPEAKER_KEY),
                (prasconncb->fDisableModemSpeaker)
                ? TEXT("0") : TEXT("1"),
                pszType, pszName )) != 0)
        {
            return dwErr;
        }
    }

    //
    // Set up hunt group if indicated.
    //
    if (!prasconncb->cPhoneNumbers)
    {
        prasconncb->cPhoneNumbers =
            DtlGetNodes(pLink->pdtllistPhones);

        //
        // If multiple phone numbers were found turn on local
        // error handling, i.e. don't report failures to API
        // caller until all numbers are tried.
        //
        if (prasconncb->cPhoneNumbers > 1)
        {
            RASAPI32_TRACE1(
              "Hunt group of %d begins",
              prasconncb->cPhoneNumbers);

            prasconncb->dwRestartOnError = RESTART_HuntGroup;
        }
    }

    //
    // Pass device parameters to RAS Manager, interpreting
    // special features as required.
    //
    if (fModem)
    {
        if (prasconncb->fOperatorDial)
        {
            //
            // Special case to recognize MXS Operator Dial
            // mode and override any phone number with an
            // empty number.
            //
            prasconncb->rasdialparams.szPhoneNumber[ 0 ] = '\0';

            dwErr = SetDeviceParamString(
                        prasconncb->hport,
                        TEXT(MXS_AUTODIAL_KEY),
                        TEXT("0"),
                        pszType, pszName );

            if (dwErr != 0)
            {
                return dwErr;
            }
        }

        //
        // Set the phone number.
        //
        dwErr = SetDeviceParamString(
                  prasconncb->hport,
                  TEXT(MXS_PHONENUMBER_KEY),
                  prasconncb->szPhoneNumber,
                  pszType,
                  pszName);
        if (dwErr)
        {
            return dwErr;
        }

        /* Indicate interactive mode for manual modem commands.  The
        ** manual modem commands flag is used only for connection and is
        ** not a "RAS Manager "info" parameter.
        // Support for mxsmodems is not present in nt5
        if (pLink->fManualDial)
            *pfTerminal = TRUE; */

        //
        // Set hardware flow control.
        //
        dwErr = SetDeviceParamString(
                  prasconncb->hport,
                  TEXT(MXS_HDWFLOWCONTROL_KEY),
                  pLink->fHwFlow ? TEXT("1") : TEXT("0"),
                  pszType,
                  pszName);

        if (dwErr)
        {
            return dwErr;
        }

        //
        // Set protocol.
        //
        dwErr = SetDeviceParamString(
                  prasconncb->hport,
                  TEXT(MXS_PROTOCOL_KEY),
                  pLink->fEc ? TEXT("1") : TEXT("0"),
                  pszType,
                  pszName);

        if (dwErr)
        {
            return dwErr;
        }

        //
        // Set compression.
        //
        dwErr = SetDeviceParamString(
                  prasconncb->hport,
                  TEXT(MXS_COMPRESSION_KEY),
                  pLink->fEcc ? TEXT("1") : TEXT("0"),
                  pszType,
                  pszName);

        if (dwErr)
        {
            return dwErr;
        }

        {
            CHAR szTypeA[RAS_MaxDeviceType + 1];
            BYTE* pBlob;
            DWORD cbBlob = 0;

            //
            // Setup a unimodem blob containing default settings,
            // less any settings that cannot apply to RAS, plus the
            // phonebook settings user has specified, and tell RASMAN
            // to use it.
            //
            strncpyTtoA(szTypeA, pszType, sizeof(szTypeA));

            // XP 281306
            //
            // Load the appropriate device settings.
            // 
            // This silly exercise is due to some bugs in the 
            // unimodem tapi service provider.  By the time the bugs
            // were discovered, it was too late to fix for XP so
            // this is the workaround.  
            //
            // Calling GetRasUnimodemBlobEx(fGlobal=TRUE) will cause 
            // rasman to read the "comm/datamodem/dialin" settings  
            // instead of the "comm/datamodem" settings it normally 
            // reads when fGlobal is FALSE.
            //
            // The "default" settings for a device as rendered in the 
            // control panel are actually the "comm/datamodem/dialin"
            // settings.
            //
            if ( prasconncb->pEntry->fGlobalDeviceSettings )
            {
                dwErr = GetRasUnimodemBlobEx(
                    NULL,
                    prasconncb->hport,
                    szTypeA,
                    TRUE,
                    &pBlob,
                    &cbBlob );
                    
                RASAPI32_TRACE1("SetDeviceParams: get glob devcfg %d", dwErr);
            }
            else
            {
                dwErr = GetRasUnimodemBlobEx(
                    NULL,
                    prasconncb->hport,
                    szTypeA,
                    FALSE,
                    &pBlob,
                    &cbBlob );
            }

            if (dwErr != 0)
            {
                return dwErr;
            }
            
            if (cbBlob > 0)
            {
                UNIMODEMINFO info;

                // Whistler bug 281306.  
                //
                // Ignore pbk settings when the global config flag is set.
                //
                if ( ! prasconncb->pEntry->fGlobalDeviceSettings )
                {
                    info.fHwFlow    = pLink->fHwFlow;
                    info.fEc        = pLink->fEc;
                    info.fEcc       = pLink->fEcc;
                    info.dwBps      = pLink->dwBps;
                    info.fSpeaker   = !prasconncb->fDisableModemSpeaker;
                    info.fOperatorDial = prasconncb->fOperatorDial;
                    info.dwModemProtocol = pLink->dwModemProtocol;

                    info.fUnimodemPreTerminal =
                        (   pLink->pbport.fScriptBeforeTerminal
                         && (pLink->pbport.pbdevicetype == PBDT_Modem)
                         ) ? TRUE : FALSE;

                    UnimodemInfoToBlob( &info, pBlob );
                }                    

                RASAPI32_TRACE("RasSetDevConfig");
                {
                    CHAR szSetTypeA[MAX_DEVICETYPE_NAME];

                    strncpyTtoA(szSetTypeA, pszType, sizeof(szSetTypeA));

                    dwErr = g_pRasSetDevConfig(
                                prasconncb->hport,
                                szSetTypeA, pBlob, cbBlob );
                }

                RASAPI32_TRACE1("RasSetDevConfig=%d",dwErr);

                Free0( pBlob );
            }

        }
    }
    else if (fIsdn)
    {
        TCHAR szNum[17];

        //
        // Set the line type.
        //
        wsprintf(szNum, TEXT("%d"), pLink->lLineType);

        dwErr = SetDeviceParamString(
                  prasconncb->hport,
                  TEXT(ISDN_LINETYPE_KEY),
                  szNum,
                  pszType,
                  pszName);

        if (dwErr)
        {
            return dwErr;
        }

        //
        // Set the fallback value.
        //
        dwErr = SetDeviceParamString(
                  prasconncb->hport,
                  TEXT(ISDN_FALLBACK_KEY),
                  pLink->fFallback ? TEXT("1") : TEXT("0"),
                  pszType,
                  pszName);

        if (dwErr)
        {
            return dwErr;
        }

        //
        // Set the Digi proprietary framing flags.
        //
        dwErr = SetDeviceParamString(
                  prasconncb->hport,
                  TEXT(ISDN_COMPRESSION_KEY),
                  pLink->fCompression ? TEXT("1") : TEXT("0"),
                  pszType,
                  pszName);

        if (dwErr)
        {
            return dwErr;
        }

        wsprintf(szNum, TEXT("%d"), pLink->lChannels);

        dwErr = SetDeviceParamString(
                  prasconncb->hport,
                  TEXT(ISDN_CHANNEL_AGG_KEY),
                  szNum,
                  pszType,
                  pszName);
        if (dwErr)
        {
            return dwErr;
        }

        //
        // Set the phone number.
        //
        dwErr = SetDeviceParamString(
                  prasconncb->hport,
                  TEXT(MXS_PHONENUMBER_KEY),
                  prasconncb->szPhoneNumber,
                  pszType,
                  pszName);

        if (dwErr)
        {
            return dwErr;
        }
    }
    else if (   fPad
            ||  fX25)
    {
        //
        // The PAD Type from the entry applies only if the port
        // is not configured as a local PAD.  In any case, PAD
        // Type is used only for connection and is not a RAS Manager
        // "info" parameter.
        //
        if (CaseInsensitiveMatch(
                prasconncb->szDeviceType,
                TEXT(MXS_PAD_TXT)) == FALSE)
        {
            lstrcpyn(pszName, pEntry->pszX25Network, RAS_MAXLINEBUFLEN + 1);
        }

        //
        // Set the X.25 address.
        //
        dwErr = SetDeviceParamString(
                  prasconncb->hport,
                  TEXT(X25_ADDRESS_KEY),
                  pEntry->pszX25Address,
                  pszType,
                  pszName);

        if (dwErr)
        {
            return dwErr;
        }

        //
        // Set the X.25 user data.
        //
        dwErr = SetDeviceParamString(
                  prasconncb->hport,
                  TEXT(X25_USERDATA_KEY),
                  pEntry->pszX25UserData,
                  pszType,
                  pszName);

        if (dwErr)
        {
            return dwErr;
        }

        //
        // Set the X.25 facilities.
        //
        dwErr = SetDeviceParamString(
                  prasconncb->hport,
                  TEXT(MXS_FACILITIES_KEY),
                  pEntry->pszX25Facilities,
                  pszType,
                  pszName);

        if (dwErr)
        {
            return dwErr;
        }
    }
    else if (fSwitch)
    {
    }
    else {

        if(RASET_Vpn == prasconncb->pEntry->dwType)
        {
            struct in_addr addr;
            DWORD iAddress = prasconncb->iAddress;
            TCHAR *pszPhoneNumber = NULL;
            CHAR *pszPhoneNumberA =
                        strdupTtoA(prasconncb->szPhoneNumber);

            if(NULL == pszPhoneNumberA)
            {
                dwErr = E_OUTOFMEMORY;
                return dwErr;
            }

            ASSERT(iAddress > 0);

            if(     (prasconncb->cAddresses > 1)
                ||  (inet_addr(pszPhoneNumberA)) == -1)
            {
                addr.s_addr = prasconncb->pAddresses[iAddress - 1];

                pszPhoneNumber = strdupAtoT(
                            inet_ntoa(addr));
            }
            else if(1 == prasconncb->cAddresses)
            {
                pszPhoneNumber = StrDup(prasconncb->szPhoneNumber);
            }

            if(NULL != pszPhoneNumber)
            {

                RASAPI32_TRACE2("SetDefaultParams: Using address %d=%ws",
                        iAddress - 1,
                        pszPhoneNumber);

                //
                // Set the phone number.
                //
                dwErr = SetDeviceParamString(
                          prasconncb->hport,
                          TEXT(MXS_PHONENUMBER_KEY),
                          pszPhoneNumber,
                          pszType,
                          pszName);
            }
            else
            {
                dwErr = E_OUTOFMEMORY;
            }

            Free(pszPhoneNumberA);
            Free0(pszPhoneNumber);
        }
        else
        {
            //
            // Set the phone number.
            //
            dwErr = SetDeviceParamString(
                      prasconncb->hport,
                      TEXT(MXS_PHONENUMBER_KEY),
                      prasconncb->szPhoneNumber,
                      pszType,
                      pszName);
        }                  

        if (dwErr)
        {
            return dwErr;
        }
    }

    if (    (   fModem
            ||  fPad
            ||  (   fSwitch
                &&  !*pfTerminal))
        && (    prasconncb->rasdialparams.szUserName[0] != TEXT('\0')
            ||  prasconncb->rasdialparams.szPassword[0] != TEXT('\0')))
    {
        RASAPI32_TRACE1(
          "User/pw set for substitution (%S)",
          prasconncb->rasdialparams.szUserName);

        //
        // It's a serial device with clear-text user name
        // and password supplied.  Make the credentials
        // available for substitution use in script
        // files.
        //
        if ((dwErr = SetDeviceParamString(
                prasconncb->hport, TEXT(MXS_USERNAME_KEY),
                prasconncb->rasdialparams.szUserName,
                pszType, pszName )) != 0)
        {
            return dwErr;
        }

        DecodePassword( prasconncb->rasdialparams.szPassword );

        dwErr = SetDeviceParamString(
            prasconncb->hport, TEXT(MXS_PASSWORD_KEY),
            prasconncb->rasdialparams.szPassword,
            pszType, pszName );

        EncodePassword( prasconncb->rasdialparams.szPassword );

        if (dwErr != 0)
        {
            return dwErr;
        }
    }

    return dwErr;
}


DWORD
ConstructPhoneNumber(
    IN RASCONNCB *prasconncb
    )
{
    DWORD dwErr = 0;

    PBENTRY* pEntry = prasconncb->pEntry;

    PBLINK* pLink = prasconncb->pLink;

    TCHAR* pszNum = prasconncb->rasdialparams.szPhoneNumber;

    TCHAR* pszDisplayNum = pszNum;

    DTLNODE* pdtlnode;

    DTLNODE* pdtlnodePhone = NULL;

    WCHAR* pwszNum;

    PBUSER pbuser;

    PBPHONE *pPhone;

    dwErr = GetUserPreferences(NULL,
                               &pbuser,
                               prasconncb->dwUserPrefMode);
    if (dwErr)
    {
        return dwErr;
    }

    prasconncb->fOperatorDial = pbuser.fOperatorDial;

    ASSERT(pLink);

    if(     (pLink->pdtllistPhones)
        &&  (pdtlnodePhone = DtlGetFirstNode(
                            pLink->pdtllistPhones
                            )))
    {

        pPhone = (PBPHONE *)
                 DtlGetData(pdtlnodePhone);

        ASSERT(pPhone);

    }
    else
    {
        pPhone = NULL;
    }

    //
    // Construct the phone number.
    //

    //
    // Use of TAPI dialing properties is dependent only on
    // the entry flag and is never applied to an overridden
    // phone number, this to be consistent with Win95.
    //

    //
    // Use of prefix/suffix (even on overridden number) is
    // controlled by the RASDIALEXTENSIONS setting, this all
    // necessary for RASDIAL.EXE support.
    //
    if (    (   (NULL != pPhone)
            &&  (pPhone->fUseDialingRules)
            &&  (*pszNum == TEXT('\0')))
         || (   (NULL != pPhone)
            &&  (!pPhone->fUseDialingRules)
            &&  (prasconncb->fUsePrefixSuffix)))
    {
        HLINEAPP hlineApp = 0;
        TCHAR *pszDialNum;

        //
        // Calculate the dialable string to
        // be sent to the device.
        //
        pszDialNum = LinkPhoneNumberFromParts(
                       GetModuleHandle(NULL),
                       &hlineApp,
                       &pbuser,
                       prasconncb->pEntry,
                       pLink,
                       prasconncb->iPhoneNumber,
                       pszNum,
                       TRUE);

        //
        // Calculate the displayable string to
        // be returned in RasGetConnectStatus().
        //
        pszDisplayNum = LinkPhoneNumberFromParts(
                          GetModuleHandle(NULL),
                          &hlineApp,
                          &pbuser,
                          prasconncb->pEntry,
                          pLink,
                          prasconncb->iPhoneNumber,
                          pszNum,
                          FALSE);
        pszNum = pszDialNum;
    }
    else if (*pszNum == '\0')
    {
        //
        // Use only the base number.
        //
        pdtlnode = DtlNodeFromIndex(
                     pLink->pdtllistPhones,
                     prasconncb->iPhoneNumber);

        if (pdtlnode != NULL)
        {
            pPhone = (PBPHONE *) DtlGetData(pdtlnode);

            ASSERT(pPhone != NULL);

            pszNum = StrDup(pPhone->pszPhoneNumber);

            if(NULL == pszNum)
            {
                return GetLastError();
            }

            pszDisplayNum = pszNum;
        }
    }

    DestroyUserPreferences(&pbuser);

    if(NULL == pszNum)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Copy the resulting phone number
    // to the connection block
    //
    if (lstrlen(pszNum) > RAS_MaxPhoneNumber)
    {
        return ERROR_PHONE_NUMBER_TOO_LONG;
    }

    //
    // Store the phone number in the connection block.
    //
    lstrcpyn(
        prasconncb->szPhoneNumber,
        pszNum,
        sizeof(prasconncb->szPhoneNumber) / sizeof(WCHAR));

#if DBG
    RASAPI32_TRACE1(
        "ConstructPhoneNumber: %S",
        prasconncb->szPhoneNumber);
#endif

    //
    // Also store the constructed phone number
    // off the port so other applications (like
    // rasphone) can get this information.
    //
    dwErr = g_pRasSetPortUserData(
              prasconncb->hport,
              PORT_PHONENUMBER_INDEX,
              (PBYTE)pszDisplayNum,
              (lstrlen(pszDisplayNum) + 1) * sizeof (TCHAR));
    //
    // Free resources.
    //
    if (pszDisplayNum != pszNum)
    {
        Free(pszDisplayNum);
    }

    if (pszNum != prasconncb->rasdialparams.szPhoneNumber)
    {
        Free(pszNum);
    }

    return dwErr;
}


DWORD
SetMediaParam(
    IN HPORT hport,
    IN TCHAR* pszKey,
    IN TCHAR* pszValue )

/*++

Routine Description:

    Set port info on port 'hport' with the given parameters.

Arguments:

Return Value:

    Returns 0 if successful, otherwise a non-0 error code.

--*/

{
    DWORD            dwErr;
    RASMAN_PORTINFO* pinfo;
    RAS_PARAMS*      pparam;

    if (!(pinfo = Malloc(
                    sizeof(RASMAN_PORTINFO) + RAS_MAXLINEBUFLEN )))
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    pinfo->PI_NumOfParams = 1;

    pparam = pinfo->PI_Params;

    pparam->P_Attributes = 0;

    pparam->P_Type = String;

    pparam->P_Value.String.Data = (LPSTR )(pparam + 1);

    strncpyTtoA(pparam->P_Key, pszKey, sizeof(pparam->P_Key));

    strncpyTtoA(pparam->P_Value.String.Data, pszValue, RAS_MAXLINEBUFLEN);

    pparam->P_Value.String.Length =
                    strlen( pparam->P_Value.String.Data );

    RASAPI32_TRACE2("RasPortSetInfo(%S=%S)...", pszKey, pszValue);

    dwErr = g_pRasPortSetInfo( hport, pinfo );

    RASAPI32_TRACE1("RasPortSetInfo done(%d)", dwErr);

    Free( pinfo );

    return dwErr;
}


DWORD
SetMediaParams(
    IN RASCONNCB *prasconncb
    )

/*++

Routine Description:

    Set RAS Manager media information.

Arguments:

Return Value:

    Returns 0 if successful, otherwise a non-0 error code.

--*/

{
    DWORD            dwErr = 0;
    PBENTRY*         pEntry = prasconncb->pEntry;
    PBLINK*          pLink = prasconncb->pLink;

    if (pLink->pbport.pszMedia == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    if (CaseInsensitiveMatch(
            pLink->pbport.pszMedia,
            TEXT(SERIAL_TXT)) == TRUE)
    {
        TCHAR szBps[64];

        prasconncb->cDevices = 4;
        prasconncb->iDevice = 0;

        //
        // Set the connect BPS only if it's not zero.
        //
        if (pLink->dwBps)
        {
            wsprintf(
                szBps,
                TEXT("%d"),
                pLink->dwBps);

            dwErr = SetMediaParam(
                      prasconncb->hport,
                      TEXT(SER_CONNECTBPS_KEY),
                      szBps);
        }
    }
    else if (CaseInsensitiveMatch(
                pLink->pbport.pszMedia,
                TEXT(ISDN_TXT)) == TRUE)
    {
        prasconncb->cDevices = 1;
        prasconncb->iDevice = 0;

        // no media params
    }
    else if (CaseInsensitiveMatch(
                pLink->pbport.pszMedia,
                TEXT(X25_TXT)) == TRUE)
    {
        prasconncb->cDevices = 1;
        prasconncb->iDevice = 0;

        // no media params
    }
    else
    {
        prasconncb->cDevices = 1;
        prasconncb->iDevice = 0;

        // no media params
    }

    return dwErr;
}


RASCONNCB*
ValidateHrasconn(
    IN HRASCONN hrasconn )

/*++

Routine Description:

    Converts RAS connection handle 'hrasconn' into the
    address of the corresponding RAS connection control
    block.

Arguments:

Return Value:

--*/

{
    RASCONNCB* prasconncb = NULL;
    DTLNODE*   pdtlnode;

    EnterCriticalSection(&RasconncbListLock);

    for (pdtlnode = DtlGetFirstNode( PdtllistRasconncb );
         pdtlnode;
         pdtlnode = DtlGetNextNode( pdtlnode ))
    {
        prasconncb = (RASCONNCB* )DtlGetData( pdtlnode );
        if (prasconncb->hrasconn == (HCONN)hrasconn)
        {
            goto done;
        }
    }
    prasconncb = NULL;

done:
    LeaveCriticalSection(&RasconncbListLock);

    return prasconncb;
}


RASCONNCB*
ValidateHrasconn2(
    IN HRASCONN hrasconn,
    IN DWORD dwSubEntry
    )
{
    RASCONNCB* prasconncb = NULL;
    DTLNODE*   pdtlnode;


    //
    // Convert RAS connection handle 'hrasconn' and
    // dwSubEntry into the address of the corresponding
    // RAS connection control block.
    //
    EnterCriticalSection(&RasconncbListLock);

    for (pdtlnode = DtlGetFirstNode( PdtllistRasconncb );
         pdtlnode;
         pdtlnode = DtlGetNextNode( pdtlnode ))
    {
        prasconncb = (RASCONNCB* )DtlGetData( pdtlnode );
        if (    prasconncb->hrasconn == (HCONN)hrasconn
            &&  prasconncb->rasdialparams.dwSubEntry == dwSubEntry
            &&  !prasconncb->fRasdialRestart)
        {
            goto done;
        }
    }
    prasconncb = NULL;

done:
    LeaveCriticalSection(&RasconncbListLock);

    return prasconncb;
}


RASCONNCB*
ValidatePausedHrasconn(
    IN HRASCONN hrasconn )

/*++

Routine Description:

    Converts RAS connection handle 'hrasconn' into
    the address of the corresponding RAS connection
    control block.

Arguments:

Return Value:

--*/

{
    RASCONNCB* prasconncb = NULL;
    DTLNODE*   pdtlnode;

    EnterCriticalSection(&RasconncbListLock);

    for (pdtlnode = DtlGetFirstNode( PdtllistRasconncb );
         pdtlnode;
         pdtlnode = DtlGetNextNode( pdtlnode ))
    {
        prasconncb = (RASCONNCB* )DtlGetData( pdtlnode );

        if (    prasconncb->hrasconn == (HCONN)hrasconn
            &&  prasconncb->rasconnstate & RASCS_PAUSED)
        {
            goto done;
        }
    }
    prasconncb = NULL;

done:
    LeaveCriticalSection(&RasconncbListLock);

    return prasconncb;
}

/*

Routine Description:

    returns the connection block of a connection if the
    connection corresponding to the hrasconn and
    dwSubEntryId is in a paused and the dial mode
    is RASEDM_DialAsNeeded.returns the connection
    block corresponding to hrasconn if the connection
    is in a paused state and the dial mode is
    RASEDM_DialAll

Arguments::

    hrasconn

    dwSubEntry

Return Value::

    RASCONNCB * corresponding to the hrasconn

*/
RASCONNCB *
ValidatePausedHrasconnEx(IN HRASCONN hrasconn,
                         IN DWORD dwSubEntry)
{
    RASCONNCB   *prasconncb = NULL;
    DTLNODE     *pdtlnode;

    EnterCriticalSection(&RasconncbListLock);

    for (pdtlnode = DtlGetFirstNode( PdtllistRasconncb );
         pdtlnode;
         pdtlnode = DtlGetNextNode( pdtlnode))
    {
        prasconncb = (RASCONNCB *)DtlGetData( pdtlnode) ;

        if (    prasconncb->hrasconn == (HCONN) hrasconn
            &&  prasconncb->rasconnstate & RASCS_PAUSED)
        {
            if (    (   (prasconncb->pEntry->dwDialMode
                        & RASEDM_DialAsNeeded)

                    &&  (prasconncb->rasdialparams.dwSubEntry
                        == dwSubEntry))

                ||  (prasconncb->pEntry->dwDialMode
                    & RASEDM_DialAll))
            {
                goto done;
            }
        }
    }

    prasconncb = NULL;

done:
    LeaveCriticalSection (&RasconncbListLock);

    return prasconncb;

}


#if 0
DWORD
RunApp(
    IN LPTSTR lpszApplication,
    IN LPTSTR lpszCmdLine
    )
{
    STARTUPINFO startupInfo;
    PROCESS_INFORMATION processInfo;

    //
    // Start the process.
    //
    RtlZeroMemory(
        &startupInfo,
        sizeof (startupInfo));

    startupInfo.cb = sizeof(STARTUPINFO);
    if (!CreateProcess(
          NULL,
          lpszCmdLine,
          NULL,
          NULL,
          FALSE,
          NORMAL_PRIORITY_CLASS|DETACHED_PROCESS,
          NULL,
          NULL,
          &startupInfo,
          &processInfo))
    {
        return GetLastError();
    }

    CloseHandle(processInfo.hThread);

    //
    // Wait for the process to exit.
    //
    for (;;)
    {
        DWORD dwExitCode;

        if (!GetExitCodeProcess(
                processInfo.hProcess,
                &dwExitCode))
        {
            break;
        }

        if (dwExitCode != STILL_ACTIVE)
        {
            break;
        }

        Sleep(2);
    }

    CloseHandle(processInfo.hProcess);

    return 0;
}
#endif


DWORD
StringToIpAddr(
    IN LPTSTR pszIpAddr,
    OUT RASIPADDR *pipaddr
    )
{
    DWORD   dwErr;
    CHAR    szIpAddr[17];
    PULONG  pul = (PULONG)pipaddr;

    strncpyTtoA(szIpAddr, pszIpAddr, 17);

    if('\0' != szIpAddr[0])
    {
        *pul = inet_addr(szIpAddr);
    }
    else
    {
        *pul = 0;
    }

    return 0;
}


DWORD
IpAddrToString(
    IN RASIPADDR* pipaddr,
    OUT LPTSTR*   ppszIpAddr
    )
{
    DWORD   dwErr;
    PCHAR   psz;
    LPTSTR  pszIpAddr;
    PULONG  pul = (PULONG)pipaddr;
    struct  in_addr in_addr;

    pszIpAddr = Malloc(17 * sizeof(TCHAR));
    if (pszIpAddr == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    in_addr.s_addr = *pul;

    psz = inet_ntoa(in_addr);

    if (psz == NULL)
    {
        DbgPrint("IpAddrToString: inet_ntoa failed!\n");
        Free(pszIpAddr);
        return WSAGetLastError();
    }

    strncpyAtoT(pszIpAddr, psz, 17);

    *ppszIpAddr = pszIpAddr;

    return 0;
}


DWORD
GetRasmanDeviceType(
    IN PBLINK *pLink,
    OUT LPTSTR pszDeviceType
    )
{
    INT         i;
    DWORD       dwErr;
    DWORD       dwcPorts;
    RASMAN_PORT *pports, *pport;
    PCHAR       pszPort = NULL;

    //
    // Retrieve the rasman device type for the port.
    //
    pszPort = strdupTtoA(pLink->pbport.pszPort);

    if (pszPort == NULL)
    {
        return GetLastError();
    }
    dwErr = GetRasPorts(NULL, &pports, &dwcPorts);

    if (dwErr)
    {
        goto done;
    }

    *pszDeviceType = TEXT('\0');

    for (i = 0,
         pport = pports;
         i < (INT )dwcPorts; ++i, ++pport)
    {
        if (!_stricmp(pport->P_PortName, pszPort))
        {
            strncpyAtoT(
                pszDeviceType,
                pport->P_DeviceType,
                RAS_MaxDeviceType + 1);

            break;
        }
    }
    Free(pports);

    //
    // If we couldn't match the port name,
    // then fallback to the media name.
    //
    if (*pszDeviceType == TEXT('\0'))
    {
        lstrcpyn(
            pszDeviceType,
            pLink->pbport.pszMedia,
            RAS_MaxDeviceType + 1);
    }

done:
    if (pszPort != NULL)
        Free(pszPort);

    return dwErr;
}


VOID
SetDevicePortName(
    IN TCHAR *pszDeviceName,
    IN TCHAR *pszPortName,
    OUT TCHAR *pszDevicePortName
    )
{
    //
    // Encode the port name after the
    // NULL character in the device name,
    // so it looks like:
    //
    //      <device name>\0<port name>\0
    //
    RtlZeroMemory(
        pszDevicePortName,
        (RAS_MaxDeviceName + 1) * sizeof (TCHAR));

    lstrcpyn(pszDevicePortName, pszDeviceName, RAS_MaxDeviceName + 1);

    if (pszPortName != NULL)
    {
        DWORD dwSize = lstrlen(pszDevicePortName) + 1;

        lstrcpyn(
            &pszDevicePortName[dwSize],
            pszPortName,
            (RAS_MaxDeviceName + 1) - dwSize);
    }
}


VOID
GetDevicePortName(
    IN TCHAR *pszDevicePortName,
    OUT TCHAR *pszDeviceName,
    OUT TCHAR *pszPortName
    )
{
    DWORD i, dwStart;

    //
    // Copy the device name.
    //
    lstrcpyn(pszDeviceName, pszDevicePortName, RAS_MaxDeviceName + 1);

    //
    // Check to see if there is a NULL
    // within MAX_PORT_NAME characters
    // after the device name's NULL.If
    // there is, the copy the characters
    // between the NULLs as the port name.
    //
    *pszPortName = TEXT('\0');

    dwStart = lstrlen(pszDeviceName) + 1;

    for (i = 0; i < MAX_PORT_NAME; i++)
    {
        if (pszDevicePortName[dwStart + i] == TEXT('\0'))
        {
            lstrcpyn(
                pszPortName,
                &pszDevicePortName[dwStart],
                MAX_PORT_NAME);

            break;

        }
    }
}


VOID
SetDevicePortNameFromLink(
    IN PBLINK *pLink,
    OUT TCHAR* pszDevicePortName
    )
{
    *pszDevicePortName = TEXT('\0');

    if (pLink->pbport.pszDevice != NULL)
    {
        SetDevicePortName(
            pLink->pbport.pszDevice,
            pLink->pbport.pszPort,
            pszDevicePortName);
    }
}


DWORD
PhonebookEntryToRasEntry(
    IN PBENTRY*     pEntry,
    OUT LPRASENTRY  lpRasEntry,
    IN OUT LPDWORD  lpdwcb,
    OUT LPBYTE      lpbDeviceConfig,
    IN OUT LPDWORD  lpcbDeviceConfig
    )
{
    DWORD       dwErr,
                dwcb,
                dwcbPhoneNumber;

    DWORD       dwnPhoneNumbers,
                dwnAlternatePhoneNumbers = 0;
    DWORD       dwcbOrig,
                dwcbOrigDeviceConfig = 0;

    DTLNODE*    pdtlnode;
    PTCHAR      pszPhoneNumber;
    PBLINK*     pLink;
    PBPHONE*    pPhone;
    DTLNODE*    pDefaultPhone = NULL;


    //
    // Set up to access information for the first link.
    //
    pdtlnode = DtlGetFirstNode(pEntry->pdtllistLinks);

    pLink = (PBLINK *)DtlGetData(pdtlnode);

    //
    // Determine up front if the buffer
    // is large enough.
    //
    dwcb = sizeof (RASENTRY);

    if(pLink->pdtllistPhones)
    {
        dwnPhoneNumbers = DtlGetNodes(pLink->pdtllistPhones);
    }
    else
    {
        dwnPhoneNumbers = 0;
    }

    if (dwnPhoneNumbers > 1)
    {
        dwnAlternatePhoneNumbers = dwnPhoneNumbers - 1;

        pdtlnode = DtlGetFirstNode(pLink->pdtllistPhones);

        for (pdtlnode = DtlGetNextNode(pdtlnode);
             pdtlnode != NULL;
             pdtlnode = DtlGetNextNode(pdtlnode))
        {
            TCHAR *pszNum = DtlGetData(pdtlnode);

            pPhone = DtlGetData(pdtlnode);

            pszNum = pPhone->pszPhoneNumber;

            ASSERT(pszNum);

            dwcb += (lstrlen(pszNum) + 1) * sizeof (TCHAR);
        }

        dwcb += sizeof (TCHAR);
    }

    //
    // Set the return buffer size.
    //
    dwcbOrig = *lpdwcb;

    *lpdwcb = dwcb;

    if (lpcbDeviceConfig != NULL)
    {
        dwcbOrigDeviceConfig = *lpcbDeviceConfig;

        *lpcbDeviceConfig = pLink->cbTapiBlob;
    }

    //
    // Return if the buffer is NULL or if
    // there is not enough room.
    //
    if (    lpRasEntry == NULL
        ||  dwcbOrig < dwcb
        ||  (   lpbDeviceConfig != NULL
            &&  dwcbOrigDeviceConfig < pLink->cbTapiBlob))
    {
        return ERROR_BUFFER_TOO_SMALL;
    }

    //
    // Get the first phonenumber from the first link.
    // This will be the primary phonenumber we use -
    // note that direct connect entries may not have
    // this number
    //
    if(     NULL != pLink->pdtllistPhones
        &&  NULL != DtlGetFirstNode(pLink->pdtllistPhones))
    {
        pPhone = (PBPHONE *)
                 DtlGetData(DtlGetFirstNode(pLink->pdtllistPhones));

        ASSERT(NULL != pPhone);
    }
    else
    {
        pPhone = NULL;
    }

    //
    // Set dwfOptions.
    //
    lpRasEntry->dwfOptions = 0;

    if (    pPhone
        &&  pPhone->fUseDialingRules)
    {
        lpRasEntry->dwfOptions |= RASEO_UseCountryAndAreaCodes;
    }

    if (pEntry->dwIpAddressSource == ASRC_RequireSpecific)
    {
        lpRasEntry->dwfOptions |= RASEO_SpecificIpAddr;
    }

    if (pEntry->dwIpNameSource == ASRC_RequireSpecific)
    {
        lpRasEntry->dwfOptions |= RASEO_SpecificNameServers;
    }

    if (pEntry->fIpHeaderCompression)
    {
        lpRasEntry->dwfOptions |= RASEO_IpHeaderCompression;
    }

    if (!pEntry->fLcpExtensions)
    {
        lpRasEntry->dwfOptions |= RASEO_DisableLcpExtensions;
    }

    if (pLink->pbport.fScriptBeforeTerminal)
    {
        lpRasEntry->dwfOptions |= RASEO_TerminalBeforeDial;
    }

    if (pEntry->fScriptAfterTerminal)
    {
        lpRasEntry->dwfOptions |= RASEO_TerminalAfterDial;
    }

    if (pEntry->fShowMonitorIconInTaskBar)
    {
        lpRasEntry->dwfOptions |= RASEO_ModemLights;
    }
    if (pEntry->fSwCompression)
    {
        lpRasEntry->dwfOptions |= RASEO_SwCompression;
    }

    if (    !(pEntry->dwAuthRestrictions & AR_F_AuthPAP)
        &&  !(pEntry->dwAuthRestrictions & AR_F_AuthEAP))
    {
        lpRasEntry->dwfOptions |= RASEO_RequireEncryptedPw;
    }

    // (SteveC) Changed from '&' to '==' to avoid setting the RASEO bit when
    // AR_F_AuthMSCHAP and other bits are set, which is the RequireEncryptedPw
    // rather than the RequireMsEncryptedPw condition.
    //
    if (pEntry->dwAuthRestrictions == AR_F_AuthMSCHAP)
    {
        lpRasEntry->dwfOptions |= RASEO_RequireMsEncryptedPw;
    }

    if (    pEntry->dwDataEncryption != DE_None
        &&  pEntry->dwDataEncryption != DE_IfPossible)
    {
        lpRasEntry->dwfOptions |= RASEO_RequireDataEncryption;
    }

    //
    // RASEO_NetworkLogon is always FALSE
    //
    if (pEntry->fAutoLogon)
    {
        lpRasEntry->dwfOptions |= RASEO_UseLogonCredentials;
    }

    if (pLink->fPromoteAlternates)
    {
        lpRasEntry->dwfOptions |= RASEO_PromoteAlternates;
    }

    if(     !pEntry->fShareMsFilePrint
        ||  !pEntry->fBindMsNetClient)
    {
        lpRasEntry->dwfOptions |= RASEO_SecureLocalFiles;
    }

    if(NULL == pPhone)
    {
        //
        // Get Default phone values
        //
        pDefaultPhone = CreatePhoneNode();

        if(NULL == pDefaultPhone)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        pPhone = DtlGetData(pDefaultPhone);

    }

    ASSERT(NULL != pPhone);

    lpRasEntry->dwCountryID = pPhone->dwCountryID;
    lpRasEntry->dwCountryCode = pPhone->dwCountryCode;

    if(pPhone->pszAreaCode != NULL)
    {
        lstrcpyn(
            lpRasEntry->szAreaCode,
            pPhone->pszAreaCode,
            RAS_MaxAreaCode + 1);
    }
    else
    {
        *lpRasEntry->szAreaCode = TEXT('\0');
    }

    if(NULL != pDefaultPhone)
    {
        DestroyPhoneNode(pDefaultPhone);

        pPhone = NULL;
    }

    //
    // Set IP addresses.
    //
    if (lpRasEntry->dwfOptions & RASEO_SpecificIpAddr)
    {
        dwErr = StringToIpAddr(
                    pEntry->pszIpAddress,
                    &lpRasEntry->ipaddr);

        if (dwErr)
        {
            return dwErr;
        }
    }
    else
    {
        RtlZeroMemory(&lpRasEntry->ipaddr, sizeof (RASIPADDR));
    }

    if (lpRasEntry->dwfOptions & RASEO_SpecificNameServers)
    {
        dwErr = StringToIpAddr(
                  pEntry->pszIpDnsAddress,
                  &lpRasEntry->ipaddrDns);

        if (dwErr)
        {
            return dwErr;
        }

        dwErr = StringToIpAddr(
                  pEntry->pszIpDns2Address,
                  &lpRasEntry->ipaddrDnsAlt);

        if (dwErr)
        {
            return dwErr;
        }

        dwErr = StringToIpAddr(
                  pEntry->pszIpWinsAddress,
                  &lpRasEntry->ipaddrWins);

        if (dwErr)
        {
            return dwErr;
        }

        dwErr = StringToIpAddr(
                  pEntry->pszIpWins2Address,
                  &lpRasEntry->ipaddrWinsAlt);

        if (dwErr)
        {
            return dwErr;
        }
    }
    else
    {
        RtlZeroMemory(&lpRasEntry->ipaddrDns, sizeof (RASIPADDR));

        RtlZeroMemory(&lpRasEntry->ipaddrDnsAlt, sizeof (RASIPADDR));

        RtlZeroMemory(&lpRasEntry->ipaddrWins, sizeof (RASIPADDR));

        RtlZeroMemory(&lpRasEntry->ipaddrWinsAlt, sizeof (RASIPADDR));
    }

    //
    // Set protocol and framing information.
    //
    switch (pEntry->dwBaseProtocol)
    {
    case BP_Ras:
        lpRasEntry->dwFramingProtocol   = RASFP_Ras;
        lpRasEntry->dwFrameSize         = 0;
        lpRasEntry->dwfNetProtocols     = 0;
        break;

    case BP_Ppp:
        lpRasEntry->dwFramingProtocol = RASFP_Ppp;

        lpRasEntry->dwFrameSize = 0;

        lpRasEntry->dwfNetProtocols = 0;

        if (!(pEntry->dwfExcludedProtocols & NP_Nbf))
        {
            lpRasEntry->dwfNetProtocols |= RASNP_NetBEUI;
        }

        if (!(pEntry->dwfExcludedProtocols & NP_Ipx))
        {
            lpRasEntry->dwfNetProtocols |= RASNP_Ipx;
        }

        if (!(pEntry->dwfExcludedProtocols & NP_Ip))
        {
            lpRasEntry->dwfNetProtocols |= RASNP_Ip;
        }

        if (pEntry->fIpPrioritizeRemote)
        {
            lpRasEntry->dwfOptions |= RASEO_RemoteDefaultGateway;
        }

        //
        // Check for no protocols configured.  In this case,
        // set AMB framing.
        //
        if (!lpRasEntry->dwfNetProtocols)
        {
            lpRasEntry->dwFramingProtocol = RASFP_Ras;
        }

        break;

    case BP_Slip:
        lpRasEntry->dwFramingProtocol   = RASFP_Slip;
        lpRasEntry->dwFrameSize         = pEntry->dwFrameSize;
        lpRasEntry->dwfNetProtocols     = RASNP_Ip;

        if (pEntry->fIpPrioritizeRemote)
        {
            lpRasEntry->dwfOptions |= RASEO_RemoteDefaultGateway;
        }

        break;
    }

    //
    // Make sure only installed protocols get reported.
    //
    lpRasEntry->dwfNetProtocols &= GetInstalledProtocolsEx(
                                                NULL,
                                                FALSE,
                                                TRUE,
                                                FALSE);

    //
    // Set X.25 information.
    //
    *lpRasEntry->szScript = '\0';

    if (pEntry->fScriptAfterTerminal)
    {
        lpRasEntry->dwfOptions |= RASEO_TerminalAfterDial;
    }

    if (pEntry->fScriptAfter)
    {
        DWORD i, cdwDevices;
        RASMAN_DEVICE *pDevices;
        CHAR szScriptA[MAX_PATH];

        strncpyTtoA(szScriptA, pEntry->pszScriptAfter, sizeof(szScriptA));

        //
        // Get the list of switches to see if it is an
        // old-style script or a new style script.
        //
        dwErr = GetRasSwitches(NULL, &pDevices, &cdwDevices);
        if (dwErr)
        {
            return dwErr;
        }

        for (i = 0; i < cdwDevices; i++)
        {
            if (!_stricmp(pDevices[i].D_Name, szScriptA))
            {
                _snwprintf(
                    lpRasEntry->szScript,
                    sizeof(lpRasEntry->szScript) / sizeof(WCHAR),
                    TEXT("[%s"),
                    pEntry->pszScriptAfter);

                break;
            }
        }

        Free(pDevices);

        //
        // If we didn't find an old-style script match,
        // then it's a new-sytle script.
        //
        if (*lpRasEntry->szScript == TEXT('\0'))
        {
            _snwprintf(
                lpRasEntry->szScript,
                sizeof(lpRasEntry->szScript) / sizeof(WCHAR),
                TEXT("%s"),
                pEntry->pszScriptAfter);
        }
    }

    if (pEntry->pszX25Network != NULL)
    {
        lstrcpyn(
            lpRasEntry->szX25PadType,
            pEntry->pszX25Network,
            sizeof(lpRasEntry->szX25PadType) / sizeof(WCHAR));
    }
    else
    {
        *lpRasEntry->szX25PadType = TEXT('\0');
    }

    if (pEntry->pszX25Address != NULL)
    {
        lstrcpyn(
            lpRasEntry->szX25Address,
            pEntry->pszX25Address,
            sizeof(lpRasEntry->szX25Address) / sizeof(WCHAR));
    }
    else
    {
        *lpRasEntry->szX25Address = TEXT('\0');
    }

    if (pEntry->pszX25Facilities != NULL)
    {
        lstrcpyn(
            lpRasEntry->szX25Facilities,
            pEntry->pszX25Facilities,
            sizeof(lpRasEntry->szX25Facilities) / sizeof(WCHAR));
    }
    else
    {
        *lpRasEntry->szX25Facilities = TEXT('\0');
    }

    if (pEntry->pszX25UserData != NULL)
    {
        lstrcpyn(
            lpRasEntry->szX25UserData,
            pEntry->pszX25UserData,
            sizeof(lpRasEntry->szX25UserData) / sizeof(WCHAR));
    }
    else
    {
        *lpRasEntry->szX25UserData = TEXT('\0');
    }

    //
    // Set custom dial UI information.
    //
    if (    pEntry->pszCustomDialDll != NULL
        &&  pEntry->pszCustomDialFunc != NULL)
    {
        lstrcpyn(
          lpRasEntry->szAutodialDll,
          pEntry->pszCustomDialDll,
          sizeof (lpRasEntry->szAutodialDll) / sizeof (TCHAR));

        lstrcpyn(
          lpRasEntry->szAutodialFunc,
          pEntry->pszCustomDialFunc,
          sizeof (lpRasEntry->szAutodialFunc) / sizeof (TCHAR));
    }
    else
    {
        *lpRasEntry->szAutodialDll = TEXT('\0');
        *lpRasEntry->szAutodialFunc = TEXT('\0');
    }

    //
    // Set area code and primary phone number.
    //
    if (    pPhone
        &&  pPhone->pszAreaCode != NULL)
    {
        lstrcpyn(
          lpRasEntry->szAreaCode,
          pPhone->pszAreaCode,
          sizeof (lpRasEntry->szAreaCode) / sizeof (TCHAR));
    }
    else
    {
        *lpRasEntry->szAreaCode = TEXT('\0');
    }

    if(NULL != pLink->pdtllistPhones)
    {
        pdtlnode = DtlGetFirstNode(pLink->pdtllistPhones);
    }
    else
    {
        pdtlnode = NULL;
    }

    if (pdtlnode != NULL)
    {
        PBPHONE *pPhonePrimary = (PBPHONE *) DtlGetData(pdtlnode);
        TCHAR *pszNum;

        ASSERT(pPhonePrimary);

        pszNum = pPhonePrimary->pszPhoneNumber;

        ASSERT(pszNum);

        lstrcpyn(
          lpRasEntry->szLocalPhoneNumber,
          pszNum,
          sizeof (lpRasEntry->szLocalPhoneNumber)
                    / sizeof (TCHAR));
    }
    else
    {
        *lpRasEntry->szLocalPhoneNumber = TEXT('\0');
    }

    //
    // Copy the alternate phone numbers past the
    // end of the structure.
    //
    if (dwnAlternatePhoneNumbers)
    {
        PTCHAR pEnd = (PTCHAR)((ULONG_PTR)lpRasEntry
                                + sizeof (RASENTRY));

        lpRasEntry->dwAlternateOffset =
                     (DWORD)((ULONG_PTR) pEnd - (ULONG_PTR) lpRasEntry);

        for (pdtlnode = DtlGetNextNode(pdtlnode);
             pdtlnode != NULL;
             pdtlnode = DtlGetNextNode(pdtlnode))
        {
            PBPHONE *pPhoneSecondary = DtlGetData(pdtlnode);

            TCHAR *pszNum;

            ASSERT(pPhoneSecondary);

            pszNum = pPhoneSecondary->pszPhoneNumber;

            ASSERT(pszNum);

            pszPhoneNumber = StrDup(pszNum);

            if(NULL == pszPhoneNumber)
            {
                return ERROR_NOT_ENOUGH_MEMORY;
            }

            ASSERT(pszPhoneNumber);

            dwcbPhoneNumber = lstrlen(pszPhoneNumber);

            lstrcpyn(
                pEnd,
                pszPhoneNumber,
                (INT )(((PTCHAR )lpRasEntry + dwcbOrig) - pEnd));

            Free(pszPhoneNumber);

            pEnd += dwcbPhoneNumber + 1;
        }

        //
        // Add an extra NULL character to
        // terminate the list.
        //
        *pEnd = TEXT('\0');
    }
    else
    {
        lpRasEntry->dwAlternateOffset = 0;
    }

    //
    // Set device information.
    //
    switch (pLink->pbport.pbdevicetype)
    {
    case PBDT_Isdn:
        lstrcpy(lpRasEntry->szDeviceType, RASDT_Isdn);
        break;

    case PBDT_X25:
        lstrcpy(lpRasEntry->szDeviceType, RASDT_X25);
        break;

    case PBDT_Other:
    case PBDT_Irda:
    case PBDT_Vpn:
    case PBDT_Serial:
    case PBDT_Atm:
    case PBDT_Parallel:
    case PBDT_Sonet:
    case PBDT_Sw56:
    case PBDT_FrameRelay:
    case PBDT_PPPoE:
    {
        dwErr = GetRasmanDeviceType(
                    pLink,
                    lpRasEntry->szDeviceType);
        if (dwErr)
        {
            return dwErr;
        }

        //
        // Convert the device type to lower case
        // to be consistent with the predefined
        // types.
        //
        _tcslwr(lpRasEntry->szDeviceType);
        break;
    }

    default:
        lstrcpy(
            lpRasEntry->szDeviceType,
            RASDT_Modem);
        break;
    }

    SetDevicePortNameFromLink(pLink, lpRasEntry->szDeviceName);

    //
    // Set the TAPI configuration blob.
    //
    if (    lpbDeviceConfig != NULL
        &&  dwcbOrigDeviceConfig <= pLink->cbTapiBlob)
    {
        memcpy(
            lpbDeviceConfig,
            pLink->pTapiBlob,
            pLink->cbTapiBlob);
    }

    //
    // Copy the following fields over only
    // for a V401 structure or greater
    //
    if (    lpRasEntry->dwSize == sizeof (RASENTRY)
        ||  lpRasEntry->dwSize == sizeof (RASENTRYW_V500)
        ||  lpRasEntry->dwSize == sizeof (RASENTRYW_V401))
    {
        //
        // Set multilink information.
        //
        lpRasEntry->dwSubEntries =
                    DtlGetNodes(pEntry->pdtllistLinks);

        lpRasEntry->dwDialMode = pEntry->dwDialMode;

        lpRasEntry->dwDialExtraPercent =
                                    pEntry->dwDialPercent;

        lpRasEntry->dwDialExtraSampleSeconds =
                                    pEntry->dwDialSeconds;

        lpRasEntry->dwHangUpExtraPercent =
                                pEntry->dwHangUpPercent;

        lpRasEntry->dwHangUpExtraSampleSeconds =
                                pEntry->dwHangUpSeconds;

        //
        // Set idle timeout information.
        //
        lpRasEntry->dwIdleDisconnectSeconds =
                        pEntry->lIdleDisconnectSeconds;
                        
        if(1 == pEntry->dwCustomScript)
        {
            lpRasEntry->dwfOptions |= RASEO_CustomScript;
        }
    }

    //
    // Set the entry guid, EntryType
    // and encryptiontype if this is
    // nt5
    //
    if (    (sizeof (RASENTRY) == lpRasEntry->dwSize)
        ||  (sizeof (RASENTRYW_V500) == lpRasEntry->dwSize))
    {
        if (pEntry->pGuid)
        {
            lpRasEntry->guidId = *pEntry->pGuid;
        }

        lpRasEntry->dwType = pEntry->dwType;

        //
        // Encryption type
        //
        if (pEntry->dwDataEncryption != DE_None)
        {
            if(DE_Require == pEntry->dwDataEncryption)
            {
                lpRasEntry->dwEncryptionType = ET_Require;
            }
            else if(DE_RequireMax == pEntry->dwDataEncryption)
            {
                lpRasEntry->dwEncryptionType = ET_RequireMax;
            }
            else if(DE_IfPossible == pEntry->dwDataEncryption)
            {
                lpRasEntry->dwEncryptionType = ET_Optional;
            }
        }
        else
        {
            lpRasEntry->dwEncryptionType = ET_None;
        }

        /*
        //
        // Clear the authentication bits set if this is nt5.
        // we will set the new bits here
        //
        lpRasEntry->dwfOptions &= ~(RASEO_RequireMsEncryptedPw
                                  | RASEO_RequireEncryptedPw);

        */

        //
        // Set the authentication bits for nt5
        //
        if (pEntry->dwAuthRestrictions & AR_F_AuthMSCHAP)
        {
            lpRasEntry->dwfOptions |= RASEO_RequireMsCHAP;
        }

        if(pEntry->dwAuthRestrictions & AR_F_AuthMSCHAP2)
        {
            lpRasEntry->dwfOptions |= RASEO_RequireMsCHAP2;
        }

        if(pEntry->dwAuthRestrictions & AR_F_AuthW95MSCHAP)
        {
            lpRasEntry->dwfOptions |= RASEO_RequireW95MSCHAP;
        }

        if (pEntry->dwAuthRestrictions & AR_F_AuthPAP)
        {
            lpRasEntry->dwfOptions |= RASEO_RequirePAP;
        }

        if (pEntry->dwAuthRestrictions & AR_F_AuthMD5CHAP)
        {
            lpRasEntry->dwfOptions |= RASEO_RequireCHAP;
        }

        if (pEntry->dwAuthRestrictions & AR_F_AuthSPAP)
        {
            lpRasEntry->dwfOptions |= RASEO_RequireSPAP;
        }

        if (pEntry->dwAuthRestrictions & AR_F_AuthEAP)
        {
            lpRasEntry->dwfOptions |= RASEO_RequireEAP;

            if(     (0 != pEntry->dwCustomAuthKey)
                &&  (-1 != pEntry->dwCustomAuthKey))
            {
                lpRasEntry->dwCustomAuthKey =
                    pEntry->dwCustomAuthKey;
            }
        }

        if(pEntry->dwAuthRestrictions & AR_F_AuthCustom)
        {
            lpRasEntry->dwfOptions |= RASEO_Custom;
        }

        //
        // Set custom dial dll information.
        //
        if (NULL != pEntry->pszCustomDialerName)
        {
            lstrcpyn(
              lpRasEntry->szCustomDialDll,
              pEntry->pszCustomDialerName,
              sizeof ( lpRasEntry->szCustomDialDll)
                     / sizeof (TCHAR));

        }
        else
        {
            *lpRasEntry->szCustomDialDll = TEXT('\0');
        }

        //
        // Set the PreviewPhoneNumbers/SharedPhonenumbers
        //
        if(pEntry->fPreviewPhoneNumber)
        {
            lpRasEntry->dwfOptions |= RASEO_PreviewPhoneNumber;
        }

        if(pEntry->fSharedPhoneNumbers)
        {
            lpRasEntry->dwfOptions |= RASEO_SharedPhoneNumbers;
        }

        if(pEntry->fPreviewUserPw)
        {
            lpRasEntry->dwfOptions |= RASEO_PreviewUserPw;
        }

        if(pEntry->fPreviewDomain)
        {
            lpRasEntry->dwfOptions |= RASEO_PreviewDomain;
        }

        if(pEntry->fShowDialingProgress)
        {
            lpRasEntry->dwfOptions |= RASEO_ShowDialingProgress;
        }

        //
        // Copy the vpn strategy
        //
        lpRasEntry->dwVpnStrategy = pEntry->dwVpnStrategy;
    }

    if(lpRasEntry->dwSize == sizeof(RASENTRYW))
    {
        lpRasEntry->dwfOptions2 = 0;
        
        //
        // Set the FileAndPrint and ClientForMSNet bits
        //
        if(!pEntry->fShareMsFilePrint)
        {
            lpRasEntry->dwfOptions2 |= RASEO2_SecureFileAndPrint;
        }

        if(!pEntry->fBindMsNetClient)
        {
            lpRasEntry->dwfOptions2 |= RASEO2_SecureClientForMSNet;
        }

        if(!pEntry->fNegotiateMultilinkAlways)
        {
            lpRasEntry->dwfOptions2 |= RASEO2_DontNegotiateMultilink;
        }

        if(!pEntry->fUseRasCredentials)
        {
            lpRasEntry->dwfOptions2 |= RASEO2_DontUseRasCredentials;
        }

        if(pEntry->dwIpSecFlags & AR_F_IpSecPSK)
        {
            lpRasEntry->dwfOptions2  |= RASEO2_UsePreSharedKey;
        }

        if (! (pEntry->dwIpNbtFlags & PBK_ENTRY_IP_NBT_Enable))
        {
            lpRasEntry->dwfOptions2 |= RASEO2_DisableNbtOverIP;
        }

        if (pEntry->dwUseFlags & PBK_ENTRY_USE_F_Internet)
        {
            lpRasEntry->dwfOptions2 |= RASEO2_Internet;
        }

        // Whislter bug 281306
        //
        if (pEntry->fGlobalDeviceSettings)
        {
            lpRasEntry->dwfOptions2 |= RASEO2_UseGlobalDeviceSettings;
        }

        if(pEntry->pszIpDnsSuffix)
        {
            lstrcpyn(lpRasEntry->szDnsSuffix,
                     pEntry->pszIpDnsSuffix,
                     RAS_MaxDnsSuffix);
        }
        else
        {
            lpRasEntry->szDnsSuffix[0] = TEXT('\0');
        }

        if ((pEntry->pszPrerequisiteEntry) && (pEntry->dwType == RASET_Vpn))
        {
            lstrcpyn(lpRasEntry->szPrerequisiteEntry,
                     pEntry->pszPrerequisiteEntry,
                     RAS_MaxEntryName);
        }
        else
        {
            lpRasEntry->szPrerequisiteEntry[0] = TEXT('\0');
        }

        if((pEntry->pszPrerequisitePbk) && (pEntry->dwType == RASET_Vpn))
        {
            lstrcpyn(lpRasEntry->szPrerequisitePbk,
                     pEntry->pszPrerequisitePbk,
                     MAX_PATH);
        }
        else
        {
            lpRasEntry->szPrerequisitePbk[0] = TEXT('\0');
        }

        // Whistler bug 300933
        //
        lpRasEntry->dwTcpWindowSize = pEntry->dwTcpWindowSize;

        // XP 351608
        //
        lpRasEntry->dwRedialCount = pEntry->dwRedialAttempts;
        lpRasEntry->dwRedialPause = pEntry->dwRedialSeconds;

        // XP 370815
        // 
        if (pEntry->fRedialOnLinkFailure)
        {
            lpRasEntry->dwfOptions2 |= RASEO2_ReconnectIfDropped;
        }
        
        // XP 403967
        //
        if (pEntry->fSharedPhoneNumbers)
        {
            lpRasEntry->dwfOptions2 |= RASEO2_SharePhoneNumbers;
        }
        
    }

    return 0;
}

DWORD
CreateAndInitializePhone(
            LPTSTR      lpszAreaCode,
            DWORD       dwCountryCode,
            DWORD       dwCountryID,
            LPTSTR      lpszPhoneNumber,
            BOOL        fUseDialingRules,
            LPTSTR      lpszComment,
            DTLNODE**   ppdtlnode)
{
    DWORD    dwRetCode = ERROR_SUCCESS;
    PBPHONE* pPhone;
    DTLNODE* pdtlnode;

    pdtlnode = CreatePhoneNode();
    if (pdtlnode == NULL)
    {
        dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
        goto done;
    }

    pPhone = (PBPHONE *) DtlGetData(pdtlnode);

    if(lpszAreaCode)
    {
        pPhone->pszAreaCode = StrDup(lpszAreaCode);
        if(NULL == pPhone->pszAreaCode)
        {
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            goto done;
        }
    }
    else
    {
        pPhone->pszAreaCode = NULL;
    }

    pPhone->dwCountryCode   = dwCountryCode;
    pPhone->dwCountryID     = dwCountryID;

    pPhone->fUseDialingRules = fUseDialingRules;

    if(lpszPhoneNumber)
    {
        pPhone->pszPhoneNumber  = StrDup(lpszPhoneNumber);
        if(NULL == pPhone->pszPhoneNumber)
        {
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            goto done;
        }
    }
    else
    {
        pPhone->pszPhoneNumber = NULL;
    }

    if(pPhone->pszComment)
    {
        pPhone->pszComment = StrDup(lpszComment);
        if(NULL == pPhone->pszComment)
        {
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            goto done;
        }
    }
    else
    {
        pPhone->pszComment = NULL;
    }

    *ppdtlnode = pdtlnode;

done:
    return dwRetCode;
}

void
SetBogusPortInformation(PBLINK *pLink, DWORD dwType)
{
    PBPORT *pPort = &pLink->pbport;
    
    if (dwType == RASET_Phone)
    {
        pPort->pszMedia = StrDup( TEXT(SERIAL_TXT) );
        pPort->pbdevicetype = PBDT_Modem;

        pPort->dwFlags |= PBP_F_BogusDevice;
    }
    else if (dwType == RASET_Vpn)
    {
        pPort->pszMedia = StrDup( TEXT("rastapi") );
        pPort->pbdevicetype = PBDT_Vpn;
    }
    else
    {
        pPort->pszMedia = StrDup( TEXT(SERIAL_TXT) );
        pPort->pbdevicetype = PBDT_Null;

        pPort->dwFlags |= PBP_F_BogusDevice;
    }
}

DWORD
RasEntryToPhonebookEntry(
    IN LPCTSTR      lpszEntry,
    IN LPRASENTRY   lpRasEntry,
    IN DWORD        dwcb,
    IN LPBYTE       lpbDeviceConfig,
    IN DWORD        dwcbDeviceConfig,
    OUT PBENTRY     *pEntry
    )
{
    DWORD           dwErr, dwcbStr;
    DTLNODE         *pdtlnode;
    PBDEVICETYPE    pbdevicetype;
    PBLINK          *pLink;
    DTLLIST         *pdtllistPorts;
    PBPORT          *pPort;
    DWORD           i, cwDevices;
    RASMAN_DEVICE   *pDevices;
    TCHAR           szDeviceName[RAS_MaxDeviceName + 1];
    TCHAR           szPortName[MAX_PORT_NAME];
    DTLNODE         *pNodePhone;
    LPTSTR          pszAreaCode;
    PBPHONE         *pPhone;
    BOOL            fScriptBefore;
    BOOL            fScriptBeforeTerminal = FALSE;
    LPTSTR          pszScriptBefore;
    BOOL            fNewEntry = FALSE;

    //
    // Set up to access information for the first link.
    //
    pdtlnode = DtlGetFirstNode(pEntry->pdtllistLinks);

    pLink = (PBLINK *)DtlGetData(pdtlnode);

    ASSERT(NULL != pLink);

    fScriptBefore = pLink->pbport.fScriptBeforeTerminal;
    pszScriptBefore = pLink->pbport.pszScriptBefore;

    if(NULL == pEntry->pszEntryName)
    {
        fNewEntry = TRUE;
    }
    
    //
    // Get entry name.
    //
    Free0( pEntry->pszEntryName );

    pEntry->pszEntryName = StrDup(lpszEntry);

    //
    // Get dwfOptions.
    //
    pEntry->dwIpAddressSource =
      lpRasEntry->dwfOptions & RASEO_SpecificIpAddr ?
        ASRC_RequireSpecific : ASRC_ServerAssigned;

    pEntry->dwIpNameSource =
      lpRasEntry->dwfOptions & RASEO_SpecificNameServers ?
        ASRC_RequireSpecific : ASRC_ServerAssigned;

    switch (lpRasEntry->dwFramingProtocol)
    {
    case RASFP_Ppp:

        //
        // Get PPP-based information.
        //
        pEntry->dwBaseProtocol = BP_Ppp;

#if AMB
        pEntry->dwAuthentication = AS_PppThenAmb;
#endif

        pEntry->fIpHeaderCompression =
          (BOOL)lpRasEntry->dwfOptions & RASEO_IpHeaderCompression;

        pEntry->fIpPrioritizeRemote =
          (BOOL)lpRasEntry->dwfOptions & RASEO_RemoteDefaultGateway;

        //
        // Get specified IP addresses.
        //
        if (pEntry->dwIpAddressSource == ASRC_RequireSpecific)
        {
            Clear0(pEntry->pszIpAddress);
            dwErr = IpAddrToString(
                                &lpRasEntry->ipaddr,
                                &pEntry->pszIpAddress);
            if (dwErr)
                return dwErr;
        }
        else
        {
            pEntry->pszIpAddress = NULL;
        }

        if (pEntry->dwIpNameSource == ASRC_RequireSpecific)
        {
            Clear0(pEntry->pszIpDnsAddress);
            dwErr = IpAddrToString(
                        &lpRasEntry->ipaddrDns,
                        &pEntry->pszIpDnsAddress);

            if (dwErr)
            {
                return dwErr;
            }

            Clear0(pEntry->pszIpDns2Address);
            dwErr = IpAddrToString(
                        &lpRasEntry->ipaddrDnsAlt,
                        &pEntry->pszIpDns2Address);

            if (dwErr)
            {
                return dwErr;
            }

            Clear0(pEntry->pszIpWinsAddress);
            dwErr = IpAddrToString(
                        &lpRasEntry->ipaddrWins,
                        &pEntry->pszIpWinsAddress);

            if (dwErr)
            {
                return dwErr;
            }

            Clear0(pEntry->pszIpWins2Address);
            dwErr = IpAddrToString(
                        &lpRasEntry->ipaddrWinsAlt,
                        &pEntry->pszIpWins2Address);
            if (dwErr)
            {
                return dwErr;
            }
        }
        else
        {
            pEntry->pszIpDnsAddress     = NULL;
            pEntry->pszIpDns2Address    = NULL;
            pEntry->pszIpWinsAddress    = NULL;
            pEntry->pszIpWins2Address   = NULL;
        }

        //
        // Get protocol information.
        //
        pEntry->dwfExcludedProtocols = 0;

        if (!(lpRasEntry->dwfNetProtocols & RASNP_NetBEUI))
        {
            pEntry->dwfExcludedProtocols |= NP_Nbf;
        }

        if (!(lpRasEntry->dwfNetProtocols & RASNP_Ipx))
        {
            pEntry->dwfExcludedProtocols |= NP_Ipx;
        }

        if (!(lpRasEntry->dwfNetProtocols & RASNP_Ip))
        {
            pEntry->dwfExcludedProtocols |= NP_Ip;
        }

        break;

    case RASFP_Slip:

        //
        // Get SLIP-based information.
        //
        pEntry->dwBaseProtocol   = BP_Slip;
#if AMB
        pEntry->dwAuthentication = AS_PppThenAmb;
#endif

        pEntry->dwFrameSize      = lpRasEntry->dwFrameSize;

        pEntry->fIpHeaderCompression =
          (BOOL)lpRasEntry->dwfOptions & RASEO_IpHeaderCompression;

        pEntry->fIpPrioritizeRemote =
          (BOOL)lpRasEntry->dwfOptions & RASEO_RemoteDefaultGateway;

        //
        // Get protocol information.
        //
        pEntry->dwfExcludedProtocols = (NP_Nbf|NP_Ipx);

        if (pEntry->dwIpAddressSource == ASRC_RequireSpecific)
        {
            Clear0(pEntry->pszIpAddress);
            dwErr = IpAddrToString(
                        &lpRasEntry->ipaddr,
                        &pEntry->pszIpAddress);

            if (dwErr)
            {
                return dwErr;
            }
        }
        else
        {
            pEntry->pszIpAddress = NULL;
        }
        if (pEntry->dwIpNameSource == ASRC_RequireSpecific)
        {
            Clear0(pEntry->pszIpDnsAddress);
            dwErr = IpAddrToString(
                        &lpRasEntry->ipaddrDns,
                        &pEntry->pszIpDnsAddress);

            if (dwErr)
            {
                return dwErr;
            }

            Clear0(pEntry->pszIpDns2Address);
            dwErr = IpAddrToString(
                            &lpRasEntry->ipaddrDnsAlt,
                            &pEntry->pszIpDns2Address);

            if (dwErr)
            {
                return dwErr;
            }

            Clear0(pEntry->pszIpWinsAddress);
            dwErr = IpAddrToString(
                        &lpRasEntry->ipaddrWins,
                        &pEntry->pszIpWinsAddress);

            if (dwErr)
            {
                return dwErr;
            }

            Clear0(pEntry->pszIpWins2Address);
            dwErr = IpAddrToString(
                        &lpRasEntry->ipaddrWinsAlt,
                        &pEntry->pszIpWins2Address);

            if (dwErr)
            {
                return dwErr;
            }
        }
        else
        {
            pEntry->pszIpDnsAddress   = NULL;
            pEntry->pszIpDns2Address  = NULL;
            pEntry->pszIpWinsAddress  = NULL;
            pEntry->pszIpWins2Address = NULL;
        }
        break;
    case RASFP_Ras:

        //
        // Get AMB-based information.
        //
        pEntry->dwBaseProtocol   = BP_Ras;
#if AMB
        pEntry->dwAuthentication = AS_AmbOnly;
#endif

        break;
    }

    pEntry->fLcpExtensions =
      (BOOL)!(lpRasEntry->dwfOptions & RASEO_DisableLcpExtensions);

    //
    // If terminal before/after dial options are set,
    // then update the entry.  Otherwise, leave it as it
    // is.
    //
    if(lpRasEntry->dwfOptions & RASEO_TerminalBeforeDial)
    {
        fScriptBeforeTerminal = TRUE;
    }

    if(lpRasEntry->dwfOptions & RASEO_TerminalAfterDial)
    {
        pEntry->fScriptAfterTerminal = TRUE;
    }
    else
    {
        pEntry->fScriptAfterTerminal = FALSE;
    }


    pEntry->fShowMonitorIconInTaskBar =
        (BOOL) (lpRasEntry->dwfOptions & RASEO_ModemLights);

    pEntry->fSwCompression =
      (BOOL)(lpRasEntry->dwfOptions & RASEO_SwCompression);

    if (lpRasEntry->dwfOptions & RASEO_RequireMsEncryptedPw)
    {
        pEntry->dwAuthRestrictions = AR_F_AuthMSCHAP;
    }
    else if (lpRasEntry->dwfOptions & RASEO_RequireEncryptedPw)
    {
        pEntry->dwAuthRestrictions =    AR_F_AuthSPAP
                                    |   AR_F_AuthMD5CHAP
                                    |   AR_F_AuthMSCHAP;
    }
    else
    {
        pEntry->dwAuthRestrictions = AR_F_TypicalUnsecure;
    }

    pEntry->dwDataEncryption =
        (lpRasEntry->dwfOptions & RASEO_RequireDataEncryption)
      ? DE_Mppe40bit
      : DE_None;

    pEntry->fAutoLogon =
      (BOOL)(lpRasEntry->dwfOptions & RASEO_UseLogonCredentials);

    pLink->fPromoteAlternates =
      (BOOL)(lpRasEntry->dwfOptions & RASEO_PromoteAlternates);

    pEntry->fShareMsFilePrint = pEntry->fBindMsNetClient =
      (BOOL) !(lpRasEntry->dwfOptions & RASEO_SecureLocalFiles);

    //
    // Make sure that the network components section in the
    // phonebook correspond to the values user is setting.
    //
    EnableOrDisableNetComponent(
            pEntry, 
            TEXT("ms_msclient"),
            pEntry->fBindMsNetClient);

    EnableOrDisableNetComponent(
            pEntry, 
            TEXT("ms_server"),
            pEntry->fShareMsFilePrint);

    if (*lpRasEntry->szAreaCode != TEXT('\0'))
    {
        //
        // Make sure the area code does not contain
        // non-numeric characters.
        //
        if (!ValidateAreaCode(lpRasEntry->szAreaCode))
        {
            return ERROR_INVALID_PARAMETER;
        }

        pszAreaCode = StrDup(lpRasEntry->szAreaCode);
    }
    else
    {
        pszAreaCode = NULL;
    }

    //
    // Get script information.
    //
    if (lpRasEntry->szScript[0] == TEXT('['))
    {
        //
        // Verify the switch is valid.
        //
        dwErr = GetRasSwitches(NULL, &pDevices, &cwDevices);
        if (!dwErr)
        {
            CHAR szScriptA[MAX_PATH];

            strncpyTtoA(szScriptA, lpRasEntry->szScript, sizeof(szScriptA));
            for (i = 0; i < cwDevices; i++)
            {
                if (!_stricmp(pDevices[i].D_Name, &szScriptA[1]))
                {
                    pEntry->fScriptAfter = TRUE;

                    Clear0(pEntry->pszScriptAfter);
                    pEntry->pszScriptAfter =
                            StrDup(&lpRasEntry->szScript[1]);

                    if (pEntry->pszScriptAfter == NULL)
                    {
                        dwErr = GetLastError();
                    }
                    break;
                }
            }
            Free(pDevices);

            if (dwErr)
            {
                return dwErr;
            }
        }
    }
    else if (lpRasEntry->szScript[0] != TEXT('\0'))
    {
        pEntry->fScriptAfter = TRUE;

        Clear0(pEntry->pszScriptAfter);
        pEntry->pszScriptAfter = StrDup(lpRasEntry->szScript);

        if (pEntry->pszScriptAfter == NULL)
        {
            return GetLastError();
        }
    }
    else
    {
        Clear0(pEntry->pszScriptAfter);
        pEntry->fScriptAfter = FALSE;

        if(pLink->pbport.pszScriptBefore)
        {
            Free(pLink->pbport.pszScriptBefore);
            pLink->pbport.pszScriptBefore = NULL;
            pszScriptBefore = NULL;
        }

        pLink->pbport.fScriptBefore = FALSE;
        fScriptBefore = FALSE;
    }

    //
    // Get X.25 information.
    //
    pEntry->pszX25Network = NULL;
    if (*lpRasEntry->szX25PadType != TEXT('\0'))
    {
        //
        // Verify the X25 network is valid.
        //
        dwErr = GetRasPads(&pDevices, &cwDevices);
        if (!dwErr)
        {
            CHAR szX25PadTypeA[RAS_MaxPadType + 1];

            strncpyTtoA(
                szX25PadTypeA,
                lpRasEntry->szX25PadType,
                sizeof(szX25PadTypeA));

            for (i = 0; i < cwDevices; i++)
            {
                if (!_stricmp(pDevices[i].D_Name, szX25PadTypeA))
                {
                    Clear0(pEntry->pszX25Network);
                    pEntry->pszX25Network = StrDup(lpRasEntry->szX25PadType);
                    break;
                }
            }

            Free(pDevices);
        }
    }

    Clear0(pEntry->pszX25Address);
    pEntry->pszX25Address =
        lstrlen(lpRasEntry->szX25Address)
        ? StrDup(lpRasEntry->szX25Address)
        : NULL;

    Clear0(pEntry->pszX25Facilities);
    pEntry->pszX25Facilities =
        lstrlen(lpRasEntry->szX25Facilities)
        ? StrDup(lpRasEntry->szX25Facilities)
        : NULL;

    Clear0(pEntry->pszX25UserData);
    pEntry->pszX25UserData =
        lstrlen(lpRasEntry->szX25UserData)
        ? StrDup(lpRasEntry->szX25UserData)
        : NULL;

    //
    // Get custom dial UI information.
    //
    Clear0(pEntry->pszCustomDialDll);
    pEntry->pszCustomDialDll =
        lstrlen(lpRasEntry->szAutodialDll)
        ? StrDup(lpRasEntry->szAutodialDll)
        : NULL;

    Clear0(pEntry->pszCustomDialFunc);
    pEntry->pszCustomDialFunc =
        lstrlen(lpRasEntry->szAutodialFunc)
        ? StrDup(lpRasEntry->szAutodialFunc)
        : NULL;

    //
    // Get primary phone number.  Clear out any existing
    // numbers.
    //
    DtlDestroyList(pLink->pdtllistPhones, DestroyPhoneNode);

    pLink->pdtllistPhones = DtlCreateList(0);

    if(NULL == pLink->pdtllistPhones)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    if (*lpRasEntry->szLocalPhoneNumber != '\0')
    {

        if(CreateAndInitializePhone(
                        pszAreaCode,
                        lpRasEntry->dwCountryCode,
                        lpRasEntry->dwCountryID,
                        lpRasEntry->szLocalPhoneNumber,
                        !!(lpRasEntry->dwfOptions
                         & RASEO_UseCountryAndAreaCodes),
                        lpRasEntry->szDeviceName,
                        &pdtlnode))
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        DtlAddNodeFirst(pLink->pdtllistPhones, pdtlnode);
    }

    //
    // Get the alternate phone numbers.
    //
    if (lpRasEntry->dwAlternateOffset)
    {
        PTCHAR pszPhoneNumber =
        (PTCHAR)((ULONG_PTR)lpRasEntry
                + lpRasEntry->dwAlternateOffset);

        while (*pszPhoneNumber != TEXT('\0'))
        {

            if(CreateAndInitializePhone(
                            pszAreaCode,
                            lpRasEntry->dwCountryCode,
                            lpRasEntry->dwCountryID,
                            pszPhoneNumber,
                            !!(lpRasEntry->dwfOptions
                             & RASEO_UseCountryAndAreaCodes),
                            lpRasEntry->szDeviceName,
                            &pdtlnode))
            {
                return ERROR_NOT_ENOUGH_MEMORY;
            }

            DtlAddNodeLast(pLink->pdtllistPhones, pdtlnode);

            pszPhoneNumber += lstrlen(pszPhoneNumber) + 1;
        }
    }

    //
    // Get device information.
    //
    dwErr = LoadPortsList(&pdtllistPorts);

    if (dwErr)
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Get the encoded device name/port
    // and check for a match.
    //
    GetDevicePortName(
        lpRasEntry->szDeviceName,
        szDeviceName, szPortName);

    pPort = PpbportFromPortAndDeviceName(
                pdtllistPorts,
                szPortName,
                ((szDeviceName[ 0 ]) ? szDeviceName : NULL) );

    if (pPort != NULL)
    {
        if (CopyToPbport(&pLink->pbport, pPort))
        {
            pPort = NULL;
        }
    }

    //
    // Search for a device name match.
    //
    if (pPort == NULL)
    {
        for (pdtlnode = DtlGetFirstNode(pdtllistPorts);
             pdtlnode != NULL;
             pdtlnode = DtlGetNextNode(pdtlnode))
        {
            PBPORT *pPortTmp = (PBPORT *)DtlGetData(pdtlnode);

            if (    (pPortTmp->pszDevice != NULL)
                &&  (!lstrcmpi(pPortTmp->pszDevice, szDeviceName))
                &&  (!CopyToPbport(&pLink->pbport, pPortTmp)))
            {
                pPort = pPortTmp;
                break;
            }
        }
    }

    //
    // If we don't have a match, then
    // pick the first device of the
    // same type.
    //
    if (pPort == NULL)
    {
        pbdevicetype = PbdevicetypeFromPszType(
                        lpRasEntry->szDeviceType
                        );

        //
        // Initialize dwErr in case
        // we fall through the loop
        // without finding a match.
        //
        // dwErr = ERROR_INVALID_PARAMETER;

        //
        // Look for a port with the same
        // device type.
        //
        for (pdtlnode = DtlGetFirstNode(pdtllistPorts);
             pdtlnode != NULL;
             pdtlnode = DtlGetNextNode(pdtlnode))
        {
            pPort = (PBPORT *)DtlGetData(pdtlnode);

            if (pPort->pbdevicetype == pbdevicetype)
            {
                // XP 358859
                //
                // Validate the port against the entry type if 
                // possible.
                //
                if (    (lpRasEntry->dwSize == sizeof (RASENTRY))
                    ||  (lpRasEntry->dwSize == sizeof (RASENTRYW_V500)))
                {
                    if (lpRasEntry->dwType == RASET_Phone)
                    {
                        if (RASET_Phone != EntryTypeFromPbport(pPort))
                        {
                            continue;
                        }
                    }
                }
            
                dwErr = CopyToPbport(&pLink->pbport, pPort);

                break;
            }
        }

        if(NULL == pdtlnode)
        {
            if(fNewEntry)
            {
                //
                // Hack to make CM connections work.
                // Remove this code after beta
                // and just return an error in this case. The api
                // should not be setting bogus information.
                //
                SetBogusPortInformation(pLink, pEntry->dwType);
            }

            pPort = NULL;
        }
        
        //
        // If the device is a modem,
        // then set the default modem settings.
        //
        if (pbdevicetype == PBDT_Modem)
        {
            SetDefaultModemSettings(pLink);
        }
    }

    // pmay: 401682
    // 
    // Update the preferred device.  Whenever this api is called,
    // we can assume that the user wants the given device to 
    // be sticky.
    //
    if (pPort)
    {
        Clear0(pEntry->pszPreferredDevice);
        pEntry->pszPreferredDevice = StrDup(pPort->pszDevice);
        
        Clear0(pEntry->pszPreferredPort);
        pEntry->pszPreferredPort = StrDup(pPort->pszPort);;
    }

    //
    // Copy the remembered values
    //
    pLink->pbport.fScriptBefore = fScriptBefore;
    pLink->pbport.fScriptBeforeTerminal = fScriptBeforeTerminal;
    pLink->pbport.pszScriptBefore = pszScriptBefore;

    DtlDestroyList(pdtllistPorts, DestroyPortNode);

    if (dwErr)
    {
        return dwErr;
    }

    //
    // Copy the TAPI configuration blob.
    //
    if (lpbDeviceConfig != NULL && dwcbDeviceConfig)
    {
        Free0(pLink->pTapiBlob);

        pLink->pTapiBlob = Malloc(dwcbDeviceConfig);

        if (pLink->pTapiBlob == NULL)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        memcpy(pLink->pTapiBlob,
               lpbDeviceConfig,
               dwcbDeviceConfig);

        pLink->cbTapiBlob = dwcbDeviceConfig;
    }

    //
    // Copy the following fields over only for
    // a V401 structure or above.
    //
    if (    (lpRasEntry->dwSize == sizeof (RASENTRY))
        ||  (lpRasEntry->dwSize == sizeof (RASENTRYW_V500))
        ||  (lpRasEntry->dwSize == sizeof (RASENTRYW_V401)))
    {

        if(lpRasEntry->dwDialMode == 0)
        {
            pEntry->dwDialMode = 0;
        }
        else
        {
            pEntry->dwDialMode =    lpRasEntry->dwDialMode
                                 == RASEDM_DialAsNeeded
                                 ?  RASEDM_DialAsNeeded
                                 :  RASEDM_DialAll;
        }                             

        //
        // Get multilink and idle timeout information.
        //
        pEntry->dwDialPercent =
                lpRasEntry->dwDialExtraPercent;

        pEntry->dwDialSeconds =
            lpRasEntry->dwDialExtraSampleSeconds;

        pEntry->dwHangUpPercent =
                lpRasEntry->dwHangUpExtraPercent;

        pEntry->dwHangUpSeconds =
                lpRasEntry->dwHangUpExtraSampleSeconds;

        //
        // Get idle disconnect information.
        //
        pEntry->lIdleDisconnectSeconds =
                    lpRasEntry->dwIdleDisconnectSeconds;

        //
        // if the user is setting the dwIdleDisconnect
        // Seconds through apis then override the user
        // preferences.
        //
        if (pEntry->lIdleDisconnectSeconds)
        {
            pEntry->dwfOverridePref |= RASOR_IdleDisconnectSeconds;
        }
        
        //
        // CustomScript
        //
        pEntry->dwCustomScript = !!(    RASEO_CustomScript
                                    &   lpRasEntry->dwfOptions);
    }

    // 287667.  Make sure that the size of the structure is recent
    // enough to check the dwType value
    //
    if (    (lpRasEntry->dwSize == sizeof (RASENTRY))
        ||  (lpRasEntry->dwSize == sizeof (RASENTRYW_V500)))
    {        
        if(RASET_Phone != lpRasEntry->dwType)
        {
            pEntry->fPreviewPhoneNumber = FALSE;
            pEntry->fSharedPhoneNumbers = FALSE;
        }
    }        
    
    //
    // Copy the following information only if its nt5
    //
    if(     (lpRasEntry->dwSize == sizeof(RASENTRYW_V500))
        ||  (lpRasEntry->dwSize == sizeof(RASENTRY)))
    {
        //
        // Connection type
        //
        pEntry->dwType = lpRasEntry->dwType;

        //
        // Clear the Encryption type. We set it below
        // for nt5 - default to Mppe40Bit.
        //
        pEntry->dwDataEncryption = 0;

        /*
        if(     (ET_40Bit & lpRasEntry->dwEncryptionType)
            ||  (   (0 == lpRasEntry->dwEncryptionType)
                &&  (  RASEO_RequireDataEncryption
                     & lpRasEntry->dwfOptions)))
        {
            pEntry->dwDataEncryption |= DE_Mppe40bit;
        }

        if(ET_128Bit & lpRasEntry->dwEncryptionType)
        {
            pEntry->dwDataEncryption |= DE_Mppe128bit;
        }
        */

        if(     (ET_Require == lpRasEntry->dwEncryptionType)
            ||  (   (0 == lpRasEntry->dwEncryptionType)
                &&  (   RASEO_RequireDataEncryption
                    &   lpRasEntry->dwfOptions)))
        {
            pEntry->dwDataEncryption = DE_Require;
        }
        else if (ET_RequireMax == lpRasEntry->dwEncryptionType)
        {
            pEntry->dwDataEncryption = DE_RequireMax;
        }
        else if (ET_Optional == lpRasEntry->dwEncryptionType)
        {
            pEntry->dwDataEncryption = DE_IfPossible;
        }

        //
        // Clear the authrestrictions for nt5 if the user didn't
        // specify any authentication protocol.
        //
        if(     (!(lpRasEntry->dwfOptions & RASEO_RequireMsEncryptedPw))
            &&  (!(lpRasEntry->dwfOptions & RASEO_RequireEncryptedPw)))
        {
            pEntry->dwAuthRestrictions = 0;
        }

        //
        // Set the new authentication bits based on options defined
        // in NT5.
        //
        if(RASEO_RequireMsCHAP & lpRasEntry->dwfOptions)
        {
            pEntry->dwAuthRestrictions |= (AR_F_AuthMSCHAP | AR_F_AuthCustom);
        }

        if(RASEO_RequireMsCHAP2 & lpRasEntry->dwfOptions)
        {
            pEntry->dwAuthRestrictions |= (AR_F_AuthMSCHAP2 | AR_F_AuthCustom);
        }

        if(RASEO_RequireW95MSCHAP & lpRasEntry->dwfOptions)
        {
            pEntry->dwAuthRestrictions |= (AR_F_AuthW95MSCHAP | AR_F_AuthCustom);
        }

        if(RASEO_RequireCHAP & lpRasEntry->dwfOptions)
        {
            pEntry->dwAuthRestrictions |= (AR_F_AuthMD5CHAP | AR_F_AuthCustom);
        }

        if(RASEO_RequirePAP & lpRasEntry->dwfOptions)
        {
            pEntry->dwAuthRestrictions |= (AR_F_AuthPAP | AR_F_AuthCustom);
        }

        if(RASEO_RequireSPAP & lpRasEntry->dwfOptions)
        {
            pEntry->dwAuthRestrictions |= (AR_F_AuthSPAP | AR_F_AuthCustom);
        }

        if(RASEO_RequireEAP & lpRasEntry->dwfOptions)
        {
            pEntry->dwAuthRestrictions |= AR_F_AuthEAP;

            if(     (0 != lpRasEntry->dwCustomAuthKey)
                &&  (-1  != lpRasEntry->dwCustomAuthKey))
            {
                pEntry->dwCustomAuthKey =
                    lpRasEntry->dwCustomAuthKey;
            }
        }

        if(RASEO_Custom & lpRasEntry->dwfOptions)
        {
            pEntry->dwAuthRestrictions |= AR_F_AuthCustom;
        }

        if(0 == pEntry->dwAuthRestrictions)
        {
            pEntry->dwAuthRestrictions = AR_F_TypicalUnsecure;
        }

        if(     (lpRasEntry->dwfOptions & RASEO_RequireEncryptedPw)
            ||  (lpRasEntry->dwfOptions & RASEO_RequireMsEncryptedPw))
        {
            pEntry->dwAuthRestrictions &= ~(AR_F_AuthPAP);
        }
        

        //
        // Get custom dial UI information.
        //
        Clear0(pEntry->pszCustomDialerName);
        pEntry->pszCustomDialerName =
            lstrlen(lpRasEntry->szCustomDialDll)
            ? StrDup(lpRasEntry->szCustomDialDll)
            : NULL;

        //
        // Set fSharedPhoneNumbers/fPreviewPhoneNumbers
        //
        pEntry->fSharedPhoneNumbers = !!( RASEO_SharedPhoneNumbers
                                        & lpRasEntry->dwfOptions);

        pEntry->fPreviewPhoneNumber = !!(  RASEO_PreviewPhoneNumber
                                          & lpRasEntry->dwfOptions);

        pEntry->fPreviewUserPw = !!(  RASEO_PreviewUserPw
                                    & lpRasEntry->dwfOptions);

        pEntry->fPreviewDomain = !!(  RASEO_PreviewDomain
                                    & lpRasEntry->dwfOptions);

        pEntry->fShowDialingProgress = !!(  RASEO_ShowDialingProgress
                                          & lpRasEntry->dwfOptions);

        //
        // Vpn strategy
        //
        pEntry->dwVpnStrategy = lpRasEntry->dwVpnStrategy;

    }

    if(lpRasEntry->dwSize == sizeof(RASENTRY))
    {
        //
        // If the legacy RASEO bit is set, we don't want to do
        // anything. Otherwise we break legacy.
        //
        if(     (lpRasEntry->dwfOptions2 & RASEO2_SecureFileAndPrint)
            ||  (lpRasEntry->dwfOptions2 & RASEO2_SecureClientForMSNet))
        {
            pEntry->fShareMsFilePrint = 
                !(lpRasEntry->dwfOptions2 & RASEO2_SecureFileAndPrint);
                
            EnableOrDisableNetComponent(
                    pEntry, 
                    TEXT("ms_server"),
                    pEntry->fShareMsFilePrint);

            pEntry->fBindMsNetClient =
                !(lpRasEntry->dwfOptions2 & RASEO2_SecureClientForMSNet);
                
            EnableOrDisableNetComponent(
                    pEntry, 
                    TEXT("ms_msclient"),
                    pEntry->fBindMsNetClient);
        }

        if(lpRasEntry->dwfOptions2 & RASEO2_DontNegotiateMultilink)
        {
            pEntry->fNegotiateMultilinkAlways = FALSE;
        }
        else
        {
            pEntry->fNegotiateMultilinkAlways = TRUE;
        }

        if(lpRasEntry->dwfOptions2 & RASEO2_DontUseRasCredentials)
        {
            pEntry->fUseRasCredentials = FALSE;
        }
        else
        {
            pEntry->fUseRasCredentials = TRUE;
        }

        if(lpRasEntry->dwfOptions2 & RASEO2_UsePreSharedKey)
        {
            pEntry->dwIpSecFlags |= AR_F_IpSecPSK;
        }
        else
        {
            pEntry->dwIpSecFlags &= ~(AR_F_IpSecPSK);
        }

        if (lpRasEntry->dwfOptions2 & RASEO2_DisableNbtOverIP)
        {
            pEntry->dwIpNbtFlags = 0;
        }
        else
        {
            pEntry->dwIpNbtFlags = PBK_ENTRY_IP_NBT_Enable;
        }

        if (lpRasEntry->dwfOptions2 & RASEO2_Internet)
        {
            pEntry->dwUseFlags = PBK_ENTRY_USE_F_Internet;
        }
        else
        {
            pEntry->dwUseFlags = 0;
        }

        // Whislter bug 281306
        //
        pEntry->fGlobalDeviceSettings = 
            !!(lpRasEntry->dwfOptions2 & RASEO2_UseGlobalDeviceSettings);

        Clear0(pEntry->pszIpDnsSuffix);
        if(TEXT('\0') != lpRasEntry->szDnsSuffix[0])
        {
            pEntry->pszIpDnsSuffix = StrDup(lpRasEntry->szDnsSuffix);
        }
		else
		{
			pEntry->pszIpDnsSuffix = NULL;
		}

		// Whistler bug 300933
		//
		// Window size must be between 4K and 65K.  No particular increment needed
		// as the stack will calculate the correct value based on MTU.
		//
		// 0= use system default
		//
		if ((lpRasEntry->dwTcpWindowSize == 0) ||
		     ((lpRasEntry->dwTcpWindowSize < 64*1024) && 
		      (lpRasEntry->dwTcpWindowSize > 4*1024)))
        {		      
    		pEntry->dwTcpWindowSize = lpRasEntry->dwTcpWindowSize;
        }    		

        if ((TEXT('\0') != lpRasEntry->szPrerequisiteEntry[0]) && 
            (RASET_Vpn == lpRasEntry->dwType))
        {
            // XP bug 339970
            //
            // Don't allow the entry to require itself to be dialed
            //
            if (lstrcmpi(lpRasEntry->szPrerequisiteEntry, lpszEntry))
            {
                Clear0(pEntry->pszPrerequisiteEntry);
                pEntry->pszPrerequisiteEntry = 
                    StrDup(lpRasEntry->szPrerequisiteEntry);
            }
            else
            {
                return ERROR_INVALID_PARAMETER;
            }
        }
        else
        {
            pEntry->pszPrerequisiteEntry = NULL;
        }

        if ((TEXT('\0') != lpRasEntry->szPrerequisitePbk[0]) && 
            (RASET_Vpn == lpRasEntry->dwType))
        {
            Clear0(pEntry->pszPrerequisitePbk);
            pEntry->pszPrerequisitePbk = 
                StrDup(lpRasEntry->szPrerequisitePbk);
        }
        else
        {
            pEntry->pszPrerequisitePbk = NULL;
        }

        // XP 351608
        //
        if (lpRasEntry->dwRedialCount <= RAS_MaxRedialCount)
        {
            pEntry->dwRedialAttempts = lpRasEntry->dwRedialCount;
        }
        else
        {
            return ERROR_INVALID_PARAMETER;
        }

        // XP 351608
        //
        if (lpRasEntry->dwRedialPause <= RAS_RedialPause10m)
        {
            pEntry->dwRedialSeconds = lpRasEntry->dwRedialPause;
        }
        else
        {
            return ERROR_INVALID_PARAMETER;
        }

        // XP 370815
        // 
        pEntry->fRedialOnLinkFailure = 
            !!(lpRasEntry->dwfOptions2 & RASEO2_ReconnectIfDropped);
	
        // XP 403967
        //
        pEntry->fSharedPhoneNumbers = 
            !!(lpRasEntry->dwfOptions2 & RASEO2_SharePhoneNumbers);
            
    }

    //
    // Set dirty bit so this entry will get written out.
    //
    pEntry->fDirty = TRUE;

    return 0;
}


DWORD
PhonebookLinkToRasSubEntry(
    PBLINK*         pLink,
    LPRASSUBENTRY   lpRasSubEntry,
    LPDWORD         lpdwcb,
    LPBYTE          lpbDeviceConfig,
    LPDWORD         lpcbDeviceConfig
    )
{
    DWORD       dwErr,
                dwcb,
                dwcbPhoneNumber;
    DWORD       dwnPhoneNumbers,
                dwnAlternatePhoneNumbers = 0;
    DWORD       dwcbOrig,
                dwcbOrigDeviceConfig;
    DTLNODE*    pdtlnode;
    PTCHAR      pszPhoneNumber;
    PBPHONE*    pPhone;

    //
    // Determine up front if the buffer
    // is large enough.
    //
    dwcb = sizeof (RASSUBENTRY);

    dwnPhoneNumbers = DtlGetNodes(
                        pLink->pdtllistPhones
                        );

    if (dwnPhoneNumbers > 1)
    {
        dwnAlternatePhoneNumbers = dwnPhoneNumbers - 1;

        pdtlnode = DtlGetFirstNode(
                        pLink->pdtllistPhones
                        );

        for (pdtlnode = DtlGetNextNode(pdtlnode);
             pdtlnode != NULL;
             pdtlnode = DtlGetNextNode(pdtlnode))
        {

            TCHAR *pszNum;

            pPhone = (PBPHONE *) DtlGetData(pdtlnode);

            pszNum = pPhone->pszPhoneNumber;

            ASSERT(pszNum);

            dwcb += (lstrlen(pszNum) + 1) * sizeof (TCHAR);

        }
        dwcb += sizeof (TCHAR);
    }

    //
    // Set the return buffer size.
    //
    dwcbOrig = *lpdwcb;

    dwcbOrigDeviceConfig =
        lpcbDeviceConfig != NULL ? *lpcbDeviceConfig : 0;

    *lpdwcb = dwcb;

    if (lpcbDeviceConfig != NULL)
    {
        *lpcbDeviceConfig = pLink->cbTapiBlob;
    }

    //
    // Return if the buffer is NULL or if
    // there is not enough room.
    //
    if (    (lpRasSubEntry == NULL )
        ||  (dwcbOrig < dwcb)
        ||  (   (lpbDeviceConfig != NULL)
            &&  (dwcbOrigDeviceConfig < pLink->cbTapiBlob)))
    {
        return ERROR_BUFFER_TOO_SMALL;
    }

    //
    // Set dwfFlags.
    //
    lpRasSubEntry->dwfFlags = 0;

    //
    // Copy primary phone number
    //
    pdtlnode = DtlGetFirstNode(pLink->pdtllistPhones);
    if (pdtlnode != NULL)
    {
        TCHAR *pszNum;

        pPhone = (PBPHONE *) DtlGetData(pdtlnode);

        pszNum = pPhone->pszPhoneNumber;

        ASSERT(pszNum);

        lstrcpyn(
          lpRasSubEntry->szLocalPhoneNumber,
          pszNum,
          RAS_MaxPhoneNumber + 1);
    }
    else
    {
        *lpRasSubEntry->szLocalPhoneNumber = TEXT('\0');
    }

    //
    // Copy the alternate phone numbers past the
    // end of the structure.
    //
    if (dwnAlternatePhoneNumbers)
    {
        PTCHAR pEnd = (PTCHAR)((ULONG_PTR)lpRasSubEntry
                              + sizeof (RASSUBENTRY));

        lpRasSubEntry->dwAlternateOffset = (DWORD)((ULONG_PTR) pEnd
                                         - (ULONG_PTR) lpRasSubEntry);

        for (pdtlnode = DtlGetNextNode(pdtlnode);
             pdtlnode != NULL;
             pdtlnode = DtlGetNextNode(pdtlnode))
        {
            TCHAR *pszNum;

            pPhone = (PBPHONE *) DtlGetData(pdtlnode);

            ASSERT(pPhone);

            pszNum = pPhone->pszPhoneNumber;

            ASSERT(pszNum);

            pszPhoneNumber = StrDup(pszNum);

            if(NULL == pszPhoneNumber)
            {
                return ERROR_NOT_ENOUGH_MEMORY;
            }

            dwcbPhoneNumber = lstrlen(pszPhoneNumber);

            lstrcpyn(
                pEnd,
                pszPhoneNumber,
                (INT )(((PTCHAR )lpRasSubEntry + dwcbOrig) - pEnd));

            Free(pszPhoneNumber);

            pEnd += dwcbPhoneNumber + 1;
        }

        //
        // Add an extra NULL character to
        // terminate the list.
        //
        *pEnd = '\0';
    }
    else
    {
        lpRasSubEntry->dwAlternateOffset = 0;
    }

    //
    // Set device information.
    //
    switch (pLink->pbport.pbdevicetype)
    {
    case PBDT_Isdn:
        lstrcpy(
            lpRasSubEntry->szDeviceType,
            RASDT_Isdn);

        break;

    case PBDT_X25:
        lstrcpy(
            lpRasSubEntry->szDeviceType,
            RASDT_X25);

        break;

    case PBDT_Pad:
        lstrcpy(
            lpRasSubEntry->szDeviceType,
            RASDT_Pad);

        break;

    case PBDT_Other:
    case PBDT_Irda:
    case PBDT_Vpn:
    case PBDT_Serial:
    case PBDT_Atm:
    case PBDT_Parallel:
    case PBDT_Sonet:
    case PBDT_Sw56:
    case PBDT_FrameRelay:
    case PBDT_PPPoE:
    {
        dwErr = GetRasmanDeviceType(
                    pLink,
                    lpRasSubEntry->szDeviceType);

        if (dwErr)
        {
            return dwErr;
        }

        //
        // Convert the device type to lower case
        // to be consistent with the predefined
        // types.
        //
        _tcslwr(lpRasSubEntry->szDeviceType);
        break;
    }
    default:
        lstrcpy(
            lpRasSubEntry->szDeviceType,
            RASDT_Modem);

        break;

    }

    SetDevicePortNameFromLink(
                        pLink,
                        lpRasSubEntry->szDeviceName);

    //
    // Set the TAPI configuration blob.
    //
    if (    lpbDeviceConfig != NULL
        &&  dwcbOrigDeviceConfig <= pLink->cbTapiBlob)
    {
        memcpy(
            lpbDeviceConfig,
            pLink->pTapiBlob,
            pLink->cbTapiBlob);
    }

    return 0;
}


DWORD
RasSubEntryToPhonebookLink(
    PBENTRY*        pEntry,
    LPRASSUBENTRY   lpRasSubEntry,
    DWORD           dwcb,
    LPBYTE          lpbDeviceConfig,
    DWORD           dwcbDeviceConfig,
    PBLINK*         pLink
    )
{
    DWORD           dwErr, dwcbStr;
    DTLNODE         *pdtlnode;
    PBDEVICETYPE    pbdevicetype;
    DTLLIST         *pdtllistPorts;
    PBPORT          *pPort;
    WORD            i, cwDevices;
    RASMAN_DEVICE   *pDevices;
    TCHAR           szDeviceName[RAS_MaxDeviceName + 1];
    TCHAR           szPortName[MAX_PORT_NAME];
    PBPHONE         *pPhone;

    //
    // Get primary phone number.  Clear out any existing
    // numbers.
    //
    DtlDestroyList(pLink->pdtllistPhones, DestroyPhoneNode);

    pLink->pdtllistPhones = DtlCreateList(0);

    if (*lpRasSubEntry->szLocalPhoneNumber != TEXT('\0'))
    {
        //
        // The areacode/etc. will have to be
        // inherited from the entry properties.
        //
        pdtlnode = CreatePhoneNode();
        if (pdtlnode == NULL)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        pPhone = (PBPHONE *) DtlGetData(pdtlnode);

        pPhone->pszPhoneNumber = StrDup(
                            lpRasSubEntry->szLocalPhoneNumber
                            );

        if(NULL == pPhone->pszPhoneNumber)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        DtlAddNodeFirst(pLink->pdtllistPhones, pdtlnode);
    }

    //
    // Get the alternate phone numbers.
    //
    if (lpRasSubEntry->dwAlternateOffset)
    {
        PTCHAR pszPhoneNumber =
                    (PTCHAR)((ULONG_PTR)lpRasSubEntry
                    + lpRasSubEntry->dwAlternateOffset);

        while (*pszPhoneNumber != TEXT('\0'))
        {
            pdtlnode = CreatePhoneNode();

            if (pdtlnode == NULL)
            {
                return ERROR_NOT_ENOUGH_MEMORY;
            }

            pPhone = (PBPHONE *) DtlGetData(pdtlnode);

            pPhone->pszPhoneNumber = StrDup(
                            pszPhoneNumber
                            );

            if(NULL == pPhone->pszPhoneNumber)
            {
                return ERROR_NOT_ENOUGH_MEMORY;
            }

            DtlAddNodeLast(pLink->pdtllistPhones, pdtlnode);

            pszPhoneNumber += lstrlen(pszPhoneNumber) + 1;
        }
    }

    //
    // Get device information.
    //
    dwErr = LoadPortsList(&pdtllistPorts);
    if (dwErr)
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Get the encoded device name/port
    // and check for a match.
    //
    GetDevicePortName(
        lpRasSubEntry->szDeviceName,
        szDeviceName, szPortName);

    pPort = PpbportFromPortAndDeviceName(
                pdtllistPorts,
                szPortName,
                ((szDeviceName[ 0 ]) ? szDeviceName : NULL) );

    if (pPort != NULL)
    {
        if (CopyToPbport(&pLink->pbport, pPort))
        {
            pPort = NULL;
        }
    }

    //
    // Search for a device name match.
    //
    if (pPort == NULL)
    {
        for (pdtlnode = DtlGetFirstNode(pdtllistPorts);
             pdtlnode != NULL;
             pdtlnode = DtlGetNextNode(pdtlnode))
        {
            PBPORT *pPortTmp = (PBPORT *)DtlGetData(pdtlnode);

            if (    pPortTmp->pszDevice != NULL
                &&  !lstrcmpi(pPortTmp->pszDevice, szDeviceName)
                &&  !CopyToPbport(&pLink->pbport, pPortTmp))
            {
                pPort = pPortTmp;
                break;
            }
        }
    }

    //
    // If we don't have a match, then
    // pick the first device of the
    // same type.
    //
    if (pPort == NULL)
    {
        pbdevicetype = PbdevicetypeFromPszType(
                            lpRasSubEntry->szDeviceType
                            );

        //
        // Initialize dwErr in case
        // we fall through the loop
        // without finding a match.
        //
        dwErr = ERROR_INVALID_PARAMETER;

        //
        // Look for a port with the same
        // device type.
        //
        for (pdtlnode = DtlGetFirstNode(pdtllistPorts);
             pdtlnode != NULL;
             pdtlnode = DtlGetNextNode(pdtlnode))
        {
            pPort = (PBPORT *)DtlGetData(pdtlnode);

            if (pPort->pbdevicetype == pbdevicetype)
            {
                dwErr = CopyToPbport(&pLink->pbport, pPort);

                //
                // If the device is a modem,
                // then set the default modem settings.
                //
                if (pbdevicetype == PBDT_Modem)
                {
                    SetDefaultModemSettings(pLink);
                }

                break;
            }
        }
    }

    DtlDestroyList(pdtllistPorts, DestroyPortNode);
    if (dwErr)
    {
        return dwErr;
    }

    //
    // Copy the TAPI configuration blob.
    //
    if (lpbDeviceConfig != NULL && dwcbDeviceConfig)
    {
        Free0(pLink->pTapiBlob);

        pLink->pTapiBlob = Malloc(dwcbDeviceConfig);

        if (pLink->pTapiBlob == NULL)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        memcpy(
            pLink->pTapiBlob,
            lpbDeviceConfig,
            dwcbDeviceConfig);

        pLink->cbTapiBlob = dwcbDeviceConfig;
    }

    //
    // Set dirty bit so this entry will get written out.
    //
    pEntry->fDirty = TRUE;

    return 0;
}


DWORD
RenamePhonebookEntry(
    IN PBFILE *ppbfile,
    IN LPCTSTR lpszOldEntry,
    IN LPCTSTR lpszNewEntry,
    IN DTLNODE *pdtlnode
    )
{
    DWORD dwErr;
    PBENTRY *pEntry = (PBENTRY *)DtlGetData(pdtlnode);

    //
    // Make sure the new entry name is valid.
    //
    if (!ValidateEntryName(lpszNewEntry))
    {
        return ERROR_INVALID_NAME;
    }

    //
    // Remove it from the list of phonebook entries.
    //
    DtlRemoveNode(ppbfile->pdtllistEntries, pdtlnode);

    //
    // Change the name and set the dirty bit.
    //
    DtlAddNodeLast(ppbfile->pdtllistEntries, pdtlnode);

    Free(pEntry->pszEntryName);

    pEntry->pszEntryName = StrDup(lpszNewEntry);

    pEntry->fDirty = TRUE;

    dwErr = DwSendRasNotification(ENTRY_RENAMED,
                                  pEntry,
                                  ppbfile->pszPath,
                                  NULL);

    return 0;
}


DWORD
SetEntryDialParamsUID(
    IN DWORD dwUID,
    IN DWORD dwMask,
    IN LPRASDIALPARAMS lprasdialparams,
    IN BOOL fDelete
    )
{
    DWORD dwErr;
    RAS_DIALPARAMS dialparams;

    //
    // Convert the rasapi32 dialparams to
    // rasman dialparams, taking into account
    // the version of the structure the user
    // has passed in.
    //
    dialparams.DP_Uid = dwUID;

#ifdef UNICODE
    if (lprasdialparams->dwSize == sizeof (RASDIALPARAMSW_V351))
    {
        RASDIALPARAMSW_V351 *prdp =
                        (RASDIALPARAMSW_V351 *)lprasdialparams;
#else
    if (lprasdialparams->dwSize == sizeof (RASDIALPARAMSA_V351))
    {
        RASDIALPARAMSA_V351 *prdp =
                        (RASDIALPARAMSA_V351 *)lprasdialparams;
#endif
        strncpyTtoW(
            dialparams.DP_PhoneNumber,
            prdp->szPhoneNumber,
            sizeof(dialparams.DP_PhoneNumber) / sizeof(WCHAR));

        strncpyTtoW(
            dialparams.DP_CallbackNumber,
            prdp->szCallbackNumber,
            sizeof(dialparams.DP_CallbackNumber) / sizeof(WCHAR));

        strncpyTtoW(
            dialparams.DP_UserName,
            prdp->szUserName,
            sizeof(dialparams.DP_UserName) / sizeof(WCHAR));

        strncpyTtoW(
            dialparams.DP_Password,
            prdp->szPassword,
            sizeof(dialparams.DP_Password) / sizeof(WCHAR));

        strncpyTtoW(
            dialparams.DP_Domain,
            prdp->szDomain,
            sizeof(dialparams.DP_Domain) / sizeof(WCHAR));
    }
    else
    {
        //
        // V400 and V401 structures only differ by the
        // the addition of the dwSubEntry field, which
        // we test below.
        //
        strncpyTtoW(
            dialparams.DP_PhoneNumber,
            lprasdialparams->szPhoneNumber,
            sizeof(dialparams.DP_PhoneNumber) / sizeof(WCHAR));

        strncpyTtoW(
            dialparams.DP_CallbackNumber,
            lprasdialparams->szCallbackNumber,
            sizeof(dialparams.DP_CallbackNumber) / sizeof(WCHAR));

        strncpyTtoW(
            dialparams.DP_UserName,
            lprasdialparams->szUserName,
            sizeof(dialparams.DP_UserName) / sizeof(WCHAR));

        strncpyTtoW(
            dialparams.DP_Password,
            lprasdialparams->szPassword,
            sizeof(dialparams.DP_Password) / sizeof(WCHAR));

        strncpyTtoW(
            dialparams.DP_Domain,
            lprasdialparams->szDomain,
            sizeof(dialparams.DP_Domain) / sizeof(WCHAR));
    }

    if (lprasdialparams->dwSize == sizeof (RASDIALPARAMS))
    {
        dialparams.DP_SubEntry = lprasdialparams->dwSubEntry;
    }
    else
    {
        dialparams.DP_SubEntry = 1;
    }

    //
    // Set the dial parameters in rasman.
    //
    return g_pRasSetDialParams(dwUID,
                               dwMask,
                               &dialparams,
                               fDelete);
}


DWORD
GetAsybeuiLana(
    IN  HPORT hport,
    OUT BYTE* pbLana )

/*++

Routine Description:

    Loads caller's '*pbLana' with the LANA associated with
    NBF or AMB connection on port 'hport' or 0xFF if none.

Arguments:

Return Value:

    Returns 0 if successful, otherwise a non-0 error code.
    Note that caller is trusted to pass only an 'hport'
    associated with AMB or NBF.

--*/

{
    DWORD         dwErr;
    RAS_PROTOCOLS protocols;
    DWORD         cProtocols = 0;
    DWORD         i;

    *pbLana = 0xFF;

    RASAPI32_TRACE("RasPortEnumProtocols");

    dwErr = g_pRasPortEnumProtocols(NULL,
                                    hport,
                                    &protocols,
                                    &cProtocols );

    RASAPI32_TRACE1("RasPortEnumProtocols done(%d)",
            dwErr);

    if (dwErr != 0)
    {
        return dwErr;
    }

    for (i = 0; i < cProtocols; ++i)
    {
        if (protocols.RP_ProtocolInfo[ i ].RI_Type == ASYBEUI)
        {
            *pbLana = protocols.RP_ProtocolInfo[ i ].RI_LanaNum;

            RASAPI32_TRACE1("bLana=%d", (INT)*pbLana);

            break;
        }
    }

    return 0;
}


DWORD
SubEntryFromConnection(
    IN LPHRASCONN lphrasconn
    )
{
    DWORD dwErr, dwSubEntry = 1;
    RASMAN_INFO info;

    if (IS_HPORT(*lphrasconn))
    {
        HPORT hport = HRASCONN_TO_HPORT(*lphrasconn);

        //
        // The HRASCONN passed in is actually a
        // rasman HPORT.  Get the subentry index
        // from rasman.
        //
        dwErr = g_pRasGetInfo(NULL,
                              hport,
                              &info);
        if (dwErr)
        {
            RASAPI32_TRACE1(
                "SubEntryFromConnection: RasGetInfo"
                " failed (dwErr=%d)",
                dwErr);

            *lphrasconn = (HRASCONN)NULL;

            return 0;
        }

        *lphrasconn = (HRASCONN)info.RI_ConnectionHandle;
        dwSubEntry = info.RI_SubEntry;
    }
    else
    {
        RASMAN_PORT *lpPorts;
        DWORD i, dwcbPorts, dwcPorts;

        //
        // Get the ports associated with the
        // connection.
        //
        dwcbPorts = dwcPorts = 0;
        dwErr = g_pRasEnumConnectionPorts(
                    NULL,
                    (HCONN)*lphrasconn,
                    NULL,
                    &dwcbPorts,
                    &dwcPorts);

        //
        // If there are no ports associated
        // with the connection then return
        // ERROR_NO_MORE_ITEMS.
        //
        if (    (   !dwErr
                &&  !dwcPorts)
            ||  dwErr != ERROR_BUFFER_TOO_SMALL)
        {
            return 0;
        }

        lpPorts = Malloc(dwcbPorts);
        if (lpPorts == NULL)
        {
            return 0;
        }

        dwErr = g_pRasEnumConnectionPorts(
                    NULL,
                    (HCONN)*lphrasconn,
                    lpPorts,
                    &dwcbPorts,
                    &dwcPorts);
        if (dwErr)
        {
            Free(lpPorts);
            return 0;
        }

        //
        // Get the subentry index for the port.
        //
        for (i = 0; i < dwcPorts; i++)
        {
            dwErr = g_pRasGetInfo(NULL,
                                  lpPorts[i].P_Handle,
                                  &info);

            if (    !dwErr
                &&  info.RI_ConnState == CONNECTED
                &&  info.RI_SubEntry)
            {
                dwSubEntry = info.RI_SubEntry;
                break;
            }
        }

        Free(lpPorts);
    }

    RASAPI32_TRACE2(
      "SubEntryFromConnection: "
      "hrasconn=0x%x, dwSubEntry=%d",
      *lphrasconn,
      dwSubEntry);

    return dwSubEntry;
}


DWORD
SubEntryPort(
    IN HRASCONN hrasconn,
    IN DWORD dwSubEntry,
    OUT HPORT *lphport
    )
{
    DWORD dwErr;
    DWORD i, dwcbPorts, dwcPorts;
    DWORD dwSubEntryMax = 0;
    RASMAN_PORT *lpPorts;
    RASMAN_INFO info;

    //
    // Verify parameters.
    //
    if (    lphport == NULL
        ||  !dwSubEntry)
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Get the ports associated with the
    // connection.
    //
    dwcbPorts = dwcPorts = 0;
    dwErr = g_pRasEnumConnectionPorts(
                NULL,
                (HCONN)hrasconn,
                NULL,
                &dwcbPorts,
                &dwcPorts);

    //
    // If there are no ports associated
    // with the connection then return
    // ERROR_NO_MORE_ITEMS.
    //
    if (    (   !dwErr
            &&  !dwcPorts)
        ||  dwErr != ERROR_BUFFER_TOO_SMALL)
    {
        return ERROR_NO_CONNECTION;
    }

    lpPorts = Malloc(dwcbPorts);
    if (lpPorts == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    dwErr = g_pRasEnumConnectionPorts(
                NULL,
                (HCONN)hrasconn,
                lpPorts,
                &dwcbPorts,
                &dwcPorts);
    if (dwErr)
    {
        Free(lpPorts);
        return ERROR_NO_CONNECTION;
    }

    //
    // Enumerate the ports associated with
    // the connection to find the requested
    // subentry.
    //
    for (i = 0; i < dwcPorts; i++)
    {
        dwErr = g_pRasGetInfo(NULL,
                              lpPorts[i].P_Handle,
                              &info);
        if (dwErr)
        {
            continue;
        }

        //
        // Save the maximum subentry index.
        //
        if (info.RI_SubEntry > dwSubEntryMax)
        {
            dwSubEntryMax = info.RI_SubEntry;
        }

        if (info.RI_SubEntry == dwSubEntry)
        {
            *lphport = lpPorts[i].P_Handle;
            break;
        }
    }

    //
    // Free resources.
    //
    Free(lpPorts);

    if (info.RI_SubEntry == dwSubEntry)
    {
        return 0;
    }
    else if (dwSubEntry < dwSubEntryMax)
    {
        return ERROR_PORT_NOT_OPEN;
    }
    else
    {
        return ERROR_NO_MORE_ITEMS;
    }
}


VOID
CloseFailedLinkPorts()

/*++

Routine Description:

    Close any ports that are open but disconnected due to
    hardware failure or remote disconnection.  'pports'
    and 'cPorts' are the array and count of ports as
    returned by GetRasPorts.

Arguments:

Return Value:

--*/

{
    INT   i;
    DWORD dwErr;
    DWORD dwcPorts;
    RASMAN_PORT *pports = NULL, *pport;

    RASAPI32_TRACE("CloseFailedLinkPorts");

    dwErr = GetRasPorts(NULL, &pports, &dwcPorts);
    if (dwErr)
    {
        RASAPI32_TRACE1(
            "RasGetPorts failed (dwErr=%d)",
            dwErr);

        return;
    }

    for (i = 0, pport = pports; i < (INT )dwcPorts; ++i, ++pport)
    {
        RASAPI32_TRACE2(
            "Handle=%d, Status=%d",
            pport->P_Handle,
            pport->P_Status);

        if (pport->P_Status == OPEN)
        {
            RASMAN_INFO info;

            dwErr = g_pRasGetInfo(NULL,
                                  pport->P_Handle,
                                  &info );

            RASAPI32_TRACE5(
              "dwErr=%d, Handle=%d, ConnectionHandle=0x%x, "
              "ConnState=%d, DisconnectReason=%d",
              dwErr,
              pport->P_Handle,
              info.RI_ConnectionHandle,
              info.RI_ConnState,
              info.RI_DisconnectReason);

            if (!dwErr)
            {
                if (    info.RI_ConnState
                        == DISCONNECTED
                    &&  info.RI_ConnectionHandle
                        != (HCONN)NULL)
                {
                    RASCONNSTATE connstate;
                    DWORD dwSize = sizeof (connstate);

                    RASAPI32_TRACE1("Open disconnected port %d found",
                            pport->P_Handle);

                    dwErr = g_pRasGetPortUserData(
                              pport->P_Handle,
                              PORT_CONNSTATE_INDEX,
                              (PBYTE)&connstate,
                              &dwSize);

                    RASAPI32_TRACE2("dwErr=%d, connstate=%d",
                            dwErr, connstate);

                    if (    !dwErr
                        &&  dwSize == sizeof (RASCONNSTATE)
                        &&  (   connstate < RASCS_PrepareForCallback
                            ||  connstate > RASCS_WaitForCallback))
                    {
                        RASAPI32_TRACE1("RasPortClose(%d)...",
                                pport->P_Handle);

                        dwErr = g_pRasPortClose( pport->P_Handle );

                        RASAPI32_TRACE1("RasPortClose done(%d)",
                                dwErr);
                    }
                }
            }
        }
    }

    if (pports != NULL)
    {
        Free(pports);
    }

    RASAPI32_TRACE("CloseFailedLinkPorts done");
}


BOOL
GetCallbackNumber(
    IN RASCONNCB *prasconncb,
    IN PBUSER *ppbuser
    )
{
    DTLNODE *pdtlnode;
    CALLBACKINFO *pcbinfo;

    RASAPI32_TRACE("GetCallbackNumber");

    for (pdtlnode = DtlGetFirstNode(ppbuser->pdtllistCallback);
         pdtlnode != NULL;
         pdtlnode = DtlGetNextNode(pdtlnode))
    {
        BOOL fMatch;

        pcbinfo = DtlGetData(pdtlnode);
        ASSERT(pcbinfo);

        fMatch = FALSE;
        if (    pcbinfo->pszDeviceName != NULL
            &&  pcbinfo->pszPortName != NULL)
        {
            fMatch =
                (   !lstrcmpi(
                        pcbinfo->pszPortName,
                        prasconncb->szPortName)
                 && !lstrcmpi(
                        pcbinfo->pszDeviceName,
                        prasconncb->szDeviceName));
        }

        if (fMatch)
        {
            lstrcpyn(
              prasconncb->rasdialparams.szCallbackNumber,
              pcbinfo->pszNumber,
              sizeof(prasconncb->rasdialparams.szCallbackNumber) /
                sizeof(WCHAR));

            RASAPI32_TRACE1(
              "GetCallbackNumber: %S",
               prasconncb->rasdialparams.szCallbackNumber);

            return TRUE;
        }
    }

    RASAPI32_TRACE("GetCallbackNumber: not found!");
    return FALSE;
}


DWORD
SaveProjectionResults(
    IN RASCONNCB *prasconncb
    )
{
    DWORD dwErr;

    RASAPI32_TRACE2(
        "SaveProjectionResults: saving results "
        "(dwSubEntry=%d, nbf.dwError=%d)",
        prasconncb->rasdialparams.dwSubEntry,
        prasconncb->PppProjection.nbf.dwError);

    dwErr = g_pRasSetConnectionUserData(
              prasconncb->hrasconn,
              CONNECTION_PPPRESULT_INDEX,
              (PBYTE)&prasconncb->PppProjection,
              sizeof (prasconncb->PppProjection));
    if (dwErr)
    {
        return dwErr;
    }

    dwErr = g_pRasSetConnectionUserData(
              prasconncb->hrasconn,
              CONNECTION_AMBRESULT_INDEX,
              (PBYTE)&prasconncb->AmbProjection,
              sizeof (prasconncb->AmbProjection));

    if (dwErr)
    {
        return dwErr;
    }

    dwErr = g_pRasSetConnectionUserData(
              prasconncb->hrasconn,
              CONNECTION_SLIPRESULT_INDEX,
              (PBYTE)&prasconncb->SlipProjection,
              sizeof (prasconncb->SlipProjection));
    if (dwErr)
    {
        return dwErr;
    }

    return 0;
}


DWORD
LoadRasAuthDll()
{
    static BOOL fRasAuthDllLoaded = FALSE;

    if (fRasAuthDllLoaded)
    {
        return 0;
    }

    hinstAuth = LoadLibrary(TEXT("rascauth.dll"));
    if (hinstAuth == NULL)
    {
        return GetLastError();
    }

    if (
            (NULL == (g_pAuthCallback =
                (AUTHCALLBACK)GetProcAddress(
                                hinstAuth,
                                "AuthCallback")))

        ||  (NULL == (g_pAuthChangePassword =
                (AUTHCHANGEPASSWORD)GetProcAddress(
                                hinstAuth,
                                "AuthChangePassword")))

        ||  (NULL == (g_pAuthContinue =
                 (AUTHCONTINUE)GetProcAddress(
                                hinstAuth,
                                "AuthContinue")))

        ||  (NULL == (g_pAuthGetInfo =
                  (AUTHGETINFO)GetProcAddress(
                                hinstAuth,
                                "AuthGetInfo")))

        ||  (NULL == (g_pAuthRetry =
                  (AUTHRETRY)GetProcAddress(
                                hinstAuth,
                                "AuthRetry")))

        ||  (NULL == (g_pAuthStart =
                  (AUTHSTART)GetProcAddress(
                                hinstAuth,
                                "AuthStart")))
        ||  (NULL == (g_pAuthStop =
                (AUTHSTOP)GetProcAddress(
                                hinstAuth,
                                "AuthStop"))))
    {
        return GetLastError();
    }

    fRasAuthDllLoaded = TRUE;

    return 0;
}


DWORD
LoadRasScriptDll()
{
    static BOOL fRasScriptDllLoaded = FALSE;
    
    if (fRasScriptDllLoaded)
    {
        return 0;
    }

    hinstScript = LoadLibrary(TEXT("rasscrpt.dll"));

    if (hinstScript == NULL)
    {
        return GetLastError();
    }

    if (NULL == (g_pRasScriptExecute =
            (RASSCRIPTEXECUTE)GetProcAddress(
                                hinstScript,
                                "RasScriptExecute")))
    {
        return GetLastError();
    }

    fRasScriptDllLoaded = TRUE;
    return 0;
}


DWORD
LoadRasmanDllAndInit()
{
    if (FRasInitialized)
    {
        return 0;
    }

    RASAPI32_TRACE("LoadRasmanDll");
    if (LoadRasmanDll())
    {
        return GetLastError();
    }

    //
    // Success is returned if RasInitialize fails, in which
    // case none of the APIs will ever do anything but report
    // that RasInitialize failed.  All this is to avoid the
    // ugly system popup if RasMan service can't start.
    //
    if ((DwRasInitializeError = g_pRasInitialize()) != 0)
    {
        RASAPI32_TRACE1(
            "RasInitialize returned %d",
            DwRasInitializeError);

        return DwRasInitializeError;
    }

    FRasInitialized = TRUE;

    g_FRunningInAppCompatMode = FRunningInAppCompatMode();

    // pmay: 300166
    // 
    // We don't start rasauto automatically anymore. (win2k)
    //
    // pmay: 174997
    //
    // Due to several win9x app compat issues, we're enhancing
    // and re-enabling the rasauto service in whistler personal.
    //
    // pmay: 389988
    //
    // Ok take that back, it should not be started by our api's.
    // On personal sku, it should be auto-started.
    // Manually started elsewhere.
    //
    // g_pRasStartRasAutoIfRequired();

    return 0;
}

VOID
UnInitializeRAS()
{
    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    FRasInitialized = FALSE;
}


VOID
UnloadDlls()
{
    if (hinstIpHlp != NULL)
    {
        FreeLibrary(hinstIpHlp);
        hinstIpHlp = NULL;
    }

    if (hinstAuth != NULL)
    {
        FreeLibrary(hinstAuth);
        hinstAuth = NULL;
    }

    if (hinstScript != NULL)
    {
        FreeLibrary(hinstScript);
        hinstScript = NULL;
    }

    if (hinstMprapi != NULL)
    {
        FreeLibrary(hinstMprapi);
        hinstMprapi = NULL;
    }
}

#define net_long(x) (((((unsigned long)(x))&0xffL)<<24) | \
                     ((((unsigned long)(x))&0xff00L)<<8) | \
                     ((((unsigned long)(x))&0xff0000L)>>8) | \
                     ((((unsigned long)(x))&0xff000000L)>>24))
/*++

Routine Description::

    Converts 'ipaddr' to a string in the a.b.c.d form and
    returns same in caller's 'pwszIpAddress' buffer.
    The buffer should be at least 16 wide characters long.

Arguments::

    dwIpAddress

    pwszIpAddress

Returns:

    None

--*/

VOID
ConvertIpAddressToString(
    IN DWORD    dwIpAddress,
    IN LPWSTR   pwszIpAddress
)
{
    WCHAR wszBuf[ 3 + 1 ];
    LONG  lNetIpaddr = net_long( dwIpAddress );

    LONG lA = (lNetIpaddr & 0xFF000000) >> 24;
    LONG lB = (lNetIpaddr & 0x00FF0000) >> 16;
    LONG lC = (lNetIpaddr & 0x0000FF00) >> 8;
    LONG lD = (lNetIpaddr & 0x000000FF);

    _ltow( lA, wszBuf, 10 );
    wcscpy( pwszIpAddress, wszBuf );
    wcscat( pwszIpAddress, L"." );

    _ltow( lB, wszBuf, 10 );
    wcscat( pwszIpAddress, wszBuf );
    wcscat( pwszIpAddress, L"." );

    _ltow( lC, wszBuf, 10 );
    wcscat( pwszIpAddress, wszBuf );
    wcscat( pwszIpAddress, L"." );

    _ltow( lD, wszBuf, 10 );
    wcscat( pwszIpAddress, wszBuf );
}

/*++

Routine Description::

Arguments::

    bIpxAddress

    pwszIpxAddress

Returns:

    None

--*/
VOID
ConvertIpxAddressToString(
    IN PBYTE    bIpxAddress,
    IN LPWSTR   pwszIpxAddress
)
{
    wsprintf( pwszIpxAddress,
              TEXT("%2.2X%2.2X%2.2X%2.2X.%2.2X%2.2X%2.2X%2.2X%2.2X%2.2X"),
              bIpxAddress[0],
              bIpxAddress[1],
              bIpxAddress[2],
              bIpxAddress[3],
              bIpxAddress[4],
              bIpxAddress[5],
              bIpxAddress[6],
              bIpxAddress[7],
              bIpxAddress[8],
              bIpxAddress[9] );
}

RASDEVICETYPE
GetDefaultRdt(DWORD dwType)
{
    RASDEVICETYPE rdt;

    switch(dwType)
    {
        case RASET_Phone:
        {
            rdt = RDT_Modem;
            break;
        }

        case RASET_Vpn:
        {
            rdt = RDT_Tunnel | RDT_Tunnel_Pptp;
            break;
        }
        case RASET_Direct:
        {
            rdt = RDT_Direct | RDT_Parallel;
            break;
        }

        default:
        {
            rdt = RDT_Other;
            break;
        }
    }

    return rdt;
}

DWORD
DwEnumEntriesFromPhonebook(
        LPCWSTR         lpszPhonebookPath,
        LPBYTE          lprasentryname,
        LPDWORD         lpcb,
        LPDWORD         lpcEntries,
        DWORD           dwSize,
        DWORD           dwFlags,
        BOOL            fViewInfo
        )
{
    DWORD   dwErr;
    PBFILE  pbfile;
    BOOL    fV351;
    DTLNODE *dtlnode;
    PBENTRY *pEntry;
    DWORD   dwInBufSize;

    dwErr = LoadRasmanDllAndInit();
    if (dwErr)
    {
        return dwErr;
    }

    if (DwRasInitializeError != 0)
    {
        return DwRasInitializeError;
    }

    ASSERT(NULL != lpszPhonebookPath);

    dwErr = ReadPhonebookFile(
              lpszPhonebookPath,
              NULL,
              NULL,
              RPBF_NoCreate,
              &pbfile);

    if (dwErr)
    {
        return ERROR_CANNOT_OPEN_PHONEBOOK;
    }

    fV351 = (   !fViewInfo
            &&  (dwSize == sizeof(RASENTRYNAMEW_V351)));

    *lpcEntries = 0;

    for (dtlnode = DtlGetFirstNode(pbfile.pdtllistEntries);
         dtlnode != NULL;
         dtlnode = DtlGetNextNode(dtlnode))
    {
        pEntry = (PBENTRY *)DtlGetData(dtlnode);

        ASSERT(pEntry);

        //
        // Skip the entry if this is a CM Type Entry and
        // the app is not compiled using nt50 or greater
        // ras headers. fViewInfo will be set only for
        // nt5
        //
        if(     RASET_Internet == pEntry->dwType
            &&  sizeof(RASENTRYNAMEW) != dwSize
            &&  !fViewInfo)
        {
            continue;
        }

        if (    !fV351
            ||  wcslen(pEntry->pszEntryName)
                <= RAS_MaxEntryName_V351)
        {
            ++(*lpcEntries);
        }
    }

    dwInBufSize = *lpcb;
    *lpcb       = *lpcEntries * dwSize;

    if (*lpcb > dwInBufSize)
    {
        dwErr = ERROR_BUFFER_TOO_SMALL;
        goto done;
    }

    for (dtlnode = DtlGetFirstNode(pbfile.pdtllistEntries);
         dtlnode != NULL;
         dtlnode = DtlGetNextNode(dtlnode))
    {
        pEntry = (PBENTRY *)DtlGetData(dtlnode);

        //
        // Skip the entry if this is a CM Type Entry and
        // the app is not compiled using nt50 or greater
        // ras headers
        //
        if(     RASET_Internet == pEntry->dwType
            &&  sizeof(RASENTRYNAMEW) != dwSize
            &&  !fViewInfo)
        {
            continue;
        }

        if (fV351)
        {
            RASENTRYNAMEW_V351* lprasentryname351 =
                (RASENTRYNAMEW_V351* )lprasentryname;

            lprasentryname351->dwSize = sizeof(RASENTRYNAMEW_V351);              

            //
            // Entries with names longer than expected are
            // discarded since these might not match the
            // longer entry at RasDial (if there was another
            // entry identical up to the truncation point).
            //
            if (wcslen(pEntry->pszEntryName)
                       <= RAS_MaxEntryName_V351)
            {
                lstrcpyn(lprasentryname351->szEntryName,
                         pEntry->pszEntryName,
                         sizeof(lprasentryname351->szEntryName) /
                             sizeof(WCHAR));
            }

            ++lprasentryname351;
            lprasentryname = (LPBYTE)lprasentryname351;
        }
        else if(!fViewInfo)
        {
            LPRASENTRYNAMEW lprasentrynamew =
                            (RASENTRYNAMEW *)lprasentryname;

            lprasentrynamew->dwSize = sizeof(RASENTRYNAMEW);

            memset(
                lprasentrynamew->szEntryName,
                '\0',
                (RAS_MaxEntryName + 1) * sizeof (WCHAR));

            wcsncpy(
                lprasentrynamew->szEntryName,
                pEntry->pszEntryName,
                RAS_MaxEntryName);

            if(sizeof(RASENTRYNAMEW) == dwSize)
            {
                //
                // Also copy the phonebook path here
                //
                memset(
                    lprasentrynamew->szPhonebookPath,
                    '\0',
                    (MAX_PATH + 1) * sizeof (WCHAR));

                wcsncpy(
                    lprasentrynamew->szPhonebookPath,
                    lpszPhonebookPath,
                    MAX_PATH);

                //
                // Fill in the flags
                //
                lprasentrynamew->dwFlags = dwFlags;
            }

            if(sizeof(RASENTRYNAMEW_V401) == dwSize)
            {
                ((RASENTRYNAMEW_V401 *)
                lprasentryname) += 1;
            }
            else
            {
                ((RASENTRYNAMEW *)
                lprasentryname) += 1;
            }
        }
        else if(fViewInfo)
        {
            RASENUMENTRYDETAILS* pDetails =
                    (RASENUMENTRYDETAILS *)lprasentryname;

            dwErr = DwPbentryToDetails(
                        pEntry, 
                        lpszPhonebookPath,
                        !!(dwFlags & REN_AllUsers),
                        pDetails);
            if (dwErr != NO_ERROR)
            {
                break;
            }

            ((RASENUMENTRYDETAILS *) lprasentryname) += 1;
        }
    }

done:
    ClosePhonebookFile(&pbfile);
    return dwErr;
}

DWORD
DwEnumEntriesInDir(
    LPCTSTR     pszDirPath,
    DWORD       dwFlags,
    LPBYTE      lprasentryname,
    LPDWORD     lpcb,
    LPDWORD     lpcEntries,
    DWORD       dwSize,
    BOOL        fViewInfo
    )
{
    DWORD dwErr = SUCCESS;

    DWORD dwcEntries;

    DWORD dwcbLeft;

    TCHAR szFilePath[MAX_PATH + 1] = {0};

    WIN32_FIND_DATA wfdData;

    BOOL fFirstTime = TRUE;

    HANDLE hFindFile = INVALID_HANDLE_VALUE;

    BOOL fMem = FALSE;

    DWORD dwcb;

    ASSERT(lpcb);
    ASSERT(lpcEntries);
    ASSERT(lprasentryname);

    dwcbLeft    = *lpcb;
    *lpcb       = 0;
    *lpcEntries = 0;

    //
    // Enumerate entries in the phonebooks in this directory
    //
    while(SUCCESS == dwErr)
    {
        //
        // Whistler bug 292981 rasapi32.dll prefast warnings
        //
        if (!pszDirPath)
        {
            dwErr = ERROR_INVALID_PARAMETER;
            break;
        }
        //
        // Append the filter to dir.
        //
        lstrcpyn(szFilePath, pszDirPath, sizeof(szFilePath) / sizeof(TCHAR));

        wcsncat(
            szFilePath,
            TEXT("*.pbk"),
            (sizeof(szFilePath) / sizeof(TCHAR)) - lstrlen(szFilePath));

        if(fFirstTime)
        {
            fFirstTime = FALSE;

            hFindFile = FindFirstFile(szFilePath,
                                      &wfdData);

            if(INVALID_HANDLE_VALUE == hFindFile)
            {
                dwErr = GetLastError();
            }
        }
        else
        {
            if(!FindNextFile(hFindFile,
                             &wfdData))
            {
                dwErr = GetLastError();
            }
        }

        if(     ERROR_NO_MORE_FILES == dwErr
            ||  ERROR_FILE_NOT_FOUND == dwErr
            ||  ERROR_PATH_NOT_FOUND == dwErr)
        {
            dwErr = SUCCESS;
            goto done;
        }
        else if(ERROR_SUCCESS != dwErr)
        {
            continue;   
        }
        

        if(FILE_ATTRIBUTE_DIRECTORY & wfdData.dwFileAttributes
           ||  (REN_AllUsers == dwFlags
                &&  (CaseInsensitiveMatch(wfdData.cFileName, 
                                          TEXT("router.pbk")) == TRUE)))
        {
            continue;
        }

        dwcb = dwcbLeft;

        //
        // Construct full path name to the pbk file
        //
        lstrcpyn(szFilePath, pszDirPath, sizeof(szFilePath) / sizeof(TCHAR));

        wcsncat(
            szFilePath,
            wfdData.cFileName,
            (sizeof(szFilePath) / sizeof(TCHAR)) - lstrlen(szFilePath));

        //
        // Enumerate all the entries from this
        // file
        //
        dwErr = DwEnumEntriesFromPhonebook(
                                    szFilePath,
                                    lprasentryname,
                                    &dwcb,
                                    &dwcEntries,
                                    dwSize,
                                    dwFlags,
                                    fViewInfo);
        if(     dwErr
            &&  ERROR_BUFFER_TOO_SMALL != dwErr)
        {
            goto done;
        }

        *lpcEntries += dwcEntries;
        *lpcb       += dwcb;

        if(ERROR_BUFFER_TOO_SMALL == dwErr)
        {
            fMem        = TRUE;
            dwcbLeft    = 0;
            dwErr       = SUCCESS;
        }
        else
        {
            (BYTE*)lprasentryname += (dwcEntries * dwSize);

            if(dwcbLeft > dwcb)
            {
                dwcbLeft -= dwcb;
            }
            else
            {
                dwcbLeft = 0;
            }
        }
    }

done:
    if(INVALID_HANDLE_VALUE != hFindFile)
    {
        FindClose(hFindFile);
    }

    if(     SUCCESS == dwErr
        &&  fMem)
    {
        dwErr = ERROR_BUFFER_TOO_SMALL;
    }

    return dwErr;
}


// 205217: (shaunco) Introduced this because we now enumerate REN_AllUsers
// phonebooks from two locations.  One is the "All Users" proflie which
// GetPhonebookDirectory(PBM_System) now returns; the other is the legacy
// %windir%\system32\ras directory.
//
DWORD
DwEnumEntriesForPbkMode(
    DWORD       dwFlags,
    LPBYTE      lprasentryname,
    LPDWORD     lpcb,
    LPDWORD     lpcEntries,
    DWORD       dwSize,
    BOOL        fViewInfo
    )
{
    BOOL  fMem = FALSE;
    DWORD dwErr = SUCCESS;
    DWORD dwcbLeft;
    DWORD dwcb;
    DWORD dwcEntries;
    TCHAR szDirPath[MAX_PATH + 1] = {0};

    ASSERT(lprasentryname);
    ASSERT(lpcb);
    ASSERT(lpcEntries);

    dwcbLeft    = *lpcb;
    *lpcb       = 0;
    *lpcEntries = 0;

    if(!GetPhonebookDirectory(
            (dwFlags & REN_AllUsers) ? PBM_System : PBM_Personal,
            szDirPath))
    {
        //
        // Treat this as no entries to enumerate.  Sometimes
        // we have problems enumerating the per-user directory.
        //
        dwErr = SUCCESS;
        goto done;
    }

    dwcb = dwcbLeft;
    dwErr = DwEnumEntriesInDir(szDirPath,
                               dwFlags,
                               lprasentryname,
                               &dwcb,
                               &dwcEntries,
                               dwSize,
                               fViewInfo);
    if(     dwErr
        &&  ERROR_BUFFER_TOO_SMALL != dwErr)
    {
        goto done;
    }

    *lpcEntries += dwcEntries;
    *lpcb       += dwcb;

    if(ERROR_BUFFER_TOO_SMALL == dwErr)
    {
        fMem        = TRUE;
        dwcbLeft    = 0;
        dwErr       = SUCCESS;
    }
    else
    {
        (BYTE*)lprasentryname += (dwcEntries * dwSize);

        if(dwcbLeft > dwcb)
        {
            dwcbLeft -= dwcb;
        }
        else
        {
            dwcbLeft = 0;
        }
    }

    // If for all users, handle the legacy %windir%\system32\ras directory.
    //
    if(dwFlags & REN_AllUsers)
    {
        UINT cch = GetSystemDirectory(szDirPath, MAX_PATH + 1);

        if (cch == 0 || cch > (MAX_PATH - (5 + 8 + 1 + 3)))
        {
            // Treat this as no entries to enumerate.  Return with
            // whatever dwErr is now.
            //
            goto done;
        }

        wcsncat(
            szDirPath,
            TEXT("\\Ras\\"),
            (sizeof(szDirPath) / sizeof(TCHAR)) - lstrlen(szDirPath));

        dwcb = dwcbLeft;
        dwErr = DwEnumEntriesInDir(szDirPath,
                                   dwFlags,
                                   lprasentryname,
                                   &dwcb,
                                   &dwcEntries,
                                   dwSize,
                                   fViewInfo);
        if(     dwErr
            &&  ERROR_BUFFER_TOO_SMALL != dwErr)
        {
            goto done;
        }

        *lpcEntries += dwcEntries;
        *lpcb       += dwcb;

        if(ERROR_BUFFER_TOO_SMALL == dwErr)
        {
            fMem        = TRUE;
            dwcbLeft    = 0;
            dwErr       = SUCCESS;
        }
    }

done:
    if(     SUCCESS == dwErr
        &&  fMem)
    {
        dwErr = ERROR_BUFFER_TOO_SMALL;
    }

    return dwErr;
}

DWORD
DwCustomHangUp(
    CHAR *      lpszPhonebook,
    CHAR *      lpszEntryName,
    HRASCONN    hRasconn)
{
    DWORD       dwErr       = ERROR_SUCCESS;
    HINSTANCE   hInstDll    = NULL;
    BOOL        fCustomDll;
    RASENTRY    re          = {0};
    DWORD       dwSize;
    TCHAR*      szPhonebookPath = NULL;
    TCHAR*      szEntryName = NULL;
    TCHAR       *pszExpandedPath = NULL;

    RasCustomHangUpFn pfnRasCustomHangUp = NULL;

    RASAPI32_TRACE("DwCustomHangUp..");

    ASSERT(NULL != lpszPhonebook);
    ASSERT(NULL != lpszEntryName);

    // XP 339346
    //
    szPhonebookPath = (TCHAR*) Malloc((MAX_PATH + 1) * sizeof(TCHAR));
    szEntryName = (TCHAR*) Malloc((MAX_ENTRYNAME_SIZE + 1) * sizeof(TCHAR));
    if ((!szPhonebookPath) || (!szEntryName))
    {
        goto done;
    }

    strncpyAtoT(szPhonebookPath,
               lpszPhonebook,
               MAX_PATH + 1);

    strncpyAtoT(szEntryName,
               lpszEntryName,
               MAX_ENTRYNAME_SIZE + 1);

    //
    // Get the DllName
    //
    re.dwSize = dwSize = sizeof(RASENTRY);

    dwErr = RasGetEntryProperties(
                        szPhonebookPath,
                        szEntryName,
                        &re,
                        &dwSize,
                        NULL,
                        NULL);

    if(ERROR_SUCCESS != dwErr)
    {
        goto done;
    }

    ASSERT(TEXT('\0') != re.szCustomDialDll[0]);

    dwErr = DwGetExpandedDllPath(re.szCustomDialDll,
                                 &pszExpandedPath);

    if(ERROR_SUCCESS != dwErr)
    {
        goto done;
    }

    //
    // Load the Custom Dll
    //
    if(     NULL == (hInstDll = LoadLibrary(pszExpandedPath))
        ||  NULL == (pfnRasCustomHangUp =
                        (RasCustomHangUpFn) GetProcAddress(
                                            hInstDll,
                                            "RasCustomHangUp"
                                            )))
    {
        dwErr = GetLastError();
        goto done;
    }

    ASSERT(NULL != pfnRasCustomHangUp);

    dwErr = (pfnRasCustomHangUp) (hRasconn);

done:
    Free0(szPhonebookPath);
    Free0(szEntryName);

    if(NULL != hInstDll)
    {
        FreeLibrary(hInstDll);
    }

    if(NULL != pszExpandedPath)
    {
        LocalFree(pszExpandedPath);
    }

    RASAPI32_TRACE1("DwCustomHangUp done. %d",
            dwErr);

    return dwErr;
}

DWORD
DwCustomDial(LPRASDIALEXTENSIONS lpExtensions,
             LPCTSTR             lpszPhonebook,
             CHAR                *pszSysPbk,
             LPRASDIALPARAMS     prdp,
             DWORD               dwNotifierType,
             LPVOID              pvNotifier,
             HRASCONN            *phRasConn)
{

    RasCustomDialFn pfnCustomDial     = NULL;
    DWORD           dwErr             = SUCCESS;
    CHAR            *pszPhonebookA    = NULL;
    CHAR            *pszEntryNameA    = NULL;
    HINSTANCE       hInstDll          = NULL;
    DWORD           dwFlags           = 0;

    //
    // Get the custom dial function
    //
    dwErr = DwGetCustomDllEntryPoint((LPTSTR) lpszPhonebook,
                                     prdp->szEntryName,
                                     NULL,
                                     (FARPROC *) &pfnCustomDial,
                                     &hInstDll,
                                     CUSTOM_RASDIAL,
                                     NULL);

    if(SUCCESS != dwErr)
    {
        goto done;
    }

    dwErr = DwGetEntryMode((LPTSTR) lpszPhonebook,
                           prdp->szEntryName,
                           NULL,
                           &dwFlags);

    if(ERROR_SUCCESS != dwErr)
    {
        goto done;
    }

    //
    // Make the function call
    //
    dwErr = pfnCustomDial(hInstDll,
                          lpExtensions,
                          lpszPhonebook,
                          prdp,
                          dwNotifierType,
                          pvNotifier,
                          phRasConn,
                          dwFlags);

    if(SUCCESS != dwErr)
    {
        goto done;
    }

    if(lpszPhonebook)
    {
        pszPhonebookA = strdupTtoA(lpszPhonebook);
    }
    else
    {
        pszPhonebookA = pszSysPbk;
    }

    pszEntryNameA = strdupTtoA(prdp->szEntryName);

    if(     NULL == pszPhonebookA
        ||  NULL == pszEntryNameA)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto done;
    }

    //
    // Custom Rasdial succeeded. Mark the connection
    // in rasman.
    //
    dwErr = g_pRasReferenceCustomCount((HCONN) NULL,
                                       TRUE,
                                       pszPhonebookA,
                                       pszEntryNameA,
                                       NULL);

done:

    if(NULL != pszPhonebookA)
    {
        Free(pszPhonebookA);
    }

    if(NULL != pszEntryNameA)
    {
        Free(pszEntryNameA);
    }

    return dwErr;
}

// Marks the default internet connection in a group of phonebook
// entries.
//
DWORD
DwMarkDefaultInternetConnnection(
    LPRASENUMENTRYDETAILS pEntries, 
    DWORD dwCount)
{
    DWORD dwErr = NO_ERROR, i, dwAdCount = 1, dwAdSize;
    RASAUTODIALENTRY adEntry;

    ZeroMemory(&adEntry, sizeof(adEntry));
    adEntry.dwSize = sizeof(adEntry);
    
    do
    {
        dwAdCount = 1;
        dwAdSize = sizeof(adEntry);
        dwErr = RasGetAutodialAddress(
                    NULL,
                    NULL,
                    &adEntry,
                    &dwAdSize,
                    &dwAdCount);
                    
        if (dwErr != NO_ERROR)
        {
            break;
        }

        for (i = 0; i < dwCount; i++)
        {
            // Initialize the flags to zero -- bug 247151
            //
            pEntries[i].dwFlagsPriv = 0;
        }

        for (i = 0; i < dwCount; i++)
        {
            // Mark the default internet connection if found
            //
            if (wcsncmp(
                    pEntries[i].szEntryName, 
                    adEntry.szEntry, 
                    sizeof(pEntries[i].szEntryName)) == 0)
            {
                pEntries[i].dwFlagsPriv |= REED_F_Default;
                break;
            }
        }
                    
    } while (FALSE);

    return dwErr;
}

// 
// Rename the default internet connection as appropriate
//
DWORD 
DwRenameDefaultConnection(
    LPCWSTR lpszPhonebook,
    LPCWSTR lpszOldEntry,
    LPCWSTR lpszNewEntry)
{
    RASAUTODIALENTRYW adEntry;
    DWORD dwErr = NO_ERROR, dwCount = 0, dwCb = 0;

    // Initialize
    //
    ZeroMemory(&adEntry, sizeof(adEntry));
    adEntry.dwSize = sizeof(adEntry);
    dwCb = sizeof(adEntry);
    dwCount = 1;

    do
    {
        // Discover the current default internet connection
        //
        dwErr = RasGetAutodialAddressW(
                    NULL,
                    NULL,
                    &adEntry,
                    &dwCb,
                    &dwCount);
        if (dwErr != NO_ERROR) 
        {
            break;
        }
        if ((dwCb != sizeof(adEntry)) ||
            (dwCount != 1))
        {
            dwErr = ERROR_CAN_NOT_COMPLETE;
            break;
        }

        // Validate parameters and see if there is a match in the 
        // default connection name
        //
        if (lstrcmpi(lpszOldEntry, adEntry.szEntry))
        {
            // Not the default internet connection that is 
            // changing.  Return success.
            //
            break;
        }

        // So, we are changing the default connection.  
        //
        wcsncpy(
            adEntry.szEntry, 
            lpszNewEntry, 
            sizeof(adEntry.szEntry) / sizeof(WCHAR));
        dwErr = RasSetAutodialAddressW(
                    NULL,
                    0,
                    &adEntry,
                    sizeof(adEntry),
                    1);
    
    } while (FALSE);

    return dwErr;
}

DWORD APIENTRY
DwEnumEntryDetails(
    IN     LPCWSTR               lpszPhonebookPath,
    OUT    LPRASENUMENTRYDETAILS lprasentryname,
    IN OUT LPDWORD               lpcb,
    OUT    LPDWORD               lpcEntries )
{
    DWORD    dwErr = ERROR_SUCCESS;
    PBFILE   pbfile;
    DTLNODE  *dtlnode;
    PBENTRY  *pEntry;
    DWORD    dwInBufSize;
    BOOL     fStatus;
    DWORD    cEntries;
    DWORD    dwSize;
    LPRASENUMENTRYDETAILS pEntriesOrig = lprasentryname;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    RASAPI32_TRACE("DwEnumEntryDetails");

    if (!lpcb)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (    !lprasentryname
        || (    lprasentryname->dwSize
                != sizeof(RASENUMENTRYDETAILS)))
    {
        return ERROR_INVALID_SIZE;
    }

    if (!lpcEntries)
    {
        lpcEntries = &cEntries;
    }

    dwSize = lprasentryname->dwSize;

    if(lpszPhonebookPath)
    {
        dwErr = DwEnumEntriesFromPhonebook(
                                lpszPhonebookPath,
                                (LPBYTE) lprasentryname,
                                lpcb,
                                lpcEntries,
                                dwSize,
                                (IsPublicPhonebook(
                                    (TCHAR *)lpszPhonebookPath)
                                ? REN_AllUsers
                                : REN_User),
                                TRUE);
        goto done;
    }
    else
    {
        DWORD   dwcb      = *lpcb;
        DWORD   dwcEntries;
        DWORD   dwcbLeft  = *lpcb;

        DWORD   dwErrSav  = SUCCESS;

        *lpcb       = 0;
        *lpcEntries = 0;

        //
        // Enumerate entries from all pbk files in
        // All Users
        //
        dwErr = DwEnumEntriesForPbkMode(REN_AllUsers,
                                        (LPBYTE) lprasentryname,
                                        &dwcb,
                                        &dwcEntries,
                                        dwSize,
                                        TRUE);

        if(     dwErr
            &&  ERROR_BUFFER_TOO_SMALL != dwErr)
        {
            goto done;
        }

        if(ERROR_BUFFER_TOO_SMALL == dwErr)
        {
            dwErrSav = dwErr;
            dwcbLeft = 0;
        }
        else
        {
            ((RASENUMENTRYDETAILS *)
            lprasentryname) += dwcEntries;

            dwcbLeft -= ((dwcbLeft >= dwcb) ? dwcb : 0);
        }

        *lpcb += dwcb;
        dwcb = dwcbLeft;

        if(lpcEntries)
        {
            *lpcEntries = dwcEntries;
        }

        dwcEntries = 0;

        //
        // Enumerate entries from all pbk files in
        // users profile
        //
        dwErr = DwEnumEntriesForPbkMode(REN_User,
                                        (LPBYTE) lprasentryname,
                                        &dwcb,
                                        &dwcEntries,
                                        dwSize,
                                        TRUE);
        if(     dwErr
            &&  ERROR_BUFFER_TOO_SMALL != dwErr)
        {
            goto done;
        }
        else if (SUCCESS == dwErr)
        {
            dwErr = dwErrSav;
        }

        *lpcb += dwcb;

        if(lpcEntries)
        {
            *lpcEntries += dwcEntries;
        }

        if(NO_ERROR == dwErr)
        {
            // Mark the default internet connection.  Ignore the error
            // return here, it's non-critical
            //
            DwMarkDefaultInternetConnnection(pEntriesOrig, *lpcEntries);
        }
    }

done:
    RASAPI32_TRACE1("DwEnumEntryDetails done. %d", dwErr);
    return dwErr;
}

DWORD APIENTRY
DwCloneEntry(LPCWSTR lpwszPhonebookPath,
             LPCWSTR lpwszSrcEntryName,
             LPCWSTR lpwszDstEntryName)
{
    DWORD dwErr = ERROR_SUCCESS;
    DTLNODE *pdtlnodeSrc = NULL;
    DTLNODE *pdtlnodeDst = NULL;
    PBFILE  pbfile;
    PBENTRY *pEntry;
    BOOL    fPhonebookOpened = FALSE;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    //
    // Make some rudimentary parameter validation
    //
    if(     (NULL == lpwszSrcEntryName)
        ||  (NULL == lpwszDstEntryName)
        ||  (0 == lstrcmpi(lpwszSrcEntryName, lpwszDstEntryName)))

    {
        dwErr = E_INVALIDARG;
        goto done;
    }

    //
    // Things are good. So open the phonebookfile and get the
    // src entry
    //
    dwErr = GetPbkAndEntryName(
                    lpwszPhonebookPath,
                    lpwszSrcEntryName,
                    RPBF_NoCreate,
                    &pbfile,
                    &pdtlnodeSrc);

    if(ERROR_SUCCESS != dwErr)
    {
        goto done;
    }

    fPhonebookOpened = TRUE;

    pdtlnodeDst = CloneEntryNode(pdtlnodeSrc);

    if(NULL == pdtlnodeDst)
    {
        dwErr = E_OUTOFMEMORY;
        goto done;
    }

    //
    // Change the entryname to the new entryname and
    // save the node in the phonebook
    //
    pEntry = (PBENTRY *) DtlGetData(pdtlnodeDst);

    ASSERT(NULL != pEntry);

    Free0(pEntry->pszEntryName);

    pEntry->pszEntryName = StrDup((LPCTSTR) lpwszDstEntryName);

    if(NULL == pEntry->pszEntryName)
    {
        dwErr = E_OUTOFMEMORY;
        goto done;
    }

    //
    // Add the entry to the file
    //
    DtlAddNodeLast(pbfile.pdtllistEntries, pdtlnodeDst);

    //
    // Dirty the entry and write the phonebook file
    //
    pEntry->fDirty = TRUE;

    WritePhonebookFile(&pbfile, NULL);

    dwErr = DwSendRasNotification(
                ENTRY_ADDED,
                pEntry,
                pbfile.pszPath,
                NULL);

done:

    if(fPhonebookOpened)
    {
        ClosePhonebookFile(&pbfile);
    }

    return dwErr;
}

void
EnumEntryHeaderCallback(PBFILE *pFile, void *pvContext)
{
    struct s_EntryHeaderContext
    {
        DWORD cEntries;
        DWORD dwSize;
        RASENTRYHEADER *pRasEntryHeader;
    } *pEntryHeader = (struct s_EntryHeaderContext *) pvContext;

    DTLNODE *pdtlnode;

    RASENTRYHEADER *pEntryBuffer = pEntryHeader->pRasEntryHeader;

    if(NULL == pFile)
    {
        goto done;
    }

    //
    // Run through all the entries in the phonebook and fill
    // in the EntryHeader structure
    //
    for (pdtlnode = DtlGetFirstNode(pFile->pdtllistEntries);
         pdtlnode != NULL;
         pdtlnode = DtlGetNextNode(pdtlnode))
    {
        pEntryHeader->cEntries += 1;

        if(pEntryHeader->dwSize >=
            (pEntryHeader->cEntries * sizeof(RASENTRYHEADER)))
        {

            CopyMemory(
                &pEntryBuffer[pEntryHeader->cEntries - 1],
                DtlGetData(pdtlnode),
                sizeof(RASENTRYHEADER));
        }
    }

done:
    return;

}


DWORD APIENTRY
DwEnumEntriesForAllUsers(
            DWORD *lpcb,
            DWORD *lpcEntries,
            RASENTRYHEADER * pRasEntryHeader)
{
    DWORD dwErr = SUCCESS;
    DWORD dwSize = 0;
    WCHAR szPbkPath[MAX_PATH + 1];


    struct s_EntryHeaderContext
    {
        DWORD cEntries;
        DWORD dwSize;
        RASENTRYHEADER *pRasEntryHeader;
    } EntryHeader;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    if(     (NULL == lpcb)
        ||  (NULL == lpcEntries))
    {
        dwErr = E_INVALIDARG;
        goto done;
    }

    ZeroMemory(szPbkPath, sizeof(szPbkPath));

    if(!GetPhonebookDirectory(PBM_System, szPbkPath))
    {
        dwErr = ERROR_CANNOT_OPEN_PHONEBOOK;
        goto done;
    }

    ZeroMemory(&EntryHeader, sizeof(EntryHeader));

    EntryHeader.pRasEntryHeader = pRasEntryHeader;
    EntryHeader.dwSize = *lpcb;

    //
    // Enumerate entries from All Users dir
    //
    dwErr = DwEnumeratePhonebooksFromDirectory(
                szPbkPath,
                RPBF_HeaderType,
                (PBKENUMCALLBACK) EnumEntryHeaderCallback,
                &EntryHeader);

    if(SUCCESS != dwErr)
    {
        RASAPI32_TRACE1("Failed to enumerate from AllUsers pbk. rc=0x%x",
               dwErr);
    }

    ZeroMemory(szPbkPath, sizeof(szPbkPath));

    if(     (0 == (dwSize = GetSystemDirectory(szPbkPath, 
                            (sizeof(szPbkPath)/sizeof(WCHAR)))
                    ))
        ||  (dwSize * sizeof(WCHAR) > sizeof(szPbkPath)))
    {
        dwErr = ERROR_CANNOT_OPEN_PHONEBOOK;
        goto done;
    }

    wcsncat(
        szPbkPath,
        TEXT("\\Ras\\"),
        (sizeof(szPbkPath) / sizeof(WCHAR)) - lstrlen(szPbkPath));

    dwErr = DwEnumeratePhonebooksFromDirectory(
                szPbkPath,
                RPBF_HeaderType,
                (PBKENUMCALLBACK) EnumEntryHeaderCallback,
                &EntryHeader);

    *lpcEntries = EntryHeader.cEntries;

    if(*lpcb < EntryHeader.cEntries * sizeof(RASENTRYHEADER))
    {
        dwErr = ERROR_BUFFER_TOO_SMALL;
    }

    *lpcb = (EntryHeader.cEntries * sizeof(RASENTRYHEADER));

done:
    return dwErr;
}


DWORD
DwDeleteSubEntry(
    LPCWSTR lpszPhonebook,
    LPCWSTR lpszEntry,
    DWORD dwSubEntryId
    )
{
    DWORD dwErr = SUCCESS;
    DTLNODE *pdtlnode = NULL;
    PBFILE pbfile;
    DWORD dwSubEntries = 0;
    PBENTRY *pEntry = NULL;
    PBLINK *pLink = NULL;

    // Initialize the ras api debugging facility.  This should be done at the begining of
    // every public api.
    //
    RasApiDebugInit();

    if(     (NULL == lpszEntry)
        ||  (0 == dwSubEntryId))
    {
        RASAPI32_TRACE("DwDeleteSubEntry: invalid entryid or entryname specified");
        return E_INVALIDARG;
    }

    dwErr = LoadRasmanDllAndInit();
    if (dwErr)
    {
        RASAPI32_TRACE1("DwDeleteSubEntry: failed to init rasman. 0x%x",
                dwErr);
        return dwErr;
    }
    
#if PBCS
    EnterCriticalSection(&PhonebookLock);
#endif

    ZeroMemory(&pbfile, sizeof(pbfile));
    pbfile.hrasfile = -1;

    dwErr = GetPbkAndEntryName(
                lpszPhonebook,
                lpszEntry,
                0,
                &pbfile,
                &pdtlnode);

    if(     (ERROR_SUCCESS != dwErr)
        ||  (NULL == pdtlnode))
    {
        RASAPI32_TRACE("DwDeleteSubEntry: Entry not found");
        if(ERROR_SUCCESS == dwErr)
        {
            dwErr = ERROR_CANNOT_FIND_PHONEBOOK_ENTRY;
        }
        goto done;
    }

    pEntry = (PBENTRY *) DtlGetData(pdtlnode);

    ASSERT(pEntry);

    dwSubEntries = DtlGetNodes(pEntry->pdtllistLinks);

    if(     (1 < dwSubEntries)
        &&  (dwSubEntryId <= dwSubEntries))
    {
        pdtlnode = DtlNodeFromIndex(
                        pEntry->pdtllistLinks,
                        dwSubEntryId - 1);

        if(NULL == pdtlnode)
        {
            RASAPI32_TRACE("DwDeleteSubEntry: subentry not found");
            dwErr = ERROR_CANNOT_FIND_PHONEBOOK_ENTRY;
            goto done;
        }

        //
        // Found the link. Remove it from the list of links
        //
        pdtlnode = DtlRemoveNode(pEntry->pdtllistLinks,
                                 pdtlnode);

        ASSERT(pdtlnode);

        DtlDestroyNode(pdtlnode);

        pEntry->fDirty = TRUE;

        dwErr = WritePhonebookFile(&pbfile,NULL);
    }
    else
    {
        RASAPI32_TRACE1("DwDeletSubEntry: invalid subentry specified. %d",
              dwSubEntryId);

        dwErr = E_INVALIDARG;
    }

done:

    ClosePhonebookFile(&pbfile);

#if PBCS
    LeaveCriticalSection(&PhonebookLock);
#endif

    RASAPI32_TRACE1("DwDeleteSubEntry done. 0x%x", dwErr);

    return dwErr;    
}

DWORD
DwRasUninitialize()
{
    DWORD dwErr = ERROR_SUCCESS;

    dwErr = RasmanUninitialize();

    FRasInitialized = FALSE;

    return dwErr;
}

//
// Prefast warns us that performing case-insensitive comparisions should always
// use CompareString for const's: Prefast Error 400-Using <function> to perform
// a case-insensitive compare to constant <string> will give unexpected results
// in non-English locales.
//
BOOL
CaseInsensitiveMatch(
    IN LPCWSTR pszStr1,
    IN LPCWSTR pszStr2
    )
{
    return (CompareString(
                LOCALE_INVARIANT,
                NORM_IGNORECASE,
                pszStr1,
                -1,
                pszStr2,
                -1) == CSTR_EQUAL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\inc\common.h ===
//
// Copyright (c) Microsoft Corporation 1993-1995
//
// common.h
//
// Declares common and useful data structures, macros and functions.
// These items are broken down into the following sections.  Defining
// the associated flags will inhibit definition of the indicated
// items.
//
// NORTL            - run-time library functions
// NOBASICS         - basic macros
// NOMEM            - memory management, dynamic array functions
// NODA             - dynamic array functions
// NOSHAREDHEAP     - shared heap functions
// NOFILEINFO       - FileInfo functions
// NOCOLOR          - helper macros to derive COLOR_ values from state
// NODRAWTEXT       - enhanced version of DrawText
// NODIALOGHELPER   - dialog helper functions
// NOMESSAGESTRING  - construct message string functions
// NOSTRING         - string functions
// NOPATH           - path whacking functions
// NODEBUGHELP      - debug routines
// NOSYNC           - synchronization (critical sections, etc.)
// NOPROFILE        - profile (.ini) support functions
//
// Optional defines are:
//
// WANT_SHELL_SUPPORT   - include SH* function support
// SZ_MODULE            - debug string prepended to debug spew
// SHARED_DLL           - DLL is in shared memory (may require 
//                        per-instance data)
// SZ_DEBUGSECTION      - .ini section name for debug options
// SZ_DEBUGINI          - .ini name for debug options
//
// This is the "master" header.  The associated files are:
//
//  common.c
//  path.c
//  mem.c, mem.h
//  profile.c
//
//
// History:
//  04-26-95 ScottH     Transferred from Briefcase code
//                      Added controlling defines
//

#ifndef __COMMON_H__
#define __COMMON_H__

#ifdef RC_INVOKED
// Turn off a bunch of stuff to ensure that RC files compile OK
#define NOMEM
#define NOCOLOR
#define NODRAWTEXT
#define NODIALOGHELPER
#define NOMESSAGESTRING
#define NOSTRING
#define NODEBUGHELP
#define NODA
#define NOSYNC
#define NOPROFILE
#endif // RC_INVOKED

#ifdef _INC_OLE
#define WANT_OLE_SUPPORT
#endif

// Check for any conflicting defines...

#if !defined(WANT_SHELL_SUPPORT) && !defined(NOFILEINFO)
#pragma message("FileInfo routines need WANT_SHELL_SUPPORT.  Not providing FileInfo routines.")
#define NOFILEINFO
#endif

#if !defined(NOFILEINFO) && defined(NOMEM)
#pragma message("FileInfo routines need NOMEM undefined.  Overriding.")
#undef NOMEM
#endif

#if !defined(NOFILEINFO) && defined(NOMESSAGESTRING)
#pragma message("FileInfo routines need NOMESSAGESTRING undefined.  Overriding.")
#undef NOMESSAGESTRING
#endif

#if !defined(NOFILEINFO) && defined(NOSTRING)
#pragma message("FileInfo routines need NOSTRING undefined.  Overriding.")
#undef NOSTRING
#endif

#if !defined(NOMESSAGESTRING) && defined(NOMEM)
#pragma message("ConstructMessage routines need NOMEM undefined.  Overriding.")
#undef NOMEM
#endif

#if !defined(NOPATH) && defined(NOSTRING)
#pragma message("Path routines need NOSTRING undefined.  Overriding.")
#undef NOSTRING
#endif

#if !defined(NODA) && defined(NOMEM)
#pragma message("Dynamic Array routines need NOMEM undefined.  Overriding.")
#undef NOMEM
#endif

#if !defined(NOSHAREDHEAP) && defined(NOMEM)
#pragma message("Shared memory routines need NOMEM undefined.  Overriding.")
#undef NOMEM
#endif

#if !defined(NOPROFILE) && defined(NODEBUGHELP)
#pragma message("Debug profiling routines need NODEBUGHELP undefined.  Overriding.")
#undef NODEBUGHELP
#endif



// Other include files...

#if !defined(NOFILEINFO) && !defined(_SHLOBJ_H_)
#include <shlobj.h>
#endif


//
// Basics
//
#ifndef NOBASICS

#define Unref(x)        x

#ifdef DEBUG
#define INLINE
#define DEBUG_CODE(x)   x
#else
#define INLINE          __inline
#define DEBUG_CODE(x)   
#endif

// General flag macros
//
#define SetFlag(obj, f)             (obj |= (f))
#define ToggleFlag(obj, f)          (obj ^= (f))
#define ClearFlag(obj, f)           (obj &= ~(f))
#define IsFlagSet(obj, f)           (BOOL)(((obj) & (f)) == (f))  
#define IsFlagClear(obj, f)         (BOOL)(((obj) & (f)) != (f))  

#define InRange(id, idFirst, idLast)  ((UINT)(id-idFirst) <= (UINT)(idLast-idFirst))

// Standard buffer lengths
//
#define MAX_BUF                     260
#define MAX_BUF_MSG                 520
#define MAX_BUF_MED                 64
#define MAX_BUF_SHORT               32

#define NULL_CHAR                   '\0'
#define CCH_NUL                     (sizeof(TCHAR))
#define ARRAY_ELEMENTS(rg)          (sizeof(rg) / sizeof((rg)[0]))

// Comparison return values
//
#define CMP_GREATER                 1
#define CMP_LESSER                  (-1)
#define CMP_EQUAL                   0

// Count of characters to count of bytes
//
#define CbFromCch(cch)              ((cch)*sizeof(TCHAR))

// Swap values
//
#define Swap(a, b)      ((DWORD)(a) ^= (DWORD)(b) ^= (DWORD)(a) ^= (DWORD)(b))

// 64-bit macros
//
#define HIDWORD(_qw)                (DWORD)((_qw)>>32)
#define LODWORD(_qw)                (DWORD)(_qw)

// Calling declarations
//
#define PUBLIC                      FAR PASCAL
#define CPUBLIC                     FAR _cdecl
#define PRIVATE                     NEAR PASCAL

// Data segments
//
#define DATASEG_READONLY            ".text"
#define DATASEG_PERINSTANCE         ".instanc"
#define DATASEG_SHARED              ".data"

// Range of resource ID indexes are 0x000 - 0x7ff
#define IDS_BASE                    0x1000
#define IDS_ERR_BASE                (IDS_BASE + 0x0000)
#define IDS_OOM_BASE                (IDS_BASE + 0x0800)
#define IDS_MSG_BASE                (IDS_BASE + 0x1000)
#define IDS_RANDO_BASE              (IDS_BASE + 0x1800)
#define IDS_COMMON_BASE             (IDS_BASE + 0x2000)

#ifndef DECLARE_STANDARD_TYPES
// For a type "FOO", define the standard derived types PFOO, CFOO, and PCFOO.
//
#define DECLARE_STANDARD_TYPES(type)      typedef type *P##type; \
                                          typedef const type C##type; \
                                          typedef const type *PC##type;
#endif

// Zero-initialize data-item
//
#define ZeroInit(pobj, type)        MyZeroMemory(pobj, sizeof(type))

// Copy chunk of memory
//
#define BltByte(pdest, psrc, cb)    MyMoveMemory(pdest, psrc, cb)

#endif // NOBASICS


//
// Run-time library replacements
//
#ifdef NORTL

// (implemented privately)
LPSTR   PUBLIC lmemmove(LPSTR dst, LPCSTR src, int count);
LPSTR   PUBLIC lmemset(LPSTR dst, char val, UINT count);

#define MyZeroMemory(p, cb)             lmemset((LPSTR)(p), 0, cb)
#define MyMoveMemory(pdest, psrc, cb)   lmemmove((LPSTR)(pdest), (LPCSTR)(psrc), cb)

#else // NORTL

#define MyZeroMemory                    ZeroMemory
#define MyMoveMemory                    MoveMemory

#endif // NORTL


//
// Memory and dynamic array functions
//
#ifndef NOMEM
#include "mem.h"
#endif // NOMEM


//
// Message string helpers
//
#ifndef NOMESSAGESTRING

LPSTR   PUBLIC ConstructVMessageString(HINSTANCE hinst, LPCSTR pszMsg, va_list *ArgList);
BOOL    PUBLIC ConstructMessage(LPSTR * ppsz, HINSTANCE hinst, LPCSTR pszMsg, ...);

#define SzFromIDS(hinst, ids, pszBuf, cchBuf)   (LoadString(hinst, ids, pszBuf, cchBuf), pszBuf)

int PUBLIC MsgBox(HINSTANCE hinst, HWND hwndOwner, LPCSTR pszText, LPCSTR pszCaption, HICON hicon, DWORD dwStyle, ...);

// Additional MB_ flags
#define MB_WARNING      (MB_OK | MB_ICONWARNING)
#define MB_INFO         (MB_OK | MB_ICONINFORMATION)
#define MB_ERROR        (MB_OK | MB_ICONERROR)
#define MB_QUESTION     (MB_YESNO | MB_ICONQUESTION)

#endif // NOMESSAGESTRING


//
// String functions
//
#ifndef NOSTRING

int     PUBLIC AnsiToInt(LPCSTR pszString);
int     PUBLIC lstrnicmp(LPCSTR psz1, LPCSTR psz2, UINT count);
LPSTR   PUBLIC AnsiChr(LPCSTR psz, WORD wMatch);

#define IsSzEqual(sz1, sz2)         (BOOL)(lstrcmpi(sz1, sz2) == 0)
#define IsSzEqualC(sz1, sz2)        (BOOL)(lstrcmp(sz1, sz2) == 0)

#endif // NOSTRING


//
// FileInfo functions
//
#ifndef NOFILEINFO

// FileInfo struct that contains file time/size info
//
typedef struct _FileInfo
    {
    HICON   hicon;
    FILETIME ftMod;
    DWORD   dwSize;         // size of the file
    DWORD   dwAttributes;   // attributes
    LPARAM  lParam;
    LPSTR   pszDisplayName; // points to the display name
    char    szPath[1];      
    } FileInfo;

#define FIGetSize(pfi)          ((pfi)->dwSize)
#define FIGetPath(pfi)          ((pfi)->szPath)
#define FIGetDisplayName(pfi)   ((pfi)->pszDisplayName)
#define FIGetAttributes(pfi)    ((pfi)->dwAttributes)
#define FIIsFolder(pfi)         (IsFlagSet((pfi)->dwAttributes, SFGAO_FOLDER))

// Flags for FICreate
#define FIF_DEFAULT             0x0000
#define FIF_ICON                0x0001
#define FIF_DONTTOUCH           0x0002
#define FIF_FOLDER              0x0004

HRESULT PUBLIC FICreate(LPCSTR pszPath, FileInfo ** ppfi, UINT uFlags);
BOOL    PUBLIC FISetPath(FileInfo ** ppfi, LPCSTR pszPathNew, UINT uFlags);
BOOL    PUBLIC FIGetInfoString(FileInfo * pfi, LPSTR pszBuf, int cchBuf);
void    PUBLIC FIFree(FileInfo * pfi);

void    PUBLIC FileTimeToDateTimeString(LPFILETIME pft, LPSTR pszBuf, int cchBuf);

// Resource string IDs
#define IDS_BYTES                   (IDS_COMMON_BASE + 0x000)
#define IDS_ORDERKB                 (IDS_COMMON_BASE + 0x001)
#define IDS_ORDERMB                 (IDS_COMMON_BASE + 0x002)
#define IDS_ORDERGB                 (IDS_COMMON_BASE + 0x003)
#define IDS_ORDERTB                 (IDS_COMMON_BASE + 0x004)
#define IDS_DATESIZELINE            (IDS_COMMON_BASE + 0x005)

#endif // NOFILEINFO


//
// Color-from-owner-draw-state macros
//
#ifndef NOCOLOR

#define ColorText(nState)           (((nState) & ODS_SELECTED) ? COLOR_HIGHLIGHTTEXT : COLOR_WINDOWTEXT)
#define ColorBk(nState)             (((nState) & ODS_SELECTED) ? COLOR_HIGHLIGHT : COLOR_WINDOW)
#define ColorMenuText(nState)       (((nState) & ODS_SELECTED) ? COLOR_HIGHLIGHTTEXT : COLOR_MENUTEXT)
#define ColorMenuBk(nState)         (((nState) & ODS_SELECTED) ? COLOR_HIGHLIGHT : COLOR_MENU)
#define GetImageDrawStyle(nState)   (((nState) & ODS_SELECTED) ? ILD_SELECTED : ILD_NORMAL)

#endif // NOCOLOR


//
// Dialog helper functions
//
#ifndef NODIALOGHELPER

// Sets the dialog handle in the given data struct on first
// message that the dialog gets (WM_SETFONT).
//
#define SetDlgHandle(hwnd, msg, lp)     if((msg)==WM_SETFONT) (lp)->hdlg=(hwnd);

int     PUBLIC DoModal (HWND hwndParent, DLGPROC lpfnDlgProc, UINT uID, LPARAM lParam);
VOID    PUBLIC SetRectFromExtent(HDC hdc, LPRECT lprc, LPCSTR lpcsz);

#endif // NODIALOGHELPER


//
// Enhanced form of DrawText()
//
#ifndef NODRAWTEXT

// Flags for MyDrawText()
#define MDT_DRAWTEXT        0x00000001                                  
#define MDT_ELLIPSES        0x00000002                                  
#define MDT_LINK            0x00000004                                  
#define MDT_SELECTED        0x00000008                                  
#define MDT_DESELECTED      0x00000010                                  
#define MDT_DEPRESSED       0x00000020                                  
#define MDT_EXTRAMARGIN     0x00000040                                  
#define MDT_TRANSPARENT     0x00000080
#define MDT_LEFT            0x00000100
#define MDT_RIGHT           0x00000200
#define MDT_CENTER          0x00000400
#define MDT_VCENTER         0x00000800
#define MDT_CLIPPED         0x00001000

#ifndef CLR_DEFAULT         // (usually defined in commctrl.h)
#define CLR_DEFAULT         0xFF000000L
#endif

void    PUBLIC MyDrawText(HDC hdc, LPCSTR pszText, RECT FAR* prc, UINT flags, int cyChar, int cxEllipses, COLORREF clrText, COLORREF clrTextBk);
void    PUBLIC GetCommonMetrics(WPARAM wParam);

extern int g_cxLabelMargin;
extern int g_cxBorder;
extern int g_cyBorder;

extern COLORREF g_clrHighlightText;
extern COLORREF g_clrHighlight;
extern COLORREF g_clrWindowText;
extern COLORREF g_clrWindow;

extern HBRUSH g_hbrHighlight;
extern HBRUSH g_hbrWindow;

#endif // NODRAWTEXT

//
// Synchronization
//
#ifndef NOSYNC

#define INIT_EXCLUSIVE()        Common_InitExclusive();
#define ENTER_EXCLUSIVE()       Common_EnterExclusive();
#define LEAVE_EXCLUSIVE()       Common_LeaveExclusive();
#define ASSERT_EXCLUSIVE()      ASSERT(0 < g_cRefCommonCS)
#define ASSERT_NOT_EXCLUSIVE()  ASSERT(0 == g_cRefCommonCS)

extern UINT g_cRefCommonCS;

void    PUBLIC Common_InitExclusive(void);
void    PUBLIC Common_EnterExclusive(void);
void    PUBLIC Common_LeaveExclusive(void);

// Safe version of MsgWaitMultipleObjects()
//
DWORD   PUBLIC MsgWaitObjectsSendMessage(DWORD cObjects, LPHANDLE phObjects, DWORD dwTimeout);

#else // NOSYNC

#define INIT_EXCLUSIVE()        
#define ENTER_EXCLUSIVE()       
#define LEAVE_EXCLUSIVE()       
#define ASSERT_EXCLUSIVE()      
#define ASSERT_NOT_EXCLUSIVE()  

#endif // NOSYNC


//
// Path whacking functions
//
#ifndef NOPATH

BOOL    PUBLIC WPPathIsRoot(LPCSTR pszPath);
BOOL    PUBLIC WPPathIsUNC(LPCSTR pszPath);
LPSTR   PUBLIC WPRemoveBackslash(LPSTR lpszPath);
LPSTR   PUBLIC WPRemoveExt(LPCSTR pszPath, LPSTR pszBuf);
LPSTR   PUBLIC WPFindNextComponentI(LPCSTR lpszPath);
void    PUBLIC WPMakePresentable(LPSTR pszPath);
BOOL    PUBLIC WPPathsTooLong(LPCSTR pszFolder, LPCSTR pszName);
void    PUBLIC WPCanonicalize(LPCSTR pszPath, LPSTR pszBuf);
LPSTR   PUBLIC WPFindFileName(LPCSTR pPath);
BOOL    PUBLIC WPPathExists(LPCSTR pszPath);
LPCSTR  PUBLIC WPFindEndOfRoot(LPCSTR pszPath);
BOOL    PUBLIC WPPathIsPrefix(LPCSTR lpcszPath1, LPCSTR lpcszPath2);

#ifdef WANT_SHELL_SUPPORT
LPSTR   PUBLIC WPGetDisplayName(LPCSTR pszPath, LPSTR pszBuf);

// Events for WPNotifyShell
typedef enum _notifyshellevent
    {
    NSE_CREATE       = 0,
    NSE_MKDIR,
    NSE_UPDATEITEM,
    NSE_UPDATEDIR
    } NOTIFYSHELLEVENT;

void    PUBLIC WPNotifyShell(LPCSTR pszPath, NOTIFYSHELLEVENT nse, BOOL bDoNow);
#endif

#endif // NOPATH


//
// Profile (.ini) support functions
//
// (Currently all profile functions are for DEBUG use only
#ifndef DEBUG
#define NOPROFILE
#endif
#ifndef NOPROFILE

#ifndef SZ_DEBUGINI
#pragma message("SZ_DEBUGINI is not #defined.  Assuming \"rover.ini\".")
#define SZ_DEBUGINI   "rover.ini"
#endif
#ifndef SZ_DEBUGSECTION
#pragma message("SZ_DEBUGSECTION is not #defined.  Assuming [Debug].")
#define SZ_DEBUGSECTION   "Debug"
#endif

BOOL    PUBLIC ProcessIniFile(void);

#else // NOPROFILE

#define ProcessIniFile()

#endif // NOPROFILE


//
// Debug helper functions
//


// Break flags
#define BF_ONTHREADATT      0x00000001
#define BF_ONTHREADDET      0x00000002
#define BF_ONPROCESSATT     0x00000004
#define BF_ONPROCESSDET     0x00000008
#define BF_ONVALIDATE       0x00000010
#define BF_ONOPEN           0x00000020
#define BF_ONCLOSE          0x00000040

// Trace flags
#define TF_ALWAYS           0x00000000
#define TF_WARNING          0x00000001
#define TF_ERROR            0x00000002
#define TF_GENERAL          0x00000004      // Standard messages
#define TF_FUNC             0x00000008      // Trace function calls
// (Upper 16 bits reserved for user)

#if defined(NODEBUGHELP) || !defined(DEBUG)

#define DEBUG_BREAK  1 ? (void)0 : (void)
#define ASSERT(f)
#define EVAL(f)      (f)
#define ASSERT_MSG   1 ? (void)0 : (void)
#define DEBUG_MSG    1 ? (void)0 : (void)
#define TRACE_MSG    1 ? (void)0 : (void)

#define VERIFY_SZ(f, szFmt, x)          (f)
#define VERIFY_SZ2(f, szFmt, x1, x2)    (f)

#define DBG_ENTER(fn)
#define DBG_ENTER_SZ(fn, sz)
#define DBG_ENTER_DTOBJ(fn, pdtobj, sz)
#define DBG_ENTER_RIID(fn, riid)   

#define DBG_EXIT(fn)                            
#define DBG_EXIT_TYPE(fn, dw, pfnStrFromType)
#define DBG_EXIT_INT(fn, n)
#define DBG_EXIT_BOOL(fn, b)
#define DBG_EXIT_US(fn, us)
#define DBG_EXIT_UL(fn, ul)
#define DBG_EXIT_PTR(fn, ptr)                            
#define DBG_EXIT_HRES(fn, hres)   

#else // defined(NODEBUGHELP) || !defined(DEBUG)

extern DWORD g_dwDumpFlags;
extern DWORD g_dwBreakFlags;
extern DWORD g_dwTraceFlags;

// Debugging macros
//
#ifndef SZ_MODULE
#pragma message("SZ_MODULE is not #defined.  Debug spew will use UNKNOWN module.")
#define SZ_MODULE   "UNKNOWN"
#endif

#define DEBUG_CASE_STRING(x)    case x: return #x
#define DEBUG_STRING_MAP(x)     { x, #x }

#define ASSERTSEG

// Use this macro to declare message text that will be placed
// in the CODE segment (useful if DS is getting full)
//
// Ex: DEBUGTEXT(szMsg, "Invalid whatever: %d");
//
#define DEBUGTEXT(sz, msg) \
    static const char ASSERTSEG sz[] = msg;

void    PUBLIC CommonDebugBreak(DWORD flag);
void    PUBLIC CommonAssertFailed(LPCSTR szFile, int line);
void    CPUBLIC CommonAssertMsg(BOOL f, LPCSTR pszMsg, ...);
void    CPUBLIC CommonDebugMsg(DWORD mask, LPCSTR pszMsg, ...);

LPCSTR  PUBLIC Dbg_SafeStr(LPCSTR psz);

#define DEBUG_BREAK     CommonDebugBreak

// ASSERT(f)  -- Generate "assertion failed in line x of file.c"
//               message if f is NOT true.
//
#define ASSERT(f)                                                       \
    {                                                                   \
        DEBUGTEXT(szFile, __FILE__);                                    \
        if (!(f))                                                       \
            CommonAssertFailed(szFile, __LINE__);                       \
    }
#define EVAL        ASSERT

// ASSERT_MSG(f, msg, args...)  -- Generate wsprintf-formatted msg w/params
//                          if f is NOT true.
//
#define ASSERT_MSG   CommonAssertMsg

// TRACE_MSG(mask, msg, args...) - Generate wsprintf-formatted msg using
//                          specified debug mask.  System debug mask
//                          governs whether message is output.
//
#define DEBUG_MSG    CommonDebugMsg
#define TRACE_MSG    DEBUG_MSG

// VERIFY_SZ(f, msg, arg)  -- Generate wsprintf-formatted msg w/ 1 param
//                          if f is NOT true 
//
#define VERIFY_SZ(f, szFmt, x)   ASSERT_MSG(f, szFmt, x)


// VERIFY_SZ2(f, msg, arg1, arg2)  -- Generate wsprintf-formatted msg w/ 2
//                          param if f is NOT true 
//
#define VERIFY_SZ2(f, szFmt, x1, x2)   ASSERT_MSG(f, szFmt, x1, x2)



// DBG_ENTER(fn)  -- Generates a function entry debug spew for
//                          a function 
//
#define DBG_ENTER(fn)                  \
    TRACE_MSG(TF_FUNC, " > " #fn "()")


// DBG_ENTER_SZ(fn, sz)  -- Generates a function entry debug spew for
//                          a function that accepts a string as one of its
//                          parameters.
//
#define DBG_ENTER_SZ(fn, sz)                  \
    TRACE_MSG(TF_FUNC, " > " #fn "(..., \"%s\",...)", Dbg_SafeStr(sz))


#ifdef WANT_OLE_SUPPORT
// DBG_ENTER_RIID(fn, riid)  -- Generates a function entry debug spew for
//                          a function that accepts an riid as one of its
//                          parameters.
//
#define DBG_ENTER_RIID(fn, riid)                  \
    TRACE_MSG(TF_FUNC, " > " #fn "(..., %s,...)", Dbg_GetRiidName(riid))
#endif


// DBG_EXIT(fn)  -- Generates a function exit debug spew 
//
#define DBG_EXIT(fn)                              \
        TRACE_MSG(TF_FUNC, " < " #fn "()")

// DBG_EXIT_TYPE(fn, dw, pfnStrFromType)  -- Generates a function exit debug 
//                          spew for functions that return <type>.
//
#define DBG_EXIT_TYPE(fn, dw, pfnStrFromType)                   \
        TRACE_MSG(TF_FUNC, " < " #fn "() with %s", (LPCSTR)pfnStrFromType(dw))

// DBG_EXIT_INT(fn, us)  -- Generates a function exit debug spew for
//                          functions that return an INT.
//
#define DBG_EXIT_INT(fn, n)                       \
        TRACE_MSG(TF_FUNC, " < " #fn "() with %d", (int)(n))

// DBG_EXIT_BOOL(fn, b)  -- Generates a function exit debug spew for
//                          functions that return a boolean.
//
#define DBG_EXIT_BOOL(fn, b)                      \
        TRACE_MSG(TF_FUNC, " < " #fn "() with %s", (b) ? (LPSTR)"TRUE" : (LPSTR)"FALSE")

// DBG_EXIT_US(fn, us)  -- Generates a function exit debug spew for
//                          functions that return a USHORT.
//
#define DBG_EXIT_US(fn, us)                       \
        TRACE_MSG(TF_FUNC, " < " #fn "() with %#x", (USHORT)(us))

// DBG_EXIT_UL(fn, ul)  -- Generates a function exit debug spew for
//                          functions that return a ULONG.
//
#define DBG_EXIT_UL(fn, ul)                   \
        TRACE_MSG(TF_FUNC, " < " #fn "() with %#lx", (ULONG)(ul))

// DBG_EXIT_PTR(fn, pv)  -- Generates a function exit debug spew for
//                          functions that return a pointer.
//
#define DBG_EXIT_PTR(fn, pv)                   \
        TRACE_MSG(TF_FUNC, " < " #fn "() with %#lx", (LPVOID)(pv))

// DBG_EXIT_HRES(fn, hres)  -- Generates a function exit debug spew for
//                          functions that return an HRESULT.
//
#define DBG_EXIT_HRES(fn, hres)     DBG_EXIT_TYPE(fn, hres, Dbg_GetScode)

#endif // defined(NODEBUGHELP) || !defined(DEBUG)

//
// TRACING macros specific to RASSCRPIT
//
extern DWORD g_dwRasscrptTraceId;

#define RASSCRPT_TRACE_INIT(module) DebugInitEx(module, &g_dwRasscrptTraceId)
#define RASSCRPT_TRACE_TERM() DebugTermEx(&g_dwRasscrptTraceId)

#define RASSCRPT_TRACE(a)               TRACE_ID(g_dwRasscrptTraceId, a)
#define RASSCRPT_TRACE1(a,b)            TRACE_ID1(g_dwRasscrptTraceId, a,b)
#define RASSCRPT_TRACE2(a,b,c)          TRACE_ID2(g_dwRasscrptTraceId, a,b,c)
#define RASSCRPT_TRACE3(a,b,c,d)        TRACE_ID3(g_dwRasscrptTraceId, a,b,c,d)
#define RASSCRPT_TRACE4(a,b,c,d,e)      TRACE_ID4(g_dwRasscrptTraceId, a,b,c,d,e)
#define RASSCRPT_TRACE5(a,b,c,d,e,f)    TRACE_ID5(g_dwRasscrptTraceId, a,b,c,d,e,f)
#define RASSCRPT_TRACE6(a,b,c,d,e,f,g)  TRACE_ID6(g_dwRasscrptTraceId, a,b,c,d,e,f,g)

#endif // __COMMON_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\inc\inetcfgp.h ===
/*
    File    inetcfgp.h

    Private helper functions for dealing with inetcfg.  These
    functions are implemented in nouiutil.lib.

    Paul Mayfield, 1/5/98 (implementation by shaunco)
*/

#ifndef __nouiutil_inetcfgp_h
#define __nouiutil_inetcfgp_h

#define COBJMACROS

#include "objbase.h"
#include "netcfgx.h"
#include "netcfgp.h"
#include "netconp.h"

#ifdef _cplusplus
extern "C" {
#endif

HRESULT APIENTRY
HrCreateAndInitializeINetCfg (
    BOOL*       pfInitCom,
    INetCfg**   ppnc,
    BOOL        fGetWriteLock,
    DWORD       cmsTimeout,
    LPCWSTR     szwClientDesc,
    LPWSTR*     ppszwClientDesc);

HRESULT APIENTRY
HrUninitializeAndUnlockINetCfg(
    INetCfg*    pnc);

HRESULT APIENTRY
HrUninitializeAndReleaseINetCfg (
    BOOL        fUninitCom,
    INetCfg*    pnc,
    BOOL        fHasLock);

HRESULT APIENTRY
HrEnumComponentsInClasses (
    INetCfg*            pNetCfg,
    ULONG               cpguidClass,
    GUID**              apguidClass,
    ULONG               celt,
    INetCfgComponent**  rgelt,
    ULONG*              pceltFetched);

ULONG APIENTRY
ReleaseObj (void* punk);

HRESULT APIENTRY
HrCreateNetConnectionUtilities(
    INetConnectionUiUtilities ** ppncuu);


//Add this for bug 342810 328673
//
BOOL
IsGPAEnableFirewall(
    void);


#ifdef _cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\inc\eapcfg.h ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
//
// eapcfg.h
// EAP configuration library
// Public header
//
// 11/25/97 Steve Cobb


#ifndef _EAPCFG_H_
#define _EAPCFG_H_


//----------------------------------------------------------------------------
// Constants
//----------------------------------------------------------------------------

// The default EAP key code, i.e. TLS.
//
#define EAPCFG_DefaultKey 13


//----------------------------------------------------------------------------
// Datatypes
//----------------------------------------------------------------------------

// EAP configuration DLL entrypoints.  These definitions must match the
// raseapif.h prototypes for RasEapInvokeConfigUI and RasEapFreeUserData.
//
typedef DWORD (APIENTRY * RASEAPFREE)( PBYTE );
typedef DWORD (APIENTRY * RASEAPINVOKECONFIGUI)( DWORD, HWND, DWORD, PBYTE, DWORD, PBYTE*, DWORD*);
typedef DWORD (APIENTRY * RASEAPGETIDENTITY)( DWORD, HWND, DWORD, const WCHAR*, const WCHAR*, PBYTE, DWORD, PBYTE, DWORD, PBYTE*, DWORD*, WCHAR** );

// Flags
//
#define EAPCFG_FLAG_RequireUsername   0x1
#define EAPCFG_FLAG_RequirePassword   0x2

// EAP configuration package definition.
//
typedef struct
_EAPCFG
{
    // The package's unique EAP algorithm code.
    //
    DWORD dwKey;

    // The friendly name of the package suitable for display to the user.
    //
    TCHAR* pszFriendlyName;

    // The SystemRoot-relative path to the package's configuration DLL.  May
    // be NULL indicating there is none.
    //
    TCHAR* pszConfigDll;

    // The SystemRoot-relative path to the package's identity DLL.  May
    // be NULL indicating there is none.
    //
    TCHAR* pszIdentityDll;

    // Flags that specify what standard credentials are required at dial
    // time.
    //
    DWORD dwStdCredentialFlags;

    // True if user is to be forced to run the configuration API for the
    // package, i.e. defaults are not sufficient.
    //
    BOOL fForceConfig;

    // True if the package provides MPPE encryption keys, false if not.
    //
    BOOL fProvidesMppeKeys;

    // The package's default configuration blob, which can be overwritten by
    // the configuration DLL.  May be NULL and 0 indicating there is none.
    //
    BYTE* pData;
    DWORD cbData;

    // Eap per user data to be stored in HKCU. This data is returned from
    // the EapInvokeConfigUI entrypoint in the eap dll.
    //
    BYTE* pUserData;
    DWORD cbUserData;

    // Set when the configuration DLL has been called on the package.  This is
    // not a registry setting.  It is provided for the convenience of the UI
    // only.
    //
    BOOL fConfigDllCalled;

    // Specifies the class ID of the configuration UI for remote machines.
    GUID guidConfigCLSID;
}
EAPCFG;


//----------------------------------------------------------------------------
// Prototypes
//----------------------------------------------------------------------------

DTLNODE*
CreateEapcfgNode(
    void );

VOID
DestroyEapcfgNode(
    IN OUT DTLNODE* pNode );

DTLNODE*
EapcfgNodeFromKey(
    IN DTLLIST* pList,
    IN DWORD dwKey );

DTLLIST*
ReadEapcfgList(
    IN TCHAR* pszMachine );


#endif // _EAPCFG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\inc\intl.h ===
/* Copyright (c) 1995, Microsoft Corporation, all rights reserved
**
** intl.h
** Remote Access international helpers
** Public header
*/

#ifndef _INTL_H_
#define _INTL_H_

/*----------------------------------------------------------------------------
** Constants
**----------------------------------------------------------------------------
*/

/* Flags to GetDurationString.
*/
#define GDSFLAG_Mseconds 0x00000001
#define GDSFLAG_Seconds  0x00000002
#define GDSFLAG_Minutes  0x00000004
#define GDSFLAG_Hours    0x00000008
#define GDSFLAG_Days     0x00000010
#define GDSFLAG_All      0x0000001F


/*----------------------------------------------------------------------------
** Prototypes
**----------------------------------------------------------------------------
*/

DWORD
GetDurationString(
    IN DWORD dwMilliseconds,
    IN DWORD dwFormatFlags,
    IN OUT PTSTR pszBuffer,
    IN OUT DWORD *pdwBufSize );

DWORD
GetNumberString(
    IN DWORD dwNumber,
    IN OUT PTSTR pszBuffer,
    IN OUT PDWORD pdwBufSize );

PTSTR
padultoa(
    UINT  val,
    PTSTR pszBuf,
    INT   width );


#endif // _INTL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\inc\mdm.h ===
/*
    File    mdm.h

    Library for dealing with and installing modems.

    Paul Mayfield, 5/20/98
*/

#ifndef __rassrvui_mdm_h
#define __rassrvui_mdm_h

//
// Definition of callback function used for enumerating
// com ports.  Return TRUE to stop enumeration, FALSE to
// continue.
//
typedef BOOL (*MdmPortEnumFuncPtr)(
                    IN PWCHAR pszPort,
                    IN HANDLE hData);

//
// Enumerates serial ports on the system
//
DWORD MdmEnumComPorts(
        IN MdmPortEnumFuncPtr pEnumFunc,
        IN HANDLE hData);


//
// Installs a null modem on the given port
//
DWORD MdmInstallNullModem(
        IN PWCHAR pszPort);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\inc\loaddlls.h ===
/* Copyright (c) 1996, Microsoft Corporation, all rights reserved
**
** loaddlls.h
** RAS DLL load public header
**
** 02/17/96 Steve Cobb
*/

#ifndef _LOADDLLS_H_
#define _LOADDLLS_H_


#include <ras.h>    // Win32 RAS APIs
#include <rasdlg.h> // Win32 RAS UI APIs
#include <rasman.h> // RAS connection manager service
#include <rasppp.h> // PPP structure definitions

#define RASMERGE

/*----------------------------------------------------------------------------
** Datatypes and global declarations (defined in loaddlls.c)
**----------------------------------------------------------------------------
*/

/* RASAPI32.DLL entry points.
*/
#ifndef RASMERGE
extern HINSTANCE g_hRasapi32Dll;
#endif

typedef DWORD (APIENTRY * PRASCONNECTIONNOTIFICATION)( HRASCONN, HANDLE, DWORD );
extern PRASCONNECTIONNOTIFICATION g_pRasConnectionNotification;

typedef DWORD (APIENTRY * PRASDELETEENTRY)( LPTSTR, LPTSTR );
extern PRASDELETEENTRY g_pRasDeleteEntry;

typedef DWORD (APIENTRY * PRASDIAL)( LPRASDIALEXTENSIONS, LPTSTR, LPRASDIALPARAMS, DWORD, LPVOID, LPHRASCONN );
extern PRASDIAL g_pRasDial;

typedef DWORD (APIENTRY * PRASENUMENTRIES)( LPTSTR, LPTSTR, LPRASENTRYNAME, LPDWORD, LPDWORD );
extern PRASENUMENTRIES g_pRasEnumEntries;

typedef DWORD (APIENTRY * PRASENUMCONNECTIONS)( LPRASCONN, LPDWORD, LPDWORD );
extern PRASENUMCONNECTIONS g_pRasEnumConnections;

typedef DWORD (APIENTRY * PRASGETCONNECTSTATUS)( HRASCONN, LPRASCONNSTATUS );
extern PRASGETCONNECTSTATUS g_pRasGetConnectStatus;

typedef VOID (APIENTRY * PRASGETCONNECTRESPONSE)( HRASCONN, CHAR* );
extern PRASGETCONNECTRESPONSE g_pRasGetConnectResponse;

typedef DWORD (APIENTRY * PRASGETCREDENTIALS)( LPTSTR, LPTSTR, LPRASCREDENTIALS );
extern PRASGETCREDENTIALS g_pRasGetCredentials;

typedef DWORD (APIENTRY * PRASGETENTRYDIALPARAMS)( LPTSTR, LPRASDIALPARAMS, LPBOOL );
extern PRASGETENTRYDIALPARAMS g_pRasGetEntryDialParams;

typedef DWORD (APIENTRY * PRASGETERRORSTRING)( UINT, LPTSTR, DWORD );
extern PRASGETERRORSTRING g_pRasGetErrorString;

typedef DWORD (APIENTRY * PRASHANGUP)( HRASCONN );
extern PRASHANGUP g_pRasHangUp;

typedef DWORD (APIENTRY * PRASGETAUTODIALENABLE)( DWORD, LPBOOL );
extern PRASGETAUTODIALENABLE g_pRasGetAutodialEnable;

typedef DWORD (APIENTRY * PRASGETAUTODIALPARAM)( DWORD, LPVOID, LPDWORD );
extern PRASGETAUTODIALPARAM g_pRasGetAutodialParam;

typedef DWORD (APIENTRY * PRASGETPROJECTIONINFO)( HRASCONN, RASPROJECTION, LPVOID, LPDWORD );
extern PRASGETPROJECTIONINFO g_pRasGetProjectionInfo;

typedef DWORD (APIENTRY * PRASSETAUTODIALENABLE)( DWORD, BOOL );
extern PRASSETAUTODIALENABLE g_pRasSetAutodialEnable;

typedef DWORD (APIENTRY * PRASSETAUTODIALPARAM)( DWORD, LPVOID, DWORD );
extern PRASSETAUTODIALPARAM g_pRasSetAutodialParam;

typedef DWORD (APIENTRY * PRASGETSUBENTRYHANDLE)( HRASCONN, DWORD, LPHRASCONN );
extern PRASGETSUBENTRYHANDLE g_pRasGetSubEntryHandle;

typedef HPORT (APIENTRY * PRASGETHPORT)( HRASCONN );
extern PRASGETHPORT g_pRasGetHport;

typedef DWORD (APIENTRY * PRASSETCREDENTIALS)( LPTSTR, LPTSTR, LPRASCREDENTIALS, BOOL );
extern PRASSETCREDENTIALS g_pRasSetCredentials;

typedef DWORD (APIENTRY * PRASSETOLDPASSWORD)( HRASCONN, CHAR* );
extern PRASSETOLDPASSWORD g_pRasSetOldPassword;

typedef DWORD (APIENTRY * PRASGETCOUNTRYINFO)( LPRASCTRYINFO, LPDWORD );
extern PRASGETCOUNTRYINFO g_pRasGetCountryInfo;

typedef DWORD (APIENTRY * PRASINVOKEEAPUI)(HRASCONN, DWORD dwSubEntry, LPRASDIALEXTENSIONS, HWND );
extern PRASINVOKEEAPUI g_pRasInvokeEapUI;

typedef DWORD (APIENTRY * PRASSETEAPUSERDATA)( HANDLE, LPCTSTR, LPCTSTR, LPBYTE, LPDWORD );
extern PRASSETEAPUSERDATA g_pRasSetEapUserData;

typedef DWORD (APIENTRY * PRASGETENTRYPROPERTIES) (LPCTSTR, LPCTSTR, LPRASENTRY, LPDWORD, LPBYTE, LPDWORD);
extern PRASGETENTRYPROPERTIES g_pRasGetEntryProperties;

typedef DWORD (APIENTRY * PRASVALIDATEENTRYNAME) (LPCWSTR, LPCWSTR);
extern PRASVALIDATEENTRYNAME g_pRasValidateEntryName;


/* RASDLG.DLL entry points
*/
#ifndef RASMERGE
extern HINSTANCE g_hRasdlgDll;
#endif

typedef DWORD (APIENTRY * PRASPHONEBOOKDLG)( LPTSTR, LPTSTR, LPRASPBDLG );
extern PRASPHONEBOOKDLG g_pRasPhonebookDlg;

typedef DWORD (APIENTRY * PRASENTRYDLG)( LPTSTR, LPTSTR, LPRASENTRYDLG );
extern PRASENTRYDLG g_pRasEntryDlg;

typedef DWORD (APIENTRY * PROUTERENTRYDLG)( LPTSTR, LPTSTR, LPTSTR, LPRASENTRYDLG );
extern PROUTERENTRYDLG g_pRouterEntryDlg;

typedef DWORD (APIENTRY * PRASDIALDLG)( LPTSTR, LPTSTR, LPTSTR, LPRASDIALDLG );
extern PRASDIALDLG g_pRasDialDlg;


/* RASMAN.DLL entry points
*/
#ifndef RASMERGE
extern HINSTANCE g_hRasmanDll;
#endif

typedef DWORD (APIENTRY * PRASPORTCLEARSTATISTICS)( HANDLE, HPORT );
extern PRASPORTCLEARSTATISTICS g_pRasPortClearStatistics;

typedef DWORD (APIENTRY * PRASBUNDLECLEARSTATISTICS)( HANDLE, HPORT );
extern PRASBUNDLECLEARSTATISTICS g_pRasBundleClearStatistics;

typedef DWORD (APIENTRY * PRASBUNDLECLEARSTATISTICSEX)( HANDLE, HCONN );
extern PRASBUNDLECLEARSTATISTICSEX g_pRasBundleClearStatisticsEx;

typedef DWORD (APIENTRY * PRASDEVICEENUM)( HANDLE, PCHAR, PBYTE, PDWORD, PDWORD );
extern PRASDEVICEENUM g_pRasDeviceEnum;

typedef DWORD (APIENTRY * PRASDEVICEGETINFO)( HANDLE, HPORT, PCHAR, PCHAR, PBYTE, PDWORD );
extern PRASDEVICEGETINFO g_pRasDeviceGetInfo;

typedef DWORD (APIENTRY * PRASFREEBUFFER)( PBYTE );
extern PRASFREEBUFFER g_pRasFreeBuffer;

typedef DWORD (APIENTRY * PRASGETBUFFER)( PBYTE*, PDWORD );
extern PRASGETBUFFER g_pRasGetBuffer;

typedef DWORD (APIENTRY * PRASPORTGETFRAMINGEX)( HANDLE, HPORT, RAS_FRAMING_INFO* );
extern PRASPORTGETFRAMINGEX g_pRasPortGetFramingEx;

typedef DWORD (APIENTRY * PRASGETINFO)( HANDLE, HPORT, RASMAN_INFO* );
extern PRASGETINFO g_pRasGetInfo;

typedef DWORD (APIENTRY * PRASGETNDISWANDRIVERCAPS)( HANDLE, RAS_NDISWAN_DRIVER_INFO* );
extern PRASGETNDISWANDRIVERCAPS g_pRasGetNdiswanDriverCaps;

typedef DWORD (APIENTRY * PRASINITIALIZE)();
extern PRASINITIALIZE g_pRasInitialize;

typedef DWORD (APIENTRY * PRASINITIALIZENOWAIT)();
extern PRASINITIALIZE g_pRasInitializeNoWait;

typedef DWORD (APIENTRY * PRASPORTCANCELRECEIVE)( HPORT );
extern PRASPORTCANCELRECEIVE g_pRasPortCancelReceive;

typedef DWORD (APIENTRY * PRASPORTENUM)( HANDLE, PBYTE, PDWORD, PDWORD );
extern PRASPORTENUM g_pRasPortEnum;

typedef DWORD (APIENTRY * PRASPORTGETINFO)( HANDLE, HPORT, PBYTE, PDWORD );
extern PRASPORTGETINFO g_pRasPortGetInfo;

typedef DWORD (APIENTRY * PRASPORTGETSTATISTICS)( HANDLE, HPORT, PBYTE, PDWORD );
extern PRASPORTGETSTATISTICS g_pRasPortGetStatistics;

typedef DWORD (APIENTRY * PRASBUNDLEGETSTATISTICS)( HANDLE, HPORT, PBYTE, PDWORD );
extern PRASBUNDLEGETSTATISTICS g_pRasBundleGetStatistics;

typedef DWORD (APIENTRY * PRASPORTGETSTATISTICSEX)( HANDLE, HPORT, PBYTE, PDWORD );
extern PRASPORTGETSTATISTICSEX g_pRasPortGetStatisticsEx;

typedef DWORD (APIENTRY * PRASBUNDLEGETSTATISTICSEX)(HANDLE, HPORT, PBYTE, PDWORD);
extern PRASBUNDLEGETSTATISTICSEX g_pRasBundleGetStatisticsEx;

typedef DWORD (APIENTRY * PRASPORTRECEIVE)( HPORT, PBYTE, PDWORD, DWORD, HANDLE );
extern PRASPORTRECEIVE g_pRasPortReceive;

typedef DWORD (APIENTRY * PRASPORTRECEIVEEX ) ( HPORT, PBYTE, PDWORD );
extern PRASPORTRECEIVEEX g_pRasPortReceiveEx;

typedef DWORD (APIENTRY * PRASPORTSEND)( HPORT, PBYTE, DWORD );
extern PRASPORTSEND g_pRasPortSend;

typedef DWORD (APIENTRY * PRASPORTGETBUNDLE)(HANDLE,  HPORT, HBUNDLE* );
extern PRASPORTGETBUNDLE g_pRasPortGetBundle;

typedef DWORD (APIENTRY * PRASGETDEVCONFIG)( HANDLE, HPORT, PCHAR, PBYTE, DWORD* );
extern PRASGETDEVCONFIG g_pRasGetDevConfig;
extern PRASGETDEVCONFIG g_pRasGetDevConfigEx;

typedef DWORD (APIENTRY * PRASSETDEVCONFIG)(HPORT, PCHAR, PBYTE, DWORD );
extern PRASSETDEVCONFIG g_pRasSetDevConfig;

typedef DWORD (APIENTRY * PRASPORTOPEN)(PCHAR, HPORT*, HANDLE);
extern PRASPORTOPEN g_pRasPortOpen;

typedef DWORD (APIENTRY * PRASPORTREGISTERSLIP)(HPORT, DWORD, DWORD, BOOL,
                                                WCHAR*, WCHAR*, WCHAR*, WCHAR*);
extern PRASPORTREGISTERSLIP g_pRasPortRegisterSlip;

typedef DWORD (APIENTRY * PRASALLOCATEROUTE)(HPORT, RAS_PROTOCOLTYPE, BOOL,
                                             RASMAN_ROUTEINFO*);
extern PRASALLOCATEROUTE g_pRasAllocateRoute;

typedef DWORD (APIENTRY * PRASACTIVATEROUTE)(HPORT, RAS_PROTOCOLTYPE,
                                            RASMAN_ROUTEINFO*, PROTOCOL_CONFIG_INFO*);
extern PRASACTIVATEROUTE g_pRasActivateRoute;

typedef DWORD (APIENTRY * PRASACTIVATEROUTEEX)(HPORT, RAS_PROTOCOLTYPE, DWORD,
                                               RASMAN_ROUTEINFO*, PROTOCOL_CONFIG_INFO*);
extern PRASACTIVATEROUTEEX g_pRasActivateRouteEx;

typedef DWORD (APIENTRY * PRASDEVICESETINFO)(HPORT, PCHAR, PCHAR, RASMAN_DEVICEINFO*);
extern PRASDEVICESETINFO g_pRasDeviceSetInfo;

typedef DWORD (APIENTRY * PRASDEVICECONNECT)(HPORT, PCHAR, PCHAR, DWORD, HANDLE);
extern PRASDEVICECONNECT g_pRasDeviceConnect;

typedef DWORD (APIENTRY * PRASPORTSETINFO)(HPORT, RASMAN_PORTINFO*);
extern PRASPORTSETINFO g_pRasPortSetInfo;

typedef DWORD (APIENTRY * PRASPORTCLOSE)(HPORT);
extern PRASPORTCLOSE g_pRasPortClose;

typedef DWORD (APIENTRY * PRASPORTLISTEN)(HPORT, DWORD, HANDLE);
extern PRASPORTLISTEN g_pRasPortListen;

typedef DWORD (APIENTRY * PRASPORTCONNECTCOMPLETE)(HPORT);
extern PRASPORTCONNECTCOMPLETE g_pRasPortConnectComplete;

typedef DWORD (APIENTRY * PRASPORTDISCONNECT)(HPORT, HANDLE);
extern PRASPORTDISCONNECT g_pRasPortDisconnect;

typedef DWORD (APIENTRY * PRASREQUESTNOTIFICATION)(HPORT, HANDLE);
extern PRASREQUESTNOTIFICATION g_pRasRequestNotification;

typedef DWORD (APIENTRY * PRASPORTENUMPROTOCOLS)(HANDLE, HPORT, RAS_PROTOCOLS*, PDWORD);
extern PRASPORTENUMPROTOCOLS g_pRasPortEnumProtocols;

typedef DWORD (APIENTRY * PRASPORTSETFRAMING)(HPORT, RAS_FRAMING,
                                             RASMAN_PPPFEATURES*, RASMAN_PPPFEATURES*);
extern PRASPORTSETFRAMING g_pRasPortSetFraming;

typedef DWORD (APIENTRY * PRASPORTSETFRAMINGEX)(HPORT, RAS_FRAMING_INFO*);
extern PRASPORTSETFRAMINGEX g_pRasPortSetFramingEx;

typedef DWORD (APIENTRY * PRASSETCACHEDCREDENTIALS)(PCHAR, PCHAR, PCHAR);
extern PRASSETCACHEDCREDENTIALS g_pRasSetCachedCredentials;

typedef DWORD (APIENTRY * PRASGETDIALPARAMS)(DWORD, LPDWORD, PRAS_DIALPARAMS);
extern PRASGETDIALPARAMS g_pRasGetDialParams;

typedef DWORD (APIENTRY * PRASSETDIALPARAMS)(DWORD, DWORD, PRAS_DIALPARAMS, BOOL);
extern PRASSETDIALPARAMS g_pRasSetDialParams;

typedef DWORD (APIENTRY * PRASCREATECONNECTION) ( HCONN *, DWORD, DWORD *, DWORD *,
                                                  DWORD, GUID *, CHAR *, CHAR *,CHAR *, 
                                                  CHAR *);
extern PRASCREATECONNECTION g_pRasCreateConnection;

typedef DWORD (APIENTRY * PRASDESTROYCONNECTION)(HCONN);
extern PRASDESTROYCONNECTION g_pRasDestroyConnection;

typedef DWORD (APIENTRY * PRASCONNECTIONENUM)(HANDLE, HCONN*, LPDWORD, LPDWORD);
extern PRASCONNECTIONENUM g_pRasConnectionEnum;

typedef DWORD (APIENTRY * PRASADDCONNECTIONPORT)(HCONN, HPORT, DWORD);
extern PRASADDCONNECTIONPORT g_pRasAddConnectionPort;

typedef DWORD (APIENTRY * PRASENUMCONNECTIONPORTS)(HANDLE, HCONN, RASMAN_PORT*,
                                                   LPDWORD, LPDWORD);
extern PRASENUMCONNECTIONPORTS g_pRasEnumConnectionPorts;

typedef DWORD (APIENTRY * PRASGETCONNECTIONPARAMS)(HCONN, PRAS_CONNECTIONPARAMS);
extern PRASGETCONNECTIONPARAMS g_pRasGetConnectionParams;

typedef DWORD (APIENTRY * PRASSETCONNECTIONPARAMS)(HCONN, PRAS_CONNECTIONPARAMS);
extern PRASSETCONNECTIONPARAMS g_pRasSetConnectionParams;

typedef DWORD (APIENTRY * PRASGETCONNECTIONUSERDATA)(HCONN, DWORD, PBYTE, LPDWORD);
extern PRASGETCONNECTIONUSERDATA g_pRasGetConnectionUserData;

typedef DWORD (APIENTRY * PRASSETCONNECTIONUSERDATA)(HCONN, DWORD, PBYTE, DWORD);
extern PRASSETCONNECTIONUSERDATA g_pRasSetConnectionUserData;

typedef DWORD (APIENTRY * PRASGETPORTUSERDATA)(HCONN, DWORD, PBYTE, LPDWORD);
extern PRASGETPORTUSERDATA g_pRasGetPortUserData;

typedef DWORD (APIENTRY * PRASSETPORTUSERDATA)(HCONN, DWORD, PBYTE, DWORD);
extern PRASSETPORTUSERDATA g_pRasSetPortUserData;

typedef DWORD (APIENTRY * PRASADDNOTIFICATION)(HCONN, HANDLE, DWORD);
extern PRASADDNOTIFICATION g_pRasAddNotification;

typedef DWORD (APIENTRY * PRASSIGNALNEWCONNECTION)(HCONN);
extern PRASSIGNALNEWCONNECTION g_pRasSignalNewConnection;

typedef DWORD (APIENTRY * PRASPPPSTOP)(HPORT);
extern PRASPPPSTOP g_pRasPppStop;

typedef DWORD (APIENTRY * PRASPPPCALLBACK)(HPORT, CHAR*);
extern PRASPPPCALLBACK g_pRasPppCallback;

typedef DWORD (APIENTRY * PRASPPPCHANGEPASSWORD)(HPORT, CHAR*, CHAR*, CHAR*);
extern PRASPPPCHANGEPASSWORD g_pRasPppChangePassword;

typedef DWORD (APIENTRY * PRASPPPGETINFO)(HPORT, PPP_MESSAGE*);
extern PRASPPPGETINFO g_pRasPppGetInfo;

typedef DWORD (APIENTRY * PRASPPPRETRY)(HPORT, CHAR*, CHAR*, CHAR*);
extern PRASPPPRETRY g_pRasPppRetry;

typedef DWORD (APIENTRY *PRASPPPSTART)(HPORT, CHAR*, CHAR*, CHAR*, CHAR*, LUID*,
                                       PPP_CONFIG_INFO*, LPVOID, CHAR*,
                                       BOOL, HANDLE, DWORD, BOOL, PPP_BAPPARAMS*,
                                       BOOL, DWORD, DWORD);
extern PRASPPPSTART g_pRasPppStart;

typedef DWORD (APIENTRY * PRASSETIOCOMPLETIONPORT)(HPORT, HANDLE, PRAS_OVERLAPPED,
                                                   PRAS_OVERLAPPED, PRAS_OVERLAPPED,
                                                   PRAS_OVERLAPPED);
extern PRASSETIOCOMPLETIONPORT g_pRasSetIoCompletionPort;

typedef DWORD (APIENTRY * PRASSENDPPPMESSAGETORASMAN) (PPP_MESSAGE *pPppMessage);
extern PRASSENDPPPMESSAGETORASMAN g_pRasSendPppMessageToRasman;

typedef DWORD (APIENTRY * PRASSETRASDIALINFO) (HPORT, CHAR*, CHAR*, CHAR *, DWORD, PBYTE);
extern PRASSETRASDIALINFO g_pRasSetRasdialInfo;

typedef DWORD (APIENTRY * PRASRPCCONNECT ) ( LPCTSTR, HANDLE * );
extern PRASRPCCONNECT g_pRasRpcConnect;

typedef DWORD (APIENTRY * PRASRPCDISCONNECT ) ( HANDLE * );
extern PRASRPCDISCONNECT g_pRasRpcDisconnect;

typedef DWORD (APIENTRY * PRASNUMPORTOPEN ) ();
extern PRASNUMPORTOPEN g_pRasNumPortOpen;

typedef DWORD (APIENTRY *PRASREFCONNECTION ) ( HCONN, BOOL, DWORD * );
extern PRASREFCONNECTION g_pRasRefConnection;

typedef DWORD (APIENTRY *PRASPPPGETEAPINFO) ( HCONN, DWORD, DWORD *, DWORD *,
                                              DWORD *, PBYTE);
extern PRASPPPGETEAPINFO g_pRasPppGetEapInfo;

typedef DWORD( APIENTRY *PRASPPPSETEAPINFO) (HPORT, DWORD, DWORD, PBYTE);
extern PRASPPPSETEAPINFO g_pRasPppSetEapInfo;

typedef DWORD(APIENTRY *PRASFINDPREREQUISITEENTRY) (HCONN, HCONN *);
extern PRASFINDPREREQUISITEENTRY g_pRasFindPrerequisiteEntry;

typedef DWORD(APIENTRY *PRASPORTOPENEX) (CHAR *, DWORD, HPORT *, HANDLE, DWORD *);
extern PRASPORTOPENEX g_pRasPortOpenEx;

typedef DWORD(APIENTRY *PRASLINKGETSTATISTICS) (HANDLE, HCONN, DWORD, PBYTE);
extern PRASLINKGETSTATISTICS g_pRasLinkGetStatistics;

typedef DWORD(APIENTRY *PRASCONNECTIONGETSTATISTICS) (HANDLE, HCONN, PBYTE);
extern PRASCONNECTIONGETSTATISTICS g_pRasConnectionGetStatistics;

typedef DWORD(APIENTRY *PRASGETHPORTFROMCONNECTION) (HANDLE, HCONN, HPORT *);
extern PRASGETHPORTFROMCONNECTION g_pRasGetHportFromConnection;

typedef DWORD(APIENTRY *PRASRPCBIND) (LPWSTR, HANDLE *);
extern PRASRPCBIND g_pRasRpcBind;

typedef DWORD(APIENTRY *PRASREFERENCECUSTOMCOUNT) (HCONN ,BOOL, CHAR *, CHAR *, DWORD *);
extern PRASREFERENCECUSTOMCOUNT g_pRasReferenceCustomCount;

typedef DWORD(APIENTRY *PRASGETHCONNFROMENTRY) (HCONN *, CHAR *, CHAR *);
extern PRASGETHCONNFROMENTRY g_pRasGetHConnFromEntry;

typedef DWORD(APIENTRY *PRASGETDEVICENAME) (RASDEVICETYPE, CHAR *);
extern PRASGETDEVICENAME g_pRasGetDeviceName;

typedef DWORD(APIENTRY *PRASENABLEIPSEC) (HPORT, BOOL, BOOL, RAS_L2TP_ENCRYPTION);
extern PRASENABLEIPSEC g_pRasEnableIpSec;

typedef DWORD(APIENTRY *PRASISIPSECENABLED) (HPORT, BOOL *);
extern PRASISIPSECENABLED g_pRasIsIpSecEnabled;

typedef DWORD(APIENTRY *PRASGETEAPUSERINFO) (HANDLE, PBYTE, DWORD *, GUID *, BOOL, DWORD);
extern PRASGETEAPUSERINFO g_pRasGetEapUserInfo;
 
typedef DWORD(APIENTRY *PRASSETEAPUSERINFO) (HANDLE, GUID *, PBYTE, DWORD, BOOL, BOOL, DWORD);
extern PRASSETEAPUSERINFO g_pRasSetEapUserInfo;

typedef DWORD(APIENTRY *PRASSETEAPLOGONINFO) (HPORT, BOOL, RASEAPINFO *);
extern PRASSETEAPLOGONINFO g_pRasSetEapLogonInfo;

typedef DWORD(APIENTRY *PRASSTARTRASAUTOIFREQUIRED) (VOID);
extern PRASSTARTRASAUTOIFREQUIRED g_pRasStartRasAutoIfRequired;

/* MPRAPI.DLL entry points
*/
#ifndef RASMERGE
extern HINSTANCE g_hMpradminDll;
#endif

typedef DWORD (APIENTRY * PMPRADMININTERFACECREATE)(HANDLE,DWORD,LPBYTE,HANDLE*);
extern PMPRADMININTERFACECREATE g_pMprAdminInterfaceCreate;
typedef DWORD (APIENTRY * PMPRADMININTERFACEDELETE)(HANDLE,HANDLE);
extern PMPRADMININTERFACEDELETE g_pMprAdminInterfaceDelete;
typedef DWORD (APIENTRY * PMPRADMININTERFACEGETHANDLE)(HANDLE,LPWSTR,HANDLE*,BOOL);
extern PMPRADMININTERFACEGETHANDLE g_pMprAdminInterfaceGetHandle;
typedef DWORD (APIENTRY * PMPRADMININTERFACEGETCREDENTIALS)(LPWSTR,LPWSTR,LPWSTR,LPWSTR,LPWSTR);
extern PMPRADMININTERFACEGETCREDENTIALS g_pMprAdminInterfaceGetCredentials;
typedef DWORD (APIENTRY * PMPRADMININTERFACEGETCREDENTIALSEX)(HANDLE,HANDLE,DWORD,LPBYTE *);
extern PMPRADMININTERFACEGETCREDENTIALSEX g_pMprAdminInterfaceGetCredentialsEx;
typedef DWORD (APIENTRY * PMPRADMININTERFACESETCREDENTIALS)(LPWSTR,LPWSTR,LPWSTR,LPWSTR,LPWSTR);
extern PMPRADMININTERFACESETCREDENTIALS g_pMprAdminInterfaceSetCredentials;
typedef DWORD (APIENTRY * PMPRADMININTERFACESETCREDENTIALSEX)(HANDLE,HANDLE,DWORD,LPBYTE);
extern PMPRADMININTERFACESETCREDENTIALSEX g_pMprAdminInterfaceSetCredentialsEx;
typedef DWORD (APIENTRY * PMPRADMINBUFFERFREE)(LPVOID);
extern PMPRADMINBUFFERFREE  g_pMprAdminBufferFree;
typedef DWORD (APIENTRY * PMPRADMININTERFACETRANSPORTADD)(HANDLE,HANDLE,DWORD,LPBYTE,DWORD);
extern PMPRADMININTERFACETRANSPORTADD g_pMprAdminInterfaceTransportAdd;
typedef DWORD (APIENTRY * PMPRADMININTERFACETRANSPORTSETINFO)(HANDLE,HANDLE,DWORD,LPBYTE,DWORD);
extern PMPRADMININTERFACETRANSPORTSETINFO g_pMprAdminInterfaceTransportSetInfo;
typedef DWORD (APIENTRY * PMPRADMINSERVERDISCONNECT)(HANDLE);
extern PMPRADMINSERVERDISCONNECT g_pMprAdminServerDisconnect;
typedef DWORD (APIENTRY * PMPRADMINSERVERCONNECT)(LPWSTR,HANDLE*);
extern PMPRADMINSERVERCONNECT g_pMprAdminServerConnect;
typedef DWORD (APIENTRY * PMPRADMINTRANSPORTSETINFO)(HANDLE,DWORD,LPBYTE,DWORD,LPBYTE,DWORD);
extern PMPRADMINTRANSPORTSETINFO g_pMprAdminTransportSetInfo;
typedef DWORD (APIENTRY * PRASADMINSERVERCONNECT)(LPWSTR, HANDLE*);
extern PRASADMINSERVERCONNECT g_pRasAdminServerConnect;
typedef DWORD (APIENTRY * PRASADMINSERVERDISCONNECT)(HANDLE);
extern PRASADMINSERVERDISCONNECT g_pRasAdminServerDisconnect;
typedef DWORD (APIENTRY * PRASADMINBUFFERFREE)(LPVOID);
extern PRASADMINBUFFERFREE g_pRasAdminBufferFree;
typedef DWORD (APIENTRY * PRASADMINCONNECTIONENUM)(HANDLE, DWORD, LPBYTE*, DWORD, LPDWORD, LPDWORD, LPDWORD);
extern PRASADMINCONNECTIONENUM g_pRasAdminConnectionEnum;
typedef DWORD (APIENTRY * PRASADMINCONNECTIONGETINFO)(HANDLE, DWORD, HANDLE, LPBYTE*);
extern PRASADMINCONNECTIONGETINFO g_pRasAdminConnectionGetInfo;
typedef DWORD (APIENTRY * PRASADMINPORTENUM)(HANDLE, DWORD, HANDLE, LPBYTE*, DWORD, LPDWORD, LPDWORD, LPDWORD);
extern PRASADMINPORTENUM g_pRasAdminPortEnum;
typedef DWORD (APIENTRY * PRASADMINPORTGETINFO)(HANDLE, DWORD, HANDLE, LPBYTE*);
extern PRASADMINPORTGETINFO g_pRasAdminPortGetInfo;
typedef DWORD (APIENTRY * PRASADMINPORTDISCONNECT)(HANDLE, HANDLE);
extern PRASADMINPORTDISCONNECT g_pRasAdminPortDisconnect;
typedef DWORD (APIENTRY * PRASADMINUSERSETINFO)(LPCWSTR,LPCWSTR,DWORD,LPBYTE);
extern PRASADMINUSERSETINFO g_pRasAdminUserSetInfo;
typedef DWORD (APIENTRY * PMPRADMINUSERSERVERCONNECT)(PWCHAR, BOOL, PHANDLE);
extern PMPRADMINUSERSERVERCONNECT g_pMprAdminUserServerConnect;
typedef DWORD (APIENTRY * PMPRADMINUSERSERVERDISCONNECT)(HANDLE);
extern PMPRADMINUSERSERVERDISCONNECT g_pMprAdminUserServerDisconnect;
typedef DWORD (APIENTRY * PMPRADMINUSEROPEN)(HANDLE, PWCHAR, PHANDLE);
extern PMPRADMINUSEROPEN g_pMprAdminUserOpen;
typedef DWORD (APIENTRY * PMPRADMINUSERCLOSE)(HANDLE);
extern PMPRADMINUSERCLOSE g_pMprAdminUserClose;
typedef DWORD (APIENTRY * PMPRADMINUSERWRITE)(HANDLE, DWORD, LPBYTE);
extern PMPRADMINUSERWRITE g_pMprAdminUserWrite;
typedef DWORD (APIENTRY * PMPRCONFIGBUFFERFREE)(LPVOID);
extern PMPRCONFIGBUFFERFREE g_pMprConfigBufferFree;
typedef DWORD (APIENTRY * PMPRCONFIGSERVERCONNECT)(LPWSTR,HANDLE*);
extern PMPRCONFIGSERVERCONNECT g_pMprConfigServerConnect;
typedef VOID (APIENTRY * PMPRCONFIGSERVERDISCONNECT)(HANDLE);
extern PMPRCONFIGSERVERDISCONNECT g_pMprConfigServerDisconnect;
typedef DWORD (APIENTRY * PMPRCONFIGTRANSPORTGETINFO)(HANDLE,HANDLE,LPBYTE*,LPDWORD,LPBYTE*,LPDWORD,LPWSTR*);
extern PMPRCONFIGTRANSPORTGETINFO g_pMprConfigTransportGetInfo;
typedef DWORD (APIENTRY * PMPRCONFIGTRANSPORTSETINFO)(HANDLE,HANDLE,LPBYTE,DWORD,LPBYTE,DWORD,LPWSTR);
extern PMPRCONFIGTRANSPORTSETINFO g_pMprConfigTransportSetInfo;
typedef DWORD (APIENTRY * PMPRCONFIGTRANSPORTGETHANDLE)(HANDLE,DWORD,HANDLE*);
extern PMPRCONFIGTRANSPORTGETHANDLE g_pMprConfigTransportGetHandle;
typedef DWORD (APIENTRY * PMPRCONFIGINTERFACECREATE)(HANDLE,DWORD,LPBYTE,HANDLE*);
extern PMPRCONFIGINTERFACECREATE g_pMprConfigInterfaceCreate;
typedef DWORD (APIENTRY * PMPRCONFIGINTERFACEDELETE)(HANDLE,HANDLE);
extern PMPRCONFIGINTERFACEDELETE g_pMprConfigInterfaceDelete;
typedef DWORD (APIENTRY * PMPRCONFIGINTERFACEGETHANDLE)(HANDLE,LPWSTR,HANDLE*);
extern PMPRCONFIGINTERFACEGETHANDLE g_pMprConfigInterfaceGetHandle;
typedef DWORD (APIENTRY * PMPRCONFIGINTERFACEENUM)(HANDLE,DWORD,LPBYTE*,DWORD,LPDWORD,LPDWORD,LPDWORD);
extern PMPRCONFIGINTERFACEENUM g_pMprConfigInterfaceEnum;
typedef DWORD (APIENTRY * PMPRCONFIGINTERFACETRANSPORTADD)(HANDLE,HANDLE,DWORD,LPWSTR,LPBYTE,DWORD,HANDLE*);
extern PMPRCONFIGINTERFACETRANSPORTADD g_pMprConfigInterfaceTransportAdd;
typedef DWORD (APIENTRY * PMPRCONFIGINTERFACETRANSPORTGETINFO)(HANDLE,HANDLE,HANDLE,LPBYTE*,LPDWORD);
extern PMPRCONFIGINTERFACETRANSPORTGETINFO g_pMprConfigInterfaceTransportGetInfo;
typedef DWORD (APIENTRY * PMPRCONFIGINTERFACETRANSPORTSETINFO)(HANDLE,HANDLE,HANDLE,LPBYTE,DWORD);
extern PMPRCONFIGINTERFACETRANSPORTSETINFO g_pMprConfigInterfaceTransportSetInfo;
typedef DWORD (APIENTRY * PMPRCONFIGINTERFACETRANSPORTGETHANDLE)(HANDLE,HANDLE,DWORD,HANDLE*);
extern PMPRCONFIGINTERFACETRANSPORTGETHANDLE g_pMprConfigInterfaceTransportGetHandle;
typedef DWORD (APIENTRY * PMPRINFOCREATE)(DWORD,LPVOID*);
extern PMPRINFOCREATE g_pMprInfoCreate;
typedef DWORD (APIENTRY * PMPRINFODELETE)(LPVOID);
extern PMPRINFODELETE g_pMprInfoDelete;
typedef DWORD (APIENTRY * PMPRINFODUPLICATE)(LPVOID,LPVOID*);
extern PMPRINFODUPLICATE g_pMprInfoDuplicate;
typedef DWORD (APIENTRY * PMPRINFOBLOCKADD)(LPVOID,DWORD,DWORD,DWORD,LPBYTE,LPVOID*);
extern PMPRINFOBLOCKADD g_pMprInfoBlockAdd;
typedef DWORD (APIENTRY * PMPRINFOBLOCKREMOVE)(LPVOID,DWORD,LPVOID*);
extern PMPRINFOBLOCKREMOVE g_pMprInfoBlockRemove;
typedef DWORD (APIENTRY * PMPRINFOBLOCKSET)(LPVOID,DWORD,DWORD,DWORD,LPBYTE,LPVOID*);
extern PMPRINFOBLOCKSET g_pMprInfoBlockSet;
typedef DWORD (APIENTRY * PMPRINFOBLOCKFIND)(LPVOID,DWORD,LPDWORD,LPDWORD,LPBYTE*);
extern PMPRINFOBLOCKFIND g_pMprInfoBlockFind;

//
// Miscellaneous entry points.
//
// These are included for consistency because they
// are remotable by the RAS RPC interface.
//
typedef DWORD (*PGETINSTALLEDPROTOCOLS)();
extern PGETINSTALLEDPROTOCOLS g_pGetInstalledProtocols;

typedef DWORD (*PGETINSTALLEDPROTOCOLSEX)(HANDLE, BOOL, BOOL, BOOL);
extern PGETINSTALLEDPROTOCOLSEX g_pGetInstalledProtocolsEx;

typedef DWORD (*PGETUSERPREFERENCES)(HANDLE, PBUSER*, DWORD);
extern PGETUSERPREFERENCES g_pGetUserPreferences;

typedef DWORD (*PSETUSERPREFERENCES)(HANDLE, PBUSER*, DWORD);
extern PSETUSERPREFERENCES g_pSetUserPreferences;

typedef DWORD (WINAPI *PGETSYSTEMDIRECTORY)(HANDLE, LPTSTR, UINT);
extern PGETSYSTEMDIRECTORY g_pGetSystemDirectory;

/*----------------------------------------------------------------------------
** Prototypes
**----------------------------------------------------------------------------
*/

BOOL
IsRasmanServiceRunning(
    void );

DWORD
LoadMpradminDll(
    void );

DWORD
LoadRasapi32Dll(
    void );

DWORD
LoadRasdlgDll(
    void );

DWORD
LoadRasmanDll(
    void );

#if 0

DWORD
LoadRasRpcDll(
    LPTSTR  lpszServer
    );

#endif    

BOOL
Rasapi32DllLoaded(
    void
    );

BOOL
RasRpcDllLoaded(
    void
    );

LPTSTR
RemoteGetServerName(
        HANDLE hConnection
        );

DWORD
RemoteGetServerVersion(
    HANDLE hConnection
    );

BOOL
IsRasRemoteConnection(
    HANDLE hConnection
    );

VOID
UnloadMpradminDll(
    void );

VOID
UnloadRasapi32Dll(
    void );

VOID
UnloadRasdlgDll(
    void );

VOID
UnloadRasmanDll(
    void );

DWORD
UnloadRasRpcDll(
    void );

DWORD
InitializeConnection(
    LPTSTR lpszServer,
    HANDLE *pHConnection);

VOID
UninitializeConnection(
    HANDLE hConnection);


DWORD
RemoteGetInstalledProtocols(
    HANDLE hConnection
    );

DWORD
RemoteGetInstalledProtocolsEx(
    HANDLE hConnection,
    BOOL fRouter,
    BOOL fRasCli,
    BOOL fRasSrv );

UINT WINAPI
RemoteGetSystemDirectory(
    HANDLE hConnection,
    LPTSTR lpBuffer,
    UINT uSize );

DWORD
RemoteGetUserPreferences(
    HANDLE hConnection,
    OUT PBUSER* pPbuser,
    IN DWORD dwMode );

DWORD APIENTRY
RemoteRasDeleteEntry(
    HANDLE hConnection,
    LPTSTR lpszPhonebook,
    LPTSTR lpszEntry );


DWORD APIENTRY
RemoteRasDeviceEnum(
    HANDLE hConnection,
    PCHAR pszDeviceType,
    PBYTE lpDevices,
    PDWORD pwcbDevices,
    PDWORD pwcDevices );

DWORD APIENTRY
RemoteRasEnumConnections(
    HANDLE hConnection,
    LPRASCONN lpRasConn,
    LPDWORD lpdwcbRasConn,
    LPDWORD lpdwcRasConn );

DWORD APIENTRY
RemoteRasGetCountryInfo(
    HANDLE hConnection,
    LPRASCTRYINFO lpRasCountryInfo,
    LPDWORD lpdwcbRasCountryInfo );


DWORD APIENTRY
RemoteRasGetDevConfig(
    HANDLE hConnection,
    HPORT hport,
    PCHAR pszDeviceType,
    PBYTE lpConfig,
    LPDWORD lpcbConfig );

DWORD APIENTRY
RemoteRasGetErrorString(
    HANDLE hConnection,
    UINT uErrorValue,
    LPTSTR lpszBuf,
    DWORD cbBuf );


DWORD APIENTRY
RemoteRasPortEnum(
    HANDLE hConnection,
    PBYTE lpPorts,
    PDWORD pdwcbPorts,
    PDWORD pdwcPorts );

DWORD
RemoteSetUserPreferences(
    HANDLE hConnection,
    OUT PBUSER* pPbuser,
    IN DWORD dwMode );

DWORD APIENTRY
RemoteRasPortGetInfo(
    HANDLE hConnection,
        HPORT porthandle,
        PBYTE buffer,
        PDWORD pSize );

UINT WINAPI
RasGetSystemDirectory(
    HANDLE hConnection,
    LPTSTR lpBuffer,
    UINT uSize
    );

#endif // _LOADDLLS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\inc\list.h ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File:    list.h
//============================================================================


#ifndef InitializeListHead


//
//  Doubly-linked list manipulation routines.  Implemented as macros
//  but logically these are procedures.
//

//
//  VOID
//  InitializeListHead(
//      PLIST_ENTRY ListHead
//      );
//

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

//
//  BOOLEAN
//  IsListEmpty(
//      PLIST_ENTRY ListHead
//      );
//

#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))

//
//  PLIST_ENTRY
//  RemoveHeadList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveHeadList(ListHead) \
    (ListHead)->Flink;\
    {RemoveEntryList((ListHead)->Flink)}

//
//  PLIST_ENTRY
//  RemoveTailList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveTailList(ListHead) \
    (ListHead)->Blink;\
    {RemoveEntryList((ListHead)->Blink)}

//
//  VOID
//  RemoveEntryList(
//      PLIST_ENTRY Entry
//      );
//

#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }

//
//  VOID
//  InsertTailList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }

//
//  VOID
//  InsertHeadList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
    }

//
//
//  PSINGLE_LIST_ENTRY
//  PopEntryList(
//      PSINGLE_LIST_ENTRY ListHead
//      );
//

#define PopEntryList(ListHead) \
    (ListHead)->Next;\
    {\
        PSINGLE_LIST_ENTRY FirstEntry;\
        FirstEntry = (ListHead)->Next;\
        if (FirstEntry != NULL) {     \
            (ListHead)->Next = FirstEntry->Next;\
        }                             \
    }


//
//  VOID
//  PushEntryList(
//      PSINGLE_LIST_ENTRY ListHead,
//      PSINGLE_LIST_ENTRY Entry
//      );
//

#define PushEntryList(ListHead,Entry) \
    (Entry)->Next = (ListHead)->Next; \
    (ListHead)->Next = (Entry)


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\inc\mem.h ===
//
// Copyright (c) Microsoft Corporation 1993-1995
//
// mem.h
//
// Memory management functions.
//
// History:
//  09-27-94 ScottH     Partially taken from commctrl
//  04-29-95 ScottH     Taken from briefcase and cleaned up
//

#ifndef _MEM_H_
#define _MEM_H_

//
// Memory routines
//

#ifdef WIN32
//
// These macros are used in our controls, that in 32 bits we simply call
// LocalAlloc as to have the memory associated with the process that created
// it and as such will be cleaned up if the process goes away.
//

LPVOID  PUBLIC MemAlloc(HANDLE hheap, DWORD cb);
LPVOID  PUBLIC MemReAlloc(HANDLE hheap, LPVOID pb, DWORD cb);
BOOL    PUBLIC MemFree(HANDLE hheap, LPVOID pb);
DWORD   PUBLIC MemSize(HANDLE hheap, LPVOID pb);

#else // WIN32

// In 16 bit code we need the Allocs to go from our heap code as we do not
// want to limit them to 64K of data.  If we have some type of notification of
// 16 bit application termination, We may want to see if we can
// dedicate different heaps for different processes to cleanup...

#define MemAlloc(hheap, cb)       Alloc(cb)  /* calls to verify heap exists */
#define MemReAlloc(hheap, pb, cb) ReAlloc(pb, cb)
#define MemFree(hheap, pb)        Free(pb)
#define MemSize(hheap, pb)        GetSize((LPCVOID)pb)

#endif // WIN32

//  Mem_Terminate() must be called before the app/dll is terminated.
//
void PUBLIC Mem_Terminate();

//
// Non-shared memory allocation
//

//      void * GAlloc(DWORD cbBytes)
//
//          Alloc a chunk of memory.  Initialize to zero.
//
#define GAlloc(cbBytes)         GlobalAlloc(GPTR, cbBytes)

//      void * GReAlloc(void * pv, DWORD cbNewSize)
//
//          Realloc memory.  If pv is NULL, then this function will do
//          an alloc for you.  Initializes new portion to zero.
//
#define GReAlloc(pv, cbNewSize) GlobalReAlloc(pv, cbNewSize, GMEM_MOVEABLE | GMEM_ZEROINIT)

//      void GFree(void *pv)
//
//          Free pv if it is nonzero.
//
#define GFree(pv)               ((pv) ? GlobalFree(pv) : (void)0)

//      DWORD GGetSize(void *pv)
//
//          Get the size of a block allocated by GAlloc()
//
#define GGetSize(pv)            GlobalSize(pv)

//      type * GAllocType(type)                     (macro)
//
//          Alloc some memory the size of <type> and return 
//          pointer to <type>.
//
#define GAllocType(type)                (type *)GAlloc(sizeof(type))

//      type * GAllocArray(type, DWORD cNum)        (macro)
//
//          Alloc an array of data the size of <type>.  Returns
//          a pointer to <type>.
//
#define GAllocArray(type, cNum)          (type *)GAlloc(sizeof(type) * (cNum))

//      type * GReAllocArray(type, void * pb, DWORD cNum);
//
//          Realloc an array of <type>.  Returns a pointer to
//          <type>.  The returned pointer may differ from the 
//          given <pb> parameter.
//
#define GReAllocArray(type, pb, cNum)    (type *)GReAlloc(pb, sizeof(type) * (cNum))

//      (Re)allocates *ppszBuf and copies psz into *ppszBuf.  If
//      *ppszBuf is NULL, this function allocates memory to hold
//      psz.  If *ppszBuf is non-NULL, this function reallocates
//      memory to hold psz.  If psz is NULL, this function frees
//      *ppszBuf.
//
//      Returns TRUE if successful, FALSE if not.
//
BOOL    PUBLIC GSetString(LPSTR * ppszBuf, LPCSTR psz);

//      This function is like GSetString except it concatentates
//      psz onto *ppszBuf.
//
BOOL    PUBLIC GCatString(LPSTR * ppszBuf, LPCSTR psz);


//
// Shared memory allocation functions.
//
#ifndef NOSHAREDHEAP

//      PVOID SharedAlloc(DWORD cb);
//
//          Alloc a chunk of memory.  Initialize to zero.
//
PVOID   PUBLIC SharedAlloc(DWORD cb);                              

//      PVOID SharedReAlloc(PVOID pv, DWORD cb);
//
//          Realloc memory.  If pv is NULL, then this function will do
//          an alloc for you.  Initializes new portion to zero.
//
PVOID   PUBLIC SharedReAlloc(PVOID pv, DWORD cb);

//      void SharedFree(PVOID pv);
//
//          Free pv if it is nonzero.
//
void    PUBLIC _SharedFree(PVOID pv);
#define SharedFree(pv)                  ((pv) ? _SharedFree(pv) : (void)0)

//      DWORD SharedGetSize(PVOID pv);
//
//          Get the size of a block allocated by SharedAlloc()
//      
DWORD   PUBLIC SharedGetSize(PVOID pv);                      


//      type * SharedAllocType(type);                    (macro)
//
//          Alloc some memory the size of <type> and return 
//          pointer to <type>.
//
#define SharedAllocType(type)           (type *)SharedAlloc(sizeof(type))

//      type * SharedAllocArray(type, DWORD cNum);       (macro)
//
//          Alloc an array of data the size of <type>.  Returns
//          a pointer to <type>.
//
#define SharedAllocArray(type, cNum)    (type *)SharedAlloc(sizeof(type) * (cNum))

//      type * SharedReAllocArray(type, void * pb, DWORD cNum);
//
//          Realloc an array of <type>.  Returns a pointer to
//          <type>.  The returned pointer may differ from the 
//          given <pb> parameter.
//
#define SharedReAllocArray(type, pb, cNum) (type *)SharedReAlloc(pb, sizeof(type) * (cNum))

//      (Re)allocates *ppszBuf and copies psz into *ppszBuf.  If
//      *ppszBuf is NULL, this function allocates memory to hold
//      psz.  If *ppszBuf is non-NULL, this function reallocates
//      memory to hold psz.  If psz is NULL, this function frees
//      *ppszBuf.
//
//      Returns TRUE if successful, FALSE if not.
//
BOOL    PUBLIC SharedSetString(LPSTR * ppszBuf, LPCSTR psz);

#else  // NOSHAREDHEAP

#define SharedAlloc(cbBytes)            GAlloc(cbBytes)
#define SharedReAlloc(pv, cb)           GReAlloc(pv, cb)
#define SharedFree(pv)                  GFree(pv)
#define SharedGetSize(pv)               GGetSize(pv)
#define SharedAllocType(type)           (type *)SharedAlloc(sizeof(type))
#define SharedAllocArray(type, cNum)    (type *)SharedAlloc(sizeof(type) * (cNum))
#define SharedReAllocArray(type, pb, cNum) (type *)SharedReAlloc(pb, sizeof(type) * (cNum))
#define SharedSetString(ppszBuf, psz)   GSetString(ppszBuf, psz)

#endif // NOSHAREDHEAP



#ifndef NODA
//
// Structure Array
//
#define SA_ERR      ((DWORD)(-1))
#define SA_APPEND   NULL

typedef struct _SA FAR * HSA;                                            
typedef HSA *            PHSA;
                                                                          
BOOL    PUBLIC SACreateEx(PHSA phsa, DWORD cbItem, DWORD cItemGrow, HANDLE hheap, DWORD dwFlags);
#define        SACreate(phsa, cbItem, cItemGrow)    SACreateEx(phsa, cbItem, cItemGrow, NULL, SAF_DEFAULT)

// Flags for SACreate
#define SAF_DEFAULT     0x0000
#define SAF_SHARED      0x0001
#define SAF_HEAP        0x0002

typedef void (CALLBACK *PFNSAFREE)(LPVOID pv, LPARAM lParam);

BOOL    PUBLIC SADestroyEx(HSA hsa, PFNSAFREE pfnFree, LPARAM lParam);
#define        SADestroy(hsa)           SADestroyEx(hsa, NULL, 0)

BOOL    PUBLIC SAGetItem(HSA hsa, DWORD iItem, LPVOID pitem);        
BOOL    PUBLIC SAGetItemPtr(HSA hsa, DWORD iItem, LPVOID * ppv);
BOOL    PUBLIC SASetItem(HSA hsa, DWORD iItem, LPVOID pitem);        
BOOL    PUBLIC SAInsertItem(HSA hsa, LPDWORD pindex, LPVOID pitem);     
BOOL    PUBLIC SADeleteItem(HSA hsa, DWORD iItem);                      
BOOL    PUBLIC SADeleteAllItems(HSA hsa);                         
#define        SAGetCount(hsa)          (*(DWORD FAR*)(hsa))             
    
//                                                                      
// Pointer Array
//
#define PA_ERR      ((DWORD)(-1))
#define PA_APPEND   NULL

typedef struct _PA FAR * HPA;                                            
typedef HPA *            PHPA;
                                                                          
BOOL    PUBLIC PACreateEx(PHPA phpa, DWORD cItemGrow, HANDLE hheap, DWORD dwFlags);
#define        PACreate(phpa, cItemGrow)    (PACreateEx(phpa, cItemGrow, NULL, PAF_DEFAULT))

// Flags for PACreate
#define PAF_DEFAULT     0x0000
#define PAF_SHARED      0x0001
#define PAF_HEAP        0x0002

typedef void (CALLBACK *PFNPAFREE)(LPVOID pv, LPARAM lParam);

BOOL    PUBLIC PADestroyEx(HPA hpa, PFNPAFREE pfnFree, LPARAM lParam);
#define        PADestroy(hpa)           PADestroyEx(hpa, NULL, 0)

BOOL    PUBLIC PAClone(PHPA phpa, HPA hpa);                    
BOOL    PUBLIC PAGetPtr(HPA hpa, DWORD i, LPVOID * ppv);                          
BOOL    PUBLIC PAGetPtrIndex(HPA hpa, LPVOID pv, LPDWORD pindex);               
BOOL    PUBLIC PAGrow(HPA pdpa, DWORD cp);                           
BOOL    PUBLIC PASetPtr(HPA hpa, DWORD i, LPVOID p);             
BOOL    PUBLIC PAInsertPtr(HPA hpa, LPDWORD pindex, LPVOID pv);          
LPVOID  PUBLIC PADeletePtr(HPA hpa, DWORD i);
BOOL    PUBLIC PADeleteAllPtrsEx(HPA hpa, PFNPAFREE pfnFree, LPARAM lParam);
#define        PADeleteAllPtrs(hpa)     PADeleteAllPtrsEx(hpa, NULL, 0)
#define        PAGetCount(hpa)          (*(DWORD FAR*)(hpa))
#define        PAGetPtrPtr(hpa)         (*((LPVOID FAR* FAR*)((BYTE FAR*)(hpa) + 2*sizeof(DWORD))))
#define        PAFastGetPtr(hpa, i)     (PAGetPtrPtr(hpa)[i])  

typedef int (CALLBACK *PFNPACOMPARE)(LPVOID p1, LPVOID p2, LPARAM lParam);
                                                                          
BOOL   PUBLIC PASort(HPA hpa, PFNPACOMPARE pfnCompare, LPARAM lParam);
                                                                          
// Search array.  If PAS_SORTED, then array is assumed to be sorted      
// according to pfnCompare, and binary search algorithm is used.          
// Otherwise, linear search is used.                                      
//                                                                        
// Searching starts at iStart (0 to start search at beginning).          
//                                                                        
// PAS_INSERTBEFORE/AFTER govern what happens if an exact match is not   
// found.  If neither are specified, this function returns -1 if no exact 
// match is found.  Otherwise, the index of the item before or after the  
// closest (including exact) match is returned.                           
//                                                                        
// Search option flags                                                    
//                                                                        
#define PAS_SORTED             0x0001                                	  
#define PAS_INSERTBEFORE       0x0002                                    
#define PAS_INSERTAFTER        0x0004                                    
                                                                          
DWORD PUBLIC PASearch(HPA hpa, LPVOID pFind, DWORD iStart,
              PFNPACOMPARE pfnCompare,
              LPARAM lParam, UINT options);
#endif // NODA

#endif // _MEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\inc\ipaddr.h ===
/* Copyright (c) 1991, Microsoft Corporation, all rights reserved

    ipaddr.h - TCP/IP Address custom control, global definitions

    November 10, 1992   - Greg Strange
*/

#ifndef _IPADDR_H_
#define _IPADDR_H_


// Messages sent to IPAddress controls

#define IP_CLEARADDRESS WM_USER+100 // no parameters
#define IP_SETADDRESS   WM_USER+101 // lparam = TCP/IP address
#define IP_GETADDRESS   WM_USER+102 // lresult = TCP/IP address
#define IP_SETRANGE     WM_USER+103 // wparam = field, lparam = range
#define IP_SETFOCUS     WM_USER+104 // wparam = field
#define IP_ISBLANK      WM_USER+105 // no parameters


// The following is a useful macro for passing the range values in the
// IP_SETRANGE message.

#define MAKERANGE(low,high) ((LPARAM)(WORD)(((BYTE)(high)<<8)+(BYTE)(low)))

// And this is a useful macro for making the IP Address to be passed
// as a LPARAM.

#define MAKEIPADDRESS(b1,b2,b3,b4) ((LPARAM)(((DWORD)(b1)<<24)+((DWORD)(b2)<<16)+((DWORD)(b3)<<8)+((DWORD)(b4))))

// Get individual number

#define FIRST_IPADDRESS(x)  ((x>>24) & 0xff)
#define SECOND_IPADDRESS(x) ((x>>16) & 0xff)
#define THIRD_IPADDRESS(x)  ((x>>8) & 0xff)
#define FOURTH_IPADDRESS(x) (x & 0xff)

// Use this function to force the ip address entered to 
// be contiguous (series of 1's followed by a series of 0's).
// This is useful for entering valid submasks
//
// Returns NO_ERROR if successful, error code otherwise
//
DWORD APIENTRY
IpAddr_ForceContiguous(
    HWND hwndIpAddr );

// Call this function once during initialization.

int FAR PASCAL
IpAddrInit(
    IN HANDLE hInstance,
    IN DWORD  dwErrorTitle,
    IN DWORD  dwBadIpAddrRange );


#endif // _IPADDR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\inc\netguid.h ===
#pragma once

#include <initguid.h>
#include <devguid.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\inc\nouiutil.h ===
/* Copyright (c) 1995, Microsoft Corporation, all rights reserved
**
** nouiutil.h
** No UI helper routines (no HWNDs required)
** Public header
**
** 08/25/95 Steve Cobb
*/

#pragma once
#ifndef _NOUIUTIL_H_
#define _NOUIUTIL_H_


/* Maximum length of string returned by LToT without terminating null.
*/
#define MAXLTOTLEN 11

/* Heap allocation macros allowing easy substitution of alternate heap.  These
** are used by the other utility sections.
*/
#ifndef EXCL_HEAPDEFS
#define Malloc(c)    (void*)GlobalAlloc(0,(c))
#define Realloc(p,c) (void*)GlobalReAlloc((p),(c),GMEM_MOVEABLE)
#define Free(p)      (void*)GlobalFree(p)
#endif

/* Bits returned by GetInstalledProtocols.
*/
#define NP_Nbf      0x1
#define NP_Ipx      0x2
#define NP_Ip       0x4
#define NP_Netmon   0x8


/* Definition of comparison function required by ShellSort and
** ShellSortIndirect.
** The comparison is essentially <arg1> - <arg2>, thus the function should
** return negative if the first item is less than the second, zero
** if the items are equal, and positive if the first item is greater
** than the second.
*/
typedef INT (*PFNCOMPARE)( VOID*, VOID* );

/* Linked list library.
*/
#ifndef EXCL_DTL_H
#include <dtl.h>
#endif

/* International formatting library.
*/
#ifndef EXCL_INTL_H
#include <intl.h>
#endif

/* User preference library.
*/
#ifndef EXCL_PBUSER_H
#include <pbuser.h>
#endif

/* RasApi utility library.
*/
#ifndef EXCL_RAUTIL_H
#include <rautil.h>
#endif

/* RasMan utility library.
*/
#ifndef EXCL_RMUTIL_H
#include <rmutil.h>
#endif

/* RAS DLL entrypoint loader library.
*/
#ifndef EXCL_LOADDLLS_H
#include <loaddlls.h>
#endif

/* EAP configuration utility library.
*/
#ifndef EXCL_EAPCFG_H
#include <eapcfg.h>
#endif

/* Node types used by MultiSz calls.
*/
#define NT_Psz 1
#define NT_Kv  2

//
// Defs to determine which entrypoint to load
//
#define CUSTOM_RASDIALDLG           0
#define CUSTOM_RASENTRYDLG          1
#define CUSTOM_RASDIAL              2
#define CUSTOM_RASDELETEENTRYNOTIFY 3

/*----------------------------------------------------------------------------
** Datatypes
**----------------------------------------------------------------------------
*/

/* Key/Value string pair.  The contents of a Kv node.
*/
#define KEYVALUE struct tagKEYVALUE
KEYVALUE
{
    TCHAR* pszKey;
    TCHAR* pszValue;
};

/* RAS-relevant Unimodem settings.
*/
#define UNIMODEMINFO struct tagUNIMODEMINFO
UNIMODEMINFO
{
    BOOL  fHwFlow;
    BOOL  fEc;
    BOOL  fEcc;
    DWORD dwBps;
    BOOL  fSpeaker;
    BOOL  fOperatorDial;
    BOOL  fUnimodemPreTerminal;
    DWORD dwModemProtocol;      // selected modem protocol
    DTLLIST *pListProtocols;    // list of available protocols
};


/*----------------------------------------------------------------------------
** Prototypes
**----------------------------------------------------------------------------
*/

INT
ComparePszNode(
    IN DTLNODE* pNode1,
    IN DTLNODE* pNode2 );

DWORD
CreateDirectoriesOnPath(
    LPTSTR                  pszPath,
    LPSECURITY_ATTRIBUTES   psa);

DTLNODE*
CreateKvNode(
    IN LPCTSTR pszKey,
    IN LPCTSTR pszValue );

DTLNODE*
CreatePszNode(
    IN LPCTSTR psz );

VOID
DestroyKvNode(
    IN DTLNODE* pdtlnode );

VOID
DestroyPszNode(
    IN DTLNODE* pdtlnode );

BOOL
DeviceAndPortFromPsz(
    IN  TCHAR*  pszDP,
    OUT TCHAR** ppszDevice,
    OUT TCHAR** ppszPort );

DTLNODE*
DuplicateKvNode(
    IN DTLNODE* pdtlnode );

DTLNODE*
DuplicatePszNode(
    IN DTLNODE* pdtlnode );

BOOL
FFileExists(
    IN TCHAR* pszPath );

BOOL
FIsTcpipInstalled();

BOOL
FIsUserAdminOrPowerUser();

VOID*
Free0(
    VOID* p );

//for utilsys.c
TCHAR*
GetComputer(
    void );

TCHAR*
GetLogonDomain(
    void );

TCHAR*
GetLogonUser(
    void );
    
BOOL
IsFirewallAvailablePlatform(
    void);

BOOL
IsAdvancedServerPlatform(
    void);

BOOL
IsPersonalPlatform(
    void);

BOOL
IsStandaloneWKS(
    void);

BOOL
IsConsumerPlatform(
    void);
    
//end of definitions for utilsys.c

DWORD
GetInstalledProtocols(
    VOID );

DWORD
GetInstalledProtocolsEx(
    HANDLE hConnection,
    BOOL fRouter,
    BOOL fRasCli,
    BOOL fRasSrv );

VOID
GetRegBinary(
    IN HKEY hkey,
    IN TCHAR* pszName,
    OUT BYTE** ppbResult,
    OUT DWORD* pcbResult );

VOID
GetRegDword(
    IN HKEY hkey,
    IN TCHAR* pszName,
    OUT DWORD* pdwResult );

DWORD
GetRegExpandSz(
    IN HKEY hkey,
    IN TCHAR* pszName,
    OUT TCHAR** ppszResult );

DWORD
GetRegMultiSz(
    IN HKEY hkey,
    IN TCHAR* pszName,
    IN OUT DTLLIST** ppListResult,
    IN DWORD dwNodeType );

DWORD
GetRegSz(
    IN HKEY hkey,
    IN TCHAR* pszName,
    OUT TCHAR** ppszResult );

DWORD
GetRegSzz(
    IN HKEY hkey,
    IN TCHAR* pszName,
    OUT TCHAR** ppszResult );

CHAR
HexChar(
    IN BYTE byte );

BYTE
HexValue(
    IN CHAR byte );

void
IpHostAddrToPsz(
    IN  DWORD   dwAddr,
    OUT LPTSTR  pszBuffer );

BOOL
IsAllWhite(
    IN LPCTSTR psz );

BOOL
IsNullTerminatedA(
    IN CHAR* psz,
    IN DWORD dwSize );

DWORD
IpPszToHostAddr(
    IN  LPCTSTR cp );

DWORD
GetRasUnimodemBlob(
    IN  HANDLE hConnection,
    IN  HPORT  hport,
    IN  CHAR*  pszDeviceType,
    OUT BYTE** ppBlob,
    OUT DWORD* pcbBlob );

DWORD
GetRasUnimodemBlobEx(
    IN  HANDLE hConnection,
    IN  HPORT  hport,
    IN  CHAR*  pszDeviceType,
    IN  BOOL   fGlobal,
    OUT BYTE** ppBlob,
    OUT DWORD* pcbBlob );

VOID
GetRasUnimodemInfo(
    IN  HANDLE        hConnection,
    IN  HPORT         hport,
    IN  CHAR*         pszDeviceType,
    OUT UNIMODEMINFO* pInfo );

TCHAR*
LToT(
    LONG   lValue,
    TCHAR* pszBuf,
    INT    nRadix );

TCHAR*
PszFromDeviceAndPort(
    IN TCHAR* pszDevice,
    IN TCHAR* pszPort );

LPCTSTR
PszLoadStringPcch (
        HINSTANCE   hinst,
        UINT        unId,
        int*        pcch);

LPCTSTR
PszLoadString (
        HINSTANCE   hinst,
        UINT        unId);

DWORD
RegDeleteTree(
    IN HKEY RootKey,
    IN TCHAR* SubKeyName );

BOOL
RegValueExists(
    IN HKEY hkey,
    IN TCHAR* pszValue );

BOOL
RestartComputer();

TCHAR*
StripPath(
    IN TCHAR* pszPath );

LONG
TToL(
    TCHAR *pszBuf );

TCHAR*
PszFromError(
    IN DWORD dwError );

TCHAR*
PszFromId(
    IN HINSTANCE hInstance,
    IN DWORD     dwStringId );

BOOL
RestartComputer();

VOID
SanitizeUnimodemBlob(
    IN OUT BYTE* pBlob );

VOID
SetDefaultUnimodemInfo(
    OUT UNIMODEMINFO* pInfo );

HFONT
SetFont(
    HWND   hwndCtrl,
    TCHAR* pszFaceName,
    BYTE   bfPitchAndFamily,
    INT    nPointSize,
    BOOL   fUnderline,
    BOOL   fStrikeout,
    BOOL   fItalic,
    BOOL   fBold );

DWORD
SetRegDword(
    IN HKEY hkey,
    IN TCHAR* pszName,
    IN DWORD dwValue );

DWORD
SetRegMultiSz(
    IN HKEY hkey,
    IN TCHAR* pszName,
    IN DTLLIST* pListValues,
    IN DWORD dwNodeType );

DWORD
SetRegSz(
    IN HKEY hkey,
    IN TCHAR* pszName,
    IN TCHAR* pszValue );

DWORD
SetRegSzz(
    IN HKEY hkey,
    IN TCHAR* pszName,
    IN TCHAR* pszValue );

DWORD
ShellSort(
    IN VOID*        pItemTable,
    IN DWORD        dwItemSize,
    IN DWORD        dwItemCount,
    IN PFNCOMPARE   pfnCompare );

VOID
ShellSortIndirect(
    IN VOID*        pItemTable,
    IN VOID**       ppItemTable,
    IN DWORD        dwItemSize,
    IN DWORD        dwItemCount,
    IN PFNCOMPARE   pfnCompare );

TCHAR*
StrDup(
    LPCTSTR psz );

CHAR*
StrDupAFromT(
    LPCTSTR psz );

CHAR*
StrDupAFromTAnsi(
    LPCTSTR psz);
    
TCHAR*
StrDupTFromA(
    LPCSTR psz );

TCHAR*
StrDupTFromW(
    LPCWSTR psz );

WCHAR*
StrDupWFromA(
    LPCSTR psz );

TCHAR*
StrDupTFromAUsingAnsiEncoding(
    LPCSTR psz );
    
WCHAR*
StrDupWFromAUsingAnsiEncoding(
    LPCSTR psz );
    
WCHAR*
StrDupWFromT(
    LPCTSTR psz );

DWORD
StrCpyWFromA(
    WCHAR* pszDst,
    LPCSTR pszSrc,
    DWORD dwDstChars);
    
DWORD
StrCpyAFromW(
    LPSTR pszDst,
    LPCWSTR pszSrc, 
    DWORD dwDstChars);
    
DWORD
StrCpyWFromAUsingAnsiEncoding(
    WCHAR* pszDst,
    LPCSTR pszSrc,
    DWORD dwDstChars);
    
DWORD
StrCpyAFromWUsingAnsiEncoding(
    LPSTR pszDst,
    LPCWSTR pszSrc, 
    DWORD dwDstChars);
    
int
StrNCmpA(
    IN CHAR* psz1,
    IN CHAR* psz2,
    IN INT   nLen );

CHAR*
StrStrA(
    IN CHAR* psz1,
    IN CHAR* psz2 );

VOID
UnimodemInfoFromBlob(
    IN  BYTE*         pBlob,
    OUT UNIMODEMINFO* pInfo );

VOID
UnimodemInfoToBlob(
    IN     UNIMODEMINFO* pInfo,
    IN OUT BYTE*         pBlob );

TCHAR*
UnNull(
    TCHAR* psz );

#endif // _NOUIUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\inc\pbuser.h ===
/* Copyright (c) 1995, Microsoft Corporation, all rights reserved
**
** pbuser.h
** Remote Access phonebook user preference library
** Public header
**
** 06/20/95 Steve Cobb
*/

#ifndef _PBUSER_H_
#define _PBUSER_H_

/*----------------------------------------------------------------------------
** Constants
**----------------------------------------------------------------------------
*/

/* User preference modes
*/
#define UPM_Normal 0
#define UPM_Logon  1
#define UPM_Router 2


/* User preference key and values.
*/
#define REGKEY_HkcuOldRas                TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Network\\RemoteAccess")
#define REGKEY_HkcuOldRasParent          TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Network")
#define REGKEY_HkcuOldRasRoot            TEXT("RemoteAccess")
#define REGKEY_HkuOldRasLogon            TEXT(".DEFAULT\\Software\\Microsoft\\RAS Phonebook")
#define REGKEY_HkcuRas                   TEXT("Software\\Microsoft\\RAS Phonebook")
#define REGKEY_HkuRasLogon               TEXT(".DEFAULT\\Software\\Microsoft\\RAS Logon Phonebook")
#define REGKEY_HklmRouter                TEXT("Software\\Microsoft\\Router Phonebook")
#define REGKEY_Callback                  TEXT("Callback")
#define REGKEY_Location                  TEXT("Location")
#define REGVAL_szNumber                  TEXT("Number")
#define REGVAL_dwDeviceType              TEXT("DeviceType")
#define REGVAL_dwPhonebookMode           TEXT("PhonebookMode")
#define REGVAL_szUsePersonalPhonebook    TEXT("UsePersonalPhonebook")
#define REGVAL_szPersonalPhonebookPath   TEXT("PersonalPhonebookPath")
#define REGVAL_szPersonalPhonebookFile   TEXT("PersonalPhonebookFile")
#define REGVAL_szAlternatePhonebookPath  TEXT("AlternatePhonebookPath")
#define REGVAL_fOperatorDial             TEXT("OperatorDial")
#define REGVAL_fPreviewPhoneNumber       TEXT("PreviewPhoneNumber")
#define REGVAL_fUseLocation              TEXT("UseLocation")
#define REGVAL_fShowLights               TEXT("ShowLights")
#define REGVAL_fShowConnectStatus        TEXT("ShowConnectStatus")
#define REGVAL_fNewEntryWizard           TEXT("NewEntryWizard")
#define REGVAL_dwRedialAttempts          TEXT("RedialAttempts")
#define REGVAL_dwRedialSeconds           TEXT("RedialSeconds")
#define REGVAL_dwIdleDisconnectSeconds   TEXT("IdleHangUpSeconds")
#define REGVAL_dwCallbackMode            TEXT("CallbackMode")
#define REGVAL_mszPhonebooks             TEXT("Phonebooks")
#define REGVAL_mszAreaCodes              TEXT("AreaCodes")
#define REGVAL_mszPrefixes               TEXT("Prefixes")
#define REGVAL_mszSuffixes               TEXT("Suffixes")
#define REGVAL_szLastCallbackByCaller    TEXT("LastCallbackByCaller")
#define REGVAL_dwPrefix                  TEXT("Prefix")
#define REGVAL_dwSuffix                  TEXT("Suffix")
#define REGVAL_dwXWindow                 TEXT("WindowX")
#define REGVAL_dwYWindow                 TEXT("WindowY")
#define REGVAL_szDefaultEntry            TEXT("DefaultEntry")
#define REGVAL_fCloseOnDial              TEXT("CloseOnDial")
#define REGVAL_fAllowLogonPhonebookEdits TEXT("AllowLogonPhonebookEdits")
#define REGVAL_fAllowLogonLocationEdits  TEXT("AllowLogonLocationEdits")
#define REGVAL_fUseAreaAndCountry        TEXT("UseAreaAndCountry")
#define REGVAL_dwMode                    TEXT("Mode")
#define REGVAL_dwFlags                   TEXT("Flags")
#define REGVAL_dwX                       TEXT("x")
#define REGVAL_dwY                       TEXT("y")
#define REGVAL_dwCx                      TEXT("cx")
#define REGVAL_dwCy                      TEXT("cy")
#define REGVAL_dwCxCol1                  TEXT("cxCol1")
#define REGVAL_dwStartPage               TEXT("StartPage")
#define REGVAL_dwXDlg                    TEXT("xDlg")
#define REGVAL_dwYDlg                    TEXT("yDlg")
#define REGVAL_dwCxDlgCol1               TEXT("cxDlgCol1")
#define REGVAL_dwCxDlgCol2               TEXT("cxDlgCol2")
#define REGVAL_szLastDevice              TEXT("LastDevice")
#define REGVAL_mszDeviceList             TEXT("DeviceList")
#define REGVAL_fSkipConnectComplete      TEXT("SkipConnectComplete")
#define REGVAL_fRedialOnLinkFailure      TEXT("RedialOnLinkFailure")
#define REGVAL_fExpandAutoDialQuery      TEXT("ExpandAutoDialQuery")
#define REGVAL_fPopupOnTopWhenRedialing  TEXT("PopupOnTopWhenRedialing")
#define REGVAL_dwVersion                 TEXT("Version")


/* Callback modes (see dwCallbackMode below).
*/
#define CBM_No    0
#define CBM_Maybe 1
#define CBM_Yes   2


/* Phonebook modes (see dwPhonebookMode below).
*/
#define PBM_System    0
#define PBM_Personal  1
#define PBM_Alternate 2
#define PBM_Router    3


/*----------------------------------------------------------------------------
** Datatypes
**----------------------------------------------------------------------------
*/

/* Information about a callback number.  See 'PBUSER.pdtllistCallback'.  Note
** that 'dwDeviceType' is a PBK PBDEVICETYPE enumeration cast to a DWORD.
*/
#define CALLBACKINFO struct tagCALLBACKINFO
CALLBACKINFO
{
    TCHAR* pszPortName;
    TCHAR* pszDeviceName;
    TCHAR* pszNumber;
    DWORD  dwDeviceType;
};


/* Information associated with a TAPI location number.
*/
#define LOCATIONINFO struct tagLOCATIONINFO
LOCATIONINFO
{
    DWORD  dwLocationId;
    DWORD  iPrefix;
    DWORD  iSuffix;
};


/* User preference information read from the "CURRENT_USER" registry.  This
** information applies to all "normal" user phonebooks plus the system
** phonebook.  The router phonebook may work differently.
*/
#define PBUSER struct tagPBUSER
PBUSER
{
    /* Appearance page.
    */
    BOOL fOperatorDial;
    BOOL fPreviewPhoneNumber;
    BOOL fUseLocation;
    BOOL fShowLights;
    BOOL fShowConnectStatus;
    BOOL fCloseOnDial;
    BOOL fAllowLogonPhonebookEdits;
    BOOL fAllowLogonLocationEdits;
    BOOL fSkipConnectComplete;
    BOOL fNewEntryWizard;

    /* Auto-dial page.
    */
    DWORD dwRedialAttempts;
    DWORD dwRedialSeconds;
    DWORD dwIdleDisconnectSeconds;
    BOOL  fRedialOnLinkFailure;
    BOOL  fPopupOnTopWhenRedialing;
    BOOL  fExpandAutoDialQuery;

    /* Callback page.
    **
    ** This list is of CALLBACKINFO.
    */
    DWORD    dwCallbackMode;
    DTLLIST* pdtllistCallback;
    TCHAR*   pszLastCallbackByCaller;

    /* Phone list page.
    */
    DWORD    dwPhonebookMode;
    TCHAR*   pszPersonalFile;
    TCHAR*   pszAlternatePath;
    DTLLIST* pdtllistPhonebooks;

    /* Area code strings, in MRU order.
    */
    DTLLIST* pdtllistAreaCodes;
    BOOL     fUseAreaAndCountry;

    /* Prefix/suffix information, i.e. the ordered string lists and the
    ** settings for a particular TAPI location.
    */
    DTLLIST* pdtllistPrefixes;
    DTLLIST* pdtllistSuffixes;
    DTLLIST* pdtllistLocations;

    /* Phonebook window position and last entry selected used by RASPHONE.EXE.
    */
    DWORD  dwXPhonebook;
    DWORD  dwYPhonebook;
    TCHAR* pszDefaultEntry;

    /* Set true if the structure has been initialized.
    */
    BOOL fInitialized;

    /* Set true if something's changed since the structure was read.
    */
    BOOL fDirty;
};


/*----------------------------------------------------------------------------
** Prototypes
**----------------------------------------------------------------------------
*/

DTLNODE*
CreateLocationNode(
    IN DWORD dwLocationId,
    IN DWORD iPrefix,
    IN DWORD iSuffix );

DTLNODE*
CreateCallbackNode(
    IN TCHAR* pszPortName,
    IN TCHAR* pszDeviceName,
    IN TCHAR* pszNumber,
    IN DWORD  dwDeviceType );

VOID
DestroyLocationNode(
    IN DTLNODE* pNode );

VOID
DestroyCallbackNode(
    IN DTLNODE* pNode );

VOID
DestroyUserPreferences(
    IN PBUSER* pUser );

DTLNODE*
DuplicateLocationNode(
    IN DTLNODE* pNode );

DWORD
GetUserPreferences(
    IN HANDLE   hConnection,
    OUT PBUSER* pUser,
    IN  DWORD   dwMode );

DWORD
SetUserPreferences(
    IN HANDLE  hConnection,
    IN PBUSER* pUser,
    IN DWORD   dwMode );

// These two are provided as an optimization.  
// They write directly to the registry.
DWORD GetUserManualDialEnabling (
    IN OUT PBOOL pbEnabled,
    IN DWORD dwMode );
    
DWORD SetUserManualDialEnabling (
    IN BOOL bEnable,
    IN DWORD dwMode );

#endif // _PBUSER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\inc\pbk.h ===
// Copyright (c) 1995, Microsoft Corporation, all rights reserved
//
// pbk.h
// Remote Access phonebook file (.PBK) library
// Public header
//
// 06/20/95 Steve Cobb


#ifndef _PBK_H_
#define _PBK_H_


#include <windows.h>  // Win32 core
#include <nouiutil.h> // No-HWNDs utility library
#include <ras.h>      // Win32 RAS
#include <raserror.h> // Win32 RAS error codes
#include <rasfile.h>  // RAS configuration file library
#include <rasman.h>   // RAS Manager library
#include <rpc.h>      // UUID support
#include <rasapip.h>

//----------------------------------------------------------------------------
// Constants
//----------------------------------------------------------------------------

#define GLOBALSECTIONNAME    "."
#define GLOBALSECTIONNAMENEW ".GlobalSection"
#define PREFIXSECTIONNAME    ".Prefix"
#define SUFFIXSECTIONNAME    ".Suffix"

#define GROUPID_Media          "MEDIA="
#define GROUPKEY_Media         "MEDIA"
#define GROUPID_Device         "DEVICE="
#define GROUPKEY_Device        "DEVICE"
#define GROUPID_NetComponents  "NETCOMPONENTS="
#define GROUPKEY_NetComponents "NETCOMPONENTS"

// Project-specific maximums
//
#define RAS_MaxRedialCount  999999999
#define RAS_RedialPause10m  600         // 600 seconds=10 min

// Pbport flags
//
#define PBP_F_PptpDevice    0x00000001
#define PBP_F_L2tpDevice    0x00000002
#define PBP_F_NullModem     0x00000004
#define PBP_F_BogusDevice   0x00000008      // pmay: 233287
#define PBP_F_PPPoEDevice   0x00000010      // gangz:whistler 345068

// ReadPhonebookFile flags
//
#define RPBF_ReadOnly    0x00000001
#define RPBF_HeadersOnly 0x00000002
#define RPBF_NoList      0x00000004
#define RPBF_NoCreate    0x00000008
#define RPBF_Router      0x00000010
#define RPBF_NoUser      0x00000020
#define RPBF_HeaderType  0x00000040
#define RPBF_AllUserPbk  0x00000080  // If no path, then global .pbk 346918

// PBENTRY.dwUsage
#define PBK_ENTRY_USE_F_Internet    0x1     // connection to Internet

// Base protocol definitions (see dwBaseProtocol).
//
#define BP_Ppp      1
#define BP_Slip     2
#define BP_Ras      3

#ifdef AMB

// Authentication strategy definitions (see dwAuthentication).
//
#define AS_Default    -1
#define AS_PppThenAmb 0
#define AS_AmbThenPpp 1
#define AS_PppOnly    2
#define AS_AmbOnly    3

#endif

// Net protocol bit definitions (see dwfExcludedProtocols)
//
// (The NP_* definitions have moved to nouiutil.h with the
//  GetInstalledProtocols routine)

// IP address source definitions (see dwIpAddressSource)
//
#define ASRC_ServerAssigned  1 // For router means "the ones in NCPA"
#define ASRC_RequireSpecific 2
#define ASRC_None            3 // Router only

// Security restrictions on authentication (see dwAuthRestrictions)
//
// Note: AR_AuthTerminal is defunct and is not written to the phonebook by the
//       new library.  It is, however, read and translated into AR_AuthAny,
//       fAutoLogon=0, and an after dialing terminal.
//
// Note: The AR_AuthXXX ordinals are replaced with AR_F_AuthXXX flags in NT5
//       to support the fact that these flags are not mutually exclusive.
//       You'll know if you need to upgrade the dwAuthRestrictions variable
//       because old phone books have this value set to 0 or have some of the
//       bottom 3 bits set.
//
// Note: The AR_F_AuthCustom bit is used a little differently.  It indicates
//       that the settings are made in "advanced" mode rather than "typical"
//       mode.  In "typical" mode the bits MUST correspond to one of the
//       AR_F_TypicalXxx sets.
//
// Note: The AR_F_AuthEAP bit is mutually exclusive of all other bits, except
//       the AR_F_AuthCustom bit.  When AR_F_AuthEap is specified without the
//       AR_F_AuthCustom bit EAP_TLS_PROTOCOL should be assumed.
//
// Note: The AR_F_AuthW95MSCHAP flag will not be set in the UI unless
//       AR_F_AuthMSCHAP is set.  This is a usability decision to steer user
//       away from misinterpreting the meaning of the W95 bit.
//
// The old scalar values (which should no eliminated from all non-PBK-upgrade
// code).
//
#define AR_AuthAny         0  // Upgrade to AR_F_TypicalUnsecure
#define AR_AuthTerminal    1  // Eliminate during upgrade
#define AR_AuthEncrypted   2  // Upgrade to AR_F_TypicalSecure
#define AR_AuthMsEncrypted 3  // Upgrade to AR_F_AuthMSCHAP
#define AR_AuthCustom      4  // Upgrade ORs in AR_F_AuthEAP

// The new bitmask style flags.
//
#define AR_F_AuthPAP       0x00000008
#define AR_F_AuthSPAP      0x00000010
#define AR_F_AuthMD5CHAP   0x00000020
#define AR_F_AuthMSCHAP    0x00000040
#define AR_F_AuthEAP       0x00000080  // See note above
#define AR_F_AuthCustom    0x00000100  // See note above
#define AR_F_AuthMSCHAP2   0x00000200
#define AR_F_AuthW95MSCHAP 0x00000400  // See note above

// the bitmask for IPSec Policy
#define AR_F_IpSecPSK               0x1
#define AR_F_IpSecUserCerts         0x2
#define AR_F_IpSecSpecificCerts     0x4

#define AR_F_AuthAnyMSCHAP (AR_F_AuthMSCHAP | AR_F_AuthW95MSCHAP | AR_F_AuthMSCHAP2)
#define AR_F_AuthNoMPPE    (AR_F_AuthPAP | AR_F_AuthSPAP | AR_F_AuthMD5CHAP)

// "Typical" authentication setting masks.  See 'dwAuthRestrictions'.
//
#define AR_F_TypicalUnsecure   (AR_F_AuthPAP | AR_F_AuthSPAP | AR_F_AuthMD5CHAP | AR_F_AuthMSCHAP | AR_F_AuthMSCHAP2)
#define AR_F_TypicalSecure     (AR_F_AuthMD5CHAP | AR_F_AuthMSCHAP | AR_F_AuthMSCHAP2)
#define AR_F_TypicalCardOrCert (AR_F_AuthEAP)

// "Typical" authentication setting constants.  See 'dwTypicalAuth'.
//
#define TA_Unsecure   1
#define TA_Secure     2
#define TA_CardOrCert 3

// Script mode (see dwScriptMode)
//
#define SM_None               0
#define SM_Terminal           1
#define SM_ScriptWithTerminal 2
#define SM_ScriptOnly         3

// Miscellaneous "no value" constants.
//
#define XN_None  0   // No X25 network
#define CPW_None -1  // No cached password

// Description field.  Move to ras.h if/when supported by
// RasGet/SetEntryProperties API.
//
#define RAS_MaxDescription 200

// 'OverridePref' bits.  Set indicates the corresponding value read from the
// phonebook should be used.  Clear indicates the global user preference
// should be used.
//
#define RASOR_RedialAttempts          0x00000001 // Always set in NT5
#define RASOR_RedialSeconds           0x00000002 // Always set in NT5
#define RASOR_IdleDisconnectSeconds   0x00000004 // Always set in NT5
#define RASOR_RedialOnLinkFailure     0x00000008 // Always set in NT5
#define RASOR_PopupOnTopWhenRedialing 0x00000010
#define RASOR_CallbackMode            0x00000020

// 'DwDataEncryption' codes.  These are now bitmask-ish for the convenience of
// the UI in building capability masks, though more than one bit will never be
// set in 'dwDataEncryption'.
//
#define DE_None          0x00000000 // Do not encrypt
#define DE_IfPossible    0x00000008 // Request encryption but none OK
#define DE_Require       0x00000100 // Require encryption of any strength
#define DE_RequireMax    0x00000200 // Require maximum strength encryption

// The following bit values are now defunct and are converted during phonebook
// upgrade to one of the above set.  References should be eliminated from
// non-PBK code.
//
#define DE_Mppe40bit    0x00000001 // Old DE_Weak. Setting for "Always encrypt data"
#define DE_Mppe128bit   0x00000002 // Old De_Strong. Setting for "Always encrypt data"
#define DE_IpsecDefault 0x00000004 // Setting for "Always encrypt data" for l2tp
#define DE_VpnAlways    0x00000010 // Setting for vpn conn to "Always encrypt data"
#define DE_PhysAlways   (DE_Mppe40bit | DE_Mppe128bit)

// 'dwDnsFlags' settings
//
// Used to determine the dns suffix registration behavior for an entry
//
// When 'dwDnsFlags' is 0, it means 'do not register'
//
#define DNS_RegPrimary         0x1     // register w/ primary domain suffix
#define DNS_RegPerConnection   0x2     // register w/ per-connection suffix
#define DNS_RegDhcpInform      0x4     // register w/ dhcp informed suffix
#define DNS_RegDefault         (DNS_RegPrimary)

// 'dwIpNbtFlags' settings
//
// Used to determine the whether to enable nbt over tcpip for the connection
//
#define PBK_ENTRY_IP_NBT_Enable 1

//-----------------------------------------------------------------------------
// Data types
//-----------------------------------------------------------------------------

// Provides shorthand to identify devices without re-parsing RAS Manager
// strings.  "Other" is anything not recognized as another specific type.
//
// Note: This datatype is stored in the registry preferences so the values
//       must not change over time.  For this reason, I have hard-coded the
//       value of each enumberated type.
//
typedef enum
_PBDEVICETYPE
{
    PBDT_None = 0,
    PBDT_Null = 1,
    PBDT_Other = 2,
    PBDT_Modem = 3,
    PBDT_Pad = 4,
    PBDT_Switch = 5,
    PBDT_Isdn = 6,
    PBDT_X25 = 7,
    PBDT_ComPort = 8,           // added for dcc wizard (nt5)
    PBDT_Irda = 10,             // added for nt5
    PBDT_Vpn = 11,
    PBDT_Serial = 12,
    PBDT_Atm = 13,
    PBDT_Parallel = 14,
    PBDT_Sonet = 15,
    PBDT_Sw56 = 16,
    PBDT_FrameRelay = 17,
    PBDT_PPPoE = 18
}
PBDEVICETYPE;


// RAS port information read from RASMAN.
//
// Each port (and link) is uniquely identified by port name.  If it were only
// that simple...
//
// In the old RAS model, the port name was the unique identifier that was
// presented to the user, and the user can have two same-type devices on two
// different ports.
//
// In TAPI/Unimodem, the "friendly" device name is the unique identifier
// that's presented to the user and the corresponding port is a property of
// the device.  If the port is changed and you dial it still finds the device
// you originally selected.  If you swap two devices on two ports it uses the
// one with the matching unique device name.  NT5 will follow this model.
//
typedef struct
_PBPORT
{
    // The port name is always unique, if configured.  Unconfigured port names
    // might not be unique.  This is never NULL.
    //
    TCHAR* pszPort;

    // Indicates the port is actually configured and not a remnant of an old
    // configuration read from the phonebook.
    //
    BOOL fConfigured;

    // The device name is the one from RASMAN when 'fConfigured' or the one
    // from the phonebook if not.  May be NULL with unconfigured ports as it
    // was not stored in old phonebooks.
    //
    TCHAR* pszDevice;

    // The media as it appears in the MEDIA= lines in the phonebook.  This is
    // usually but not always (for obscure historical reasons) the same as the
    // RASMAN media.  See PbMedia.
    //
    TCHAR* pszMedia;

    // Shorthand device type code derived from the RASMAN device type string.
    //
    PBDEVICETYPE pbdevicetype;

    // RASET_* entry type code of the link.  This is provided for the
    // convenience of the UI during link configuration.
    //
    DWORD dwType;

    // PBP_F_* flags that yield additional information concerning this port
    // that may be of use in rendering UI.
    DWORD dwFlags;

    // These are default settings read from RASMAN and are valid for modems
    // only.  See AppendPbportToList.
    //
    DWORD dwBpsDefault;
    BOOL fHwFlowDefault;
    BOOL fEcDefault;
    BOOL fEccDefault;
    DWORD fSpeakerDefault;
    DWORD dwModemProtDefault;
    DTLLIST* pListProtocols;

    // These are valid only for modems.
    //
    BOOL fScriptBeforeTerminal;
    BOOL fScriptBefore;
    TCHAR* pszScriptBefore;
}
PBPORT;


// Phonebook entry link phone number information.
//
typedef struct
_PBPHONE
{
    TCHAR* pszAreaCode;
    DWORD dwCountryCode;
    DWORD dwCountryID;
    TCHAR* pszPhoneNumber;
    BOOL fUseDialingRules;
    TCHAR* pszComment;
}
PBPHONE;


// Phonebook entry link information.  One per link, multiple per multi-link.
//
typedef struct
_PBLINK
{
    // Information about the port/device to which this link is attached.
    //
    PBPORT pbport;

    // These fields are set for modems only.  See SetDefaultModemSettings.
    //
    DWORD dwBps;
    BOOL fHwFlow;
    BOOL fEc;
    BOOL fEcc;
    DWORD fSpeaker;
    DWORD dwModemProtocol;          // pmay: 228565

    // These fields are set for ISDN only.  'LChannels' and 'fCompression' are
    // not used unless 'fProprietaryIsdn' is set.
    //
    BOOL fProprietaryIsdn;
    LONG lLineType;
    BOOL fFallback;
    BOOL fCompression;
    LONG lChannels;

    // Address and size of opaque device configuration block created/edited by
    // TAPI.  Currently, there are no TAPI devices that provide blob-editing
    // acceptable to RAS so these field are unused.
    //
    BYTE* pTapiBlob;
    DWORD cbTapiBlob;

    // Phone number information for the link.
    //
    // Note: The 'iLastSelectedPhone' field is used only when
    //       'fTryNextAlternateOnFail' is clear.  Otherwise, it is ignored and
    //       assumed 0 (top of list).  See bug 150958.
    //
    DTLLIST* pdtllistPhones;
    DWORD iLastSelectedPhone;
    BOOL fPromoteAlternates;
    BOOL fTryNextAlternateOnFail;

    // Indicates the link is enabled.  All links appearing in the file are
    // enabled.  This is provided for the convenience of the UI during link
    // configuration.
    //
    BOOL fEnabled;
}
PBLINK;


// Phonebook entry information.
//
typedef struct
_PBENTRY
{
    // Arbitrary name of entry and it's RASET_* entry type code.
    //
    TCHAR* pszEntryName;
    DWORD dwType;

    // General page fields.
    //
    DTLLIST* pdtllistLinks;
    BOOL fSharedPhoneNumbers;
    BOOL fGlobalDeviceSettings;         // whistler bug 281306
    BOOL fShowMonitorIconInTaskBar;
    TCHAR* pszPrerequisiteEntry;
    TCHAR* pszPrerequisitePbk;
    TCHAR* pszPreferredPort;
    TCHAR* pszPreferredDevice;

    //For XPSP1 664578, .Net 639551
    //
    DWORD  dwPreferredBps;             // Port Speed
    BOOL   fPreferredHwFlow;           // Hardware Flow Control           
    BOOL   fPreferredEc;               // Error control protocol
    BOOL   fPreferredEcc;              // Compression Control
    DWORD  fPreferredSpeaker;          // Enable Modem Speaker
    
    DWORD  dwPreferredModemProtocol;    //For whislter bug 402522

    // Options page fields.
    //
    // Note: Fields marked (1) are ignored when 'fAutoLogon' is set.  Field
    //       marked (2) *may* be set when 'fPreviewUserPw' is not also set.
    //       In this case it means to include the domain in the authentication
    //       but to to prompt only when the 'fPreviewUserPw' is set.
    //       Otherwise, "save PW" with a domain does not include the domain
    //       (MarkL problem) which is wrong.  See also bug 212963 and 261374.
    //
    BOOL fShowDialingProgress;
    BOOL fPreviewUserPw;          // See above: 1
    BOOL fPreviewDomain;          // See above: 1, 2
    BOOL fPreviewPhoneNumber;

    DWORD dwDialMode;
    DWORD dwDialPercent;
    DWORD dwDialSeconds;
    DWORD dwHangUpPercent;
    DWORD dwHangUpSeconds;

    // How the connection was configured to be used.  
    //
    DWORD dwUseFlags;      // See PBK_ENTRY_USE_F_*
    
    // IPSec Policy fields for whisler bug 193987 gangz
    //
    DWORD dwIpSecFlags;

    // These fields are used in place of the equivalent user preference only
    // when the corresponding 'dwfOverridePref' bit is set.  In NT5, the
    // indicated fields become always per-entry, i.e. the corresponding
    // override bits are always set.
    //
    DWORD dwfOverridePref;

    DWORD dwRedialAttempts;       // Always per-entry in NT5
    DWORD dwRedialSeconds;        // Always per-entry in NT5
    LONG lIdleDisconnectSeconds;  // Always per-entry in NT5
    BOOL fRedialOnLinkFailure;    // Always per-entry in NT5

    // Security page fields.
    //
    DWORD dwAuthRestrictions;
    DWORD dwVpnStrategy;          // Valid for vpn entries only.  see VS_xxx
    DWORD dwDataEncryption;
    BOOL fAutoLogon;              // See dependencies on Option page flags
    BOOL fUseRasCredentials;

    // The selection in the "Typical" security listbox.  This is for the UI's
    // use only.  Others should refer to 'dwAuthRestrictions' for this
    // information.
    //
    DWORD dwTypicalAuth;

    // Note: CustomAuth fields have meaning only when dwAuthRestrictions
    //       includes AR_F_AuthCustom.  If the AR_F_Eap flag is set without
    //       AR_F_AuthCustom, it should be assumed to be the
    //       'EAPCFG_DefaultKey' protocol, currently EAP_TLS_PROTOCOL.
    //
    DWORD dwCustomAuthKey;
    BYTE* pCustomAuthData;
    DWORD cbCustomAuthData;

    BOOL fScriptAfterTerminal;
    BOOL fScriptAfter;
    TCHAR* pszScriptAfter;
    DWORD dwCustomScript;

    TCHAR* pszX25Network;
    TCHAR* pszX25Address;
    TCHAR* pszX25UserData;
    TCHAR* pszX25Facilities;

    // Network page fields.
    //
    DWORD dwBaseProtocol;
    DWORD dwfExcludedProtocols;
    BOOL fLcpExtensions;
    BOOL fSwCompression;
    BOOL fNegotiateMultilinkAlways;
    BOOL fSkipNwcWarning;
    BOOL fSkipDownLevelDialog;
    BOOL fSkipDoubleDialDialog;

    BOOL fShareMsFilePrint;
    BOOL fBindMsNetClient;

    // List of KEYVALUE nodes containing any key/value pairs found in the
    // NETCOMPONENT group of the entry.
    //
    DTLLIST* pdtllistNetComponents;

#ifdef AMB

    // Note: dwAuthentication is read-only.  The phonebook file value of this
    //       parameter is set by the RasDial API based on the result of
    //       authentication attempts.
    //
    DWORD dwAuthentication;

#endif

    // TCPIP settings sheet PPP or SLIP configuration information.
    // 'DwBaseProtocol' determines which.
    //
    BOOL fIpPrioritizeRemote;
    BOOL fIpHeaderCompression;
    TCHAR* pszIpAddress;
    TCHAR* pszIpDnsAddress;
    TCHAR* pszIpDns2Address;
    TCHAR* pszIpWinsAddress;
    TCHAR* pszIpWins2Address;
    DWORD dwIpAddressSource; // PPP only
    DWORD dwIpNameSource;    // PPP only
    DWORD dwFrameSize;       // SLIP only
    DWORD dwIpDnsFlags;        // DNS_* values
    DWORD dwIpNbtFlags;      // PBK_ENTRY_IP_NBT_*
    DWORD dwTcpWindowSize;   // Whistler bug 300933. 0=default
    TCHAR* pszIpDnsSuffix;     // The dns suffix for this connection

    // Router page.
    //
    DWORD dwCallbackMode;
    BOOL fAuthenticateServer;

    // Other fields not shown in UI.
    //
    TCHAR* pszCustomDialDll;
    TCHAR* pszCustomDialFunc;

    //
    // custom dialer name
    //
    TCHAR* pszCustomDialerName;

    // The UID of the cached password is fixed at entry creation.  The GUID is
    // also created at entry creation and used for inter-machine uniqueness.
    // This is currently used to identify an IP configuration to the external
    // TCP/IP dialogs.
    //
    DWORD dwDialParamsUID;
    GUID* pGuid;

    // To translate user's old entries, the user name and domain are read and
    // used as authentication defaults if no cached credentials exist.  They
    // are not rewritten to the entry.
    //
    TCHAR* pszOldUser;
    TCHAR* pszOldDomain;

    // Status flags.  'fDirty' is set when the entry has changed so as to
    // differ from the phonebook file on disk.  'fCustom' is set when the
    // entry contains a MEDIA and DEVICE (so RASAPI is able to read it) but
    // was not created by us.  When 'fCustom' is set only 'pszEntry' is
    // guaranteed valid and the entry cannot be edited.
    //
    BOOL fDirty;
    BOOL fCustom;
}
PBENTRY;


// Phonebook (.PBK) file information.
//
typedef struct
_PBFILE
{
    // Handle of phone book file.
    //
    HRASFILE hrasfile;

    // Fully qualified path to the phonebook.
    //
    TCHAR* pszPath;

    // Phonebook mode, system, personal, or alternate.
    //
    DWORD dwPhonebookMode;

    // Unsorted list of PBENTRY.  The list is manipulated by the Entry
    // dialogs.
    //
    DTLLIST* pdtllistEntries;

    HANDLE hConnection;
}
PBFILE;

typedef void (WINAPI *PBKENUMCALLBACK)( PBFILE *, VOID * );


// The callback number for a device.  This type is a node in the
// 'pdllistCallbackNumbers' below.
//
typedef struct
_CALLBACKNUMBER
{
    TCHAR* pszDevice;
    TCHAR* pszCallbackNumber;
}
CALLBACKNUMBER;


//----------------------------------------------------------------------------
// Prototypes
//----------------------------------------------------------------------------

VOID
ChangeEntryType(
    PBENTRY* ppbentry,
    DWORD dwType );

DTLNODE*
CloneEntryNode(
    DTLNODE* pdtlnodeSrc );

VOID
ClosePhonebookFile(
    IN OUT PBFILE* pFile );

DWORD
CopyToPbport(
    IN PBPORT* ppbportDst,
    IN PBPORT* ppbportSrc );

DTLNODE*
CreateEntryNode(
    BOOL fCreateLink );

DTLNODE*
CreateLinkNode(
    void );

DTLNODE*
CreatePhoneNode(
    void );

DTLNODE*
CreatePortNode(
    void );

VOID
DestroyEntryNode(
    IN DTLNODE* pdtlnode );

VOID
DestroyEntryTypeNode(
    IN DTLNODE *pdtlnode );

VOID
DestroyLinkNode(
    IN DTLNODE* pdtlnode );

VOID
DestroyPhoneNode(
    IN DTLNODE* pdtlnode );

VOID
DestroyPortNode(
    IN DTLNODE* pdtlnode );

VOID
DestroyProtocolNode(
    IN DTLNODE* pdtlnode );

DTLNODE*
DuplicateEntryNode(
    DTLNODE* pdtlnodeSrc );

DTLNODE*
DuplicateLinkNode(
    IN DTLNODE* pdtlnodeSrc );


DTLNODE*
DuplicatePhoneNode(
    IN DTLNODE* pdtlnodeSrc );

DTLNODE*
DuplicateProtocolNode(
    IN DTLNODE* pdtlnodeSrc );

VOID
EnableOrDisableNetComponent(
    IN PBENTRY* pEntry,
    IN LPCTSTR  pszComponent,
    IN BOOL     fEnable);

BOOL
FIsNetComponentListed(
    IN PBENTRY*     pEntry,
    IN LPCTSTR      pszComponent,
    OUT BOOL*       pfEnabled,
    OUT KEYVALUE**  ppKv);

DTLNODE*
EntryNodeFromName(
    IN DTLLIST* pdtllistEntries,
    IN LPCTSTR pszName );

DWORD
EntryTypeFromPbport(
    IN PBPORT* ppbport );

BOOL
GetDefaultPhonebookPath(
    IN DWORD dwFlags,
    OUT TCHAR** ppszPath );

DWORD
GetOverridableParam(
    IN PBUSER* pUser,
    IN PBENTRY* pEntry,
    IN DWORD dwfRasorBit );

BOOL
GetPhonebookPath(
    IN PBUSER* pUser,
    IN DWORD dwFlags,
    OUT TCHAR** ppszPath,
    OUT DWORD* pdwPhonebookMode );

BOOL
GetPhonebookDirectory(
    IN DWORD dwPhonebookMode,
    OUT TCHAR* pszPathBuf );

BOOL
GetPersonalPhonebookPath(
    IN TCHAR* pszFile,
    OUT TCHAR* pszPathBuf );

BOOL
GetPublicPhonebookPath(
    OUT TCHAR* pszPathBuf );

DWORD
InitializePbk(
    void );

DWORD
InitPersonalPhonebook(
    OUT TCHAR** ppszFile );

BOOL
IsPublicPhonebook(
    IN LPCTSTR pszPhonebookPath );

DWORD
GetPbkAndEntryName(
    IN  LPCTSTR          pszPhonebook,
    IN  LPCTSTR          pszEntry,
    IN  DWORD            dwFlags,
    OUT PBFILE           *pFile,
    OUT DTLNODE          **ppdtlnode);

DWORD
LoadPadsList(
    OUT DTLLIST** ppdtllistPads );

DWORD
LoadPhonebookFile(
    IN TCHAR* pszPhonebookPath,
    IN TCHAR* pszSection,
    IN BOOL fHeadersOnly,
    IN BOOL fReadOnly,
    OUT HRASFILE* phrasfile,
    OUT BOOL* pfPersonal );

DWORD
LoadPortsList(
    OUT DTLLIST** ppdtllistPorts );

DWORD
LoadPortsList2(
    IN  HANDLE hConnection,
    OUT DTLLIST** ppdtllistPorts,
    IN  BOOL fRouter );

DWORD
LoadScriptsList(
    IN  HANDLE    hConnection,
    OUT DTLLIST** ppdtllistScripts );

PBDEVICETYPE
PbdevicetypeFromPszType(
    IN TCHAR* pszDeviceType );

PBDEVICETYPE
PbdevicetypeFromPszTypeA(
    IN CHAR* pszDeviceType );

PBPORT*
PpbportFromPortAndDeviceName(
    IN DTLLIST* pdtllistPorts,
    IN TCHAR* pszPort,
    IN TCHAR* pszDevice );

PBPORT*
PpbportFromNT4PortandDevice(
    IN DTLLIST* pdtlllistPorts,
    IN TCHAR*   pszPort,
    IN TCHAR*   pszDevice);

DWORD
RdtFromPbdt(PBDEVICETYPE pbdt,
            DWORD dwFlags);

DWORD
ReadPhonebookFile(
    IN LPCTSTR pszPhonebookPath,
    IN PBUSER* pUser,
    IN LPCTSTR pszSection,
    IN DWORD dwFlags,
    OUT PBFILE* pFile );

TCHAR *pszDeviceTypeFromRdt(
    RASDEVICETYPE rdt);

BOOL
SetDefaultModemSettings(
    IN PBLINK* pLink );

DWORD
SetPersonalPhonebookInfo(
    IN BOOL fPersonal,
    IN TCHAR* pszPath );

VOID
TerminatePbk(
    void );

DWORD
WritePhonebookFile(
    IN PBFILE* pFile,
    IN LPCTSTR pszSectionToDelete );

DWORD
UpgradePhonebookFile(
    IN LPCTSTR pszPhonebookPath,
    IN PBUSER* pUser,
    OUT BOOL* pfUpgraded );

BOOL
ValidateAreaCode(
    IN OUT TCHAR* pszAreaCode );

BOOL
ValidateEntryName(
    IN LPCTSTR pszEntry );


BOOL 
IsRouterPhonebook(LPCTSTR pszPhonebook);

DWORD
DwPbentryToDetails(
    IN  PBENTRY* pEntry,
    IN  LPCWSTR pszPhonebookPath,
    IN  BOOL fIsAllUsersPbk,
    OUT RASENUMENTRYDETAILS* pDetails);

DWORD
DwSendRasNotification(
    IN RASEVENTTYPE     Type,
    IN PBENTRY*         pEntry,
    IN LPCTSTR          pszPhonebookPath,
    IN HANDLE           hData);             // Extra Type-specific info

DWORD
DwGetCustomDllEntryPoint(
        LPCTSTR    lpszPhonebook,
        LPCTSTR    lpszEntry,
        BOOL       *pfCustomDllSpecified,
        FARPROC    *pfnCustomEntryPoint,
        HINSTANCE  *phInstDll,
        DWORD      dwFnId,
        LPTSTR     pszCustomDialerName
        );

DWORD
DwCustomDialDlg(
        LPTSTR          lpszPhonebook,
        LPTSTR          lpszEntry,
        LPTSTR          lpszPhoneNumber,
        LPRASDIALDLG    lpInfo,
        DWORD           dwFlags,
        BOOL            *pfStatus,
        PVOID           pvInfo,
        LPTSTR          pszCustomDialer);


DWORD
DwCustomEntryDlg(
        LPTSTR          lpszPhonebook,
        LPTSTR          lpszEntry,
        LPRASENTRYDLG   lpInfo,
        BOOL            *pfStatus);

DWORD
DwCustomDeleteEntryNotify(
        LPCTSTR          lpszPhonebook,
        LPCTSTR          lpszEntry,
        LPTSTR           pszCustomDialer);
        


DWORD
DwGetExpandedDllPath(LPTSTR pszDllPath,
                     LPTSTR *ppszExpandedDllPath);

DWORD
DwGetEntryMode( LPCTSTR pszPhonebook,
                LPCTSTR pszEntry,
                PBFILE *pFileIn,
                DWORD  *pdwFlags);

DWORD
DwEnumeratePhonebooksFromDirectory(
    TCHAR *pszDir,
    DWORD dwFlags,
    PBKENUMCALLBACK pfnCallback,
    VOID *pvContext
    );

DWORD
DwGetCustomAuthData(
    PBENTRY *pEntry,
    DWORD *pcbCustomAuthData,
    PBYTE *ppCustomAuthData
    );

DWORD
DwSetCustomAuthData(
    PBENTRY *pEntry,
    DWORD cbCustomAuthData,
    PBYTE pCustomAuthData
    );

DWORD
DwCustomTerminalDlg(
    TCHAR *pszPhonebook,
    HRASCONN hrasconn,
    PBENTRY *pEntry,
    HWND hwndDlg,
    RASDIALPARAMS *prdp,
    PVOID pvReserved
    );

DWORD
DwGetVpnDeviceName(
    DWORD dwVpnStrategy, 
    WCHAR *pszDeviceDefault, 
    WCHAR *pszDeviceName);
    
                
#endif // _PBK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\inc\phonenum.h ===
// Copyright (c) 1996, Microsoft Corporation, all rights reserved
//
// phonenum.h
// Phone number building library
// Public header
//
// 03/06/96 Steve Cobb
//

#ifndef _PHONENUM_H_
#define _PHONENUM_H_


#include <pbk.h>
#include <tapi.h>


//----------------------------------------------------------------------------
// Prototypes
//----------------------------------------------------------------------------

TCHAR*
LinkPhoneNumberFromParts(
    IN HINSTANCE hInst,
    IN OUT HLINEAPP* pHlineapp,
    IN PBUSER* pUser,
    IN PBENTRY* pEntry,
    IN PBLINK* pLink,
    IN DWORD iPhoneNumber,
    IN TCHAR* pszOverrideNumber,
    IN BOOL fDialable );

TCHAR*
PhoneNumberFromParts(
    IN HINSTANCE hInst,
    IN OUT HLINEAPP* pHlineapp,
    IN PBUSER* pUser,
    IN PBPHONE* pPhone,
    IN BOOL fDownLevelIsdn,
    IN BOOL fDialable );

TCHAR*
PhoneNumberFromPrefixSuffix(
    IN TCHAR* pszBaseNumber,
    IN TCHAR* pszPrefix,
    IN TCHAR* pszSuffix );

TCHAR*
PhoneNumberFromPrefixSuffixEx(
    IN TCHAR* pszBaseNumber,
    IN TCHAR* pszPrefix,
    IN TCHAR* pszSuffix,
    IN BOOL fDownLevelIsdn );

TCHAR*
PhoneNumberFromTapiParts(
    IN HINSTANCE hInst,
    IN TCHAR* pszBaseNumber,
    IN TCHAR* pszAreaCode,
    IN DWORD dwCountryCode,
    IN OUT HLINEAPP* pHlineapp,
    IN BOOL fDialable );

TCHAR*
PhoneNumberFromTapiPartsEx(
    IN HINSTANCE hInst,
    IN TCHAR* pszBaseNumber,
    IN TCHAR* pszAreaCode,
    IN DWORD dwCountryCode,
    IN BOOL fDownLevelIsdn,
    IN OUT HLINEAPP* pHlineapp,
    IN BOOL fDialable );

VOID
PrefixSuffixFromLocationId(
    IN PBUSER* pUser,
    IN DWORD dwLocationId,
    OUT TCHAR** ppszPrefix,
    OUT TCHAR** ppszSuffix );


#endif // _PHONENUM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\inc\rasip.h ===
//****************************************************************************
//
//		       Microsoft NT Remote Access Service
//
//		       Copyright 1992-93
//
//
//  Revision History
//
//
//  12/9/93	Gurdeep Singh Pall	Created
//
//
//  Description: Shared structs between rasarp and ipcp
//
//****************************************************************************

#ifndef _RASIP_H_
#define _RASIP_H_

#define RASARP_DEVICE_NAME	L"\\\\.\\RASARP"

#define RASARP_DEVICE_NAME_NUC	"\\\\.\\RASARP"

#define FILE_DEVICE_RASARP	0x00009001

#define _RASARP_CONTROL_CODE(request,method)  ((FILE_DEVICE_RASARP)<<16 | (request<<2) | method)

#define IOCTL_RASARP_ACTIVITYINFO	_RASARP_CONTROL_CODE( 0, METHOD_BUFFERED )

#define IOCTL_RASARP_DISABLEIF		_RASARP_CONTROL_CODE( 1, METHOD_BUFFERED )

typedef ULONG IPADDR ;

struct IPLinkUpInfo {

#define CALLIN	0
#define CALLOUT 1

    ULONG	    I_Usage ;	// CALLIN, or CALLOUT

    IPADDR	    I_IPAddress ; // For client - the client's IP Address, for server
				  // the client's IP address.

    ULONG	    I_NetbiosFilter ; // 1 = ON, 0 - OFF.

} ;

typedef struct IPLinkUpInfo IPLinkUpInfo ;


struct ActivityInfo {

    IPADDR	    A_IPAddress ; // The address for which activity is requested.

    ULONG	    A_TimeSinceLastActivity ; // In minutes

} ;

typedef struct ActivityInfo ActivityInfo ;

#endif // _RASIP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\inc\pwutil.h ===
/* Copyright (c) 1993, Microsoft Corporation, all rights reserved
**
** ppputil.h
** Public header for miscellaneuos PPP common library functions.
*/

#ifndef _PWUTIL_H_
#define _PWUTIL_H_

VOID
DecodePasswordA(
    CHAR* pszPassword
    );

VOID
DecodePasswordW(
    WCHAR* pszPassword
    );

VOID
EncodePasswordA(
    CHAR* pszPassword
    );

VOID
EncodePasswordW(
    WCHAR* pszPassword
    );

VOID
WipePasswordA(
    CHAR* pszPassword
    );

VOID
WipePasswordW(
    WCHAR* pszPassword
    );

#ifdef UNICODE
#define DecodePassword  DecodePasswordW
#define EncodePassword  EncodePasswordW
#define WipePassword    WipePasswordW
#else
#define DecodePassword  DecodePasswordA
#define EncodePassword  EncodePasswordA
#define WipePassword    WipePasswordA
#endif

#endif // _PWUTIL_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\inc\rasrpclb.h ===
/*++

Copyright(c) 1995 Microsoft Corporation

MODULE NAME
    rasrpclb.h

ABSTRACT
    Header file for rasrpc client/server common routines

AUTHOR
    Anthony Discolo (adiscolo) 10-Sep-1996

REVISION HISTORY

--*/

#ifndef _RASRPCLIB_H
#define _RASRPCLIB_H

DWORD
RasToRpcPbuser(
    LPRASRPC_PBUSER pUser,
    PBUSER *pPbuser
    );

DWORD
RpcToRasPbuser(
    PBUSER *pPbuser,
    LPRASRPC_PBUSER pUser
    );

#endif // _RASRPCLIB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\inc\popupdlg.h ===
/* Copyright (c) 1995, Microsoft Corporation, all rights reserved
**
** popupdlg.h
** UI helper library
** Error and message dialog public header
**
** 08/25/95 Steve Cobb
*/

#ifndef _POPUPDLG_H_
#define _POPUPDLG_H_


/*----------------------------------------------------------------------------
** Datatypes
**----------------------------------------------------------------------------
*/

/* Extended arguments for the ErrorDlgUtil routine.  Designed so zeroed gives
** default behaviors.
*/
#define ERRORARGS struct tagERRORARGS
ERRORARGS
{
    /* Insertion strings for arguments %1 to %9 in the 'dwOperation' string,
    ** or NULLs if none.
    */
    TCHAR* apszOpArgs[ 9 ];

    /* Insertion strings for auxillary arguments %4 to %6 in the 'dwFormat'
    ** string, or NULLs if none.  (The standard arguments are %1=the
    ** 'dwOperation' string, %2=the decimal error number, and %3=the
    ** 'dwError'string.)
    */
    TCHAR* apszAuxFmtArgs[ 3 ];

    /* If 'fStringOutput' is true, the ErrorDlgUtil returns the formatted text
    ** string that would otherwise be displayed in the popup in 'pszOutput'.
    ** It is caller's responsibility to LocalFree the returned string.
    */
    BOOL   fStringOutput;
    TCHAR* pszOutput;
};


/* Extended arguments for the MsgDlgUtil routine.  Designed so zeroed gives
** default behaviors.
*/
#define MSGARGS struct tagMSGARGS
MSGARGS
{
    /* Insertion strings for arguments %1 to %9 in the 'dwMsg' string, or
    ** NULLs if none.
    */
    TCHAR* apszArgs[ 9 ];

    /* Currently, as for MessageBox, where defaults if 0 are MB_OK and
    ** MB_ICONINFORMATION.
    */
    DWORD dwFlags;

    /* If non-NULL, specifies a string overriding the loading of the 'dwMsg'
    ** parameter string.
    */
    TCHAR* pszString;

    /* If 'fStringOutput' is true, the MsgDlgUtil returns the formatted text
    ** string that would otherwise be displayed in the popup in 'pszOutput'.
    ** It is caller's responsibility to LocalFree the returned string.
    */
    BOOL   fStringOutput;
    TCHAR* pszOutput;
};


/*----------------------------------------------------------------------------
** Prototypes
**----------------------------------------------------------------------------
*/

LRESULT CALLBACK
CenterDlgOnOwnerCallWndProc(
    int    code,
    WPARAM wparam,
    LPARAM lparam );

BOOL
GetErrorText(
    DWORD   dwError,
    TCHAR** ppszError );

int
ErrorDlgUtil(
    IN     HWND       hwndOwner,
    IN     DWORD      dwOperation,
    IN     DWORD      dwError,
    IN OUT ERRORARGS* pargs,
    IN     HINSTANCE  hInstance,
    IN     DWORD      dwTitle,
    IN     DWORD      dwFormat );

int
MsgDlgUtil(
    IN     HWND      hwndOwner,
    IN     DWORD     dwMsg,
    IN OUT MSGARGS*  pargs,
    IN     HINSTANCE hInstance,
    IN     DWORD     dwTitle );


#endif // _POPUPDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\inc\rasp.h ===
/* Copyright (c) 1992, Microsoft Corporation, all rights reserved
**
** rasp.h
** Remote Access external API
** Private header for external API clients
*/

#ifndef _RASP_H_
#define _RASP_H_

/* Trusted entry points used by RASPHONE.
*/
HPORT    APIENTRY RasGetHport( HRASCONN );
HRASCONN APIENTRY RasGetHrasconn( HPORT );
VOID     APIENTRY RasGetConnectResponse( HRASCONN, CHAR* );
DWORD    APIENTRY RasSetNewPassword( HRASCONN, CHAR* );


/*----------------------------------------------------------------------------
** Off-version ras.h definitions
**----------------------------------------------------------------------------
*/

#include "pshpack4.h"

/* RAS structures as they appear to a caller in previous releases.  These are
** defined here because RASAPI32 needs to be able to access both old and new
** definitions in the same code.
*/

/* Windows NT 3.51 definitions.
*/

#define RAS_MaxEntryName_V351      20
#define RAS_MaxDeviceName_V351     32
#define RAS_MaxCallbackNumber_V351 48

/* Identifies an active RAS connection.  (See RasEnumConnections)
*/
#define RASCONNW_V351 struct tagRASCONNW_V351
RASCONNW_V351
{
    DWORD    dwSize;
    HRASCONN hrasconn;
    WCHAR    szEntryName[ RAS_MaxEntryName_V351 + 1 ];
};

#define RASCONNA_V351 struct tagRASCONNA_V351
RASCONNA_V351
{
    DWORD    dwSize;
    HRASCONN hrasconn;
    CHAR     szEntryName[ RAS_MaxEntryName_V351 + 1 ];
};

#define RASCONNW_V400 struct tagRASCONNW_V400
RASCONNW_V400
{
    DWORD    dwSize;
    HRASCONN hrasconn;
    WCHAR    szEntryName[ RAS_MaxEntryName + 1 ];
    WCHAR    szDeviceType[ RAS_MaxDeviceType + 1 ];
    WCHAR    szDeviceName[ RAS_MaxDeviceName + 1 ];
};

#define RASCONNA_V400 struct tagRASCONNA_V400
RASCONNA_V400
{
    DWORD    dwSize;
    HRASCONN hrasconn;
    CHAR     szEntryName[ RAS_MaxEntryName + 1 ];
    CHAR     szDeviceType[ RAS_MaxDeviceType + 1 ];
    CHAR     szDeviceName[ RAS_MaxDeviceName + 1 ];
};

#define RASCONNA_V401 struct tagRASCONNA_V401
RASCONNA_V401
{
    DWORD    dwSize;
    HRASCONN hrasconn;
    CHAR     szEntryName[ RAS_MaxEntryName + 1 ];
    CHAR     szDeviceType[ RAS_MaxDeviceType + 1 ];
    CHAR     szDeviceName[ RAS_MaxDeviceName + 1 ];
    CHAR     szPhonebook [ MAX_PATH ];
    DWORD    dwSubEntry;
};

#define RASCONNW_V401 struct tagRASCONNW_V401
RASCONNW_V401
{
    DWORD    dwSize;
    HRASCONN hrasconn;
    WCHAR    szEntryName[ RAS_MaxEntryName + 1 ];
    WCHAR    szDeviceType[ RAS_MaxDeviceType + 1 ];
    WCHAR    szDeviceName[ RAS_MaxDeviceName + 1 ];
    WCHAR    szPhonebook [ MAX_PATH ];
    DWORD    dwSubEntry;
};

#define RASCONNA_V500 struct tagRASCONNA_V500
RASCONNA_V500
{
    DWORD    dwSize;
    HRASCONN hrasconn;
    CHAR     szEntryName[ RAS_MaxEntryName + 1 ];
    CHAR     szDeviceType[ RAS_MaxDeviceType + 1 ];
    CHAR     szDeviceName[ RAS_MaxDeviceName + 1 ];
    CHAR     szPhonebook [ MAX_PATH ];
    DWORD    dwSubEntry;
    GUID     guidEntry;
};

#define RASCONNW_V500 struct tagRASCONNW_V500
RASCONNW_V500
{
    DWORD    dwSize;
    HRASCONN hrasconn;
    WCHAR    szEntryName[ RAS_MaxEntryName + 1 ];
    WCHAR    szDeviceType[ RAS_MaxDeviceType + 1 ];
    WCHAR    szDeviceName[ RAS_MaxDeviceName + 1 ];
    WCHAR    szPhonebook [ MAX_PATH ];
    DWORD    dwSubEntry;
    GUID     guidEntry;
};


/* Describes the status of a RAS connection.  (See RasConnectionStatus)
*/
#define RASCONNSTATUSW_V351 struct tagRASCONNSTATUSW_V351
RASCONNSTATUSW_V351
{
    DWORD        dwSize;
    RASCONNSTATE rasconnstate;
    DWORD        dwError;
    WCHAR        szDeviceType[ RAS_MaxDeviceType + 1 ];
    WCHAR        szDeviceName[ RAS_MaxDeviceName_V351 + 1 ];
};

#define RASCONNSTATUSA_V351 struct tagRASCONNSTATUSA_V351
RASCONNSTATUSA_V351
{
    DWORD        dwSize;
    RASCONNSTATE rasconnstate;
    DWORD        dwError;
    CHAR         szDeviceType[ RAS_MaxDeviceType + 1 ];
    CHAR         szDeviceName[ RAS_MaxDeviceName_V351 + 1 ];
};

#define RASCONNSTATUSW_V400 struct tagRASCONNSTATUSW_V400
RASCONNSTATUSW_V400
{
    DWORD        dwSize;
    RASCONNSTATE rasconnstate;
    DWORD        dwError;
    WCHAR        szDeviceType[ RAS_MaxDeviceType + 1 ];
    WCHAR        szDeviceName[ RAS_MaxDeviceName + 1 ];
};

#define RASCONNSTATUSA_V400 struct tagRASCONNSTATUSA_V400
RASCONNSTATUSA_V400
{
    DWORD        dwSize;
    RASCONNSTATE rasconnstate;
    DWORD        dwError;
    CHAR         szDeviceType[ RAS_MaxDeviceType + 1 ];
    CHAR         szDeviceName[ RAS_MaxDeviceName + 1 ];
};

/* Describes connection establishment parameters.  (See RasDial)
*/
#define RASDIALPARAMSW_V351 struct tagRASDIALPARAMSW_V351
RASDIALPARAMSW_V351
{
    DWORD dwSize;
    WCHAR szEntryName[ RAS_MaxEntryName_V351 + 1 ];
    WCHAR szPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    WCHAR szCallbackNumber[ RAS_MaxCallbackNumber_V351 + 1 ];
    WCHAR szUserName[ UNLEN + 1 ];
    WCHAR szPassword[ PWLEN + 1 ];
    WCHAR szDomain[ DNLEN + 1 ];
};

#define RASDIALPARAMSA_V351 struct tagRASDIALPARAMSA_V351
RASDIALPARAMSA_V351
{
    DWORD dwSize;
    CHAR  szEntryName[ RAS_MaxEntryName_V351 + 1 ];
    CHAR  szPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    CHAR  szCallbackNumber[ RAS_MaxCallbackNumber_V351 + 1 ];
    CHAR  szUserName[ UNLEN + 1 ];
    CHAR  szPassword[ PWLEN + 1 ];
    CHAR  szDomain[ DNLEN + 1 ];
};

#define RASDIALPARAMSW_V400 struct tagRASDIALPARAMSW_V400
RASDIALPARAMSW_V400
{
    DWORD dwSize;
    WCHAR szEntryName[ RAS_MaxEntryName + 1 ];
    WCHAR szPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    WCHAR szCallbackNumber[ RAS_MaxCallbackNumber + 1 ];
    WCHAR szUserName[ UNLEN + 1 ];
    WCHAR szPassword[ PWLEN + 1 ];
    WCHAR szDomain[ DNLEN + 1 ];
};

#define RASDIALPARAMSA_V400 struct tagRASDIALPARAMSA_V400
RASDIALPARAMSA_V400
{
    DWORD dwSize;
    CHAR  szEntryName[ RAS_MaxEntryName + 1 ];
    CHAR  szPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    CHAR  szCallbackNumber[ RAS_MaxCallbackNumber + 1 ];
    CHAR  szUserName[ UNLEN + 1 ];
    CHAR  szPassword[ PWLEN + 1 ];
    CHAR  szDomain[ DNLEN + 1 ];
};

/* Describes an enumerated RAS phone book entry name.  (See RasEntryEnum)
*/
#define RASENTRYNAMEW_V351 struct tagRASENTRYNAMEW_V351
RASENTRYNAMEW_V351
{
    DWORD dwSize;
    WCHAR szEntryName[ RAS_MaxEntryName_V351 + 1 ];
};

#define RASENTRYNAMEA_V351 struct tagRASENTRYNAMEA_V351
RASENTRYNAMEA_V351
{
    DWORD dwSize;
    CHAR  szEntryName[ RAS_MaxEntryName_V351 + 1 ];
};


#define RASENTRYNAMEW_V401 struct tagRASENTRYNAMEW_V401
RASENTRYNAMEW_V401
{
    DWORD dwSize;
    WCHAR szEntryName[ RAS_MaxEntryName + 1 ];
};

#define RASENTRYNAMEA_V401 struct tagRASENTRYNAMEA_V401
RASENTRYNAMEA_V401
{
    DWORD dwSize;
    CHAR  szEntryName[ RAS_MaxEntryName + 1 ];
};


/* A RAS phone book entry.
*/
#define RASENTRYW_V400 struct tagRASENTRYW_V400
RASENTRYW_V400
{
    DWORD       dwSize;
    DWORD       dwfOptions;
    //
    // Location/phone number
    //
    DWORD       dwCountryID;
    DWORD       dwCountryCode;
    WCHAR       szAreaCode[ RAS_MaxAreaCode + 1 ];
    WCHAR       szLocalPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    DWORD       dwAlternateOffset;
    //
    // PPP/Ip
    //
    RASIPADDR   ipaddr;
    RASIPADDR   ipaddrDns;
    RASIPADDR   ipaddrDnsAlt;
    RASIPADDR   ipaddrWins;
    RASIPADDR   ipaddrWinsAlt;
    //
    // Framing
    //
    DWORD       dwFrameSize;
    DWORD       dwfNetProtocols;
    DWORD       dwFramingProtocol;
    //
    // Scripting
    //
    WCHAR       szScript[ MAX_PATH ];
    //
    // AutoDial
    //
    WCHAR       szAutodialDll[ MAX_PATH ];
    WCHAR       szAutodialFunc[ MAX_PATH ];
    //
    // Device
    //
    WCHAR       szDeviceType[ RAS_MaxDeviceType + 1 ];
    WCHAR       szDeviceName[ RAS_MaxDeviceName + 1 ];
    //
    // X.25
    //
    WCHAR       szX25PadType[ RAS_MaxPadType + 1 ];
    WCHAR       szX25Address[ RAS_MaxX25Address + 1 ];
    WCHAR       szX25Facilities[ RAS_MaxFacilities + 1 ];
    WCHAR       szX25UserData[ RAS_MaxUserData + 1 ];
    DWORD       dwChannels;
    //
    // Reserved
    //
    DWORD       dwReserved1;
    DWORD       dwReserved2;
};


#define RASENTRYA_V400 struct tagRASENTRYA_V400
RASENTRYA_V400
{
    DWORD       dwSize;
    DWORD       dwfOptions;
    //
    // Location/phone number.
    //
    DWORD       dwCountryID;
    DWORD       dwCountryCode;
    CHAR        szAreaCode[ RAS_MaxAreaCode + 1 ];
    CHAR        szLocalPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    DWORD       dwAlternateOffset;
    //
    // PPP/Ip
    //
    RASIPADDR   ipaddr;
    RASIPADDR   ipaddrDns;
    RASIPADDR   ipaddrDnsAlt;
    RASIPADDR   ipaddrWins;
    RASIPADDR   ipaddrWinsAlt;
    //
    // Framing
    //
    DWORD       dwFrameSize;
    DWORD       dwfNetProtocols;
    DWORD       dwFramingProtocol;
    //
    // Scripting
    //
    CHAR        szScript[ MAX_PATH ];
    //
    // AutoDial
    //
    CHAR        szAutodialDll[ MAX_PATH ];
    CHAR        szAutodialFunc[ MAX_PATH ];
    //
    // Device
    //
    CHAR        szDeviceType[ RAS_MaxDeviceType + 1 ];
    CHAR        szDeviceName[ RAS_MaxDeviceName + 1 ];
    //
    // X.25
    //
    CHAR        szX25PadType[ RAS_MaxPadType + 1 ];
    CHAR        szX25Address[ RAS_MaxX25Address + 1 ];
    CHAR        szX25Facilities[ RAS_MaxFacilities + 1 ];
    CHAR        szX25UserData[ RAS_MaxUserData + 1 ];
    DWORD       dwChannels;
    //
    // Reserved
    //
    DWORD       dwReserved1;
    DWORD       dwReserved2;
};


/* A RAS phone book entry (v401)
*/
#define RASENTRYA_V401 struct tagRASENTRYA_V401
RASENTRYA_V401
{
    DWORD       dwSize;
    DWORD       dwfOptions;
    //
    // Location/phone number.
    //
    DWORD       dwCountryID;
    DWORD       dwCountryCode;
    CHAR        szAreaCode[ RAS_MaxAreaCode + 1 ];
    CHAR        szLocalPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    DWORD       dwAlternateOffset;
    //
    // PPP/Ip
    //
    RASIPADDR   ipaddr;
    RASIPADDR   ipaddrDns;
    RASIPADDR   ipaddrDnsAlt;
    RASIPADDR   ipaddrWins;
    RASIPADDR   ipaddrWinsAlt;
    //
    // Framing
    //
    DWORD       dwFrameSize;
    DWORD       dwfNetProtocols;
    DWORD       dwFramingProtocol;
    //
    // Scripting
    //
    CHAR        szScript[ MAX_PATH ];
    //
    // AutoDial
    //
    CHAR        szAutodialDll[ MAX_PATH ];
    CHAR        szAutodialFunc[ MAX_PATH ];
    //
    // Device
    //
    CHAR        szDeviceType[ RAS_MaxDeviceType + 1 ];
    CHAR        szDeviceName[ RAS_MaxDeviceName + 1 ];
    //
    // X.25
    //
    CHAR        szX25PadType[ RAS_MaxPadType + 1 ];
    CHAR        szX25Address[ RAS_MaxX25Address + 1 ];
    CHAR        szX25Facilities[ RAS_MaxFacilities + 1 ];
    CHAR        szX25UserData[ RAS_MaxUserData + 1 ];
    DWORD       dwChannels;
    //
    // Reserved
    //
    DWORD       dwReserved1;
    DWORD       dwReserved2;
    //
    // Multilink
    //
    DWORD       dwSubEntries;
    DWORD       dwDialMode;
    DWORD       dwDialExtraPercent;
    DWORD       dwDialExtraSampleSeconds;
    DWORD       dwHangUpExtraPercent;
    DWORD       dwHangUpExtraSampleSeconds;
    //
    // Idle timeout
    //
    DWORD       dwIdleDisconnectSeconds;

};

#define RASENTRYW_V401 struct tagRASENTRYW_V401
RASENTRYW_V401
{
    DWORD       dwSize;
    DWORD       dwfOptions;
    //
    // Location/phone number
    //
    DWORD       dwCountryID;
    DWORD       dwCountryCode;
    WCHAR       szAreaCode[ RAS_MaxAreaCode + 1 ];
    WCHAR       szLocalPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    DWORD       dwAlternateOffset;
    //
    // PPP/Ip
    //
    RASIPADDR   ipaddr;
    RASIPADDR   ipaddrDns;
    RASIPADDR   ipaddrDnsAlt;
    RASIPADDR   ipaddrWins;
    RASIPADDR   ipaddrWinsAlt;
    //
    // Framing
    //
    DWORD       dwFrameSize;
    DWORD       dwfNetProtocols;
    DWORD       dwFramingProtocol;
    //
    // Scripting
    //
    WCHAR       szScript[ MAX_PATH ];
    //
    // AutoDial
    //
    WCHAR       szAutodialDll[ MAX_PATH ];
    WCHAR       szAutodialFunc[ MAX_PATH ];
    //
    // Device
    //
    WCHAR       szDeviceType[ RAS_MaxDeviceType + 1 ];
    WCHAR       szDeviceName[ RAS_MaxDeviceName + 1 ];
    //
    // X.25
    //
    WCHAR       szX25PadType[ RAS_MaxPadType + 1 ];
    WCHAR       szX25Address[ RAS_MaxX25Address + 1 ];
    WCHAR       szX25Facilities[ RAS_MaxFacilities + 1 ];
    WCHAR       szX25UserData[ RAS_MaxUserData + 1 ];
    DWORD       dwChannels;
    //
    // Reserved
    //
    DWORD       dwReserved1;
    DWORD       dwReserved2;
    //
    // Multilink
    //
    DWORD       dwSubEntries;
    DWORD       dwDialMode;
    DWORD       dwDialExtraPercent;
    DWORD       dwDialExtraSampleSeconds;
    DWORD       dwHangUpExtraPercent;
    DWORD       dwHangUpExtraSampleSeconds;
    //
    // Idle timeout
    //
    DWORD       dwIdleDisconnectSeconds;
};


#define RASENTRYA_V500 struct tagRASENTRYA_V500
RASENTRYA_V500
{
    DWORD       dwSize;
    DWORD       dwfOptions;
    //
    // Location/phone number.
    //
    DWORD       dwCountryID;
    DWORD       dwCountryCode;
    CHAR        szAreaCode[ RAS_MaxAreaCode + 1 ];
    CHAR        szLocalPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    DWORD       dwAlternateOffset;
    //
    // PPP/Ip
    //
    RASIPADDR   ipaddr;
    RASIPADDR   ipaddrDns;
    RASIPADDR   ipaddrDnsAlt;
    RASIPADDR   ipaddrWins;
    RASIPADDR   ipaddrWinsAlt;
    //
    // Framing
    //
    DWORD       dwFrameSize;
    DWORD       dwfNetProtocols;
    DWORD       dwFramingProtocol;
    //
    // Scripting
    //
    CHAR        szScript[ MAX_PATH ];
    //
    // AutoDial
    //
    CHAR        szAutodialDll[ MAX_PATH ];
    CHAR        szAutodialFunc[ MAX_PATH ];
    //
    // Device
    //
    CHAR        szDeviceType[ RAS_MaxDeviceType + 1 ];
    CHAR        szDeviceName[ RAS_MaxDeviceName + 1 ];
    //
    // X.25
    //
    CHAR        szX25PadType[ RAS_MaxPadType + 1 ];
    CHAR        szX25Address[ RAS_MaxX25Address + 1 ];
    CHAR        szX25Facilities[ RAS_MaxFacilities + 1 ];
    CHAR        szX25UserData[ RAS_MaxUserData + 1 ];
    DWORD       dwChannels;
    //
    // Reserved
    //
    DWORD       dwReserved1;
    DWORD       dwReserved2;
#if (WINVER >= 0x401)
    //
    // Multilink
    //
    DWORD       dwSubEntries;
    DWORD       dwDialMode;
    DWORD       dwDialExtraPercent;
    DWORD       dwDialExtraSampleSeconds;
    DWORD       dwHangUpExtraPercent;
    DWORD       dwHangUpExtraSampleSeconds;
    //
    // Idle timeout
    //
    DWORD       dwIdleDisconnectSeconds;
#endif

#if (WINVER >= 0x500)

    //
    // Entry Type
    //
    DWORD       dwType;

    //
    // Encryption type
    //
    DWORD       dwEncryptionType;

    //
    // CustomAuthKey to be used for EAP
    //
    DWORD       dwCustomAuthKey;

    //
    // Guid of the connection
    //
    GUID        guidId;

    //
    // Custom Dial Dll
    //
    CHAR        szCustomDialDll[MAX_PATH];

    //
    // DwVpnStrategy
    //
    DWORD       dwVpnStrategy;
#endif

};


#define RASENTRYW_V500 struct tagRASENTRYW_V500
RASENTRYW_V500
{
    DWORD       dwSize;
    DWORD       dwfOptions;
    //
    // Location/phone number
    //
    DWORD       dwCountryID;
    DWORD       dwCountryCode;
    WCHAR       szAreaCode[ RAS_MaxAreaCode + 1 ];
    WCHAR       szLocalPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    DWORD       dwAlternateOffset;
    //
    // PPP/Ip
    //
    RASIPADDR   ipaddr;
    RASIPADDR   ipaddrDns;
    RASIPADDR   ipaddrDnsAlt;
    RASIPADDR   ipaddrWins;
    RASIPADDR   ipaddrWinsAlt;
    //
    // Framing
    //
    DWORD       dwFrameSize;
    DWORD       dwfNetProtocols;
    DWORD       dwFramingProtocol;
    //
    // Scripting
    //
    WCHAR       szScript[ MAX_PATH ];
    //
    // AutoDial
    //
    WCHAR       szAutodialDll[ MAX_PATH ];
    WCHAR       szAutodialFunc[ MAX_PATH ];
    //
    // Device
    //
    WCHAR       szDeviceType[ RAS_MaxDeviceType + 1 ];
    WCHAR       szDeviceName[ RAS_MaxDeviceName + 1 ];
    //
    // X.25
    //
    WCHAR       szX25PadType[ RAS_MaxPadType + 1 ];
    WCHAR       szX25Address[ RAS_MaxX25Address + 1 ];
    WCHAR       szX25Facilities[ RAS_MaxFacilities + 1 ];
    WCHAR       szX25UserData[ RAS_MaxUserData + 1 ];
    DWORD       dwChannels;
    //
    // Reserved
    //
    DWORD       dwReserved1;
    DWORD       dwReserved2;
#if (WINVER >= 0x401)
    //
    // Multilink
    //
    DWORD       dwSubEntries;
    DWORD       dwDialMode;
    DWORD       dwDialExtraPercent;
    DWORD       dwDialExtraSampleSeconds;
    DWORD       dwHangUpExtraPercent;
    DWORD       dwHangUpExtraSampleSeconds;
    //
    // Idle timeout
    //
    DWORD       dwIdleDisconnectSeconds;
#endif

#if (WINVER >= 0x500)
    //
    // Entry Type
    //
    DWORD       dwType;

    //
    // EncryptionType
    //
    DWORD       dwEncryptionType;

    //
    // CustomAuthKey to be used for EAP
    //
    DWORD       dwCustomAuthKey;

    //
    // Guid of the connection
    //
    GUID        guidId;

    //
    // Custom Dial Dll
    //
    WCHAR       szCustomDialDll[MAX_PATH];

    //
    // Vpn Strategy
    //
    DWORD       dwVpnStrategy;
#endif
};


// RasSubEntry (<= v401)
#define RASSUBENTRYA_V401 struct tagRASSUBENTRYA_V401
RASSUBENTRYA_V401
{
    DWORD       dwSize;
    DWORD       dwfFlags;
    //
    // Device
    //
    CHAR        szDeviceType[ RAS_MaxDeviceType + 1 ];
    CHAR        szDeviceName[ RAS_MaxDeviceName + 1 ];
    //
    // Phone numbers
    //
    CHAR        szLocalPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    DWORD       dwAlternateOffset;
};

#define RASSUBENTRYW_V401 struct tagRASSUBENTRYW_V401
RASSUBENTRYW_V401
{
    DWORD       dwSize;
    DWORD       dwfFlags;
    //
    // Device
    //
    WCHAR       szDeviceType[ RAS_MaxDeviceType + 1 ];
    WCHAR       szDeviceName[ RAS_MaxDeviceName + 1 ];
    //
    // Phone numbers
    //
    WCHAR       szLocalPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    DWORD       dwAlternateOffset;
};


/* RAS structures as they appeared in NT 3.5 prior to 3.51 additions.
*/


/* Windows NT 3.5 definitions.
*/

/* Describes the results of a PPP IP (Internet) projection.
*/
#define RASPPPIPW_V35 struct tagRASPPPIPW_V35
RASPPPIPW_V35
{
    DWORD dwSize;
    DWORD dwError;
    WCHAR szIpAddress[ RAS_MaxIpAddress + 1 ];
};

#define RASPPPIPA_V35 struct tagRASPPPIPA_V35
RASPPPIPA_V35
{
    DWORD dwSize;
    DWORD dwError;
    CHAR  szIpAddress[ RAS_MaxIpAddress + 1 ];
};

/* Describes the results of a PPP IP (Internet) projection.
*/
#define RASPPPIPW_V401 struct tagRASPPPIPW_V401
RASPPPIPW_V401
{
    DWORD dwSize;
    DWORD dwError;
    WCHAR szIpAddress[ RAS_MaxIpAddress + 1 ];

#ifndef WINNT35COMPATIBLE

    WCHAR szServerIpAddress[ RAS_MaxIpAddress + 1 ];

#endif
};

#define RASPPPIPA_V401 struct tagRASPPPIPA_V401
RASPPPIPA_V401
{
    DWORD dwSize;
    DWORD dwError;
    CHAR  szIpAddress[ RAS_MaxIpAddress + 1 ];

#ifndef WINNT35COMPATIBLE

    CHAR  szServerIpAddress[ RAS_MaxIpAddress + 1 ];

#endif
};

/* Describes the results of a PPP LCP/multi-link negotiation.
*/
#define RASPPPLCP_V401 struct tagRASPPPLCP_V401
RASPPPLCP_V401
{
    DWORD dwSize;
    BOOL  fBundled;
};

#define LPRASPPPLCP RASPPPLCP*

/*  Putting this here for backward compatibility with RASDIALPARAMS
*   structure as defined in FE version of nt 3.5
*/ 
#define RASDIALPARAMSA_WINNT35J struct tagRASDIALPARAMSA_WINNT35J
RASDIALPARAMSA_WINNT35J
{
    DWORD dwSize;
/* MSKK HitoshiT modified to supprot DBCS 94/9/2  */
    CHAR  szEntryName[ RAS_MaxEntryName_V351 * sizeof( USHORT ) + 1 ];
    CHAR  szPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    CHAR  szCallbackNumber[ RAS_MaxCallbackNumber_V351 + 1 ];
    CHAR  szUserName[ UNLEN + 1 ];
    CHAR  szPassword[ PWLEN + 1 ];
    CHAR  szDomain[ DNLEN * sizeof( USHORT ) + 1 ];
};

/* Describes extended connection establishment options.  (See RasDial)
*/
#define RASDIALEXTENSIONS_401 struct tagRASDIALEXTENSIONS_401
RASDIALEXTENSIONS_401
{
    DWORD dwSize;
    DWORD dwfOptions;
    HWND  hwndParent;
    ULONG_PTR reserved;
};

#include "poppack.h"


#endif /*_RASP_H_*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\inc\rasscrpt.h ===
//============================================================================
// Copyright (c) Microsoft Corporation
//
// File:    rasscrpt.h
//
// History:
//  Abolade-Gbadegesin  Mar-29-96   Created.
//
// Contains declarations for the exported scripting API functions.
//============================================================================

#ifndef _RASSCRPT_H_
#define _RASSCRPT_H_


//
// Flags passed to RasScriptInit:
//
// RASSCRIPT_NotifyOnInput          Caller requires input-notification
// RASSCRIPT_HwndNotify             'hNotifier' is an HWND (defaults to event)
//
#define RASSCRIPT_NotifyOnInput     0x00000001
#define RASSCRIPT_HwndNotify        0x00000002


//
// event codes retrieved using RasScriptGetEventCode
//
#define SCRIPTCODE_Done             0
#define SCRIPTCODE_Halted           1
#define SCRIPTCODE_InputNotify      2
#define SCRIPTCODE_KeyboardEnable   3
#define SCRIPTCODE_KeyboardDisable  4
#define SCRIPTCODE_IpAddressSet     5
#define SCRIPTCODE_HaltedOnError    6


//
// path to log-file containing syntax errors, if any
//
#define RASSCRIPT_LOG               "%windir%\\system32\\ras\\script.log"



DWORD
APIENTRY
RasScriptExecute(
    IN      HRASCONN        hrasconn,
    IN      PBENTRY*        pEntry,
    IN      CHAR*           pszUserName,
    IN      CHAR*           pszPassword,
    OUT     CHAR*           pszIpAddress
    );


DWORD
RasScriptGetEventCode(
    IN      HANDLE          hscript
    );


DWORD
RasScriptGetIpAddress(
    IN      HANDLE          hscript,
    OUT     CHAR*           pszIpAddress
    );


DWORD
APIENTRY
RasScriptInit(
    IN      HRASCONN        hrasconn,
    IN      PBENTRY*        pEntry,
    IN      CHAR*           pszUserName,
    IN      CHAR*           pszPassword,
    IN      DWORD           dwFlags,
    IN      HANDLE          hNotifier,
    OUT     HANDLE*         phscript
    );


DWORD
APIENTRY
RasScriptReceive(
    IN      HANDLE          hscript,
    IN      BYTE*           pBuffer,
    IN OUT  DWORD*          pdwBufferSize
    );


DWORD
APIENTRY
RasScriptSend(
    IN      HANDLE          hscript,
    IN      BYTE*           pBuffer,
    IN      DWORD           dwBufferSize
    );


DWORD
APIENTRY
RasScriptTerm(
    IN      HANDLE          hscript
    );


#endif // _RASSCRPT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\inc\rassapip.h ===
/******************************************************************\
*                     Microsoft Windows NT                         *
*               Copyright(c) Microsoft Corp., 1992                 *
\******************************************************************/

/*++

Module Name:

    RASSAPIP.H

Description:

    This file contains structure defs and defines used in implementing
    the RASADMIN APIs.


Author:

    Michael Salamone (MikeSa)   July 13,1992

Revision History:

--*/


#ifndef _RASSAPIP_H_
#define _RASAAPIP_H_


#define RASSAPI_MAX_CALLBACK_NUMBER_SIZE  48
#define RASSAPI_MAX_DEVICE_NAME_OLD       32

// 3rd party DLLs don't need this version information because they will only
// be administering a NT3.51 or greater server.
#define RAS_SERVER_20      20    // identifies a NT RAS 2.0 server

//
// Number of port statistics returned by a RAS 1.0 server
//
#define RAS10_MAX_STATISTICS 6

//
// RAS10 specific port statistics defines
//

#define RAS10_BYTES_RCVED         0
#define RAS10_BYTES_XMITED        1
#define RAS10_SERIAL_OVERRUN_ERR  2
#define RAS10_TIMEOUT_ERR         3
#define RAS10_FRAMING_ERR         4
#define RAS10_CRC_ERR             5


#define MEDIA_NAME_DEFAULT   L"SERIAL"
#define DEVICE_TYPE_DEFAULT  L"MODEM"
#define DEVICE_NAME_DEFAULT  L"UNKNOWN"

//
// structures used by down level RAS 1.x servers
//

typedef struct tagWpdStatisticsInfo
{
    ULONG stat_bytesreceived;
    ULONG stat_bytesxmitted;
    USHORT stat_overrunerr;
    USHORT stat_timeouterr;
    USHORT stat_framingerr;
    USHORT stat_crcerr;
} WpdStatisticsInfo;


struct dialin_user_info_0
{
    unsigned char duseri0_privilege_mask ;
    char duseri0_phone_number[RASSAPI_MAX_PHONENUMBER_SIZE + 1];
};


struct dialin_user_info_1
{
    struct dialin_user_info_0 duseri0;
    char duseri1_name[LM20_UNLEN+1];
};


struct dialin_user_info_2
{
    struct dialin_user_info_0 duseri0;
    USER_INFO_2 usri2;
};


struct dialin_port_info_0
{
    char dporti0_username[LM20_UNLEN+1];   // name of user using the port

    char dporti0_computer[NETBIOS_NAME_LEN+1]; // computer user dialed in from
                                               // Used when the admin wants to
                                               // send a message to this user

    unsigned short dporti0_comid;          // COM1 = 1 etc

    unsigned long dporti0_time;            // time user dialed in and
                                           // authenticated - number of seconds
                                           // since 00:00:00 Jan 1, 1970

    unsigned short dporti0_line_condition; // If RAS_PORT_AUTHENTICATED, then
                                           // comid, time username and computer
                                           // name fields are valid.

    unsigned short dporti0_modem_condition;
};


struct dialin_port_info_1
{
    struct dialin_port_info_0 dporti0;
    unsigned long dporti1_baud;
    WpdStatisticsInfo dporti1_stats;
};


struct dialin_server_info_0
{
    unsigned short dserveri0_total_ports;
    unsigned short dserveri0_ports_in_use;
};


//
// defined to support RAS 1.x - the max ports in RAS 2.0 and greater
// is 64 (could be greater)
//
#define RAS_MAX_SERVER_PORTS 16


//
// Max length of RAS 1.0 port name including terminating
// NULL character - eg., "COM16"
//
#define RAS10_MAX_PORT_NAME 6


//
// How long a client will wait for a pipe connection (milliseconds)
// if it is busy.
//
#define PIPE_CONNECTION_TIMEOUT   10000L


#define PIPE_BUFSIZE              512


//
// Name of pipe that will be used to process requests
//
#define	RASADMIN_PIPE  TEXT("\\pipe\\dialin\\adminsrv")


//
// Pipe path to which RASADMIN_PIPE should be concatenated for local
// machine
//
#define LOCAL_PIPE     TEXT("\\\\.")


//
// Request codes for RAS 1.x server
//
#define	RASADMINREQ_DISCONNECT_USER	1
#define	RASADMINREQ_GET_PORT_INFO	2
#define	RASADMINREQ_CLEAR_PORT_STATS	3
#define	RASADMINREQ_ENUM_PORTS		4	
#define	RASADMINREQ_GET_SERVER_INFO	5


//
// Request codes for RAS 2.0 server
//
#define RASADMIN20_REQ_DISCONNECT_USER    2001
#define RASADMIN20_REQ_GET_PORT_INFO      2002
#define RASADMIN20_REQ_CLEAR_PORT_STATS   2003
#define RASADMIN20_REQ_ENUM_PORTS         2004
#define RASADMIN20_REQ_ENUM_RESUME        2005


//
// This request code remains the same as in RAS 1.0
// so that, if RAS 1.0 admin tried to connect, it
// will get server info back, but not in the format
// that it recognizes.  It will then be unable to
// admin the RAS 2.0 server.
//
#define RASADMIN20_REQ_GET_SERVER_INFO    5


//
// These can be returned in the RetCode field of server response
// packet sent to the client.  These should not be changed in
// order to preserve compatibility with different versions of
// RASADMIN.
//
#define ERR_NO_SUCH_DEVICE                   635
#define ERR_SERVER_SYSTEM_ERR                636


//
// These are the packets sent back and forth between RAS 1.x server
// and the RASADMIN APIs.
//
struct PortEnumRequestPkt
{
    unsigned short Request;    // ENUM_PORTS
};                             // ENUM_PORTS_TOTALAVAIL


struct PortEnumReceivePkt
{
    unsigned short RetCode;
    unsigned short TotalAvail;
    struct dialin_port_info_0 Data[RAS_MAX_SERVER_PORTS];
};


struct DisconnectUserRequestPkt
{
    unsigned short Request;    // DISCONNECT_USER
    unsigned short ComId;
};


struct DisconnectUserReceivePkt
{
    unsigned short RetCode;
};


struct PortClearRequestPkt
{
    unsigned short Request;    // CLEAR_PORT_STATISTICS
    unsigned short ComId;
};


struct PortClearReceivePkt
{
    unsigned short RetCode;
};


struct ServerInfoRequestPkt
{
    unsigned short Request;    // GET_SERVER_INFO
};


struct ServerInfoReceivePkt
{
    unsigned short RetCode;
    struct dialin_server_info_0 Data;
};


struct PortInfoRequestPkt
{
    unsigned short Request;    // GET_PORT_INFO
    unsigned short ComId;
};


struct PortInfoReceivePkt
{
    unsigned short RetCode;
    struct dialin_port_info_1 Data;
};


//
// These are the packed structures that are sent out on the network.
// It is up to the receiver to unpack and convert to the proper endian
// for the host.
//
typedef struct _P_WPD_STATISTICS_INFO
{
    BYTE stat_bytesreceived[4];
    BYTE stat_bytesxmitted[4];
    BYTE stat_overrunerr[2];
    BYTE stat_timeouterr[2];
    BYTE stat_framingerr[2];
    BYTE stat_crcerr[2];
} P_WPD_STATISTICS_INFO, *PP_WPD_STATISTICS_INFO;


typedef struct _P_DIALIN_PORT_INFO_0
{
    BYTE dporti0_username[LM20_UNLEN+1];   // name of user using the port

    BYTE dporti0_computer[NETBIOS_NAME_LEN+1]; // computer user dialed in from
                                               // Used when the admin wants to
                                               // send a message to this user

    BYTE dporti0_comid[2];                 // COM1 = 1 etc

    BYTE dporti0_time[4];                  // time user dialed in and
                                           // authenticated - number of seconds
                                           // since 00:00:00 Jan 1, 1970

    BYTE dporti0_line_condition[2];        // If RAS_PORT_AUTHENTICATED, then
                                           // comid, time username and computer
                                           // name fields are valid.

    BYTE dporti0_modem_condition[2];
} P_DIALIN_PORT_INFO_0, *PP_DIALIN_PORT_INFO_0;


typedef struct _P_DIALIN_PORT_INFO_1
{
    P_DIALIN_PORT_INFO_0 dporti0;
    BYTE dporti1_baud[4];
    P_WPD_STATISTICS_INFO dporti1_stats;
} P_DIALIN_PORT_INFO_1, *PP_DIALIN_PORT_INFO_1;


typedef struct _P_DIALIN_SERVER_INFO_0
{
    BYTE dserveri0_total_ports[2];
    BYTE dserveri0_ports_in_use[2];
} P_DIALIN_SERVER_INFO_0, *PP_DIALIN_SERVER_INFO_0;


typedef struct _P_PORT_ENUM_REQUEST_PKT
{
    BYTE Request[2];    // ENUM_PORTS
} P_PORT_ENUM_REQUEST_PKT, *PP_PORT_ENUM_REQUEST_PKT;   // ENUM_PORTS_TOTALAVAIL


typedef struct _P_PORT_ENUM_RECEIVE_PKT
{
    BYTE RetCode[2];
    BYTE TotalAvail[2];
    P_DIALIN_PORT_INFO_0 Data[RAS_MAX_SERVER_PORTS];
} P_PORT_ENUM_RECEIVE_PKT, *PP_PORT_ENUM_RECEIVE_PKT;


typedef struct _P_DISCONNECT_USER_REQUEST_PKT
{
    BYTE Request[2];    // DISCONNECT_USER
    BYTE ComId[2];
} P_DISCONNECT_USER_REQUEST_PKT, *PP_DISCONNECT_USER_REQUEST_PKT;


typedef struct _P_DISCONNECT_USER_RECEIVE_PKT
{
    BYTE RetCode[2];
} P_DISCONNECT_USER_RECEIVE_PKT, *PP_DISCONNECT_USER_RECEIVE_PKT;


typedef struct _P_PORT_CLEAR_REQUEST_PKT
{
    BYTE Request[2];    // CLEAR_PORT_STATISTICS
    BYTE ComId[2];
} P_PORT_CLEAR_REQUEST_PKT, *PP_PORT_CLEAR_REQUEST_PKT;


typedef struct _P_PORT_CLEAR_RECEIVE_PKT
{
    BYTE RetCode[2];
} P_PORT_CLEAR_RECEIVE_PKT, *PP_PORT_CLEAR_RECEIVE_PKT;


typedef struct _P_SERVER_INFO_REQUEST_PKT
{
    BYTE Request[2];    // GET_SERVER_INFO
} P_SERVER_INFO_REQUEST_PKT, *PP_SERVER_INFO_REQUEST_PKT;


typedef struct _P_SERVER_INFO_RECEIVE_PKT
{
    BYTE RetCode[2];
    P_DIALIN_SERVER_INFO_0 Data;
} P_SERVER_INFO_RECEIVE_PKT, *PP_SERVER_INFO_RECEIVE_PKT;


typedef struct _P_PORT_INFO_REQUEST_PKT
{
    BYTE Request[2];    // GET_PORT_INFO
    BYTE ComId[2];
} P_PORT_INFO_REQUEST_PKT, *PP_PORT_INFO_REQUEST_PKT;


typedef struct _P_PORT_INFO_RECEIVE_PKT
{
    BYTE RetCode[2];
    P_DIALIN_PORT_INFO_1 Data;
} P_PORT_INFO_RECEIVE_PKT, *PP_PORT_INFO_RECEIVE_PKT;


//
// These are the packets sent back and forth between a RAS 2.0 server
// and the RASADMIN APIs
//
typedef struct tagPortEnumReceivePkt
{
    DWORD RetCode;
    WORD TotalAvail;
    RAS_PORT_0 *Data;
} PORT_ENUM_RECEIVE, *PPORT_ENUM_RECEIVE;


typedef struct tagPortInfoReceivePkt
{
    DWORD RetCode;
    DWORD ReqBufSize;
    RAS_PORT_1 Data;
} PORT_INFO_RECEIVE, *PPORT_INFO_RECEIVE;


typedef struct tagPortClearReceivePkt
{
    DWORD RetCode;
} PORT_CLEAR_RECEIVE, *PPORT_CLEAR_RECEIVE;


typedef struct tagDisconnectUserReceivePkt
{
    DWORD RetCode;
} DISCONNECT_USER_RECEIVE, *PDISCONNECT_USER_RECEIVE;


typedef struct tagServerInfoReceivePkt
{
    WORD RetCode;   // VERY IMPORTANT TO BE A WORD!!! - RAS1.0 COMPATIBILITY
    RAS_SERVER_0 Data;
} SERVER_INFO_RECEIVE, *PSERVER_INFO_RECEIVE;


typedef struct _CLIENT_REQUEST
{
    WORD RequestCode;
    WCHAR PortName[RASSAPI_MAX_PORT_NAME];
    DWORD RcvBufSize;
    DWORD ClientVersion;
} CLIENT_REQUEST, *PCLIENT_REQUEST;



//
// These are the packed structures that are sent out on the network.
// It is up to the receiver to unpack and convert to the proper endian
// for the host.
//

typedef struct _P_RAS_PORT_0
{
    BYTE wszPortName[2 * RASSAPI_MAX_PORT_NAME];
    BYTE wszDeviceType[2 * RASSAPI_MAX_DEVICETYPE_NAME];
    BYTE wszDeviceName[2 * RASSAPI_MAX_DEVICE_NAME_OLD];
    BYTE wszMediaName[2 * RASSAPI_MAX_MEDIA_NAME];
    BYTE reserved[4];
    BYTE Flags[4];
    BYTE wszUserName[2 * (UNLEN + 1)];
    BYTE wszComputer[2 * NETBIOS_NAME_LEN];
    BYTE dwStartSessionTime[4];
    BYTE wszLogonDomain[2 * (DNLEN + 1)];
    BYTE fAdvancedServer[4];
} P_RAS_PORT_0, *PP_RAS_PORT_0;


typedef struct _P_RAS_STATISTIC
{
    BYTE Stat[4];
} P_RAS_STATISTIC, *PP_RAS_STATISTIC;



/* PPP control protocol results returned by RasPppGetInfo.
*/
typedef struct __PPP_NBFCP_RESULT
{
    BYTE dwError[4];
    BYTE dwNetBiosError[4];
    BYTE szName[NETBIOS_NAME_LEN + 1];
    BYTE wszWksta[2 * (NETBIOS_NAME_LEN + 1)];
} P_PPP_NBFCP_RESULT, *PP_PPP_NBFCP_RESULT;

typedef struct __PPP_IPCP_RESULT
{
    BYTE dwError[4];
    BYTE wszAddress[2 * (RAS_IPADDRESSLEN + 1)];
} P_PPP_IPCP_RESULT, *PP_PPP_IPCP_RESULT;

typedef struct __PPP_IPXCP_RESULT
{
    BYTE dwError[4];
    BYTE wszAddress[2 * (RAS_IPXADDRESSLEN + 1)];
} P_PPP_IPXCP_RESULT, *PP_PPP_IPXCP_RESULT;

typedef struct __PPP_ATCP_RESULT
{
    BYTE dwError[4];
    BYTE wszAddress[2 * (RAS_ATADDRESSLEN + 1)];
} P_PPP_ATCP_RESULT, *PP_PPP_ATCP_RESULT;

typedef struct __PPP_PROJECTION_RESULT
{
    P_PPP_NBFCP_RESULT nbf;
    P_PPP_IPCP_RESULT ip;
    P_PPP_IPXCP_RESULT ipx;
    P_PPP_ATCP_RESULT at;
} P_PPP_PROJECTION_RESULT, *PP_PPP_PROJECTION_RESULT;


typedef struct _P_RAS_PORT_1
{
    P_RAS_PORT_0 rasport0;
    BYTE LineCondition[4];
    BYTE HardwareCondition[4];
    BYTE LineSpeed[4];      // in bits/second
    BYTE NumStatistics[2];
    BYTE NumMediaParms[2];
    BYTE SizeMediaParms[4];
    P_PPP_PROJECTION_RESULT ProjResult;
} P_RAS_PORT_1, *PP_RAS_PORT_1;


typedef struct _P_RAS_FORMAT
{
    BYTE Format[4];
} P_RAS_FORMAT, *PP_RAS_FORMAT;


typedef union _P_RAS_VALUE
{
    BYTE Number[4];
    struct
    {
        BYTE Length[4];
        BYTE Offset[4];
    } String;
} P_RAS_VALUE, *PP_RAS_VALUE;


typedef struct _P_RAS_PARAMS
{
    BYTE P_Key[RASSAPI_MAX_PARAM_KEY_SIZE];
    P_RAS_FORMAT P_Type;
    BYTE P_Attributes;
    P_RAS_VALUE P_Value;
} P_RAS_PARAMS, *PP_RAS_PARAMS;


typedef struct _P_RAS_SERVER_0
{
    BYTE TotalPorts[2];
    BYTE PortsInUse[2];
    BYTE RasVersion[4];
} P_RAS_SERVER_0, *PP_RAS_SERVER_0;


typedef struct _P_PORT_ENUM_RECEIVE
{
    BYTE RetCode[4];
    BYTE TotalAvail[2];
    P_RAS_PORT_0 Data[1];
} P_PORT_ENUM_RECEIVE, *PP_PORT_ENUM_RECEIVE;


typedef struct _P_PORT_INFO_RECEIVE
{
    BYTE RetCode[4];
    BYTE ReqBufSize[4];
    P_RAS_PORT_1 Data;
} P_PORT_INFO_RECEIVE, *PP_PORT_INFO_RECEIVE;


typedef struct _P_PORT_CLEAR_RECEIVE
{
    BYTE RetCode[4];
} P_PORT_CLEAR_RECEIVE, *PP_PORT_CLEAR_RECEIVE;


typedef struct _P_DISCONNECT_USER_RECEIVE
{
    BYTE RetCode[4];
} P_DISCONNECT_USER_RECEIVE, *PP_DISCONNECT_USER_RECEIVE;


typedef struct _P_SERVER_INFO_RECEIVE
{
    BYTE RetCode[2];
    P_RAS_SERVER_0 Data;
} P_SERVER_INFO_RECEIVE, *PP_SERVER_INFO_RECEIVE;


typedef struct _P_CLIENT_REQUEST
{
    BYTE RequestCode[2];
    BYTE PortName[2 * RASSAPI_MAX_PORT_NAME];
    BYTE RcvBufSize[4];
    BYTE ClientVersion[4];
} P_CLIENT_REQUEST, *PP_CLIENT_REQUEST;


//
// The following macros deal with on-the-wire integer and long values
// On the wire format is little-endian i.e. a long value of 0x01020304 is
// represented as 04 03 02 01. Similarly an int value of 0x0102 is
// represented as 02 01.
//
// The host format is not assumed since it will vary from processor to
// processor.
//

// Get a short from on-the-wire format to the host format
#define GETUSHORT(DstPtr, SrcPtr)               \
    *(unsigned short *)(DstPtr) =               \
        ((*((unsigned char *)(SrcPtr)+1) << 8) +\
        (*((unsigned char *)(SrcPtr)+0)))

// Get a dword from on-the-wire format to the host format
#define GETULONG(DstPtr, SrcPtr)                 \
    *(unsigned long *)(DstPtr) =                 \
        ((*((unsigned char *)(SrcPtr)+3) << 24) +\
        (*((unsigned char *)(SrcPtr)+2) << 16) + \
        (*((unsigned char *)(SrcPtr)+1) << 8)  + \
        (*((unsigned char *)(SrcPtr)+0)))


// Put a ushort from the host format to on-the-wire format
#define PUTUSHORT(DstPtr, Src)   \
    *((unsigned char *)(DstPtr)+1)=(unsigned char)((unsigned short)(Src) >> 8),\
    *((unsigned char *)(DstPtr)+0)=(unsigned char)(Src)

// Put a ulong from the host format to on-the-wire format
#define PUTULONG(DstPtr, Src)   \
    *((unsigned char *)(DstPtr)+3)=(unsigned char)((unsigned long)(Src) >> 24),\
    *((unsigned char *)(DstPtr)+2)=(unsigned char)((unsigned long)(Src) >> 16),\
    *((unsigned char *)(DstPtr)+1)=(unsigned char)((unsigned long)(Src) >>  8),\
    *((unsigned char *)(DstPtr)+0)=(unsigned char)(Src)


#endif // _RASSAPIP_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\inc\rassrvrc.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by rassrvui.rc
//
#define VER_PRODUCTVER                  0074
#define DID_UserTab_New                 7000
#define CID_UserTab_New_EB_Username     7001
#define CID_UserTab_New_EB_Fullname     7002
#define CID_UserTab_New_EB_Password1    7003
#define CID_UserTab_New_EB_Password2    7004
#define DID_UserTab_Callback            7005
#define CID_UserTab_Callback_RB_Caller  7006
#define CID_UserTab_Callback_RB_Admin   7007
#define CID_UserTab_Callback_EB_Number  7008
#define CID_UserTab_Callback_RB_No      7009
#define PID_GenTab                      7010
#define CID_GenTab_LV_Devices           7011
#define CID_GenTab_CB_Multilink         7012
#define CID_GenTab_PB_Properties        7013
#define CID_GenTab_CB_Vpn               7014
#define CID_GenTab_CB_ShowIcons         7015
#define DID_NetTab_Tcpipui              7016
#define CID_NetTab_Tcpipui_CB_ExposeNetwork 7017
#define CID_NetTab_Tcpipui_EB_Start     7018
#define CID_NetTab_Tcpipui_RB_Dhcp      7019
#define CID_NetTab_Tcpipui_RB_StaticPool 7020
#define CID_NetTab_Tcpipui_EB_Mask      7021
#define CID_NetTab_Tcpipui_CB_CallerSpec 7022
#define CID_NetTab_Tcpipui_EB_Range     7023
#define CID_NetTab_Tcpipui_EB_Total     7024
#define DID_NetTab_Ipxui                7025
#define CID_NetTab_Ipxui_RB_AutoAssign  7026
#define CID_NetTab_Ipxui_RB_ManualAssign 7027
#define CID_NetTab_Ipxui_CB_AssignSame  7028
#define CID_NetTab_Ipxui_EB_Netnum      7029
#define CID_NetTab_Ipxui_ST_Network     7030
#define CID_NetTab_Ipxui_CB_CallerSpec  7031
#define CID_NetTab_Ipxui_CB_ExposeNetwork 7032
#define DID_NetTab_GenProt              7033
#define CID_NetTab_GenProt_CB_ExposeNetwork 7034
#define PID_NetTab                      7035
#define CID_NetTab_LV_Components        7036
#define CID_NetTab_PB_Add               7037
#define CID_NetTab_PB_Remove            7038
#define CID_NetTab_PB_Properties        7039
#define CID_NetTab_ST_Description       7040
#define CID_NetTab_PB_SwitchToMMC       7041
#define PID_UserTab                     7042
#define CID_UserTab_LV_Users            7043
#define CID_UserTab_PB_New              7044
#define CID_UserTab_PB_Delete           7045
#define CID_UserTab_PB_Properties       7046
#define CID_UserTab_PB_SwitchToMMC      7047
#define CID_UserTab_CB_Encryption       7048
#define PID_Wizard_UserTab              7049
#define CID_UserTab_CB_BypassDcc        7049
#define PID_Wizard_GenTab               7050
#define PID_Wizard_NetTab               7051
#define PID_Wizard_Vpn                  7052
#define CID_Wizard_Vpn_RB_Yes           7053
#define CID_Wizard_Vpn_RB_No            7054
#define PID_Wizard_Dccdev               7055
#define CID_Wizard_Dccdev_LB_Devices    7056
#define CID_UserTab_ST_AdvancedGroup    7057
#define CID_UserTab_ST_AdvancedText     7058
#define CID_NetTab_ST_AdvancedGroup     7059
#define CID_NetTab_ST_AdvancedText      7060
#define CID_Dccdev_PB_Properties        7061
#define SID_TCPIP_TITLE                 7301
#define SID_TCPIP_BADRANGE              7302
#define SID_TCPIP                       7303
#define SID_IPX                         7304
#define SID_NETBUI                      7305
#define ERR_GENERIC_CATAGORY            7306
#define ERR_GENERALTAB_CATAGORY         7307
#define ERR_USERTAB_CATAGORY            7308
#define ERR_ADVANCEDTAB_CATAGORY        7309
#define ERR_MULTILINK_CATAGORY          7310
#define ERR_RASSRV_CATAGORY             7311
#define ERR_GLOBAL_CATAGORY             7312
#define ERR_TCPIPPROP_CATAGORY          7313
#define ERR_IPXPROP_CATAGORY            7314
#define ERR_QUEUE_PROPERTY              7315
#define ERR_QUEUE_CATAGORY              7315
#define ERR_GENERIC_SUBCAT              7316
#define ERR_DEVICEDB_SUBCAT             7317
#define ERR_MISCDB_SUBCAT               7318
#define ERR_USERDB_SUBCAT               7319
#define ERR_PROTDB_SUBCAT               7320
#define ERR_LOGON_NAME_TOO_SMALL        7321
#define ERR_PASSWORD_TOO_SMALL          7322
#define ERR_PASSWORD_MISMATCH           7323
#define ERR_GENERIC_CODE                7324
#define ERR_LISTVIEW_SUBCAT             7325
#define ERR_USER_CANT_COMMIT_CHANGES    7326
#define ERR_CANT_ADD_USER_ACCESS        7327
#define ERR_CANT_ADD_USER_DUPLICATE     7328
#define ERR_CANT_ADD_USER_PASSWORD      7329
#define ERR_USER_CANT_RELOAD            7330
#define ERR_USER_DATABASE_CORRUPT       7331
#define ERR_USER_RESOURCE_ERROR         7332
#define ERR_USER_CANT_ROLLBACK_CHANGES  7333
#define ERR_DEVICE_DATABASE_CORRUPT     7334
#define ERR_GENERAL_RESOURCE            7335
#define ERR_GENERAL_CANT_COMMIT_CHANGES 7336
#define ERR_GENERAL_CANT_ROLLBACK_CHANGES 7337
#define ERR_PROT_DATABASE_CORRUPTED     7338
#define ERR_PROT_RESOURCE_ERROR         7339
#define ERR_PROT_CANT_COMMIT_CHANGES    7340
#define ERR_PROT_CANT_ROLLBACK_CHANGES  7341
#define ERR_TCPIP_CANT_SAVE             7342
#define ERR_IPX_CANT_SAVE               7343
#define ERR_TCPIP_CANT_DISPLAY          7344
#define ERR_IPX_CANT_DISPLAY            7345
#define ERR_TCPIP_CANT_LOAD             7346
#define ERR_IPX_CANT_LOAD               7347
#define ERR_SERVICE_CANT_START          7348
#define ERR_CANT_SHOW_NETTAB_INETCFG    7349
#define ERR_CANT_ADD_USER_GENERIC       7350
#define ERR_CANT_DELETE_USER_GENERAL    7351
#define ERR_CANT_REMOVE_NETCOMP_INUSE   7352
#define WRN_TITLE                       7353
#define WRN_DELETE_USER_PERMANENT       7354
#define WRN_SWITCHING_TO_MMC            7355
#define WRN_NETMASK_CHANGED             7356
#define SID_WIZUSERTITLE                7357
#define SID_WIZUSERSUBTITLE             7358
#define SID_WIZDEVICETITLE              7359
#define SID_WIZDEVICESUBTITLE           7360
#define SID_WIZVPNTITLE                 7361
#define SID_WIZVPNSUBTITLE              7362
#define SID_WIZPROTTITLE                7363
#define SID_WIZPROTSUBTITLE             7364
#define SID_WIZFINISHTITLE              7365
#define SID_WIZFINISHSUBTITLE           7366
#define SID_DEFAULT_CONNECTION_NAME     7367
#define SID_TCPIP_DESC                  7368
#define SID_IPX_DESC                    7369
#define SID_NBF_DESC                    7370
#define SID_NO_DEVICES1                 7371
#define SID_NO_DEVICES2                 7372
#define SID_NETWORKNUMBERLABEL          7373
#define SID_STARTNETNUMLABEL            7374
#define SID_NEWUSER                     7375
#define SID_WIZDCCDEVTITLE              7376
#define SID_WIZDCCDEVSUBTITLE           7377
#define SID_NO_DCC_DEVICES_INSTALLED    7378
#define WRN_WIZARD_NOT_ALLOWED_TITLE    7379
#define PID_Wizard_SwitchMmc            7379
#define WRN_WIZARD_NOT_ALLOWED_MSG      7380
#define SID_AUTO_NETNUM_LABEL           7381
#define SID_AUTO_NETNUMS_LABEL          7382
#define ERR_IPX_BAD_POOL_CONFIG         7383
#define SID_TCPIP_RANGE_SEPARATOR       7384
#define SID_COMPORT_FORMAT              7385
#define WRN_USERS_CONFIGURED_MMC        7386
#define ERR_CALLBACK_NUM_REQUIRED       7387
#define WRN_REBOOT_REQUIRED             7388
#define ERR_DEVICE_HAS_NO_CONFIG        7389
#define SID_TCPIP_RANGE_INVALID         7390
#define SID_STOP_FP_SERVICE             7391
#define SID_COM_PORT_NOT_ENABLED        7392
#define SID_DEFAULT_MSG_TITLE           7393
#define SID_TCPIP_InvalidPool           7394
#define SID_TCPIP_InvalidMask           7395
#define SID_TCPIP_InvalidNetId          7396
#define SID_TCPIP_NetidTooSpecific      7397
#define SID_TCPIP_NetidMaskSame         7398
#define SID_SERVICE_StopPending         7399
#define SID_DEVICE_DccDeviceFormat      7400
#define SID_DEVICE_MultiEndpointDeviceFormat 7401
#define SID_PPTP_Title                  7402
#define SID_L2TP_Title                  7403
#define SID_IKE_Title                   7404
#define SID_LoopbackAddr                7405
#define ERR_SERVICE_NOT_GRANTED         7406
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        7380
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         7062
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\inc\rassrvp.h ===
/*
    File    rassrvp.h

    Private header used to merge the ras server ui module
    with rasdlg.dll.

    Paul Mayfield, 12/4/97
*/

#ifndef __rassrv_private_header_for_merging
#define __rassrv_private_header_for_merging

// Callbacks for when processes/threads attach to this dll
DWORD RassrvHandleProcessAttach (HINSTANCE hInstDll, LPVOID pReserved);
DWORD RassrvHandleProcessDetach (HINSTANCE hInstDll, LPVOID pReserved);
DWORD RassrvHandleThreadAttach (HINSTANCE hInstDll, LPVOID pReserved);
DWORD RassrvHandleThreadDetach (HINSTANCE hInstDll, LPVOID pReserved);

// Function adds the host-side direct connect wizard pages
DWORD
APIENTRY
RassrvAddDccWizPages (
    IN LPFNADDPROPSHEETPAGE pfnAddPage,
    IN LPARAM               lParam,
    IN OUT PVOID *          ppvContext);

// Function causes the ras-server specific wizard pages 
// to allow activation or not.
DWORD
APIENTRY
RassrvShowWizPages (
    IN PVOID pvContext,         // Context to be affected
    IN BOOL bShow);             // TRUE to show, FALSE to hide

// Saves any server changes related to the 
// given type.
DWORD 
APIENTRY
RassrvCommitSettings (
    IN PVOID pvContext,         // Context to commit
    IN DWORD dwRasWizType);     // Type of settings to commit

// Function returns the suggested name for an incoming connection. 
DWORD
APIENTRY
RassrvGetDefaultConnectionName (
    IN OUT PWCHAR pszBuffer,            // Buffer in which to place name
    IN OUT LPDWORD lpdwBufSize);        // Size of buffer in bytes

// Returns the maximum number of pages for the
// a ras server wizard of the given type
DWORD 
APIENTRY
RassrvQueryMaxPageCount(
    IN DWORD dwRasWizType);
    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\inc\rautil.h ===
/* Copyright (c) 1995, Microsoft Corporation, all rights reserved
**
** rautil.h
** Remote Access RASAPI utility library
** Public header
**
** 12/26/95 Steve Cobb
*/

#ifndef _RAUTIL_H_
#define _RAUTIL_H_


#include <list.h>    // for LIST_ENTRY definitions
#include <serial.h>  // RAS serial media header, for SERIAL_TXT
#include <isdn.h>    // RAS ISDN media header, for ISDN_TXT
#include <x25.h>     // RAS X.25 media header, for X25_TXT
#include <rasmxs.h>  // RAS modem/X.25/switch device header, for MXS_*_TXT
#include <ras.h>     // Win32 RAS header, for constants


/*----------------------------------------------------------------------------
** Prototypes
**----------------------------------------------------------------------------
*/

DWORD
FreeRasconnList(
    LIST_ENTRY *pListHead );

DWORD
GetRasconnList(
    LIST_ENTRY *pListHead );

DWORD
GetRasconnTable(
    OUT RASCONN** ppConnTable,
    OUT DWORD*    pdwConnCount );

DWORD
GetRasEntrynameTable(
    OUT RASENTRYNAME**  ppEntrynameTable,
    OUT DWORD*          pdwEntrynameCount );

DWORD
GetRasProjectionInfo(
    IN  HRASCONN    hrasconn,
    OUT RASAMB*     pamb,
    OUT RASPPPNBF*  pnbf,
    OUT RASPPPIP*   pip,
    OUT RASPPPIPX*  pipx,
    OUT RASPPPLCP*  plcp,
    OUT RASSLIP*    pslip,
    OUT RASPPPCCP*  pccp);

HRASCONN
HrasconnFromEntry(
    IN TCHAR* pszPhonebook,
    IN TCHAR* pszEntry );


#endif // _RAUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\inc\rcids.h ===
//THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
//ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
//THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//
// Copyright  1993-1995  Microsoft Corporation.  All Rights Reserved.
//
//      MODULE:         rcids.h
//
//      PURPOSE:        Constant definitions for resources
//
//	PLATFORMS:	Windows 95
//
//      FUNCTIONS:      N/A
//
//	SPECIAL INSTRUCTIONS: N/A
//

#define IDI_SCRIPT              100

#define IDD_TERMINALDLG         1000
#define CID_T_EB_SCREEN         (IDD_TERMINALDLG)
#define CID_T_PB_ENTER          (IDD_TERMINALDLG+1)
#define CID_T_CB_INPUT          (IDD_TERMINALDLG+2)
#define CID_T_CB_MIN            (IDD_TERMINALDLG+3)

#define IDD_TERMINALTESTDLG     2000
#define CID_T_ST_FILE           (IDD_TERMINALTESTDLG+2)
#define CID_T_EB_SCRIPT         (IDD_TERMINALTESTDLG+3)
#define CID_T_PB_STEP           (IDD_TERMINALTESTDLG+4)

#define IDC_STATIC              -1

//
// String IDs
//

#define IDS_ERR_ScriptNotFound      (IDS_ERR_BASE+0x0001)
#define IDS_ERR_UnexpectedEOF       (IDS_ERR_BASE+0x0002)
#define IDS_ERR_SyntaxError         (IDS_ERR_BASE+0x0003)
#define IDS_ERR_MainProcMissing     (IDS_ERR_BASE+0x0004)
#define IDS_ERR_IdentifierMissing   (IDS_ERR_BASE+0x0005)
#define IDS_ERR_StringMissing       (IDS_ERR_BASE+0x0006)
#define IDS_ERR_IntMissing          (IDS_ERR_BASE+0x0007)
#define IDS_ERR_InvalidType         (IDS_ERR_BASE+0x0008)
#define IDS_ERR_OutOfMemory         (IDS_ERR_BASE+0x0009)
#define IDS_ERR_InternalError       (IDS_ERR_BASE+0x000a)
#define IDS_ERR_InvalidParam        (IDS_ERR_BASE+0x000b)
#define IDS_ERR_InvalidIPParam      (IDS_ERR_BASE+0x000c)
#define IDS_ERR_InvalidPortParam    (IDS_ERR_BASE+0x000d)
#define IDS_ERR_InvalidRange        (IDS_ERR_BASE+0x000e)
#define IDS_ERR_InvalidScreenParam  (IDS_ERR_BASE+0x000f)
#define IDS_ERR_RParenMissing       (IDS_ERR_BASE+0x0010)
#define IDS_ERR_RequireInt          (IDS_ERR_BASE+0x0011)
#define IDS_ERR_RequireString       (IDS_ERR_BASE+0x0012)
#define IDS_ERR_RequireBool         (IDS_ERR_BASE+0x0013)
#define IDS_ERR_RequireIntString    (IDS_ERR_BASE+0x0014)
#define IDS_ERR_TypeMismatch        (IDS_ERR_BASE+0x0015)
#define IDS_ERR_Redefined           (IDS_ERR_BASE+0x0016)
#define IDS_ERR_Undefined           (IDS_ERR_BASE+0x0017)
#define IDS_ERR_RequireLabel        (IDS_ERR_BASE+0x0018)
#define IDS_ERR_DivByZero           (IDS_ERR_BASE+0x0019)
#define IDS_ERR_RequireIntStrBool   (IDS_ERR_BASE+0x001a)

#define IDS_CAP_Script              (IDS_RANDO_BASE+0x0001)

#define IDS_IP_Address              (IDS_RANDO_BASE+0X002)

#define IDS_RUN                     (IDS_RANDO_BASE+0X0010)
#define IDS_TEST                    (IDS_RANDO_BASE+0X0011)
#define IDS_COMPLETE                (IDS_RANDO_BASE+0X0012)
#define IDS_HALT                    (IDS_RANDO_BASE+0X0013)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\inc\rassrvrh.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by rassrvui.rc
// Generated by Paul Mayfield
//
#define IDH_UserTab_LV_Users                  7001
#define IDH_UserTab_PB_SwitchToMMC            7002
#define IDH_UserTab_New_EB_Username           7004
#define IDH_UserTab_New_EB_Fullname           7005
#define IDH_UserTab_New_EB_Password1          7006
#define IDH_UserTab_New_EB_Password2          7007
#define IDH_UserTab_Callback_RB_Admin         7008
#define IDH_UserTab_Callback_EB_Number        7009
#define IDH_UserTab_Callback_RB_No            7010
#define IDH_GenTab_LV_Devices                 7011
#define IDH_GenTab_CB_Multilink               7012
#define IDH_GenTab_PB_Properties              7013
#define IDH_GenTab_CB_Vpn                     7014
#define IDH_GenTab_CB_ShowIcons               7015
#define IDH_NetTab_LV_Components              7016
#define IDH_NetTab_PB_Properties              7017
#define IDH_NetTab_PB_Remove                  7018
#define IDH_NetTab_PB_Add                     7019
#define IDH_NetTab_Tcpipui_EB_Start           7020
#define IDH_NetTab_Tcpipui_RB_Dhcp            7021
#define IDH_NetTab_Tcpipui_RB_StaticPool      7022
#define IDH_NetTab_Tcpipui_EB_Mask            7023
#define IDH_NetTab_Tcpipui_CB_CallerSpec      7024
#define IDH_NetTab_Ipxui_RB_AutoAssign        7025
#define IDH_NetTab_Ipxui_RB_ManualAssign      7026
#define IDH_NetTab_Ipxui_CB_AssignSame        7027
#define IDH_NetTab_Ipxui_EB_Netnum            7028
#define IDH_UserTab_CB_Encryption             7063
#define IDH_UserTab_PB_New                    7065
#define IDH_UserTab_PB_Delete                 7066
#define IDH_UserTab_PB_Properties             7067
#define IDH_Wizard_Dccdev_LB_Devices          7068
#define IDH_NetTab_Ipxui_CB_CallerSpec        7069
#define IDH_UserTab_Callback_RB_Caller        7071

#define IDH_UserTab_CB_BypassDcc              7072
#define IDH_NetTab_Tcpipui_CB_ExposeNetwork   7073
#define IDH_NetTab_Tcpipui_EB_Range           7074
#define IDH_NetTab_Tcpipui_EB_Total           7075
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\inc\rnk.h ===
/* Copyright (c) 1996, Microsoft Corporation, all rights reserved
**
** rnk.h
** Remote Access shortcut file (.RNK) library
** Public header
**
** 02/15/96 Steve Cobb
*/

#ifndef _RNK_H_
#define _RNK_H_


/*----------------------------------------------------------------------------
** Constants
**----------------------------------------------------------------------------
*/

#define RNK_SEC_Main      "Dial-Up Shortcut"
#define RNK_KEY_Phonebook "Phonebook"
#define RNK_KEY_Entry     "Entry"


/*----------------------------------------------------------------------------
** Datatypes
**----------------------------------------------------------------------------
*/

/* Information read from the .RNK file.
*/
#define RNKINFO struct tagRNKINFO
RNKINFO
{
    TCHAR* pszPhonebook;
    TCHAR* pszEntry;
};


/*----------------------------------------------------------------------------
** Prototypes
**----------------------------------------------------------------------------
*/

VOID
FreeRnkInfo(
    IN RNKINFO* pInfo );

RNKINFO*
ReadShortcutFile(
    IN TCHAR* pszRnkPath );

DWORD
WriteShortcutFile(
    IN TCHAR* pszRnkPath,
    IN TCHAR* pszPbkPath,
    IN TCHAR* pszEntry );


#endif // _RNK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\inc\rmutil.h ===
/* Copyright (c) 1995, Microsoft Corporation, all rights reserved
**
** rmutil.h
** Remote Access RASMAN utility library
** Public header
**
** 06/20/95 Steve Cobb
** 12/26/95 Merge Abolade Gbadesin routines
*/

#ifndef _RMUTIL_H_
#define _RMUTIL_H_


#include <rasman.h>  // RAS connection manager header
#include <serial.h>  // RAS serial media header, for SERIAL_TXT
#include <isdn.h>    // RAS ISDN media header, for ISDN_TXT
#include <x25.h>     // RAS X.25 media header, for X25_TXT
#include <rasmxs.h>  // RAS modem/X.25/switch device header, for MXS_*_TXT
#include <ras.h>     // Win32 RAS header, for constants

/* Private RASAPI32 entrypoints.
*/
extern HPORT APIENTRY RasGetHport( HRASCONN );
extern DWORD APIENTRY RasSetOldPassword( HRASCONN, CHAR* );


/*----------------------------------------------------------------------------
** Constants
**----------------------------------------------------------------------------
*/

/* String translation flags.
*/
#define XLATE_Ctrl      0x00000001
#define XLATE_Cr        0x00000002
#define XLATE_CrSpecial 0x00000004
#define XLATE_Lf        0x00000008
#define XLATE_LfSpecial 0x00000010
#define XLATE_LAngle    0x00000020
#define XLATE_RAngle    0x00000040
#define XLATE_BSlash    0x00000080
#define XLATE_SSpace    0x00000100

#define XLATE_None          0
#define XLATE_Diagnostic    (XLATE_Ctrl)
#define XLATE_ErrorResponse (XLATE_Ctrl | XLATE_LAngle | XLATE_RAngle \
                               | XLATE_BSlash | XLATE_CrSpecial \
                               | XLATE_LfSpecial)

/*----------------------------------------------------------------------------
** Datatypes
**----------------------------------------------------------------------------
*/
struct RASDEV {

    HANDLE          RD_Handle;
    DWORD           RD_Flags;
    PTSTR           RD_DeviceName;
    TCHAR           RD_PortName[MAX_PORT_NAME + 1];
    TCHAR           RD_DeviceType[RAS_MaxDeviceType + 1];

};

typedef struct RASDEV RASDEV, *PRASDEV, FAR *LPRASDEV;

#define RDFLAG_DialIn       0x00000001
#define RDFLAG_DialOut      0x00000002
#define RDFLAG_Router       0x00000004
#define RDFLAG_IsDialedIn   0x00000008
#define RDFLAG_IsDialedOut  0x00000010
#define RDFLAG_IsRouter     0x00000020
#define RDFLAG_User1        0x80000000


struct RASDEVSTATS {

    DWORD           RDS_Condition;
    DWORD           RDS_Flags;
    DWORD           RDS_LineSpeed;
    DWORD           RDS_ConnectTime;
    DWORD           RDS_InBytes;
    DWORD           RDS_InFrames;
    DWORD           RDS_InCompRatio;
    DWORD           RDS_OutBytes;
    DWORD           RDS_OutFrames;
    DWORD           RDS_OutCompRatio;
    DWORD           RDS_InBytesTotal;
    DWORD           RDS_OutBytesTotal;
    DWORD           RDS_ErrCRC;
    DWORD           RDS_ErrTimeout;
    DWORD           RDS_ErrAlignment;
    DWORD           RDS_ErrFraming;
    DWORD           RDS_ErrHwOverruns;
    DWORD           RDS_ErrBufOverruns;
    HRASCONN        RDS_Hrasconn;

};

typedef struct RASDEVSTATS RASDEVSTATS, *PRASDEVSTATS;


struct RASCONNENTRY {

    LIST_ENTRY      RCE_Node;
    RASCONN        *RCE_Entry;
    LIST_ENTRY      RCE_Links;

};

typedef struct RASCONNENTRY RASCONNENTRY, *PRASCONNENTRY;


struct RASCONNLINK {

    LIST_ENTRY      RCL_Node;
    RASCONN         RCL_Link;

};

typedef struct RASCONNLINK RASCONNLINK, *PRASCONNLINK;


/*----------------------------------------------------------------------------
** Prototypes
**----------------------------------------------------------------------------
*/

DWORD
ClearRasdevStats(
    IN RASDEV*  pdev,
    IN BOOL     fBundle );

DWORD
DeviceIdFromDeviceName(
    TCHAR* pszDeviceName );

DWORD
FreeRasdevTable(
    RASDEV* pDevTable,
    DWORD   iDevCount );

DWORD
GetRasConnection0Table(
    OUT RAS_CONNECTION_0 ** ppRc0Table,
    OUT DWORD *             piRc0Count );

DWORD
GetConnectTime(
    IN  HRASCONN hrasconn,
    OUT DWORD*   pdwConnectTime );

DWORD
GetRasconnFraming(
    IN  HRASCONN hrasconn,
    OUT DWORD*   pdwSendFraming,
    OUT DWORD*   pdwRecvFraming );

DWORD
GetRasconnFromRasdev(
    IN  RASDEV*   pdev,
    OUT RASCONN** ppconn,
    IN  RASCONN*  pConnTable OPTIONAL,
    IN  DWORD     iConnCount OPTIONAL );

DWORD
GetRasdevBundle(
    IN  RASDEV*  pdev,
    OUT DWORD*   pdwBundle );

DWORD
GetRasdevFraming(
    IN  RASDEV*  pdev,
    OUT DWORD*   pdwFraming );

DWORD
GetRasdevFromRasconn(
    IN  RASCONN* pconn,
    OUT RASDEV** ppdev,
    IN  RASDEV*  pDevTable OPTIONAL,
    IN  DWORD    iDevCount OPTIONAL );

DWORD
GetRasdevFromRasPort0(
    IN  RAS_PORT_0* pport,
    OUT RASDEV**    ppdev,
    IN  RASDEV*     pDevTable OPTIONAL,
    IN  DWORD       iDevCount OPTIONAL );

DWORD
GetRasDeviceString(
    IN  HPORT  hport,
    IN  CHAR*  pszDeviceType,
    IN  CHAR*  pszDeviceName,
    IN  CHAR*  pszKey,
    OUT CHAR** ppszValue,
    IN  DWORD  dwXlate );

DWORD
GetRasdevStats(
    IN  RASDEV*      pdev,
    OUT RASDEVSTATS* pstats );

DWORD
GetRasdevTable(
    OUT RASDEV** ppDevTable,
    OUT DWORD*   piDevCount );

DWORD
GetRasMessage(
    IN  HRASCONN hrasconn,
    OUT TCHAR**  ppszMessage );

DWORD
GetRasPads(
    OUT RASMAN_DEVICE** ppDevices,
    OUT DWORD*          pdwEntries );

DWORD
GetRasPort0FromRasdev(
    IN  RASDEV*         pdev,
    OUT RAS_PORT_0**    ppport,
    IN  RAS_PORT_0*     pPortTable OPTIONAL,
    IN  DWORD           iPortCount OPTIONAL );

DWORD
GetRasPort0Info(
    IN  HANDLE          hPort,
    OUT RAS_PORT_1 *    pRasPort1 );

DWORD
GetRasPort0Table(
    OUT RAS_PORT_0 **   ppPortTable,
    OUT DWORD *         piPortCount );

TCHAR *
GetRasPort0UserString(
    IN  RAS_PORT_0 *    pport,
    IN  TCHAR *         pszUser );

VOID
GetRasPortMaxBps(
    IN  HPORT  hport,
    OUT DWORD* pdwMaxConnectBps,
    OUT DWORD* pdwMaxCarrierBps );

VOID
GetRasPortModemSettings(
    IN  HPORT hport,
    OUT BOOL* pfHwFlowDefault,
    OUT BOOL* pfEcDefault,
    OUT BOOL* pfEccDefault );

DWORD
GetRasPorts(
    IN  HANDLE        hConnection,
    OUT RASMAN_PORT** ppPorts,
    OUT DWORD*        pdwEntries );

DWORD
GetRasPortString(
    IN  HPORT  hport,
    IN  CHAR*  pszKey,
    OUT CHAR** ppszValue,
    IN  DWORD  dwXlate );

DWORD
GetRasSwitches(
    IN  HANDLE          hConnection,
    OUT RASMAN_DEVICE** ppDevices,
    OUT DWORD*          pdwEntries );

TCHAR*
GetRasX25Diagnostic(
    IN HRASCONN hrasconn );

BOOL
IsRasdevBundled(
    IN  RASDEV* prasdev,
    IN  RASDEV* pDevTable,
    IN  DWORD   iDevCount );

CHAR*
PszFromRasValue(
    IN RAS_VALUE* prasvalue,
    IN DWORD      dwXlate );

DWORD
RasPort0Hangup(
    IN  HANDLE      hPort );

#endif // _RMUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\inc\tapiutil.h ===
/* Copyright (c) 1996, Microsoft Corporation, all rights reserved
**
** tapiutil.h
** TAPI helper routines
** Public header
**
** 06/18/95 Steve Cobb
*/

#ifndef _TAPIUTIL_H_
#define _TAPIUTIL_H_


#include <tapi.h>


/*----------------------------------------------------------------------------
** Datatypes
**----------------------------------------------------------------------------
*/

/* Information about a TAPI location.  See GetLocationInfo.
*/
#define LOCATION struct tagLOCATION
LOCATION
{
    TCHAR* pszName;
    DWORD  dwId;
};


/* Information about a TAPI country.  See GetCountryInfo.
*/
#define COUNTRY struct tagCOUNTRY
COUNTRY
{
    TCHAR* pszName;
    DWORD  dwId;
    DWORD  dwCode;
};


/*----------------------------------------------------------------------------
** Prototypes (alphabetically)
**----------------------------------------------------------------------------
*/

VOID
FreeCountryInfo(
    IN COUNTRY* pCountries,
    IN DWORD    cCountries );

VOID
FreeLocationInfo(
    IN LOCATION* pLocations,
    IN DWORD     cLocations );

DWORD
GetCountryInfo(
    OUT COUNTRY** ppCountries,
    OUT DWORD*    pcCountries,
    IN  DWORD     dwCountryID );

DWORD
GetCurrentLocation(
    IN     HINSTANCE hInst,
    IN OUT HLINEAPP* pHlineapp );

DWORD
GetLocationInfo(
    IN     HINSTANCE  hInst,
    IN OUT HLINEAPP*  pHlineapp,
    OUT    LOCATION** ppLocations,
    OUT    DWORD*     pcLocations,
    OUT    DWORD*     pdwCurLocation );

DWORD
SetCurrentLocation(
    IN     HINSTANCE hInst,
    IN OUT HLINEAPP* pHlineapp,
    IN     DWORD     dwLocationId );

DWORD
TapiConfigureDlg(
    IN     HWND   hwndOwner,
    IN     DWORD  dwDeviceId,
    IN OUT BYTE** ppBlob,
    IN OUT DWORD* pcbBlob );

DWORD
TapiInit(
    IN     HINSTANCE hInst,
    IN OUT HLINEAPP* pHlineapp,
    OUT    DWORD*    pcDevices );

DWORD
TapiLocationDlg(
    IN     HINSTANCE hInst,
    IN OUT HLINEAPP* pHlineapp,
    IN     HWND      hwndOwner,
    IN     DWORD     dwCountryCode,
    IN     TCHAR*    pszAreaCode,
    IN     TCHAR*    pszPhoneNumber,
    IN     DWORD     dwDeviceId );

DWORD APIENTRY
TapiNewLocation(
    IN TCHAR* pszName );

DWORD
TapiNoLocationDlg(
    IN HINSTANCE hInst,
    IN HLINEAPP* pHlineapp,
    IN HWND      hwndOwner );

DWORD APIENTRY
TapiRemoveLocation(
    IN DWORD dwID );

DWORD APIENTRY
TapiRenameLocation(
    IN TCHAR* pszOldName,
    IN TCHAR* pszNewName );

DWORD
TapiShutdown(
    IN HLINEAPP hlineapp );

DWORD
TapiTranslateAddress(
    IN     HINSTANCE hInst,
    IN OUT HLINEAPP* pHlineapp,
    IN     DWORD     dwCountryCode,
    IN     TCHAR*    pszAreaCode,
    IN     TCHAR*    pszPhoneNumber,
    IN     DWORD     dwDeviceId,
    IN     BOOL      fDialable,
    OUT    TCHAR**   ppszResult );


#endif // _TAPIUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\nt4\common\nouiutil\intl.c ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File:    intl.c
//
// History:
//  Abolade Gbadegesin  Nov-14-1995     Created.
//
// Internationalized string routines
//============================================================================

#include <windows.h>

#include <nouiutil.h>


//----------------------------------------------------------------------------
// Function:    padultoa
// 
// This functions formats the specified unsigned integer
// into the specified string buffer, padding the buffer
// so that it is at least the specified width.
//
// It is assumed that the buffer is at least wide enough
// to contain the output, so this function does not truncate
// the conversion result to the length of the 'width' parameter.
//----------------------------------------------------------------------------

PTSTR padultoa(UINT val, PTSTR pszBuf, INT width) {
    TCHAR temp;
    PTSTR psz, zsp;

    psz = pszBuf;

    //
    // write the digits in reverse order
    //

    do {

        *psz++ = TEXT('0') + (val % 10);
        val /= 10;

    } while(val > 0);

    //
    // pad the string to the required width
    //

    zsp = pszBuf + width;
    while (psz < zsp) { *psz++ = TEXT('0'); }


    *psz-- = TEXT('\0');


    //
    // reverse the digits
    //

    for (zsp = pszBuf; zsp < psz; zsp++, psz--) {

        temp = *psz; *psz = *zsp; *zsp = temp;
    }

    //
    // return the result
    //

    return pszBuf;
}



// Function:    GetNumberString
//
// This function takes an integer and formats a string with the value
// represented by the number, grouping digits by powers of one-thousand

DWORD
GetNumberString(
    IN DWORD dwNumber,
    IN OUT PTSTR pszBuffer,
    IN OUT PDWORD pdwBufSize
    ) {

    static TCHAR szSep[4] = TEXT("");

    DWORD i, dwLength;
    TCHAR szDigits[12], *pszNumber;

    if (pdwBufSize == NULL) { return ERROR_INVALID_PARAMETER; }

    if (szSep[0] == TEXT('\0')) {
        GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_STHOUSAND, szSep, 4);
    }


    //
    // convert the number to a string without thousands-separators
    //

    padultoa(dwNumber, szDigits, 0);

    dwLength = lstrlen(szDigits);

    //
    // if the length of the string without separators is n,
    // then the length of the string with separators is n + (n - 1) / 3
    //

    i = dwLength;
    dwLength += (dwLength - 1) / 3;

    if (pszBuffer != NULL && dwLength < *pdwBufSize) {
        PTSTR pszsrc, pszdst;

        pszsrc = szDigits + i - 1; pszdst = pszBuffer + dwLength;

        *pszdst-- = TEXT('\0');

        while (TRUE) {
            if (i--) { *pszdst-- = *pszsrc--; } else { break; }
            if (i--) { *pszdst-- = *pszsrc--; } else { break; }
            if (i--) { *pszdst-- = *pszsrc--; } else { break; }
            if (i) { *pszdst-- = *szSep; } else { break; }
        }
    }

    *pdwBufSize = dwLength;

    return NO_ERROR;
}


//----------------------------------------------------------------------------
// Function:    GetDurationString
//
// This function takes a millisecond count and formats a string
// with the duration represented by the millisecond count.
// The caller may specify the resolution required by setting the flags field
//----------------------------------------------------------------------------

DWORD
GetDurationString(
    IN DWORD dwMilliseconds,
    IN DWORD dwFormatFlags,
    IN OUT PTSTR pszBuffer,
    IN OUT DWORD *pdwBufSize
    ) {

    static TCHAR szSep[4] = TEXT("");
    DWORD dwSize;
    TCHAR *psz, szOutput[64];

    if (pdwBufSize == NULL || (dwFormatFlags & GDSFLAG_All) == 0) {
        return ERROR_INVALID_PARAMETER;
    }


    if (szSep[0] == TEXT('\0')) {
        GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_STIME, szSep, 4);
    }


    //
    // concatenate the strings together
    //

    psz = szOutput;
    dwFormatFlags &= GDSFLAG_All;

    if (dwFormatFlags & GDSFLAG_Days) {

        padultoa(dwMilliseconds / (24 * 60 * 60 * 1000), psz, 0);
        dwMilliseconds %= (24 * 60 * 60 * 1000);

        if (dwFormatFlags &= ~GDSFLAG_Days) { lstrcat(psz, szSep); }

        psz += lstrlen(psz);
    }

    if (dwFormatFlags & GDSFLAG_Hours) {

        padultoa(dwMilliseconds / (60 * 60 * 1000), psz, 2);
        dwMilliseconds %= (60 * 60 * 1000);

        if (dwFormatFlags &= ~GDSFLAG_Hours) { lstrcat(psz, szSep); }

        psz += lstrlen(psz);
    }

    if (dwFormatFlags & GDSFLAG_Minutes) {

        padultoa(dwMilliseconds / (60 * 1000), psz, 2);
        dwMilliseconds %= (60 * 1000);

        if (dwFormatFlags &= ~GDSFLAG_Minutes) { lstrcat(psz, szSep); }

        psz += lstrlen(psz);
    }

    if (dwFormatFlags & GDSFLAG_Seconds) {

        padultoa(dwMilliseconds / 1000, psz, 2);
        dwMilliseconds %= 1000;

        if (dwFormatFlags &= ~GDSFLAG_Seconds) { lstrcat(psz, szSep); }

        psz += lstrlen(psz);
    }

    if (dwFormatFlags & GDSFLAG_Mseconds) {

        padultoa(dwMilliseconds, psz, 0);

        psz += lstrlen(psz);
    }

    dwSize = (DWORD) (psz - szOutput + 1);

    if (*pdwBufSize >= dwSize && pszBuffer != NULL) {
        lstrcpy(pszBuffer, szOutput);
    }

    *pdwBufSize = dwSize;

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\inc\x25.h ===
/* Copyright (c) 1995, Microsoft Corporation, all rights reserved
**
** x25.h
** Remote Access Connection Manager
** Native X.25 media/device header
*/


#ifndef _X25MEDIA_
#define _X25MEDIA_


/* Media/device identification string.
*/
#define X25_TXT "x25"

/* Device parameter key strings.
*/
#define X25_ADDRESS_KEY    "X25Address"
#define X25_USERDATA_KEY   "UserData"
#define X25_FACILITIES_KEY "Facilities"


#endif // _X25MEDIA_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\inc\uiutil.h ===
/* Copyright (c) 1995, Microsoft Corporation, all rights reserved
**
** uiutil.h
** UI helper routines
** Public header
**
** 08/25/95 Steve Cobb
*/

#ifndef _UIUTIL_H_
#define _UIUTIL_H_


#include <nouiutil.h>


/* IP address custom control definitions.
*/
#ifndef EXCL_IPADDR_H
#include <ipaddr.h>
#endif

/* Error and Message dialog definitions.
*/
#ifndef EXCL_POPUPDLG_H
#include <popupdlg.h>
#endif


/*----------------------------------------------------------------------------
** Constants/datatypes
**----------------------------------------------------------------------------
*/

/* ListView of devices indices.
*/
#define DI_Modem   0
#define DI_Adapter 1
#define DI_Direct  2
#define DI_Phone   3

#define UI_Connections_User 0

#define NI_Protocol 0
#define NI_Service  1
#define NI_Client   2

/* Bitmap styles for use with Button_CreateBitmap.
*/
#define BMS_OnLeft  0x100
#define BMS_OnRight 0x200

#define BITMAPSTYLE enum tagBITMAPSTYLE
BITMAPSTYLE
{
    BMS_UpArrowOnLeft = BMS_OnLeft,
    BMS_DownArrowOnLeft,
    BMS_UpTriangleOnLeft,
    BMS_DownTriangleOnLeft,
    BMS_UpArrowOnRight = BMS_OnRight,
    BMS_DownArrowOnRight,
    BMS_UpTriangleOnRight,
    BMS_DownTriangleOnRight
};


/* The extended list view control calls the owner back to find out the layout
** and desired characteristics of the enhanced list view.
*/
#define LVX_MaxCols      10
#define LVX_MaxColTchars 512

/* 'dwFlags' option bits.
*/
#define LVXDI_DxFill     1  // Auto-fill wasted space on right (recommended)
#define LVXDI_Blend50Sel 2  // Dither small icon if selected (not recommended)
#define LVXDI_Blend50Dis 4  // Dither small icon if disabled (recommended)

/* 'adwFlags' option bits.
*/
#define LVXDIA_3dFace 1  // Column is not editable but other columns are
#define LVXDIA_Static 2  // Emulates static text control w/icon if disabled

/* Returned by owner at draw item time.
*/
#define LVXDRAWINFO struct tagLVXDRAWINFO
LVXDRAWINFO
{
    /* The number of columns.  The list view extensions require that your
    ** columns are numbered sequentially from left to right where 0 is the
    ** item column and 1 is the first sub-item column.  Required always.
    */
    INT cCols;

    /* Pixels to indent this item, or -1 to indent a "small icon" width.  Set
    ** 0 to disable.
    */
    INT dxIndent;

    /* LVXDI_* options applying to all columns.
    */
    DWORD dwFlags;

    /* LVXDIA_* options applying to individual columns.
    */
    DWORD adwFlags[ LVX_MaxCols ];
};

typedef LVXDRAWINFO* (*PLVXCALLBACK)( IN HWND, IN DWORD dwItem );

/* Sent by ListView when check changes on an item
*/
#define LVXN_SETCHECK (LVN_LAST + 1)

/* Sent by ListView when item is double clicked so properties can be 
 * raised.
*/
#define LVXN_DBLCLK (LVN_LAST + 2)

/* SetOffDesktop actions.
*/
#define SOD_MoveOff        1
#define SOD_MoveBackFree   2
#define SOD_MoveBackHidden 3
#define SOD_Free           4
#define SOD_GetOrgRect     5


/*----------------------------------------------------------------------------
** Prototypes
**----------------------------------------------------------------------------
*/

VOID
AddContextHelpButton(
    IN HWND hwnd );

VOID
Button_MakeDefault(
    IN HWND hwndDlg,
    IN HWND hwndPb );

HBITMAP
Button_CreateBitmap(
    IN HWND        hwndPb,
    IN BITMAPSTYLE bitmapstyle );

VOID
CancelOwnedWindows(
    IN HWND hwnd );

VOID
CenterWindow(
    IN HWND hwnd,
    IN HWND hwndRef );

//For whislter bug 320863
//
VOID
CenterExpandWindowRemainLeftMargin(
    IN HWND hwnd,
    IN HWND hwndRef,
    BOOL bHoriz,
    BOOL bVert,
    IN HWND hwndVertBottomBound);

VOID
CloseOwnedWindows(
    IN HWND hwnd );

INT
ComboBox_AddItem(
    IN HWND    hwndLb,
    IN LPCTSTR pszText,
    IN VOID*   pItem );

INT
ComboBox_AddItemFromId(
    IN HINSTANCE hinstance,
    IN HWND      hwndLb,
    IN DWORD     dwStringId,
    IN VOID*     pItem );

INT
ComboBox_AddItemSorted(
    IN HWND    hwndLb,
    IN LPCTSTR pszText,
    IN VOID*   pItem );

VOID
ComboBox_AutoSizeDroppedWidth(
    IN HWND hwndLb );

VOID
ComboBox_FillFromPszList(
    IN HWND     hwndLb,
    IN DTLLIST* pdtllistPsz );

VOID*
ComboBox_GetItemDataPtr(
    IN HWND hwndLb,
    IN INT  nIndex );

TCHAR*
ComboBox_GetPsz(
    IN HWND hwnd,
    IN INT  nIndex );

VOID
ComboBox_SetCurSelNotify(
    IN HWND hwndLb,
    IN INT  nIndex );

TCHAR*
Ellipsisize(
    IN HDC    hdc,
    IN TCHAR* psz,
    IN INT    dxColumn,
    IN INT    dxColText OPTIONAL );

VOID
ExpandWindow(
    IN HWND hwnd,
    IN LONG dx,
    IN LONG dy );

TCHAR*
GetText(
    IN HWND hwnd );

HWND
HwndFromCursorPos(
    IN HINSTANCE    hinstance,
    IN POINT*       ppt OPTIONAL );

LPTSTR
IpGetAddressAsText(
    HWND    hwndIp );

void
IpSetAddressText(
    HWND    hwndIp,
    LPCTSTR pszIpAddress );

INT
ListBox_AddItem(
    IN HWND   hwndLb,
    IN TCHAR* pszText,
    IN VOID*  pItem );

TCHAR*
ListBox_GetPsz(
    IN HWND hwnd,
    IN INT  nIndex );

INT
ListBox_IndexFromString(
    IN HWND   hwnd,
    IN TCHAR* psz );

VOID
ListBox_SetCurSelNotify(
    IN HWND hwndLb,
    IN INT  nIndex );

BOOL
ListView_GetCheck(
    IN HWND hwndLv,
    IN INT  iItem );

UINT
ListView_GetCheckedCount(
    IN HWND hwndLv );

VOID*
ListView_GetParamPtr(
    IN HWND hwndLv,
    IN INT  iItem );

VOID*
ListView_GetSelectedParamPtr(
    IN HWND hwndLv );

VOID
ListView_InsertSingleAutoWidthColumn(
    HWND hwndLv );

BOOL
ListView_InstallChecks(
    IN HWND      hwndLv,
    IN HINSTANCE hinst );

BOOL
ListView_OwnerHandler(
    IN HWND         hwnd,
    IN UINT         unMsg,
    IN WPARAM       wparam,
    IN LPARAM       lparam,
    IN PLVXCALLBACK pLvxCallback );

VOID
ListView_SetCheck(
    IN HWND hwndLv,
    IN INT  iItem,
    IN BOOL fCheck );

BOOL
ListView_IsCheckDisabled(
        IN HWND hwndLv,
        IN INT  iItem);

VOID
ListView_DisableCheck(
        IN HWND hwndLv,
        IN INT  iItem);

VOID
ListView_EnableCheck(
        IN HWND hwndLv,
        IN INT  iItem);

VOID
ListView_SetDeviceImageList(
    IN HWND      hwndLv,
    IN HINSTANCE hinst );

VOID
ListView_SetUserImageList(
    IN HWND      hwndLv,
    IN HINSTANCE hinst );

VOID
ListView_SetNetworkComponentImageList(
    IN HWND      hwndLv,
    IN HINSTANCE hinst );

BOOL
ListView_SetParamPtr(
    IN HWND  hwndLv,
    IN INT   iItem,
    IN VOID* pParam );

VOID
ListView_UninstallChecks(
    IN HWND hwndLv );

DWORD
LoadRas(
    IN HINSTANCE hInst,
    IN HWND      hwnd );

VOID
Menu_CreateAccelProxies(
    IN HINSTANCE hinst,
    IN HWND      hwndParent,
    IN DWORD     dwMid );

BOOL
SetEvenTabWidths(
    IN HWND  hwndDlg,
    IN DWORD cPages );

VOID
SlideWindow(
    IN HWND hwnd,
    IN HWND hwndParent,
    IN LONG dx,
    IN LONG dy );

VOID
UnclipWindow(
    IN HWND hwnd );

BOOL
SetDlgItemNum(
    IN HWND     hwndDlg,
    IN INT      iDlgItem,
    IN UINT     uValue );

VOID
ScreenToClientRect(
    IN     HWND  hwnd,
    IN OUT RECT* pRect );

BOOL
SetOffDesktop(
    IN  HWND    hwnd,
    IN  DWORD   dwAction,
    OUT RECT*   prectOrg );

VOID
UnloadRas(
    void );


#endif // _UIUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\inc\treelist.h ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File:    treelist.h
//
// History:
//  Abolade Gbadegesin   Nov-20-1995    Created.
//
// The control whose declarations are included here provides a view
// which is a hybrid treeview/listview. Like a listview, each item
// may have zero or more subitems. Like a treeview, items are organized
// hierarchically, and displayed as a n-ary tree.
//
//  [  Header1        ][ Header2
//  -- Level 1          subtext
//      |- Level 2      subtext
//      |   |- Level 3
//      |   +- Level 3
//      |- Level 2      subtext
//      +- Level 2
//  +- Level 1          subtext
//
//
// The control is implemented as window which provides item-management,
// and which contains a listview window to which display is delegated.
//
// Once the window class has been initialized by calling TL_Init(),
// a treelist window can be created by calling CreateWindow() or
// CreateWindowEx() and passing it WC_TREELIST as the name of the class
// of window to be created.
//
// Communication with the window is via message passing, and macros are
// provided below for the operations supported by the treelist.
//
// As with a listview, at least one column must be inserted into the treelist
// before inserted items are displayed. Columns are described using 
// the LV_COLUMN structure defined in commctrl.h. Use the macros
// TreeList_InsertColumn() and TreeList_DeleteColumn() for column management.
// 
// Item insertion and deletion shoudl be done with TreeList_InsertItem() and
// TreeList_DeleteItem(). The insertion macro takes a TL_INSERTSTRUCT,
// which contains a pointer to a LV_ITEM structure which, as with listviews,
// is used to describe the item to be inserted. The LV_ITEM structure
// is defined in commctrl.h. (Note the iItem field is ignored).
// As with a treeview, once items have been inserted, there are referred to
// via handles. The type for treelist handles is HTLITEM.
//
// Once an item has been inserted, its attributes can be retreived or changed,
// it can be deleted, and subitems can be set for it. The LV_ITEM structure
// is used to retrieve or set an items attributes, and the iItem field
// is used to store the HTLITEM of the item to which the operation refers.
//
//============================================================================


#ifndef _TREELIST_H_
#define _TREELIST_H_


//
// Window class name string
//

#define WC_TREELIST         TEXT("TreeList")


//
// Item handle definition
//

typedef VOID *HTLITEM;


//
// struct passed to TreeList_InsertItem
//

typedef struct _TL_INSERTSTRUCT {

    HTLITEM     hParent; 
    HTLITEM     hInsertAfter;
    LV_ITEM    *plvi;

} TL_INSERTSTRUCT;



//
// values for TL_INSERTSTRUCT::hInsertAfter
//

#define TLI_FIRST           ((HTLITEM)UlongToPtr(0xffff0001))
#define TLI_LAST            ((HTLITEM)UlongToPtr(0xffff0002))
#define TLI_SORT            ((HTLITEM)UlongToPtr(0xffff0003))


//
// struct sent in notifications by a treelist
//

typedef struct _NMTREELIST {

    NMHDR   hdr;
    HTLITEM hItem;
    LPARAM  lParam;

} NMTREELIST;


//
// flags for TreeList_GetNextItem
//

#define TLGN_FIRST          0x0000
#define TLGN_PARENT         0x0001
#define TLGN_CHILD          0x0002
#define TLGN_NEXTSIBLING    0x0004
#define TLGN_PREVSIBLING    0x0008
#define TLGN_ENUMERATE      0x0010
#define TLGN_SELECTION      0x0020


//
// flags for TreeList_Expand
//

#define TLE_EXPAND          0x0001
#define TLE_COLLAPSE        0x0002
#define TLE_TOGGLE          0x0003


#define TLM_FIRST           (WM_USER + 1)
#define TLM_INSERTITEM      (TLM_FIRST + 0)
#define TLM_DELETEITEM      (TLM_FIRST + 1)
#define TLM_DELETEALLITEMS  (TLM_FIRST + 2)
#define TLM_GETITEM         (TLM_FIRST + 3)
#define TLM_SETITEM         (TLM_FIRST + 4)
#define TLM_GETITEMCOUNT    (TLM_FIRST + 5)
#define TLM_GETNEXTITEM     (TLM_FIRST + 6)
#define TLM_EXPAND          (TLM_FIRST + 7)
#define TLM_SETIMAGELIST    (TLM_FIRST + 8)
#define TLM_GETIMAGELIST    (TLM_FIRST + 9)
#define TLM_INSERTCOLUMN    (TLM_FIRST + 10)
#define TLM_DELETECOLUMN    (TLM_FIRST + 11)
#define TLM_SETSELECTION    (TLM_FIRST + 12)
#define TLM_REDRAW          (TLM_FIRST + 13)
#define TLM_ISITEMEXPANDED  (TLM_FIRST + 14)
#define TLM_GETCOLUMNWIDTH  (TLM_FIRST + 15)
#define TLM_SETCOLUMNWIDTH  (TLM_FIRST + 16)

#define TLN_FIRST           (0U - 1000U)
#define TLN_DELETEITEM      (TLN_FIRST - 1)
#define TLN_SELCHANGED      (TLN_FIRST - 2)


BOOL
TL_Init(
    HINSTANCE hInstance
    );

#define TreeList_InsertItem(hwnd, ptlis) \
        (HTLITEM)SendMessage( \
            (hwnd), TLM_INSERTITEM, 0, (LPARAM)(CONST TL_INSERTSTRUCT *)(ptlis)\
            )
#define TreeList_DeleteItem(hwnd, hItem) \
        (BOOL)SendMessage( \
            (hwnd), TLM_DELETEITEM, 0, (LPARAM)(CONST HTLITEM)(hItem) \
            )
#define TreeList_DeleteAllItems(hwnd) \
        (BOOL)SendMessage((hwnd), TLM_DELETEALLITEMS, 0, 0)
#define TreeList_GetItem(hwnd, pItem) \
        (BOOL)SendMessage( \
            (hwnd), TLM_GETITEM, 0, (LPARAM)(LV_ITEM *)(pItem) \
            )
#define TreeList_SetItem(hwnd, pItem) \
        (BOOL)SendMessage( \
            (hwnd), TLM_SETITEM, 0, (LPARAM)(CONST LV_ITEM *)(pItem) \
            )
#define TreeList_GetItemCount(hwnd) \
        (UINT)SendMessage((hwnd), TLM_GETITEMCOUNT, 0, 0)
#define TreeList_GetNextItem(hwnd, hItem, flag) \
        (HTLITEM)SendMessage( \
            (hwnd), TLM_GETNEXTITEM, (WPARAM)(UINT)(flag), \
            (LPARAM)(CONST HTLITEM)(hItem) \
            )
#define TreeList_GetFirst(hwnd) \
        TreeList_GetNextItem((hwnd), NULL, TLGN_FIRST)
#define TreeList_GetParent(hwnd, hItem) \
        TreeList_GetNextItem((hwnd), (hItem), TLGN_PARENT)
#define TreeList_GetChild(hwnd, hItem) \
        TreeList_GetNextItem((hwnd), (hItem), TLGN_CHILD)
#define TreeList_GetNextSibling(hwnd, hItem) \
        TreeList_GetNextItem((hwnd), (hItem), TLGN_NEXTSIBLING)
#define TreeList_GetPrevSibling(hwnd, hItem) \
        TreeList_GetNextItem((hwnd), (hItem), TLGN_PREVSIBLING)
#define TreeList_GetEnumerate(hwnd, hItem) \
        TreeList_GetNextItem((hwnd), (hItem), TLGN_ENUMERATE)
#define TreeList_GetSelection(hwnd) \
        TreeList_GetNextItem((hwnd), NULL, TLGN_SELECTION)
#define TreeList_Expand(hwnd, hItem, flag) \
        (BOOL)SendMessage( \
            (hwnd), TLM_EXPAND, (WPARAM)(UINT)(flag), \
            (LPARAM)(CONST HTLITEM)(hItem) \
            )
#define TreeList_SetImageList(hwnd, himl) \
        (BOOL)SendMessage( \
            (hwnd), TLM_SETIMAGELIST, 0, (LPARAM)(CONST HIMAGELIST)(himl) \
            )
#define TreeList_GetImageList(hwnd, himl) \
        (HIMAGELIST)SendMessage((hwnd), TLM_GETIMAGELIST, 0, 0)
#define TreeList_InsertColumn(hwnd, iCol, pCol) \
        (INT)SendMessage( \
            (hwnd),  TLM_INSERTCOLUMN, (WPARAM)(INT)(iCol), \
            (LPARAM)(CONST LV_COLUMN *)(pCol) \
            )
#define TreeList_DeleteColumn(hwnd, iCol) \
        (BOOL)SendMessage((hwnd), TLM_DELETECOLUMN, (WPARAM)(INT)(iCol), 0)
#define TreeList_SetSelection(hwnd, hItem) \
        (BOOL)SendMessage( \
            (hwnd), TLM_SETSELECTION, 0, (LPARAM)(CONST HTLITEM)(hItem) \
            )
#define TreeList_Redraw(hwnd) \
        (BOOL)SendMessage((hwnd), TLM_REDRAW, 0, 0)
#define TreeList_IsItemExpanded(hwnd, hItem) \
        (BOOL)SendMessage( \
            (hwnd), TLM_ISITEMEXPANDED, 0, (LPARAM)(CONST HTLITEM)(hItem) \
            )
#define TreeList_GetColumnWidth(hwnd, iCol) \
        (INT)SendMessage((hwnd), TLM_GETCOLUMNWIDTH, (WPARAM)(int)(iCol), 0)
#define TreeList_SetColumnWidth(hwnd, iCol, cx) \
        (BOOL)SendMessage( \
            (hwnd), TLM_SETCOLUMNWIDTH, (WPARAM)(int)(iCol), \
            MAKELPARAM((cx), 0) \
            )


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\nt4\common\nouiutil\loaddlls.c ===
/* Copyright (c) 1996, Microsoft Corporation, all rights reserved
**
** loaddlls.c
** RAS DLL load routines
** Listed alphabetically
**
** 02/17/96 Steve Cobb
*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <rpc.h>
#include <rasrpc.h>
#include <debug.h>    // Trace and assert
#include <nouiutil.h>
#include <loaddlls.h> // Our public header
#include <rasrpclb.h>


/*----------------------------------------------------------------------------
** Constants
**----------------------------------------------------------------------------
*/

#ifdef UNICODE
#define SZ_RasConnectionNotification "RasConnectionNotificationW"
#define SZ_RasDeleteEntry            "RasDeleteEntryW"
#define SZ_RasDial                   "RasDialW"
#define SZ_RasGetEntryDialParams     "RasGetEntryDialParamsW"
#define SZ_RasEnumEntries            "RasEnumEntriesW"
#define SZ_RasEnumConnections        "RasEnumConnectionsW"
#define SZ_RasGetAutodialEnable      "RasGetAutodialEnableW"
#define SZ_RasGetAutodialParam       "RasGetAutodialParamW"
#define SZ_RasGetConnectStatus       "RasGetConnectStatusW"
#define SZ_RasGetConnectResponse     "RasGetConnectResponse"
#define SZ_RasGetCredentials         "RasGetCredentialsW"
#define SZ_RasGetErrorString         "RasGetErrorStringW"
#define SZ_RasGetProjectionInfo      "RasGetProjectionInfoW"
#define SZ_RasGetSubEntryHandle      "RasGetSubEntryHandleW"
#define SZ_RasSetAutodialEnable      "RasSetAutodialEnableW"
#define SZ_RasSetAutodialParam       "RasSetAutodialParamW"
#define SZ_RasSetCredentials         "RasSetCredentialsW"
#define SZ_RasHangUp                 "RasHangUpW"
#define SZ_RasPhonebookDlg           "RasPhonebookDlgW"
#define SZ_RasEntryDlg               "RasEntryDlgW"
#define SZ_RouterEntryDlg            "RouterEntryDlgW"
#define SZ_RasDialDlg                "RasDialDlgW"
#define SZ_RasMonitorDlg             "RasMonitorDlgW"
#define SZ_RasGetCountryInfo         "RasGetCountryInfoW"
#else
#define SZ_RasConnectionNotification "RasConnectionNotificationA"
#define SZ_RasDeleteEntry            "RasDeleteEntryA"
#define SZ_RasDial                   "RasDialA"
#define SZ_RasGetEntryDialParams     "RasGetEntryDialParamsA"
#define SZ_RasEnumEntries            "RasEnumEntriesA"
#define SZ_RasEnumConnections        "RasEnumConnectionsA"
#define SZ_RasGetAutodialEnable      "RasGetAutodialEnableA"
#define SZ_RasGetAutodialParam       "RasGetAutodialParamA"
#define SZ_RasGetConnectStatus       "RasGetConnectStatusA"
#define SZ_RasGetConnectResponse     "RasGetConnectResponse"
#define SZ_RasGetCredentials         "RasGetCredentialsA"
#define SZ_RasGetErrorString         "RasGetErrorStringA"
#define SZ_RasGetProjectionInfo      "RasGetProjectionInfoA"
#define SZ_RasGetSubEntryHandle      "RasGetSubEntryHandleA"
#define SZ_RasSetAutodialEnable      "RasSetAutodialEnableA"
#define SZ_RasSetAutodialParam       "RasSetAutodialParamA"
#define SZ_RasSetCredentials         "RasSetCredentialsA"
#define SZ_RasHangUp                 "RasHangUpA"
#define SZ_RasPhonebookDlg           "RasPhonebookDlgA"
#define SZ_RouterEntryDlg            "RouterEntryDlgA"
#define SZ_RasDialDlg                "RasDialDlgA"
#define SZ_RasMonitorDlg             "RasMonitorDlgA"
#define SZ_RasGetCountryInfo         "RasGetCountryInfoA"
#endif
#define SZ_MprAdminInterfaceCreate   "MprAdminInterfaceCreate"
#define SZ_MprAdminInterfaceSetCredentials  "MprAdminInterfaceSetCredentials"
#define SZ_MprAdminServerConnect     "MprAdminServerConnect"
#define SZ_MprAdminServerDisconnect  "MprAdminServerDisconnect"
#define SZ_RasAdminServerConnect     "RasAdminServerConnect"
#define SZ_RasAdminServerDisconnect  "RasAdminServerDisconnect"
#define SZ_RasAdminBufferFree        "RasAdminBufferFree"
#define SZ_RasAdminConnectionEnum    "RasAdminConnectionEnum"
#define SZ_RasAdminConnectionGetInfo "RasAdminConnectionGetInfo"
#define SZ_RasAdminPortEnum          "RasAdminPortEnum"
#define SZ_RasAdminPortGetInfo       "RasAdminPortGetInfo"
#define SZ_RasAdminPortDisconnect    "RasAdminPortDisconnect"
#define SZ_RasAdminUserSetInfo       "RasAdminUserSetInfo"

/*----------------------------------------------------------------------------
** Globals
**----------------------------------------------------------------------------
*/

/* RASAPI32.DLL entry points.
*/
HINSTANCE g_hRasapi32Dll = NULL;

PRASCONNECTIONNOTIFICATION g_pRasConnectionNotification = NULL;
PRASDELETEENTRY            g_pRasDeleteEntry = NULL;
PRASDIAL                   g_pRasDial = NULL;
PRASENUMENTRIES            g_pRasEnumEntries = NULL;
PRASENUMCONNECTIONS        g_pRasEnumConnections = NULL;
PRASGETCONNECTSTATUS       g_pRasGetConnectStatus = NULL;
PRASGETCONNECTRESPONSE     g_pRasGetConnectResponse = NULL;
PRASGETCREDENTIALS         g_pRasGetCredentials = NULL;
PRASGETENTRYDIALPARAMS     g_pRasGetEntryDialParams = NULL;
PRASGETERRORSTRING         g_pRasGetErrorString = NULL;
PRASHANGUP                 g_pRasHangUp = NULL;
PRASGETAUTODIALENABLE      g_pRasGetAutodialEnable = NULL;
PRASGETAUTODIALPARAM       g_pRasGetAutodialParam = NULL;
PRASGETPROJECTIONINFO      g_pRasGetProjectionInfo = NULL;
PRASSETAUTODIALENABLE      g_pRasSetAutodialEnable = NULL;
PRASSETAUTODIALPARAM       g_pRasSetAutodialParam = NULL;
PRASGETSUBENTRYHANDLE      g_pRasGetSubEntryHandle = NULL;
PRASGETHPORT               g_pRasGetHport = NULL;
PRASSETCREDENTIALS         g_pRasSetCredentials = NULL;
PRASSETOLDPASSWORD         g_pRasSetOldPassword = NULL;
PRASGETCOUNTRYINFO         g_pRasGetCountryInfo = NULL;

/* RASDLG.DLL entry points
*/
HINSTANCE g_hRasdlgDll = NULL;

PRASPHONEBOOKDLG g_pRasPhonebookDlg = NULL;
PRASENTRYDLG     g_pRasEntryDlg = NULL;
PROUTERENTRYDLG  g_pRouterEntryDlg = NULL;
PRASDIALDLG      g_pRasDialDlg = NULL;
PRASMONITORDLG   g_pRasMonitorDlg = NULL;

/* RASMAN.DLL entry points
*/
HINSTANCE g_hRasmanDll = NULL;

PRASPORTCLEARSTATISTICS 	g_pRasPortClearStatistics = NULL;
PRASBUNDLECLEARSTATISTICS 	g_pRasBundleClearStatistics = NULL;
PRASBUNDLECLEARSTATISTICSEX g_pRasBundleClearStatisticsEx = NULL;
PRASDEVICEENUM          	g_pRasDeviceEnum = NULL;
PRASDEVICEGETINFO       	g_pRasDeviceGetInfo = NULL;
PRASFREEBUFFER          	g_pRasFreeBuffer = NULL;
PRASGETBUFFER           	g_pRasGetBuffer = NULL;
PRASPORTGETFRAMINGEX    	g_pRasPortGetFramingEx = NULL;
PRASGETINFO             	g_pRasGetInfo = NULL;
PRASINITIALIZE          	g_pRasInitialize = NULL;
PRASPORTCANCELRECEIVE   	g_pRasPortCancelReceive = NULL;
PRASPORTENUM            	g_pRasPortEnum = NULL;
PRASPORTGETINFO         	g_pRasPortGetInfo = NULL;
PRASPORTGETSTATISTICS   	g_pRasPortGetStatistics = NULL;
PRASBUNDLEGETSTATISTICS 	g_pRasBundleGetStatistics = NULL;
PRASPORTGETSTATISTICSEX     g_pRasPortGetStatisticsEx = NULL;
PRASBUNDLEGETSTATISTICSEX   g_pRasBundleGetStatisticsEx = NULL;
PRASPORTRECEIVE         	g_pRasPortReceive = NULL;
PRASPORTSEND            	g_pRasPortSend = NULL;
PRASPORTGETBUNDLE       	g_pRasPortGetBundle = NULL;
PRASGETDEVCONFIG        	g_pRasGetDevConfig = NULL;
PRASSETDEVCONFIG        	g_pRasSetDevConfig = NULL;
PRASPORTOPEN            	g_pRasPortOpen = NULL;
PRASPORTREGISTERSLIP    	g_pRasPortRegisterSlip = NULL;
PRASALLOCATEROUTE       	g_pRasAllocateRoute = NULL;
PRASACTIVATEROUTE       	g_pRasActivateRoute = NULL;
PRASACTIVATEROUTEEX     	g_pRasActivateRouteEx = NULL;
PRASDEVICESETINFO       	g_pRasDeviceSetInfo = NULL;
PRASDEVICECONNECT       	g_pRasDeviceConnect = NULL;
PRASPORTSETINFO         	g_pRasPortSetInfo = NULL;
PRASPORTCLOSE           	g_pRasPortClose = NULL;
PRASPORTLISTEN          	g_pRasPortListen = NULL;
PRASPORTCONNECTCOMPLETE 	g_pRasPortConnectComplete = NULL;
PRASPORTDISCONNECT      	g_pRasPortDisconnect = NULL;
PRASREQUESTNOTIFICATION 	g_pRasRequestNotification = NULL;
PRASPORTENUMPROTOCOLS   	g_pRasPortEnumProtocols = NULL;
PRASPORTSETFRAMING      	g_pRasPortSetFraming = NULL;
PRASPORTSETFRAMINGEX    	g_pRasPortSetFramingEx = NULL;
PRASSETCACHEDCREDENTIALS 	g_pRasSetCachedCredentials = NULL;
PRASGETDIALPARAMS       	g_pRasGetDialParams = NULL;
PRASSETDIALPARAMS       	g_pRasSetDialParams = NULL;
PRASCREATECONNECTION    	g_pRasCreateConnection = NULL;
PRASDESTROYCONNECTION   	g_pRasDestroyConnection = NULL;
PRASCONNECTIONENUM      	g_pRasConnectionEnum = NULL;
PRASADDCONNECTIONPORT   	g_pRasAddConnectionPort = NULL;
PRASENUMCONNECTIONPORTS 	g_pRasEnumConnectionPorts = NULL;
PRASGETCONNECTIONPARAMS 	g_pRasGetConnectionParams = NULL;
PRASSETCONNECTIONPARAMS 	g_pRasSetConnectionParams = NULL;
PRASGETCONNECTIONUSERDATA 	g_pRasGetConnectionUserData = NULL;
PRASSETCONNECTIONUSERDATA 	g_pRasSetConnectionUserData = NULL;
PRASGETPORTUSERDATA     	g_pRasGetPortUserData = NULL;
PRASSETPORTUSERDATA     	g_pRasSetPortUserData = NULL;
PRASADDNOTIFICATION     	g_pRasAddNotification = NULL;
PRASSIGNALNEWCONNECTION 	g_pRasSignalNewConnection = NULL;
PRASPPPSTOP             	g_pRasPppStop = NULL;
PRASPPPCALLBACK         	g_pRasPppCallback = NULL;
PRASPPPCHANGEPASSWORD   	g_pRasPppChangePassword = NULL;
PRASPPPGETINFO          	g_pRasPppGetInfo = NULL;
PRASPPPRETRY            	g_pRasPppRetry = NULL;
PRASPPPSTART            	g_pRasPppStart = NULL;
PRASSETIOCOMPLETIONPORT		g_pRasSetIoCompletionPort = NULL;
PRASSENDPPPMESSAGETORASMAN	g_pRasSendPppMessageToRasman = NULL;

/* MPRAPI.DLL entry points.
*/
HINSTANCE g_hMpradminDll = NULL;

PMPRADMININTERFACECREATE    g_pMprAdminInterfaceCreate = NULL;
PMPRADMININTERFACESETCREDENTIALS    g_pMprAdminInterfaceSetCredentials = NULL;
PMPRADMINSERVERCONNECT  g_pMprAdminServerConnect = NULL;
PMPRADMINSERVERDISCONNECT g_pMprAdminServerDisconnect = NULL;
PRASADMINSERVERCONNECT  g_pRasAdminServerConnect = NULL;
PRASADMINSERVERDISCONNECT g_pRasAdminServerDisconnect = NULL;
PRASADMINBUFFERFREE     g_pRasAdminBufferFree = NULL;
PRASADMINCONNECTIONENUM g_pRasAdminConnectionEnum = NULL;
PRASADMINCONNECTIONGETINFO g_pRasAdminConnectionGetInfo = NULL;
PRASADMINPORTENUM       g_pRasAdminPortEnum = NULL;
PRASADMINPORTGETINFO    g_pRasAdminPortGetInfo = NULL;
PRASADMINPORTDISCONNECT g_pRasAdminPortDisconnect = NULL;
PRASADMINUSERSETINFO    g_pRasAdminUserSetInfo = NULL;

//
// Miscellaneous DLLs
//
PGETINSTALLEDPROTOCOLS g_pGetInstalledProtocols = GetInstalledProtocols;
PGETUSERPREFERENCES g_pGetUserPreferences = GetUserPreferences;
PSETUSERPREFERENCES g_pSetUserPreferences = SetUserPreferences;
PGETSYSTEMDIRECTORY g_pGetSystemDirectory = GetSystemDirectory;

//
// RASRPC.DLL
//
RAS_RPC* g_pRpc = NULL;
BOOL g_fRasapi32PreviouslyLoaded;
BOOL g_fRasmanPreviouslyLoaded;

DWORD
RemoteGetInstalledProtocols(
    void );

DWORD
RemoteGetInstalledProtocols(
    void );

UINT WINAPI
RemoteGetSystemDirectory(
    LPTSTR lpBuffer,
    UINT uSize );

DWORD
RemoteGetUserPreferences(
    OUT PBUSER* pPbuser,
    IN DWORD dwMode );

DWORD APIENTRY
RemoteRasDeleteEntry(
    LPTSTR lpszPhonebook,
    LPTSTR lpszEntry );

DWORD APIENTRY
RemoteRasDeviceEnum(
    PCHAR pszDeviceType,
    PBYTE lpDevices,
    PWORD pwcbDevices,
    PWORD pwcDevices );

DWORD APIENTRY
RemoteRasEnumConnections(
    LPRASCONN lpRasConn,
    LPDWORD lpdwcbRasConn,
    LPDWORD lpdwcRasConn );

DWORD APIENTRY
RemoteRasGetCountryInfo(
    LPRASCTRYINFO lpRasCountryInfo,
    LPDWORD lpdwcbRasCountryInfo );

DWORD APIENTRY
RemoteRasGetDevConfig(
    HPORT hport,
    PCHAR pszDeviceType,
    PBYTE lpConfig,
    LPDWORD lpcbConfig );

DWORD APIENTRY
RemoteRasGetErrorString(
    UINT uErrorValue,
    LPTSTR lpszBuf,
    DWORD cbBuf );

DWORD APIENTRY
RemoteRasPortEnum(
    PBYTE lpPorts,
    PWORD pwcbPorts,
    PWORD pwcPorts );

DWORD
RemoteSetUserPreferences(
    OUT PBUSER* pPbuser,
    IN DWORD dwMode );

DWORD APIENTRY
RemoteRasPortGetInfo(
	HPORT porthandle,
	PBYTE buffer,
	PWORD pSize );

/*----------------------------------------------------------------------------
** Routines
**----------------------------------------------------------------------------
*/

BOOL
IsRasmanServiceRunning(
    void )

    /* Returns true if the PRASMAN service is running, false otherwise.
    */
{
    BOOL           fStatus;
    SC_HANDLE      schScm;
    SC_HANDLE      schRasman;
    SERVICE_STATUS status;

    fStatus = FALSE;
    schScm = NULL;
    schRasman = NULL;

    do
    {
        schScm = OpenSCManager( NULL, NULL, GENERIC_READ );
        if (!schScm)
            break;

        schRasman = OpenService(
            schScm, TEXT( RASMAN_SERVICE_NAME ), SERVICE_QUERY_STATUS );
        if (!schRasman)
            break;

        if (!QueryServiceStatus( schRasman, &status ))
            break;

        fStatus = (status.dwCurrentState == SERVICE_RUNNING);
    }
    while (FALSE);

    if (schRasman)
        CloseServiceHandle( schRasman );
    if (schScm)
        CloseServiceHandle( schScm );

    TRACE1("IsRasmanServiceRunning=%d",fStatus);
    return fStatus;
}



DWORD
LoadMpradminDll(
    void )

    /* Loads MPRAPI DLL and it's entry points.
    ** Returns 0 if successful, otherwise a non-zero error code.
    */
{
    HINSTANCE h;

    if (g_hMpradminDll)
        return 0;

    if (!(h = LoadLibrary(TEXT("MPRAPI.DLL")))
        || !(g_pMprAdminInterfaceCreate =
                (PMPRADMININTERFACECREATE)GetProcAddress(
                    h, SZ_MprAdminInterfaceCreate))
        || !(g_pMprAdminInterfaceSetCredentials =
                (PMPRADMININTERFACESETCREDENTIALS)GetProcAddress(
                    h, SZ_MprAdminInterfaceSetCredentials))
        || !(g_pMprAdminServerConnect =
                (PMPRADMINSERVERCONNECT)GetProcAddress(
                    h, SZ_MprAdminServerConnect))
        || !(g_pMprAdminServerDisconnect =
                (PMPRADMINSERVERDISCONNECT)GetProcAddress(
                    h, SZ_MprAdminServerDisconnect))
        || !(g_pRasAdminServerConnect =
                (PRASADMINSERVERCONNECT)GetProcAddress(
                    h, SZ_RasAdminServerConnect))
        || !(g_pRasAdminServerDisconnect =
                (PRASADMINSERVERDISCONNECT)GetProcAddress(
                    h, SZ_RasAdminServerDisconnect))
        || !(g_pRasAdminBufferFree =
                (PRASADMINBUFFERFREE)GetProcAddress(
                    h, SZ_RasAdminBufferFree))
        || !(g_pRasAdminConnectionEnum =
                (PRASADMINCONNECTIONENUM)GetProcAddress(
                    h, SZ_RasAdminConnectionEnum))
        || !(g_pRasAdminConnectionGetInfo =
                (PRASADMINCONNECTIONGETINFO)GetProcAddress(
                    h, SZ_RasAdminConnectionGetInfo))
        || !(g_pRasAdminPortEnum =
                (PRASADMINPORTENUM)GetProcAddress(
                    h, SZ_RasAdminPortEnum))
        || !(g_pRasAdminPortGetInfo =
                (PRASADMINPORTGETINFO)GetProcAddress(
                    h, SZ_RasAdminPortGetInfo))
        || !(g_pRasAdminPortDisconnect =
                (PRASADMINPORTDISCONNECT)GetProcAddress(
                    h, SZ_RasAdminPortDisconnect))
        || !(g_pRasAdminUserSetInfo =
                (PRASADMINUSERSETINFO)GetProcAddress(
                    h, SZ_RasAdminUserSetInfo)) )
    {
        return GetLastError();
    }

    g_hMpradminDll = h;

    return 0;
}

DWORD
LoadRasapi32Dll(
    void )

    /* Loads the RASAPI32.DLL and it's entrypoints.
    **
    ** Returns 0 if successful, otherwise a non-0 error code.
    */
{
    HINSTANCE h;

    if (g_hRasapi32Dll)
        return 0;

    if (!(h = LoadLibrary( TEXT("RASAPI32.DLL") ))
        || !(g_pRasConnectionNotification =
                (PRASCONNECTIONNOTIFICATION )GetProcAddress(
                    h, SZ_RasConnectionNotification ))
        || !(g_pRasDeleteEntry =
                (PRASDELETEENTRY )GetProcAddress(
                    h, SZ_RasDeleteEntry ))
        || !(g_pRasDial =
                (PRASDIAL )GetProcAddress(
                    h, SZ_RasDial ))
        || !(g_pRasEnumEntries =
                (PRASENUMENTRIES )GetProcAddress(
                    h, SZ_RasEnumEntries ))
        || !(g_pRasEnumConnections =
                (PRASENUMCONNECTIONS )GetProcAddress(
                    h, SZ_RasEnumConnections ))
        || !(g_pRasGetAutodialEnable =
                (PRASGETAUTODIALENABLE )GetProcAddress(
                    h, SZ_RasGetAutodialEnable ))
        || !(g_pRasGetAutodialParam =
                (PRASGETAUTODIALPARAM )GetProcAddress(
                    h, SZ_RasGetAutodialParam ))
        || !(g_pRasGetConnectStatus =
                (PRASGETCONNECTSTATUS )GetProcAddress(
                    h, SZ_RasGetConnectStatus ))
        || !(g_pRasGetConnectResponse =
                (PRASGETCONNECTRESPONSE )GetProcAddress(
                    h, SZ_RasGetConnectResponse ))
        || !(g_pRasGetCredentials =
                (PRASGETCREDENTIALS )GetProcAddress(
                    h, SZ_RasGetCredentials ))
        || !(g_pRasGetEntryDialParams =
                (PRASGETENTRYDIALPARAMS )GetProcAddress(
                    h, SZ_RasGetEntryDialParams ))
        || !(g_pRasGetErrorString =
                (PRASGETERRORSTRING )GetProcAddress(
                    h, SZ_RasGetErrorString ))
        || !(g_pRasGetHport =
                (PRASGETHPORT )GetProcAddress(
                    h, "RasGetHport" ))
        || !(g_pRasGetProjectionInfo =
                (PRASGETPROJECTIONINFO )GetProcAddress(
                    h, SZ_RasGetProjectionInfo ))
        || !(g_pRasGetSubEntryHandle =
                (PRASGETSUBENTRYHANDLE )GetProcAddress(
                    h, SZ_RasGetSubEntryHandle ))
        || !(g_pRasHangUp =
                (PRASHANGUP )GetProcAddress(
                    h, SZ_RasHangUp ))
        || !(g_pRasSetAutodialEnable =
                (PRASSETAUTODIALENABLE )GetProcAddress(
                    h, SZ_RasSetAutodialEnable ))
        || !(g_pRasSetAutodialParam =
                (PRASSETAUTODIALPARAM )GetProcAddress(
                    h, SZ_RasSetAutodialParam ))
        || !(g_pRasSetCredentials =
                (PRASSETCREDENTIALS )GetProcAddress(
                    h, SZ_RasSetCredentials ))
        || !(g_pRasSetOldPassword =
                (PRASSETOLDPASSWORD )GetProcAddress(
                    h, "RasSetOldPassword" ))
        || !(g_pRasGetCountryInfo =
                (PRASGETCOUNTRYINFO )GetProcAddress(
                    h, SZ_RasGetCountryInfo )))
    {
        return GetLastError();
    }

    g_hRasapi32Dll = h;
    return 0;
}


DWORD
LoadRasdlgDll(
    void )

    /* Loads the RASDLG.DLL and it's entrypoints.
    **
    ** Returns 0 if successful, otherwise a non-0 error code.
    */
{
    HINSTANCE h;

    if (g_hRasdlgDll)
        return 0;

    if (!(h = LoadLibrary( TEXT("RASDLG.DLL") ))
        || !(g_pRasPhonebookDlg =
                (PRASPHONEBOOKDLG )GetProcAddress(
                    h, SZ_RasPhonebookDlg ))
        || !(g_pRasEntryDlg =
                (PRASENTRYDLG )GetProcAddress(
                    h, SZ_RasEntryDlg ))
        || !(g_pRouterEntryDlg =
                (PROUTERENTRYDLG )GetProcAddress(
                    h, SZ_RouterEntryDlg ))
        || !(g_pRasDialDlg =
                (PRASDIALDLG )GetProcAddress(
                    h, SZ_RasDialDlg ))
        || !(g_pRasMonitorDlg =
                (PRASMONITORDLG )GetProcAddress(
                    h, SZ_RasMonitorDlg )))
    {
        return GetLastError();
    }

    g_hRasdlgDll = h;
    return 0;
}


DWORD
LoadRasmanDll(
    void )

    /* Loads the RASMAN.DLL and it's entrypoints.
    **
    ** Returns 0 if successful, otherwise a non-0 error code.
    */
{
    HINSTANCE h;

    if (g_hRasmanDll)
        return 0;

    if (!(h = LoadLibrary( TEXT("RASMAN.DLL") ))
        || !(g_pRasPortClearStatistics =
                (PRASPORTCLEARSTATISTICS )GetProcAddress(
                    h, "RasPortClearStatistics" ))
        || !(g_pRasBundleClearStatistics =
                (PRASBUNDLECLEARSTATISTICS )GetProcAddress(
                    h, "RasBundleClearStatistics" ))
        || !(g_pRasBundleClearStatisticsEx =
                (PRASBUNDLECLEARSTATISTICSEX ) GetProcAddress(
                    h, "RasBundleClearStatisticsEx"))
        || !(g_pRasDeviceEnum =
                (PRASDEVICEENUM )GetProcAddress(
                    h, "RasDeviceEnum" ))
        || !(g_pRasDeviceGetInfo =
                (PRASDEVICEGETINFO )GetProcAddress(
                    h, "RasDeviceGetInfo" ))
        || !(g_pRasFreeBuffer =
                (PRASFREEBUFFER )GetProcAddress(
                    h, "RasFreeBuffer" ))
        || !(g_pRasGetBuffer =
                (PRASGETBUFFER )GetProcAddress(
                    h, "RasGetBuffer" ))
        || !(g_pRasGetInfo =
                (PRASGETINFO )GetProcAddress(
                    h, "RasGetInfo" ))
        || !(g_pRasInitialize =
                (PRASINITIALIZE )GetProcAddress(
                    h, "RasInitialize" ))
        || !(g_pRasPortCancelReceive =
                (PRASPORTCANCELRECEIVE )GetProcAddress(
                    h, "RasPortCancelReceive" ))
        || !(g_pRasPortEnum =
                (PRASPORTENUM )GetProcAddress(
                    h, "RasPortEnum" ))
        || !(g_pRasPortGetInfo =
                (PRASPORTGETINFO )GetProcAddress(
                    h, "RasPortGetInfo" ))
        || !(g_pRasPortGetFramingEx =
                (PRASPORTGETFRAMINGEX )GetProcAddress(
                    h, "RasPortGetFramingEx" ))
        || !(g_pRasPortGetStatistics =
                (PRASPORTGETSTATISTICS )GetProcAddress(
                    h, "RasPortGetStatistics" ))
        || !(g_pRasBundleGetStatistics =
                (PRASBUNDLEGETSTATISTICS )GetProcAddress(
                    h, "RasBundleGetStatistics" ))
        || !(g_pRasPortGetStatisticsEx =
                (PRASPORTGETSTATISTICSEX )GetProcAddress(
                    h, "RasPortGetStatisticsEx"))
        || !(g_pRasBundleGetStatisticsEx = 
                (PRASBUNDLEGETSTATISTICSEX)GetProcAddress(
                    h, "RasBundleGetStatisticsEx" ))
        || !(g_pRasPortReceive =
                (PRASPORTRECEIVE )GetProcAddress(
                    h, "RasPortReceive" ))
        || !(g_pRasPortSend =
                (PRASPORTSEND )GetProcAddress(
                    h, "RasPortSend" ))
        || !(g_pRasPortGetBundle =
                (PRASPORTGETBUNDLE )GetProcAddress(
                    h, "RasPortGetBundle" ))
        || !(g_pRasGetDevConfig =
                (PRASGETDEVCONFIG )GetProcAddress(
                    h, "RasGetDevConfig" ))
        || !(g_pRasSetDevConfig =
                (PRASSETDEVCONFIG )GetProcAddress(
                    h, "RasSetDevConfig" ))
        || !(g_pRasPortClose =
                (PRASPORTCLOSE )GetProcAddress(
                    h, "RasPortClose" ))
        || !(g_pRasPortListen =
                (PRASPORTLISTEN )GetProcAddress(
                    h, "RasPortListen" ))
        || !(g_pRasPortConnectComplete =
                (PRASPORTCONNECTCOMPLETE )GetProcAddress(
                    h, "RasPortConnectComplete" ))
        || !(g_pRasPortDisconnect =
                (PRASPORTDISCONNECT )GetProcAddress(
                    h, "RasPortDisconnect" ))
        || !(g_pRasRequestNotification =
                (PRASREQUESTNOTIFICATION )GetProcAddress(
                    h, "RasRequestNotification" ))
        || !(g_pRasPortEnumProtocols =
                (PRASPORTENUMPROTOCOLS )GetProcAddress(
                    h, "RasPortEnumProtocols" ))
        || !(g_pRasPortSetFraming =
                (PRASPORTSETFRAMING )GetProcAddress(
                    h, "RasPortSetFraming" ))
        || !(g_pRasPortSetFramingEx =
                (PRASPORTSETFRAMINGEX )GetProcAddress(
                    h, "RasPortSetFramingEx" ))
        || !(g_pRasSetCachedCredentials =
                (PRASSETCACHEDCREDENTIALS )GetProcAddress(
                    h, "RasSetCachedCredentials" ))
        || !(g_pRasGetDialParams =
                (PRASGETDIALPARAMS )GetProcAddress(
                    h, "RasGetDialParams" ))
        || !(g_pRasSetDialParams =
                (PRASSETDIALPARAMS )GetProcAddress(
                    h, "RasSetDialParams" ))
        || !(g_pRasCreateConnection =
                (PRASCREATECONNECTION )GetProcAddress(
                    h, "RasCreateConnection" ))
        || !(g_pRasDestroyConnection =
                (PRASDESTROYCONNECTION )GetProcAddress(
                    h, "RasDestroyConnection" ))
        || !(g_pRasConnectionEnum =
                (PRASCONNECTIONENUM )GetProcAddress(
                    h, "RasConnectionEnum" ))
        || !(g_pRasAddConnectionPort =
                (PRASADDCONNECTIONPORT )GetProcAddress(
                    h, "RasAddConnectionPort" ))
        || !(g_pRasEnumConnectionPorts =
                (PRASENUMCONNECTIONPORTS )GetProcAddress(
                    h, "RasEnumConnectionPorts" ))
        || !(g_pRasGetConnectionParams =
                (PRASGETCONNECTIONPARAMS )GetProcAddress(
                    h, "RasGetConnectionParams" ))
        || !(g_pRasSetConnectionParams =
                (PRASSETCONNECTIONPARAMS )GetProcAddress(
                    h, "RasSetConnectionParams" ))
        || !(g_pRasGetConnectionUserData =
                (PRASGETCONNECTIONUSERDATA )GetProcAddress(
                    h, "RasGetConnectionUserData" ))
        || !(g_pRasSetConnectionUserData =
                (PRASSETCONNECTIONUSERDATA )GetProcAddress(
                    h, "RasSetConnectionUserData" ))
        || !(g_pRasGetPortUserData =
                (PRASGETPORTUSERDATA )GetProcAddress(
                    h, "RasGetPortUserData" ))
        || !(g_pRasSetPortUserData =
                (PRASSETPORTUSERDATA )GetProcAddress(
                    h, "RasSetPortUserData" ))
        || !(g_pRasAddNotification =
                (PRASADDNOTIFICATION )GetProcAddress(
                    h, "RasAddNotification" ))
        || !(g_pRasSignalNewConnection =
                (PRASSIGNALNEWCONNECTION )GetProcAddress(
                    h, "RasSignalNewConnection" ))
        || !(g_pRasPppStop =
                (PRASPPPSTOP )GetProcAddress(
                    h, "RasPppStop" ))
        || !(g_pRasPppCallback =
                (PRASPPPCALLBACK )GetProcAddress(
                    h, "RasPppCallback" ))
        || !(g_pRasPppChangePassword =
                (PRASPPPCHANGEPASSWORD )GetProcAddress(
                    h, "RasPppChangePassword" ))
        || !(g_pRasPppGetInfo =
                (PRASPPPGETINFO )GetProcAddress(
                    h, "RasPppGetInfo" ))
        || !(g_pRasPppRetry =
                (PRASPPPRETRY )GetProcAddress(
                    h, "RasPppRetry" ))
        || !(g_pRasPppStart =
                (PRASPPPSTART )GetProcAddress(
                    h, "RasPppStart" ))
        || !(g_pRasPortOpen =
                (PRASPORTOPEN )GetProcAddress(
                    h, "RasPortOpen" ))
        || !(g_pRasPortRegisterSlip =
                (PRASPORTREGISTERSLIP )GetProcAddress(
                    h, "RasPortRegisterSlip" ))
        || !(g_pRasAllocateRoute =
                (PRASALLOCATEROUTE )GetProcAddress(
                    h, "RasAllocateRoute" ))
        || !(g_pRasActivateRoute =
                (PRASACTIVATEROUTE )GetProcAddress(
                    h, "RasActivateRoute" ))
        || !(g_pRasActivateRouteEx =
                (PRASACTIVATEROUTEEX )GetProcAddress(
                    h, "RasActivateRouteEx" ))
        || !(g_pRasDeviceSetInfo =
                (PRASDEVICESETINFO )GetProcAddress(
                    h, "RasDeviceSetInfo" ))
        || !(g_pRasDeviceConnect =
                (PRASDEVICECONNECT )GetProcAddress(
                    h, "RasDeviceConnect" ))
        || !(g_pRasPortSetInfo =
                (PRASPORTSETINFO )GetProcAddress(
                    h, "RasPortSetInfo" ))
        || !(g_pRasSetIoCompletionPort =
                (PRASSETIOCOMPLETIONPORT )GetProcAddress(
                    h, "RasSetIoCompletionPort" ))
        || !(g_pRasSendPppMessageToRasman =
        		(PRASSENDPPPMESSAGETORASMAN)GetProcAddress(
        			h, "RasSendPppMessageToRasman")))
    {
        return GetLastError();
    }

    g_hRasmanDll = h;
    return 0;
}

DWORD
RasRPCBind(
    IN  LPWSTR  lpwsServerName,
    OUT HANDLE* phServer
)
{
    RPC_STATUS RpcStatus;
    LPWSTR     lpwsStringBinding;
    LPWSTR     lpwsEndpoint;

    RpcStatus = RpcStringBindingCompose(
                                    NULL,
                                    TEXT("ncacn_np"),
                                    lpwsServerName,
                                    TEXT("\\PIPE\\ROUTER"),     
                                    TEXT("Security=Impersonation Static True"),
                                    &lpwsStringBinding);

    if ( RpcStatus != RPC_S_OK )
    {
        return( I_RpcMapWin32Status( RpcStatus ) );
    }

    RpcStatus = RpcBindingFromStringBinding( lpwsStringBinding,
                                             (handle_t *)phServer );

    RpcStringFree( &lpwsStringBinding );

    if ( RpcStatus != RPC_S_OK )
    {
        return( I_RpcMapWin32Status( RpcStatus ) );
    }

    return( NO_ERROR );
}

DWORD
LoadRasRpcDll(
    LPTSTR lpszServer
    )
{
    DWORD dwErr;
    RPC_STATUS rpcStatus;
    HINSTANCE h;

    //
    // Handle the local server case up front.
    //
    if (lpszServer == NULL) {
        DWORD dwErr;

        if (g_fRasapi32PreviouslyLoaded) {
            dwErr = LoadRasapi32Dll();
            if (dwErr)
                return dwErr;
            g_fRasapi32PreviouslyLoaded = FALSE;
        }
        if (g_fRasmanPreviouslyLoaded) {
            dwErr = LoadRasmanDll();
            if (dwErr)
                return dwErr;
            g_fRasmanPreviouslyLoaded = FALSE;
        }
        return 0;
    }
    else
    {
        TCHAR szComputerName[MAX_COMPUTERNAME_LENGTH + 1];
        DWORD dwcbComputerName = sizeof (szComputerName);

        /* Convert "\\server" to "server", if necessary.
        */
        if (lpszServer[ 0 ] == TEXT('\\') && lpszServer[ 1 ] == TEXT('\\'))
            lpszServer += 2;
    }

    //
    // Free a previous RPC binding handle
    // if it exists.
    //

    if (g_pRpc != NULL) 
    {
        rpcStatus = RasRpcDisconnectServer(g_pRpc);

        if (rpcStatus != RPC_S_OK ) 
        {
            return( rpcStatus );
        }
    }

    dwErr = RasRpcConnectServer( lpszServer, (HANDLE*)&g_pRpc );

    if ( dwErr != NO_ERROR )
    {
        return( dwErr );
    }

    //
    // We have successfully bound with a
    // server, so unload any of the existing
    // DLLs, if they have been loaded.
    //
    g_fRasmanPreviouslyLoaded = (g_hRasmanDll != NULL);
    if (g_fRasmanPreviouslyLoaded)
        UnloadRasmanDll();
    g_fRasapi32PreviouslyLoaded = (g_hRasapi32Dll != NULL);
    if (g_fRasapi32PreviouslyLoaded)
        UnloadRasapi32Dll();
    //
    // Remap the RPCable APIs.
    //
    g_pRasPortEnum = RemoteRasPortEnum;
    g_pRasDeviceEnum = RemoteRasDeviceEnum;
    g_pRasGetDevConfig = RemoteRasGetDevConfig;
    g_pRasEnumConnections = RemoteRasEnumConnections;
    g_pRasDeleteEntry = RemoteRasDeleteEntry;
    g_pRasGetErrorString = RemoteRasGetErrorString;
    g_pRasGetCountryInfo = RemoteRasGetCountryInfo;
    g_pGetInstalledProtocols = RemoteGetInstalledProtocols;
    g_pGetUserPreferences = RemoteGetUserPreferences;
    g_pSetUserPreferences = RemoteSetUserPreferences;
    g_pGetSystemDirectory = RemoteGetSystemDirectory;
	g_pRasPortGetInfo = RemoteRasPortGetInfo;

    return 0;
}


BOOL
Rasapi32DllLoaded(
    void
    )
{
    return (g_hRasapi32Dll != NULL);
}


BOOL
RasRpcDllLoaded(
    void
    )
{
    return (g_pRpc != NULL);
}


DWORD
RemoteGetInstalledProtocols(
    void
    )
{
    DWORD dwStatus;

    ASSERT(g_pRpc->hRpcBinding);
    RpcTryExcept
    {
        dwStatus = RasRpcGetInstalledProtocols(g_pRpc->hRpcBinding);
    }
    RpcExcept(1)
    {
        dwStatus = RpcExceptionCode();
    }
    RpcEndExcept

    return dwStatus;
}


UINT WINAPI
RemoteGetSystemDirectory(
    LPTSTR lpBuffer,
    UINT uSize
    )
{
    DWORD dwStatus;

    ASSERT(g_pRpc->hRpcBinding);
    RpcTryExcept
    {
        dwStatus = RasRpcGetSystemDirectory(g_pRpc->hRpcBinding, lpBuffer, uSize);
    }
    RpcExcept(1)
    {
        dwStatus = RpcExceptionCode();
    }
    RpcEndExcept

    return dwStatus;
}


DWORD
RemoteGetUserPreferences(
    OUT PBUSER* pPbuser,
    IN DWORD dwMode
    )
{
    DWORD dwStatus;
    RASRPC_PBUSER pbuser;

    ASSERT(g_pRpc->hRpcBinding);
    RtlZeroMemory(&pbuser, sizeof (RASRPC_PBUSER));
    RpcTryExcept
    {
        dwStatus = RasRpcGetUserPreferences(g_pRpc->hRpcBinding, &pbuser, dwMode);
    }
    RpcExcept(1)
    {
        dwStatus = RpcExceptionCode();
    }
    RpcEndExcept
    if (dwStatus)
        return dwStatus;
    //
    // Convert RPC format to RAS format.
    //
    return RpcToRasPbuser(pPbuser, &pbuser);
}


DWORD APIENTRY
RemoteRasDeleteEntry(
    LPTSTR lpszPhonebook,
    LPTSTR lpszEntry
    )
{
    DWORD dwStatus;

    ASSERT(g_pRpc->hRpcBinding);
    RpcTryExcept
    {
        dwStatus = RasRpcDeleteEntry(g_pRpc->hRpcBinding, lpszPhonebook, lpszEntry);
    }
    RpcExcept(1)
    {
        dwStatus = RpcExceptionCode();
    }
    RpcEndExcept

    return dwStatus;
}


DWORD APIENTRY
RemoteRasDeviceEnum(
    PCHAR pszDeviceType,
    PBYTE lpDevices,
    PWORD pwcbDevices,
    PWORD pwcDevices
    )
{
    DWORD dwStatus, dwDevices, dwcDevices;

    dwDevices = *pwcbDevices;
    dwcDevices = *pwcDevices;

    ASSERT(g_pRpc);
    RpcTryExcept
    {
        dwStatus = RasDeviceEnum((HANDLE)g_pRpc, pszDeviceType, lpDevices, &dwDevices, &dwcDevices);
    }
    RpcExcept(1)
    {
        dwStatus = RpcExceptionCode();
    }
    RpcEndExcept

    *pwcbDevices = (WORD)dwDevices;
    *pwcDevices = (WORD)dwcDevices;

    return dwStatus;
}


DWORD APIENTRY
RemoteRasEnumConnections(
    LPRASCONN lpRasConn,
    LPDWORD lpdwcbRasConn,
    LPDWORD lpdwcRasConn
    )
{

    DWORD dwStatus;
    DWORD dwcbBufSize = *lpdwcbRasConn;

    ASSERT(g_pRpc);
    RpcTryExcept
    {
        dwStatus = RasRpcEnumConnections(g_pRpc->hRpcBinding, (LPBYTE)lpRasConn, 
        				lpdwcbRasConn, lpdwcRasConn, dwcbBufSize);
    }
    RpcExcept(1)
    {
        dwStatus = RpcExceptionCode();
    }
    RpcEndExcept

    return dwStatus;
}


DWORD APIENTRY
RemoteRasGetCountryInfo(
    LPRASCTRYINFO lpRasCountryInfo,
    LPDWORD lpdwcbRasCountryInfo
    )
{
    DWORD dwStatus;

    ASSERT(g_pRpc->hRpcBinding);
    RpcTryExcept
    {
        dwStatus = RasRpcGetCountryInfo(g_pRpc->hRpcBinding, (LPBYTE)lpRasCountryInfo, lpdwcbRasCountryInfo);
    }
    RpcExcept(1)
    {
        dwStatus = RpcExceptionCode();
    }
    RpcEndExcept

    return dwStatus;
}


DWORD APIENTRY
RemoteRasGetDevConfig(
    HPORT hport,
    PCHAR pszDeviceType,
    PBYTE lpConfig,
    LPDWORD lpcbConfig
    )
{
    DWORD dwStatus;

    ASSERT(g_pRpc);
    RpcTryExcept
    {
        dwStatus = RasGetDevConfig((HANDLE)g_pRpc, hport, pszDeviceType, lpConfig, lpcbConfig);
    }
    RpcExcept(1)
    {
        dwStatus = RpcExceptionCode();
    }
    RpcEndExcept

    return dwStatus;
}


DWORD APIENTRY
RemoteRasGetErrorString(
    UINT uErrorValue,
    LPTSTR lpszBuf,
    DWORD cbBuf
    )
{
    DWORD dwStatus;

    ASSERT(g_pRpc->hRpcBinding);
    RpcTryExcept
    {
        dwStatus = RasRpcGetErrorString(g_pRpc->hRpcBinding, uErrorValue, lpszBuf, cbBuf);
    }
    RpcExcept(1)
    {
        dwStatus = RpcExceptionCode();
    }
    RpcEndExcept

    return dwStatus;
}


DWORD APIENTRY
RemoteRasPortEnum(
    PBYTE lpPorts,
    PWORD pwcbPorts,
    PWORD pwcPorts
    )
{
    DWORD dwStatus, dwcbPorts, dwcPorts;

    dwcbPorts = *pwcbPorts;
    dwcPorts = *pwcPorts;

    ASSERT(g_pRpc);
    RpcTryExcept
    {
        dwStatus = RasPortEnum((HANDLE)g_pRpc, lpPorts, &dwcbPorts, &dwcPorts);
    }
    RpcExcept(1)
    {
        dwStatus = RpcExceptionCode();
    }
    RpcEndExcept

    *pwcbPorts = (WORD)dwcbPorts;
    *pwcPorts = (WORD)dwcPorts;

    return dwStatus;
}


DWORD
RemoteSetUserPreferences(
    OUT PBUSER* pPbuser,
    IN DWORD dwMode
    )
{
    DWORD dwStatus;
    RASRPC_PBUSER pbuser;

    ASSERT(g_pRpc->hRpcBinding);
    //
    // Convert the RAS format to RPC format.
    //
    
    dwStatus = RasToRpcPbuser(&pbuser, pPbuser);
    
    if (dwStatus)
        return dwStatus;
    RpcTryExcept
    {
        dwStatus = RasRpcSetUserPreferences(g_pRpc->hRpcBinding, &pbuser, dwMode);
    }
    RpcExcept(1)
    {
        dwStatus = RpcExceptionCode();
    }
    RpcEndExcept

    return dwStatus;
}

DWORD
RemoteRasPortGetInfo(
	HPORT porthandle,
	PBYTE buffer,
	PWORD pSize)
{
	DWORD	dwStatus, dwSize;

    dwSize = *pSize;
	
	RpcTryExcept
	{
		dwStatus = RasPortGetInfo((HANDLE)g_pRpc, porthandle, buffer, &dwSize);
	}
	RpcExcept(1)
	{
		dwStatus = RpcExceptionCode();
	}
	RpcEndExcept

	*pSize = (WORD)dwSize;

	return dwStatus;
}


VOID
UnloadMpradminDll(
    void )

    /* Unload the MPRAPI.DLL library and its entrypoints
    */
{
    if (g_hMpradminDll)
    {
        HINSTANCE h;

        g_pMprAdminInterfaceCreate = NULL;
        g_pMprAdminInterfaceSetCredentials = NULL;
        g_pMprAdminServerConnect = NULL;
        g_pMprAdminServerDisconnect = NULL;
        g_pRasAdminServerConnect = NULL;
        g_pRasAdminServerDisconnect = NULL;
        g_pRasAdminBufferFree = NULL;
        g_pRasAdminConnectionEnum = NULL;
        g_pRasAdminConnectionGetInfo = NULL;
        g_pRasAdminPortEnum = NULL;
        g_pRasAdminPortGetInfo = NULL;
        g_pRasAdminPortDisconnect = NULL;
        g_pRasAdminUserSetInfo = NULL;

        h = g_hMpradminDll;
        g_hMpradminDll = NULL;
        FreeLibrary(h);
    }
}

VOID
UnloadRasapi32Dll(
    void )

    /* Unload the RASAPI32.DLL library and it's entrypoints.
    */
{
    if (g_hRasapi32Dll)
    {
        HINSTANCE h;

        g_pRasConnectionNotification = NULL;
        g_pRasDeleteEntry = NULL;
        g_pRasDial = NULL;
        g_pRasEnumEntries = NULL;
        g_pRasEnumConnections = NULL;
        g_pRasGetConnectStatus = NULL;
        g_pRasGetConnectResponse = NULL;
        g_pRasGetCredentials = NULL;
        g_pRasGetErrorString = NULL;
        g_pRasHangUp = NULL;
        g_pRasGetAutodialEnable = NULL;
        g_pRasGetAutodialParam = NULL;
        g_pRasGetProjectionInfo = NULL;
        g_pRasSetAutodialEnable = NULL;
        g_pRasSetAutodialParam = NULL;
        g_pRasGetSubEntryHandle = NULL;
        g_pRasGetHport = NULL;
        g_pRasSetCredentials = NULL;
        g_pRasSetOldPassword = NULL;
        g_pRasGetCountryInfo = NULL;
        h = g_hRasapi32Dll;
        g_hRasapi32Dll = NULL;
        FreeLibrary( h );
    }
}


VOID
UnloadRasdlgDll(
    void )

    /* Unload the RASDLG.DLL library and it's entrypoints.
    */
{
    if (g_hRasdlgDll)
    {
        HINSTANCE h;

        g_pRasPhonebookDlg = NULL;
        g_pRasEntryDlg = NULL;
        g_pRouterEntryDlg = NULL;
        g_pRasDialDlg = NULL;
        g_pRasMonitorDlg = NULL;
        h = g_hRasdlgDll;
        g_hRasdlgDll = NULL;
        FreeLibrary( h );
    }
}


VOID
UnloadRasmanDll(
    void )

    /* Unload the RASMAN.DLL library and it's entrypoints.
    */
{
    if (g_hRasmanDll)
    {
        HINSTANCE h;

        g_pRasPortClearStatistics = NULL;
        g_pRasDeviceEnum = NULL;
        g_pRasDeviceGetInfo = NULL;
        g_pRasFreeBuffer = NULL;
        g_pRasGetBuffer = NULL;
        g_pRasPortGetFramingEx = NULL;
        g_pRasGetInfo = NULL;
        g_pRasInitialize = NULL;
        g_pRasPortCancelReceive = NULL;
        g_pRasPortEnum = NULL;
        g_pRasPortGetInfo = NULL;
        g_pRasPortGetStatistics = NULL;
        g_pRasPortReceive = NULL;
        g_pRasPortSend = NULL;
        g_pRasPortGetBundle = NULL;
        g_pRasGetDevConfig = NULL;
        g_pRasSetDevConfig = NULL;
        g_pRasPortOpen = NULL;
        g_pRasPortRegisterSlip = NULL;
        g_pRasAllocateRoute = NULL;
        g_pRasActivateRoute = NULL;
        g_pRasActivateRouteEx = NULL;
        g_pRasDeviceSetInfo = NULL;
        g_pRasDeviceConnect = NULL;
        g_pRasPortSetInfo = NULL;
        g_pRasPortClose = NULL;
        g_pRasPortListen = NULL;
        g_pRasPortConnectComplete = NULL;
        g_pRasPortDisconnect = NULL;
        g_pRasRequestNotification = NULL;
        g_pRasPortEnumProtocols = NULL;
        g_pRasPortSetFraming = NULL;
        g_pRasPortSetFramingEx = NULL;
        g_pRasSetCachedCredentials = NULL;
        g_pRasGetDialParams = NULL;
        g_pRasSetDialParams = NULL;
        g_pRasCreateConnection = NULL;
        g_pRasDestroyConnection = NULL;
        g_pRasConnectionEnum = NULL;
        g_pRasAddConnectionPort = NULL;
        g_pRasEnumConnectionPorts = NULL;
        g_pRasGetConnectionParams = NULL;
        g_pRasSetConnectionParams = NULL;
        g_pRasGetConnectionUserData = NULL;
        g_pRasSetConnectionUserData = NULL;
        g_pRasGetPortUserData = NULL;
        g_pRasSetPortUserData = NULL;
        g_pRasAddNotification = NULL;
        g_pRasSignalNewConnection = NULL;
        g_pRasPppStop = NULL;
        g_pRasPppCallback = NULL;
        g_pRasPppChangePassword = NULL;
        g_pRasPppGetInfo = NULL;
        g_pRasPppRetry = NULL;
        g_pRasPppStart = NULL;
        g_pRasSetIoCompletionPort = NULL;
        h = g_hRasmanDll;
        g_hRasmanDll = NULL;
        FreeLibrary( h );
    }
}


VOID
UnloadRasRpcDll(
    void
    )
{
    g_pRasPortEnum = NULL;
    g_pRasDeviceEnum = NULL;
    g_pRasGetDevConfig = NULL;
    g_pRasEnumConnections = NULL;
    g_pRasDeleteEntry = NULL;
    g_pRasGetErrorString = NULL;
    g_pRasGetCountryInfo = NULL;
    g_pGetInstalledProtocols = GetInstalledProtocols;
    g_pGetUserPreferences = GetUserPreferences;
    g_pSetUserPreferences = SetUserPreferences;
    g_pGetSystemDirectory = GetSystemDirectory;
	g_pRasPortGetInfo = NULL;
	
    //
    // Release the binding resources.
    //
    (void)RasRpcDisconnectServer(g_pRpc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\nt4\common\nouiutil\pbuser.c ===
/* Copyright (c) 1995, Microsoft Corporation, all rights reserved
**
** pbuser.c
** User preference storage routines
** Listed alphabetically
**
** 10/31/95 Steve Cobb
*/

#include <windows.h>  // Win32 root
#include <debug.h>    // Trace/Assert library
#include <nouiutil.h> // Heap macros
#include <pbuser.h>   // Our public header
#include <rasdlg.h>   // RAS common dialog header for RASMD_*


/* Default user preference settings.
*/
static PBUSER g_pbuserDefaults =
{
    FALSE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, TRUE,
    0, 15, 1200, FALSE, TRUE, FALSE,
    CBM_Maybe, NULL, NULL,
    PBM_System, NULL, NULL, NULL,
    NULL, FALSE,
    NULL, NULL, NULL,
    0x7FFFFFFF, 0x7FFFFFFF, NULL,
    FALSE, FALSE
};


/* Default Rasmon user preference settings
*/
RMUSER g_rmuserDefaults = {

    //
    // Mode
    //
    RMDM_Taskbar,
    //
    // Flags
    //
    RMFLAG_SoundOnConnect | RMFLAG_SoundOnDisconnect | RMFLAG_SoundOnError |
    RMFLAG_Topmost | RMFLAG_Titlebar | RMFLAG_AllDevices, 
    //
    // list of devices to monitor activity on
    //
    NULL,

    //
    // desktop-window screen position and
    // saved widths for desktop-window columns
    //
    40, 40, 230, 80,
    80,

    //
    // property-sheet screen position and
    // saved widths for Summary page treelist columns
    //
    40, 40,
    252, 54,
    //
    // saved number of last page open on property sheet
    //
    RASMDPAGE_Status,
    //
    // saved name of last device selected on Status page
    //
    NULL
};


/*----------------------------------------------------------------------------
** Constants.
**----------------------------------------------------------------------------
*/

/* Node types used by MultiSz calls.
*/
#define NT_Psz 1
#define NT_Kv  2


/*----------------------------------------------------------------------------
** Local prototypes (alphabetically)
**----------------------------------------------------------------------------
*/

VOID
GetCallbackList(
    IN  HKEY      hkey,
    OUT DTLLIST** ppListResult );

VOID
GetLocationList(
    IN  HKEY      hkey,
    OUT DTLLIST** ppListResult );

VOID
GetRegDword(
    IN  HKEY   hkey,
    IN  TCHAR* pszName,
    OUT DWORD* pdwResult );

DWORD
GetRegMultiSz(
    IN     HKEY      hkey,
    IN     TCHAR*    pszName,
    IN OUT DTLLIST** ppListResult,
    IN     DWORD     dwNodeType );

DWORD
GetRegSz(
    IN  HKEY    hkey,
    IN  TCHAR*  pszName,
    OUT TCHAR** ppszResult );

DWORD
GetRegSzz(
    IN  HKEY    hkey,
    IN  TCHAR*  pszName,
    OUT TCHAR** ppszResult );

VOID
MoveLogonPreferences(
    void );

VOID
MoveUserPreferences(
    void );

DWORD
ReadUserPreferences(
    IN  HKEY    hkey,
    OUT PBUSER* pUser );

DWORD
RegDeleteTree(
    IN HKEY   RootKey,
    IN TCHAR* SubKeyName );

BOOL
RegDeleteTreeWorker(
    IN  HKEY   ParentKeyHandle,
    IN  TCHAR* KeyName,
    OUT DWORD* ErrorCode );

BOOL
RegValueExists(
    IN HKEY   hkey,
    IN TCHAR* pszValue );

DWORD
SetCallbackList(
    IN HKEY     hkey,
    IN DTLLIST* pList );

DWORD
SetDefaultUserPreferences(
    OUT PBUSER* pUser,
    IN  DWORD   dwMode );

DWORD
SetLocationList(
    IN HKEY     hkey,
    IN DTLLIST* pList );

DWORD
SetRegDword(
    IN HKEY   hkey,
    IN TCHAR* pszName,
    IN DWORD  dwValue );

DWORD
SetRegMultiSz(
    IN HKEY     hkey,
    IN TCHAR*   pszName,
    IN DTLLIST* pListValues,
    IN DWORD    dwNodeType );

DWORD
SetRegSz(
    IN HKEY   hkey,
    IN TCHAR* pszName,
    IN TCHAR* pszValue );

DWORD
SetRegSzz(
    IN  HKEY    hkey,
    IN  TCHAR*  pszName,
    IN  TCHAR*  pszValue );

DWORD
WriteUserPreferences(
    IN HKEY    hkey,
    IN PBUSER* pUser );


/*----------------------------------------------------------------------------
** Phonebook preference routines (alphabetically)
**----------------------------------------------------------------------------
*/

DTLNODE*
CreateLocationNode(
    IN DWORD dwLocationId,
    IN DWORD iPrefix,
    IN DWORD iSuffix )

    /* Returns a LOCATIONINFO node associated with TAPI location
    ** 'dwLocationId', prefix index 'iPrefix' and suffix index 'iSuffix'.
    */
{
    DTLNODE*      pNode;
    LOCATIONINFO* pInfo;

    pNode = DtlCreateSizedNode( sizeof(LOCATIONINFO), 0L );
    if (!pNode)
        return NULL;

    pInfo = (LOCATIONINFO* )DtlGetData( pNode );
    pInfo->dwLocationId = dwLocationId;
    pInfo->iPrefix = iPrefix;
    pInfo->iSuffix = iSuffix;

    return pNode;
}


DTLNODE*
CreateCallbackNode(
    IN TCHAR* pszPortName,
    IN TCHAR* pszDeviceName,
    IN TCHAR* pszNumber,
    IN DWORD  dwDeviceType )

    /* Returns a CALLBACKINFO node containing a copy of 'pszPortName',
    ** 'pszDeviceName' and 'pszNumber' and 'dwDeviceType' or NULL on error.
    ** It is caller's responsibility to DestroyCallbackNode the returned node.
    */
{
    DTLNODE*      pNode;
    CALLBACKINFO* pInfo;

    pNode = DtlCreateSizedNode( sizeof(CALLBACKINFO), 0L );
    if (!pNode)
        return NULL;

    pInfo = (CALLBACKINFO* )DtlGetData( pNode );
    pInfo->pszPortName = StrDup( pszPortName );
    pInfo->pszDeviceName = StrDup( pszDeviceName );
    pInfo->pszNumber = StrDup( pszNumber );
    pInfo->dwDeviceType = dwDeviceType;

    if (!pInfo->pszPortName || !pInfo->pszDeviceName || !pInfo->pszNumber)
    {
        Free0( pInfo->pszPortName );
        Free0( pInfo->pszDeviceName );
        DtlDestroyNode( pNode );
        return NULL;
    }

    return pNode;
}


VOID
DestroyLocationNode(
    IN DTLNODE* pNode )

    /* Release memory allociated with location node 'pNode'.
    */
{
    DtlDestroyNode( pNode );
}


VOID
DestroyCallbackNode(
    IN DTLNODE* pNode )

    /* Release memory allociated with callback node 'pNode'.
    */
{
    CALLBACKINFO* pInfo;

    ASSERT(pNode);
    pInfo = (CALLBACKINFO* )DtlGetData( pNode );
    ASSERT(pInfo);

    Free0( pInfo->pszPortName );
    Free0( pInfo->pszDeviceName );
    Free0( pInfo->pszNumber );

    DtlDestroyNode( pNode );
}


VOID
DestroyUserPreferences(
    IN PBUSER* pUser )

    /* Releases memory allocated by GetUserPreferences and zeros the
    ** structure.
    */
{
    if (pUser->fInitialized)
    {
        DtlDestroyList( pUser->pdtllistCallback, DestroyCallbackNode );
        DtlDestroyList( pUser->pdtllistPhonebooks, DestroyPszNode );
        DtlDestroyList( pUser->pdtllistAreaCodes, DestroyPszNode );
        DtlDestroyList( pUser->pdtllistPrefixes, DestroyPszNode );
        DtlDestroyList( pUser->pdtllistSuffixes, DestroyPszNode );
        DtlDestroyList( pUser->pdtllistLocations, DestroyLocationNode );
        Free0( pUser->pszPersonalFile );
        Free0( pUser->pszAlternatePath );
        Free0( pUser->pszLastCallbackByCaller );
        Free0( pUser->pszDefaultEntry );
    }

    ZeroMemory( pUser, sizeof(*pUser) );
}


DTLNODE*
DuplicateLocationNode(
    IN DTLNODE* pNode )

    /* Duplicates LOCATIONINFO node 'pNode'.  See DtlDuplicateList.
    **
    ** Returns the address of the allocated node or NULL if out of memory.  It
    ** is caller's responsibility to free the returned node.
    */
{
    LOCATIONINFO* pInfo = (LOCATIONINFO* )DtlGetData( pNode );

    return CreateLocationNode(
        pInfo->dwLocationId, pInfo->iPrefix, pInfo->iSuffix );
}


DWORD
GetUserPreferences(
    OUT PBUSER* pUser,
    IN  DWORD   dwMode )

    /* Load caller's 'pUser' with user phonebook preferences from the
    ** registry.  'DwMode' indicates the preferences to get, either the normal
    ** interactive user, the pre-logon, or router preferences.
    **
    ** Returns 0 if successful or an error code.  If successful, caller should
    ** eventually call DestroyUserPreferences to release the returned heap
    ** buffers.
    */
{
    DWORD dwErr;

    TRACE1("GetUserPreferences(m=%d)",dwMode);

    /* Move the user preferences, if it's not already been done.
    */
    if (dwMode == UPM_Normal)
        MoveUserPreferences();
    else if (dwMode == UPM_Logon)
        MoveLogonPreferences();

    dwErr = SetDefaultUserPreferences( pUser, dwMode );
    if (dwErr == 0)
    {
        HKEY  hkey;
        DWORD dwErr2;

        if (dwMode == UPM_Normal)
        {
            dwErr2 = RegOpenKeyEx(
                HKEY_CURRENT_USER, (LPCTSTR )REGKEY_HkcuRas,
                0, KEY_READ, &hkey );
        }
        else if (dwMode == UPM_Logon)
        {
            dwErr2 = RegOpenKeyEx(
                HKEY_USERS, (LPCTSTR )REGKEY_HkuRasLogon,
                0, KEY_READ, &hkey );
        }
        else
        {
            ASSERT(dwMode==UPM_Router);
            dwErr2 = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE, (LPCTSTR )REGKEY_HklmRouter,
                0, KEY_READ, &hkey );
        }

        if (dwErr2 == 0)
        {
            if (ReadUserPreferences( hkey, pUser ) != 0)
                dwErr = SetDefaultUserPreferences( pUser, dwMode );
            RegCloseKey( hkey );
        }
        else
        {
            TRACE1("RegOpenKeyEx=%d",dwErr2);
        }
    }

    TRACE1("GetUserPreferences=%d",dwErr);
    return dwErr;
}


DWORD
SetUserPreferences(
    IN PBUSER* pUser,
    IN DWORD   dwMode )

    /* Set current user phonebook preferences in the registry from caller's
    ** settings in 'pUser', if necessary.  'DwMode' indicates the preferences
    ** to get, either the normal interactive user, the pre-logon, or router
    ** preferences.
    **
    ** Returns 0 if successful, or an error code.  Caller's 'pUser' is marked
    ** clean if successful.
    */
{
    DWORD dwErr;
    DWORD dwDisposition;
    HKEY  hkey;

    TRACE1("SetUserPreferences(m=%d)",dwMode);

    if (!pUser->fDirty)
        return 0;

    /* Create the preference key, or if it exists just open it.
    */
    if (dwMode == UPM_Normal)
    {
        dwErr = RegCreateKeyEx( HKEY_CURRENT_USER, REGKEY_HkcuRas,
            0, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
            &hkey, &dwDisposition );
    }
    else if (dwMode == UPM_Logon)
    {
        dwErr = RegCreateKeyEx( HKEY_USERS, REGKEY_HkuRasLogon,
            0, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
            &hkey, &dwDisposition );
    }
    else
    {
        ASSERT(dwMode==UPM_Router);
        dwErr = RegCreateKeyEx( HKEY_LOCAL_MACHINE, REGKEY_HklmRouter,
            0, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
            &hkey, &dwDisposition );
    }

    if (dwErr == 0)
    {
        dwErr = WriteUserPreferences( hkey, pUser );
        RegCloseKey( hkey );
    }

    TRACE1("SetUserPreferences=%d",dwErr);
    return dwErr;
}


/*----------------------------------------------------------------------------
** Rasmon preference routines (alphabetically)
**----------------------------------------------------------------------------
*/


VOID
DestroyRasmonPreferences(
    IN RMUSER *pUser )

    /* Releases memory allocated by GetRasmonPreferences and zeroes the
    ** structure.
    */
{

    if (!pUser) { return; }

    Free0(pUser->pszLastDevice);

    Free0(pUser->pszzDeviceList);

    ZeroMemory(pUser, sizeof(*pUser));

    return;
}


DWORD
GetRasmonPreferences(
    OUT RMUSER *pUser )

    /* Retrieves the preferences for the current user.
    */
{

    HKEY hkey;
    DWORD dwErr;
    PTSTR pszPos;


    //
    // Set default values; on a no-mouse system, we default to
    // desktop-mode, with title-bar and tasklist-entry,
    // so we see if there's a mouse to decide which mode to use
    //

    if (!GetSystemMetrics(SM_MOUSEPRESENT)) {

        g_rmuserDefaults.dwMode = RMDM_Desktop;
        g_rmuserDefaults.dwFlags |= RMFLAG_Tasklist;
    }

    *pUser = g_rmuserDefaults;


    //
    // open the RASMON key
    //

    dwErr = RegOpenKeyEx( HKEY_CURRENT_USER, REGKEY_Rasmon,
                0, KEY_READ, &hkey );
    if (dwErr != NO_ERROR) {
        // just use the defaults
        return NO_ERROR;
    }


    //
    // read the values
    //

    GetRegDword( hkey, REGVAL_dwMode, &pUser->dwMode );

    GetRegDword( hkey, REGVAL_dwFlags, &pUser->dwFlags );

    GetRegDword( hkey, REGVAL_dwX, (PDWORD)&pUser->x );

    GetRegDword( hkey, REGVAL_dwY, (PDWORD)&pUser->y );

    GetRegDword( hkey, REGVAL_dwCx, (PDWORD)&pUser->cx );

    GetRegDword( hkey, REGVAL_dwCy, (PDWORD)&pUser->cy );

    GetRegDword( hkey, REGVAL_dwCxCol1, (PDWORD)&pUser->cxCol1 );

    GetRegDword( hkey, REGVAL_dwXDlg, (PDWORD)&pUser->xDlg );

    GetRegDword( hkey, REGVAL_dwYDlg, (PDWORD)&pUser->yDlg );

    GetRegDword( hkey, REGVAL_dwCxDlgCol1, (PDWORD)&pUser->cxDlgCol1 );

    GetRegDword( hkey, REGVAL_dwCxDlgCol2, (PDWORD)&pUser->cxDlgCol2 );

    GetRegDword( hkey, REGVAL_dwStartPage, &pUser->dwStartPage );

    GetRegSz( hkey, REGVAL_szLastDevice, &pUser->pszLastDevice );

    GetRegSzz( hkey, REGVAL_mszDeviceList, &pUser->pszzDeviceList );

    RegCloseKey(hkey);

    return NO_ERROR;
}


DWORD
SetRasmonUserPreferences(
    IN  RMUSER* pUser )

    /* This function saves the settings which are controlled
    ** by the user via the context menu and/or Preferences page.
    */

{

    HKEY hkey;
    DWORD dwErr, dwDisposition;


    //
    // create the RASMON key (or open if it exists)
    //

    dwErr = RegCreateKeyEx(
                HKEY_CURRENT_USER, REGKEY_Rasmon,  0, TEXT(""),
                REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                &hkey, &dwDisposition
                );

    if (dwErr != NO_ERROR) {
        return dwErr;
    }

    do {


        dwErr = SetRegDword( hkey, REGVAL_dwMode, pUser->dwMode );
        if (dwErr != 0) { break; }

        dwErr = SetRegDword( hkey, REGVAL_dwFlags, pUser->dwFlags );
        if (dwErr != 0) { break; }

        dwErr = SetRegSzz( hkey, REGVAL_mszDeviceList, pUser->pszzDeviceList );
        if (dwErr != 0) { break; }



    } while(FALSE);

    RegCloseKey(hkey);

    return dwErr;
}


DWORD
SetRasmonWndPreferences(
    IN  RMUSER* pUser )

    /* This function saves the settings which pertain to the window
    ** in particular rather than to RASMON as a whole.
    ** These settings are saved each time the window is closed.
    */
{

    HKEY hkey;
    DWORD dwErr, dwDisposition;


    //
    // create the RASMON key (or open if it exists)
    //

    dwErr = RegCreateKeyEx(
                HKEY_CURRENT_USER, REGKEY_Rasmon,  0, TEXT(""),
                REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                &hkey, &dwDisposition
                );

    if (dwErr != NO_ERROR) {
        return dwErr;
    }

    do {


        dwErr = SetRegDword( hkey, REGVAL_dwX, (DWORD)pUser->x );
        if (dwErr != 0) { break; }

        dwErr = SetRegDword( hkey, REGVAL_dwY, (DWORD)pUser->y );
        if (dwErr != 0) { break; }

        dwErr = SetRegDword( hkey, REGVAL_dwCx, (DWORD)pUser->cx );
        if (dwErr != 0) { break; }

        dwErr = SetRegDword( hkey, REGVAL_dwCy, (DWORD)pUser->cy );
        if (dwErr != 0) { break; }

        dwErr = SetRegDword( hkey, REGVAL_dwCxCol1, (DWORD)pUser->cxCol1 );
        if (dwErr != 0) { break; }


    } while(FALSE);

    RegCloseKey(hkey);

    return dwErr;
}



DWORD
SetRasmonDlgPreferences(
    IN  RMUSER* pUser )

    /* This function saves the settings which pertain to the Monitor property
    ** sheet in particular rather than to RASMON as a whole.
    ** These settings are saved each time the property sheet closes.
    */
{

    HKEY hkey;
    DWORD dwErr, dwDisposition;


    //
    // create the RASMON key (or open if it exists)
    //

    dwErr = RegCreateKeyEx(
                HKEY_CURRENT_USER, REGKEY_Rasmon,  0, TEXT(""),
                REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                &hkey, &dwDisposition
                );

    if (dwErr != NO_ERROR) {
        return dwErr;
    }

    do {

        dwErr = SetRegDword( hkey, REGVAL_dwXDlg, (DWORD)pUser->xDlg );
        if (dwErr != 0) { break; }

        dwErr = SetRegDword( hkey, REGVAL_dwYDlg, (DWORD)pUser->yDlg );
        if (dwErr != 0) { break; }

        dwErr = SetRegDword( hkey, REGVAL_dwCxDlgCol1, (DWORD)pUser->cxDlgCol1);
        if (dwErr != 0) { break; }

        dwErr = SetRegDword( hkey, REGVAL_dwCxDlgCol2, (DWORD)pUser->cxDlgCol2);
        if (dwErr != 0) { break; }

        dwErr = SetRegDword( hkey, REGVAL_dwStartPage, pUser->dwStartPage );
        if (dwErr != 0) { break; }

        dwErr = SetRegSz( hkey, REGVAL_szLastDevice, pUser->pszLastDevice );
        if (dwErr != 0) { break; }


    } while(FALSE);

    RegCloseKey(hkey);

    return dwErr;
}



DWORD
SetRasmonPreferences(
    IN RMUSER *pUser)

    /* This function saves the all the RASMON settings to the registry
    */
{

    DWORD dwErr;
    dwErr = SetRasmonDlgPreferences(pUser);
    if (dwErr != NO_ERROR) { return dwErr; }

    dwErr = SetRasmonWndPreferences(pUser);
    if (dwErr != NO_ERROR) { return dwErr; }

    dwErr = SetRasmonUserPreferences(pUser);
    return dwErr;
}




/*----------------------------------------------------------------------------
** Utilities (alphabetically)
**----------------------------------------------------------------------------
*/

VOID
GetCallbackList(
    IN  HKEY      hkey,
    OUT DTLLIST** ppListResult )

    /* Replaces '*ppListResult' with a list containing a node for each device
    ** name under registry value "REGVAL_szCallback" of registry key 'hkey'.
    ** If no values exist *ppListResult' is replaced with an empty list.
    **
    ** It is caller's responsibility to destroy the returned list if non-NULL.
    */
{
    DWORD    dwErr;
    TCHAR    szDP[ RAS_MaxDeviceName + 2 + MAX_PORT_NAME + 1 + 1 ];
    TCHAR*   pszDevice;
    TCHAR*   pszPort;
    TCHAR*   pszNumber;
    DWORD    dwDeviceType;
    DWORD    cb;
    INT      i;
    DTLLIST* pList;
    DTLNODE* pNode;
    HKEY     hkeyCb;
    HKEY     hkeyDP;

    pList = DtlCreateList( 0 );
    if (!pList)
        return;

    dwErr = RegOpenKeyEx( hkey, REGKEY_Callback, 0, KEY_READ, &hkeyCb );
    if (dwErr == 0)
    {
        for (i = 0; TRUE; ++i)
        {
            cb = sizeof(szDP)/sizeof(TCHAR);    //for bug170549
            dwErr = RegEnumKeyEx(
                        hkeyCb, i, szDP, &cb, NULL, NULL, NULL, NULL );
            if (dwErr == ERROR_NO_MORE_ITEMS)
                break;
            if (dwErr != 0)
                continue;

            /* Ignore keys not of the form "device (port)".
            */
            if (!DeviceAndPortFromPsz( szDP, &pszDevice, &pszPort ))
                continue;

            dwErr = RegOpenKeyEx( hkeyCb, szDP, 0, KEY_READ, &hkeyDP );
            if (dwErr == 0)
            {
                GetRegDword( hkeyDP, REGVAL_dwDeviceType, &dwDeviceType );

                dwErr = GetRegSz( hkeyDP, REGVAL_szNumber, &pszNumber );
                if (dwErr == 0)
                {
                    pNode = CreateCallbackNode(
                                pszPort, pszDevice, pszNumber, dwDeviceType );
                    if (pNode)
                        DtlAddNodeLast( pList, pNode );
                    Free( pszNumber );
                }

                RegCloseKey( hkeyDP );
            }

            Free( pszDevice );
            Free( pszPort );
        }

        RegCloseKey( hkeyCb );
    }

    DtlDestroyList( *ppListResult, DestroyCallbackNode );
    *ppListResult = pList;
}


VOID
GetLocationList(
    IN  HKEY      hkey,
    OUT DTLLIST** ppListResult )

    /* Replaces '*ppListResult' with a list containing a node for each
    ** location under registry value "REGVAL_szLocation" of registry key
    ** 'hkey'.  If no values exist *ppListResult' is replaced with an empty
    ** list.
    **
    ** It is caller's responsibility to destroy the returned list if non-NULL.
    */
{
    DWORD    dwErr;
    TCHAR    szId[ MAXLTOTLEN + 1 ];
    DWORD    cb;
    INT      i;
    DTLLIST* pList;
    DTLNODE* pNode;
    HKEY     hkeyL;
    HKEY     hkeyId;

    pList = DtlCreateList( 0 );
    if (!pList)
        return;

    dwErr = RegOpenKeyEx( hkey, REGKEY_Location, 0, KEY_READ, &hkeyL );
    if (dwErr == 0)
    {
        for (i = 0; TRUE; ++i)
        {
            cb = MAXLTOTLEN + 1;
            dwErr = RegEnumKeyEx( hkeyL, i, szId, &cb, NULL, NULL, NULL, NULL );
            if (dwErr == ERROR_NO_MORE_ITEMS)
                break;
            if (dwErr != 0)
                continue;

            dwErr = RegOpenKeyEx( hkeyL, szId, 0, KEY_READ, &hkeyId );
            if (dwErr == 0)
            {
                DWORD dwId;
                DWORD iPrefix;
                DWORD iSuffix;

                dwId = (DWORD )TToL( szId );
                iPrefix = 0;
                GetRegDword( hkeyId, REGVAL_dwPrefix, &iPrefix );
                iSuffix = 0;
                GetRegDword( hkeyId, REGVAL_dwSuffix, &iSuffix );

                pNode = CreateLocationNode( dwId, iPrefix, iSuffix );
                if (!pNode)
                    continue;

                DtlAddNodeLast( pList, pNode );

                RegCloseKey( hkeyId );
            }
        }

        RegCloseKey( hkeyL );
    }

    DtlDestroyList( *ppListResult, DestroyLocationNode );
    *ppListResult = pList;
}


VOID
GetRegDword(
    IN  HKEY   hkey,
    IN  TCHAR* pszName,
    OUT DWORD* pdwResult )

    /* Set '*pdwResult' to the DWORD registry value 'pszName' under key
    ** 'hkey'.  If the value does not exist '*pdwResult' is unchanged.
    */
{
    DWORD dwErr;
    DWORD dwType;
    DWORD dwResult;
    DWORD cb;

    cb = sizeof(DWORD);
    dwErr = RegQueryValueEx(
        hkey, pszName, NULL, &dwType, (LPBYTE )&dwResult, &cb );

    if (dwErr == 0 && dwType == REG_DWORD && cb == sizeof(DWORD))
        *pdwResult = dwResult;
}


DWORD
GetRegMultiSz(
    IN     HKEY      hkey,
    IN     TCHAR*    pszName,
    IN OUT DTLLIST** ppListResult,
    IN     DWORD     dwNodeType )

    /* Replaces '*ppListResult' with a list containing a node for each string
    ** in the MULTI_SZ registry value 'pszName' under key 'hkey'.  If the
    ** value does not exist *ppListResult' is replaced with an empty list.
    ** 'DwNodeType' determines the type of node.
    **
    ** Returns 0 if successful or an error code.  It is caller's
    ** responsibility to destroy the returned list.
    */
{
    DWORD    dwErr;
    DWORD    dwType;
    DWORD    cb;
    TCHAR*   pszzResult;
    DTLLIST* pList;

    pList = DtlCreateList( 0 );
    if (!pList)
        return ERROR_NOT_ENOUGH_MEMORY;

    pszzResult = NULL;

    /* Get result buffer size required.
    */
    dwErr = RegQueryValueEx(
        hkey, pszName, NULL, &dwType, NULL, &cb );

    if (dwErr != 0)
    {
        /* If can't find the value, just return an empty list.  This not
        ** considered an error.
        */
        dwErr = 0;
    }
    else
    {
        /* Allocate result buffer.
        */
        pszzResult = Malloc( cb );
        if (!pszzResult)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            /* Get the result string.  It's not an error if we can't get it.
            */
            dwErr = RegQueryValueEx(
                hkey, pszName, NULL, &dwType, (LPBYTE )pszzResult, &cb );

            if (dwErr != 0)
            {
                /* Not an error if can't read the string, though this should
                ** have been caught by the query retrieving the buffer size.
                */
                dwErr = 0;
            }
            else if (dwType == REG_MULTI_SZ)
            {
                TCHAR* psz;
                TCHAR* pszKey;

                /* Convert the result to a list of strings.
                */
                pszKey = NULL;
                for (psz = pszzResult;
                     *psz != TEXT('\0');
                     psz += lstrlen( psz ) + 1)
                {
                    DTLNODE* pNode;

                    if (dwNodeType == NT_Psz)
                    {
                        pNode = CreatePszNode( psz );
                    }
                    else
                    {
                        if (pszKey)
                        {
                            ASSERT(*psz==TEXT('='));
                            pNode = CreateKvNode( pszKey, psz + 1 );
                            pszKey = NULL;
                        }
                        else
                        {
                            pszKey = psz;
                            continue;
                        }
                    }

                    if (!pNode)
                    {
                        dwErr = ERROR_NOT_ENOUGH_MEMORY;
                        break;
                    }

                    DtlAddNodeLast( pList, pNode );
                }
            }
        }
    }

    {
        PDESTROYNODE pfunc;

        if (dwNodeType == NT_Psz)
            pfunc = DestroyPszNode;
        else
            pfunc = DestroyKvNode;

        if (dwErr == 0)
        {
            DtlDestroyList( *ppListResult, pfunc );
            *ppListResult = pList;
        }
        else
            DtlDestroyList( pList, pfunc );
    }

    Free0( pszzResult );
    return 0;
}


DWORD
GetRegSz(
    IN  HKEY    hkey,
    IN  TCHAR*  pszName,
    OUT TCHAR** ppszResult )

    /* Set '*ppszResult' to the SZ registry value 'pszName' under key 'hkey'.
    ** If the value does not exist *ppszResult' is set to empty string.
    **
    ** Returns 0 if successful or an error code.  It is caller's
    ** responsibility to Free the returned string.
    */
{
    DWORD  dwErr = NO_ERROR;
    DWORD  dwType;
    DWORD  cb = 0L;    TCHAR* pszResult = NULL;

    /* Get result buffer size required.
    */
    dwErr = RegQueryValueEx(
        hkey, pszName, NULL, &dwType, NULL, &cb );
    if (dwErr != 0)
        cb = sizeof(TCHAR);

    /* Allocate result buffer.
    */
    pszResult = Malloc( cb );
    if (!pszResult)
        return ERROR_NOT_ENOUGH_MEMORY;

    *pszResult = TEXT('\0');
    *ppszResult = pszResult;

    /* Get the result string.  It's not an error if we can't get it.
    */
    dwErr = RegQueryValueEx(
        hkey, pszName, NULL, &dwType, (LPBYTE )pszResult, &cb );

    return 0;
}


DWORD
GetRegSzz(
    IN  HKEY    hkey,
    IN  TCHAR*  pszName,
    OUT TCHAR** ppszResult )

    /* Set '*ppszResult to the MULTI_SZ registry value 'pszName'
    ** under key 'hkey', returned as a null-terminated list of
    ** null-terminated strings. If the value does not exist,
    ** *ppszResult is set to an empty string (single null character).
    **
    ** Returns 0 if successful or an error code. It is caller's
    ** responsibility to Free the returned string.
    */
{
    DWORD  dwErr;
    DWORD  dwType;
    DWORD  cb = 0L;
    TCHAR* pszResult;

    /* Get result buffer size required.
    */
    dwErr = RegQueryValueEx(
        hkey, pszName, NULL, &dwType, NULL, &cb );
    if (dwErr != 0)
        cb = sizeof(TCHAR);

    /* Allocate result buffer.
    */
    pszResult = Malloc( cb );
    if (!pszResult)
        return ERROR_NOT_ENOUGH_MEMORY;

    *pszResult = TEXT('\0');
    *ppszResult = pszResult;

    /* Get the result string list.  It's not an error if we can't get it.
    */
    dwErr = RegQueryValueEx(
        hkey, pszName, NULL, &dwType, (LPBYTE )pszResult, &cb );

    return 0;
}


VOID
MoveLogonPreferences(
    void )

    /* Move logon preferences from the NT 4.0 location to a new unique
    ** position, if necessary.  This manuever is added because in NT 4.0 user
    ** preference calls from LocalSystem service use the old logon location at
    ** HKU\.DEFAULT due to fallbacks in the registry APIs causing logon and
    ** LocalSystem settings to overwrite each other.
    */
{
    DWORD  dwErr;
    HKEY   hkeyOld;
    HKEY   hkeyNew;
    PBUSER user;

    dwErr = RegOpenKeyEx(
        HKEY_USERS, (LPCTSTR )REGKEY_HkuOldRasLogon,
        0, KEY_READ, &hkeyOld );
    if (dwErr != 0)
        return;

    dwErr = RegOpenKeyEx(
        HKEY_USERS, (LPCTSTR )REGKEY_HkuRasLogon,
        0, KEY_READ, &hkeyNew );
    if (dwErr == 0)
        RegCloseKey( hkeyNew );
    else
    {
        /* Old tree exists and new tree doesn't.  Move a copy of the old tree
        ** to the new tree.
        */
        dwErr = SetDefaultUserPreferences( &user, UPM_Logon );
        if (dwErr == 0)
        {
            dwErr = ReadUserPreferences( hkeyOld, &user );
            if (dwErr == 0)
                dwErr = SetUserPreferences( &user, UPM_Logon );
        }

        DestroyUserPreferences( &user );
        TRACE1("MoveLogonPreferences=%d",dwErr);
    }

    RegCloseKey( hkeyOld );
}


VOID
MoveUserPreferences(
    void )

    /* Move user preferences from their old net-tools registry location to the
    ** new location nearer the other RAS keys.
    */
{
    DWORD dwErr;
    HKEY  hkeyOld;
    HKEY  hkeyNew;

    /* See if the old current-user key exists.
    */
    dwErr = RegOpenKeyEx(
        HKEY_CURRENT_USER, (LPCTSTR )REGKEY_HkcuOldRas, 0,
        KEY_ALL_ACCESS, &hkeyOld );

    if (dwErr == 0)
    {
        PBUSER user;

        /* Read the preferences at the old key.
        */
        TRACE("Getting old prefs");
        dwErr = SetDefaultUserPreferences( &user, UPM_Normal );
        if (dwErr == 0)
        {
            dwErr = ReadUserPreferences( hkeyOld, &user );
            if (dwErr == 0)
            {
                /* Write the preferences at the new key.
                */
                user.fDirty = TRUE;
                dwErr = SetUserPreferences( &user, FALSE );
                if (dwErr == 0)
                {
                    /* Blow away the old tree.
                    */
                    dwErr = RegOpenKeyEx(
                        HKEY_CURRENT_USER, (LPCTSTR )REGKEY_HkcuOldRasParent,
                        0, KEY_ALL_ACCESS, &hkeyNew );
                    if (dwErr == 0)
                    {
                        TRACE("Delete old prefs");
                        dwErr = RegDeleteTree( hkeyNew, REGKEY_HkcuOldRasRoot );
                        RegCloseKey( hkeyNew );
                    }
                }
            }
        }

        RegCloseKey( hkeyOld );

        TRACE1("MoveUserPreferences=%d",dwErr);
    }
}


DWORD
ReadUserPreferences(
    IN  HKEY    hkey,
    OUT PBUSER* pUser )

    /* Fill caller's 'pUser' buffer with user preferences from RAS-Phonebook
    ** registry tree 'hkey'.
    **
    ** Returns 0 if successful, false otherwise.
    */
{
    BOOL  fOldSettings;
    DWORD dwErr;

    TRACE("ReadUserPreferences");

    /* Read the values.
    */
    {
        DWORD dwMode;

        /* Lack of a phonebook mode key indicates that we are updating old NT
        ** 3.51-style settings.
        */
        dwMode = 0xFFFFFFFF;
        GetRegDword( hkey, REGVAL_dwPhonebookMode, &dwMode );
        if (dwMode != 0xFFFFFFFF)
        {
            pUser->dwPhonebookMode = dwMode;
            fOldSettings = FALSE;
        }
        else
            fOldSettings = TRUE;
    }

    GetRegDword( hkey, REGVAL_fOperatorDial,
        &pUser->fOperatorDial );
    GetRegDword( hkey, REGVAL_fPreviewPhoneNumber,
        &pUser->fPreviewPhoneNumber );
    GetRegDword( hkey, REGVAL_fUseLocation,
        &pUser->fUseLocation );
    GetRegDword( hkey, REGVAL_fShowLights,
        &pUser->fShowLights );
    GetRegDword( hkey, REGVAL_fShowConnectStatus,
        &pUser->fShowConnectStatus );
    GetRegDword( hkey, REGVAL_fNewEntryWizard,
        &pUser->fNewEntryWizard );
    GetRegDword( hkey, REGVAL_fCloseOnDial,
        &pUser->fCloseOnDial );
    GetRegDword( hkey, REGVAL_fAllowLogonPhonebookEdits,
        &pUser->fAllowLogonPhonebookEdits );
    GetRegDword( hkey, REGVAL_fAllowLogonLocationEdits,
        &pUser->fAllowLogonLocationEdits );
    GetRegDword( hkey, REGVAL_fSkipConnectComplete,
        &pUser->fSkipConnectComplete );
    GetRegDword( hkey, REGVAL_dwRedialAttempts,
        &pUser->dwRedialAttempts );
    GetRegDword( hkey, REGVAL_dwRedialSeconds,
        &pUser->dwRedialSeconds );
    GetRegDword( hkey, REGVAL_dwIdleDisconnectSeconds,
        &pUser->dwIdleDisconnectSeconds );
    GetRegDword( hkey, REGVAL_fRedialOnLinkFailure,
        &pUser->fRedialOnLinkFailure );
    GetRegDword( hkey, REGVAL_fPopupOnTopWhenRedialing,
        &pUser->fPopupOnTopWhenRedialing );
    GetRegDword( hkey, REGVAL_fExpandAutoDialQuery,
        &pUser->fExpandAutoDialQuery );
    GetRegDword( hkey, REGVAL_dwCallbackMode,
        &pUser->dwCallbackMode );
    GetRegDword( hkey, REGVAL_fUseAreaAndCountry,
        &pUser->fUseAreaAndCountry );
    GetRegDword( hkey, REGVAL_dwXWindow,
        &pUser->dwXPhonebook );
    GetRegDword( hkey, REGVAL_dwYWindow,
        &pUser->dwYPhonebook );

    do
    {
        GetCallbackList( hkey, &pUser->pdtllistCallback );

        dwErr = GetRegMultiSz( hkey, REGVAL_mszPhonebooks,
            &pUser->pdtllistPhonebooks, NT_Psz );
        if (dwErr != 0)
            break;

        dwErr = GetRegMultiSz( hkey, REGVAL_mszAreaCodes,
            &pUser->pdtllistAreaCodes, NT_Psz );
        if (dwErr != 0)
            break;

        /* If the prefixes key doesn't exist don't read an empty list over the
        ** defaults.
        */
        if (RegValueExists( hkey, REGVAL_mszPrefixes ))
        {
            dwErr = GetRegMultiSz( hkey, REGVAL_mszPrefixes,
                &pUser->pdtllistPrefixes, NT_Psz );
            if (dwErr != 0)
                break;
        }

        dwErr = GetRegMultiSz( hkey, REGVAL_mszSuffixes,
            &pUser->pdtllistSuffixes, NT_Psz );
        if (dwErr != 0)
            break;

        GetLocationList( hkey, &pUser->pdtllistLocations );

        dwErr = GetRegSz( hkey, REGVAL_szLastCallbackByCaller,
            &pUser->pszLastCallbackByCaller );
        if (dwErr != 0)
            break;

        /* Get the personal phonebook file name, if any.  In NT 3.51, the full
        ** path was stored, but now "<nt>\system32\ras" directory is assumed.
        ** This gives better (not perfect) behavior with user profiles rooted
        ** on different drive letters.
        */
        {
            TCHAR* psz;

            dwErr = GetRegSz( hkey, REGVAL_szPersonalPhonebookPath, &psz );
            if (dwErr != 0)
                break;

            if (*psz == TEXT('\0'))
            {
                Free(psz);
                dwErr = GetRegSz( hkey, REGVAL_szPersonalPhonebookFile,
                    &pUser->pszPersonalFile );
                if (dwErr != 0)
                    break;
            }
            else
            {
                pUser->pszPersonalFile = StrDup( StripPath( psz ) );
                Free( psz );
                if (!pUser->pszPersonalFile)
                {
                    dwErr = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }
            }
        }

        dwErr = GetRegSz( hkey, REGVAL_szAlternatePhonebookPath,
            &pUser->pszAlternatePath );
        if (dwErr != 0)
            break;

        dwErr = GetRegSz( hkey, REGVAL_szDefaultEntry,
            &pUser->pszDefaultEntry );
        if (dwErr != 0)
            break;

        if (fOldSettings)
        {
            TCHAR* psz;

            psz = NULL;
            dwErr = GetRegSz( hkey, REGVAL_szUsePersonalPhonebook, &psz );
            if (dwErr != 0)
                break;
            if (psz)
            {
                if (*psz == TEXT('1'))
                    pUser->dwPhonebookMode = PBM_Personal;
                Free( psz );
            }
        }
    }
    while (FALSE);

    if (dwErr != 0)
        DestroyUserPreferences( pUser );

    TRACE1("ReadUserPreferences=%d",dwErr);
    return dwErr;
}


DWORD
RegDeleteTree(
    IN HKEY   RootKey,
    IN TCHAR* SubKeyName )

    /* Delete registry tree 'SubKeyName' under key 'RootKey'.
    **
    ** (taken from Ted Miller's setup API)
    */
{
    DWORD d,err;

    d = RegDeleteTreeWorker(RootKey,SubKeyName,&err) ? NO_ERROR : err;

    if((d == ERROR_FILE_NOT_FOUND) || (d == ERROR_PATH_NOT_FOUND)) {
        d = NO_ERROR;
    }

    if(d == NO_ERROR) {
        //
        // Delete top-level key
        //
        d = RegDeleteKey(RootKey,SubKeyName);
        if((d == ERROR_FILE_NOT_FOUND) || (d == ERROR_PATH_NOT_FOUND)) {
            d = NO_ERROR;
        }
    }

    return(d);
}


BOOL
RegDeleteTreeWorker(
    IN  HKEY   ParentKeyHandle,
    IN  TCHAR* KeyName,
    OUT DWORD* ErrorCode )

    /* Delete all subkeys of a key whose name and parent's handle was passed
    ** as parameter.  The algorithm used in this function guarantees that the
    ** maximum number of descendent keys will be deleted.
    **
    ** 'ParentKeyHandle' is a handle to the parent of the key that is
    ** currently being examined.
    **
    ** 'KeyName' is the name of the key that is currently being examined.
    ** This name can be an empty string (but not a NULL pointer), and in this
    ** case ParentKeyHandle refers to the key that is being examined.
    **
    ** 'ErrorCode' is the address to receive a Win32 error code if the
    ** function fails.
    **
    ** Returns true if successful, false otherwise.
    **
    ** (taken from Ted Miller's setup API)
    */
{
    HKEY     CurrentKeyTraverseAccess;
    DWORD    iSubKey;
    TCHAR    SubKeyName[MAX_PATH+1];
    DWORD    SubKeyNameLength;
    FILETIME ftLastWriteTime;
    LONG     Status;
    LONG     StatusEnum;
    LONG     SavedStatus;


    //
    //  Do not accept NULL pointer for ErrorCode
    //
    if(ErrorCode == NULL) {
        return(FALSE);
    }
    //
    //  Do not accept NULL pointer for KeyName.
    //
    if(KeyName == NULL) {
        *ErrorCode = ERROR_INVALID_PARAMETER;
        return(FALSE);
    }

    //
    // Open a handle to the key whose subkeys are to be deleted.
    // Since we need to delete its subkeys, the handle must have
    // KEY_ENUMERATE_SUB_KEYS access.
    //
    Status = RegOpenKeyEx(
                ParentKeyHandle,
                KeyName,
                0,
                KEY_ENUMERATE_SUB_KEYS | DELETE,
                &CurrentKeyTraverseAccess
                );

    if(Status != ERROR_SUCCESS) {
        //
        //  If unable to enumerate the subkeys, return error.
        //
        *ErrorCode = Status;
        return(FALSE);
    }

    //
    //  Traverse the key
    //
    iSubKey = 0;
    SavedStatus = ERROR_SUCCESS;
    do {
        //
        // Get the name of a subkey
        //
        SubKeyNameLength = sizeof(SubKeyName) / sizeof(TCHAR);
        StatusEnum = RegEnumKeyEx(
                        CurrentKeyTraverseAccess,
                        iSubKey,
                        SubKeyName,
                        &SubKeyNameLength,
                        NULL,
                        NULL,
                        NULL,
                        &ftLastWriteTime
                        );

        if(StatusEnum == ERROR_SUCCESS) {
            //
            // Delete all children of the subkey.
            // Just assume that the children will be deleted, and don't check
            // for failure.
            //
            RegDeleteTreeWorker(CurrentKeyTraverseAccess,SubKeyName,&Status);
            //
            // Now delete the subkey, and check for failure.
            //
            Status = RegDeleteKey(CurrentKeyTraverseAccess,SubKeyName);
            //
            // If unable to delete the subkey, then save the error code.
            // Note that the subkey index is incremented only if the subkey
            // was not deleted.
            //
            if(Status != ERROR_SUCCESS) {
                iSubKey++;
                SavedStatus = Status;
            }
        } else {
            //
            // If unable to get a subkey name due to ERROR_NO_MORE_ITEMS,
            // then the key doesn't have subkeys, or all subkeys were already
            // enumerated. Otherwise, an error has occurred, so just save
            // the error code.
            //
            if(StatusEnum != ERROR_NO_MORE_ITEMS) {
                SavedStatus = StatusEnum;
            }
        }
        //if((StatusEnum != ERROR_SUCCESS ) && (StatusEnum != ERROR_NO_MORE_ITEMS)) {
        //    printf( "RegEnumKeyEx() failed, Key Name = %ls, Status = %d, iSubKey = %d \n",KeyName,StatusEnum,iSubKey);
        //}
    } while(StatusEnum == ERROR_SUCCESS);

    //
    // Close the handle to the key whose subkeys were deleted, and return
    // the result of the operation.
    //
    RegCloseKey(CurrentKeyTraverseAccess);

    if(SavedStatus != ERROR_SUCCESS) {
        *ErrorCode = SavedStatus;
        return(FALSE);
    }
    return(TRUE);
}


BOOL
RegValueExists(
    IN HKEY   hkey,
    IN TCHAR* pszValue )

    /* Returns true if 'pszValue' is an existing value under 'hkey', false if
    ** not.
    */
{
    DWORD dwErr;
    DWORD dwType;
    DWORD cb = 0L;

    dwErr = RegQueryValueEx( hkey, pszValue, NULL, &dwType, NULL, &cb );
    return (dwErr == 0);
}


DWORD
SetCallbackList(
    IN HKEY     hkey,
    IN DTLLIST* pList )

    /* Sets callback tree under registry key 'hkey' to the list of callback
    ** nodes 'pList'.
    **
    ** Returns 0 if successful or an error code.
    */
{
    DWORD    dwErr;
    TCHAR    szDP[ RAS_MaxDeviceName + 2 + MAX_PORT_NAME + 1 + 1 ];
    DWORD    cb;
    DWORD    i;
    DWORD    dwDisposition;
    HKEY     hkeyCb;
    HKEY     hkeyDP;
    DTLNODE* pNode;

    dwErr = RegCreateKeyEx( hkey, REGKEY_Callback,
        0, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
        &hkeyCb, &dwDisposition );
    if (dwErr != 0)
        return dwErr;

    /* Delete all keys and values under the callback key.
    */
    for (;;)
    {
        cb = sizeof(szDP);
        dwErr = RegEnumKeyEx(
            hkeyCb, 0, szDP, &cb, NULL, NULL, NULL, NULL );
        if (dwErr != 0)
            break;

        dwErr = RegDeleteKey( hkeyCb, szDP );
        if (dwErr != 0)
            break;
    }

    if (dwErr == ERROR_NO_MORE_ITEMS)
        dwErr = 0;

    if (dwErr == 0)
    {
        /* Add the new device/port sub-trees.
        */
        for (pNode = DtlGetFirstNode( pList );
             pNode;
             pNode = DtlGetNextNode( pNode ))
        {
            CALLBACKINFO* pInfo;
            TCHAR*        psz;

            pInfo = (CALLBACKINFO* )DtlGetData( pNode );
            ASSERT(pInfo);
            ASSERT(pInfo->pszPortName);
            ASSERT(pInfo->pszDeviceName);
            ASSERT(pInfo->pszNumber);

            psz = PszFromDeviceAndPort(
                pInfo->pszDeviceName, pInfo->pszPortName );
            if (psz)
            {
                dwErr = RegCreateKeyEx( hkeyCb, psz, 0, TEXT(""),
                    REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkeyDP,
                    &dwDisposition );
                if (dwErr != 0)
                    break;

                dwErr = SetRegDword( hkeyDP, REGVAL_dwDeviceType,
                    pInfo->dwDeviceType );
                if (dwErr == 0)
                {
                    dwErr = SetRegSz( hkeyDP,
                        REGVAL_szNumber, pInfo->pszNumber );
                }

                RegCloseKey( hkeyDP );
            }
            else
                dwErr = ERROR_NOT_ENOUGH_MEMORY;

            if (dwErr != 0)
                break;
        }
    }

    RegCloseKey( hkeyCb );
    return dwErr;
}


DWORD
SetDefaultUserPreferences(
    OUT PBUSER* pUser,
    IN  DWORD   dwMode )

    /* Fill caller's 'pUser' buffer with default user preferences.  'DwMode'
    ** indicates the type of user preferences.
    **
    ** Returns 0 if successful, false otherwise.
    */
{
    DTLNODE* pNode;

    /* Set defaults.
    */
    CopyMemory( pUser, &g_pbuserDefaults, sizeof(*pUser) );
    pUser->pdtllistCallback = DtlCreateList( 0L );
    pUser->pdtllistPhonebooks = DtlCreateList( 0L );
    pUser->pdtllistAreaCodes = DtlCreateList( 0L );
    pUser->pdtllistPrefixes = DtlCreateList( 0L );
    pUser->pdtllistSuffixes = DtlCreateList( 0L );
    pUser->pdtllistLocations = DtlCreateList( 0L );

    if (!pUser->pdtllistCallback
        || !pUser->pdtllistPhonebooks
        || !pUser->pdtllistAreaCodes
        || !pUser->pdtllistPrefixes
        || !pUser->pdtllistSuffixes
        || !pUser->pdtllistLocations)
    {
        /* Can't even get empty lists, so we're forced to return an error.
        */
        DestroyUserPreferences( pUser );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    /* Add the default prefixes.
    */
    pNode = CreatePszNode( TEXT("0,") );
    if (pNode)
        DtlAddNodeLast( pUser->pdtllistPrefixes, pNode );
    pNode = CreatePszNode( TEXT("9,") );
    if (pNode)
        DtlAddNodeLast( pUser->pdtllistPrefixes, pNode );
    pNode = CreatePszNode( TEXT("8,") );
    if (pNode)
        DtlAddNodeLast( pUser->pdtllistPrefixes, pNode );
    pNode = CreatePszNode( TEXT("70#") );
    if (pNode)
        DtlAddNodeLast( pUser->pdtllistPrefixes, pNode );

    if (dwMode == UPM_Logon)
    {
        ASSERT(pUser->dwPhonebookMode!=PBM_Personal);
        pUser->fShowLights = FALSE;
        pUser->fSkipConnectComplete = TRUE;
    }

    if (dwMode == UPM_Router)
    {
        pUser->dwCallbackMode = CBM_No;
    }

    pUser->fInitialized = TRUE;
    return 0;
}


DWORD
SetLocationList(
    IN HKEY     hkey,
    IN DTLLIST* pList )

    /* Sets by-location tree under registry key 'hkey' to the list of
    ** by-location nodes 'pList'.
    **
    ** Returns 0 if successful or an error code.
    */
{
    DWORD    dwErr;
    TCHAR    szId[ MAXLTOTLEN + 1 ];
    DWORD    cb;
    DWORD    i;
    DWORD    dwDisposition;
    HKEY     hkeyL;
    HKEY     hkeyId;
    DTLNODE* pNode;

    dwErr = RegCreateKeyEx( hkey, REGKEY_Location,
        0, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
        &hkeyL, &dwDisposition );
    if (dwErr != 0)
        return dwErr;

    /* Delete all keys and values under the location key.
    */
    for (;;)
    {
        cb = MAXLTOTLEN + 1;
        dwErr = RegEnumKeyEx( hkeyL, 0, szId, &cb, NULL, NULL, NULL, NULL );
        if (dwErr != 0)
            break;

        dwErr = RegDeleteKey( hkeyL, szId );
        if (dwErr != 0)
            break;
    }

    if (dwErr == ERROR_NO_MORE_ITEMS)
        dwErr = 0;

    if (dwErr == 0)
    {
        /* Add the new ID sub-trees.
        */
        for (pNode = DtlGetFirstNode( pList );
             pNode;
             pNode = DtlGetNextNode( pNode ))
        {
            LOCATIONINFO* pInfo;

            pInfo = (LOCATIONINFO* )DtlGetData( pNode );
            ASSERT(pInfo);

            LToT( pInfo->dwLocationId, szId, 10 );

            dwErr = RegCreateKeyEx( hkeyL, szId, 0, TEXT(""),
                REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkeyId,
                &dwDisposition );
            if (dwErr != 0)
                break;

            dwErr = SetRegDword( hkeyId, REGVAL_dwPrefix, pInfo->iPrefix );
            if (dwErr == 0)
                dwErr = SetRegDword( hkeyId, REGVAL_dwSuffix, pInfo->iSuffix );

            RegCloseKey( hkeyId );

            if (dwErr != 0)
                break;
        }
    }

    RegCloseKey( hkeyL );
    return dwErr;
}


DWORD
SetRegDword(
    IN HKEY   hkey,
    IN TCHAR* pszName,
    IN DWORD  dwValue )

    /* Set registry value 'pszName' under key 'hkey' to REG_DWORD value
    ** 'dwValue'.
    **
    ** Returns 0 is successful or an error code.
    */
{
    return RegSetValueEx(
        hkey, pszName, 0, REG_DWORD, (LPBYTE )&dwValue, sizeof(dwValue) );
}


DWORD
SetRegMultiSz(
    IN HKEY     hkey,
    IN TCHAR*   pszName,
    IN DTLLIST* pListValues,
    IN DWORD    dwNodeType )

    /* Set registry value 'pszName' under key 'hkey' to a REG_MULTI_SZ value
    ** containing the strings in the Psz list 'pListValues'.  'DwNodeType'
    ** determines the type of node.
    **
    ** Returns 0 is successful or an error code.
    */
{
    DWORD    dwErr;
    DWORD    cb;
    DTLNODE* pNode;
    TCHAR*   pszzValues;
    TCHAR*   pszValue;

    /* Count up size of MULTI_SZ buffer needed.
    */
    cb = sizeof(TCHAR);
    for (pNode = DtlGetFirstNode( pListValues );
         pNode;
         pNode = DtlGetNextNode( pNode ))
    {
        if (dwNodeType == NT_Psz)
        {
            TCHAR* psz;
            psz = (TCHAR* )DtlGetData( pNode );
            ASSERT(psz);
            cb += (lstrlen( psz ) + 1) * sizeof(TCHAR);
        }
        else
        {
            KEYVALUE* pkv;

            ASSERT(dwNodeType==NT_Kv);
            pkv = (KEYVALUE* )DtlGetData( pNode );
            ASSERT(pkv);
            ASSERT(pkv->pszKey);
            ASSERT(pkv->pszValue);
            cb += (lstrlen( pkv->pszKey ) + 1
                      + 1 + lstrlen( pkv->pszValue ) + 1) * sizeof(TCHAR);
        }
    }

    if (cb == sizeof(TCHAR))
        cb += sizeof(TCHAR);

    /* Allocate MULTI_SZ buffer.
    */
    pszzValues = Malloc( cb );
    if (!pszzValues)
        return ERROR_NOT_ENOUGH_MEMORY;

    /* Fill MULTI_SZ buffer from list.
    */
    if (cb == 2 * sizeof(TCHAR))
    {
        pszzValues[ 0 ] = pszzValues[ 1 ] = TEXT('\0');
    }
    else
    {
        pszValue = pszzValues;
        for (pNode = DtlGetFirstNode( pListValues );
             pNode;
             pNode = DtlGetNextNode( pNode ))
        {
            if (dwNodeType == NT_Psz)
            {
                TCHAR* psz;

                psz = (TCHAR* )DtlGetData( pNode );
                ASSERT(psz);
                lstrcpy( pszValue, psz );
                pszValue += lstrlen( pszValue ) + 1;
            }
            else
            {
                KEYVALUE* pkv;

                pkv = (KEYVALUE* )DtlGetData( pNode );
                ASSERT(pkv);
                ASSERT(pkv->pszKey);
                ASSERT(pkv->pszValue);
                lstrcpy( pszValue, pkv->pszKey );
                pszValue += lstrlen( pszValue ) + 1;
                *pszValue = TEXT('=');
                ++pszValue;
                lstrcpy( pszValue, pkv->pszValue );
                pszValue += lstrlen( pszValue ) + 1;
            }
        }

        *pszValue = TEXT('\0');
    }

    /* Set registry value from MULTI_SZ buffer.
    */
    dwErr = RegSetValueEx(
        hkey, pszName, 0, REG_MULTI_SZ, (LPBYTE )pszzValues, cb );

    Free( pszzValues );
    return dwErr;
}


DWORD
SetRegSz(
    IN HKEY   hkey,
    IN TCHAR* pszName,
    IN TCHAR* pszValue )

    /* Set registry value 'pszName' under key 'hkey' to a REG_SZ value
    ** 'pszValue'.
    **
    ** Returns 0 is successful or an error code.
    */
{
    TCHAR* psz;

    if (pszValue)
        psz = pszValue;
    else
        psz = TEXT("");

    return
        RegSetValueEx(
            hkey, pszName, 0, REG_SZ,
            (LPBYTE )psz, (lstrlen( psz ) + 1) * sizeof(TCHAR) );
}


DWORD
SetRegSzz(
    IN HKEY   hkey,
    IN TCHAR* pszName,
    IN TCHAR* pszValue )

    /* Set registry value 'pszName' under key 'hkey' to a REG_MULTI_SZ value
    ** 'pszValue'.
    **
    ** Returns 0 is successful or an error code.
    */
{
    DWORD cb;
    TCHAR* psz;

    cb = sizeof(TCHAR);
    if (!pszValue) {
        psz = TEXT("");
    }
    else {

        /* compute the total size of the string-list in bytes
        */

        INT len;

        for (psz = pszValue; *psz; psz += len) {

            len = lstrlen(psz) + 1;

            cb += len * sizeof(TCHAR);
        }

        psz = pszValue;
    }

    return RegSetValueEx( hkey, pszName, 0, REG_MULTI_SZ, (LPBYTE )psz, cb );
}



DWORD
WriteUserPreferences(
    IN HKEY    hkey,
    IN PBUSER* pUser )

    /* Write user preferences 'pUser' at RAS-Phonebook registry key 'hkey'.
    **
    ** Returns 0 if successful or an error code.
    */
{
    DWORD dwErr;

    TRACE("WriteUserPreferences");

    do
    {
        dwErr = SetRegDword( hkey, REGVAL_fOperatorDial,
            pUser->fOperatorDial );
        if (dwErr != 0)
            break;

        dwErr = SetRegDword( hkey, REGVAL_fPreviewPhoneNumber,
            pUser->fPreviewPhoneNumber );
        if (dwErr != 0)
            break;

        dwErr = SetRegDword( hkey, REGVAL_fUseLocation,
            pUser->fUseLocation );
        if (dwErr != 0)
            break;

        dwErr = SetRegDword( hkey, REGVAL_fShowLights,
            pUser->fShowLights );
        if (dwErr != 0)
            break;

        dwErr = SetRegDword( hkey, REGVAL_fShowConnectStatus,
            pUser->fShowConnectStatus );
        if (dwErr != 0)
            break;

        dwErr = SetRegDword( hkey, REGVAL_fNewEntryWizard,
            pUser->fNewEntryWizard );
        if (dwErr != 0)
            break;

        dwErr = SetRegDword( hkey, REGVAL_fCloseOnDial,
            pUser->fCloseOnDial );
        if (dwErr != 0)
            break;

        dwErr = SetRegDword( hkey, REGVAL_fAllowLogonPhonebookEdits,
            pUser->fAllowLogonPhonebookEdits );
        if (dwErr != 0)
            break;

        dwErr = SetRegDword( hkey, REGVAL_fAllowLogonLocationEdits,
            pUser->fAllowLogonLocationEdits );
        if (dwErr != 0)
            break;

        dwErr = SetRegDword( hkey, REGVAL_fSkipConnectComplete,
            pUser->fSkipConnectComplete );
        if (dwErr != 0)
            break;

        dwErr = SetRegDword( hkey, REGVAL_dwRedialAttempts,
            pUser->dwRedialAttempts );
        if (dwErr != 0)
            break;

        dwErr = SetRegDword( hkey, REGVAL_dwRedialSeconds,
            pUser->dwRedialSeconds );
        if (dwErr != 0)
            break;

        dwErr = SetRegDword( hkey, REGVAL_dwIdleDisconnectSeconds,
            pUser->dwIdleDisconnectSeconds );
        if (dwErr != 0)
            break;

        dwErr = SetRegDword( hkey, REGVAL_fRedialOnLinkFailure,
            pUser->fRedialOnLinkFailure );
        if (dwErr != 0)
            break;

        dwErr = SetRegDword( hkey, REGVAL_fPopupOnTopWhenRedialing,
            pUser->fPopupOnTopWhenRedialing );
        if (dwErr != 0)
            break;

        dwErr = SetRegDword( hkey, REGVAL_fExpandAutoDialQuery,
            pUser->fExpandAutoDialQuery );
        if (dwErr != 0)
            break;

        dwErr = SetRegDword( hkey, REGVAL_dwCallbackMode,
            pUser->dwCallbackMode );
        if (dwErr != 0)
            break;

        dwErr = SetRegDword( hkey, REGVAL_dwPhonebookMode,
            pUser->dwPhonebookMode );
        if (dwErr != 0)
            break;

        dwErr = SetRegDword( hkey, REGVAL_fUseAreaAndCountry,
            pUser->fUseAreaAndCountry );
        if (dwErr != 0)
            break;

        dwErr = SetRegDword( hkey, REGVAL_dwXWindow,
            pUser->dwXPhonebook );
        if (dwErr != 0)
            break;

        dwErr = SetRegDword( hkey, REGVAL_dwYWindow,
            pUser->dwYPhonebook );

        dwErr = SetCallbackList( hkey, pUser->pdtllistCallback );
        if (dwErr != 0)
            break;

        dwErr = SetRegMultiSz( hkey, REGVAL_mszPhonebooks,
            pUser->pdtllistPhonebooks, NT_Psz );
        if (dwErr != 0)
            break;

        dwErr = SetRegMultiSz( hkey, REGVAL_mszAreaCodes,
            pUser->pdtllistAreaCodes, NT_Psz );
        if (dwErr != 0)
            break;

        dwErr = SetRegMultiSz( hkey, REGVAL_mszPrefixes,
            pUser->pdtllistPrefixes, NT_Psz );
        if (dwErr != 0)
            break;

        dwErr = SetRegMultiSz( hkey, REGVAL_mszSuffixes,
            pUser->pdtllistSuffixes, NT_Psz );
        if (dwErr != 0)
            break;

        dwErr = SetLocationList( hkey, pUser->pdtllistLocations );
        if (dwErr != 0)
            break;

        dwErr = SetRegSz( hkey, REGVAL_szLastCallbackByCaller,
            pUser->pszLastCallbackByCaller );
        if (dwErr != 0)
            break;

        dwErr = SetRegSz( hkey, REGVAL_szPersonalPhonebookFile,
            pUser->pszPersonalFile );
        if (dwErr != 0)
            break;

        dwErr = SetRegSz( hkey, REGVAL_szAlternatePhonebookPath,
            pUser->pszAlternatePath );
        if (dwErr != 0)
            break;

        dwErr = SetRegSz( hkey, REGVAL_szDefaultEntry,
            pUser->pszDefaultEntry );
        if (dwErr != 0)
            break;

        RegDeleteValue( hkey, REGVAL_szPersonalPhonebookPath );
    }
    while (FALSE);

    if (dwErr == 0)
        pUser->fDirty = FALSE;

    TRACE1("WriteUserPreferences=%d",dwErr);
    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\nt4\common\debug\debug.c ===
/* Copyright (c) 1995, Microsoft Corporation, all rights reserved
**
** debug.c
** Debug, trace, and assert library
**
** 08/25/95 Steve Cobb
*/


#include <windows.h> // Win32 root
#include <debug.h>   // Our public header


#if (DBG || FREETRACE)


/*----------------------------------------------------------------------------
** Globals
**----------------------------------------------------------------------------
*/

/* The debug trace ID of this module as returned by TraceRegisterExA.
*/
DWORD g_dwTraceId = (DWORD )-1;

/* RtUtil DLL tracing entrypoints loaded by DebugInit.  It is safe to assume
** these addresses are loaded if g_dwTraceId is not -1.
*/
TRACEREGISTEREXA    g_pTraceRegisterExA;
TRACEDEREGISTERA    g_pTraceDeregisterA;
TRACEDEREGISTEREXA  g_pTraceDeregisterExA;
TRACEPRINTFA        g_pTracePrintfA;
TRACEPRINTFEXA      g_pTracePrintfExA;
TRACEDUMPEXA        g_pTraceDumpExA;


/*----------------------------------------------------------------------------
** Routines
**----------------------------------------------------------------------------
*/

VOID
DebugInit(
    IN CHAR* pszModule )

    /* Initialize debug trace and assertion support.
    */
{
    HINSTANCE h;

    /* Load and register with the trace DLL.
    */
    if ((h = LoadLibrary( L"RTUTILS.DLL" ))
        && (g_pTraceRegisterExA = (TRACEREGISTEREXA )GetProcAddress(
               h, "TraceRegisterExA" ))
        && (g_pTraceDeregisterA = (TRACEDEREGISTERA )GetProcAddress(
               h, "TraceDeregisterA" ))
        && (g_pTraceDeregisterExA = (TRACEDEREGISTEREXA )GetProcAddress(
               h, "TraceDeregisterExA" ))
        && (g_pTracePrintfA = (TRACEPRINTFA )GetProcAddress(
               h, "TracePrintfA" ))
        && (g_pTracePrintfExA = (TRACEPRINTFEXA )GetProcAddress(
               h, "TracePrintfExA" ))
        && (g_pTraceDumpExA = (TRACEDUMPEXA )GetProcAddress(
               h, "TraceDumpExA" )))
    {
        /* Register with 0 giving user Registry control over output
        ** in HKLM\SYSTEM\CurrentControlSet\Services\Tracing\<your-module>
        */
        g_dwTraceId = g_pTraceRegisterExA( pszModule, 0 );
    }
}


VOID
DebugTerm(
    void )

    /* Terminate debug support.
    */
{
    /* De-register with the trace DLL.
    */
    if (g_dwTraceId != -1)
        g_pTraceDeregisterExA( g_dwTraceId, 4 );
}


VOID
Assert(
    IN const CHAR* pszExpression,
    IN const CHAR* pszFile,
    IN UINT        unLine )

    /* Assertion handler called from ASSERT macro with the expression that
    ** failed and the filename and line number where the problem occurred.
    */
{
    CHAR szBuf[ 512 ];

    wsprintfA(
        szBuf,
        "The assertion \"%s\" at line %d of file %s is false.",
        pszExpression, unLine, pszFile );

    MessageBoxA(
        NULL, szBuf, "Assertion Failure", MB_ICONEXCLAMATION + MB_OK );
}


VOID
TracePrintfW1(
    CHAR*  pszFormat,
    TCHAR* psz1 )

    /* Like TracePrintf but provides W->A argument conversion on the single
    ** string argument.  This is better than mixing TracePrinfA and
    ** TracePrintfW calls which causes viewing problems when the trace is sent
    ** to a file.
    */
{
#ifdef UNICODE

    CHAR  szBuf[ 512 ];
    DWORD cb;

    if (WideCharToMultiByte(
            CP_ACP, 0, psz1, -1, szBuf, 512, NULL, NULL ) <= 0)
    {
        TRACE("TraceW1 failed");
        return;
    }

    TRACE1( pszFormat, szBuf );

#else

    TRACE1( pszFormat, psz1 );

#endif
}


#endif // (DBG || FREETRACE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\nt4\common\nouiutil\noui.c ===
/* Copyright (c) 1995, Microsoft Corporation, all rights reserved
**
** noui.c
** Non-UI helper routines (no HWNDs required)
** Listed alphabetically
**
** 08/25/95 Steve Cobb
*/

#include <windows.h>  // Win32 root
#include <stdlib.h>   // for atol()
#include <nouiutil.h> // Our public header
#include <debug.h>    // Trace/Assert library



INT
ComparePszNode(
    IN DTLNODE* pNode1,
    IN DTLNODE* pNode2 )

    /* Callback for DtlMergeSort; takes two DTLNODE*'s whose data
    ** are assumed to be strings (TCHAR*), and compares the strings.
    **
    ** Return value is as defined for 'lstrcmpi'.
    */
{
    return lstrcmpi( (TCHAR *)DtlGetData(pNode1), (TCHAR *)DtlGetData(pNode2) );
}


DTLNODE*
CreateKvNode(
    IN TCHAR* pszKey,
    IN TCHAR* pszValue )

    /* Returns a KEYVALUE node containing a copy of 'pszKey' and 'pszValue' or
    ** NULL on error.  It is caller's responsibility to DestroyKvNode the
    ** returned node.
    */
{
    DTLNODE*  pNode;
    KEYVALUE* pkv;

    pNode = DtlCreateSizedNode( sizeof(KEYVALUE), 0L );
    if (!pNode)
        return NULL;

    pkv = (KEYVALUE* )DtlGetData( pNode );
    pkv->pszKey = StrDup( pszKey );
    pkv->pszValue = StrDup( pszValue );

    if (!pkv->pszKey || !pkv->pszValue)
    {
        Free0( pkv->pszValue );
        DestroyKvNode( pNode );
        return NULL;
    }

    return pNode;
}


DTLNODE*
CreatePszNode(
    IN TCHAR* psz )

    /* Returns a node containing a copy of 'psz' or NULL on error.  It is
    ** caller's responsibility to DestroyPszNode the returned node.
    */
{
    TCHAR*   pszData;
    DTLNODE* pNode;

    pszData = StrDup( psz );
    if (!pszData)
        return NULL;

    pNode = DtlCreateNode( pszData, 0L );
    if (!pNode)
    {
        Free( pszData );
        return NULL;
    }

    return pNode;
}


VOID
DestroyPszNode(
    IN DTLNODE* pdtlnode )

    /* Release memory associated with string (or any simple Malloc) node
    ** 'pdtlnode'.  See DtlDestroyList.
    */
{
    TCHAR* psz;

    ASSERT(pdtlnode);
    psz = (TCHAR* )DtlGetData( pdtlnode );
    ASSERT(psz);

    Free( psz );

    DtlDestroyNode( pdtlnode );
}


VOID
DestroyKvNode(
    IN DTLNODE* pdtlnode )

    /* Release memory associated with a KEYVALUE node 'pdtlnode'.  See
    ** DtlDestroyList.
    */
{
    KEYVALUE* pkv;

    ASSERT(pdtlnode);
    pkv = (KEYVALUE* )DtlGetData( pdtlnode );
    ASSERT(pkv);

    Free0( pkv->pszKey );
    Free0( pkv->pszValue );

    DtlDestroyNode( pdtlnode );
}


BOOL
DeviceAndPortFromPsz(
    IN  TCHAR*  pszDP,
    OUT TCHAR** ppszDevice,
    OUT TCHAR** ppszPort )

    /* Loads '*ppszDevice' and '*ppszPort' with the parsed out device and port
    ** names from 'pszDP', a display string created with PszFromDeviceAndPort.
    **
    ** Returns true if successful, false if 'pszDP' is not of the stated form.
    ** It is caller's responsibility to Free the returned '*ppszDevice' and
    ** '*ppszPort'.
    */
{
    TCHAR szDP[ RAS_MaxDeviceName + 2 + MAX_PORT_NAME + 1 + 1 ];
    INT   cb;

    *ppszDevice = NULL;
    *ppszPort = NULL;

    lstrcpy( szDP, pszDP );
    cb = lstrlen( szDP );

    if (cb > 0)
    {
        TCHAR* pch;

        pch = szDP + cb;
        pch = CharPrev( szDP, pch );

        while (pch != szDP)
        {
            if (*pch == TEXT(')'))
            {
                *pch = TEXT('\0');
            }
            else if (*pch == TEXT('('))
            {
                *ppszPort = StrDup( CharNext( pch ) );
                *pch = TEXT('\0');
                *ppszDevice = StrDup( szDP );
                break;
            }

            pch = CharPrev( szDP, pch );
        }
    }

    return (*ppszDevice && *ppszPort);
}



DTLNODE*
DuplicatePszNode(
    IN DTLNODE* pdtlnode )

    /* Duplicates string node 'pdtlnode'.  See DtlDuplicateList.
    **
    ** Returns the address of the allocated node or NULL if out of memory.  It
    ** is caller's responsibility to free the returned node.
    */
{
    DTLNODE* pNode;
    TCHAR*   psz;

    psz = (TCHAR* )DtlGetData( pdtlnode );
    ASSERT(psz);

    pNode = CreatePszNode( psz );
    if (pNode)
    {
        DtlPutNodeId( pNode, DtlGetNodeId( pdtlnode ) );
    }
    return pNode;
}


BOOL
FileExists(
    IN TCHAR* pszPath )

    /* Returns true if the path 'pszPath' exists, false otherwise.
    */
{
    WIN32_FIND_DATA finddata;
    HANDLE          h;

    if ((h = FindFirstFile( pszPath, &finddata )) != INVALID_HANDLE_VALUE)
    {
        FindClose( h );
        return TRUE;
    }

    return FALSE;
}


VOID*
Free0(
    VOID* p )

    /* Like Free, but deals with NULL 'p'.
    */
{
    if (!p)
        return NULL;

    return Free( p );
}


DWORD
GetInstalledProtocols(
    void )

    /* Returns a bit field containing NP_<protocol> flags for the installed
    ** PPP protocols.  The term "installed" here includes enabling in RAS
    ** Setup.
    */
{
#define REGKEY_Protocols   TEXT("SOFTWARE\\Microsoft\\RAS\\PROTOCOLS")
#define REGVAL_NbfSelected TEXT("fNetbeuiSelected")
#define REGVAL_IpSelected  TEXT("fTcpIpSelected")
#define REGVAL_IpxSelected TEXT("fIpxSelected")
#define REGKEY_Nbf TEXT("SYSTEM\\CurrentControlSet\\Services\\Nbf\\Linkage")
#define REGKEY_Ipx TEXT("SYSTEM\\CurrentControlSet\\Services\\NWLNKIPX\\Linkage")
#define REGKEY_Ip  TEXT("SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Linkage")

    DWORD dwfInstalledProtocols;
    HKEY  hkey;

    /* Find whether the specific stack is installed.
    */
    dwfInstalledProtocols = 0;

    if (RegOpenKey( HKEY_LOCAL_MACHINE, REGKEY_Nbf, &hkey ) == 0)
    {
        dwfInstalledProtocols |= NP_Nbf;
        RegCloseKey( hkey );
    }

    if (RegOpenKey( HKEY_LOCAL_MACHINE, REGKEY_Ipx, &hkey ) == 0)
    {
        dwfInstalledProtocols |= NP_Ipx;
        RegCloseKey( hkey );
    }

    if (RegOpenKey( HKEY_LOCAL_MACHINE, REGKEY_Ip, &hkey ) == 0)
    {
        dwfInstalledProtocols |= NP_Ip;
        RegCloseKey( hkey );
    }

    /* Make sure the installed stack is enabled for RAS.
    */
    if (RegOpenKey( HKEY_LOCAL_MACHINE, REGKEY_Protocols, &hkey ) == 0)
    {
        DWORD dwType;
        DWORD dwValue;
        DWORD cb = sizeof(DWORD);

        if (RegQueryValueEx(
                hkey, REGVAL_NbfSelected, NULL,
                &dwType, (LPBYTE )&dwValue, &cb ) == 0
            && dwType == REG_DWORD
            && dwValue == 0)
        {
            dwfInstalledProtocols &= ~(NP_Nbf);
        }

        if (RegQueryValueEx(
                hkey, REGVAL_IpxSelected, NULL,
                &dwType, (LPBYTE )&dwValue, &cb ) == 0
            && dwType == REG_DWORD
            && dwValue == 0)
        {
            dwfInstalledProtocols &= ~(NP_Ipx);
        }

        if (RegQueryValueEx(
                hkey, REGVAL_IpSelected, NULL,
                &dwType, (LPBYTE )&dwValue, &cb ) == 0
            && dwType == REG_DWORD
            && dwValue == 0)
        {
            dwfInstalledProtocols &= ~(NP_Ip);
        }

        RegCloseKey( hkey );
    }
    else
    {
        /* The RAS installation is messed up.
        */
        dwfInstalledProtocols = 0;
    }

    TRACE1("GetInstalledProtocols=$%x",dwfInstalledProtocols);
    return dwfInstalledProtocols;
}


CHAR
HexChar(
    IN BYTE byte )

    /* Returns an ASCII hexidecimal character corresponding to 0 to 15 value,
    ** 'byte'.
    */
{
    const CHAR* pszHexDigits = "0123456789ABCDEF";

    if (byte >= 0 && byte < 16)
        return pszHexDigits[ byte ];
    else
        return '0';
}


BYTE
HexValue(
    IN CHAR ch )

    /* Returns the value 0 to 15 of hexadecimal character 'ch'.
    */
{
    if (ch >= '0' && ch <= '9')
        return (BYTE )(ch - '0');
    else if (ch >= 'A' && ch <= 'F')
        return (BYTE )((ch - 'A') + 10);
    else if (ch >= 'a' && ch <= 'f')
        return (BYTE )((ch - 'a') + 10);
    else
        return 0;
}


BOOL
IsAllWhite(
    IN TCHAR* psz )

    /* Returns true if 'psz' consists entirely of spaces and tabs.  NULL
    ** pointers and empty strings are considered all white.  Otherwise,
    ** returns false.
    */
{
    TCHAR* pszThis;

    for (pszThis = psz; *pszThis != TEXT('\0'); ++pszThis)
    {
        if (*pszThis != TEXT(' ') && *pszThis != TEXT('\t'))
            return FALSE;
    }

    return TRUE;
}


#if 0
BOOL
IsNullTerminatedA(
    IN CHAR* psz,
    IN DWORD dwSize )

    /* Returns true is 'psz' contains a null character somewhere in it's
    ** 'dwSize' bytes, false otherwise.
    */
{
    CHAR* pszThis;
    CHAR* pszEnd;

    pszEnd = psz + dwSize;
    for (pszThis = psz; pszThis < pszEnd; ++pszThis)
    {
        if (*pszThis == '\0')
            return TRUE;
    }

    return FALSE;
}
#endif


TCHAR*
LToT(
    LONG   lValue,
    TCHAR* pszBuf,
    INT    nRadix )

    /* Like ltoa, but returns TCHAR*.
    */
{
#ifdef UNICODE
    WCHAR szBuf[ MAXLTOTLEN + 1 ];

    ASSERT(nRadix==10||nRadix==16);

    if (nRadix == 10)
        wsprintf( pszBuf, TEXT("%d"), lValue );
    else
        wsprintf( pszBuf, TEXT("%x"), lValue );
#else
    _ltoa( lValue, pszBuf, nRadix );
#endif

    return pszBuf;
}



LONG
TToL(
    TCHAR *pszBuf )

    /* Like atol, but accepts TCHAR*.
    */
{
    CHAR* psz;
    CHAR  szBuf[ MAXLTOTLEN + 1 ];

#ifdef UNICODE
    psz = szBuf;

    WideCharToMultiByte(
        CP_ACP, 0, pszBuf, -1, psz, MAXLTOTLEN + 1, NULL, NULL );
#else
    psz = pszBuf;
#endif

    return atol( psz );
}


TCHAR*
PszFromDeviceAndPort(
    IN TCHAR* pszDevice,
    IN TCHAR* pszPort )

    /* Returns address of heap block psz containing the MXS modem list display
    ** form, i.e. the device name 'pszDevice' followed by the port name
    ** 'pszPort'.  It's caller's responsibility to Free the returned string.
    */
{
    /* If you're thinking of changing this format string be aware that
    ** DeviceAndPortFromPsz parses it.
    */
    const TCHAR* pszF = TEXT("%s (%s)");

    TCHAR* pszResult;
    TCHAR* pszD;
    TCHAR* pszP;

    if (pszDevice)
        pszD = pszDevice;
    else
        pszD = TEXT("");

    if (pszPort)
        pszP = pszPort;
    else
        pszP = TEXT("");

    pszResult = Malloc(
        (lstrlen( pszD ) + lstrlen( pszP ) + lstrlen( pszF ))
            * sizeof(TCHAR) );

    if (pszResult)
        wsprintf( pszResult, pszF, pszD, pszP );

    return pszResult;
}


TCHAR*
PszFromId(
    IN HINSTANCE hInstance,
    IN DWORD     dwStringId )

    /* String resource message loader routine.
    **
    ** Returns the address of a heap block containing the string corresponding
    ** to string resource 'dwStringId' or NULL if error.  It is caller's
    ** responsibility to Free the returned string.
    */
{
    HRSRC  hrsrc;
    TCHAR* pszBuf;
    int    cchBuf = 256;
    int    cchGot;

    for (;;)
    {
        pszBuf = Malloc( cchBuf * sizeof(TCHAR) );
        if (!pszBuf)
            break;

        /* LoadString wants to deal with character-counts rather than
        ** byte-counts...weird.  Oh, and if you're thinking I could
        ** FindResource then SizeofResource to figure out the string size, be
        ** advised it doesn't work.  From perusing the LoadString source, it
        ** appears the RT_STRING resource type requests a segment of 16
        ** strings not an individual string.
        */
        cchGot = LoadString( hInstance, (UINT )dwStringId, pszBuf, cchBuf );

        if (cchGot < cchBuf - 1)
        {
            /* Good, got the whole string.  Reduce heap block to actual size
            ** needed.
            */
            pszBuf = Realloc( pszBuf, (cchGot + 1) * sizeof(TCHAR) );
            ASSERT(pszBuf);
            break;
        }

        /* Uh oh, LoadStringW filled the buffer entirely which could mean the
        ** string was truncated.  Try again with a larger buffer to be sure it
        ** wasn't.
        */
        Free( pszBuf );
        cchBuf += 256;
        TRACE1("Grow string buf to %d",cchBuf);
    }

    return pszBuf;
}


#if 0
TCHAR*
PszFromError(
    IN DWORD dwError )

    /* Error message loader routine.
    **
    ** Returns the address of a heap block containing the error string
    ** corresponding to RAS or system error code 'dwMsgid' or NULL if error.
    ** It is caller's responsibility to Free the returned string.
    */
{
    return NULL;
}
#endif


BOOL
RestartComputer()

    /* Called if user chooses to shut down the computer.
    **
    ** Return false if failure, true otherwise
    */
{
   HANDLE            hToken;              /* handle to process token */
   TOKEN_PRIVILEGES  tkp;                 /* ptr. to token structure */
   BOOL              fResult;             /* system shutdown flag */

   TRACE("RestartComputer");

   /* Enable the shutdown privilege */

   if (!OpenProcessToken( GetCurrentProcess(),
                          TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                          &hToken))
      return FALSE;

   /* Get the LUID for shutdown privilege. */

   LookupPrivilegeValue(NULL, SE_SHUTDOWN_NAME, &tkp.Privileges[0].Luid);

   tkp.PrivilegeCount = 1;  /* one privilege to set    */
   tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

   /* Get shutdown privilege for this process. */

   AdjustTokenPrivileges(hToken, FALSE, &tkp, 0, (PTOKEN_PRIVILEGES) NULL, 0);

   /* Cannot test the return value of AdjustTokenPrivileges. */

   if (GetLastError() != ERROR_SUCCESS)
      return FALSE;

   if( !ExitWindowsEx(EWX_REBOOT, 0))
      return FALSE;

   /* Disable shutdown privilege. */

   tkp.Privileges[0].Attributes = 0;
   AdjustTokenPrivileges(hToken, FALSE, &tkp, 0, (PTOKEN_PRIVILEGES) NULL, 0);

   if (GetLastError() != ERROR_SUCCESS)
      return FALSE;

   return TRUE;
}


DWORD
ShellSort(
    IN VOID*        pItemTable,
    IN DWORD        dwItemSize,
    IN DWORD        dwItemCount,
    IN PFNCOMPARE   pfnCompare )

    /* Sort an array of items in-place using shell-sort.
    ** This function calls ShellSortIndirect to sort a table of pointers
    ** to table items. We then move the items into place by copying.
    ** This algorithm allows us to guarantee that the number
    ** of copies necessary in the worst case is N + 1.
    **
    ** Note that if the caller merely needs to know the sorted order
    ** of the array, ShellSortIndirect should be called since that function
    ** avoids moving items altogether, and instead fills an array with pointers
    ** to the array items in the correct order. The array items can then
    ** be accessed through the array of pointers.
    */
{

    VOID** ppItemTable;

    INT N;
    INT i;
    BYTE *a, **p, *t = NULL;

    if (!dwItemCount) { return NO_ERROR; }


    /* allocate space for the table of pointers.
    */
    ppItemTable = Malloc(dwItemCount * sizeof(VOID*));
    if (!ppItemTable) { return ERROR_NOT_ENOUGH_MEMORY; }


    /* call ShellSortIndirect to fill our table of pointers
    ** with the sorted positions for each table element.
    */
    ShellSortIndirect(
        pItemTable, ppItemTable, dwItemSize, dwItemCount, pfnCompare );


    /* now that we know the sort order, move each table item into place.
    ** This involves going through the table of pointers making sure
    ** that the item which should be in 'i' is in fact in 'i', moving
    ** things around if necessary to achieve this condition.
    */

    a = (BYTE*)pItemTable;
    p = (BYTE**)ppItemTable;
    N = (INT)dwItemCount;

    for (i = 0; i < N; i++)
    {
        INT j, k;
        BYTE* ai =  (a + i * dwItemSize), *ak, *aj;

        /* see if item 'i' is not in-place
        */
        if (p[i] != ai)
        {


            /* item 'i' isn't in-place, so we'll have to move it.
            ** if we've delayed allocating a temporary buffer so far,
            ** we'll need one now.
            */

            if (!t) {
                t = Malloc(dwItemSize);
                if (!t) { return ERROR_NOT_ENOUGH_MEMORY; }
            }

            /* save a copy of the item to be overwritten
            */
            CopyMemory(t, ai, dwItemSize);

            k = i;
            ak = ai;


            /* Now move whatever item is occupying the space where it should be.
            ** This may involve moving the item occupying the space where 
            ** it should be, etc.
            */

            do
            {

                /* copy the item which should be in position 'j'
                ** over the item which is currently in position 'j'.
                */
                j = k;
                aj = ak;
                CopyMemory(aj, p[j], dwItemSize);

                /* set 'k' to the position from which we copied
                ** into position 'j'; this is where we will copy
                ** the next out-of-place item in the array.
                */
                ak = p[j];
                k = (INT) ((ak - a) / dwItemSize);

                /* keep the array of position pointers up-to-date;
                ** the contents of 'aj' are now in their sorted position.
                */
                p[j] = aj;

            } while (ak != ai);


            /* now write the item which we first overwrote.
            */
            CopyMemory(aj, t, dwItemSize);
        }
    }

    Free0(t);
    Free(ppItemTable);

    return NO_ERROR;
}


VOID
ShellSortIndirect(
    IN VOID*        pItemTable,
    IN VOID**       ppItemTable,
    IN DWORD        dwItemSize,
    IN DWORD        dwItemCount,
    IN PFNCOMPARE   pfnCompare )

    /* Sorts an array of items indirectly using shell-sort.
    ** 'pItemTable' points to the table of items, 'dwItemCount' is the number
    ** of items in the table,  and 'pfnCompare' is a function called
    ** to compare items.
    **
    ** Rather than sort the items by moving them around,
    ** we sort them by initializing the table of pointers 'ppItemTable'
    ** with pointers such that 'ppItemTable[i]' contains a pointer
    ** into 'pItemTable' for the item which would be in position 'i'
    ** if 'pItemTable' were sorted.
    **
    ** For instance, given an array pItemTable of 5 strings as follows
    **
    **      pItemTable[0]:      "xyz"
    **      pItemTable[1]:      "abc"
    **      pItemTable[2]:      "mno"
    **      pItemTable[3]:      "qrs"
    **      pItemTable[4]:      "def"
    **
    ** on output ppItemTable contains the following pointers
    **
    **      ppItemTable[0]:     &pItemTable[1]  ("abc")
    **      ppItemTable[1]:     &pItemTable[4]  ("def")
    **      ppItemTable[2]:     &pItemTable[2]  ("mno")
    **      ppItemTable[3]:     &pItemTable[3]  ("qrs")
    **      ppItemTable[4]:     &pItemTable[0]  ("xyz")
    **
    ** and the contents of pItemTable are untouched.
    ** And the caller can print out the array in sorted order using
    **      for (i = 0; i < 4; i++) {
    **          printf("%s\n", (char *)*ppItemTable[i]);
    **      }
    */
{

    /* The following algorithm is derived from Sedgewick's Shellsort,
    ** as given in "Algorithms in C++".
    **
    ** The Shellsort algorithm sorts the table by viewing it as
    ** a number of interleaved arrays, each of whose elements are 'h'
    ** spaces apart for some 'h'. Each array is sorted separately,
    ** starting with the array whose elements are farthest apart and
    ** ending with the array whose elements are closest together.
    ** Since the 'last' such array always has elements next to each other,
    ** this degenerates to Insertion sort, but by the time we get down
    ** to the 'last' array, the table is pretty much sorted.
    **
    ** The sequence of values chosen below for 'h' is 1, 4, 13, 40, 121, ...
    ** and the worst-case running time for the sequence is N^(3/2), where
    ** the running time is measured in number of comparisons.
    */

#define PFNSHELLCMP(a,b) (++Ncmp, pfnCompare((a),(b)))

    DWORD dwErr;
    INT i, j, h, N, Ncmp;
    BYTE* a, *v, **p;


    a = (BYTE*)pItemTable;
    p = (BYTE**)ppItemTable;
    N = (INT)dwItemCount;
    Ncmp = 0;

    TRACE1("ShellSortIndirect: N=%d", N);

    /* Initialize the table of position pointers.
    */
    for (i = 0; i < N; i++) { p[i] = (a + i * dwItemSize); }


    /* Move 'h' to the largest increment in our series
    */
    for (h = 1; h < N/9; h = 3 * h + 1) { }


    /* For each increment in our series, sort the 'array' for that increment
    */
    for ( ; h > 0; h /= 3)
    {

        /* For each element in the 'array', get the pointer to its
        ** sorted position.
        */
        for (i = h; i < N; i++)
        {
            /* save the pointer to be inserted
            */
            v = p[i]; j = i;

            /* Move all the larger elements to the right
            */
            while (j >= h && PFNSHELLCMP(p[j - h], v) > 0)
            {
                p[j] = p[j - h]; j -= h;
            }

            /* put the saved pointer in the position where we stopped.
            */
            p[j] = v;
        }
    }

    TRACE1("ShellSortIndirect: Ncmp=%d", Ncmp);

#undef PFNSHELLCMP

}


TCHAR*
StrDup(
    TCHAR* psz )

    /* Returns heap block containing a copy of 0-terminated string 'psz' or
    ** NULL on error or is 'psz' is NULL.  It is caller's responsibility to
    ** 'Free' the returned string.
    */
{
    TCHAR* pszNew = NULL;

    if (psz)
    {
        pszNew = Malloc( (lstrlen( psz ) + 1) * sizeof(TCHAR) );
        if (!pszNew)
        {
            TRACE("StrDup Malloc failed");
            return NULL;
        }

        lstrcpy( pszNew, psz );
    }

    return pszNew;
}


CHAR*
StrDupAFromT(
    TCHAR* psz )

    /* Returns heap block containing a copy of 0-terminated string 'psz' or
    ** NULL on error or is 'psz' is NULL.  The output string is converted to
    ** MB ANSI.  It is caller's responsibility to 'Free' the returned string.
    */
{
#ifdef UNICODE

    CHAR* pszNew = NULL;

    if (psz)
    {
        DWORD cb;

        cb = WideCharToMultiByte( CP_ACP, 0, psz, -1, NULL, 0, NULL, NULL );
        ASSERT(cb);

        pszNew = (CHAR* )Malloc( cb );
        if (!pszNew)
        {
            TRACE("StrDupAFromT Malloc failed");
            return NULL;
        }

        cb = WideCharToMultiByte( CP_ACP, 0, psz, -1, pszNew, cb, NULL, NULL );
        if (cb == 0)
        {
            Free( pszNew );
            TRACE("StrDupAFromT conversion failed");
            return NULL;
        }
    }

    return pszNew;

#else // !UNICODE

    return StrDup( psz );

#endif
}


TCHAR*
StrDupTFromA(
    CHAR* psz )

    /* Returns heap block containing a copy of 0-terminated string 'psz' or
    ** NULL on error or is 'psz' is NULL.  The output string is converted to
    ** UNICODE.  It is caller's responsibility to Free the returned string.
    */
{
#ifdef UNICODE

    return StrDupWFromA( psz );

#else // !UNICODE

    return StrDup( psz );

#endif
}


TCHAR*
StrDupTFromW(
    WCHAR* psz )

    /* Returns heap block containing a copy of 0-terminated string 'psz' or
    ** NULL on error or is 'psz' is NULL.  The output string is converted to
    ** UNICODE.  It is caller's responsibility to Free the returned string.
    */
{
#ifdef UNICODE

    return StrDup( psz );

#else // !UNICODE

    CHAR* pszNew = NULL;

    if (psz)
    {
        DWORD cb;

        cb = WideCharToMultiByte( CP_ACP, 0, psz, -1, NULL, 0, NULL, NULL );
        ASSERT(cb);

        pszNew = (CHAR* )Malloc( cb );
        if (!pszNew)
        {
            TRACE("StrDupTFromW Malloc failed");
            return NULL;
        }

        cb = WideCharToMultiByte( CP_ACP, 0, psz, -1, pszNew, cb, NULL, NULL );
        if (cb == 0)
        {
            Free( pszNew );
            TRACE("StrDupTFromW conversion failed");
            return NULL;
        }
    }

    return pszNew;

#endif
}


WCHAR*
StrDupWFromA(
    CHAR* psz )

    /* Returns heap block containing a copy of 0-terminated string 'psz' or
    ** NULL on error or if 'psz' is NULL.  The output string is converted to
    ** UNICODE.  It is caller's responsibility to Free the returned string.
    */
{
    WCHAR* pszNew = NULL;

    if (psz)
    {
        DWORD cb;

        cb = MultiByteToWideChar( CP_ACP, 0, psz, -1, NULL, 0 );
        ASSERT(cb);

        pszNew = Malloc( cb * sizeof(TCHAR) );
        if (!pszNew)
        {
            TRACE("StrDupWFromA Malloc failed");
            return NULL;
        }

        cb = MultiByteToWideChar( CP_ACP, 0, psz, -1, pszNew, cb );
        if (cb == 0)
        {
            Free( pszNew );
            TRACE("StrDupWFromA conversion failed");
            return NULL;
        }
    }

    return pszNew;
}


WCHAR*
StrDupWFromT(
    TCHAR* psz )

    /* Returns heap block containing a copy of 0-terminated string 'psz' or
    ** NULL on error or if 'psz' is NULL.  The output string is converted to
    ** UNICODE.  It is caller's responsibility to Free the returned string.
    */
{
#ifdef UNICODE

    return StrDup( psz );

#else // !UNICODE

    WCHAR* pszNew = NULL;

    if (psz)
    {
        DWORD cb;

        cb = MultiByteToWideChar( CP_ACP, 0, psz, -1, NULL, 0 );
        ASSERT(cb);

        pszNew = Malloc( cb * sizeof(TCHAR) );
        if (!pszNew)
        {
            TRACE("StrDupWFromT Malloc failed");
            return NULL;
        }

        cb = MultiByteToWideChar( CP_ACP, 0, psz, -1, pszNew, cb );
        if (cb == 0)
        {
            Free( pszNew );
            TRACE("StrDupWFromT conversion failed");
            return NULL;
        }
    }

    return pszNew;
#endif
}


TCHAR*
StripPath(
    IN TCHAR* pszPath )

    /* Returns a pointer to the file name within 'pszPath'.
    */
{
    TCHAR* p;

    p = pszPath + lstrlen( pszPath );

    while (p > pszPath)
    {
        if (*p == TEXT('\\') || *p == TEXT('/') || *p == TEXT(':'))
        {
            p = CharNext( p );
            break;
        }

        p = CharPrev( pszPath, p );
    }

    return p;
}


int
StrNCmpA(
    IN CHAR* psz1,
    IN CHAR* psz2,
    IN INT   nLen )

    /* Like strncmp, which is not in Win32 for some reason.
    */
{
    INT i;

    for (i= 0; i < nLen; ++i)
    {
        if (*psz1 == *psz2)
        {
            if (*psz1 == '\0')
                return 0;
        }
        else if (*psz1 < *psz2)
            return -1;
        else
            return 1;

        ++psz1;
        ++psz2;
    }

    return 0;
}


CHAR*
StrStrA(
    IN CHAR* psz1,
    IN CHAR* psz2 )

    /* Like strstr, which is not in Win32.
    */
{
    CHAR* psz;
    INT   nLen2;

    if (!psz1 || !psz2 || !*psz1 || !*psz2)
        return NULL;

    nLen2 = lstrlenA( psz2 );

    for (psz = psz1;
         *psz && StrNCmpA( psz, psz2, nLen2 ) != 0;
         ++psz);

    if (*psz)
        return psz;
    else
        return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\nt4\common\nouiutil\dtl.c ===
/* Copyright (c) 1992, Microsoft Corporation, all rights reserved
**
** dtl.c
** Double-threaded linked list manipulation core routines
** Listed alphabetically
**
** 06/28/92 Steve Cobb
*/


#include <windows.h>   // Win32 root
#include <nouiutil.h>  // Heap definitions
#include <dtl.h>       // Our public header
#include <debug.h>     // debug macros

DTLNODE*
DtlMoveToTail(
    IN  DTLLIST*    pdtllist,
    IN  DTLNODE*    pdtlnode
    );


DTLNODE*
DtlAddNodeAfter(
    IN OUT DTLLIST* pdtllist,
    IN OUT DTLNODE* pdtlnodeInList,
    IN OUT DTLNODE* pdtlnode )

    /* Adds node 'pdtlnode' to list 'pdtllist' after node 'pdtlnodeInList'.
    ** If 'pdtlnodeInList' is NULL, 'pdtlnode' is added at the end of the
    ** list.
    **
    ** Returns the address of the added node, i.e. 'pdtlnode'.
    */
{
    if (!pdtlnodeInList || !pdtlnodeInList->pdtlnodeNext)
        return DtlAddNodeLast( pdtllist, pdtlnode );

    pdtlnode->pdtlnodePrev = pdtlnodeInList;
    pdtlnode->pdtlnodeNext = pdtlnodeInList->pdtlnodeNext;

    pdtlnodeInList->pdtlnodeNext->pdtlnodePrev = pdtlnode;
    pdtlnodeInList->pdtlnodeNext = pdtlnode;

    ++pdtllist->lNodes;
    return pdtlnode;
}


DTLNODE*
DtlAddNodeBefore(
    IN OUT DTLLIST* pdtllist,
    IN OUT DTLNODE* pdtlnodeInList,
    IN OUT DTLNODE* pdtlnode )

    /* Adds node 'pdtlnode' to list 'pdtllist' before node 'pdtlnodeInList'.
    ** If 'pdtlnodeInList' is NULL, 'pdtlnode' is added at the beginning of
    ** the list.
    **
    ** Returns the address of the added node, i.e. 'pdtlnode'.
    */
{
    if (!pdtlnodeInList || !pdtlnodeInList->pdtlnodePrev)
        return DtlAddNodeFirst( pdtllist, pdtlnode );

    pdtlnode->pdtlnodePrev = pdtlnodeInList->pdtlnodePrev;
    pdtlnode->pdtlnodeNext = pdtlnodeInList;

    pdtlnodeInList->pdtlnodePrev->pdtlnodeNext = pdtlnode;
    pdtlnodeInList->pdtlnodePrev = pdtlnode;

    ++pdtllist->lNodes;
    return pdtlnode;
}


DTLNODE*
DtlAddNodeFirst(
    IN OUT DTLLIST* pdtllist,
    IN OUT DTLNODE* pdtlnode )

    /* Adds node 'pdtlnode' at the beginning of list 'pdtllist'.
    **
    ** Returns the address of the added node, i.e. 'pdtlnode'.
    */
{
    if (pdtllist->lNodes)
    {
        pdtllist->pdtlnodeFirst->pdtlnodePrev = pdtlnode;
        pdtlnode->pdtlnodeNext = pdtllist->pdtlnodeFirst;
    }
    else
    {
        pdtllist->pdtlnodeLast = pdtlnode;
        pdtlnode->pdtlnodeNext = NULL;
    }

    pdtlnode->pdtlnodePrev = NULL;
    pdtllist->pdtlnodeFirst = pdtlnode;

    ++pdtllist->lNodes;
    return pdtlnode;
}


DTLNODE*
DtlAddNodeLast(
    IN OUT DTLLIST* pdtllist,
    IN OUT DTLNODE* pdtlnode )

    /* Adds 'pdtlnode' at the end of list 'pdtllist'.
    **
    ** Returns the address of the added node, i.e. 'pdtlnode'.
    */
{
    if (pdtllist->lNodes)
    {
        pdtlnode->pdtlnodePrev = pdtllist->pdtlnodeLast;
        pdtllist->pdtlnodeLast->pdtlnodeNext = pdtlnode;
    }
    else
    {
        pdtlnode->pdtlnodePrev = NULL;
        pdtllist->pdtlnodeFirst = pdtlnode;
    }

    pdtllist->pdtlnodeLast = pdtlnode;
    pdtlnode->pdtlnodeNext = NULL;

    ++pdtllist->lNodes;
    return pdtlnode;
}


DTLLIST*
DtlCreateList(
    IN LONG lListId )

    /* Allocates a list and initializes it to empty.  The list is marked with
    ** the user-defined list identification code 'lListId'.
    **
    ** Returns the address of the list control block or NULL if out of memory.
    */
{
    DTLLIST* pdtllist = Malloc( sizeof(DTLLIST) );

    if (pdtllist)
    {
        pdtllist->pdtlnodeFirst = NULL;
        pdtllist->pdtlnodeLast = NULL;
        pdtllist->lNodes = 0;
        pdtllist->lListId = lListId;
    }

    return pdtllist;
}


DTLNODE*
DtlCreateNode(
    IN VOID* pData,
    IN LONG  lNodeId )

    /* Allocates an unsized node and initializes it to contain the address of
    ** the user data block 'pData' and the user-defined node identification
    ** code 'lNodeId'.
    **
    ** Returns the address of the new node or NULL if out of memory.
    */
{
    DTLNODE* pdtlnode = DtlCreateSizedNode( 0, lNodeId );

    if (pdtlnode)
        DtlPutData( pdtlnode, pData );

    return pdtlnode;
}


DTLNODE*
DtlCreateSizedNode(
    IN LONG lDataBytes,
    IN LONG lNodeId )

    /* Allocates a sized node with space for 'lDataBytes' bytes of user data
    ** built-in.  The node is initialized to contain the address of the
    ** built-in user data block (or NULL if of zero length) and the
    ** user-defined node identification code 'lNodeId'.  The user data block
    ** is zeroed.
    **
    ** Returns the address of the new node or NULL if out of memory.
    */
{
    DTLNODE* pdtlnode = Malloc( sizeof(DTLNODE) + lDataBytes );

    if (pdtlnode)
    {
        ZeroMemory( pdtlnode, sizeof(DTLNODE) + lDataBytes );

        if (lDataBytes)
            pdtlnode->pData = pdtlnode + 1;

        pdtlnode->lNodeId = lNodeId;
    }

    return pdtlnode;
}


DTLNODE*
DtlDeleteNode(
    IN OUT DTLLIST* pdtllist,
    IN OUT DTLNODE* pdtlnode )

    /* Destroys node 'pdtlnode' after removing it from list 'pdtllist'.
    **
    ** Returns the address of the node after the deleted node in 'pdtllist' or
    ** NULL if none.
    */
{
    DTLNODE* pdtlnodeNext = pdtlnode->pdtlnodeNext;

    DtlRemoveNode( pdtllist, pdtlnode );
    DtlDestroyNode( pdtlnode );

    return pdtlnodeNext;
}


VOID
DtlDestroyList(
    IN OUT DTLLIST*     pdtllist,
    IN     PDESTROYNODE pfuncDestroyNode )

    /* Deallocates all nodes in list 'pdtllist' using the node deallocation
    ** function 'pfuncDestroyNode' if non-NULL or DtlDestroyNode otherwise.
    ** Won't GP-fault if passed a NULL list, e.g. if 'pdtllist', was never
    ** allocated.
    */
{
    if (pdtllist)
    {
        DTLNODE* pdtlnode;

        while (pdtlnode = DtlGetFirstNode( pdtllist ))
        {
            DtlRemoveNode( pdtllist, pdtlnode );
            if (pfuncDestroyNode)
                pfuncDestroyNode( pdtlnode );
            else
                DtlDestroyNode( pdtlnode );
        }

        Free( pdtllist );
    }
}


VOID
DtlDestroyNode(
    IN OUT DTLNODE* pdtlnode )

    /* Deallocates node 'pdtlnode'.  It is the caller's responsibility to free
    ** the entry in an unsized node, if necessary.
    */
{
    Free( pdtlnode );
}


DTLLIST*
DtlDuplicateList(
    IN DTLLIST*     pdtllist,
    IN PDUPNODE     pfuncDupNode,
    IN PDESTROYNODE pfuncDestroyNode )

    /* Duplicates a list 'pdtllist' using 'pfuncDupNode' to duplicate the
    ** individual nodes.  'PfuncDestroyNode' is used for clean-up before
    ** returning an error.
    **
    ** Returns the address of the new list or NULL if out of memory.  It is
    ** caller's responsibility to free the returned list.
    */
{
    DTLNODE* pdtlnode;
    DTLLIST* pdtllistDup = DtlCreateList( 0 );

    if (!pdtllistDup)
        return NULL;

    for (pdtlnode = DtlGetFirstNode( pdtllist );
         pdtlnode;
         pdtlnode = DtlGetNextNode( pdtlnode ))
    {
        DTLNODE* pdtlnodeDup;

        pdtlnodeDup = pfuncDupNode( pdtlnode );
        if (!pdtlnodeDup)
        {
            DtlDestroyList( pdtllist, pfuncDestroyNode );
            break;
        }

        DtlAddNodeLast( pdtllistDup, pdtlnodeDup );
    }

    return pdtllistDup;
}


DTLNODE*
DtlNodeFromIndex(
    IN DTLLIST* pdtllist,
    IN LONG     lToFind )

    /* Returns the node associated with 0-based index 'lToFind' in the linked
    ** list of nodes, 'pdtllist', or NULL if not found.
    */
{
    DTLNODE* pdtlnode;

    if (!pdtllist || lToFind < 0)
        return NULL;

    pdtlnode = DtlGetFirstNode( pdtllist );
    while (pdtlnode && lToFind--)
        pdtlnode = DtlGetNextNode( pdtlnode );

    return pdtlnode;
}



VOID
DtlMergeSort(
    IN  DTLLIST*        pdtllist,
    IN  PCOMPARENODE    pfnCompare )

    /* Sorts the list 'pdtllist' in-place using merge-sort.
    ** The comparison-function 'pfnCompare' is passed 'DTLNODE' pointers
    ** when entries in the list need to be compared.
    **
    ** This implementation is a bottom-up iterative merge-sort.
    ** The list is sorted by merging adjacent pairs of lists of length i
    ** where i starts as 1 and doubles on each iteration.
    ** Thus for the list (3 1 4 1 5 9 2 6), the following pairs of sublists
    ** are merged, with the intermediate results on the right:
    **
    **  (3)-(1), (4)-(1), (5)-(9), (2)-(6)  ==>     (1 3 1 4 5 9 2 6)
    **
    **  (1 3)-(1 4), (5 9)-(2 6)            ==>     (1 1 3 4 2 5 6 9)
    **
    **  (1 1 3 4)-(2 5 6 9)                 ==>     (1 1 2 3 4 5 6 9)
    **
    ** Mergesort is a stable sort (i.e. the order of equal items is preserved)
    ** and it never does more than N lg N comparisons.
    */
{

    DTLNODE* a, *b;
    INT N, Ncmp = 0, Nsub;

    N = DtlGetNodes(pdtllist);

    TRACE1("DtlMergeSort: N=%d", N);


    //
    // sort and merge all adjacent sublists of length 'Nsub',
    // where 'Nsub' goes from 1 to N^lg('N'), by doubling on each iteration
    //

    for (Nsub = 1; Nsub < N; Nsub *= 2) {

        INT Nremnant;
        INT aLength, bLength;


        //
        // get the head of the first (left) sublist
        //

        a = DtlGetFirstNode(pdtllist);

        //
        // as long as there is a right sublist, sort
        //

        for (Nremnant = N; Nremnant > 0; Nremnant -= Nsub * 2) {

            //
            // get the head of the right sublist;
            // it's just the tail of the left sublist
            //

            INT i, an, bn;

            aLength = min(Nremnant, Nsub);

            for (i = aLength, b = a; i; i--, b = DtlGetNextNode(b)) { }


            //
            // compute the length of the right sublist;
            // in the case where there is no right sublist
            // set the length to zero and the loop below just moves
            // the left sublist
            //

            bLength = min(Nremnant - Nsub, Nsub);

            if (bLength < 0) { bLength = 0; }


            //
            // now merge the left and right sublists in-place;
            // we merge by building a sorted list at the tail of
            // the unsorted list
            //

            an = aLength; bn = bLength;

            //
            // as long as both sublists are non-empty, merge them
            // by moving the entry with the smallest key to the tail.
            //

            while (an && bn) {

                ++Ncmp;

                if (pfnCompare(a, b) <= 0) {
                    a = DtlMoveToTail(pdtllist, a); --an;
                }
                else {
                    b = DtlMoveToTail(pdtllist, b); --bn;
                }
            }


            //
            // one of the sublists is empty; move all the entries
            // in the other sublist to the end of our sorted list
            //

            if (an) do { a = DtlMoveToTail(pdtllist, a); } while(--an);
            else
            if (bn) do { b = DtlMoveToTail(pdtllist, b); } while(--bn);


            //
            // 'b' now points to the end of the right sublist,
            // meaning that the item after 'b' is the one which will be
            // the head of the left sublist on our next iteration;
            // we therefore update 'a' here
            //

            a = b;
        }
    }
    
    TRACE1("DtlMergeSort: Ncmp=%d", Ncmp);
}


DTLNODE*
DtlMoveToTail(
    IN  DTLLIST*    pdtllist,
    IN  DTLNODE*    pdtlnode
    )

    /* Moves a DTLNODE to the end of a list;
    ** Takes the list and the node to be moved, and returns the next node.
    */
{
    DTLNODE* pdtltemp = DtlGetNextNode(pdtlnode);

    DtlRemoveNode(pdtllist, pdtlnode);

    DtlAddNodeLast(pdtllist, pdtlnode);

    return pdtltemp;
}


DTLNODE*
DtlRemoveNode(
    IN OUT DTLLIST* pdtllist,
    IN OUT DTLNODE* pdtlnodeInList )

    /* Removes node 'pdtlnodeInList' from list 'pdtllist'.
    **
    ** Returns the address of the removed node, i.e. 'pdtlnodeInList'.
    */
{
    if (pdtlnodeInList->pdtlnodePrev)
        pdtlnodeInList->pdtlnodePrev->pdtlnodeNext = pdtlnodeInList->pdtlnodeNext;
    else
        pdtllist->pdtlnodeFirst = pdtlnodeInList->pdtlnodeNext;

    if (pdtlnodeInList->pdtlnodeNext)
        pdtlnodeInList->pdtlnodeNext->pdtlnodePrev = pdtlnodeInList->pdtlnodePrev;
    else
        pdtllist->pdtlnodeLast = pdtlnodeInList->pdtlnodePrev;

    --pdtllist->lNodes;
    return pdtlnodeInList;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\nt4\common\nouiutil\rasman.c ===
/* Copyright (c) 1995, Microsoft Corporation, all rights reserved
**
** rasman.c
** RAS Manager helpers
** Listed alphabetically
**
** These routines have been exempted from the TCHARizing applied to the rest
** of the library because RASMAN is still an ANSI interface.
**
** 09/20/95 Steve Cobb
*/

#include <windows.h>  // Win32 root
#include <stdlib.h>   // for atol()
#include <debug.h>    // Trace/Assert library
#include <nouiutil.h> // Our public header
#include <raserror.h> // RAS error constants
#include <mcx.h>      // Unimodem


/* These types are described in MSDN and appear in Win95's unimdm.h private
** header (complete with typo) but not in any SDK headers.
*/

typedef struct tagDEVCFGGDR
{
    DWORD dwSize;
    DWORD dwVersion;
    WORD  fwOptions;
    WORD  wWaitBong;
}
DEVCFGHDR;

typedef struct tagDEVCFG
{
    DEVCFGHDR  dfgHdr;
    COMMCONFIG commconfig;
}
DEVCFG;

#define MANUAL_DIAL  0x0004
#define TERMINAL_PRE 0x0001


/*----------------------------------------------------------------------------
** Local prototypes
**----------------------------------------------------------------------------
*/

DWORD
GetRasDevices(
    IN  CHAR*           pszDeviceType,
    OUT RASMAN_DEVICE** ppDevices,
    OUT WORD*           pwEntries );

DWORD
GetRasPortParam(
    IN  HPORT             hport,
    IN  CHAR*             pszKey,
    OUT RASMAN_PORTINFO** ppPortInfo,
    OUT RAS_PARAMS**      ppParam );


/*----------------------------------------------------------------------------
** Routines
**----------------------------------------------------------------------------
*/


DWORD
ClearRasdevStats(
    IN RASDEV* pdev,
    IN BOOL    fBundle )

    /* Resets statistics counters for a device.
    **
    ** (Abolade Gbadegesin Nov-9-1995)
    */
{
    if (pdev == NULL) { return ERROR_INVALID_PARAMETER; }

    if ((HPORT)UlongToPtr(pdev->RD_Handle) == (HPORT)INVALID_HANDLE_VALUE) {
        return ERROR_INVALID_HANDLE;
    }

    ASSERT(g_pRasPortClearStatistics);
    return (fBundle ? g_pRasBundleClearStatistics((HPORT)UlongToPtr(pdev->RD_Handle))
                    : g_pRasPortClearStatistics((HPORT)UlongToPtr(pdev->RD_Handle)));
}


#if 0
DWORD
DeviceIdFromDeviceName(
    TCHAR* pszDeviceName )

    /* Returns the TAPI device ID associated with 'pszDeviceName'.  Returns
    ** 0xFFFFFFFE if not found, 0xFFFFFFFF if found but not a Unimodem.
    **
    ** This routine assumes that TAPI devices have unique names.
    */
{
    DWORD        dwErr;
    DWORD        dwId;
    WORD         wPorts;
    RASMAN_PORT* pPorts;

    TRACE("DeviceIdFromDeviceName");

    dwId = 0xFFFFFFFE;

    if (pszDeviceName)
    {
        dwErr = GetRasPorts( &pPorts, &wPorts );
        if (dwErr == 0)
        {
            CHAR* pszDeviceNameA;
            pszDeviceNameA = StrDupAFromT( pszDeviceName );
            if (pszDeviceNameA)
            {
                INT          i;
                RASMAN_PORT* pPort;

                for (i = 0, pPort = pPorts; i < wPorts; ++i, ++pPort)
                {
                    if (lstrcmpiA( pszDeviceNameA, pPort->P_DeviceName ) == 0)
                    {
                        dwId = pPort->P_LineDeviceId;
                        break;
                    }
                }
                Free( pszDeviceNameA );
            }
            Free( pPorts );
        }
    }

    TRACE1("DeviceIdFromDeviceName=%d",dwErr);
    return dwId;
}
#endif

DWORD
GetRasDevices(
    IN  CHAR*           pszDeviceType,
    OUT RASMAN_DEVICE** ppDevices,
    OUT WORD*           pwEntries )

    /* Fills caller's '*ppDevices' with the address of a heap block containing
    ** '*pwEntries' RASMAN_DEVICE structures.
    **
    ** Returns 0 if successful, otherwise a non-0 error code.  If successful,
    ** it is the caller's responsibility to free the returned memory block.
    */
{
    WORD  wSize = 0;
    DWORD dwErr;

    TRACE1("GetRasDevices(%s)",pszDeviceType);

    ASSERT(g_pRasDeviceEnum);
    TRACE("RasDeviceEnum...");
    dwErr = g_pRasDeviceEnum( pszDeviceType, NULL, &wSize, pwEntries );
    TRACE2("RasDeviceEnum=%d,c=%d",dwErr,*pwEntries);

    if (dwErr == 0)
    {
        /* No devices to enumerate.  Set up to allocate a single byte anyway,
        ** so things work without lots of special code.
        */
        wSize = 1;
    }
    else if (dwErr != ERROR_BUFFER_TOO_SMALL)
        return dwErr;

    *ppDevices = (RASMAN_DEVICE* )Malloc( wSize );
    if (!*ppDevices)
        return ERROR_NOT_ENOUGH_MEMORY;

    TRACE("RasDeviceEnum...");
    dwErr = g_pRasDeviceEnum(
        pszDeviceType, (PBYTE )*ppDevices, &wSize, pwEntries );
    TRACE1("RasDeviceEnum=%d",dwErr);

    if (dwErr != 0)
    {
        Free( *ppDevices );
        return dwErr;
    }

    return 0;
}


DWORD
GetRasDeviceString(
    IN  HPORT  hport,
    IN  CHAR*  pszDeviceType,
    IN  CHAR*  pszDeviceName,
    IN  CHAR*  pszKey,
    OUT CHAR** ppszValue,
    IN  DWORD  dwXlate )

    /* Loads callers '*ppszValue' with the address of a heap block containing
    ** a NUL-terminated copy of the value string associated with key 'pszKey'
    ** for the device on port 'hport'.  'pszDeviceType' specifies the type of
    ** device, e.g. "modem".  'pszDeviceName' specifies the name of the
    ** device, e.g. "Hayes V-Series 9600".  'dwXlate' is a bit mask of XLATE_
    ** bits specifying translations to perform on the returned string.
    **
    ** Returns 0 if successful, otherwise a non-0 error code.  If successful,
    ** it is the caller's responsibility to Free the returned string.
    */
{
    DWORD              dwErr = 0;
    RASMAN_DEVICEINFO* pDeviceInfo = NULL;
    RAS_PARAMS*        pParam;
    WORD               wSize = 0;
    INT                i;

    TRACE2("GetRasDeviceString(%s,%s)",pszDeviceName,pszKey);

    *ppszValue = NULL;

    do
    {
        ASSERT(g_pRasDeviceGetInfo);
        TRACE("RasDeviceGetInfo...");
        dwErr = g_pRasDeviceGetInfo(
            hport, pszDeviceType, pszDeviceName, NULL, &wSize );
        TRACE2("RasDeviceGetInfo=%d,s=%d",dwErr,(INT)wSize);

        if (dwErr != ERROR_BUFFER_TOO_SMALL && dwErr != 0)
            break;

        /* So it will fall thru and be "not found".
        */
        if (wSize == 0)
            wSize = 1;

        pDeviceInfo = (RASMAN_DEVICEINFO* )Malloc( wSize );
        if (!pDeviceInfo)
            return ERROR_NOT_ENOUGH_MEMORY;

        TRACE("RasDeviceGetInfo...");
        dwErr = g_pRasDeviceGetInfo(
            hport, pszDeviceType, pszDeviceName, (PBYTE )pDeviceInfo, &wSize );
        TRACE2("RasDeviceGetInfo=%d,s=%d",dwErr,(INT)wSize);

        if (dwErr != 0)
            break;

        dwErr = ERROR_KEY_NOT_FOUND;

        for (i = 0, pParam = pDeviceInfo->DI_Params;
             i < (INT )pDeviceInfo->DI_NumOfParams;
             ++i, ++pParam)
        {
            if (lstrcmpiA( pParam->P_Key, pszKey ) == 0)
            {
                *ppszValue = PszFromRasValue( &pParam->P_Value, dwXlate );

                dwErr = (*ppszValue) ? 0 : ERROR_NOT_ENOUGH_MEMORY;
                break;
            }
        }
    }
    while (FALSE);

    Free0( pDeviceInfo );

    TRACE1("String=\"%s\"",(*ppszValue)?*ppszValue:"");

    return dwErr;
}

DWORD
GetRasMessage(
    IN  HRASCONN hrasconn,
    OUT TCHAR**  ppszMessage )

    /* Loads caller's '*ppszMessage' with the address of a heap block
    ** containing the current MXS_MESSAGE_KEY value associated with RAS
    ** connection 'hrasconn'.
    **
    ** Returns 0 if successful or an error code.  It is caller's
    ** responsibility to Free the returned string.
    */
{
    DWORD         dwErr;
    RASCONNSTATUS rcs;
    CHAR*         pszMessage;

    TRACE("GetRasMessage");

    *ppszMessage = 0;

    ZeroMemory( &rcs, sizeof(rcs) );
    rcs.dwSize = sizeof(rcs);
    ASSERT(g_pRasGetConnectStatus);
    TRACE("RasGetConnectStatus");
    dwErr = g_pRasGetConnectStatus( hrasconn, &rcs );
    TRACE1("RasGetConnectStatus=%d",dwErr);

    if (dwErr == 0)
    {
        CHAR* pszDeviceTypeA;
        CHAR* pszDeviceNameA;

        pszDeviceTypeA = StrDupAFromT( rcs.szDeviceType );
        pszDeviceNameA = StrDupAFromT( rcs.szDeviceName );
        if (!pszDeviceTypeA || !pszDeviceNameA)
        {
            Free0( pszDeviceNameA );
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        dwErr = GetRasDeviceString(
            g_pRasGetHport( hrasconn ), pszDeviceTypeA, pszDeviceNameA,
            MXS_MESSAGE_KEY, &pszMessage, XLATE_ErrorResponse );

        Free0( pszDeviceTypeA );
        Free0( pszDeviceNameA );

        if (dwErr == 0)
        {
            *ppszMessage = StrDupTFromA( pszMessage );
            if (!*ppszMessage)
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
            Free0( pszMessage );
        }
    }

    return dwErr;
}


DWORD
GetRasPads(
    OUT RASMAN_DEVICE** ppDevices,
    OUT WORD*           pwEntries )

    /* Fills caller's '*ppDevices' with the address of a heap block containing
    ** '*pwEntries' X.25 PAD DEVICE structures.
    **
    ** Returns 0 if successful, otherwise a non-0 error code.  If successful,
    ** it is the caller's responsibility to free the returned memory block.
    */
{
    return GetRasDevices( MXS_PAD_TXT, ppDevices, pwEntries );
}


VOID
GetRasPortMaxBps(
    IN  HPORT  hport,
    OUT DWORD* pdwMaxConnectBps,
    OUT DWORD* pdwMaxCarrierBps )

    /* Loads callers '*pdwMaxConnectBps' with the maximum port->modem bps rate
    ** for port 'pport', or with 0 if not found.  '*pdwMaxCarrierBps' is the
    ** same but for maximum modem->modem speed.
    */
{
    CHAR* pszValue;
    DWORD dwErr;

    TRACE("GetRasPortMaxBps");

    dwErr = GetRasPortString(
        hport, SER_CONNECTBPS_KEY, &pszValue, XLATE_None );
    if (dwErr == 0)
        *pdwMaxConnectBps = (DWORD )atol( pszValue );
    else
        *pdwMaxConnectBps = 0;

    dwErr = GetRasPortString(
        hport, SER_CARRIERBPS_KEY, &pszValue, XLATE_None );
    if (dwErr == 0)
        *pdwMaxCarrierBps = (DWORD )atol( pszValue );
    else
        *pdwMaxCarrierBps = 0;
}


VOID
GetRasPortModemSettings(
    IN  HPORT hport,
    OUT BOOL* pfHwFlowDefault,
    OUT BOOL* pfEcDefault,
    OUT BOOL* pfEccDefault )

    /* Loads caller's flags with the default setting of Hardware Flow Control,
    ** Error Control, and Error Control and Compression for the given 'hport'.
    */
{
    CHAR* pszValue = NULL;

    *pfHwFlowDefault = TRUE;
    *pfEcDefault = TRUE;
    *pfEccDefault = TRUE;

    if (GetRasPortString(
            hport, SER_C_DEFAULTOFFSTR_KEY, &pszValue, XLATE_None ) == 0)
    {
        if (StrStrA( pszValue, MXS_HDWFLOWCONTROL_KEY ) != NULL)
            *pfHwFlowDefault = FALSE;

        if (StrStrA( pszValue, MXS_PROTOCOL_KEY ) != NULL)
            *pfEcDefault = FALSE;

        if (StrStrA( pszValue, MXS_COMPRESSION_KEY ) != NULL)
            *pfEccDefault = FALSE;

        Free0( pszValue );
    }
}


DWORD
GetRasPortParam(
    IN  HPORT             hport,
    IN  CHAR*             pszKey,
    OUT RASMAN_PORTINFO** ppPortInfo,
    OUT RAS_PARAMS**      ppParam )

    /* Loads callers '*ppParam' with the address of a RAS_PARAM block
    ** associated with key 'pszKey', or NULL if none.  'ppPortInfo' is the
    ** address of the array of RAS_PARAMS containing the found 'pparam'.
    **
    ** Returns 0 if successful, otherwise a non-0 error code.  If successful,
    ** it is the caller's responsibility to Free the returned '*ppPortInfo'.
    */
{
    DWORD dwErr = 0;
    WORD  wSize = 0;
    INT   i;

    TRACE("GetRasPortParam");

    *ppPortInfo = NULL;

    do
    {
        ASSERT(g_pRasPortGetInfo);
        TRACE("RasPortGetInfo");
        dwErr = g_pRasPortGetInfo( hport, NULL, &wSize );
        TRACE2("RasPortGetInfo=%d,s=%d",dwErr,(INT)wSize);

        if (dwErr != ERROR_BUFFER_TOO_SMALL && dwErr != 0)
            break;

        /* So it will fall thru and be "not found".
        */
        if (wSize == 0)
            wSize = 1;

        *ppPortInfo = (RASMAN_PORTINFO* )Malloc( wSize );
        if (!*ppPortInfo)
            return ERROR_NOT_ENOUGH_MEMORY;

        TRACE("RasPortGetInfo");
        dwErr = g_pRasPortGetInfo( hport, (PBYTE )*ppPortInfo, &wSize );
        TRACE2("RasPortGetInfo=%d,s=%d",dwErr,(INT)wSize);

        if (dwErr != 0)
            break;

        for (i = 0, *ppParam = (*ppPortInfo)->PI_Params;
             i < (INT )(*ppPortInfo)->PI_NumOfParams;
             ++i, ++(*ppParam))
        {
            if (lstrcmpiA( (*ppParam)->P_Key, pszKey ) == 0)
                break;
        }

        if (i >= (INT )(*ppPortInfo)->PI_NumOfParams)
            dwErr = ERROR_KEY_NOT_FOUND;
    }
    while (FALSE);

    return dwErr;
}


DWORD
GetRasPorts(
    OUT RASMAN_PORT** ppPorts,
    OUT WORD*         pwEntries )

    /* Enumerate RAS ports.  Sets '*ppPort' to the address of a heap memory
    ** block containing an array of PORT structures with '*pwEntries'
    ** elements.
    **
    ** Returns 0 if successful, otherwise a non-0 error code.  If successful,
    ** it is the caller's responsibility to free the returned memory block.
    */
{
    WORD  wSize = 0;
    DWORD dwErr;

    TRACE("GetRasPorts");

#if 0 // Phonebook test dummies

    {
        RASMAN_PORT* pPort;

        TRACE("TEST: Fake ISDN ports");

        *pwEntries = 5;
        wSize = *pwEntries * sizeof(RASMAN_PORT);

        *ppPorts = (RASMAN_PORT* )Malloc( wSize );
        if (!*ppPorts)
            return ERROR_NOT_ENOUGH_MEMORY;

        pPort = *ppPorts;
        ZeroMemory( pPort, sizeof(*pPort) );
        lstrcpyA( pPort->P_PortName, "ISDN1" );
        pPort->P_Status = CLOSED;
        pPort->P_ConfiguredUsage = CALL_OUT;
        pPort->P_CurrentUsage = CALL_OUT;
        lstrcpyA( pPort->P_MediaName, "rastapi" );
        lstrcpyA( pPort->P_DeviceName, "Digiboard PCIMac ISDN adapter" );
        lstrcpyA( pPort->P_DeviceType, "ISDN" );

        ++pPort;
        ZeroMemory( pPort, sizeof(*pPort) );
        lstrcpyA( pPort->P_PortName, "ISDN2" );
        pPort->P_Status = CLOSED;
        pPort->P_ConfiguredUsage = CALL_OUT;
        pPort->P_CurrentUsage = CALL_OUT;
        lstrcpyA( pPort->P_MediaName, "rastapi" );
        lstrcpyA( pPort->P_DeviceName, "Digiboard PCIMac ISDN adapter" );
        lstrcpyA( pPort->P_DeviceType, "ISDN" );

        ++pPort;
        ZeroMemory( pPort, sizeof(*pPort) );
        lstrcpyA( pPort->P_PortName, "COM1" );
        pPort->P_Status = CLOSED;
        pPort->P_ConfiguredUsage = CALL_OUT;
        pPort->P_CurrentUsage = CALL_OUT;
        lstrcpyA( pPort->P_MediaName, "rasser" );
        lstrcpyA( pPort->P_DeviceName, "US Robotics Courier V32 bis" );
        lstrcpyA( pPort->P_DeviceType, "MODEM" );

        ++pPort;
        ZeroMemory( pPort, sizeof(*pPort) );
        lstrcpyA( pPort->P_PortName, "COM500" );
        pPort->P_Status = CLOSED;
        pPort->P_ConfiguredUsage = CALL_OUT;
        pPort->P_CurrentUsage = CALL_OUT;
        lstrcpyA( pPort->P_MediaName, "rasser" );
        lstrcpyA( pPort->P_DeviceName, "Eicon X.PAD" );
        lstrcpyA( pPort->P_DeviceType, "PAD" );

        ++pPort;
        ZeroMemory( pPort, sizeof(*pPort) );
        lstrcpyA( pPort->P_PortName, "VPN1" );
        pPort->P_Status = CLOSED;
        pPort->P_ConfiguredUsage = CALL_OUT;
        pPort->P_CurrentUsage = CALL_OUT;
        lstrcpyA( pPort->P_MediaName, "rastapi" );
        lstrcpyA( pPort->P_DeviceName, "RASPPTPM" );
        lstrcpyA( pPort->P_DeviceType, "VPN1" );

        return 0;
    }

#else

    ASSERT(g_pRasPortEnum);
    TRACE("RasPortEnum...");
    dwErr = g_pRasPortEnum( NULL, &wSize, pwEntries );
    TRACE2("RasPortEnum=%d,c=%d",dwErr,(INT)*pwEntries);

    if (dwErr == 0)
    {
        /* No ports to enumerate.  Set up to allocate a single byte anyway, so
        ** things work without lots of special code.
        */
        wSize = 1;
    }
    else if (dwErr != ERROR_BUFFER_TOO_SMALL)
        return dwErr;

    *ppPorts = (RASMAN_PORT* )Malloc( wSize );
    if (!*ppPorts)
        return ERROR_NOT_ENOUGH_MEMORY;

    TRACE("RasPortEnum...");
    dwErr = g_pRasPortEnum( (PBYTE )*ppPorts, &wSize, pwEntries );
    TRACE2("RasPortEnum=%d,c=%d",dwErr,(INT)*pwEntries);

    if (dwErr != 0)
    {
        Free( *ppPorts );
        *ppPorts = NULL;
        return dwErr;
    }

#endif

#if 1 // Verbose trace
    {
        RASMAN_PORT* pPort;
        WORD         i;

        for (pPort = *ppPorts, i = 0; i < *pwEntries; ++i, ++pPort)
        {
            TRACE4("Port[%d]=%s,DID=$%08x,AID=$%08x",
                pPort->P_Handle,pPort->P_PortName,
                pPort->P_LineDeviceId,pPort->P_AddressId);
            TRACE3(" M=%s,DT=%s,DN=%s",
                pPort->P_MediaName,pPort->P_DeviceType,pPort->P_DeviceName);
            TRACE3(" S=$%08x,CfgU=$%08x,CurU=$%08x",
                pPort->P_Status,pPort->P_ConfiguredUsage,pPort->P_CurrentUsage);
        }
    }
#endif

    return 0;
}


DWORD
GetRasPortString(
    IN  HPORT  hport,
    IN  CHAR*  pszKey,
    OUT CHAR** ppszValue,
    IN  DWORD  dwXlate )

    /* Loads callers '*ppszValue' with the address of a heap block containing
    ** a NUL-terminated copy of the value string associated with key 'pszKey'
    ** on port 'hport'.  'dwXlate' is a bit mask of XLATE_ bits specifying
    ** translations to be done on the string value.
    **
    ** Returns 0 if successful, otherwise a non-0 error code.  If successful,
    ** it is the caller's responsibility to Free the returned string.
    */
{
    RASMAN_PORTINFO* pPortInfo;
    RAS_PARAMS*      pParam;
    DWORD            dwErr;

    TRACE("GetRasPortString");

    dwErr = GetRasPortParam( hport, pszKey, &pPortInfo, &pParam );

    *ppszValue = NULL;

    if (dwErr == 0)
    {
        *ppszValue = PszFromRasValue( &pParam->P_Value, dwXlate );
        dwErr = (*ppszValue) ? 0 : ERROR_NOT_ENOUGH_MEMORY;
    }

    Free0( pPortInfo );

    return dwErr;
}



DWORD
GetRasSwitches(
    OUT RASMAN_DEVICE** ppDevices,
    OUT WORD*           pwEntries )

    /* Fills caller's '*ppDevices' with the address of a heap block containing
    ** '*pwEntries' switch DEVICE structures.
    **
    ** Returns 0 if successful, otherwise a non-0 error code.  If successful,
    ** it is the caller's responsibility to free the returned memory block.
    */
{
    return GetRasDevices( MXS_SWITCH_TXT, ppDevices, pwEntries );
}


DWORD
GetRasUnimodemBlob(
    IN  HPORT  hport,
    IN  CHAR*  pszDeviceType,
    OUT BYTE** ppBlob,
    OUT DWORD* pcbBlob )

    /* Loads '*ppBlob' and '*pcbBlob' with the sanitized Unimodem blob and
    ** size associated with 'hport' and 'pszDeviceType'.  It is caller's
    ** responsibility to Free the returned '*ppBlob'.
    **
    ** Returns 0 if successful, or an error code.
    */
{
    DWORD dwErr;
    BYTE* pBlob;
    DWORD cbBlob;

    cbBlob = 0;

    ASSERT(g_pRasGetDevConfig);
    TRACE("RasGetDevConfig");
    dwErr = g_pRasGetDevConfig( hport, pszDeviceType, NULL, &cbBlob );
    TRACE1("RasGetDevConfig=%d",dwErr);

    if (dwErr != 0 && dwErr != ERROR_BUFFER_TOO_SMALL)
        return dwErr;

    if (cbBlob > 0)
    {
        pBlob = Malloc( cbBlob );
        if (!pBlob)
            return ERROR_NOT_ENOUGH_MEMORY;

        TRACE("RasGetDevConfig");
        dwErr = g_pRasGetDevConfig( hport, pszDeviceType, pBlob, &cbBlob );
        TRACE1("RasGetDevConfig=%d",dwErr);

        if (dwErr != 0)
        {
            Free( pBlob );
            return dwErr;
        }

        SanitizeUnimodemBlob( pBlob );
    }
    else
        pBlob = NULL;

    *ppBlob = pBlob;
    *pcbBlob = cbBlob;

    return dwErr;
}


VOID
GetRasUnimodemInfo(
    IN  HPORT         hport,
    IN  CHAR*         pszDeviceType,
    OUT UNIMODEMINFO* pInfo )

    /* Loads 'pInfo' with the RAS-relevant information of the port 'hport'
    ** with device name 'pszDeviceName'.
    */
{
    DWORD dwErr;
    BYTE* pBlob;
    DWORD cbBlob;

    SetDefaultUnimodemInfo( pInfo );

    dwErr = GetRasUnimodemBlob( hport, pszDeviceType, &pBlob, &cbBlob );
    if (dwErr == 0 && cbBlob > 0)
        UnimodemInfoFromBlob( pBlob, pInfo );

    Free0( pBlob );
}

CHAR*
PszFromRasValue(
    IN RAS_VALUE* prasvalue,
    IN DWORD      dwXlate )

    /* Returns the address of a heap block containing a NUL-terminated string
    ** value from caller's '*prasvalue', or NULL if out of memory.  'dwXlate'
    ** is a bit mask of XLATE_ bits specifying translations to be performed on
    ** the string.  The value is assumed to be of format String.  It is
    ** translated to modem.inf style.
    */
{
#define MAXEXPANDPERCHAR 5
#define HEXCHARS         "0123456789ABCDEF"

    INT   i;
    BOOL  fXlate;
    BOOL  fXlateCtrl;
    BOOL  fXlateCr;
    BOOL  fXlateCrSpecial;
    BOOL  fXlateLf;
    BOOL  fXlateLfSpecial;
    BOOL  fXlateLAngle;
    BOOL  fXlateRAngle;
    BOOL  fXlateBSlash;
    BOOL  fXlateSSpace;
    BOOL  fNoCharSinceLf;
    INT   nLen;
    CHAR* pszIn;
    CHAR* pszBuf;
    CHAR* pszOut;

    nLen = prasvalue->String.Length;
    pszIn = prasvalue->String.Data;

    pszBuf = Malloc( (nLen * MAXEXPANDPERCHAR) + 1 );
    if (!pszBuf)
        return NULL;

    /* Translate the returned string based on the translation bit map.  The
    ** assumption here is that all these devices talk ASCII and not some
    ** localized ANSI.
    */
    fXlate = (dwXlate != 0);
    fXlateCtrl = (dwXlate & XLATE_Ctrl);
    fXlateCr = (dwXlate & XLATE_Cr);
    fXlateCrSpecial = (dwXlate & XLATE_CrSpecial);
    fXlateLf = (dwXlate & XLATE_Lf);
    fXlateLfSpecial = (dwXlate & XLATE_LfSpecial);
    fXlateLAngle = (dwXlate & XLATE_LAngle);
    fXlateRAngle = (dwXlate & XLATE_RAngle);
    fXlateBSlash = (dwXlate & XLATE_BSlash);
    fXlateSSpace = (dwXlate & XLATE_SSpace);

    pszOut = pszBuf;
    fNoCharSinceLf = TRUE;
    for (i = 0; i < nLen; ++i)
    {
        CHAR ch = pszIn[ i ];

        if (fXlate)
        {
            if (ch == 0x0D)
            {
                if (fXlateSSpace && fNoCharSinceLf)
                    continue;

                if (fXlateCrSpecial)
                {
                    /* Special symbol for carriage return.
                    */
                    lstrcpyA( pszOut, "<cr>" );
                    pszOut += 4;
                    continue;
                }
            }

            if (ch == 0x0A)
            {
                if (fXlateSSpace && fNoCharSinceLf)
                    continue;

                fNoCharSinceLf = TRUE;

                if (fXlateLfSpecial)
                {
                    /* Special symbol for line feed.
                    */
                    lstrcpyA( pszOut, "<lf>" );
                    pszOut += 4;
                    continue;
                }
            }

            if (ch != 0x0A && ch != 0x0D)
                fNoCharSinceLf = FALSE;

            if ((((ch < 0x20 || ch > 0x7E)
                   && ch != 0x0D && ch != 0x0A) && fXlateCtrl)
                || (ch == 0x0D && fXlateCr)
                || (ch == 0x0A && fXlateLf)
                || (ch == 0x3C && fXlateLAngle)
                || (ch == 0x3E && fXlateRAngle)
                || (ch == 0x5C && fXlateBSlash))
            {
                /* Expand to "dump" form, i.e. <hFF> where FF is the hex value
                ** of the character.
                */
                *pszOut++ = '<';
                *pszOut++ = 'h';
                *pszOut++ = HEXCHARS[ ch / 16 ];
                *pszOut++ = HEXCHARS[ ch % 16 ];
                *pszOut++ = '>';
                continue;
            }
        }

        /* Just copy without translation.
        */
        *pszOut++ = ch;
    }

    *pszOut = '\0';
    pszOut = Realloc( pszBuf, lstrlenA( pszBuf ) + 1 );
    if(!pszOut)
    {
        Free(pszBuf);
        return NULL;
    }

    return pszOut;
}


VOID
SanitizeUnimodemBlob(
    IN OUT BYTE* pBlob )

    /* Fix non-RAS-compatible settings in unimodem blob 'pBlob'.
    **
    ** (Based on Gurdeepian routine)
    */
{
    DEVCFG*        pDevCfg;
    MODEMSETTINGS* pModemSettings;

    pDevCfg = (DEVCFG* )pBlob;
    pModemSettings = (MODEMSETTINGS* )(((BYTE* )&pDevCfg->commconfig)
        + pDevCfg->commconfig.dwProviderOffset);

    /* No unimodem service provider pre/post-connect terminal, operator dial,
    ** or tray lights.  RAS does these itself.
    */
    pDevCfg->dfgHdr.fwOptions = 0;

    pDevCfg->commconfig.dcb.fBinary           = TRUE;
    pDevCfg->commconfig.dcb.fParity           = TRUE;
    pDevCfg->commconfig.dcb.fOutxDsrFlow      = FALSE;
    pDevCfg->commconfig.dcb.fDtrControl       = DTR_CONTROL_ENABLE;
    pDevCfg->commconfig.dcb.fTXContinueOnXoff = FALSE;
    pDevCfg->commconfig.dcb.fOutX             = FALSE;
    pDevCfg->commconfig.dcb.fInX              = FALSE;
    pDevCfg->commconfig.dcb.fErrorChar        = FALSE;
    pDevCfg->commconfig.dcb.fNull             = FALSE;
    pDevCfg->commconfig.dcb.fAbortOnError     = FALSE;
    pDevCfg->commconfig.dcb.ByteSize          = 8;
    pDevCfg->commconfig.dcb.Parity            = NOPARITY;
    pDevCfg->commconfig.dcb.StopBits          = ONESTOPBIT;

    /* Wait 55 seconds to establish call.
    */
    pModemSettings->dwCallSetupFailTimer = 55;

    /* Disable inactivity timeout.
    */
    pModemSettings->dwInactivityTimeout = 0;
}


VOID
SetDefaultUnimodemInfo(
    OUT UNIMODEMINFO* pInfo )

    /* Sets 'pInfo' to default settings.
    */
{
    pInfo->fHwFlow = FALSE;
    pInfo->fEc = FALSE;
    pInfo->fEcc = FALSE;
    pInfo->dwBps = 9600;
    pInfo->fSpeaker = TRUE;
    pInfo->fOperatorDial = FALSE;
    pInfo->fUnimodemPreTerminal = FALSE;
}


VOID
UnimodemInfoFromBlob(
    IN  BYTE*         pBlob,
    OUT UNIMODEMINFO* pInfo )

    /* Loads 'pInfo' with RAS-relevant Unimodem information retrieved from
    ** Unimodem blob 'pBlob'.
    **
    ** (Based on Gurdeepian routine)
    */
{
    DEVCFG*        pDevCfg;
    MODEMSETTINGS* pModemSettings;

    pDevCfg = (DEVCFG* )pBlob;
    pModemSettings = (MODEMSETTINGS* )(((BYTE* )&pDevCfg->commconfig)
        + pDevCfg->commconfig.dwProviderOffset);

    pInfo->fSpeaker =
        (pModemSettings->dwSpeakerMode != MDMSPKR_OFF)
            ? TRUE : FALSE;

    pInfo->fHwFlow =
        (pModemSettings->dwPreferredModemOptions & MDM_FLOWCONTROL_HARD)
            ? TRUE : FALSE;

    pInfo->fEcc =
        (pModemSettings->dwPreferredModemOptions & MDM_COMPRESSION)
            ? TRUE : FALSE;

    pInfo->fEc =
        (pModemSettings->dwPreferredModemOptions & MDM_ERROR_CONTROL)
            ? TRUE : FALSE;

    pInfo->dwBps = pDevCfg->commconfig.dcb.BaudRate;

    pInfo->fOperatorDial =
        (pDevCfg->dfgHdr.fwOptions & MANUAL_DIAL)
            ? TRUE : FALSE;

    pInfo->fUnimodemPreTerminal =
        (pDevCfg->dfgHdr.fwOptions & TERMINAL_PRE)
            ? TRUE : FALSE;
}


VOID
UnimodemInfoToBlob(
    IN     UNIMODEMINFO* pInfo,
    IN OUT BYTE*         pBlob )

    /* Applies RAS-relevant Unimodem information supplied in 'pInfo' to
    ** Unimodem blob 'pBlob'.
    **
    ** (Based on Gurdeepian routine)
    */
{
    DEVCFG*        pDevCfg;
    MODEMSETTINGS* pModemSettings;

    pDevCfg = (DEVCFG* )pBlob;
    pModemSettings = (MODEMSETTINGS* )(((BYTE* )&pDevCfg->commconfig)
        + pDevCfg->commconfig.dwProviderOffset);

    pModemSettings->dwSpeakerMode =
        (pInfo->fSpeaker) ? MDMSPKR_DIAL : MDMSPKR_OFF;

    if (pInfo->fHwFlow)
    {
        pDevCfg->commconfig.dcb.fOutxCtsFlow = TRUE;
        pDevCfg->commconfig.dcb.fRtsControl = RTS_CONTROL_HANDSHAKE;
        pModemSettings->dwPreferredModemOptions |= MDM_FLOWCONTROL_HARD;
    }
    else
    {
        pDevCfg->commconfig.dcb.fOutxCtsFlow = FALSE;
        pDevCfg->commconfig.dcb.fRtsControl = RTS_CONTROL_DISABLE;
        pModemSettings->dwPreferredModemOptions &= ~(MDM_FLOWCONTROL_HARD);
    }

    if (pInfo->fEc)
        pModemSettings->dwPreferredModemOptions |= MDM_ERROR_CONTROL;
    else
        pModemSettings->dwPreferredModemOptions &= ~(MDM_ERROR_CONTROL);

    if (pInfo->fEcc)
        pModemSettings->dwPreferredModemOptions |= MDM_COMPRESSION;
    else
        pModemSettings->dwPreferredModemOptions &= ~(MDM_COMPRESSION);

    pDevCfg->commconfig.dcb.BaudRate = pInfo->dwBps;

    if (pInfo->fOperatorDial)
        pDevCfg->dfgHdr.fwOptions |= MANUAL_DIAL;

    if (pInfo->fUnimodemPreTerminal)
        pDevCfg->dfgHdr.fwOptions |= TERMINAL_PRE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\nt4\common\nouiutil\rasapi.c ===
/* Copyright (c) 1995, Microsoft Corporation, all rights reserved
**
** rasapi.c
** RAS API helpers (with no RASMAN calls)
** Listed alphabetically
**
** 12/20/95 Steve Cobb
*/

#include <windows.h>  // Win32 root
#include <list.h>     // for LIST_ENTRY definitions
#include <stdlib.h>   // for atol()
#include <debug.h>    // Trace/Assert library
#include <nouiutil.h> // Our public header
#include <raserror.h> // RAS error constants


DWORD
FreeRasconnList(
    LIST_ENTRY *pListHead )

    /* Frees a list built by GetRasconnList.
    **
    ** Returns 0 always.
    **
    ** (Abolade Gbadegesin Nov-9-1995)
    */
{
    RASCONNLINK *plink;
    RASCONNENTRY *pentry;
    LIST_ENTRY *ple, *plel;

    while (!IsListEmpty(pListHead)) {

        ple = RemoveHeadList(pListHead);

        pentry = CONTAINING_RECORD(ple, RASCONNENTRY, RCE_Node);

        while (!IsListEmpty(&pentry->RCE_Links)) {

            plel = RemoveHeadList(&pentry->RCE_Links);

            plink = CONTAINING_RECORD(plel, RASCONNLINK, RCL_Node);

            Free(plink);
        }

        Free(pentry);
    }

    return NO_ERROR;
}



DWORD
GetRasconnList(
    LIST_ENTRY *pListHead )

    /* Builds a sorted list containing entries for each connected network.
    ** Each entry consists of an entry-name and a list of RASCONN structures
    ** for each link connected to the entry-name's network.
    **
    ** The type of each node in the list of entries is RASCONNENTRY.
    ** The type of each node in each list of links is RASCONNLINK.
    **
    ** Returns 0 if successful, or an error code.
    **
    ** (Abolade Gbadegesin Nov-9-1995)
    */
{
    DWORD dwErr;
    INT cmp, cmpl;
    RASCONNLINK *plink;
    RASCONNENTRY *pentry;
    DWORD i, iConnCount;
    RASCONN *pConnTable, *pconn;
    LIST_ENTRY *ple, *plel, *pheadl;

    InitializeListHead(pListHead);

    //
    // get an array of all the connections
    //

    dwErr = GetRasconnTable(&pConnTable, &iConnCount);
    if (dwErr != NO_ERROR) { return dwErr; }

    //
    // convert the array into a list
    //

    for (i = 0, pconn = pConnTable; i < iConnCount; i++, pconn++) {

        //
        // see if there is an entry for the network to which
        // this RASCONN corresponds
        //

        for (ple = pListHead->Flink; ple != pListHead; ple = ple->Flink) {

            pentry = CONTAINING_RECORD(ple, RASCONNENTRY, RCE_Node);

            cmp = lstrcmp(pconn->szEntryName, pentry->RCE_Entry->szEntryName);
            if (cmp > 0) { continue; }
            else
            if (cmp < 0) { break; }

            //
            // the entry has been found;
            // now insert a link for the connection
            //

            pheadl = &pentry->RCE_Links;

            for (plel = pheadl->Flink; plel != pheadl; plel = plel->Flink) {

                plink = CONTAINING_RECORD(plel, RASCONNLINK, RCL_Node);

                cmpl = lstrcmp(
                          pconn->szDeviceName, plink->RCL_Link.szDeviceName
                          );
                if (cmpl > 0) { continue; }
                else
                if (cmpl < 0) { break; }

                //
                // the link already exists, so do nothing
                //

                break;
            }

            //
            // the link was not found but we found where to insert it,
            // insert the link now
            //

            if (plel == pheadl || cmpl < 0) {

                plink = Malloc(sizeof(RASCONNLINK));

                if (plink == NULL) {
                    FreeRasconnList(pListHead);
                    Free(pConnTable);
                    return ERROR_NOT_ENOUGH_MEMORY;
                }

                plink->RCL_Link = *pconn;

                InsertTailList(plel, &plink->RCL_Node);
            }

            break;
        }

        //
        // the entry was not found, but now we know where to insert it
        //

        if (ple == pListHead || cmp < 0) {

            //
            // allocate the new entry
            //

            pentry = Malloc(sizeof(RASCONNENTRY));

            if (pentry == NULL) {
                FreeRasconnList(pListHead);
                Free(pConnTable);
                return ERROR_NOT_ENOUGH_MEMORY;
            }

            InitializeListHead(&pentry->RCE_Links);

            //
            // insert it in the list of entries
            //

            InsertTailList(ple, &pentry->RCE_Node);

            //
            // allocate the link which corresponds to the RASCONN
            // we are currently working on
            //

            plink = Malloc(sizeof(RASCONNLINK));

            if (plink == NULL) {
                FreeRasconnList(pListHead);
                Free(pConnTable);
                return ERROR_NOT_ENOUGH_MEMORY;
            }

            plink->RCL_Link = *pconn;

            //
            // insert it in the entry's list of links
            //

            InsertHeadList(&pentry->RCE_Links, &plink->RCL_Node);

            pentry->RCE_Entry = &plink->RCL_Link;
        }
    }

    Free(pConnTable);
    return NO_ERROR;
}


DWORD
GetRasconnTable(
    OUT RASCONN** ppConnTable,
    OUT DWORD*    pdwConnCount )

    /* Get active RAS dial-out connections.  Loads '*ppConnTable' with the
    ** address of a heap block containing an array of '*pdwConnCount' active
    ** connections.
    **
    ** (Abolade Gbadegesin Nov-9-1995)
    */
{
    RASCONN conn, *pconn;
    DWORD dwErr, dwSize, dwCount;

    //
    // validate arguments
    //

    if (ppConnTable == NULL || pdwConnCount == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    *pdwConnCount = 0;
    *ppConnTable = NULL;

    //
    // RasEnumConnections doesn't give the size required
    // unless a valid buffer is specified, so pass in a dummy buffer
    //

    conn.dwSize = dwSize = sizeof(RASCONN);

    pconn = &conn;

    ASSERT(g_pRasEnumConnections);
    dwErr = g_pRasEnumConnections(pconn, &dwSize, &dwCount);

    if (dwErr == NO_ERROR) {

        if (dwCount == 0) {
            return NO_ERROR;
        }
        else {

            //
            // only one entry, so return it
            //

            pconn = Malloc(sizeof(RASCONN));

            if (pconn == NULL) {
                return ERROR_NOT_ENOUGH_MEMORY;
            }

            *pconn = conn;
            *ppConnTable = pconn;
            *pdwConnCount = 1;

            return NO_ERROR;
        }
    }

    if (dwErr != ERROR_BUFFER_TOO_SMALL) {
        return dwErr;
    }

    //
    // allocate more space
    //

    pconn = Malloc(dwSize);

    if (pconn == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    pconn->dwSize = sizeof(RASCONN);
    dwErr = g_pRasEnumConnections(pconn, &dwSize, &dwCount);

    if (dwErr != NO_ERROR) {
        Free(pconn);
        return dwErr;
    }

    *ppConnTable = pconn;
    *pdwConnCount = dwCount;

    return NO_ERROR;
}


DWORD
GetRasEntrynameTable(
    OUT RASENTRYNAME**  ppEntrynameTable,
    OUT DWORD*          pdwEntrynameCount )

    /* Get active RAS dial-out connections.  Loads '*ppEntrynameTable' with the
    ** address of a heap block containing an array of '*pdwEntrynameCount'
    ** active connections.
    **
    ** (Abolade Gbadegesin Nov-9-1995)
    */
{
    RASENTRYNAME ename, *pename;
    DWORD dwErr, dwSize, dwCount;

    //
    // validate arguments
    //

    if (ppEntrynameTable == NULL || pdwEntrynameCount == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    *pdwEntrynameCount = 0;
    *ppEntrynameTable = NULL;


    //
    // RasEnumEntries doesn't give the size required
    // unless a valid buffer is specified, so pass in a dummy buffer
    //

    ename.dwSize = dwSize = sizeof(ename);

    pename = &ename;

    ASSERT(g_pRasEnumEntries);
    dwErr = g_pRasEnumEntries(NULL, NULL, pename, &dwSize, &dwCount);

    if (dwErr == NO_ERROR) {

        if (dwCount == 0) {
            return NO_ERROR;
        }
        else {

            //
            // only one entry, so return it
            //

            pename = Malloc(sizeof(*pename));

            if (pename == NULL) { return ERROR_NOT_ENOUGH_MEMORY; }

            *pename = ename;
            *ppEntrynameTable = pename;
            *pdwEntrynameCount = 1;

            return NO_ERROR;
        }
    }

    if (dwErr != ERROR_BUFFER_TOO_SMALL) {
        return dwErr;
    }


    //
    // allocate more space
    //

    pename = Malloc(dwSize);

    if (pename == NULL) { return ERROR_NOT_ENOUGH_MEMORY; }

    pename->dwSize = sizeof(*pename);

    dwErr = g_pRasEnumEntries(NULL, NULL, pename, &dwSize, &dwCount);

    if (dwErr != NO_ERROR) { Free(pename); return dwErr; }

    *ppEntrynameTable = pename;
    *pdwEntrynameCount = dwCount;

    return NO_ERROR;
}


DWORD
GetRasProjectionInfo(
    IN  HRASCONN    hrasconn,
    OUT RASAMB*     pamb,
    OUT RASPPPNBF*  pnbf,
    OUT RASPPPIP*   pip,
    OUT RASPPPIPX*  pipx,
    OUT RASPPPLCP*  plcp,
    OUT RASSLIP*    pslip )

    /* Reads projection info for all protocols, translating "not requested"
    ** into an in-structure code of ERROR_PROTOCOL_NOT_CONFIGURED.
    **
    ** Returns 0 is successful, otherwise a non-0 error code.
    */
{
    DWORD dwErr;
    DWORD dwSize;

    ZeroMemory( pamb, sizeof(*pamb) );
    ZeroMemory( pnbf, sizeof(*pnbf) );
    ZeroMemory( pip,  sizeof(*pip) );
    ZeroMemory( pipx, sizeof(*pipx) );
    ZeroMemory( plcp, sizeof(*plcp) );
    ZeroMemory( pslip,sizeof(*pslip) );

    dwSize = pamb->dwSize = sizeof(*pamb);
    ASSERT(g_pRasGetProjectionInfo);
    TRACE("RasGetProjectionInfo(AMB)");
    dwErr = g_pRasGetProjectionInfo( hrasconn, RASP_Amb, pamb, &dwSize );
    TRACE2("RasGetProjectionInfo(AMB)=%d,e=%d",dwErr,pamb->dwError);

    if (dwErr == ERROR_PROTOCOL_NOT_CONFIGURED)
    {
        ZeroMemory( pamb, sizeof(*pamb) );
        pamb->dwError = ERROR_PROTOCOL_NOT_CONFIGURED;
    }
    else if (dwErr != 0)
        return dwErr;

    dwSize = pnbf->dwSize = sizeof(*pnbf);
    TRACE("RasGetProjectionInfo(NBF)");
    dwErr = g_pRasGetProjectionInfo( hrasconn, RASP_PppNbf, pnbf, &dwSize );
    TRACE2("RasGetProjectionInfo(NBF)=%d,e=%d",dwErr,pnbf->dwError);

    if (dwErr == ERROR_PROTOCOL_NOT_CONFIGURED)
    {
        ZeroMemory( pnbf, sizeof(*pnbf) );
        pnbf->dwError = ERROR_PROTOCOL_NOT_CONFIGURED;
    }
    else if (dwErr != 0)
        return dwErr;

    dwSize = pip->dwSize = sizeof(*pip);
    TRACE("RasGetProjectionInfo(IP)");
    dwErr = g_pRasGetProjectionInfo( hrasconn, RASP_PppIp, pip, &dwSize );
    TRACE2("RasGetProjectionInfo(IP)=%d,e=%d",dwErr,pip->dwError);

    if (dwErr == ERROR_PROTOCOL_NOT_CONFIGURED)
    {
        ZeroMemory( pip, sizeof(*pip) );
        pip->dwError = ERROR_PROTOCOL_NOT_CONFIGURED;
    }
    else if (dwErr != 0)
        return dwErr;

    dwSize = pipx->dwSize = sizeof(*pipx);
    TRACE("RasGetProjectionInfo(IPX)");
    dwErr = g_pRasGetProjectionInfo( hrasconn, RASP_PppIpx, pipx, &dwSize );
    TRACE2("RasGetProjectionInfo(IPX)=%d,e=%d",dwErr,pipx->dwError);

    if (dwErr == ERROR_PROTOCOL_NOT_CONFIGURED)
    {
        dwErr = 0;
        ZeroMemory( pipx, sizeof(*pipx) );
        pipx->dwError = ERROR_PROTOCOL_NOT_CONFIGURED;
    }

    dwSize = plcp->dwSize = sizeof(*plcp);
    TRACE("RasGetProjectionInfo(LCP)");
    dwErr = g_pRasGetProjectionInfo( hrasconn, RASP_PppLcp, plcp, &dwSize );
    TRACE2("RasGetProjectionInfo(LCP)=%d,f=%d",dwErr,plcp->fBundled);

    if (dwErr == ERROR_PROTOCOL_NOT_CONFIGURED)
    {
        dwErr = 0;
        plcp->fBundled = FALSE;
    }

#if 0
    pslip->dwError = ERROR_PROTOCOL_NOT_CONFIGURED;
#else

    dwSize = pslip->dwSize = sizeof(*pslip);
    TRACE("RasGetProjectionInfo(SLIP)");
    dwErr = g_pRasGetProjectionInfo( hrasconn, RASP_Slip, pslip, &dwSize );
    TRACE2("RasGetProjectionInfo(SLIP)=%d,e=%d",dwErr,pslip->dwError);

    if (dwErr == ERROR_PROTOCOL_NOT_CONFIGURED)
    {
        dwErr = 0;
        ZeroMemory( pslip, sizeof(*pslip) );
        pslip->dwError = ERROR_PROTOCOL_NOT_CONFIGURED;
    }
#endif

    return dwErr;
}


HRASCONN
HrasconnFromEntry(
    IN TCHAR* pszPhonebook,
    IN TCHAR* pszEntry )

    /* Returns the HRASCONN associated with entry 'pszEntry' from phonebook
    ** 'pszPhonebook' or NULL if not connected or error.
    */
{
    DWORD    dwErr;
    RASCONN* prc;
    DWORD    c;
    HRASCONN h;

    TRACE("HrasconnFromEntry");

    if (!pszEntry)
        return NULL;

    h = NULL;

    dwErr = GetRasconnTable( &prc, &c );
    if (dwErr == 0 && c > 0)
    {
        RASCONN* p;
        DWORD    i;

        for (i = 0, p = prc; i < c; ++i, ++p)
        {
            if ((!pszPhonebook
                  || lstrcmpi( p->szPhonebook, pszPhonebook ) == 0)
                && lstrcmp( p->szEntryName, pszEntry ) == 0)
            {
                h = p->hrasconn;
                break;
            }
        }

        Free( prc );
    }

    TRACE1("HrasconnFromEntry=$%08x",h);
    return h;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\nt4\common\nouiutil\rasrpc.c ===
/*++

Copyright(c) 1995 Microsoft Corporation

MODULE NAME
    rasrpclb.c

ABSTRACT
    rasrpc client/server common routines

AUTHOR
    Anthony Discolo (adiscolo) 28-Jul-1995

REVISION HISTORY

--*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <rpc.h>
#include "rasrpc.h"
#include <ras.h>
#include <nouiutil.h>
#include <rasman.h>
#include <raserror.h>
#include <mprapi.h>
#include <dtl.h>
#include <debug.h>

//
// Handle NULL string parameters 
// to the TRACE macro.
//
#define TRACESTR(s)     (s) != NULL ? (s) : TEXT("")

DWORD
CallbackListToRpc(
    OUT LPRASRPC_CALLBACKLIST *pCallbacks,
    IN DTLLIST *pdtllistCallbacks
    )
{
    DTLNODE *pdtlnode;
    LPRASRPC_CALLBACKLIST pNewCallback, pTail = NULL;
    CALLBACKINFO *pCallback;

TRACE("CallbackListToRpc: begin");
    *pCallbacks = NULL;
    for (pdtlnode = DtlGetFirstNode(pdtllistCallbacks);
         pdtlnode != NULL;
         pdtlnode = DtlGetNextNode(pdtlnode))
    {
        pCallback = (CALLBACKINFO *)DtlGetData(pdtlnode);
        
        //
        // Allocate and initialize
        // the new structure.
        //
        pNewCallback = MIDL_user_allocate(sizeof (RASRPC_CALLBACKLIST));
        if (pNewCallback == NULL)
            return GetLastError();
        if (pCallback->pszPortName != NULL)
            lstrcpy(pNewCallback->pszPortName, pCallback->pszPortName);
        else 
            *pNewCallback->pszPortName = TEXT('\0');
        if (pCallback->pszDeviceName != NULL)
            lstrcpy(pNewCallback->pszDeviceName, pCallback->pszDeviceName);
        else 
            *pNewCallback->pszDeviceName = TEXT('\0');
        if (pCallback->pszNumber != NULL)
            lstrcpy(pNewCallback->pszNumber, pCallback->pszNumber);
        else 
            *pNewCallback->pszNumber = TEXT('\0');
        pNewCallback->dwDeviceType = pCallback->dwDeviceType;
TRACE2("CallbackListToRpc: new node: %S, %S", pCallback->pszPortName, pCallback->pszDeviceName);
        pNewCallback->pNext = NULL;
        //
        // Insert it at the tail of the list.
        //
        if (*pCallbacks == NULL)
            *pCallbacks = pTail = pNewCallback;
        else {
            pTail->pNext = pNewCallback;
            pTail = pNewCallback;
        }
    }
TRACE("CallbackListToRpc: end");
    return 0;
}


DWORD
CallbackListFromRpc(
    OUT DTLLIST **pdtllistCallbacks,
    IN LPRASRPC_CALLBACKLIST pCallbacks
    )
{
    LPRASRPC_CALLBACKLIST pCallback;
    DTLNODE *pdtlnode;

TRACE("CallbackListFromRpc: begin");
    //
    // Initialize the new list.
    //
    *pdtllistCallbacks = DtlCreateList(0);
    if (*pdtllistCallbacks == NULL)
        return GetLastError();

    for (pCallback = pCallbacks; pCallback != NULL; pCallback = pCallback->pNext)
    {
        pdtlnode = CreateCallbackNode(pCallback->pszPortName, pCallback->pszDeviceName, pCallback->pszNumber, pCallback->dwDeviceType);
        if (pdtlnode == NULL)
            return GetLastError();
TRACE2("CallbackListToRpc: new node: %S, %S", pCallback->pszPortName, pCallback->pszDeviceName);
        DtlAddNodeLast(*pdtllistCallbacks, pdtlnode);
    }
TRACE("CallbackListFromRpc: end");
    return 0;
}


DWORD
StringListToRpc(
    OUT LPRASRPC_STRINGLIST *pStrings,
    IN DTLLIST *pdtllistStrings
    )
{
    DTLNODE *pdtlnode;
    LPRASRPC_STRINGLIST pNewString, pTail = NULL;
    PWCHAR psz;

TRACE("StringListToRpc: begin");
    *pStrings = NULL;
    for (pdtlnode = DtlGetFirstNode(pdtllistStrings);
         pdtlnode != NULL;
         pdtlnode = DtlGetNextNode(pdtlnode))
    {
        psz = (PWCHAR)DtlGetData(pdtlnode);
        
        //
        // Allocate and initialize
        // the new structure.
        //
        pNewString = MIDL_user_allocate(sizeof (RASRPC_STRINGLIST));
        if (pNewString == NULL)
            return GetLastError();
        if (psz != NULL)
            lstrcpy(pNewString->psz, psz);
        else
            *pNewString->psz = TEXT('\0');
        pNewString->pNext = NULL;
TRACE1("StringListToRpc: new node: %S", psz);
        //
        // Insert it at the tail of the list.
        //
        if (*pStrings == NULL)
            *pStrings = pTail = pNewString;
        else {
            pTail->pNext = pNewString;
            pTail = pNewString;
        }
    }
TRACE("StringListToRpc: end");
    return 0;
}


DWORD
StringListFromRpc(
    OUT DTLLIST **pdtllistStrings,
    IN LPRASRPC_STRINGLIST pStrings
    )
{
    LPRASRPC_STRINGLIST pString;
    DTLNODE *pdtlnode;

    //
    // Initialize the new list.
    //
TRACE("StringListFromRpc: begin");
    *pdtllistStrings = DtlCreateList(0);
    if (*pdtllistStrings == NULL)
        return GetLastError();

    for (pString = pStrings; pString != NULL; pString = pString->pNext)
    {
        pdtlnode = CreatePszNode(pString->psz);
        if (pdtlnode == NULL)
            return GetLastError();
TRACE1("StringListToRpc: new node: %S", pString->psz);
        DtlAddNodeLast(*pdtllistStrings, pdtlnode);
    }
TRACE("StringListFromRpc: end");
    return 0;
}


DWORD
LocationListToRpc(
    OUT LPRASRPC_LOCATIONLIST *pLocations,
    IN DTLLIST *pdtllistLocations
    )
{
    DTLNODE *pdtlnode;
    LPRASRPC_LOCATIONLIST pNewLocation, pTail = NULL;
    LOCATIONINFO *pLocation;

TRACE("LocationListToRpc: begin");
    *pLocations = NULL;
    for (pdtlnode = DtlGetFirstNode(pdtllistLocations);
         pdtlnode != NULL;
         pdtlnode = DtlGetNextNode(pdtlnode))
    {
        pLocation = (LOCATIONINFO *)DtlGetData(pdtlnode);
        
        //
        // Allocate and initialize
        // the new structure.
        //
        pNewLocation = MIDL_user_allocate(sizeof (RASRPC_LOCATIONLIST));
        if (pNewLocation == NULL)
            return GetLastError();
        pNewLocation->dwLocationId = pLocation->dwLocationId;
        pNewLocation->iPrefix = pLocation->iPrefix;
        pNewLocation->iSuffix = pLocation->iSuffix;
        pNewLocation->pNext = NULL;
TRACE3("LocationListToRpc: new node: %d, %d, %d", pLocation->dwLocationId, pLocation->iPrefix, pLocation->iSuffix);
        //
        // Insert it at the tail of the list.
        //
        if (*pLocations == NULL)
            *pLocations = pTail = pNewLocation;
        else {
            pTail->pNext = pNewLocation;
            pTail = pNewLocation;
        }
    }
TRACE("LocationListToRpc: end");
    return 0;
}


DWORD
LocationListFromRpc(
    OUT DTLLIST **pdtllistLocations,
    IN LPRASRPC_LOCATIONLIST pLocations
    )
{
    LPRASRPC_LOCATIONLIST pLocation;
    DTLNODE *pdtlnode;

    //
    // Initialize the new list.
    //
TRACE("LocationListFromRpc: begin");
    *pdtllistLocations = DtlCreateList(0);
    if (*pdtllistLocations == NULL)
        return GetLastError();

    for (pLocation = pLocations; pLocation != NULL; pLocation = pLocation->pNext)
    {
        pdtlnode = CreateLocationNode(pLocation->dwLocationId, pLocation->iPrefix, pLocation->iSuffix);
        if (pdtlnode == NULL)
            return GetLastError();
TRACE3("LocationListFromRpc: new node: %d, %d, %d", pLocation->dwLocationId, pLocation->iPrefix, pLocation->iSuffix);
        DtlAddNodeLast(*pdtllistLocations, pdtlnode);
    }
TRACE("LocationListFromRpc: end");
    return 0;
}


DWORD
RasToRpcPbuser(
    LPRASRPC_PBUSER pUser,
    PBUSER *pPbuser
    )
{
    DWORD dwErr;

    TRACE("RasToRpcPbUser: begin");
    pUser->fOperatorDial = pPbuser->fOperatorDial;
    pUser->fPreviewPhoneNumber = pPbuser->fPreviewPhoneNumber;
    pUser->fUseLocation = pPbuser->fUseLocation;
    pUser->fShowLights = pPbuser->fShowLights;
    pUser->fShowConnectStatus = pPbuser->fShowConnectStatus;
    pUser->fCloseOnDial = pPbuser->fCloseOnDial;
    pUser->fAllowLogonPhonebookEdits = pPbuser->fAllowLogonPhonebookEdits;
    pUser->fAllowLogonLocationEdits = pPbuser->fAllowLogonLocationEdits;
    pUser->fSkipConnectComplete = pPbuser->fSkipConnectComplete;
    pUser->fNewEntryWizard = pPbuser->fNewEntryWizard;
    pUser->dwRedialAttempts = pPbuser->dwRedialAttempts;
    pUser->dwRedialSeconds = pPbuser->dwRedialSeconds;
    pUser->dwIdleDisconnectSeconds = pPbuser->dwIdleDisconnectSeconds;
    pUser->fRedialOnLinkFailure = pPbuser->fRedialOnLinkFailure;
    pUser->fPopupOnTopWhenRedialing = pPbuser->fPopupOnTopWhenRedialing;
    pUser->fExpandAutoDialQuery = pPbuser->fExpandAutoDialQuery;
    pUser->dwCallbackMode = pPbuser->dwCallbackMode;
    dwErr = CallbackListToRpc(&pUser->pCallbacks, pPbuser->pdtllistCallback);
    if (dwErr)
        return dwErr;
    if (pPbuser->pszLastCallbackByCaller != NULL)
        lstrcpy(pUser->pszLastCallbackByCaller, pPbuser->pszLastCallbackByCaller);
    else
        *pUser->pszLastCallbackByCaller = TEXT('\0');
    pUser->dwPhonebookMode = pPbuser->dwPhonebookMode;
    if (pPbuser->pszPersonalFile != NULL)
        lstrcpy(pUser->pszPersonalFile, pPbuser->pszPersonalFile);
    else 
        *pUser->pszPersonalFile = TEXT('\0');
    if (pPbuser->pszAlternatePath != NULL)
        lstrcpy(pUser->pszAlternatePath, pPbuser->pszAlternatePath);
    else 
        *pUser->pszAlternatePath = TEXT('\0');
    dwErr = StringListToRpc(&pUser->pPhonebooks, pPbuser->pdtllistPhonebooks);
    if (dwErr)
        return dwErr;
    dwErr = StringListToRpc(&pUser->pAreaCodes, pPbuser->pdtllistAreaCodes);
    if (dwErr)
        return dwErr;
    pUser->fUseAreaAndCountry = pPbuser->fUseAreaAndCountry;
    dwErr = StringListToRpc(&pUser->pPrefixes, pPbuser->pdtllistPrefixes);
    if (dwErr)
        return dwErr;
    dwErr = StringListToRpc(&pUser->pSuffixes, pPbuser->pdtllistSuffixes);
    if (dwErr)
        return dwErr;
    dwErr = LocationListToRpc(&pUser->pLocations, pPbuser->pdtllistLocations);
    if (dwErr)
        return dwErr;
    pUser->dwXPhonebook = pPbuser->dwXPhonebook;
    pUser->dwYPhonebook = pPbuser->dwYPhonebook;
    if (pPbuser->pszDefaultEntry != NULL)
        lstrcpy(pUser->pszDefaultEntry, pPbuser->pszDefaultEntry);
    else 
        *pUser->pszDefaultEntry = TEXT('\0');
    pUser->fInitialized = pPbuser->fInitialized;
    pUser->fDirty = pPbuser->fDirty;
    TRACE("RasToRpcPbUser: end");

    return 0;
}


DWORD
RpcToRasPbuser(
    PBUSER *pPbuser,
    LPRASRPC_PBUSER pUser
    )
{
    DWORD dwErr;

    TRACE("RpcToRasPbUser: begin");
    pPbuser->fOperatorDial = pUser->fOperatorDial;
    pPbuser->fPreviewPhoneNumber = pUser->fPreviewPhoneNumber;
    pPbuser->fUseLocation = pUser->fUseLocation;
    pPbuser->fShowLights = pUser->fShowLights;
    pPbuser->fShowConnectStatus = pUser->fShowConnectStatus;
    pPbuser->fCloseOnDial = pUser->fCloseOnDial;
    pPbuser->fAllowLogonPhonebookEdits = pUser->fAllowLogonPhonebookEdits;
    pPbuser->fAllowLogonLocationEdits = pUser->fAllowLogonLocationEdits;
    pPbuser->fSkipConnectComplete = pUser->fSkipConnectComplete;
    pPbuser->fNewEntryWizard = pUser->fNewEntryWizard;
    pPbuser->dwRedialAttempts = pUser->dwRedialAttempts;
    pPbuser->dwRedialSeconds = pUser->dwRedialSeconds;
    pPbuser->dwIdleDisconnectSeconds = pUser->dwIdleDisconnectSeconds;
    pPbuser->fRedialOnLinkFailure = pUser->fRedialOnLinkFailure;
    pPbuser->fPopupOnTopWhenRedialing = pUser->fPopupOnTopWhenRedialing;
    pPbuser->fExpandAutoDialQuery = pUser->fExpandAutoDialQuery;
    pPbuser->dwCallbackMode = pUser->dwCallbackMode;
    dwErr = CallbackListFromRpc(&pPbuser->pdtllistCallback, pUser->pCallbacks);
    if (dwErr)
        return dwErr;
    pPbuser->pszLastCallbackByCaller = StrDup(pUser->pszLastCallbackByCaller);
    if (pPbuser->pszLastCallbackByCaller == NULL)
        return GetLastError();
    pPbuser->dwPhonebookMode = pUser->dwPhonebookMode;
    pPbuser->pszPersonalFile = StrDup(pUser->pszPersonalFile);
    if (pPbuser->pszPersonalFile == NULL)
        return GetLastError();
    pPbuser->pszAlternatePath = StrDup(pUser->pszAlternatePath);
    if (pPbuser->pszAlternatePath == NULL)
        return GetLastError();
    dwErr = StringListFromRpc(&pPbuser->pdtllistPhonebooks, pUser->pPhonebooks);
    if (dwErr)
        return dwErr;
    dwErr = StringListFromRpc(&pPbuser->pdtllistAreaCodes, pUser->pAreaCodes);
    if (dwErr)
        return dwErr;
    pPbuser->fUseAreaAndCountry = pUser->fUseAreaAndCountry;
    dwErr = StringListFromRpc(&pPbuser->pdtllistPrefixes, pUser->pPrefixes);
    if (dwErr)
        return dwErr;
    dwErr = StringListFromRpc(&pPbuser->pdtllistSuffixes, pUser->pSuffixes);
    if (dwErr)
        return dwErr;
    dwErr = LocationListFromRpc(&pPbuser->pdtllistLocations, pUser->pLocations);
    if (dwErr)
        return dwErr;
    pPbuser->dwXPhonebook = pUser->dwXPhonebook;
    pPbuser->dwYPhonebook = pUser->dwYPhonebook;
    pPbuser->pszDefaultEntry = StrDup(pUser->pszDefaultEntry);
    if (pPbuser->pszDefaultEntry == NULL)
        return GetLastError();
    pPbuser->fInitialized = pUser->fInitialized;
    pPbuser->fDirty = pUser->fDirty;

#if DBG
    TRACE1("fOperatorDial=%d", pPbuser->fOperatorDial);
    TRACE1("fPreviewPhoneNumber=%d", pPbuser->fPreviewPhoneNumber);
    TRACE1("fUseLocation=%d", pPbuser->fUseLocation);
    TRACE1("fShowLights=%d", pPbuser->fShowLights);
    TRACE1("fShowConnectStatus=%d", pPbuser->fShowConnectStatus);
    TRACE1("fCloseOnDial=%d", pPbuser->fCloseOnDial);
    TRACE1("fAllowLogonPhonebookEdits=%d", pPbuser->fAllowLogonPhonebookEdits);
    TRACE1("fAllowLogonLocationEdits=%d", pPbuser->fAllowLogonLocationEdits);
    TRACE1("fSkipConnectComplete=%d", pPbuser->fSkipConnectComplete);
    TRACE1("fNewEntryWizard=%d", pPbuser->fNewEntryWizard);
    TRACE1("dwRedialAttempts=%d", pPbuser->dwRedialAttempts);
    TRACE1("dwRedialSeconds=%d", pPbuser->dwRedialSeconds);
    TRACE1("dwIdleDisconnectSeconds=%d", pPbuser->dwIdleDisconnectSeconds);
    TRACE1("fRedialOnLinkFailure=%d", pPbuser->fRedialOnLinkFailure);
    TRACE1("fPopupOnTopWhenRedialing=%d", pPbuser->fPopupOnTopWhenRedialing);
    TRACE1("fExpandAutoDialQuery=%d", pPbuser->fExpandAutoDialQuery);
    TRACE1("dwCallbackMode=%d", pPbuser->dwCallbackMode);
    TRACE1("pszLastCallbackByCaller=%S", TRACESTR(pPbuser->pszLastCallbackByCaller));
    TRACE1("dwPhonebookMode=%d", pPbuser->dwPhonebookMode);
    TRACE1("pszPersonalFile=%S", TRACESTR(pPbuser->pszPersonalFile));
    TRACE1("pszAlternatePath=%S", TRACESTR(pPbuser->pszAlternatePath));
    TRACE1("fUseAreaAndCountry=%d", pPbuser->fUseAreaAndCountry);
    TRACE1("dwXPhonebook=%d", pPbuser->dwXPhonebook);
    TRACE1("dwYPhonebook=%d", pPbuser->dwYPhonebook);
    TRACE1("pszDefaultEntry=%S", TRACESTR(pPbuser->pszDefaultEntry));
    TRACE1("fInitialized=%d", pPbuser->fInitialized);
    TRACE1("fDirty=%d", pPbuser->fDirty);
#endif
    TRACE("RpcToRasPbUser: end");

    return 0;
}


//
// Utility routines.
//
void * __RPC_USER 
MIDL_user_allocate(size_t size)
{
    return(Malloc(size));
}


void __RPC_USER 
MIDL_user_free( void *pointer)
{
    Free(pointer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\nt4\common\rnk\rnk.c ===
/* Copyright (c) 1996, Microsoft Corporation, all rights reserved
**
** rnk.c
** Remote Access shortcut file (.RNK) library
**
** 02/15/96 Steve Cobb
*/

#include <windows.h>   // Win32 core
#include <debug.h>     // TRACE/ASSERT macros
#include <nouiutil.h>  // Heap macros
#include <rnk.h>       // Our public header


VOID
FreeRnkInfo(
    IN RNKINFO* pInfo )

    /* Destroys 'pInfo' buffer returned from ReadShortcutFile.
    */
{
    if (pInfo)
    {
        Free0( pInfo->pszEntry );
        Free0( pInfo->pszPhonebook );
        Free( pInfo );
    }
}


RNKINFO*
ReadShortcutFile(
    IN TCHAR* pszRnkPath )

    /* Reads shortcut file at 'pszRnkPath' returning a RNKINFO buffer.  Caller
    ** should eventually call FreeRnkInfo on the returned buffer.
    **
    ** Returns 0 or an error code.
    */
{
    RNKINFO* pInfo;
    TCHAR    szBuf[ 1024 ];

    TRACE("ReadShortcutFile");

    pInfo = (RNKINFO* )Malloc( sizeof(RNKINFO) );
    if (!pInfo)
        return NULL;

    ZeroMemory( pInfo, sizeof(*pInfo) );

    GetPrivateProfileString( TEXT(RNK_SEC_Main), TEXT(RNK_KEY_Entry),
        TEXT(""), szBuf, sizeof(szBuf) / sizeof(TCHAR), pszRnkPath );
    pInfo->pszEntry = StrDup( szBuf );

    GetPrivateProfileString( TEXT(RNK_SEC_Main), TEXT(RNK_KEY_Phonebook),
        TEXT(""), szBuf, sizeof(szBuf) / sizeof(TCHAR), pszRnkPath );
    pInfo->pszPhonebook = StrDup( szBuf );

    return pInfo;
}



DWORD
WriteShortcutFile(
    IN TCHAR* pszRnkPath,
    IN TCHAR* pszPbkPath,
    IN TCHAR* pszEntry )

    /* Write the shortcut file 'pszRnkPath' with a command line to dial entry
    ** 'pszEntry' from phonebook 'pszPath'.
    **
    ** Returns 0 if succesful or an error code.
    */
{
    DWORD  dwErr;
    HANDLE hFile;
    CHAR*  pszRnkPathA;
    CHAR*  pszEntryA;
    CHAR*  pszPbkPathA;

    TRACE("WriteShortcutFile");

    /* The file is written in ANSI to
    ** avoid potential portability/compatibility problems with Windows 95.
    */
    dwErr = 0;

    pszRnkPathA = StrDupAFromT( pszRnkPath );
    if (!pszRnkPathA)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
    }
    else
    {
        hFile = CreateFileA( pszRnkPathA, GENERIC_WRITE, 0, NULL,
                    CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );

        if (hFile == INVALID_HANDLE_VALUE)
        {
            dwErr = GetLastError();
        }
        else
        {
            CloseHandle( hFile );

            pszEntryA = StrDupAFromT( pszEntry );
            pszPbkPathA = StrDupAFromT( pszPbkPath );

            if (!pszEntryA || !pszPbkPathA)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
            }
            else
            {
                BOOL  f;
                CHAR  szBuf[ (2 * MAX_PATH) + 100 ];
                CHAR* pszKey;

                ZeroMemory( szBuf, sizeof(szBuf) );

                pszKey = szBuf;
                wsprintfA( pszKey, "%s=%s",
                    RNK_KEY_Entry, pszEntryA );

                pszKey += lstrlenA( pszKey ) + 1;
                wsprintfA( pszKey, "%s=%s",
                    RNK_KEY_Phonebook, pszPbkPathA );

                f = WritePrivateProfileSectionA(
                        RNK_SEC_Main, szBuf, pszRnkPathA );
                if (!f)
                    dwErr = GetLastError();
            }

            Free0( pszPbkPathA );
            Free0( pszEntryA );
        }

        Free( pszRnkPathA );
    }

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\nt4\common\pbk\file.c ===
/* Copyright (c) 1995, Microsoft Corporation, all rights reserved
**
** file.c
** Remote Access phonebook library
** File access routines
** Listed alphabetically
**
** 09/21/95 Steve Cobb
**
** About .PBK files:
** -----------------
**
** A phonebook file is an MB ANSI file containing 0-n []ed sections, each
** containing information for a single phonebook entry.  The single entry may
** contain multiple link information.  Refer to file 'notes.txt' for a
** description of how this format differs from the NT 3.51 format.
**
**    [ENTRY]
**    Description=<1/0>
**    AutoLogon=<1/0>
**    DialParamsUID=<unique-ID>
**    UsePwForNetwork=<1/0>
**    BaseProtocol=<BP-code>
**    Authentication=<AS-code>
**    ExcludedProtocols=<PP-bits>
**    LcpExtensions=<1/0>
**    DataEncryption=<DE-code>
**    SkipNwcWarning=<1/0>
**    SkipDownLevelDialog=<1/0>
**    SwCompression=<1/0>
**    UseCountryAndAreaCodes=<1/0>
**    AreaCode=<string>
**    CountryID=<id>
**    CountryCode=<code>
**    DialMode=<DM-code>
**    DialPercent=<0-100>
**    DialSeconds=<1-n>
**    HangUpPercent=<0-100>
**    HangUpSeconds=<1-n>
**    OverridePref=<RASOR-bits>
**    RedialAttempts=<n>
**    RedialSeconds=<n>
**    IdleDisconnectSeconds=<-1,0,1-n>
**    RedialOnLinkFailure=<1/0>
**    PopupOnTopWhenRedialing=<1/0>
**    CallbackMode=<CBM-code>
**    SecureLocalFiles=<1/0>
**    CustomDialDll=<path>
**    CustomDialFunc=<func-name>
**    AuthRestrictions=<AR-code>
**    AuthenticateServer=<1/0>
**
** The following single set of IP parameters appear in place of the equivalent
** separate sets of PppXxx or SlipXxx parameters in the previous phonebook.
**
**    IpPrioritizeRemote=<1/0>
**    IpHeaderCompression=<1/0>
**    IpAddress=<a.b.c.d>
**    IpDnsAddress=<a.b.c.d>
**    IpDns2Address=<a.b.c.d>
**    IpWinsAddress=<a.b.c.d>
**    IpWins2Address=<a.b.c.d>
**    IpAssign=<ASRC-code>
**    IpNameAssign=<ASRC-code>
**    IpFrameSize=<1006/1500>
**
** In general each section contains subsections delimited by MEDIA=<something>
** and DEVICE=<something> lines.  In NT 3.51 there had to be exactly one MEDIA
** subsection and it had to be the first subsection of the section.  There
** could be any number of DEVICE subsections.  Now, there can be multiple
** MEDIA/DEVICE sets where the position of the set determines it's sub-entry
** index, the first being 1, the second 2, etc.
**
** For serial media, the program currently expects 1 to 4 DEVICE subsections,
** representing a preconnect switch, modem, X.25 PAD, and postconnect switch
** (often a script).  Following is a full serial link:
**
**    MEDIA=serial
**    Port=<port-name>
**    OtherPortOk=<1/0>
**    Device=<device-name>            ; Absence indicates an "old" phonebook
**    ConnectBps=<bps>
**
**    DEVICE=switch
**    Type=<switchname or Terminal>
**
**    DEVICE=modem
**    PhoneNumber=<phonenumber1>
**    PhoneNumber=<phonenumber2>
**    PhoneNumber=<phonenumberN>
**    PromoteAlternates=<1/0>
**    TapiBlob=<hexdump>
**    ManualDial=<1/0>                ; Old MXS modems only
**    HwFlowControl=<1/0>
**    Protocol=<1/0>
**    Compression=<1/0>
**    Speaker=<0/1>
**
**    DEVICE=pad
**    X25Pad=<padtype>
**    X25Address=<X121address>
**    UserData=<userdata>
**    Facilities=<facilities>
**
**    DEVICE=switch
**    Type=<switchname or Terminal>
**
** In the above, when a "pad" device appears without a modem (local PAD card),
** the X25Pad field is written but is empty, because this is what the old
** library/UI appears to do (though it does not look to be what was intended).
**
** For ISDN media, the program expects exactly 1 DEVICE subsection.
**
**    MEDIA=isdn
**    Port=<port>
**    OtherPortOk=<1/0>
**    Device=<device-name>
**
**    DEVICE=isdn
**    PhoneNumber=<phonenumber1>
**    PhoneNumber=<phonenumber2>
**    PhoneNumber=<phonenumberN>
**    PromoteAlternates=<1/0>
**    LineType=<0/1/2>
**    Fallback=<1/0>
**    EnableCompression=<1/0>         ; Old proprietary protocol only
**    ChannelAggregation=<channels>   ; Old proprietary protocol only
**    Proprietary=<1/0>               ; Exists only in new, not found is 1.
**
**
** For X.25 media, the program expects exactly 1 DEVICE subsection.
**
**    MEDIA=x25
**    Port=<port-name>
**    OtherPortOk=<1/0>
**    Device=<device-name>
**
**    DEVICE=x25
**    X25Address=<X121address>
**    UserData=<userdata>
**    Facilities=<facilities>
**
** For other media, the program expects exactly one DEVICE subsection with
** device name matching the media.  "Other" media and devices are created for
** entries assigned to all non-serial, non-isdn medias.
**
**    MEDIA=<media>
**    Port=<port-name>
**    OtherPortOk=<1/0>
**    Device=<device-name>
**
**    DEVICE=<media>
**    PhoneNumber=<phonenumber1>
**    PhoneNumber=<phonenumber2>
**    PhoneNumber=<phonenumberN>
**    PromoteAlternates=<1/0>
**
** The phonebook also supports the concept of "custom" entries, i.e. entries
** that fit the MEDIA followed by DEVICE subsection rules but which do not
** include certain expected key fields.  A custom entry is not editable with
** the UI, but may be chosen for connection.  This gives us a story for new
** drivers added by 3rd parties or after release and not yet fully supported
** in the UI.  (Note: The RAS API support for most the custom entry discussion
** above may be removed for NT SUR)
*/

#include "pbkp.h"


/* This mutex guards against multiple RASFILE access to any phonebook file
** across processes.  Because this is currently a static library there is no
** easy way to protect a single file at a time though this would be adequate.
*/
#define PBMUTEXNAME "RasPbFileNt4"
HANDLE g_hmutexPb = NULL;


#define MARK_LastLineToDelete 249

#define IB_BytesPerLine 64


/*----------------------------------------------------------------------------
** Local prototypes
**----------------------------------------------------------------------------
*/

BOOL
DeleteCurrentSection(
    IN HRASFILE h );

DWORD
GetPersonalPhonebookFile(
    IN  TCHAR* pszUser,
    IN  LONG   lNum,
    OUT TCHAR* pszFile );

BOOL
GetPersonalPhonebookPath(
    IN  TCHAR* pszFile,
    OUT TCHAR* pszPathBuf );

BOOL
GetPhonebookPath(
    IN  PBUSER* pUser,
    OUT TCHAR** ppszPath,
    OUT DWORD*  pdwPhonebookMode );

DWORD
InitSecurityDescriptor(
    PSECURITY_DESCRIPTOR pSecurityDescriptor );

DWORD
InsertBinary(
    IN HRASFILE h,
    IN CHAR*    pszKey,
    IN BYTE*    pData,
    IN DWORD    cbData );

DWORD
InsertBinaryChunk(
    IN HRASFILE h,
    IN CHAR*    pszKey,
    IN BYTE*    pData,
    IN DWORD    cbData );

DWORD
InsertDeviceList(
    IN HRASFILE h,
    IN PBENTRY* ppbentry,
    IN PBLINK*  ppblink );

DWORD
InsertFlag(
    IN HRASFILE h,
    IN CHAR*    pszKey,
    IN BOOL     fValue );

DWORD
InsertGroup(
    IN HRASFILE h,
    IN CHAR*    pszGroupKey,
    IN TCHAR*   pszValue );

DWORD
InsertLong(
    IN HRASFILE h,
    IN CHAR*    pszKey,
    IN LONG     lValue );

DWORD
InsertSection(
    IN HRASFILE h,
    IN TCHAR*   pszSectionName );

DWORD
InsertString(
    IN HRASFILE h,
    IN CHAR*    pszKey,
    IN TCHAR*   pszValue );

DWORD
InsertStringA(
    IN HRASFILE h,
    IN CHAR*    pszKey,
    IN CHAR*    pszValue );

DWORD
InsertStringList(
    IN HRASFILE h,
    IN CHAR*    pszKey,
    IN DTLLIST* pdtllistValues );

BOOL
IsGroup(
    IN CHAR* pszText );

DWORD
ModifyEntryList(
    IN PBFILE* pFile );

DWORD
ReadBinary(
    IN  HRASFILE h,
    IN  RFSCOPE  rfscope,
    IN  CHAR*    pszKey,
    OUT BYTE**   ppResult,
    OUT DWORD*   pcb );

DWORD
ReadDeviceList(
    IN     HRASFILE h,
    IN OUT PBENTRY* ppbentry,
    IN OUT PBLINK*  ppblink,
    IN     BOOL     fUnconfiguredPort,
    IN     BOOL*    pfSpeaker );

DWORD
ReadEntryList(
    IN OUT PBFILE* pFile,
    IN     BOOL    fRouter );

DWORD
ReadEntryNameList(
    IN OUT PBFILE* pFile );

DWORD
ReadFlag(
    IN  HRASFILE h,
    IN  RFSCOPE  rfscope,
    IN  CHAR*    pszKey,
    OUT BOOL*    pfResult );

DWORD
ReadLong(
    IN  HRASFILE h,
    IN  RFSCOPE  rfscope,
    IN  CHAR*    pszKey,
    OUT LONG*    plResult );

DWORD
ReadString(
    IN  HRASFILE h,
    IN  RFSCOPE  rfscope,
    IN  CHAR*    pszKey,
    OUT TCHAR**  ppszResult );

DWORD
ReadStringList(
    IN  HRASFILE  h,
    IN  RFSCOPE   rfscope,
    IN  CHAR*     pszKey,
    OUT DTLLIST** ppdtllistResult );

/*----------------------------------------------------------------------------
** Routines
**----------------------------------------------------------------------------
*/


VOID
ClosePhonebookFile(
    IN OUT PBFILE* pFile )

    /* Closes the currently open phonebook file for shutdown.
    */
{
    if (pFile->hrasfile != -1)
    {
        RasfileClose( pFile->hrasfile );
        pFile->hrasfile = -1;
    }

    Free0( pFile->pszPath );
    pFile->pszPath = NULL;

    if (pFile->pdtllistEntries)
    {
        if (DtlGetListId( pFile->pdtllistEntries ) == RPBF_HeadersOnly)
            DtlDestroyList( pFile->pdtllistEntries, DestroyPszNode );
        else
            DtlDestroyList( pFile->pdtllistEntries, DestroyEntryNode );
        pFile->pdtllistEntries = NULL;
    }
}


BOOL
DeleteCurrentSection(
    IN HRASFILE h )

    /* Delete the section containing the current line from phonebook file 'h'.
    **
    ** Returns true if all lines are deleted successfully, false otherwise.
    ** False is returned if the current line is not in a section.  If
    ** successful, the current line is set to the line following the deleted
    ** section.  There are no promises about the current line in case of
    ** failure.
    */
{
    BOOL fLastLine;

    /* Mark the last line in the section, then reset the current line to the
    ** first line of the section.
    */
    if (!RasfileFindLastLine( h, RFL_ANY, RFS_SECTION )
        || !RasfilePutLineMark( h, MARK_LastLineToDelete )
        || !RasfileFindFirstLine( h, RFL_ANY, RFS_SECTION ))
    {
        return FALSE;
    }

    /* Delete lines up to and including the last line of the section.
    */
    do
    {
        fLastLine = (RasfileGetLineMark( h ) == MARK_LastLineToDelete);

        if (!RasfileDeleteLine( h ))
            return FALSE;
    }
    while (!fLastLine);

    return TRUE;
}


DWORD
GetPersonalPhonebookFile(
    IN  TCHAR* pszUser,
    IN  LONG   lNum,
    OUT TCHAR* pszFile )

    /* Loads caller's 'pszFile' buffer with the NUL-terminated filename
    ** corresponding to unique phonebook file name attempt 'lNum' for current
    ** user 'pszUser'.  Caller's 'pszFile' must be at least 13 characters
    ** long.  Attempts go from -1 to 999.
    **
    ** Returns 0 if successful or a non-0 error code.
    */
{
    TCHAR szNum[ 3 + 1 ];

    if (lNum < 0)
    {
        lstrcpyn( pszFile, pszUser, 9 );
    }
    else
    {
        if (lNum > 999)
            return ERROR_PATH_NOT_FOUND;

        lstrcpy( pszFile, TEXT("00000000") );
        LToT( lNum, szNum, 10 );
        lstrcpy( pszFile + 8 - lstrlen( szNum ), szNum );
        CopyMemory( pszFile, pszUser,
            (min( lstrlen( pszUser ), 5 )) * sizeof(TCHAR) );
    }

    lstrcat( pszFile, TEXT(".pbk") );
    return 0;
}


BOOL
GetPhonebookDirectory(
    OUT TCHAR* pszPathBuf )

    /* Loads caller's 'pszPathBuf' (should have length MAX_PATH + 1) with the
    ** path to the RAS directory, e.g. c:\nt\system32\ras\".  Note the
    ** trailing backslash.
    **
    ** Returns true if successful, false otherwise.  Caller is guaranteed that
    ** an 8.3 filename will fit on the end of the directory without exceeding
    ** MAX_PATH.
    */
{
    UINT unStatus = g_pGetSystemDirectory( pszPathBuf, MAX_PATH + 1 );

    if (unStatus == 0 || unStatus > (MAX_PATH - (5 + 8 + 1 + 3)))
        return FALSE;

    lstrcat( pszPathBuf, TEXT("\\RAS\\") );

    return TRUE;
}


BOOL
GetPhonebookPath(
    IN  PBUSER* pUser,
    OUT TCHAR** ppszPath,
    OUT DWORD*  pdwPhonebookMode )

    /* Loads caller's '*ppszPath', with the full path to the user's phonebook
    ** file.  Caller's '*pdwPhonebookMode' is set to the mode, system,
    ** personal, or alternate.  'PUser' is the current user preferences.
    **
    ** Returns true if successful, false otherwise.  It is caller's
    ** responsibility to Free the returned string.
    */
{
    TCHAR szPath[ MAX_PATH + 1 ];

    if (pUser)
    {
        if (pUser->dwPhonebookMode == PBM_Personal)
        {
            GetPersonalPhonebookPath( pUser->pszPersonalFile, szPath );
            *ppszPath = StrDup( szPath );
            *pdwPhonebookMode = PBM_Personal;
            return TRUE;
        }
        else if (pUser->dwPhonebookMode == PBM_Alternate)
        {
            *ppszPath = StrDup( pUser->pszAlternatePath );
            *pdwPhonebookMode = PBM_Alternate;
            return TRUE;
        }
    }

    if (!GetPublicPhonebookPath( szPath ))
        return FALSE;

    *ppszPath = StrDup( szPath );
    *pdwPhonebookMode = PBM_System;
    return TRUE;
}


#if 0
DWORD
GetPhonebookVersion(
    IN  TCHAR*  pszPhonebookPath,
    IN  PBUSER* pUser,
    OUT DWORD*  pdwVersion )

    /* Loads caller's '*pdwVersion' with the phonebook version number of
    ** phonebook 'pszPhonebookPath'.  'PszPhonebookPath' can be NULL
    ** indicating the default phonebook.
    **
    ** Version identified:
    **   NT 3.51 and before = 0x0351 *
    **   NT 4.00 and later  = 0x0401 **
    **
    ** *  It is not necessary to distinguish NT 3.1 phonebooks from NT 3.51
    **    as the difference is added fields that assume default values when
    **    the older phonebook is loaded.
    **
    ** ** The RAS APIs in NT 4.00 have version 4.01 because they are extended
    **    beyond what shipped in Win95 which are the 4.00 set.
    **
    ** Returns 0 if successful or a non-0 error code.
    */
{
    DWORD  dwErr;
    PBFILE file;

    dwErr = ReadPhonebookFile(
        pszPhonebookPath, pUser, TEXT(GLOBALSECTIONNAME),
        RPBF_ReadOnly | RPBF_NoList, &file );

    if (dwErr != 0)
        return dwErr;

    if (RasfileFindSectionLine( file.hrasfile, GLOBALSECTIONNAME, TRUE ))
    {
        /* The global [.] section exists, so it's an old phonebook.
        */
        *pdwVersion = 0x351;
    }
    else
        *pdwVersion = 0x401;

    return 0;
}
#endif


BOOL
GetPersonalPhonebookPath(
    IN  TCHAR* pszFile,
    OUT TCHAR* pszPathBuf )

    /* Loads caller's 'pszPathBuf' (should have length MAX_PATH + 1) with the
    ** path to the personal phonebook, e.g. c:\nt\system32\ras\stevec.pbk".
    ** 'PszFile' is the filename of the personal phonebook.
    **
    ** Returns true if successful, false otherwise.
    */
{
    if (!GetPhonebookDirectory( pszPathBuf ))
        return FALSE;

    lstrcat( pszPathBuf, pszFile );

    return TRUE;
}


BOOL
GetPublicPhonebookPath(
    OUT TCHAR* pszPathBuf )

    /* Loads caller's 'pszPathBuf' (should have length MAX_PATH + 1) with the
    ** path to the system phonebook, e.g. c:\nt\system32\ras\rasphone.pbk".
    **
    ** Returns true if successful, false otherwise.
    */
{
    if (!GetPhonebookDirectory( pszPathBuf ))
        return FALSE;

    lstrcat( pszPathBuf, TEXT("rasphone.pbk") );

    return TRUE;
}


DWORD
InitializePbk(
    void )

    /* Initialize the PBK library.  This routine must be called before any
    ** other PBK library calls.  See also TerminatePbk.
    */
{
    DWORD dwErr = NO_ERROR;
    
    if (!g_hmutexPb)
    {
        DWORD dwErr;
        SECURITY_ATTRIBUTES sa;
        SECURITY_DESCRIPTOR sd;
        PACL pDacl = NULL;
        BOOL bPresent = FALSE, bDefault = FALSE;

        /* The mutex must be accessible by everyone, even processes with
        ** security privilege lower than the creator.
        */
        dwErr = InitSecurityDescriptor( &sd );
        if (dwErr != 0)
            return dwErr;

        sa.nLength = sizeof(SECURITY_ATTRIBUTES) ;
        sa.lpSecurityDescriptor = &sd;
        sa.bInheritHandle = TRUE ;

        g_hmutexPb = CreateMutexA( &sa, FALSE, PBMUTEXNAME );
        if (!g_hmutexPb)
        {
            dwErr = GetLastError();
        }

        if ((GetSecurityDescriptorDacl(&sd, &bPresent, &pDacl, &bDefault)) &&
            (bPresent)                                                     &&
            (!bDefault))
        {
            LocalFree(pDacl);
        }
    }

    return dwErr;
}


DWORD
InitPersonalPhonebook(
    OUT TCHAR** ppszFile )

    /* Creates a new personal phonebook file and initializes it to the current
    ** contents of the public phonebook file.  Returns the address of the file
    ** name in caller's '*ppszfile' which is caller's responsibility to Free.
    **
    ** Returns 0 if succesful, otherwise a non-0 error code.
    */
{
    TCHAR  szUser[ UNLEN + 1 ];
    DWORD  cbUser = UNLEN + 1;
    TCHAR  szPath[ MAX_PATH + 1 ];
    TCHAR* pszDirEnd;
    LONG   lTry = -1;

    /* Find a name for the personal phonebook that is derived from the
    ** username and does not already exist.
    */
    if (!GetUserName( szUser, &cbUser ))
        return ERROR_NO_SUCH_USER;

    if (!GetPhonebookDirectory( szPath ))
        return ERROR_PATH_NOT_FOUND;

    pszDirEnd = &szPath[ lstrlen( szPath ) ];

    do
    {
        DWORD dwErr;

        dwErr = GetPersonalPhonebookFile( szUser, lTry++, pszDirEnd );
        if (dwErr != 0)
            return dwErr;
    }
    while (FileExists( szPath ));

    /* Copy the public phonebook to the new personal phonebook.
    */
    {
        TCHAR szPublicPath[ MAX_PATH + 1 ];

        if (!GetPublicPhonebookPath( szPublicPath ))
            return ERROR_PATH_NOT_FOUND;

        if (!CopyFile( szPublicPath, szPath, TRUE ))
            return GetLastError();
    }

    *ppszFile = StrDup( pszDirEnd );
    if (!*ppszFile)
        return ERROR_NOT_ENOUGH_MEMORY;

    return 0;
}


//* InitSecurityDescriptor()
//
// Description: This procedure will set up the WORLD security descriptor that
//      is used in creation of all rasman objects.
//
// Returns: SUCCESS
//      non-zero returns from security functions
//
// (Taken from RASMAN)
//*
DWORD
InitSecurityDescriptor(
    PSECURITY_DESCRIPTOR pSecurityDescriptor )
{
    DWORD    dwRetCode;
    DWORD    cbDaclSize;
    PULONG   pSubAuthority;
    PSID     pRasmanObjSid    = NULL;
    PACL     pDacl        = NULL;
    SID_IDENTIFIER_AUTHORITY SidIdentifierWorldAuth
                  = SECURITY_WORLD_SID_AUTHORITY;


    // The do - while(FALSE) statement is used so that the break statement
    // maybe used insted of the goto statement, to execute a clean up and
    // and exit action.
    //
    do {
    dwRetCode = SUCCESS;

        // Set up the SID for the admins that will be allowed to have
    // access. This SID will have 1 sub-authorities
    // SECURITY_BUILTIN_DOMAIN_RID.
        //
    pRasmanObjSid = (PSID)LocalAlloc( LPTR, GetSidLengthRequired(1) );

    if ( pRasmanObjSid == NULL ) {
        dwRetCode = GetLastError() ;
        break;
    }

    if ( !InitializeSid( pRasmanObjSid, &SidIdentifierWorldAuth, 1) ) {
        dwRetCode = GetLastError();
        break;
    }

        // Set the sub-authorities
        //
    pSubAuthority = GetSidSubAuthority( pRasmanObjSid, 0 );
    *pSubAuthority = SECURITY_WORLD_RID;

    // Set up the DACL that will allow all processeswith the above SID all
    // access. It should be large enough to hold all ACEs.
        //
        cbDaclSize = sizeof(ACCESS_ALLOWED_ACE) +
             GetLengthSid(pRasmanObjSid) +
             sizeof(ACL);

        if ( (pDacl = (PACL)LocalAlloc( LPTR, cbDaclSize ) ) == NULL ) {
        dwRetCode = GetLastError ();
        break;
    }

        if ( !InitializeAcl( pDacl,  cbDaclSize, ACL_REVISION2 ) ) {
        dwRetCode = GetLastError();
        break;
    }

        // Add the ACE to the DACL
        //
        if ( !AddAccessAllowedAce( pDacl,
                       ACL_REVISION2,
                   STANDARD_RIGHTS_ALL | SPECIFIC_RIGHTS_ALL,
                   pRasmanObjSid )) {
        dwRetCode = GetLastError();
        break;
    }

        // Create the security descriptor an put the DACL in it.
        //
    if ( !InitializeSecurityDescriptor( pSecurityDescriptor, 1 )){
        dwRetCode = GetLastError();
        break;
        }

    if ( !SetSecurityDescriptorDacl( pSecurityDescriptor,
                     TRUE,
                     pDacl,
                     FALSE ) ){
        dwRetCode = GetLastError();
        break;
    }


    // Set owner for the descriptor
    //
    if ( !SetSecurityDescriptorOwner( pSecurityDescriptor,
                      //pRasmanObjSid,
                      NULL,
                      FALSE) ){
        dwRetCode = GetLastError();
        break;
    }


    // Set group for the descriptor
    //
    if ( !SetSecurityDescriptorGroup( pSecurityDescriptor,
                      //pRasmanObjSid,
                      NULL,
                      FALSE) ){
        dwRetCode = GetLastError();
        break;
    }
    } while( FALSE );

    if (pRasmanObjSid)
    {
        LocalFree(pRasmanObjSid);
    }
    //if (pDacl)
    //{
    //    LocalFree(pDacl);
    //}
    
    return( dwRetCode );
}


#if 0
DWORD
InsertBinary(
    IN HRASFILE h,
    IN CHAR*    pszKey,
    IN BYTE*    pData,
    IN DWORD    cbData )

    /* Insert key/value line(s) with key 'pszKey' and value hex dump 'cbData'
    ** of 'pData' at the current line in file 'h'.  The data will be split
    ** over multiple same-named keys, if necessary.
    **
    ** Returns 0 if successful, otherwise a non-zero error code.  The current
    ** line is the one added.
    */
{
    DWORD dwErr;
    BYTE* p;
    DWORD c;

    p = pData;
    c = 0;

    while (cbData)
    {
        if (cbData >= IB_BytesPerLine)
            c = IB_BytesPerLine;
        else
            c = cbData;

        dwErr = InsertBinaryChunk( h, pszKey, p, c );
        if (dwErr != 0)
            return dwErr;

        p += c;
        cbData -= c;
    }

    return 0;
}


DWORD
InsertBinaryChunk(
    IN HRASFILE h,
    IN CHAR*    pszKey,
    IN BYTE*    pData,
    IN DWORD    cbData )

    /* Insert key/value line(s) with key 'pszKey' and value hex dump 'cbData'
    ** of 'pData' at the current line in file 'h'.  The data will be split
    ** over multiple same-named keys, if necessary.
    **
    ** Returns 0 if successful, otherwise a non-zero error code.  The current
    ** line is the one added.
    */
{

    CHAR  szBuf[ (IB_BytesPerLine * 2) + 1 ];
    CHAR* pszBuf;
    BOOL  fStatus;

    ASSERT(cbData<=IB_BytesPerLine);

    szBuf[ 0 ] = '\0';
    for (pszBuf = szBuf; cbData; ++pData, --cbData)
    {
        *pszBuf++ = HexChar( (BYTE )(*pData / 16) );
        *pszBuf++ = HexChar( (BYTE )(*pData % 16) );
    }
    *pszBuf = '\0';

    return InsertStringA( h, pszKey, szBuf );
}
#endif


DWORD
InsertDeviceList(
    IN HRASFILE h,
    IN PBENTRY* ppbentry,
    IN PBLINK*  ppblink )

    /* Inserts the list of devices associated with link 'ppblink' of phone
    ** book entry 'ppbentry' at the current line of file 'h'.
    **
    ** Returns 0 if successful, otherwise a non-zero error code.
    */
{
    DWORD dwErr;
    PBDEVICETYPE type;

    type = ppblink->pbport.pbdevicetype;

    if (type == PBDT_Isdn)
    {
        /* ISDN ports use a single device with the same name as the media.
        */
        if ((dwErr = InsertGroup(
                h, GROUPKEY_Device, TEXT(ISDN_TXT) )) != 0)
        {
            return dwErr;
        }

        if (DtlGetNodes( ppblink->pdtllistPhoneNumbers ) == 0)
        {
            if ((dwErr = InsertString( h, KEY_PhoneNumber, NULL )) != 0)
                return dwErr;
        }
        else if ((dwErr = InsertStringList(
                h, KEY_PhoneNumber, ppblink->pdtllistPhoneNumbers )) != 0)
        {
            return dwErr;
        }

        if ((dwErr = InsertFlag(
                h, KEY_PromoteAlternates, ppblink->fPromoteHuntNumbers )) != 0)
        {
            return dwErr;
        }

        if ((dwErr = InsertLong( h, KEY_LineType, ppblink->lLineType )) != 0)
            return dwErr;

        if ((dwErr = InsertFlag( h, KEY_Fallback, ppblink->fFallback )) != 0)
            return dwErr;

        if ((dwErr = InsertFlag(
                h, KEY_Compression, ppblink->fCompression )) != 0)
        {
            return dwErr;
        }

        if ((dwErr = InsertLong(
                h, KEY_Channels, ppblink->lChannels )) != 0)
        {
            return dwErr;
        }

        if ((dwErr = InsertFlag(
                h, KEY_ProprietaryIsdn, ppblink->fProprietaryIsdn )) != 0)
        {
            return dwErr;
        }
    }
    else if (type == PBDT_X25)
    {
        /* Native X.25 ports are assumed to use a single device with the same
        ** name as the media, i.e. "x25".
        */
        if ((dwErr = InsertGroup( h, GROUPKEY_Device, TEXT(X25_TXT) )) != 0)
            return dwErr;

        if ((dwErr = InsertString(
                h, KEY_X25_Address, ppbentry->pszX25Address )) != 0)
        {
            return dwErr;
        }

        if ((dwErr = InsertString(
                h, KEY_X25_UserData, ppbentry->pszX25UserData )) != 0)
        {
            return dwErr;
        }

        if ((dwErr = InsertString(
                h, KEY_X25_Facilities, ppbentry->pszX25Facilities )) != 0)
        {
            return dwErr;
        }
    }
    else if (type == PBDT_Other)
    {
        /* "Other" ports use a single device with the same name as the media.
        */
        if ((dwErr = InsertGroup(
                h, GROUPKEY_Device, ppblink->pbport.pszMedia )) != 0)
        {
            return dwErr;
        }

        if (DtlGetNodes( ppblink->pdtllistPhoneNumbers ) == 0)
        {
            if ((dwErr = InsertString( h, KEY_PhoneNumber, NULL )) != 0)
                return dwErr;
        }
        else if ((dwErr = InsertStringList(
                h, KEY_PhoneNumber, ppblink->pdtllistPhoneNumbers )) != 0)
        {
            return dwErr;
        }

        if ((dwErr = InsertFlag(
                h, KEY_PromoteAlternates, ppblink->fPromoteHuntNumbers )) != 0)
        {
            return dwErr;
        }
    }
    else
    {
        /* Serial ports may involve multiple devices, specifically a modem, an
        ** X.25 dialup PAD, and a post-connect switch.  Pre-connect script is
        ** preserved, though no longer offered by UI.
        */
        if (ppbentry->dwScriptModeBefore != SM_None)
        {
            if ((dwErr = InsertGroup(
                    h, GROUPKEY_Device, TEXT(MXS_SWITCH_TXT) )) != 0)
            {
                return dwErr;
            }

            if (ppbentry->dwScriptModeBefore == SM_Terminal)
            {
                if ((dwErr = InsertStringA(
                        h, KEY_Type, SM_TerminalText )) != 0)
                {
                    return dwErr;
                }
            }
            else
            {
                ASSERT(ppbentry->dwScriptModeBefore==SM_Script);

                if ((dwErr = InsertString(
                        h, KEY_Type, ppbentry->pszScriptBefore )) != 0)
                {
                    return dwErr;
                }
            }
        }

        if (type == PBDT_Null)
        {
            if ((dwErr = InsertGroup(
                    h, GROUPKEY_Device, TEXT(MXS_NULL_TXT) )) != 0)
            {
                return dwErr;
            }
        }

        if (type == PBDT_Modem)
        {
            if ((dwErr = InsertGroup(
                    h, GROUPKEY_Device, TEXT(MXS_MODEM_TXT) )) != 0)
            {
                return dwErr;
            }

            if (DtlGetNodes( ppblink->pdtllistPhoneNumbers ) == 0)
            {
                if ((dwErr = InsertString( h, KEY_PhoneNumber, NULL )) != 0)
                    return dwErr;
            }
            else if ((dwErr = InsertStringList(
                    h, KEY_PhoneNumber, ppblink->pdtllistPhoneNumbers )) != 0)
            {
                return dwErr;
            }

            if ((dwErr = InsertFlag(
                    h, KEY_PromoteAlternates,
                    ppblink->fPromoteHuntNumbers )) != 0)
            {
                return dwErr;
            }

            if (ppblink->pbport.fMxsModemPort)
            {
                if ((dwErr = InsertFlag(
                        h, KEY_ManualDial, ppblink->fManualDial )) != 0)
                {
                    return dwErr;
                }
            }

            if ((dwErr = InsertFlag(
                    h, KEY_HwFlow, ppblink->fHwFlow )) != 0)
            {
                return dwErr;
            }

            if ((dwErr = InsertFlag(
                    h, KEY_Ec, ppblink->fEc )) != 0)
            {
                return dwErr;
            }

            if ((dwErr = InsertFlag(
                    h, KEY_Ecc, ppblink->fEcc )) != 0)
            {
                return dwErr;
            }

            if ((dwErr = InsertFlag(
                    h, KEY_Speaker, ppblink->fSpeaker )) != 0)
            {
                return dwErr;
            }

#if 0
            if (!ppblink->pbport.fMxsModemPort)
            {
                if (ppblink->pTapiBlob)
                {
                    if ((dwErr = InsertBinary(
                            h, KEY_TapiBlob,
                            ppblink->pTapiBlob, ppblink->cbTapiBlob )) != 0)
                    {
                        return dwErr;
                    }
                }
            }
#endif
        }

        if (type == PBDT_Pad
            || (type == PBDT_Modem && ppbentry->pszX25Network))
        {
            if ((dwErr = InsertGroup(
                    h, GROUPKEY_Device, TEXT(MXS_PAD_TXT) )) != 0)
            {
                return dwErr;
            }

            if ((dwErr = InsertString(
                    h, KEY_PAD_Type, ppbentry->pszX25Network )) != 0)
            {
                return dwErr;
            }

            if ((dwErr = InsertString(
                    h, KEY_PAD_Address, ppbentry->pszX25Address )) != 0)
            {
                return dwErr;
            }

            if ((dwErr = InsertString(
                    h, KEY_PAD_UserData, ppbentry->pszX25UserData )) != 0)
            {
                return dwErr;
            }

            if ((dwErr = InsertString(
                    h, KEY_PAD_Facilities, ppbentry->pszX25Facilities )) != 0)
            {
                return dwErr;
            }
        }

        if (ppbentry->dwScriptModeAfter != SM_None)
        {
            if ((dwErr = InsertGroup(
                    h, GROUPKEY_Device, TEXT(MXS_SWITCH_TXT) )) != 0)
            {
                return dwErr;
            }

            if (ppbentry->dwScriptModeAfter == SM_Terminal)
            {
                if ((dwErr = InsertStringA(
                        h, KEY_Type, SM_TerminalText )) != 0)
                {
                    return dwErr;
                }
            }
            else
            {
                ASSERT(ppbentry->dwScriptModeAfter==SM_Script);

                if ((dwErr = InsertString(
                        h, KEY_Type, ppbentry->pszScriptAfter )) != 0)
                {
                    return dwErr;
                }
            }
        }
    }

    return 0;
}


DWORD
InsertFlag(
    IN HRASFILE h,
    IN CHAR*    pszKey,
    IN BOOL     fValue )

    /* Insert a key/value line after the current line in file 'h'.  The
    ** inserted line has a key of 'pszKey' and a value of "1" if 'fValue' is
    ** true or "0" otherwise.  If 'pszKey' is NULL a blank line is appended.
    **
    ** Returns 0 if successful, otherwise a non-zero error code.  The current
    ** line is the one added.
    */
{
    return InsertStringA( h, pszKey, (fValue) ? "1" : "0" );
}


DWORD
InsertGroup(
    IN HRASFILE h,
    IN CHAR*    pszGroupKey,
    IN TCHAR*   pszValue )

    /* Insert a blank line and a group header with group key 'pszGroupKey' and
    ** value 'pszValue' after the current line in file 'h'.
    **
    ** Returns 0 if successful, otherwise a non-zero error code.  The current
    ** line is the added group header.
    */
{
    DWORD dwErr;

    if ((dwErr = InsertString( h, NULL, NULL )) != 0)
        return dwErr;

    if ((dwErr = InsertString( h, pszGroupKey, pszValue )) != 0)
        return dwErr;

    return 0;
}


DWORD
InsertLong(
    IN HRASFILE h,
    IN CHAR*    pszKey,
    IN LONG     lValue )

    /* Insert a key/value line after the current line in file 'h'.  The
    ** inserted line has a key of 'pszKey' and a value of 'lValue'.  If
    ** 'pszKey' is NULL a blank line is appended.
    **
    ** Returns 0 if successful, otherwise a non-zero error code.  The current
    ** line is the one added.
    */
{
    CHAR szNum[ 33 + 1 ];

    _ltoa( lValue, szNum, 10 );

    return InsertStringA( h, pszKey, szNum );
}


DWORD
InsertSection(
    IN HRASFILE h,
    IN TCHAR*   pszSectionName )

    /* Insert a section header with name 'pszSectionName' and a trailing blank
    ** line in file 'h' after the current line.
    **
    ** Returns 0 if successful, otherwise a non-zero error code.  The current
    ** line is the added section header.
    */
{
    DWORD dwErr;
    CHAR* pszSectionNameA;
    BOOL  fStatus;

    ASSERT(pszSectionName);

    if ((dwErr = InsertString( h, NULL, NULL )) != 0)
        return dwErr;

    pszSectionNameA = StrDupAFromT( pszSectionName );
    if (!pszSectionNameA)
        return ERROR_NOT_ENOUGH_MEMORY;

    fStatus = RasfilePutSectionName( h, pszSectionNameA );

    Free( pszSectionNameA );

    if (!fStatus)
        return ERROR_NOT_ENOUGH_MEMORY;

    if ((dwErr = InsertString( h, NULL, NULL )) != 0)
        return dwErr;

    RasfileFindFirstLine( h, RFL_SECTION, RFS_SECTION );

    return 0;
}


DWORD
InsertString(
    IN HRASFILE h,
    IN CHAR*    pszKey,
    IN TCHAR*   pszValue )

    /* Insert a key/value line with key 'pszKey' and value 'pszValue' after
    ** the current line in file 'h'.  If 'pszKey' is NULL a blank line is
    ** appended.
    **
    ** Returns 0 if successful, otherwise a non-zero error code.  The current
    ** line is the one added.
    */
{
    BOOL  fStatus;
    CHAR* pszValueA;

    if (pszValue)
    {
        pszValueA = StrDupAFromT( pszValue );

        if (!pszValueA)
            return ERROR_NOT_ENOUGH_MEMORY;
    }
    else
        pszValueA = NULL;

    fStatus = InsertStringA( h, pszKey, pszValueA );

    Free0( pszValueA );
    return fStatus;
}


DWORD
InsertStringA(
    IN HRASFILE h,
    IN CHAR*    pszKey,
    IN CHAR*    pszValue )

    /* Insert a key/value line with key 'pszKey' and value 'pszValue' after
    ** the current line in file 'h'.  If 'pszKey' is NULL a blank line is
    ** appended.
    **
    ** Returns 0 if successful, otherwise a non-zero error code.  The current
    ** line is the one added.
    */
{
    if (!RasfileInsertLine( h, "", FALSE ))
        return ERROR_NOT_ENOUGH_MEMORY;

    if (!RasfileFindNextLine( h, RFL_ANY, RFS_FILE ))
        RasfileFindFirstLine( h, RFL_ANY, RFS_FILE );

    if (pszKey)
    {
        CHAR* pszValueA;

        if (!pszValue)
            pszValue = "";

        if (!RasfilePutKeyValueFields( h, pszKey, pszValue ))
            return ERROR_NOT_ENOUGH_MEMORY;
    }

    return 0;
}


DWORD
InsertStringList(
    IN HRASFILE h,
    IN CHAR*    pszKey,
    IN DTLLIST* pdtllistValues )

    /* Insert key/value lines with key 'pszKey' and values from
    ** 'pdtllistValues' after the current line in file 'h'.
    **
    ** Returns 0 if successful, otherwise a non-zero error code.  The current
    ** line is the last one added.
    */
{
    DTLNODE* pdtlnode;

    for (pdtlnode = DtlGetFirstNode( pdtllistValues );
         pdtlnode;
         pdtlnode = DtlGetNextNode( pdtlnode ))
    {
        CHAR* pszValueA;
        BOOL  fStatus;

        if (!RasfileInsertLine( h, "", FALSE ))
            return ERROR_NOT_ENOUGH_MEMORY;

        if (!RasfileFindNextLine( h, RFL_ANY, RFS_FILE ))
            RasfileFindFirstLine( h, RFL_ANY, RFS_FILE );

        pszValueA = StrDupAFromT( (TCHAR* )DtlGetData( pdtlnode ) );
        if (!pszValueA)
            return ERROR_NOT_ENOUGH_MEMORY;

        fStatus = RasfilePutKeyValueFields( h, pszKey, pszValueA );

        Free( pszValueA );

        if (!fStatus)
            return ERROR_NOT_ENOUGH_MEMORY;
    }

    return 0;
}


BOOL
IsDeviceLine(
    IN CHAR* pszText )

    /* Returns true if the text of the line, 'pszText', indicates the line is
    ** a DEVICE subsection header, false otherwise.
    */
{
    return
        (StrNCmpA( pszText, GROUPID_Device, sizeof(GROUPID_Device) - 1 ) == 0);
}


BOOL
IsGroup(
    IN CHAR* pszText )

    /* Returns true if the text of the line, 'pszText', indicates the line is
    ** a valid subsection header, false otherwise.  The address of this
    ** routine is passed to the RASFILE library on RasFileLoad.
    */
{
    return IsMediaLine( pszText ) || IsDeviceLine( pszText );
}


BOOL
IsMediaLine(
    IN CHAR* pszText )

    /* Returns true if the text of the line, 'pszText', indicates the line is
    ** a MEDIA subsection header, false otherwise.
    */
{
    return
        (StrNCmpA( pszText, GROUPID_Media, sizeof(GROUPID_Media) - 1 ) == 0);
}


DWORD
ModifyEntryList(
    IN PBFILE* pFile )

    /* Update all dirty entries in phone book file 'pFile'.
    **
    ** Returns 0 if successful, otherwise a non-zero error code.
    */
{
    DWORD    dwErr = 0;
    DTLNODE* pdtlnodeEntry;
    DTLNODE* pdtlnodeLink;
    HRASFILE h;

    h = pFile->hrasfile;

    for (pdtlnodeEntry = DtlGetFirstNode( pFile->pdtllistEntries );
         pdtlnodeEntry;
         pdtlnodeEntry = DtlGetNextNode( pdtlnodeEntry ))
    {
        PBENTRY* ppbentry = (PBENTRY* )DtlGetData( pdtlnodeEntry );

        if (!ppbentry->fDirty || ppbentry->fCustom)
            continue;

        /* Delete the current version of the entry, if any.
        */
        {
            CHAR* pszEntryNameA;

            ASSERT(ppbentry->pszEntryName);
            pszEntryNameA = StrDupAFromT( ppbentry->pszEntryName );
            if (!pszEntryNameA)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            if (RasfileFindSectionLine( h, pszEntryNameA, TRUE ))
                DeleteCurrentSection( h );

            Free( pszEntryNameA );
        }

        /* Append a blank line followed by a section header and the entry
        ** description to the end of the file.
        */
        RasfileFindLastLine( h, RFL_ANY, RFS_FILE );

        if ((dwErr = InsertSection( h, ppbentry->pszEntryName )) != 0)
            break;

        if ((dwErr = InsertString(
                h, KEY_Description, ppbentry->pszDescription )) != 0)
        {
            break;
        }

        if ((dwErr = InsertFlag(
                h, KEY_AutoLogon, ppbentry->fAutoLogon )) != 0)
        {
            break;
        }

        if ((dwErr = InsertLong(
                h, KEY_UID,
                (LONG )ppbentry->dwDialParamsUID )) != 0)
        {
            break;
        }

        if ((dwErr = InsertFlag(
                h, KEY_UsePwForNetwork, ppbentry->fUsePwForNetwork )) != 0)
        {
            break;
        }

        if ((dwErr = InsertLong(
                h, KEY_BaseProtocol,
                (LONG )ppbentry->dwBaseProtocol )) != 0)
        {
            break;
        }

        if ((dwErr = InsertLong(
                h, KEY_Authentication,
                (LONG )ppbentry->dwAuthentication )) != 0)
        {
            break;
        }

        if ((dwErr = InsertLong(
                h, KEY_ExcludedProtocols,
                (LONG )ppbentry->dwfExcludedProtocols )) != 0)
        {
            break;
        }

        if ((dwErr = InsertFlag(
                h, KEY_LcpExtensions,
                ppbentry->fLcpExtensions )) != 0)
        {
            break;
        }

        if ((dwErr = InsertLong(
                h, KEY_DataEncryption,
                ppbentry->dwDataEncryption )) != 0)
        {
            break;
        }

        if ((dwErr = InsertFlag(
                h, KEY_SwCompression,
                ppbentry->fSwCompression )) != 0)
        {
            break;
        }

        if ((dwErr = InsertFlag(
                h, KEY_UseCountryAndAreaCodes,
                ppbentry->fUseCountryAndAreaCode )) != 0)
        {
            break;
        }

        if ((dwErr = InsertString(
                h, KEY_AreaCode,
                ppbentry->pszAreaCode )) != 0)
        {
            break;
        }

        if ((dwErr = InsertLong(
                h, KEY_CountryID,
                (LONG )ppbentry->dwCountryID )) != 0)
        {
            break;
        }

        if ((dwErr = InsertLong(
                h, KEY_CountryCode,
                (LONG )ppbentry->dwCountryCode )) != 0)
        {
            break;
        }

        if ((dwErr = InsertFlag(
                h, KEY_SkipNwcWarning,
                ppbentry->fSkipNwcWarning )) != 0)
        {
            break;
        }

        if ((dwErr = InsertFlag(
                h, KEY_SkipDownLevelDialog,
                ppbentry->fSkipDownLevelDialog )) != 0)
        {
            break;
        }

        if ((dwErr = InsertLong(
                h, KEY_DialMode,
                (LONG )ppbentry->dwDialMode )) != 0)
        {
            break;
        }

        if ((dwErr = InsertLong(
                h, KEY_DialPercent,
                (LONG )ppbentry->dwDialPercent )) != 0)
        {
            break;
        }

        if ((dwErr = InsertLong(
                h, KEY_DialSeconds,
                (LONG )ppbentry->dwDialSeconds )) != 0)
        {
            break;
        }

        if ((dwErr = InsertLong(
                h, KEY_HangUpPercent,
                (LONG )ppbentry->dwHangUpPercent )) != 0)
        {
            break;
        }

        if ((dwErr = InsertLong(
                h, KEY_HangUpSeconds,
                (LONG )ppbentry->dwHangUpSeconds )) != 0)
        {
            break;
        }

        if ((dwErr = InsertLong(
                h, KEY_OverridePref,
                ppbentry->dwfOverridePref )) != 0)
        {
            break;
        }

        if ((dwErr = InsertLong(
                h, KEY_RedialAttempts,
                ppbentry->dwRedialAttempts )) != 0)
        {
            break;
        }

        if ((dwErr = InsertLong(
                h, KEY_RedialSeconds,
                ppbentry->dwRedialSeconds )) != 0)
        {
            break;
        }

        if ((dwErr = InsertLong(
                h, KEY_IdleDisconnectSeconds,
                ppbentry->dwIdleDisconnectSeconds )) != 0)
        {
            break;
        }

        if ((dwErr = InsertFlag(
                h, KEY_RedialOnLinkFailure,
                ppbentry->fRedialOnLinkFailure )) != 0)
        {
            break;
        }

        if ((dwErr = InsertFlag(
                h, KEY_PopupOnTopWhenRedialing,
                ppbentry->fPopupOnTopWhenRedialing )) != 0)
        {
            break;
        }

        if ((dwErr = InsertLong(
                h, KEY_CallbackMode,
                ppbentry->dwCallbackMode )) != 0)
        {
            break;
        }

        if ((dwErr = InsertFlag(
                h, KEY_SecureLocalFiles,
                ppbentry->fSecureLocalFiles )) != 0)
        {
            break;
        }

        if ((dwErr = InsertString(
                h, KEY_CustomDialDll,
                ppbentry->pszCustomDialDll )) != 0)
        {
            return dwErr;
        }

        if ((dwErr = InsertString(
                h, KEY_CustomDialFunc,
                ppbentry->pszCustomDialFunc )) != 0)
        {
            return dwErr;
        }

        if ((dwErr = InsertLong(
                h, KEY_AuthRestrictions,
                ppbentry->dwAuthRestrictions )) != 0)
        {
            return dwErr;
        }

        if ((dwErr = InsertFlag(
                h, KEY_AuthenticateServer,
                ppbentry->fAuthenticateServer )) != 0)
        {
            return dwErr;
        }

        /* Insert the IP addressing parameters for both PPP/SLIP.
        */
        if ((dwErr = InsertFlag(
                h, KEY_IpPrioritizeRemote,
                ppbentry->fIpPrioritizeRemote )) != 0)
        {
            return dwErr;
        }

        if ((dwErr = InsertFlag(
                h, KEY_IpHeaderCompression,
                ppbentry->fIpHeaderCompression )) != 0)
        {
            return dwErr;
        }

        if ((dwErr = InsertString(
                h, KEY_IpAddress,
                (ppbentry->pszIpAddress)
                    ? ppbentry->pszIpAddress : TEXT("0.0.0.0") )) != 0)
        {
            return dwErr;
        }

        if ((dwErr = InsertString(
                h, KEY_IpDnsAddress,
                (ppbentry->pszIpDnsAddress)
                    ? ppbentry->pszIpDnsAddress : TEXT("0.0.0.0") )) != 0)
        {
            return dwErr;
        }

        if ((dwErr = InsertString(
                h, KEY_IpDns2Address,
                (ppbentry->pszIpDns2Address)
                    ? ppbentry->pszIpDns2Address : TEXT("0.0.0.0") )) != 0)
        {
            return dwErr;
        }

        if ((dwErr = InsertString(
                h, KEY_IpWinsAddress,
                (ppbentry->pszIpWinsAddress)
                    ? ppbentry->pszIpWinsAddress : TEXT("0.0.0.0") )) != 0)
        {
            return dwErr;
        }

        if ((dwErr = InsertString(
                h, KEY_IpWins2Address,
                (ppbentry->pszIpWins2Address)
                    ? ppbentry->pszIpWins2Address : TEXT("0.0.0.0") )) != 0)
        {
            return dwErr;
        }

        /* Next two actually used for PPP only.
        */
        if ((dwErr = InsertLong(
                h, KEY_IpAddressSource,
                ppbentry->dwIpAddressSource )) != 0)
        {
            return dwErr;
        }

        if ((dwErr = InsertLong(
                h, KEY_IpNameSource,
                ppbentry->dwIpNameSource )) != 0)
        {
            return dwErr;
        }

        /* Next one actually used for SLIP only.
        */
        if ((dwErr = InsertLong(
                h, KEY_IpFrameSize, ppbentry->dwFrameSize )) != 0)
        {
            return dwErr;
        }

        /* Append the MEDIA subsections.
        */
        for (pdtlnodeLink = DtlGetFirstNode( ppbentry->pdtllistLinks );
             pdtlnodeLink;
             pdtlnodeLink = DtlGetNextNode( pdtlnodeLink ))
        {
            PBLINK* ppblink;
            TCHAR*  pszMedia;

            ppblink = (PBLINK* )DtlGetData( pdtlnodeLink );
            ASSERT(ppblink);
            pszMedia = ppblink->pbport.pszMedia;

            if ((dwErr = InsertGroup( h, GROUPKEY_Media, pszMedia )) != 0)
                break;

            if ((dwErr = InsertString(
                    h, KEY_Port, ppblink->pbport.pszPort )) != 0)
            {
                break;
            }

            if ((dwErr = InsertFlag(
                    h, KEY_OtherPortOk, ppblink->fOtherPortOk )) != 0)
            {
                break;
            }

            if (ppblink->pbport.pszDevice)
            {
                if ((dwErr = InsertString(
                        h, KEY_Device, ppblink->pbport.pszDevice )) != 0)
                {
                    break;
                }
            }

            if (ppblink->pbport.pbdevicetype == PBDT_Modem)
            {
                if ((dwErr = InsertLong(
                        h, KEY_InitBps, ppblink->dwBps )) != 0)
                {
                    break;
                }
            }

            /* Append the device subsection lines.
            */
            RasfileFindLastLine( h, RFL_ANYACTIVE, RFS_GROUP );

            if ((dwErr = InsertDeviceList( h, ppbentry, ppblink )) != 0)
                break;

            ppbentry->fDirty = FALSE;
        }
    }

    return dwErr;
}


#if 0
DWORD
ReadBinary(
    IN  HRASFILE h,
    IN  RFSCOPE  rfscope,
    IN  CHAR*    pszKey,
    OUT BYTE**   ppResult,
    OUT DWORD*   pcb )

    /* Utility routine to read a string value from the next line in the scope
    ** 'rfscope' with key 'pszKey'.  The result is placed in the allocated
    ** '*ppszResult' buffer.  The current line is reset to the start of the
    ** scope if the call was successful.
    **
    ** Returns 0 if successful, or a non-zero error code.  "Not found" is
    ** considered successful, in which case '*ppszResult' is not changed.
    ** Caller is responsible for freeing the returned '*ppszResult' buffer.
    */
{
    DWORD cb;
    DWORD cbLine;
    CHAR  szValue[ RAS_MAXLINEBUFLEN + 1 ];
    CHAR* pch;
    BYTE* pResult;
    BYTE* pLineResult;

    pResult = pLineResult = NULL;
    cb = cbLine = 0;

    while (RasfileFindNextKeyLine( h, pszKey, rfscope ))
    {
        if (!RasfileGetKeyValueFields( h, NULL, szValue ))
        {
            Free0( pResult );
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        cbLine = lstrlenA( szValue );
        if (cbLine & 1)
        {
            Free0( pResult );
            return ERROR_CORRUPT_PHONEBOOK;
        }
        cbLine /= 2;
        cb += cbLine;

        if (pResult)
            pResult = Realloc( pResult, cb );
        else
            pResult = Malloc( cb );

        if (!pResult)
            return ERROR_NOT_ENOUGH_MEMORY;

        pLineResult = pResult + (cb - cbLine);

        pch = szValue;
        while (*pch != '\0')
        {
            *pLineResult = HexValue( *pch++ ) * 16;
            *pLineResult += HexValue( *pch++ );
            ++pLineResult;
        }
    }

    RasfileFindFirstLine( h, RFL_ANY, rfscope );

    *ppResult = pResult;
    *pcb = cb;
    return 0;
}
#endif


DWORD
ReadDeviceList(
    IN     HRASFILE h,
    IN OUT PBENTRY* ppbentry,
    IN OUT PBLINK*  ppblink,
    IN     BOOL     fUnconfiguredPort,
    IN     BOOL*    pfDisableSpeaker )

    /* Reads all DEVICE subsections the section from the first subsection
    ** following the current position in phonebook file 'h'.  Caller's
    ** '*ppbentry' and '*ppblink' buffer is loaded with information extracted
    ** from the subsections.  'FUnconfiguredPort' is true if the port for the
    ** link was unconfigured.  In this case, data found/not-found by this
    ** routine helps determine whether the link was an MXS modem link.
    ** 'pfDisableSpeaker' is the address of the old speaker setting or NULL to
    ** read it from the file.
    **
    ** Returns 0 if successful, ERROR_CORRUPT_PHONEBOOK if any subsection
    ** other than a DEVICE subsection is encountered, or another non-0 error
    ** code indicating a fatal error.
    */
{
    INT   i;
    DWORD dwErr;
    CHAR  szValue[ RAS_MAXLINEBUFLEN + 1 ];
    BOOL  fPreconnectFound = FALSE;
    BOOL  fModemFound = FALSE;
    BOOL  fPadFound = FALSE;
    BOOL  fPostconnectFound = FALSE;

    /* For each subsection...
    */
    while (RasfileFindNextLine( h, RFL_GROUP, RFS_SECTION ))
    {
        CHAR* pszLine;

        pszLine = (CHAR* )RasfileGetLine( h );
        if (IsMediaLine( pszLine ))
        {
            RasfileFindPrevLine( h, RFL_ANY, RFS_SECTION );
            break;
        }

        if (!IsDeviceLine( pszLine ))
            return ERROR_CORRUPT_PHONEBOOK;

        RasfileGetKeyValueFields( h, NULL, szValue );

        TRACE1("Reading device group \"%s\"",szValue);

        if (lstrcmpiA( szValue, ISDN_TXT ) == 0)
        {
            /* It's an ISDN device.
            */
            ppblink->pbport.pbdevicetype = PBDT_Isdn;

            if ((dwErr = ReadStringList( h, RFS_GROUP,
                    KEY_PhoneNumber, &ppblink->pdtllistPhoneNumbers )) != 0)
            {
                return dwErr;
            }

            if ((dwErr = ReadFlag( h, RFS_GROUP,
                    KEY_PromoteAlternates,
                    &ppblink->fPromoteHuntNumbers )) != 0)
            {
                return dwErr;
            }

            if ((dwErr = ReadLong( h, RFS_GROUP,
                    KEY_LineType, &ppblink->lLineType )) != 0)
            {
                return dwErr;
            }

            if (ppblink->lLineType < 0 || ppblink->lLineType > 2)
                ppblink->lLineType = 0;

            if ((dwErr = ReadFlag( h, RFS_GROUP,
                    KEY_Fallback, &ppblink->fFallback )) != 0)
            {
                return dwErr;
            }

            /* Default is true if not found.  Default for new entry is false,
            ** so must set this before reading the entry.
            */
            ppblink->fProprietaryIsdn = TRUE;
            if ((dwErr = ReadFlag( h, RFS_GROUP,
                    KEY_ProprietaryIsdn, &ppblink->fProprietaryIsdn )) != 0)
            {
                return dwErr;
            }

            /* If "Channels" is not found assume it's not proprietary.  This
            ** covers a case that never shipped outside the NT group.
            */
            {
                LONG lChannels = -1;
                if ((dwErr = ReadLong( h, RFS_GROUP,
                        KEY_Channels, &lChannels )) != 0)
                {
                    return dwErr;
                }

                if (lChannels == -1)
                    ppblink->fProprietaryIsdn = FALSE;
                else
                    ppblink->lChannels = lChannels;
            }

            if ((dwErr = ReadFlag( h, RFS_GROUP,
                    KEY_Compression, &ppblink->fCompression )) != 0)
            {
                return dwErr;
            }
        }
        else if (lstrcmpiA( szValue, X25_TXT ) == 0)
        {
            /* It's a native X.25 device.
            */
            ppblink->pbport.pbdevicetype = PBDT_X25;

            if ((dwErr = ReadString( h, RFS_GROUP,
                    KEY_X25_Address, &ppbentry->pszX25Address )) != 0)
            {
                return dwErr;
            }

            if ((dwErr = ReadString( h, RFS_GROUP,
                    KEY_X25_UserData, &ppbentry->pszX25UserData )) != 0)
            {
                return dwErr;
            }

            if ((dwErr = ReadString( h, RFS_GROUP,
                    KEY_X25_Facilities, &ppbentry->pszX25Facilities )) != 0)
            {
                return dwErr;
            }
        }
        else if (lstrcmpiA( szValue, MXS_MODEM_TXT ) == 0)
        {
            /* It's a MODEM device.
            */
            ppblink->pbport.pbdevicetype = PBDT_Modem;

            if ((dwErr = ReadStringList( h, RFS_GROUP,
                    KEY_PhoneNumber, &ppblink->pdtllistPhoneNumbers )) != 0)
            {
                return dwErr;
            }

            if ((dwErr = ReadFlag( h, RFS_GROUP,
                    KEY_PromoteAlternates,
                    &ppblink->fPromoteHuntNumbers )) != 0)
            {
                return dwErr;
            }

            {
                BOOL fManualDial;

                fManualDial = (BOOL )-1;
                if ((dwErr = ReadFlag( h, RFS_GROUP,
                        KEY_ManualDial, &fManualDial )) != 0)
                {
                    return dwErr;
                }

                if (fManualDial != (BOOL )-1)
                {
                    if (fUnconfiguredPort)
                    {
                        /* Found "ManualDial" parameter so assume the
                        ** unconfigured port was once an MXS modem and mark
                        ** the link accordingly.
                        */
                        ppblink->pbport.fMxsModemPort = TRUE;
                    }

                    ppblink->fManualDial = fManualDial;
                }

                if ((dwErr = ReadFlag( h, RFS_GROUP,
                        KEY_HwFlow, &ppblink->fHwFlow )) != 0)
                {
                    return dwErr;
                }

                if ((dwErr = ReadFlag( h, RFS_GROUP,
                        KEY_Ec, &ppblink->fEc )) != 0)
                {
                    return dwErr;
                }

                if ((dwErr = ReadFlag( h, RFS_GROUP,
                        KEY_Ecc, &ppblink->fEcc )) != 0)
                {
                    return dwErr;
                }

                if (pfDisableSpeaker)
                    ppblink->fSpeaker = !*pfDisableSpeaker;
                else
                {
                    if ((dwErr = ReadFlag( h, RFS_GROUP,
                            KEY_Speaker, &ppblink->fSpeaker )) != 0)
                    {
                        return dwErr;
                    }
                }
            }
#if 0
            if (!ppblink->pbport.fMxsModemPort)
            {
                if ((dwErr = ReadBinary( h, RFS_GROUP, KEY_TapiBlob,
                        &ppblink->pTapiBlob, &ppblink->cbTapiBlob )) != 0)
                {
                    return dwErr;
                }
            }
#endif

            fModemFound = TRUE;
        }
        else if (lstrcmpiA( szValue, MXS_SWITCH_TXT ) == 0)
        {
            /* It's a SWITCH device.
            ** Read switch type string.
            */
            TCHAR* pszSwitch = NULL;

            if ((dwErr = ReadString( h, RFS_GROUP,
                    KEY_Type, &pszSwitch )) != 0)
            {
                return dwErr;
            }

            if (!pszSwitch)
            {
                /* It's a switch without a TYPE key.  This is allowed, but
                ** makes it a custom switch type.
                */
                ppbentry->fCustom = TRUE;
                break;
            }

            if (!fPreconnectFound && !fModemFound && !fPadFound)
            {
                /* It's the preconnect switch.
                */
                if (lstrcmpi( pszSwitch, TEXT(SM_TerminalText) ) == 0)
                {
                    ppbentry->dwScriptModeBefore = SM_Terminal;
                    Free( pszSwitch );
                }
                else
                {
                    ppbentry->dwScriptModeBefore = SM_Script;
                    ppbentry->pszScriptBefore = pszSwitch;
                }

                fPreconnectFound = TRUE;
            }
            else if (!fPostconnectFound)
            {
                /* It's the postconnect switch, i.e. a login script.
                */
                if (lstrcmpi( pszSwitch, TEXT(SM_TerminalText) ) == 0)
                {
                    ppbentry->dwScriptModeAfter = SM_Terminal;
                    Free( pszSwitch );
                }
                else
                {
                    ppbentry->dwScriptModeAfter = SM_Script;
                    ppbentry->pszScriptAfter = pszSwitch;
                }

                fPostconnectFound = TRUE;
            }
            else
            {
                /* It's a switch, but it's not in the normal pre- or post-
                ** connect positions.
                */
                ppbentry->fCustom = TRUE;
                Free( pszSwitch );
                return 0;
            }
        }
        else if (lstrcmpiA( szValue, MXS_PAD_TXT ) == 0)
        {
            /* It's an X.25 PAD device.
            */
            if (!fModemFound)
                ppblink->pbport.pbdevicetype = PBDT_Pad;

            if ((dwErr = ReadString( h, RFS_GROUP,
                    KEY_PAD_Type, &ppbentry->pszX25Network )) != 0)
            {
                return dwErr;
            }

            if ((dwErr = ReadString( h, RFS_GROUP,
                    KEY_PAD_Address, &ppbentry->pszX25Address )) != 0)
            {
                return dwErr;
            }

            if ((dwErr = ReadString( h, RFS_GROUP,
                    KEY_PAD_UserData, &ppbentry->pszX25UserData )) != 0)
            {
                return dwErr;
            }

            if ((dwErr = ReadString( h, RFS_GROUP,
                    KEY_PAD_Facilities, &ppbentry->pszX25Facilities )) != 0)
            {
                return dwErr;
            }

            fPadFound = TRUE;
        }
        else if (lstrcmpiA( szValue, MXS_NULL_TXT ) == 0)
        {
            /* It's a null device.
            ** Currently, there is no specific null information stored.
            */
            ppblink->pbport.pbdevicetype = PBDT_Null;
        }
        else
        {
            BOOL  fSame;
            CHAR* pszMedia;

            pszMedia = StrDupAFromT( ppblink->pbport.pszMedia );
            if (!pszMedia)
                return ERROR_NOT_ENOUGH_MEMORY;

            fSame = (lstrcmpiA( szValue, pszMedia ) == 0);

            Free( pszMedia );

            if (fSame)
            {
                /* It's an "other" device.
                */
                ppblink->pbport.pbdevicetype = PBDT_Other;

                /* Read only the phone number strings and hunt flag.
                */
                if ((dwErr = ReadStringList( h, RFS_GROUP,
                        KEY_PhoneNumber,
                        &ppblink->pdtllistPhoneNumbers )) != 0)
                {
                    return dwErr;
                }

                if ((dwErr = ReadFlag( h, RFS_GROUP,
                        KEY_PromoteAlternates,
                        &ppblink->fPromoteHuntNumbers )) != 0)
                {
                    return dwErr;
                }
            }
            else
            {
                /* Device name doesn't match media so it's a custom type, i.e.
                ** it wasn't created by us.
                */
                ppbentry->fCustom = TRUE;
            }
        }
    }

    if (ppblink->pbport.pbdevicetype == PBDT_None)
    {
        TRACE("No device section");
        return ERROR_CORRUPT_PHONEBOOK;
    }

    return 0;
}


DWORD
ReadEntryList(
    IN OUT PBFILE* pFile,
    IN     BOOL    fRouter )

    /* Creates the entry list 'pFile->pdtllistEntries' from previously loaded
    ** phonebook file 'pFile.hrasfile'.' 'FRouter' is true if router ports
    ** should be used for comparison/conversion of devices, false otherwise.
    **
    ** Returns 0 if successful, otherwise a non-0 error code.
    */
{
    DWORD    dwErr = 0;
    BOOL     fDirty = FALSE;
    DTLNODE* pdtlnodeEntry = NULL;
    DTLNODE* pdtlnodeLink = NULL;
    PBENTRY* ppbentry;
    PBLINK*  ppblink;
    CHAR     szValue[ RAS_MAXLINEBUFLEN + 1 ];
    BOOL     fStatus;
    BOOL     fFoundMedia;
    BOOL     fSectionDeleted;
    INT      i;
    HRASFILE h;
    DTLLIST* pdtllistPorts = NULL;
    BOOL     fOldPhonebook;
    BOOL     fDisableSwCompression;
    BOOL     fDisableModemSpeaker;
    DWORD    dwfInstalledProtocols;

    /* Make sure our assumption that ISDN phone number keys are equivalent to
    ** modem phone number keys is correct.
    */
    ASSERT(lstrcmpiA(ISDN_PHONENUMBER_KEY,KEY_PhoneNumber)==0);
    ASSERT(lstrcmpiA(MXS_PHONENUMBER_KEY,KEY_PhoneNumber)==0);

    h = pFile->hrasfile;
    ASSERT(h!=-1);

    dwfInstalledProtocols = GetInstalledProtocols();

    /* Look up a couple flags in the old global section and, if found, apply
    ** them to the new per-entry equivalents.  This will only find anything on
    ** phonebook upgrade, since all ".XXX" sections are deleted later.
    */
    fOldPhonebook = FALSE;
    if (RasfileFindSectionLine( h, GLOBALSECTIONNAME, TRUE ))
    {
        fOldPhonebook = TRUE;

        fDisableModemSpeaker = FALSE;
        if ((dwErr = ReadFlag( h, RFS_SECTION,
                KEY_DisableModemSpeaker, &fDisableModemSpeaker )) != 0)
        {
            return dwErr;
        }

        fDisableSwCompression = FALSE;
        if ((dwErr = ReadFlag( h, RFS_SECTION,
                KEY_DisableSwCompression, &fDisableSwCompression )) != 0)
        {
            return dwErr;
        }

        TRACE2("Old phonebook: dms=%d,dsc=%d",
            fDisableModemSpeaker,fDisableSwCompression);
    }

    if (!(pFile->pdtllistEntries = DtlCreateList( 0L )))
        return ERROR_NOT_ENOUGH_MEMORY;

    /* For each section in the file...
    */
    fSectionDeleted = FALSE;
    for (fStatus = RasfileFindFirstLine( h, RFL_SECTION, RFS_FILE );
         fStatus;
         fSectionDeleted
             || (fStatus = RasfileFindNextLine( h, RFL_SECTION, RFS_FILE )))
    {
        fSectionDeleted = FALSE;

        /* Read the entry name (same as section name), skipping over any
        ** sections beginning with dot.  These are reserved for special
        ** purposes (like the old global section).
        */
        if (!RasfileGetSectionName( h, szValue ))
        {
            /* Get here only when the last section in the file is deleted
            ** within the loop.
            */
            break;
        }

        TRACE1("ENTRY: Reading \"%s\"",szValue);

        if (szValue[ 0 ] == '.')
        {
            TRACE1("Obsolete section %s deleted",szValue);
            DeleteCurrentSection( h );
            fSectionDeleted = TRUE;
            continue;
        }

        /* Create a default entry node and add it to the list.
        */
        if (!(pdtlnodeEntry = CreateEntryNode( FALSE )))
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        DtlAddNodeLast( pFile->pdtllistEntries, pdtlnodeEntry );
        ppbentry = (PBENTRY* )DtlGetData( pdtlnodeEntry );

        if (fOldPhonebook)
        {
            /* Mark all entries dirty when upgrading old phonebooks because
            ** they all need to have there DialParamUIDs written out.
            */
            fDirty = ppbentry->fDirty = TRUE;
        }

        if (!(ppbentry->pszEntryName = StrDupTFromA( szValue )))
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        if ((dwErr = ReadString( h, RFS_SECTION,
                KEY_Description, &ppbentry->pszDescription )) != 0)
        {
            break;
        }

        if ((dwErr = ReadFlag( h, RFS_SECTION,
                KEY_AutoLogon, &ppbentry->fAutoLogon )) != 0)
        {
            break;
        }

        if ((dwErr = ReadLong( h, RFS_SECTION,
                KEY_UID,
                (LONG* )&ppbentry->dwDialParamsUID )) != 0)
        {
            break;
        }

        if ((dwErr = ReadFlag( h, RFS_SECTION,
                KEY_UsePwForNetwork, &ppbentry->fUsePwForNetwork )) != 0)
        {
            break;
        }

        if ((dwErr = ReadString( h, RFS_SECTION,
                KEY_User, &ppbentry->pszOldUser )) != 0)
        {
            break;
        }

        if ((dwErr = ReadString( h, RFS_SECTION,
                KEY_Domain, &ppbentry->pszOldDomain )) != 0)
        {
            break;
        }

        if ((dwErr = ReadLong( h, RFS_SECTION,
                KEY_BaseProtocol,
                (LONG* )&ppbentry->dwBaseProtocol )) != 0)
        {
            break;
        }

        if ((dwErr = ReadLong( h, RFS_SECTION,
                KEY_Authentication,
                (LONG* )&ppbentry->dwAuthentication )) != 0)
        {
            break;
        }

        if ((dwErr = ReadLong( h, RFS_SECTION,
                KEY_ExcludedProtocols,
                (LONG * )&ppbentry->dwfExcludedProtocols )) != 0)
        {
            break;
        }

#if AMB
        /* Automatically mark all installed protocols on AMB-only entries as
        ** "excluded for PPP connections".
        */
        if (ppbentry->dwAuthentication == AS_AmbOnly
            || (ppbentry->dwBaseProtocol == BP_Ppp
                && (dwfInstalledProtocols
                    & ~(ppbentry->dwfExcludedProtocols)) == 0))
        {
            ppbentry->dwBaseProtocol = BP_Ras;
            ppbentry->dwfExcludedProtocols = 0;
            fDirty = ppbentry->fDirty = TRUE;
        }
#else
        /* AMB support deprecated, see NarenG.  If old AMB entry, set framing
        ** and authentication strategy back to defaults.  If calling a non-PPP
        ** (NT 3.1 or WFW server) it still won't work, but at least this fixes
        ** someone who accidently chose AMB.
        */
        if (ppbentry->dwBaseProtocol == BP_Ras)
            ppbentry->dwBaseProtocol = BP_Ppp;

        if (ppbentry->dwAuthentication == AS_PppThenAmb
            || ppbentry->dwAuthentication == AS_AmbThenPpp
            || ppbentry->dwAuthentication == AS_AmbOnly)
        {
            ppbentry->dwAuthentication = (DWORD )AS_Default;
        }

#endif

        if ((dwErr = ReadFlag( h, RFS_SECTION,
                KEY_LcpExtensions,
                &ppbentry->fLcpExtensions )) != 0)
        {
            break;
        }

        if ((dwErr = ReadLong( h, RFS_SECTION,
                KEY_DataEncryption,
                &ppbentry->dwDataEncryption )) != 0)
        {
            break;
        }

        if ((dwErr = ReadFlag( h, RFS_SECTION,
                KEY_SkipNwcWarning,
                &ppbentry->fSkipNwcWarning )) != 0)
        {
            break;
        }

        if ((dwErr = ReadFlag( h, RFS_SECTION,
                KEY_SkipDownLevelDialog,
                &ppbentry->fSkipDownLevelDialog )) != 0)
        {
            break;
        }

        if (fOldPhonebook)
            ppbentry->fSwCompression = !fDisableSwCompression;
        else
        {
            if ((dwErr = ReadFlag( h, RFS_SECTION,
                    KEY_SwCompression,
                    &ppbentry->fSwCompression )) != 0)
            {
                break;
            }
        }

        if ((dwErr = ReadFlag( h, RFS_SECTION,
                KEY_UseCountryAndAreaCodes,
                &ppbentry->fUseCountryAndAreaCode )) != 0)
        {
            break;
        }

        if ((dwErr = ReadString( h, RFS_SECTION,
                KEY_AreaCode, &ppbentry->pszAreaCode )) != 0)
        {
            break;
        }

        if ((dwErr = ReadLong( h, RFS_SECTION,
                KEY_CountryID,
                (LONG* )&ppbentry->dwCountryID )) != 0)
        {
            break;
        }

        if (ppbentry->dwCountryID == 0)
            ppbentry->dwCountryID = 1;

        if ((dwErr = ReadLong( h, RFS_SECTION,
                KEY_CountryCode,
                (LONG* )&ppbentry->dwCountryCode )) != 0)
        {
            break;
        }

        if (ppbentry->dwCountryCode == 0)
            ppbentry->dwCountryCode = 1;

        if ((dwErr = ReadLong( h, RFS_SECTION,
                KEY_DialMode,
                (LONG* )&ppbentry->dwDialMode )) != 0)
        {
            break;
        }

        if ((dwErr = ReadLong( h, RFS_SECTION,
                KEY_DialPercent,
                (LONG* )&ppbentry->dwDialPercent )) != 0)
        {
            break;
        }

        if ((dwErr = ReadLong( h, RFS_SECTION,
                KEY_DialSeconds,
                (LONG* )&ppbentry->dwDialSeconds )) != 0)
        {
            break;
        }

        if ((dwErr = ReadLong( h, RFS_SECTION,
                KEY_HangUpPercent,
                (LONG* )&ppbentry->dwHangUpPercent )) != 0)
        {
            break;
        }

        if ((dwErr = ReadLong( h, RFS_SECTION,
                KEY_HangUpSeconds,
                (LONG* )&ppbentry->dwHangUpSeconds )) != 0)
        {
            break;
        }

        if ((dwErr = ReadLong( h, RFS_SECTION,
                KEY_OverridePref,
                (LONG* )&ppbentry->dwfOverridePref )) != 0)
        {
            break;
        }

        if ((dwErr = ReadLong( h, RFS_SECTION,
                KEY_RedialAttempts,
                (LONG* )&ppbentry->dwRedialAttempts )) != 0)
        {
            break;
        }

        if ((dwErr = ReadLong( h, RFS_SECTION,
                KEY_RedialSeconds,
                (LONG* )&ppbentry->dwRedialSeconds )) != 0)
        {
            break;
        }

        if ((dwErr = ReadLong( h, RFS_SECTION,
                KEY_IdleDisconnectSeconds,
                (LONG* )&ppbentry->dwIdleDisconnectSeconds )) != 0)
        {
            break;
        }

        /* If this "idle seconds" is non-zero set it's override bit
        ** explicitly.  This is necessary for this field only, because it
        ** existed in entries created before the override bits were
        ** implemented.
        */
        if (ppbentry->dwIdleDisconnectSeconds != 0)
            ppbentry->dwfOverridePref |= RASOR_IdleDisconnectSeconds;

        if ((dwErr = ReadFlag(
                h, RFS_SECTION, KEY_RedialOnLinkFailure,
                &ppbentry->fRedialOnLinkFailure )) != 0)
        {
            return dwErr;
        }

        if ((dwErr = ReadFlag(
                h, RFS_SECTION, KEY_PopupOnTopWhenRedialing,
                &ppbentry->fPopupOnTopWhenRedialing )) != 0)
        {
            return dwErr;
        }

        if ((dwErr = ReadLong( h, RFS_SECTION,
                KEY_CallbackMode,
                (LONG* )&ppbentry->dwCallbackMode )) != 0)
        {
            break;
        }

        if ((dwErr = ReadFlag(
                h, RFS_SECTION, KEY_SecureLocalFiles,
                &ppbentry->fSecureLocalFiles )) != 0)
        {
            return dwErr;
        }

        if ((dwErr = ReadString( h, RFS_SECTION,
                KEY_CustomDialDll,
                &ppbentry->pszCustomDialDll )) != 0)
        {
            return dwErr;
        }

        if ((dwErr = ReadString( h, RFS_SECTION,
                KEY_CustomDialFunc,
                &ppbentry->pszCustomDialFunc )) != 0)
        {
            return dwErr;
        }

        if ((dwErr = ReadFlag(
                h, RFS_SECTION, KEY_AuthenticateServer,
                &ppbentry->fAuthenticateServer )) != 0)
        {
            return dwErr;
        }

        if (fOldPhonebook)
        {
            /* Look for the old PPP keys.
            */
            if (ppbentry->dwBaseProtocol == BP_Ppp)
            {
                if ((dwErr = ReadLong(
                        h, RFS_SECTION, KEY_PppTextAuthentication,
                        &ppbentry->dwAuthRestrictions )) != 0)
                {
                    return dwErr;
                }

                if ((dwErr = ReadFlag(
                        h, RFS_SECTION, KEY_PppIpPrioritizeRemote,
                        &ppbentry->fIpPrioritizeRemote )) != 0)
                {
                    return dwErr;
                }

                if ((dwErr = ReadFlag(
                        h, RFS_SECTION, KEY_PppIpVjCompression,
                        &ppbentry->fIpHeaderCompression )) != 0)
                {
                    return dwErr;
                }

                if ((dwErr = ReadString( h, RFS_SECTION,
                        KEY_PppIpAddress, &ppbentry->pszIpAddress )) != 0)
                {
                    return dwErr;
                }

                if ((dwErr = ReadLong( h, RFS_SECTION,
                        KEY_PppIpAddressSource,
                        &ppbentry->dwIpAddressSource )) != 0)
                {
                    return dwErr;
                }

                if ((dwErr = ReadString( h, RFS_SECTION,
                        KEY_PppIpDnsAddress,
                        &ppbentry->pszIpDnsAddress )) != 0)
                {
                    return dwErr;
                }

                if ((dwErr = ReadString( h, RFS_SECTION,
                        KEY_PppIpDns2Address,
                        &ppbentry->pszIpDns2Address )) != 0)
                {
                    return dwErr;
                }

                if ((dwErr = ReadString( h, RFS_SECTION,
                        KEY_PppIpWinsAddress,
                        &ppbentry->pszIpWinsAddress )) != 0)
                {
                    return dwErr;
                }

                if ((dwErr = ReadString( h, RFS_SECTION,
                        KEY_PppIpWins2Address,
                        &ppbentry->pszIpWins2Address )) != 0)
                {
                    return dwErr;
                }

                if ((dwErr = ReadLong( h, RFS_SECTION,
                        KEY_PppIpNameSource,
                        &ppbentry->dwIpNameSource )) != 0)
                {
                    return dwErr;
                }
            }

            /* Look for the old SLIP keys.
            */
            if (ppbentry->dwBaseProtocol == BP_Slip)
            {
                if ((dwErr = ReadFlag( h, RFS_SECTION,
                        KEY_SlipHeaderCompression,
                        &ppbentry->fIpHeaderCompression )) != 0)
                {
                    break;
                }

                if ((dwErr = ReadFlag( h, RFS_SECTION,
                        KEY_SlipPrioritizeRemote,
                        &ppbentry->fIpPrioritizeRemote )) != 0)
                {
                    break;
                }

                if ((dwErr = ReadLong( h, RFS_SECTION,
                        KEY_SlipFrameSize, &ppbentry->dwFrameSize )) != 0)
                {
                    break;
                }

                if ((dwErr = ReadString( h, RFS_SECTION,
                        KEY_SlipIpAddress, &ppbentry->pszIpAddress )) != 0)
                {
                    break;
                }
            }
        }
        else
        {
            /* Look for the new IP names.
            */
            if ((dwErr = ReadLong(
                    h, RFS_SECTION, KEY_AuthRestrictions,
                    &ppbentry->dwAuthRestrictions )) != 0)
            {
                return dwErr;
            }

            if ((dwErr = ReadFlag(
                    h, RFS_SECTION, KEY_IpPrioritizeRemote,
                    &ppbentry->fIpPrioritizeRemote )) != 0)
            {
                return dwErr;
            }

            if ((dwErr = ReadFlag(
                    h, RFS_SECTION, KEY_IpHeaderCompression,
                    &ppbentry->fIpHeaderCompression )) != 0)
            {
                return dwErr;
            }

            if ((dwErr = ReadString( h, RFS_SECTION,
                    KEY_IpAddress, &ppbentry->pszIpAddress )) != 0)
            {
                return dwErr;
            }

            if ((dwErr = ReadString( h, RFS_SECTION,
                    KEY_IpDnsAddress,
                    &ppbentry->pszIpDnsAddress )) != 0)
            {
                return dwErr;
            }

            if ((dwErr = ReadString( h, RFS_SECTION,
                    KEY_IpDns2Address,
                    &ppbentry->pszIpDns2Address )) != 0)
            {
                return dwErr;
            }

            if ((dwErr = ReadString( h, RFS_SECTION,
                    KEY_IpWinsAddress,
                    &ppbentry->pszIpWinsAddress )) != 0)
            {
                return dwErr;
            }

            if ((dwErr = ReadString( h, RFS_SECTION,
                    KEY_IpWins2Address,
                    &ppbentry->pszIpWins2Address )) != 0)
            {
                return dwErr;
            }

            if ((dwErr = ReadLong( h, RFS_SECTION,
                    KEY_IpAddressSource,
                    &ppbentry->dwIpAddressSource )) != 0)
            {
                return dwErr;
            }

            if ((dwErr = ReadLong( h, RFS_SECTION,
                    KEY_IpNameSource,
                    &ppbentry->dwIpNameSource )) != 0)
            {
                return dwErr;
            }

            if ((dwErr = ReadLong( h, RFS_SECTION,
                    KEY_IpFrameSize, &ppbentry->dwFrameSize )) != 0)
            {
                break;
            }
        }

        /* MEDIA subsections.
        */
        fFoundMedia = FALSE;

        if (!pdtllistPorts)
        {
            dwErr = LoadPortsList2( &pdtllistPorts, fRouter );
            if (dwErr != 0)
                break;
        }

        for (;;)
        {
            TCHAR*  pszDevice;
            PBPORT* ppbport;

            if (!RasfileFindNextLine( h, RFL_GROUP, RFS_SECTION )
                || !IsMediaLine( (CHAR* )RasfileGetLine( h ) ))
            {
                if (fFoundMedia)
                {
                    /* Out of media groups, i.e. "links", but found at least
                    ** one.  This is the successful exit case.
                    */
                    break;
                }

                /* First subsection MUST be a MEDIA subsection.  Delete
                ** non-conforming entries as invalid.
                */
                TRACE("No media section?");
                DeleteCurrentSection( h );
                fSectionDeleted = TRUE;
                DtlRemoveNode( pFile->pdtllistEntries, pdtlnodeEntry );
                DestroyEntryNode( pdtlnodeEntry );
                break;
            }

            /* Create a default link node and add it to the list.
            */
            if (!(pdtlnodeLink = CreateLinkNode()))
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            DtlAddNodeLast( ppbentry->pdtllistLinks, pdtlnodeLink );
            ppblink = (PBLINK* )DtlGetData( pdtlnodeLink );

            RasfileGetKeyValueFields( h, NULL, szValue );
            TRACE1("Reading media group \"%s\"",szValue);

            if ((dwErr = ReadString( h, RFS_GROUP,
                    KEY_Port, &ppblink->pbport.pszPort )) != 0)
            {
                break;
            }

            if (!ppblink->pbport.pszPort)
            {
                /* No port.  Blow away corrupt section and go on to the next
                ** one.
                */
                TRACE("No port key? (section deleted)");
                dwErr = 0;
                DeleteCurrentSection( h );
                fSectionDeleted = TRUE;
                DtlRemoveNode( pFile->pdtllistEntries, pdtlnodeEntry );
                DestroyEntryNode( pdtlnodeEntry );
                break;
            }

            {
                pszDevice = NULL;
                if ((dwErr = ReadString(
                        h, RFS_GROUP, KEY_Device,
                        &pszDevice )) != 0)
                {
                    break;
                }

                ppblink->pbport.pszDevice = pszDevice;
                TRACE1("%s link format",(pszDevice)?"New":"Old");
            }

            if ((dwErr = ReadFlag(
                    h, RFS_GROUP, KEY_OtherPortOk,
                    &ppblink->fOtherPortOk )) != 0)
            {
                return dwErr;
            }

            TRACEW1("Port=%s",ppblink->pbport.pszPort);

            ppbport = PpbportFromPortName(
                pdtllistPorts, ppblink->pbport.pszPort );
            if (ppbport)
            {
                if (lstrcmp( ppbport->pszPort, ppblink->pbport.pszPort ) != 0)
                {
                    /* The phonebook had an old-style port name.  Mark the
                    ** entry for update with the new port name format.
                    */
                    TRACEW1("Port=>%s",ppblink->pbport.pszPort);
                    fDirty = ppbentry->fDirty = TRUE;
                }

                dwErr = CopyToPbport( &ppblink->pbport, ppbport );
                if (dwErr != 0)
                    break;
            }
            else
            {
                TRACE("Port not configured");
                ppblink->pbport.fConfigured = FALSE;

                /* Assign unconfigured port the media we read earlier.
                */
                Free0( ppblink->pbport.pszMedia );
                ppblink->pbport.pszMedia = StrDupTFromA( szValue );
                if (!ppblink->pbport.pszMedia)
                {
                    dwErr = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }
            }

            if (!ppbport || ppblink->pbport.pbdevicetype == PBDT_Modem)
            {
                SetDefaultModemSettings( ppblink );

                if ((dwErr = ReadLong( h, RFS_GROUP,
                        KEY_InitBps, &ppblink->dwBps )) != 0)
                {
                    break;
                }
            }

            /* DEVICE subsections.
            */

            /* At this point ppblink->pbport contains information from the
            ** matching port in the configured port list or defaults with
            ** pszMedia and pszDevice filled in.  ReadDeviceList fills in the
            ** pbdevicetype, and if it's an unconfigured port, the unimodem or
            ** MXS modem flag.
            */
            dwErr = ReadDeviceList( h, ppbentry, ppblink, !ppbport,
                (fOldPhonebook) ? &fDisableModemSpeaker : NULL );

            if (dwErr == ERROR_CORRUPT_PHONEBOOK)
            {
                /* Blow away corrupt section and go on to the next one.
                */
                dwErr = 0;
                DeleteCurrentSection( h );
                fSectionDeleted = TRUE;
                DtlRemoveNode( pFile->pdtllistEntries, pdtlnodeEntry );
                DestroyEntryNode( pdtlnodeEntry );
                break;
            }
            else if (dwErr != 0)
                break;

            if (fOldPhonebook
                && ppbentry->dwBaseProtocol == BP_Slip
                && ppbentry->dwScriptModeAfter == SM_None)
            {
                /* Set an after-dial terminal when upgrading old phonebooks.
                ** This was implied in the old format.
                */
                TRACE("Add SLIP terminal");
                ppbentry->dwScriptModeAfter = SM_Terminal;
            }

            if (!ppbport && !pszDevice)
            {
                DTLNODE* pdtlnode;

                /* This is an old-format link not in the list of installed
                ** ports.  Change it to the first device of the same device
                ** type or to an "unknown" device of that type.  Note this is
                ** what converts "Any port".
                */
                for (pdtlnode = DtlGetFirstNode( pdtllistPorts );
                     pdtlnode;
                     pdtlnode = DtlGetNextNode( pdtlnode ))
                {
                    ppbport = (PBPORT* )DtlGetData( pdtlnode );

                    if (ppbport->pbdevicetype == ppblink->pbport.pbdevicetype)
                    {
                        /* Don't convert two links of the entry to use the
                        ** same port.  If there aren't enough similar ports,
                        ** the overflow will be left "unknown".  (bug 63203).
                        */
                        DTLNODE* pNodeL;

                        for (pNodeL = DtlGetFirstNode( ppbentry->pdtllistLinks );
                             pNodeL;
                             pNodeL = DtlGetNextNode( pNodeL ))
                        {
                            PBLINK* pLink = DtlGetData( pNodeL );

                            if (lstrcmp( pLink->pbport.pszPort,
                                    ppbport->pszPort ) == 0)
                            {
                                break;
                            }
                        }

                        if (!pNodeL)
                        {
                            TRACE("Port converted");
                            dwErr = CopyToPbport( &ppblink->pbport, ppbport );
                            if (ppblink->pbport.pbdevicetype == PBDT_Modem)
                                SetDefaultModemSettings( ppblink );
                            break;
                        }
                    }
                }

                if (dwErr != 0)
                    break;
            }

            fFoundMedia = TRUE;
        }

        if (dwErr != 0)
            break;

        if (!fSectionDeleted)
        {
            if (ppbentry->dwBaseProtocol != BP_Ppp
                && DtlGetNodes( ppbentry->pdtllistLinks ) > 1)
            {
                TRACE("Non-PPP multi-link corrected");
                ppbentry->dwBaseProtocol = BP_Ppp;
                fDirty = ppbentry->fDirty = TRUE;
            }
        }
    }

    if (dwErr != 0)
        DtlDestroyList( pFile->pdtllistEntries, DestroyEntryNode );

    /* If adjusted something to bring it within bounds write the change to the
    ** phonebook.
    */
    if (fDirty)
        WritePhonebookFile( pFile, NULL );

    if (pdtllistPorts)
        DtlDestroyList( pdtllistPorts, DestroyPortNode );

    return dwErr;
}


DWORD
ReadEntryNameList(
    IN OUT PBFILE* pFile )

    /* Creates the entry list 'pFile->pdtllistEntries' from previously loaded
    ** phonebook file 'pFile.hrasfile'; each node contains an entry-name.
    **
    ** Returns 0 if successful, otherwise a non-0 error code.
    */
{

    BOOL     fStatus;
    HRASFILE h;
    DTLNODE* pdtlnode;
    DWORD    dwErr = 0;
    CHAR     szValue[ RAS_MAXLINEBUFLEN + 1 ];

    h = pFile->hrasfile;
    ASSERT(h!=-1);

    /* Create the list. We set the list type to be 'RPBF_HeadersOnly'
    ** to indicate that only entry-names are loaded.
    ** 'ClosePhonebookFile' checks the list code to see whether to destroy it
    ** as a list of PBENTRY or a list of TCHAR*.
    */

    if (!(pFile->pdtllistEntries = DtlCreateList( 0L )))
        return ERROR_NOT_ENOUGH_MEMORY;

    DtlPutListCode( pFile->pdtllistEntries, RPBF_HeadersOnly );


    /* For each section in the file...
    */
    for (fStatus = RasfileFindFirstLine( h, RFL_SECTION, RFS_FILE );
         fStatus;
         fStatus = RasfileFindNextLine( h, RFL_SECTION, RFS_FILE ))
    {
        TCHAR* pszDup;

        /* Read the entry name (same as section name), skipping over any
        ** sections beginning with dot.  These are reserved for special
        ** purposes (like the old global section).
        */
        if (!RasfileGetSectionName( h, szValue ))
        {
            break;
        }

        TRACE1("ENTRY: Reading \"%s\"",szValue);

        if (szValue[ 0 ] == '.')
        {
            TRACE1("Obsolete section %s ignored",szValue);
            continue;
        }

        /* Append an entry-name node to the end of the list
        */
        pszDup = StrDupTFromA( szValue );
        pdtlnode = DtlCreateNode( pszDup, 0L );
        if (!pdtlnode )
        {
            Free( pszDup );
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        DtlAddNodeLast( pFile->pdtllistEntries, pdtlnode );
    }

    if (dwErr != 0)
        DtlDestroyList( pFile->pdtllistEntries, DestroyPszNode );

    return dwErr;
}


DWORD
ReadFlag(
    IN  HRASFILE h,
    IN  RFSCOPE  rfscope,
    IN  CHAR*    pszKey,
    OUT BOOL*    pfResult )

    /* Utility routine to read a flag value from the next line in the scope
    ** 'rfscope' with key 'pszKey'.  The result is placed in caller's
    ** '*ppszResult' buffer.  The current line is reset to the start of the
    ** scope if the call was successful.
    **
    ** Returns 0 if successful, or a non-zero error code.  "Not found" is
    ** considered successful, in which case '*pfResult' is not changed.
    */
{
    DWORD dwErr;
    LONG  lResult = *pfResult;

    dwErr = ReadLong( h, rfscope, pszKey, &lResult );

    if (lResult != (LONG )*pfResult)
        *pfResult = (lResult != 0);

    return dwErr;
}


DWORD
ReadLong(
    IN  HRASFILE h,
    IN  RFSCOPE  rfscope,
    IN  CHAR*    pszKey,
    OUT LONG*    plResult )

    /* Utility routine to read a long integer value from the next line in the
    ** scope 'rfscope' with key 'pszKey'.  The result is placed in caller's
    ** '*ppszResult' buffer.  The current line is reset to the start of the
    ** scope if the call was successful.
    **
    ** Returns 0 if successful, or a non-zero error code.  "Not found" is
    ** considered successful, in which case '*plResult' is not changed.
    */
{
    CHAR szValue[ RAS_MAXLINEBUFLEN + 1 ];

    if (RasfileFindNextKeyLine( h, pszKey, rfscope ))
    {
        if (!RasfileGetKeyValueFields( h, NULL, szValue ))
            return ERROR_NOT_ENOUGH_MEMORY;

        *plResult = atol( szValue );
    }

    RasfileFindFirstLine( h, RFL_ANY, rfscope );
    return 0;
}


DWORD
ReadPhonebookFile(
    IN  TCHAR*  pszPhonebookPath,
    IN  PBUSER* pUser,
    IN  TCHAR*  pszSection,
    IN  DWORD   dwFlags,
    OUT PBFILE* pFile )

    /* Reads the phonebook file into a list of PBENTRY.
    **
    ** 'PszPhonebookPath' specifies the full path to the RAS phonebook file, or
    ** is NULL indicating the default phonebook should be used.
    **
    ** 'PUser' is the user preferences used to determine the default phonebook
    ** path or NULL if they should be looked up by this routine.  If
    ** 'pszPhonebookPath' is non-NULL 'pUser' is ignored.  Note that caller
    ** MUST provide his own 'pUser' in "winlogon" mode.
    **
    ** 'PszSection' indicates that only the section named 'pszSection' should
    ** be loaded, or is NULL to indicate all sections.
    **
    ** 'DwFlags' options: 'RPBF_ReadOnly' causes the file to be opened for
    ** reading only.  'RPBF_HeadersOnly' causes only the headers to loaded,
    ** and the memory image is parsed into a list of strings, unless the flag
    ** 'RPBF_NoList' is specified.
    **
    ** 'PFile' is the address of caller's file block.  This routine sets
    ** 'pFile->hrasfile' to the handle to the open phonebook, 'pFile->pszPath'
    ** to the full path to the file mode, 'pFile->dwPhonebookMode' to the mode
    ** of the file, and 'pFile->pdtllistEntries' to the parsed chain of entry
    ** blocks.
    **
    ** Returns 0 if successful, otherwise a non-0 error code.  On success,
    ** caller should eventually call ClosePhonebookFile on the returned
    ** PBFILE*.
    */
{
    DWORD dwErr = 0;

    TRACE("ReadPhonebookFile");

    pFile->hrasfile = -1;
    pFile->pszPath = NULL;
    pFile->dwPhonebookMode = PBM_System;
    pFile->pdtllistEntries = NULL;

    do
    {
        TCHAR szFullPath[MAX_PATH + 1];

        if (pszPhonebookPath)
        {
            pFile->dwPhonebookMode = PBM_Alternate;
            pFile->pszPath = StrDup( pszPhonebookPath );
            if (!pFile->pszPath)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }
        }
        else
        {
            BOOL f;

            if (pUser)
            {
                f = GetPhonebookPath(
                        pUser, &pFile->pszPath, &pFile->dwPhonebookMode );
            }
            else
            {
                PBUSER user;

                /* Caller didn't provide user preferences but we need them to
                ** find the phonebook, so look them up ourselves.  Note that
                ** "not winlogon mode" is assumed.
                */
                dwErr = GetUserPreferences( &user, FALSE );
                if (dwErr != 0)
                    break;

                f = GetPhonebookPath(
                        &user, &pFile->pszPath, &pFile->dwPhonebookMode );

                DestroyUserPreferences( &user );
            }

            if (!f)
            {
                dwErr = ERROR_CANNOT_OPEN_PHONEBOOK;
                break;
            }
        }

        TRACEW1("path=%s",pFile->pszPath);
        if (GetFullPathName(pFile->pszPath, MAX_PATH, szFullPath, NULL) > 0) {
            TRACEW1("full path=%s", szFullPath);
            Free(pFile->pszPath);
            pFile->pszPath = StrDup(szFullPath);
        }


        if ((dwFlags & RPBF_NoCreate) && !FileExists( pFile->pszPath ))
        {
            dwErr = ERROR_CANNOT_OPEN_PHONEBOOK;
            break;
        }

        if (pFile->dwPhonebookMode == PBM_System
            && !FileExists( pFile->pszPath ))
        {
            /* The public phonebook file does not exist.  Create it with
            ** "everybody" access now.  Otherwise Rasfile will create it with
            ** "current account" access which may prevent another account from
            ** accessing it later.
            */
            HANDLE               hFile;
            SECURITY_ATTRIBUTES  sa;
            SECURITY_DESCRIPTOR  sd;

            dwErr = InitSecurityDescriptor( &sd );
            if (dwErr != 0)
                break;

            sa.nLength = sizeof(SECURITY_ATTRIBUTES) ;
            sa.lpSecurityDescriptor = &sd;
            sa.bInheritHandle = TRUE ;

            hFile =
                CreateFile(
                    pFile->pszPath,
                    GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ,
                    &sa,
                    CREATE_ALWAYS,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL );

            if (hFile == INVALID_HANDLE_VALUE)
            {
                dwErr = ERROR_CANNOT_OPEN_PHONEBOOK;
                break;
            }

            CloseHandle( hFile );

            TRACE("System phonebook created.");
        }

        /* Load the phonebook file into memory.  In "write" mode, comments are
        ** loaded so user's custom comments (if any) will be preserved.
        ** Normally, there will be none so this costs nothing in the typical
        ** case.
        */
        {
            DWORD dwMode;
            CHAR* pszPathA;
            CHAR* pszSectionA;

            dwMode = 0;
            if (dwFlags & RPBF_ReadOnly)
                dwMode |= RFM_READONLY;
            else
                dwMode |= RFM_CREATE | RFM_LOADCOMMENTS;

            if (dwFlags & RPBF_HeadersOnly)
            {
                dwMode |= RFM_ENUMSECTIONS;
            }

            /* Read the disk file into a linked list of lines.
            */
            pszPathA = StrDupAFromT( pFile->pszPath );
            pszSectionA = StrDupAFromT( pszSection );

            if (pszPathA && (!pszSection || pszSectionA))
            {
                ASSERT(g_hmutexPb);
                WaitForSingleObject( g_hmutexPb, INFINITE );

                pFile->hrasfile = RasfileLoad(
                    pszPathA, dwMode, pszSectionA, IsGroup );

                ReleaseMutex( g_hmutexPb );
            }

            Free0( pszPathA );
            Free0( pszSectionA );

            if (pFile->hrasfile == -1)
            {
                dwErr = ERROR_CANNOT_LOAD_PHONEBOOK;
                break;
            }
        }

        /* Parse the linked list of lines
        */
        if (!(dwFlags & RPBF_NoList))
        {
            /* If 'RPBF_HeadersOnly' is specified, parse into a linked list
            ** of strings; otherwise, parse into a linked list of entries
            */
            if (dwFlags & RPBF_HeadersOnly)
            {
                dwErr = ReadEntryNameList( pFile );
            }
            else
            {
                dwErr = ReadEntryList( pFile, (dwFlags & RPBF_Router) );
            }
            break;
        }
    }
    while (FALSE);

    if (dwErr != 0)
        ClosePhonebookFile( pFile );

    TRACE1("ReadPhonebookFile=%d",dwErr);
    return dwErr;
}


DWORD
ReadString(
    IN  HRASFILE h,
    IN  RFSCOPE  rfscope,
    IN  CHAR*    pszKey,
    OUT TCHAR**  ppszResult )

    /* Utility routine to read a string value from the next line in the scope
    ** 'rfscope' with key 'pszKey'.  The result is placed in the allocated
    ** '*ppszResult' buffer.  The current line is reset to the start of the
    ** scope if the call was successful.
    **
    ** Returns 0 if successful, or a non-zero error code.  "Not found" is
    ** considered successful, in which case '*ppszResult' is not changed.
    ** Caller is responsible for freeing the returned '*ppszResult' buffer.
    */
{
    CHAR szValue[ RAS_MAXLINEBUFLEN + 1 ];

    if (RasfileFindNextKeyLine( h, pszKey, rfscope ))
    {
        if (!RasfileGetKeyValueFields( h, NULL, szValue )
            || !(*ppszResult = StrDupTFromA( szValue )))
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    RasfileFindFirstLine( h, RFL_ANY, rfscope );
    return 0;
}


DWORD
ReadStringList(
    IN  HRASFILE  h,
    IN  RFSCOPE   rfscope,
    IN  CHAR*     pszKey,
    OUT DTLLIST** ppdtllistResult )

    /* Utility routine to read a list of string values from next lines in the
    ** scope 'rfscope' with key 'pszKey'.  The result is placed in the
    ** allocated '*ppdtllistResult' list.  The current line is reset to the
    ** start of the scope after the call.
    **
    ** Returns 0 if successful, or a non-zero error code.  "Not found" is
    ** considered successful, in which case 'pdtllistResult' is set to an
    ** empty list.  Caller is responsible for freeing the returned
    ** '*ppdtllistResult' list.
    */
{
    CHAR szValue[ RAS_MAXLINEBUFLEN + 1 ];

    //
    //  Free existing list, if present.
    //
    if (*ppdtllistResult != NULL)
        DtlDestroyList(*ppdtllistResult, DestroyPszNode);

    if (!(*ppdtllistResult = DtlCreateList( 0 )))
        return ERROR_NOT_ENOUGH_MEMORY;

    while (RasfileFindNextKeyLine( h, pszKey, rfscope ))
    {
        TCHAR*   psz;
        DTLNODE* pdtlnode;

        if (!RasfileGetKeyValueFields( h, NULL, szValue )
            || !(psz = StrDupTFromA( szValue )))
        {
            DtlDestroyList( *ppdtllistResult, DestroyPszNode );
            *ppdtllistResult = NULL;
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        if (!(pdtlnode = DtlCreateNode( psz, 0 )))
        {
            Free( psz );
            DtlDestroyList( *ppdtllistResult, DestroyPszNode );
            *ppdtllistResult = NULL;
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        DtlAddNodeLast( *ppdtllistResult, pdtlnode );
    }

    RasfileFindFirstLine( h, RFL_ANY, rfscope );
    return 0;
}


#if 0
DWORD
SetPersonalPhonebookInfo(
    IN BOOL   fPersonal,
    IN TCHAR* pszPath )

    /* Sets information about the personal phonebook file in the registry.
    ** 'fPersonal' indicates whether the personal phonebook should be used.
    ** 'pszPath' indicates the full path to the phonebook file, or is NULL
    ** leave the setting as is.
    **
    ** Returns 0 if successful, or a non-0 error code.
    */
{
    DWORD dwErr;
    HKEY  hkey;
    DWORD dwDisposition;

    if ((dwErr = RegCreateKeyEx( HKEY_CURRENT_USER, REGKEY_Ras, 0,
            TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
            &hkey, &dwDisposition )) != 0)
    {
        return dwErr;
    }

    if ((dwErr = RegSetValueEx(
            hkey, REGVAL_szUsePersonalPhonebook, 0, REG_SZ,
            (BYTE* )((fPersonal) ? TEXT("1") : TEXT("0")), 1 )) != 0)
    {
        RegCloseKey( hkey );
        return dwErr;
    }

    if (pszPath)
    {
        if ((dwErr = RegSetValueEx(
                hkey, REGVAL_szPersonalPhonebookPath, 0, REG_SZ,
                (BYTE* )pszPath, lstrlen( pszPath ) + 1 )) != 0)
        {
            RegCloseKey( hkey );
            return dwErr;
        }
    }

    RegCloseKey( hkey );
    return 0;
}
#endif


VOID
TerminatePbk(
    void )

    /* Terminate  the PBK library.  This routine should be called after all
    ** PBK library access is complete.  See also InitializePbk.
    */
{
    if (g_hmutexPb)
    {
        CloseHandle( g_hmutexPb );
    }
}


#if 0
DWORD
UpgradePhonebookFile(
    IN  TCHAR*  pszPhonebookPath,
    IN  PBUSER* pUser,
    OUT BOOL*   pfUpgraded )

    /* Upgrades phonebook file 'pszPhonebookPath' to the current phonebook
    ** format if it is out of date, in which case '*pfUpgraded' is set true.
    ** If upgrade is unnecessary or fails '*pfUpgraded' is set false.  'PUser'
    ** is the current user preferences.
    **
    ** Returns 0 if successful or a non-0 error code.
    */
{
    DWORD dwErr;
    DWORD dwVersion;

    *pfUpgraded = FALSE;
    dwVersion = 0;

    dwErr = GetPhonebookVersion( pszPhonebookPath, pUser, &dwVersion );

    if (dwErr != 0)
        return dwErr;

    if (dwVersion < 0x410)
    {
        PBFILE file;

        dwErr = ReadPhonebookFile( pszPhonebookPath, pUser, NULL, 0, &file );

        if (dwErr != 0)
            return dwErr;

        dwErr = WritePhonebookFile( &file, NULL );
        ClosePhonebookFile( &file );

        if (dwErr != 0)
            return dwErr;

        *pfUpgraded = TRUE;
    }

    return 0;
}
#endif


DWORD
WritePhonebookFile(
    IN PBFILE* pFile,
    IN TCHAR*  pszSectionToDelete )

    /* Write out any dirty globals or entries in 'pFile'.  The
    ** 'pszSectionToDelete' indicates a section to delete or is NULL.
    **
    ** Returns 0 if successful, otherwise a non-zero error code.
    */
{
    DWORD    dwErr;
    HRASFILE h = pFile->hrasfile;

    TRACE("WritePhonebookFile");

    if (pszSectionToDelete)
    {
        CHAR* pszSectionToDeleteA;

        pszSectionToDeleteA = StrDupAFromT( pszSectionToDelete );
        if (!pszSectionToDeleteA)
            return ERROR_NOT_ENOUGH_MEMORY;

        if (RasfileFindSectionLine( h, pszSectionToDeleteA, TRUE ))
            DeleteCurrentSection( h );

        Free( pszSectionToDeleteA );
    }

    dwErr = ModifyEntryList( pFile );
    if (dwErr != 0)
        return dwErr;

    {
        BOOL f;

        ASSERT(g_hmutexPb);
        WaitForSingleObject( g_hmutexPb, INFINITE );

        f = RasfileWrite( h, NULL );

        ReleaseMutex( g_hmutexPb );

        if (!f)
            return ERROR_CANNOT_WRITE_PHONEBOOK;
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\nt4\common\pbk\pbk.c ===
/* Copyright (c) 1995, Microsoft Corporation, all rights reserved
**
** pbk.c
** Remote Access phonebook library
** General routines
** Listed alphabetically
**
** 06/20/95 Steve Cobb
*/

#include "pbkp.h"
#include <search.h>  // Qsort


/*----------------------------------------------------------------------------
** Local prototypes
**----------------------------------------------------------------------------
*/

DWORD
AppendPbportToList(
    IN DTLLIST*     pdtllist,
    IN RASMAN_PORT* pPort );

DWORD
AppendStringToList(
    IN DTLLIST* pdtllist,
    IN TCHAR*   psz );

int __cdecl
CompareDevices(
    const void* pDevice1,
    const void* pDevice2 );

int __cdecl
ComparePorts(
    const void* pPort1,
    const void* pPort2 );

CHAR*
PbMedia(
    IN PBDEVICETYPE pbdt,
    IN CHAR*        pszMedia );

/*----------------------------------------------------------------------------
** Routines
**----------------------------------------------------------------------------
*/

DWORD
AppendPbportToList(
    IN DTLLIST*     pdtllist,
    IN RASMAN_PORT* pPort )

    /* Append a PBPORT onto the list 'pdtllist' which has the characteristics
    ** of RAS Manager port 'pPort'.
    **
    ** Returns 0 if successful, otherwise a non-zero error code.
    */
{
    DWORD    dwErr;
    DTLNODE* pdtlnode;
    PBPORT*  ppbport;

    dwErr = 0;

    pdtlnode = CreatePortNode();
    if (!pdtlnode)
        return ERROR_NOT_ENOUGH_MEMORY;

    ppbport = (PBPORT* )DtlGetData( pdtlnode );

    ppbport->pszDevice = StrDupTFromA( pPort->P_DeviceName );
    ppbport->pszPort = StrDupTFromA( pPort->P_PortName );
    ppbport->pbdevicetype = PbdevicetypeFromPszTypeA( pPort->P_DeviceType );
    ppbport->pszMedia = StrDupTFromA(
        PbMedia( ppbport->pbdevicetype, pPort->P_MediaName ) );

    if (!ppbport->pszPort || !ppbport->pszDevice || !ppbport->pszMedia)
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
    else if (ppbport->pbdevicetype == PBDT_Modem)
    {
        if (pPort->P_LineDeviceId == 0xFFFFFFFF)
        {
            /* MXS modem port.
            */
            ppbport->fMxsModemPort = TRUE;

            GetRasPortMaxBps( pPort->P_Handle,
                &ppbport->dwMaxConnectBps, &ppbport->dwMaxCarrierBps );

            GetRasPortModemSettings( pPort->P_Handle, &ppbport->fHwFlowDefault,
                &ppbport->fEcDefault, &ppbport->fEccDefault );
        }
        else
        {
            /* Unimodem port.
            */
            UNIMODEMINFO info;

            GetRasUnimodemInfo( pPort->P_Handle, pPort->P_DeviceType, &info );

            TRACE6("Port=%s,fHw=%d,fEc=%d,fEcc=%d,bps=%d,fSp=%d",
                pPort->P_PortName,info.fHwFlow,info.fEc,info.fEcc,
                info.dwBps,info.fSpeaker);

            ppbport->fHwFlowDefault = info.fHwFlow;
            ppbport->fEcDefault = info.fEc;
            ppbport->fEccDefault = info.fEcc;
            ppbport->dwBpsDefault = info.dwBps;
            ppbport->fSpeakerDefault = info.fSpeaker;
        }
    }

    if (dwErr == 0)
        DtlAddNodeLast( pdtllist, pdtlnode );
    else
    {
        Free0( ppbport->pszDevice );
        Free0( ppbport->pszMedia );
        Free0( ppbport->pszPort );
        DtlDestroyNode( pdtlnode );
    }

    return dwErr;
}


DWORD
AppendStringToList(
    IN DTLLIST* pdtllist,
    IN TCHAR*   psz )

    /* Appends a copy of 'psz' to the end of list 'pdtllist'.
    **
    ** Returns 0 if successful, otherwise a non-zero error code.
    ** ERROR_NOT_ENOUGH_MEMORY is returned if 'psz' is NULL.
    */
{
    DTLNODE* pdtlnode;
    TCHAR*   pszDup;

    if (!psz)
        return ERROR_NOT_ENOUGH_MEMORY;

    pszDup = StrDup( psz );
    if (!pszDup)
        return ERROR_NOT_ENOUGH_MEMORY;

    pdtlnode = DtlCreateNode( pszDup, 0L );
    if (!pdtlnode )
    {
        Free( pszDup );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    DtlAddNodeLast( pdtllist, pdtlnode );
    return 0;
}


DTLNODE*
CloneEntryNode(
    DTLNODE* pdtlnodeSrc )

    /* Duplicates entry node 'pdtlnodeSrc' with fields that cannot be cloned
    ** set to "like new" settings.
    */
{
    DTLNODE* pdtlnode;

    pdtlnode = DuplicateEntryNode( pdtlnodeSrc );
    if (pdtlnode)
    {
        PBENTRY* ppbentry = (PBENTRY* )DtlGetData( pdtlnode );
        ASSERT(ppbentry);

        ppbentry->fSkipDownLevelDialog = FALSE;
        ppbentry->fSkipNwcWarning = FALSE;
        ppbentry->dwDialParamsUID = GetTickCount();
        ppbentry->fUsePwForNetwork = FALSE;
        ppbentry->fDirty = FALSE;
    }

    return pdtlnode;
}


int __cdecl
CompareDevices(
    const void* pDevice1,
    const void* pDevice2 )

    /* Qsort compare function for RASMAN_DEVICEs.
    */
{
    return
        lstrcmpiA( ((RASMAN_DEVICE* )pDevice1)->D_Name,
                   ((RASMAN_DEVICE* )pDevice2)->D_Name );
}


int __cdecl
ComparePorts(
    const void* pPort1,
    const void* pPort2 )

    /* Qsort compare function for RASMAN_PORTs.
    */
{
    return
        lstrcmpiA( ((RASMAN_PORT* )pPort1)->P_PortName,
                   ((RASMAN_PORT* )pPort2)->P_PortName );
}


DWORD
CopyToPbport(
    IN PBPORT* ppbportDst,
    IN PBPORT* ppbportSrc )

    /* Make a duplicate of 'ppbportSrc' in 'ppbportDst'.  If 'ppbportSrc' is
    ** NULL it sets 'ppbportDst' to defaults.
    **
    ** Returns 0 if successful or an error code.
    */
{
    Free0( ppbportDst->pszDevice );
    Free0( ppbportDst->pszMedia );
    Free0( ppbportDst->pszPort );

    if (!ppbportSrc)
    {
        ppbportDst->pszPort = NULL;
        ppbportDst->fConfigured = TRUE;
        ppbportDst->pszDevice = NULL;
        ppbportDst->pszMedia = NULL;
        ppbportDst->pbdevicetype = PBDT_None;
        ppbportDst->fMxsModemPort = FALSE;
        ppbportDst->dwMaxConnectBps = 0;
        ppbportDst->dwMaxCarrierBps = 0;
        ppbportDst->fHwFlowDefault = FALSE;
        ppbportDst->fEcDefault = FALSE;
        ppbportDst->fEccDefault = FALSE;
        ppbportDst->dwBpsDefault = 0;
        ppbportDst->fSpeakerDefault = TRUE;
        return 0;
    }

    CopyMemory( ppbportDst, ppbportSrc, sizeof(*ppbportDst) );
    ppbportDst->pszDevice = StrDup( ppbportSrc->pszDevice );
    ppbportDst->pszMedia = StrDup( ppbportSrc->pszMedia );
    ppbportDst->pszPort = StrDup( ppbportSrc->pszPort );

    if ((ppbportSrc->pszDevice && !ppbportDst->pszDevice)
        || (ppbportSrc->pszMedia && !ppbportDst->pszMedia)
        || (ppbportSrc->pszPort && !ppbportDst->pszPort))
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    return 0;
}


DTLNODE*
CreateEntryNode(
    BOOL fCreateLink )

    /* Allocates a sized phonebook entry node and fills it with default
    ** values.  If 'fCreateLink' is true a default node is added the list of
    ** links.  Otherwise, the list of links is empty.
    **
    ** Returns the address of the allocated node if successful, NULL
    ** otherwise.
    */
{
    DTLNODE* pdtlnode;
    PBENTRY* ppbentry;

    TRACE("CreateEntryNode");

    pdtlnode = DtlCreateSizedNode( sizeof(PBENTRY), 0L );
    if (!pdtlnode)
        return NULL;

    ppbentry = (PBENTRY* )DtlGetData( pdtlnode );
    ASSERT(ppbentry);

    /* Basic page fields.
    */
    ppbentry->pszEntryName = NULL;
    ppbentry->pszDescription = NULL;
    ppbentry->pszAreaCode = NULL;
    ppbentry->dwCountryCode = 1;
    ppbentry->dwCountryID = 1;
    ppbentry->fUseCountryAndAreaCode = FALSE;

    /* The list of links is created but left empty.
    */
    ppbentry->pdtllistLinks = DtlCreateList( 0 );
    if (!ppbentry->pdtllistLinks)
    {
        DestroyEntryNode( pdtlnode );
        return NULL;
    }

    if (fCreateLink)
    {
        DTLNODE* pLinkNode;

        pLinkNode = CreateLinkNode();
        if (!pLinkNode)
        {
            DestroyEntryNode( pdtlnode );
            return NULL;
        }

        DtlAddNodeLast( ppbentry->pdtllistLinks, pLinkNode );
    }

    ppbentry->dwDialMode = RASEDM_DialAll;
    ppbentry->dwDialPercent = 90;
    ppbentry->dwDialSeconds = 120;
    ppbentry->dwHangUpPercent = 50;
    ppbentry->dwHangUpSeconds = 120;

    /* Server page fields.
    */
    ppbentry->dwBaseProtocol = BP_Ppp;
    ppbentry->dwfExcludedProtocols = 0;
    ppbentry->fLcpExtensions = TRUE;
    ppbentry->dwAuthentication = (DWORD )AS_Default;
    ppbentry->fSkipNwcWarning = FALSE;
    ppbentry->fSkipDownLevelDialog = FALSE;
    ppbentry->fSwCompression = TRUE;

    /* TCPIP Settings dialog.
    */
    ppbentry->fIpPrioritizeRemote = TRUE;
    ppbentry->fIpHeaderCompression = TRUE;
    ppbentry->pszIpAddress = NULL;
    ppbentry->pszIpDnsAddress = NULL;
    ppbentry->pszIpDns2Address = NULL;
    ppbentry->pszIpWinsAddress = NULL;
    ppbentry->pszIpWins2Address = NULL;
    ppbentry->dwIpAddressSource = ASRC_ServerAssigned;
    ppbentry->dwIpNameSource = ASRC_ServerAssigned;
    ppbentry->dwFrameSize = 1006;

    /* Script settings.
    */
    ppbentry->dwScriptModeBefore = SM_None;
    ppbentry->pszScriptBefore = NULL;
    ppbentry->dwScriptModeAfter = SM_None;
    ppbentry->pszScriptAfter = NULL;

    /* Security page fields.
    */
    ppbentry->dwAuthRestrictions = AR_AuthAny;
    ppbentry->dwDataEncryption = DE_None;
    ppbentry->fAutoLogon = FALSE;
    ppbentry->fSecureLocalFiles = FALSE;
    ppbentry->fAuthenticateServer = FALSE;

    /* X.25 page fields.
    */
    ppbentry->pszX25Network = NULL;
    ppbentry->pszX25Address = NULL;
    ppbentry->pszX25UserData = NULL;
    ppbentry->pszX25Facilities = NULL;

    /* (Router) Dialing page fields.
    */
    ppbentry->dwfOverridePref = 0;
    ppbentry->dwIdleDisconnectSeconds = 0;
    ppbentry->dwRedialAttempts = 3;
    ppbentry->dwRedialSeconds = 60;
    ppbentry->fRedialOnLinkFailure = FALSE;
    ppbentry->fPopupOnTopWhenRedialing = TRUE;
    ppbentry->dwCallbackMode = CBM_No;

    /* Other fields not shown in UI.
    */
    ppbentry->pszCustomDialDll = NULL;
    ppbentry->pszCustomDialFunc = NULL;

    /* Authentication dialog fields.
    */
    ppbentry->dwDialParamsUID = GetTickCount();
    ppbentry->fUsePwForNetwork = FALSE;
    ppbentry->pszOldUser = NULL;
    ppbentry->pszOldDomain = NULL;

    /* Status flags.  'fDirty' is set when the entry has changed so as to
    ** differ from the phonebook file on disk.  'fCustom' is set when the
    ** entry contains at least one MEDIA and DEVICE (so RASAPI is able to read
    ** it) but was not created by us.  When 'fCustom' is set only 'pszEntry'
    ** is guaranteed valid and the entry cannot be edited.
    */
    ppbentry->fDirty = FALSE;
    ppbentry->fCustom = FALSE;

    return pdtlnode;
}


DTLNODE*
CreateLinkNode(
    void )

    /* Allocates a sized phonebook entry link node and fills it with default
    ** values.
    **
    ** Returns the address of the allocated node if successful, NULL
    ** otherwise.  It's the caller's responsibility to free the block.
    */
{
    DTLNODE* pdtlnode;
    PBLINK*  ppblink;

    TRACE("CreateLinkNode");

    pdtlnode = DtlCreateSizedNode( sizeof(PBLINK), 0L );
    if (!pdtlnode)
        return NULL;

    ppblink = (PBLINK* )DtlGetData( pdtlnode );
    ASSERT(ppblink);

    CopyToPbport( &ppblink->pbport, NULL );
    ppblink->fOtherPortOk = TRUE;

    ppblink->dwBps = 0;
    ppblink->fHwFlow = TRUE;
    ppblink->fEc = TRUE;
    ppblink->fEcc = TRUE;
    ppblink->fManualDial = FALSE;
    ppblink->fSpeaker = TRUE;

    ppblink->fProprietaryIsdn = FALSE;
    ppblink->lLineType = 0;
    ppblink->fFallback = TRUE;
    ppblink->fCompression = TRUE;
    ppblink->lChannels = 1;

    ppblink->pTapiBlob = NULL;
    ppblink->cbTapiBlob = 0;
    ppblink->fPromoteHuntNumbers = TRUE;

    ppblink->fEnabled = TRUE;

    /* The list of phone numbers is created but left empty.
    */
    ppblink->pdtllistPhoneNumbers = DtlCreateList( 0 );
    if (!ppblink->pdtllistPhoneNumbers)
    {
        Free( ppblink );
        return NULL;
    }

    return pdtlnode;
}


DTLNODE*
CreatePortNode(
    void )

    /* Allocates a sized port node and fills it with default values.
    **
    ** Returns the address of the allocated node if successful, NULL
    ** otherwise.  It's the caller's responsibility to free the block.
    */
{
    DTLNODE* pdtlnode;
    PBPORT*  ppbport;

    TRACE("CreatePortNode");

    pdtlnode = DtlCreateSizedNode( sizeof(PBPORT), 0L );
    if (!pdtlnode)
        return NULL;

    ppbport = (PBPORT* )DtlGetData( pdtlnode );
    ASSERT(ppbport);

    CopyToPbport( ppbport, NULL );

    return pdtlnode;
}


VOID
DestroyEntryNode(
    IN DTLNODE* pdtlnode )

    /* Release all memory associated with phonebook entry node 'pdtlnode'.
    ** See DtlDestroyList.
    */
{
    PBENTRY* ppbentry;

    TRACE("DestroyEntryNode");

    ASSERT(pdtlnode);
    ppbentry = (PBENTRY* )DtlGetData( pdtlnode );
    ASSERT(ppbentry);

    Free0( ppbentry->pszEntryName );
    Free0( ppbentry->pszDescription );
    Free0( ppbentry->pszAreaCode );
    Free0( ppbentry->pszIpAddress );
    Free0( ppbentry->pszIpDnsAddress );
    Free0( ppbentry->pszIpDns2Address );
    Free0( ppbentry->pszIpWinsAddress );
    Free0( ppbentry->pszIpWins2Address );
    Free0( ppbentry->pszScriptBefore );
    Free0( ppbentry->pszScriptAfter );
    Free0( ppbentry->pszX25Network );
    Free0( ppbentry->pszX25Address );
    Free0( ppbentry->pszX25UserData );
    Free0( ppbentry->pszX25Facilities );
    Free0( ppbentry->pszCustomDialDll );
    Free0( ppbentry->pszCustomDialFunc );
    Free0( ppbentry->pszOldUser );
    Free0( ppbentry->pszOldDomain );
    DtlDestroyList( ppbentry->pdtllistLinks, DestroyLinkNode );

    DtlDestroyNode( pdtlnode );
}


VOID
DestroyLinkNode(
    IN DTLNODE* pdtlnode )

    /* Release all memory associated with phonebook entry link node
    ** 'pdtlnode'.  See DtlDestroyList.
    */
{
    PBLINK* ppblink;

    TRACE("DestroyLinkNode");

    ASSERT(pdtlnode);
    ppblink = (PBLINK* )DtlGetData( pdtlnode );
    ASSERT(ppblink);

    Free( ppblink->pbport.pszDevice );
    Free( ppblink->pbport.pszMedia );
    Free0( ppblink->pbport.pszPort );
    Free0( ppblink->pTapiBlob );
    DtlDestroyList( ppblink->pdtllistPhoneNumbers, DestroyPszNode );

    DtlDestroyNode( pdtlnode );
}


VOID
DestroyPortNode(
    IN DTLNODE* pdtlnode )

    /* Release memory associated with PBPORT node 'pdtlnode'.  See
    ** DtlDestroyList.
    */
{
    PBPORT* pPort;

    TRACE("DestroyPortNode");

    ASSERT(pdtlnode);
    pPort = (PBPORT* )DtlGetData( pdtlnode );
    ASSERT(pPort);

    Free0( pPort->pszDevice );
    Free0( pPort->pszMedia );
    Free0( pPort->pszPort );

    DtlDestroyNode( pdtlnode );
}


DTLNODE*
DuplicateEntryNode(
    DTLNODE* pdtlnodeSrc )

    /* Duplicates phonebook entry node 'pdtlnodeSrc'.  See CloneEntryNode and
    ** DtlDuplicateList.
    **
    ** Returns the address of the allocated node if successful, NULL
    ** otherwise.  It's the caller's responsibility to free the block.
    */
{
    DTLNODE* pdtlnodeDst;
    PBENTRY* ppbentrySrc;
    PBENTRY* ppbentryDst;
    BOOL     fDone;

    TRACE("DuplicateEntryNode");

    pdtlnodeDst = DtlCreateSizedNode( sizeof(PBENTRY), 0L );
    if (!pdtlnodeDst)
        return NULL;

    ppbentrySrc = (PBENTRY* )DtlGetData( pdtlnodeSrc );
    ppbentryDst = (PBENTRY* )DtlGetData( pdtlnodeDst );
    fDone = FALSE;

    CopyMemory( ppbentryDst, ppbentrySrc, sizeof(PBENTRY) );

    ppbentryDst->pszEntryName = NULL;
    ppbentryDst->pszDescription = NULL;
    ppbentryDst->pszAreaCode = NULL;
    ppbentryDst->pszIpAddress = NULL;
    ppbentryDst->pszIpDnsAddress = NULL;
    ppbentryDst->pszIpDns2Address = NULL;
    ppbentryDst->pszIpWinsAddress = NULL;
    ppbentryDst->pszIpWins2Address = NULL;
    ppbentryDst->pszScriptBefore = NULL;
    ppbentryDst->pszScriptAfter = NULL;
    ppbentryDst->pszX25Network = NULL;
    ppbentryDst->pszX25Address = NULL;
    ppbentryDst->pszX25UserData = NULL;
    ppbentryDst->pszX25Facilities = NULL;
    ppbentryDst->pszCustomDialDll = NULL;
    ppbentryDst->pszCustomDialFunc = NULL;
    ppbentryDst->pszOldUser = NULL;
    ppbentryDst->pszOldDomain = NULL;
    ppbentryDst->pdtllistLinks = NULL;

    do
    {
        /* Duplicate strings.
        */
        if (ppbentrySrc->pszEntryName
            && (!(ppbentryDst->pszEntryName =
                    StrDup( ppbentrySrc->pszEntryName ))))
        {
            break;
        }

        if (ppbentrySrc->pszDescription
            && (!(ppbentryDst->pszDescription =
                    StrDup( ppbentrySrc->pszDescription ))))
        {
            break;
        }

        if (ppbentrySrc->pszAreaCode
            && (!(ppbentryDst->pszAreaCode =
                    StrDup( ppbentrySrc->pszAreaCode ))))
        {
            break;
        }

        if (ppbentrySrc->pszIpAddress
            && (!(ppbentryDst->pszIpAddress =
                    StrDup( ppbentrySrc->pszIpAddress ))))
        {
            break;
        }

        if (ppbentrySrc->pszIpDnsAddress
            && (!(ppbentryDst->pszIpDnsAddress =
                    StrDup( ppbentrySrc->pszIpDnsAddress ))))
        {
            break;
        }

        if (ppbentrySrc->pszIpDns2Address
            && (!(ppbentryDst->pszIpDns2Address =
                    StrDup( ppbentrySrc->pszIpDns2Address ))))
        {
            break;
        }

        if (ppbentrySrc->pszIpWinsAddress
            && (!(ppbentryDst->pszIpWinsAddress =
                    StrDup( ppbentrySrc->pszIpWinsAddress ))))
        {
            break;
        }

        if (ppbentrySrc->pszIpWins2Address
            && (!(ppbentryDst->pszIpWins2Address =
                    StrDup( ppbentrySrc->pszIpWins2Address ))))
        {
            break;
        }

        if (ppbentrySrc->pszScriptBefore
            && (!(ppbentryDst->pszScriptBefore =
                    StrDup( ppbentrySrc->pszScriptBefore ))))
        {
            break;
        }

        if (ppbentrySrc->pszScriptAfter
            && (!(ppbentryDst->pszScriptAfter =
                    StrDup( ppbentrySrc->pszScriptAfter ))))
        {
            break;
        }

        if (ppbentrySrc->pszX25Network
            && (!(ppbentryDst->pszX25Network =
                    StrDup( ppbentrySrc->pszX25Network ))))
        {
            break;
        }

        if (ppbentrySrc->pszX25Address
            && (!(ppbentryDst->pszX25Address =
                    StrDup( ppbentrySrc->pszX25Address ))))
        {
            break;
        }

        if (ppbentrySrc->pszX25UserData
            && (!(ppbentryDst->pszX25UserData =
                    StrDup( ppbentrySrc->pszX25UserData ))))
        {
            break;
        }

        if (ppbentrySrc->pszX25Facilities
            && (!(ppbentryDst->pszX25Facilities =
                    StrDup( ppbentrySrc->pszX25Facilities ))))
        {
            break;
        }

        if (ppbentrySrc->pszCustomDialDll
            && (!(ppbentryDst->pszCustomDialDll =
                    StrDup( ppbentrySrc->pszCustomDialDll ))))
        {
            break;
        }

        if (ppbentrySrc->pszCustomDialFunc
            && (!(ppbentryDst->pszCustomDialFunc =
                    StrDup( ppbentrySrc->pszCustomDialFunc ))))
        {
            break;
        }

        if (ppbentrySrc->pszOldUser
            && (!(ppbentryDst->pszOldUser =
                    StrDup( ppbentrySrc->pszOldUser ))))
        {
            break;
        }

        if (ppbentrySrc->pszOldDomain
            && (!(ppbentryDst->pszOldDomain =
                    StrDup( ppbentrySrc->pszOldDomain ))))
        {
            break;
        }

        /* Duplicate list of link information.
        */
        if (ppbentrySrc->pdtllistLinks
            &&  (!(ppbentryDst->pdtllistLinks =
                     DtlDuplicateList(
                         ppbentrySrc->pdtllistLinks,
                         DuplicateLinkNode,
                         DestroyLinkNode ))))
        {
            break;
        }

        fDone = TRUE;
    }
    while (FALSE);

    if (!fDone)
    {
        DestroyEntryNode( pdtlnodeDst );
        return NULL;
    }

    /* Since the copy is "new" it is inherently dirty relative to the
    ** phonebook file.
    */
    ppbentryDst->fDirty = TRUE;

    return pdtlnodeDst;
}


DTLNODE*
DuplicateLinkNode(
    IN DTLNODE* pdtlnodeSrc )

    /* Duplicates phonebook entry link node 'pdtlnodeSrc'.  See
    ** DtlDuplicateList.
    **
    ** Returns the address of the allocated node if successful, NULL
    ** otherwise.  It's the caller's responsibility to free the block.
    */
{
    DTLNODE* pdtlnodeDst;
    PBLINK*  ppblinkSrc;
    PBLINK*  ppblinkDst;
    BOOL     fDone;

    TRACE("DuplicateLinkNode");

    pdtlnodeDst = DtlCreateSizedNode( sizeof(PBLINK), 0L );
    if (!pdtlnodeDst)
        return NULL;

    ppblinkSrc = (PBLINK* )DtlGetData( pdtlnodeSrc );
    ppblinkDst = (PBLINK* )DtlGetData( pdtlnodeDst );
    fDone = FALSE;

    CopyMemory( ppblinkDst, ppblinkSrc, sizeof(PBLINK) );

    ppblinkDst->pbport.pszDevice = NULL;
    ppblinkDst->pbport.pszMedia = NULL;
    ppblinkDst->pbport.pszPort = NULL;
    ppblinkDst->pTapiBlob = NULL;
    ppblinkDst->pdtllistPhoneNumbers = NULL;

    do
    {
        /* Duplicate strings.
        */
        if (ppblinkSrc->pbport.pszDevice
            && (!(ppblinkDst->pbport.pszDevice =
                    StrDup( ppblinkSrc->pbport.pszDevice ))))
        {
            break;
        }

        if (ppblinkSrc->pbport.pszMedia
            && (!(ppblinkDst->pbport.pszMedia =
                    StrDup( ppblinkSrc->pbport.pszMedia ))))
        {
            break;
        }


        if (ppblinkSrc->pbport.pszPort
            && (!(ppblinkDst->pbport.pszPort =
                    StrDup( ppblinkSrc->pbport.pszPort ))))
        {
            break;
        }
        /* Duplicate TAPI blob.
        */
        if (ppblinkSrc->pTapiBlob)
        {
            VOID* pTapiBlobDst;

            ppblinkDst->pTapiBlob = (VOID* )Malloc( ppblinkSrc->cbTapiBlob );
            if (!ppblinkDst->pTapiBlob)
                break;

            CopyMemory( ppblinkDst->pTapiBlob, ppblinkSrc->pTapiBlob,
                ppblinkSrc->cbTapiBlob );
        }

        /* Duplicate list of phone numbers.
        */
        if (ppblinkSrc->pdtllistPhoneNumbers
            &&  (!(ppblinkDst->pdtllistPhoneNumbers =
                     DtlDuplicateList(
                         ppblinkSrc->pdtllistPhoneNumbers,
                         DuplicatePszNode,
                         DestroyPszNode ))))
        {
            break;
        }

        fDone = TRUE;
    }
    while (FALSE);

    if (!fDone)
    {
        DestroyLinkNode( pdtlnodeDst );
        return NULL;
    }

    return pdtlnodeDst;
}


DTLNODE*
EntryNodeFromName(
    IN DTLLIST* pdtllistEntries,
    IN TCHAR*   pszName )

    /* Returns the address of the node in the global phonebook entries list
    ** whose Entry Name matches 'pszName' or NULL if none.
    */
{
    DTLNODE* pdtlnode;

    for (pdtlnode = DtlGetFirstNode( pdtllistEntries );
         pdtlnode;
         pdtlnode = DtlGetNextNode( pdtlnode ))
    {
        PBENTRY* ppbentry = (PBENTRY* )DtlGetData( pdtlnode );

        if (lstrcmpi( ppbentry->pszEntryName, pszName ) == 0)
            return pdtlnode;
    }

    return NULL;
}


#if 0
INT
IndexFromName(
    IN DTLLIST* pdtllist,
    IN TCHAR*   pszName )

    /* Returns the 0-based index of the first node that matches 'pszName' in
    ** the linked list of strings, 'pdtllist', or -1 if not found.
    */
{
    DTLNODE* pdtlnode;
    INT      i;

    for (pdtlnode = DtlGetFirstNode( pdtllist ), i = 0;
         pdtlnode;
         pdtlnode = DtlGetNextNode( pdtlnode ), ++i)
    {
        if (lstrcmp( pszName, (TCHAR* )DtlGetData( pdtlnode ) ) == 0)
            break;
    }

    return (pdtlnode) ? i : -1;
}
#endif


#if 0
INT
IndexFromDeviceName(
    IN DTLLIST* pdtllist,
    IN TCHAR*   pszDeviceName )

    /* Returns the 0-based index of the first node that matches
    ** 'pszDeviceName' in the linked list of PBPORTs, 'pdtllist', or -1 if not
    ** found.
    */
{
    DTLNODE* pdtlnode;
    INT      i;

    for (pdtlnode = DtlGetFirstNode( pdtllist ), i = 0;
         pdtlnode;
         pdtlnode = DtlGetNextNode( pdtlnode ), ++i)
    {
        PBPORT* pPort = (PBPORT* )DtlGetData( pdtlnode );

        if (lstrcmp( pszDeviceName, pPort->pszDevice ) == 0)
            break;
    }

    return (pdtlnode) ? i : -1;
}
#endif


DWORD
LoadPadsList(
    OUT DTLLIST** ppdtllistPads )

    /* Build a list of all X.25 PAD devices in '*ppdtllistPads'.
    **
    ** Returns 0 if successful, otherwise a non-zero error code.  It is
    ** caller's responsibility to DtlDestroyList the list when done.
    */
{
    INT            i;
    DWORD          dwErr;
    RASMAN_DEVICE* pDevices;
    WORD           wDevices;

    TRACE("LoadPadsList");

    *ppdtllistPads = NULL;

    dwErr = GetRasPads( &pDevices, &wDevices );
    if (dwErr != 0)
        return dwErr;

    *ppdtllistPads = DtlCreateList( 0L );
    if (!*ppdtllistPads)
    {
        Free( pDevices );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    qsort( (VOID* )pDevices, (size_t )wDevices, sizeof(RASMAN_DEVICE),
           CompareDevices );

    for (i = 0; i < (INT )wDevices; ++i)
    {
        TCHAR* pszDup;

        pszDup = StrDupTFromA( pDevices[ i ].D_Name );
        dwErr = AppendStringToList( *ppdtllistPads, pszDup );
        Free0( pszDup );

        if (dwErr != 0)
        {
            Free( pDevices );
            DtlDestroyList( *ppdtllistPads, NULL );
            *ppdtllistPads = NULL;
            return dwErr;
        }
    }

    Free( pDevices );

    TRACE("LoadPadsList=0");
    return 0;
}


DWORD
LoadPortsList(
    OUT DTLLIST** ppdtllistPorts )

    /* Build a sorted list of all RAS ports in '*ppdtllistPorts'.
    **
    ** Returns 0 if successful, otherwise a non-zero error code.  It is
    ** caller's responsibility to DtlDestroyList the list when done.
    */
{
    return LoadPortsList2( ppdtllistPorts, FALSE );
}


DWORD
LoadPortsList2(
    OUT DTLLIST** ppdtllistPorts,
    OUT BOOL      fRouter )

    /* Build a sorted list of all RAS ports in '*ppdtllistPorts'.  'FRouter'
    ** indicates only ports with "router" usage should be returned.
    ** Otherwise, only dialout ports are returned.
    **
    ** Returns 0 if successful, otherwise a non-zero error code.  It is
    ** caller's responsibility to DtlDestroyList the list when done.
    */
{
    INT          i;
    DWORD        dwErr;
    RASMAN_PORT* pPorts;
    RASMAN_PORT* pPort;
    WORD         wPorts;

    TRACE("LoadPortsList2");

    *ppdtllistPorts = NULL;

    dwErr = GetRasPorts( &pPorts, &wPorts );
    if (dwErr != 0)
        return dwErr;

    *ppdtllistPorts = DtlCreateList( 0L );
    if (!*ppdtllistPorts)
        return ERROR_NOT_ENOUGH_MEMORY;

    qsort( (VOID* )pPorts, (size_t )wPorts, sizeof(RASMAN_PORT),
           ComparePorts );

    for (i = 0, pPort = pPorts; i < (INT )wPorts; ++i, ++pPort)
    {
        if (fRouter)
        {
            /* We're only interested in router ports.
            */
            if (!(pPort->P_ConfiguredUsage & CALL_ROUTER))
                continue;
        }
        else
        {
            /* We're only interested in ports you can dial-out on.
            */
            if (!(pPort->P_ConfiguredUsage & CALL_OUT))
                continue;
        }

        dwErr = AppendPbportToList( *ppdtllistPorts, pPort );
        if (dwErr != 0)
        {
            Free( pPorts );
            DtlDestroyList( *ppdtllistPorts, NULL );
            *ppdtllistPorts = NULL;
            return dwErr;
        }
    }

    Free( pPorts );

    TRACE("LoadPortsList=0");
    return 0;
}


DWORD
LoadScriptsList(
    OUT DTLLIST** ppdtllistScripts )

    /* Build a sorted list of all RAS switch devices in '*ppdtllistPorts'.
    **
    ** Returns 0 if successful, otherwise a non-zero error code.  It is
    ** caller's responsibility to DtlDestroyList the list when done.
    */
{
    INT            i;
    DWORD          dwErr;
    RASMAN_DEVICE* pDevices;
    WORD           wDevices;

    TRACE("LoadScriptsList");

    *ppdtllistScripts = NULL;

    dwErr = GetRasSwitches( &pDevices, &wDevices );
    if (dwErr != 0)
        return dwErr;

    *ppdtllistScripts = DtlCreateList( 0L );
    if (!*ppdtllistScripts)
    {
        Free( pDevices );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    qsort( (VOID* )pDevices, (size_t )wDevices, sizeof(RASMAN_DEVICE),
           CompareDevices );

    for (i = 0; i < (INT )wDevices; ++i)
    {
        TCHAR* pszDup;

        pszDup = StrDupTFromA( pDevices[ i ].D_Name );
        dwErr = AppendStringToList( *ppdtllistScripts, pszDup );
        Free( pszDup );

        if (dwErr != 0)
        {
            Free( pDevices );
            DtlDestroyList( *ppdtllistScripts, NULL );
            *ppdtllistScripts = NULL;
            return dwErr;
        }
    }

    Free( pDevices );

    TRACE("LoadScriptsList=0");
    return 0;
}


#if 0
TCHAR*
NameFromIndex(
    IN DTLLIST* pdtllist,
    IN INT      iToFind )

    /* Returns the name associated with 0-based index 'iToFind' in the linked
    ** list of strings, 'pdtllist', or NULL if not found.
    */
{
    DTLNODE* pdtlnode;

    if (!pdtllist)
        return NULL;

    pdtlnode = DtlGetFirstNode( pdtllist );

    if (iToFind < 0)
        return NULL;

    while (pdtlnode && iToFind--)
        pdtlnode = DtlGetNextNode( pdtlnode );

    return (pdtlnode) ? (TCHAR* )DtlGetData( pdtlnode ) : NULL;
}
#endif


PBDEVICETYPE
PbdevicetypeFromPszType(
    IN TCHAR* pszDeviceType )

    /* Returns the device type corresponding to the device type string,
    ** 'pszDeviceType'.
    */
{
    CHAR*        pszA;
    PBDEVICETYPE pbdt;

    pbdt = PBDT_None;
    pszA = StrDupAFromT( pszDeviceType );
    if (pszA)
    {
        pbdt = PbdevicetypeFromPszTypeA( pszA );
        Free( pszA );
    }
    return pbdt;
}


PBDEVICETYPE
PbdevicetypeFromPszTypeA(
    IN CHAR* pszDeviceType )

    /* Returns the device type corresponding to the ANSI device type string,
    ** 'pszDeviceType'.
    */
{
    if (*pszDeviceType == '\0')
        return PBDT_None;
    else if (lstrcmpiA( pszDeviceType, MXS_MODEM_TXT ) == 0)
        return PBDT_Modem;
    else if (lstrcmpiA( pszDeviceType, MXS_NULL_TXT ) == 0)
        return PBDT_Null;
    else if (lstrcmpiA( pszDeviceType, MXS_PAD_TXT ) == 0)
        return PBDT_Pad;
    else if (lstrcmpiA( pszDeviceType, MXS_SWITCH_TXT ) == 0)
        return PBDT_Switch;
    else if (lstrcmpiA( pszDeviceType, ISDN_TXT ) == 0)
        return PBDT_Isdn;
    else if (lstrcmpiA( pszDeviceType, X25_TXT ) == 0)
        return PBDT_X25;
    else
        return PBDT_Other;
}


CHAR*
PbMedia(
    IN PBDEVICETYPE pbdt,
    IN CHAR*        pszMedia )

    /* The media names stored in the phonebook are not exactly the same as
    ** those returned by RASMAN.  This translates a RASMAN media name to
    ** equivalent phonebook media names given the device type.  The reason for
    ** this is historical and obscure.
    */
{
    if (pbdt == PBDT_Isdn)
        return ISDN_TXT;
    else if (pbdt == PBDT_X25)
        return X25_TXT;
    else if (pbdt == PBDT_Other)
        return pszMedia;
    else
        return SERIAL_TXT;
}


PBPORT*
PpbportFromPortName(
    IN DTLLIST* pdtllistPorts,
    IN TCHAR*   pszPort )

    /* Return port with name 'pszPort' in list of ports 'pdtllistPorts' or
    ** NULL if not found.  'PszPort' may be an old-style name such as
    ** PcImacISDN1, in which case it will match ISDN1.
    */
{
    DTLNODE* pdtlnode;

    if (!pszPort)
        return NULL;

    for (pdtlnode = DtlGetFirstNode( pdtllistPorts );
         pdtlnode;
         pdtlnode = DtlGetNextNode( pdtlnode ))
    {
        PBPORT* ppbport = (PBPORT* )DtlGetData( pdtlnode );

        if (ppbport->pszPort && lstrcmp( ppbport->pszPort, pszPort ) == 0)
            return ppbport;
    }

    /* No match.  Look for the old port name format.
    */
    for (pdtlnode = DtlGetFirstNode( pdtllistPorts );
         pdtlnode;
         pdtlnode = DtlGetNextNode( pdtlnode ))
    {
        TCHAR   szBuf[ MAX_DEVICE_NAME + MAX_DEVICETYPE_NAME + 10 + 1 ];
        PBPORT* ppbport;

        ppbport = (PBPORT* )DtlGetData( pdtlnode );

        /* Skip modems (COM ports) and unconfigured ports, since they do not
        ** follow the same port name formatting rules as other ports.
        */
        if (!ppbport->pszDevice || ppbport->pbdevicetype == PBDT_Modem)
            continue;

        lstrcpy( szBuf, ppbport->pszDevice );
        lstrcat( szBuf, ppbport->pszPort );

        if (lstrcmp( szBuf, pszPort ) == 0)
            return ppbport;
    }

    return NULL;
}


BOOL
SetDefaultModemSettings(
    IN PBLINK* pLink )

    /* Set the MXS modem settings for link 'pLink' to the defaults.
    **
    ** Returns true if something changed, false otherwise.
    */
{
    BOOL  fChange;
    DWORD dwBps;

    fChange = FALSE;

    if (pLink->fHwFlow != pLink->pbport.fHwFlowDefault)
    {
        fChange = TRUE;
        pLink->fHwFlow = pLink->pbport.fHwFlowDefault;
    }

    if (pLink->fEc != pLink->pbport.fEcDefault)
    {
        fChange = TRUE;
        pLink->fEc = pLink->pbport.fEcDefault;
    }

    if (pLink->fEcc != pLink->pbport.fEccDefault)
    {
        fChange = TRUE;
        pLink->fEcc = pLink->pbport.fEccDefault;
    }

    if (pLink->fManualDial)
    {
        fChange = TRUE;
        pLink->fManualDial = FALSE;
    }

    if (!pLink->pbport.fMxsModemPort)
    {
        if (pLink->fSpeaker != pLink->pbport.fSpeakerDefault)
        {
            fChange = TRUE;
            pLink->fSpeaker = pLink->pbport.fSpeakerDefault;
        }
    }

    if (pLink->pbport.fMxsModemPort)
    {
        dwBps = (pLink->fHwFlow)
            ? pLink->pbport.dwMaxConnectBps
            : pLink->pbport.dwMaxCarrierBps;
    }
    else
        dwBps = pLink->pbport.dwBpsDefault;

    if (pLink->dwBps != dwBps)
    {
        fChange = TRUE;
        pLink->dwBps = dwBps;
    }

    TRACE2("SetDefaultModemSettings(bps=%d)=%d",pLink->dwBps,fChange);
    return fChange;
}


BOOL
ValidateAreaCode(
    IN OUT TCHAR* pszAreaCode )

    /* Checks that area code consists of decimal digits only.  If the area
    ** code is all white characters it is reduced to empty string.  Returns
    ** true if 'pszAreaCode' is a valid area code, false if not.
    */
{
    if (IsAllWhite( pszAreaCode ))
    {
        *pszAreaCode = TEXT('\0');
        return TRUE;
    }

    if (lstrlen( pszAreaCode ) > RAS_MaxAreaCode)
        return FALSE;

    while (*pszAreaCode != TEXT('\0'))
    {
        if (*pszAreaCode < TEXT('0') || *pszAreaCode > TEXT('9'))
            return FALSE;

        ++pszAreaCode;
    }

    return TRUE;
}


BOOL
ValidateEntryName(
    IN TCHAR* pszEntry )

    /* Returns true if 'pszEntry' is a valid phonebook entry name, false if
    ** not.
    */
{
    INT nLen = lstrlen( pszEntry );

    if (nLen <= 0
        || nLen > RAS_MaxEntryName
        || IsAllWhite( pszEntry )
        || pszEntry[ 0 ] == TEXT('.'))
    {
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\nt4\common\pbk\pbkp.h ===
/* Copyright (c) 1995, Microsoft Corporation, all rights reserved
**
** pbkp.h
** Remote Access phonebook file (.PBK) library
** Private header
**
** 06/20/95 Steve Cobb
*/

#ifndef _PBKP_H_
#define _PBKP_H_


#include <pbk.h>    // RAS phonebook library (our public header)
#include <stdlib.h> // ltoa
#include <debug.h>  // Trace/Assert library
#include <ras.h>    // Win32 RAS header, for constants
#include <serial.h> // RAS serial media header, for SERIAL_TXT, SER_*
#include <isdn.h>   // RAS ISDN media header, for ISDN_TXT, for ISDN_*
#include <x25.h>    // RAS X.25 media header, for X25_TXT
#include <rasmxs.h> // RAS modem/X.25/switch device header, for MXS_*


/*----------------------------------------------------------------------------
** Constants
**----------------------------------------------------------------------------
*/

/* PBK file section names.
*/
#define GLOBALSECTIONNAME "."

/* PBK file key names.
*/
#define KEY_Port                     "Port"
#define KEY_InitBps                  SER_CONNECTBPS_KEY
#define KEY_HwFlow                   MXS_HDWFLOWCONTROL_KEY
#define KEY_Ec                       MXS_PROTOCOL_KEY
#define KEY_Ecc                      MXS_COMPRESSION_KEY
#define KEY_ManualDial               "ManualDial"
#define KEY_PhoneNumber              "PhoneNumber"
#define KEY_PromoteAlternates        "PromoteAlternates"
#define KEY_AutoLogon                "AutoLogon"
#define KEY_Domain                   "Domain"
#define KEY_User                     "User"
#define KEY_UID                      "DialParamsUID"
#define KEY_SavePw                   "SavePw"
#define KEY_UsePwForNetwork          "UsePwForNetwork"
#define KEY_Device                   "Device"
#define KEY_SwCompression            "SwCompression"
#define KEY_UseCountryAndAreaCodes   "UseCountryAndAreaCodes"
#define KEY_AreaCode                 "AreaCode"
#define KEY_CountryID                "CountryID"
#define KEY_CountryCode              "CountryCode"
#define KEY_ServerType               "ServerType"
#define KEY_DialMode                 "DialMode"
#define KEY_DialPercent              "DialPercent"
#define KEY_DialSeconds              "DialSeconds"
#define KEY_HangUpPercent            "HangUpPercent"
#define KEY_HangUpSeconds            "HangUpSeconds"
#define KEY_AuthRestrictions         "AuthRestrictions"
#define KEY_TapiBlob                 "TapiBlob"
#define KEY_Type                     "Type"
#define KEY_PAD_Type                 MXS_X25PAD_KEY
#define KEY_PAD_Address              MXS_X25ADDRESS_KEY
#define KEY_PAD_UserData             MXS_USERDATA_KEY
#define KEY_PAD_Facilities           MXS_FACILITIES_KEY
#define KEY_X25_Address              X25_ADDRESS_KEY
#define KEY_X25_UserData             X25_USERDATA_KEY
#define KEY_X25_Facilities           X25_FACILITIES_KEY
#define KEY_RedialAttempts           "RedialAttempts"
#define KEY_RedialPauseSecs          "RedialPauseSecs"
#define KEY_RedialOnLinkFailure      "RedialOnLinkFailure"
#define KEY_CallbackNumber           "CallbackNumber"
#define KEY_ExcludedProtocols        "ExcludedProtocols"
#define KEY_LcpExtensions            "LcpExtensions"
#define KEY_Authentication           "Authentication"
#define KEY_BaseProtocol             "BaseProtocol"
#define KEY_Item                     "Item"
#define KEY_Selection                "Selection"
#define KEY_SlipHeaderCompression    "SlipHeaderCompression"
#define KEY_SlipFrameSize            "SlipFrameSize"
#define KEY_SlipIpAddress            "SlipIpAddress"
#define KEY_SlipPrioritizeRemote     "SlipPrioritizeRemote"
#define KEY_PppIpPrioritizeRemote    "PppIpPrioritizeRemote"
#define KEY_PppIpVjCompression       "PppIpVjCompression"
#define KEY_PppIpAddress             "PppIpAddress"
#define KEY_PppIpAddressSource       "PppIpAssign"
#define KEY_PppIpDnsAddress          "PppIpDnsAddress"
#define KEY_PppIpDns2Address         "PppIpDns2Address"
#define KEY_PppIpWinsAddress         "PppIpWinsAddress"
#define KEY_PppIpWins2Address        "PppIpWins2Address"
#define KEY_PppIpNameSource          "PppIpNameAssign"
#define KEY_IpPrioritizeRemote       "IpPrioritizeRemote"
#define KEY_IpHeaderCompression      "IpHeaderCompression"
#define KEY_IpAddress                "IpAddress"
#define KEY_IpAddressSource          "IpAssign"
#define KEY_IpDnsAddress             "IpDnsAddress"
#define KEY_IpDns2Address            "IpDns2Address"
#define KEY_IpWinsAddress            "IpWinsAddress"
#define KEY_IpWins2Address           "IpWins2Address"
#define KEY_IpNameSource             "IpNameAssign"
#define KEY_IpFrameSize              "IpFrameSize"
#define KEY_SkipNwcWarning           "SkipNwcWarning"
#define KEY_SkipDownLevelDialog      "SkipDownLevelDialog"
#define KEY_PppTextAuthentication    "PppTextAuthentication"
#define KEY_DataEncryption           "DataEncryption"
#define KEY_CustomDialDll            "CustomDialDll"
#define KEY_CustomDialFunc           "CustomDialFunc"
#define KEY_IdleDisconnectSeconds    "IdleDisconnectSeconds"
#define KEY_SecureLocalFiles         "SecureLocalFiles"
#define KEY_LineType                 ISDN_LINETYPE_KEY
#define KEY_Fallback                 ISDN_FALLBACK_KEY
#define KEY_Compression              ISDN_COMPRESSION_KEY
#define KEY_Channels                 ISDN_CHANNEL_AGG_KEY
#define KEY_Description              "Description"
#define KEY_Speaker                  "Speaker"
#define KEY_ProprietaryIsdn          "Proprietary"
#define KEY_DisableModemSpeaker      "DisableModemSpeaker"
#define KEY_DisableSwCompression     "DisableSwCompression"
#define KEY_OtherPortOk              "OtherPortOk"
#define KEY_OverridePref             "OverridePref"
#define KEY_RedialAttempts           "RedialAttempts"
#define KEY_RedialSeconds            "RedialSeconds"
#define KEY_RedialOnLinkFailure      "RedialOnLinkFailure"
#define KEY_PopupOnTopWhenRedialing  "PopupOnTopWhenRedialing"
#define KEY_CallbackMode             "CallbackMode"
#define KEY_AuthenticateServer       "AuthenticateServer"

/* The switch device type text value written to the phonebook file.
*/
#define SM_TerminalText "Terminal"


/*----------------------------------------------------------------------------
** Prototypes
**----------------------------------------------------------------------------
*/

BOOL
GetPhonebookDirectory(
    OUT TCHAR* pszPathBuf );

BOOL
GetPublicPhonebookPath(
    OUT TCHAR* pszPathBuf );

DWORD
GetPhonebookVersion(
    IN  TCHAR*  pszPhonebookPath,
    IN  PBUSER* pUser,
    OUT DWORD*  pdwVersion );

BOOL
IsDeviceLine(
    IN CHAR* pszText );

BOOL
IsMediaLine(
    IN CHAR* pszText );


#endif // _PBKP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\nt4\common\nouiutil\rassrv.c ===
/* Copyright (c) 1995, Microsoft Corporation, all rights reserved
**
** rassrv.c
** RAS Server helpers
** Listed alphabetically
**
** 03/05/96 Abolade Gbadegesin
*/

#include <windows.h>  // Win32 root
#include <debug.h>    // Trace/Assert library
#include <nouiutil.h> // Our public header
#include <raserror.h> // RAS error constants


HANDLE g_hserver = NULL;

DWORD
RasServerConnect(
    IN  HANDLE*  phserver );


DWORD
GetRasConnection0Table(
    OUT RAS_CONNECTION_0 ** ppRc0Table,
    OUT DWORD *             piRc0Count )

    /* This function queries the RAS server for a table of the inbound
    ** connections on the local machine.
    **
    ** (Abolade Gbadegesin Mar-05-1996)
    */
{

    DWORD dwErr, dwTotal;

    dwErr = RasServerConnect(&g_hserver);
    if (dwErr != NO_ERROR) { return dwErr; }

    return g_pRasAdminConnectionEnum(
                g_hserver,
                0,
                (BYTE**)ppRc0Table,
                (DWORD)-1,
                piRc0Count,
                &dwTotal,
                NULL
                );
}

DWORD
GetRasPort0Info(
    IN  HANDLE                  hPort,
    OUT RAS_PORT_1 *            pRasPort1 )

    /* This function queries the local RAS server for information
    ** about the specified port.
    **
    ** (Abolade Gbadegesin Mar-05-1996)
    */
{

    DWORD dwErr;

    dwErr = RasServerConnect(&g_hserver);
    if (dwErr != NO_ERROR) { return dwErr; }

    return g_pRasAdminPortGetInfo(
                g_hserver,
                1,
                hPort,
                (BYTE**)&pRasPort1
                );
}



DWORD
GetRasPort0Table(
    OUT RAS_PORT_0 **   ppPortTable,
    OUT DWORD *         piPortCount )

    /* This function queries the RAS server for a table of the dial-in ports
    ** on the local machine.
    **
    ** (Abolade Gbadegesin Mar-05-1996)
    */
{

    DWORD dwErr;
    DWORD dwTotal;

    dwErr = RasServerConnect(&g_hserver);
    if (dwErr != NO_ERROR) { return dwErr; }

    dwErr = g_pRasAdminPortEnum(
                g_hserver,
                0,
                INVALID_HANDLE_VALUE,
                (BYTE**)ppPortTable,
                (DWORD)-1,
                piPortCount,
                &dwTotal,
                NULL
                );

    return dwErr;
}



TCHAR *
GetRasPort0UserString(
    IN  RAS_PORT_0 *    pport,
    IN  TCHAR *         pszUser OPTIONAL )

    /* This function formats the user and domain in the specified port
    ** as a standard DOMAINNAME\username string and returns the result,
    ** unless the argument 'pszUser' is non-NULL in which case 
    ** the result is formatted into the given string.
    **
    ** (Abolade Gbadegesin Mar-06-1996)
    */
{

    DWORD dwErr;
    PTSTR psz = NULL;
    RAS_CONNECTION_0 *prc0 = NULL;

    dwErr = RasServerConnect(&g_hserver);
    if (dwErr != NO_ERROR) { return NULL; }

    do {

        dwErr = g_pRasAdminConnectionGetInfo(
                    g_hserver,
                    0,
                    pport->hConnection,
                    (BYTE**)&prc0
                    );
    
        if (dwErr != NO_ERROR) { break; }
    
    
        if (pszUser) { psz = pszUser; }
        else {
        
            psz = Malloc(
                    (lstrlenW(prc0->wszUserName) +
                     lstrlenW(prc0->wszLogonDomain) + 2) * sizeof(TCHAR)
                    );
        
            if (!psz) { break; }
        }
    
        wsprintf(psz, TEXT("%ls\\%ls"), prc0->wszLogonDomain, prc0->wszUserName);
    
    } while(FALSE);

    if (prc0) { g_pRasAdminBufferFree(prc0); }

    return psz;
}





DWORD
RasPort0Hangup(
    IN  HANDLE      hPort )

    /* This function hangs up the specified dial-in port
    ** on the local RAS server.
    **
    ** (Abolade Gbadegesin Mar-05-1996)
    */
{
    DWORD dwErr;

    dwErr = RasServerConnect(&g_hserver);
    if (dwErr != NO_ERROR) { return dwErr; }

    dwErr = g_pRasAdminPortDisconnect(g_hserver, hPort);

    return dwErr;
}



DWORD
RasServerConnect(
    IN  HANDLE*  phserver )

    /* This function establishes a connection to the local MPR RAS server,
    ** if the connection has not already been established.
    */
{
    DWORD dwErr;

    if (*phserver) { return NO_ERROR; }

    dwErr = g_pRasAdminServerConnect(NULL, phserver);

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\nt4\common\phonenum\phonenum.c ===
/* Copyright (c) 1996, Microsoft Corporation, all rights reserved
**
** phonenum.c
** Phone number helper library
** Listed alphabetically
**
** 03/06/96 Steve Cobb
*/

#include <windows.h>  // Win32 root
#include <nouiutil.h> // No-HWND utilities
#include <tapiutil.h> // TAPI wrappers
#include <phonenum.h> // Our public header
#include <debug.h>    // Trace/Assert library


TCHAR*
LinkPhoneNumberFromParts(
    IN     HINSTANCE hInst,
    IN OUT HLINEAPP* pHlineapp,
    IN     PBUSER*   pUser,
    IN     PBENTRY*  pEntry,
    IN     PBLINK*   pLink,
    IN     DWORD     iPhoneNumber,
    IN     TCHAR*    pszOverrideNumber,
    IN     BOOL      fDialable )

    /* Like PhoneNumberFromParts but takes a link and hunt group index as
    ** input instead of a base number, and handles not modifying the number
    ** associated with non-modem/ISDN links.  If 'pszOverrideNumber' is
    ** non-NULL and non-"" it is used instead of the derived number.
    */
{
    DTLNODE* pNode;
    TCHAR*   pszBaseNumber;

    if (pszOverrideNumber && *pszOverrideNumber)
        pszBaseNumber = StrDup( pszOverrideNumber );
    else
    {
        pNode = DtlNodeFromIndex( pLink->pdtllistPhoneNumbers, iPhoneNumber );
        if (pNode)
            pszBaseNumber = StrDup( (TCHAR* )DtlGetData( pNode ) );
        else
            pszBaseNumber = StrDup( TEXT("") );
    }

    if (pszBaseNumber
        && (pLink->pbport.pbdevicetype == PBDT_Modem
            || pLink->pbport.pbdevicetype == PBDT_Isdn))
    {
        TCHAR* pszNumber;

        pszNumber = PhoneNumberFromParts(
            hInst, pHlineapp, pUser, pEntry, pszBaseNumber, fDialable );
        Free( pszBaseNumber );
        return pszNumber;
    }
    else
        return pszBaseNumber;
}


TCHAR*
PhoneNumberFromParts(
    IN     HINSTANCE hInst,
    IN OUT HLINEAPP* pHlineapp,
    IN     PBUSER*   pUser,
    IN     PBENTRY*  pEntry,
    IN     TCHAR*    pszBaseNumber,
    IN     BOOL      fDialable )

    /* Returns a heap block containing the composite phone number using base
    ** number 'pszBaseNumber' and the rules from 'pEntry' and 'pUser'.
    ** 'HInst' is the module handle.  'PHlineapp' is the TAPI context.
    ** 'FDialable' indicates the dialable string, instead of the displayable
    ** string, should be returned.
    **
    ** It is caller's responsibility to Free the returned string.
    */
{
    TCHAR*   pszResult;
    BOOL     fDownLevelIsdn;
    PBLINK*  pLink;
    DTLNODE* pNode;

    TRACE("PhoneNumberFromParts");

    ASSERT(pEntry->pdtllistLinks);
    pNode = DtlGetFirstNode( pEntry->pdtllistLinks );
    ASSERT(pNode);
    pLink = (PBLINK* )DtlGetData( pNode );
    ASSERT(pLink);

    fDownLevelIsdn =
        (pLink->pbport.pbdevicetype == PBDT_Isdn
         && pLink->fProprietaryIsdn);

    if (pEntry->fUseCountryAndAreaCode)
    {
        pszResult =
            PhoneNumberFromTapiPartsEx( hInst, pszBaseNumber,
                pEntry->pszAreaCode, pEntry->dwCountryCode, fDownLevelIsdn,
                pHlineapp, fDialable );
    }
    else
    {
        TCHAR* pszPrefix;
        TCHAR* pszSuffix;

        PrefixSuffixFromLocationId( pUser,
            GetCurrentLocation( hInst, pHlineapp ),
            &pszPrefix, &pszSuffix );

        pszResult =
            PhoneNumberFromPrefixSuffixEx(
                pszBaseNumber, pszPrefix, pszSuffix, fDownLevelIsdn );

        Free0( pszPrefix );
        Free0( pszSuffix );
    }

    if (!pszResult)
    {
        TRACE("!Phone#");
        pszResult = StrDup( pszBaseNumber );
    }

    return pszResult;
}


TCHAR*
PhoneNumberFromPrefixSuffix(
    IN TCHAR* pszBaseNumber,
    IN TCHAR* pszPrefix,
    IN TCHAR* pszSuffix )

    /* Returns a heap block containing the composite phone number comprised of
    ** prefix 'pszPrefix', base phone number 'pszBaseNumber', and suffix
    ** 'pszSuffix', or NULL if the composite number is too long or on a memory
    ** error.
    **
    ** It is caller's responsibility to Free the returned string.
    */
{
    TCHAR* pszResult;
    DWORD  cch;

    TRACE("PhoneNumberFromPrefixSuffix");

    pszResult = NULL;

    if (!pszBaseNumber)
        pszBaseNumber = TEXT("");
    if (!pszPrefix)
        pszPrefix = TEXT("");
    if (!pszSuffix)
        pszSuffix = TEXT("");

    cch = lstrlen( pszPrefix ) + lstrlen( pszBaseNumber ) + lstrlen( pszSuffix );
    if (cch > RAS_MaxPhoneNumber)
        return NULL;

    pszResult = Malloc( (cch + 1) * sizeof(TCHAR) );
    if (pszResult)
    {
        *pszResult = TEXT('\0');
        lstrcat( pszResult, pszPrefix );
        lstrcat( pszResult, pszBaseNumber );
        lstrcat( pszResult, pszSuffix );
    }

    return pszResult;
}


TCHAR*
PhoneNumberFromPrefixSuffixEx(
    IN  TCHAR*  pszBaseNumber,
    IN  TCHAR*  pszPrefix,
    IN  TCHAR*  pszSuffix,
    IN  BOOL    fDownLevelIsdn )

    /* Returns a heap block containing the composite phone number comprised of
    ** prefix 'pszPrefix', base phone number 'pszBaseNumber', and suffix
    ** 'pszSuffix', or NULL if the composite number is too long or on a memory
    ** error.
    **
    ** If 'fDownLevelIsdn' is set colons are recognized as separaters with
    ** each colon separated token built treated separately.
    **
    ** It is caller's responsibility to Free the returned string.
    */
{
    TCHAR* psz;
    TCHAR* pszResult;
    INT    cchResult;

    TRACE("PhoneNumberFromPrefixSuffixEx");

    if (fDownLevelIsdn)
    {
        TCHAR* pszNum;
        TCHAR* pszS;
        TCHAR* pszE;

        pszResult = StrDup( TEXT("") );

        for (pszS = pszE = pszBaseNumber;
             *pszE != TEXT('\0');
             pszE = CharNext( pszE ))
        {
            if (*pszE == TEXT(':'))
            {
                *pszE = TEXT('\0');

                pszNum =
                    PhoneNumberFromPrefixSuffix(
                        pszS, pszPrefix, pszSuffix );

                *pszE = TEXT(':');

                if (pszNum)
                {
                    if (pszResult)
                        cchResult = lstrlen( pszResult );

                    psz = Realloc( pszResult,
                        (cchResult + lstrlen( pszNum ) + 2) * sizeof(TCHAR) );

                    if (!psz)
                    {
                        Free0( pszResult );
                        Free( pszNum );
                        return NULL;
                    }

                    pszResult = psz;
                    lstrcat( pszResult, pszNum );
                    lstrcat( pszResult, TEXT(":") );
                    Free( pszNum );
                }

                pszS = CharNext( pszE );
            }
        }

        {
            pszNum =
                PhoneNumberFromPrefixSuffix(
                    pszS, pszPrefix, pszSuffix );

            if (pszNum)
            {
                if (pszResult)
                    cchResult = lstrlen( pszResult );

                psz = Realloc( pszResult,
                    (cchResult + lstrlen( pszNum ) + 1) * sizeof(TCHAR) );

                if (!psz)
                {
                    Free0( pszResult );
                    Free( pszNum );
                    return NULL;
                }

                pszResult = psz;
                lstrcat( pszResult, pszNum );
                Free( pszNum );
            }
        }
    }
    else
    {
        pszResult =
            PhoneNumberFromPrefixSuffix(
                pszBaseNumber, pszPrefix, pszSuffix );
    }

    if (pszResult && (lstrlen( pszResult ) > RAS_MaxPhoneNumber ))
    {
        Free( pszResult );
        return NULL;
    }

    return pszResult;
}


TCHAR*
PhoneNumberFromTapiParts(
    IN     HINSTANCE hInst,
    IN     TCHAR*    pszBaseNumber,
    IN     TCHAR*    pszAreaCode,
    IN     DWORD     dwCountryCode,
    IN OUT HLINEAPP* pHlineapp,
    IN     BOOL      fDialable )

    /* Returns a heap block containing the composite phone number comprised of
    ** base phone number 'pszBaseNumber', area code 'pszAreaCode', and country
    ** code 'dwCountryCode, or NULL if the composite number is too long or on
    ** a memory error.  'HInst' is the module instance handle.  '*PHlineapp'
    ** is the address of the TAPI context.  'FDialable' indicates the dialable
    ** string, as opposed to the displayable string, should be returned.
    **
    ** It is caller's responsibility to Free the returned string.
    */
{
    TCHAR* pszResult;

    TRACE("PhoneNumberFromTapiParts");

    pszResult = NULL;

    TapiTranslateAddress(
        hInst, pHlineapp, dwCountryCode, pszAreaCode, pszBaseNumber,
        0, fDialable, &pszResult );

    return pszResult;
}


TCHAR*
PhoneNumberFromTapiPartsEx(
    IN     HINSTANCE hInst,
    IN     TCHAR*    pszBaseNumber,
    IN     TCHAR*    pszAreaCode,
    IN     DWORD     dwCountryCode,
    IN     BOOL      fDownLevelIsdn,
    IN OUT HLINEAPP* pHlineapp,
    IN     BOOL      fDialable )

    /* Returns  heap block containing the composite phone number comprised of
    ** base phone number 'pszBaseNumber', area code 'pszAreaCode', and country
    ** code 'dwCountryCode or NULL if the composite number is too long or on a
    ** memory error.  'HInst' is the module instance handle.  '*PHlineapp' is
    ** the address of the TAPI context.  'FDialable' indicates the dialable
    ** string, as opposed to the displayable string, should be returned.
    **
    ** If 'fDownLevelIsdn' is set colons are recognized as separaters with
    ** each colon separated token built treated separately.
    **
    ** It is caller's responsibility to Free the returned string.
    */
{
    TCHAR* psz;
    TCHAR* pszResult;
    INT    cchResult;

    TRACE("PhoneNumberFromTapiPartsEx");

    if (fDownLevelIsdn)
    {
        TCHAR* pszNum;
        TCHAR* pszS;
        TCHAR* pszE;

        pszResult = StrDup( TEXT("") );

        for (pszS = pszE = pszBaseNumber;
             *pszE != TEXT('\0');
             pszE = CharNext( pszE ))
        {
            if (*pszE == TEXT(':'))
            {
                *pszE = TEXT('\0');

                pszNum = PhoneNumberFromTapiParts(
                    hInst, pszS, pszAreaCode, dwCountryCode, pHlineapp, fDialable );

                *pszE = TEXT(':');

                if (pszNum)
                {
                    if (pszResult)
                        cchResult = lstrlen( pszResult );

                    psz = Realloc( pszResult,
                        (cchResult + lstrlen( pszNum ) + 2) * sizeof(TCHAR) );

                    if (!psz)
                    {
                        Free0( pszResult );
                        Free( pszNum );
                        return NULL;
                    }

                    pszResult = psz;
                    lstrcat( pszResult, pszNum );
                    lstrcat( pszResult, TEXT(":") );
                    Free( pszNum );
                }

                pszS = CharNext( pszE );
            }
        }

        {
            pszNum = PhoneNumberFromTapiParts(
                hInst, pszS, pszAreaCode, dwCountryCode, pHlineapp, fDialable );

            if (pszNum)
            {
                if (pszResult)
                    cchResult = lstrlen( pszResult );

                psz = Realloc( pszResult,
                    (cchResult + lstrlen( pszNum ) + 1) * sizeof(TCHAR) );

                if (!psz)
                {
                    Free0( pszResult );
                    Free( pszNum );
                    return NULL;
                }

                pszResult = psz;
                lstrcat( pszResult, pszNum );
                Free( pszNum );
            }
        }
    }
    else
    {
        pszResult = PhoneNumberFromTapiParts(
            hInst, pszBaseNumber, pszAreaCode, dwCountryCode, pHlineapp,
            fDialable );
    }

    if (pszResult && (lstrlen( pszResult ) > RAS_MaxPhoneNumber ))
    {
        Free( pszResult );
        return NULL;
    }

    return pszResult;
}


VOID
PrefixSuffixFromLocationId(
    IN  PBUSER* pUser,
    IN  DWORD   dwLocationId,
    OUT TCHAR** ppszPrefix,
    OUT TCHAR** ppszSuffix )

    /* Retrieve the prefix and suffix strings, '*ppszPrefix' and '*ppszSuffix'
    ** associated with TAPI location 'dwLocationId'.  'PUser' is the user
    ** preferences from which to retrieve.
    **
    ** It is caller's responsibility to Free the returned strings.
    */
{
    DTLNODE* pNode;
    INT      iPrefix;
    INT      iSuffix;

    TRACE("PrefixSuffixFromLocationId");

    iPrefix = iSuffix = 0;
    for (pNode = DtlGetFirstNode( pUser->pdtllistLocations );
         pNode;
         pNode = DtlGetNextNode( pNode ))
    {
        LOCATIONINFO* p = (LOCATIONINFO* )DtlGetData( pNode );
        ASSERT(p);

        if (p->dwLocationId == dwLocationId)
        {
            iPrefix = p->iPrefix;
            iSuffix = p->iSuffix;
            break;
        }
    }

    *ppszPrefix = NULL;
    if (iPrefix != 0)
    {
        pNode = DtlNodeFromIndex( pUser->pdtllistPrefixes, iPrefix - 1 );
        if (pNode)
            *ppszPrefix = StrDup( (TCHAR* )DtlGetData( pNode ) );
    }

    *ppszSuffix = NULL;
    if (iSuffix != 0)
    {
        pNode = DtlNodeFromIndex( pUser->pdtllistSuffixes, iSuffix - 1 );
        if (pNode)
            *ppszSuffix = StrDup( (TCHAR* )DtlGetData( pNode ) );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\nt4\common\uiutil\bubble.h ===
//============================================================================
// Copyright (c) 1996, Microsoft Corporation
//
// File:    bubble.h
//
// History:
//  Abolade-Gbadegesin  Mar-1-1996  Created.
//
// This file contains popup declarations for the bubble-popup controls.
//============================================================================


typedef struct _BPOPUP {

    HWND    hwnd;
    UINT_PTR iCtrlId;
    PTSTR   pszText;
    HFONT   hfont;
    DWORD   dwFlags;
    UINT_PTR uiTimer;
    UINT    uiTimeout;

} BPOPUP, *PBPOPUP;


#define BPFLAG_Activated        0x0001
#define BPFLAG_FontCreated      0x0002

#define BP_TimerId              0xa09

#define BP_GetPtr(hwnd)         (BPOPUP *)GetWindowLongPtr((hwnd), 0)
#define BP_SetPtr(hwnd,ptr)     (BPOPUP *)SetWindowLongPtr((hwnd), 0, (LONG_PTR)(ptr))


LRESULT
CALLBACK
BP_WndProc(
    IN  HWND    hwnd,
    IN  UINT    uiMsg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
    );

BOOL
BP_OnCreate(
    IN  BPOPUP *        pbp,
    IN  CREATESTRUCT *  pcs
    );

VOID
BP_OnDestroy(
    IN  BPOPUP *pbp
    );

VOID
BP_OnGetRect(
    IN  BPOPUP *    pbp,
    IN  RECT *      prc
    );

VOID
BP_ResizeClient(
    IN  BPOPUP *    pbp
    );

BOOL
BP_OnSetFont(
    IN  BPOPUP *    pbp,
    IN  HFONT       hfont,
    IN  BOOL        bRedraw
    );

DWORD
BP_OnPaint(
    IN  BPOPUP *    pbp
    );

BOOL
BP_OnActivate(
    IN  BPOPUP *    pbp
    );

BOOL
BP_OnDeactivate(
    IN  BPOPUP *    pbp
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\nt4\common\uiutil\lvx.c ===
/* Copyright (c) 1995, Microsoft Corporation, all rights reserved
**
** lvx.c
** Listview extension routines
** Listed alphabetically
**
** 11/25/95 Steve Cobb
**     Some adapted from \\ftp\data\softlib\mslfiles\odlistvw.exe sample code.
*/

#include <windows.h>  // Win32 root
#include <windowsx.h> // Win32 macro extensions
#include <commctrl.h> // Win32 common controls
#include <debug.h>    // Trace and assert
#include <uiutil.h>   // Our public header
#include <lvx.rch>    // Our resource constants


/* List view of check boxes state indices.
*/
#define SI_Unchecked 1
#define SI_Checked   2

/* Text indents within a column in pixels.  If you mess with the dx, you're
** asking for misalignment problems with the header labels.  BTW, the first
** column doesn't line up with it's header if there are no icons.  Regular
** list view has this problem, too.  If you try to fix this you'll wind up
** duplicating the AUTOSIZE_USEHEADER option of ListView_SetColumnWidth.
** Should be able to change the dy without causing problems.
*/
#define LVX_dxColText 4
#define LVX_dyColText 1

/* Guaranteed vertical space between icons.  Should be able to mess with this
** without causing problems.
*/
#define LVX_dyIconSpacing 1

/* The atom identifying our context property suitable for use by the Windows
** XxxProp APIs.  A Prop is used to associate context information (the address
** of the WNDPROC we subclassed) with a "list view of check boxes" window.
*/
static LPCWSTR g_lvxcbContextId = NULL;


/*----------------------------------------------------------------------------
** Local prototypes
**----------------------------------------------------------------------------
*/
LRESULT APIENTRY
LvxcbProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
LvxDrawItem(
    IN DRAWITEMSTRUCT* pdis,
    IN PLVXCALLBACK    pLvxCallback );

BOOL
LvxMeasureItem(
    IN     HWND               hwnd,
    IN OUT MEASUREITEMSTRUCT* pmis );


/*----------------------------------------------------------------------------
** ListView of check boxes
**----------------------------------------------------------------------------
*/

BOOL
ListView_GetCheck(
    IN HWND hwndLv,
    IN INT  iItem )

    /* Returns true if the check box of item 'iItem' of listview of checkboxes
    ** 'hwndLv' is checked, false otherwise.
    */
{
    UINT unState;

    unState = ListView_GetItemState( hwndLv, iItem, LVIS_STATEIMAGEMASK );
    return !!(unState & INDEXTOSTATEIMAGEMASK( SI_Checked ));
}


UINT
ListView_GetCheckedCount(
    IN HWND hwndLv )

    /* Returns the number of checked items in 'hwndLv'.
    */
{
    UINT c = 0;
    INT  i = -1;

    while ((i = ListView_GetNextItem( hwndLv, i, LVNI_ALL )) >= 0)
    {
        if (ListView_GetCheck( hwndLv, i ))
            ++c;
    }

    return c;
}


BOOL
ListView_InstallChecks(
    IN HWND      hwndLv,
    IN HINSTANCE hinst )

    /* Initialize "list of checkbox" handling for listview 'hwndLv'.  'Hinst'
    ** is the module instance containing the two checkbox icons.  See LVX.RC.
    **
    ** Returns true if successful, false otherwise.  Caller must eventually
    ** call 'ListView_UninstallChecks', typically in WM_DESTROY processing.
    */
{
    HICON      hIcon;
    HIMAGELIST himl;
    WNDPROC    pOldProc;

    /* Build checkbox image lists.
    */
    himl = ImageList_Create(
               GetSystemMetrics( SM_CXSMICON ),
               GetSystemMetrics( SM_CYSMICON ),
               ILC_MASK, 2, 2 );

    /* The order these are added is significant since it implicitly
    ** establishes the state indices matching SI_Unchecked and SI_Checked.
    */
    hIcon = LoadIcon( hinst, MAKEINTRESOURCE( IID_Unchecked ) );
    if (hIcon)
    {
        ImageList_AddIcon( himl, hIcon );
        DeleteObject( hIcon );
    }        

    hIcon = LoadIcon( hinst, MAKEINTRESOURCE( IID_Checked ) );
    if (hIcon)
    {
        ImageList_AddIcon( himl, hIcon );
        DeleteObject( hIcon );
    }        

    ListView_SetImageList( hwndLv, himl, LVSIL_STATE );

    /* Register atom for use in the Windows XxxProp calls which are used to
    ** associate the old WNDPROC with the listview window handle.
    */
    if (!g_lvxcbContextId)
        g_lvxcbContextId = (LPCWSTR )GlobalAddAtom( L"RASLVXCB" );
    if (!g_lvxcbContextId)
        return FALSE;

    /* Subclass the current window procedure.
    */
    pOldProc = (WNDPROC )SetWindowLongPtr(
        hwndLv, GWLP_WNDPROC, (LONG_PTR)LvxcbProc );

    return SetProp( hwndLv, g_lvxcbContextId, (HANDLE )pOldProc );
}


VOID
ListView_SetCheck(
    IN HWND hwndLv,
    IN INT  iItem,
    IN BOOL fCheck )

    /* Sets the check mark on item 'iItem' of listview of checkboxes 'hwndLv'
    ** to checked if 'fCheck' is true or unchecked if false.
    */
{
    NMHDR nmh;

    ListView_SetItemState( hwndLv, iItem,
        INDEXTOSTATEIMAGEMASK( (fCheck) ? SI_Checked : SI_Unchecked ),
        LVIS_STATEIMAGEMASK );

    nmh.code = LVXN_SETCHECK;
    nmh.hwndFrom = hwndLv;

    FORWARD_WM_NOTIFY(
        GetParent(hwndLv), GetDlgCtrlID(hwndLv), &nmh, SendMessage
        );
}


VOID
ListView_UninstallChecks(
    IN HWND hwndLv )

    /* Uninstalls "listview of check boxes" handling from list view 'hwndLv'.
    */
{
    WNDPROC pOldProc;

    pOldProc = (WNDPROC)GetProp( hwndLv, g_lvxcbContextId );
    if (pOldProc)
    {
        /* Un-subclass so it can terminate without access to the context.
        */
        SetWindowLongPtr( hwndLv, GWLP_WNDPROC, (LONG_PTR)pOldProc );
    }

    RemoveProp( hwndLv, g_lvxcbContextId );
}


LRESULT APIENTRY
LvxcbProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    /* List view subclass window procedure to trap toggle-check events.
    */
{
    WNDPROC pOldProc;
    INT     iItem;
    BOOL    fSet;
    BOOL    fClear;
    BOOL    fToggle;

    iItem = -1;
    fSet = fClear = fToggle = FALSE;

    if (unMsg == WM_LBUTTONDOWN)
    {
        LV_HITTESTINFO info;

        /* Left mouse button pressed over checkbox icon toggles state.
        ** Normally, we'd use LVHT_ONITEMSTATEICON and be done with it, but we
        ** want to work with our cool owner-drawn list view extensions in
        ** which case the control doesn't know where the icon is on the item,
        ** so it returns a hit anywhere on the item anyway.
        */
        ZeroMemory( &info, sizeof(info) );
        info.pt.x = LOWORD( lparam );
        info.pt.y = HIWORD( lparam );
        info.flags = LVHT_ONITEM;
        iItem = ListView_HitTest( hwnd, &info );

        if (iItem >= 0)
        {
            /* OK, it's over item 'iItem'.  Now figure out if it's over the
            ** checkbox.  Note this currently doesn't account for use of the
            ** "indent" feature on an owner-drawn item.
            */
            if ((INT )(LOWORD( lparam )) >= GetSystemMetrics( SM_CXSMICON ))
                iItem = -1;
            else
                fToggle = TRUE;
        }
    }
    else if (unMsg == WM_CHAR)
    {
        /* Space bar pressed with item selected toggles check.
        ** Plus or Equals keys set check.
        ** Minus key clears check.
        */
        switch (wparam)
        {
            case TEXT(' '):
                fToggle = TRUE;
                break;

            case TEXT('+'):
            case TEXT('='):
                fSet = TRUE;
                break;

            case TEXT('-'):
                fClear = TRUE;
                break;
        }

        if (fToggle || fSet || fClear)
            iItem = ListView_GetNextItem( hwnd, -1, LVNI_SELECTED );
    }
    else if (unMsg == WM_KEYDOWN)
    {
        /* Left arrow becomes up arrow and right arrow becomes down arrow so
        ** the list of checkboxes behaves just like a static group of
        ** checkboxes.
        */
        if (wparam == VK_LEFT)
            wparam = VK_UP;
        else if (wparam == VK_RIGHT)
            wparam = VK_DOWN;
    }

    if (iItem >= 0)
    {

        /* If we are handling the spacebar, plus, minus, or equals,
        ** the change we make applies to all the selected items;
        ** hence the do {} while(WM_CHAR).
        */
        
        do {

            if (fToggle)
            {
                UINT unOldState;
                BOOL fCheck;
    
                fCheck = ListView_GetCheck( hwnd, iItem );
                ListView_SetCheck( hwnd, iItem, !fCheck );
            }
            else if (fSet)
            {
                if (!ListView_GetCheck( hwnd, iItem ))
                    ListView_SetCheck( hwnd, iItem, TRUE );
            }
            else if (fClear)
            {
                if (ListView_GetCheck( hwnd, iItem ))
                    ListView_SetCheck( hwnd, iItem, FALSE );
            }

            iItem = ListView_GetNextItem(hwnd, iItem, LVNI_SELECTED);

        } while(iItem >= 0 && unMsg == WM_CHAR);

        if (fSet || fClear) {

            /* Don't pass to listview to avoid beep.
            */
            return 0;
        }
    }

    pOldProc = (WNDPROC )GetProp( hwnd, g_lvxcbContextId );
    if (pOldProc)
        return CallWindowProc( pOldProc, hwnd, unMsg, wparam, lparam );

    return 0;
}


/*----------------------------------------------------------------------------
** Enhanced ListView
**----------------------------------------------------------------------------
*/

BOOL
ListView_OwnerHandler(
    IN HWND         hwnd,
    IN UINT         unMsg,
    IN WPARAM       wparam,
    IN LPARAM       lparam,
    IN PLVXCALLBACK pLvxCallback )

    /* Handler that, when installed, turns a regular report-view-only list
    ** view (but with style LVS_OWNERDRAWFIXED) into an enhanced list view
    ** with full width selection bar and other custom column display options.
    ** It should appear in list view owner's dialog proc as follows:
    **
    **     BOOL
    **     MyDlgProc(
    **         IN HWND   hwnd,
    **         IN UINT   unMsg,
    **         IN WPARAM wparam,
    **         IN LPARAM lparam )
    **     {
    **         if (ListView_OwnerHandler(
    **                 hwnd, unMsg, wParam, lParam, MyLvxCallback ))
    **             return TRUE;
    **
    **         <the rest of your stuff here>
    **     }
    **
    ** 'PLvxCallback' is caller's callback routine that provides information
    ** about drawing columns and other options.
    **
    ** Returns true if processed message, false otherwise.
    */
{
    /* This routine executes on EVERY message thru the dialog so keep it
    ** efficient, please.
    */
    switch (unMsg)
    {
        case WM_DRAWITEM:
            return LvxDrawItem( (DRAWITEMSTRUCT* )lparam, pLvxCallback );

        case WM_MEASUREITEM:
            return LvxMeasureItem( hwnd, (MEASUREITEMSTRUCT* )lparam );
    }

    return FALSE;
}


BOOL
LvxDrawItem(
    IN DRAWITEMSTRUCT* pdis,
    IN PLVXCALLBACK    pLvxCallback )

    /* Respond to WM_DRAWITEM by drawing the list view item.  'Pdis' is the
    ** information sent by the system.  'PLvxCallback' is caller's callback to
    ** get information about drawing the control.
    **
    ** Returns true is processed the message, false otherwise.
    */
{
    LV_ITEM      item;
    INT          i;
    INT          dxState;
    INT          dyState;
    INT          dxSmall;
    INT          dySmall;
    INT          dxIndent;
    UINT         uiStyleState;
    UINT         uiStyleSmall;
    HIMAGELIST   himlState;
    HIMAGELIST   himlSmall;
    LVXDRAWINFO* pDrawInfo;
    RECT         rc;
    RECT         rcClient;
    BOOL         fEnabled;
    BOOL         fSelected;
    HDC          hdc;
    HFONT        hfont;

    TRACE3("LvxDrawItem,i=%d,a=$%X,s=$%X",
        pdis->itemID,pdis->itemAction,pdis->itemState);

    /* Make sure this is something we want to handle.
    */
    if (pdis->CtlType != ODT_LISTVIEW)
        return FALSE;

    if (pdis->itemAction != ODA_DRAWENTIRE
        && pdis->itemAction != ODA_SELECT
        && pdis->itemAction != ODA_FOCUS)
    {
        return TRUE;
    }

    /* Get item information from the list view.
    */
    ZeroMemory( &item, sizeof(item) );
    item.mask = LVIF_IMAGE + LVIF_STATE;
    item.iItem = pdis->itemID;
    item.stateMask = LVIS_STATEIMAGEMASK;
    if (!ListView_GetItem( pdis->hwndItem, &item ))
    {
        TRACE("LvxDrawItem GetItem failed");
        return TRUE;
    }

    /* Stash some useful stuff for reference later.
    */
    fEnabled = IsWindowEnabled( pdis->hwndItem )
               && !(pdis->itemState & ODS_DISABLED);
    fSelected = (pdis->itemState & ODS_SELECTED);
    GetClientRect( pdis->hwndItem, &rcClient );

    /* Callback owner to get drawing information.
    */
    ASSERT(pLvxCallback);
    pDrawInfo = pLvxCallback( pdis->hwndItem, pdis->itemID );
    ASSERT(pDrawInfo);

    /* Get image list icon sizes now, though we draw them last because their
    ** background is set up during first column text output.
    */
    dxState = dyState = 0;
    himlState = ListView_GetImageList( pdis->hwndItem, LVSIL_STATE );
    if (himlState)
        ImageList_GetIconSize( himlState, &dxState, &dyState );

    dxSmall = dySmall = 0;
    himlSmall = ListView_GetImageList( pdis->hwndItem, LVSIL_SMALL );
    if (himlSmall)
        ImageList_GetIconSize( himlSmall, &dxSmall, &dySmall );

    uiStyleState = uiStyleSmall = ILD_TRANSPARENT;

    /* Figure out the number of pixels to indent the item, if any.
    */
    if (pDrawInfo->dxIndent >= 0)
        dxIndent = pDrawInfo->dxIndent;
    else
    {
        if (dxSmall > 0)
            dxIndent = dxSmall;
        else
            dxIndent = GetSystemMetrics( SM_CXSMICON );
    }

    /* Get a device context for the window and set it up with the font the
    ** control says it's using.  (Can't use the one that comes in the
    ** DRAWITEMSTRUCT because sometimes it has the wrong rectangle, see bug
    ** 13106)
    */
    hdc = GetDC( pdis->hwndItem );
    hfont = (HFONT )SendMessage( pdis->hwndItem, WM_GETFONT, 0, 0 );
    if (hfont)
        SelectObject( hdc, hfont );

    /* Set things up as if we'd just got done processing a column that ends
    ** after the icons, then loop thru each column from left to right.
    */
    rc.right = pdis->rcItem.left + dxIndent + dxState + dxSmall;
    rc.top = pdis->rcItem.top;
    rc.bottom = pdis->rcItem.bottom;

    for (i = 0; i < pDrawInfo->cCols; ++i)
    {
        TCHAR  szText[ LVX_MaxColTchars + 1 ];
        TCHAR* pszText;
        INT    dxCol;

        /* Get the column width, adding any index and icon width to the first
        ** column.
        */
        dxCol = ListView_GetColumnWidth( pdis->hwndItem, i );
        if (i == 0)
            dxCol -= dxIndent + dxState + dySmall;

        szText[ 0 ] = TEXT('\0');
        ListView_GetItemText( pdis->hwndItem, pdis->itemID, i, szText,
            LVX_MaxColTchars + 1 );

        /* Update rectangle to enclose just this one item's column 'i'.
        */
        rc.left = rc.right;
        rc.right = rc.left + dxCol;

        if ((pDrawInfo->dwFlags & LVXDI_DxFill)
            && i == pDrawInfo->cCols - 1)
        {
            INT dxWnd = pdis->rcItem.left + rcClient.right;

            if (rc.right < dxWnd)
            {
                /* When the last column does not fill out a full controls
                ** width of space, extend it to the right so it does.  Note
                ** this does not mean the user can't scroll off to the right
                ** if they want.
                ** (Abolade-Gbadegesin 03-27-96)
                ** Don't subtrace rc.left when there is only one column;
                ** this accounts for the space needed for icons.
                */
                rc.right = pdis->rcItem.right = dxWnd;
                if (i == 0) {
                    ListView_SetColumnWidth(pdis->hwndItem, i, rc.right);
                }
                else {
                    ListView_SetColumnWidth(
                        pdis->hwndItem, i, rc.right - rc.left );
                }
            }
        }

        /* Lop the text and append "..." if it won't fit in the column.
        */
        pszText = Ellipsisize( hdc, szText, rc.right - rc.left, LVX_dxColText );
        if (!pszText)
            continue;

        /* Figure out the appropriate text and background colors for the
        ** current item state.
        */
        if (fEnabled)
        {
            if (fSelected)
            {
                SetTextColor( hdc, GetSysColor( COLOR_HIGHLIGHTTEXT ) );
                SetBkColor( hdc, GetSysColor( COLOR_HIGHLIGHT ) );
                if (pDrawInfo->dwFlags & LVXDI_Blend50Sel)
                    uiStyleSmall |= ILD_BLEND50;
            }
            else
            {
                if (pDrawInfo->adwFlags[ i ] & LVXDIA_3dFace)
                {
                    SetTextColor( hdc, GetSysColor( COLOR_WINDOWTEXT ) );
                    SetBkColor( hdc, GetSysColor( COLOR_3DFACE ) );
                }
                else
                {
                    SetTextColor( hdc, GetSysColor( COLOR_WINDOWTEXT ) );
                    SetBkColor( hdc, GetSysColor( COLOR_WINDOW ) );
                }
            }
        }
        else
        {
            SetTextColor( hdc, GetSysColor( COLOR_GRAYTEXT ) );
            SetBkColor( hdc, GetSysColor( COLOR_3DFACE ) );
            if (pDrawInfo->dwFlags & LVXDI_Blend50Dis)
                uiStyleSmall |= ILD_BLEND50;
        }

        /* Draw the column text.  In the first column the background of any
        ** indent and icons is erased to the text background color.
        */
        {
            RECT rcBg = rc;

            if (i == 0)
                rcBg.left -= dxIndent + dxState + dxSmall;

            ExtTextOut( hdc, rc.left + LVX_dxColText,
                rc.top + LVX_dyColText, ETO_CLIPPED + ETO_OPAQUE,
                &rcBg, pszText, lstrlen( pszText ), NULL );
        }

        Free( pszText );
    }

    /* Finally, draw the icons, if caller specified any.
    */
    if (himlState)
    {
        ImageList_Draw( himlState, (item.state >> 12) - 1, hdc,
            pdis->rcItem.left + dxIndent, pdis->rcItem.top, uiStyleState );
    }

    if (himlSmall)
    {
        ImageList_Draw( himlSmall, item.iImage, hdc,
            pdis->rcItem.left + dxIndent + dxState,
            pdis->rcItem.top, uiStyleSmall );
    }

    /* Draw the dotted focus rectangle around the whole item, if indicated.
    */
    if ((pdis->itemState & ODS_FOCUS) && GetFocus() == pdis->hwndItem)
        DrawFocusRect( hdc, &pdis->rcItem );

    ReleaseDC( pdis->hwndItem, hdc );

    return TRUE;
}



BOOL
LvxMeasureItem(
    IN     HWND               hwnd,
    IN OUT MEASUREITEMSTRUCT* pmis )

    /* Respond to WM_MEASUREITEM message, i.e. fill in the height of an item
    ** in the ListView.  'Hwnd' is the owner window.  'Pmis' is the structure
    ** provided from Windows.
    **
    ** Returns true is processed the message, false otherwise.
    */
{
    HDC        hdc;
    HWND       hwndLv;
    HFONT      hfont;
    TEXTMETRIC tm;
    UINT       dySmIcon;
    RECT       rc;

    TRACE("LvxMeasureItem");

    if (pmis->CtlType != ODT_LISTVIEW)
        return FALSE;

    hwndLv = GetDlgItem( hwnd, pmis->CtlID );
    ASSERT(hwndLv);

    /* Get a device context for the list view control and set up the font the
    ** control says it's using.  MSDN claims the final font may not be
    ** available at this point, but it sure seems to be.
    */
    hdc = GetDC( hwndLv );
    hfont = (HFONT )SendMessage( hwndLv, WM_GETFONT, 0, 0 );
    if (hfont)
        SelectObject( hdc, hfont );

    if (GetTextMetrics( hdc, &tm ))
        pmis->itemHeight = tm.tmHeight + 1;
    else
        pmis->itemHeight = 0;

    /* Make sure it's tall enough for a standard small icon.
    */
    dySmIcon = (UINT )GetSystemMetrics( SM_CYSMICON );
    if (pmis->itemHeight < dySmIcon + LVX_dyIconSpacing)
        pmis->itemHeight = dySmIcon + LVX_dyIconSpacing;

    /* Set the width since the docs say to, though I don't think it's used by
    ** list view.
    */
    GetClientRect( hwndLv, &rc );
    pmis->itemWidth = rc.right - rc.left - 1;

    ReleaseDC( hwndLv, hdc );
    return TRUE;
}


/*----------------------------------------------------------------------------
** ListView utilities
**----------------------------------------------------------------------------
*/

VOID
ListView_SetDeviceImageList(
    IN HWND      hwndLv,
    IN HINSTANCE hinst )

    /* Set the "small icon" image list view 'hwndLv' to be a list of DI_*
    ** images.  'Hinst' is the module instance containing the icons IID_Modem
    ** and IID_Adapter.  For example, see RASDLG.DLL.
    */
{
    HICON      hIcon;
    HIMAGELIST himl;

    himl = ImageList_Create(
               GetSystemMetrics( SM_CXSMICON ),
               GetSystemMetrics( SM_CYSMICON ),
               ILC_MASK, 2, 2 );

    if (himl)
    {
        /* The order these are added is significant since it implicitly
        ** establishes the state indices matching SI_Unchecked and SI_Checked.
        */
        hIcon = LoadIcon( hinst, MAKEINTRESOURCE( IID_Modem ) );
        if (hIcon)
        {
            ImageList_ReplaceIcon( himl, -1, hIcon );
            DeleteObject( hIcon );
        }            

        hIcon = LoadIcon( hinst, MAKEINTRESOURCE( IID_Adapter ) );
        if (hIcon)
        {
            ImageList_ReplaceIcon( himl, -1, hIcon );
            DeleteObject( hIcon );
        }            

        ListView_SetImageList( hwndLv, himl, LVSIL_SMALL );
    }        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\nt4\common\tapiutil\tapi.c ===
/* Copyright (c) 1995-1996, Microsoft Corporation, all rights reserved
**
** tapi.c
** TAPI utility routines
** Listed alphabetically
**
** 10/20/95 Steve Cobb
*/

#include <windows.h>  // Win32 root
#include <debug.h>    // Trace/Assert library
#include <nouiutil.h> // Heap macros
#include <tapiutil.h> // Our public header


#define TAPIVERSION 0x00010004

TCHAR g_szTapiDevClass[] = TEXT("tapi/line");


/*----------------------------------------------------------------------------
** Private TAPI entrypoint prototypes
**----------------------------------------------------------------------------
*/

DWORD APIENTRY
internalNewLocationW(
    IN WCHAR* pszName );

DWORD APIENTRY
internalRemoveLocation(
    IN DWORD dwID );

DWORD APIENTRY
internalRenameLocationW(
    IN WCHAR* pszOldName,
    IN WCHAR* pszNewName );


/*----------------------------------------------------------------------------
** Local prototypes
**----------------------------------------------------------------------------
*/

TCHAR*
GetCanonPhoneNumber(
    IN DWORD  dwCountryCode,
    IN TCHAR* pszAreaCode,
    IN TCHAR* pszPhoneNumber );

DWORD
GetDefaultDeviceBlob(
    IN  DWORD       dwDeviceId,
    OUT VARSTRING** ppVs,
    OUT BYTE**      ppBlob,
    OUT DWORD*      pcbBlob );

void
TapiLineCallback(
    IN DWORD hDevice,
    IN DWORD dwMessage,
    IN DWORD dwInstance,
    IN DWORD dwParam1,
    IN DWORD dwParam2,
    IN DWORD dwParam3 );


/*----------------------------------------------------------------------------
** Routines
**----------------------------------------------------------------------------
*/

VOID
FreeCountryInfo(
    IN COUNTRY* pCountries,
    IN DWORD    cCountries )

    /* Frees the 'pCountries' buffer of 'cCountries' elements as returned by
    ** GetCountryInfo.
    */
{
    if (cCountries)
    {
        Free( *((VOID** )(pCountries + cCountries)) );
        Free( pCountries );
    }
}


VOID
FreeLocationInfo(
    IN LOCATION* pLocations,
    IN DWORD     cLocations )

    /* Frees the 'pLocations' buffer of 'cLocations' elements as returned by
    ** GetLocationInfo.
    */
{
    if (cLocations)
    {
        Free( *((VOID** )(pLocations + cLocations)) );
        Free( pLocations );
    }
}


TCHAR*
GetCanonPhoneNumber(
    IN DWORD  dwCountryCode,
    IN TCHAR* pszAreaCode,
    IN TCHAR* pszPhoneNumber )

    /* Returns a TAPI canonical phone number from constituent parts or NULL on
    ** error or when 'pszPhoneNumber' is NULL.  It is caller's responsibility
    ** to Free the returned string.
    */
{
    TCHAR szBuf[ 512 ];

    TRACE("GetCanonPhoneNumber");

    if (!pszPhoneNumber)
        return NULL;

    if (pszAreaCode && *pszAreaCode)
    {
        wsprintf( szBuf, TEXT("+%d (%s) %s"),
            dwCountryCode, pszAreaCode, pszPhoneNumber );
    }
    else
    {
        wsprintf( szBuf, TEXT("+%d %s"),
            dwCountryCode, pszPhoneNumber );
    }

    return StrDup( szBuf );
}


DWORD
GetCountryInfo(
    OUT COUNTRY** ppCountries,
    OUT DWORD*    pcCountries,
    IN  DWORD     dwCountryID )

    /* Sets '*ppCountries' to a heap block containing an array of TAPI country
    ** information.  '*pcCountries' is set to the number of elements in the
    ** array.  If 'dwCountryID' is 0, all countries are loaded.  Otherwise,
    ** only the specific country is loaded.
    **
    ** Returns 0 if successful, or an error code.  If successful, it is
    ** caller's responsibility to call FreeLocationInfo on *ppLocations.
    */
{
    DWORD             dwErr;
    LINECOUNTRYLIST   list;
    LINECOUNTRYLIST*  pList;
    LINECOUNTRYENTRY* pEntry;
    COUNTRY*          pCountry;
    DWORD             cb;
    DWORD             i;

    TRACE("GetCountryInfo");

    *ppCountries = NULL;
    *pcCountries = 0;

    /* Get the buffer size needed.
    */
    ZeroMemory( &list, sizeof(list) );
    list.dwTotalSize = sizeof(list);
    TRACE("lineGetCountryW");
    dwErr = lineGetCountryW( dwCountryID, TAPIVERSION, &list );
    TRACE1("lineGetCountryW=$%X",dwErr);
    if (dwErr != 0)
        return dwErr;

    /* Allocate the buffer.
    */
    pList = (LINECOUNTRYLIST* )Malloc( list.dwNeededSize );
    if (!pList)
        return ERROR_NOT_ENOUGH_MEMORY;

    /* Fill the buffer with TAPI country info.
    */
    ZeroMemory( pList, list.dwNeededSize );
    pList->dwTotalSize = list.dwNeededSize;
    TRACE("lineGetCountryW");
    dwErr = lineGetCountryW( dwCountryID, TAPIVERSION, pList );
    TRACE1("lineGetCountryW=$%X",dwErr);
    if (dwErr != 0)
    {
        Free( pList );
        return dwErr;
    }

    /* Allocate array returned to caller.
    */
    *pcCountries = pList->dwNumCountries;
    TRACE1("countries=%d",*pcCountries);
    cb = (sizeof(COUNTRY) * *pcCountries) + sizeof(LINECOUNTRYLIST*);
    *ppCountries = Malloc( cb );
    if (!*ppCountries)
    {
        *pcCountries = 0;
        Free( pList );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    /* Fill buffer returned to caller with information from TAPI location
    ** buffer.  References to the CAPS buffer are included, so the address
    ** of the CAPS buffer is tacked on the end for freeing later.
    */
    pEntry = (LINECOUNTRYENTRY* )
        (((BYTE* )pList) + pList->dwCountryListOffset);
    pCountry = *ppCountries;
    ZeroMemory( pCountry, cb );
    for (i = 0; i < *pcCountries; ++i)
    {
        pCountry->dwId = pEntry->dwCountryID;
        pCountry->dwCode = pEntry->dwCountryCode;
        pCountry->pszName =
            (TCHAR* )(((BYTE* )pList) + pEntry->dwCountryNameOffset);

        ++pEntry;
        ++pCountry;
    }

    *((LINECOUNTRYLIST** )pCountry) = pList;
    return 0;
}


DWORD
GetCurrentLocation(
    IN     HINSTANCE hInst,
    IN OUT HLINEAPP* pHlineapp )

    /* Returns the ID of the current TAPI location, or the default 0 if there
    ** is none.  'HInst' is the module instance handle.  '*PHlineapp' is the
    ** TAPI handle returned from a previous TAPI call or NULL if none.
    */
{
    DWORD             dwErr;
    LINETRANSLATECAPS caps;
    DWORD             dwId;

    dwId = 0;

#if 0
    dwErr = TapiInit( hInst, pHlineapp, NULL );
    if (dwErr == 0)
#endif
    {
        ZeroMemory( &caps, sizeof(caps) );
        caps.dwTotalSize = sizeof(caps);
        TRACE("lineGetTranslateCapsW");
        dwErr = lineGetTranslateCapsW( *pHlineapp, TAPIVERSION, &caps );
        TRACE1("lineGetTranslateCapsW=$%X",dwErr);
        if (dwErr == 0)
            dwId = caps.dwCurrentLocationID;
    }

    TRACE1("GetCurrentLocation=%d",dwId);
    return dwId;
}


DWORD
GetDefaultDeviceBlob(
    IN  DWORD       dwDeviceId,
    OUT VARSTRING** ppVs,
    OUT BYTE**      ppBlob,
    OUT DWORD*      pcbBlob )

    /* Returns the default device blob for device 'dwDeviceId' in caller's
    ** '*ppBlob'.  '*pcbBlob' is set to the size of the blob.
    **
    ** Returns 0 if successful or an error code.  If succussful, it is
    ** caller's responsibility to Free the returned '*ppVs', which is a buffer
    ** containing the returned blob.
    */
{
    DWORD      dwErr;
    VARSTRING  vs;
    VARSTRING* pVs;

    *ppVs = NULL;
    *ppBlob = NULL;
    *pcbBlob = 0;

    /* Get the buffer size needed.
    */
    ZeroMemory( &vs, sizeof(vs) );
    vs.dwTotalSize = sizeof(vs);
    TRACE("lineGetDevConfigW");
    dwErr = lineGetDevConfigW( dwDeviceId, &vs, g_szTapiDevClass );
    TRACE1("lineGetDevConfigW=$%X",dwErr);
    if (dwErr != LINEERR_STRUCTURETOOSMALL && dwErr != 0)
        return dwErr;

    /* Allocate the buffer.
    */
    pVs = (VARSTRING* )Malloc( vs.dwNeededSize );
    if (!pVs)
        return ERROR_NOT_ENOUGH_MEMORY;

    /* Fill buffer with TAPI VARSTRING containing blob information.
    */
    ZeroMemory( pVs, vs.dwNeededSize );
    pVs->dwTotalSize = vs.dwNeededSize;
    TRACE("lineGetDevConfigW");
    dwErr = lineGetDevConfigW( dwDeviceId, pVs, g_szTapiDevClass );
    TRACE1("lineGetDevConfigW=$%X",dwErr);
    if (dwErr != 0)
    {
        Free( pVs );
        return dwErr;
    }

    *ppVs = pVs;
    *ppBlob = ((BYTE* )pVs) + pVs->dwStringOffset;
    *pcbBlob = pVs->dwStringSize;
    TRACE1("GetDefaultDeviceBlob=0,cb=%d",*pcbBlob);
    return 0;
}


DWORD
GetLocationInfo(
    IN     HINSTANCE  hInst,
    IN OUT HLINEAPP*  pHlineapp,
    OUT    LOCATION** ppLocations,
    OUT    DWORD*     pcLocations,
    OUT    DWORD*     pdwCurLocation )

    /* Sets '*ppLocations' to a heap block containing TAPI location
    ** information.  '*PcLocations' is set to the number of elements in the
    ** array.  '*pdwLocation' is set to the TAPI ID of the currently selected
    ** location.  '*PHlineapp' is the TAPI handle returned from a previous
    ** TAPI call or NULL if none.  'HInst' is the module instance handle.
    **
    ** Returns 0 if successful, or an error code.  If successful, it is
    ** caller's responsibility to call FreeLocationInfo on *ppLocations.
    */
{
    DWORD              dwErr;
    LINETRANSLATECAPS  caps;
    LINETRANSLATECAPS* pCaps;
    LINELOCATIONENTRY* pEntry;
    LOCATION*          pLocation;
    DWORD              cb;
    DWORD              i;

    TRACE("GetLocationInfo");

    *ppLocations = NULL;
    *pcLocations = 0;
    *pdwCurLocation = 0;

#if 0
    dwErr = TapiInit( hInst, pHlineapp, NULL );
    if (dwErr != 0)
        return dwErr;
#endif

    /* Get the buffer size needed.
    */
    ZeroMemory( &caps, sizeof(caps) );
    caps.dwTotalSize = sizeof(caps);
    TRACE("lineGetTranslateCapsW");
    dwErr = lineGetTranslateCapsW( *pHlineapp, TAPIVERSION, &caps );
    TRACE1("lineGetTranslateCapsW=$%X",dwErr);
    if (dwErr != 0)
    {
        if (dwErr == (DWORD )LINEERR_INIFILECORRUPT)
        {
            /* Means the TAPI registry is uninitialized.  Return no locations
            ** and "default" current location.
            */
            dwErr = 0;
        }
        return dwErr;
    }

    /* Allocate the buffer.
    */
    pCaps = (LINETRANSLATECAPS* )Malloc( caps.dwNeededSize );
    if (!pCaps)
        return ERROR_NOT_ENOUGH_MEMORY;

    /* Fill buffer with TAPI location data.
    */
    ZeroMemory( pCaps, caps.dwNeededSize );
    pCaps->dwTotalSize = caps.dwNeededSize;
    TRACE("lineGetTranslateCapsW");
    dwErr = lineGetTranslateCapsW( *pHlineapp, TAPIVERSION, pCaps );
    TRACE1("lineGetTranslateCapsW=$%X",dwErr);
    if (dwErr != 0)
    {
        Free( pCaps );
        return dwErr;
    }

    /* Allocate array returned to caller.
    */
    *pcLocations = pCaps->dwNumLocations;
    *pdwCurLocation = pCaps->dwCurrentLocationID;
    TRACE2("locs=%d,cur=%d",*pcLocations,*pdwCurLocation);
    cb = (sizeof(LOCATION) * *pcLocations) + sizeof(LINETRANSLATECAPS*);
    *ppLocations = Malloc( cb );
    if (!*ppLocations)
    {
        *pcLocations = 0;
        Free( pCaps );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    /* Fill buffer returned to caller with information from TAPI location
    ** buffer.  References to the CAPS buffer are included, so the address
    ** of the CAPS buffer is tacked on the end for freeing later.
    */
    pEntry = (LINELOCATIONENTRY* )
        (((BYTE* )pCaps) + pCaps->dwLocationListOffset);
    pLocation = *ppLocations;
    ZeroMemory( pLocation, cb );
    for (i = 0; i < *pcLocations; ++i)
    {
        pLocation->dwId = pEntry->dwPermanentLocationID;
        pLocation->pszName =
            (TCHAR* )(((BYTE* )pCaps) + pEntry->dwLocationNameOffset);

        ++pEntry;
        ++pLocation;
    }

    *((LINETRANSLATECAPS** )pLocation) = pCaps;
    return 0;
}


DWORD
SetCurrentLocation(
    IN     HINSTANCE hInst,
    IN OUT HLINEAPP* pHlineapp,
    IN     DWORD     dwLocationId )

    /* Sets the current TAPI location to 'dwLocationId'.  '*PHlineapp' is the
    ** TAPI handle returned from a previous TAPI call or NULL if none.
    ** 'HInst' is the module instance handle.
    **
    ** Returns 0 if successful, or an error code.
    */
{
    DWORD    dwErr;
    HLINEAPP hlineapp;

    TRACE1("SetCurrentLocation(id=%d)",dwLocationId);

#if 0
    dwErr = TapiInit( hInst, pHlineapp, NULL );
    if (dwErr != 0)
        return dwErr;
#endif

    TRACE("lineSetCurrentLocation");
    dwErr = lineSetCurrentLocation( *pHlineapp, dwLocationId );
    TRACE1("lineSetCurrentLocation=$%X",dwErr);

    if (dwErr == (DWORD )LINEERR_INIFILECORRUPT && dwLocationId == 0)
    {
        /* Means the TAPI registry is uninitialized.  If caller is setting the
        ** default location, this is OK.
        */
        return 0;
    }

    return dwErr;
}


#if 0
DWORD
TapiConfigureDlg(
    IN     HWND   hwndOwner,
    IN     DWORD  dwDeviceId,
    IN OUT BYTE** ppBlob,
    IN OUT DWORD* pcbBlob )

    /* Popup the TAPI dialog to edit device 'dwDeviceId, with input blob
    ** '*ppBlob' of size '*pcBlob'.  '*ppBlob' can be NULL causing the current
    ** system defaults for the device to be used as input.  'HwndOwner' is the
    ** window owning the modal dialog.
    */
{
    DWORD      dwErr;
    VARSTRING  vs;
    VARSTRING* pVs;
    VARSTRING* pVsDefault;
    BYTE*      pIn;
    BYTE*      pOut;
    DWORD      cbIn;
    DWORD      cbOut;

    TRACE("TapiConfigureDlg");

    pVs = NULL;

    if (*ppBlob)
    {
        /* Caller provided input blob.
        */
        pIn = *ppBlob;
        cbIn = *pcbBlob;
    }
    else
    {
        /* Caller did not provide input blob, so look up the default for this
        ** device.
        */
        dwErr = GetDefaultDeviceBlob( dwDeviceId, &pVsDefault, &pIn, &cbIn );
        if (dwErr != 0)
            return dwErr;
    }

    /* Get the buffer size needed.
    */
    ZeroMemory( &vs, sizeof(vs) );
    vs.dwTotalSize = sizeof(vs);
    TRACE("lineConfigDialogEditW");
    dwErr = lineConfigDialogEditW(
        dwDeviceId, hwndOwner, g_szTapiDevClass, pIn, cbIn, &vs );
    TRACE1("lineConfigDialogEditW=$%X",dwErr);
    if (dwErr != LINEERR_STRUCTURETOOSMALL && dwErr != 0)
        goto TapiConfigureDlg_Error;

    /* Allocate the buffer.
    */
    pVs = (VARSTRING* )Malloc( vs.dwNeededSize );
    if (!pVs)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto TapiConfigureDlg_Error;
    }

    /* Popup the dialog which edits the information in the buffer.
    */
    ZeroMemory( pVs, vs.dwNeededSize );
    pVs->dwTotalSize = vs.dwNeededSize;
    TRACE("lineConfigDialogEditW");
    dwErr = lineConfigDialogEditW(
        dwDeviceId, hwndOwner, g_szTapiDevClass, pIn, cbIn, pVs );
    TRACE1("lineConfigDialogEditW=$%X",dwErr);
    if (dwErr != 0)
        goto TapiConfigureDlg_Error;

    /* Allocate a new "blob" buffer and fill it with the "blob" subset of the
    ** larger VARSTRING buffer.  Can't avoid this copy without introducing
    ** Freeing complexity for caller.
    */
    cbOut = pVs->dwStringSize;
    pOut = Malloc( cbOut );
    if (!pOut)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto TapiConfigureDlg_Error;
    }

    CopyMemory( pOut, ((BYTE* )pVs) + pVs->dwStringOffset, cbOut );
    Free( pVs );

    if (pIn == *ppBlob)
        Free( pIn );
    else
        Free( pVsDefault );

    *ppBlob = pOut;
    *pcbBlob = cbOut;
    TRACE1("TapiConfigureDlg=0,cbBlob=%d",cbOut);
    return 0;

TapiConfigureDlg_Error:

    Free0( pVs );
    if (pIn != *ppBlob)
        Free( pVsDefault );

    TRACE1("TapiConfigureDlg=$%X",dwErr);
    return dwErr;
}
#endif


#if 0
DWORD
TapiInit(
    IN     HINSTANCE hInst,
    IN OUT HLINEAPP* pHlineapp,
    OUT    DWORD*    pcDevices )

    /* Initialize TAPI and return the app handle and device count.  Does
    ** nothing if '*pHlineapp' is non-NULL.  'PcDevices' may be NULL if caller
    ** is not interested in the device count.  'HInst' is the module instance.
    **
    ** According to BernieM, the hlineapp passed to the TAPI location,
    ** country, and line translation APIs (the ones we use in the UI) is not
    ** currently used.  Therefore, since, lineInitialize can take several
    ** seconds to complete we optimize for speed by stubbing it out in these
    ** wrappers.
    */
{
    DWORD    dwErr;
    HLINEAPP hlineapp;
    DWORD    cDevices;

    ASSERT(pHlineapp);
    TRACE1("TapiInit(h=$%x)",*pHlineapp);

    dwErr = 0;

    if (!*pHlineapp)
    {
        hlineapp = NULL;
        cDevices = 0;

        TRACE("lineInitializeW");
        dwErr = lineInitializeW(
            &hlineapp, hInst, TapiLineCallback, NULL, &cDevices );
        TRACE1("lineInitializeW=$%X",dwErr);

        if (dwErr == 0)
        {
            *pHlineapp = hlineapp;
            if (pcDevices)
                *pcDevices = cDevices;
        }
    }

    return dwErr;
}
#endif


void
TapiLineCallback(
    IN DWORD hDevice,
    IN DWORD dwMessage,
    IN DWORD dwInstance,
    IN DWORD dwParam1,
    IN DWORD dwParam2,
    IN DWORD dwParam3 )

    /* Dummy TAPI callback required by lineInitialize.
    */
{
    TRACE3("TapiLineCallback(h=$%x,m=$%x,i=$%x...",hDevice,dwMessage,dwInstance);
    TRACE3(" p1=$%x,p2=$%x,p3=$%x)",dwParam1,dwParam2,dwParam3);
}


DWORD
TapiLocationDlg(
    IN     HINSTANCE hInst,
    IN OUT HLINEAPP* pHlineapp,
    IN     HWND      hwndOwner,
    IN     DWORD     dwCountryCode,
    IN     TCHAR*    pszAreaCode,
    IN     TCHAR*    pszPhoneNumber,
    IN     DWORD     dwDeviceId )

    /* Displays the TAPI location property sheet owned by 'hwndOwner'.
    ** '*PHlineapp' is the TAPI handle returned from a previous TAPI call or
    ** NULL if none.  'DwCountryCode', 'pszAreaCode', and 'pszPhoneNumber' are
    ** the components of the TAPI canonical phone number.  'DwDeviceId'
    ** specified the device to which the dialog applies, or 0 for a generic
    ** device.  'HInst' is the module instance handle.
    */
{
    DWORD  dwErr;
    DWORD  cDevices;
    TCHAR* pszCanon;

    TRACE("TapiLocationDlg");

#if 0
    dwErr = TapiInit( hInst, pHlineapp, NULL );
    if (dwErr != 0)
        return dwErr;
#endif

    pszCanon = GetCanonPhoneNumber(
        dwCountryCode, pszAreaCode, pszPhoneNumber );
    TRACEW1("lineTranslateDialogW(\"%s\")",(pszCanon)?pszCanon:TEXT(""));
    dwErr = lineTranslateDialogW(
        *pHlineapp, dwDeviceId, TAPIVERSION, hwndOwner, pszCanon );
    TRACE1("lineTranslateDialogW=$%X",dwErr);
    Free0( pszCanon );

    return dwErr;
}


DWORD APIENTRY
TapiNewLocation(
    IN TCHAR* pszName )

    /* Clone current location giving name 'pszName'.
    **
    ** Returns 0 if successful, or an error code.
    */
{
    TRACEW1("TapiNewLocation(%s)",pszName);

#ifdef UNICODE

    return internalNewLocationW( pszName );

#else
    {
        DWORD  dwErr;
        WCHAR* pszNameW;

        pszNameW = StrDupWFromA( pszName );
        dwErr = internalNewLocation( pszNameW );
        Free0( pszNameW );
        return dwErr;
    }
#endif
}


DWORD
TapiNoLocationDlg(
    IN HINSTANCE hInst,
    IN HLINEAPP* pHlineapp,
    IN HWND      hwndOwner )

    /* Gives TAPI a chance to initialize the first location, if necessary.
    ** Call this before any other TAPI calls.  'HInst' is the module instance
    ** handle.  '*pHlineapp' is the handle returned from a previous TAPI call
    ** or NULL if none (typical in this case).  'HwndOwner' is the window to
    ** own the TAPI dialog, if it appears.
    **
    ** Returns 0 if successful, or an error code.
    */
{
    DWORD             dwErr;
    LINETRANSLATECAPS caps;

    TRACE("TapiNoLocationDlg");

#if 0
    dwErr = TapiInit( hInst, pHlineapp, NULL );
    if (dwErr != 0)
        return dwErr;
#endif

    /* Make an arbitrary TAPI call to see if the TAPI registry has been
    ** initialized.
    */
    ZeroMemory( &caps, sizeof(caps) );
    caps.dwTotalSize = sizeof(caps);
    TRACE("lineGetTranslateCapsW");
    dwErr = lineGetTranslateCapsW( *pHlineapp, TAPIVERSION, &caps );
    TRACE1("lineGetTranslateCapsW=$%X",dwErr);

    if (dwErr == (DWORD )LINEERR_INIFILECORRUPT)
    {
        /* This semi-private TAPI API allows the "first location" wizard page
        ** to appear without the following "TAPI Dialing Properties" sheet.
        */
        extern LOpenDialAsst(
            IN HWND    hwnd,
            IN LPCTSTR lpszAddressIn,
            IN BOOL    fSimple,
            IN BOOL    fSilentInstall );

        dwErr = LOpenDialAsst( hwndOwner, NULL, TRUE, TRUE );
    }

    return dwErr;
}


DWORD APIENTRY
TapiRemoveLocation(
    IN DWORD dwID )

    /* Remove TAPI location 'dwID'.
    **
    ** Returns 0 if successful, or an error code.
    */
{
    TRACE("TapiRemoveLocation");

    return internalRemoveLocation( dwID );
}


DWORD APIENTRY
TapiRenameLocation(
    IN WCHAR* pszOldName,
    IN WCHAR* pszNewName )

    /* Renames TAPI location 'pszOldName' to 'pszNewName'.
    **
    ** Returns 0 if successful, or an error code.
    */
{
    TRACEW1("TapiRenameLocation(o=%s...",pszOldName);
    TRACEW1("...n=%s)",pszNewName);

#ifdef UNICODE

    return internalRenameLocationW( pszOldName, pszNewName );

#else
    {
        WCHAR* pszOldNameW;
        WCHAR* pszNewNameW;

        pszOldNameW = StrDupWFromA( pszOldName );
        pszNewNameW = StrDupWFromA( pszNewName );
        dwErr = internalNewLocation( pszOldNameW, pszNewNameW );
        Free0( pszOldNameW );
        Free0( pszNewNameW );
        return dwErr;
    }
#endif
}


DWORD
TapiShutdown(
    IN HLINEAPP hlineapp )

    /* Terminate the TAPI session 'hlineapp', or do nothing if 'hlineapp' is
    ** NULL.
    */
{
#if 0
    DWORD dwErr = 0;

    TRACE1("TapiShutdown(h=$%x)",hlineapp);

    if (hlineapp)
    {
        TRACE("lineShutdown");
        dwErr = lineShutdown( hlineapp );
        TRACE1("lineShutdown=$%X",dwErr);
    }

    return dwErr;
#else
    /* See TapiInit.
    */
    ASSERT(!hlineapp);
    return 0;
#endif
}


DWORD
TapiTranslateAddress(
    IN     HINSTANCE hInst,
    IN OUT HLINEAPP* pHlineapp,
    IN     DWORD     dwCountryCode,
    IN     TCHAR*    pszAreaCode,
    IN     TCHAR*    pszPhoneNumber,
    IN     DWORD     dwDeviceId,
    IN     BOOL      fDialable,
    OUT    TCHAR**   ppszResult )

    /* Returns '*pszResult', a heap string containing the TAPI location
    ** transformed dialable phone number built from the component phone number
    ** parts.  '*PHlineapp' is the TAPI handle returned from a previous TAPI
    ** call or NULL if none.  parts.  'dwDeviceId' is the device to which the
    ** number is to be applied or 0 for generic treatment.  'HInst' is the
    ** module instance handle.  'FDialable' indicates the dialable, as opposed
    ** to the displayable string should be returned.
    **
    ** Returns 0 if successful, or an error code.
    */
{
    DWORD                dwErr;
    TCHAR*               pszCanon;
    LINETRANSLATEOUTPUT  output;
    LINETRANSLATEOUTPUT* pOutput;

    TRACE("TapiTranslateAddress");

    pOutput = NULL;
    pszCanon = NULL;
    *ppszResult = NULL;

#if 0
    dwErr = TapiInit( hInst, pHlineapp, NULL );
    if (dwErr != 0)
        return dwErr;
#endif

    pszCanon = GetCanonPhoneNumber(
        dwCountryCode, pszAreaCode, pszPhoneNumber );

    ZeroMemory( &output, sizeof(output) );
    output.dwTotalSize = sizeof(output);

    TRACE("lineTranslateAddressW");
    dwErr = lineTranslateAddressW(
        *pHlineapp, dwDeviceId, TAPIVERSION, pszCanon, 0,
        LINETRANSLATEOPTION_CANCELCALLWAITING, &output );
    TRACE1("lineTranslateAddressW=$%X",dwErr);
    if (dwErr != 0)
        goto TapiTranslateAddress_Error;

    pOutput = (LINETRANSLATEOUTPUT* )Malloc( output.dwNeededSize );
    if (!pOutput)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto TapiTranslateAddress_Error;
    }

    ZeroMemory( pOutput, output.dwNeededSize );
    pOutput->dwTotalSize = output.dwNeededSize;
    TRACE("lineTranslateAddressW");
    dwErr = lineTranslateAddressW(
        *pHlineapp, dwDeviceId, TAPIVERSION, pszCanon, 0,
        LINETRANSLATEOPTION_CANCELCALLWAITING, pOutput );
    TRACE1("lineTranslateAddressW=$%X",dwErr);
    if (dwErr != 0)
        goto TapiTranslateAddress_Error;

    if (fDialable)
    {
        *ppszResult = StrDup(
            (TCHAR* )(((BYTE* )pOutput) + pOutput->dwDialableStringOffset) );
    }
    else
    {
        *ppszResult = StrDup(
            (TCHAR* )(((BYTE* )pOutput) + pOutput->dwDisplayableStringOffset) );
    }

    if (!*ppszResult)
        dwErr = ERROR_NOT_ENOUGH_MEMORY;

TapiTranslateAddress_Error:

    Free0( pszCanon );
    Free0( pOutput );
    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\nt4\common\uiutil\ipaddr.c ===
/* Copyright (c) 1991, Microsoft Corporation, all rights reserved
**
** ipaddr.c
** IP Address custom edit control
**
** 11/09/92 Greg Strange
**     Original code
**
** 09/07/95 Steve Cobb
**     Lifted TerryK/TRomano-updated version from NCPA, deleting IPDLL
**     stuff, and making minor RAS-related customizations.
*/

#include <windows.h> // Win32 core
#include <uiutil.h>  // Our public header


#define IPADDRESS_CLASS TEXT("RasIpAddress")


/* Module instance handle set when custom control is initialized.
*/
static HANDLE g_hLibInstance = NULL;

/* String ID of message displayed when user enters a field value that is out
** of range.  Something like "You must choose a value from %1 to %2 for this
** field."  Set when the custom control is initialized.
*/
static DWORD g_dwBadIpAddrRange = 0;

/* String ID of the popup title when the range error above is displayed.  Set
** when the custom control is initialized.
*/
static DWORD g_dwErrorTitle = 0;


// The character that is displayed between address fields.
#define FILLER     TEXT('.')
#define SZFILLER   TEXT(".")
#define SPACE      TEXT(' ')
#define BACK_SPACE 8

/* Min, max values */
#define NUM_FIELDS      4
#define CHARS_PER_FIELD 3
#define HEAD_ROOM       1       // space at top of control
#define LEAD_ROOM       3       // space at front of control
#define MIN_FIELD_VALUE 0       // default minimum allowable field value
#define MAX_FIELD_VALUE 255     // default maximum allowable field value


// All the information unique to one control is stuffed in one of these
// structures in global memory and the handle to the memory is stored in the
// Windows extra space.

typedef struct tagFIELD {
    HANDLE      hWnd;
    FARPROC     lpfnWndProc;
    BYTE        byLow;  // lowest allowed value for this field.
    BYTE        byHigh; // Highest allowed value for this field.
} FIELD;

typedef struct tagCONTROL {
    HWND        hwndParent;
    UINT        uiFieldWidth;
    UINT        uiFillerWidth;
    BOOL        fEnabled;
    BOOL        fPainted;
    BOOL        bControlInFocus;        // TRUE if the control is already in focus, dont't send another focus command
    BOOL        bCancelParentNotify;    // Don't allow the edit controls to notify parent if TRUE
    BOOL        fInMessageBox;  // Set when a message box is displayed so that
                                // we don't send a EN_KILLFOCUS message when
                                // we receive the EN_KILLFOCUS message for the
                                // current field.
    FIELD       Children[NUM_FIELDS];
} CONTROL;


// The following macros extract and store the CONTROL structure for a control.
#define IPADDRESS_EXTRA             sizeof(DWORD)
#define GET_CONTROL_HANDLE(hWnd)    ((HGLOBAL)(GetWindowLongPtr((hWnd), GWLP_USERDATA)))
#define SAVE_CONTROL_HANDLE(hWnd,x) (SetWindowLongPtr((hWnd), GWLP_USERDATA, (LONG_PTR)x))


/* internal IPAddress function prototypes */
INT_PTR FAR PASCAL IPAddressWndFn( HWND, UINT, WPARAM, LPARAM );
INT_PTR FAR PASCAL IPAddressFieldProc(HWND, UINT, WPARAM, LPARAM);
BOOL SwitchFields(CONTROL FAR *, int, int, WORD, WORD);
void EnterField(FIELD FAR *, WORD, WORD);
BOOL ExitField(CONTROL FAR *, int iField);
int GetFieldValue(FIELD FAR *);


LOGFONT logfont;


void SetDefaultFont( )
{
    logfont.lfWidth            = 0;
    logfont.lfEscapement       = 0;
    logfont.lfOrientation      = 0;
    logfont.lfOutPrecision     = OUT_DEFAULT_PRECIS;
    logfont.lfClipPrecision    = CLIP_DEFAULT_PRECIS;
    logfont.lfQuality          = DEFAULT_QUALITY;
    logfont.lfPitchAndFamily   = VARIABLE_PITCH | FF_SWISS;
    logfont.lfUnderline        = 0;
    logfont.lfStrikeOut        = 0;
    logfont.lfItalic           = 0;
    logfont.lfWeight           = FW_NORMAL;
#ifdef JAPAN
    logfont.lfHeight           = -(10*GetDeviceCaps(GetDC(NULL),LOGPIXELSY)/72);
    logfont.lfCharSet          = SHIFTJIS_CHARSET;
    lstrcpy( logfont.lfFaceName,TEXT("lr SVbN"));
#else
    logfont.lfHeight           = -(8*GetDeviceCaps(GetDC(NULL),LOGPIXELSY)/72);
    logfont.lfCharSet          = ANSI_CHARSET;
    lstrcpy( logfont.lfFaceName,TEXT("MS Shell Dlg"));
#endif
}



/*
    IpAddrInit() - IPAddress custom control initialization
    call
        hInstance = library or application instance
        dwErrorTitle = String ID of error popup title
        dwBadIpAddrRange = String ID of bad range popup text, e.g.
            "You must choose a value between %1 and %2 for this field."
    return
        TRUE on success, FALSE on failure.

    This function does all the one time initialization of IPAddress custom
    controls.  Specifically it creates the IPAddress window class.
*/
int FAR PASCAL
IpAddrInit(
    IN HANDLE hInstance,
    IN DWORD  dwErrorTitle,
    IN DWORD  dwBadIpAddrRange )
{
    HGLOBAL            hClassStruct;
    LPWNDCLASS        lpClassStruct;

    /* register IPAddress window if necessary */
    if ( g_hLibInstance == NULL ) {

        /* allocate memory for class structure */
        hClassStruct = GlobalAlloc( GHND, (DWORD)sizeof(WNDCLASS) );
        if ( hClassStruct ) {

            /* lock it down */
            lpClassStruct = (LPWNDCLASS)GlobalLock( hClassStruct );
            if ( lpClassStruct ) {

                /* define class attributes */
                lpClassStruct->lpszClassName = IPADDRESS_CLASS;
                lpClassStruct->hCursor =       LoadCursor(NULL,IDC_IBEAM);
                lpClassStruct->lpszMenuName =  (LPCTSTR)NULL;
                lpClassStruct->style =         CS_HREDRAW|CS_VREDRAW|CS_DBLCLKS|CS_GLOBALCLASS;
                lpClassStruct->lpfnWndProc =   IPAddressWndFn;
                lpClassStruct->hInstance =     hInstance;
                lpClassStruct->hIcon =         NULL;
                lpClassStruct->cbWndExtra =    IPADDRESS_EXTRA;
                lpClassStruct->hbrBackground = (HBRUSH)(COLOR_WINDOW + 1 );

                /* register IPAddress window class */
                g_hLibInstance = ( RegisterClass(lpClassStruct) ) ? hInstance : NULL;
                GlobalUnlock( hClassStruct );
            }
            GlobalFree( hClassStruct );
        }
    }
    SetDefaultFont();

    g_dwErrorTitle = dwErrorTitle;
    g_dwBadIpAddrRange = dwBadIpAddrRange;

    return( g_hLibInstance ? 1:0 );
}


void FormatIPAddress(LPTSTR pszString, DWORD* dwValue)
{
    static TCHAR szBuf[CHARS_PER_FIELD+1];
    int nField, nPos;
    BOOL fFinish = FALSE;

    dwValue[0] = 0; dwValue[1] = 0; dwValue[2] = 0; dwValue[3] = 0;

    if (pszString[0] == 0)
        return;

    for( nField = 0, nPos = 0; !fFinish; nPos++)
    {
        if (( pszString[nPos]<TEXT('0')) || (pszString[nPos]>TEXT('9')))
        {
            // not a number
            nField++;
            fFinish = (nField == 4);
        }
        else
        {
            dwValue[nField] *= 10;
            dwValue[nField] += (pszString[nPos]-TEXT('0'));
        }
    }
}

INT_PTR FAR PASCAL IPAddressWndFn( hWnd, wMsg, wParam, lParam )
    HWND            hWnd;
    UINT            wMsg;
    WPARAM            wParam;
    LPARAM            lParam;
{
    INT_PTR lResult;
    HGLOBAL hControl;
    CONTROL *pControl;
    int i;

    lResult = TRUE;

    switch( wMsg )
    {

// use empty string (not NULL) to set to blank
    case WM_SETTEXT:
        {
            static TCHAR szBuf[CHARS_PER_FIELD+1];
            DWORD dwValue[4];
            LPTSTR pszString = (LPTSTR)lParam; 

            if (!pszString)
                pszString = TEXT("0.0.0.0");

            FormatIPAddress(pszString, &dwValue[0]);

            hControl = GET_CONTROL_HANDLE(hWnd);
            pControl = (CONTROL *)GlobalLock(hControl);
            pControl->bCancelParentNotify = TRUE;

            for (i = 0; i < NUM_FIELDS; ++i)
            {
                if (pszString[0] == 0)
                {
                    szBuf[0] = 0;
                }
                else
                {
                    wsprintf(szBuf, TEXT("%d"), dwValue[i]);
                }
                SendMessage(pControl->Children[i].hWnd, WM_SETTEXT,
                                0, (LPARAM) (LPSTR) szBuf);
            }

            pControl->bCancelParentNotify = FALSE;

            SendMessage(pControl->hwndParent, WM_COMMAND,
                MAKEWPARAM(GetWindowLong(hWnd, GWL_ID), EN_CHANGE), (LPARAM)hWnd);

            GlobalUnlock(hControl);
        }
        break;

    case WM_GETTEXTLENGTH:
    case WM_GETTEXT:
        {
            int iFieldValue;
            int srcPos, desPos;
            DWORD dwValue[4];
            TCHAR pszResult[30];
            TCHAR *pszDest = (TCHAR *)lParam;

            hControl = GET_CONTROL_HANDLE(hWnd);
            pControl = (CONTROL *)GlobalLock(hControl);

            lResult = 0;
            dwValue[0] = 0;
            dwValue[1] = 0;
            dwValue[2] = 0;
            dwValue[3] = 0;
            for (i = 0; i < NUM_FIELDS; ++i)
            {
                iFieldValue = GetFieldValue(&(pControl->Children[i]));
                if (iFieldValue == -1)
                    iFieldValue = 0;
                else
                    ++lResult;
                dwValue[i] = iFieldValue;
            }
            wsprintf( pszResult, TEXT("%d.%d.%d.%d"), dwValue[0], dwValue[1], dwValue[2], dwValue[3] );
            if ( wMsg == WM_GETTEXTLENGTH )
            {
                lResult = lstrlen( pszResult );
            }
            else
            {
                for ( srcPos=0, desPos=0; (srcPos+1<(INT)wParam) && (pszResult[srcPos]!=TEXT('\0')); )
                {
                    pszDest[desPos++] = pszResult[srcPos++];
                }
                pszDest[desPos]=TEXT('\0');
                lResult = desPos;
            }
            GlobalUnlock(hControl);
        }
        break;

    case WM_GETDLGCODE :
        lResult = DLGC_WANTCHARS;
        break;

    case WM_NCCREATE:
        SetWindowLong(hWnd, GWL_EXSTYLE, (GetWindowLong(hWnd, GWL_EXSTYLE) | WS_EX_CLIENTEDGE));
        lResult = TRUE;
        break;

    case WM_CREATE : /* create pallette window */
        {
            HDC hdc;
            UINT uiFieldStart;
            FARPROC lpfnFieldProc;

            hControl = GlobalAlloc(GMEM_MOVEABLE, sizeof(CONTROL));
            if (hControl)
            {
                HFONT OldFont, hNewFont;
                RECT rect;

                #define LPCS    ((CREATESTRUCT *)lParam)

                pControl = (CONTROL *)GlobalLock(hControl);
                pControl->fEnabled = TRUE;
                pControl->fPainted = FALSE;
                pControl->fInMessageBox = FALSE;
                pControl->hwndParent = LPCS->hwndParent;
                pControl->uiFillerWidth = 1;
                pControl->bControlInFocus = FALSE;
                pControl->bCancelParentNotify = FALSE;

                hdc = GetDC(hWnd);
                hNewFont = CreateFontIndirect(&logfont);
                GetClientRect(hWnd, &rect);
                if (hNewFont)
                {
                    OldFont = SelectObject( hdc, hNewFont );
                    GetCharWidth(hdc, FILLER, FILLER,
                                            (int *)(&pControl->uiFillerWidth));
                    SelectObject(hdc, OldFont );                                            
                    DeleteObject(hNewFont);
                }                    
                ReleaseDC(hWnd, hdc);

                pControl->uiFieldWidth = (LPCS->cx
                                          - LEAD_ROOM
                                          - pControl->uiFillerWidth
                                              *(NUM_FIELDS-1))
                                                  / NUM_FIELDS;
                uiFieldStart = LEAD_ROOM;

                lpfnFieldProc = MakeProcInstance((FARPROC)IPAddressFieldProc,
                                                 LPCS->hInstance);

                for (i = 0; i < NUM_FIELDS; ++i)
                {
                    pControl->Children[i].byLow = MIN_FIELD_VALUE;
                    pControl->Children[i].byHigh = MAX_FIELD_VALUE;

                    pControl->Children[i].hWnd = CreateWindowEx(0, 
                                        TEXT("Edit"),
                                        NULL,
                                        WS_CHILD | WS_VISIBLE |
                                        ES_CENTER,
                                        uiFieldStart,
                                        HEAD_ROOM,
                                        pControl->uiFieldWidth,
                                        (rect.bottom-rect.top), 
                                        hWnd,
                                        (HMENU)UlongToPtr(i),
                                        LPCS->hInstance,
                                        (LPVOID)NULL);

                    SendMessage(pControl->Children[i].hWnd, EM_LIMITTEXT,
                                CHARS_PER_FIELD, 0L);

                    SendMessage(pControl->Children[i].hWnd, WM_SETFONT,
                                (WPARAM)CreateFontIndirect(&logfont), TRUE);

                    pControl->Children[i].lpfnWndProc =
                        (FARPROC) GetWindowLongPtr(pControl->Children[i].hWnd,
                                                GWLP_WNDPROC);

                    SetWindowLongPtr(pControl->Children[i].hWnd,
                                  GWLP_WNDPROC, (LONG_PTR)lpfnFieldProc);

                    uiFieldStart += pControl->uiFieldWidth
                                    + pControl->uiFillerWidth;
                }

                GlobalUnlock(hControl);
                SAVE_CONTROL_HANDLE(hWnd, hControl);

                #undef LPCS
            }
            else
                DestroyWindow(hWnd);
        }
        lResult = 0;
        break;

    case WM_PAINT: /* paint control window */
        {
            PAINTSTRUCT Ps;
            RECT rect;
            UINT uiFieldStart;
            COLORREF TextColor;
            COLORREF cRef;
            HFONT OldFont;
            HBRUSH hbr;
            HGDIOBJ hgdiobj = NULL;

            BeginPaint(hWnd, (LPPAINTSTRUCT)&Ps);
            OldFont = SelectObject( Ps.hdc, CreateFontIndirect(&logfont));
            GetClientRect(hWnd, &rect);
            hControl = GET_CONTROL_HANDLE(hWnd);
            pControl = (CONTROL *)GlobalLock(hControl);

            if (pControl->fEnabled)
            {
                TextColor = GetSysColor(COLOR_WINDOWTEXT);
                cRef = GetSysColor(COLOR_WINDOW);

            }
            else
            {
                TextColor = GetSysColor(COLOR_GRAYTEXT);
                cRef = GetSysColor(COLOR_3DFACE);
            }

            if (cRef)
                SetBkColor(Ps.hdc, cRef);

            if (TextColor)
                SetTextColor(Ps.hdc, TextColor);


            hbr = CreateSolidBrush(cRef);
            if (hbr)
            {
                FillRect(Ps.hdc, &rect, hbr);
                DeleteObject(hbr);
            }                

            SetRect(&rect, 0, HEAD_ROOM, pControl->uiFillerWidth, (rect.bottom-rect.top));
            ExtTextOut(Ps.hdc, rect.left, HEAD_ROOM, ETO_OPAQUE, &rect, L" ", 1, NULL);

            for (i = 0; i < NUM_FIELDS-1; ++i)
            {
                rect.left += pControl->uiFieldWidth + pControl->uiFillerWidth;
                rect.right += rect.left + pControl->uiFillerWidth;
                ExtTextOut(Ps.hdc, rect.left, HEAD_ROOM, ETO_OPAQUE, &rect, SZFILLER, 1, NULL);
            }

            pControl->fPainted = TRUE;

            GlobalUnlock(hControl);
            hgdiobj = SelectObject(Ps.hdc, OldFont);
            if(NULL != hgdiobj)
            {
                DeleteObject(hgdiobj);
            }
            EndPaint(hWnd, &Ps);
        }
        break;

    case WM_SETFOCUS : /* get focus - display caret */
        hControl = GET_CONTROL_HANDLE(hWnd);
        pControl = (CONTROL *)GlobalLock(hControl);
        EnterField(&(pControl->Children[0]), 0, CHARS_PER_FIELD);
        GlobalUnlock(hControl);
        break;

    case WM_LBUTTONDOWN : /* left button depressed - fall through */
        SetFocus(hWnd);
        break;

    case WM_ENABLE:
        {
            hControl = GET_CONTROL_HANDLE(hWnd);
            pControl = (CONTROL *)GlobalLock(hControl);
            pControl->fEnabled = (BOOL)wParam;
            for (i = 0; i < NUM_FIELDS; ++i)
            {
                EnableWindow(pControl->Children[i].hWnd, (BOOL)wParam);
            }
            if (pControl->fPainted)    InvalidateRect(hWnd, NULL, FALSE);
            GlobalUnlock(hControl);
        }
        break;

    case WM_DESTROY :
        hControl = GET_CONTROL_HANDLE(hWnd);
        pControl = (CONTROL *)GlobalLock(hControl);

// Restore all the child window procedures before we delete our memory block.
        for (i = 0; i < NUM_FIELDS; ++i)
        {
            SetWindowLongPtr(pControl->Children[i].hWnd, GWLP_WNDPROC,
                          (LONG_PTR)pControl->Children[i].lpfnWndProc);
        }

        GlobalUnlock(hControl);
        GlobalFree(hControl);
        break;

    case WM_COMMAND:
        switch (HIWORD(wParam))
        {
// One of the fields lost the focus, see if it lost the focus to another field
// of if we've lost the focus altogether.  If its lost altogether, we must send
// an EN_KILLFOCUS notification on up the ladder.
        case EN_KILLFOCUS:
            {
                HWND hFocus;

                hControl = GET_CONTROL_HANDLE(hWnd);
                pControl = (CONTROL *)GlobalLock(hControl);

                if (!pControl->fInMessageBox)
                {
                    hFocus = GetFocus();
                    for (i = 0; i < NUM_FIELDS; ++i)
                        if (pControl->Children[i].hWnd == hFocus)
                            break;

                    if (i >= NUM_FIELDS)
                    {
                        SendMessage(pControl->hwndParent, WM_COMMAND,
                                    MAKEWPARAM(GetWindowLong(hWnd, GWL_ID),
                                    EN_KILLFOCUS), (LPARAM)hWnd);
                        pControl->bControlInFocus = FALSE;
                    }
                }
                GlobalUnlock(hControl);
            }
            break;

        case EN_SETFOCUS:
            {
                HWND hFocus;

                hControl = GET_CONTROL_HANDLE(hWnd);
                pControl = (CONTROL *)GlobalLock(hControl);

                if (!pControl->fInMessageBox)
                {
                    hFocus = (HWND)lParam;

                    for (i = 0; i < NUM_FIELDS; ++i)
                        if (pControl->Children[i].hWnd == hFocus)
                            break;

                    // send a focus message when the 
                    if (i < NUM_FIELDS && pControl->bControlInFocus == FALSE)
                    {
                        SendMessage(pControl->hwndParent, WM_COMMAND,
                                    MAKEWPARAM(GetWindowLong(hWnd, GWL_ID),
                                    EN_SETFOCUS), (LPARAM)hWnd);

                    pControl->bControlInFocus = TRUE; // only set the focus once
                    }
                }
                GlobalUnlock(hControl);
            }
            break;

        case EN_CHANGE:
            hControl = GET_CONTROL_HANDLE(hWnd);
            pControl = (CONTROL *)GlobalLock(hControl);

            if (pControl->bCancelParentNotify == FALSE)
            {
                    SendMessage(pControl->hwndParent, WM_COMMAND,
                    MAKEWPARAM(GetWindowLong(hWnd, GWL_ID), EN_CHANGE), (LPARAM)hWnd);

                GlobalUnlock(hControl);
            }

            break;
        }
        break;

// Get the value of the IP Address.  The address is placed in the DWORD pointed
// to by lParam and the number of non-blank fields is returned.
    case IP_GETADDRESS:
        {
            int iFieldValue;
            DWORD dwValue;

            hControl = GET_CONTROL_HANDLE(hWnd);
            pControl = (CONTROL *)GlobalLock(hControl);

            lResult = 0;
            dwValue = 0;
            for (i = 0; i < NUM_FIELDS; ++i)
            {
                iFieldValue = GetFieldValue(&(pControl->Children[i]));
                if (iFieldValue == -1)
                    iFieldValue = 0;
                else
                    ++lResult;
                dwValue = (dwValue << 8) + iFieldValue;
            }
            *((DWORD *)lParam) = dwValue;

            GlobalUnlock(hControl);
        }
        break;

// Clear all fields to blanks.
    case IP_CLEARADDRESS:
        {
            hControl = GET_CONTROL_HANDLE(hWnd);
            pControl = (CONTROL *)GlobalLock(hControl);
            pControl->bCancelParentNotify = TRUE;
            for (i = 0; i < NUM_FIELDS; ++i)
            {
                SendMessage(pControl->Children[i].hWnd, WM_SETTEXT,
                            0, (LPARAM) (LPSTR) TEXT(""));
            }
            pControl->bCancelParentNotify = FALSE;
            SendMessage(pControl->hwndParent, WM_COMMAND,
                MAKEWPARAM(GetWindowLong(hWnd, GWL_ID), EN_CHANGE), (LPARAM)hWnd);

            GlobalUnlock(hControl);
        }
        break;

// Set the value of the IP Address.  The address is in the lParam with the
// first address byte being the high byte, the second being the second byte,
// and so on.  A lParam value of -1 removes the address.
    case IP_SETADDRESS:
        {
            static TCHAR szBuf[CHARS_PER_FIELD+1];
            DWORD dwValue[4];
            LPTSTR pszString = (LPTSTR)lParam;

            FormatIPAddress(pszString, &dwValue[0]);

            hControl = GET_CONTROL_HANDLE(hWnd);
            pControl = (CONTROL *)GlobalLock(hControl);

            pControl->bCancelParentNotify = TRUE;

            for (i = 0; i < NUM_FIELDS; ++i)
            {
                if (pszString[0] == 0)
                {
                    szBuf[0] =0;
                }
                else
                {
                    wsprintf(szBuf, TEXT("%d"), dwValue[i]);
                }
                SendMessage(pControl->Children[i].hWnd, WM_SETTEXT,
                                0, (LPARAM) (LPSTR) szBuf);
            }


            pControl->bCancelParentNotify = FALSE;

            SendMessage(pControl->hwndParent, WM_COMMAND,
                MAKEWPARAM(GetWindowLong(hWnd, GWL_ID), EN_CHANGE), (LPARAM)hWnd);

            GlobalUnlock(hControl);
        }
        break;

    case IP_SETRANGE:
        if (wParam < NUM_FIELDS)
        {
            hControl = GET_CONTROL_HANDLE(hWnd);
            pControl = (CONTROL *)GlobalLock(hControl);

            pControl->Children[wParam].byLow = LOBYTE(LOWORD(lParam));
            pControl->Children[wParam].byHigh = HIBYTE(LOWORD(lParam));

            GlobalUnlock(hControl);
        }
        break;

// Set the focus to this control.
// wParam = the field number to set focus to, or -1 to set the focus to the
// first non-blank field.
    case IP_SETFOCUS:
        hControl = GET_CONTROL_HANDLE(hWnd);
        pControl = (CONTROL *)GlobalLock(hControl);

        if (wParam >= NUM_FIELDS)
        {
            for (wParam = 0; wParam < NUM_FIELDS; ++wParam)
                if (GetFieldValue(&(pControl->Children[wParam])) == -1)   break;
            if (wParam >= NUM_FIELDS)    wParam = 0;
        }
        EnterField(&(pControl->Children[wParam]), 0, CHARS_PER_FIELD);

        GlobalUnlock(hControl);
        break;

// Determine whether all four subfields are blank
    case IP_ISBLANK:
        hControl = GET_CONTROL_HANDLE(hWnd);
        pControl = (CONTROL *)GlobalLock(hControl);

        lResult = TRUE;
        for (i = 0; i < NUM_FIELDS; ++i)
        {
            if (GetFieldValue(&(pControl->Children[i])) != -1)
            {
                lResult = FALSE;
                break;
            }
        }

        GlobalUnlock(hControl);
        break;

    default:
        lResult = DefWindowProc( hWnd, wMsg, wParam, lParam );
        break;
    }
    return( lResult );
}




/*
    IPAddressFieldProc() - Edit field window procedure

    This function sub-classes each edit field.
*/
INT_PTR FAR PASCAL IPAddressFieldProc(HWND hWnd,
                                   UINT wMsg,
                                   WPARAM wParam,
                                   LPARAM lParam)
{
    HANDLE hControl;
    CONTROL *pControl;
    FIELD *pField;
    HWND hControlWindow;
    WORD wChildID;
    LRESULT lresult;

    if (!(hControlWindow = GetParent(hWnd)))
        return 0;

    hControl = GET_CONTROL_HANDLE(hControlWindow);
    pControl = (CONTROL *)GlobalLock(hControl);
    wChildID = (WORD)GetWindowLong(hWnd, GWL_ID);
    pField = &(pControl->Children[wChildID]);
    if (pField->hWnd != hWnd)    return 0;

    switch (wMsg)
    {
    case WM_DESTROY:
        DeleteObject( (HGDIOBJ)SendMessage( hWnd, WM_GETFONT, 0, 0 ));
        return 0;
    case WM_CHAR:

// Typing in the last digit in a field, skips to the next field.
        if (wParam >= TEXT('0') && wParam <= TEXT('9'))
        {
            LONG_PTR dwResult;

            dwResult = CallWindowProc((WNDPROC)pControl->Children[wChildID].lpfnWndProc,
                                      hWnd, wMsg, wParam, lParam);
            dwResult = SendMessage(hWnd, EM_GETSEL, 0, 0L);

            if (dwResult == MAKELPARAM(CHARS_PER_FIELD, CHARS_PER_FIELD)
                && ExitField(pControl, wChildID)
                && wChildID < NUM_FIELDS-1)
            {
                EnterField(&(pControl->Children[wChildID+1]),
                                0, CHARS_PER_FIELD);
            }
            GlobalUnlock( hControl );
            return dwResult;
        }

// spaces and periods fills out the current field and then if possible,
// goes to the next field.
        else if (wParam == FILLER || wParam == SPACE )
        {
            LONG_PTR dwResult;
            dwResult = SendMessage(hWnd, EM_GETSEL, 0, 0L);
            if (dwResult != 0L && HIWORD(dwResult) == LOWORD(dwResult)
                && ExitField(pControl, wChildID))
            {
                if (wChildID >= NUM_FIELDS-1)
                    MessageBeep((UINT)-1);
                else
                {
                    EnterField(&(pControl->Children[wChildID+1]),
                                    0, CHARS_PER_FIELD);
                }
            }
            GlobalUnlock( hControl );
            return 0;
        }

// Backspaces go to the previous field if at the beginning of the current field.
// Also, if the focus shifts to the previous field, the backspace must be
// processed by that field.
        else if (wParam == BACK_SPACE)
        {
            if (wChildID > 0 && SendMessage(hWnd, EM_GETSEL, 0, 0L) == 0L)
            {
                if (SwitchFields(pControl, wChildID, wChildID-1,
                              CHARS_PER_FIELD, CHARS_PER_FIELD)
                    && SendMessage(pControl->Children[wChildID-1].hWnd,
                        EM_LINELENGTH, 0, 0L) != 0L)
                {
                    SendMessage(pControl->Children[wChildID-1].hWnd,
                                wMsg, wParam, lParam);
                }
                GlobalUnlock( hControl );
                return 0;
            }
        }

// Any other printable characters are not allowed.
        else if (wParam > SPACE)
        {
            MessageBeep((UINT)-1);
            GlobalUnlock( hControl );
            return 0;
        }
        break;

    case WM_KEYDOWN:
        switch (wParam)
        {

// Arrow keys move between fields when the end of a field is reached.
        case VK_LEFT:
        case VK_RIGHT:
        case VK_UP:
        case VK_DOWN:
            if (GetKeyState(VK_CONTROL) < 0)
            {
                if ((wParam == VK_LEFT || wParam == VK_UP) && wChildID > 0)
                {
                    SwitchFields(pControl, wChildID, wChildID-1,
                                  0, CHARS_PER_FIELD);
                    GlobalUnlock( hControl );
                    return 0;
                }
                else if ((wParam == VK_RIGHT || wParam == VK_DOWN)
                         && wChildID < NUM_FIELDS-1)
                {
                    SwitchFields(pControl, wChildID, wChildID+1,
                                      0, CHARS_PER_FIELD);
                    GlobalUnlock( hControl );
                    return 0;
                }
            }
            else
            {
                LONG_PTR dwResult;
                WORD wStart, wEnd;

                dwResult = SendMessage(hWnd, EM_GETSEL, 0, 0L);
                wStart = LOWORD(dwResult);
                wEnd = HIWORD(dwResult);
                if (wStart == wEnd)
                {
                    if ((wParam == VK_LEFT || wParam == VK_UP)
                        && wStart == 0
                        && wChildID > 0)
                    {
                        SwitchFields(pControl, wChildID, wChildID-1,
                                          CHARS_PER_FIELD, CHARS_PER_FIELD);
                        GlobalUnlock( hControl );
                        return 0;
                    }
                    else if ((wParam == VK_RIGHT || wParam == VK_DOWN)
                             && wChildID < NUM_FIELDS-1)
                    {
                        dwResult = SendMessage(hWnd, EM_LINELENGTH, 0, 0L);
                        if (wStart >= dwResult)
                        {
                            SwitchFields(pControl, wChildID, wChildID+1, 0, 0);
                            GlobalUnlock( hControl );
                            return 0;
                        }
                    }
                }
            }
            break;

// Home jumps back to the beginning of the first field.
        case VK_HOME:
            if (wChildID > 0)
            {
                SwitchFields(pControl, wChildID, 0, 0, 0);
                GlobalUnlock( hControl );
                return 0;
            }
            break;

// End scoots to the end of the last field.
        case VK_END:
            if (wChildID < NUM_FIELDS-1)
            {
                SwitchFields(pControl, wChildID, NUM_FIELDS-1,
                                CHARS_PER_FIELD, CHARS_PER_FIELD);
                GlobalUnlock( hControl );
                return 0;
            }
            break;


        } // switch (wParam)

        break;

    case WM_KILLFOCUS:
        if ( !ExitField( pControl, wChildID ))
        {
            GlobalUnlock( hControl );
            return 0;
        }

    } // switch (wMsg)

    lresult = CallWindowProc( (WNDPROC)pControl->Children[wChildID].lpfnWndProc,
        hWnd, wMsg, wParam, lParam);
    GlobalUnlock( hControl );
    return lresult;
}




/*
    Switch the focus from one field to another.
    call
        pControl = Pointer to the CONTROL structure.
        iOld = Field we're leaving.
        iNew = Field we're entering.
        hNew = Window of field to goto
        wStart = First character selected
        wEnd = Last character selected + 1
    returns
        TRUE on success, FALSE on failure.

    Only switches fields if the current field can be validated.
*/
BOOL SwitchFields(CONTROL *pControl, int iOld, int iNew, WORD wStart, WORD wEnd)
{
    if (!ExitField(pControl, iOld))    return FALSE;
    EnterField(&(pControl->Children[iNew]), wStart, wEnd);
    return TRUE;
}



/*
    Set the focus to a specific field's window.
    call
        pField = pointer to field structure for the field.
        wStart = First character selected
        wEnd = Last character selected + 1
*/
void EnterField(FIELD *pField, WORD wStart, WORD wEnd)
{
    SetFocus(pField->hWnd);
    SendMessage(pField->hWnd, EM_SETSEL, wStart, wEnd);
}


/*
    Exit a field.
    call
        pControl = pointer to CONTROL structure.
        iField = field number being exited.
    returns
        TRUE if the user may exit the field.
        FALSE if he may not.
*/
BOOL ExitField(CONTROL  *pControl, int iField)
{
    HWND hControlWnd;
    HWND hDialog;
    WORD wLength;
    FIELD *pField;
    static TCHAR szBuf[CHARS_PER_FIELD+1];
    int i,j;

    pField = &(pControl->Children[iField]);
    *(WORD *)szBuf = (sizeof(szBuf)/sizeof(TCHAR)) - 1;
    wLength = (WORD)SendMessage(pField->hWnd,EM_GETLINE,0,(LPARAM)(LPSTR)szBuf);
    if (wLength != 0)
    {
        szBuf[wLength] = TEXT('\0');
        for (j=0,i=0;j<(INT)wLength;j++)
        {
            i=i*10+szBuf[j]-TEXT('0');
        }
        if (i < (int)(UINT)pField->byLow || i > (int)(UINT)pField->byHigh)
        {
            if ( i < (int)(UINT) pField->byLow )
            {
                /* too small */
                wsprintf(szBuf, TEXT("%d"), (int)(UINT)pField->byLow );
            }
            else
            {
                /* must be bigger */
                wsprintf(szBuf, TEXT("%d"), (int)(UINT)pField->byHigh );
            }
            SendMessage(pField->hWnd, WM_SETTEXT, 0, (LPARAM) (LPSTR) szBuf);
            if ((hControlWnd = GetParent(pField->hWnd)) != NULL
                && (hDialog = GetParent(hControlWnd)) != NULL)
            {
                MSGARGS msgargs;
                TCHAR   szLow[ 50 ];
                TCHAR   szHigh[ 50 ];

                pControl->fInMessageBox = TRUE;

                ZeroMemory( &msgargs, sizeof(msgargs) );
                msgargs.dwFlags = MB_ICONEXCLAMATION + MB_OK;
                wsprintf( szLow, TEXT("%d"), (int )pField->byLow );
                msgargs.apszArgs[ 0 ] = szLow;
                wsprintf( szHigh, TEXT("%d"), (int )pField->byHigh );
                msgargs.apszArgs[ 1 ] = szHigh;

                MsgDlgUtil( hDialog, g_dwBadIpAddrRange,
                    &msgargs, g_hLibInstance, g_dwErrorTitle );

                pControl->fInMessageBox = FALSE;
                SendMessage(pField->hWnd, EM_SETSEL, 0, CHARS_PER_FIELD);
                return FALSE;
            }
        }
    }
    return TRUE;
}


/*
    Get the value stored in a field.
    call
        pField = pointer to the FIELD structure for the field.
    returns
        The value (0..255) or -1 if the field has not value.
*/
int GetFieldValue(FIELD *pField)
{
    WORD wLength;
    static TCHAR szBuf[CHARS_PER_FIELD+1];
    INT i,j;

    *(WORD *)szBuf = (sizeof(szBuf)/sizeof(TCHAR)) - 1;
    wLength = (WORD)SendMessage(pField->hWnd,EM_GETLINE,0,(LPARAM)(LPSTR)szBuf);
    if (wLength != 0)
    {
        szBuf[wLength] = TEXT('\0');
        for (j=0,i=0;j<(INT)wLength;j++)
        {
            i=i*10+szBuf[j]-TEXT('0');
        }
        return i;
    }
    else
        return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\nt4\common\uiutil\bubble.c ===
//============================================================================
// Copyright (c) 1996, Microsoft Corporation
//
// File:    bubble.c
//
// History:
//  Abolade Gbadegesin  Mar-1-1996  Created.
//
// This file contains code for the bubble-popup control.
//============================================================================

#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>

#include <debug.h>
#include <nouiutil.h>
#include <uiutil.h>

#include "bpopup.h"     // public declarations
#include "bubble.h"     // private declarations



//----------------------------------------------------------------------------
// Function:    BubblePopup_Init
//
// This function is called to initialize the control class.
// It registers the bubble-popup window class.
//----------------------------------------------------------------------------

BOOL
BubblePopup_Init(
    IN  HINSTANCE   hinstance
    ) {

    //
    // if the window class is registered already, return
    //

    WNDCLASS wc;

    if (GetClassInfo(hinstance, WC_BUBBLEPOPUP, &wc)) { return TRUE; }


    //
    // set up the window class for registration
    //

    wc.lpfnWndProc = BP_WndProc;
    wc.hCursor = LoadCursor(hinstance, IDC_ARROW);
    wc.hIcon = NULL;
    wc.lpszMenuName = NULL;
    wc.hInstance = hinstance;
    wc.lpszClassName = WC_BUBBLEPOPUP;
    wc.hbrBackground = (HBRUSH)(COLOR_INFOBK + 1);
    wc.style = CS_HREDRAW | CS_VREDRAW;
    wc.cbWndExtra = sizeof(BPOPUP *);
    wc.cbClsExtra = 0;

    return RegisterClass(&wc);
}



//----------------------------------------------------------------------------
// Function:    BP_WndProc
//
// This is the window procedure for all windows in the BubblePopup class.
//----------------------------------------------------------------------------

LRESULT
CALLBACK
BP_WndProc(
    IN  HWND    hwnd,
    IN  UINT    uiMsg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
    ) {

    BPOPUP *pbp;

    //
    // attempt to retrieve the private data pointer for the window
    // on WM_NCCREATE, this fails, so we allocate the data.
    //

    pbp = BP_GetPtr(hwnd);

    if (pbp == NULL) {

        if (uiMsg != WM_NCCREATE) {
            return DefWindowProc(hwnd, uiMsg, wParam, lParam);
        }


        //
        // allocate a block of memory
        //

        pbp = (BPOPUP *)Malloc(sizeof(BPOPUP));
        if (pbp == NULL) { return (LRESULT)FALSE; }


        //
        // save the pointer in the window's private bytes
        //

        pbp->hwnd = hwnd;
        BP_SetPtr(hwnd, pbp);

        return DefWindowProc(hwnd, uiMsg, wParam, lParam);
    }


    //
    // if the window is being destroyed, free the block allocated
    // and set the private bytes pointer to NULL
    //

    if (uiMsg == WM_NCDESTROY) {

        Free(pbp);

        BP_SetPtr(hwnd, NULL);

        return (LRESULT)0;
    }



    //
    // handle other messages
    //

    switch(uiMsg) {

        HANDLE_MSG(pbp, WM_CREATE, BP_OnCreate);
        HANDLE_MSG(pbp, WM_DESTROY, BP_OnDestroy);

        case WM_PAINT: {

            return BP_OnPaint(pbp);
        }

        case WM_WINDOWPOSCHANGED: {

            BP_ResizeClient(pbp);

            return 0;
        }

        case WM_LBUTTONDOWN:
        case WM_RBUTTONDOWN: {

            //
            // hide the window if it is showing
            //

            BP_OnDeactivate(pbp);

            return 0;
        }

        case WM_GETFONT: {

            return (LRESULT)pbp->hfont;
        }

        case WM_SETFONT: {

            BOOL bRet = BP_OnSetFont(pbp, (HFONT)wParam, (BOOL)LOWORD(lParam));

            BP_ResizeClient(pbp);

            if (pbp->dwFlags & BPFLAG_Activated) {

                InvalidateRect(pbp->hwnd, NULL, TRUE);
                UpdateWindow(pbp->hwnd);
            }

            return bRet;
        }

        case WM_SETTEXT: {

            //
            // change the text we're currently using,
            // and invalidate our client area
            //

            Free0(pbp->pszText);

            pbp->pszText = StrDup((PTSTR)lParam);

            BP_ResizeClient(pbp);

            if (pbp->dwFlags & BPFLAG_Activated) {

                InvalidateRect(pbp->hwnd, NULL, TRUE);
                UpdateWindow(pbp->hwnd);
            }

            return (pbp->pszText) ? TRUE : FALSE;
        }

        case WM_GETTEXT: {

            //
            // return the text we're currently using
            //

            PTSTR dst = (LPTSTR)lParam;
            PTSTR src = pbp->pszText;
            return lstrlen(lstrcpyn(dst, src ? src : TEXT(""), (DWORD)wParam));
        }

        case WM_TIMER: {

            BP_OnDeactivate(pbp);

            return 0;
        }

        case BPM_SETTIMEOUT: {

            pbp->uiTimeout = (UINT)lParam;

            if (pbp->dwFlags & BPFLAG_Activated) {

                KillTimer(pbp->hwnd, pbp->uiTimer);

                pbp->uiTimer = SetTimer(
                                    pbp->hwnd, BP_TimerId, pbp->uiTimeout, NULL
                                    );
            }

            return 0;
        }

        case BPM_ACTIVATE: {

            return BP_OnActivate(pbp);
        }

        case BPM_DEACTIVATE: {

            return BP_OnDeactivate(pbp);
        }
    }

    return DefWindowProc(hwnd, uiMsg, wParam, lParam);
}



//----------------------------------------------------------------------------
// Function:    BP_OnCreate
//
// This function handles the creation of private data for a bubble-popup.
//----------------------------------------------------------------------------

BOOL
BP_OnCreate(
    IN  BPOPUP *        pbp,
    IN  CREATESTRUCT *  pcs
    ) {


    //
    // initialize the structure members
    //

    pbp->iCtrlId = (UINT_PTR)pcs->hMenu;
    pbp->pszText = (pcs->lpszName ? StrDup((PTSTR)pcs->lpszName) : NULL);
    pbp->dwFlags = 0;
    pbp->uiTimer = 0;
    pbp->uiTimeout = 5000;


    //
    // we force the window to have the WS_POPUP style
    //

    SetWindowLong(pbp->hwnd, GWL_STYLE, WS_POPUP);


    //
    // set the WS_EX_TOOLWINDOW style to make sure
    // that this window doesn't show up in the tasklist
    //

    SetWindowLong(pbp->hwnd, GWL_EXSTYLE, pcs->dwExStyle | WS_EX_TOOLWINDOW);

    return BP_OnSetFont(pbp, NULL, FALSE);
}



//----------------------------------------------------------------------------
// Function:    BP_OnDestroy
//
// This function handles the deallocation of private data for a bubble-popup.
//----------------------------------------------------------------------------

VOID
BP_OnDestroy(
    IN  BPOPUP *    pbp
    ) {

    //
    // if the font was created by this window, delete it
    //

    if (pbp->dwFlags & BPFLAG_FontCreated) { DeleteObject(pbp->hfont); }

    pbp->dwFlags = 0;
    pbp->hfont = NULL;
}



//----------------------------------------------------------------------------
// Function:    BP_OnSetFont
//
// This function handles the changing of the font in use by a bubble-popup.
//----------------------------------------------------------------------------

BOOL
BP_OnSetFont(
    IN  BPOPUP *    pbp,
    IN  HFONT       hfont,
    IN  BOOL        bRedraw
    ) {

    if (pbp->dwFlags & BPFLAG_FontCreated) { DeleteObject(pbp->hfont); }

    pbp->dwFlags &= ~BPFLAG_FontCreated;
    pbp->hfont = NULL;

    if (!hfont) {

        //
        // (re)create the default font.
        //

        NONCLIENTMETRICS ncm;

        ncm.cbSize = sizeof(ncm);

        if (!SystemParametersInfo(
                SPI_GETNONCLIENTMETRICS, sizeof(ncm), &ncm, 0
                )) {

            TRACE1("error %d getting font info", GetLastError());
            return FALSE;
        }

        hfont = CreateFontIndirect(&ncm.lfStatusFont);

        if (!hfont) {

            TRACE("error creating bubble-popup font");
            return FALSE;
        }

        pbp->dwFlags |= BPFLAG_FontCreated;
    }

    pbp->hfont = hfont;

    if (bRedraw) { InvalidateRect(pbp->hwnd, NULL, TRUE); }

    return TRUE;
}



//----------------------------------------------------------------------------
// Function:    BP_OnGetRect
//
// This function recomputes the rectangle required to display
// a bubble-popup's current text.
//----------------------------------------------------------------------------

VOID
BP_OnGetRect(
    IN  BPOPUP *    pbp,
    IN  RECT *      prc
    ) {

    if (!pbp->pszText) { SetRectEmpty(prc); }
    else {
    
        HFONT hfontOld;
        HDC hdc = GetDC(pbp->hwnd);
    
        //
        // select the font into the DC and compute the new rectangle
        //
    
        hfontOld = SelectObject(hdc, pbp->hfont);
    
        DrawText(hdc, pbp->pszText, -1, prc, DT_CALCRECT | DT_EXPANDTABS);
    
        if (hfontOld) { SelectObject(hdc, hfontOld); }
    
        ReleaseDC(pbp->hwnd, hdc);
    
    
        //
        // make space in the rectangle for the border
        //
    
        InflateRect(
            prc, GetSystemMetrics(SM_CXEDGE), GetSystemMetrics(SM_CYEDGE)
            );
    }


    //
    // convert the rectangle to screen coordinates
    //

    MapWindowPoints(pbp->hwnd, NULL, (POINT *)prc, 2);
}


//----------------------------------------------------------------------------
// Function:    BP_ResizeClient
//
// When a change occurs (e.g. font-change, new text) this function is called
// to resize the bubble-popup's window so the text still fits.
//----------------------------------------------------------------------------

VOID
BP_ResizeClient(
    IN  BPOPUP *    pbp
    ) {

    RECT rc;


    //
    // find out what size the window needs to be to hold
    // the text it is currently set to display
    //

    BP_OnGetRect(pbp, &rc);


    //
    // resize the window so its client area is large enough
    // to hold DrawText's output
    //

    SetWindowPos(
        pbp->hwnd, HWND_TOPMOST, 0, 0, rc.right - rc.left,
        rc.bottom - rc.top, SWP_NOMOVE
        );
}



//----------------------------------------------------------------------------
// Function:    BP_OnPaint
//
// This function handles the painting of a bubble-popup window.
//----------------------------------------------------------------------------

DWORD
BP_OnPaint(
    IN  BPOPUP *    pbp
    ) {

    HDC hdc;
    HBRUSH hbr;
    HFONT hfontOld;
    PAINTSTRUCT ps;
    RECT rc, rcText;

    if (!pbp->hfont || !pbp->pszText) { return (DWORD)-1; }

    hdc = BeginPaint(pbp->hwnd, &ps);


    GetClientRect(pbp->hwnd, &rc);
    rcText = rc;
    InflateRect(
        &rcText, -GetSystemMetrics(SM_CXEDGE), -GetSystemMetrics(SM_CYEDGE)
        );

    hfontOld = SelectObject(hdc, pbp->hfont);

    SetTextColor(hdc, GetSysColor(COLOR_INFOTEXT));


    //
    // clear the window's background
    //

    hbr = CreateSolidBrush(GetSysColor(COLOR_INFOBK));
    FillRect(hdc, &rc, hbr);
    DeleteObject(hbr);


    //
    // draw our formatted text in the window
    //

    SetBkMode(hdc, TRANSPARENT);
    DrawText(hdc, pbp->pszText, -1, &rcText, DT_EXPANDTABS);


    //
    // draw a border around the window
    //

    DrawEdge(hdc, &rc, BDR_RAISEDOUTER, BF_RECT);

    if (hfontOld) { SelectObject(hdc, hfontOld); }

    EndPaint(pbp->hwnd, &ps);

    return 0;
}


BOOL
BP_OnActivate(
    IN  BPOPUP *    pbp
    ) {

    if (pbp->dwFlags & BPFLAG_Activated) {

        KillTimer(pbp->hwnd, pbp->uiTimer);
    }

    ShowWindow(pbp->hwnd, SW_SHOW);

    UpdateWindow(pbp->hwnd);

    pbp->uiTimer = SetTimer(pbp->hwnd, BP_TimerId, pbp->uiTimeout, NULL);

    pbp->dwFlags |= BPFLAG_Activated;

    return TRUE;
}


BOOL
BP_OnDeactivate(
    IN  BPOPUP *    pbp
    ) {

    if (pbp->uiTimer) { KillTimer(pbp->hwnd, pbp->uiTimer); pbp->uiTimer = 0; }

    ShowWindow(pbp->hwnd, SW_HIDE);

    pbp->dwFlags &= ~BPFLAG_Activated;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\nt4\common\uiutil\popupdlg.c ===
/* Copyright (c) 1995, Microsoft Corporation, all rights reserved
**
** popupdlg.c
** UI helper library
** Popup dialog routines
** Listed alphabetically
**
** 08/25/95 Steve Cobb
*/


#include <windows.h>  // Win32 root
#include <lmerr.h>    // LAN Manager errors
#include <lmcons.h>   // LAN Manager constants
#include <stdarg.h>   // To stop va_list argument warning only
#include <ras.h>      // RAS API definitions
#include <debug.h>    // Trace/assert library
#include <nouiutil.h> // No-HWND utilities
#include <uiutil.h>   // Our public header


/*----------------------------------------------------------------------------
** Error popup
**----------------------------------------------------------------------------
*/

int
ErrorDlgUtil(
    IN     HWND       hwndOwner,
    IN     DWORD      dwOperation,
    IN     DWORD      dwError,
    IN OUT ERRORARGS* pargs,
    IN     HINSTANCE  hInstance,
    IN     DWORD      dwTitle,
    IN     DWORD      dwFormat )

    /* Pops up a modal error dialog centered on 'hwndOwner'.  'DwOperation' is
    ** the string resource ID of the string describing the operation underway
    ** when the error occurred.  'DwError' is the code of the system or RAS
    ** error that occurred.  'Pargs' is a extended formatting arguments or
    ** NULL if none.  'hInstance' is the application/module handle where
    ** string resources are located.  'DwTitle' is the string ID of the dialog
    ** title.  'DwFormat' is the string ID of the error format title.
    **
    ** Returns MessageBox-style code.
    */
{
    TCHAR* pszUnformatted;
    TCHAR* pszOp;
    TCHAR  szErrorNum[ 50 ];
    TCHAR* pszError;
    TCHAR* pszResult;
    TCHAR* pszNotFound;
    int    nResult;

    TRACE("ErrorDlgUtil");

    /* A placeholder for missing strings components.
    */
    pszNotFound = TEXT("");

    /* Build the error number string.
    */
    if (dwError > 0x7FFFFFFF)
        wsprintf( szErrorNum, TEXT("0x%X"), dwError );
    else
        wsprintf( szErrorNum, TEXT("%u"), dwError );

    /* Build the error text string.
    */
    if (!GetErrorText( dwError, &pszError ))
        pszError = pszNotFound;

    /* Build the operation string.
    */
    pszUnformatted = PszFromId( hInstance, dwOperation );
    pszOp = pszNotFound;

    if (pszUnformatted)
    {
        FormatMessage(
            FORMAT_MESSAGE_FROM_STRING +
                FORMAT_MESSAGE_ALLOCATE_BUFFER +
                FORMAT_MESSAGE_ARGUMENT_ARRAY,
            pszUnformatted, 0, 0, (LPTSTR )&pszOp, 1,
            (va_list* )((pargs) ? pargs->apszOpArgs : NULL) );

        Free( pszUnformatted );
    }

    /* Call MsgDlgUtil with the standard arguments plus any auxillary format
    ** arguments.
    */
    pszUnformatted = PszFromId( hInstance, dwFormat );
    pszResult = pszNotFound;

    if (pszUnformatted)
    {
        MSGARGS msgargs;

        ZeroMemory( &msgargs, sizeof(msgargs) );
        msgargs.dwFlags = MB_ICONEXCLAMATION + MB_OK + MB_SETFOREGROUND;
        msgargs.pszString = pszUnformatted;
        msgargs.apszArgs[ 0 ] = pszOp;
        msgargs.apszArgs[ 1 ] = szErrorNum;
        msgargs.apszArgs[ 2 ] = pszError;

        if (pargs)
        {
            msgargs.fStringOutput = pargs->fStringOutput;

            CopyMemory( &msgargs.apszArgs[ 3 ], pargs->apszAuxFmtArgs,
                3 * sizeof(TCHAR) );
        }

        nResult =
            MsgDlgUtil(
                hwndOwner, 0, &msgargs, hInstance, dwTitle );

        Free( pszUnformatted );

        if (pargs && pargs->fStringOutput)
            pargs->pszOutput = msgargs.pszOutput;
    }

    if (pszOp != pszNotFound)
        LocalFree( pszOp );
    if (pszError != pszNotFound)
        LocalFree( pszError );

    return nResult;
}


BOOL
GetErrorText(
    DWORD   dwError,
    TCHAR** ppszError )

    /* Fill caller's '*ppszError' with the address of a LocalAlloc'ed heap
    ** block containing the error text associated with error 'dwError'.  It is
    ** caller's responsibility to LocalFree the returned string.
    **
    ** Returns true if successful, false otherwise.
    */
{
#define MAXRASERRORLEN 256

    TCHAR  szBuf[ MAXRASERRORLEN + 1 ];
    DWORD  dwFlags;
    HANDLE hmodule;
    DWORD  cch;

    /* Don't panic if the RAS API address is not loaded.  Caller may be trying
    ** and get an error up during LoadRas.
    */
    if ((Rasapi32DllLoaded() || RasRpcDllLoaded())
        && g_pRasGetErrorString
        && g_pRasGetErrorString(
               (UINT )dwError, (LPTSTR )szBuf, MAXRASERRORLEN ) == 0)
    {
        /* It's a RAS error.
        */
        *ppszError = LocalAlloc( LPTR, (lstrlen( szBuf ) + 1) * sizeof(TCHAR) );
        if (!*ppszError)
            return FALSE;

        lstrcpy( *ppszError, szBuf );
        return TRUE;
    }

    /* The rest adapted from BLT's LoadSystem routine.
    */
    dwFlags = FORMAT_MESSAGE_ALLOCATE_BUFFER + FORMAT_MESSAGE_IGNORE_INSERTS;

    if (dwError >= MIN_LANMAN_MESSAGE_ID && dwError <= MAX_LANMAN_MESSAGE_ID)
    {
        /* It's a net error.
        */
        dwFlags += FORMAT_MESSAGE_FROM_HMODULE;
        hmodule = GetModuleHandle( TEXT("NETMSG.DLL") );
    }
    else
    {
        /* It must be a system error.
        */
        dwFlags += FORMAT_MESSAGE_FROM_SYSTEM;
        hmodule = NULL;
    }

    cch = FormatMessage(
        dwFlags, hmodule, dwError, 0, (LPTSTR )ppszError, 1, NULL );
    return (cch > 0);
}


/*----------------------------------------------------------------------------
** Message popup
**----------------------------------------------------------------------------
*/

int
MsgDlgUtil(
    IN     HWND      hwndOwner,
    IN     DWORD     dwMsg,
    IN OUT MSGARGS*  pargs,
    IN     HINSTANCE hInstance,
    IN     DWORD     dwTitle )

    /* Pops up a message dialog centered on 'hwndOwner'.  'DwMsg' is the
    ** string resource ID of the message text.  'Pargs' is a extended
    ** formatting arguments or NULL if none.  'hInstance' is the
    ** application/module handle where string resources are located.
    ** 'DwTitle' is the string ID of the dialog title.
    **
    ** Returns MessageBox-style code.
    */
{
    TCHAR* pszUnformatted;
    TCHAR* pszResult;
    TCHAR* pszNotFound;
    int    nResult;

    TRACE("MsgDlgUtil");

    /* A placeholder for missing strings components.
    */
    pszNotFound = TEXT("");

    /* Build the message string.
    */
    pszResult = pszNotFound;

    if (pargs && pargs->pszString)
    {
        FormatMessage(
            FORMAT_MESSAGE_FROM_STRING +
                FORMAT_MESSAGE_ALLOCATE_BUFFER +
                FORMAT_MESSAGE_ARGUMENT_ARRAY,
            pargs->pszString, 0, 0, (LPTSTR )&pszResult, 1,
            (va_list* )pargs->apszArgs );
    }
    else
    {
        pszUnformatted = PszFromId( hInstance, dwMsg );

        if (pszUnformatted)
        {
            FormatMessage(
                FORMAT_MESSAGE_FROM_STRING +
                    FORMAT_MESSAGE_ALLOCATE_BUFFER +
                    FORMAT_MESSAGE_ARGUMENT_ARRAY,
                pszUnformatted, 0, 0, (LPTSTR )&pszResult, 1,
                (va_list* )((pargs) ? pargs->apszArgs : NULL) );

            Free( pszUnformatted );
        }
    }

    if (!pargs || !pargs->fStringOutput)
    {
        TCHAR* pszTitle;
        DWORD  dwFlags;
        HHOOK  hhook;

        if (pargs && pargs->dwFlags != 0)
            dwFlags = pargs->dwFlags;
        else
            dwFlags = MB_ICONINFORMATION + MB_OK + MB_SETFOREGROUND;

        pszTitle = PszFromId( hInstance, dwTitle );

        if (hwndOwner)
        {
            /* Install hook that will get the message box centered on the
            ** owner window.
            */
            hhook = SetWindowsHookEx( WH_CALLWNDPROC,
                CenterDlgOnOwnerCallWndProc,
                hInstance, GetCurrentThreadId() );
        }
        else
            hhook = NULL;

        nResult = MessageBox( hwndOwner, pszResult, pszTitle, dwFlags );

        if (hhook)
            UnhookWindowsHookEx( hhook );

        Free0( pszTitle );
        if (pszResult != pszNotFound)
            LocalFree( pszResult );
    }
    else
    {
        /* Caller wants the string without doing the popup.
        */
        pargs->pszOutput = (pszResult != pszNotFound) ? pszResult : NULL;
        nResult = IDOK;
    }

    return nResult;
}


LRESULT CALLBACK
CenterDlgOnOwnerCallWndProc(
    int    code,
    WPARAM wparam,
    LPARAM lparam )

    /* Standard Win32 CallWndProc hook callback that looks for the next dialog
    ** started and centers it on it's owner window.
    */
{
    /* Arrive here when any window procedure associated with our thread is
    ** called.
    */
    if (!wparam)
    {
        CWPSTRUCT* p = (CWPSTRUCT* )lparam;

        /* The message is from outside our process.  Look for the MessageBox
        ** dialog initialization message and take that opportunity to center
        ** the dialog on it's owner's window.
        */
        if (p->message == WM_INITDIALOG)
            CenterWindow( p->hwnd, GetParent( p->hwnd ) );
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\nt4\inc\bpopup.h ===
//============================================================================
// Copyright(c) 1996, Microsoft Corporation
//
// File:    bpopup.h
//
// History:
//  Abolade Gbadegesin      Mar-2-1996      Created.
//
// This file contains public declarations for the Bubble-Popup window class.
// A bubble-popup provides functionality similar to that of a tooltip, 
// in that it displays text for a brief period and then hides itself.
// This class differs in that it uses DrawText for its output, thus allowing
// multi-line text formatted using tabs. Further, the user is required
// to tell the bubble-popup when to show itself.
//
// To create a bubble-popup, call BubblePopup_Create().
// This returns an HWND (to be later destroyed using DestroyWindow()).
// The text of the bubble-popup can be set and retrieved using WM_SETTEXT
// and WM_GETTEXT (and hence the macros {Get,Set}WindowText().
//
// Set the period for which a popup is active by calling BubblePopup_SetTimeout
// and activate the popup by calling BubblePopup_Activate.
// While a popup is activated, changes to its text are reflected immediately.
// If BubblePopup_Activate is called while the popup is already active,
// the countdown (till the window is hidden) is started again.
//============================================================================


#ifndef _BPOPUP_H_
#define _BPOPUP_H_


// Window class name for bubble-popups

#define WC_BUBBLEPOPUP      TEXT("BubblePopup")


// Messages accepted by bubble-popups

#define BPM_FIRST           (WM_USER + 1)
#define BPM_ACTIVATE        (BPM_FIRST + 0)
#define BPM_DEACTIVATE      (BPM_FIRST + 1)
#define BPM_SETTIMEOUT      (BPM_FIRST + 2)

BOOL
BubblePopup_Init(
    IN  HINSTANCE   hinstance
    );

#define BubblePopup_Create(hinstance) \
        CreateWindow( \
            WC_BUBBLEPOPUP, NULL, 0, 0, 0, 0, 0, NULL, 0, (hinstance), NULL \
            )

#define BubblePopup_Activate(hwnd) \
        (VOID)SendMessage((HWND)hwnd, BPM_ACTIVATE, 0, 0)
#define BubblePopup_Deactivate(hwnd) \
        (VOID)SendMessage((HWND)hwnd, BPM_DEACTIVATE, 0, 0)
#define BubblePopup_SetTimeout(hwnd, uiTimeout) \
        (VOID)SendMessage((HWND)hwnd, BPM_SETTIMEOUT, 0,(LPARAM)(UINT)uiTimeout)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\nt4\inc\intl.h ===
/* Copyright (c) 1995, Microsoft Corporation, all rights reserved
**
** intl.h
** Remote Access international helpers
** Public header
*/

#ifndef _INTL_H_
#define _INTL_H_

/*----------------------------------------------------------------------------
** Constants
**----------------------------------------------------------------------------
*/

/* Flags to GetDurationString.
*/
#define GDSFLAG_Mseconds 0x00000001
#define GDSFLAG_Seconds  0x00000002
#define GDSFLAG_Minutes  0x00000004
#define GDSFLAG_Hours    0x00000008
#define GDSFLAG_Days     0x00000010
#define GDSFLAG_All      0x0000001F


/*----------------------------------------------------------------------------
** Prototypes
**----------------------------------------------------------------------------
*/

DWORD
GetDurationString(
    IN DWORD dwMilliseconds,
    IN DWORD dwFormatFlags,
    IN OUT PTSTR pszBuffer,
    IN OUT DWORD *pdwBufSize );

DWORD
GetNumberString(
    IN DWORD dwNumber,
    IN OUT PTSTR pszBuffer,
    IN OUT PDWORD pdwBufSize );

PTSTR
padultoa(
    UINT  val,
    PTSTR pszBuf,
    INT   width );


#endif // _INTL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\nt4\inc\list.h ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File:    list.h
//============================================================================


#ifndef InitializeListHead


//
//  Doubly-linked list manipulation routines.  Implemented as macros
//  but logically these are procedures.
//

//
//  VOID
//  InitializeListHead(
//      PLIST_ENTRY ListHead
//      );
//

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

//
//  BOOLEAN
//  IsListEmpty(
//      PLIST_ENTRY ListHead
//      );
//

#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))

//
//  PLIST_ENTRY
//  RemoveHeadList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveHeadList(ListHead) \
    (ListHead)->Flink;\
    {RemoveEntryList((ListHead)->Flink)}

//
//  PLIST_ENTRY
//  RemoveTailList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveTailList(ListHead) \
    (ListHead)->Blink;\
    {RemoveEntryList((ListHead)->Blink)}

//
//  VOID
//  RemoveEntryList(
//      PLIST_ENTRY Entry
//      );
//

#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }

//
//  VOID
//  InsertTailList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }

//
//  VOID
//  InsertHeadList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
    }

//
//
//  PSINGLE_LIST_ENTRY
//  PopEntryList(
//      PSINGLE_LIST_ENTRY ListHead
//      );
//

#define PopEntryList(ListHead) \
    (ListHead)->Next;\
    {\
        PSINGLE_LIST_ENTRY FirstEntry;\
        FirstEntry = (ListHead)->Next;\
        if (FirstEntry != NULL) {     \
            (ListHead)->Next = FirstEntry->Next;\
        }                             \
    }


//
//  VOID
//  PushEntryList(
//      PSINGLE_LIST_ENTRY ListHead,
//      PSINGLE_LIST_ENTRY Entry
//      );
//

#define PushEntryList(ListHead,Entry) \
    (Entry)->Next = (ListHead)->Next; \
    (ListHead)->Next = (Entry)


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\nt4\common\uiutil\rmmem.c ===
//============================================================================
// Copyright (c) 1996, Microsoft Corporation
//
// File:    rmmem.c
//
// History:
//  Abolade Gbadegesin  Mar-15-1996 Created.
//
// Contains functions used for RASUI shared memory manipulation.
//============================================================================

#include <windows.h>    // Win32 root
#include <rmmem.h>      // shared-memory declarations



HANDLE
ActivatePreviousInstance(
    IN HWND  hwnd,
    IN PTSTR pszName )

    /* Attempts to create a shared-memory block named 'PszName'.
    ** If the block already exists, it's assumed that it contains
    ** an RMMEM structure, and the window in the structure is brought to
    ** the foreground and the shared-memory block is closed.
    ** Otherwise, the given 'Hwnd' is written into the block.
    **
    ** When the window is being closed, the caller should close the returned
    ** handle by calling CloseHandle().
    */
{

    RMMEM *prm;
    DWORD dwErr;
    HANDLE hMap, hMutex;

    /* Create a mutex to be acquired while examining the shared memory;
    */

    hMutex = CreateMutex(NULL, FALSE, INSTANCEMUTEXNAME);
    if (!hMutex) { return NULL; }

    WaitForSingleObject(hMutex, INFINITE);


    do {

        /* create or open the shared memory block
        */
        hMap = CreateFileMapping(
                    (HANDLE)INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE,
                    0, sizeof(RMMEM), pszName
                    );
        if (hMap == NULL) { break; }

        /* save the result of the Create
        */
        dwErr = GetLastError();


        /* map the block as a pointer to an HWND
        */
        prm = (RMMEM *)MapViewOfFile(
                    hMap, FILE_MAP_ALL_ACCESS, 0, 0, sizeof(RMMEM)
                    );
        if (!prm) { CloseHandle(hMap); hMap = NULL; break; }


        /* if the block didn't exist, write our HWND to it.
        ** otherwise, if it contains an HWND bring that to the foreground
        ** and close the block of shared memory
        */
        if (dwErr != ERROR_ALREADY_EXISTS) {

            prm->hwnd = hwnd;
            prm->pid = GetCurrentProcessId();

            UnmapViewOfFile(prm);
        }
        else {

            if (IsWindow(prm->hwnd)) { SetForegroundWindow(prm->hwnd); }

            UnmapViewOfFile(prm);
            CloseHandle(hMap); hMap = NULL;
        }


    } while(FALSE);

    ReleaseMutex(hMutex);

    CloseHandle(hMutex);

    return hMap;
}


HWND
GetInstanceHwnd(
    IN HANDLE   hMap )

    /* Returns the window-handle stored in hMap.
    */
{

    HWND hwnd;
    RMMEM *prm;
    DWORD dwErr;
    HANDLE hMutex;

    if (!hMap) { return NULL; }


    /* Create a mutex to be acquired while examining the shared memory;
    */

    hMutex = CreateMutex(NULL, FALSE, INSTANCEMUTEXNAME);
    if (!hMutex) { return NULL; }

    WaitForSingleObject(hMutex, INFINITE);

    hwnd = NULL;

    do {

        /* map the block as a pointer to an RMMEM
        */
        prm = (RMMEM *)MapViewOfFile(
                    hMap, FILE_MAP_ALL_ACCESS, 0, 0, sizeof(RMMEM)
                    );
        if (!prm) { break; }


        hwnd = prm->hwnd;

        UnmapViewOfFile(prm);

    } while(FALSE);

    ReleaseMutex(hMutex);

    CloseHandle(hMutex);

    return hwnd;
}


HANDLE
GetInstanceMap(
    IN PTSTR    pszName )

    /* Returns the handle of the shared-memory block named 'PszName',
    ** or NULL if an error occurs.
    **
    ** The handle returned should be closed using CloseHandle.
    */
{
    /* create or open the shared memory block
    */
    return CreateFileMapping(
                (HANDLE)INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE, 0, sizeof(RMMEM),
                pszName
                );
}


DWORD
GetInstancePid(
    IN HANDLE   hMap )

    /* Returns the process-ID stored in hMap.
    */
{

    RMMEM *prm;
    HANDLE hMutex;
    DWORD dwErr, dwPid;

    if (!hMap) { return 0; }


    /* Create a mutex to be acquired while examining the shared memory;
    */

    hMutex = CreateMutex(NULL, FALSE, INSTANCEMUTEXNAME);
    if (!hMutex) { return 0; }

    WaitForSingleObject(hMutex, INFINITE);

    dwPid = 0;

    do {

        /* map the block as a pointer to an RMMEM
        */
        prm = (RMMEM *)MapViewOfFile(
                    hMap, FILE_MAP_ALL_ACCESS, 0, 0, sizeof(RMMEM)
                    );
        if (!prm) { break; }


        dwPid = prm->pid;

        UnmapViewOfFile(prm);

    } while(FALSE);

    ReleaseMutex(hMutex);

    CloseHandle(hMutex);

    return dwPid;
}


DWORD
SetInstanceHwnd(
    HANDLE hMap,
    HWND   hwnd )

    /* Takes a handle 'HMap' returned by ActivatePreviousInstance()
    ** or by GetInstanceMap(), and an HWND, and writes the supplied HWND
    ** into the shared memory block 'HMap'.
    */
{

    RMMEM *prm;
    DWORD dwErr;
    HANDLE hMutex;

    /* Create a mutex to be acquired while examining the shared memory
    */

    hMutex = CreateMutex(NULL, FALSE, INSTANCEMUTEXNAME);
    if (!hMutex) { return GetLastError(); }

    WaitForSingleObject(hMutex, INFINITE);


    do {

        /* map the block as a pointer to an RMMEM
        */
        prm = (RMMEM *)MapViewOfFile(
                    hMap, FILE_MAP_ALL_ACCESS, 0, 0, sizeof(RMMEM)
                    );
        if (!prm) { dwErr = GetLastError(); break; }


        /* save the new instance RMMEM
        */
        prm->hwnd = hwnd;
        prm->pid = GetCurrentProcessId();

        UnmapViewOfFile(prm);

        dwErr = NO_ERROR;

    } while(FALSE);

    ReleaseMutex(hMutex);

    CloseHandle(hMutex);

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\nt4\common\uiutil\ui.c ===
/* Copyright (c) 1995, Microsoft Corporation, all rights reserved
**
** ui.c
** UI helper routines
** Listed alphabetically
**
** 08/25/95 Steve Cobb
*/


#include <windows.h>  // Win32 root
#include <windowsx.h> // Win32 macro extensions
#include <commctrl.h> // Win32 common controls
#include <debug.h>    // Trace and assert
#include <uiutil.h>   // Our public header


/*----------------------------------------------------------------------------
** Globals
**----------------------------------------------------------------------------
*/

/* See SetOffDesktop.
*/
static LPCWSTR g_SodContextId = NULL;

/* Set when running in a mode where WinHelp does not work.  This is a
** workaround to the problem where WinHelp does not work correctly before a
** user is logged on.  See AddContextHelpButton.
*/
BOOL g_fNoWinHelp = FALSE;


/*----------------------------------------------------------------------------
** Local datatypes
**----------------------------------------------------------------------------
*/

/* SetOffDesktop context.
*/
#define SODINFO struct tagSODINFO
SODINFO
{
    RECT  rectOrg;
    BOOL  fWeMadeInvisible;
};

/*----------------------------------------------------------------------------
** Local prototypes
**----------------------------------------------------------------------------
*/

BOOL CALLBACK
CloseOwnedWindowsEnumProc(
    IN HWND   hwnd,
    IN LPARAM lparam );


/*----------------------------------------------------------------------------
** Utility routines
**----------------------------------------------------------------------------
*/

VOID
AddContextHelpButton(
    IN HWND hwnd )

    /* Turns on title bar context help button in 'hwnd'.
    **
    ** Dlgedit.exe doesn't currently support adding this style at dialog
    ** resource edit time.  When that's fixed set DS_CONTEXTHELP in the dialog
    ** definition and remove this routine.
    */
{
    LONG lStyle;

    if (g_fNoWinHelp)
        return;

    lStyle = GetWindowLong( hwnd, GWL_EXSTYLE );

    if (lStyle)
        SetWindowLong( hwnd, GWL_EXSTYLE, lStyle | WS_EX_CONTEXTHELP );
}


VOID
Button_MakeDefault(
    IN HWND hwndDlg,
    IN HWND hwndPb )

    /* Make 'hwndPb' the default button on dialog 'hwndDlg'.
    */
{
    INT_PTR dwResult;
    HWND  hwndPbOldDefault;

    dwResult = SendMessage( hwndDlg, DM_GETDEFID, 0, 0 );
    if (HIWORD( dwResult ) == DC_HASDEFID)
    {
        /* Un-default the current default button.
        */
        hwndPbOldDefault = GetDlgItem( hwndDlg, LOWORD( dwResult ) );
        Button_SetStyle( hwndPbOldDefault, BS_PUSHBUTTON, TRUE );
    }

    /* Set caller's button to the default.
    */
    SendMessage( hwndDlg, DM_SETDEFID, GetDlgCtrlID( hwndPb ), 0 );
    Button_SetStyle( hwndPb, BS_DEFPUSHBUTTON, TRUE );
}


HBITMAP
Button_CreateBitmap(
    IN HWND        hwndPb,
    IN BITMAPSTYLE bitmapstyle )

    /* Creates a bitmap of 'bitmapstyle' suitable for display on 'hwndPb.  The
    ** 'hwndPb' must have been created with BS_BITMAP style.
    **
    ** 'HwndPb' may be a checkbox with BS_PUSHLIKE style, in which case the
    ** button locks down when pressed like a toolbar button.  This case
    ** requires that a color bitmap be created resulting in two extra
    ** restrictions.  First, caller must handle WM_SYSCOLORCHANGE and rebuild
    ** the bitmaps with the new colors and second, the button cannot be
    ** disabled.
    **
    ** Returns the handle to the bitmap.  Caller can display it on the button
    ** as follows:
    **
    **     SendMessage( hwndPb, BM_SETIMAGE, 0, (LPARAM )hbitmap );
    **
    ** Caller is responsible for calling DeleteObject(hbitmap) when done using
    ** the bitmap, typically when the dialog is destroyed.
    **
    ** (Adapted from a routine by Tony Romano)
    */
{
    RECT    rect;
    HDC     hdc;
    HDC     hdcMem;
    HBITMAP hbitmap;
    HFONT   hfont;
    HPEN    hpen;
    SIZE    sizeText;
    SIZE    sizeBitmap;
    INT     x;
    INT     y;
    TCHAR*  psz;
    TCHAR*  pszText;
    TCHAR*  pszText2;
    DWORD   dxBitmap;
    DWORD   dxBetween;
    BOOL    fOnRight;
    BOOL    fPushLike;

    hdc = NULL;
    hdcMem = NULL;
    hbitmap = NULL;
    hpen = NULL;
    pszText = NULL;
    pszText2 = NULL;

    switch (bitmapstyle)
    {
        case BMS_UpArrowOnLeft:
        case BMS_DownArrowOnLeft:
        case BMS_UpArrowOnRight:
        case BMS_DownArrowOnRight:
            dxBitmap = 5;
            dxBetween = 4;
            break;

        case BMS_UpTriangleOnLeft:
        case BMS_DownTriangleOnLeft:
        case BMS_UpTriangleOnRight:
        case BMS_DownTriangleOnRight:
            dxBitmap = 7;
            dxBetween = 6;
            break;

        default:
            return NULL;
    }

    fOnRight = (bitmapstyle & BMS_OnRight);
    fPushLike = (GetWindowLong( hwndPb, GWL_STYLE ) & BS_PUSHLIKE);

    /* Get a memory DC compatible with the button window.
    */
    hdc = GetDC( hwndPb );
    if (!hdc)
        return NULL;
    hdcMem = CreateCompatibleDC( hdc );
    if (!hdcMem)
        goto BCB_Error;

    /* Create a compatible bitmap covering the entire button in the memory DC.
    **
    ** For a push button, the bitmap is created compatible with the memory DC,
    ** NOT the display DC.  This causes the bitmap to be monochrome, the
    ** default for memory DCs.  When GDI maps monochrome bitmaps into color,
    ** white is replaced with the background color and black is replaced with
    ** the text color, which is exactly what we want.  With this technique, we
    ** are relieved from explicit handling of changes in system colors.
    **
    ** For a push-like checkbox the bitmap is created compatible with the
    ** button itself, so the bitmap is typically color.
    */
    GetClientRect( hwndPb, &rect );
    hbitmap = CreateCompatibleBitmap(
        (fPushLike) ? hdc : hdcMem, rect.right, rect.bottom );
    if (!hbitmap)
        goto BCB_Error;
    ReleaseDC( hwndPb, hdc );
    hdc = NULL;
    SelectObject( hdcMem, hbitmap );

    /* Select the font the button says it's using.
    */
    hfont = (HFONT )SendMessage( hwndPb, WM_GETFONT, 0, 0 );
    if (hfont)
        SelectObject( hdcMem, hfont );

    /* Set appropriate colors for regular and stuck-down states.  Don't need
    ** to do anything for the monochrome case as the default black pen and
    ** white background are what we want.
    */
    if (fPushLike)
    {
        INT nColor;

        if (bitmapstyle == BMS_UpArrowOnLeft
           || bitmapstyle == BMS_UpArrowOnRight
           || bitmapstyle == BMS_UpTriangleOnLeft
           || bitmapstyle == BMS_UpTriangleOnRight)
        {
            nColor = COLOR_BTNHILIGHT;
        }
        else
        {
            nColor = COLOR_BTNFACE;
        }

        SetBkColor( hdcMem, GetSysColor( nColor ) );
        hpen = CreatePen( PS_SOLID, 0, GetSysColor( COLOR_BTNTEXT ) );
        if (hpen)
            SelectObject( hdcMem, hpen );
    }

    /* The created bitmap is random, so we erase it to the background color.
    ** No text is written here.
    */
    ExtTextOut( hdcMem, 0, 0, ETO_OPAQUE, &rect, NULL, 0, NULL );

    /* Get the button label and make a copy with the '&' accelerator-escape
    ** removed, which would otherwise mess up our width calculations.
    */
    pszText = GetText( hwndPb );
    pszText2 = StrDup( pszText );
    if (!pszText || !pszText2)
        goto BCB_Error;

    for (psz = pszText2; *psz; psz = CharNext( psz ) )
    {
        if (*psz == TEXT('&'))
        {
            lstrcpy( psz, psz + 1 );
            break;
        }
    }

    /* Calculate the width of the button label text.
    */
    sizeText.cx = 0;
    sizeText.cy = 0;
    GetTextExtentPoint32( hdcMem, pszText2, lstrlen( pszText2 ), &sizeText );

    /* Draw the text off-center horizontally enough so it is centered with the
    ** bitmap symbol added.
    */
    --rect.bottom;
    sizeBitmap.cx = dxBitmap;
    sizeBitmap.cy = 0;

    rect.left +=
        ((rect.right - (sizeText.cx + sizeBitmap.cx) - dxBetween) / 2);

    if (fOnRight)
    {
        DrawText( hdcMem, pszText, -1, &rect,
            DT_VCENTER + DT_SINGLELINE + DT_EXTERNALLEADING );
        rect.left += sizeText.cx + dxBetween;
    }
    else
    {
        rect.left += dxBitmap + dxBetween;
        DrawText( hdcMem, pszText, -1, &rect,
            DT_VCENTER + DT_SINGLELINE + DT_EXTERNALLEADING );
        rect.left -= dxBitmap + dxBetween;
    }

    /* Eliminate the top and bottom 3 pixels of button from consideration for
    ** the bitmap symbol.  This leaves the button control room to do the
    ** border and 3D edges.
    */
    InflateRect( &rect, 0, -3 );

    /* Draw the bitmap symbol.  The rectangle is now 'dxBitmap' wide and
    ** centered vertically with variable height depending on the button size.
    */
    switch (bitmapstyle)
    {
        case BMS_UpArrowOnLeft:
        case BMS_UpArrowOnRight:
        {
            /* v-left
            ** ..... <-top
            ** .....
            ** .....
            ** ..*.. \
            ** .***.  |
            ** *****  |
            ** ..*..  |
            ** ..*..  |
            ** ..*..   > varies depending on font height
            ** ..*..  |
            ** ..*..  |
            ** ..*..  |
            ** ..*..  |
            ** ..*.. /
            ** .....
            ** .....
            ** .....
            ** ..... <-bottom
            */

            /* Draw the vertical line.
            */
            x = rect.left + 2;
            y = rect.top + 3;
            MoveToEx( hdcMem, x, y, NULL );
            LineTo( hdcMem, x, rect.bottom - 3 );

            /* Draw the 2 crossbars.
            */
            MoveToEx( hdcMem, x - 1, ++y, NULL );
            LineTo( hdcMem, x + 2, y );
            MoveToEx( hdcMem, x - 2, ++y, NULL );
            LineTo( hdcMem, x + 3, y );
            break;
        }

        case BMS_DownArrowOnLeft:
        case BMS_DownArrowOnRight:
        {
            /* v-left
            ** ..... <-top
            ** .....
            ** .....
            ** ..*.. \
            ** ..*..  |
            ** ..*..  |
            ** ..*..  |
            ** ..*..  |
            ** ..*..   > varies depending on font height
            ** ..*..  |
            ** ..*..  |
            ** *****  |
            ** .***.  |
            ** ..*.. /
            ** .....
            ** .....
            ** .....
            ** ..... <-bottom
            */

            /* Draw the vertical line.
            */
            x = rect.left + 2;
            y = rect.top + 3;
            MoveToEx( hdcMem, x, y, NULL );
            LineTo( hdcMem, x, rect.bottom - 3 );

            /* Draw the 2 crossbars.
            */
            y = rect.bottom - 6;
            MoveToEx( hdcMem, x - 2, y, NULL );
            LineTo( hdcMem, x + 3, y );
            MoveToEx( hdcMem, x - 1, ++y, NULL );
            LineTo( hdcMem, x + 2, y );
            break;
        }

        case BMS_UpTriangleOnLeft:
        case BMS_UpTriangleOnRight:
        {
            /* v-left
            ** ....... <-top
            ** .......
            ** .......
            ** .......
            ** .......
            ** .......
            ** .......
            ** ...o... <- o indicates x,y origin
            ** ..***..
            ** .*****.
            ** *******
            ** .......
            ** .......
            ** .......
            ** .......
            ** .......
            ** .......
            ** ....... <-bottom
            */
            x = rect.left + 3;
            y = ((rect.bottom - rect.top) / 2) + 2;
            MoveToEx( hdcMem, x, y, NULL );
            LineTo( hdcMem, x + 1, y );
            ++y;
            MoveToEx( hdcMem, x - 1, y, NULL );
            LineTo( hdcMem, x + 2, y );
            ++y;
            MoveToEx( hdcMem, x - 2, y, NULL );
            LineTo( hdcMem, x + 3, y );
            ++y;
            MoveToEx( hdcMem, x - 3, y, NULL );
            LineTo( hdcMem, x + 4, y );
            break;
        }

        case BMS_DownTriangleOnLeft:
        case BMS_DownTriangleOnRight:
        {
            /* v-left
            ** ....... <-top
            ** .......
            ** .......
            ** .......
            ** .......
            ** .......
            ** .......
            ** ***o*** <- o indicates x,y origin
            ** .*****.
            ** ..***..
            ** ...*...
            ** .......
            ** .......
            ** .......
            ** .......
            ** .......
            ** .......
            ** ....... <-bottom
            */
            x = rect.left + 3;
            y = ((rect.bottom - rect.top) / 2) + 2;
            MoveToEx( hdcMem, x - 3, y, NULL );
            LineTo( hdcMem, x + 4, y );
            ++y;
            MoveToEx( hdcMem, x - 2, y, NULL );
            LineTo( hdcMem, x + 3, y );
            ++y;
            MoveToEx( hdcMem, x - 1, y, NULL );
            LineTo( hdcMem, x + 2, y );
            ++y;
            MoveToEx( hdcMem, x, y, NULL );
            LineTo( hdcMem, x + 1, y );
            break;
        }
    }

BCB_Error:

    Free0( pszText );
    Free0( pszText2 );
    if (hdc)
        ReleaseDC( hwndPb, hdc );
    if (hdcMem)
        DeleteDC( hdcMem );
    if (hpen)
        DeleteObject( hpen );
    return hbitmap;
}


VOID
CenterWindow(
    IN HWND hwnd,
    IN HWND hwndRef )

    /* Center window 'hwnd' on window 'hwndRef' or if 'hwndRef' is NULL on
    ** screen.  The window position is adjusted so that no parts are clipped
    ** by the edge of the screen, if necessary.  If 'hwndRef' has been moved
    ** off-screen with SetOffDesktop, the original position is used.
    */
{
    RECT rectCur;
    LONG dxCur;
    LONG dyCur;
    RECT rectRef;
    LONG dxRef;
    LONG dyRef;

    GetWindowRect( hwnd, &rectCur );
    dxCur = rectCur.right - rectCur.left;
    dyCur = rectCur.bottom - rectCur.top;

    if (hwndRef)
    {
        if (!SetOffDesktop( hwndRef, SOD_GetOrgRect, &rectRef ))
            GetWindowRect( hwndRef, &rectRef );
    }
    else
    {
        rectRef.top = rectRef.left = 0;
        rectRef.right = GetSystemMetrics( SM_CXSCREEN );
        rectRef.bottom = GetSystemMetrics( SM_CYSCREEN );
    }

    dxRef = rectRef.right - rectRef.left;
    dyRef = rectRef.bottom - rectRef.top;

    rectCur.left = rectRef.left + ((dxRef - dxCur) / 2);
    rectCur.top = rectRef.top + ((dyRef - dyCur) / 2);

    SetWindowPos(
        hwnd, NULL,
        rectCur.left, rectCur.top, 0, 0,
        SWP_NOZORDER + SWP_NOSIZE );

    UnclipWindow( hwnd );
}


VOID
CloseOwnedWindows(
    IN HWND hwnd )

    /* Sends WM_CLOSE to all windows that are owned by 'hwnd' in the current
    ** thread.
    */
{
    EnumThreadWindows( GetCurrentThreadId(),
        CloseOwnedWindowsEnumProc, (LPARAM )hwnd );
}


BOOL CALLBACK
CloseOwnedWindowsEnumProc(
    IN HWND   hwnd,
    IN LPARAM lparam )

    /* Standard Win32 EnumThreadWindowsWndProc used by CloseOwnedWindows.
    */
{
    HWND hwndThis;

    for (hwndThis = GetParent( hwnd );
         hwndThis;
         hwndThis = GetParent( hwndThis ))
    {
        if (hwndThis == (HWND )lparam)
        {
            SendMessage( hwnd, WM_CLOSE, 0, 0 );
            break;
        }
    }

    return TRUE;
}


INT
ComboBox_AddItem(
    IN HWND   hwndLb,
    IN TCHAR* pszText,
    IN VOID*  pItem )

    /* Adds data item 'pItem' with displayed text 'pszText' to listbox
    ** 'hwndLb'.  The item is added sorted if the listbox has LBS_SORT style,
    ** or to the end of the list otherwise.  If the listbox has LB_HASSTRINGS
    ** style, 'pItem' is a null terminated string, otherwise it is any user
    ** defined data.
    **
    ** Returns the index of the item in the list or negative if error.
    */
{
    INT nIndex;

    nIndex = ComboBox_AddString( hwndLb, pszText );
    if (nIndex >= 0)
        ComboBox_SetItemData( hwndLb, nIndex, pItem );
    return nIndex;
}


INT
ComboBox_AddItemFromId(
    IN HINSTANCE hinstance,
    IN HWND      hwndLb,
    IN DWORD     dwStringId,
    IN VOID*     pItem )

    /* Adds data item 'pItem' to listbox 'hwndLb'.  'dwStringId' is the string
    ** ID of the item's displayed text.  'Hinstance' is the app or module
    ** instance handle.
    **
    ** Returns the index of the item in the list or negative if error.
    */
{
    INT    i;
    TCHAR* psz;

    psz = PszFromId( hinstance, dwStringId );

    if (psz)
    {
        i = ComboBox_AddItem( hwndLb, psz, pItem );
        Free( psz );
    }
    else
    {
        i = LB_ERRSPACE;
    }

    return i;
}


INT
ComboBox_AddItemSorted(
    IN HWND   hwndLb,
    IN TCHAR* pszText,
    IN VOID*  pItem )

    /* Adds data item 'pItem' with displayed text 'pszText' to listbox
    ** 'hwndLb' in order sorted by 'pszText'.  It is assumed all items added
    ** to the list to this point are sorted.  If the listbox has LB_HASSTRINGS
    ** style, 'pItem' is a null terminated string, otherwise it is any user
    ** defined data.
    **
    ** Returns the index of the item in the list or negative if error.
    */
{
    INT nIndex;
    INT i;
    INT c;

    c = ComboBox_GetCount( hwndLb );
    for (i = 0; i < c; ++i)
    {
        TCHAR* psz;

        psz = ComboBox_GetPsz( hwndLb, i );
        if (psz)
        {
            if (lstrcmp( pszText, psz ) < 0)
                break;
            Free( psz );
        }
    }

    if (i >= c)
        i = -1;

    nIndex = ComboBox_InsertString( hwndLb, i, pszText );
    if (nIndex >= 0)
        ComboBox_SetItemData( hwndLb, nIndex, pItem );

    return nIndex;
}


VOID
ComboBox_AutoSizeDroppedWidth(
    IN HWND hwndLb )

    /* Set the width of the drop-down list 'hwndLb' to the width of the
    ** longest item (or the width of the list box if that's wider).
    */
{
    HDC    hdc;
    HFONT  hfont;
    TCHAR* psz;
    SIZE   size;
    DWORD  cch;
    DWORD  dxNew;
    DWORD  i;

    hfont = (HFONT )SendMessage( hwndLb, WM_GETFONT, 0, 0 );
    if (!hfont)
        return;

    hdc = GetDC( hwndLb );
    if (!hdc)
        return;

    SelectObject( hdc, hfont );

    dxNew = 0;
    for (i = 0; psz = ComboBox_GetPsz( hwndLb, i ); ++i)
    {
        cch = lstrlen( psz );
        if (GetTextExtentPoint32( hdc, psz, cch, &size ))
        {
            if (dxNew < (DWORD )size.cx)
                dxNew = (DWORD )size.cx;
        }

        Free( psz );
    }

    ReleaseDC( hwndLb, hdc );

    /* Allow for the spacing on left and right added by the control.
    */
    dxNew += 6;

    /* Figure out if the vertical scrollbar will be displayed and, if so,
    ** allow for it's width.
    */
    {
        RECT  rectD;
        RECT  rectU;
        DWORD dyItem;
        DWORD cItemsInDrop;
        DWORD cItemsInList;

        GetWindowRect( hwndLb, &rectU );
        SendMessage( hwndLb, CB_GETDROPPEDCONTROLRECT, 0, (LPARAM )&rectD );
        dyItem = (DWORD) SendMessage( hwndLb, CB_GETITEMHEIGHT, 0, 0 );
        cItemsInDrop = (rectD.bottom - rectU.bottom) / dyItem;
        cItemsInList = ComboBox_GetCount( hwndLb );
        if (cItemsInDrop < cItemsInList)
            dxNew += GetSystemMetrics( SM_CXVSCROLL );
    }

    SendMessage( hwndLb, CB_SETDROPPEDWIDTH, dxNew, 0 );
}


#if 0
VOID
ComboBox_FillFromPszList(
    IN HWND     hwndLb,
    IN DTLLIST* pdtllistPsz )

    /* Loads 'hwndLb' with an item form each node in the list strings,
    ** 'pdtllistPsz'.
    */
{
    DTLNODE* pNode;

    if (!pdtllistPsz)
        return;

    for (pNode = DtlGetFirstNode( pdtllistPsz );
         pNode;
         pNode = DtlGetNextNode( pNode ))
    {
        TCHAR* psz;

        psz = (TCHAR* )DtlGetData( pNode );
        ASSERT(psz);
        ComboBox_AddString( hwndLb, psz );
    }
}
#endif


VOID*
ComboBox_GetItemDataPtr(
    IN HWND hwndLb,
    IN INT  nIndex )

    /* Returns the address of the 'nIndex'th item context in 'hwndLb' or NULL
    ** if none.
    */
{
    LONG_PTR lResult;

    if (nIndex < 0)
        return NULL;

    lResult = ComboBox_GetItemData( hwndLb, nIndex );
    if (lResult < 0)
        return NULL;

    return (VOID* )lResult;
}


TCHAR*
ComboBox_GetPsz(
    IN HWND hwnd,
    IN INT  nIndex )

    /* Returns heap block containing the text contents of the 'nIndex'th item
    ** of combo box 'hwnd' or NULL.  It is caller's responsibility to Free the
    ** returned string.
    */
{
    INT    cch;
    TCHAR* psz;

    cch = ComboBox_GetLBTextLen( hwnd, nIndex );
    if (cch < 0)
        return NULL;

    psz = Malloc( (cch + 1) * sizeof(TCHAR) );

    if (psz)
    {
        *psz = TEXT('\0');
        ComboBox_GetLBText( hwnd, nIndex, psz );
    }

    return psz;
}


VOID
ComboBox_SetCurSelNotify(
    IN HWND hwndLb,
    IN INT  nIndex )

    /* Set selection in listbox 'hwndLb' to 'nIndex' and notify parent as if
    ** user had clicked the item which Windows doesn't do for some reason.
    */
{
    ComboBox_SetCurSel( hwndLb, nIndex );

    SendMessage(
        GetParent( hwndLb ),
        WM_COMMAND,
        (WPARAM )MAKELONG(
            (WORD )GetDlgCtrlID( hwndLb ), (WORD )CBN_SELCHANGE ),
        (LPARAM )hwndLb );
}


TCHAR*
Ellipsisize(
    IN HDC    hdc,
    IN TCHAR* psz,
    IN INT    dxColumn,
    IN INT    dxColText OPTIONAL )

    /* Returns a heap string containing the 'psz' shortened to fit in the
    ** given width, if necessary, by truncating and adding "...". 'Hdc' is the
    ** device context with the appropiate font selected.  'DxColumn' is the
    ** width of the column.  It is caller's responsibility to Free the
    ** returned string.
    */
{
    const TCHAR szDots[] = TEXT("...");

    SIZE   size;
    TCHAR* pszResult;
    TCHAR* pszResultLast;
    TCHAR* pszResult2nd;
    DWORD  cch;

    cch = lstrlen( psz );
    pszResult = Malloc( (cch * sizeof(TCHAR)) + sizeof(szDots) );
    if (!pszResult)
        return NULL;
    lstrcpy( pszResult, psz );

    dxColumn -= dxColText;
    if (dxColumn <= 0)
    {
        /* None of the column text will be visible so bag the calculations and
        ** just return the original string.
        */
        return pszResult;
    }

    if (!GetTextExtentPoint32( hdc, pszResult, cch, &size ))
    {
        Free( pszResult );
        return NULL;
    }

    pszResult2nd = CharNext( pszResult );
    pszResultLast = pszResult + cch;

    while (size.cx > dxColumn && pszResultLast > pszResult2nd)
    {
        /* Doesn't fit.  Lop off a character, add the ellipsis, and try again.
        ** The minimum result is "..." for empty original or "x..." for
        ** non-empty original.
        */
        pszResultLast = CharPrev( pszResult2nd, pszResultLast );
        lstrcpy( pszResultLast, szDots );

        if (!GetTextExtentPoint( hdc, pszResult, lstrlen( pszResult ), &size ))
        {
            Free( pszResult );
            return NULL;
        }
    }

    return pszResult;
}


VOID
ExpandWindow(
    IN HWND hwnd,
    IN LONG dx,
    IN LONG dy )

    /* Expands window 'hwnd' 'dx' pels to the right and 'dy' pels down from
    ** it's current size.
    */
{
    RECT rect;

    GetWindowRect( hwnd, &rect );

    SetWindowPos( hwnd, NULL,
        0, 0, rect.right - rect.left + dx, rect.bottom - rect.top + dy,
        SWP_NOMOVE + SWP_NOZORDER );
}


TCHAR*
GetText(
    IN HWND hwnd )

    /* Returns heap block containing the text contents of the window 'hwnd' or
    ** NULL.  It is caller's responsibility to Free the returned string.
    */
{
    INT    cch;
    TCHAR* psz;

    cch = GetWindowTextLength( hwnd );
    psz = Malloc( (cch + 1) * sizeof(TCHAR) );

    if (psz)
    {
        *psz = TEXT('\0');
        GetWindowText( hwnd, psz, cch + 1 );
    }

    return psz;
}


HWND
HwndFromCursorPos(
    IN  HINSTANCE   hinstance,
    IN  POINT*      ppt OPTIONAL )

    /* Returns a "Static" control window created at the specified position
    ** (or at the cursor position if NULL is passed in).
    ** The window is moved off the desktop using SetOffDesktop()
    ** so that it can be specified as the owner window
    ** for a popup dialog shown using MsgDlgUtil.
    ** The window returned should be destroyed using DestroyWindow().
    */
{

    HWND hwnd;
    POINT pt;

    if (ppt) { pt = *ppt; }
    else { GetCursorPos(&pt); }

    //
    // create the window
    //

    hwnd = CreateWindowEx(
                WS_EX_TOOLWINDOW, TEXT("Static"), NULL, WS_POPUP, pt.x, pt.y,
                1, 1, NULL, NULL, hinstance, NULL
                );
    if (!hwnd) { return NULL; }

    //
    // move it off the desktop
    //

    SetOffDesktop(hwnd, SOD_MoveOff, NULL);

    ShowWindow(hwnd, SW_SHOW);

    return hwnd;
}


INT
ListBox_AddItem(
    IN HWND   hwndLb,
    IN TCHAR* pszText,
    IN VOID*  pItem )

    /* Adds data item 'pItem' with displayed text 'pszText' to listbox
    ** 'hwndLb'.  The item is added sorted if the listbox has LBS_SORT style,
    ** or to the end of the list otherwise.  If the listbox has LB_HASSTRINGS
    ** style, 'pItem' is a null terminated string, otherwise it is any user
    ** defined data.
    **
    ** Returns the index of the item in the list or negative if error.
    */
{
    INT nIndex;

    nIndex = ListBox_AddString( hwndLb, pszText );
    if (nIndex >= 0)
        ListBox_SetItemData( hwndLb, nIndex, pItem );
    return nIndex;
}


TCHAR*
ListBox_GetPsz(
    IN HWND hwnd,
    IN INT  nIndex )

    /* Returns heap block containing the text contents of the 'nIndex'th item
    ** of list box 'hwnd' or NULL.  It is caller's responsibility to Free the
    ** returned string.
    */
{
    INT    cch;
    TCHAR* psz;

    cch = ListBox_GetTextLen( hwnd, nIndex );
    psz = Malloc( (cch + 1) * sizeof(TCHAR) );

    if (psz)
    {
        *psz = TEXT('\0');
        ListBox_GetText( hwnd, nIndex, psz );
    }

    return psz;
}


INT
ListBox_IndexFromString(
    IN HWND   hwnd,
    IN TCHAR* psz )

    /* Returns the index of the item in string list 'hwnd' that matches 'psz'
    ** or -1 if not found.  Unlike, ListBox_FindStringExact, this compare in
    ** case sensitive.
    */
{
    INT i;
    INT c;

    c = ListBox_GetCount( hwnd );

    for (i = 0; i < c; ++i)
    {
        TCHAR* pszThis;

        pszThis = ListBox_GetPsz( hwnd, i );
        if (pszThis)
        {
            BOOL f;

            f = (lstrcmp( psz, pszThis ) == 0);
            Free( pszThis );
            if (f)
                return i;
        }
    }

    return -1;
}


VOID
ListBox_SetCurSelNotify(
    IN HWND hwndLb,
    IN INT  nIndex )

    /* Set selection in listbox 'hwndLb' to 'nIndex' and notify parent as if
    ** user had clicked the item which Windows doesn't do for some reason.
    */
{
    ListBox_SetCurSel( hwndLb, nIndex );

    SendMessage(
        GetParent( hwndLb ),
        WM_COMMAND,
        (WPARAM )MAKELONG(
            (WORD )GetDlgCtrlID( hwndLb ), (WORD )LBN_SELCHANGE ),
        (LPARAM )hwndLb );
}


VOID*
ListView_GetParamPtr(
    IN HWND hwndLv,
    IN INT  iItem )

    /* Returns the lParam address of the 'iItem' item in 'hwndLv' or NULL if
    ** none or error.
    */
{
    LV_ITEM item;

    ZeroMemory( &item, sizeof(item) );
    item.mask = LVIF_PARAM;
    item.iItem = iItem;

    if (!ListView_GetItem( hwndLv, &item ))
        return NULL;

    return (VOID* )item.lParam;
}


VOID*
ListView_GetSelectedParamPtr(
    IN HWND hwndLv )

    /* Returns the lParam address of the first selected item in 'hwndLv' or
    ** NULL if none or error.
    */
{
    INT     iSel;
    LV_ITEM item;

    iSel = ListView_GetNextItem( hwndLv, -1, LVNI_SELECTED );
    if (iSel < 0)
        return NULL;

    return ListView_GetParamPtr( hwndLv, iSel );
}


BOOL
ListView_SetParamPtr(
    IN HWND  hwndLv,
    IN INT   iItem,
    IN VOID* pParam )

    /* Set the lParam address of the 'iItem' item in 'hwndLv' to 'pParam'.
    ** Return true if successful, false otherwise.
    */
{
    LV_ITEM item;

    ZeroMemory( &item, sizeof(item) );
    item.mask = LVIF_PARAM;
    item.iItem = iItem;
    item.lParam = (LPARAM )pParam;

    return ListView_SetItem( hwndLv, &item );
}


VOID
Menu_CreateAccelProxies(
    IN HINSTANCE hinst,
    IN HWND      hwndParent,
    IN DWORD     dwMid )

    /* Causes accelerators on a popup menu to choose menu commands when the
    ** popup menu is not dropped down.  'Hinst' is the app/dll instance.
    ** 'HwndParent' is the window that receives the popup menu command
    ** messages.  'DwMid' is the menu ID of the menu bar containing the popup
    ** menu.
    */
{
    #define MCF_cbBuf 512

    HMENU        hmenuBar;
    HMENU        hmenuPopup;
    TCHAR        szBuf[ MCF_cbBuf ];
    MENUITEMINFO item;
    INT          i;

    hmenuBar = LoadMenu( hinst, MAKEINTRESOURCE( dwMid ) );
    ASSERT(hmenuBar);
    hmenuPopup = GetSubMenu( hmenuBar, 0 );
    ASSERT(hmenuPopup);

    /* Loop thru menu items on the popup menu.
    */
    for (i = 0; TRUE; ++i)
    {
        ZeroMemory( &item, sizeof(item) );
        item.cbSize = sizeof(item);
        item.fMask = MIIM_TYPE + MIIM_ID;
        item.dwTypeData = szBuf;
        item.cch = MCF_cbBuf;

        if (!GetMenuItemInfo( hmenuPopup, i, TRUE, &item ))
            break;

        if (item.fType != MFT_STRING)
            continue;

        /* Create an off-screen button on the parent with the same ID and
        ** text as the menu item.
        */
        CreateWindow( TEXT("button"), szBuf, WS_CHILD,
            30000, 30000, 0, 0, hwndParent, (HMENU )UlongToPtr(item.wID), hinst, NULL );
    }

    DestroyMenu( hmenuBar );
}


VOID
ScreenToClientRect(
    IN     HWND  hwnd,
    IN OUT RECT* pRect )

    /* Converts '*pRect' from screen to client coordinates of 'hwnd'.
    */
{
    POINT xyUL;
    POINT xyBR;

    xyUL.x = pRect->left;
    xyUL.y = pRect->top;
    xyBR.x = pRect->right;
    xyBR.y = pRect->bottom;

    ScreenToClient( hwnd, &xyUL );
    ScreenToClient( hwnd, &xyBR );

    pRect->left = xyUL.x;
    pRect->top = xyUL.y;
    pRect->right = xyBR.x;
    pRect->bottom = xyBR.y;
}


BOOL
SetOffDesktop(
    IN  HWND  hwnd,
    IN  DWORD dwAction,
    OUT RECT* prectOrg )

    /* Move 'hwnd' back and forth from the visible desktop to the area
    ** off-screen.  Use this when you want to "hide" your owner window without
    ** hiding yourself which Windows automatically does.
    **
    ** 'dwAction' describes the action to take:
    **     SOD_Moveoff:        Move 'hwnd' off the desktop.
    **     SOD_MoveBackFree:   Undo SOD_MoveOff.
    **     SOD_GetOrgRect:     Retrieves original 'hwnd' position.
    **     SOD_Free:           Free SOD_MoveOff context without restoring.
    **     SOD_MoveBackHidden: Move window back, but hidden so you can call
    **                             routines that internally query the position
    **                             of the window.  Undo with SOD_Moveoff.
    **
    ** '*prectOrg' is set to the original window position when 'dwAction' is
    ** SOD_GetOrgRect.  Otherwise, it is ignored, and may be NULL.
    **
    ** Returns true if the window has a SODINFO context, false otherwise.
    */
{
    SODINFO* pInfo;

    TRACE2("SetOffDesktop(h=$%08x,a=%d)",hwnd,dwAction);

    if (!g_SodContextId)
    {
        g_SodContextId = (LPCTSTR )GlobalAddAtom( TEXT("RASSETOFFDESKTOP") );
        if (!g_SodContextId)
            return FALSE;
    }

    pInfo = (SODINFO* )GetProp( hwnd, g_SodContextId );

    if (dwAction == SOD_MoveOff)
    {
        if (pInfo)
        {
            /* Caller is undoing a SOD_MoveBackHidden.
            */
            SetWindowPos( hwnd, NULL,
                pInfo->rectOrg.left, GetSystemMetrics( SM_CYSCREEN ),
                0, 0, SWP_NOSIZE + SWP_NOZORDER );

            if (pInfo->fWeMadeInvisible)
            {
                ShowWindow( hwnd, SW_SHOW );
                pInfo->fWeMadeInvisible = FALSE;
            }
        }
        else
        {
            BOOL f;

            pInfo = (SODINFO* )Malloc( sizeof(SODINFO) );
            if (!pInfo)
                return FALSE;

            f = IsWindowVisible( hwnd );
            if (!f)
                ShowWindow( hwnd, SW_HIDE );

            GetWindowRect( hwnd, &pInfo->rectOrg );
            SetWindowPos( hwnd, NULL, pInfo->rectOrg.left,
                GetSystemMetrics( SM_CYSCREEN ),
                0, 0, SWP_NOSIZE + SWP_NOZORDER );

            if (!f)
                ShowWindow( hwnd, SW_SHOW );

            pInfo->fWeMadeInvisible = FALSE;
            SetProp( hwnd, g_SodContextId, pInfo );
        }
    }
    else if (dwAction == SOD_MoveBackFree || dwAction == SOD_Free)
    {
        if (pInfo)
        {
            if (dwAction == SOD_MoveBackFree)
            {
                SetWindowPos( hwnd, NULL,
                    pInfo->rectOrg.left, pInfo->rectOrg.top, 0, 0,
                    SWP_NOSIZE + SWP_NOZORDER );
            }

            Free( pInfo );
            RemoveProp( hwnd, g_SodContextId );
        }

        return FALSE;
    }
    else if (dwAction == SOD_GetOrgRect)
    {
        if (!pInfo)
            return FALSE;

        *prectOrg = pInfo->rectOrg;
    }
    else
    {
        ASSERT(dwAction==SOD_MoveBackHidden);

        if (!pInfo)
            return FALSE;

        if (IsWindowVisible( hwnd ))
        {
            ShowWindow( hwnd, SW_HIDE );
            pInfo->fWeMadeInvisible = TRUE;
        }

        SetWindowPos( hwnd, NULL,
            pInfo->rectOrg.left, pInfo->rectOrg.top, 0, 0,
            SWP_NOSIZE + SWP_NOZORDER );
    }

    return TRUE;
}


BOOL
SetDlgItemNum(
    IN HWND hwndDlg,
    IN INT iDlgItem,
    IN UINT uValue )

    /* Similar to SetDlgItemInt, but this function uses commas (or the
    ** locale-specific separator) to delimit thousands
    */
{

    DWORD dwSize;
    TCHAR szNumber[32];

    dwSize  = 30;
    GetNumberString(uValue, szNumber, &dwSize);

    return SetDlgItemText(hwndDlg, iDlgItem, szNumber);
}


BOOL
SetEvenTabWidths(
    IN HWND  hwndDlg,
    IN DWORD cPages )

    /* Set the tabs on property sheet 'hwndDlg' to have even fixed width.
    ** 'cPages' is the number of pages on the property sheet.
    **
    ** Returns true if successful, false if any of the tabs requires more than
    ** the fixed width in which case the call has no effect.
    */
{
    HWND hwndTab;
    LONG lStyle;
    RECT rect;
    INT  dxFixed;

    /* The tab control uses hard-coded 1-inch tabs when you set FIXEDWIDTH
    ** style while we want the tabs to fill the page, so we figure out the
    ** correct width ourselves.  For some reason, without a fudge-factor (the
    ** -10) the expansion does not fit on a single line.  The factor
    ** absolutely required varies between large and small fonts and the number
    ** of tabs does not seem to be a factor.
    */
    hwndTab = PropSheet_GetTabControl( hwndDlg );
    GetWindowRect( hwndTab, &rect );
    dxFixed = (rect.right - rect.left - 10 ) / cPages;

    while (cPages > 0)
    {
        RECT rectTab;

        --cPages;
        if (!TabCtrl_GetItemRect( hwndTab, cPages, &rectTab )
            || dxFixed < rectTab.right - rectTab.left)
        {
            /* This tab requires more than the fixed width.  Since the fixed
            ** width is unworkable do nothing.
            */
            return FALSE;
        }
    }

    TabCtrl_SetItemSize( hwndTab, dxFixed, 0 );
    lStyle = GetWindowLong( hwndTab, GWL_STYLE );
    SetWindowLong( hwndTab, GWL_STYLE, lStyle | TCS_FIXEDWIDTH );
    return TRUE;
}


HFONT
SetFont(
    HWND   hwndCtrl,
    TCHAR* pszFaceName,
    BYTE   bfPitchAndFamily,
    INT    nPointSize,
    BOOL   fUnderline,
    BOOL   fStrikeout,
    BOOL   fItalic,
    BOOL   fBold )

    /* Sets font of control 'hwndCtrl' to a font matching the specified
    ** attributes.  See LOGFONT documentation.
    **
    ** Returns the HFONT of the created font if successful or NULL.  Caller
    ** should DeleteObject the returned HFONT when the control is destroyed.
    */
{
    LOGFONT logfont;
    INT     nPelsPerInch;
    HFONT   hfont;

    {
        HDC hdc = GetDC( NULL );
        nPelsPerInch = GetDeviceCaps( hdc, LOGPIXELSY );
        ReleaseDC( NULL, hdc );
    }

    ZeroMemory( &logfont, sizeof(logfont) );
    logfont.lfHeight = -MulDiv( nPointSize, nPelsPerInch, 72 );

    {
        DWORD       cp;
        CHARSETINFO csi;

        cp = GetACP();
        if (TranslateCharsetInfo( &cp, &csi, TCI_SRCCODEPAGE ))
            logfont.lfCharSet = (BYTE)csi.ciCharset;
        else
            logfont.lfCharSet = ANSI_CHARSET;
    }

    logfont.lfOutPrecision = OUT_DEFAULT_PRECIS;
    logfont.lfClipPrecision = CLIP_DEFAULT_PRECIS;
    logfont.lfQuality = DEFAULT_QUALITY;
    logfont.lfPitchAndFamily = bfPitchAndFamily;
    lstrcpy( logfont.lfFaceName, pszFaceName );
    logfont.lfUnderline = (BYTE)fUnderline;
    logfont.lfStrikeOut = (BYTE)fStrikeout;
    logfont.lfItalic = (BYTE)fItalic;
    logfont.lfWeight = (fBold) ? FW_BOLD : FW_NORMAL;

    hfont = CreateFontIndirect( &logfont );
    if (hfont)
    {
        SendMessage( hwndCtrl,
            WM_SETFONT, (WPARAM )hfont, MAKELPARAM( TRUE, 0 ) );
    }

    return hfont;
}



VOID
SlideWindow(
    IN HWND hwnd,
    IN HWND hwndParent,
    IN LONG dx,
    IN LONG dy )

    /* Moves window 'hwnd' 'dx' pels right and 'dy' pels down from it's
    ** current position.  'HwndParent' is the handle of 'hwnd's parent or NULL
    ** if 'hwnd' is not a child window.
    */
{
    RECT  rect;
    POINT xy;

    GetWindowRect( hwnd, &rect );
    xy.x = rect.left;
    xy.y = rect.top;

    if (GetParent( hwnd ))
        ScreenToClient( hwndParent, &xy );

    SetWindowPos( hwnd, NULL,
        xy.x + dx, xy.y + dy, 0, 0,
        SWP_NOSIZE + SWP_NOZORDER );
}


VOID
UnclipWindow(
    IN HWND hwnd )

    /* Moves window 'hwnd' so any clipped parts are again visible on the
    ** screen.  The window is moved only as far as necessary to achieve this.
    */
{
    RECT rect;
    INT  dxScreen = GetSystemMetrics( SM_CXSCREEN );
    INT  dyScreen = GetSystemMetrics( SM_CYSCREEN );

    GetWindowRect( hwnd, &rect );

    if (rect.right > dxScreen)
        rect.left = dxScreen - (rect.right - rect.left);

    if (rect.left < 0)
        rect.left = 0;

    if (rect.bottom > dyScreen)
        rect.top = dyScreen - (rect.bottom - rect.top);

    if (rect.top < 0)
        rect.top = 0;

    SetWindowPos(
        hwnd, NULL,
        rect.left, rect.top, 0, 0,
        SWP_NOZORDER + SWP_NOSIZE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\nt4\common\uiutil\tldef.h ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File:    tldef.h
//
// History:
//  Abolade Gbadegesin   Nov-20-1995    Created.
//
// Private implementation declarations for TreeList control.
//============================================================================

#ifndef _TLDEF_H_
#define _TLDEF_H_


typedef struct _TLITEM {

    struct _TLITEM *pParent;
    LIST_ENTRY      leSiblings;
    LIST_ENTRY      lhChildren;
    LIST_ENTRY      lhSubitems;
    INT             iLevel;
    INT             iIndex;
    UINT            nChildren;

    LV_ITEM         lvi;
    PTSTR           pszText;
    LPARAM          lParam;
    INT             iImage;
    UINT            uiFlag;

} TLITEM;


typedef struct _TLSUBITEM {

    LIST_ENTRY      leItems;
    DWORD           dwFlags;
    INT             iSubItem;
    PTSTR           pszText;

} TLSUBITEM;


typedef struct _TL {

    HWND            hwnd;
    UINT            iCtrlId;
    HWND            hwndList;
    HWND            hwndParent;
    TLITEM          root;
    UINT            nColumns;
    UINT            cyItem;
    UINT            cyText;
    UINT            cxIndent;
    HDC             hdcImages;
    HBITMAP         hbmp;
    HBITMAP         hbmpMem;
    UINT            cxBmp;
    UINT            cyBmp;
    HBITMAP         hbmpStart;
    HBRUSH          hbrBk;

} TL;

#define TLI_EXPANDED        0x0001

#define TL_ICONCOUNT            (IID_TL_IconLast - IID_TL_IconBase + 1)
#define TL_ICONID(index)        ((index) + IID_TL_IconBase)
#define TL_ICONINDEX(id)        ((id) - IID_TL_IconBase)

#define TL_GetPtr(hwnd)         (TL *)GetWindowLong((hwnd), 0)
#define TL_SetPtr(hwnd,ptr)     (TL *)SetWindowLong((hwnd), 0, (UINT)(ptr))

#define TL_StateImageValue(p)   (((p)->lvi.state >> 12) & 0xf)
#define TL_StateImageIndex(p)   (TL_StateImageValue(p) - 1)
#define TL_IsExpanded(p)        ((p)->uiFlag & TLI_EXPANDED)
#define TL_IsVisible(p)         ((p)->iIndex != -1)

#define TL_VerticalLine         0
#define TL_RootChildless        1
#define TL_RootParentCollapsed  2
#define TL_RootParentExpanded   3
#define TL_MidChildless         4
#define TL_MidParentCollapsed   5
#define TL_MidParentExpanded    6
#define TL_EndChildless         7
#define TL_EndParentCollapsed   8
#define TL_EndParentExpanded    9
#define TL_ImageCount           10


LRESULT
CALLBACK
TL_WndProc(
    HWND hwnd,
    UINT uiMsg,
    WPARAM wParam,
    LPARAM lParam
    );

BOOL
TL_OnCreate(
    TL *ptl,
    CREATESTRUCT *pcs
    );

VOID
TL_OnDestroy(
    TL *ptl
    );

BOOL
TL_NotifyParent(
    TL *ptl,
    NMHDR *pnmh
    );

LRESULT
TL_OnNotify(
    TL *ptl,
    INT idCtl,
    NMHDR *pnmh
    );

HTLITEM
TL_OnInsertItem(
    TL *ptl,
    TL_INSERTSTRUCT *ptlis
    );

BOOL
TL_OnDeleteItem(
    TL *ptl,
    HTLITEM hitem
    );

BOOL
TL_OnDeleteAllItems(
    TL *ptl
    );

VOID
TL_DeleteAndNotify(
    TL *ptl,
    TLITEM *pItem
    );

BOOL
TL_OnGetItem(
    TL *ptl,
    LV_ITEM *plvi
    );

BOOL
TL_OnSetItem(
    TL *ptl,
    LV_ITEM *plvi
    );

UINT
TL_OnGetItemCount(
    TL *ptl
    );

HTLITEM
TL_OnGetNextItem(
    TL *ptl,
    UINT uiFlag,
    HTLITEM hItem
    );

#define TL_Enumerate(ptl,pitem) \
        TL_OnGetNextItem((ptl), TLGN_ENUMERATE, (HTLITEM)(pitem))

BOOL
TL_OnExpand(
    TL *ptl,
    UINT uiFlag,
    HTLITEM hItem
    );

BOOL
TL_ItemExpand(
    TL *ptl,
    TLITEM *pItem
    );

BOOL
TL_ItemCollapse(
    TL *ptl,
    TLITEM *pItem
    );

INT
TL_OnInsertColumn(
    TL *ptl,
    INT iCol,
    LV_COLUMN *pCol
    );

BOOL
TL_OnDeleteColumn(
    TL *ptl,
    INT iCol
    );

BOOL
TL_OnSetSelection(
    TL *ptl,
    HTLITEM hItem
    );

VOID
TL_OnWindowPosChanged(
    TL *ptl,
    WINDOWPOS *pwp
    );

VOID
TL_OnEraseBackground(
    TL *ptl,
    HDC hdc
    );

BOOL
TL_OnDrawItem(
    TL *ptl,
    CONST DRAWITEMSTRUCT *pdis
    );

BOOL
TL_DrawItem(
    TL *ptl,
    CONST DRAWITEMSTRUCT *pdis
    );

VOID
TL_OnMeasureItem(
    TL *ptl,
    MEASUREITEMSTRUCT *pmis
    );

HBITMAP
TL_CreateColorBitmap(
    INT cx,
    INT cy
    );

VOID
TL_CreateTreeImages(
    TL *ptl
    );

VOID
TL_DottedLine(
    HDC hdc,
    INT x,
    INT y,
    INT dim,
    BOOL fVertical
    );

VOID
TL_DrawButton(
    HDC hdc,
    INT x,
    INT y,
    INT dim,
    HBRUSH hbrSign,
    HBRUSH hbrBox,
    HBRUSH hbrBk,
    BOOL bCollapsed
    );

VOID
TL_UpdateListIndices(
    TL *ptl,
    TLITEM *pStart
    );

VOID
TL_UpdateDescendantIndices(
    TL *ptl,
    TLITEM *pStart,
    INT *piIndex
    );

VOID
TL_UpdateAncestorIndices(
    TL *ptl,
    TLITEM *pStart,
    INT *piIndex
    );

VOID
TL_UpdateImage(
    TL *ptl,
    TLITEM *pItem,
    TLITEM **ppChanged
    );

VOID
TL_CountItems(
    TLITEM *pParent,
    INT *piCount
    );

BOOL
TL_OnRedraw(
    TL *ptl
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\nt4\common\uiutil\wait.c ===
/* Copyright (c) 1996, Microsoft Corporation, all rights reserved
**
** wait.c
** Waiting for services popup
** Listed alphabetically
**
** 02/17/96 Steve Cobb
*/

#include <windows.h>  // Win32 root
#include <debug.h>    // Trace and assert
#include <nouiutil.h> // No-HWND utilities
#include <uiutil.h>   // Our public header
#include <wait.rch>   // Our resource constants

/* Set when RasLoad has completed successfully in this process context.
*/
BOOL g_fRasLoaded = FALSE;


/* Waiting for services thread argument block.
*/
#define WSARGS struct tagWSARGS
WSARGS
{
    HINSTANCE hInst;
    HWND      hwndOwner;
    HANDLE    hEventUp;
    HANDLE    hEventDie;
};

/* Waiting for services thread context.
*/
#define WSINFO struct tagWSINFO
WSINFO
{
    HANDLE hEventDie;
    DWORD  dwThreadId;
};


/*----------------------------------------------------------------------------
** Local prototypes
**----------------------------------------------------------------------------
*/

VOID
StartWaitingForServices(
    HINSTANCE hInst,
    HWND      hwndOwner,
    WSINFO*   pInfo );

VOID
StopWaitingForServices(
    IN WSINFO* pInfo );

DWORD
WsThread(
    LPVOID pArg );

INT_PTR CALLBACK
WsDlgProc(
    HWND   hwnd,
    UINT   unMsg,
    WPARAM wParam,
    LPARAM lParam );


/*----------------------------------------------------------------------------
** Routines
**----------------------------------------------------------------------------
*/

DWORD
LoadRas(
    IN HINSTANCE hInst,
    IN HWND      hwnd )

    /* Starts the RASMAN service and loads the RASMAN and RASAPI32 entrypoint
    ** addresses.  The "waiting for services" popup is displayed, if
    ** indicated.  'HInst' and 'hwnd' are the owning instance and window.
    **
    ** Returns 0 if successful or an error code.
    */
{
    DWORD  dwErr;
    WSINFO info;

    TRACE("LoadRas");

    if (g_fRasLoaded)
        dwErr = 0;
    else
    {
        if (IsRasmanServiceRunning())
            info.hEventDie = NULL;
        else
            StartWaitingForServices( hInst, hwnd, &info );

        dwErr = LoadRasapi32Dll();
        if (dwErr == 0)
        {
            dwErr = LoadRasmanDll();
            if (dwErr == 0)
            {
                ASSERT(g_pRasInitialize);
                TRACE("RasInitialize");
                dwErr = g_pRasInitialize();
                TRACE1("RasInitialize=%d",dwErr);
            }
        }

        StopWaitingForServices( &info );

        if (dwErr == 0)
            g_fRasLoaded = TRUE;
    }

    TRACE1("LoadRas=%d",dwErr);
    return dwErr;
}


VOID
StartWaitingForServices(
    HINSTANCE hInst,
    HWND      hwndOwner,
    WSINFO*   pInfo )

    /* Popup the "waiting for services" dialog in another thread.  'HInst' and
    ** 'hwnd' are the owning instance and window.  Fills caller's 'pInfo' with
    ** context to pass to StopWaitingForServices.
    */
{
    WSARGS* pArgs;
    HANDLE  hThread;
    HANDLE  hEventUp;

    pInfo->hEventDie = NULL;

    pArgs = (WSARGS* )Malloc( sizeof(*pArgs) );
    if (!pArgs)
        return;

    ZeroMemory( pArgs, sizeof(*pArgs) );
    pArgs->hInst = hInst;
    pArgs->hwndOwner = hwndOwner;

    hEventUp = pArgs->hEventUp =
        CreateEvent( NULL, FALSE, FALSE, NULL );
    if (!hEventUp)
    {
        Free( pArgs );
        return;
    }

    pInfo->hEventDie = pArgs->hEventDie =
        CreateEvent( NULL, FALSE, FALSE, NULL );
    if (!pInfo->hEventDie)
    {
        Free( pArgs );
        CloseHandle( hEventUp );
        return;
    }

    /* Create a thread so paint messages for the popup get processed.  The
    ** current thread is going to be tied up starting RAS Manager.
    */
    hThread = CreateThread( NULL, 0, WsThread, pArgs, 0, &pInfo->dwThreadId );
    if (hThread)
    {
        /* Don't begin churning on RASMAN until the popup has displayed
        ** itself.
        */
        SetThreadPriority( hThread, THREAD_PRIORITY_HIGHEST );
        WaitForSingleObject( hEventUp, INFINITE );
        CloseHandle( hThread );
    }
    else
    {
        /* Thread was DOA.
        */
        CloseHandle( pInfo->hEventDie );
        pInfo->hEventDie = NULL;
        Free( pArgs );
    }

    CloseHandle( hEventUp );
}


VOID
StopWaitingForServices(
    IN WSINFO* pInfo )

    /* Terminate the "waiting for services" popup.  'PInfo' is the context
    ** from StartWaitingForServices.
    */
{
    TRACE("StopWaitingForServices");

    if (pInfo->hEventDie)
    {
        /* The post triggers the message loop to action, but you can't rely on
        ** the posted message arriving in the thread message loop.  For
        ** example, if user holds the mouse down on the window caption, the
        ** message never appears, presumably because it's flushed by some
        ** sub-loop during "move window" processing.  Set the event to make
        ** sure the popup knows to quit the next time it processes a message.
        */
        SetEvent( pInfo->hEventDie );
        PostThreadMessage( pInfo->dwThreadId, WM_CLOSE, 0, 0 );
    }
}


DWORD
WsThread(
    LPVOID pArg )

    /* Waiting for services thread main.
    */
{
    WSARGS* pArgs;
    HWND    hwnd;
    MSG     msg;

    TRACE("WsThread running");

    pArgs = (WSARGS* )pArg;
    hwnd = CreateDialog( pArgs->hInst,
               MAKEINTRESOURCE( DID_WS_WaitingForServices ),
               NULL, WsDlgProc );
    if (hwnd)
    {
        LONG lStyle;

        /* Make ourselves topmost if the owner window is, otherwise we may not
        ** be visible under the topmost window, such as the winlogin window.
        ** Note that if you actally create the dialog with an owner you have
        ** all kinds of thread related problems.  In retrospect, should have
        ** written this such that the "waiting" dialog happened in the main
        ** thread and the LoadLibraries and RasInitialize happened in the
        ** created thread which would automatically avoid this kind of
        ** problem, but this works too.
        */
        lStyle = GetWindowLong( pArgs->hwndOwner, GWL_EXSTYLE );
        if (lStyle & WS_EX_TOPMOST)
        {
            TRACE("TOPMOST");
            SetWindowPos( hwnd, HWND_TOPMOST,
                0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE );
        }

        CenterWindow( hwnd, pArgs->hwndOwner );
        ShowWindow( hwnd, SW_SHOW );
        UpdateWindow( hwnd );
        SetForegroundWindow( hwnd );
    }

    /* Tell other thread to go on.
    */
    SetEvent( pArgs->hEventUp );

    if (hwnd)
    {
        TRACE("WsThread msg-loop running");

        while (GetMessage( &msg, NULL, 0, 0 ))
        {
            if (WaitForSingleObject( pArgs->hEventDie, 0 ) == WAIT_OBJECT_0)
            {
                /* Normal termination.
                */
                DestroyWindow( hwnd );
                break;
            }

            if (!IsDialogMessage( hwnd, &msg ))
            {
                TranslateMessage( &msg );
                DispatchMessage( &msg );
            }
        }

        if (pArgs->hwndOwner)
            SetForegroundWindow( pArgs->hwndOwner );
    }

    CloseHandle( pArgs->hEventDie );
    Free( pArgs );
    TRACE("WsThread terminating");
    return 0;
}


INT_PTR CALLBACK
WsDlgProc(
    HWND   hwnd,
    UINT   unMsg,
    WPARAM wParam,
    LPARAM lParam )

    /* Standard Win32 dialog procedure.
    */
{
    if (unMsg == WM_INITDIALOG)
    {
        HMENU hmenu;

        /* Remove Close from the system menu since some people think it kills
        ** the app and not just the popup.
        */
        hmenu = GetSystemMenu( hwnd, FALSE );
        if (hmenu && DeleteMenu( hmenu, SC_CLOSE, MF_BYCOMMAND ))
            DrawMenuBar( hwnd );
        return TRUE;
    }

    return FALSE;
}


VOID
UnloadRas(
    void )

    /* Unload the DLLs loaded by LoadRas().
    */
{
    if (g_fRasLoaded)
    {
        g_fRasLoaded = FALSE;
        UnloadRasmanDll();
        UnloadRasapi32Dll();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\nt4\inc\debug.h ===
/* Copyright (c) 1995, Microsoft Corporation, all rights reserved
**
** debug.h
** Debug and tracing macros
**
** 08/24/95 Steve Cobb
**
** To use TRACE/DUMP:
**
**     These calls encapsulate dynamically linking to the tracing utilities in
**     RTUTIL.DLL and provide shortcut macros to access them and to prevent
**     their inclusion in non-DBG builds.
**
**     Before calling any TRACE/DUMP macros call:
**         DEBUGINIT( "YOURMODULE" );
**
**     Use the TRACEx and DUMPx macros to print messages to the log as defined
**     by the associated RTUTIL.DLL routines.  Currently, this code is removed
**     from non-DBG builds.  A few examples:
**
**       TRACE("MyRoutine");
**       TRACE2("MyRoutine=%d,c=%s",dwErr,psz);
**
**     After done calling TRACE/DUMP macros call:
**         DEBUGTERM();
**
**     Exactly one file should have define the debug globals with the
**     following while all other files should include the header without
**     defining the manifest.
**
**         #define DEBUGGLOBALS
**         #include <debug.h>
**
**     Static libraries can safely use TRACE/DUMP without calling DEBUGINIT
**     and DEBUGTERM or defining DEBUGGLOBALS.  If the caller sets up these in
**     his module, the library trace will appear as part of caller's module
**     trace.
**
** To use ASSERT:
**
**     Use ASSERT to assert that a given expression is true, popping up a
**     dialog indicating the file and line number of the ASSERTION if it
**     fails.  It is not necessary to call DEBUGINIT and DEBUGTERM to use
**     ASSERT.  For example:
**
**         hwndOwner = GetParent( hwnd );
**         ASSERT(hwndOwner!=NULL);
*/

#ifndef _DEBUG_H_
#define _DEBUG_H_


#define FREETRACE 1


/*----------------------------------------------------------------------------
** Datatypes and global declarations (defined in debug.c)
**----------------------------------------------------------------------------
*/

#if (DBG || FREETRACE)

extern DWORD g_dwTraceId;

typedef DWORD (APIENTRY * TRACEREGISTEREXA)( LPCSTR, DWORD );
extern TRACEREGISTEREXA g_pTraceRegisterExA;

typedef DWORD (APIENTRY * TRACEDEREGISTERA)( DWORD );
extern TRACEDEREGISTERA g_pTraceDeregisterA;

typedef DWORD (APIENTRY * TRACEDEREGISTEREXA)( DWORD, DWORD );
extern TRACEDEREGISTEREXA g_pTraceDeregisterExA;

typedef DWORD (APIENTRY * TRACEPRINTFA)( DWORD, LPCSTR, ... );
extern TRACEPRINTFA g_pTracePrintfA;

typedef DWORD (APIENTRY * TRACEPRINTFEXA)( DWORD, DWORD, LPCSTR, ... );
extern TRACEPRINTFEXA g_pTracePrintfExA;

typedef DWORD (APIENTRY * TRACEDUMPEXA)( DWORD, DWORD, LPBYTE, DWORD, DWORD, BOOL, LPCSTR );
extern TRACEDUMPEXA g_pTraceDumpExA;

#endif // (DBG || FREETRACE)


/*----------------------------------------------------------------------------
** Macros
**----------------------------------------------------------------------------
*/

/* Debug macros.  This code does not appear in non-DBG builds unless FREETRACE
** is defined.
**
** The trailing number indicates the number of printf arguments in the format
** string.  TRACEW1 accepts a format string containing a single WCHAR*
** argument.  The argument is converted before output so that the output file
** remains entirely ANSI.
*/
#if (DBG || FREETRACE)

#define TRACE(a) \
            if (g_dwTraceId!=-1) g_pTracePrintfA(g_dwTraceId,a)
#define TRACE1(a,b) \
            if (g_dwTraceId!=-1) g_pTracePrintfA(g_dwTraceId,a,b)
#define TRACE2(a,b,c) \
            if (g_dwTraceId!=-1) g_pTracePrintfA(g_dwTraceId,a,b,c)
#define TRACE3(a,b,c,d)\
            if (g_dwTraceId!=-1) g_pTracePrintfA(g_dwTraceId,a,b,c,d)
#define TRACE4(a,b,c,d,e) \
            if (g_dwTraceId!=-1) g_pTracePrintfA(g_dwTraceId,a,b,c,d,e)
#define TRACE5(a,b,c,d,e,f) \
            if (g_dwTraceId!=-1) g_pTracePrintfA(g_dwTraceId,a,b,c,d,e,f)
#define TRACE6(a,b,c,d,e,f,g) \
            if (g_dwTraceId!=-1) g_pTracePrintfA(g_dwTraceId,a,b,c,d,e,f,g)
#define TRACEX(l,a) \
            if (g_dwTraceId!=-1) g_pTracePrintfExA(g_dwTraceId,l,a)
#define TRACEX1(l,a,b) \
            if (g_dwTraceId!=-1) g_pTracePrintfExA(g_dwTraceId,l,a,b)
#define TRACEX2(l,a,b,c) \
            if (g_dwTraceId!=-1) g_pTracePrintfExA(g_dwTraceId,l,a,b,c)
#define TRACEX3(l,a,b,c,d)\
            if (g_dwTraceId!=-1) g_pTracePrintfExA(g_dwTraceId,l,a,b,c,d)
#define TRACEX4(l,a,b,c,d,e) \
            if (g_dwTraceId!=-1) g_pTracePrintfExA(g_dwTraceId,l,a,b,c,d,e)
#define TRACEX5(l,a,b,c,d,e,f) \
            if (g_dwTraceId!=-1) g_pTracePrintfExA(g_dwTraceId,l,a,b,c,d,e,f)
#define TRACEX6(l,a,b,c,d,e,f,h) \
            if (g_dwTraceId!=-1) g_pTracePrintfExA(g_dwTraceId,l,a,b,c,d,e,f,h)
#define TRACEW1(a,b) \
            if (g_dwTraceId!=-1) TracePrintfW1(a,b)
#define DUMPB(p,c) \
            if (g_dwTraceId!=-1) g_pTraceDumpExA(g_dwTraceId,1,(LPBYTE)p,c,1,1,NULL)
#define DUMPDW(p,c) \
            if (g_dwTraceId!=-1) g_pTraceDumpExA(g_dwTraceId,1,(LPBYTE)p,c,4,1,NULL)
#if defined(ASSERT)
#undef ASSERT
#endif
#define ASSERT(a) \
            if (!(a)) Assert(#a,__FILE__,__LINE__)
#define DEBUGINIT(s) \
            DebugInit(s)
#define DEBUGTERM() \
            DebugTerm()
#else

#define TRACE(a)
#define TRACE1(a,b)
#define TRACE2(a,b,c)
#define TRACE3(a,b,c,d)
#define TRACE4(a,b,c,d,e)
#define TRACE5(a,b,c,d,e,f)
#define TRACE6(a,b,c,d,e,f,g)
#define TRACEX(l,a)
#define TRACEX1(l,a,b)
#define TRACEX2(l,a,b,c)
#define TRACEX3(l,a,b,c,d)
#define TRACEX4(l,a,b,c,d,e)
#define TRACEX5(l,a,b,c,d,e,f)
#define TRACEX6(l,a,b,c,d,e,f,g)
#define TRACEW1(a,b)
#define DUMPB(p,c)
#define DUMPDW(p,c)
#if defined(ASSERT)
#undef ASSERT
#endif
#define ASSERT(a)
#define DEBUGINIT(s)
#define DEBUGTERM()

#endif


/*----------------------------------------------------------------------------
** Prototypes (alphabetically)
**----------------------------------------------------------------------------
*/

VOID
DebugInit(
    IN CHAR* pszModule );

VOID
DebugTerm(
    void );

VOID
Assert(
    IN const CHAR* pszExpression,
    IN const CHAR* pszFile,
    IN UINT        unLine );

VOID
TracePrintfW1(
    CHAR*  pszFormat,
    TCHAR* psz1 );


#endif // _DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\nt4\inc\dtl.h ===
/* Copyright (c) 1992, Microsoft Corporation, all rights reserved
**
** dtl.h
** Double-threaded linked list header
**
** 06/28/92 Steve Cobb
*/

#ifndef _DTL_H_
#define _DTL_H_


#include <nouiutil.h>  // Heap definitions


/* Double-threaded linked list node control block.  There is one node for each
** entry in a list.
**
** Applications should not access this structure directly.
*/
#define DTLNODE struct tagDTLNODE
DTLNODE
{
    DTLNODE* pdtlnodePrev; /* Address of previous node or NULL if none */
    DTLNODE* pdtlnodeNext; /* Address of next node or NULL if none     */
    VOID*    pData;        /* Address of user's data                   */
    LONG     lNodeId;      /* User-defined node identification code    */
};


/* Double-threaded linked list control block.  There is one for each list.
**
** Applications should not access this structure directly.
*/
#define DTLLIST struct tagDTLLIST
DTLLIST
{
    DTLNODE* pdtlnodeFirst; /* Address of first node or NULL if none */
    DTLNODE* pdtlnodeLast;  /* Address of last node or NULL if none  */
    LONG     lNodes;        /* Number of nodes in list               */
    LONG     lListId;       /* User-defined list identification code */
};


/* List node duplication function.  See DuplicateList.
*/
typedef DTLNODE* (*PDUPNODE)( IN DTLNODE* );

/* List node free function.  See FreeList.
*/
typedef VOID (*PDESTROYNODE)( IN DTLNODE* );

/* List node comparison function. See MergeSort.
*/
typedef IN (*PCOMPARENODE)( IN DTLNODE*, IN DTLNODE* );



/* Macros and function prototypes.
*/
#define DtlGetData( pdtlnode )        ((pdtlnode)->pData)
#define DtlGetNodeId( pdtlnode )      ((pdtlnode)->lNodeId)
#define DtlGetFirstNode( pdtllist )   ((pdtllist)->pdtlnodeFirst)
#define DtlGetListId( pdtllist )      ((pdtllist)->lListId)
#define DtlGetNextNode( pdtlnode )    ((pdtlnode)->pdtlnodeNext)
#define DtlGetNodes( pdtllist )       ((pdtllist)->lNodes)
#define DtlGetPrevNode( pdtlnode )    ((pdtlnode)->pdtlnodePrev)
#define DtlGetLastNode( pdtllist )    ((pdtllist)->pdtlnodeLast)
#define DtlPutData( pdtlnode, p )     ((pdtlnode)->pData = (p))
#define DtlPutNodeId( pdtlnode, l )   ((pdtlnode)->lNodeId = (LONG )(l))
#define DtlPutListCode( pdtllist, l ) ((pdtllist)->lListId = (LONG )(l))

DTLNODE* DtlAddNodeAfter( DTLLIST*, DTLNODE*, DTLNODE* );
DTLNODE* DtlAddNodeBefore( DTLLIST*, DTLNODE*, DTLNODE* );
DTLNODE* DtlAddNodeFirst( DTLLIST*, DTLNODE* );
DTLNODE* DtlAddNodeLast( DTLLIST*, DTLNODE* );
DTLLIST* DtlCreateList( LONG );
DTLNODE* DtlCreateNode( VOID*, LONG );
DTLNODE* DtlCreateSizedNode( LONG, LONG );
VOID     DtlDestroyList( DTLLIST*, PDESTROYNODE );
VOID     DtlDestroyNode( DTLNODE* );
DTLNODE* DtlDeleteNode( DTLLIST*, DTLNODE* );
DTLLIST* DtlDuplicateList( DTLLIST*, PDUPNODE, PDESTROYNODE );
VOID     DtlMergeSort( DTLLIST*, PCOMPARENODE );

DTLNODE* DtlNodeFromIndex( DTLLIST*, LONG );
DTLNODE* DtlRemoveNode( DTLLIST*, DTLNODE* );


#endif /*_DTL_H_*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\nt4\inc\ipaddr.h ===
/* Copyright (c) 1991, Microsoft Corporation, all rights reserved

    ipaddr.h - TCP/IP Address custom control, global definitions

    November 10, 1992   - Greg Strange
*/

#ifndef _IPADDR_H_
#define _IPADDR_H_


// Messages sent to IPAddress controls

#define IP_CLEARADDRESS WM_USER+100 // no parameters
#define IP_SETADDRESS   WM_USER+101 // lparam = TCP/IP address
#define IP_GETADDRESS   WM_USER+102 // lresult = TCP/IP address
#define IP_SETRANGE     WM_USER+103 // wparam = field, lparam = range
#define IP_SETFOCUS     WM_USER+104 // wparam = field
#define IP_ISBLANK      WM_USER+105 // no parameters


// The following is a useful macro for passing the range values in the
// IP_SETRANGE message.

#define MAKERANGE(low,high) ((LPARAM)(WORD)(((BYTE)(high)<<8)+(BYTE)(low)))

// And this is a useful macro for making the IP Address to be passed
// as a LPARAM.

#define MAKEIPADDRESS(b1,b2,b3,b4) ((LPARAM)(((DWORD)(b1)<<24)+((DWORD)(b2)<<16)+((DWORD)(b3)<<8)+((DWORD)(b4))))

// Get individual number

#define FIRST_IPADDRESS(x)  ((x>>24) & 0xff)
#define SECOND_IPADDRESS(x) ((x>>16) & 0xff)
#define THIRD_IPADDRESS(x)  ((x>>8) & 0xff)
#define FOURTH_IPADDRESS(x) (x & 0xff)


// Call this function once during initialization.

int FAR PASCAL
IpAddrInit(
    IN HANDLE hInstance,
    IN DWORD  dwErrorTitle,
    IN DWORD  dwBadIpAddrRange );


#endif // _IPADDR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\nt4\inc\popupdlg.h ===
/* Copyright (c) 1995, Microsoft Corporation, all rights reserved
**
** popupdlg.h
** UI helper library
** Error and message dialog public header
**
** 08/25/95 Steve Cobb
*/

#ifndef _POPUPDLG_H_
#define _POPUPDLG_H_


/*----------------------------------------------------------------------------
** Datatypes
**----------------------------------------------------------------------------
*/

/* Extended arguments for the ErrorDlgUtil routine.  Designed so zeroed gives
** default behaviors.
*/
#define ERRORARGS struct tagERRORARGS
ERRORARGS
{
    /* Insertion strings for arguments %1 to %9 in the 'dwOperation' string,
    ** or NULLs if none.
    */
    TCHAR* apszOpArgs[ 9 ];

    /* Insertion strings for auxillary arguments %4 to %6 in the 'dwFormat'
    ** string, or NULLs if none.  (The standard arguments are %1=the
    ** 'dwOperation' string, %2=the decimal error number, and %3=the
    ** 'dwError'string.)
    */
    TCHAR* apszAuxFmtArgs[ 3 ];

    /* If 'fStringOutput' is true, the ErrorDlgUtil returns the formatted text
    ** string that would otherwise be displayed in the popup in 'pszOutput'.
    ** It is caller's responsibility to LocalFree the returned string.
    */
    BOOL   fStringOutput;
    TCHAR* pszOutput;
};


/* Extended arguments for the MsgDlgUtil routine.  Designed so zeroed gives
** default behaviors.
*/
#define MSGARGS struct tagMSGARGS
MSGARGS
{
    /* Insertion strings for arguments %1 to %9 in the 'dwMsg' string, or
    ** NULLs if none.
    */
    TCHAR* apszArgs[ 9 ];

    /* Currently, as for MessageBox, where defaults if 0 are MB_OK and
    ** MB_ICONINFORMATION.
    */
    DWORD dwFlags;

    /* If non-NULL, specifies a string overriding the loading of the 'dwMsg'
    ** parameter string.
    */
    TCHAR* pszString;

    /* If 'fStringOutput' is true, the MsgDlgUtil returns the formatted text
    ** string that would otherwise be displayed in the popup in 'pszOutput'.
    ** It is caller's responsibility to LocalFree the returned string.
    */
    BOOL   fStringOutput;
    TCHAR* pszOutput;
};


/*----------------------------------------------------------------------------
** Prototypes
**----------------------------------------------------------------------------
*/

LRESULT CALLBACK
CenterDlgOnOwnerCallWndProc(
    int    code,
    WPARAM wparam,
    LPARAM lparam );

BOOL
GetErrorText(
    DWORD   dwError,
    TCHAR** ppszError );

int
ErrorDlgUtil(
    IN     HWND       hwndOwner,
    IN     DWORD      dwOperation,
    IN     DWORD      dwError,
    IN OUT ERRORARGS* pargs,
    IN     HINSTANCE  hInstance,
    IN     DWORD      dwTitle,
    IN     DWORD      dwFormat );

int
MsgDlgUtil(
    IN     HWND      hwndOwner,
    IN     DWORD     dwMsg,
    IN OUT MSGARGS*  pargs,
    IN     HINSTANCE hInstance,
    IN     DWORD     dwTitle );


#endif // _POPUPDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\nt4\inc\rasip.h ===
//****************************************************************************
//
//		       Microsoft NT Remote Access Service
//
//		       Copyright 1992-93
//
//
//  Revision History
//
//
//  12/9/93	Gurdeep Singh Pall	Created
//
//
//  Description: Shared structs between rasarp and ipcp
//
//****************************************************************************

#ifndef _RASIP_H_
#define _RASIP_H_

#define RASARP_DEVICE_NAME	L"\\\\.\\RASARP"

#define RASARP_DEVICE_NAME_NUC	"\\\\.\\RASARP"

#define FILE_DEVICE_RASARP	0x00009001

#define _RASARP_CONTROL_CODE(request,method)  ((FILE_DEVICE_RASARP)<<16 | (request<<2) | method)

#define IOCTL_RASARP_ACTIVITYINFO	_RASARP_CONTROL_CODE( 0, METHOD_BUFFERED )

#define IOCTL_RASARP_DISABLEIF		_RASARP_CONTROL_CODE( 1, METHOD_BUFFERED )

typedef ULONG IPADDR ;

struct IPLinkUpInfo {

#define CALLIN	0
#define CALLOUT 1

    ULONG	    I_Usage ;	// CALLIN, or CALLOUT

    IPADDR	    I_IPAddress ; // For client - the client's IP Address, for server
				  // the client's IP address.

    ULONG	    I_NetbiosFilter ; // 1 = ON, 0 - OFF.

} ;

typedef struct IPLinkUpInfo IPLinkUpInfo ;


struct ActivityInfo {

    IPADDR	    A_IPAddress ; // The address for which activity is requested.

    ULONG	    A_TimeSinceLastActivity ; // In minutes

} ;

typedef struct ActivityInfo ActivityInfo ;

#endif // _RASIP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\nt4\inc\rasrpclb.h ===
/*++

Copyright(c) 1995 Microsoft Corporation

MODULE NAME
    rasrpclb.h

ABSTRACT
    Header file for rasrpc client/server common routines

AUTHOR
    Anthony Discolo (adiscolo) 10-Sep-1996

REVISION HISTORY

--*/

#ifndef _RASRPCLIB_H
#define _RASRPCLIB_H

DWORD
RasToRpcPbuser(
    LPRASRPC_PBUSER pUser,
    PBUSER *pPbuser
    );

DWORD
RpcToRasPbuser(
    PBUSER *pPbuser,
    LPRASRPC_PBUSER pUser
    );

#endif // _RASRPCLIB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\nt4\inc\rasscrpt.h ===
//============================================================================
// Copyright (c) Microsoft Corporation
//
// File:    rasscrpt.h
//
// History:
//  Abolade-Gbadegesin  Mar-29-96   Created.
//
// Contains declarations for the exported scripting API functions.
//============================================================================

#ifndef _RASSCRPT_H_
#define _RASSCRPT_H_


//
// Flags passed to RasScriptInit:
//
// RASSCRIPT_NotifyOnInput          Caller requires input-notification
// RASSCRIPT_HwndNotify             'hNotifier' is an HWND (defaults to event)
//
#define RASSCRIPT_NotifyOnInput     0x00000001
#define RASSCRIPT_HwndNotify        0x00000002


//
// event codes retrieved using RasScriptGetEventCode
//
#define SCRIPTCODE_Done             0
#define SCRIPTCODE_Halted           1
#define SCRIPTCODE_InputNotify      2
#define SCRIPTCODE_KeyboardEnable   3
#define SCRIPTCODE_KeyboardDisable  4
#define SCRIPTCODE_IpAddressSet     5
#define SCRIPTCODE_HaltedOnError    6


//
// path to log-file containing syntax errors, if any
//
#define RASSCRIPT_LOG               "%windir%\\system32\\ras\\script.log"



DWORD
APIENTRY
RasScriptExecute(
    IN      HRASCONN        hrasconn,
    IN      PBENTRY*        pEntry,
    IN      CHAR*           pszUserName,
    IN      CHAR*           pszPassword,
    OUT     CHAR*           pszIpAddress
    );


DWORD
RasScriptGetEventCode(
    IN      HANDLE          hscript
    );


DWORD
RasScriptGetIpAddress(
    IN      HANDLE          hscript,
    OUT     CHAR*           pszIpAddress
    );


DWORD
APIENTRY
RasScriptInit(
    IN      HRASCONN        hrasconn,
    IN      PBENTRY*        pEntry,
    IN      CHAR*           pszUserName,
    IN      CHAR*           pszPassword,
    IN      DWORD           dwFlags,
    IN      HANDLE          hNotifier,
    OUT     HANDLE*         phscript
    );


DWORD
APIENTRY
RasScriptReceive(
    IN      HANDLE          hscript,
    IN      BYTE*           pBuffer,
    IN OUT  DWORD*          pdwBufferSize
    );


DWORD
APIENTRY
RasScriptSend(
    IN      HANDLE          hscript,
    IN      BYTE*           pBuffer,
    IN      DWORD           dwBufferSize
    );


DWORD
APIENTRY
RasScriptTerm(
    IN      HANDLE          hscript
    );


#endif // _RASSCRPT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\nt4\inc\loaddlls.h ===
/* Copyright (c) 1996, Microsoft Corporation, all rights reserved
**
** loaddlls.h
** RAS DLL load public header
**
** 02/17/96 Steve Cobb
*/

#ifndef _LOADDLLS_H_
#define _LOADDLLS_H_


#include <ras.h>    // Win32 RAS APIs
#include <rasdlg.h> // Win32 RAS UI APIs
#include <rasman.h> // RAS connection manager service
#include <rasppp.h> // PPP structure definitions

#define RASMERGE

/*----------------------------------------------------------------------------
** Datatypes and global declarations (defined in loaddlls.c)
**----------------------------------------------------------------------------
*/

/* RASAPI32.DLL entry points.
*/
#ifndef RASMERGE
extern HINSTANCE g_hRasapi32Dll;
#endif

typedef DWORD (APIENTRY * PRASCONNECTIONNOTIFICATION)( HRASCONN, HANDLE, DWORD );
extern PRASCONNECTIONNOTIFICATION g_pRasConnectionNotification;

typedef DWORD (APIENTRY * PRASDELETEENTRY)( LPTSTR, LPTSTR );
extern PRASDELETEENTRY g_pRasDeleteEntry;

typedef DWORD (APIENTRY * PRASDIAL)( LPRASDIALEXTENSIONS, LPTSTR, LPRASDIALPARAMS, DWORD, LPVOID, LPHRASCONN );
extern PRASDIAL g_pRasDial;

typedef DWORD (APIENTRY * PRASENUMENTRIES)( LPTSTR, LPTSTR, LPRASENTRYNAME, LPDWORD, LPDWORD );
extern PRASENUMENTRIES g_pRasEnumEntries;

typedef DWORD (APIENTRY * PRASENUMCONNECTIONS)( LPRASCONN, LPDWORD, LPDWORD );
extern PRASENUMCONNECTIONS g_pRasEnumConnections;

typedef DWORD (APIENTRY * PRASGETCONNECTSTATUS)( HRASCONN, LPRASCONNSTATUS );
extern PRASGETCONNECTSTATUS g_pRasGetConnectStatus;

typedef VOID (APIENTRY * PRASGETCONNECTRESPONSE)( HRASCONN, CHAR* );
extern PRASGETCONNECTRESPONSE g_pRasGetConnectResponse;

typedef DWORD (APIENTRY * PRASGETCREDENTIALS)( LPTSTR, LPTSTR, LPRASCREDENTIALS );
extern PRASGETCREDENTIALS g_pRasGetCredentials;

typedef DWORD (APIENTRY * PRASGETENTRYDIALPARAMS)( LPTSTR, LPRASDIALPARAMS, LPBOOL );
extern PRASGETENTRYDIALPARAMS g_pRasGetEntryDialParams;

typedef DWORD (APIENTRY * PRASGETERRORSTRING)( UINT, LPTSTR, DWORD );
extern PRASGETERRORSTRING g_pRasGetErrorString;

typedef DWORD (APIENTRY * PRASHANGUP)( HRASCONN );
extern PRASHANGUP g_pRasHangUp;

typedef DWORD (APIENTRY * PRASGETAUTODIALENABLE)( DWORD, LPBOOL );
extern PRASGETAUTODIALENABLE g_pRasGetAutodialEnable;

typedef DWORD (APIENTRY * PRASGETAUTODIALPARAM)( DWORD, LPVOID, LPDWORD );
extern PRASGETAUTODIALPARAM g_pRasGetAutodialParam;

typedef DWORD (APIENTRY * PRASGETPROJECTIONINFO)( HRASCONN, RASPROJECTION, LPVOID, LPDWORD );
extern PRASGETPROJECTIONINFO g_pRasGetProjectionInfo;

typedef DWORD (APIENTRY * PRASSETAUTODIALENABLE)( DWORD, BOOL );
extern PRASSETAUTODIALENABLE g_pRasSetAutodialEnable;

typedef DWORD (APIENTRY * PRASSETAUTODIALPARAM)( DWORD, LPVOID, DWORD );
extern PRASSETAUTODIALPARAM g_pRasSetAutodialParam;

typedef DWORD (APIENTRY * PRASGETSUBENTRYHANDLE)( HRASCONN, DWORD, LPHRASCONN );
extern PRASGETSUBENTRYHANDLE g_pRasGetSubEntryHandle;

typedef HPORT (APIENTRY * PRASGETHPORT)( HRASCONN );
extern PRASGETHPORT g_pRasGetHport;

typedef DWORD (APIENTRY * PRASSETCREDENTIALS)( LPTSTR, LPTSTR, LPRASCREDENTIALS, BOOL );
extern PRASSETCREDENTIALS g_pRasSetCredentials;

typedef DWORD (APIENTRY * PRASSETOLDPASSWORD)( HRASCONN, CHAR* );
extern PRASSETOLDPASSWORD g_pRasSetOldPassword;

typedef DWORD (APIENTRY * PRASGETCOUNTRYINFO)( LPRASCTRYINFO, LPDWORD );
extern PRASGETCOUNTRYINFO g_pRasGetCountryInfo;


/* RASDLG.DLL entry points
*/
#ifndef RASMERGE
extern HINSTANCE g_hRasdlgDll;
#endif

typedef DWORD (APIENTRY * PRASPHONEBOOKDLG)( LPTSTR, LPTSTR, LPRASPBDLG );
extern PRASPHONEBOOKDLG g_pRasPhonebookDlg;

typedef DWORD (APIENTRY * PRASENTRYDLG)( LPTSTR, LPTSTR, LPRASENTRYDLG );
extern PRASENTRYDLG g_pRasEntryDlg;

typedef DWORD (APIENTRY * PROUTERENTRYDLG)( LPTSTR, LPTSTR, LPTSTR, LPRASENTRYDLG );
extern PROUTERENTRYDLG g_pRouterEntryDlg;

typedef DWORD (APIENTRY * PRASDIALDLG)( LPTSTR, LPTSTR, LPTSTR, LPRASDIALDLG );
extern PRASDIALDLG g_pRasDialDlg;

typedef DWORD (APIENTRY * PRASMONITORDLG)( LPTSTR, LPRASMONITORDLG );
extern PRASMONITORDLG g_pRasMonitorDlg;


/* RASMAN.DLL entry points
*/
#ifndef RASMERGE
extern HINSTANCE g_hRasmanDll;
#endif

typedef DWORD (APIENTRY * PRASPORTCLEARSTATISTICS)( HPORT );
extern PRASPORTCLEARSTATISTICS g_pRasPortClearStatistics;

typedef DWORD (APIENTRY * PRASBUNDLECLEARSTATISTICS)( HPORT );
extern PRASBUNDLECLEARSTATISTICS g_pRasBundleClearStatistics;

typedef DWORD (APIENTRY * PRASBUNDLECLEARSTATISTICSEX)( HCONN );
extern PRASBUNDLECLEARSTATISTICSEX g_pRasBundleClearStatisticsEx;

typedef DWORD (APIENTRY * PRASDEVICEENUM)( PCHAR, PBYTE, PWORD, PWORD );
extern PRASDEVICEENUM g_pRasDeviceEnum;

typedef DWORD (APIENTRY * PRASDEVICEGETINFO)( HPORT, PCHAR, PCHAR, PBYTE, PWORD );
extern PRASDEVICEGETINFO g_pRasDeviceGetInfo;

typedef DWORD (APIENTRY * PRASFREEBUFFER)( PBYTE );
extern PRASFREEBUFFER g_pRasFreeBuffer;

typedef DWORD (APIENTRY * PRASGETBUFFER)( PBYTE*, PWORD );
extern PRASGETBUFFER g_pRasGetBuffer;

typedef DWORD (APIENTRY * PRASPORTGETFRAMINGEX)( HPORT, RAS_FRAMING_INFO* );
extern PRASPORTGETFRAMINGEX g_pRasPortGetFramingEx;

typedef DWORD (APIENTRY * PRASGETINFO)( HPORT, RASMAN_INFO* );
extern PRASGETINFO g_pRasGetInfo;

typedef DWORD (APIENTRY * PRASINITIALIZE)();
extern PRASINITIALIZE g_pRasInitialize;

typedef DWORD (APIENTRY * PRASPORTCANCELRECEIVE)( HPORT );
extern PRASPORTCANCELRECEIVE g_pRasPortCancelReceive;

typedef DWORD (APIENTRY * PRASPORTENUM)( PBYTE, PWORD, PWORD );
extern PRASPORTENUM g_pRasPortEnum;

typedef DWORD (APIENTRY * PRASPORTGETINFO)( HPORT, PBYTE, PWORD );
extern PRASPORTGETINFO g_pRasPortGetInfo;

typedef DWORD (APIENTRY * PRASPORTGETSTATISTICS)( HPORT, PBYTE, PWORD );
extern PRASPORTGETSTATISTICS g_pRasPortGetStatistics;

typedef DWORD (APIENTRY * PRASBUNDLEGETSTATISTICS)( HPORT, PBYTE, PWORD );
extern PRASBUNDLEGETSTATISTICS g_pRasBundleGetStatistics;

typedef DWORD (APIENTRY * PRASPORTGETSTATISTICSEX)( HPORT, PBYTE, PWORD );
extern PRASPORTGETSTATISTICSEX g_pRasPortGetStatisticsEx;

typedef DWORD (APIENTRY * PRASBUNDLEGETSTATISTICSEX)(HPORT, PBYTE, PWORD);
extern PRASBUNDLEGETSTATISTICSEX g_pRasBundleGetStatisticsEx;

typedef DWORD (APIENTRY * PRASPORTRECEIVE)( HPORT, PBYTE, PWORD, DWORD, HANDLE );
extern PRASPORTRECEIVE g_pRasPortReceive;

typedef DWORD (APIENTRY * PRASPORTSEND)( HPORT, PBYTE, WORD );
extern PRASPORTSEND g_pRasPortSend;

typedef DWORD (APIENTRY * PRASPORTGETBUNDLE)( HPORT, HBUNDLE* );
extern PRASPORTGETBUNDLE g_pRasPortGetBundle;

typedef DWORD (APIENTRY * PRASGETDEVCONFIG)( HPORT, PCHAR, PBYTE, DWORD* );
extern PRASGETDEVCONFIG g_pRasGetDevConfig;

typedef DWORD (APIENTRY * PRASSETDEVCONFIG)( HPORT, PCHAR, PBYTE, DWORD );
extern PRASSETDEVCONFIG g_pRasSetDevConfig;

typedef DWORD (APIENTRY * PRASPORTOPEN)(PCHAR, HPORT*, HANDLE);
extern PRASPORTOPEN g_pRasPortOpen;

typedef DWORD (APIENTRY * PRASPORTREGISTERSLIP)(HPORT, DWORD, WCHAR*, BOOL, WCHAR*, WCHAR*, WCHAR*, WCHAR*);
extern PRASPORTREGISTERSLIP g_pRasPortRegisterSlip;

typedef DWORD (APIENTRY * PRASALLOCATEROUTE)(HPORT, RAS_PROTOCOLTYPE, BOOL, RASMAN_ROUTEINFO*);
extern PRASALLOCATEROUTE g_pRasAllocateRoute;

typedef DWORD (APIENTRY * PRASACTIVATEROUTE)(HPORT, RAS_PROTOCOLTYPE, RASMAN_ROUTEINFO*, PROTOCOL_CONFIG_INFO*);
extern PRASACTIVATEROUTE g_pRasActivateRoute;

typedef DWORD (APIENTRY * PRASACTIVATEROUTEEX)(HPORT, RAS_PROTOCOLTYPE, DWORD, RASMAN_ROUTEINFO*, PROTOCOL_CONFIG_INFO*);
extern PRASACTIVATEROUTEEX g_pRasActivateRouteEx;

typedef DWORD (APIENTRY * PRASDEVICESETINFO)(HPORT, PCHAR, PCHAR, RASMAN_DEVICEINFO*);
extern PRASDEVICESETINFO g_pRasDeviceSetInfo;

typedef DWORD (APIENTRY * PRASDEVICECONNECT)(HPORT, PCHAR, PCHAR, DWORD, HANDLE);
extern PRASDEVICECONNECT g_pRasDeviceConnect;

typedef DWORD (APIENTRY * PRASPORTSETINFO)(HPORT, RASMAN_PORTINFO*);
extern PRASPORTSETINFO g_pRasPortSetInfo;

typedef DWORD (APIENTRY * PRASPORTCLOSE)(HPORT);
extern PRASPORTCLOSE g_pRasPortClose;

typedef DWORD (APIENTRY * PRASPORTLISTEN)(HPORT, DWORD, HANDLE);
extern PRASPORTLISTEN g_pRasPortListen;

typedef DWORD (APIENTRY * PRASPORTCONNECTCOMPLETE)(HPORT);
extern PRASPORTCONNECTCOMPLETE g_pRasPortConnectComplete;

typedef DWORD (APIENTRY * PRASPORTDISCONNECT)(HPORT, HANDLE);
extern PRASPORTDISCONNECT g_pRasPortDisconnect;

typedef DWORD (APIENTRY * PRASREQUESTNOTIFICATION)(HPORT, HANDLE);
extern PRASREQUESTNOTIFICATION g_pRasRequestNotification;

typedef DWORD (APIENTRY * PRASPORTENUMPROTOCOLS)(HPORT, RAS_PROTOCOLS*, PWORD);
extern PRASPORTENUMPROTOCOLS g_pRasPortEnumProtocols;

typedef DWORD (APIENTRY * PRASPORTSETFRAMING)(HPORT, RAS_FRAMING, RASMAN_PPPFEATURES*, RASMAN_PPPFEATURES*);
extern PRASPORTSETFRAMING g_pRasPortSetFraming;

typedef DWORD (APIENTRY * PRASPORTSETFRAMINGEX)(HPORT, RAS_FRAMING_INFO*);
extern PRASPORTSETFRAMINGEX g_pRasPortSetFramingEx;

typedef DWORD (APIENTRY * PRASSETCACHEDCREDENTIALS)(PCHAR, PCHAR, PCHAR);
extern PRASSETCACHEDCREDENTIALS g_pRasSetCachedCredentials;

typedef DWORD (APIENTRY * PRASGETDIALPARAMS)(DWORD, LPDWORD, PRAS_DIALPARAMS);
extern PRASGETDIALPARAMS g_pRasGetDialParams;

typedef DWORD (APIENTRY * PRASSETDIALPARAMS)(DWORD, DWORD, PRAS_DIALPARAMS, BOOL);
extern PRASSETDIALPARAMS g_pRasSetDialParams;

typedef DWORD (APIENTRY * PRASCREATECONNECTION)(HCONN*);
extern PRASCREATECONNECTION g_pRasCreateConnection;

typedef DWORD (APIENTRY * PRASDESTROYCONNECTION)(HCONN);
extern PRASDESTROYCONNECTION g_pRasDestroyConnection;

typedef DWORD (APIENTRY * PRASCONNECTIONENUM)(HCONN*, LPDWORD, LPDWORD);
extern PRASCONNECTIONENUM g_pRasConnectionEnum;

typedef DWORD (APIENTRY * PRASADDCONNECTIONPORT)(HCONN, HPORT, DWORD);
extern PRASADDCONNECTIONPORT g_pRasAddConnectionPort;

typedef DWORD (APIENTRY * PRASENUMCONNECTIONPORTS)(HCONN, RASMAN_PORT*, LPDWORD, LPDWORD);
extern PRASENUMCONNECTIONPORTS g_pRasEnumConnectionPorts;

typedef DWORD (APIENTRY * PRASGETCONNECTIONPARAMS)(HCONN, PRAS_CONNECTIONPARAMS);
extern PRASGETCONNECTIONPARAMS g_pRasGetConnectionParams;

typedef DWORD (APIENTRY * PRASSETCONNECTIONPARAMS)(HCONN, PRAS_CONNECTIONPARAMS);
extern PRASSETCONNECTIONPARAMS g_pRasSetConnectionParams;

typedef DWORD (APIENTRY * PRASGETCONNECTIONUSERDATA)(HCONN, DWORD, PBYTE, LPDWORD);
extern PRASGETCONNECTIONUSERDATA g_pRasGetConnectionUserData;

typedef DWORD (APIENTRY * PRASSETCONNECTIONUSERDATA)(HCONN, DWORD, PBYTE, DWORD);
extern PRASSETCONNECTIONUSERDATA g_pRasSetConnectionUserData;

typedef DWORD (APIENTRY * PRASGETPORTUSERDATA)(HCONN, DWORD, PBYTE, LPDWORD);
extern PRASGETPORTUSERDATA g_pRasGetPortUserData;

typedef DWORD (APIENTRY * PRASSETPORTUSERDATA)(HCONN, DWORD, PBYTE, DWORD);
extern PRASSETPORTUSERDATA g_pRasSetPortUserData;

typedef DWORD (APIENTRY * PRASADDNOTIFICATION)(HCONN, HANDLE, DWORD);
extern PRASADDNOTIFICATION g_pRasAddNotification;

typedef DWORD (APIENTRY * PRASSIGNALNEWCONNECTION)(HCONN);
extern PRASSIGNALNEWCONNECTION g_pRasSignalNewConnection;

typedef DWORD (APIENTRY * PRASPPPSTOP)(HPORT);
extern PRASPPPSTOP g_pRasPppStop;

typedef DWORD (APIENTRY * PRASPPPCALLBACK)(HPORT, CHAR*);
extern PRASPPPCALLBACK g_pRasPppCallback;

typedef DWORD (APIENTRY * PRASPPPCHANGEPASSWORD)(HPORT, CHAR*, CHAR*, CHAR*);
extern PRASPPPCHANGEPASSWORD g_pRasPppChangePassword;

typedef DWORD (APIENTRY * PRASPPPGETINFO)(HPORT, PPP_MESSAGE*);
extern PRASPPPGETINFO g_pRasPppGetInfo;

typedef DWORD (APIENTRY * PRASPPPRETRY)(HPORT, CHAR*, CHAR*, CHAR*);
extern PRASPPPRETRY g_pRasPppRetry;

typedef DWORD (APIENTRY *PRASPPPSTART)(HPORT, CHAR*, CHAR*, CHAR*, CHAR*, LUID*,
                                       PPP_CONFIG_INFO*, LPVOID, CHAR*,
                                       BOOL, HANDLE, DWORD, BOOL);
extern PRASPPPSTART g_pRasPppStart;

typedef DWORD (APIENTRY * PRASSETIOCOMPLETIONPORT)(HPORT, HANDLE, PRAS_OVERLAPPED, PRAS_OVERLAPPED, PRAS_OVERLAPPED, PRAS_OVERLAPPED);
extern PRASSETIOCOMPLETIONPORT g_pRasSetIoCompletionPort;

typedef DWORD (APIENTRY * PRASSENDPPPMESSAGETORASMAN) (PPP_MESSAGE *pPppMessage);
extern PRASSENDPPPMESSAGETORASMAN g_pRasSendPppMessageToRasman;

/* MPRADMIN.DLL entry points
*/
#ifndef RASMERGE
extern HINSTANCE g_hMpradminDll;
#endif

typedef DWORD (APIENTRY * PMPRADMININTERFACECREATE)(HANDLE,DWORD,LPBYTE,HANDLE*);
extern PMPRADMININTERFACECREATE g_pMprAdminInterfaceCreate;
typedef DWORD (APIENTRY * PMPRADMININTERFACESETCREDENTIALS)(LPWSTR,LPWSTR,LPWSTR,LPWSTR,LPWSTR);
extern PMPRADMININTERFACESETCREDENTIALS g_pMprAdminInterfaceSetCredentials;
typedef DWORD (APIENTRY * PMPRADMINSERVERDISCONNECT)(HANDLE);
extern PMPRADMINSERVERDISCONNECT g_pMprAdminServerDisconnect;
typedef DWORD (APIENTRY * PMPRADMINSERVERCONNECT)(LPWSTR,HANDLE*);
extern PMPRADMINSERVERCONNECT g_pMprAdminServerConnect;
typedef DWORD (APIENTRY * PRASADMINSERVERCONNECT)(LPWSTR, HANDLE*);
extern PRASADMINSERVERCONNECT g_pRasAdminServerConnect;
typedef DWORD (APIENTRY * PRASADMINSERVERDISCONNECT)(HANDLE);
extern PRASADMINSERVERDISCONNECT g_pRasAdminServerDisconnect;
typedef DWORD (APIENTRY * PRASADMINBUFFERFREE)(LPVOID);
extern PRASADMINBUFFERFREE g_pRasAdminBufferFree;
typedef DWORD (APIENTRY * PRASADMINCONNECTIONENUM)(HANDLE, DWORD, LPBYTE*, DWORD, LPDWORD, LPDWORD, LPDWORD);
extern PRASADMINCONNECTIONENUM g_pRasAdminConnectionEnum;
typedef DWORD (APIENTRY * PRASADMINCONNECTIONGETINFO)(HANDLE, DWORD, HANDLE, LPBYTE*);
extern PRASADMINCONNECTIONGETINFO g_pRasAdminConnectionGetInfo;
typedef DWORD (APIENTRY * PRASADMINPORTENUM)(HANDLE, DWORD, HANDLE, LPBYTE*, DWORD, LPDWORD, LPDWORD, LPDWORD);
extern PRASADMINPORTENUM g_pRasAdminPortEnum;
typedef DWORD (APIENTRY * PRASADMINPORTGETINFO)(HANDLE, DWORD, HANDLE, LPBYTE*);
extern PRASADMINPORTGETINFO g_pRasAdminPortGetInfo;
typedef DWORD (APIENTRY * PRASADMINPORTDISCONNECT)(HANDLE, HANDLE);
extern PRASADMINPORTDISCONNECT g_pRasAdminPortDisconnect;
typedef DWORD (APIENTRY * PRASADMINUSERSETINFO)(LPCWSTR,LPCWSTR,DWORD,LPBYTE);
extern PRASADMINUSERSETINFO g_pRasAdminUserSetInfo;

//
// Miscellaneous entry points.
//
// These are included for consistency because they
// are remotable by the RAS RPC interface.
//
typedef DWORD (*PGETINSTALLEDPROTOCOLS)(void);
extern PGETINSTALLEDPROTOCOLS g_pGetInstalledProtocols;

typedef DWORD (*PGETUSERPREFERENCES)(PBUSER*, DWORD);
extern PGETUSERPREFERENCES g_pGetUserPreferences;

typedef DWORD (*PSETUSERPREFERENCES)(PBUSER*, DWORD);
extern PSETUSERPREFERENCES g_pSetUserPreferences;

typedef DWORD (WINAPI *PGETSYSTEMDIRECTORY)(LPTSTR, UINT);
extern PGETSYSTEMDIRECTORY g_pGetSystemDirectory;

/*----------------------------------------------------------------------------
** Prototypes
**----------------------------------------------------------------------------
*/

BOOL
IsRasmanServiceRunning(
    void );

DWORD
LoadMpradminDll(
    void );

DWORD
LoadRasapi32Dll(
    void );

DWORD
LoadRasdlgDll(
    void );

DWORD
LoadRasmanDll(
    void );

DWORD
LoadRasRpcDll(
    LPTSTR lpszServer
    );

BOOL
Rasapi32DllLoaded(
    void
    );

BOOL
RasRpcDllLoaded(
    void
    );

VOID
UnloadMpradminDll(
    void );

VOID
UnloadRasapi32Dll(
    void );

VOID
UnloadRasdlgDll(
    void );

VOID
UnloadRasmanDll(
    void );

VOID
UnloadRasRpcDll(
    void );

#endif // _LOADDLLS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\nt4\inc\phonenum.h ===
/* Copyright (c) 1996, Microsoft Corporation, all rights reserved
**
** phonenum.h
** Phone number building library
** Public header
**
** 03/06/96 Steve Cobb
*/

#ifndef _PHONENUM_H_
#define _PHONENUM_H_


#include <pbk.h>
#include <tapi.h>


/*----------------------------------------------------------------------------
** Prototypes
**----------------------------------------------------------------------------
*/

TCHAR*
LinkPhoneNumberFromParts(
    IN     HINSTANCE hInst,
    IN OUT HLINEAPP* pHlineapp,
    IN     PBUSER*   pUser,
    IN     PBENTRY*  pEntry,
    IN     PBLINK*   pLink,
    IN     DWORD     iPhoneNumber,
    IN     TCHAR*    pszOverrrideNumber,
    IN     BOOL      fDialable );

TCHAR*
PhoneNumberFromParts(
    IN     HINSTANCE hInst,
    IN OUT HLINEAPP* pHlineapp,
    IN     PBUSER*   pUser,
    IN     PBENTRY*  pEntry,
    IN     TCHAR*    pszBaseNumber,
    IN     BOOL      fDialable );

TCHAR*
PhoneNumberFromPrefixSuffix(
    IN TCHAR* pszBaseNumber,
    IN TCHAR* pszPrefix,
    IN TCHAR* pszSuffix );

TCHAR*
PhoneNumberFromPrefixSuffixEx(
    IN  TCHAR*  pszBaseNumber,
    IN  TCHAR*  pszPrefix,
    IN  TCHAR*  pszSuffix,
    IN  BOOL    fDownLevelIsdn );

TCHAR*
PhoneNumberFromTapiParts(
    IN     HINSTANCE hInst,
    IN     TCHAR*    pszBaseNumber,
    IN     TCHAR*    pszAreaCode,
    IN     DWORD     dwCountryCode,
    IN OUT HLINEAPP* pHlineapp,
    IN     BOOL      fDialable );

TCHAR*
PhoneNumberFromTapiPartsEx(
    IN     HINSTANCE hInst,
    IN     TCHAR*    pszBaseNumber,
    IN     TCHAR*    pszAreaCode,
    IN     DWORD     dwCountryCode,
    IN     BOOL      fDownLevelIsdn,
    IN OUT HLINEAPP* pHlineapp,
    IN     BOOL      fDialable );

VOID
PrefixSuffixFromLocationId(
    IN  PBUSER* pUser,
    IN  DWORD   dwLocationId,
    OUT TCHAR** ppszPrefix,
    OUT TCHAR** ppszSuffix );


#endif // _PHONENUM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\nt4\inc\pbk.h ===
/* Copyright (c) 1995, Microsoft Corporation, all rights reserved
**
** pbk.h
** Remote Access phonebook file (.PBK) library
** Public header
**
** 06/20/95 Steve Cobb
*/

#ifndef _PBK_H_
#define _PBK_H_

#include <windows.h>  // Win32 core

/* RASFIL32.DLL is built ANSI-based, but the header uses T-types so if we're
** built UNICODE-based we need to un-UNICODE around it's header.
*/
#ifdef UNICODE
#undef LPTSTR
#define LPTSTR CHAR*
#undef TCHAR
#define TCHAR CHAR
#include <rasfile.h>  // RAS configuration file library
#undef TCHAR
#define TCHAR WCHAR
#undef LPTSTR
#define LPTSTR TCHAR*
#else
#include <rasfile.h>  // RAS configuration file library
#endif

#include <ras.h>      // Win32 RAS
#include <raserror.h> // Win32 RAS error codes
#include <nouiutil.h> // No-HWNDs utility library
#include <rasman.h>   // RAS Manager library


/*----------------------------------------------------------------------------
** Constants
**----------------------------------------------------------------------------
*/

#define GLOBALSECTIONNAME "."
#define PREFIXSECTIONNAME ".Prefix"
#define SUFFIXSECTIONNAME ".Suffix"

#define GROUPID_Media   "MEDIA="
#define GROUPKEY_Media  "MEDIA"
#define GROUPID_Device  "DEVICE="
#define GROUPKEY_Device "DEVICE"

/* ReadPhonebookFile flags
*/
#define RPBF_ReadOnly    0x00000001
#define RPBF_HeadersOnly 0x00000002
#define RPBF_NoList      0x00000004
#define RPBF_NoCreate    0x00000008
#define RPBF_Router      0x00000010

/* Base protocol definitions (see dwBaseProtocol).
*/
#define BP_Ppp  1
#define BP_Slip 2
#define BP_Ras  3

/* Authentication strategy definitions (see dwAuthentication).
*/
#define AS_Default    -1
#define AS_PppThenAmb 0
#define AS_AmbThenPpp 1
#define AS_PppOnly    2
#define AS_AmbOnly    3

/* Net protocol bit definitions (see dwfExcludedProtocols)
**
** (The NP_* definitions have moved to nouiutil.h with the
**  GetInstalledProtocols routine)
*/

/* IP address source definitions (see dwIpAddressSource)
*/
#define ASRC_ServerAssigned  1 // For router means "the ones in NCPA"
#define ASRC_RequireSpecific 2
#define ASRC_None            3 // Router only

/* Security restrictions on authentication (see dwAuthRestrictions)
**
** Note: AR_AuthTerminal is defunct and is not written to the phonebook by the
**       new library.  It is, however, read and translated into AR_AuthAny,
**       fAutoLogon=0, and an after dialing terminal.
*/
#define AR_AuthAny         0
#define AR_AuthTerminal    1
#define AR_AuthEncrypted   2
#define AR_AuthMsEncrypted 3

/* Script mode (see dwScriptMode)
*/
#define SM_None     0
#define SM_Terminal 1
#define SM_Script   2

/* Miscellaneous "no value" constants.
*/
#define XN_None  0   // No X25 network
#define CPW_None -1  // No cached password

/* Description field.  Move to ras.h if/when supported by
** RasGet/SetEntryProperties API.
*/
#define RAS_MaxDescription 200

/* 'OverridePref' bits.  Set indicates the corresponding value read from the
** phonebook should be used.  Clear indicates the global user preference
** should be used.
*/
#define RASOR_RedialAttempts          0x00000001
#define RASOR_RedialSeconds           0x00000002
#define RASOR_IdleDisconnectSeconds   0x00000004
#define RASOR_RedialOnLinkFailure     0x00000008
#define RASOR_PopupOnTopWhenRedialing 0x00000010
#define RASOR_CallbackMode            0x00000020

/* 'DwDataEntcryption' codes.
*/
#define DE_None   0
#define DE_Weak   1
#define DE_Strong 2


/*----------------------------------------------------------------------------
** Data types
**----------------------------------------------------------------------------
*/

/* Provides shorthand to identify devices without re-parsing RAS Manager
** strings.  "Other" is anything not recognized as another specific type.
**
** Note: This datatype is stored in the registry preferences so the values
**       must not change over time.  For this reason, I have hard-coded the
**       value of each enumberated type.
*/
#define PBDEVICETYPE enum tagPBDEVICETYPE
PBDEVICETYPE
{
    PBDT_None = 0,
    PBDT_Null = 1,
    PBDT_Other = 2,
    PBDT_Modem = 3,
    PBDT_Pad = 4,
    PBDT_Switch = 5,
    PBDT_Isdn = 6,
    PBDT_X25 = 7
};


/* RAS port information read from RASMAN.
**
** Each port (and link) is uniquely identified by port name.  If it were only
** that simple...
**
** In the old RAS model, the port name was the unique identifier that was
** presented to the user, and the user can have two same-type devices on two
** different ports.
**
** In TAPI/Unimodem, the "friendly" device name is the unique identifier
** that's presented to the user and the corresponding port is a property of
** the device.  If the port is changed and you dial it still finds the device
** you originally selected.  If you swap two devices on two ports it uses the
** one with the matching unique device name.
**
** So, since we're using TAPI now we should use the device as the unique
** identifier, right?  Well, the trouble is the "#1" and "#2" appended at the
** end of the identical TAPI device names to make them unique says nothing to
** the user, and Toby tells us that customers are indeed asking for the port
** name to appear instead of "#1".  But, of course, when they do that they're
** port-centric like RAS was in the first place.  Given this, we in RAS will
** continue to use the port name as the unique identifier, though the UI will
** de-emphasize the port name in the display.
*/
#define PBPORT struct tagPBPORT
PBPORT
{
    /* The port name is always unique, if configured.  Unconfigured port names
    ** might not be unique.  This is never NULL.
    */
    TCHAR* pszPort;

    /* Indicates the port is actually configured and not a remnant of an old
    ** configuration read from the phonebook, which is a more common case with
    ** plug-n-play.
    */
    BOOL fConfigured;

    /* The device name is the one from RASMAN when 'fConfigured' or the one
    ** from the phonebook if not.  May be NULL with unconfigured ports as it
    ** was not stored in old phonebooks.
    */
    TCHAR* pszDevice;

    /* The media as it appears in the MEDIA= lines in the phonebook.  This is
    ** usually but not always (for obscure historical reasons) the same as the
    ** RASMAN media.  See PbMedia.
    */
    TCHAR* pszMedia;

    /* Shorthand device type code derived from the RASMAN device type string.
    */
    PBDEVICETYPE pbdevicetype;

    /* 'FMxsModemPort' is set if the port is attached to a RASMXS modem.
    */
    BOOL fMxsModemPort;

    /* These are default settings read from RASMAN and are valid for modems
    ** only.  See AppendPbportToList.
    */
    DWORD dwMaxConnectBps;  // Applies to MXS only
    DWORD dwMaxCarrierBps;  // Applies to MXS only
    DWORD dwBpsDefault;
    BOOL  fHwFlowDefault;
    BOOL  fEcDefault;
    BOOL  fEccDefault;
    DWORD fSpeakerDefault;
};


/* Phonebook entry link information.  One per link, multiple per multi-link.
*/
#define PBLINK struct tagPBLINK
PBLINK
{
    /* Information about the port to which this link is attached.
    */
    PBPORT pbport;
    BOOL   fOtherPortOk;

    /* These fields are set for modems only.  See SetDefaultModemSettings.
    */
    DWORD dwBps;
    BOOL  fHwFlow;
    BOOL  fEc;
    BOOL  fEcc;
    DWORD fSpeaker;
    BOOL  fManualDial;  // Applies to MXS only

    /* These fields are set for ISDN only.  'LChannels' and 'fCompression' are
    ** not used unless 'fProprietaryIsdn' is set.
    */
    BOOL fProprietaryIsdn;
    LONG lLineType;
    BOOL fFallback;
    BOOL fCompression;
    LONG lChannels;

    /* Address and size of opaque device configuration block created/edited by
    ** TAPI.  Currently, there are no TAPI devices that provide blob-editing
    ** acceptable to RAS so these field are unused.
    */
    BYTE* pTapiBlob;
    DWORD cbTapiBlob;

    /* Phone number information for the link.
    */
    DTLLIST* pdtllistPhoneNumbers;
    BOOL     fPromoteHuntNumbers;

    /* Indicates the link is enabled.  All links appearing in the file are
    ** enabled.  This is provided for the convenience of the UI during link
    ** configuration.
    */
    BOOL fEnabled;
};


/* Phonebook entry information.
*/
#define PBENTRY struct tagPBENTRY
PBENTRY
{
    /* Basic page fields.
    */
    TCHAR* pszEntryName;
    TCHAR* pszDescription;
    TCHAR* pszAreaCode;
    DWORD  dwCountryCode;
    DWORD  dwCountryID;
    BOOL   fUseCountryAndAreaCode;

    /* The "dial using" field is stored as a list of links.
    */
    DTLLIST* pdtllistLinks;

    /* Dialing policy.
    */
    DWORD dwDialMode;
    DWORD dwDialPercent;
    DWORD dwDialSeconds;
    DWORD dwHangUpPercent;
    DWORD dwHangUpSeconds;

    /* Server page fields.
    */

    /* Protocol information.  SLIP/PPP settings, PPP/AMB authentication
    ** strategy, PPP protocols not desired for this entry.
    **
    ** Note: dwAuthentication is read-only.  The phonebook file value of this
    **       parameter is set by the RasDial API based on the result of
    **       authentication attempts.
    */
    DWORD dwBaseProtocol;
    DWORD dwfExcludedProtocols;
    BOOL  fLcpExtensions;
    DWORD dwAuthentication;
    BOOL  fSkipNwcWarning;
    BOOL  fSkipDownLevelDialog;
    BOOL  fSwCompression;

    /* TCPIP Settings dialog PPP or SLIP TCP/IP configuration information.
    ** 'DwBaseProtocol' determines which.
    */
    BOOL   fIpPrioritizeRemote;
    BOOL   fIpHeaderCompression;
    TCHAR* pszIpAddress;
    TCHAR* pszIpDnsAddress;
    TCHAR* pszIpDns2Address;
    TCHAR* pszIpWinsAddress;
    TCHAR* pszIpWins2Address;
    DWORD  dwIpAddressSource; // PPP only
    DWORD  dwIpNameSource;    // PPP only
    DWORD  dwFrameSize;       // SLIP only

    /* Script settings.
    */
    DWORD  dwScriptModeBefore;
    TCHAR* pszScriptBefore;
    DWORD  dwScriptModeAfter;
    TCHAR* pszScriptAfter;

    /* Security page fields.
    */
    DWORD dwAuthRestrictions;
    DWORD dwDataEncryption;
    BOOL  fAutoLogon;
    BOOL  fSecureLocalFiles;
    BOOL  fAuthenticateServer;

    /* X.25 page fields.
    */
    TCHAR* pszX25Network;
    TCHAR* pszX25Address;
    TCHAR* pszX25UserData;
    TCHAR* pszX25Facilities;

    /* (Router) Dialing page fields.
    **
    ** These fields are used in place of the equivalent user preference only
    ** when the corresponding 'dwfOverridePref' bit is set.
    */
    DWORD dwfOverridePref;

    DWORD dwRedialAttempts;
    DWORD dwRedialSeconds;
    LONG  dwIdleDisconnectSeconds;
    BOOL  fRedialOnLinkFailure;
    BOOL  fPopupOnTopWhenRedialing;
    DWORD dwCallbackMode;

    /* Other fields not shown in UI.
    */
    TCHAR* pszCustomDialDll;
    TCHAR* pszCustomDialFunc;

    /* Authentication dialog fields.  The UID of the cached password is fixed
    ** at entry creation.  To translate user's old entries, the user name and
    ** domain are read and used as authentication defaults if no cached
    ** credentials exist.  They are not rewritten to the entry.
    */
    DWORD  dwDialParamsUID;
    BOOL   fUsePwForNetwork;
    TCHAR* pszOldUser;
    TCHAR* pszOldDomain;

    /* Status flags.  'fDirty' is set when the entry has changed so as to
    ** differ from the phonebook file on disk.  'fCustom' is set when the
    ** entry contains a MEDIA and DEVICE (so RASAPI is able to read it) but
    ** was not created by us.  When 'fCustom' is set only 'pszEntry' is
    ** guaranteed valid and the entry cannot be edited.
    */
    BOOL fDirty;
    BOOL fCustom;
};


/* Phonebook (.PBK) file information.
*/
#define PBFILE struct tagPBFILE
PBFILE
{
    /* Handle of phone book file.
    */
    HRASFILE hrasfile;

    /* Fully qualified path to the phonebook.
    */
    TCHAR* pszPath;

    /* Phonebook mode, system, personal, or alternate.
    */
    DWORD dwPhonebookMode;

    /* Unsorted list of PBENTRY.  The list is manipulated by the Entry
    ** dialogs.
    */
    DTLLIST* pdtllistEntries;
};


/* The callback number for a device.  This type is a node in the
** 'pdllistCallbackNumbers' below.
*/
#define CALLBACKNUMBER struct tagCALLBACKNUMBER
CALLBACKNUMBER
{
    TCHAR* pszDevice;
    TCHAR* pszCallbackNumber;
};


/*----------------------------------------------------------------------------
** Prototypes
**----------------------------------------------------------------------------
*/

DTLNODE*
CloneEntryNode(
    DTLNODE* pdtlnodeSrc );

VOID
ClosePhonebookFile(
    IN OUT PBFILE* pFile );

DWORD
CopyToPbport(
    IN PBPORT* ppbportDst,
    IN PBPORT* ppbportSrc );

DTLNODE*
CreateEntryNode(
    BOOL fCreateLink );

DTLNODE*
CreateLinkNode(
    void );

DTLNODE*
CreatePortNode(
    void );

VOID
DestroyEntryNode(
    IN DTLNODE* pdtlnode );

VOID
DestroyLinkNode(
    IN DTLNODE* pdtlnode );

VOID
DestroyPortNode(
    IN DTLNODE* pdtlnode );

DTLNODE*
DuplicateEntryNode(
    DTLNODE* pdtlnodeSrc );

DTLNODE*
DuplicateLinkNode(
    IN DTLNODE* pdtlnodeSrc );

DTLNODE*
EntryNodeFromName(
    IN DTLLIST* pdtllistEntries,
    IN TCHAR*   pszName );

DWORD
InitializePbk(
    void );

DWORD
InitPersonalPhonebook(
    OUT TCHAR** ppszFile );

DWORD
LoadPadsList(
    OUT DTLLIST** ppdtllistPads );

DWORD
LoadPhonebookFile(
    IN  TCHAR*    pszPhonebookPath,
    IN  TCHAR*    pszSection,
    IN  BOOL      fHeadersOnly,
    IN  BOOL      fReadOnly,
    OUT HRASFILE* phrasfile,
    OUT BOOL*     pfPersonal );

DWORD
LoadPortsList(
    OUT DTLLIST** ppdtllistPorts );

DWORD
LoadPortsList2(
    OUT DTLLIST** ppdtllistPorts,
    IN  BOOL      fRouter );

DWORD
LoadScriptsList(
    OUT DTLLIST** ppdtllistScripts );

PBDEVICETYPE
PbdevicetypeFromPszType(
    IN TCHAR* pszDeviceType );

PBDEVICETYPE
PbdevicetypeFromPszTypeA(
    IN CHAR* pszDeviceType );

PBPORT*
PpbportFromPortName(
    IN DTLLIST* pdtllistPorts,
    IN TCHAR*   pszPort );

DWORD
ReadPhonebookFile(
    IN  TCHAR*  pszPhonebookPath,
    IN  PBUSER* pUser,
    IN  TCHAR*  pszSection,
    IN  DWORD   dwFlags,
    OUT PBFILE* pFile );

BOOL
SetDefaultModemSettings(
    IN PBLINK* pLink );

DWORD
SetPersonalPhonebookInfo(
    IN BOOL   fPersonal,
    IN TCHAR* pszPath );

VOID
TerminatePbk(
    void );

DWORD
WritePhonebookFile(
    IN PBFILE* pFile,
    IN TCHAR*  pszSectionToDelete );

DWORD
UpgradePhonebookFile(
    IN  TCHAR*  pszPhonebookPath,
    IN  PBUSER* pUser,
    OUT BOOL*   pfUpgraded );

BOOL
ValidateAreaCode(
    IN OUT TCHAR* pszAreaCode );

BOOL
ValidateEntryName(
    IN TCHAR* pszEntry );


#endif // _PBK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\nt4\inc\nouiutil.h ===
/* Copyright (c) 1995, Microsoft Corporation, all rights reserved
**
** nouiutil.h
** No UI helper routines (no HWNDs required)
** Public header
**
** 08/25/95 Steve Cobb
*/

#ifndef _NOUIUTIL_H_
#define _NOUIUTIL_H_

#define RASEAPINFO struct tagRASEAPINFO
RASEAPINFO
{
    DWORD dwSizeofEapInfo;
    BYTE  *pbEapInfo;
};

/* Maximum length of string returned by LToT without terminating null.
*/
#define MAXLTOTLEN 11

/* Heap allocation macros allowing easy substitution of alternate heap.  These
** are used by the other utility sections.
*/
#ifndef EXCL_HEAPDEFS
#define Malloc(c)    (void*)GlobalAlloc(0,(c))
#define Realloc(p,c) (void*)GlobalReAlloc((p),(c),GMEM_MOVEABLE)
#define Free(p)      (void* )GlobalFree(p)
#endif

/* Bits returned by GetInstalledProtocols.
*/
#define NP_Nbf 0x1
#define NP_Ipx 0x2
#define NP_Ip  0x4

/* Definition of comparison function required by ShellSort and
** ShellSortIndirect.
** The comparison is essentially <arg1> - <arg2>, thus the function should
** return negative if the first item is less than the second, zero
** if the items are equal, and positive if the first item is greater
** than the second.
*/
typedef INT (*PFNCOMPARE)( VOID*, VOID* );

/* Linked list library.
*/
#ifndef EXCL_DTL_H
#include <dtl.h>
#endif

/* International formatting library.
*/
#ifndef EXCL_INTL_H
#include <intl.h>
#endif

/* User preference library.
*/
#ifndef EXCL_PBUSER_H
#include <pbuser.h>
#endif

/* RasApi utility library.
*/
#ifndef EXCL_RAUTIL_H
#include <rautil.h>
#endif

/* RasMan utility library.
*/
#ifndef EXCL_RMUTIL_H
#include <rmutil.h>
#endif

/* RAS DLL entrypoint loader library.
*/
#ifndef EXCL_LOADDLLS_H
#include <loaddlls.h>
#endif


/*----------------------------------------------------------------------------
** Datatypes
**----------------------------------------------------------------------------
*/

/* Key/Value string pair.  The contents of a Kv node.
*/
#define KEYVALUE struct tagKEYVALUE
KEYVALUE
{
    TCHAR* pszKey;
    TCHAR* pszValue;
};

/* RAS-relevant Unimodem settings.
*/
#define UNIMODEMINFO struct tagUNIMODEMINFO
UNIMODEMINFO
{
    BOOL  fHwFlow;
    BOOL  fEc;
    BOOL  fEcc;
    DWORD dwBps;
    BOOL  fSpeaker;
    BOOL  fOperatorDial;
    BOOL  fUnimodemPreTerminal;
};


/*----------------------------------------------------------------------------
** Prototypes
**----------------------------------------------------------------------------
*/


INT
ComparePszNode(
    IN DTLNODE* pNode1,
    IN DTLNODE* pNode2 );

DTLNODE*
CreateKvNode(
    IN TCHAR* pszKey,
    IN TCHAR* pszValue );

DTLNODE*
CreatePszNode(
    IN TCHAR* psz );

VOID
DestroyKvNode(
    IN DTLNODE* pdtlnode );

VOID
DestroyPszNode(
    IN DTLNODE* pdtlnode );

BOOL
DeviceAndPortFromPsz(
    IN  TCHAR*  pszDP,
    OUT TCHAR** ppszDevice,
    OUT TCHAR** ppszPort );

DTLNODE*
DuplicatePszNode(
    IN DTLNODE* pdtlnode );

BOOL
FileExists(
    IN TCHAR* pszPath );

VOID*
Free0(
    VOID* p );

DWORD
GetInstalledProtocols(
    void );

CHAR
HexChar(
    IN BYTE byte );

BYTE
HexValue(
    IN CHAR byte );

BOOL
IsAllWhite(
    IN TCHAR* psz );

BOOL
IsNullTerminatedA(
    IN CHAR* psz,
    IN DWORD dwSize );

DWORD
GetRasUnimodemBlob(
    IN  HPORT  hport,
    IN  CHAR*  pszDeviceType,
    OUT BYTE** ppBlob,
    OUT DWORD* pcbBlob );

VOID
GetRasUnimodemInfo(
    IN  HPORT         hport,
    IN  CHAR*         pszDeviceType,
    OUT UNIMODEMINFO* pInfo );

TCHAR*
LToT(
    LONG   lValue,
    TCHAR* pszBuf,
    INT    nRadix );

TCHAR*
PszFromDeviceAndPort(
    IN TCHAR* pszDevice,
    IN TCHAR* pszPort );

BOOL
RestartComputer();

TCHAR*
StripPath(
    IN TCHAR* pszPath );

LONG
TToL(
    TCHAR *pszBuf );

TCHAR*
PszFromError(
    IN DWORD dwError );

TCHAR*
PszFromId(
    IN HINSTANCE hInstance,
    IN DWORD     dwStringId );

BOOL
RestartComputer();

VOID
SanitizeUnimodemBlob(
    IN OUT BYTE* pBlob );

VOID
SetDefaultUnimodemInfo(
    OUT UNIMODEMINFO* pInfo );

HFONT
SetFont(
    HWND   hwndCtrl,
    TCHAR* pszFaceName,
    BYTE   bfPitchAndFamily,
    INT    nPointSize,
    BOOL   fUnderline,
    BOOL   fStrikeout,
    BOOL   fItalic,
    BOOL   fBold );

DWORD
ShellSort(
    IN VOID*        pItemTable,
    IN DWORD        dwItemSize,
    IN DWORD        dwItemCount,
    IN PFNCOMPARE   pfnCompare );

VOID
ShellSortIndirect(
    IN VOID*        pItemTable,
    IN VOID**       ppItemTable,
    IN DWORD        dwItemSize,
    IN DWORD        dwItemCount,
    IN PFNCOMPARE   pfnCompare );

TCHAR*
StrDup(
    TCHAR* psz );

CHAR*
StrDupAFromT(
    TCHAR* psz );

TCHAR*
StrDupTFromA(
    CHAR* psz );

TCHAR*
StrDupTFromW(
    WCHAR* psz );

WCHAR*
StrDupWFromA(
    CHAR* psz );

WCHAR*
StrDupWFromT(
    TCHAR* psz );

int
StrNCmpA(
    IN CHAR* psz1,
    IN CHAR* psz2,
    IN INT   nLen );

CHAR*
StrStrA(
    IN CHAR* psz1,
    IN CHAR* psz2 );

VOID
UnimodemInfoFromBlob(
    IN  BYTE*         pBlob,
    OUT UNIMODEMINFO* pInfo );

VOID
UnimodemInfoToBlob(
    IN     UNIMODEMINFO* pInfo,
    IN OUT BYTE*         pBlob );


#endif // _NOUIUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\nt4\inc\pbuser.h ===
/* Copyright (c) 1995, Microsoft Corporation, all rights reserved
**
** pbuser.h
** Remote Access phonebook user preference library
** Public header
**
** 06/20/95 Steve Cobb
*/

#ifndef _PBUSER_H_
#define _PBUSER_H_

/*----------------------------------------------------------------------------
** Constants
**----------------------------------------------------------------------------
*/

/* User preference modes
*/
#define UPM_Normal 0
#define UPM_Logon  1
#define UPM_Router 2


/* User preference key and values.
*/
#define REGKEY_HkcuOldRas                TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Network\\RemoteAccess")
#define REGKEY_HkcuOldRasParent          TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Network")
#define REGKEY_HkcuOldRasRoot            TEXT("RemoteAccess")
#define REGKEY_HkuOldRasLogon            TEXT(".DEFAULT\\Software\\Microsoft\\RAS Phonebook")
#define REGKEY_HkcuRas                   TEXT("Software\\Microsoft\\RAS Phonebook")
#define REGKEY_HkuRasLogon               TEXT(".DEFAULT\\Software\\Microsoft\\RAS Logon Phonebook")
#define REGKEY_HklmRouter                TEXT("Software\\Microsoft\\Router Phonebook")
#define REGKEY_Callback                  TEXT("Callback")
#define REGKEY_Location                  TEXT("Location")
#define REGVAL_szNumber                  TEXT("Number")
#define REGVAL_dwDeviceType              TEXT("DeviceType")
#define REGVAL_dwPhonebookMode           TEXT("PhonebookMode")
#define REGVAL_szUsePersonalPhonebook    TEXT("UsePersonalPhonebook")
#define REGVAL_szPersonalPhonebookPath   TEXT("PersonalPhonebookPath")
#define REGVAL_szPersonalPhonebookFile   TEXT("PersonalPhonebookFile")
#define REGVAL_szAlternatePhonebookPath  TEXT("AlternatePhonebookPath")
#define REGVAL_fOperatorDial             TEXT("OperatorDial")
#define REGVAL_fPreviewPhoneNumber       TEXT("PreviewPhoneNumber")
#define REGVAL_fUseLocation              TEXT("UseLocation")
#define REGVAL_fShowLights               TEXT("ShowLights")
#define REGVAL_fShowConnectStatus        TEXT("ShowConnectStatus")
#define REGVAL_fNewEntryWizard           TEXT("NewEntryWizard")
#define REGVAL_dwRedialAttempts          TEXT("RedialAttempts")
#define REGVAL_dwRedialSeconds           TEXT("RedialSeconds")
#define REGVAL_dwIdleDisconnectSeconds   TEXT("IdleHangUpSeconds")
#define REGVAL_dwCallbackMode            TEXT("CallbackMode")
#define REGVAL_mszPhonebooks             TEXT("Phonebooks")
#define REGVAL_mszAreaCodes              TEXT("AreaCodes")
#define REGVAL_mszPrefixes               TEXT("Prefixes")
#define REGVAL_mszSuffixes               TEXT("Suffixes")
#define REGVAL_szLastCallbackByCaller    TEXT("LastCallbackByCaller")
#define REGVAL_dwPrefix                  TEXT("Prefix")
#define REGVAL_dwSuffix                  TEXT("Suffix")
#define REGVAL_dwXWindow                 TEXT("WindowX")
#define REGVAL_dwYWindow                 TEXT("WindowY")
#define REGVAL_szDefaultEntry            TEXT("DefaultEntry")
#define REGVAL_fCloseOnDial              TEXT("CloseOnDial")
#define REGVAL_fAllowLogonPhonebookEdits TEXT("AllowLogonPhonebookEdits")
#define REGVAL_fAllowLogonLocationEdits  TEXT("AllowLogonLocationEdits")
#define REGVAL_fUseAreaAndCountry        TEXT("UseAreaAndCountry")
#define REGKEY_Rasmon                    TEXT("Software\\Microsoft\\RAS Monitor")
#define REGVAL_dwMode                    TEXT("Mode")
#define REGVAL_dwFlags                   TEXT("Flags")
#define REGVAL_dwX                       TEXT("x")
#define REGVAL_dwY                       TEXT("y")
#define REGVAL_dwCx                      TEXT("cx")
#define REGVAL_dwCy                      TEXT("cy")
#define REGVAL_dwCxCol1                  TEXT("cxCol1")
#define REGVAL_dwStartPage               TEXT("StartPage")
#define REGVAL_dwXDlg                    TEXT("xDlg")
#define REGVAL_dwYDlg                    TEXT("yDlg")
#define REGVAL_dwCxDlgCol1               TEXT("cxDlgCol1")
#define REGVAL_dwCxDlgCol2               TEXT("cxDlgCol2")
#define REGVAL_szLastDevice              TEXT("LastDevice")
#define REGVAL_mszDeviceList             TEXT("DeviceList")
#define REGVAL_fSkipConnectComplete      TEXT("SkipConnectComplete")
#define REGVAL_fRedialOnLinkFailure      TEXT("RedialOnLinkFailure")
#define REGVAL_fExpandAutoDialQuery      TEXT("ExpandAutoDialQuery")
#define REGVAL_fPopupOnTopWhenRedialing  TEXT("PopupOnTopWhenRedialing")
#define REGVAL_dwVersion                 TEXT("Version")


/* Callback modes (see dwCallbackMode below).
*/
#define CBM_No    0
#define CBM_Maybe 1
#define CBM_Yes   2


/* Phonebook modes (see dwPhonebookMode below).
*/
#define PBM_System    0
#define PBM_Personal  1
#define PBM_Alternate 2


/* RASMON Preferences constants;
*/

/* Display Mode constants
*/

#define RMDM_Desktop            0x0
#define RMDM_Taskbar            0x1


/* Flags values
*/

#define RMFLAG_SoundOnConnect           0x00000001
#define RMFLAG_SoundOnDisconnect        0x00000002
#define RMFLAG_SoundOnTransmit          0x00000004
#define RMFLAG_SoundOnError             0x00000008
#define RMFLAG_Topmost                  0x00000010
#define RMFLAG_Titlebar                 0x00000020
#define RMFLAG_Tasklist                 0x00000040
#define RMFLAG_Header                   0x00000080
#define RMFLAG_AllDevices               0x00000100


/* RASMON refresh rate in milliseconds
*/

#define RMRR_RefreshRate        250



/*----------------------------------------------------------------------------
** Datatypes
**----------------------------------------------------------------------------
*/

/* Information about a callback number.  See 'PBUSER.pdtllistCallback'.  Note
** that 'dwDeviceType' is a PBK PBDEVICETYPE enumeration cast to a DWORD.
*/
#define CALLBACKINFO struct tagCALLBACKINFO
CALLBACKINFO
{
    TCHAR* pszPortName;
    TCHAR* pszDeviceName;
    TCHAR* pszNumber;
    DWORD  dwDeviceType;
};


/* Information associated with a TAPI location number.
*/
#define LOCATIONINFO struct tagLOCATIONINFO
LOCATIONINFO
{
    DWORD  dwLocationId;
    DWORD  iPrefix;
    DWORD  iSuffix;
};


/* User preference information read from the "CURRENT_USER" registry.  This
** information applies to all "normal" user phonebooks plus the system
** phonebook.  The router phonebook may work differently.
*/
#define PBUSER struct tagPBUSER
PBUSER
{
    /* Appearance page.
    */
    BOOL fOperatorDial;
    BOOL fPreviewPhoneNumber;
    BOOL fUseLocation;
    BOOL fShowLights;
    BOOL fShowConnectStatus;
    BOOL fCloseOnDial;
    BOOL fAllowLogonPhonebookEdits;
    BOOL fAllowLogonLocationEdits;
    BOOL fSkipConnectComplete;
    BOOL fNewEntryWizard;

    /* Auto-dial page.
    */
    DWORD dwRedialAttempts;
    DWORD dwRedialSeconds;
    DWORD dwIdleDisconnectSeconds;
    BOOL  fRedialOnLinkFailure;
    BOOL  fPopupOnTopWhenRedialing;
    BOOL  fExpandAutoDialQuery;

    /* Callback page.
    **
    ** This list is of CALLBACKINFO.
    */
    DWORD    dwCallbackMode;
    DTLLIST* pdtllistCallback;
    TCHAR*   pszLastCallbackByCaller;

    /* Phone list page.
    */
    DWORD    dwPhonebookMode;
    TCHAR*   pszPersonalFile;
    TCHAR*   pszAlternatePath;
    DTLLIST* pdtllistPhonebooks;

    /* Area code strings, in MRU order.
    */
    DTLLIST* pdtllistAreaCodes;
    BOOL     fUseAreaAndCountry;

    /* Prefix/suffix information, i.e. the ordered string lists and the
    ** settings for a particular TAPI location.
    */
    DTLLIST* pdtllistPrefixes;
    DTLLIST* pdtllistSuffixes;
    DTLLIST* pdtllistLocations;

    /* Phonebook window position and last entry selected used by RASPHONE.EXE.
    */
    DWORD  dwXPhonebook;
    DWORD  dwYPhonebook;
    TCHAR* pszDefaultEntry;

    /* Set true if the structure has been initialized.
    */
    BOOL fInitialized;

    /* Set true if something's changed since the structure was read.
    */
    BOOL fDirty;
};


/* RASMON user preference information read from the "CURRENT_USER" registry.
*/
#define RMUSER struct tagRMUSER
RMUSER
{

    /* Display Mode (desktop or taskbar)
    */
    DWORD dwMode;

    /* Flags field:
    ** RMFLAG_Sound*:       sounds (connect, disconnect, transmission, errors)
    ** RMFLAG_Topmost:      make window topmost
    ** RMFLAG_Titlebar:     show titlebar
    ** RMFLAG_Tasklist:     include in tasklist
    ** RMFLAG_Header:       show header-control
    ** RMFLAG_AllDevices:   show a set of master lights (for all devices).
    */
    DWORD dwFlags;

    /* Names of devices for which status should be displayed;
    ** This is a null-terminated list of null-terminated strings.
    */
    TCHAR *pszzDeviceList;

    /* Screen position variables for desktop display mode
    */
    INT x;
    INT y;
    INT cx;
    INT cy;

    /* Saved width of left column in desktop window
    */
    INT cxCol1;

    /* Screen position for Dial-Up Networking Monitor property sheet
    /* and saved widths of the treelist columns in Summary property page 
    */
    INT xDlg;
    INT yDlg;
    INT cxDlgCol1;
    INT cxDlgCol2;

    /* Starting page for property sheet
    */
    DWORD dwStartPage;

    /* Name of device last selected on Status page
    */
    TCHAR *pszLastDevice;

};



/*----------------------------------------------------------------------------
** Prototypes
**----------------------------------------------------------------------------
*/

DTLNODE*
CreateLocationNode(
    IN DWORD dwLocationId,
    IN DWORD iPrefix,
    IN DWORD iSuffix );

DTLNODE*
CreateCallbackNode(
    IN TCHAR* pszPortName,
    IN TCHAR* pszDeviceName,
    IN TCHAR* pszNumber,
    IN DWORD  dwDeviceType );

VOID
DestroyLocationNode(
    IN DTLNODE* pNode );

VOID
DestroyCallbackNode(
    IN DTLNODE* pNode );

VOID
DestroyUserPreferences(
    IN PBUSER* pUser );

DTLNODE*
DuplicateLocationNode(
    IN DTLNODE* pNode );

DWORD
GetUserPreferences(
    OUT PBUSER* pUser,
    IN  DWORD   dwMode );

DWORD
SetUserPreferences(
    IN PBUSER* pUser,
    IN DWORD   dwMode );

DWORD
GetRasmonPreferences(
    OUT RMUSER* pUser );

DWORD
SetRasmonPreferences(
    IN  RMUSER* pUser );

DWORD
SetRasmonDlgPreferences(
    IN  RMUSER* pUser );

DWORD
SetRasmonUserPreferences(
    IN  RMUSER* pUser );

DWORD
SetRasmonWndPreferences(
    IN  RMUSER* pUser );

VOID
DestroyRasmonPreferences(
    IN  RMUSER* pUser );

#endif // _PBUSER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\nt4\inc\rnk.h ===
/* Copyright (c) 1996, Microsoft Corporation, all rights reserved
**
** rnk.h
** Remote Access shortcut file (.RNK) library
** Public header
**
** 02/15/96 Steve Cobb
*/

#ifndef _RNK_H_
#define _RNK_H_


/*----------------------------------------------------------------------------
** Constants
**----------------------------------------------------------------------------
*/

#define RNK_SEC_Main      "Dial-Up Shortcut"
#define RNK_KEY_Phonebook "Phonebook"
#define RNK_KEY_Entry     "Entry"


/*----------------------------------------------------------------------------
** Datatypes
**----------------------------------------------------------------------------
*/

/* Information read from the .RNK file.
*/
#define RNKINFO struct tagRNKINFO
RNKINFO
{
    TCHAR* pszPhonebook;
    TCHAR* pszEntry;
};


/*----------------------------------------------------------------------------
** Prototypes
**----------------------------------------------------------------------------
*/

VOID
FreeRnkInfo(
    IN RNKINFO* pInfo );

RNKINFO*
ReadShortcutFile(
    IN TCHAR* pszRnkPath );

DWORD
WriteShortcutFile(
    IN TCHAR* pszRnkPath,
    IN TCHAR* pszPbkPath,
    IN TCHAR* pszEntry );


#endif // _RNK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\nt4\inc\tapiutil.h ===
/* Copyright (c) 1996, Microsoft Corporation, all rights reserved
**
** tapiutil.h
** TAPI helper routines
** Public header
**
** 06/18/95 Steve Cobb
*/

#ifndef _TAPIUTIL_H_
#define _TAPIUTIL_H_


#include <tapi.h>


/*----------------------------------------------------------------------------
** Datatypes
**----------------------------------------------------------------------------
*/

/* Information about a TAPI location.  See GetLocationInfo.
*/
#define LOCATION struct tagLOCATION
LOCATION
{
    TCHAR* pszName;
    DWORD  dwId;
};


/* Information about a TAPI country.  See GetCountryInfo.
*/
#define COUNTRY struct tagCOUNTRY
COUNTRY
{
    TCHAR* pszName;
    DWORD  dwId;
    DWORD  dwCode;
};


/*----------------------------------------------------------------------------
** Prototypes (alphabetically)
**----------------------------------------------------------------------------
*/

VOID
FreeCountryInfo(
    IN COUNTRY* pCountries,
    IN DWORD    cCountries );

VOID
FreeLocationInfo(
    IN LOCATION* pLocations,
    IN DWORD     cLocations );

DWORD
GetCountryInfo(
    OUT COUNTRY** ppCountries,
    OUT DWORD*    pcCountries,
    IN  DWORD     dwCountryID );

DWORD
GetCurrentLocation(
    IN     HINSTANCE hInst,
    IN OUT HLINEAPP* pHlineapp );

DWORD
GetLocationInfo(
    IN     HINSTANCE  hInst,
    IN OUT HLINEAPP*  pHlineapp,
    OUT    LOCATION** ppLocations,
    OUT    DWORD*     pcLocations,
    OUT    DWORD*     pdwCurLocation );

DWORD
SetCurrentLocation(
    IN     HINSTANCE hInst,
    IN OUT HLINEAPP* pHlineapp,
    IN     DWORD     dwLocationId );

DWORD
TapiConfigureDlg(
    IN     HWND   hwndOwner,
    IN     DWORD  dwDeviceId,
    IN OUT BYTE** ppBlob,
    IN OUT DWORD* pcbBlob );

DWORD
TapiInit(
    IN     HINSTANCE hInst,
    IN OUT HLINEAPP* pHlineapp,
    OUT    DWORD*    pcDevices );

DWORD
TapiLocationDlg(
    IN     HINSTANCE hInst,
    IN OUT HLINEAPP* pHlineapp,
    IN     HWND      hwndOwner,
    IN     DWORD     dwCountryCode,
    IN     TCHAR*    pszAreaCode,
    IN     TCHAR*    pszPhoneNumber,
    IN     DWORD     dwDeviceId );

DWORD APIENTRY
TapiNewLocation(
    IN TCHAR* pszName );

DWORD
TapiNoLocationDlg(
    IN HINSTANCE hInst,
    IN HLINEAPP* pHlineapp,
    IN HWND      hwndOwner );

DWORD APIENTRY
TapiRemoveLocation(
    IN DWORD dwID );

DWORD APIENTRY
TapiRenameLocation(
    IN TCHAR* pszOldName,
    IN TCHAR* pszNewName );

DWORD
TapiShutdown(
    IN HLINEAPP hlineapp );

DWORD
TapiTranslateAddress(
    IN     HINSTANCE hInst,
    IN OUT HLINEAPP* pHlineapp,
    IN     DWORD     dwCountryCode,
    IN     TCHAR*    pszAreaCode,
    IN     TCHAR*    pszPhoneNumber,
    IN     DWORD     dwDeviceId,
    IN     BOOL      fDialable,
    OUT    TCHAR**   ppszResult );


#endif // _TAPIUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\nt4\inc\rasp.h ===
/* Copyright (c) 1992, Microsoft Corporation, all rights reserved
**
** rasp.h
** Remote Access external API
** Private header for external API clients
*/

#ifndef _RASP_H_
#define _RASP_H_

/* Trusted entry points used by RASPHONE.
*/
HPORT    APIENTRY RasGetHport( HRASCONN );
HRASCONN APIENTRY RasGetHrasconn( HPORT );
VOID     APIENTRY RasGetConnectResponse( HRASCONN, CHAR* );
DWORD    APIENTRY RasSetNewPassword( HRASCONN, CHAR* );


/*----------------------------------------------------------------------------
** Off-version ras.h definitions
**----------------------------------------------------------------------------
*/

#include "pshpack4.h"

/* RAS structures as they appear to a caller in previous releases.  These are
** defined here because RASAPI32 needs to be able to access both old and new
** definitions in the same code.
*/

/* Windows NT 3.51 definitions.
*/

#define RAS_MaxEntryName_V351      20
#define RAS_MaxDeviceName_V351     32
#define RAS_MaxCallbackNumber_V351 48

/* Identifies an active RAS connection.  (See RasEnumConnections)
*/
#define RASCONNW_V351 struct tagRASCONNW_V351
RASCONNW_V351
{
    DWORD    dwSize;
    HRASCONN hrasconn;
    WCHAR    szEntryName[ RAS_MaxEntryName_V351 + 1 ];
};

#define RASCONNA_V351 struct tagRASCONNA_V351
RASCONNA_V351
{
    DWORD    dwSize;
    HRASCONN hrasconn;
    CHAR     szEntryName[ RAS_MaxEntryName_V351 + 1 ];
};

#define RASCONNW_V400 struct tagRASCONNW_V400
RASCONNW_V400
{
    DWORD    dwSize;
    HRASCONN hrasconn;
    WCHAR    szEntryName[ RAS_MaxEntryName + 1 ];
    WCHAR    szDeviceType[ RAS_MaxDeviceType + 1 ];
    WCHAR    szDeviceName[ RAS_MaxDeviceName + 1 ];
};

#define RASCONNA_V400 struct tagRASCONNA_V400
RASCONNA_V400
{
    DWORD    dwSize;
    HRASCONN hrasconn;
    CHAR     szEntryName[ RAS_MaxEntryName + 1 ];
    CHAR     szDeviceType[ RAS_MaxDeviceType + 1 ];
    CHAR     szDeviceName[ RAS_MaxDeviceName + 1 ];
};

/* Describes the status of a RAS connection.  (See RasConnectionStatus)
*/
#define RASCONNSTATUSW_V351 struct tagRASCONNSTATUSW_V351
RASCONNSTATUSW_V351
{
    DWORD        dwSize;
    RASCONNSTATE rasconnstate;
    DWORD        dwError;
    WCHAR        szDeviceType[ RAS_MaxDeviceType + 1 ];
    WCHAR        szDeviceName[ RAS_MaxDeviceName_V351 + 1 ];
};

#define RASCONNSTATUSA_V351 struct tagRASCONNSTATUSA_V351
RASCONNSTATUSA_V351
{
    DWORD        dwSize;
    RASCONNSTATE rasconnstate;
    DWORD        dwError;
    CHAR         szDeviceType[ RAS_MaxDeviceType + 1 ];
    CHAR         szDeviceName[ RAS_MaxDeviceName_V351 + 1 ];
};

#define RASCONNSTATUSW_V400 struct tagRASCONNSTATUSW_V400
RASCONNSTATUSW_V400
{
    DWORD        dwSize;
    RASCONNSTATE rasconnstate;
    DWORD        dwError;
    WCHAR        szDeviceType[ RAS_MaxDeviceType + 1 ];
    WCHAR        szDeviceName[ RAS_MaxDeviceName + 1 ];
};

#define RASCONNSTATUSA_V400 struct tagRASCONNSTATUSA_V400
RASCONNSTATUSA_V400
{
    DWORD        dwSize;
    RASCONNSTATE rasconnstate;
    DWORD        dwError;
    CHAR         szDeviceType[ RAS_MaxDeviceType + 1 ];
    CHAR         szDeviceName[ RAS_MaxDeviceName + 1 ];
};

/* Describes connection establishment parameters.  (See RasDial)
*/
#define RASDIALPARAMSW_V351 struct tagRASDIALPARAMSW_V351
RASDIALPARAMSW_V351
{
    DWORD dwSize;
    WCHAR szEntryName[ RAS_MaxEntryName_V351 + 1 ];
    WCHAR szPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    WCHAR szCallbackNumber[ RAS_MaxCallbackNumber_V351 + 1 ];
    WCHAR szUserName[ UNLEN + 1 ];
    WCHAR szPassword[ PWLEN + 1 ];
    WCHAR szDomain[ DNLEN + 1 ];
};

#define RASDIALPARAMSA_V351 struct tagRASDIALPARAMSA_V351
RASDIALPARAMSA_V351
{
    DWORD dwSize;
    CHAR  szEntryName[ RAS_MaxEntryName_V351 + 1 ];
    CHAR  szPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    CHAR  szCallbackNumber[ RAS_MaxCallbackNumber_V351 + 1 ];
    CHAR  szUserName[ UNLEN + 1 ];
    CHAR  szPassword[ PWLEN + 1 ];
    CHAR  szDomain[ DNLEN + 1 ];
};

#define RASDIALPARAMSW_V400 struct tagRASDIALPARAMSW_V400
RASDIALPARAMSW_V400
{
    DWORD dwSize;
    WCHAR szEntryName[ RAS_MaxEntryName + 1 ];
    WCHAR szPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    WCHAR szCallbackNumber[ RAS_MaxCallbackNumber + 1 ];
    WCHAR szUserName[ UNLEN + 1 ];
    WCHAR szPassword[ PWLEN + 1 ];
    WCHAR szDomain[ DNLEN + 1 ];
};

#define RASDIALPARAMSA_V400 struct tagRASDIALPARAMSA_V400
RASDIALPARAMSA_V400
{
    DWORD dwSize;
    CHAR  szEntryName[ RAS_MaxEntryName + 1 ];
    CHAR  szPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    CHAR  szCallbackNumber[ RAS_MaxCallbackNumber + 1 ];
    CHAR  szUserName[ UNLEN + 1 ];
    CHAR  szPassword[ PWLEN + 1 ];
    CHAR  szDomain[ DNLEN + 1 ];
};

/* Describes an enumerated RAS phone book entry name.  (See RasEntryEnum)
*/
#define RASENTRYNAMEW_V351 struct tagRASENTRYNAMEW_V351
RASENTRYNAMEW_V351
{
    DWORD dwSize;
    WCHAR szEntryName[ RAS_MaxEntryName_V351 + 1 ];
};

#define RASENTRYNAMEA_V351 struct tagRASENTRYNAMEA_V351
RASENTRYNAMEA_V351
{
    DWORD dwSize;
    CHAR  szEntryName[ RAS_MaxEntryName_V351 + 1 ];
};

/* A RAS phone book entry.
*/
#define RASENTRYW_V400 struct tagRASENTRYW_V400
RASENTRYW_V400
{
    DWORD       dwSize;
    DWORD       dwfOptions;
    //
    // Location/phone number
    //
    DWORD       dwCountryID;
    DWORD       dwCountryCode;
    WCHAR       szAreaCode[ RAS_MaxAreaCode + 1 ];
    WCHAR       szLocalPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    DWORD       dwAlternateOffset;
    //
    // PPP/Ip
    //
    RASIPADDR   ipaddr;
    RASIPADDR   ipaddrDns;
    RASIPADDR   ipaddrDnsAlt;
    RASIPADDR   ipaddrWins;
    RASIPADDR   ipaddrWinsAlt;
    //
    // Framing
    //
    DWORD       dwFrameSize;
    DWORD       dwfNetProtocols;
    DWORD       dwFramingProtocol;
    //
    // Scripting
    //
    WCHAR       szScript[ MAX_PATH ];
    //
    // AutoDial
    //
    WCHAR       szAutodialDll[ MAX_PATH ];
    WCHAR       szAutodialFunc[ MAX_PATH ];
    //
    // Device
    //
    WCHAR       szDeviceType[ RAS_MaxDeviceType + 1 ];
    WCHAR       szDeviceName[ RAS_MaxDeviceName + 1 ];
    //
    // X.25
    //
    WCHAR       szX25PadType[ RAS_MaxPadType + 1 ];
    WCHAR       szX25Address[ RAS_MaxX25Address + 1 ];
    WCHAR       szX25Facilities[ RAS_MaxFacilities + 1 ];
    WCHAR       szX25UserData[ RAS_MaxUserData + 1 ];
    DWORD       dwChannels;
    //
    // Reserved
    //
    DWORD       dwReserved1;
    DWORD       dwReserved2;
};


#define RASENTRYA_V400 struct tagRASENTRYA_V400
RASENTRYA_V400
{
    DWORD       dwSize;
    DWORD       dwfOptions;
    //
    // Location/phone number.
    //
    DWORD       dwCountryID;
    DWORD       dwCountryCode;
    CHAR        szAreaCode[ RAS_MaxAreaCode + 1 ];
    CHAR        szLocalPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    DWORD       dwAlternateOffset;
    //
    // PPP/Ip
    //
    RASIPADDR   ipaddr;
    RASIPADDR   ipaddrDns;
    RASIPADDR   ipaddrDnsAlt;
    RASIPADDR   ipaddrWins;
    RASIPADDR   ipaddrWinsAlt;
    //
    // Framing
    //
    DWORD       dwFrameSize;
    DWORD       dwfNetProtocols;
    DWORD       dwFramingProtocol;
    //
    // Scripting
    //
    CHAR        szScript[ MAX_PATH ];
    //
    // AutoDial
    //
    CHAR        szAutodialDll[ MAX_PATH ];
    CHAR        szAutodialFunc[ MAX_PATH ];
    //
    // Device
    //
    CHAR        szDeviceType[ RAS_MaxDeviceType + 1 ];
    CHAR        szDeviceName[ RAS_MaxDeviceName + 1 ];
    //
    // X.25
    //
    CHAR        szX25PadType[ RAS_MaxPadType + 1 ];
    CHAR        szX25Address[ RAS_MaxX25Address + 1 ];
    CHAR        szX25Facilities[ RAS_MaxFacilities + 1 ];
    CHAR        szX25UserData[ RAS_MaxUserData + 1 ];
    DWORD       dwChannels;
    //
    // Reserved
    //
    DWORD       dwReserved1;
    DWORD       dwReserved2;
};


/* RAS structures as they appeared in NT 3.5 prior to 3.51 additions.
*/


/* Windows NT 3.5 definitions.
*/

/* Describes the results of a PPP IP (Internet) projection.
*/
#define RASPPPIPW_V35 struct tagRASPPPIPW_V35
RASPPPIPW_V35
{
    DWORD dwSize;
    DWORD dwError;
    WCHAR szIpAddress[ RAS_MaxIpAddress + 1 ];
};

#define RASPPPIPA_V35 struct tagRASPPPIPA_V35
RASPPPIPA_V35
{
    DWORD dwSize;
    DWORD dwError;
    CHAR  szIpAddress[ RAS_MaxIpAddress + 1 ];
};


#include "poppack.h"


#endif /*_RASP_H_*/

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\nt4\inc\rautil.h ===
/* Copyright (c) 1995, Microsoft Corporation, all rights reserved
**
** rautil.h
** Remote Access RASAPI utility library
** Public header
**
** 12/26/95 Steve Cobb
*/

#ifndef _RAUTIL_H_
#define _RAUTIL_H_


#include <list.h>    // for LIST_ENTRY definitions
#include <serial.h>  // RAS serial media header, for SERIAL_TXT
#include <isdn.h>    // RAS ISDN media header, for ISDN_TXT
#include <x25.h>     // RAS X.25 media header, for X25_TXT
#include <rasmxs.h>  // RAS modem/X.25/switch device header, for MXS_*_TXT
#include <ras.h>     // Win32 RAS header, for constants


/*----------------------------------------------------------------------------
** Prototypes
**----------------------------------------------------------------------------
*/

DWORD
FreeRasconnList(
    LIST_ENTRY *pListHead );

DWORD
GetRasconnList(
    LIST_ENTRY *pListHead );

DWORD
GetRasconnTable(
    OUT RASCONN** ppConnTable,
    OUT DWORD*    pdwConnCount );

DWORD
GetRasEntrynameTable(
    OUT RASENTRYNAME**  ppEntrynameTable,
    OUT DWORD*          pdwEntrynameCount );

DWORD
GetRasProjectionInfo(
    IN  HRASCONN    hrasconn,
    OUT RASAMB*     pamb,
    OUT RASPPPNBF*  pnbf,
    OUT RASPPPIP*   pip,
    OUT RASPPPIPX*  pipx,
    OUT RASPPPLCP*  plcp,
    OUT RASSLIP*    pslip );

HRASCONN
HrasconnFromEntry(
    IN TCHAR* pszPhonebook,
    IN TCHAR* pszEntry );


#endif // _RAUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\nt4\inc\x25.h ===
/* Copyright (c) 1995, Microsoft Corporation, all rights reserved
**
** x25.h
** Remote Access Connection Manager
** Native X.25 media/device header
*/


#ifndef _X25MEDIA_
#define _X25MEDIA_


/* Media/device identification string.
*/
#define X25_TXT "x25"

/* Device parameter key strings.
*/
#define X25_ADDRESS_KEY    "X25Address"
#define X25_USERDATA_KEY   "UserData"
#define X25_FACILITIES_KEY "Facilities"


#endif // _X25MEDIA_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\nt4\inc\rmmem.h ===
/* Copyright (c) 1996, Microsoft Corporation, all rights reserved
**
** rmmem.h
** RASDLG<->RASMON shared memory
** Public header
**
** 03/05/96 Steve Cobb
** 03/14/96 Abolade Gbadegesin  -   Added RMMEMRASMON
**                                  Changed RMMEMNAME to RMMEMRASPHONE
*/

#ifndef _RMMEM_H_
#define _RMMEM_H_


/* Names of the memory blocks shared by RASDLG.DLL, RASMON.EXE,
** and RASPHONE.EXE. Each of these blocks contains an RMMEM structure.
**
** RMMEMRASMON is created by RASMON.EXE
** RMMEMRASPHONE is created by RASPHONE.EXE
*/
#define RMMEMRASMON     TEXT("RASMON")
#define RMMEMRASPHONE   TEXT("RASPHONE")
#define RMMEMRASMONDLG  TEXT("RASMONDLG")


/* Shared memory used to pass information between RASDLG.DLL, RASMON.EXE,
** and RASPHONE.EXE.
** 'Hwnd' contains the handle of a window associated with the process.
** 'Pid' contains the process ID. (This value can be passed to OpenProcess).
*/
#define RMMEM struct tagRMMEM
RMMEM
{
    HWND  hwnd;
    DWORD pid;
};


/* Name for mutex used by xxInstancexx functions (GetInstanceMap, etc)
*/
#define INSTANCEMUTEXNAME   TEXT("InstanceMutex")


/* The following functions all deal with shared-memory blocks
** which contain RMMEM structures.
*/

HANDLE
ActivatePreviousInstance(
    IN HWND     hwnd,
    IN PTSTR    pszName );

HWND 
GetInstanceHwnd(
    IN  HANDLE  hMap );

HANDLE
GetInstanceMap(
    IN  PTSTR   pszName );

DWORD
GetInstancePid(
    IN  HANDLE  hMap );

DWORD
SetInstanceHwnd(
    IN  HANDLE  hMap,
    IN  HWND    hwnd );


#endif // _RMMEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\nt4\inc\rmutil.h ===
/* Copyright (c) 1995, Microsoft Corporation, all rights reserved
**
** rmutil.h
** Remote Access RASMAN utility library
** Public header
**
** 06/20/95 Steve Cobb
** 12/26/95 Merge Abolade Gbadesin routines
*/

#ifndef _RMUTIL_H_
#define _RMUTIL_H_


#include <rasman.h>  // RAS connection manager header
#include <serial.h>  // RAS serial media header, for SERIAL_TXT
#include <isdn.h>    // RAS ISDN media header, for ISDN_TXT
#include <x25.h>     // RAS X.25 media header, for X25_TXT
#include <rasmxs.h>  // RAS modem/X.25/switch device header, for MXS_*_TXT
#include <ras.h>     // Win32 RAS header, for constants

/* Private RASAPI32 entrypoints.
*/
extern HPORT APIENTRY RasGetHport( HRASCONN );
extern DWORD APIENTRY RasSetOldPassword( HRASCONN, CHAR* );


/*----------------------------------------------------------------------------
** Constants
**----------------------------------------------------------------------------
*/

/* String translation flags.
*/
#define XLATE_Ctrl      0x00000001
#define XLATE_Cr        0x00000002
#define XLATE_CrSpecial 0x00000004
#define XLATE_Lf        0x00000008
#define XLATE_LfSpecial 0x00000010
#define XLATE_LAngle    0x00000020
#define XLATE_RAngle    0x00000040
#define XLATE_BSlash    0x00000080
#define XLATE_SSpace    0x00000100

#define XLATE_None          0
#define XLATE_Diagnostic    (XLATE_Ctrl)
#define XLATE_ErrorResponse (XLATE_Ctrl | XLATE_LAngle | XLATE_RAngle \
                               | XLATE_BSlash | XLATE_CrSpecial \
                               | XLATE_LfSpecial)

/*----------------------------------------------------------------------------
** Datatypes
**----------------------------------------------------------------------------
*/
struct RASDEV {

    DWORD           RD_Handle;
    DWORD           RD_Flags;
    PTSTR           RD_DeviceName;
    TCHAR           RD_PortName[MAX_PORT_NAME + 1];
    TCHAR           RD_DeviceType[RAS_MaxDeviceType + 1];

};

typedef struct RASDEV RASDEV, *PRASDEV, FAR *LPRASDEV;

#define RDFLAG_DialIn       0x00000001
#define RDFLAG_DialOut      0x00000002
#define RDFLAG_Router       0x00000004
#define RDFLAG_IsDialedIn   0x00000008
#define RDFLAG_IsDialedOut  0x00000010
#define RDFLAG_IsRouter     0x00000020
#define RDFLAG_User1        0x80000000


struct RASDEVSTATS {

    DWORD           RDS_Condition;
    DWORD           RDS_Flags;
    DWORD           RDS_LineSpeed;
    DWORD           RDS_ConnectTime;
    DWORD           RDS_InBytes;
    DWORD           RDS_InFrames;
    DWORD           RDS_InCompRatio;
    DWORD           RDS_OutBytes;
    DWORD           RDS_OutFrames;
    DWORD           RDS_OutCompRatio;
    DWORD           RDS_InBytesTotal;
    DWORD           RDS_OutBytesTotal;
    DWORD           RDS_ErrCRC;
    DWORD           RDS_ErrTimeout;
    DWORD           RDS_ErrAlignment;
    DWORD           RDS_ErrFraming;
    DWORD           RDS_ErrHwOverruns;
    DWORD           RDS_ErrBufOverruns;
    HRASCONN        RDS_Hrasconn;

};

typedef struct RASDEVSTATS RASDEVSTATS, *PRASDEVSTATS;


struct RASCONNENTRY {

    LIST_ENTRY      RCE_Node;
    RASCONN        *RCE_Entry;
    LIST_ENTRY      RCE_Links;

};

typedef struct RASCONNENTRY RASCONNENTRY, *PRASCONNENTRY;


struct RASCONNLINK {

    LIST_ENTRY      RCL_Node;
    RASCONN         RCL_Link;

};

typedef struct RASCONNLINK RASCONNLINK, *PRASCONNLINK;


/*----------------------------------------------------------------------------
** Prototypes
**----------------------------------------------------------------------------
*/

DWORD
ClearRasdevStats(
    IN RASDEV*  pdev,
    IN BOOL     fBundle );

DWORD
DeviceIdFromDeviceName(
    TCHAR* pszDeviceName );

DWORD
FreeRasdevTable(
    RASDEV* pDevTable,
    DWORD   iDevCount );

DWORD
GetRasConnection0Table(
    OUT RAS_CONNECTION_0 ** ppRc0Table,
    OUT DWORD *             piRc0Count );

DWORD
GetConnectTime(
    IN  HRASCONN hrasconn,
    OUT DWORD*   pdwConnectTime );

DWORD
GetRasconnFraming(
    IN  HRASCONN hrasconn,
    OUT DWORD*   pdwSendFraming,
    OUT DWORD*   pdwRecvFraming );

DWORD
GetRasconnFromRasdev(
    IN  RASDEV*   pdev,
    OUT RASCONN** ppconn,
    IN  RASCONN*  pConnTable OPTIONAL,
    IN  DWORD     iConnCount OPTIONAL );

DWORD
GetRasdevBundle(
    IN  RASDEV*  pdev,
    OUT DWORD*   pdwBundle );

DWORD
GetRasdevFraming(
    IN  RASDEV*  pdev,
    OUT DWORD*   pdwFraming );

DWORD
GetRasdevFromRasconn(
    IN  RASCONN* pconn,
    OUT RASDEV** ppdev,
    IN  RASDEV*  pDevTable OPTIONAL,
    IN  DWORD    iDevCount OPTIONAL );

DWORD
GetRasdevFromRasPort0(
    IN  RAS_PORT_0* pport,
    OUT RASDEV**    ppdev,
    IN  RASDEV*     pDevTable OPTIONAL,
    IN  DWORD       iDevCount OPTIONAL );

DWORD
GetRasDeviceString(
    IN  HPORT  hport,
    IN  CHAR*  pszDeviceType,
    IN  CHAR*  pszDeviceName,
    IN  CHAR*  pszKey,
    OUT CHAR** ppszValue,
    IN  DWORD  dwXlate );

DWORD
GetRasdevStats(
    IN  RASDEV*      pdev,
    OUT RASDEVSTATS* pstats );

DWORD
GetRasdevTable(
    OUT RASDEV** ppDevTable,
    OUT DWORD*   piDevCount );

DWORD
GetRasMessage(
    IN  HRASCONN hrasconn,
    OUT TCHAR**  ppszMessage );

DWORD
GetRasPads(
    OUT RASMAN_DEVICE** ppDevices,
    OUT WORD*           pwEntries );

DWORD
GetRasPort0FromRasdev(
    IN  RASDEV*         pdev,
    OUT RAS_PORT_0**    ppport,
    IN  RAS_PORT_0*     pPortTable OPTIONAL,
    IN  DWORD           iPortCount OPTIONAL );

DWORD
GetRasPort0Info(
    IN  HANDLE          hPort,
    OUT RAS_PORT_1 *    pRasPort1 );

DWORD
GetRasPort0Table(
    OUT RAS_PORT_0 **   ppPortTable,
    OUT DWORD *         piPortCount );

TCHAR *
GetRasPort0UserString(
    IN  RAS_PORT_0 *    pport,
    IN  TCHAR *         pszUser );

VOID
GetRasPortMaxBps(
    IN  HPORT  hport,
    OUT DWORD* pdwMaxConnectBps,
    OUT DWORD* pdwMaxCarrierBps );

VOID
GetRasPortModemSettings(
    IN  HPORT hport,
    OUT BOOL* pfHwFlowDefault,
    OUT BOOL* pfEcDefault,
    OUT BOOL* pfEccDefault );

DWORD
GetRasPorts(
    OUT RASMAN_PORT** ppPorts,
    OUT WORD*         pwEntries );

DWORD
GetRasPortString(
    IN  HPORT  hport,
    IN  CHAR*  pszKey,
    OUT CHAR** ppszValue,
    IN  DWORD  dwXlate );

DWORD
GetRasSwitches(
    OUT RASMAN_DEVICE** ppDevices,
    OUT WORD*           pwEntries );

TCHAR*
GetRasX25Diagnostic(
    IN HRASCONN hrasconn );

BOOL
IsRasdevBundled(
    IN  RASDEV* prasdev,
    IN  RASDEV* pDevTable,
    IN  DWORD   iDevCount );

CHAR*
PszFromRasValue(
    IN RAS_VALUE* prasvalue,
    IN DWORD      dwXlate );

DWORD
RasPort0Hangup(
    IN  HANDLE      hPort );

#endif // _RMUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\nt4\inc\rassapip.h ===
/******************************************************************\
*                     Microsoft Windows NT                         *
*               Copyright(c) Microsoft Corp., 1992                 *
\******************************************************************/

/*++

Module Name:

    RASSAPIP.H

Description:

    This file contains structure defs and defines used in implementing
    the RASADMIN APIs.


Author:

    Michael Salamone (MikeSa)   July 13,1992

Revision History:

--*/


#ifndef _RASSAPIP_H_
#define _RASAAPIP_H_


#define RASSAPI_MAX_CALLBACK_NUMBER_SIZE  48
#define RASSAPI_MAX_DEVICE_NAME_OLD       32

// 3rd party DLLs don't need this version information because they will only
// be administering a NT3.51 or greater server.
#define RAS_SERVER_20      20    // identifies a NT RAS 2.0 server

//
// Number of port statistics returned by a RAS 1.0 server
//
#define RAS10_MAX_STATISTICS 6

//
// RAS10 specific port statistics defines
//

#define RAS10_BYTES_RCVED         0
#define RAS10_BYTES_XMITED        1
#define RAS10_SERIAL_OVERRUN_ERR  2
#define RAS10_TIMEOUT_ERR         3
#define RAS10_FRAMING_ERR         4
#define RAS10_CRC_ERR             5


#define MEDIA_NAME_DEFAULT   L"SERIAL"
#define DEVICE_TYPE_DEFAULT  L"MODEM"
#define DEVICE_NAME_DEFAULT  L"UNKNOWN"

//
// structures used by down level RAS 1.x servers
//

typedef struct tagWpdStatisticsInfo
{
    ULONG stat_bytesreceived;
    ULONG stat_bytesxmitted;
    USHORT stat_overrunerr;
    USHORT stat_timeouterr;
    USHORT stat_framingerr;
    USHORT stat_crcerr;
} WpdStatisticsInfo;


struct dialin_user_info_0
{
    unsigned char duseri0_privilege_mask ;
    char duseri0_phone_number[RASSAPI_MAX_PHONENUMBER_SIZE + 1];
};


struct dialin_user_info_1
{
    struct dialin_user_info_0 duseri0;
    char duseri1_name[LM20_UNLEN+1];
};


struct dialin_user_info_2
{
    struct dialin_user_info_0 duseri0;
    USER_INFO_2 usri2;
};


struct dialin_port_info_0
{
    char dporti0_username[LM20_UNLEN+1];   // name of user using the port

    char dporti0_computer[NETBIOS_NAME_LEN+1]; // computer user dialed in from
                                               // Used when the admin wants to
                                               // send a message to this user

    unsigned short dporti0_comid;          // COM1 = 1 etc

    unsigned long dporti0_time;            // time user dialed in and
                                           // authenticated - number of seconds
                                           // since 00:00:00 Jan 1, 1970

    unsigned short dporti0_line_condition; // If RAS_PORT_AUTHENTICATED, then
                                           // comid, time username and computer
                                           // name fields are valid.

    unsigned short dporti0_modem_condition;
};


struct dialin_port_info_1
{
    struct dialin_port_info_0 dporti0;
    unsigned long dporti1_baud;
    WpdStatisticsInfo dporti1_stats;
};


struct dialin_server_info_0
{
    unsigned short dserveri0_total_ports;
    unsigned short dserveri0_ports_in_use;
};


//
// defined to support RAS 1.x - the max ports in RAS 2.0 and greater
// is 64 (could be greater)
//
#define RAS_MAX_SERVER_PORTS 16


//
// Max length of RAS 1.0 port name including terminating
// NULL character - eg., "COM16"
//
#define RAS10_MAX_PORT_NAME 6


//
// How long a client will wait for a pipe connection (milliseconds)
// if it is busy.
//
#define PIPE_CONNECTION_TIMEOUT   10000L


#define PIPE_BUFSIZE              512


//
// Name of pipe that will be used to process requests
//
#define	RASADMIN_PIPE  TEXT("\\pipe\\dialin\\adminsrv")


//
// Pipe path to which RASADMIN_PIPE should be concatenated for local
// machine
//
#define LOCAL_PIPE     TEXT("\\\\.")


//
// Request codes for RAS 1.x server
//
#define	RASADMINREQ_DISCONNECT_USER	1
#define	RASADMINREQ_GET_PORT_INFO	2
#define	RASADMINREQ_CLEAR_PORT_STATS	3
#define	RASADMINREQ_ENUM_PORTS		4	
#define	RASADMINREQ_GET_SERVER_INFO	5


//
// Request codes for RAS 2.0 server
//
#define RASADMIN20_REQ_DISCONNECT_USER    2001
#define RASADMIN20_REQ_GET_PORT_INFO      2002
#define RASADMIN20_REQ_CLEAR_PORT_STATS   2003
#define RASADMIN20_REQ_ENUM_PORTS         2004
#define RASADMIN20_REQ_ENUM_RESUME        2005


//
// This request code remains the same as in RAS 1.0
// so that, if RAS 1.0 admin tried to connect, it
// will get server info back, but not in the format
// that it recognizes.  It will then be unable to
// admin the RAS 2.0 server.
//
#define RASADMIN20_REQ_GET_SERVER_INFO    5


//
// These can be returned in the RetCode field of server response
// packet sent to the client.  These should not be changed in
// order to preserve compatibility with different versions of
// RASADMIN.
//
#define ERR_NO_SUCH_DEVICE                   635
#define ERR_SERVER_SYSTEM_ERR                636


//
// These are the packets sent back and forth between RAS 1.x server
// and the RASADMIN APIs.
//
struct PortEnumRequestPkt
{
    unsigned short Request;    // ENUM_PORTS
};                             // ENUM_PORTS_TOTALAVAIL


struct PortEnumReceivePkt
{
    unsigned short RetCode;
    unsigned short TotalAvail;
    struct dialin_port_info_0 Data[RAS_MAX_SERVER_PORTS];
};


struct DisconnectUserRequestPkt
{
    unsigned short Request;    // DISCONNECT_USER
    unsigned short ComId;
};


struct DisconnectUserReceivePkt
{
    unsigned short RetCode;
};


struct PortClearRequestPkt
{
    unsigned short Request;    // CLEAR_PORT_STATISTICS
    unsigned short ComId;
};


struct PortClearReceivePkt
{
    unsigned short RetCode;
};


struct ServerInfoRequestPkt
{
    unsigned short Request;    // GET_SERVER_INFO
};


struct ServerInfoReceivePkt
{
    unsigned short RetCode;
    struct dialin_server_info_0 Data;
};


struct PortInfoRequestPkt
{
    unsigned short Request;    // GET_PORT_INFO
    unsigned short ComId;
};


struct PortInfoReceivePkt
{
    unsigned short RetCode;
    struct dialin_port_info_1 Data;
};


//
// These are the packed structures that are sent out on the network.
// It is up to the receiver to unpack and convert to the proper endian
// for the host.
//
typedef struct _P_WPD_STATISTICS_INFO
{
    BYTE stat_bytesreceived[4];
    BYTE stat_bytesxmitted[4];
    BYTE stat_overrunerr[2];
    BYTE stat_timeouterr[2];
    BYTE stat_framingerr[2];
    BYTE stat_crcerr[2];
} P_WPD_STATISTICS_INFO, *PP_WPD_STATISTICS_INFO;


typedef struct _P_DIALIN_PORT_INFO_0
{
    BYTE dporti0_username[LM20_UNLEN+1];   // name of user using the port

    BYTE dporti0_computer[NETBIOS_NAME_LEN+1]; // computer user dialed in from
                                               // Used when the admin wants to
                                               // send a message to this user

    BYTE dporti0_comid[2];                 // COM1 = 1 etc

    BYTE dporti0_time[4];                  // time user dialed in and
                                           // authenticated - number of seconds
                                           // since 00:00:00 Jan 1, 1970

    BYTE dporti0_line_condition[2];        // If RAS_PORT_AUTHENTICATED, then
                                           // comid, time username and computer
                                           // name fields are valid.

    BYTE dporti0_modem_condition[2];
} P_DIALIN_PORT_INFO_0, *PP_DIALIN_PORT_INFO_0;


typedef struct _P_DIALIN_PORT_INFO_1
{
    P_DIALIN_PORT_INFO_0 dporti0;
    BYTE dporti1_baud[4];
    P_WPD_STATISTICS_INFO dporti1_stats;
} P_DIALIN_PORT_INFO_1, *PP_DIALIN_PORT_INFO_1;


typedef struct _P_DIALIN_SERVER_INFO_0
{
    BYTE dserveri0_total_ports[2];
    BYTE dserveri0_ports_in_use[2];
} P_DIALIN_SERVER_INFO_0, *PP_DIALIN_SERVER_INFO_0;


typedef struct _P_PORT_ENUM_REQUEST_PKT
{
    BYTE Request[2];    // ENUM_PORTS
} P_PORT_ENUM_REQUEST_PKT, *PP_PORT_ENUM_REQUEST_PKT;   // ENUM_PORTS_TOTALAVAIL


typedef struct _P_PORT_ENUM_RECEIVE_PKT
{
    BYTE RetCode[2];
    BYTE TotalAvail[2];
    P_DIALIN_PORT_INFO_0 Data[RAS_MAX_SERVER_PORTS];
} P_PORT_ENUM_RECEIVE_PKT, *PP_PORT_ENUM_RECEIVE_PKT;


typedef struct _P_DISCONNECT_USER_REQUEST_PKT
{
    BYTE Request[2];    // DISCONNECT_USER
    BYTE ComId[2];
} P_DISCONNECT_USER_REQUEST_PKT, *PP_DISCONNECT_USER_REQUEST_PKT;


typedef struct _P_DISCONNECT_USER_RECEIVE_PKT
{
    BYTE RetCode[2];
} P_DISCONNECT_USER_RECEIVE_PKT, *PP_DISCONNECT_USER_RECEIVE_PKT;


typedef struct _P_PORT_CLEAR_REQUEST_PKT
{
    BYTE Request[2];    // CLEAR_PORT_STATISTICS
    BYTE ComId[2];
} P_PORT_CLEAR_REQUEST_PKT, *PP_PORT_CLEAR_REQUEST_PKT;


typedef struct _P_PORT_CLEAR_RECEIVE_PKT
{
    BYTE RetCode[2];
} P_PORT_CLEAR_RECEIVE_PKT, *PP_PORT_CLEAR_RECEIVE_PKT;


typedef struct _P_SERVER_INFO_REQUEST_PKT
{
    BYTE Request[2];    // GET_SERVER_INFO
} P_SERVER_INFO_REQUEST_PKT, *PP_SERVER_INFO_REQUEST_PKT;


typedef struct _P_SERVER_INFO_RECEIVE_PKT
{
    BYTE RetCode[2];
    P_DIALIN_SERVER_INFO_0 Data;
} P_SERVER_INFO_RECEIVE_PKT, *PP_SERVER_INFO_RECEIVE_PKT;


typedef struct _P_PORT_INFO_REQUEST_PKT
{
    BYTE Request[2];    // GET_PORT_INFO
    BYTE ComId[2];
} P_PORT_INFO_REQUEST_PKT, *PP_PORT_INFO_REQUEST_PKT;


typedef struct _P_PORT_INFO_RECEIVE_PKT
{
    BYTE RetCode[2];
    P_DIALIN_PORT_INFO_1 Data;
} P_PORT_INFO_RECEIVE_PKT, *PP_PORT_INFO_RECEIVE_PKT;


//
// These are the packets sent back and forth between a RAS 2.0 server
// and the RASADMIN APIs
//
typedef struct tagPortEnumReceivePkt
{
    DWORD RetCode;
    WORD TotalAvail;
    RAS_PORT_0 *Data;
} PORT_ENUM_RECEIVE, *PPORT_ENUM_RECEIVE;


typedef struct tagPortInfoReceivePkt
{
    DWORD RetCode;
    DWORD ReqBufSize;
    RAS_PORT_1 Data;
} PORT_INFO_RECEIVE, *PPORT_INFO_RECEIVE;


typedef struct tagPortClearReceivePkt
{
    DWORD RetCode;
} PORT_CLEAR_RECEIVE, *PPORT_CLEAR_RECEIVE;


typedef struct tagDisconnectUserReceivePkt
{
    DWORD RetCode;
} DISCONNECT_USER_RECEIVE, *PDISCONNECT_USER_RECEIVE;


typedef struct tagServerInfoReceivePkt
{
    WORD RetCode;   // VERY IMPORTANT TO BE A WORD!!! - RAS1.0 COMPATIBILITY
    RAS_SERVER_0 Data;
} SERVER_INFO_RECEIVE, *PSERVER_INFO_RECEIVE;


typedef struct _CLIENT_REQUEST
{
    WORD RequestCode;
    WCHAR PortName[RASSAPI_MAX_PORT_NAME];
    DWORD RcvBufSize;
    DWORD ClientVersion;
} CLIENT_REQUEST, *PCLIENT_REQUEST;



//
// These are the packed structures that are sent out on the network.
// It is up to the receiver to unpack and convert to the proper endian
// for the host.
//

typedef struct _P_RAS_PORT_0
{
    BYTE wszPortName[2 * RASSAPI_MAX_PORT_NAME];
    BYTE wszDeviceType[2 * RASSAPI_MAX_DEVICETYPE_NAME];
    BYTE wszDeviceName[2 * RASSAPI_MAX_DEVICE_NAME_OLD];
    BYTE wszMediaName[2 * RASSAPI_MAX_MEDIA_NAME];
    BYTE reserved[4];
    BYTE Flags[4];
    BYTE wszUserName[2 * (UNLEN + 1)];
    BYTE wszComputer[2 * NETBIOS_NAME_LEN];
    BYTE dwStartSessionTime[4];
    BYTE wszLogonDomain[2 * (DNLEN + 1)];
    BYTE fAdvancedServer[4];
} P_RAS_PORT_0, *PP_RAS_PORT_0;


typedef struct _P_RAS_STATISTIC
{
    BYTE Stat[4];
} P_RAS_STATISTIC, *PP_RAS_STATISTIC;



/* PPP control protocol results returned by RasPppGetInfo.
*/
typedef struct __PPP_NBFCP_RESULT
{
    BYTE dwError[4];
    BYTE dwNetBiosError[4];
    BYTE szName[NETBIOS_NAME_LEN + 1];
    BYTE wszWksta[2 * (NETBIOS_NAME_LEN + 1)];
} P_PPP_NBFCP_RESULT, *PP_PPP_NBFCP_RESULT;

typedef struct __PPP_IPCP_RESULT
{
    BYTE dwError[4];
    BYTE wszAddress[2 * (RAS_IPADDRESSLEN + 1)];
} P_PPP_IPCP_RESULT, *PP_PPP_IPCP_RESULT;

typedef struct __PPP_IPXCP_RESULT
{
    BYTE dwError[4];
    BYTE wszAddress[2 * (RAS_IPXADDRESSLEN + 1)];
} P_PPP_IPXCP_RESULT, *PP_PPP_IPXCP_RESULT;

typedef struct __PPP_ATCP_RESULT
{
    BYTE dwError[4];
    BYTE wszAddress[2 * (RAS_ATADDRESSLEN + 1)];
} P_PPP_ATCP_RESULT, *PP_PPP_ATCP_RESULT;

typedef struct __PPP_PROJECTION_RESULT
{
    P_PPP_NBFCP_RESULT nbf;
    P_PPP_IPCP_RESULT ip;
    P_PPP_IPXCP_RESULT ipx;
    P_PPP_ATCP_RESULT at;
} P_PPP_PROJECTION_RESULT, *PP_PPP_PROJECTION_RESULT;


typedef struct _P_RAS_PORT_1
{
    P_RAS_PORT_0 rasport0;
    BYTE LineCondition[4];
    BYTE HardwareCondition[4];
    BYTE LineSpeed[4];      // in bits/second
    BYTE NumStatistics[2];
    BYTE NumMediaParms[2];
    BYTE SizeMediaParms[4];
    P_PPP_PROJECTION_RESULT ProjResult;
} P_RAS_PORT_1, *PP_RAS_PORT_1;


typedef struct _P_RAS_FORMAT
{
    BYTE Format[4];
} P_RAS_FORMAT, *PP_RAS_FORMAT;


typedef union _P_RAS_VALUE
{
    BYTE Number[4];
    struct
    {
        BYTE Length[4];
        BYTE Offset[4];
    } String;
} P_RAS_VALUE, *PP_RAS_VALUE;


typedef struct _P_RAS_PARAMS
{
    BYTE P_Key[RASSAPI_MAX_PARAM_KEY_SIZE];
    P_RAS_FORMAT P_Type;
    BYTE P_Attributes;
    P_RAS_VALUE P_Value;
} P_RAS_PARAMS, *PP_RAS_PARAMS;


typedef struct _P_RAS_SERVER_0
{
    BYTE TotalPorts[2];
    BYTE PortsInUse[2];
    BYTE RasVersion[4];
} P_RAS_SERVER_0, *PP_RAS_SERVER_0;


typedef struct _P_PORT_ENUM_RECEIVE
{
    BYTE RetCode[4];
    BYTE TotalAvail[2];
    P_RAS_PORT_0 Data[1];
} P_PORT_ENUM_RECEIVE, *PP_PORT_ENUM_RECEIVE;


typedef struct _P_PORT_INFO_RECEIVE
{
    BYTE RetCode[4];
    BYTE ReqBufSize[4];
    P_RAS_PORT_1 Data;
} P_PORT_INFO_RECEIVE, *PP_PORT_INFO_RECEIVE;


typedef struct _P_PORT_CLEAR_RECEIVE
{
    BYTE RetCode[4];
} P_PORT_CLEAR_RECEIVE, *PP_PORT_CLEAR_RECEIVE;


typedef struct _P_DISCONNECT_USER_RECEIVE
{
    BYTE RetCode[4];
} P_DISCONNECT_USER_RECEIVE, *PP_DISCONNECT_USER_RECEIVE;


typedef struct _P_SERVER_INFO_RECEIVE
{
    BYTE RetCode[2];
    P_RAS_SERVER_0 Data;
} P_SERVER_INFO_RECEIVE, *PP_SERVER_INFO_RECEIVE;


typedef struct _P_CLIENT_REQUEST
{
    BYTE RequestCode[2];
    BYTE PortName[2 * RASSAPI_MAX_PORT_NAME];
    BYTE RcvBufSize[4];
    BYTE ClientVersion[4];
} P_CLIENT_REQUEST, *PP_CLIENT_REQUEST;


//
// The following macros deal with on-the-wire integer and long values
// On the wire format is little-endian i.e. a long value of 0x01020304 is
// represented as 04 03 02 01. Similarly an int value of 0x0102 is
// represented as 02 01.
//
// The host format is not assumed since it will vary from processor to
// processor.
//

// Get a short from on-the-wire format to the host format
#define GETUSHORT(DstPtr, SrcPtr)               \
    *(unsigned short *)(DstPtr) =               \
        ((*((unsigned char *)(SrcPtr)+1) << 8) +\
        (*((unsigned char *)(SrcPtr)+0)))

// Get a dword from on-the-wire format to the host format
#define GETULONG(DstPtr, SrcPtr)                 \
    *(unsigned long *)(DstPtr) =                 \
        ((*((unsigned char *)(SrcPtr)+3) << 24) +\
        (*((unsigned char *)(SrcPtr)+2) << 16) + \
        (*((unsigned char *)(SrcPtr)+1) << 8)  + \
        (*((unsigned char *)(SrcPtr)+0)))


// Put a ushort from the host format to on-the-wire format
#define PUTUSHORT(DstPtr, Src)   \
    *((unsigned char *)(DstPtr)+1)=(unsigned char)((unsigned short)(Src) >> 8),\
    *((unsigned char *)(DstPtr)+0)=(unsigned char)(Src)

// Put a ulong from the host format to on-the-wire format
#define PUTULONG(DstPtr, Src)   \
    *((unsigned char *)(DstPtr)+3)=(unsigned char)((unsigned long)(Src) >> 24),\
    *((unsigned char *)(DstPtr)+2)=(unsigned char)((unsigned long)(Src) >> 16),\
    *((unsigned char *)(DstPtr)+1)=(unsigned char)((unsigned long)(Src) >>  8),\
    *((unsigned char *)(DstPtr)+0)=(unsigned char)(Src)


#endif // _RASSAPIP_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\nt4\inc\uiutil.h ===
/* Copyright (c) 1995, Microsoft Corporation, all rights reserved
**
** uiutil.h
** UI helper routines
** Public header
**
** 08/25/95 Steve Cobb
*/

#ifndef _UIUTIL_H_
#define _UIUTIL_H_


#include <nouiutil.h>


/* IP address custom control definitions.
*/
#ifndef EXCL_IPADDR_H
#include <ipaddr.h>
#endif

/* Error and Message dialog definitions.
*/
#ifndef EXCL_POPUPDLG_H
#include <popupdlg.h>
#endif


/*----------------------------------------------------------------------------
** Constants/datatypes
**----------------------------------------------------------------------------
*/

/* ListView of devices indices.
*/
#define DI_Modem   0
#define DI_Adapter 1

/* Bitmap styles for use with Button_CreateBitmap.
*/
#define BMS_OnLeft  0x100
#define BMS_OnRight 0x200

#define BITMAPSTYLE enum tagBITMAPSTYLE
BITMAPSTYLE
{
    BMS_UpArrowOnLeft = BMS_OnLeft,
    BMS_DownArrowOnLeft,
    BMS_UpTriangleOnLeft,
    BMS_DownTriangleOnLeft,
    BMS_UpArrowOnRight = BMS_OnRight,
    BMS_DownArrowOnRight,
    BMS_UpTriangleOnRight,
    BMS_DownTriangleOnRight
};


/* The extended list view control calls the owner back to find out the layout
** and desired characteristics of the enhanced list view.
*/
#define LVX_MaxCols      10
#define LVX_MaxColTchars 512

/* 'dwFlags' option bits.
*/
#define LVXDI_DxFill     1  // Auto-fill wasted space on right (recommended)
#define LVXDI_Blend50Sel 2  // Dither small icon if selected (not recommended)
#define LVXDI_Blend50Dis 4  // Dither small icon if disabled (recommended)

/* 'adwFlags' option bits.
*/
#define LVXDIA_3dFace 1     // Column is not editable but other columns are

/* Returned by owner at draw item time.
*/
#define LVXDRAWINFO struct tagLVXDRAWINFO
LVXDRAWINFO
{
    /* The number of columns.  The list view extensions require that your
    ** columns are numbered sequentially from left to right where 0 is the
    ** item column and 1 is the first sub-item column.  Required always.
    */
    INT cCols;

    /* Pixels to indent this item, or -1 to indent a "small icon" width.  Set
    ** 0 to disable.
    */
    INT dxIndent;

    /* LVXDI_* options applying to all columns.
    */
    DWORD dwFlags;

    /* LVXDIA_* options applying to individual columns.
    */
    DWORD adwFlags[ LVX_MaxCols ];
};

typedef LVXDRAWINFO* (*PLVXCALLBACK)( IN HWND, IN DWORD dwItem );

/* Sent by ListView when check changes on an item
*/
#define LVXN_SETCHECK (LVN_LAST + 1)


/* SetOffDesktop actions.
*/
#define SOD_MoveOff        1
#define SOD_MoveBackFree   2
#define SOD_MoveBackHidden 3
#define SOD_Free           4
#define SOD_GetOrgRect     5


/*----------------------------------------------------------------------------
** Prototypes
**----------------------------------------------------------------------------
*/

VOID
AddContextHelpButton(
    IN HWND hwnd );

VOID
Button_MakeDefault(
    IN HWND hwndDlg,
    IN HWND hwndPb );

HBITMAP
Button_CreateBitmap(
    IN HWND        hwndPb,
    IN BITMAPSTYLE bitmapstyle );

VOID
CenterWindow(
    IN HWND hwnd,
    IN HWND hwndRef );

VOID
CloseOwnedWindows(
    IN HWND hwnd );

INT
ComboBox_AddItem(
    IN HWND   hwndLb,
    IN TCHAR* pszText,
    IN VOID*  pItem );

INT
ComboBox_AddItemFromId(
    IN HINSTANCE hinstance,
    IN HWND      hwndLb,
    IN DWORD     dwStringId,
    IN VOID*     pItem );

INT
ComboBox_AddItemSorted(
    IN HWND   hwndLb,
    IN TCHAR* pszText,
    IN VOID*  pItem );

VOID
ComboBox_AutoSizeDroppedWidth(
    IN HWND hwndLb );

VOID
ComboBox_FillFromPszList(
    IN HWND     hwndLb,
    IN DTLLIST* pdtllistPsz );

VOID*
ComboBox_GetItemDataPtr(
    IN HWND hwndLb,
    IN INT  nIndex );

TCHAR*
ComboBox_GetPsz(
    IN HWND hwnd,
    IN INT  nIndex );

VOID
ComboBox_SetCurSelNotify(
    IN HWND hwndLb,
    IN INT  nIndex );

TCHAR*
Ellipsisize(
    IN HDC    hdc,
    IN TCHAR* psz,
    IN INT    dxColumn,
    IN INT    dxColText OPTIONAL );

VOID
ExpandWindow(
    IN HWND hwnd,
    IN LONG dx,
    IN LONG dy );

TCHAR*
GetText(
    IN HWND hwnd );

HWND
HwndFromCursorPos(
    IN HINSTANCE    hinstance,
    IN POINT*       ppt OPTIONAL );

INT
ListBox_AddItem(
    IN HWND   hwndLb,
    IN TCHAR* pszText,
    IN VOID*  pItem );

TCHAR*
ListBox_GetPsz(
    IN HWND hwnd,
    IN INT  nIndex );

INT
ListBox_IndexFromString(
    IN HWND   hwnd,
    IN TCHAR* psz );

VOID
ListBox_SetCurSelNotify(
    IN HWND hwndLb,
    IN INT  nIndex );

BOOL
ListView_GetCheck(
    IN HWND hwndLv,
    IN INT  iItem );

UINT
ListView_GetCheckedCount(
    IN HWND hwndLv );

VOID*
ListView_GetParamPtr(
    IN HWND hwndLv,
    IN INT  iItem );

VOID*
ListView_GetSelectedParamPtr(
    IN HWND hwndLv );

BOOL
ListView_InstallChecks(
    IN HWND      hwndLv,
    IN HINSTANCE hinst );

BOOL
ListView_OwnerHandler(
    IN HWND         hwnd,
    IN UINT         unMsg,
    IN WPARAM       wparam,
    IN LPARAM       lparam,
    IN PLVXCALLBACK pLvxCallback );

VOID
ListView_SetCheck(
    IN HWND hwndLv,
    IN INT  iItem,
    IN BOOL fCheck );

VOID
ListView_SetDeviceImageList(
    IN HWND      hwndLv,
    IN HINSTANCE hinst );

BOOL
ListView_SetParamPtr(
    IN HWND  hwndLv,
    IN INT   iItem,
    IN VOID* pParam );

VOID
ListView_UninstallChecks(
    IN HWND hwndLv );

DWORD
LoadRas(
    IN HINSTANCE hInst,
    IN HWND      hwnd );

VOID
Menu_CreateAccelProxies(
    IN HINSTANCE hinst,
    IN HWND      hwndParent,
    IN DWORD     dwMid );

BOOL
SetEvenTabWidths(
    IN HWND  hwndDlg,
    IN DWORD cPages );

VOID
SlideWindow(
    IN HWND hwnd,
    IN HWND hwndParent,
    IN LONG dx,
    IN LONG dy );

VOID
UnclipWindow(
    IN HWND hwnd );

BOOL
SetDlgItemNum(
    IN HWND     hwndDlg,
    IN INT      iDlgItem,
    IN UINT     uValue );

VOID
ScreenToClientRect(
    IN     HWND  hwnd,
    IN OUT RECT* pRect );

BOOL
SetOffDesktop(
    IN  HWND    hwnd,
    IN  DWORD   dwAction,
    OUT RECT*   prectOrg );

VOID
UnloadRas(
    void );


#endif // _UIUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\nt4\inc\treelist.h ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File:    treelist.h
//
// History:
//  Abolade Gbadegesin   Nov-20-1995    Created.
//
// The control whose declarations are included here provides a view
// which is a hybrid treeview/listview. Like a listview, each item
// may have zero or more subitems. Like a treeview, items are organized
// hierarchically, and displayed as a n-ary tree.
//
//  [  Header1        ][ Header2
//  -- Level 1          subtext
//      |- Level 2      subtext
//      |   |- Level 3
//      |   +- Level 3
//      |- Level 2      subtext
//      +- Level 2
//  +- Level 1          subtext
//
//
// The control is implemented as window which provides item-management,
// and which contains a listview window to which display is delegated.
//
// Once the window class has been initialized by calling TL_Init(),
// a treelist window can be created by calling CreateWindow() or
// CreateWindowEx() and passing it WC_TREELIST as the name of the class
// of window to be created.
//
// Communication with the window is via message passing, and macros are
// provided below for the operations supported by the treelist.
//
// As with a listview, at least one column must be inserted into the treelist
// before inserted items are displayed. Columns are described using 
// the LV_COLUMN structure defined in commctrl.h. Use the macros
// TreeList_InsertColumn() and TreeList_DeleteColumn() for column management.
// 
// Item insertion and deletion shoudl be done with TreeList_InsertItem() and
// TreeList_DeleteItem(). The insertion macro takes a TL_INSERTSTRUCT,
// which contains a pointer to a LV_ITEM structure which, as with listviews,
// is used to describe the item to be inserted. The LV_ITEM structure
// is defined in commctrl.h. (Note the iItem field is ignored).
// As with a treeview, once items have been inserted, there are referred to
// via handles. The type for treelist handles is HTLITEM.
//
// Once an item has been inserted, its attributes can be retreived or changed,
// it can be deleted, and subitems can be set for it. The LV_ITEM structure
// is used to retrieve or set an items attributes, and the iItem field
// is used to store the HTLITEM of the item to which the operation refers.
//
//============================================================================


#ifndef _TREELIST_H_
#define _TREELIST_H_


//
// Window class name string
//

#define WC_TREELIST         TEXT("TreeList")


//
// Item handle definition
//

typedef VOID *HTLITEM;


//
// struct passed to TreeList_InsertItem
//

typedef struct _TL_INSERTSTRUCT {

    HTLITEM     hParent; 
    HTLITEM     hInsertAfter;
    LV_ITEM    *plvi;

} TL_INSERTSTRUCT;



//
// values for TL_INSERTSTRUCT::hInsertAfter
//

#define TLI_FIRST           ((HTLITEM)0xffff0001)
#define TLI_LAST            ((HTLITEM)0xffff0002)
#define TLI_SORT            ((HTLITEM)0xffff0003)


//
// struct sent in notifications by a treelist
//

typedef struct _NMTREELIST {

    NMHDR   hdr;
    HTLITEM hItem;
    LPARAM  lParam;

} NMTREELIST;


//
// flags for TreeList_GetNextItem
//

#define TLGN_FIRST          0x0000
#define TLGN_PARENT         0x0001
#define TLGN_CHILD          0x0002
#define TLGN_NEXTSIBLING    0x0004
#define TLGN_PREVSIBLING    0x0008
#define TLGN_ENUMERATE      0x0010
#define TLGN_SELECTION      0x0020


//
// flags for TreeList_Expand
//

#define TLE_EXPAND          0x0001
#define TLE_COLLAPSE        0x0002
#define TLE_TOGGLE          0x0003


#define TLM_FIRST           (WM_USER + 1)
#define TLM_INSERTITEM      (TLM_FIRST + 0)
#define TLM_DELETEITEM      (TLM_FIRST + 1)
#define TLM_DELETEALLITEMS  (TLM_FIRST + 2)
#define TLM_GETITEM         (TLM_FIRST + 3)
#define TLM_SETITEM         (TLM_FIRST + 4)
#define TLM_GETITEMCOUNT    (TLM_FIRST + 5)
#define TLM_GETNEXTITEM     (TLM_FIRST + 6)
#define TLM_EXPAND          (TLM_FIRST + 7)
#define TLM_SETIMAGELIST    (TLM_FIRST + 8)
#define TLM_GETIMAGELIST    (TLM_FIRST + 9)
#define TLM_INSERTCOLUMN    (TLM_FIRST + 10)
#define TLM_DELETECOLUMN    (TLM_FIRST + 11)
#define TLM_SETSELECTION    (TLM_FIRST + 12)
#define TLM_REDRAW          (TLM_FIRST + 13)
#define TLM_ISITEMEXPANDED  (TLM_FIRST + 14)
#define TLM_GETCOLUMNWIDTH  (TLM_FIRST + 15)
#define TLM_SETCOLUMNWIDTH  (TLM_FIRST + 16)

#define TLN_FIRST           (0U - 1000U)
#define TLN_DELETEITEM      (TLN_FIRST - 1)
#define TLN_SELCHANGED      (TLN_FIRST - 2)


BOOL
TL_Init(
    HINSTANCE hInstance
    );

#define TreeList_InsertItem(hwnd, ptlis) \
        (HTLITEM)SendMessage( \
            (hwnd), TLM_INSERTITEM, 0, (LPARAM)(CONST TL_INSERTSTRUCT *)(ptlis)\
            )
#define TreeList_DeleteItem(hwnd, hItem) \
        (BOOL)SendMessage( \
            (hwnd), TLM_DELETEITEM, 0, (LPARAM)(CONST HTLITEM)(hItem) \
            )
#define TreeList_DeleteAllItems(hwnd) \
        (BOOL)SendMessage((hwnd), TLM_DELETEALLITEMS, 0, 0)
#define TreeList_GetItem(hwnd, pItem) \
        (BOOL)SendMessage( \
            (hwnd), TLM_GETITEM, 0, (LPARAM)(LV_ITEM *)(pItem) \
            )
#define TreeList_SetItem(hwnd, pItem) \
        (BOOL)SendMessage( \
            (hwnd), TLM_SETITEM, 0, (LPARAM)(CONST LV_ITEM *)(pItem) \
            )
#define TreeList_GetItemCount(hwnd) \
        (UINT)SendMessage((hwnd), TLM_GETITEMCOUNT, 0, 0)
#define TreeList_GetNextItem(hwnd, hItem, flag) \
        (HTLITEM)SendMessage( \
            (hwnd), TLM_GETNEXTITEM, (WPARAM)(UINT)(flag), \
            (LPARAM)(CONST HTLITEM)(hItem) \
            )
#define TreeList_GetFirst(hwnd) \
        TreeList_GetNextItem((hwnd), NULL, TLGN_FIRST)
#define TreeList_GetParent(hwnd, hItem) \
        TreeList_GetNextItem((hwnd), (hItem), TLGN_PARENT)
#define TreeList_GetChild(hwnd, hItem) \
        TreeList_GetNextItem((hwnd), (hItem), TLGN_CHILD)
#define TreeList_GetNextSibling(hwnd, hItem) \
        TreeList_GetNextItem((hwnd), (hItem), TLGN_NEXTSIBLING)
#define TreeList_GetPrevSibling(hwnd, hItem) \
        TreeList_GetNextItem((hwnd), (hItem), TLGN_PREVSIBLING)
#define TreeList_GetEnumerate(hwnd, hItem) \
        TreeList_GetNextItem((hwnd), (hItem), TLGN_ENUMERATE)
#define TreeList_GetSelection(hwnd) \
        TreeList_GetNextItem((hwnd), NULL, TLGN_SELECTION)
#define TreeList_Expand(hwnd, hItem, flag) \
        (BOOL)SendMessage( \
            (hwnd), TLM_EXPAND, (WPARAM)(UINT)(flag), \
            (LPARAM)(CONST HTLITEM)(hItem) \
            )
#define TreeList_SetImageList(hwnd, himl) \
        (BOOL)SendMessage( \
            (hwnd), TLM_SETIMAGELIST, 0, (LPARAM)(CONST HIMAGELIST)(himl) \
            )
#define TreeList_GetImageList(hwnd, himl) \
        (HIMAGELIST)SendMessage((hwnd), TLM_GETIMAGELIST, 0, 0)
#define TreeList_InsertColumn(hwnd, iCol, pCol) \
        (INT)SendMessage( \
            (hwnd),  TLM_INSERTCOLUMN, (WPARAM)(INT)(iCol), \
            (LPARAM)(CONST LV_COLUMN *)(pCol) \
            )
#define TreeList_DeleteColumn(hwnd, iCol) \
        (BOOL)SendMessage((hwnd), TLM_DELETECOLUMN, (WPARAM)(INT)(iCol), 0)
#define TreeList_SetSelection(hwnd, hItem) \
        (BOOL)SendMessage( \
            (hwnd), TLM_SETSELECTION, 0, (LPARAM)(CONST HTLITEM)(hItem) \
            )
#define TreeList_Redraw(hwnd) \
        (BOOL)SendMessage((hwnd), TLM_REDRAW, 0, 0)
#define TreeList_IsItemExpanded(hwnd, hItem) \
        (BOOL)SendMessage( \
            (hwnd), TLM_ISITEMEXPANDED, 0, (LPARAM)(CONST HTLITEM)(hItem) \
            )
#define TreeList_GetColumnWidth(hwnd, iCol) \
        (INT)SendMessage((hwnd), TLM_GETCOLUMNWIDTH, (WPARAM)(int)(iCol), 0)
#define TreeList_SetColumnWidth(hwnd, iCol, cx) \
        (BOOL)SendMessage( \
            (hwnd), TLM_SETCOLUMNWIDTH, (WPARAM)(int)(iCol), \
            MAKELPARAM((cx), 0) \
            )


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\nt4\rasdlg\dstat.h ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File:    dstat.h
//
// History:
//  Abolade Gbadegesin  Nov-15-1995     Created.
//
// Device status property sheet declarations.
//============================================================================

#ifndef _DSTAT_H_
#define _DSTAT_H_




//
// error dialog macro used by all Device Status property pages
//

#define DsErrorDlg(h,o,e,a) \
            ErrorDlgUtil(h,o,e,a,g_hinstDll,SID_DS_Details,SID_FMT_ErrorMsg)


//
// definiton for arguments passed to DsPropertySheet
//

#define DETAILSFLAG_Network     0x0001
#define DETAILSFLAG_Device      0x0002
#define DETAILSFLAG_Client      0x0004
//#define DETAILSFLAG_Port        0x0008

#define DSARGS      struct tagDSARGS
DSARGS {

    DWORD           dwError;
    DWORD           dwFlags;
    HWND            hwndParent;
    TCHAR           szNameString[max(RAS_MaxEntryName, RAS_MaxDeviceName) + 1];
    DWORD           iDevice;
    RASDEV         *pDevTable;
    DWORD           iDevCount;

};


#define DS_NrPage           0
#define DS_PageCount        1

#define DS_NRTIMERID        1
#define DS_NRREFRESHRATEMS  5000


//
// definition of Details property sheet information
//

#define DSINFO      struct tagDSINFO
DSINFO {

    DSARGS         *pArgs;
    UINT_PTR        uiTimerId;
    DWORD           iDevice;

    HWND            hwndSheet;
    HWND            hwndFirstPage;
    HWND            hwndNr;

    RASAMB          nrAmb;
    RASSLIP         nrSlip;
    RASPPPIP        nrPppIp;
    RASPPPIPX       nrPppIpx;
    RASPPPLCP       nrPppLcp;
    RASPPPNBF       nrPppNbf;
    RAS_PORT_1      nrRp1;
    DWORD           nrFraming;
    TCHAR           nrNbfName[MAX_COMPUTERNAME_LENGTH + 2];

};



//
// Details property sheet functions
//


VOID
DsPropertySheet(
    DSARGS *pArgs
    );

DSINFO *
DsInit(
    HWND hwndFirstPage,
    DSARGS *pArgs
    );

VOID
DsInitFail(
    DSINFO *pInfo,
    DWORD dwOp,
    DWORD dwErr
    );

DSINFO *
DsContext(
    HWND hwndPage
    );

VOID
DsExit(
    HWND hwndPage,
    DWORD dwErr
    );

VOID
DsTerm(
    HWND hwndPage
    );



//
// Network Registration property page functions
//

INT_PTR 
CALLBACK
NrDlgProc(
    HWND hwndPage,
    UINT uiMsg,
    WPARAM wParam,
    LPARAM lParam
    );

BOOL
NrInit(
    HWND hwndPage,
    DSARGS *pArgs
    );

DWORD
NrRefresh(
    DSINFO *pInfo
    );

VOID
NrEnableIpControls(
    HWND hwnd,
    BOOL bEnable,
    BOOL bClear
    );

VOID
NrEnableIpxControls(
    HWND hwnd,
    BOOL bEnable,
    BOOL bClear
    );

VOID
NrEnableNbfControls(
    HWND hwnd,
    BOOL bEnable,
    BOOL bClear
    );


DWORD
NrDialInRefresh(
    DSINFO *pInfo
    );

DWORD
NrDialOutRefresh(
    DSINFO *pInfo
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\nt4\rasdlg\entry.c ===
/* Copyright (c) 1995, Microsoft Corporation, all rights reserved
**
** entry.c
** Remote Access Common Dialog APIs
** RasPhonebookEntryDlg APIs
**
** 06/20/95 Steve Cobb
*/

#include "rasdlgp.h"
#include "entry.h"
#include <serial.h>     // for SERIAL_TXT
#include <mprapi.h>     // for MprAdmin API declarations
#include <lmaccess.h>   // for NetUserAdd declarations


/*----------------------------------------------------------------------------
** Local prototypes (alphabetically)
**----------------------------------------------------------------------------
*/

BOOL
EuCommit(
    IN EINFO* pInfo );

DWORD
EuCommitCredentials(
    IN  EINFO*  pInfo );

DWORD
EuLoadScpScriptsList(
    OUT DTLLIST** ppList );

/* Target machine for RouterEntryDlg{A,W}
*/
static WCHAR g_wszServer[ MAX_COMPUTERNAME_LENGTH + 3] = L"";

/*----------------------------------------------------------------------------
** External entry points
**----------------------------------------------------------------------------
*/

BOOL APIENTRY
RasEntryDlgA(
    IN     LPSTR          lpszPhonebook,
    IN     LPSTR          lpszEntry,
    IN OUT LPRASENTRYDLGA lpInfo )

    /* Win32 ANSI entrypoint that displays the modal Phonebook Entry property
    ** sheet.  'LpszPhonebook' is the full path to the phonebook file or NULL
    ** to use the default phonebook.  'LpszEntry' is the entry to edit or the
    ** default name of the new entry.  'LpInfo' is caller's additional
    ** input/output parameters.
    **
    ** Returns true if user presses OK and succeeds, false on error or Cancel.
    */
{
    WCHAR*       pszPhonebookW;
    WCHAR*       pszEntryW;
    RASENTRYDLGW infoW;
    BOOL         fStatus;

    TRACE("RasEntryDlgA");

    if (!lpInfo)
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    if (lpInfo->dwSize != sizeof(RASENTRYDLGA))
    {
        lpInfo->dwError = ERROR_INVALID_SIZE;
        return FALSE;
    }

    /* Thunk "A" arguments to "W" arguments.
    */
    if (lpszPhonebook)
    {
        pszPhonebookW = StrDupTFromA( lpszPhonebook );
        if (!pszPhonebookW)
        {
            lpInfo->dwError = ERROR_NOT_ENOUGH_MEMORY;
            return FALSE;
        }
    }
    else
        pszPhonebookW = NULL;

    if (lpszEntry)
    {
        pszEntryW = StrDupTFromA( lpszEntry );
        if (!pszEntryW)
        {
            Free0( pszPhonebookW );
            {
                lpInfo->dwError = ERROR_NOT_ENOUGH_MEMORY;
                return FALSE;
            }
        }
    }
    else
        pszEntryW = NULL;

    ZeroMemory( &infoW, sizeof(infoW) );
    infoW.dwSize = sizeof(infoW);
    infoW.hwndOwner = lpInfo->hwndOwner;
    infoW.dwFlags = lpInfo->dwFlags;
    infoW.xDlg = lpInfo->xDlg;
    infoW.yDlg = lpInfo->yDlg;
    infoW.reserved = lpInfo->reserved;
    infoW.reserved2 = lpInfo->reserved2;

    /* Thunk to the equivalent "W" API.
    */
    fStatus = RasEntryDlgW( pszPhonebookW, pszEntryW, &infoW );

    Free0( pszPhonebookW );
    Free0( pszEntryW );

    /* Thunk "W" results to "A" results.
    */
    WideCharToMultiByte(
        CP_ACP, 0, infoW.szEntry, -1, lpInfo->szEntry,
        RAS_MaxEntryName + 1, NULL, NULL );
    lpInfo->dwError = infoW.dwError;

    return fStatus;
}


BOOL APIENTRY
RasEntryDlgW(
    IN     LPWSTR         lpszPhonebook,
    IN     LPWSTR         lpszEntry,
    IN OUT LPRASENTRYDLGW lpInfo )

    /* Win32 Unicode entrypoint that displays the modal Phonebook Entry
    ** property sheet.  'LpszPhonebook' is the full path to the phonebook file
    ** or NULL to use the default phonebook.  'LpszEntry' is the entry to edit
    ** or the default name of the new entry.  'LpInfo' is caller's additional
    ** input/output parameters.
    **
    ** Returns true if user presses OK and succeeds, false on error or Cancel.
    */
{
    DWORD dwErr;
    EINFO einfo;
    BOOL  fStatus;
    HWND  hwndOwner;
    DWORD dwOp;

    TRACE("RasEntryDlgW");

    if (!lpInfo)
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    if (lpInfo->dwSize != sizeof(RASENTRYDLGW))
    {
        lpInfo->dwError = ERROR_INVALID_SIZE;
        return FALSE;
    }

    /* Eliminate some invalid flag combinations up front.
    */
    if (lpInfo->dwFlags & RASEDFLAG_CloneEntry)
        lpInfo->dwFlags &= ~(RASEDFLAG_NewEntry | RASEDFLAG_NoRename);

    /* Pre-initialize the entry common context block.  The initialization is
    ** completed later after the property sheet or wizard has been positioned
    ** so that "waiting for services" can be centered.
    */
    dwErr = EuInit0( lpszPhonebook, lpszEntry, lpInfo, &einfo, &dwOp );
    if (dwErr == 0)
    {
        if ((lpInfo->dwFlags & RASEDFLAG_NewEntry)
            && einfo.pUser->fNewEntryWizard)
        {
            if (!einfo.fRouter)
                AeWizard( &einfo );
            else
                AiWizard( &einfo );
            if (einfo.fPadSelected)
            {
                /* Explain to the user that an address must be entered,
                */
                MsgDlg( lpInfo->hwndOwner, SID_EnterX25Address, NULL );
                einfo.fChainPropertySheet = TRUE;
            }
            if (einfo.fChainPropertySheet && lpInfo->dwError == 0)
                PePropertySheet( &einfo );
            if (einfo.fPadSelected)
            {
                /* Now we clear 'fChainPropertySheet' if we only set it
                ** because an X25 pad was selected.
                ** This way, the user credentials are committed as required
                ** in EuCommit below.
                */
                einfo.fChainPropertySheet = FALSE;
            }
        }
        else
        {
            PePropertySheet( &einfo );
        }
    }
    else
    {
        ErrorDlg( lpInfo->hwndOwner, dwOp, dwErr, NULL );
        lpInfo->dwError = dwErr;
    }

    fStatus = (einfo.fCommit && EuCommit( &einfo ));
    EuFree( &einfo );
    return fStatus;
}


BOOL APIENTRY
RouterEntryDlgA(
    IN     LPSTR          lpszServer,
    IN     LPSTR          lpszPhonebook,
    IN     LPSTR          lpszEntry,
    IN OUT LPRASENTRYDLGA lpInfo )
{
    BOOL fSuccess;
    DWORD dwErr;
    PWCHAR pszServerW = NULL;

    TRACE("RouterEntryDlgA");

    //
    // Set the RPC server.
    //
    if (!lpszServer)
        g_wszServer[0] = L'\0';
    else
    {
        MultiByteToWideChar(
            CP_ACP, 0, lpszServer, -1, g_wszServer, MAX_COMPUTERNAME_LENGTH+3 );
    }
    dwErr = LoadRasRpcDll(g_wszServer);
    if (dwErr) {
        lpInfo->dwError = dwErr;
        return FALSE;
    }
    //
    // Load MprApi entrypoints
    //
    dwErr = LoadMpradminDll();
    if (dwErr) {
        LoadRasRpcDll(NULL);
        lpInfo->dwError = dwErr;
        return FALSE;
    }
    //
    // Call the existing UI.
    //
    fSuccess = RasEntryDlgA(lpszPhonebook, lpszEntry, lpInfo);
    //
    // Unload MprApi entrypoints
    //
    UnloadMpradminDll();
    //
    // Unset the RPC server.
    //
    dwErr = LoadRasRpcDll(NULL);
    if (dwErr) {
        lpInfo->dwError = dwErr;
        return FALSE;
    }
    
    return fSuccess;
}

WCHAR pszRemoteHelpFmt[] = L"\\\\%s\\admin$\\system32\\%s";

DWORD 
UpdateRemoteHelpFile(
    IN PWCHAR lpszServer,
    IN DWORD dwSid,
    OUT PWCHAR* ppszFile)
{
    PWCHAR pszFile = NULL, pszMachine = NULL;
    DWORD dwSize = 0;

    pszFile = PszFromId( g_hinstDll, dwSid );
    if (pszFile == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    if ((*lpszServer) && (*lpszServer == L'\\'))
    {
        pszMachine = lpszServer + 2;
    }
    else
    {
        pszMachine = lpszServer;
    }

    dwSize = lstrlen(pszRemoteHelpFmt)  + 
             lstrlen(pszMachine)        + 
             lstrlen(pszFile)           +
             1;
    dwSize *= 2;

    // Free the previous setting
    //
    Free0(*ppszFile);
    *ppszFile = (PWCHAR) Malloc(dwSize);
    if (*ppszFile == NULL)
    {
        Free0(pszFile);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    wsprintfW(*ppszFile, pszRemoteHelpFmt, pszMachine, pszFile);
    
    Free0(pszFile);

    return NO_ERROR;
}

BOOL APIENTRY
RouterEntryDlgW(
    IN     LPWSTR         lpszServer,
    IN     LPWSTR         lpszPhonebook,
    IN     LPWSTR         lpszEntry,
    IN OUT LPRASENTRYDLGW lpInfo )
{
    BOOL fSuccess;
    DWORD dwErr;

    TRACE("RouterEntryDlgW");
    TRACEW1("  s=%s",(lpszServer)?lpszServer:TEXT(""));
    TRACEW1("  p=%s",(lpszPhonebook)?lpszPhonebook:TEXT(""));
    TRACEW1("  e=%s",(lpszEntry)?lpszEntry:TEXT(""));

    if (!lpszServer)
        g_wszServer[0] = L'\0';
    else
        lstrcpyW(g_wszServer, lpszServer);

    // 
    // Reset the global router help file to be the one
    // already installed on the nt4 machine.
    //
    if (lpszServer)
    {
        dwErr = UpdateRemoteHelpFile(
                    lpszServer, 
                    SID_HelpFile, 
                    &g_pszHelpFile);
        if (dwErr != NO_ERROR)
        {
            return dwErr;
        }
        
        dwErr = UpdateRemoteHelpFile(
                    lpszServer, 
                    SID_RouterHelpFile, 
                    &g_pszRouterHelpFile);
        if (dwErr != NO_ERROR)
        {
            return dwErr;
        }
    }
        
    //
    // Set the RPC server before calling RasEntryDlg.
    //
    dwErr = LoadRasRpcDll(lpszServer);
    if (dwErr) {
        lpInfo->dwError = dwErr;
        return FALSE;
    }
    //
    // Load MprApi entrypoints
    //
    dwErr = LoadMpradminDll();
    if (dwErr) {
        LoadRasRpcDll(NULL);
        lpInfo->dwError = dwErr;
        return FALSE;
    }
    //
    // Call the existing UI.
    //
    fSuccess = RasEntryDlgW(lpszPhonebook, lpszEntry, lpInfo);
    //
    // Unload MprApi entrypoints
    //
    UnloadMpradminDll();
    //
    // Unset the RPC server.
    //
    dwErr = LoadRasRpcDll(NULL);
    if (dwErr) {
        lpInfo->dwError = dwErr;
        return FALSE;
    }

    return fSuccess;
}


/*----------------------------------------------------------------------------
** Phonebook Entry common routines
** Listed alphabetically
**----------------------------------------------------------------------------
*/

BOOL
EuCommit(
    IN EINFO* pInfo )

    /* Commits the new or changed entry node to the phonebook file and list.
    ** Also adds the area code to the per-user list, if indicated.  'PInfo' is
    ** the common entry information block.
    **
    ** Returns true if successful, false otherwise.
    */
{
    DWORD dwErr;
    BOOL  fEditMode;
    BOOL  fChangedNameInEditMode;

    /* Delete all disabled link nodes.
    */
    if (DtlGetNodes( pInfo->pEntry->pdtllistLinks ) > 1)
    {
        DTLNODE* pNode;

        pNode = DtlGetFirstNode( pInfo->pEntry->pdtllistLinks );
        while (pNode)
        {
            PBLINK*  pLink = (PBLINK* )DtlGetData( pNode );
            DTLNODE* pNextNode = DtlGetNextNode( pNode );

            if (!pLink->fEnabled)
            {
                DtlRemoveNode( pInfo->pEntry->pdtllistLinks, pNode );
                DestroyLinkNode( pNode );
            }

            pNode = pNextNode;
        }
    }

    /* Add the area code to the per-user list.
    */
    if (pInfo->pEntry->pszAreaCode)
    {
        TCHAR*   pszNewAreaCode = NULL;
        DTLNODE* pNodeNew;
        DTLNODE* pNode;

        /* Create a new node for the current area code and add it to the list
        ** head.
        */
        pszNewAreaCode = StrDup( pInfo->pEntry->pszAreaCode );
        if (!pszNewAreaCode)
            return FALSE;

        pNodeNew = DtlCreateNode( pszNewAreaCode, 0 );
        if (!pNodeNew)
        {
            Free( pszNewAreaCode );
            return FALSE;
        }

        DtlAddNodeFirst( pInfo->pUser->pdtllistAreaCodes, pNodeNew );

        /* Delete any other occurrence of the same area code later in the
        ** list.
        */
        pNode = DtlGetNextNode( pNodeNew );

        while (pNode)
        {
            TCHAR*   pszAreaCode;
            DTLNODE* pNodeNext;

            pNodeNext = DtlGetNextNode( pNode );

            pszAreaCode = (TCHAR* )DtlGetData( pNode );
            if (lstrcmp( pszAreaCode, pszNewAreaCode ) == 0)
            {
                DtlRemoveNode( pInfo->pUser->pdtllistAreaCodes, pNode );
                DestroyPszNode( pNode );
            }

            pNode = pNodeNext;
        }

        Free0( pszNewAreaCode );
        pInfo->pUser->fDirty = TRUE;
    }

    /* Notice if user changed his area-code/country-code preference.
    */
    if ((pInfo->pApiArgs->dwFlags & RASEDFLAG_NewEntry)
        && pInfo->pUser->fUseAreaAndCountry
              != pInfo->pEntry->fUseCountryAndAreaCode)
    {
        pInfo->pUser->fUseAreaAndCountry =
            pInfo->pEntry->fUseCountryAndAreaCode;

        pInfo->pUser->fDirty = TRUE;
    }

    /* Save preferences if they've changed.
    */
    if (pInfo->pUser->fDirty)
    {
        if (g_pSetUserPreferences(
                pInfo->pUser,
                (pInfo->fRouter) ? UPM_Router : UPM_Normal ) != 0)
        {
            return FALSE;
        }
    }

    /* Save the changed phonebook entry.
    */
    pInfo->pEntry->fDirty = TRUE;

    /* The final name of the entry is output to caller via API structure.
    */
    lstrcpy( pInfo->pApiArgs->szEntry, pInfo->pEntry->pszEntryName );

    /* Delete the old node if in edit mode, then add the new node.
    */
    EuGetEditFlags( pInfo, &fEditMode, &fChangedNameInEditMode );

    if (fEditMode)
        DtlDeleteNode( pInfo->pFile->pdtllistEntries, pInfo->pOldNode );

    DtlAddNodeLast( pInfo->pFile->pdtllistEntries, pInfo->pNode );
    pInfo->pNode = NULL;

    /* Write the change to the phone book file.
    */
    dwErr = WritePhonebookFile( pInfo->pFile,
                (fChangedNameInEditMode) ? pInfo->szOldEntryName : NULL );

    if (dwErr != 0)
    {
        ErrorDlg( pInfo->pApiArgs->hwndOwner, SID_OP_WritePhonebook, dwErr,
            NULL );
        return FALSE;
    }

    /* If the user is creating a new router-phonebook entry,
    ** and the user is using the router wizard to create it,
    ** and the user did not edit properties directly,
    ** save the dial-out credentials, and optionally, the dial-in credentials.
    */
    if ((pInfo->pApiArgs->dwFlags & RASEDFLAG_NewEntry)
        && pInfo->fRouter
        && pInfo->pUser->fNewEntryWizard
        && !pInfo->fChainPropertySheet)
    {
        dwErr = EuCommitCredentials(pInfo);
    }

    /* If the user edited/created a router-phonebook entry,
    ** store the bitmask of selected network-protocols in 'reserved2'.
    */
    if (pInfo->fRouter)
        pInfo->pApiArgs->reserved2 =
            ((NP_Ip|NP_Ipx) & ~pInfo->pEntry->dwfExcludedProtocols);

    pInfo->pApiArgs->dwError = 0;
    return TRUE;
}


DWORD
EuCommitCredentials(
    IN  EINFO*  pInfo )

    /* Commits the credentials and user-account for a router interface.
    */
{
    DWORD   dwErr;
    DWORD   dwPos;
    HANDLE  hServer;
    HANDLE  hInterface;
    WCHAR*  pwszInterface = NULL;

    TRACE("EuCommitCredentials");
    /* Connect to the router service
    */
    dwErr = g_pMprAdminServerConnect(g_wszServer, &hServer);
    if (dwErr != NO_ERROR)
        return dwErr;

    do
    {
        RAS_USER_0 ru0;
        USER_INFO_1 ui1;
        MPR_INTERFACE_0 mi0;

        /* Initialize the interface-information structure.
        */
        ZeroMemory(&mi0, sizeof(mi0));

        mi0.dwIfType = ROUTER_IF_TYPE_FULL_ROUTER;
        mi0.fEnabled = TRUE;
        pwszInterface = StrDupWFromT(pInfo->pEntry->pszEntryName);
        if (!pwszInterface)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }
        lstrcpyW(mi0.wszInterfaceName, pwszInterface);

        /* Create the interface.
        */
        dwErr = g_pMprAdminInterfaceCreate(
                    hServer, 0, (BYTE*)&mi0, &hInterface );
        if (dwErr) {
            TRACE1("EuCommitCredentials: MprAdminInterfaceCreate error %d", dwErr);
            break;
        }


        /* Set the dial-out credentials for the interface.
        ** Stop after this if an error occurs, or if we don't need
        ** to add a user-account.
        */
        dwErr = g_pMprAdminInterfaceSetCredentials(
                    g_wszServer, pwszInterface, pInfo->pszRouterUserName,
                    pInfo->pszRouterDomain, pInfo->pszRouterPassword );
        if (dwErr || !pInfo->fAddUser)
        {
            if(dwErr)
                TRACE1("EuCommitCredentials: MprAdminInterfaceSetCredentials error %d", dwErr);
            break;
        }

        /* Initialize user-information structure.
        */
        ZeroMemory(&ui1, sizeof(ui1));

        ui1.usri1_name = pwszInterface;
        ui1.usri1_password = StrDupWFromT(pInfo->pszRouterDialInPassword);
        ui1.usri1_priv = USER_PRIV_USER;
        ui1.usri1_comment = PszFromId(g_hinstDll, SID_RouterDialInAccount);
        ui1.usri1_flags = UF_SCRIPT|UF_NORMAL_ACCOUNT|UF_DONT_EXPIRE_PASSWD;


        /* Add the user-account.
        */
        {
            WCHAR pszComputer[256], *pszMachine = NULL;

            if (g_wszServer == NULL)
            {
                pszMachine = NULL;
            }
            else
            {
                pszMachine = pszComputer;

                if (*g_wszServer == L'\\')
                {
                    wcscpy(pszMachine, g_wszServer);
                }
                else
                {
                    wcscpy(pszMachine, L"\\\\");
                    wcscpy(pszMachine + 2, g_wszServer);
                }
            }
            
            dwErr = NetUserAdd(pszMachine, 1, (BYTE*)&ui1, &dwPos);

            ZeroMemory(
                ui1.usri1_password, lstrlen(ui1.usri1_password) * sizeof(TCHAR));
            Free0(ui1.usri1_password);
            Free0(ui1.usri1_comment);

            if (dwErr) {
                TRACE1("EuCommitCredentials: NetUserAdd error %d", dwErr);
                break;
            }
        }            

        /* Initialize the RAS user-settings structure.
        */
        ZeroMemory(&ru0, sizeof(ru0));

        ru0.bfPrivilege = RASPRIV_NoCallback|RASPRIV_DialinPrivilege;


        /* Enable dial-in access for the user-account.
        */
        dwErr = g_pRasAdminUserSetInfo(
                    g_wszServer, pwszInterface, 0, (BYTE*)&ru0);
        if(dwErr)
            TRACE1("EuCommitCredentials: RasAdminUserSetInfo error %d", dwErr);

    } while(FALSE);

    if (pwszInterface)
        Free(pwszInterface);

    g_pMprAdminServerDisconnect(hServer);

    return dwErr;
}


VOID
EuEditScpScript(
    IN HWND   hwndOwner,
    IN TCHAR* pszScript )

    /* Starts notepad.exe on the 'pszScript' script path.  'HwndOwner' is the
    ** window to center any error popup on.  'PEinfo' is the common entry
    ** context.
    */
{
    TCHAR               szCmd[ (MAX_PATH * 2) + 50 + 1 ];
    STARTUPINFO         si;
    PROCESS_INFORMATION pi;
    BOOL                f;

    wsprintf( szCmd, TEXT("notepad.exe %s"), pszScript );

    ZeroMemory( &si, sizeof(si) );
    si.cb = sizeof(si);

    TRACEW1("EuEditScp-cmd=%s",szCmd);

    f = CreateProcess(
            NULL, szCmd, NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi );

    if (f)
    {
        CloseHandle( pi.hThread );
        CloseHandle( pi.hProcess );
    }
    else
    {
        ErrorDlg( hwndOwner, SID_OP_LoadSwitchEditor, GetLastError(), NULL );
    }
}


VOID
EuEditSwitchInf(
    IN HWND hwndOwner )

    /* Starts notepad.exe on the system script file, switch.inf.  'HwndOwner'
    ** is the window to center any error popup on.
    */
{
    TCHAR               szCmd[ (MAX_PATH * 2) + 50 + 1 ];
    TCHAR               szSysDir[ MAX_PATH + 1 ];
    STARTUPINFO         si;
    PROCESS_INFORMATION pi;
    BOOL                f;

    szSysDir[ 0 ] = TEXT('\0');
    g_pGetSystemDirectory( szSysDir, MAX_PATH );

    wsprintf( szCmd, TEXT("notepad.exe %s\\ras\\switch.inf"), szSysDir );

    ZeroMemory( &si, sizeof(si) );
    si.cb = sizeof(si);

    TRACEW1("EuEditInf-cmd=%s",szCmd);

    f = CreateProcess(
            NULL, szCmd, NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi );

    if (f)
    {
        CloseHandle( pi.hThread );
        CloseHandle( pi.hProcess );
    }
    else
    {
        ErrorDlg( hwndOwner, SID_OP_LoadSwitchEditor, GetLastError(), NULL );
    }
}


VOID
EuFillAreaCodeList(
    IN EINFO* pEinfo,
    IN HWND   hwndClbAreaCodes )

    /* Fill the area code list 'hwndClbAreaCodes' and set the selection to the
    ** area code in the entry, unless it's already been filled.  'PEinfo' is
    ** the common entry context.
    */
{
    DTLLIST* pList;
    DTLNODE* pNode;
    PBENTRY* pEntry;

    TRACE("EuFillAreaCodeList");

    if (ComboBox_GetCount( hwndClbAreaCodes ) > 0)
        return;

    pList = pEinfo->pUser->pdtllistAreaCodes;
    ASSERT(pList);
    pEntry = pEinfo->pEntry;
    ASSERT(pEntry);

    ComboBox_LimitText( hwndClbAreaCodes, RAS_MaxAreaCode );

    /* Add this entry's area code first.
    */
    if (pEntry->pszAreaCode)
        ComboBox_AddString( hwndClbAreaCodes, pEntry->pszAreaCode );

    /* Append the per-user list of area codes, skipping the one we already
    ** added.
    */
    for (pNode = DtlGetFirstNode( pList );
         pNode;
         pNode = DtlGetNextNode( pNode ))
    {
        TCHAR* pszAreaCode = (TCHAR* )DtlGetData( pNode );

        if (!pEntry->pszAreaCode
            || lstrcmp( pszAreaCode, pEntry->pszAreaCode ) != 0)
        {
            ComboBox_AddString( hwndClbAreaCodes, pszAreaCode );
        }
    }

    ComboBox_AutoSizeDroppedWidth( hwndClbAreaCodes );

    /* Select the first item, which will be this entry's code, if any.
    */
    if (ComboBox_GetCount( hwndClbAreaCodes ) > 0)
        ComboBox_SetCurSel( hwndClbAreaCodes, 0 );
}


VOID
EuFillCountryCodeList(
    IN EINFO* pEinfo,
    IN HWND   hwndLbCountryCodes,
    IN BOOL   fComplete )

    /* Fill the country code list 'hwndLbCountryCodes' and set the selection
    ** to the one in the entry, unless it's filled already.  If 'fComplete' is
    ** set the list is completedly filled, otherwise only the current entry's
    ** country code is loaded.  'PEinfo' is the common entry context.  'HwndDlg' is
    ** the dialog owning the
    */
{
    DWORD    dwErr;
    COUNTRY* pCountries;
    COUNTRY* pCountry;
    DWORD    cCountries;
    DWORD    i;

    TRACE1("EuFillCountryCodeList(f=%d)",fComplete);

    /* There are 3 items in a partial list, the single visible country code
    ** and the dummy items before and after used to give correct behavior when
    ** left/right arrows are pressed.
    */
    cCountries = ComboBox_GetCount( hwndLbCountryCodes );
    if (cCountries > 3 || (!fComplete && cCountries == 3))
        return;

    /* Release old data buffer if already partially loaded.
    */
    if (pEinfo->pCountries)
        FreeCountryInfo( pEinfo->pCountries, pEinfo->cCountries );

    pCountries = NULL;
    cCountries = 0;

    dwErr = GetCountryInfo( &pCountries, &cCountries,
                (fComplete) ? 0 : pEinfo->pEntry->dwCountryID );
    if (dwErr == 0)
    {
        ComboBox_ResetContent( hwndLbCountryCodes );

        if (!fComplete)
        {
            /* Add dummy item first in partial list so left arrow selection
            ** change can be handled correctly.  See CBN_SELCHANGE handling.
            */
            ComboBox_AddItem(
                hwndLbCountryCodes, TEXT("AAAAA"), (VOID* )-1 );
        }

        for (i = 0, pCountry = pCountries;
             i < cCountries;
             ++i, ++pCountry)
        {
            INT   iItem;
            TCHAR szBuf[ 512 ];

            wsprintf( szBuf, TEXT("%s (%d)"),
                pCountry->pszName, pCountry->dwCode );

            iItem = ComboBox_AddItem(
                hwndLbCountryCodes, szBuf, pCountry );

            /* If it's the one in the entry, select it.
            */
            if (pCountry->dwId == pEinfo->pEntry->dwCountryID)
                ComboBox_SetCurSel( hwndLbCountryCodes, iItem );
        }

        if (!fComplete)
        {
            /* Add dummy item last in partial list so right arrow selection
            ** change can be handled correctly.  See CBN_SELCHANGE handling.
            */
            ComboBox_AddItem(
                hwndLbCountryCodes, TEXT("ZZZZZ"), (VOID* )1 );
        }

        ComboBox_AutoSizeDroppedWidth( hwndLbCountryCodes );

        if (dwErr == 0 && cCountries == 0)
            dwErr = ERROR_TAPI_CONFIGURATION;
    }

    if (dwErr != 0)
    {
        ErrorDlg( GetParent( hwndLbCountryCodes ),
            SID_OP_LoadTapiInfo, dwErr, NULL );
        return;
    }

    if (ComboBox_GetCurSel( hwndLbCountryCodes ) < 0)
    {
        /* The entry's country code was not added to the list, so as an
        ** alternate select the first country in the list, loading the whole
        ** list if necessary...should be extremely rare, a diddled phonebook
        ** or TAPI country list strangeness.
        */
        if (ComboBox_GetCount( hwndLbCountryCodes ) > 0)
            ComboBox_SetCurSel( hwndLbCountryCodes, 0 );
        else
        {
            FreeCountryInfo( pCountries, cCountries );
            EuFillCountryCodeList( pEinfo, hwndLbCountryCodes, TRUE );
            return;
        }
    }

    /* Will be freed by EuFree.
    */
    pEinfo->pCountries = pCountries;
    pEinfo->cCountries = cCountries;
}


VOID
EuFillScriptsList(
    IN EINFO* pEinfo,
    IN HWND   hwndLbScripts,
    IN TCHAR* pszSelection )

    /* Fill scripts list in working entry of common entry context 'pEinfo'.
    ** The old list, if any, is freed.  Select the script from user's entry.
    ** 'HwndLbScripts' is the script dropdown.  'PszSelection' is the selected
    ** name from the phonebook or NULL for "(none)".  If the name is non-NULL
    ** but not found in the list it is appended.
    */
{
    DWORD    dwErr;
    DTLNODE* pNode;
    INT      nIndex;
    DTLLIST* pList;

    TRACE("EuFillScriptsList");

    ComboBox_ResetContent( hwndLbScripts );
    ComboBox_AddItemFromId(
        g_hinstDll, hwndLbScripts, SID_NoneSelected, NULL );
    ComboBox_SetCurSel( hwndLbScripts, 0 );

    pList = NULL;
    dwErr = LoadScriptsList( &pList );
    if (dwErr != 0)
    {
        ErrorDlg( GetParent( hwndLbScripts ),
            SID_OP_LoadScriptInfo, dwErr, NULL );
        return;
    }

    DtlDestroyList( pEinfo->pListScripts, DestroyPszNode );
    pEinfo->pListScripts = pList;

    for (pNode = DtlGetFirstNode( pEinfo->pListScripts );
         pNode;
         pNode = DtlGetNextNode( pNode ))
    {
        TCHAR* psz;

        psz = (TCHAR* )DtlGetData( pNode );
        nIndex = ComboBox_AddString( hwndLbScripts, psz );

        if (pszSelection && lstrcmp( psz, pszSelection ) == 0)
            ComboBox_SetCurSel( hwndLbScripts, nIndex );
    }

    if (pszSelection && ComboBox_GetCurSel( hwndLbScripts ) <= 0)
    {
        nIndex = ComboBox_AddString( hwndLbScripts, pszSelection );
        if (nIndex >= 0)
            ComboBox_SetCurSel( hwndLbScripts, nIndex );
    }

    ComboBox_AutoSizeDroppedWidth( hwndLbScripts );
}


VOID
EuFillDoubleScriptsList(
    IN EINFO* pEinfo,
    IN HWND   hwndLbScripts,
    IN TCHAR* pszSelection )

    /* Fill double scripts list (switch.inf entries and .SCP files) in working
    ** entry of common entry context 'pEinfo'.  The old list, if any, is
    ** freed.  Select the script from user's entry.  'HwndLbScripts' is the
    ** script combobox.  'PszSelection' is the selected name from the
    ** phonebook or NULL for "(none)".  If the name is non-NULL but not found
    ** in the list it is appended.
    */
{
    DWORD    dwErr;
    DTLNODE* pNode;
    INT      nIndex;
    DTLLIST* pList;
    DTLLIST* pListScp;

    TRACE("EuFillDoubleScriptsList");

    ComboBox_ResetContent( hwndLbScripts );
    ComboBox_AddItemFromId(
        g_hinstDll, hwndLbScripts, SID_NoneSelected, NULL );
    ComboBox_SetCurSel( hwndLbScripts, 0 );

    pList = NULL;
    dwErr = LoadScriptsList( &pList );
    if (dwErr != 0)
    {
        ErrorDlg( GetParent( hwndLbScripts ),
            SID_OP_LoadScriptInfo, dwErr, NULL );
        return;
    }

    pListScp = NULL;
    dwErr = EuLoadScpScriptsList( &pListScp );
    if (dwErr == 0)
    {
        while (pNode = DtlGetFirstNode( pListScp ))
        {
            DtlRemoveNode( pListScp, pNode );
            DtlAddNodeLast( pList, pNode );
        }

        DtlDestroyList( pListScp, NULL );
    }

    DtlDestroyList( pEinfo->pListDoubleScripts, DestroyPszNode );
    pEinfo->pListDoubleScripts = pList;

    for (pNode = DtlGetFirstNode( pEinfo->pListDoubleScripts );
         pNode;
         pNode = DtlGetNextNode( pNode ))
    {
        TCHAR* psz;

        psz = (TCHAR* )DtlGetData( pNode );
        nIndex = ComboBox_AddString( hwndLbScripts, psz );

        if (pszSelection && lstrcmp( psz, pszSelection ) == 0)
            ComboBox_SetCurSel( hwndLbScripts, nIndex );
    }

    if (pszSelection && ComboBox_GetCurSel( hwndLbScripts ) <= 0)
    {
        nIndex = ComboBox_AddString( hwndLbScripts, pszSelection );
        if (nIndex >= 0)
            ComboBox_SetCurSel( hwndLbScripts, nIndex );
    }

    ComboBox_AutoSizeDroppedWidth( hwndLbScripts );
}


VOID
EuFree(
    IN EINFO* pInfo )

    /* Releases memory associated with 'pInfo'.
    */
{
    TCHAR* psz;
    INTERNALARGS* piargs;

    piargs = (INTERNALARGS* )pInfo->pApiArgs->reserved;

    /* Don't clean up the phonebook and user preferences if they arrived
    ** via the secret hack.
    */
    if (!piargs)
    {
        if (pInfo->pFile)
            ClosePhonebookFile( pInfo->pFile );

        if (pInfo->pUser)
            DestroyUserPreferences( pInfo->pUser );
    }

    DtlDestroyList( pInfo->pListScripts, DestroyPszNode );
    DtlDestroyList( pInfo->pListDoubleScripts, DestroyPszNode );

    if (pInfo->pNode)
        DestroyEntryNode( pInfo->pNode );

    if (pInfo->pCountries)
        FreeCountryInfo( pInfo->pCountries, pInfo->cCountries );

    /* Free router-information
    */
    Free0(pInfo->pszRouter);
    Free0(pInfo->pszRouterUserName);
    Free0(pInfo->pszRouterDomain);
    if (psz = pInfo->pszRouterPassword)
    {
        ZeroMemory(psz, lstrlen(psz) * sizeof(TCHAR));
        Free(psz);
    }
    if (psz = pInfo->pszRouterDialInPassword)
    {
        ZeroMemory(psz, lstrlen(psz) * sizeof(TCHAR));
        Free(psz);
    }
}


VOID
EuGetEditFlags(
    IN  EINFO* pEinfo,
    OUT BOOL*  pfEditMode,
    OUT BOOL*  pfChangedNameInEditMode )

    /* Sets '*pfEditMode' true if in edit mode, false otherwise.  Set
    ** '*pfChangedNameInEditMode' true if the entry name was changed while in
    ** edit mode, false otherwise.  'PEinfo' is the common entry context.
    */
{
    if ((pEinfo->pApiArgs->dwFlags & RASEDFLAG_NewEntry)
        || (pEinfo->pApiArgs->dwFlags & RASEDFLAG_CloneEntry))
    {
        *pfEditMode = *pfChangedNameInEditMode = FALSE;
    }
    else
    {
        *pfEditMode = TRUE;
        *pfChangedNameInEditMode =
            (lstrcmpi( pEinfo->szOldEntryName,
                pEinfo->pEntry->pszEntryName ) != 0);
    }
}


DWORD
EuInit0(
    IN  TCHAR*       pszPhonebook,
    IN  TCHAR*       pszEntry,
    IN  RASENTRYDLG* pArgs,
    OUT EINFO*       pInfo,
    OUT DWORD*       pdwOp )

    /* Initializes 'pInfo' data just enough so the user preferences are
    ** available and it can be safely EuFree()ed, for use by the property
    ** sheet or wizard.  'PszPhonebook', 'pszEntry', and 'pArgs', are the
    ** arguments passed by user to the API.  '*pdwOp' is set to the operation
    ** code associated with any error.
    **
    ** See EuInit.
    **
    ** Returns 0 if successful or an error code.
    */
{
    DWORD dwErr;

    *pdwOp = 0;

    ZeroMemory( pInfo, sizeof(*pInfo ) );
    pInfo->pszPhonebook = pszPhonebook;
    pInfo->pszEntry = pszEntry;
    pInfo->pApiArgs = pArgs;
    pInfo->fRouter = RasRpcDllLoaded();
    if (pInfo->fRouter)
        pInfo->pszRouter = StrDupTFromW(g_wszServer);

    /* Load the user preferences, or figure out that caller has already loaded
    ** them.
    */
    if (pArgs->reserved)
    {
        INTERNALARGS* piargs;

        /* We've received user preferences and the "no user" status via the
        ** secret hack.
        */
        piargs = (INTERNALARGS* )pArgs->reserved;
        pInfo->pUser = piargs->pUser;
        pInfo->fNoUser = piargs->fNoUser;
    }
    else
    {
        /* Read user preferences from registry.
        */
        dwErr = g_pGetUserPreferences(
            &pInfo->user, (pInfo->fRouter) ? UPM_Router : UPM_Normal );
        if (dwErr != 0)
        {
            *pdwOp = SID_OP_LoadPrefs;
            return dwErr;
        }

        pInfo->pUser = &pInfo->user;
    }

    return 0;
}


DWORD
EuInit(
    OUT EINFO* pInfo,
    OUT DWORD* pdwOp )

    /* Initializes 'pInfo' data for use by the property sheet or wizard.
    ** 'PszPhonebook', 'pszEntry', and 'pArgs', are the arguments passed by
    ** user to the API.  '*pdwOp' is set to the operation code associated with
    ** any error.
    **
    ** Assumes EuInit0 has been previously called.
    **
    ** Returns 0 if successful, or an error code.
    */
{
    DWORD    dwErr;
    DTLLIST* pListPorts;

    *pdwOp = 0;

    /* Load the phonebook file or figure out that caller already loaded it.
    */
    if (pInfo->pApiArgs->reserved)
    {
        INTERNALARGS* piargs;

        /* We've received an open phonebook file, user preferences, and
        ** possibly user-less information via the secret hack.
        */
        piargs = (INTERNALARGS* )pInfo->pApiArgs->reserved;
        pInfo->pFile = piargs->pFile;
    }
    else
    {
        /* Load and parse the phonebook file.
        */
        dwErr = ReadPhonebookFile(
            pInfo->pszPhonebook, &pInfo->user, NULL,
            (pInfo->fRouter) ? RPBF_Router : 0,
            &pInfo->file );
        if (dwErr != 0)
        {
            *pdwOp = SID_OP_LoadPhonebook;
            return dwErr;
        }

        pInfo->pFile = &pInfo->file;
    }

    /* Load the list of ports.
    */
    dwErr = LoadPortsList2( &pListPorts, pInfo->fRouter );
    if (dwErr != 0)
    {
        TRACE1("LoadPortsList=%d",dwErr);
        *pdwOp = SID_OP_RetrievingData;
        return dwErr;
    }

    if (DtlGetNodes( pListPorts ) <= 0)
        pInfo->fNoPortsConfigured = TRUE;

    /* Set up work entry node.
    */
    if (pInfo->pApiArgs->dwFlags & RASEDFLAG_NewEntry)
    {
        DTLNODE* pNodeL;
        DTLNODE* pNodeP;
        PBLINK*  pLink;
        PBPORT*  pPort;

        /* New entry mode, so 'pNode' set to default settings.
        */
        pInfo->pNode = CreateEntryNode( TRUE );
        if (!pInfo->pNode)
        {
            TRACE("CreateEntryNode failed");
            *pdwOp = SID_OP_RetrievingData;
            return dwErr;
        }

        /* Store entry within work node stored in context for convenience
        ** elsewhere.
        */
        pInfo->pEntry = (PBENTRY* )DtlGetData( pInfo->pNode );
        ASSERT(pInfo->pEntry);

        if (pInfo->fRouter)
        {
            /* Set router specific defaults.
            */
            pInfo->pEntry->dwIpNameSource = ASRC_None;
        }

        /* Use caller's last choice for area and country code.
        */
        if (pInfo->pUser->fUseAreaAndCountry)
            pInfo->pEntry->fUseCountryAndAreaCode = TRUE;

        /* Use caller's default name, if any.
        */
        if (pInfo->pszEntry)
            pInfo->pEntry->pszEntryName = StrDup( pInfo->pszEntry );

        /* Set an appropriate default device.
        */
        pNodeL = DtlGetFirstNode( pInfo->pEntry->pdtllistLinks );
        ASSERT(pNodeL);
        pLink = (PBLINK* )DtlGetData( pNodeL );
        ASSERT(pLink);

        pNodeP = DtlGetFirstNode( pListPorts );
        if (!pNodeP)
        {
            TRACE("No ports configured");
            pNodeP = CreatePortNode();
        }

        if (pNodeP)
        {
            pPort = (PBPORT* )DtlGetData( pNodeP );

            if (pInfo->fNoPortsConfigured)
            {
                /* Make up a bogus COM port with unknown Unimodem attached.
                ** Hereafter, this will behave like an entry whose modem has
                ** been de-installed.
                */
                pPort->pszPort = PszFromId( g_hinstDll, SID_DefaultPort );
                pPort->fConfigured = FALSE;
                pPort->pszMedia = StrDup( TEXT(SERIAL_TXT) );
                pPort->pbdevicetype = PBDT_Modem;
            }

            CopyToPbport( &pLink->pbport, pPort );
            if (pLink->pbport.pbdevicetype == PBDT_Modem)
                SetDefaultModemSettings( pLink );
        }

        if (!pNodeP || !pLink->pbport.pszPort || !pLink->pbport.pszMedia)
        {
            *pdwOp = SID_OP_RetrievingData;
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }
    else
    {
        DTLNODE* pNode;

        /* Edit or clone entry mode, so 'pNode' set to entry's current
        ** settings.
        */
        pInfo->pOldNode = EntryNodeFromName(
            pInfo->pFile->pdtllistEntries, pInfo->pszEntry );

        if (!pInfo->pOldNode)
        {
            *pdwOp = SID_OP_RetrievingData;
            return ERROR_CANNOT_FIND_PHONEBOOK_ENTRY;
        }

        if (pInfo->pApiArgs->dwFlags & RASEDFLAG_CloneEntry)
            pInfo->pNode = CloneEntryNode( pInfo->pOldNode );
        else
            pInfo->pNode = DuplicateEntryNode( pInfo->pOldNode );
        if (!pInfo->pNode)
        {
            TRACE("DuplicateEntryNode failed");
            *pdwOp = SID_OP_RetrievingData;
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        /* Store entry within work node stored in context for convenience
        ** elsewhere.
        */
        pInfo->pEntry = (PBENTRY* )DtlGetData( pInfo->pNode );

        /* Save original entry name for comparison later.
        */
        lstrcpy( pInfo->szOldEntryName, pInfo->pEntry->pszEntryName );

        /* For router, want unconfigured ports to show up as "unavailable" so
        ** they stand out to user who has been directed to change them.
        */
        if (pInfo->fRouter)
        {
            DTLNODE* pNodeL;
            PBLINK* pLink;

            pNodeL = DtlGetFirstNode( pInfo->pEntry->pdtllistLinks );
            pLink = (PBLINK* )DtlGetData( pNodeL );

            if (!pLink->pbport.fConfigured)
            {
                Free0( pLink->pbport.pszDevice );
                pLink->pbport.pszDevice = NULL;
            }
        }
    }

    /* Append links containing all remaining configured ports to the list of
    ** links with the new links marked "unenabled".  This lets us make the
    ** port<->port and single-link<->multi-link transitions behave more as
    ** user expects.
    */
    {
        DTLNODE* pNodeP;
        DTLNODE* pNodeL;

        for (pNodeP = DtlGetFirstNode( pListPorts );
             pNodeP;
             pNodeP = DtlGetNextNode( pNodeP ))
        {
            PBPORT* pPort;
            BOOL    fPortUsed;

            pPort = (PBPORT* )DtlGetData( pNodeP );
            fPortUsed = FALSE;

            for (pNodeL = DtlGetFirstNode( pInfo->pEntry->pdtllistLinks );
                 pNodeL;
                 pNodeL = DtlGetNextNode( pNodeL ))
            {
                PBLINK* pLink = (PBLINK* )DtlGetData( pNodeL );

                ASSERT( pPort->pszPort );
                ASSERT( pLink->pbport.pszPort );

                if (lstrcmp( pLink->pbport.pszPort, pPort->pszPort ) == 0)
                {
                    fPortUsed = TRUE;
                    break;
                }
            }

            if (!fPortUsed)
            {
                DTLNODE* pNode;

                pNode = CreateLinkNode();
                if (pNode)
                {
                    PBLINK* pLink = (PBLINK* )DtlGetData( pNode );

                    if (CopyToPbport( &pLink->pbport, pPort ) != 0)
                        DestroyLinkNode( pNode );
                    else
                    {
                        if (pPort->pbdevicetype == PBDT_Modem)
                            SetDefaultModemSettings( pLink );

                        pLink->fEnabled = FALSE;
                        DtlAddNodeLast( pInfo->pEntry->pdtllistLinks, pNode );
                    }
                }
            }
        }
    }

    DtlDestroyList( pListPorts, DestroyPortNode );

    if (pInfo->fRouter)
    {
        pInfo->pEntry->dwfExcludedProtocols |= NP_Nbf;
        pInfo->pEntry->fIpPrioritizeRemote = FALSE;
    }

    return 0;
}


VOID
EuLbCountryCodeSelChange(
    IN EINFO* pEinfo,
    IN HWND   hwndLbCountryCodes )

    /* Called when the country list selection has changed.  'PEinfo' is the
    ** common entry context.  'HwndLbCountryCode' is the country code
    ** combobox.
    */
{
    LONG lSign;
    LONG i;

    TRACE("EuLbCountryCodeSelChange");

    /* Make sure all the country codes are loaded.  When a partial list is
    ** there are dummy entries placed before and after the single country
    ** code.  This allows us to give transparent behavior when user presses
    ** left/right arrows to change selection.
    */
    lSign =
        (LONG )ComboBox_GetItemData( hwndLbCountryCodes,
                   ComboBox_GetCurSel( hwndLbCountryCodes ) );

    if (lSign != -1 && lSign != 1)
        lSign = 0;

    EuFillCountryCodeList( pEinfo, hwndLbCountryCodes, TRUE );

    i = (LONG )ComboBox_GetCurSel( hwndLbCountryCodes );
    if (ComboBox_SetCurSel( hwndLbCountryCodes, i + lSign ) < 0)
        ComboBox_SetCurSel( hwndLbCountryCodes, i );
}


DWORD
EuLoadScpScriptsList(
    OUT DTLLIST** ppList )

    /* Loads '*ppList' with a list of Psz nodes containing the pathnames of
    ** the .SCP files in the RAS directory.  It is caller's responsibility to
    ** call DtlDestroyList on the returned list.
    **
    ** Returns 0 if successful or an error code.
    */
{
    UINT            cch;
    TCHAR           szPath[ MAX_PATH ];
    TCHAR*          pszFile;
    WIN32_FIND_DATA data;
    HANDLE          h;
    DTLLIST*        pList;

    cch = g_pGetSystemDirectory( szPath, MAX_PATH );
    if (cch == 0)
        return GetLastError();

    pList = DtlCreateList( 0L );
    if (!pList)
        return ERROR_NOT_ENOUGH_MEMORY;

    lstrcat( szPath, TEXT("\\ras\\*.scp") );

    h = FindFirstFile( szPath, &data );
    if (h != INVALID_HANDLE_VALUE)
    {
        /* Find the address of the file name part of the path since the 'data'
        ** provides only the filename and not the rest of the path.
        */
        pszFile = szPath + lstrlen( szPath ) - 5;

        do
        {
            DTLNODE* pNode;

            /* Ignore any directories that happen to match.
            */
            if (data.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                continue;

            /* Create a Psz node with the path to the found file and append it
            ** to the end of the list.
            */
            lstrcpy( pszFile, data.cFileName );
            pNode = CreatePszNode( szPath );
            if (!pNode)
                continue;
            DtlAddNodeLast( pList, pNode );
        }
        while (FindNextFile( h, &data ));

        FindClose( h );
    }

    *ppList = pList;
    return 0;
}


VOID
EuPhoneNumberStashFromEntry(
    IN     EINFO*    pEinfo,
    IN OUT DTLLIST** ppListPhoneNumbers,
    OUT    BOOL*     pfPromoteHuntNumbers )

    /* Replace single link stashed phone number settings with first link
    ** versions.  'PEinfo' is the common entry context.  '*ppListPhoneNumbers'
    ** is the current stash phone number list or NULL if none.
    ** 'PfPromoteHuntNumber' receives the "promote hunt number" flag.
    */
{
    DTLLIST* pList;
    DTLNODE* pNode;
    PBLINK*  pLink;

    TRACE("EuPhoneNumberStashFromEntry");

    pNode = DtlGetFirstNode( pEinfo->pEntry->pdtllistLinks );
    ASSERT(pNode);
    pLink = (PBLINK* )DtlGetData( pNode );
    ASSERT(pLink);
    ASSERT(pLink->pdtllistPhoneNumbers);
    pList = DtlDuplicateList( pLink->pdtllistPhoneNumbers,
        DuplicatePszNode, DestroyPszNode );
    if (pList)
    {
        DtlDestroyList( *ppListPhoneNumbers, DestroyPszNode );
        *ppListPhoneNumbers = pList;
    }
    *pfPromoteHuntNumbers = pLink->fPromoteHuntNumbers;
}


VOID
EuPhoneNumberStashToEntry(
    IN EINFO*   pEinfo,
    IN DTLLIST* pListPhoneNumbers,
    IN BOOL     fPromoteHuntNumbers,
    IN BOOL     fAllEnabled )

    /* Replace first link, or all enabled links if 'fAllEnabled' is set, phone
    ** number settings with the single link stash versions.  'PEinfo' is the
    ** common entry context.  'PListPhoneNumbers' is the current stash list.
    ** 'fPromoteHuntNumbers' is the current "promote hunt number" flag.
    */
{
    DTLLIST* pList;
    DTLNODE* pNode;
    PBLINK*  pLink;

    TRACE("EuPhoneNumberStashToEntry");

    for (pNode = DtlGetFirstNode( pEinfo->pEntry->pdtllistLinks );
         pNode;
         pNode = DtlGetNextNode( pNode ))
    {
        pLink = (PBLINK* )DtlGetData( pNode );
        ASSERT(pLink);
        ASSERT(pListPhoneNumbers );

        if (fAllEnabled && !pLink->fEnabled)
            continue;

        pList = DtlDuplicateList( pListPhoneNumbers,
            DuplicatePszNode, DestroyPszNode );
        if (pList)
        {
            DtlDestroyList( pLink->pdtllistPhoneNumbers, DestroyPszNode );
            pLink->pdtllistPhoneNumbers = pList;
        }
        pLink->fPromoteHuntNumbers = fPromoteHuntNumbers;

        if (!fAllEnabled)
            break;
    }
}


VOID
EuSaveCountryInfo(
    IN EINFO* pEinfo,
    IN HWND   hwndLbCountryCodes )

    /* Save the country code and ID from 'hwndLbCountryCodes' into the working
    ** entry in common entry context 'pEinfo'.
    */
{
    if (pEinfo->pCountries)
    {
        COUNTRY* pCountry;
        INT      iSel;

        iSel = ComboBox_GetCurSel( hwndLbCountryCodes );
        if (iSel < 0)
            return;

        pCountry = (COUNTRY* )ComboBox_GetItemDataPtr(
            hwndLbCountryCodes, iSel );

        ASSERT(pCountry);
        pEinfo->pEntry->dwCountryID = pCountry->dwId;
        pEinfo->pEntry->dwCountryCode = pCountry->dwCode;
    }
}


BOOL
EuValidateAreaCode(
    IN HWND   hwndOwner,
    IN EINFO* pEinfo )

    /* Validates the area code in the working buffer popping up a message if
    ** invalid.  'HwndOwner' is the window that owns the popup message, if
    ** any.  'PEinfo' is the common entry context.
    **
    ** Returns true if valid, false if not.
    */
{
    if (!ValidateAreaCode( pEinfo->pEntry->pszAreaCode ))
    {
        /* Invalid area code.  If it's disabled anyway, just silently lose it.
        */
        if (pEinfo->pEntry->fUseCountryAndAreaCode)
        {
            MsgDlg( hwndOwner, SID_BadAreaCode, NULL );
            return FALSE;
        }
        else
            *pEinfo->pEntry->pszAreaCode = TEXT('\0');
    }

    return TRUE;
}


BOOL
EuValidateName(
    IN HWND   hwndOwner,
    IN EINFO* pEinfo )

    /* Validates the working entry name and pops up a message if invalid.
    ** 'HwndOwner' is the window to own the error popup.  'PEinfo' is the
    ** common dialog context containing the name to validate.
    **
    ** Returns true if the name is valid, false if not.
    */
{
    PBENTRY* pEntry;
    BOOL     fEditMode;
    BOOL     fChangedNameInEditMode;

    pEntry = pEinfo->pEntry;

    /* Validate the sheet data.
    */
    if (!ValidateEntryName( pEinfo->pEntry->pszEntryName ))
    {
        /* Invalid entry name.
        */
        MsgDlg( hwndOwner, SID_BadEntry, NULL );
        return FALSE;
    }

    EuGetEditFlags( pEinfo, &fEditMode, &fChangedNameInEditMode );

    if ((fChangedNameInEditMode || !fEditMode)
        && EntryNodeFromName(
               pEinfo->pFile->pdtllistEntries, pEntry->pszEntryName ))
    {
        /* Duplicate entry name.
        */
        MSGARGS msgargs;
        ZeroMemory( &msgargs, sizeof(msgargs) );
        msgargs.apszArgs[ 0 ] = pEntry->pszEntryName;
        MsgDlg( hwndOwner, SID_DuplicateEntry, &msgargs );
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\nt4\rasdlg\devcfg.c ===
/* Copyright (c) 1995, Microsoft Corporation, all rights reserved
**
** devcfg.c
** Remote Access Common Dialog APIs
** Device configuration dialogs
**
** 10/20/95 Steve Cobb
*/

#include "rasdlgp.h"
#include "entry.h"


/*----------------------------------------------------------------------------
** Help maps
**----------------------------------------------------------------------------
*/

static DWORD g_adwIcHelp[] =
{
    CID_IC_ST_LineType,    HID_IC_LB_LineType,
    CID_IC_LB_LineType,    HID_IC_LB_LineType,
    CID_IC_CB_Fallback,    HID_IC_CB_Fallback,
    CID_IC_GB_DownLevel,   HID_IC_CB_DownLevel,
    CID_IC_CB_DownLevel,   HID_IC_CB_DownLevel,
    CID_IC_CB_Compression, HID_IC_CB_Compression,
    CID_IC_ST_Channels,    HID_IC_EB_Channels,
    CID_IC_EB_Channels,    HID_IC_EB_Channels,
    0, 0
};

static DWORD g_adwMcHelp[] =
{
    CID_MC_EB_ModemValue,     HID_MC_EB_ModemValue,
    CID_MC_ST_InitialBps,     HID_MC_LB_InitialBps,
    CID_MC_LB_InitialBps,     HID_MC_LB_InitialBps,
    CID_MC_GB_Features,       HID_MC_GB_Features,
    CID_MC_CB_FlowControl,    HID_MC_CB_FlowControl,
    CID_MC_CB_ErrorControl,   HID_MC_CB_ErrorControl,
    CID_MC_CB_Compression,    HID_MC_CB_Compression,
    CID_MC_CB_ManualDial,     HID_MC_CB_ManualDial,
    CID_MC_CB_DisableSpeaker, HID_MC_CB_DisableSpeaker,
    0, 0
};


/*----------------------------------------------------------------------------
** Local datatypes (alphabetically)
**----------------------------------------------------------------------------
*/

/* ISDN Configuration dialog argument block.
*/
#define ICARGS struct tagICARGS
ICARGS
{
    BOOL    fShowProprietary;
    PBLINK* pLink;
};


/* ISDN Configuration dialog context block.
*/
#define ICINFO struct tagICINFO
ICINFO
{
    /* Stub API arguments including shortcut to link associated with the
    ** entry.
    */
    ICARGS* pArgs;

    /* Handle of this dialog and some of it's controls.
    */
    HWND hwndDlg;
    HWND hwndLbLineType;
    HWND hwndCbFallback;
    HWND hwndCbProprietary;
    HWND hwndCbCompression;
    HWND hwndStChannels;
    HWND hwndEbChannels;
    HWND hwndUdChannels;
};


/* MXS Modem Configuration dialog context block.
*/
#define MCINFO struct tagMCINFO
MCINFO
{
    /* Stub API arguments.  Shortcut to link associated with the entry.
    */
    PBLINK* pLink;

    /* Handle of this dialog and some of it's controls.
    */
    HWND hwndDlg;
    HWND hwndEbModemValue;
    HWND hwndLbBps;
    HWND hwndCbHwFlow;
    HWND hwndCbEc;
    HWND hwndCbEcc;
    HWND hwndCbManualDial;
    HWND hwndCbDisableSpeaker;
};


/*----------------------------------------------------------------------------
** Local prototypes (alphabetically)
**----------------------------------------------------------------------------
*/

BOOL
IcCommand(
    IN HWND hwnd,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl );

INT_PTR CALLBACK
IcDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
IcInit(
    IN HWND    hwndDlg,
    IN ICARGS* pArgs );

VOID
IcTerm(
    IN HWND hwndDlg );

BOOL
IsdnConfigureDlg(
    IN HWND    hwndOwner,
    IN PBLINK* pLink,
    IN BOOL    fShowProprietary );

BOOL
ModemConfigureDlg(
    IN HWND    hwndOwner,
    IN PBLINK* pLink );

INT_PTR CALLBACK
McDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
McCommand(
    IN HWND hwnd,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl );

BOOL
McInit(
    IN HWND    hwndDlg,
    IN PBLINK* pLink );

VOID
McTerm(
    IN HWND hwndDlg );


/*----------------------------------------------------------------------------
** Device configuration dialog
**----------------------------------------------------------------------------
*/

BOOL
DeviceConfigureDlg(
    IN HWND    hwndOwner,
    IN PBLINK* pLink,
    IN BOOL    fSingleLink )

    /* Popup a dialog to edit the device 'PLink'.  'HwndOwner' is the owner of
    ** the dialog.  'FSingleLink' is true if 'pLink' is a single link entry's
    ** link and false if multi-link.
    **
    ** Returns true if user pressed OK and succeeded, false if user pressed
    ** Cancel or encountered an error.
    */
{
    DWORD dwErr;

    switch (pLink->pbport.pbdevicetype)
    {
        case PBDT_Isdn:
        {
            return IsdnConfigureDlg( hwndOwner, pLink, fSingleLink );
        }

        case PBDT_Modem:
            return ModemConfigureDlg( hwndOwner, pLink );

#if 0
        {
            DWORD dwId;

            if (pLink->pbport.fMxsModemPort)
                return ModemConfigureDlg( hwndOwner, pLink );

            dwId = DeviceIdFromDeviceName( pLink->pbport.pszDevice );

            if (dwId == 0xFFFFFFFE)
            {
                MsgDlg( hwndOwner, SID_ModemNotInstalled, NULL );
                return FALSE;
            }

            ASSERT(!pLink->pbport.fMxsModemPort);
            ASSERT(dwId!=0xFFFFFFFF);

            dwErr = TapiConfigureDlg( hwndOwner, dwId,
                        &pLink->pTapiBlob, &pLink->cbTapiBlob );
            if (dwErr != 0)
            {
                ErrorDlg( hwndOwner, SID_OP_LoadTapiInfo, dwErr, NULL );
                return FALSE;
            }
            return TRUE;
        }
#endif

        default:
            MsgDlg( hwndOwner, SID_NoConfigure, NULL );
            return FALSE;
    }
}


/*----------------------------------------------------------------------------
** ISDN configuration dialog
** Listed alphabetically following stub API and dialog proc
**----------------------------------------------------------------------------
*/

BOOL
IsdnConfigureDlg(
    IN HWND    hwndOwner,
    IN PBLINK* pLink,
    IN BOOL    fShowProprietary )

    /* Popup the ISDN device configuration dialog.  'HwndOwner' is the owner
    ** of the dialog.  'PLink' is the link to edit.  'FShowProprietary'
    ** indicates the old proprietary Digiboard options should be shown.
    **
    ** Returns true if user pressed OK and succeeded, false if user pressed
    ** Cancel or encountered an error.
    */
{
    int    nStatus;
    ICARGS args;

    TRACE("IsdnConfigureDlg");

    args.fShowProprietary = fShowProprietary;
    args.pLink = pLink;

    nStatus =
        (BOOL )DialogBoxParam(
            g_hinstDll,
            (fShowProprietary)
                ? MAKEINTRESOURCE( DID_IC_IsdnConfigure )
                : MAKEINTRESOURCE( DID_IC_IsdnConfigureMlink ),
            hwndOwner,
            IcDlgProc,
            (LPARAM )&args );

    if (nStatus == -1)
    {
        ErrorDlg( hwndOwner, SID_OP_LoadDlg, ERROR_UNKNOWN, NULL );
        nStatus = FALSE;
    }

    return (BOOL )nStatus;
}


INT_PTR CALLBACK
IcDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    /* DialogProc callback for the ISDN Configure dialog.  Parameters and
    ** return value are as described for standard windows 'DialogProc's.
    */
{
#if 0
    TRACE4("IcDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
           (DWORD)hwnd,(DWORD)unMsg,(DWORD)wparam,(DWORD)lparam);
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
            return IcInit( hwnd, (ICARGS* )lparam );

        case WM_HELP:
        case WM_CONTEXTMENU:
            ContextHelp( g_adwIcHelp, hwnd, unMsg, wparam, lparam );
            break;

        case WM_COMMAND:
        {
            return IcCommand(
                hwnd, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }

        case WM_DESTROY:
        {
            IcTerm( hwnd );
            break;
        }
    }

    return FALSE;
}


BOOL
IcCommand(
    IN HWND hwnd,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl )

    /* Called on WM_COMMAND.  'Hwnd' is the dialog window.  'WNotification' is
    ** the notification code of the command.  'wId' is the control/menu
    ** identifier of the command.  'HwndCtrl' is the control window handle of
    ** the command.
    **
    ** Returns true if processed message, false otherwise.
    */
{
    DWORD dwErr;

    TRACE2("IcCommand(n=%d,i=%d)",
        (DWORD)wNotification,(DWORD)wId);

    switch (wId)
    {
        case CID_IC_CB_DownLevel:
        {
            if (wNotification == BN_CLICKED)
            {
                BOOL    fCheck;
                ICINFO* pInfo;

                pInfo = (ICINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
                ASSERT(pInfo);

                if (pInfo->pArgs->fShowProprietary)
                {
                    fCheck = Button_GetCheck( pInfo->hwndCbProprietary );

                    EnableWindow( pInfo->hwndCbCompression, fCheck );
                    EnableWindow( pInfo->hwndStChannels, fCheck );
                    EnableWindow( pInfo->hwndEbChannels, fCheck );
                    EnableWindow( pInfo->hwndUdChannels, fCheck );
                }
            }
            return TRUE;
        }

        case IDOK:
        {
            ICINFO* pInfo;
            INT     iSel;

            TRACE("OK pressed");

            pInfo = (ICINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
            ASSERT(pInfo);

            iSel = ComboBox_GetCurSel( pInfo->hwndLbLineType );
            if (iSel >= 0)
                pInfo->pArgs->pLink->lLineType = iSel;

            pInfo->pArgs->pLink->fFallback =
                Button_GetCheck( pInfo->hwndCbFallback );

            pInfo->pArgs->pLink->fProprietaryIsdn =
                Button_GetCheck( pInfo->hwndCbProprietary );

            if (pInfo->pArgs->fShowProprietary)
            {
                BOOL f;
                UINT unValue;

                pInfo->pArgs->pLink->fCompression =
                    Button_GetCheck( pInfo->hwndCbCompression );

                unValue = GetDlgItemInt(
                    pInfo->hwndDlg, CID_IC_EB_Channels, &f, FALSE );
                if (f && unValue >= 1 && unValue <= 999999999)
                    pInfo->pArgs->pLink->lChannels = unValue;
            }

            EndDialog( pInfo->hwndDlg, TRUE );
            return TRUE;
        }

        case IDCANCEL:
        {
            TRACE("Cancel pressed");
            EndDialog( hwnd, FALSE );
            return TRUE;
        }
    }

    return FALSE;
}


BOOL
IcInit(
    IN HWND    hwndDlg,
    IN ICARGS* pArgs )

    /* Called on WM_INITDIALOG.  'hwndDlg' is the handle of the owning window.
    ** 'PArgs' is the caller's stub API arguments.
    **
    ** Return false if focus was set, true otherwise, i.e. as defined for
    ** WM_INITDIALOG.
    */
{
    DWORD   dwErr;
    ICINFO* pInfo;

    TRACE("IcInit");

    /* Allocate the dialog context block.  Initialize minimally for proper
    ** cleanup, then attach to the dialog window.
    */
    {
        pInfo = Malloc( sizeof(*pInfo) );
        if (!pInfo)
        {
            ErrorDlg( hwndDlg, SID_OP_LoadDlg, ERROR_NOT_ENOUGH_MEMORY, NULL );
            EndDialog( hwndDlg, FALSE );
            return TRUE;
        }

        ZeroMemory( pInfo, sizeof(*pInfo) );
        pInfo->pArgs = pArgs;
        pInfo->hwndDlg = hwndDlg;

        SetWindowLongPtr( hwndDlg, DWLP_USER, (LONG_PTR)pInfo );
        TRACE("Context set");
    }

    pInfo->hwndLbLineType = GetDlgItem( hwndDlg, CID_IC_LB_LineType );
    ASSERT(pInfo->hwndLbLineType);
    pInfo->hwndCbFallback = GetDlgItem( hwndDlg, CID_IC_CB_Fallback );
    ASSERT(pInfo->hwndCbFallback);
    if (pArgs->fShowProprietary)
    {
        pInfo->hwndCbProprietary = GetDlgItem( hwndDlg, CID_IC_CB_DownLevel );
        ASSERT(pInfo->hwndCbProprietary);
        pInfo->hwndCbCompression = GetDlgItem( hwndDlg, CID_IC_CB_Compression );
        ASSERT(pInfo->hwndCbCompression);
        pInfo->hwndStChannels = GetDlgItem( hwndDlg, CID_IC_ST_Channels );
        ASSERT(pInfo->hwndStChannels);
        pInfo->hwndEbChannels = GetDlgItem( hwndDlg, CID_IC_EB_Channels );
        ASSERT(pInfo->hwndEbChannels);
    }

    /* Initialize fields.
    */
    ComboBox_AddItemFromId( g_hinstDll, pInfo->hwndLbLineType,
        SID_IsdnLineType0, NULL );
    ComboBox_AddItemFromId( g_hinstDll, pInfo->hwndLbLineType,
        SID_IsdnLineType1, NULL );
    ComboBox_AddItemFromId( g_hinstDll, pInfo->hwndLbLineType,
        SID_IsdnLineType2, NULL );
    ComboBox_SetCurSel( pInfo->hwndLbLineType, pArgs->pLink->lLineType );

    Button_SetCheck( pInfo->hwndCbFallback, pArgs->pLink->fFallback );

    if (pArgs->fShowProprietary)
    {
        /* Send click to triggle window enable update.
        */
        Button_SetCheck( pInfo->hwndCbProprietary,
            !pArgs->pLink->fProprietaryIsdn );
        SendMessage( pInfo->hwndCbProprietary, BM_CLICK, 0, 0 );

        Button_SetCheck( pInfo->hwndCbCompression, pArgs->pLink->fCompression );

        pInfo->hwndUdChannels = CreateUpDownControl(
            WS_CHILD + WS_VISIBLE + WS_BORDER +
                UDS_SETBUDDYINT + UDS_ALIGNRIGHT + UDS_NOTHOUSANDS +
                UDS_ARROWKEYS,
            0, 0, 0, 0, hwndDlg, 100, g_hinstDll, pInfo->hwndEbChannels,
            UD_MAXVAL, 1, 0 );
        ASSERT(pInfo->hwndUdChannels);
        Edit_LimitText( pInfo->hwndEbChannels, 9 );
        SetDlgItemInt( hwndDlg, CID_IC_EB_Channels,
            pArgs->pLink->lChannels, FALSE );
    }

    /* Position the dialog centered on the owner window.
    */
    CenterWindow( hwndDlg, GetParent( hwndDlg ) );

    /* Add context help button to title bar.  Dlgedit.exe doesn't currently
    ** support this at resource edit time.  When that's fixed set
    ** DS_CONTEXTHELP there and remove this call.
    */
    AddContextHelpButton( hwndDlg );

    return TRUE;
}


VOID
IcTerm(
    IN HWND hwndDlg )

    /* Dialog termination.  Releases the context block.  'HwndDlg' is the
    ** handle of a dialog.
    */
{
    ICINFO* pInfo;

    TRACE("IcTerm");

    pInfo = (ICINFO* )GetWindowLongPtr( hwndDlg, DWLP_USER );
    if (pInfo)
    {
        Free( pInfo );
        TRACE("Context freed");
    }
}


/*----------------------------------------------------------------------------
** Modem configuration dialog
** Listed alphabetically following stub API and dialog proc
**----------------------------------------------------------------------------
*/

BOOL
ModemConfigureDlg(
    IN HWND    hwndOwner,
    IN PBLINK* pLink )

    /* Popup the modem configuration dialog.  'HwndOwner' is the owner of the
    ** dialog.  'PLink' is the link to edit.
    **
    ** Returns true if user pressed OK and succeeded, false if user pressed
    ** Cancel or encountered an error.
    */
{
    int nStatus;

    TRACE("ModemConfigureDlg");

    nStatus =
        (BOOL )DialogBoxParam(
            g_hinstDll,
            (pLink->pbport.fMxsModemPort)
                ? MAKEINTRESOURCE( DID_MC_MxsModemConfigure )
                : MAKEINTRESOURCE( DID_MC_UniModemConfigure ),
            hwndOwner,
            McDlgProc,
            (LPARAM )pLink );

    if (nStatus == -1)
    {
        ErrorDlg( hwndOwner, SID_OP_LoadDlg, ERROR_UNKNOWN, NULL );
        nStatus = FALSE;
    }

    return (BOOL )nStatus;
}


INT_PTR CALLBACK
McDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    /* DialogProc callback for the Modem Settings dialog.  Parameters and
    ** return value are as described for standard windows 'DialogProc's.
    */
{
#if 0
    TRACE4("McDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
           (DWORD)hwnd,(DWORD)unMsg,(DWORD)wparam,(DWORD)lparam);
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
            return McInit( hwnd, (PBLINK* )lparam );

        case WM_HELP:
        case WM_CONTEXTMENU:
            ContextHelp( g_adwMcHelp, hwnd, unMsg, wparam, lparam );
            break;

        case WM_COMMAND:
        {
            return McCommand(
                hwnd, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }

        case WM_DESTROY:
        {
            McTerm( hwnd );
            break;
        }
    }

    return FALSE;
}


BOOL
McCommand(
    IN HWND hwnd,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl )

    /* Called on WM_COMMAND.  'Hwnd' is the dialog window.  'WNotification' is
    ** the notification code of the command.  'wId' is the control/menu
    ** identifier of the command.  'HwndCtrl' is the control window handle of
    ** the command.
    **
    ** Returns true if processed message, false otherwise.
    */
{
    DWORD dwErr;

    TRACE2("McCommand(n=%d,i=%d)",
        (DWORD)wNotification,(DWORD)wId);

    switch (wId)
    {
        case CID_MC_CB_FlowControl:
        {
            if (wNotification == BN_CLICKED)
            {
                MCINFO* pInfo = (MCINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
                ASSERT(pInfo);

                if (!Button_GetCheck( pInfo->hwndCbHwFlow ))
                {
                    Button_SetCheck( pInfo->hwndCbEc, FALSE );
                    Button_SetCheck( pInfo->hwndCbEcc, FALSE );
                }
                return TRUE;
            }
            break;
        }

        case CID_MC_CB_ErrorControl:
        {
            if (wNotification == BN_CLICKED)
            {
                MCINFO* pInfo = (MCINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
                ASSERT(pInfo);

                if (Button_GetCheck( pInfo->hwndCbEc ))
                    Button_SetCheck( pInfo->hwndCbHwFlow, TRUE );
                else
                    Button_SetCheck( pInfo->hwndCbEcc, FALSE );
                return TRUE;
            }
            break;
        }

        case CID_MC_CB_Compression:
        {
            if (wNotification == BN_CLICKED)
            {
                MCINFO* pInfo = (MCINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
                ASSERT(pInfo);

                if (Button_GetCheck( pInfo->hwndCbEcc ))
                {
                    Button_SetCheck( pInfo->hwndCbHwFlow, TRUE );
                    Button_SetCheck( pInfo->hwndCbEc, TRUE );
                }
                return TRUE;
            }
            break;
        }

        case IDOK:
        {
            MCINFO* pInfo;
            PBLINK* pLink;
            PBPORT* pPort;
            INT     iSel;
            DWORD   dwBps;

            TRACE("OK pressed");

            pInfo = (MCINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
            ASSERT(pInfo);

            pLink = pInfo->pLink;
            pPort = &pLink->pbport;

            iSel = ComboBox_GetCurSel( pInfo->hwndLbBps );
            dwBps = (DWORD)ComboBox_GetItemData( pInfo->hwndLbBps, iSel );

            if (!Button_GetCheck( pInfo->hwndCbHwFlow ))
            {
                if (pPort->fMxsModemPort
                    && dwBps > pPort->dwMaxCarrierBps)
                {
                    MSGARGS msgargs;
                    TCHAR   szBuf[ MAXLTOTLEN + 1 ];

                    LToT( pPort->dwMaxCarrierBps, szBuf, 10 );
                    ZeroMemory( &msgargs, sizeof(msgargs) );
                    msgargs.dwFlags = MB_ICONWARNING + MB_YESNO;
                    msgargs.apszArgs[ 0 ] = szBuf;
                    msgargs.apszArgs[ 1 ] = NULL;

                    if (MsgDlg( hwnd, SID_BpsWithNoHwFlow, &msgargs ) == IDYES)
                    {
                        /* User chose to lower port speed to maximum
                        ** recommended value.
                        */
                        dwBps = pPort->dwMaxCarrierBps;
                    }
                }
            }

            pLink->dwBps = dwBps;
            pLink->fHwFlow = Button_GetCheck( pInfo->hwndCbHwFlow );
            pLink->fEc = Button_GetCheck( pInfo->hwndCbEc );
            pLink->fEcc = Button_GetCheck( pInfo->hwndCbEcc );
            pLink->fSpeaker = !Button_GetCheck( pInfo->hwndCbDisableSpeaker );

            if (pLink->pbport.fMxsModemPort)
                pLink->fManualDial = Button_GetCheck( pInfo->hwndCbManualDial );

            EndDialog( pInfo->hwndDlg, TRUE );
            return TRUE;
        }

        case IDCANCEL:
        {
            TRACE("Cancel pressed");
            EndDialog( hwnd, FALSE );
            return TRUE;
        }
    }

    return FALSE;
}


BOOL
McInit(
    IN HWND    hwndDlg,
    IN PBLINK* pLink )

    /* Called on WM_INITDIALOG.  'hwndDlg' is the handle of the owning window.
    ** 'PLink' is the link information to be edited.
    **
    ** Return false if focus was set, true otherwise, i.e. as defined for
    ** WM_INITDIALOG.
    */
{
    DWORD   dwErr;
    MCINFO* pInfo;
    PBPORT* pPort;

    TRACE("McInit");

    /* Allocate the dialog context block.  Initialize minimally for proper
    ** cleanup, then attach to the dialog window.
    */
    {
        pInfo = Malloc( sizeof(*pInfo) );
        if (!pInfo)
        {
            ErrorDlg( hwndDlg, SID_OP_LoadDlg, ERROR_NOT_ENOUGH_MEMORY, NULL );
            EndDialog( hwndDlg, FALSE );
            return TRUE;
        }

        ZeroMemory( pInfo, sizeof(*pInfo) );
        pInfo->pLink = pLink;
        pInfo->hwndDlg = hwndDlg;

        SetWindowLongPtr( hwndDlg, DWLP_USER, (LONG_PTR)pInfo );
        TRACE("Context set");
    }

    pInfo->hwndEbModemValue = GetDlgItem( hwndDlg, CID_MC_EB_ModemValue );
    ASSERT(pInfo->hwndEbModemValue);
    pInfo->hwndLbBps = GetDlgItem( hwndDlg, CID_MC_LB_InitialBps );
    ASSERT(pInfo->hwndLbBps);
    pInfo->hwndCbHwFlow = GetDlgItem( hwndDlg, CID_MC_CB_FlowControl );
    ASSERT(pInfo->hwndCbHwFlow);
    pInfo->hwndCbEc = GetDlgItem( hwndDlg, CID_MC_CB_ErrorControl );
    ASSERT(pInfo->hwndCbEc);
    pInfo->hwndCbEcc = GetDlgItem( hwndDlg, CID_MC_CB_Compression );
    ASSERT(pInfo->hwndCbEcc);
    pInfo->hwndCbDisableSpeaker = GetDlgItem( hwndDlg, CID_MC_CB_DisableSpeaker );
    ASSERT(pInfo->hwndCbDisableSpeaker);

    Button_SetCheck( pInfo->hwndCbHwFlow, pLink->fHwFlow );
    Button_SetCheck( pInfo->hwndCbEc, pLink->fEc );
    Button_SetCheck( pInfo->hwndCbEcc, pLink->fEcc );
    Button_SetCheck( pInfo->hwndCbDisableSpeaker, !pLink->fSpeaker );

    pPort = &pLink->pbport;

    if (pPort->fMxsModemPort)
    {
        pInfo->hwndCbManualDial = GetDlgItem( hwndDlg, CID_MC_CB_ManualDial );
        ASSERT(pInfo->hwndCbManualDial);
        Button_SetCheck( pInfo->hwndCbManualDial, pLink->fManualDial );
    }

    /* Fill in the modem name.
    */
    {
        TCHAR* psz;
        psz = DisplayPszFromDeviceAndPort( pPort->pszDevice, pPort->pszPort );
        if (psz)
        {
            SetWindowText( pInfo->hwndEbModemValue, psz );
            Free( psz );
        }
    }

    /* Fill in the BPS list.
    */
    {
        TCHAR  szBps[ MAXLTOTLEN + 1 ];
        DWORD* pdwBps;
        INT    i;

        static DWORD adwBps[] =
        {
            1200, 2400, 4800, 9600, 19200, 38400, 57600, 115200,
            0
        };

        for (pdwBps = adwBps; *pdwBps; ++pdwBps)
        {
            LToT( *pdwBps, szBps, 10 );
            i = ComboBox_AddString( pInfo->hwndLbBps, szBps );
            ComboBox_SetItemData( pInfo->hwndLbBps, i, *pdwBps );
            if (*pdwBps == pLink->dwBps)
                ComboBox_SetCurSel( pInfo->hwndLbBps, i );
        }

        if (ComboBox_GetCurSel( pInfo->hwndLbBps ) < 0)
        {
            /* Entry lists an unknown BPS rate.  Add it to the end of the
            ** list.
            */
            TRACE("Irregular BPS");
            LToT( pLink->dwBps, szBps, 10 );
            i = ComboBox_AddString( pInfo->hwndLbBps, szBps );
            ComboBox_SetItemData( pInfo->hwndLbBps, i, pLink->dwBps );
            ComboBox_SetCurSel( pInfo->hwndLbBps, i );
        }
    }

    /* Position the dialog centered on the owner window.
    */
    CenterWindow( hwndDlg, GetParent( hwndDlg ) );

    /* Add context help button to title bar.  Dlgedit.exe doesn't currently
    ** support this at resource edit time.  When that's fixed set
    ** DS_CONTEXTHELP there and remove this call.
    */
    AddContextHelpButton( hwndDlg );

    return TRUE;
}


VOID
McTerm(
    IN HWND hwndDlg )

    /* Dialog termination.  Releases the context block.  'HwndDlg' is the
    ** handle of a dialog.
    */
{
    MCINFO* pInfo;

    TRACE("McTerm");

    pInfo = (MCINFO* )GetWindowLongPtr( hwndDlg, DWLP_USER );
    if (pInfo)
    {
        Free( pInfo );
        TRACE("Context freed");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\nt4\rasdlg\edit.c ===
/* Copyright (c) 1995, Microsoft Corporation, all rights reserved
**
** edit.c
** Remote Access Common Dialog APIs
** List editor, string editor dialog routines
**
** 08/28/95 Steve Cobb
*/

#include "rasdlgp.h"


/*----------------------------------------------------------------------------
** Local datatypes (alphabetically)
**----------------------------------------------------------------------------
*/

/* List editor dialog argument block.
*/
#define LEARGS struct tagLEARGS
LEARGS
{
    /* Caller's arguments to the stub API.
    */
    DTLLIST*     pList;
    BOOL*        pfCheck;
    DWORD        dwMaxItemLen;
    TCHAR*       pszTitle;
    TCHAR*       pszItemLabel;
    TCHAR*       pszListLabel;
    TCHAR*       pszCheckLabel;
    TCHAR*       pszDefaultItem;
    INT          iSelInitial;
    DWORD*       pdwHelp;
    DWORD        dwfFlags;
    PDESTROYNODE pDestroyId;
};


/* List editor dialog context block.
*/
#define LEINFO struct tagLEINFO
LEINFO
{
    /* Caller's arguments to the dialog.
    */
    LEARGS* pArgs;

    /* Handle of this dialog and some of it's controls.
    */
    HWND hwndDlg;
    HWND hwndStItem;
    HWND hwndStList;
    HWND hwndPbAdd;
    HWND hwndPbReplace;
    HWND hwndPbUp;
    HWND hwndPbDown;
    HWND hwndPbDelete;
    HWND hwndPbOk;
    HWND hwndEb;
    HWND hwndLb;
    HWND hwndCb;

    /* Convenient alternatives to (pInfo->pArgs->dwFlags & LEDFLAG_Sorted) and
    ** (pInfo->pArgs->dwFlags & LEDFLAG_NoDeleteLastItem).
    */
    BOOL fSorted;
    BOOL fNoDeleteLast;

    /* Button bitmaps.
    */
    HBITMAP hbmUp;
    HBITMAP hbmDown;

    /* List of empty nodes whose node-IDs should be 'pDestroyId'ed if user
    ** presses OK.
    */
    DTLLIST* pListDeletes;
};


/* String Editor dialog arument block.
*/
#define ZEARGS struct tagZEARGS
ZEARGS
{
    /* Caller's aruments to the stub API.
    */
    TCHAR*  pszIn;
    DWORD   dwSidTitle;
    DWORD   dwSidLabel;
    DWORD   cbMax;
    DWORD   dwHelpId;
    TCHAR** ppszOut;
};


/* String Editor dialog context block.
*/
#define ZEINFO struct tagZEINFO
ZEINFO
{
    /* Caller's arguments to the stub API.
    */
    ZEARGS* pArgs;

    /* Dialog and control handles.
    */
    HWND hwndDlg;
    HWND hwndEb;
};


/*----------------------------------------------------------------------------
** Local prototypes (alphabetically)
**----------------------------------------------------------------------------
*/

INT_PTR CALLBACK
LeDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

VOID
LeAdd(
    IN LEINFO* pInfo );

BOOL
LeCommand(
    IN LEINFO* pInfo,
    IN WORD    wNotification,
    IN WORD    wId,
    IN HWND    hwndCtrl );

VOID
LeDelete(
    IN LEINFO* pInfo );

VOID
LeDown(
    IN LEINFO* pInfo );

VOID
LeEnableUpAndDownButtons(
    IN LEINFO* pInfo );

VOID
LeExitNoMemory(
    IN LEINFO* pInfo );

BOOL
LeInit(
    IN HWND    hwndDlg,
    IN LEARGS* pArgs );

VOID
LeItemTextFromListSelection(
    IN LEINFO* pInfo );

VOID
LeReplace(
    IN LEINFO* pInfo );

BOOL
LeSaveSettings(
    IN LEINFO* pInfo );

VOID
LeTerm(
    IN HWND hwndDlg );

VOID
LeUp(
    IN LEINFO* pInfo );

INT_PTR CALLBACK
ZeDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
ZeCommand(
    IN ZEINFO* pInfo,
    IN WORD    wNotification,
    IN WORD    wId,
    IN HWND    hwndCtrl );

BOOL
ZeInit(
    IN HWND    hwndDlg,
    IN ZEARGS* pArgs );

VOID
ZeTerm(
    IN HWND hwndDlg );


/*----------------------------------------------------------------------------
** List Editor dialog entry point
**----------------------------------------------------------------------------
*/

BOOL
ListEditorDlg(
    IN     HWND         hwndOwner,
    IN OUT DTLLIST*     pList,
    IN OUT BOOL*        pfCheck,
    IN     DWORD        dwMaxItemLen,
    IN     TCHAR*       pszTitle,
    IN     TCHAR*       pszItemLabel,
    IN     TCHAR*       pszListLabel,
    IN     TCHAR*       pszCheckLabel,
    IN     TCHAR*       pszDefaultItem,
    IN     INT          iSelInitial,
    IN     DWORD*       pdwHelp,
    IN     DWORD        dwfFlags,
    IN     PDESTROYNODE pDestroyId )

    /* Pops-up the List Editor dialog.
    **
    ** 'HwndOwner' is the owner of the dialog.  'PList' is, on entry, the Psz
    ** list to display initially, and on successful exit, the result list.
    ** 'PfCheck' is the state of the check box or NULL for the non-checkbox
    ** style.  'DwMaxItemLen' is the maximum length of an individual list
    ** item.  'PszTitle' is the dialog title.  'PszItemLabel' is the label
    ** (and hotkey) associated with the item box.  'PszListLabel' is the label
    ** (and hotkey) associated with the list.  'PszCheckLabel' is the label
    ** (and hotkey) associated with the checkbox.  'PszDefaultItem' is the
    ** default contents of the edit box or for the selected list text.
    ** 'ISelInitial' is the item the list to initally select.  'PdwHelp' is
    ** the array of CID_LE_* help contexts to use.  'DwfFlags' indicates
    ** LEDFLAG_* behavior options.  'PDestroyId' is the routine to use to
    ** destroy node IDs when they are deleted or NULL if none.
    **
    ** Returns true if user pressed OK and succeeded, false if he pressed
    ** Cancel or encountered an error.
    */
{
    int    nStatus;
    LEARGS args;

    TRACE("ListEditorDlg");

    args.pList = pList;
    args.pfCheck = pfCheck;
    args.dwMaxItemLen = dwMaxItemLen;
    args.pszTitle = pszTitle;
    args.pszItemLabel = pszItemLabel;
    args.pszListLabel = pszListLabel;
    args.pszCheckLabel = pszCheckLabel;
    args.pszDefaultItem = pszDefaultItem;
    args.iSelInitial = iSelInitial;
    args.pdwHelp = pdwHelp;
    args.dwfFlags = dwfFlags;
    args.pDestroyId = pDestroyId;

    nStatus =
        (BOOL )DialogBoxParam(
            g_hinstDll,
            (pfCheck)
                ? MAKEINTRESOURCE( DID_LE_ListEditor2 )
                : ((dwfFlags & LEDFLAG_Sorted)
                       ? MAKEINTRESOURCE( DID_LE_ListEditor3 )
                       : MAKEINTRESOURCE( DID_LE_ListEditor )),
            hwndOwner,
            LeDlgProc,
            (LPARAM )&args );

    if (nStatus == -1)
    {
        ErrorDlg( hwndOwner, SID_OP_LoadDlg, ERROR_UNKNOWN, NULL );
        nStatus = FALSE;
    }

    return (BOOL )nStatus;
}


/*----------------------------------------------------------------------------
** List Editor dialog routines
** Listed alphabetically following dialog proc
**----------------------------------------------------------------------------
*/

INT_PTR CALLBACK
LeDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    /* DialogProc callback for the List Editor dialog.  Parameters and return
    ** value are as described for standard windows 'DialogProc's.
    */
{
#if 0
    TRACE4("LeDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)"