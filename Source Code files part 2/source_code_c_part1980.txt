    DWORD              m_nEntries;

    HTB_ELEMENT        m_htbeFirst; // the first bucket chunk

    VOID Lock(VOID) { EnterCriticalSection( &m_csLock); }
    VOID Unlock( VOID) { LeaveCriticalSection( &m_csLock); }
};




/************************************************************
 *    Member Functions of HTB_ELEMENT
 ************************************************************/

VOID
HTB_ELEMENT::Cleanup( VOID)
{

    if ( m_nElements > 0) {
        PHTBE_ENTRY phtbeEntry;

        // free up all the entries in this bucket.
        for (phtbeEntry = FirstElement();
             phtbeEntry < (LastElement());
             NextElement( phtbeEntry)) {

            if ( !phtbeEntry->IsEmpty() ) {

                // release the object now.
                DecrementElements();

                // Assert that ref == 1
                DerefAndKillElement( phtbeEntry->m_phte);
                phtbeEntry->m_phte = NULL;
                phtbeEntry->m_hashValue = 0;
            }
        } // for
    }

    DBG_ASSERT( 0 == m_nElements);
    return;
} // HTB_ELEMENT::Cleanup()


inline
HT_ELEMENT *
HTB_ELEMENT::Lookup( IN DWORD hashValue, IN LPCSTR pszKey, DWORD cchKey)
{
    HT_ELEMENT * phte = NULL;

    if ( m_nElements > 0) {

        PHTBE_ENTRY phtbeEntry;
        // find the entry by scanning all entries in this bucket chunk
        // if found, increment ref count and return a pointer to the object
        for (phtbeEntry = FirstElement();
             phtbeEntry < (LastElement());
             NextElement( phtbeEntry)) {

            //
            // If the hash values match and the strings match up, return
            //  the corresponding hash table entry object
            //
            if ( phtbeEntry->IsMatch( hashValue, pszKey, cchKey)) {

                // we found the entry. return it.
                phte = phtbeEntry->m_phte;
                DBG_REQUIRE( phte->Reference() > 0);
                break;
            }
        } // for
    }

    return ( phte);
} // HTB_ELEMENT::Lookup()


inline BOOL
HTB_ELEMENT::Insert( IN DWORD hashVal,
                     IN HT_ELEMENT * phte
                     )
{
    if ( m_nElements < MAX_ELEMENTS_PER_BUCKET) {

        // there is some empty space.
        // Find one such a slot and add this new entry

        PHTBE_ENTRY phtbeEntry;

        for (phtbeEntry = FirstElement();
             phtbeEntry < LastElement();
             NextElement( phtbeEntry)) {

            if ( phtbeEntry->IsEmpty() ) {

                DBG_ASSERT( NULL != phte);

                // Assume that the object phte already has non-zero ref count

                // we found a free entry. insert the new element here.
                phtbeEntry->m_hashValue = hashVal;
                phtbeEntry->m_phte = phte;
                IncrementElements();
                return ( TRUE);
            }
        } // for

        // we should not come here. If we do then there is trouble :(
        DBG_ASSERT( FALSE);
    }

    SetLastError( ERROR_INSUFFICIENT_BUFFER);
    return ( FALSE);
} // HTB_ELEMENT::Insert()


DWORD
HTB_ELEMENT::FindNextElement( IN OUT LPDWORD pdwPos, OUT HT_ELEMENT ** pphte)
{
    DWORD dwErr = ERROR_NO_MORE_ITEMS;

    DBG_ASSERT( NULL != pdwPos );
    DBG_ASSERT( NULL != pphte );

    // Find the first valid element to return back.

    //
    // Given that deletion might happen any time, we cannot rely on the
    //   comparison  *pdwPos < m_nElements
    //
    // Do scans with *pdwPos < MAX_ELEMENTS_PER_BUCKET
    //

    if ( *pdwPos < MAX_ELEMENTS_PER_BUCKET ) {

        PHTBE_ENTRY phtbeEntry;

        // find the entry by scanning all entries in this bucket chunk
        // if found, increment ref count and return a pointer to the object
        for (phtbeEntry = m_rgElements + *pdwPos;
             phtbeEntry < (LastElement());
             NextElement( phtbeEntry)) {

            if ( phtbeEntry->m_phte != NULL ) {

                //
                // Store the element pointer and the offset
                // and return after referencing the element
                //
                *pphte = phtbeEntry->m_phte;
                (*pphte)->Reference();
                *pdwPos = ( 1 + (DWORD)(phtbeEntry - FirstElement()));
                dwErr = NO_ERROR;
                break;
            }
        } // for
    }

    return ( dwErr);
} // HTB_ELEMENT::FindNextElement()


inline BOOL
HTB_ELEMENT::Delete( IN HT_ELEMENT * phte)
{
    DBG_ASSERT( NULL != phte);

    if ( m_nElements > 0) {

        PHTBE_ENTRY phtbeEntry;
        // find the entry by scanning all entries in this bucket chunk
        // if found, increment ref count and return a pointer to the object
        for (phtbeEntry = FirstElement();
             phtbeEntry < (LastElement());
             NextElement( phtbeEntry)) {

            //
            // If the hash values match and the strings match up,
            //  decrement ref count and kill the element.
            //
            if ( phtbeEntry->IsMatch( phte)) {

                // We found the entry.  Remove it from the table

                phtbeEntry->m_phte = NULL;
                DecrementElements();

                DerefAndKillElement( phte);

                return ( TRUE);
            }
        } // for
    }

    return ( FALSE);
} // HTB_ELEMENT::Delete()


VOID
HTB_ELEMENT::Print(IN DWORD level) const
{
    const HTBE_ENTRY * phtbeEntry;
    CHAR rgchBuffer[MAX_ELEMENTS_PER_BUCKET * 22 + 200];
    DWORD cch;
    DWORD i;

    cch = wsprintf( rgchBuffer,
                    "HTB_ELEMENT(%08p)  # Elements %4d; "
                    "Flink: %08p  Blink: %08p\n"
                    ,
                    this, m_nElements,
                    m_ListEntry.Flink, m_ListEntry.Blink);

    if ( level > 0) {

        // NYI: I need to walk down the entire array.
        // Not just the first few entries
        for( i = 0; i < m_nElements; i++) {

            phtbeEntry = &m_rgElements[i];
            cch += wsprintf( rgchBuffer + cch,
                             "  %08x %08p",
                             phtbeEntry->m_hashValue,
                             phtbeEntry->m_phte
                             );
            if ( i % 4 == 0) {
                rgchBuffer[cch++] = '\n';
                rgchBuffer[cch] = '\0';
            }
        } // for
    }

    DBGDUMP(( DBG_CONTEXT, rgchBuffer));
    return;
} // HTB_ELEMENT::Print()



/************************************************************
 *    Member Functions of HASH_TABLE_BUCKET
 ************************************************************/

HASH_TABLE_BUCKET::HASH_TABLE_BUCKET(VOID)
    : m_nEntries ( 0),
      m_htbeFirst()
{
    InitializeListHead( &m_lHead);
    InitializeCriticalSection( & m_csLock);
    SET_CRITICAL_SECTION_SPIN_COUNT( &m_csLock, IIS_DEFAULT_CS_SPIN_COUNT);
} // HASH_TABLE_BUCKET::HASH_TABLE_BUCKET()


HASH_TABLE_BUCKET::~HASH_TABLE_BUCKET( VOID)
{
    PLIST_ENTRY pl;
    PHTB_ELEMENT phtbe;

    // Free up the elements in the list
    Lock();
    while ( !IsListEmpty( &m_lHead)) {
        pl = RemoveHeadList( &m_lHead);
        phtbe = CONTAINING_RECORD( pl, HTB_ELEMENT, m_ListEntry);
        delete phtbe;
    } // while

    m_htbeFirst.Cleanup();
    Unlock();

    DeleteCriticalSection( &m_csLock);
} // HASH_TABLE_BUCKET::~HASH_TABLE_BUCKET()



HT_ELEMENT *
HASH_TABLE_BUCKET::Lookup( IN DWORD hashValue, IN LPCSTR pszKey, DWORD cchKey)
{
    HT_ELEMENT * phte;

    Lock();
    // 1. search in the first bucket
    phte = m_htbeFirst.Lookup( hashValue, pszKey, cchKey);

    if ( NULL == phte ) {

        // 2. search in the auxiliary buckets
        PLIST_ENTRY pl;

        for ( pl = m_lHead.Flink; (phte == NULL) && (pl != &m_lHead);
              pl = pl->Flink) {

            HTB_ELEMENT * phtbe = CONTAINING_RECORD( pl,
                                                     HTB_ELEMENT,
                                                     m_ListEntry);
            phte = phtbe->Lookup( hashValue, pszKey, cchKey);
        } // for
    }

    Unlock();

    return (phte);
} // HASH_TABLE_BUCKET::Lookup()


BOOL
HASH_TABLE_BUCKET::Insert( IN DWORD hashValue,
                           IN HT_ELEMENT * phte,
                           IN BOOL fCheckForDuplicate)
{
    BOOL fReturn = FALSE;

    if ( fCheckForDuplicate) {

        Lock();

        // do a lookup and find out if this data exists.
        HT_ELEMENT * phteLookedup = Lookup( hashValue,
                                            phte->QueryKey(),
                                            phte->QueryKeyLen()
                                            );

        if ( NULL != phteLookedup) {
            // the element is already present - return failure

            DerefAndKillElement( phteLookedup);
        }

        Unlock();

        if ( NULL != phteLookedup) {
            SetLastError( ERROR_DUP_NAME);
            return ( FALSE);
        }
    }

    Lock();

    // 1. try inserting in the first bucket chunk, if possible
    if ( m_htbeFirst.IsSpaceAvailable()) {

        fReturn = m_htbeFirst.Insert( hashValue, phte);
    } else {

        // 2. Find the first chunk that has space and insert it there.
        PLIST_ENTRY pl;
        HTB_ELEMENT * phtbe;

        for ( pl = m_lHead.Flink; (pl != &m_lHead);
              pl = pl->Flink) {

            phtbe = CONTAINING_RECORD( pl, HTB_ELEMENT, m_ListEntry);

            if ( phtbe->IsSpaceAvailable()) {
                fReturn = phtbe->Insert( hashValue, phte);
                break;
            }
        } // for

        if ( !fReturn ) {

            //
            // We ran out of space.
            // Allocate a new bucket and insert the new element.
            //

            phtbe = new HTB_ELEMENT();
            if ( NULL != phtbe) {

                // add the bucket to the list of buckets and
                // then add the element to the bucket
                InsertTailList( &m_lHead, &phtbe->m_ListEntry);
                fReturn = phtbe->Insert(hashValue, phte);
            } else {

                IF_DEBUG( ERROR) {
                    DBGPRINTF(( DBG_CONTEXT,
                                " HTB(%08x)::Insert: Unable to add a chunk\n",
                                this));
                }
                SetLastError( ERROR_NOT_ENOUGH_MEMORY);
            }
        }
    }

    Unlock();

    return ( fReturn);
} // HASH_TABLE_BUCKET::Insert()



BOOL
HASH_TABLE_BUCKET::Delete( IN HT_ELEMENT * phte)
{
    BOOL fReturn = FALSE;


    // We do not know which bucket this element belongs to.
    // So we should try all chunks to delete this element.

    Lock();

    // 1. try deleting the element from first bucket chunk, if possible
    fReturn = m_htbeFirst.Delete( phte);

    if (!fReturn) {

        // it was not on the first bucket chunk.

        // 2. Find the first chunk that might contain this element
        // and delete it.
        PLIST_ENTRY pl;

        for ( pl = m_lHead.Flink;
              !fReturn && (pl != &m_lHead);
              pl = pl->Flink) {

            HTB_ELEMENT * phtbe = CONTAINING_RECORD( pl,
                                                     HTB_ELEMENT,
                                                     m_ListEntry);
            fReturn = phtbe->Delete( phte);
        } // for

        // the element should have been in the hash table,
        // otherwise the app is calling with wrong entry
        DBG_ASSERT( fReturn);
    }

    Unlock();

    return ( fReturn);
} // HASH_TABLE_BUCKET::Delete()


DWORD
HASH_TABLE_BUCKET::NumEntries( VOID)
{
    DWORD nEntries;

    Lock();

    nEntries = m_htbeFirst.NumElements();

    PLIST_ENTRY pl;

    for ( pl = m_lHead.Flink;
          (pl != &m_lHead);
          pl = pl->Flink) {

        HTB_ELEMENT * phtbe = CONTAINING_RECORD( pl, HTB_ELEMENT,
                                                 m_ListEntry);
        nEntries += phtbe->NumElements();
    } // for

    Unlock();

    return (nEntries);

} // HASH_TABLE_BUCKET::NumEntries()


DWORD
HASH_TABLE_BUCKET::InitializeIterator( IN HT_ITERATOR * phti)
{
    DWORD dwErr = ERROR_NO_MORE_ITEMS;

    //
    // find the first chunk that has a valid element.
    // if we find one, leave the lock on for subsequent accesses.
    // CloseIterator will shut down the lock
    // If we do not find one, we should unlock and return
    //

    phti->nChunkId = NULL;
    phti->nPos = 0;

    Lock();
    if ( m_htbeFirst.NumElements() > 0) {
        phti->nChunkId = (DWORD_PTR) &m_htbeFirst;
        dwErr = NO_ERROR;
    } else {

        // find the first chunk that has an element

        PLIST_ENTRY pl;

        for ( pl = m_lHead.Flink; (pl != &m_lHead); pl = pl->Flink) {

            HTB_ELEMENT * phtbe = CONTAINING_RECORD( pl, HTB_ELEMENT,
                                                     m_ListEntry);
            if ( phtbe->NumElements() > 0) {
                phti->nChunkId = (DWORD_PTR) phtbe;
                dwErr = NO_ERROR;
                break;
            }
        } // for
    }

    // if we did not find any elements, then unlock and return
    // Otherwise leave the unlocking to the CloseIterator()
    if ( dwErr == ERROR_NO_MORE_ITEMS) {

        // get out of this bucket completely.
        Unlock();
    }

    return ( dwErr);

} // HASH_TABLE_BUCKET::InitializeIterator()


DWORD
HASH_TABLE_BUCKET::FindNextElement( IN HT_ITERATOR * phti,
                                    OUT HT_ELEMENT ** pphte)
{
    //  this function should be called only when the bucket is locked.

    DWORD dwErr;
    HTB_ELEMENT * phtbe = (HTB_ELEMENT * )phti->nChunkId;

    //
    // phti contains the <chunk, pos> from which we should start scan for
    //   next element.
    //

    DBG_ASSERT( NULL != phtbe);
    dwErr = phtbe->FindNextElement( &phti->nPos, pphte);

    if ( ERROR_NO_MORE_ITEMS == dwErr ) {

        // scan the rest of the chunks for next element

        PLIST_ENTRY pl = ((phtbe == &m_htbeFirst) ? m_lHead.Flink :
                          phtbe->m_ListEntry.Flink);

        for ( ; (pl != &m_lHead); pl = pl->Flink) {

            phtbe = CONTAINING_RECORD( pl, HTB_ELEMENT,
                                       m_ListEntry);
            if ( phtbe->NumElements() > 0) {
                phti->nPos = 0;
                dwErr = phtbe->FindNextElement( &phti->nPos, pphte);
                DBG_ASSERT( NO_ERROR == dwErr);
                phti->nChunkId = (DWORD_PTR) phtbe;
                break;
            }
        } // for
    }

    if ( dwErr == ERROR_NO_MORE_ITEMS) {

        phti->nChunkId = (DWORD ) NULL;
    }

    return ( dwErr);
} // HASH_TABLE_BUCKET::FindNextElement()


DWORD
HASH_TABLE_BUCKET::CloseIterator( IN HT_ITERATOR * phti)
{
    // just unlock the current bucket.
    Unlock();

    return ( NO_ERROR);
} // HASH_TABLE_BUCKET::CloseIterator()


VOID
HASH_TABLE_BUCKET::Print( IN DWORD level)
{
    Lock();
    DBGPRINTF(( DBG_CONTEXT,
                "\n\nHASH_TABLE_BUCKET (%08x): Head.Flink=%08x; Head.Blink=%08x\n"
                " Bucket Chunk # 0:\n"
                ,
                this, m_lHead.Flink, m_lHead.Blink
                ));

    m_htbeFirst.Print( level);

    if ( level > 0) {
        PLIST_ENTRY pl;
        DWORD i;

        for ( pl = m_lHead.Flink, i = 1;
              (pl != &m_lHead);
              pl = pl->Flink, i++) {

            HTB_ELEMENT * phtbe = CONTAINING_RECORD( pl, HTB_ELEMENT,
                                                     m_ListEntry);
            DBGPRINTF(( DBG_CONTEXT, "\n Bucket Chunk # %d\n", i));
            phtbe->Print( level);
        } // for
    }

    Unlock();
    return;
} // HASH_TABLE_BUCKET::Print()




/************************************************************
 *    Member Functions of HASH_TABLE
 ************************************************************/

HASH_TABLE::HASH_TABLE( IN DWORD   nBuckets,
                        IN LPCSTR  pszIdentifier,
                        IN DWORD   dwHashTableFlags
                        )
    : m_nBuckets   ( nBuckets),
      m_dwFlags    ( dwHashTableFlags),
      m_nEntries   ( 0),
      m_nLookups   ( 0),
      m_nHits      ( 0),
      m_nInserts   ( 0),
      m_nFlushes   ( 0)
{
    if ( NULL != pszIdentifier) {

        lstrcpynA( m_rgchId, pszIdentifier, sizeof( m_rgchId));
    }

    m_prgBuckets = new HASH_TABLE_BUCKET[nBuckets];

} // HASH_TABLE::HASH_TABLE()



DWORD
HASH_TABLE::CalculateHash( IN LPCSTR pszKey, DWORD cchKey) const
{
    DWORD hash = 0;

    DBG_ASSERT( pszKey != NULL );

    if ( cchKey > 8) {
        //
        // hash the last 8 characters
        //
        pszKey = (pszKey + cchKey - 8);
    }

    while ( *pszKey != '\0') {

        //
        // This is an extremely slimey way of getting upper case.
        // Kids, don't try this at home
        // -johnson
        //

        DWORD ch = ((*pszKey++) & ~0x20);

        // NYI: this is a totally pipe-line unfriendly code. Improve this.
        hash <<= 2;
        hash ^= ch;
        hash += ch;
    } // while

    //
    // Multiply by length (to introduce some randomness.  Murali said so.
    //

    return( hash * cchKey);
} // CalculateHash()


VOID
HASH_TABLE::Cleanup(VOID)
{
    if ( NULL != m_prgBuckets ) {

        delete [] m_prgBuckets;
        m_prgBuckets = NULL;
    }

} // HASH_TABLE::Cleanup()



# define INCREMENT_LOOKUPS()  \
       { InterlockedIncrement( (LPLONG ) &m_nLookups); }

# define INCREMENT_HITS( phte)  \
       if ( NULL != phte) { InterlockedIncrement( (LPLONG ) &m_nHits); }

# define INCREMENT_INSERTS()  \
       { InterlockedIncrement( (LPLONG ) &m_nInserts); }

# define INCREMENT_FLUSHES()  \
       { InterlockedIncrement( (LPLONG ) &m_nFlushes); }

# define INCREMENT_ENTRIES( fRet)  \
       if ( fRet) { InterlockedIncrement( (LPLONG ) &m_nEntries); }

# define DECREMENT_ENTRIES( fRet)  \
       if ( fRet) { InterlockedDecrement( (LPLONG ) &m_nEntries); }

HT_ELEMENT *
HASH_TABLE::Lookup( IN LPCSTR pszKey, DWORD cchKey)
{
    // 1. Calculate the hash value for pszKey
    // 2. Find the bucket for the hash value
    // 3. Search for given item in the bucket
    // 4. return the result, after updating statistics

    DWORD hashVal = CalculateHash( pszKey, cchKey);
    HT_ELEMENT * phte;

    INCREMENT_LOOKUPS();

    DBG_ASSERT( NULL != m_prgBuckets);
    phte = m_prgBuckets[hashVal % m_nBuckets].Lookup( hashVal, pszKey, cchKey);

    INCREMENT_HITS( phte);

    return ( phte);
} // HASH_TABLE::Lookup()


BOOL
HASH_TABLE::Insert( HT_ELEMENT * phte, IN BOOL fCheckBeforeInsert)
{
    // 1. Calculate the hash value for key of the HT_ELEMENT object
    // 2. Find the bucket for the hash value
    // 3. Check if this item is not already present and insert
    //     it into the hash table.
    //  (the check can be bypassed if fCheck is set to FALSE)
    // 4. return the result, after updating statistics

    DWORD hashVal = CalculateHash( phte->QueryKey());
    BOOL  fRet;

    INCREMENT_INSERTS();

    DBG_ASSERT( NULL != m_prgBuckets);
    fRet = m_prgBuckets[hashVal % m_nBuckets].Insert( hashVal,
                                                      phte,
                                                      fCheckBeforeInsert);

    IF_DEBUG( ERROR) {
        if ( !fRet) {
            DBGPRINTF(( DBG_CONTEXT,
                        " Unable to insert %08x into bucket %d."
                        "  Bucket has %d elements. Error = %d\n",
                        phte, hashVal % m_nBuckets,
                        m_prgBuckets[hashVal % m_nBuckets].NumEntries(),
                        GetLastError()
                        ));
        }
    }
    INCREMENT_ENTRIES( fRet);

    return ( fRet);
} // HASH_TABLE::Insert()



BOOL
HASH_TABLE::Delete( HT_ELEMENT * phte)
{
    BOOL  fRet;
    DWORD hashVal = CalculateHash( phte->QueryKey(), phte->QueryKeyLen());

    DBG_ASSERT( NULL != m_prgBuckets);
    fRet = m_prgBuckets[hashVal % m_nBuckets].Delete( phte);

    DECREMENT_ENTRIES( fRet);

    return ( fRet);
} // HASH_TABLE::Delete()



VOID
HASH_TABLE::Print( IN DWORD level)
{
    DWORD i;

    DBGPRINTF(( DBG_CONTEXT,
                "HASH_TABLE(%08x) "
                "%s: nBuckets = %d; dwFlags = %d;"
                " nEntries = %d; nLookups = %d; nHits = %d;"
                " nInserts = %d; nFlushes = %d;"
                " m_prgBuckets = %d\n",
                this, m_rgchId, m_nBuckets, m_dwFlags,
                m_nEntries, m_nLookups, m_nHits, m_nInserts,
                m_nFlushes, m_prgBuckets));

    if ( level == 0 ) {

        CHAR rgchBuff[2000];
        DWORD cch;

        cch = wsprintfA( rgchBuff, "\tBucket  NumEntries\n");
        DBG_ASSERT( NULL != m_prgBuckets);
        for (i = 0; i < m_nBuckets; i++) {

            cch += wsprintf( rgchBuff + cch, "\t[%4d]  %4d,\n",
                             i, m_prgBuckets[i].NumEntries());
        } // for

        DBGDUMP(( DBG_CONTEXT, rgchBuff));
    } else {

        DBG_ASSERT( NULL != m_prgBuckets);
        for (i = 0; i < m_nBuckets; i++) {

            m_prgBuckets[i].Print( level);
        } // for
    }

    return;
} // HASH_TABLE::Print()



DWORD
HASH_TABLE::InitializeIterator( IN HT_ITERATOR * phti)
{
    DWORD dwErr = ERROR_NO_MORE_ITEMS;
    DBG_ASSERT( IsValid());
    DBG_ASSERT( NULL != phti);

    // initialize the iterator
    phti->nBucketNumber = INFINITE;
    phti->nChunkId = NULL;
    phti->nPos = 0;

    if ( m_nEntries > 0) {
        // set the iterator to point to the first bucket with some elements.
        for ( DWORD i = 0; (i < m_nBuckets); i++) {

            dwErr = m_prgBuckets[i].InitializeIterator( phti);
            if ( dwErr == NO_ERROR) {
                phti->nBucketNumber = i;
                break;
            }
        }
    }

    return ( dwErr);
} // HASH_TABLE::InitializeIterator()


DWORD
HASH_TABLE::FindNextElement( IN HT_ITERATOR * phti,
                             OUT HT_ELEMENT ** pphte)
{
    DWORD dwErr = ERROR_NO_MORE_ITEMS;
    DBG_ASSERT( IsValid());
    DBG_ASSERT( NULL != phti);
    DBG_ASSERT( NULL != pphte);

    if ( INFINITE != phti->nBucketNumber) {

        // iterator has some valid state use it.
        DBG_ASSERT( phti->nBucketNumber < m_nBuckets);

        dwErr =
            m_prgBuckets[ phti->nBucketNumber].FindNextElement( phti, pphte);

        if ( ERROR_NO_MORE_ITEMS == dwErr) {

            DBG_REQUIRE( m_prgBuckets[ phti->nBucketNumber].
                            CloseIterator( phti)
                         == NO_ERROR
                        );

            // hunt for the next bucket with an element.
            for ( DWORD i = (phti->nBucketNumber + 1); (i < m_nBuckets); i++) {

                dwErr = m_prgBuckets[i].InitializeIterator( phti);

                if ( dwErr == NO_ERROR) {
                    phti->nBucketNumber = i;
                    dwErr = m_prgBuckets[ i].FindNextElement( phti, pphte);
                    DBG_ASSERT( dwErr == NO_ERROR);
                    break;
                }
            } // for

            if ( ERROR_NO_MORE_ITEMS == dwErr) {
                // reset the bucket number
                phti->nBucketNumber = INFINITE;
            }
        }
    }

    return ( dwErr);
} // HASH_TABLE::FindNextElement()


DWORD
HASH_TABLE::CloseIterator( IN HT_ITERATOR * phti)
{
    DBG_ASSERT( IsValid());
    DBG_ASSERT( NULL != phti);

    if ( INFINITE != phti->nBucketNumber) {
        DBG_ASSERT( phti->nBucketNumber < m_nBuckets);
        DBG_REQUIRE( m_prgBuckets[ phti->nBucketNumber].
                     CloseIterator( phti)
                     == NO_ERROR
                     );
        phti->nBucketNumber = INFINITE;
    }

    return ( NO_ERROR);
} // HASH_TABLE::CloseIterator()


/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\atq\dllmain.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1994-1996           **/
/**********************************************************************/

/*
    dllmain.cxx

        Library initialization for isatq.dll  --
           Internet Information Services - ATQ dll.

    FILE HISTORY:

        MuraliK     08-Apr-1996  Created.
*/


#include "isatq.hxx"


/************************************************************
 * Globals
 ************************************************************/

DECLARE_DEBUG_VARIABLE();
DECLARE_DEBUG_PRINTS_OBJECT();


//
// is winsock initialized?
//

BOOL    g_fSocketsInitialized = FALSE;

//
// This Misc lock is used to guard the initialization code (and anything else
// that might come up later).
//

BOOL    miscLockInitialized = FALSE;
CRITICAL_SECTION    MiscLock;


/************************************************************
 * Functions
 ************************************************************/



extern "C"
BOOL WINAPI
DllMain( HINSTANCE hDll, DWORD dwReason, LPVOID lpvReserved )
{
    BOOL  fReturn = TRUE;

    switch ( dwReason )
    {
    case DLL_PROCESS_ATTACH:  {

        CREATE_DEBUG_PRINT_OBJECT( "isatq");
        if ( !VALID_DEBUG_PRINT_OBJECT()) {
            return ( FALSE);
        }

        //
        // Initialize global init critsect
        //

        miscLockInitialized =
            InitializeCriticalSectionAndSpinCount(&MiscLock, 400);

        if ( !miscLockInitialized ) {
            return FALSE;
        }

        SET_DEBUG_FLAGS( DEBUG_ERROR );

        //
        // Initialize sockets
        //

        {
            DWORD dwError = NO_ERROR;

            WSADATA   wsaData;
            INT       serr;

            //
            //  Connect to WinSock 2.0
            //

            serr = WSAStartup( MAKEWORD( 2, 0), &wsaData);

            if( serr != 0 ) {
                DBGPRINTF((DBG_CONTEXT,"WSAStartup failed with %d\n",serr));
                return(FALSE);
            }
            g_fSocketsInitialized = TRUE;
        }

        //
        // Initialize the platform type
        //
        INITIALIZE_PLATFORM_TYPE();
        ATQ_ASSERT(IISIsValidPlatform());

        DisableThreadLibraryCalls( hDll );
        break;
    }

    case DLL_PROCESS_DETACH:

        if ( lpvReserved != NULL) {

            //
            //  Only Cleanup if there is a FreeLibrary() call.
            //

            break;
        }


        //
        // Cleanup sockets
        //

        if ( g_fSocketsInitialized ) {

            INT serr = WSACleanup();

            if ( serr != 0) {
                ATQ_PRINTF((DBG_CONTEXT,"WSACleanup failed with %d\n",
                            WSAGetLastError()));
            }
            g_fSocketsInitialized = FALSE;
        }

        if ( miscLockInitialized ) {
            DeleteCriticalSection(&MiscLock);
            miscLockInitialized = FALSE;
        }

        DELETE_DEBUG_PRINT_OBJECT();
        break;

    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    default:
        break ;
    }

    return ( fReturn);

} // main()


=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\atq\inetsvcs.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    inetsvcs.h

Abstract:

    Header file for Internet Services common data/functions.

Author:

    Murali R. Krishnan (MuraliK)   20-Feb-1996  - Migrated from old tcpsvcs.h

Revision History:

--*/

#ifndef _INETSVCS_H_
#define _INETSVCS_H_

//
// Service DLLs are loaded into master service executable (eg: inetinfo.exe)
//   All the dlls should export this entry point
//    defined by INETSVCS_ENTRY_POINT
//
// Note that INETSVCS_ENTRY_POINT_STRING is always ANSI, because that's
// what GetProcAddress takes.
//

#define INETSVCS_ENTRY_POINT         ServiceEntry
#define INETSVCS_ENTRY_POINT_STRING  "ServiceEntry"

//
// Start and stop RPC server entry point prototype.
//

typedef
DWORD
(*PTCPSVCS_START_RPC_SERVER_LISTEN) (
    VOID
    );

typedef
DWORD
(*PTCPSVCS_STOP_RPC_SERVER_LISTEN) (
    VOID
    );

//
// Structure containing "global" data for the various DLLs.
//

typedef struct _TCPSVCS_GLOBAL_DATA {

    //
    // Entry points provided by TCPSVCS.EXE.
    //

    PTCPSVCS_START_RPC_SERVER_LISTEN  StartRpcServerListen;
    PTCPSVCS_STOP_RPC_SERVER_LISTEN   StopRpcServerListen;

} TCPSVCS_GLOBAL_DATA, *PTCPSVCS_GLOBAL_DATA;

//
// Service DLL entry point prototype.
//

typedef
VOID
(*PINETSVCS_SERVICE_DLL_ENTRY) (
    IN DWORD argc,
    IN LPSTR argv[],
    IN PTCPSVCS_GLOBAL_DATA pGlobalData
    );


#if DBG
#define IIS_PRINTF( x )        { char buff[256]; wsprintf x; OutputDebugString( buff ); }
#else
#define IIS_PRINTF( x )
#endif

#define BUG_PRINTF( x )        { char buff[256]; wsprintf x; OutputDebugString( buff ); }


#define INIT_LOCK(_lock)        InitializeCriticalSection( _lock );
#define DELETE_LOCK(_lock)      DeleteCriticalSection( _lock );
#define ACQUIRE_LOCK(_lock)     EnterCriticalSection( _lock );
#define RELEASE_LOCK(_lock)     LeaveCriticalSection( _lock );

//
// Event used to indicate whether service is running as exe
//

#define IIS_AS_EXE_OBJECT_NAME  "Internet_infosvc_as_exe"


#endif	// ifndef _INETSVCS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\atq\pudebug.h ===
/*++

   Copyright    (c)    1994    Microsoft Corporation

   Module  Name :

        pudebug.h

   Abstract:

      This module declares the DEBUG_PRINTS object helpful in
       testing the programs

   Author:

      Murali R. Krishnan    ( MuraliK )    14-Dec-1994
      Modified to include a and other functions ( 22-Dec-1994)

   Revision History:
      MuraliK  16-May-1995   Added function to read debug flags.
      MuraliK  12-Sept-1996  Added functions to dump the output.

--*/

# ifndef _PUDEBUG_H_
# define _PUDEBUG_H_


/************************************************************
 *     Include Headers
 ************************************************************/

# ifdef __cplusplus
extern "C" {
# endif // __cplusplus

# include <windows.h>

# ifndef dllexp
# define dllexp   __declspec( dllexport)
# endif // dllexp

/***********************************************************
 *    Macros
 ************************************************************/

enum  PRINT_REASONS {
    PrintNone     = 0x0,   // Nothing to be printed
    PrintError    = 0x1,   // An error message
    PrintWarning  = 0x2,   // A  warning message
    PrintLog      = 0x3,   // Just logging. Indicates a trace of where ...
    PrintMsg      = 0x4,   // Echo input message
    PrintCritical = 0x5,   // Print and Exit
    PrintAssertion= 0x6    // Printing for an assertion failure
  };


enum  DEBUG_OUTPUT_FLAGS {
    DbgOutputNone     = 0x0,            // None
    DbgOutputKdb      = 0x1,            // Output to Kernel Debugger
    DbgOutputLogFile  = 0x2,            // Output to LogFile
    DbgOutputTruncate = 0x4,            // Truncate Log File if necessary
    DbgOutputStderr   = 0x8,            // Send output to std error
    DbgOutputBackup   = 0x10,           // Make backup of debug file ?
    DbgOutputAll      = 0xFFFFFFFF      // All the bits set.
  };


# define MAX_LABEL_LENGTH                 ( 100)



/*++
  class DEBUG_PRINTS

  This class is responsible for printing messages to log file / kernel debugger

  Currently the class supports only member functions for <ANSI> char.
   ( not unicode-strings).

--*/

typedef struct _DEBUG_PRINTS {

    CHAR         m_rgchLabel[MAX_LABEL_LENGTH];
    CHAR         m_rgchLogFilePath[MAX_PATH];
    CHAR         m_rgchLogFileName[MAX_PATH];
    HANDLE       m_LogFileHandle;
    HANDLE       m_StdErrHandle;
    BOOL         m_fInitialized;
    DWORD        m_dwOutputFlags;

} DEBUG_PRINTS, FAR * LPDEBUG_PRINTS;


dllexp
LPDEBUG_PRINTS
 PuCreateDebugPrintsObject(
   IN const char * pszPrintLabel,
   IN DWORD  dwOutputFlags);

//
// frees the debug prints object and closes any file if necessary.
//  Returns NULL on success or returns pDebugPrints on failure.
//
dllexp
LPDEBUG_PRINTS
 PuDeleteDebugPrintsObject(
   IN OUT LPDEBUG_PRINTS  pDebugPrints);


dllexp
VOID
 PuDbgPrint(
   IN OUT LPDEBUG_PRINTS   pDebugPrints,
   IN const char *         pszFilePath,
   IN int                  nLineNum,
   IN const char *         pszFormat,
   ...);                               // arglist

/*++
  PuDbgDump() does not do any formatting of output.
  It just dumps the given message onto the debug destinations.
--*/
dllexp
VOID
 PuDbgDump(
   IN OUT LPDEBUG_PRINTS   pDebugPrints,
   IN const char *         pszFilePath,
   IN int                  nLineNum,
   IN const char *         pszDump
   );

//
// PuDbgAssertFailed() *must* be __cdecl to properly capture the
// thread context at the time of the failure.
//

dllexp
VOID
__cdecl
 PuDbgAssertFailed(
   IN OUT LPDEBUG_PRINTS   pDebugPrints,
   IN const char *         pszFilePath,
   IN int                  nLineNum,
   IN const char *         pszExpression,
   IN const char *         pszMessage);

dllexp
VOID
 PuDbgCaptureContext (
    OUT PCONTEXT ContextRecord
    );

VOID
PuDbgPrintCurrentTime(
    IN OUT LPDEBUG_PRINTS         pDebugPrints,
    IN const char *               pszFilePath,
    IN int                        nLineNum
    );

dllexp
VOID
 PuSetDbgOutputFlags(
   IN OUT LPDEBUG_PRINTS   pDebugPrints,
   IN DWORD                dwFlags);

dllexp
DWORD
 PuGetDbgOutputFlags(
   IN const LPDEBUG_PRINTS       pDebugPrints);


//
// Following functions return Win32 error codes.
// NO_ERROR if success
//

dllexp
DWORD
 PuOpenDbgPrintFile(
   IN OUT LPDEBUG_PRINTS   pDebugPrints,
   IN const char *         pszFileName,
   IN const char *         pszPathForFile);

dllexp
DWORD
 PuReOpenDbgPrintFile(
   IN OUT LPDEBUG_PRINTS   pDebugPrints);

dllexp
DWORD
 PuCloseDbgPrintFile(
   IN OUT LPDEBUG_PRINTS   pDebugPrints);

dllexp
DWORD
  PuLoadDebugFlagsFromReg(IN HKEY hkey, IN DWORD dwDefault);

dllexp DWORD
  PuLoadDebugFlagsFromRegStr(IN LPCSTR pszRegKey, IN DWORD dwDefault);

dllexp
DWORD
  PuSaveDebugFlagsInReg(IN HKEY hkey, IN DWORD dwDbg);


# define PuPrintToKdb( pszOutput)    \
                    if ( pszOutput != NULL)   {   \
                        OutputDebugString( pszOutput);  \
                    } else {}



# ifdef __cplusplus
};
# endif // __cplusplus

// begin_user_unmodifiable

# if DBG


/***********************************************************
 *    Macros
 ************************************************************/


extern
#ifdef __cplusplus
"C"
# endif // _cplusplus
 DEBUG_PRINTS  *  g_pDebug;        // define a global debug variable


# define DECLARE_DEBUG_PRINTS_OBJECT()          \
         DEBUG_PRINTS  *  g_pDebug = NULL;


//
// Call the following macro as part of your initialization for program
//  planning to use the debugging class.
//
# define CREATE_DEBUG_PRINT_OBJECT( pszLabel)  \
        g_pDebug = PuCreateDebugPrintsObject( pszLabel, DEFAULT_OUTPUT_FLAGS);\
         if  ( g_pDebug == NULL) {   \
               OutputDebugStringA( "Unable to Create Debug Print Object \n"); \
         }

//
// Call the following macro once as part of the termination of program
//    which uses the debugging class.
//
# define DELETE_DEBUG_PRINT_OBJECT( )  \
        g_pDebug = PuDeleteDebugPrintsObject( g_pDebug);


# define VALID_DEBUG_PRINT_OBJECT()     \
        ( ( g_pDebug != NULL) && g_pDebug->m_fInitialized)


//
//  Use the DBG_CONTEXT without any surrounding braces.
//  This is used to pass the values for global DebugPrintObject
//     and File/Line information
//
# define DBG_CONTEXT        g_pDebug, __FILE__, __LINE__



# define DBG_CODE(s)          s          /* echoes code in debugging mode */


# define DBG_ASSERT( exp)    if ( !(exp)) { \
                                 PuDbgAssertFailed( DBG_CONTEXT, #exp, NULL); \
                             } else {}

# define DBG_ASSERT_MSG( exp, pszMsg)    \
                             if ( !(exp)) { \
                                  PuDbgAssertFailed( DBG_CONTEXT, #exp, pszMsg); \
                              } else {}

# define DBG_REQUIRE( exp)    DBG_ASSERT( exp)

# define DBG_LOG()            PuDbgPrint( DBG_CONTEXT, "\n")

# define DBG_OPEN_LOG_FILE( pszFile, pszPath)   \
                  PuOpenDbgPrintFile( g_pDebug, (pszFile), (pszPath))

# define DBG_CLOSE_LOG_FILE( )   \
                  PuCloseDbgPrintFile( g_pDebug)


//
//  DBGPRINTF() is printing function ( much like printf) but always called
//    with the DBG_CONTEXT as follows
//   DBGPRINTF( ( DBG_CONTEXT, format-string, arguments for format list);
//
# define DBGPRINTF( args)     PuDbgPrint args

# define DBGDUMP( args)       PuDbgDump  args

# define DBGPRINT_CURRENT_TIME()  PuDbgPrintCurrentTime( DBG_CONTEXT)

# else // DBG


# define DECLARE_DEBUG_PRINTS_OBJECT()           /* Do Nothing */
# define CREATE_DEBUG_PRINT_OBJECT( pszLabel)    ((void)0) /* Do Nothing */
# define DELETE_DEBUG_PRINT_OBJECT( )            ((void)0) /* Do Nothing */
# define VALID_DEBUG_PRINT_OBJECT()              ( TRUE)

# define DBG_CODE(s)                             ((void)0) /* Do Nothing */

# define DBG_ASSERT(exp)                         ((void)0) /* Do Nothing */

# define DBG_ASSERT_MSG(exp, pszMsg)             ((void)0) /* Do Nothing */

# define DBG_REQUIRE( exp)                       ( (void) (exp))

# define DBGPRINTF( args)                        ((void)0) /* Do Nothing */

# define DBGDUMP( args)                          ((void)0) /* Do nothing */

# define DBG_LOG()                               ((void)0) /* Do Nothing */

# define DBG_OPEN_LOG_FILE( pszFile, pszPath)    ((void)0) /* Do Nothing */

# define DBG_CLOSE_LOG_FILE()                    ((void)0) /* Do Nothing */

# define DBGPRINT_CURRENT_TIME()                 ((void)0) /* Do Nothing */

# endif // DBG


// end_user_unmodifiable

// begin_user_unmodifiable


#ifdef XOMASSERT
# undef XOMASSERT
#endif


# define XOMASSERT( exp)           DBG_ASSERT( exp)


# if DBG

extern
#ifdef __cplusplus
"C"
# endif // _cplusplus
 DWORD  g_dwDebugFlags;           // Debugging Flags

# define DECLARE_DEBUG_VARIABLE()     \
             DWORD  g_dwDebugFlags

# define SET_DEBUG_FLAGS( dwFlags)         g_dwDebugFlags = dwFlags
# define GET_DEBUG_FLAGS()                 ( g_dwDebugFlags)

# define LOAD_DEBUG_FLAGS_FROM_REG(hkey, dwDefault)  \
             g_dwDebugFlags = PuLoadDebugFlagsFromReg((hkey), (dwDefault))

# define LOAD_DEBUG_FLAGS_FROM_REG_STR(pszRegKey, dwDefault)  \
             g_dwDebugFlags = PuLoadDebugFlagsFromRegStr((pszRegKey), (dwDefault))

# define SAVE_DEBUG_FLAGS_IN_REG(hkey, dwDbg)  \
               PuSaveDebugFlagsInReg((hkey), (dwDbg))

# define DEBUG_IF( arg, s)     if ( DEBUG_ ## arg & GET_DEBUG_FLAGS()) { \
                                       s \
                                } else {}

# define IF_DEBUG( arg)        if ( DEBUG_## arg & GET_DEBUG_FLAGS())


# else   // DBG


# define DECLARE_DEBUG_VARIABLE()                /* Do Nothing */
# define SET_DEBUG_FLAGS( dwFlags)               /* Do Nothing */
# define GET_DEBUG_FLAGS()                       ( 0)
# define LOAD_DEBUG_FLAGS_FROM_REG(hkey, dwDefault) /* Do Nothing */

# define LOAD_DEBUG_FLAGS_FROM_REG_STR(pszRegKey, dwDefault)  /* Do Nothing */

# define SAVE_DEBUG_FLAGS_IN_REG(hkey, dwDbg)    /* Do Nothing */

# define DEBUG_IF( arg, s)                       /* Do Nothing */
# define IF_DEBUG( arg)                          if ( 0)

# endif // DBG

// end_user_unmodifiable

// begin_user_modifiable

//
//  Debugging constants consist of two pieces.
//  All constants in the range 0x0 to 0x8000 are reserved
//  User extensions may include additional constants (bit flags)
//

# define DEBUG_API_ENTRY                  0x00000001L
# define DEBUG_API_EXIT                   0x00000002L
# define DEBUG_INIT_CLEAN                 0x00000004L
# define DEBUG_ERROR                      0x00000008L

                   // End of Reserved Range
# define DEBUG_RESERVED                   0x00000FFFL

// end_user_modifiable




/***********************************************************
 *    Platform Type related variables and macros
 ************************************************************/

//
// Enum for product types
//

typedef enum _PLATFORM_TYPE {

    PtInvalid = 0,                 // Invalid
    PtNtWorkstation = 1,           // NT Workstation
    PtNtServer = 2,                // NT Server
    PtWindows95 = 3,               // Windows 95
    PtWindows9x = 4                // Windows 9x - not implemented

} PLATFORM_TYPE;

//
// IISGetPlatformType is the function used to the platform type
//

extern
#ifdef __cplusplus
"C"
# endif // _cplusplus
dllexp
PLATFORM_TYPE
IISGetPlatformType(
        VOID
        );

//
// External Macros
//

#define InetIsNtServer( _pt )           ((_pt) == PtNtServer)
#define InetIsNtWksta( _pt )            ((_pt) == PtNtWorkstation)
#define InetIsWindows95( _pt )          ((_pt) == PtWindows95)
#define InetIsValidPT(_pt)              ((_pt) != PtInvalid)

extern
#ifdef __cplusplus
"C"
# endif // _cplusplus
PLATFORM_TYPE    g_PlatformType;


// Use the DECLARE_PLATFORM_TYPE macro to declare the platform type
#define DECLARE_PLATFORM_TYPE()  \
   PLATFORM_TYPE    g_PlatformType = PtInvalid;

// Use the INITIALIZE_PLATFORM_TYPE to init the platform type
// This should typically go inside the DLLInit or equivalent place.
#define INITIALIZE_PLATFORM_TYPE()  \
   g_PlatformType = IISGetPlatformType();

//
// Additional Macros to use the Platform Type
//

#define TsIsNtServer( )         InetIsNtServer(g_PlatformType)
#define TsIsNtWksta( )          InetIsNtWksta(g_PlatformType)
#define TsIsWindows95()         InetIsWindows95(g_PlatformType)
#define IISIsValidPlatform()    InetIsValidPT(g_PlatformType)
#define IISPlatformType()       (g_PlatformType)


/***********************************************************
 *    Some utility functions for Critical Sections
 ************************************************************/

//
// IISSetCriticalSectionSpinCount() provides a thunk for the
//  original NT API SetCriticalSectionSpinCount() for CS with Spin counts
// Users of this function should definitely dynlink with kernel32.dll,
//  Otherwise errors will surface to a large extent
//
extern
#ifdef __cplusplus
"C"
# endif // _cplusplus
DWORD
IISSetCriticalSectionSpinCount(
    LPCRITICAL_SECTION lpCriticalSection,
    DWORD dwSpinCount
);

//
// Macro for the calls to SetCriticalSectionSpinCount()
//
# define SET_CRITICAL_SECTION_SPIN_COUNT( lpCS, dwSpins) \
  IISSetCriticalSectionSpinCount( (lpCS), (dwSpins))

//
// IIS_DEFAULT_CS_SPIN_COUNT is the default value of spins used by
//  Critical sections defined within IIS.
// NYI: We should have to switch the individual values based on experiments!
// Current value is an arbitrary choice
//
# define IIS_DEFAULT_CS_SPIN_COUNT   (400)

# endif  /* _DEBUG_HXX_ */

//
// The following macros allow the automatic naming of certain Win32 objects.
// See IIS\SVCS\IRTL\DBGSUPP\WIN32OBJ.C for details on the naming convention.
//
// Set IIS_NAMED_WIN32_OBJECTS to a non-zero value to enable named events,
// semaphores, and mutexes.
//

#if DBG
#define IIS_NAMED_WIN32_OBJECTS 1
#else
#define IIS_NAMED_WIN32_OBJECTS 0
#endif

#ifdef __cplusplus
extern "C" {
#endif

dllexp
HANDLE
PuDbgCreateEvent(
    IN LPSTR FileName,
    IN ULONG LineNumber,
    IN LPSTR MemberName,
    IN PVOID Address,
    IN BOOL ManualReset,
    IN BOOL InitialState
    );

dllexp
HANDLE
PuDbgCreateSemaphore(
    IN LPSTR FileName,
    IN ULONG LineNumber,
    IN LPSTR MemberName,
    IN PVOID Address,
    IN LONG InitialCount,
    IN LONG MaximumCount
    );

dllexp
HANDLE
PuDbgCreateMutex(
    IN LPSTR FileName,
    IN ULONG LineNumber,
    IN LPSTR MemberName,
    IN PVOID Address,
    IN BOOL InitialOwner
    );

#ifdef __cplusplus
}   // extern "C"
#endif

#if IIS_NAMED_WIN32_OBJECTS

#define IIS_CREATE_EVENT( membername, address, manual, state )              \
    PuDbgCreateEvent(                                                       \
        (LPSTR)__FILE__,                                                    \
        (ULONG)__LINE__,                                                    \
        (membername),                                                       \
        (PVOID)(address),                                                   \
        (manual),                                                           \
        (state)                                                             \
        )

#define IIS_CREATE_SEMAPHORE( membername, address, initial, maximum )       \
    PuDbgCreateSemaphore(                                                   \
        (LPSTR)__FILE__,                                                    \
        (ULONG)__LINE__,                                                    \
        (membername),                                                       \
        (PVOID)(address),                                                   \
        (initial),                                                          \
        (maximum)                                                           \
        )

#define IIS_CREATE_MUTEX( membername, address, initial )                     \
    PuDbgCreateMutex(                                                       \
        (LPSTR)__FILE__,                                                    \
        (ULONG)__LINE__,                                                    \
        (membername),                                                       \
        (PVOID)(address),                                                   \
        (initial)                                                           \
        )

#else   // !IIS_NAMED_WIN32_OBJECTS

#define IIS_CREATE_EVENT( membername, address, manual, state )              \
    CreateEventA(                                                           \
        NULL,                                                               \
        (manual),                                                           \
        (state),                                                            \
        NULL                                                                \
        )

#define IIS_CREATE_SEMAPHORE( membername, address, initial, maximum )       \
    CreateSemaphoreA(                                                       \
        NULL,                                                               \
        (initial),                                                          \
        (maximum),                                                          \
        NULL                                                                \
        )

#define IIS_CREATE_MUTEX( membername, address, initial )                     \
    CreateMutexA(                                                           \
        NULL,                                                               \
        (initial),                                                          \
        NULL                                                                \
        )

#endif  // IIS_NAMED_WIN32_OBJECTS


/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\atq\reftrace.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    reftrace.h

Abstract:

    This module contains public declarations and definitions for tracing
    and debugging reference count problems. This module uses the generic
    TRACE_LOG facility in tracelog.h.

    Ref count trace logs can be dumped via the !inetdbg.ref command
    in either NTSD or CDB.

Author:

    Keith Moore (keithmo)        01-May-1997

Revision History:

--*/


#ifndef _REFTRACE_H_
#define _REFTRACE_H_


#if defined(__cplusplus)
extern "C" {
#endif  // __cplusplus


#include <tracelog.h>


//
// This is the number of stack backtrace values captured in each
// trace log entry. This value is chosen to make the log entry
// exactly eight dwords long, making it a bit easier to interpret
// from within the debugger without the debugger extension.
//

#define REF_TRACE_LOG_STACK_DEPTH   5


//
// This defines the entry written to the trace log.
//

typedef struct _REF_TRACE_LOG_ENTRY {

    LONG NewRefCount;
    PVOID Context;
    PVOID Context1;
    PVOID Context2;
    PVOID Context3;
    DWORD Thread;
    PVOID Stack[REF_TRACE_LOG_STACK_DEPTH];

} REF_TRACE_LOG_ENTRY, *PREF_TRACE_LOG_ENTRY;


//
// Manipulators.
//

PTRACE_LOG
CreateRefTraceLog(
    IN LONG LogSize,
    IN LONG ExtraBytesInHeader
    );

VOID
DestroyRefTraceLog(
    IN PTRACE_LOG Log
    );

VOID
WriteRefTraceLog(
    IN PTRACE_LOG Log,
    IN LONG NewRefCount,
    IN PVOID Context
    );

VOID
WriteRefTraceLogEx(
    IN PTRACE_LOG Log,
    IN LONG NewRefCount,
    IN PVOID Context,
    IN PVOID Context1,
    IN PVOID Context2,
    IN PVOID Context3
    );


#if defined(__cplusplus)
}   // extern "C"
#endif  // __cplusplus


#endif  // _REFTRACE_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\atq\sched.cxx ===
/*++
   Copyright    (c)    1995-1996     Microsoft Corporation

   Module Name:

       sched.cxx

   Abstract:

        This module contains a simple timer interface for scheduling future
        work items


   Author:

        John Ludeman    (johnl)     17-Jul-1995

   Project:

        Internet Servers Common Server DLL

   Revisions:
        Murali R. Krishnan  (MuraliK)     16-Sept-1996
          Added scheduler items cache
--*/

//
//  Include Headers
//

#include "isatq.hxx"
#include "sched.hxx"

//
//  Global definitions
//

#define LockScheduleList()      EnterCriticalSection( &csSchedulerLock )
#define UnlockScheduleList()    LeaveCriticalSection( &csSchedulerLock )

#define NUM_SCHEDULE_THREADS_PWS        1
#define NUM_SCHEDULE_THREADS_NTS        1

ALLOC_CACHE_HANDLER * SCHED_ITEM::sm_pachSchedItems = NULL;

SCHED_ITEM_STATE sg_rgSchedNextState[SI_OP_MAX][SI_MAX_ITEMS] = {
    // operation = SI_OP_ADD
    {
        SI_ERROR,
        SI_ACTIVE,
        SI_ERROR,
        SI_ERROR,
        SI_ERROR,
        SI_ERROR,
    },

    // operation = SI_OP_ADD_PERIODIC
    {
        SI_ERROR,
        SI_ACTIVE_PERIODIC,
        SI_ERROR,
        SI_ERROR,
        SI_ACTIVE_PERIODIC,  // rescheduling periodic item
        SI_ERROR,
    },

    // operation = SI_OP_CALLBACK
    {
        SI_ERROR,
        SI_ERROR,
        SI_TO_BE_DELETED,  // to be removed after completing callbacks
        SI_CALLBACK_PERIODIC,
        SI_ERROR,
        SI_ERROR,
    },

    // operation = SI_OP_DELETE
    {
        SI_ERROR,
        SI_ERROR,
        SI_IDLE,
        SI_IDLE,
        SI_TO_BE_DELETED,  // mark this to be deleted after return
        SI_TO_BE_DELETED,  // idempotent delete operations
    }
};



SCHED_ITEM *
I_FindSchedulerItem( DWORD dwCookie);

VOID
I_InsertIntoWorkItemList( SCHED_ITEM * psi);


DWORD
SchedulerThread(
    LPDWORD lpdwParam
    );

//
//  Global data items
//

LIST_ENTRY        ScheduleListHead;
CRITICAL_SECTION  csSchedulerLock;
BOOL              fSchedulerInitialized = FALSE;
BOOL              fSchedShutdown = FALSE;
HANDLE            hSchedulerEvent;
DWORD             cSchedThreads = 0;

//
//  Used as identification cookie for removing items
//

DWORD             dwSchedSerial = 0;


/************************************************************
 *  Public functions of Scheduler
 ************************************************************/



BOOL
SchedulerInitialize(
    VOID
    )
/*++

Routine Description:

    Initializes the scheduler/timer package

Arguments:

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)

--*/
{
    DWORD   idThread;
    DWORD   i;
    DWORD   numThreads;

    if ( fSchedulerInitialized ) {
        return TRUE;
    }

    InitializeSecondsTimer();

    hSchedulerEvent = IIS_CREATE_EVENT(
                          "hSchedulerEvent",
                          &hSchedulerEvent,
                          FALSE,
                          FALSE
                          );

    if ( hSchedulerEvent == NULL ) {
        return FALSE;
    }

    if ( TsIsNtServer() ) {
        numThreads = NUM_SCHEDULE_THREADS_NTS;
    } else {
        numThreads = NUM_SCHEDULE_THREADS_PWS;
    }

    InitializeCriticalSection( &csSchedulerLock );
    SET_CRITICAL_SECTION_SPIN_COUNT( &csSchedulerLock,
                                     IIS_DEFAULT_CS_SPIN_COUNT);

    InitializeListHead( &ScheduleListHead );

    for ( i = 0; i < numThreads; i++ ) {

        HANDLE hSchedulerThread;

        hSchedulerThread =
            CreateThread( NULL,
                          0,
                          (LPTHREAD_START_ROUTINE) SchedulerThread,
                          NULL,
                          0,
                          &idThread );

        if ( !hSchedulerThread ) {
            DeleteCriticalSection( &csSchedulerLock );
            CloseHandle( hSchedulerEvent );
            return FALSE;
        }

        DBG_REQUIRE( CloseHandle( hSchedulerThread ));

        cSchedThreads++;
    }

    DBG_REQUIRE( SCHED_ITEM::Initialize());

    fSchedulerInitialized = TRUE;
    fSchedShutdown = FALSE;    
    return TRUE;
} // SchedulerInitialize()



VOID
SchedulerTerminate(
    VOID
    )
/*++

Routine Description:

    Terminates and cleans up the scheduling package.  Any items left on the
    list are *not* called during cleanup.

--*/
{
    DWORD iRetry;

    if ( !fSchedulerInitialized || fSchedShutdown) {
        // either uninitialized or already shutting down
        return;
    }

    fSchedShutdown = TRUE;

    DBG_REQUIRE( SetEvent( hSchedulerEvent ) );

    LockScheduleList();

    //
    //  Delete all of the items that were scheduled, note we do *not*
    //  call any scheduled items in the list (there shouldn't be any)
    //

    if ( !IsListEmpty( &ScheduleListHead ) ) {
        DBGPRINTF(( DBG_CONTEXT,
                    "[SchedulerTerminate] Warning - Items in schedule list "
                    "at termination\n" ));
    }

    UnlockScheduleList();

    //
    // If this function is called from DLL terminate, then the threads are dead
    //  So try finite times and give up
    // loop and wait for scheduler thread to die out
    //

    for ( iRetry = 0; cSchedThreads && (iRetry < 5); iRetry++) {

        //
        // Set the event again, so that some other thread will wake up and die
        //

        DBG_REQUIRE( SetEvent( hSchedulerEvent ) );
        Sleep( 100 );  // give some time for thread to die out
    } // for

    DeleteCriticalSection( &csSchedulerLock );
    CloseHandle( hSchedulerEvent );

    SCHED_ITEM::Cleanup();
    fSchedulerInitialized = FALSE;
} // SchedulerTerminate()



DWORD
ScheduleWorkItem(
    PFN_SCHED_CALLBACK pfnCallback,
    PVOID              pContext,
    DWORD              msecTime,
    BOOL               fPeriodic
    )
/*++

Routine Description:

    Adds a timed work item to the work list

Arguments:

    pfnCallback - Function to call
    pContext - Context to pass to the callback
    msecTime - number of milliseconds to wait before calling timeout
    nPriority - Thread priority to set for work item

Return Value:

    zero on failure, non-zero on success.  The return value can be used to
    remove the scheduled work item.

--*/
{
    SCHED_ITEM * psi;
    DWORD        dwRet;

    ATQ_ASSERT( fSchedulerInitialized );

    //
    // 1. alloc a new scheduler item
    //

    psi = new SCHED_ITEM( pfnCallback,
                          pContext,
                          msecTime,
                          ++dwSchedSerial );

    if ( !psi ) {

        //
        // unable to create the item - return error cookie '0'
        //

        return 0;
    }

    dwRet = psi->_dwSerialNumber;
    SCHED_OPS  siop = ((fPeriodic)? SI_OP_ADD_PERIODIC : SI_OP_ADD);
    psi->_siState = sg_rgSchedNextState[siop][SI_IDLE];

    //
    // 2. Insert the scheduler item into the active scheduler work-items list.
    //

    LockScheduleList();
    I_InsertIntoWorkItemList( psi);
    UnlockScheduleList();

    //
    // 3. Indicate to scheduler threads that there is one new item on the list
    //

    DBG_REQUIRE( SetEvent( hSchedulerEvent ));

    return dwRet;
} // ScheduleWorkItem()



BOOL
RemoveWorkItem(
    DWORD  dwCookie
    )
/*++

Routine Description:

    Removes a scheduled work item

Arguments:

    dwCookie - The return value from a previous call to ScheduleWorkItem

Return Value:

    TRUE if the item was found, FALSE if the item was not found.

--*/
{
    SCHED_ITEM * psi;
    BOOL fWait = FALSE;

    //
    // 1. lock the list
    //

    LockScheduleList();

    //
    // 2. Find scheduler item on the list.
    //

    psi = I_FindSchedulerItem( dwCookie);

    if ( NULL != psi) {

        //
        // 3. based on the state of the item take necessary actions.
        //

        SCHED_ITEM_STATE st =
            sg_rgSchedNextState[SI_OP_DELETE][psi->_siState];
        psi->_siState = st;
        switch ( st) {
        case SI_IDLE: {
            // delete immediately
            RemoveEntryList( &psi->_ListEntry );
            psi->_ListEntry.Flink = NULL;
            delete psi;
            break;
        }

        case SI_TO_BE_DELETED: {

            DBGPRINTF(( DBG_CONTEXT,
                        "SchedItem(%08x) marked to be deleted\n",
                        psi));
            // item will be deleted later.

            if (psi->FInsideCallbackOnOtherThread()) {
                // need to wait till callback complete
                psi->AddEvent();
                fWait = TRUE;
            }
            break;
        }

        default:
            DBG_ASSERT( FALSE);
            break;
        } // switch()
    }

    // 4. Unlock the list
    UnlockScheduleList();

    // 5. Wait for callback event and release the item
    if (fWait)
        psi->WaitForEventAndRelease();

    // return TRUE if we found the item
    return ( NULL != psi);
} // RemoveWorkItem()





dllexp
DWORD
ScheduleAdjustTime(
    DWORD dwCookie,
    DWORD msecNewTime
    )
/*++
  This function finds the scheduler object for given cookie and changes
  the interval for next timeout of the item.

--*/
{
    SCHED_ITEM * psi;

    DBG_ASSERT( 0 != dwCookie);

    LockScheduleList();
    // 1. Find the work item for given cookie
    psi = I_FindSchedulerItem( dwCookie);

    if ( NULL != psi) {

        // 2. Remove the item from the list
        RemoveEntryList( &psi->_ListEntry );
        psi->_ListEntry.Flink = NULL;

        // 2. Change the timeout value

        psi->ChangeTimeInterval( msecNewTime);

        // 3. Recalc expiry time and reinsert into the list of work items.
        psi->CalcExpiresTime();
        I_InsertIntoWorkItemList( psi);
    }

    UnlockScheduleList();

    // 4. Indicate to scheduler threads that there is one new item on the list
    DBG_REQUIRE( SetEvent( hSchedulerEvent ));

    return ( (NULL != psi) ? NO_ERROR : ERROR_INVALID_PARAMETER);
} // ScheduleAdjustTime()



/************************************************************
 *  Internal functions of Scheduler
 ************************************************************/



VOID
I_InsertIntoWorkItemList( SCHED_ITEM * psi)
{
    SCHED_ITEM * psiList;
    LIST_ENTRY * pEntry;

    DBG_ASSERT( NULL != psi);

    DBG_ASSERT( (psi->_siState == SI_ACTIVE) ||
                (psi->_siState == SI_ACTIVE_PERIODIC) ||
                (psi->_siState == SI_CALLBACK_PERIODIC ) );

    // Assumed that the scheduler list is locked.

    //
    //  Insert the list in order based on expires time
    //

    for ( pEntry =  ScheduleListHead.Flink;
          pEntry != &ScheduleListHead;
          pEntry =  pEntry->Flink )
    {
        psiList = CONTAINING_RECORD( pEntry, SCHED_ITEM, _ListEntry );

        if ( psiList->_msecExpires > psi->_msecExpires )
        {
            break;
        }
    }

    //
    // Insert the item psi in front of the item pEntry
    //  This should work in whether the list is empty or this is the last item
    //  on the list
    //

    psi->_ListEntry.Flink = pEntry;
    psi->_ListEntry.Blink = pEntry->Blink;

    pEntry->Blink->Flink = &psi->_ListEntry;
    pEntry->Blink        = &psi->_ListEntry;

    return;
} // I_InsertIntoWorkItemList()


SCHED_ITEM *
I_FindSchedulerItem( DWORD dwCookie)
{
    PLIST_ENTRY  pEntry;
    SCHED_ITEM * psi = NULL;

    // Should be called with the scheduler list locked.

    for ( pEntry =  ScheduleListHead.Flink;
          pEntry != &ScheduleListHead;
          pEntry = pEntry->Flink )
    {
        psi = CONTAINING_RECORD( pEntry, SCHED_ITEM, _ListEntry );

        ATQ_ASSERT( psi->CheckSignature() );

        if ( dwCookie == psi->_dwSerialNumber ) {

            // found the match - return
            return ( psi);
        }
    } // for

    return ( NULL);
} // I_FindSchedulerItem()



DWORD
SchedulerThread(
    LPDWORD lpdwParam
    )
/*++

Routine Description:

    Initializes the scheduler/timer package

Arguments:

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)

--*/
{
    DWORD        cmsecWait = INFINITE;
    __int64      TickCount;
    SCHED_ITEM * psi, * psiExpired;
    LIST_ENTRY * pEntry;
    BOOL         fListLocked = FALSE;
    DWORD        dwWait = 0;

    while (!fSchedShutdown) {

        ATQ_ASSERT(!fListLocked); // the list must be unlocked here

        while ( TRUE ) {

            MSG msg;

            //
            // Need to do MsgWait instead of WaitForSingleObject
            // to process windows msgs.  We now have a window
            // because of COM.
            //

            dwWait = MsgWaitForMultipleObjects( 1,
                                             &hSchedulerEvent,
                                             FALSE,
                                             cmsecWait,
                                             QS_ALLINPUT );

            if (fSchedShutdown) {
                goto exit;
            }

            if ( (dwWait == WAIT_OBJECT_0) ||
                 (dwWait == WAIT_TIMEOUT) ) {
                break;
            }

            while ( PeekMessage( &msg,
                                 NULL,
                                 0,
                                 0,
                                 PM_REMOVE ))
            {
                DispatchMessage( &msg );
            }
        }

        switch (dwWait) {
        default:
            DBGPRINTF(( DBG_CONTEXT,
                        "[Scheduler] Error %d waiting on SchedulerEvent\n",
                        GetLastError() ));
            //  Fall through

        case WAIT_OBJECT_0:
            //  Means a new item has been scheduled, reset the timeout or
            //  we are shutting down

            LockScheduleList();
            fListLocked = TRUE;

            //  Get the timeout value for the first item in the list

            if (!IsListEmpty(&ScheduleListHead)) {
                psi = CONTAINING_RECORD( ScheduleListHead.Flink,
                                         SCHED_ITEM,
                                         _ListEntry );

                ATQ_ASSERT(psi->CheckSignature());

                //  Make sure the front item hasn't already expired

                TickCount = GetCurrentTimeInMilliseconds();

                if (TickCount > psi->_msecExpires) {
                    //  Run scheduled items
                    break;
                }

                // the delay is guaranteed NOT to be > 1<<32
                // as per parameter to SCHED_ITEM constructor

                cmsecWait = (DWORD)(psi->_msecExpires - TickCount);
            }
            else {
                cmsecWait = INFINITE;
            }

            UnlockScheduleList();
            fListLocked = FALSE;

            // Wait for something else (back to sleep)
            continue;

        case WAIT_TIMEOUT:
            //  Run scheduled items
            break;
        }

        //  Run scheduled items

        while (!fSchedShutdown) {
            //  Lock the list if needed

            if (!fListLocked) {
                LockScheduleList();
                fListLocked = TRUE;
            }

            //  No timeout by default (if no items found)

            cmsecWait = INFINITE;

            if (IsListEmpty(&ScheduleListHead))
                break;

            //  Find the first expired work item

            TickCount = GetCurrentTimeInMilliseconds();

            psiExpired = NULL;

            for ( pEntry  = ScheduleListHead.Flink;
                  pEntry != &ScheduleListHead;
                ) {
                psi = CONTAINING_RECORD(pEntry, SCHED_ITEM, _ListEntry);
                pEntry = pEntry->Flink;

                ATQ_ASSERT(psi->CheckSignature());

                if ( ((psi->_siState == SI_ACTIVE) ||
                      (psi->_siState == SI_ACTIVE_PERIODIC)) ) {

                    if (TickCount > psi->_msecExpires) {
                        //  Found Expired Item
                        psiExpired = psi;
                    }
                    else {
                        //  Since they are in sorted order once we hit one that's
                        //  not expired we don't need to look further
                        cmsecWait = (DWORD)(psi->_msecExpires - TickCount);
                    }
                    break;
                }
            }

            //  If no expired work items found, go back to sleep

            if (psiExpired == NULL) {
                break;
            }

            //  Take care of the found expired work item

            SCHED_ITEM_STATE st =
                sg_rgSchedNextState[SI_OP_CALLBACK][psiExpired->_siState];

            psiExpired->_siState = st;

            //  Take care of the NON-PERIODIC case

            if (st == SI_TO_BE_DELETED) { // non-periodic?

                //  Remove this item from the list
                RemoveEntryList( &psiExpired->_ListEntry );
                psiExpired->_ListEntry.Flink = NULL;

                //  Unlock List
                ATQ_ASSERT(fListLocked);
                UnlockScheduleList();
                fListLocked = FALSE;

                //  Call callback funcitons
                psiExpired->_pfnCallback(psiExpired->_pContext);

                //  Get rid of the item regardless of state
                delete psiExpired;
                //  Find next expired item
                continue;
            }

            //  Take care of the PERIODIC case

            DBG_ASSERT(st == SI_CALLBACK_PERIODIC);

            psiExpired->_dwCallbackThreadId = GetCurrentThreadId();

            //  Unlock the list while in the callback
            ATQ_ASSERT(fListLocked);
            UnlockScheduleList();
            fListLocked = FALSE;

            //  While in PERIODIC callback the list is kept unlocked
            //  leaving the object exposed

            psiExpired->_pfnCallback( psiExpired->_pContext );

            //  Relock the list
            ATQ_ASSERT(!fListLocked);
            LockScheduleList();
            fListLocked = TRUE;

            psiExpired->_dwCallbackThreadId = 0;

            //  While in the callback the state can change
            if (psiExpired->_siState == SI_TO_BE_DELETED) {
                //  User requested delete

                //  Remove this item from the list
                RemoveEntryList( &psiExpired->_ListEntry );
                psiExpired->_ListEntry.Flink = NULL;

                //  While in callback RemoveWorkItem() could have attached
                //  an event to notify itself when callback is done
                if (psiExpired->_hCallbackEvent) {
                    //  Signal the event after item is gone from the list
                    SetEvent(psiExpired->_hCallbackEvent);
                    //  RemoveWorkItem() will remove the item
                }
                else {
                    //  Get rid of the item
                    delete psiExpired;
                }
            }
            else {
                // no events attached
                DBG_ASSERT(psiExpired->_hCallbackEvent == NULL);

                // must still remain SI_CALLBACK_PERIODIC unless deleted
                DBG_ASSERT(psiExpired->_siState == SI_CALLBACK_PERIODIC);

                // NYI: For now remove from the list and reinsert it
                RemoveEntryList( &psiExpired->_ListEntry );
                psiExpired->_ListEntry.Flink = NULL;

                // recalc the expiry time and reinsert into the list
                psiExpired->_siState =
                    sg_rgSchedNextState[SI_OP_ADD_PERIODIC]
                                       [psiExpired->_siState];
                psiExpired->CalcExpiresTime();
                I_InsertIntoWorkItemList(psiExpired);
            }

            //  Start looking in the list from the beginning in case
            //  new items have been added or other threads removed
            //  them

        } // while

        if (fListLocked) {
            UnlockScheduleList();
            fListLocked = FALSE;
        }

    } // while

exit:
    InterlockedDecrement( (LONG *) &cSchedThreads );
    return 0;
} // SchedulerThread()



BOOL
SCHED_ITEM::Initialize( VOID)
{
    ALLOC_CACHE_CONFIGURATION  acConfig = { 1, 25, sizeof(SCHED_ITEM)};

    if ( NULL != sm_pachSchedItems) {

        // already initialized
        return ( TRUE);
    }

    sm_pachSchedItems = new ALLOC_CACHE_HANDLER( "SchedItems",
                                                 &acConfig);

    return ( NULL != sm_pachSchedItems);
} // SCHED_ITEM::Initialize()


VOID
SCHED_ITEM::Cleanup( VOID)
{
    if ( NULL != sm_pachSchedItems) {

        delete sm_pachSchedItems;
        sm_pachSchedItems = NULL;
    }

    return;
} // SCHED_ITEM::Cleanup()


VOID *
SCHED_ITEM::operator new( size_t s)
{
    DBG_ASSERT( s == sizeof( SCHED_ITEM));

    // allocate from allocation cache.
    DBG_ASSERT( NULL != sm_pachSchedItems);
    return (sm_pachSchedItems->Alloc());
} // SCHED_ITEM::operator new()

VOID
SCHED_ITEM::operator delete( void * psi)
{
    DBG_ASSERT( NULL != psi);

    // free to the allocation pool
    DBG_ASSERT( NULL != sm_pachSchedItems);
    DBG_REQUIRE( sm_pachSchedItems->Free(psi));

    return;
} // SCHED_ITEM::operator delete()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\atq\timeout.cxx ===
/*++

   Copyright    (c)    1995-1997    Microsoft Corporation

   Module  Name :
        timeout.cxx

   Abstract:
        This module contains code for timeout processing of ATQ contexts

   Author:

       Murali R. Krishnan    ( MuraliK )     16-July-1997

   Environment:
       Win32 - User Mode

   Project:
       Internet Server - Asynchronous Thread Queue Module

   Functions Exported:



   Revision History:

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

#include "isatq.hxx"


/************************************************************
 * Globals
 ************************************************************/

DWORD   g_dwTimeoutCookie = 0; // Scheduler Cookie for timeout processing

DWORD   g_AtqCurrentTick = 1;

DWORD g_dwTimeout = ATQ_TIMEOUT_INTERVAL;  // active timeout value

/************************************************************
 *    Functions
 ************************************************************/



BOOL
I_TimeOutContext(
    PATQ_CONT pAtqContext
    )
/*++

Routine Description:

    This function does the actual timeout for a particular context.
    Note: The Context list lock is held while processing this function

Arguments:

    Context - Pointer to the context to be timed out

Return value:

    TRUE, if the completion routine was called
    FALSE, otherwise

--*/
{

    DWORD timeout;

    //
    //  Call client after re-checking that this item
    //  really has timed out

    //
    // Fake timeout
    //

    if ( pAtqContext->TimeOut == ATQ_INFINITE ) {
        pAtqContext->NextTimeout = ATQ_INFINITE;
        return(FALSE);
    }

    //
    // Was our timeout long enough?
    //

    // NYI: Optimize: CanonTimeout should be called only once per IO submitted
    timeout = CanonTimeout( pAtqContext->BytesSent/g_cbMinKbSec);
    if ( timeout > pAtqContext->TimeOut ) {

        //
        // Reset the Timeout value based on the bytes to be sent
        // as well as update the time when this pAtqContext be timedout
        //

        pAtqContext->TimeOut = timeout;
        pAtqContext->NextTimeout = AtqGetCurrentTick( ) + timeout;
        return(FALSE);
    }

    //
    // If this is on blocked list, remove it.
    //

    if ( pAtqContext->IsBlocked()) {
        PBANDWIDTH_INFO pBandwidthInfo = pAtqContext->m_pBandwidthInfo;
        ATQ_ASSERT( pBandwidthInfo != NULL );
        ATQ_REQUIRE( pBandwidthInfo->RemoveFromBlockedList(pAtqContext));
    }

    //
    //  If we've already indicated this connection to the client,
    //  then we abort them by calling their IO completion routine
    //  and letting them cleanup.  Otherwise we close the socket
    //  which will generally cause an IO aborted completion that
    //  we will cleanup.  Note there is a window where we may
    //  close the socket out from under a client in their
    //  connection completion routine but that should be ok.
    //

    if ( pAtqContext->pfnCompletion &&
         pAtqContext->IsFlag( ACF_CONN_INDICATED)) {

        //
        //  TransmitFile socket state will be unconnected because
        //  we're expecting it to complete successfully.  Reset the
        //  state so the socket gets cleaned up properly
        //

        if ( pAtqContext->IsState( ACS_SOCK_UNCONNECTED) ) {
            pAtqContext->MoveState( ACS_SOCK_CONNECTED);
        }

        AcIncrement( CacAtqContextsTimedOut);

        pAtqContext->NextTimeout = ATQ_INFINITE;

        pAtqContext->IOCompletion( 0, ERROR_SEM_TIMEOUT, NULL);

        //
        //  We can't touch any items on the list after notifying
        //  the client as the client may have re-entered
        //  and freed some items from the list
        //

        return(TRUE);

    } else {

        HANDLE hIO;

        hIO = (HANDLE ) InterlockedExchangePointer(
                                        (PVOID *) &pAtqContext->hAsyncIO,
                                        NULL
                                        );
        DBG_ASSERT(!pAtqContext->fDatagramContext);
        IF_DEBUG( TIMEOUT) {
            ATQ_PRINTF(( DBG_CONTEXT,
                         "Timeout: closesocket(%d) Context=%08x\n",
                         hIO, pAtqContext));
        }
        closesocket( (SOCKET) hIO );
    }

    return(FALSE); // we can touch the items on current list.

} // I_TimeOutContext




VOID
AtqProcessTimeoutOfRequests(
    PATQ_CONTEXT_LISTHEAD ContextList
    )
/*++

Routine Description:

    Walks the list of Atq clients looking for any item that has timed out and
    notifies the client if it has.

    TimeOutScanID is used as a serial number to prevent evaluating the same
    context twice.  We start from the beginning of the list everytime we
    notify a client an Atq context has timed out.  We do this because the
    client timeout processing may remove any number of Items from the
    list (including the next couple of items in the list).

    This routine also checks to make sure outstanding AcceptEx sockets
    haven't been exhausted (if less then 25% available, adds some more).

--*/
{
    DWORD                  newLatest = ATQ_INFINITE;
    BOOL                   fRescan;

    //
    // See if the latest one is timed-out
    //

    if ( ContextList->LatestTimeout > AtqGetCurrentTick( ) ) {

        return;
    }

    // set the latest timeout in the context list,
    // to avoid races with IO being started.
    ContextList->LatestTimeout = ATQ_INFINITE;

    //
    //  Scan the timeout list looking for items that have timed out
    //  and adjust the timeout values
    //

    do {

        LIST_ENTRY *           pentry;
        LIST_ENTRY *           pentryNext;
        DWORD                  scanId = AtqGetCurrentTick( );

        ContextList->Lock( );

        fRescan = FALSE;

        for ( pentry  = ContextList->ActiveListHead.Flink;
              pentry != &ContextList->ActiveListHead;
              pentry  = pentryNext ) {

            PATQ_CONT              pContext;

            pentryNext = pentry->Flink;

            pContext = CONTAINING_RECORD(
                                pentry,
                                ATQ_CONTEXT,
                                m_leTimeout
                                );

            if ( pContext->Signature != ATQ_CONTEXT_SIGNATURE ) {
                ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );
                break;
            }

            //
            //  Ignore items we've already processed
            //

            if ( pContext->TimeOutScanID == scanId ) {
                continue;
            }

            pContext->TimeOutScanID = scanId;

            //
            // If there is an IO which has popped up now,
            //  we have to do nothing. This code was added to protect catapult!
            //
            pContext->SetFlag( ACF_IN_TIMEOUT);

            if ( !pContext->lSyncTimeout) {

                // no body is using this context. Check and synchronize
                // the timeout state.

                //
                //  The client specifies the IO doesn't timeout if
                //  INFINITE is in the TimeOut field of the ATQ context
                //  If we've timed out, then notify the client.
                //

                DWORD nextTimeout = pContext->NextTimeout;
                if ( nextTimeout > AtqGetCurrentTick() ) {


                    // pick up the latest "low" value for
                    // firing next timeout thread
                    if ( nextTimeout < newLatest ) {
                        newLatest = nextTimeout;
                    }
                } else if ( I_TimeOutContext(pContext) ) {

                    // we are done checking and processing timeout.
                    // reset the In Timeout flag
                    pContext->ResetFlag( ACF_IN_TIMEOUT);
                    fRescan = TRUE;
                    break;
                } else {

                    //
                    // It is possible that the timeout got reset
                    // Check for the latest "low" value
                    //
                    nextTimeout = pContext->NextTimeout;
                    if ( nextTimeout < newLatest ) {
                        newLatest = nextTimeout;
                    }
                }

            } else {
                AcIncrement( CacAtqProcWhenTimeout);
            }

            // we are done checkin and processing timeouts.
            // reset the In Timeout flag
            pContext->ResetFlag( ACF_IN_TIMEOUT);

        } // scan list

        // let other system threads also run happily for a while
        ContextList->Unlock( );

    } while (fRescan);

    if ( newLatest != ATQ_INFINITE) {
        // We picked up the latest timeout. store it.
        ContextList->LatestTimeout = newLatest;
    }

    return;

} // AtqProcessTimeoutOfRequests




//
// ACCEPT_EX_TIMEOUT_STATS collects statistics for the
//   timeout processing in the Pending AcceptEx List//
//
struct ACCEPT_EX_TIMEOUT_STATS {

    DWORD  m_nScanned;
    DWORD  m_nTimedOut;
    DWORD  m_nSkipped;
    DWORD  m_nConnected;
    DWORD  m_nNotConnected;
};


BOOL
I_TimeOutPendingAcceptExContext(
    PATQ_CONT pAtqContext
    )
/*++

Routine Description:

    This function does the actual timeout for a pending AcceptEx context.
    Note: The Context list lock is held while processing this function

Arguments:

    pAtqContext - Pointer to the context to be timed out

Return value:

    TRUE, if a tmieout operation was conducted.
    FALSE, otherwise

--*/
{
    DBG_ASSERT( pAtqContext != NULL);

    //
    // in the shutdown case it is possible that someone closed this socket already
    // so don't worry about it.
    //
    if ( pAtqContext->hAsyncIO == NULL ) {
        return TRUE;
    }

    //
    // Validate our assumptions about this Pending AcceptEx Context
    // there is an endpoint => AcceptEx context
    DBG_ASSERT( pAtqContext->pEndpoint != NULL);
    DBG_ASSERT( pAtqContext->IsState( ACS_SOCK_LISTENING));
    DBG_ASSERT( !pAtqContext->IsFlag( ACF_CONN_INDICATED));
    DBG_ASSERT( pAtqContext->TimeOut != ATQ_INFINITE);


    //
    // We will obtain the socket handle stored inside the AcceptEx Context
    //    and free up the context.
    // Warning:
    //   The AcceptEx socket did not have a connection when this function
    //   was called. However now between the time when the state was checked
    //   and the time this timeout operation completes, it is possible that
    //   a new connection is bound to this AcceptEx context => we can get IO completion.
    //   I need to handle this case
    //

    HANDLE hIO;

    hIO = (HANDLE ) InterlockedExchangePointer(
                            (PVOID *) &pAtqContext->hAsyncIO,
                            NULL
                            );
    DBG_ASSERT(!pAtqContext->fDatagramContext);
    IF_DEBUG( TIMEOUT) {
        ATQ_PRINTF(( DBG_CONTEXT,
                     "TimeoutPendingAcceptExContext(%08x): closesocket(%d)\n",
                      pAtqContext, hIO));
    }

    closesocket( (SOCKET) hIO );

    return ( TRUE);
} // I_TimeOutPendingAcceptExContext()


BOOL
I_IsTimeoutForAcceptExContext(
    IN OUT PATQ_CONT                  pAtqContext,
    IN OUT ACCEPT_EX_TIMEOUT_STATS  * pAetStats
    )
/*++

Routine Description:

    This function checks to see if timeout operation has to be performed
    for a given AtqContext. It bases the decision on the a variety of
    details maintained in Atq Context and the Endpoint.
    Note: The Context list lock is held while processing this function

Arguments:

    pAtqContext - Pointer to the context to be timed out
    pAetStats   - pointer to AcceptEx Timeout Statistics structure

Return value:

    TRUE, if a tmieout operation has to be conducted.
    FALSE, when no timeout is required.

--*/
{
    DBG_ASSERT( pAtqContext);
    DBG_ASSERT( pAetStats);

    PATQ_ENDPOINT  pEndpoint;
    pEndpoint = pAtqContext->pEndpoint;

    if ( pEndpoint != NULL) {

        //
        // We will use getsockopt() to query the connection status
        //  for the socket inside the Atq context.
        // If Socket is not connected => leave it in the pool
        // If Socket is connected and waiting for receive operation =>
        //        do timeout processing
        //
        // The goal is to maintain a pool of sockets in listening state
        //  so that any new connection will be picked up quickly.
        //
        // getsockopt() is a very costly function.
        // We check to see if we have enough sockets available
        //  for an endpoint. If they are, then we bypass calling getsockopt
        // "enough" is defined as # of available sockets is at least
        //   25% of the total # of accept ex sockets outstanding.
        // Optimize calling getsockopt() based on
        //   current count in pEndpoint->nAvailDuringTimeOut
        //

        if ( pEndpoint->nAvailDuringTimeOut >
             ( pEndpoint->nAcceptExOutstanding >> 2)
             ) {

            // Already enough Contexts are available.
            //  Do nothing
            pAetStats->m_nSkipped++;

            return (FALSE); // Do not timeout
        }

        DWORD dwConnect;
        int   cbOptLen = sizeof( dwConnect );

        //
        // Query the socket layer if the current socket has a valid connection
        // An AcceptEx socket can be connected and waiting for new request to
        //   be read. If we are in such state we should not blow away context.
        //
        if ( getsockopt((SOCKET) pAtqContext->hAsyncIO,
                        SOL_SOCKET,
                        SO_CONNECT_TIME,
                        (char *) &dwConnect,
                        &cbOptLen ) != SOCKET_ERROR
             ) {

            //
            //  A return value of 0xFFFFFFFF indicates that the given
            //   AcceptEx socket is not connected yet.
            //  Otherwise the socket is connected and is probably wating
            //   for request to be read or maybe a completion is already
            //   on its way.
            //

            if ( dwConnect == (DWORD) 0xFFFFFFFF ) {

                //
                //  Ignore the "Listen" socket context
                //

                pAetStats->m_nNotConnected++;

                DBG_ASSERT( NULL != pEndpoint);
                pEndpoint->nAvailDuringTimeOut++;

                // Update timeout values to give a breather interval
                pAtqContext->NextTimeout =
                    AtqGetCurrentTick() + pAtqContext->TimeOut;

                return ( FALSE);  // Do not timeout
            }
            else if ( !pAtqContext->IsFlag(ACF_WINSOCK_CONNECTED) ) {

                //
                // Mark that this context has connection indicated.
                // If this context waits around in connected state for
                //  long-time we need to blow the context away.
                //

                pAetStats->m_nConnected++;

                // Update timeout values to give a breather interval
                pAtqContext->NextTimeout =
                    AtqGetCurrentTick() + pAtqContext->TimeOut;

                pAtqContext->SetFlag(ACF_WINSOCK_CONNECTED);

                return (FALSE); // do not timeout now
            }
        }
    } // if Endpoint exists

    return (TRUE); // yes timeout this context
} // I_IsTimeoutForAcceptExContext()


VOID
I_AtqProcessPendingListens(
    IN PATQ_CONTEXT_LISTHEAD pContextList
    )
/*++

Routine Description:

    Walks the list of Pending accept ex and makes sure none has timed out.
    Also checks to see if we need to allocate more AcceptEx sockets.

  Arguments:
    pContextList - pointer to ATQ_CONTEXT_LISTHEAD object

  Returns:
    None

--*/
{
    BOOL                    fRescan;

    ACCEPT_EX_TIMEOUT_STATS AetStats;

    //
    // Initialize Statistics block
    //
    AetStats.m_nScanned         = 0;
    AetStats.m_nTimedOut        = 0;
    AetStats.m_nSkipped         = 0;
    AetStats.m_nConnected       = 0;
    AetStats.m_nNotConnected    = 0;


    //
    //  Look through the listening sockets to make sure the AcceptEx sockets
    //  haven't been exhausted
    //

    do {

        LIST_ENTRY *           pentry;
        LIST_ENTRY *           pentryNext;
        DWORD                  scanId = AtqGetCurrentTick( );

        fRescan = FALSE;

        pContextList->Lock();

        for ( pentry  = pContextList->PendingAcceptExListHead.Flink;
              pentry != &pContextList->PendingAcceptExListHead;
              pentry  = pentryNext ) {

            PATQ_CONT      pContext;

            pentryNext = pentry->Flink;
            pContext = CONTAINING_RECORD(
                                pentry,
                                ATQ_CONTEXT,
                                m_leTimeout
                                );

            if ( pContext->Signature != ATQ_CONTEXT_SIGNATURE ) {
                DBG_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );
                break;
            }

            //
            //  Ignore items we've already processed
            //

            if ( pContext->TimeOutScanID == scanId ) {
                continue;
            }

            AetStats.m_nScanned++;
            pContext->TimeOutScanID = scanId;

            if ( pContext->fDatagramContext ) {
                continue;
            }

            //
            // If the context has Timeout value smaller than the one in our global tick
            //  then examine if this context can be timedout
            //

            DBG_CODE( if ( pContext->IsAcceptExRootContext())
                        {
                            DBG_ASSERT( pContext->TimeOut == ATQ_INFINITE);
                            DBG_ASSERT( pContext->NextTimeout == ATQ_INFINITE);
                        }
                        );

            if ( pContext->NextTimeout <= AtqGetCurrentTick()) {

                //
                // Protect against the race with the normal IO completion
                //
                pContext->SetFlag( ACF_IN_TIMEOUT);

                if ( !pContext->lSyncTimeout ) {

                    if ( !I_IsTimeoutForAcceptExContext( pContext, &AetStats)) {

                        pContext->ResetFlag( ACF_IN_TIMEOUT);
                        continue;
                    }

                    if ( I_TimeOutPendingAcceptExContext(pContext)) {
                        AetStats.m_nTimedOut++;
                        fRescan = TRUE;
                        pContext->ResetFlag(ACF_IN_TIMEOUT);
                        break;
                    }
                } // if (!pContext->lSyncTimeout)

                pContext->ResetFlag( ACF_IN_TIMEOUT);
            } // if the context's timeout value <= CurrentTick
            else {

                //
                // Timeout value has not been reached. Skip this context
                //

                AetStats.m_nSkipped++;
           }
        } // scan list

        pContextList->Unlock();

    } while (fRescan);

    IF_DEBUG( TIMEOUT) {
       DBGPRINTF(( DBG_CONTEXT,
                   "TimeoutPendingListens( CtxtList[%d], AtqTick=%d)\n"
                   " Contexts Scanned=%d, Skipped=%d, TimedOut=%d,"
                   " Connected=%d, NotConnected=%d\n",
                   pContextList - AtqActiveContextList, AtqGetCurrentTick(),
                   AetStats.m_nScanned, AetStats.m_nSkipped,
                   AetStats.m_nTimedOut, AetStats.m_nConnected,
                   AetStats.m_nNotConnected
                ));
    }

# ifdef IIS_AUX_COUNTERS
    g_AuxCounters[CacAtqPendingAcceptExScans] += AetStats.m_nScanned;
# endif // IIS_AUX_COUNTERS

    return;

} // I_AtqProcessPendingListens()




VOID
I_AtqCheckEndpoints(
            VOID
            )
/*++
  Description:
    This function checks all the listen info objects and adds appropriate
     number of accept ex sockets as necessary.

  Arguments:
    None

  Returns:
    None
--*/
{
    LIST_ENTRY *  pEntry;
    PATQ_ENDPOINT pEndpoint;

    AcquireLock( &AtqEndpointLock);

    for ( pEntry  = AtqEndpointList.Flink;
          pEntry != &AtqEndpointList;
          pEntry  = pEntry->Flink ) {

        pEndpoint = CONTAINING_RECORD(
                                    pEntry,
                                    ATQ_ENDPOINT,
                                    ListEntry
                                    );

        DBG_ASSERT( pEndpoint->Signature == ATQ_ENDPOINT_SIGNATURE );

        DBG_ASSERT( pEndpoint->nSocketsAvail >= 0);

        //
        // Check to make sure outstanding AcceptEx sockets
        // haven't been exhausted (if less then 25% available, adds some more).
        //

        if ( !pEndpoint->fDatagram ) {

            if ( ((DWORD ) pEndpoint->nSocketsAvail) <
                 (pEndpoint->nAcceptExOutstanding >> 2) ) {

                IF_DEBUG( TIMEOUT ) {
                    DBGPRINTF(( DBG_CONTEXT,
                                "[Timeout] Adding AcceptEx Contexts for EP=%08x; nAvail = %d;\n",
                                pEndpoint, pEndpoint->nSocketsAvail));
                }

                (VOID ) I_AtqPrepareAcceptExSockets(pEndpoint,
                                                    pEndpoint->nAcceptExOutstanding
                                                    );
            }
        }

        //
        // set to zero, so recount will be done during next timeout loop
        //

        pEndpoint->nAvailDuringTimeOut = 0;

    }

    ReleaseLock( &AtqEndpointLock);

    return;
} // I_AtqCheckEndpoints



VOID
I_AtqTimeOutWorker(VOID)
/*++
  Description:
    This function handles timeout processing using the simple
    clock algorithm, wherein partial set of lists are scanned
    during each timeout processing call.

  Arguments:
    None


  Returns:
    None
--*/
{
    DWORD start;
    PATQ_CONTEXT_LISTHEAD pContextList;

    IF_DEBUG(TIMEOUT) {
        DBGPRINTF((DBG_CONTEXT, "TimeoutWorker: entered\n"));
    }

    start = (AtqGetCurrentTick() & 0x1);

    for ( pContextList = AtqActiveContextList + start;
          pContextList < (AtqActiveContextList + g_dwNumContextLists) ;
          pContextList += 2 ) {

        IF_DEBUG(TIMEOUT) {
            DBGPRINTF((DBG_CONTEXT,
                       "TimeoutWorker: Processing list[%d] = %08x\n",
                       (pContextList - AtqActiveContextList),
                       pContextList));
        }

        AtqProcessTimeoutOfRequests( pContextList );
        I_AtqProcessPendingListens( pContextList );
    } // for

    if ( start != 0 ) {
        I_AtqCheckEndpoints( );
    }

    return;

} // I_AtqTimeOutWorker()




VOID
I_AtqTimeoutCompletion(
    IN PVOID Context
    )
/*++

Routine Description:

    Callback routine for the scheduled version of the timeout thread.

    The callback assumes timeouts are rounded to ATQ_TIMEOUT_INTERVAL

    In addition to timing out requests when necessary, the timeout thread
     also performs the job of bandwidth calculation and tuning the bandwidth
     throttle operation (which works on feedback mechanism).
    At every sampling interval the scheduled callback comes in and it updates
     the bandwidth.

Arguments:

    Context - Context returned by the scheduler thread.

Return Value:

    none.

--*/
{
    DWORD Timeout = ATQ_TIMEOUT_INTERVAL;
    BOOL  fDoContextTimeout = TRUE;

    if ( g_fShutdown ) {

        ATQ_PRINTF(( DBG_CONTEXT,
            "Detected a shutdown while entering timeout callback\n"));
        return;
    }

    InterlockedIncrement( (PLONG)&g_AtqCurrentTick );

    //
    //  Perform necessary steps to handle Bandwidth throttling.
    //

    ATQ_ASSERT( BANDWIDTH_INFO::sm_cSamplesForTimeout >= 1);

    IF_DEBUG(TIMEOUT) {
        DBGPRINTF((DBG_CONTEXT,
                 "Timeout: BANDWIDTH_INFO::cSamplesForTimeout=%d\n",
                 BANDWIDTH_INFO::sm_cSamplesForTimeout ));
    }

    if ( BANDWIDTH_INFO::GlobalActive() ) {

        --(BANDWIDTH_INFO::sm_cSamplesForTimeout);

        // Perform a sampling to update measured bandwidth +
        //  apply feedback policy

        BANDWIDTH_INFO::UpdateAllBandwidths();

        Timeout = ATQ_SAMPLE_INTERVAL_IN_SECS;
        if ( BANDWIDTH_INFO::sm_cSamplesForTimeout != 0) {

            // We have not reached timeout yet. So skip context timeouts

            fDoContextTimeout = FALSE;
        } else {

            // We had reached the timeout interval for requests.
            // Examine and release requests.
            ATQ_ASSERT( BANDWIDTH_INFO::sm_cSamplesForTimeout == 0);

            // reset the count of samples before proceeding.
            BANDWIDTH_INFO::sm_cSamplesForTimeout = NUM_SAMPLES_PER_TIMEOUT_INTERVAL;
        }
    } else {
        BANDWIDTH_INFO::sm_cSamplesForTimeout = 1;
    }

    //
    // We are at a Timeout Interval. Examine and timeout requests.
    //

    if ( fDoContextTimeout ) {
        I_AtqTimeOutWorker();
    }

    if ( Timeout != g_dwTimeout) {

        // the scheduled interval is different from this current interval
        // Inidicate the changed timeout value to the scheduler

        ScheduleAdjustTime( g_dwTimeoutCookie, TimeToWait(Timeout));
        g_dwTimeout = Timeout;
    }

    return;
} // I_AtqTimeoutCompletion




BOOL
I_AtqStartTimeoutProcessing(
    IN PVOID Context
    )
/*++

Routine Description:

    Starts the timeout processing. It always uses the scheduler to schedule
    a timeout operation.

    Note: The scheduler should be initialized before getting to this function.

Arguments:

    Context - Context passed to the thread creation or scheduler thread.

Return Value:

    TRUE, if ok
    FALSE, otherwise

--*/
{
    ATQ_ASSERT( ATQ_SAMPLE_INTERVAL_IN_SECS < ATQ_TIMEOUT_INTERVAL );

    if ( BANDWIDTH_INFO::GlobalEnabled() ) {
        g_dwTimeout = ATQ_SAMPLE_INTERVAL_IN_SECS;
        BANDWIDTH_INFO::sm_cSamplesForTimeout =
            NUM_SAMPLES_PER_TIMEOUT_INTERVAL;
    } else {
        g_dwTimeout = ATQ_TIMEOUT_INTERVAL;
        BANDWIDTH_INFO::sm_cSamplesForTimeout = 1;
    }

    g_dwTimeoutCookie =
        ScheduleWorkItem(
                         (PFN_SCHED_CALLBACK)I_AtqTimeoutCompletion,
                         Context,
                         TimeToWait(g_dwTimeout)
                         , TRUE  // ask for periodic timeout
                         );

    if ( g_dwTimeoutCookie == 0 ) {

        ATQ_PRINTF(( DBG_CONTEXT,
                     "Error %d scheduling timeout\n",GetLastError()));
        return(FALSE);
    }

    return(TRUE);

} // I_AtqStartTimeoutProcessing()



BOOL
I_AtqStopTimeoutProcessing(
    VOID
    )
/*++

Routine Description:

    Stops the timeout processing. It terminates the scheduled workitem and
    cleans up any state.

    Note: The scheduler should be terminated only after this call

Arguments:

    Context - Context passed to the thread creation or scheduler thread.

Return Value:

    TRUE, if ok
    FALSE, otherwise

--*/
{

    if ( 0 != g_dwTimeoutCookie) {
        DBG_REQUIRE( RemoveWorkItem( g_dwTimeoutCookie ));
        g_dwTimeoutCookie = 0;
    }

    return ( TRUE);

} // I_AtqStopTimeoutProcessing()


/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\atq\spud.cxx ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

      spud.cxx

   Abstract:
      This module implements the user mode entry points for SPUD.SYS.
      SPUD = Special Purpose Utility Driver.

   Author:

       John Ballard ( jballard )     22-Oct-1996

   Environment:

       User Mode -- Win32

   Project:

       Internet Services Common DLL

   Functions Exported:

       BOOL  AtqTransmitFileAndRecv();
       BOOL  AtqSendAndRecv();
       BOOL  AtqBatchRequest();

--*/


#include "isatq.hxx"
//#include <tdi.h>
#include <afd.h>
#include <spud.h>
#include "uspud.h"

#if 0
VOID
EnableLoadDriverPrivilege(
    VOID
    );

#define SPUD_REG_PATH   \
    L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Spud"

BOOL
I_AtqSpudInitialize(
            IN HANDLE hPort
            )
{
    NTSTATUS    status;
    UNICODE_STRING  DriverName;
    DWORD   Version = SPUD_VERSION;

    if ( !g_fUseDriver ) {
        return(FALSE);
    }

    EnableLoadDriverPrivilege();

    g_pfnRtlInitUnicodeString( &DriverName, SPUD_REG_PATH );
    status = g_pfnNtLoadDriver( &DriverName );
    if ( ( status != STATUS_SUCCESS ) &&
         ( status != STATUS_IMAGE_ALREADY_LOADED ) ) {

        ATQ_PRINTF(( DBG_CONTEXT,
                     "NtLoadDriver failed!!! status == %08lx\n",
                     status
                     ));
        goto disable_driver;
    }

    status = SPUDInitialize(Version, hPort);
    if ( status != STATUS_SUCCESS ) {

        if ( status == STATUS_INVALID_DEVICE_REQUEST ) {
            SPUDTerminate();
            if ( SPUDInitialize(Version, hPort) == STATUS_SUCCESS ) {
                return TRUE;
            }
        }

        ATQ_PRINTF(( DBG_CONTEXT,
                     "SPUDInitialize failed!!! status == %08lx\n",
                     status
                     ));
        goto disable_driver;
    }

    return TRUE;

disable_driver:

    g_fUseDriver = FALSE;

    ATQ_PRINTF((DBG_CONTEXT, "SPUDInitialize: Disabling driver\n"));
    return(FALSE);
} // I_AtqSpudInitialize


BOOL
I_AtqSpudTerminate()
{
    NTSTATUS    status;

    status = SPUDTerminate();
    if ( status != STATUS_SUCCESS ) {

        IF_DEBUG(ERROR) {
            ATQ_PRINTF(( DBG_CONTEXT,
                     "SPUDTerminate failed!!! status == %08lx\n",
                     status
                     ));
        }
        return FALSE;
    }

    return TRUE;
}

BOOL
I_AtqSpudCheckStatus(
    IN PATQ_CONT                patqContext             // pointer to ATQ context
    )
{
        ULONG status;

        status = SPUDCheckStatus( &patqContext->spudContext );

        if ( status != STATUS_SUCCESS ) {
                return FALSE;
        }

        return TRUE;
}

BOOL
I_AtqTransmitFileAndRecv(
    IN PATQ_CONTEXT             patqContext,            // pointer to ATQ context
    IN HANDLE                   hFile,                  // handle of file to read
    IN DWORD                    dwBytesInFile,          // Bytes to transmit
    IN LPTRANSMIT_FILE_BUFFERS  lpTransmitBuffers,      // transmit buffer structure
    IN DWORD                    dwTFFlags,              // TF Flags
    IN LPWSABUF                 pwsaBuffers,            // Buffers for recv
    IN DWORD                    dwBufferCount
    )
/*++
Routine Description:

    Calls SPUDTransmitFileAndRecv().  Cannot be blocked by bandwidth throttler

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)
--*/
{
        ULONG   status;
        AFD_TRANSMIT_FILE_INFO transmitInfo;
        AFD_RECV_INFO          recvInfo;
        PATQ_CONT              patqCont = (PATQ_CONT)patqContext;

        IF_DEBUG(API_ENTRY) {
            ATQ_PRINTF(( DBG_CONTEXT,
                     "I_AtqTransmitFileAndRecv(%08lx) called.\n", patqContext));
        }

        transmitInfo.WriteLength.QuadPart = dwBytesInFile;
        transmitInfo.SendPacketLength = 0;
        transmitInfo.FileHandle = hFile;
        transmitInfo.Flags = dwTFFlags;
        if ( lpTransmitBuffers != NULL ) {
            transmitInfo.Head = lpTransmitBuffers->Head;
            transmitInfo.HeadLength = lpTransmitBuffers->HeadLength;
            transmitInfo.Tail = lpTransmitBuffers->Tail;
            transmitInfo.TailLength = lpTransmitBuffers->TailLength;
        } else {
            transmitInfo.Head = NULL;
            transmitInfo.HeadLength = 0;
            transmitInfo.Tail = NULL;
            transmitInfo.TailLength = 0;
        }

        transmitInfo.Offset.LowPart = patqContext->Overlapped.Offset;
        transmitInfo.Offset.HighPart = 0;

        recvInfo.BufferArray = pwsaBuffers;
        recvInfo.BufferCount = dwBufferCount;
        recvInfo.AfdFlags = AFD_OVERLAPPED;
        recvInfo.TdiFlags = TDI_RECEIVE_NORMAL;
        patqCont->ResetFlag( ACF_RECV_CALLED);

        //
        // Set this flag here to avoid a race with completion handling code
        // Reset if SPUDTransmitFileAndRecv fails
        //
        patqCont->SetFlag( ACF_RECV_ISSUED);

        status = SPUDTransmitFileAndRecv( patqCont->hAsyncIO,
                                         &transmitInfo,
                                         &recvInfo,
                                         &patqCont->spudContext
                                         );

#if CC_REF_TRACKING
            //
            // ATQ notification trace
            //
            // Notify client context of all non-oplock notification.
            // This is for debugging purpose only.
            //
            // Code 0xfbfbfbfb indicates a SPUD TransmitFileAndRecv request
            //

            patqCont->NotifyIOCompletion( 0, status, 0xfbfbfbfb );
#endif

        if ( status != STATUS_SUCCESS &&
             status != STATUS_PENDING ) {

            ATQ_PRINTF(( DBG_CONTEXT,
                         "SPUDTransmitFileAndRecv failed!!! status == %08lx\n",
                         status
                         ));
            SetLastError(g_pfnRtlNtStatusToDosError(status));
            patqCont->MoveState( ACS_SOCK_CONNECTED);
            patqCont->ResetFlag( ACF_RECV_ISSUED);
            return FALSE;
        }

        return TRUE;
}

BOOL
AtqTransmitFileAndRecv(
    IN PATQ_CONTEXT             patqContext,            // pointer to ATQ context
    IN HANDLE                   hFile,                  // handle of file to read
    IN DWORD                    dwBytesInFile,          // Bytes to transmit
    IN LPTRANSMIT_FILE_BUFFERS  lpTransmitBuffers,      // transmit buffer structure
    IN DWORD                    dwTFFlags,              // TF Flags
    IN LPWSABUF                 pwsaBuffers,            // Buffers for recv
    IN DWORD                    dwBufferCount
    )
{
    BOOL fRes;
    PATQ_CONT pContext = (PATQ_CONT) patqContext;
    PBANDWIDTH_INFO pBandwidthInfo = pContext->m_pBandwidthInfo;

    ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );
    ATQ_ASSERT( pContext->arInfo.atqOp == AtqIoNone);
    ATQ_ASSERT( pBandwidthInfo != NULL );
    ATQ_ASSERT( pBandwidthInfo->QuerySignature() == ATQ_BW_INFO_SIGNATURE );

    if ( !g_fUseDriver || pContext->IsFlag( ACF_RECV_ISSUED) ) {
        BOOL            fRes;

        IF_DEBUG(API_ENTRY) {
            ATQ_PRINTF(( DBG_CONTEXT,
                "AtqTransmitFileAndRecv(%08lx) g_fUseDriver == FALSE\n Calling AtqTransmitFile.\n", patqContext));
        }

        return AtqTransmitFile( patqContext,
                                hFile,
                                dwBytesInFile,
                                lpTransmitBuffers,
                                dwTFFlags );
    }

    I_SetNextTimeout(pContext);

    pContext->BytesSent = dwBytesInFile;

    DBG_ASSERT( dwBufferCount >= 1);
    pContext->BytesSent += pwsaBuffers->len;
    if ( dwBufferCount > 1) {
        LPWSABUF pWsaBuf;
        for ( pWsaBuf = pwsaBuffers + 1;
              pWsaBuf <= (pwsaBuffers + dwBufferCount);
              pWsaBuf++) {
            pContext->BytesSent += pWsaBuf->len;
        }
    }

    if ( dwTFFlags == 0 ) {

        //
        // If no flags are set, then we can attempt to use the special
        // write-behind flag.  This flag can cause the TransmitFile to
        // complete immediately, before the send actually completes.
        // This can be a significant performance improvement inside the
        // system.
        //

        dwTFFlags = TF_WRITE_BEHIND;

    }

    InterlockedIncrement( &pContext->m_nIO);

    switch ( pBandwidthInfo->QueryStatus( AtqIoXmitFileRecv ) )
    {
    case StatusAllowOperation:

        pBandwidthInfo->IncTotalAllowedRequests();

        fRes = I_AtqTransmitFileAndRecv( patqContext,
                                         hFile,
                                         dwBytesInFile,
                                         lpTransmitBuffers,
                                         dwTFFlags,
                                         pwsaBuffers,
                                         dwBufferCount ) ||
                (GetLastError() == ERROR_IO_PENDING);

        if (!fRes) { InterlockedDecrement( &pContext->m_nIO); };

        break;

    case StatusBlockOperation:

        // store data for restarting the operation.
        pContext->arInfo.atqOp        = AtqIoXmitFileRecv;
        pContext->arInfo.lpOverlapped = &pContext->Overlapped;

        pContext->arInfo.uop.opXmitRecv.hFile = hFile;
        pContext->arInfo.uop.opXmitRecv.dwBytesInFile = dwBytesInFile;
        pContext->arInfo.uop.opXmitRecv.lpXmitBuffers = lpTransmitBuffers;
        pContext->arInfo.uop.opXmitRecv.dwTFFlags     = dwTFFlags;
        pContext->arInfo.uop.opXmitRecv.dwBufferCount = dwBufferCount;

        if ( dwBufferCount == 1) {
            pContext->arInfo.uop.opXmitRecv.buf1.len = pwsaBuffers->len;
            pContext->arInfo.uop.opXmitRecv.buf1.buf = pwsaBuffers->buf;
            pContext->arInfo.uop.opXmitRecv.pBufAll  = NULL;
        } else {

            DBG_ASSERT( dwBufferCount > 1);

            WSABUF * pBuf = (WSABUF *)
            ::LocalAlloc( LPTR, dwBufferCount * sizeof (WSABUF));
            if ( NULL != pBuf) {
                pContext->arInfo.uop.opXmitRecv.pBufAll = pBuf;
                CopyMemory( pBuf, pwsaBuffers,
                            dwBufferCount * sizeof(WSABUF));
            } else {
                InterlockedDecrement( &pContext->m_nIO);
                fRes = FALSE;
                break;
            }
        }

        // Put this request in queue of blocked requests.
        fRes = pBandwidthInfo->BlockRequest( pContext);
        if ( fRes )
        {
            pBandwidthInfo->IncTotalBlockedRequests();
            break;
        }
        // fall through

    case StatusRejectOperation:
        InterlockedDecrement( &pContext->m_nIO);
        pBandwidthInfo->IncTotalRejectedRequests();
        SetLastError( ERROR_NETWORK_BUSY);
        fRes = FALSE;
        break;

    default:
        ATQ_ASSERT( FALSE);
        InterlockedDecrement( &pContext->m_nIO);
        SetLastError( ERROR_INVALID_PARAMETER);
        fRes = FALSE;
        break;

    } // switch()

    return fRes;
} // AtqTransmitFileAndRecv()

BOOL
I_AtqSendAndRecv(
    IN PATQ_CONTEXT             patqContext,            // pointer to ATQ context
    IN LPWSABUF                 pwsaSendBuffers,        // buffers for send
    IN DWORD                    dwSendBufferCount,      // count of buffers for send
    IN LPWSABUF                 pwsaRecvBuffers,        // Buffers for recv
    IN DWORD                    dwRecvBufferCount       // count of buffers for recv
    )
/*++
Routine Description:

    Calls SPUDSendAndRecv().  Cannot be blocked by bandwidth throttler.

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)
--*/
{
        ULONG   status;
        AFD_SEND_INFO          sendInfo;
        AFD_RECV_INFO          recvInfo;
        PATQ_CONT              patqCont = (PATQ_CONT)patqContext;

        IF_DEBUG(API_ENTRY) {
            ATQ_PRINTF(( DBG_CONTEXT,
                 "I_AtqSendAndRecv(%08lx) called.\n", patqContext));
        }

        sendInfo.BufferArray = pwsaSendBuffers;
        sendInfo.BufferCount = dwSendBufferCount;
        sendInfo.AfdFlags = AFD_OVERLAPPED;
        sendInfo.TdiFlags = 0;

        recvInfo.BufferArray = pwsaRecvBuffers;
        recvInfo.BufferCount = dwRecvBufferCount;
        recvInfo.AfdFlags = AFD_OVERLAPPED;
        recvInfo.TdiFlags = TDI_RECEIVE_NORMAL;
        patqCont->ResetFlag( ACF_RECV_CALLED);

        //
        // Set this flag before SPUD call to avoid a race with completion
        // Reset if SPUDSendAndRecv fails
        //
        patqCont->SetFlag( ACF_RECV_ISSUED);

        status = SPUDSendAndRecv( patqCont->hAsyncIO,
                                 &sendInfo,
                                 &recvInfo,
                                 &patqCont->spudContext
                                 );

        if ( status != STATUS_SUCCESS &&
             status != STATUS_PENDING ) {

            ATQ_PRINTF(( DBG_CONTEXT,
                     "SPUDSendAndRecv failed!!! status == %08lx\n",
                     status
                     ));
             SetLastError(g_pfnRtlNtStatusToDosError(status));
             patqCont->ResetFlag( ACF_RECV_ISSUED);
             return FALSE;
        }

        return TRUE;
}

BOOL
AtqSendAndRecv(
    IN PATQ_CONTEXT             patqContext,            // pointer to ATQ context
    IN LPWSABUF                 pwsaSendBuffers,        // buffers for send
    IN DWORD                    dwSendBufferCount,      // count of buffers for send
    IN LPWSABUF                 pwsaRecvBuffers,        // Buffers for recv
    IN DWORD                    dwRecvBufferCount       // count of buffers for recv
    )
{
    BOOL fRes;
    PATQ_CONT pContext = (PATQ_CONT) patqContext;
    PBANDWIDTH_INFO pBandwidthInfo = pContext->m_pBandwidthInfo;

    ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );
    ATQ_ASSERT( pContext->arInfo.atqOp == AtqIoNone);
    ATQ_ASSERT( pBandwidthInfo != NULL );
    ATQ_ASSERT( pBandwidthInfo->QuerySignature() == ATQ_BW_INFO_SIGNATURE );

    IF_DEBUG(API_ENTRY) {
        ATQ_PRINTF(( DBG_CONTEXT,
            "AtqSendAndRecv(%08lx) called.\n", patqContext));
    }

    if ( !g_fUseDriver || pContext->IsFlag( ACF_RECV_ISSUED) ) {

        BOOL            fRes;
        DWORD           cbWritten;

        IF_DEBUG(API_ENTRY) {
            ATQ_PRINTF(( DBG_CONTEXT,
                 "AtqSendAndRecv(%08lx) g_fUseDriver == FALSE\n Calling AtqWriteSocket.\n", patqContext));
        }

        return AtqWriteSocket( patqContext,
                               pwsaSendBuffers,
                               dwSendBufferCount,
                               &patqContext->Overlapped );
    }

    InterlockedIncrement( &pContext->m_nIO);

    I_SetNextTimeout(pContext);

    //
    // count the number of bytes
    //

    DBG_ASSERT( dwSendBufferCount >= 1);
    pContext->BytesSent = pwsaSendBuffers->len;
    if ( dwSendBufferCount > 1) {
        LPWSABUF pWsaBuf;
        for ( pWsaBuf = pwsaSendBuffers + 1;
            pWsaBuf <= (pwsaSendBuffers + dwSendBufferCount);
            pWsaBuf++) {
            pContext->BytesSent += pWsaBuf->len;
        }
    }


    DBG_ASSERT( dwRecvBufferCount >= 1);
    pContext->BytesSent += pwsaRecvBuffers->len;
    if ( dwRecvBufferCount > 1) {
        LPWSABUF pWsaBuf;
        for ( pWsaBuf = pwsaRecvBuffers + 1;
              pWsaBuf <= (pwsaRecvBuffers + dwRecvBufferCount);
              pWsaBuf++) {
            pContext->BytesSent += pWsaBuf->len;
        }
    }

    switch ( pBandwidthInfo->QueryStatus( AtqIoSendRecv ) )
    {
    case StatusAllowOperation:

        pBandwidthInfo->IncTotalAllowedRequests();

        fRes = I_AtqSendAndRecv( patqContext,
                                 pwsaSendBuffers,
                                 dwSendBufferCount,
                                 pwsaRecvBuffers,
                                 dwRecvBufferCount ) ||
                (GetLastError() == ERROR_IO_PENDING);

        if (!fRes) { InterlockedDecrement( &pContext->m_nIO); };

        break;

    case StatusBlockOperation:

        // store data for restarting the operation.
        pContext->arInfo.atqOp        = AtqIoSendRecv;
        pContext->arInfo.lpOverlapped = &pContext->Overlapped;
        pContext->arInfo.uop.opSendRecv.dwSendBufferCount = dwSendBufferCount;
        pContext->arInfo.uop.opSendRecv.dwRecvBufferCount = dwRecvBufferCount;

        if ( dwSendBufferCount == 1) {
            pContext->arInfo.uop.opSendRecv.sendbuf1.len = pwsaSendBuffers->len;
            pContext->arInfo.uop.opSendRecv.sendbuf1.buf = pwsaSendBuffers->buf;
            pContext->arInfo.uop.opSendRecv.pSendBufAll  = NULL;
        } else {

            DBG_ASSERT( dwSendBufferCount > 1);

            WSABUF * pBuf = (WSABUF *)
            ::LocalAlloc( LPTR, dwSendBufferCount * sizeof (WSABUF));
            if ( NULL != pBuf) {
                pContext->arInfo.uop.opSendRecv.pSendBufAll = pBuf;
                CopyMemory( pBuf, pwsaSendBuffers,
                            dwSendBufferCount * sizeof(WSABUF));
            } else {
                InterlockedDecrement( &pContext->m_nIO);
                fRes = FALSE;
                break;
            }
        }

        if ( dwRecvBufferCount == 1) {
            pContext->arInfo.uop.opSendRecv.recvbuf1.len = pwsaRecvBuffers->len;
            pContext->arInfo.uop.opSendRecv.recvbuf1.buf = pwsaRecvBuffers->buf;
            pContext->arInfo.uop.opSendRecv.pRecvBufAll = NULL;
        } else {

            DBG_ASSERT( dwRecvBufferCount > 1);

            WSABUF * pBuf = (WSABUF *)
            ::LocalAlloc( LPTR, dwRecvBufferCount * sizeof (WSABUF));
            if ( NULL != pBuf) {
                pContext->arInfo.uop.opSendRecv.pRecvBufAll = pBuf;
                CopyMemory( pBuf, pwsaRecvBuffers,
                            dwRecvBufferCount * sizeof(WSABUF));
            } else {
                InterlockedDecrement( &pContext->m_nIO);
                fRes = FALSE;
                break;
            }
        }

        // Put this request in queue of blocked requests.
        fRes = pBandwidthInfo->BlockRequest( pContext);
        if ( fRes )
        {
            pBandwidthInfo->IncTotalBlockedRequests();
            break;
        }
        // fall through

    case StatusRejectOperation:
        InterlockedDecrement( &pContext->m_nIO);
        pBandwidthInfo->IncTotalRejectedRequests();
        SetLastError( ERROR_NETWORK_BUSY);
        fRes = FALSE;
        break;

    default:
        ATQ_ASSERT( FALSE);
        InterlockedDecrement( &pContext->m_nIO);
        SetLastError( ERROR_INVALID_PARAMETER);
        fRes = FALSE;
        break;

    } // switch()

    return fRes;
} // AtqSendAndRecv()




//
//  Short routine to enable the LoadDriverPrivilege for loading spud.sys
//

VOID EnableLoadDriverPrivilege(
    VOID
    )
{
    HANDLE ProcessHandle;
    HANDLE TokenHandle;
    BOOL Result;
    LUID LoadDriverValue;
    TOKEN_PRIVILEGES * TokenPrivileges;
    CHAR buf[ 5 * sizeof(TOKEN_PRIVILEGES) ];

    ProcessHandle = OpenProcess(
                        PROCESS_QUERY_INFORMATION,
                        FALSE,
                        GetCurrentProcessId()
                        );

    if ( ProcessHandle == NULL ) {

        //
        // This should not happen
        //

        goto Cleanup;
    }


    Result = OpenProcessToken (
                 ProcessHandle,
                 TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                 &TokenHandle
                 );

    if ( !Result ) {

        //
        // This should not happen
        //

        goto Cleanup;

    }

    //
    // Find out the value of LoadDriverPrivilege
    //


    Result = LookupPrivilegeValue(
                 NULL,
                 "SeLoadDriverPrivilege",
                 &LoadDriverValue
                 );

    if ( !Result ) {

        goto Cleanup;
    }

    //
    // Set up the privilege set we will need
    //

    TokenPrivileges = (TOKEN_PRIVILEGES *) buf;

    TokenPrivileges->PrivilegeCount = 1;
    TokenPrivileges->Privileges[0].Luid = LoadDriverValue;
    TokenPrivileges->Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    (VOID) AdjustTokenPrivileges (
                TokenHandle,
                FALSE,
                TokenPrivileges,
                sizeof(buf),
                NULL,
                NULL
                );
Cleanup:

    if ( TokenHandle )
    {
        CloseHandle( TokenHandle );
    }

    if ( ProcessHandle )
    {
        CloseHandle( ProcessHandle );
    }
}

HANDLE
AtqCreateFile(
    LPCSTR lpAFileName,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwFlagsAndAttributes,
    SECURITY_INFORMATION si,
    PSECURITY_DESCRIPTOR sd,
    ULONG Length,
    PULONG LengthNeeded,
    ATQ_OPLOCK_COMPLETION pfnOplockCompletion,
    PVOID Context
    )
{

    PUNICODE_STRING Unicode;
    ANSI_STRING AnsiString;
    NTSTATUS Status;
    LPCWSTR lpFileName;

    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    UNICODE_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;
    BOOLEAN TranslationStatus;
    RTL_RELATIVE_NAME RelativeName;
    PVOID FreeBuffer;
    ULONG CreateFlags;
    DWORD SQOSFlags;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    POPLOCK_INFO pOplock;

    Unicode = &NtCurrentTeb()->StaticUnicodeString;
    g_pfnRtlInitAnsiString(&AnsiString,lpAFileName);
    Status = g_pfnRtlAnsiStringToUnicodeString(Unicode,&AnsiString,FALSE);
    if ( !NT_SUCCESS(Status) ) {
        if ( Status == STATUS_BUFFER_OVERFLOW ) {
            SetLastError(ERROR_FILENAME_EXCED_RANGE);
            }
        else {
            SetLastError(g_pfnRtlNtStatusToDosError(Status));
            }
        return INVALID_HANDLE_VALUE;
        }

    lpFileName = Unicode->Buffer;


    CreateFlags = 0;

    TranslationStatus = g_pfnRtlDosPathNameToNtPathName_U(
                            lpFileName,
                            &FileName,
                            NULL,
                            &RelativeName
                            );

    if ( !TranslationStatus ) {
        SetLastError(ERROR_PATH_NOT_FOUND);
        return INVALID_HANDLE_VALUE;
        }

    FreeBuffer = FileName.Buffer;

    if ( RelativeName.RelativeName.Length ) {
        FileName = *(PUNICODE_STRING)&RelativeName.RelativeName;
        }
    else {
        RelativeName.ContainingDirectory = NULL;
        }

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        dwFlagsAndAttributes & FILE_FLAG_POSIX_SEMANTICS ? 0 : OBJ_CASE_INSENSITIVE,
        RelativeName.ContainingDirectory,
        NULL
        );


    if ( ARGUMENT_PRESENT(lpSecurityAttributes) ) {
        Obja.SecurityDescriptor = lpSecurityAttributes->lpSecurityDescriptor;
        if ( lpSecurityAttributes->bInheritHandle ) {
            Obja.Attributes |= OBJ_INHERIT;
            }
        }

    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_NO_BUFFERING ? FILE_NO_INTERMEDIATE_BUFFERING : 0 );
    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_WRITE_THROUGH ? FILE_WRITE_THROUGH : 0 );
    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_OVERLAPPED ? 0 : FILE_SYNCHRONOUS_IO_NONALERT );
    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_SEQUENTIAL_SCAN ? FILE_SEQUENTIAL_ONLY : 0 );
    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_RANDOM_ACCESS ? FILE_RANDOM_ACCESS : 0 );
    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_BACKUP_SEMANTICS ? FILE_OPEN_FOR_BACKUP_INTENT : 0 );

    if ( pfnOplockCompletion != NULL ) {
        pOplock = (POPLOCK_INFO)
        ::LocalAlloc( LPTR, sizeof(OPLOCK_INFO));
        if ( pOplock ) {
            pOplock->pfnOplockCompletion = pfnOplockCompletion;
            pOplock->Context = Context;
        }
    } else {
        pOplock = NULL;
    }

    Status = SPUDCreateFile(
                &Handle,
                &Obja,
                &IoStatusBlock,
                dwFlagsAndAttributes & (FILE_ATTRIBUTE_VALID_FLAGS & ~FILE_ATTRIBUTE_DIRECTORY),
                dwShareMode,
                CreateFlags,
                si,
                sd,
                Length,
                LengthNeeded,
                pOplock
                );

    g_pfnRtlFreeHeap(RtlProcessHeap(), 0,FreeBuffer);

    if ( !NT_SUCCESS(Status) ) {
        if ( Status == STATUS_INVALID_PARAMETER ||
             Status == STATUS_OPLOCK_NOT_GRANTED ) {
             SetLastError(ERROR_INVALID_ACCESS);
             return Handle;
        }
        if ( Status == STATUS_FILE_IS_A_DIRECTORY ) {
            SetLastError(ERROR_ACCESS_DENIED);
        } else {
            SetLastError(g_pfnRtlNtStatusToDosError(Status));
        }
        return INVALID_HANDLE_VALUE;
    }

    SetLastError(ERROR_SUCCESS);
    return Handle;

}

HANDLE
AtqCreateFileW(
    LPCWSTR lpFileName,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwFlagsAndAttributes,
    SECURITY_INFORMATION si,
    PSECURITY_DESCRIPTOR sd,
    ULONG Length,
    PULONG LengthNeeded,
    ATQ_OPLOCK_COMPLETION pfnOplockCompletion,
    PVOID Context
    )
{

    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    UNICODE_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;
    BOOLEAN TranslationStatus;
    RTL_RELATIVE_NAME RelativeName;
    PVOID FreeBuffer;
    ULONG CreateFlags;
    DWORD SQOSFlags;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    POPLOCK_INFO pOplock;

    CreateFlags = 0;

//    DbgPrint("AtqCreateFileW - %ws\n", lpFileName );

    TranslationStatus = g_pfnRtlDosPathNameToNtPathName_U(
                            lpFileName,
                            &FileName,
                            NULL,
                            &RelativeName
                            );

    if ( !TranslationStatus ) {
        SetLastError(ERROR_PATH_NOT_FOUND);
        return INVALID_HANDLE_VALUE;
        }

    FreeBuffer = FileName.Buffer;

    if ( RelativeName.RelativeName.Length ) {
        FileName = *(PUNICODE_STRING)&RelativeName.RelativeName;
        }
    else {
        RelativeName.ContainingDirectory = NULL;
        }

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        dwFlagsAndAttributes & FILE_FLAG_POSIX_SEMANTICS ? 0 : OBJ_CASE_INSENSITIVE,
        RelativeName.ContainingDirectory,
        NULL
        );


    if ( ARGUMENT_PRESENT(lpSecurityAttributes) ) {
        Obja.SecurityDescriptor = lpSecurityAttributes->lpSecurityDescriptor;
        if ( lpSecurityAttributes->bInheritHandle ) {
            Obja.Attributes |= OBJ_INHERIT;
            }
        }

    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_NO_BUFFERING ? FILE_NO_INTERMEDIATE_BUFFERING : 0 );
    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_WRITE_THROUGH ? FILE_WRITE_THROUGH : 0 );
    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_OVERLAPPED ? 0 : FILE_SYNCHRONOUS_IO_NONALERT );
    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_SEQUENTIAL_SCAN ? FILE_SEQUENTIAL_ONLY : 0 );
    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_RANDOM_ACCESS ? FILE_RANDOM_ACCESS : 0 );
    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_BACKUP_SEMANTICS ? FILE_OPEN_FOR_BACKUP_INTENT : 0 );

    if ( pfnOplockCompletion != NULL ) {
        pOplock = (POPLOCK_INFO)
        ::LocalAlloc( LPTR, sizeof(OPLOCK_INFO));
        if ( pOplock ) {
            pOplock->pfnOplockCompletion = pfnOplockCompletion;
            pOplock->Context = Context;
        }
    } else {
        pOplock = NULL;
    }

    Status = SPUDCreateFile(
                &Handle,
                &Obja,
                &IoStatusBlock,
                dwFlagsAndAttributes & (FILE_ATTRIBUTE_VALID_FLAGS & ~FILE_ATTRIBUTE_DIRECTORY),
                dwShareMode,
                CreateFlags,
                si,
                sd,
                Length,
                LengthNeeded,
                pOplock
                );

    g_pfnRtlFreeHeap(RtlProcessHeap(), 0,FreeBuffer);

    if ( !NT_SUCCESS(Status) ) {
        if ( Status == STATUS_INVALID_PARAMETER ||
             Status == STATUS_OPLOCK_NOT_GRANTED ) {
             SetLastError(ERROR_INVALID_ACCESS);
             return Handle;
        }
        if ( Status == STATUS_FILE_IS_A_DIRECTORY ) {
            SetLastError(ERROR_ACCESS_DENIED);
        } else {
            SetLastError(g_pfnRtlNtStatusToDosError(Status));
        }
        return INVALID_HANDLE_VALUE;
    }

    SetLastError(ERROR_SUCCESS);
    return Handle;

}

BOOL
AtqOplockAcknowledge(
    IN HANDLE   FileHandle,
    ATQ_OPLOCK_COMPLETION pfnOplockCompletion,
    PVOID Context
)
{
    POPLOCK_INFO pOplock;
    NTSTATUS Status;

    if ( pfnOplockCompletion != NULL ) {
        pOplock = (POPLOCK_INFO)
        ::LocalAlloc( LPTR, sizeof(OPLOCK_INFO));
        if ( pOplock ) {
            pOplock->pfnOplockCompletion = pfnOplockCompletion;
            pOplock->Context = Context;
            Status = SPUDOplockAcknowledge(
                          FileHandle,
                          pOplock
                          );

            if ( Status == STATUS_SUCCESS ) {
                return TRUE;
            }

        }
    }
    return FALSE;

}

#else

BOOL
I_AtqSpudInitialize(
            IN HANDLE hPort
            )
{
    return FALSE;
}

BOOL
I_AtqSpudTerminate()
{
    return TRUE;
}

BOOL
I_AtqTransmitFileAndRecv(
    IN PATQ_CONTEXT             patqContext,            // pointer to ATQ context
    IN HANDLE                   hFile,                  // handle of file to read
    IN DWORD                    dwBytesInFile,          // Bytes to transmit
    IN LPTRANSMIT_FILE_BUFFERS  lpTransmitBuffers,      // transmit buffer structure
    IN DWORD                    dwTFFlags,              // TF Flags
    IN LPWSABUF                 pwsaBuffers,            // Buffers for recv
    IN DWORD                    dwBufferCount
    )
{
    return FALSE;
}

BOOL
I_AtqSendAndRecv(
    IN PATQ_CONTEXT             patqContext,            // pointer to ATQ context
    IN LPWSABUF                 pwsaSendBuffers,        // buffers for send
    IN DWORD                    dwSendBufferCount,      // count of buffers for send
    IN LPWSABUF                 pwsaRecvBuffers,        // Buffers for recv
    IN DWORD                    dwRecvBufferCount       // count of buffers for recv
    )
{
    return FALSE;
}
#endif
BOOL
AtqSpudInitialized(
    VOID
)
{
    return g_fUseDriver;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\atq\timer.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    timer.h

Abstract:

    Domain Name System (DNS) Server

    Wrap proof timer routines.

    The purpose of this module is to create a timer function which
    returns a time in seconds and eliminates all timer wrapping issues.

    These routines are non-DNS specific and may be picked up
    cleanly by any module.

Author:

    Jim Gilroy (jamesg)     9-Sep-1995

Revision History:

--*/


#ifndef _TIMER_INCLUDED_
#define _TIMER_INCLUDED_

dllexp
VOID
InitializeSecondsTimer(
    VOID
    );

dllexp
DWORD
GetCurrentTimeInSeconds(
    VOID
    );

dllexp
__int64
GetCurrentTimeInMilliseconds(
    VOID
    );

#endif  // _TIMER_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\atq\timer.cxx ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    timer.c

Abstract:

    Wrap proof timer routines.

    The purpose of this module is to create a timer function which
    returns a time in seconds and eliminates all timer wrapping issues.

    These routines are non-DNS specific and may be picked up
    cleanly by any module.

    For DNS the added instructions are well worth the cost in that it
    eliminates any issue involving cleaning packet queues or resetting
    cache timeouts when millisecond timer (GetCurrentTime) wraps.

Author:

    Jim Gilroy (jamesg)     9-Sep-1995

Environment:

    Win32 User Mode

Project:

    Common Code for Internet Services

Functions Exported:

    InitializeSecondsTimer()
    GetCurrentTimeInSeconds()

Revision History:
    MuraliK  14-Nov-1995 Made multi thread safe.
    
--*/


# include "isatq.hxx"


//
//  Timer globals
//

static LONG      g_lTimerInitialized = (LONG ) FALSE;
CRITICAL_SECTION    g_csTimerWrap;



VOID
InitializeSecondsTimer(
    VOID
    )
/*++

Routine Description:

    Initialize DNS timer.

Arguments:

    None.

Return Value:

    None.

--*/
{
    if ( InterlockedExchange( &g_lTimerInitialized, (LONG ) TRUE) == FALSE) { 
        
        // I am the first thread to initialize. Let me do so.
          
        InitializeCriticalSection( &g_csTimerWrap );
        SET_CRITICAL_SECTION_SPIN_COUNT( &g_csTimerWrap, 
                                         IIS_DEFAULT_CS_SPIN_COUNT);
    }

} // InitializeSecondsTimer()



DWORD
GetCurrentTimeInSeconds(
    VOID
    )
/*++

Routine Description:

    Get current time in seconds.

Arguments:

    None.

Return Value:

    Time since boot in seconds.

--*/
{
    DWORD   dwCurrentTime;
    static DWORD    dwPreviousTime = 0;     // previous GetCurrentTime()
    static DWORD    dwWrapTime = 0;         // accumulated time (s) from timer
                                            //  wraps

    dwCurrentTime = GetCurrentTime();

    //
    //  check for timer wrap
    //
    //  Check that previous time is bigger, but since multi-threaded,
    //  occasionally preempted before making test and another thread
    //  may reset dwPreviousTime.  So we also explicitly verify the
    //  switch from a very large DWORD to a small one.
    //
    //  Note:  that we completely avoid using the CS, except right at
    //  an actual timer wrap.   Hence the cost for this function
    //  remains low.
    //

    if ( dwPreviousTime > dwCurrentTime
            &&
         (LONG)dwPreviousTime < 0
            &&
         (LONG)dwCurrentTime > 0 )
    {
        //
        //  detected timer wrap
        //
        //  inside CS, verify actual wrap and reset dwPreviousTime
        //  so other waiting threads will NOT count wrap
        //

        EnterCriticalSection( &g_csTimerWrap );

        if ( (LONG)dwPreviousTime < 0
                &&
            (LONG)dwCurrentTime > 0 )
        {
            dwPreviousTime = dwCurrentTime;
            dwWrapTime += (0xffffffff / 1000);
        }
        LeaveCriticalSection( &g_csTimerWrap );
    }
    dwPreviousTime = dwCurrentTime;

    return (dwCurrentTime / 1000 + dwWrapTime);
}


__int64
GetCurrentTimeInMilliseconds(
    VOID
    )
/*++

Routine Description:

    Get current time in milliseconds.

Arguments:

    None.

Return Value:

    Time since boot in seconds.

--*/
{
    DWORD   dwCurrentTime;
    static DWORD    dwPreviousTime = 0;     // previous GetCurrentTime()
    static DWORD    dwWrapTime = 0;         // accumulated time (s) from timer
                                            //  wraps

    dwCurrentTime = GetTickCount();

    //
    //  check for timer wrap
    //
    //  Check that previous time is bigger, but since multi-threaded,
    //  occasionally preempted before making test and another thread
    //  may reset dwPreviousTime.  So we also explicitly verify the
    //  switch from a very large DWORD to a small one.
    //
    //  Note:  that we completely avoid using the CS, except right at
    //  an actual timer wrap.   Hence the cost for this function
    //  remains low.
    //

    if ( dwPreviousTime > dwCurrentTime
            &&
         (LONG)dwPreviousTime < 0
            &&
         (LONG)dwCurrentTime > 0 )
    {
        //
        //  detected timer wrap
        //
        //  inside CS, verify actual wrap and reset dwPreviousTime
        //  so other waiting threads will NOT count wrap
        //

        EnterCriticalSection( &g_csTimerWrap );

        if ( (LONG)dwPreviousTime < 0
                &&
            (LONG)dwCurrentTime > 0 )
        {
            dwPreviousTime = dwCurrentTime;
            ++dwWrapTime;
        }
        LeaveCriticalSection( &g_csTimerWrap );
    }
    dwPreviousTime = dwCurrentTime;

    return (((__int64)dwWrapTime)<<32) |  dwCurrentTime;
}


//
//  End of timer.c
//
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\atq\inc\atq.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1994-1997           **/
/**********************************************************************/

/*
    atq.h

    This module contains async thread queue (atq) for async IO and thread
    pool sharing among various services.

    Brief Description of ATQ:
      For description, please see iis\spec\isatq.doc

*/

#ifndef _ATQ_H_
#define _ATQ_H_


//# include <tapi3.h>
const long TAPIMEDIATYPE_AUDIO = 0x8;
const long TAPIMEDIATYPE_VIDEO = 0x8000;
const long TAPIMEDIATYPE_DATAMODEM = 0x10;
const long TAPIMEDIATYPE_G3FAX = 0x20;
const long TAPIMEDIATYPE_MULTITRACK = 0x10000;
# include <msputils.h>

#ifdef __cplusplus
extern "C" {
#endif


// Include Standard headers

# include <windows.h>
# include <winsock2.h>
# include <mswsock.h>


#ifndef dllexp
#define dllexp __declspec( dllexport )
#endif


/*++
  ATQ API Overview:

  Global per module:
     AtqInitialize()
     AtqTerminate()

     AtqGetInfo()
     AtqSetInfo()

  ATQ Endpoint functions:
     AtqCreateEndpoint()
        AtqStartEndpoint()
        AtqEndpointGetInfo()
        AtqEndpointSetInfo()
        AtqStopCloseEndpoint()
     AtqCloseCloseEndpoint()

     AtqStopAndCloseEndpoint()  <-- soon to be killed
  Per ATQ Context Functions:
     AtqAddAsyncHandle()  <-- for non AcceptEx() sockets

     AtqGetAcceptExAddrs()       <-- for AcceptEx() sockets

     AtqContextSetInfo()

     AtqCloseFileHandle()
     AtqCloseSocket()
     AtqFreeContext()

  Bandwidth Throttler Functions:
     AtqCreateBandwidthInfo()
     AtqFreeBandwidthInfo()
     AtqBandwidthSetInfo()
     AtqBandwidthGetInfo()

  IO Functions:

     AtqReadFile()
     AtqWriteFile()
     AtqReadSocket()
     AtqWriteSocket()
     AtqTransmitFile()
     AtqTransmitFileAndRecv()
     AtqSendAndRecv()

  Utility Functions:

     AtqCreateFile()
     AtqCreateFileW()
     AtqOplockAcknowledge()
     AtqSpudInitialized()
     AtqReadDirChanges()
     AtqPostCompletionStatus()


--*/


/*----------------------------------------------------------
  Registry Parameters used by ATQ during AtqInitialize()
  ATQ loads some of the parameters from
  HKLM\System\CurrentControlSet\Services\InetInfo\Parameters

  Most of these parameters are for INTERNAL ANALYSIS and
   development/testing. Setup should not install values
   for the same. Setup can include values for items marked SETUP.
------------------------------------------------------------*/

// Names

#define ATQ_REG_PER_PROCESSOR_ATQ_THREADS TEXT("MaxPoolThreads")
#define ATQ_REG_POOL_THREAD_LIMIT         TEXT("PoolThreadLimit") // SETUP
#define ATQ_REG_PER_PROCESSOR_CONCURRENCY TEXT("MaxConcurrency")
#define ATQ_REG_THREAD_TIMEOUT            TEXT("ThreadTimeout")
#define ATQ_REG_USE_ACCEPTEX              TEXT("UseAcceptEx")
#define ATQ_REG_MIN_KB_SEC                TEXT("MinFileKbSec")    // SETUP
#define ATQ_REG_LISTEN_BACKLOG            TEXT("ListenBacklog")   // SETUP

// Default Values

#define ATQ_REG_DEF_ATQ_THREADS                     (128)
#define ATQ_REG_DEF_PER_PROCESSOR_CONCURRENCY         (0)
// special value of 0 means that system will determine this dynamically.

//
// thread limit settings
//

#define ATQ_REG_MIN_POOL_THREAD_LIMIT                 (64)
#define ATQ_REG_DEF_POOL_THREAD_LIMIT                 (128)
#define ATQ_REG_MAX_POOL_THREAD_LIMIT                 (512)

//
// How often to check for thread progress.
//
#define ATQ_THREAD_MONITOR_PERIOD                     (2*60) // 2 Minutes

//
// How many IO's a temp thread should handle before 
// exiting
//

#define ATQ_TEMP_THREAD_IO_COUNT                      (100)

//
// THREAD_TIMEOUTs are high to prevent async ios from being cancelled
//  when the thread goes away.
//

#define ATQ_REG_DEF_THREAD_TIMEOUT                    (12*60*60) // 12 hours
#define ATQ_REG_DEF_USE_ACCEPTEX                      (TRUE)
#define ATQ_REG_DEF_MIN_KB_SEC                        (1000)  // 1000 bytes
#define ATQ_REG_DEF_LISTEN_BACKLOG                    (25)

//
// fake xmit file buffer size
//

#define ATQ_REG_DEF_NONTF_BUFFER_SIZE                 (4096)


/*----------------------------------------------------------
  Global Functions of ATQ module
-----------------------------------------------------------*/

// Flags for AtqInitialize()
# define ATQ_INIT_SPUD_FLAG          (0x00000001)

BOOL
AtqInitialize(
    IN DWORD dwFlags
    );

BOOL
AtqTerminate(
    VOID
    );

/*
 *  Sets various context information in Atq Module for global modifications
 *
 *
 *  Bandwidth Throttle:   Sets the throttle level in Bytes/Second.
 *        If INFINITE, then it is assumed that
 *                      there is no throttle value (default)
 *
 *  Max Pool Threads: Sets the maximum number of pool threads Atq will allow
 *        to be created per processor
 *
 *  MaxConcurrency: tells how many threads to permit per processor
 *
 *  Thread Timeout: Indicates how long a thread should be kep alive
 *        waiting on GetQueuedCompletionStatus() before commiting suicide
 *        (in seconds)
 *
 *  Inc/Dec max pool threads: If a server will be doing extended processing
 *        in an ATQ pool thread, they should increase the max pool threads
 *        while the extended processing is occurring.  This prevents starvation
 *        of other requests
 *
 *  AtqMinKbSec: set the assumed minimum KB per second for AtqTransmitFile()
 *        This value is used in calculating the timeout for file transfer
 *        operation
 *
 */

typedef enum _ATQ_INFO {

    AtqBandwidthThrottle = 0,
    AtqExitThreadCallback,
    AtqMaxPoolThreads,    // per processor values
    AtqMaxConcurrency,    // per processor concurrency value
    AtqThreadTimeout,
    AtqUseAcceptEx,       // Use AcceptEx if available
    AtqIncMaxPoolThreads, // Up the max thread count
    AtqDecMaxPoolThreads, // Decrease the max thread count
    AtqMinKbSec,          // Minimum assumed transfer rate for AtqTransmitFile
    AtqBandwidthThrottleMaxBlocked,  // Max number of blocked requests
    AtqUpdatePerfCounterCallback,
    AtqMaxDGramSend,      // Max bytes in a single datagram send
    AtqPoolThreadsLimit
} ATQ_INFO;

//
// ATQ_THREAD_EXIT_CALLBACK
// Type of callback function to be called when an ATQ thread exits so
// that the user of ATQ may clen up thread specific data.
//

typedef
VOID
(*ATQ_THREAD_EXIT_CALLBACK) ( VOID );

//
// ATQ_PERF_UPDATE_CALLBACK
// Type of callback function to be called when ATQ needs to update
// PerfMon counters that do no reside within ATQ.
//
// dwStat      : see ATQ_PERFCTR_* defines.
// dwOperation : see FLAG_COUNTER_* defines.
// dwVal       : value to increment or decrement by, or to set
//

#define ATQ_PERFCTR_WORKERTHREAD_CREATED        0
#define ATQ_PERFCTR_WORKERTHREAD_ALIVE          1
#define ATQ_PERFCTR_WORKERTHREAD_ACTIVE         2
#define ATQ_PERFCTR_WORKERTHREAD_AVAILABLE      3
#define ATQ_PERFCTR_RECV_BYTES                  4
#define ATQ_PERFCTR_XMIT_BYTES                  5
#define ATQ_PERFCTR_RECV_PACKETS                6
#define ATQ_PERFCTR_XMIT_PACKETS                7

#define FLAG_COUNTER_INCREMENT  0x00000001
#define FLAG_COUNTER_DECREMENT  0x00000002
#define FLAG_COUNTER_SET        0x00000003

typedef
VOID
(*ATQ_UPDATE_PERF_CALLBACK) (
    IN DWORD            dwStat,
    IN DWORD            dwOperation,
    IN DWORD            dwVal
);


dllexp
DWORD_PTR
AtqSetInfo(
    IN ATQ_INFO atqInfo,
    IN DWORD_PTR Data
    );

dllexp
DWORD_PTR
AtqGetInfo(
    IN ATQ_INFO atqInfo
    );



typedef struct _ATQ_STATISTICS {

    DWORD  cAllowedRequests;
    DWORD  cBlockedRequests;
    DWORD  cRejectedRequests;
    DWORD  cCurrentBlockedRequests;
    DWORD  MeasuredBandwidth;

} ATQ_STATISTICS;


dllexp
BOOL AtqGetStatistics( IN OUT ATQ_STATISTICS * pAtqStats);

dllexp
BOOL AtqClearStatistics(VOID);




/*----------------------------------------------------------
  ATQ Endpoint functions
-----------------------------------------------------------*/

//
//  endpoint data
//

typedef enum _ATQ_ENDPOINT_INFO {

    EndpointInfoListenPort,
    EndpointInfoListenSocket,
    EndpointInfoAcceptExOutstanding,
    EndpointInfoConsumerType

}  ATQ_ENDPOINT_INFO;



//
//  ATQ_COMPLETION
//  This is the routine that is called upon IO completion (on
//  error or success).
//
//  Context is the context passed to AtqAddAsyncHandle
//  BytesWritten is the number of bytes written to the file or
//      bytes written to the client's buffer
//  CompletionStatus is the WinError completion code
//  lpOverLapped is the filled in overlap structure
//
//  If the timeout thread times out an IO request, the completion routine
//  will be called by the timeout thread with IOCompletion FALSE and
//  CompletionStatus == ERROR_SEM_TIMEOUT.  The IO request is *still*
//  outstanding in this instance.  Generally it will be completed when
//  the file handle is closed.
//

typedef
VOID
(*ATQ_COMPLETION)(
            IN PVOID        Context,
            IN DWORD        BytesWritten,
            IN DWORD        CompletionStatus,  // Win32 Error code
            IN OVERLAPPED * lpo
            );

//
// Type of callback function to be called when a new connection is established.
//  This function should be defined before including conninfo.hxx
//

typedef
VOID
(*ATQ_CONNECT_CALLBACK) (
                IN SOCKET sNew,
                IN LPSOCKADDR_IN pSockAddr,
                IN PVOID EndpointContext,
                IN PVOID EndpointObject
                );



typedef struct _ATQ_ENDPOINT_CONFIGURATION {

    //
    // Port to listen on.  If 0, system will assign
    //

    USHORT ListenPort;

    //
    // Is connectionless
    //

    BOOL  fDatagram;
    
    // The next two are datagram only.
    BOOL  fReverseQueuing;     // If set then winsock will drop the oldest rather
                               // than the newest datagram buffers when winsock buffers 
                               // overflow.

    INT   cbDatagramWSBufSize; // How much buffer space to tell winsock to reserve
                               // for this datagram socket.
    
    //
    // Prevent others from using this?
    //

    BOOL  fLockDownPort;

    //
    // IP address to bind to. 0 (INADDR_ANY) == wildcard.
    //

    DWORD IpAddress;

    DWORD cbAcceptExRecvBuffer;
    DWORD nAcceptExOutstanding;
    DWORD AcceptExTimeout;

    //
    // Callbacks
    //

    ATQ_CONNECT_CALLBACK pfnConnect;
    ATQ_COMPLETION pfnConnectEx;
    ATQ_COMPLETION pfnIoCompletion;

} ATQ_ENDPOINT_CONFIGURATION, *PATQ_ENDPOINT_CONFIGURATION;

dllexp
PVOID
AtqCreateEndpoint(
    IN PATQ_ENDPOINT_CONFIGURATION Configuration,
    IN PVOID EndpointContext
    );

dllexp
BOOL
AtqStartEndpoint(
    IN PVOID Endpoint
    );

dllexp
DWORD_PTR
AtqEndpointGetInfo(
    IN PVOID Endpoint,
    IN ATQ_ENDPOINT_INFO EndpointInfo
    );

dllexp
DWORD_PTR
AtqEndpointSetInfo(
    IN PVOID Endpoint,
    IN ATQ_ENDPOINT_INFO EndpointInfo,
    IN DWORD_PTR dwInfo
    );

dllexp
BOOL
AtqStopEndpoint(
    IN PVOID Endpoint
    );

dllexp
BOOL
AtqCloseEndpoint(
    IN PVOID Endpoint
    );

dllexp
BOOL
AtqStopAndCloseEndpoint(
    IN PVOID Endpoint,
    IN LPTHREAD_START_ROUTINE lpCompletion,
    IN PVOID lpCompletionContext
    );



/*----------------------------------------------------------
  ATQ CONTEXT functions
-----------------------------------------------------------*/

//
//  This is the public portion of an ATQ Context.  It should be treated
//  as read only
//
//  !!! Changes made to this structure should also be made to
//  ATQ_CONTEXT in atqtypes.hxx !!!
//

typedef struct _ATQ_CONTEXT_PUBLIC {

    HANDLE         hAsyncIO;       // handle for async i/o object: socket/file
    OVERLAPPED     Overlapped;     // Overlapped structure used for IO

} ATQ_CONTEXT_PUBLIC, *PATQ_CONTEXT;


dllexp
BOOL
AtqAddAsyncHandle(
    OUT PATQ_CONTEXT * ppatqContext,
    IN  PVOID          EndpointObject,
    IN  PVOID          ClientContext,
    IN  ATQ_COMPLETION pfnCompletion,
    IN  DWORD          TimeOut,
    IN  HANDLE         hAsyncIO
    );


dllexp
VOID
AtqGetAcceptExAddrs(
    IN  PATQ_CONTEXT patqContext,
    OUT SOCKET *     pSock,
    OUT PVOID *      ppvBuff,
    OUT PVOID *      pEndpointContext,
    OUT SOCKADDR * * ppsockaddrLocal,
    OUT SOCKADDR * * ppsockaddrRemote
    );


/*++
  AtqCloseSocket()

  Routine Description:

    Closes the socket in this atq structure if it wasn't
    closed by transmitfile. This function should be called only
    if the embedded handle in AtqContext is a Socket.

  Arguments:

    patqContext - Context whose socket should be closed.
    fShutdown - If TRUE, means we call shutdown and always close the socket.
        Note that if TransmitFile closed the socket, it will have done the
        shutdown for us

  Returns:
    TRUE on success and FALSE if there is a failure.
--*/
dllexp
BOOL
AtqCloseSocket(
    PATQ_CONTEXT patqContext,
    BOOL         fShutdown
    );

/*++
  AtqCloseFileHandle()

  Routine Description:

    Closes the file handle in this atq structure.
    This function should be called only if the embedded handle
    in AtqContext is a file handle.

  Arguments:

  patqContext - Context whose file handle should be closed.

  Returns:
    TRUE on success and FALSE if there is a failure.
--*/
dllexp
BOOL
AtqCloseFileHandle(
    PATQ_CONTEXT patqContext
    );


/*++

   AtqFreeContext()

   Routine Description:

     Frees the context created in AtqAddAsyncHandle.
     Call this after the async handle has been closed and all outstanding
     IO operations have been completed. The context is invalid after this call.
     Call AtqFreeContext() for same context only ONCE.

   Arguments:

    patqContext - Context to free
    fReuseContext - TRUE if this can context can be reused in the context of
        the calling thread.  Should be FALSE if the calling thread will exit
        soon (i.e., isn't an AtqPoolThread).

   Returns:
    None
--*/
dllexp
VOID
AtqFreeContext(
    IN PATQ_CONTEXT   patqContext,
    BOOL              fReuseContext
    );




enum ATQ_CONTEXT_INFO
{
    ATQ_INFO_TIMEOUT = 0,       // Timeout rounded up to ATQ timeout interval
    ATQ_INFO_RESUME_IO,         // resumes IO as is after Timeout
    ATQ_INFO_COMPLETION,        // Completion routine
    ATQ_INFO_COMPLETION_CONTEXT,// Completion context
    ATQ_INFO_BANDWIDTH_INFO,    // Bandwidth Throttling Descriptor
    ATQ_INFO_ABORTIVE_CLOSE,    // do abortive close on closesocket
    ATQ_INFO_NEXT_TIMEOUT
};

enum ATQ_CONSUMER_TYPE
{
    AtqConsumerLDAP,
    AtqConsumerOther,    // really represents in-progress IOCompletions. atqtypes.hxx:821,839
    AtqConsumerAtq,      // really represents total count of worker threads
    AtqConsumerMax
};


/*++

  AtqContextSetInfo()

  Routine Description:

    Sets various bits of information for this context

  Arguments:

    patqContext - pointer to ATQ context
    atqInfo     - Data item to set
    data        - New value for item

  Return Value:

    The old value of the parameter

--*/

dllexp
DWORD_PTR
AtqContextSetInfo(
    IN PATQ_CONTEXT   patqContext,
    IN enum ATQ_CONTEXT_INFO  atqInfo,
    IN DWORD_PTR      data
    );

VOID
AtqUpdatePerfStats(
    IN DWORD                    dwStat,
    IN DWORD                    dwOperation,
    IN DWORD                    dwVal
    );


/*----------------------------------------------------------
  ATQ Context IO functions
-----------------------------------------------------------*/

/*++

Routine Description:

    Atq<Operation><Target>()

    <Operation> :=  Read | Write | Transmit
    <Target>    :=  File | Socket

    These functions just setup ATQ context and then call the corresponding
    Win32/WinSock function for submitting an asynchronous IO operation. By
    default the Socket functions support scatter/gather using WSABUF

    These functions are wrappers and should be called instead of the
     correpsonding Win32 API.  The one difference from the Win32 API is TRUE
     is returned if the error ERROR_IO_PENDING occurred, thus clients do not
     need to check for this case.

   The timeout time for the request is calculated by taking the maximum of
     the context's timeout time and bytes transferred based on 1k/second.

Arguments:

    patqContext - pointer to ATQ context
    Everything else as in the Win32 API/WinSock APIs

    NOTES: AtqTransmitFile takes an additional DWORD flags which may contain
        the winsock constants TF_DISCONNECT and TF_REUSE_SOCKET

    AtqReadFile and AtqWriteFile take an optional overlapped structure if
    clients want to have multiple outstanding reads or writes.  If the value
    is NULL, then the overlapped structure from the Atq context is used.

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)
    sets ERROR_NETWORK_BUSY as error when the request needs to be rejected.

--*/

dllexp
BOOL
AtqReadFile(
    IN  PATQ_CONTEXT patqContext,
    IN  LPVOID       lpBuffer,
    IN  DWORD        BytesToRead,
    IN  OVERLAPPED * lpo OPTIONAL
    );

dllexp
BOOL
AtqReadSocket(
    IN  PATQ_CONTEXT patqContext,
    IN  LPWSABUF     pwsaBuffers,
    IN  DWORD        dwBufferCount,
    IN  OVERLAPPED * lpo  OPTIONAL
    );

/*
 *  Code for reading into single buffer will look like the following.
 * {
 *   WSABUF wsaBuf = { (BytesToRead), (lpBuffer)};
 *   fRet = AtqReadSocket( patqContext, &wsaBuf, 1, lpo);
 * }
 */

dllexp
BOOL
AtqWriteFile(
    IN  PATQ_CONTEXT patqContext,
    IN  LPCVOID      lpBuffer,
    IN  DWORD        BytesToWrite,
    IN  OVERLAPPED * lpo OPTIONAL
    );

dllexp
BOOL
AtqWriteSocket(
    IN  PATQ_CONTEXT patqContext,
    IN  LPWSABUF     pwsaBuffers,
    IN  DWORD        dwBufferCount,
    IN  OVERLAPPED * lpo OPTIONAL
    );


dllexp
BOOL
AtqSyncWsaSend(
    IN PATQ_CONTEXT  patqContext,
    IN  LPWSABUF     pwsaBuffers,
    IN  DWORD        dwBufferCount,
    OUT LPDWORD      pcbWritten
    );

// Note: This API always causes the complete file to be sent.
// If you want to change the behaviour store the appropriate offsets
//   in the ATQ_CONTEXT::Overlapped object.
dllexp
BOOL
AtqTransmitFile(
    IN  PATQ_CONTEXT            patqContext,
    IN  HANDLE                  hFile,         // File data comes from
    IN  DWORD                   dwBytesInFile, // what is the size of file?
    IN  LPTRANSMIT_FILE_BUFFERS lpTransmitBuffers,
    IN  DWORD                   dwFlags      // TF_DISCONNECT, TF_REUSE_SOCKET
    );

dllexp
BOOL
AtqTransmitFileAndRecv(
    IN PATQ_CONTEXT             patqContext,            // pointer to ATQ context
    IN HANDLE                   hFile,                  // handle of file to read
    IN DWORD                    dwBytesInFile,          // Bytes to transmit
    IN LPTRANSMIT_FILE_BUFFERS  lpTransmitBuffers,      // transmit buffer structure
    IN DWORD                    dwTFFlags,              // TF Flags
    IN LPWSABUF                 pwsaBuffers,            // Buffers for recv
    IN DWORD                    dwBufferCount
    );

dllexp
BOOL
AtqSendAndRecv(
    IN PATQ_CONTEXT             patqContext,            // pointer to ATQ context
    IN LPWSABUF                 pwsaSendBuffers,        // buffers for send
    IN DWORD                    dwSendBufferCount,      // count of buffers for send
    IN LPWSABUF                 pwsaRecvBuffers,        // Buffers for recv
    IN DWORD                    dwRecvBufferCount       // count of buffers for recv
    );


/*----------------------------------------------------------
  ATQ Utility Functions
-----------------------------------------------------------*/

#define OPLOCK_BREAK_NO_OPLOCK  0x00000001
#define OPLOCK_BREAK_OPEN       0x00000007
#define OPLOCK_BREAK_CLOSE      0x00000008

typedef
VOID
(*ATQ_OPLOCK_COMPLETION)(
            IN PVOID        Context,
            IN DWORD        Status
            );

dllexp
HANDLE
AtqCreateFile(
    LPCSTR lpAFileName,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwFlagsAndAttributes,
    SECURITY_INFORMATION si,
    PSECURITY_DESCRIPTOR sd,
    ULONG Length,
    PULONG LengthNeeded,
    ATQ_OPLOCK_COMPLETION pfnOplockCompletion,
    PVOID Context
    );

dllexp
HANDLE
AtqCreateFileW(
    LPCWSTR lpFileName,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwFlagsAndAttributes,
    SECURITY_INFORMATION si,
    PSECURITY_DESCRIPTOR sd,
    ULONG Length,
    PULONG LengthNeeded,
    ATQ_OPLOCK_COMPLETION pfnOplockCompletion,
    PVOID Context
    );

dllexp
BOOL
AtqOplockAcknowledge(
    IN HANDLE   FileHandle,
    ATQ_OPLOCK_COMPLETION pfnOplockCompletion,
    PVOID Context
);

dllexp
BOOL
AtqSpudInitialized(
    VOID
);

dllexp
BOOL
AtqReadDirChanges(PATQ_CONTEXT patqContext,
                  LPVOID       lpBuffer,
                  DWORD        BytesToRead,
                  BOOL         fWatchSubDir,
                  DWORD        dwNotifyFilter,
                  OVERLAPPED * lpo );



/*++

  AtqPostCompletionStatus()

  Routine Description:

    Posts a completion status on the completion port queue

    An IO pending error code is treated as a success error code

  Arguments:

    patqContext - pointer to ATQ context
    Everything else as in the Win32 API

    NOTES:

  Return Value:

    TRUE if successful, FALSE on error (call GetLastError)

--*/

dllexp
BOOL
AtqPostCompletionStatus(
    IN     PATQ_CONTEXT patqContext,
    IN     DWORD        BytesTransferred
    );




/*----------------------------------------------------------
  ATQ Utility Functions
-----------------------------------------------------------*/

/*++

   Bandwidth Throttling Support

   The following items are used in the support for bandwidth throttling
--*/

enum ATQ_BANDWIDTH_INFO
{
    ATQ_BW_BANDWIDTH_LEVEL = 0,
    ATQ_BW_MAX_BLOCKED,
    ATQ_BW_STATISTICS,
    ATQ_BW_DESCRIPTION,
};

/*++

  AtqCreateBandwidthInfo()

  Routine Description:

    Allocate and opaque bandwidth descriptor

  Arguments:

    None

  Return Value:

    Pointer to descriptor.  NULL if failed.

--*/
dllexp
PVOID
AtqCreateBandwidthInfo(
    VOID
    );

/*++

  AtqFreeBandwidthInfo()

  Routine Description:

    Triggers the destruction of a bandwidth descriptor

  Arguments:

    pvBandwidthInfo - pointer to valid descriptor

  Return Value:

    TRUE if successful, else FALSE

--*/
dllexp
BOOL
AtqFreeBandwidthInfo(
    IN     PVOID               pvBandwidthInfo
    );

/*++

  AtqBandwidthSetInfo()

  Routine Description:

    Set properties of bandwidth descriptor

  Arguments:

    pvBandwidthInfo - pointer to descriptor
    BWInfo - property to change
    Data - value of property

  Return Value:

    Old value of property

--*/
dllexp
DWORD_PTR
AtqBandwidthSetInfo(
    IN     PVOID               pvBandwidthInfo,
    IN     ATQ_BANDWIDTH_INFO  BwInfo,
    IN     DWORD_PTR           Data
    );

/*++

  AtqBandwidthGetInfo()

  Routine Description:

    Get properties of bandwidth descriptor

  Arguments:

    pvBandwidthInfo - pointer to descriptor
    BWInfo - property to change
    pdwData - filled in with value of property

  Return Value:

    TRUE if successful, else FALSE

--*/
dllexp
BOOL
AtqBandwidthGetInfo(
    IN     PVOID               pvBandwidthInfo,
    IN     ATQ_BANDWIDTH_INFO  BwInfo,
    OUT    DWORD_PTR *         pdwData
    );

#include "atq2.h"

#ifdef __cplusplus
}
#endif

#endif // !_ATQ_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\atq\inc\spud.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    Spud.h

Abstract:

    Contains structures and declarations for SPUD.  SPUD stands for the
    Special Purpose Utility Driver.  This driver enhances the performance
    of IIS.

Author:

    John Ballard (jballard)    21-Oct-1996

Revision History:

--*/

#ifndef _SPUD_
#define _SPUD_

#define SPUD_VERSION     0x00010000

typedef enum {
    TransmitFileAndRecv,
    SendAndRecv,
} REQ_TYPE;

typedef struct _SPUD_REQ_CONTEXT {
    REQ_TYPE            ReqType;
    IO_STATUS_BLOCK     IoStatus1;
    IO_STATUS_BLOCK     IoStatus2;
    PVOID               KernelReqInfo;
} SPUD_REQ_CONTEXT, *PSPUD_REQ_CONTEXT;

typedef struct _SPUD_COUNTERS {
    ULONG       CtrTransmitfileAndRecv;
    ULONG       CtrTransRecvFastTrans;
    ULONG       CtrTransRecvFastRecv;
    ULONG       CtrTransRecvSlowTrans;
    ULONG       CtrTransRecvSlowRecv;
    ULONG       CtrSendAndRecv;
    ULONG       CtrSendRecvFastSend;
    ULONG       CtrSendRecvFastRecv;
    ULONG       CtrSendRecvSlowSend;
    ULONG       CtrSendRecvSlowRecv;
} SPUD_COUNTERS, *PSPUD_COUNTERS;

#if 0
typedef struct _SPUD_REQUEST_ITEM {
    HANDLE              Socket;
    DWORD               RequestIoctl;
    union {
        AFD_TRANSMIT_FILE_INFO  TransmitFileInfo;
        AFD_SEND_INFO           SendInfo;
        AFD_RECV_INFO           RecvInfo;
    } AfdRequest;
    IO_STATUS_BLOCK             StatusBlock;
} SPUD_REQUEST_ITEM, *PSPUD_REQUEST_ITEM;

typedef struct _SPUD_BATCH_REQUEST {
    ULONG               RequestCount;
    PSPUD_REQUEST_ITEM  RequestList;
} SPUD_BATCH_REQUEST, *PSPUD_BATCH_REQUEST;
#endif

#endif // ndef _SPUD_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\atq\inc\auxctrs.h ===
/*++

   Copyright    (c)    1995-1996    Microsoft Corporation

   Module  Name :

       auxctrs.h

   Abstract:
       This module defines the auxiliary counters for Internet Common Services.

   Author:

       Murali R. Krishnan    ( MuraliK )    02-Apr-1996

   Environment:

       Windows NT - User Mode

   Project:

       Internet Services Common DLL

   Revision History:

--*/

# ifndef _IIS_AUX_COUNTERS_HXX_
# define _IIS_AUX_COUNTERS_HXX_

/************************************************************
 *     Include Headers
 ************************************************************/


/************************************************************
 *   Symbolic Definitions
 ************************************************************/

/*++
  Counters belong to two categories
  1. Active Counter - one that counts up and down
      It is expected that this counter consists of the current
      active items and hence this should not be wildly high, unless
      there are large # of counted objects.

  2. Cumulative Counters - counts values up and up
      This count value is used to measure the # of times event(s)
      related to this counter occurred.

  Naming Conventions:
   prefixes used are: Aac & Cac
   Aac - Active Auxiliary Counter
   Cac - Cumulative Auxiliary Counter
   Ac  - Auxiliar Counter

--*/

typedef enum  {   // Ac - stands for Aux Counters.

    AacAtqContextsAlloced = 0,

    CacAtqContextsReused,
    CacAtqContextsCleanedup,
    CacAtqPrepareContexts,
    CacAtqPendingAcceptExScans,

    CacAtqContextsTimedOut,
    CacAtqWaitsForTimeout,
    CacAtqProcWhenTimeout,           // in processing when timeout occurred.

    AacIISMaxCounters                // sentinel counter
} ENUM_IIS_AUX_COUNTER;



#ifdef IIS_AUX_COUNTERS

# define NUM_AUX_COUNTERS    (AacIISMaxCounters)

//
// Macros for operating on these counters
//

# define AcIncrement( acCounter)   \
 (((acCounter) < NUM_AUX_COUNTERS) ?  \
   g_AuxCounters[acCounter]++ : \
  0)

# define AcDecrement( acCounter)   \
 (((acCounter) < NUM_AUX_COUNTERS) ?  \
  g_AuxCounters[acCounter]-- : \
  0)

# define AcCounter( acCounter)   \
 (((acCounter) < NUM_AUX_COUNTERS) ? g_AuxCounters[acCounter] : 0)


extern LONG g_AuxCounters[];


# else // IIS_AUX_COUNTERS

# define NUM_AUX_COUNTERS              (0)

# define AcIncrement( acCounter)       (0)    /* do nothing */
# define AcDecrement( acCounter)       (0)    /* do nothing */
# define AcCounter  ( acCounter)       (0)    /* do nothing */

#endif // IIS_AUX_COUNTERS


# endif // _IIS_AUX_COUNTERS_HXX_

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\atq\inc\ntdsa.h ===
/* Copyright 1989-1999 Microsoft Corporation, All Rights Reserved */

#ifndef _ntdsa_h_
#define _ntdsa_h_
#include "ntdsadef.h"

// If you add to this list, be sure and add the corresponding #undef below.
#ifdef MIDL_PASS
#define SIZE_IS(x)      [size_is(x)]
#define SWITCH_IS(x)    [switch_is(x)]
#define SWITCH_TYPE(x)  [switch_type(x)]
#define CASE(x)         [case(x)]
#define VAR_SIZE_ARRAY
#else
#define SIZE_IS(x)
#define SWITCH_IS(x)
#define SWITCH_TYPE(x)
#define CASE(x)
#define VAR_SIZE_ARRAY  (1)
#endif

#ifdef MIDL_PASS
typedef [string] char * SZ;
#else
typedef char * SZ;
#endif

/***************************************************************************
    General Size Limits
***************************************************************************/

#define MAX_ADDRESS_SIZE      256   /* The max size of a DNS address (we hope) */

/***************************************************************************
 *    OSI defs (things to define attributes.)
 ***************************************************************************/

/*
 * Identifies an attribute
 */

typedef ULONG  ATTRTYP;

/*
 * A single attribute value.  This value is set according to the data type
 */

typedef struct ATTVAL{
    ULONG     valLen;                  /* length of attribute value        */
    SIZE_IS(valLen) UCHAR *pVal;     /* value.  May be of any predefined
                                      * type                             */
}ATTRVAL;

/*
 * A bunch of attribute values
 */
typedef struct ATTRVALBLOCK{
    ULONG valCount;                      /* count of values */
    SIZE_IS(valCount) ATTRVAL *pAVal;  /* attribute values */
}ATTRVALBLOCK;



/*
 * An attribute is composed of an attribute type and one
 * or more attribute values.
 */

typedef struct ATTR{
    ATTRTYP   attrTyp;                 /* the attribute type               */
    ATTRVALBLOCK AttrVal;              /* the values */
}ATTR;

/*
 * A block of attributes
 */

typedef struct ATTRBLOCK{
    ULONG attrCount;
    SIZE_IS(attrCount) ATTR *pAttr;
}ATTRBLOCK;

typedef ATTR RDN;

#define MAX_NT4_SID_SIZE 28

typedef struct _NT4SID {
    char Data[MAX_NT4_SID_SIZE];
} NT4SID;

typedef NT4SID *PNT4SID;

/* The Distinguished Name.  The full path name of a directory object,
 * consisting of an ordered sequence of RDNs, stored in accordance with
 * RFC 1779 string DN format (e.g., CN=donh,OU=BSD,O=Microsoft,C=US).
 *
 * To facilitate identity based and security operations, the object's
 * GUID and SID are optionally present in the DSNAME structure.  If
 * present, the GUID is assumed to take precedence over the string name.
 *
 * The NameLen includes all the non-null characters in the string name,
 * but specifically does NOT include the trailing NULL.  However, the
 * total structure size as specified by the structLen should include
 * enough storage for a trailing NULL after the string name.  This means
 * that StringName[NameLen] will always be NULL, and that
 * StringName[NameLen-1] will never be NULL.  Please don't try to compute
 * structure sizes on your own, but instead use the DSNameSizeFromLen
 * macro provided below.
 */

/*
 * The combination ID/name structure
 */
typedef struct _DSNAME {
    ULONG structLen;            /* length of entire DSNAME, in bytes */
    ULONG SidLen;               /* length of the SID, in bytes (0 = none) */
    GUID Guid;                  /* id of this object */
    NT4SID Sid;                 /* SID for this object, if present */
    ULONG NameLen;              /* length of the StringName, in chars */
#ifdef MIDL_PASS
    [size_is(NameLen+1)]        /* Unicode string name - Adding one so that */
        WCHAR StringName[];     /*   terminating NULL is also sent*/
#else
    WCHAR StringName[1];        /* Unicode string name */
#endif
} DSNAME;

typedef DSNAME *PDSNAME;

/*
 * The SizeFromLen macro is a sad commentary on the state of the sizeof
 * operator (which rounds up to allow for padding) and the IDL compiler
 * (which munges empty arrays into 1 sized arrays).
 */
#define DSNameSizeFromLen(x) \
    (sizeof(GUID) + 3*sizeof(ULONG) + sizeof(WCHAR) + sizeof(NT4SID) \
     + (x)*sizeof(WCHAR))
#define DNTFromShortDSName(x) (*((DWORD *)((x)->StringName)))

/*
 * A Generic sized buffer of bytes.
 */

typedef struct OCTET{
    USHORT     len;                      /* length */
    SIZE_IS(len) PUCHAR pVal;      /* pointer to value */
}OCTET;

// The time/date type used by the DS.
typedef LONGLONG DSTIME;

// ENTINF flags

// Read from a writeable copy
#define ENTINF_FROM_MASTER        0x00000001

// Dynamic Object (new in Whistler)
// Only available when fDRA is set (see mdread.c)
#define ENTINF_DYNAMIC_OBJECT     0x00000002

typedef struct _ENTINF
{
    DSNAME           *pName;            // Object name and identity
    ULONG            ulFlags;           // Entry flags
    ATTRBLOCK        AttrBlock;         // The attributes returned.
} ENTINF;

typedef struct _ENTINFLIST
{
    struct _ENTINFLIST   *pNextEntInf;  // linked-list to next entry of info
    ENTINF           Entinf;            // information about this entry
} ENTINFLIST;


// UTF8-encoded, transport-specific DSA address.
typedef struct{
    ULONG  mtx_namelen;          /* Length of the name, incl. null terminator */
#ifdef MIDL_PASS
    [size_is(mtx_namelen)] char mtx_name[];
#else
    char mtx_name[1];
#endif
} MTX_ADDR;
#define MTX_TSIZE(pmtx) (offsetof(MTX_ADDR, mtx_name) + (pmtx)->mtx_namelen)
// NOTE: cch does _not_ include null terminator.
#define MTX_TSIZE_FROM_LEN(cch) (offsetof(MTX_ADDR, mtx_name) + (cch) + 1)


/* An attribute value assertion is composed of an attribute type and value*/

typedef struct AVA{
    ATTRTYP  type;                       /* attribute type           */
    ATTRVAL  Value;                      /* a single attribute value */
}AVA;



/* A list of AVA's */

typedef struct AVALIST{
   struct AVALIST FAR *pNextAVAVal;      /* linked list of AVA's   */
   AVA                  AVAVal;          /* The AVA type and value */
}AVALIST;


/***************************************************************************
 *    Replication-specific structures
 ***************************************************************************/

// Property-Meta-Data:
//      This contains all the replication meta-data associated with a single
//      property of an object.  This data is required for incremental
//      replication as well as per-property propagation dampening.
//
//      attrType - identifies the attribute whose meta-data rest of fields
//          represent.
//      usnProperty - USN corresponding to the last change on the property.
//      dwVersion - Version of the property.
//      timeChanged - Time stamp corresponding to the last change to the
//          property.
//      uuidDsaOriginating - uuid of the DSA that did the last originating
//          write on the property.
//      usnOriginating - USN corresponding to the last originating write in
//          the originating DSA's USN space.


typedef struct _PROPERTY_META_DATA {
    ATTRTYP             attrType;
    DWORD               dwVersion;
    DSTIME              timeChanged;
    UUID                uuidDsaOriginating;
    USN                 usnOriginating;
    USN                 usnProperty;
} PROPERTY_META_DATA;

// Property-Meta-Data-Vector:
//      This is a vector of property-meta-data which holds the meta-data for
//      one or more properties of an object.

typedef struct _PROPERTY_META_DATA_VECTOR_V1 {
    DWORD                   cNumProps;
#ifdef MIDL_PASS
    [size_is(cNumProps)]
        PROPERTY_META_DATA  rgMetaData[];
#else
    PROPERTY_META_DATA  rgMetaData[1];
#endif
} PROPERTY_META_DATA_VECTOR_V1;

typedef struct _PROPERTY_META_DATA_VECTOR {
    DWORD               dwVersion;
    SWITCH_IS(dwVersion) union {
        CASE(1) PROPERTY_META_DATA_VECTOR_V1 V1;
    };
} PROPERTY_META_DATA_VECTOR;

#define MetaDataVecV1SizeFromLen(cNumProps) \
    (offsetof(PROPERTY_META_DATA_VECTOR,V1.rgMetaData[0]) \
     + (cNumProps)*sizeof(PROPERTY_META_DATA))

#define MetaDataVecV1Size(pMetaDataVec) \
    (offsetof(PROPERTY_META_DATA_VECTOR,V1.rgMetaData[0]) \
     + ((pMetaDataVec)->V1.cNumProps)*sizeof(PROPERTY_META_DATA))

#define VALIDATE_META_DATA_VECTOR_VERSION(pVec)         \
    {   if (NULL != (pVec)) {                           \
            Assert(VERSION_V1 == (pVec)->dwVersion);    \
        }                                               \
    }

// Value-Meta-Data
//      This contains all the replication meta-data associated with a single
//      value of a property of an object.  This is the internal version of the
//      metadata: it is not written to disk or transmitted across the wire.
//      Use the EXT form for that.
typedef struct _VALUE_META_DATA {
    DSTIME             timeCreated;
    PROPERTY_META_DATA MetaData;
} VALUE_META_DATA;

// Property-Meta-Data-Ext:
//      This is a trimmed version of property meta data containing only the
//      fields that are required by the remote DSA as part of the replication
//      packet.
typedef struct _PROPERTY_META_DATA_EXT {
    DWORD   dwVersion;
    DSTIME  timeChanged;
    UUID    uuidDsaOriginating;
    USN     usnOriginating;
} PROPERTY_META_DATA_EXT;

// Value-Meta-Data-Ext
// This structure contains the trimmed version of the value meta data
// This structure does not have a version number because it is a fixed
// size: versions may be distinguished by checking the size of the
// structure.
typedef struct _VALUE_META_DATA_EXT_V1 {
    DSTIME                 timeCreated;
    PROPERTY_META_DATA_EXT MetaData;
} VALUE_META_DATA_EXT_V1;

// Shorthand for most current version of structure
typedef VALUE_META_DATA_EXT_V1 VALUE_META_DATA_EXT;

// Property-Meta-Data-Ext-Vector:
//      This is a vector of property-meta-data-ext which holds the trimmed
//      property meta data for one or more properties of an object.
typedef struct _PROPERTY_META_DATA_EXT_VECTOR {
    DWORD                   cNumProps;
#ifdef MIDL_PASS
    [size_is( cNumProps)]
    PROPERTY_META_DATA_EXT  rgMetaData[];
#else
    PROPERTY_META_DATA_EXT  rgMetaData[1];
#endif
} PROPERTY_META_DATA_EXT_VECTOR;


#define MetaDataExtVecSizeFromLen(cNumProps) \
    (offsetof(PROPERTY_META_DATA_EXT_VECTOR,rgMetaData[0]) \
     + (cNumProps)*sizeof(PROPERTY_META_DATA_EXT))

#define MetaDataExtVecSize(pMetaDataVec) \
    (offsetof(PROPERTY_META_DATA_EXT_VECTOR,rgMetaData[0]) \
     + ((pMetaDataVec)->cNumProps)*sizeof(PROPERTY_META_DATA_EXT))


// PARTIAL_ATTR_VECTOR - represents the partial attribute set. This is an array of
//      sorted attids that make the partial set.

typedef struct _PARTIAL_ATTR_VECTOR_V1 {
    DWORD cAttrs;    // count of partial attributes in the array
#ifdef MIDL_PASS
    [size_is(cAttrs)] ATTRTYP rgPartialAttr[];
#else
    ATTRTYP rgPartialAttr[1];
#endif
} PARTIAL_ATTR_VECTOR_V1;

// We need to make sure the start of the union is aligned at an 8 byte
// boundary so that we can freely cast between internal and external
// formats.
typedef struct _PARTIAL_ATTR_VECTOR_INTERNAL {
    DWORD   dwVersion;
    DWORD   dwReserved1;
    SWITCH_IS(dwVersion) union {
        CASE(1) PARTIAL_ATTR_VECTOR_V1 V1;
    };
} PARTIAL_ATTR_VECTOR_INTERNAL;

typedef PARTIAL_ATTR_VECTOR_INTERNAL PARTIAL_ATTR_VECTOR;

#define PartialAttrVecV1SizeFromLen(cAttrs) \
    (offsetof(PARTIAL_ATTR_VECTOR, V1.rgPartialAttr[0]) \
     + (cAttrs)*sizeof(ATTRTYP))

#define PartialAttrVecV1Size(pPartialAttrVec) \
    (offsetof(PARTIAL_ATTR_VECTOR, V1.rgPartialAttr[0]) \
     + ((pPartialAttrVec)->V1.cAttrs) * sizeof(ATTRTYP))

typedef struct _PARTIAL_ATTR_VECTOR_V1_EXT {
    DWORD               dwVersion;
    DWORD               dwReserved1;
    DWORD               cAttrs;
#ifdef MIDL_PASS
    [size_is(cAttrs)] ATTRTYP rgPartialAttr[];
#else
    ATTRTYP rgPartialAttr[1];
#endif
} PARTIAL_ATTR_VECTOR_V1_EXT;

#define VALIDATE_PARTIAL_ATTR_VECTOR_VERSION(pVec)      \
    {   if (NULL != (pVec)) {                           \
            Assert(VERSION_V1 == (pVec)->dwVersion);    \
        }                                               \
    }


// USN Vector.  Replication session state.  Tracks the state of the last
//      replication session between a given pair of DSAs.

typedef struct _USN_VECTOR {
    USN         usnHighObjUpdate;
    USN         usnReserved;    // was usnHighObjCreate; not used post beta-2
    USN         usnHighPropUpdate;
} USN_VECTOR;


// Up-to-date vector.  This vector indicates the last changes each side of a
//      GetNCChanges() call saw from its neighbors.  This information, in turn,
//      is used to filter out items that do not need to be transmitted.

typedef struct _UPTODATE_CURSOR_V1 {
    UUID uuidDsa;
    USN  usnHighPropUpdate;
} UPTODATE_CURSOR_V1;

#ifdef __cplusplus
    // _UPTODATE_CURSOR_V2 inherits from _UPTODATE_CURSOR_V1 using
    // genuine C++ inheritance.
    typedef struct _UPTODATE_CURSOR_V2 : _UPTODATE_CURSOR_V1 {
#else
    // _UPTODATE_CURSOR_V2 inherits from _UPTODATE_CURSOR_V1 using
    // Microsoft's "Anonymous Structure" C language extension.
    typedef struct _UPTODATE_CURSOR_V2 {
        #ifdef MIDL_PASS
            struct  _UPTODATE_CURSOR_V1 v1;
        #else
            struct  _UPTODATE_CURSOR_V1;
        #endif
#endif
        DSTIME  timeLastSyncSuccess;
    } UPTODATE_CURSOR_V2;

typedef struct _UPTODATE_VECTOR_V1 {
    DWORD               cNumCursors;
    DWORD               dwReserved2;
    SIZE_IS(cNumCursors) UPTODATE_CURSOR_V1 rgCursors[VAR_SIZE_ARRAY];
} UPTODATE_VECTOR_V1;

typedef struct _UPTODATE_VECTOR_V2 {
    DWORD               cNumCursors;
    DWORD               dwReserved2;
    SIZE_IS(cNumCursors) UPTODATE_CURSOR_V2 rgCursors[VAR_SIZE_ARRAY];
} UPTODATE_VECTOR_V2;

typedef struct _UPTODATE_VECTOR {
    DWORD   dwVersion;
    DWORD   dwReserved1;
    SWITCH_IS(dwVersion) union {
        CASE(1) UPTODATE_VECTOR_V1 V1;
        CASE(2) UPTODATE_VECTOR_V2 V2;
    };
} UPTODATE_VECTOR;

#define UpToDateVecV1SizeFromLen(cNumCursors)  \
    (offsetof(UPTODATE_VECTOR,V1.rgCursors[0]) \
     + (cNumCursors)*sizeof(UPTODATE_CURSOR_V1))

#define UpToDateVecV2SizeFromLen(cNumCursors)  \
    (offsetof(UPTODATE_VECTOR,V2.rgCursors[0]) \
     + (cNumCursors)*sizeof(UPTODATE_CURSOR_V2))

#define UpToDateVecV1Size(putodvec) \
    (offsetof(UPTODATE_VECTOR,V1.rgCursors[0]) \
     + ((putodvec)->V1.cNumCursors)*sizeof(UPTODATE_CURSOR_V1))

#define UpToDateVecV2Size(putodvec) \
    (offsetof(UPTODATE_VECTOR,V2.rgCursors[0]) \
     + ((putodvec)->V2.cNumCursors)*sizeof(UPTODATE_CURSOR_V2))

#define UpToDateVecSize(putodvec) \
    ((2 == (putodvec)->dwVersion) \
     ? UpToDateVecV2Size(putodvec) \
     : UpToDateVecV1Size(putodvec))

// Native UTD types/macros.  These must be updated if the native (internally
// used) type is changed from Vx to Vy.
typedef UPTODATE_CURSOR_V2 UPTODATE_CURSOR_NATIVE;
typedef UPTODATE_VECTOR_V2 UPTODATE_VECTOR_NATIVE;
#define UPTODATE_VECTOR_NATIVE_VERSION (2)
#define UpToDateVecVNSizeFromLen(cNumCursors) UpToDateVecV2SizeFromLen(cNumCursors)
    

// MIDL doesn't like marshalling the definition of UPTODATE_VECTOR. So, we are
// keeping strucurally identical but a simpler looking version-specific
// definitions of UPTODATE_VECTOR for marshalling.  Castings between
// UPTODATE_VECTOR and UPTODATE_VECTOR_Vx_EXT are perfectly valid as long as
// dwVersion == x.
// Note:-
// We need the Reserved1 & Reserved2 variables to account for alignment.
// The internal form gets an 8 byte alignment due to the _int64 field in
// the UPTODATE_CURSOR. So, unless we account for this alignment through
// dummy variables, we can't freely cast back & forth between the internal
// and external versions.
typedef struct _UPTODATE_VECTOR_V1_EXT {
    DWORD               dwVersion;
    DWORD               dwReserved1;
    DWORD               cNumCursors;
    DWORD               dwReserved2;
    SIZE_IS(cNumCursors) UPTODATE_CURSOR_V1 rgCursors[VAR_SIZE_ARRAY];
} UPTODATE_VECTOR_V1_EXT;

typedef struct _UPTODATE_VECTOR_V2_EXT {
    DWORD               dwVersion;
    DWORD               dwReserved1;
    DWORD               cNumCursors;
    DWORD               dwReserved2;
    SIZE_IS(cNumCursors) UPTODATE_CURSOR_V2 rgCursors[VAR_SIZE_ARRAY];
} UPTODATE_VECTOR_V2_EXT;

#ifdef MIDL_PASS
typedef UPTODATE_VECTOR_V1_EXT UPTODATE_VECTOR_V1_WIRE;
typedef UPTODATE_VECTOR_V2_EXT UPTODATE_VECTOR_V2_WIRE;
#else
typedef UPTODATE_VECTOR UPTODATE_VECTOR_V1_WIRE;
typedef UPTODATE_VECTOR UPTODATE_VECTOR_V2_WIRE;
#endif


#define IS_VALID_UPTODATE_VECTOR(x) \
    ((1 == (x)->dwVersion) || (2 == (x)->dwVersion))

#define IS_NULL_OR_VALID_UPTODATE_VECTOR(x) \
    ((NULL == (x)) || IS_VALID_UPTODATE_VECTOR(x))

#define IS_VALID_NATIVE_UPTODATE_VECTOR(x) \
    (UPTODATE_VECTOR_NATIVE_VERSION == (x)->dwVersion)

#define IS_NULL_OR_VALID_NATIVE_UPTODATE_VECTOR(x) \
    ((NULL == (x)) || IS_VALID_NATIVE_UPTODATE_VECTOR(x))


// Following version definitions are probably unnecessary. But it shows
// explicitly through a constant that our versions start from 1 not 0.
#define VERSION_V1 (1)
#define VERSION_V2 (2)
#define VERSION_V3 (3)


// This is the structure used to set periodic replication times, each bit
// represents a 15 minute period, 8 bits* 84 bytes * 15 mins = a week
typedef struct _repltimes {
    UCHAR rgTimes[84];
} REPLTIMES;


// REPLENTINFLIST:  Similar to ENTINFLIST except it also has additional fields
//      for holding incremental replication and name space reconciliation
//      fields.
typedef struct _REPLENTINFLIST {
    struct _REPLENTINFLIST *
                pNextEntInf;    // linked-list to the next entry info
    ENTINF      Entinf;         // all the old repl info alongwith shipped
                                //      attributes
    BOOL        fIsNCPrefix;    // is this object the NC prefix?
    GUID *      pParentGuid;    // points to parent guid while replicating
                                //      renames; NULL otherwise
    PROPERTY_META_DATA_EXT_VECTOR *
                pMetaDataExt;   // pointer to the meta-data to be shipped
} REPLENTINFLIST;

// REPLVALINF: describe a single value change for replication
typedef struct _REPLVALINF {
    PDSNAME pObject;                // containing object
    ATTRTYP attrTyp;                // containing attribute
    ATTRVAL Aval;                   // The value itself
    BOOL fIsPresent;                // adding or removing?
    VALUE_META_DATA_EXT MetaData;   // Originating info
} REPLVALINF;


// DRS_EXTENSIONS is an arbitrary byte array describing the capabilities and
// other state information for a particular server.  Exchanged at bind
// time, the structure allows client and server to negotiate a compatible
// protocol.
typedef struct _DRS_EXTENSIONS {
    DWORD cb;    // length of rgb field (not of entire struct)
#ifdef MIDL_PASS
    [size_is(cb)] BYTE rgb[];
#else
    BYTE rgb[1];
#endif
} DRS_EXTENSIONS, *PDRS_EXTENSIONS;


// DRS_EXTENSIONS_INT is the data structure described by the DRS_EXTENSIONS byte
// array.  This array can be safely extended by adding additional fields onto
// the end (but not anywhere else).
//
// Parts of the extension are carried in the variable-length mail-based
// replication header. If you extend this structure, please examine
// dramail.h structure definition and dramail.c get/set extensions routines
// and consider whether your new information should be carried there as well.
//
// PORTABILITY WARNING: Since this structure is marshalled as a byte array,
// big-endian machines will need to do local byte-swapping.
typedef struct _DRS_EXTENSIONS_INT {
    DWORD cb;           // set to sizeof(DRS_EXTENSIONS_INT) - sizeof(DWORD)
    DWORD dwFlags;      // various DRS_EXT_* bits
    UUID  SiteObjGuid;  // objectGuid of owning DSA's site object
    INT   pid;          // process id of client (used to facilitate leak trking)
    DWORD dwReplEpoch;  // replication epoch (for domain rename)

    // If you extend this structure, see SITE_GUID_FROM_DRS_EXT() for an example
    // of how to safely extract your new field's data.
} DRS_EXTENSIONS_INT;

// To define an extension, add an entry to the following enumeration just
// above DRS_EXT_MAX.

// NOTE: If you add/remove extensions, please make corresponding updates to the
// structure in Dump_BHCache() in dsexts\md.c.
typedef enum {
    DRS_EXT_BASE = 0,

    // Bits for DRS_EXTENSIONS_DATA Flags field.
    DRS_EXT_ASYNCREPL,      // supports DRS_MSG_REPADD_V2, DRS_MSG_GETCHGREQ_V2
    DRS_EXT_REMOVEAPI,      // supports RemoveDsServer, RemoveDsDomain
    DRS_EXT_MOVEREQ_V2,     // supports DRS_MOVEREQ_V2
    DRS_EXT_GETCHG_COMPRESS,// supports DRS_MSG_GETCHGREPLY_V2
    DRS_EXT_DCINFO_V1,      // supports DS_DOMAIN_CONTROLLER_INFO_1
    DRS_EXT_RESTORE_USN_OPTIMIZATION,
        // supports bookmark optimizations on restore to avoid full syncs
    DRS_EXT_ADDENTRY,       // supports remoted AddEntry, v1
    DRS_EXT_KCC_EXECUTE,    // supports IDL_DRSExecuteKCC
    DRS_EXT_ADDENTRY_V2,    // supports remoted AddEntry, v2
    DRS_EXT_LINKED_VALUE_REPLICATION, // LVR supported AND enabled
    DRS_EXT_DCINFO_V2,      // supports DS_DOMAIN_CONTROLLER_INFO_2
    DRS_EXT_INSTANCE_TYPE_NOT_REQ_ON_MOD,
        // inbound repl doesn't require instance type in repl stream for mods
    DRS_EXT_CRYPTO_BIND,    // supports RPC session key setup on bind
    DRS_EXT_GET_REPL_INFO,  // supports IDL_DRSGetReplInfo
    DRS_EXT_STRONG_ENCRYPTION,
        // supports additional 128 bit encryption for passwords over the wire
    DRS_EXT_DCINFO_VFFFFFFFF,
        // supports DS_DOMAIN_CONTROLLER_INFO_FFFFFFFF
    DRS_EXT_TRANSITIVE_MEMBERSHIP,
        // supports transitive membership expansion at G.C
    DRS_EXT_ADD_SID_HISTORY,// supports DRS_MSG_ADDSIDREQ
    DRS_EXT_POST_BETA3,     // supports sending/receiving schema info,
                            //  DS_REPL_INFO_KCC_DSA_*_FAILURES,
                            //  and DS_REPL_PENDING_OPSW
    DRS_EXT_GETCHGREQ_V5,   // supports DRS_MSG_GETCHGREQ_V5
    DRS_EXT_GETMEMBERSHIPS2,   // supports DRS_MSG_GETMEMBERSHIPS2
    DRS_EXT_GETCHGREQ_V6,   // supports DRS_MSG_GETCHGREQ_V6
    DRS_EXT_NONDOMAIN_NCS,  // understands non-domain NCs
    DRS_EXT_GETCHGREQ_V8,   // supports DRS_MSG_GETCHGREQ_V8
    DRS_EXT_GETCHGREPLY_V5, // supports DRS_MSG_GETCHGREPLY_V5
    DRS_EXT_GETCHGREPLY_V6, // supports DRS_MSG_GETCHGREPLY_V6   
    DRS_EXT_WHISTLER_BETA3, // supports DRS_MSG_ADDENTRYREPLY_V3, 
                            //          DRS_MSG_REPVERIFYOBJ
                            //          DRS_MSG_GETCHGREPLY_V7
    DRS_EXT_XPRESS_COMPRESSION, // supports the Xpress compression library
    //    NO MORE BITS AVAILABLE
    // BUGBUG Either this flag DRS_EXT_RESERVED_FOR_WIN2K_PART2 or the 
    //        DRS_EXT_LAST_FLAG (preferred if it can be used) will need
    //        to be used to signal to use the extended extension bits
    //        that you'll have to create if you want a new extension bit! :)
    DRS_EXT_RESERVED_FOR_WIN2K_PART1,
    DRS_EXT_RESERVED_FOR_WIN2K_PART2, // 30
    //
    // AND DON'T FORGET TO UPDATE UTIL\REPADMIN\REPDSREP.C and DSEXTS\MD.C!
    //
    DRS_EXT_LAST_FLAG = 31,

    // Bits to hold site guid.
    DRS_EXT_SITEGUID_BEGIN = 32,
    DRS_EXT_SITEGUID_END = DRS_EXT_SITEGUID_BEGIN + sizeof(GUID)*8 - 1,

    // Bits to hold client process ID (to facilitate leak tracking).
    DRS_EXT_PID_BEGIN,
    DRS_EXT_PID_END = DRS_EXT_PID_BEGIN + sizeof(int)*8 - 1,

    // Bits to hold replication epoch.
    DRS_EXT_EPOCH_BEGIN,
    DRS_EXT_EPOCH_END = DRS_EXT_EPOCH_BEGIN + sizeof(DWORD)*8 - 1,

    DRS_EXT_MAX
} DRS_EXT;

// We decided that it'd be better self-documenting code if we tied
// this paticular bit BETA3 to conceptual bits describing what they
// do.  This makes code/repadmin/dsexts/everything much more clear.
// If someone is passionate enough, they could make DRS_EXT_POST_BETA2
// into a similar breakdown.
#define DRS_EXT_ADDENTRYREPLY_V3    DRS_EXT_WHISTLER_BETA3
#define DRS_EXT_GETCHGREPLY_V7      DRS_EXT_WHISTLER_BETA3
#define DRS_EXT_VERIFY_OBJECT       DRS_EXT_WHISTLER_BETA3


// Maximum length in bytes of an extensions _string_ containing any bits we care
// about.  (Incoming strings can be longer if they come from an up-level DSA,
// but if so the extra bytes contain bits for extensions we don't know about, so
// we need not store them.)
#define CURR_MAX_DRS_EXT_FIELD_LEN (1 + ((DRS_EXT_MAX - 1)/ sizeof(BYTE)))

// Maximum length in bytes of an extensions _structure_ containing any bits we
// care about.
#define CURR_MAX_DRS_EXT_STRUCT_SIZE \
    (sizeof(DWORD) + CURR_MAX_DRS_EXT_FIELD_LEN)

// Length in bytes of the given extensions structure.
#define DrsExtSize(pext) ((pext) ? sizeof(DWORD) + (pext)->cb : 0)

// Is the specified extension supported in the given DRS_EXTENSIONS set?
#define IS_DRS_EXT_SUPPORTED(pext, x)                   \
    ((NULL != (pext))                                   \
     && ( (pext)->cb >= 1+((x)/8) )                     \
     && ( 0 != ( (pext)->rgb[(x)/8] & (1<<((x)%8) ))))

// Get a pointer to the dwReplEpoch for a DSA given its DRS_EXTENSIONS, or 0
// if unavailable.
#define REPL_EPOCH_FROM_DRS_EXT(pext)                               \
    (((NULL == (pext))                                              \
      || ((pext)->cb < offsetof(DRS_EXTENSIONS_INT, dwReplEpoch)    \
                       + sizeof(DWORD)   /* dwReplEpoch */          \
                       - sizeof(DWORD))) /* cb */                   \
     ? 0                                                            \
     : ((DRS_EXTENSIONS_INT *)(pext))->dwReplEpoch)

// Get a pointer to the site objectGuid for a DSA given its DRS_EXTENSIONS, or
// NULL if unavailable.
#define SITE_GUID_FROM_DRS_EXT(pext)                                \
    (((NULL == (pext))                                              \
      || ((pext)->cb < offsetof(DRS_EXTENSIONS_INT, SiteObjGuid)    \
                       + sizeof(GUID)    /* SitObjGuid */           \
                       - sizeof(DWORD))) /* cb */                   \
     ? NULL                                                         \
     : &((DRS_EXTENSIONS_INT *)(pext))->SiteObjGuid)

// Given the DRS extensions for a given DSA, determine whether it's in the
// given site.  If a definite determination cannot be made, errs on the side
// of "same site."
#define IS_REMOTE_DSA_IN_SITE(pext, pSiteDN)        \
    ((NULL == (pSiteDN))                            \
     || fNullUuid(&(pSiteDN)->Guid)                 \
     || fNullUuid(SITE_GUID_FROM_DRS_EXT(pext))     \
     || (0 == memcmp(&(pSiteDN)->Guid,              \
                     SITE_GUID_FROM_DRS_EXT(pext),  \
                     sizeof(GUID))))



// Destination can support linked value replication data
// Does the DSA support linked value replication
#define IS_LINKED_VALUE_REPLICATION_SUPPORTED(pext) IS_DRS_EXT_SUPPORTED(pext, DRS_EXT_LINKED_VALUE_REPLICATION)

// Safely set extension as supported
#define SET_DRS_EXT_SUPPORTED(pext, x) \
{ \
      if ( (NULL != (pext)) && ( (pext)->cb >= 1+((x)/8) ) )  \
            (pext)->rgb[(x)/8] |= (1<<((x)%8)); \
      }


// Schema prefix table.

typedef struct OID_s {
    unsigned length;
#ifdef MIDL_PASS
    [size_is(length)] BYTE * elements;
#else
    BYTE  * elements;
#endif
} OID_t;

typedef struct {
    DWORD       ndx;
    OID_t       prefix;
} PrefixTableEntry;

typedef struct {
    DWORD PrefixCount;
    SIZE_IS(PrefixCount)
        PrefixTableEntry *  pPrefixEntry;
} SCHEMA_PREFIX_TABLE;

//
// This begins the on the wire representation of the thread state error
// NOTE: if the DIRERR struct is changed then you should increment the
// version of the DRS_Error_Data_V1 and make a function that can convert
// and package and unpackage the error state.  See:
//      DRS_SetDirErr_SemiDeepCopy() and
//      DRS_THError_SemiDeepCopy()
//

typedef struct _NAMERESOP_DRS_WIRE_V1
{
    UCHAR   nameRes;        /*  status of name resolution.
                             *  Valid values:
                             *    - OP_NAMERES_NOT_STARTED
                             *    - OP_NAMERES_PROCEEDING
                             *    - OP_NAMERES_COMPLETED
                             */
    UCHAR   unusedPad;
    USHORT  nextRDN;        /*  index to the next part of the name to be
                             *  resolved.  This parm only has meaning
                             *  if the operation is proceeding.
                             */
} NAMERESOP_DRS_WIRE_V1;

typedef struct ANYSTRINGLIST_DRS_WIRE_V1{       /* A list of substrings to match */
    struct ANYSTRINGLIST_DRS_WIRE_V1 FAR *pNextAnyVal;
    ATTRVAL AnyVal;
}ANYSTRINGLIST_DRS_WIRE_V1;

typedef struct SUBSTRING_DRS_WIRE_V1{
    ATTRTYP type;                  /* The type of attribute */
    BOOL    initialProvided;       /* If true an initial sub is provided*/
    ATTRVAL InitialVal;            /* The initial substring (str*) to match */
    struct AnyVal_DRS_WIRE_V1{
        USHORT count;              /* The # of subs (*str1*str2*) to match*/
        ANYSTRINGLIST_DRS_WIRE_V1 FirstAnyVal; /* a list of substrings to match */
    }AnyVal_DRS_WIRE_V1;
    BOOL    finalProvided;         /* If true an final sub  is provided*/
    ATTRVAL FinalVal;              /* The final substring (str*) to match */
}SUBSTRING_DRS_WIRE_V1;

/**************************************************************************
 *    Error Data Structures
 **************************************************************************/

// Obviously this is now an external format error.
typedef struct INTERNAL_FORMAT_PROBLEM_DRS_WIRE_V1
{
    DWORD                   dsid;
    DWORD                   extendedErr;  /* Non-standard error code */
    DWORD                   extendedData;   /* extra data to go with it */
    USHORT                  problem;      /* Attribute problem type,
                                           * valid values defined above
                                           */
    ATTRTYP                 type;         /* the offending attribute type */
    BOOL                    valReturned;  /* indicates that an attribute
                                           * value follows
                                           */
    ATTRVAL                 Val;          /* optionally supplied offending
                                           * att value
                                           */
} INTFORMPROB_DRS_WIRE_V1;

typedef struct _PROBLEMLIST_DRS_WIRE_V1
{
    struct _PROBLEMLIST_DRS_WIRE_V1 FAR *pNextProblem; /* linked-list to next prob att */
    INTFORMPROB_DRS_WIRE_V1 intprob;
} PROBLEMLIST_DRS_WIRE_V1;



/*  The referral is an indication from a DSA that it was unable to
 *  complete the operation because of either client specified
 *  restrictions or because some DSA's are unavailable.  It provides
 *  information as to the state of the operation and a list of other
 *  DSA's that may be able to satisfy the request.
 *
 *  To continue the request, the client must bind to each referred DSA
 *  and attempt the same operation.  They must specify the CONTREF.target
 *  object name as the search object name. (This may be different from
 *  the original object name because of alias dereferencing.)  The
 *  operation state (opstate) on the common arguments (COMMARG) must be
 *  set from the operation state on the continuation reference CONTREF.
 *  The aliasRDN of the common arguments must be set from the aliasRDN of
 *  the continuation reference.
 */

typedef UNICODE_STRING DSA_ADDRESS;
typedef struct _DSA_ADDRESS_LIST_DRS_WIRE_V1 {
    struct _DSA_ADDRESS_LIST_DRS_WIRE_V1 *   pNextAddress;
    // For ease marshalling I turned this into a pointer, so this is
    // not exactly like the original.
    DSA_ADDRESS *                            pAddress;
} DSA_ADDRESS_LIST_DRS_WIRE_V1;

/*  The continuation referrence is returned on a referral to other DSA's
    for the completion of an operation.  The reference contains the name
    of the desired directory object, the state of the partially completed
    operation, some support information that is used to continue and a
    list of other DSA's to contact.
*/

#define CH_REFTYPE_SUPERIOR     0
#define CH_REFTYPE_SUBORDINATE  1
#define CH_REFTYPE_NSSR         2
#define CH_REFTYPE_CROSS        3

typedef struct CONTREF_DRS_WIRE_V1
{
    PDSNAME                         pTarget;        /* target name in continuing operation */
    NAMERESOP_DRS_WIRE_V1           OpState;        /* operation status */
    USHORT                          aliasRDN;       /* # of RDN's produced by dereferencing */
    USHORT                          RDNsInternal;   /* reserved */
    USHORT                          refType;        /* reserved */
    USHORT                          count;          /* number of access points */
    DSA_ADDRESS_LIST_DRS_WIRE_V1 *  pDAL;           /* linked list of access points */
    struct CONTREF_DRS_WIRE_V1 *    pNextContRef;   /* linked list of CRs */
    
    // NOTE: This is assumed to be NULL, and is skipped.  For the purposes
    // of IDL_DRSAddEntry() we won't get a referral with a Filter.  However, if
    // someone did a remote search type thing, then they could get a filter in
    // the thread state error, and then they'd have to update the existing DRS
    // thread state packaging routines to account for and package up the filter.
    // PFILTER_DRS_WIRE_V1             pNewFilter;     /* new filter (optional) */

    BOOL                            bNewChoice;     /* is a new choice present? */
    UCHAR                           choice;         /* new search choice (optional) */
} CONTREF_DRS_WIRE_V1;

/* These are the seven problem types wire versions, for more   */ 
/* information about each kind look lower to the type without  */
/* the _DRS_WIRE_V1 appended                                   */

typedef struct ATRERR_DRS_WIRE_V1
{
    PDSNAME                    pObject;        /* name of the offending object */
    ULONG                      count;          /* the number of attribute errors */
    PROBLEMLIST_DRS_WIRE_V1    FirstProblem;   /* a linked-list of attribute errors */
} ATRERR_DRS_WIRE_V1;

typedef struct NAMERR_DRS_WIRE_V1
{
    DWORD       dsid;
    DWORD       extendedErr;    /* Non-standard error code */
    DWORD       extendedData;   /* extra data to go with it */
    USHORT      problem;        /* The type of name problem, valid values
                                 * defined above. */
    PDSNAME     pMatched;       /*  the closest name match  */
} NAMERR_DRS_WIRE_V1;

typedef struct REFERR_DRS_WIRE_V1
{
    DWORD                dsid;
    DWORD                extendedErr;        /* Non-standard error code */
    DWORD                extendedData;   /* extra data to go with it */
    CONTREF_DRS_WIRE_V1  Refer;                 /* alternate DSAs to contact */
} REFERR_DRS_WIRE_V1;

typedef struct _SECERR_DRS_WIRE_V1
{
    DWORD      dsid;
    DWORD      extendedErr;    /* Non-standard error code */
    DWORD      extendedData;   /* extra data to go with it */
    USHORT     problem;        /* Problems, valid values defined above */
} SECERR_DRS_WIRE_V1;

typedef struct _SVCERR_DRS_WIRE_V1
{
    DWORD      dsid;
    DWORD      extendedErr;    /* Non-standard error code */
    DWORD      extendedData;   /* extra data to go with it */
    USHORT     problem;        /* Problems, valid values defined above */
} SVCERR_DRS_WIRE_V1;

typedef struct _UPDERR_DRS_WIRE_V1
{
    DWORD      dsid;
    DWORD      extendedErr;    /* Non-standard error code */
    DWORD      extendedData;   /* extra data to go with it */
    USHORT     problem;        /* Problems, valid values defined above */
} UPDERR_DRS_WIRE_V1;

typedef struct _SYSERR_DRS_WIRE_V1
{
    DWORD      dsid;
    DWORD      extendedErr;
    DWORD      extendedData;   /* extra data to go with it */
    USHORT     problem;
} SYSERR_DRS_WIRE_V1;


/* This is the number of errors alloted per return code type. */

#define   DIR_ERROR_BASE      1000

/* These error defines correspond to API return codes. */

#define attributeError      1   /* attribute error */
#define nameError           2   /* name error */
#define referralError       3   /* referral error */
#define securityError       4   /* security error */
#define serviceError        5   /* service error */
#define updError            6   /* update error */
#define systemError         7   /* system error */

/*

    This is the wire version of the mail DIRERR info for transfering the
    thread state error.  If changes need to be made, then all structures
    above the structure will need to change to a version 2.  So for 
    instances if you changed the referral error to include the pFilter
    which it doesn't (in V1) have, then the below RefErr element would be
    of type REFERR_DRS_WIRE_V2, while the rest could remain unchanged.  
    CONTREF_DRS_WIRE_V1 would goto V2 as well.
    
    Then the encoding and decoding routines in dramderr.c would need to
    be updated to handle the different versions, and set the dwErrVer 
    correctly in the using routines, and marshall/translate/set the
    pErrData correctly depending on the new version.
    
*/    
typedef SWITCH_TYPE(DWORD) union _DIRERR_DRS_WIRE_V1
{
    CASE(attributeError) ATRERR_DRS_WIRE_V1  AtrErr;  /* attribute error */
    CASE(nameError)      NAMERR_DRS_WIRE_V1  NamErr;  /* name error      */
    CASE(referralError)  REFERR_DRS_WIRE_V1  RefErr;  /* referral error  */
    CASE(securityError)  SECERR_DRS_WIRE_V1  SecErr;  /* security error  */
    CASE(serviceError)   SVCERR_DRS_WIRE_V1  SvcErr;  /* service error   */
    CASE(updError)       UPDERR_DRS_WIRE_V1  UpdErr;  /* update error    */
    CASE(systemError)    SYSERR_DRS_WIRE_V1  SysErr;  /* system error    */
} DIRERR_DRS_WIRE_V1;


/***************************************************************************

    NOTHING BELOW THIS LINE WILL BE INCLUDED IN THE MIDL COMPILATION STAGE!

 ***************************************************************************/
#ifndef MIDL_PASS

/* Turn off the warning about the zero-sized array. */
#pragma warning (disable: 4200)




/***************************************************************************
 *    Filter Definitions
 ***************************************************************************/


typedef struct ANYSTRINGLIST{       /* A list of substrings to match */
    struct ANYSTRINGLIST FAR *pNextAnyVal;
    ATTRVAL AnyVal;
}ANYSTRINGLIST;

typedef struct SUBSTRING{
    ATTRTYP type;                  /* The type of attribute */
    BOOL    initialProvided;       /* If true an initial sub is provided*/
    ATTRVAL InitialVal;            /* The initial substring (str*) to match */
    struct AnyVal{
        USHORT count;              /* The # of subs (*str1*str2*) to match*/
        ANYSTRINGLIST FirstAnyVal; /* a list of substrings to match */
    }AnyVal;
    BOOL    finalProvided;         /* If true an final sub  is provided*/
    ATTRVAL FinalVal;              /* The final substring (str*) to match */
}SUBSTRING;


/* A filter item indicates a logical test of an AVA.  This means that
 * the provided attribute value should have one of these test performed
 * against the attribute value found on the directory object.
 */

typedef struct FILITEM{
    UCHAR   choice;                /* The type of operator:
                                    * Valid values defined in filtypes.h
                                    */
    struct FilTypes{
        AVA           ava;         /* contain the value for all binary relops */
        SUBSTRING FAR *pSubstring; /* substring match             */
        ATTRTYP       present;     /* attribute presence on entry */
        BOOL          *pbSkip;     /* when evaling filter, dont read from DB */
                                   /* Set to false for security purposes */
    }FilTypes;

    DWORD             expectedSize; /* The estimated size of this Filter Item */
                                    /* Zero means not estimated */
}FILITEM;



/* This is a linked list of filters that are either Anded or Orded together.*/

struct FilterSet{
    USHORT              count;         /* number of items in linked-set */
    struct FILTER FAR * pFirstFilter;  /* first filter in set */
};




/* The filter is used to construct an arbitrary logical test of a
 *   directory object.  It consists of either a single item (see
 *   FILIITEM above) which is a test of a single attribute,
 *   a set of attribute tests (FilterSet) Anded or Ored together,
 *   or a negation of a test or an attribute set.
 *
 *   The following examples should illustrate how filter structures work.
 *   Actual attribute names and values are omitted to simplify the examples.
 *
 *   EXAMPLE:
 *
 *        A = 5
 *
 *        item
 *        ------
 *       | A=5  |
 *        ------
 *  ___________________________________________________________________________
 *
 *        (A = 5) and (b = ab) and (c = 2)
 *
 *        AND set            item            item            item
 *        -------- first    ------ next     ------ next     ------
 *       | 3 items|---->   | A=5  |---->   | b=ab |---->   | c=2  |
 *        -------- filter   ------ filter   ------ filter   ------
 *  ___________________________________________________________________________
 *
 *        (A = 5) and ((b = "abc") or (c = 2)) and (d <=1)
 *
 *        AND set            item           OR set           item
 *        -------- first    ------ next     -------- next    ------
 *       | 3 items|---->   | A=5  |---->   | 2 items|--->   | d<=1 |
 *        -------- filter   ------ filter   -------- filter  ------
 *                                                 |
 *                                           first | filter
 *                                                 V
 *                                                item          item
 *                                             -------- next    ------
 *                                            | b="abc"|---->  | c=2  |
 *                                             -------- filter  ------
 *
 */

typedef struct FILTER{
    struct FILTER FAR *pNextFilter;  /* points to next filter in set */
    UCHAR   choice;                      /* filter type
                                          * Valid values defined in filtypes.h
                                          */
    struct _FilterTypes{                          /* based on the choice */
        FILITEM           Item;
        struct FilterSet  And;
        struct FilterSet  Or;
        struct FILTER FAR *pNot;
    }FilterTypes;
}FILTER;

typedef FILTER FAR *PFILTER;

typedef ULONG MessageId;

/* The service control structure allows the client to control how
 *    directory operations are performed.
 *
 * Prefer chaining indicates that the client perfers that distributed
 *    operations are chained rather than referred.  This does not guarantee
 *    what type of distribution may actually be used.
 *
 * ChainingProhibited stops the DSA from contacting other DSA's if the
 *    information needed to satisfy the operation resides in another DSA.
 *    Instead it will construct a referral list of DSA's for the
 *    client to contact directly. This gives the client control over the cost
 *    of a distributed operation.
 *
 * Local scope tells the DSA to only contact DSA's that are nearby
 *    (perhaps even on the same subnet) if it can't complete
 *    an operation alone.  The client may receive a referral list
 *    of other DSA's to contact if the operation couldn't be satisfied by
 *    the local set of DSA's.  This flag lets the client limit the cost of
 *    an operation by prohibiting contact to DSA's that are expensive to reach.
 *
 * DontUseCopy tells the directory that the target of the operation
 *    is the master object.  This is used when the client (usually an
 *    administrator) needs the up-to-date version of a directory object.
 *
 * DerefAliasFlag tells the directory what kind of aliases to dereference.
 *    Valid values are:
 *    DA_NEVER - never deref aliases
 *    DA_SEARCHING - deref when searching, but not for locating the base
 *                   of the search.
 *    DA_BASE - deref in locating the base of the search, but not while s
 *              searching
 *    DA_ALWAYS - always deref aliases.
 *
 * MakeDeletionsAvail is used by the internal synchronization process only.
 *    It makes visible objects that have been deleted but not yet physically
 *    removed from the system.
 *
 * DontPerformSearchOp is used to get Search Statistics from the DS using the
 *    LDAP STATS control. There are two options:
 *      a) optimize the search query and return expected number of operations
 *         without visiting the actual entries on the disk
 *      b) perform the query, but instead of returning the real data, return
 *         statistics for the query performed
 *
 * pGCVerifyHint - The DS verifies all DSNAME-valued properties for existence
 *    either against itself if it holds the naming context in question, or
 *    against a GC if not.  There are cases where apps need to add an object O1
 *    on machine M1 and then immediately thereafter add a reference to O1 on
 *    object O2 on machine M2.  M2 will fail the O1 verification check if
 *    it doesn't hold O1's NC and its choice of GC is not M1, or if it does
 *    hold O1's NC but isn't the replica where O1 was just added.  This field
 *    allows a client to tell the DS which machine to perform DSNAME
 *    verification against.  This hint is unilateral and unconditional in that
 *    if specified, all DSNAME-valued properties will be verified at the
 *    specified machine and no where else, not even locally.  Best results
 *    are obtained when the value is the DNS host name for a DC, though other
 *    forms of names may work in certain environments.
 *
 *   NOTE: The omission of the SVCCNTL (null pointer) parameter will default
 *   to no preference for chaining, chaining not prohibited, no limit on the
 *   scope of operation, use of a copy permitted, aliases will be dereferenced,
 *   a copy can not be updated and deletions will not be visible.
 */


typedef struct SVCCNTL
{
    ULONG SecurityDescriptorFlags;    /*  flags describing what part  */
                                      /*  of the SD to read.          */
    unsigned DerefAliasFlag:2;        /*  don't dereference an alias  */
    BOOL preferChaining:1;            /*  chaining is preferred       */
    BOOL chainingProhibited:1;        /*  chaining prohibited         */
    BOOL localScope:1;                /*  local scope chaining only   */
    BOOL dontUseCopy:1;               /*  dont use copy               */

    /* Non standard extensions.  Set to TRUE */
    // None yet.

    /* Non standard extensions.  Set to FALSE */
    BOOL makeDeletionsAvail:1;
    BOOL fUnicodeSupport:1;
    BOOL fStringNames:1;
    BOOL fSDFlagsNonDefault:1;
    BOOL fPermissiveModify:1;         /* don't err on update errors that   */
                                      /* do not affect the final object    */
                                      /* (e.g., remove of non-extant value */
    BOOL fUrgentReplication:1;        /* Skip wait to being replication */
    BOOL fAuthoritativeModify:1;      /* Change made is authoritative   */
                                      /* and wins against any other     */
                                      /* version that currently exists  */
                                      /* in the enterprise              */
    BOOL fMaintainSelOrder:1;         /* Don't reorder selection list   */
    BOOL fDontOptimizeSel:1;          /* Don't touch selection list     */
    BOOL fGcAttsOnly:1;               /* Only request for GC Partial Atts */

    BOOL fMissingAttributesOnGC:1;    /* Client requested attributes that */
                                      /* were not visible on the GC port */

    unsigned DontPerformSearchOp:2;   /* Do not perform actual search Op */

    WCHAR *pGCVerifyHint;             /* See description above          */

} SVCCNTL;

#define DA_NEVER     0
#define DA_SEARCHING 1
#define DA_BASE      2
#define DA_ALWAYS    (DA_SEARCHING | DA_BASE)

#define SO_NORMAL        0
#define SO_STATS         1
#define SO_ONLY_OPTIMIZE 2

/*  This structure is used by the client to continue an ongoing
 *   operation with a different DSA.  This occurs when a DSA does not have
 *   the information needed to complete an operation but knows of other
 *   DSA's that may be able to perform the operation that it can not
 *   contact for various reasons (e.g SVCCNTL's).  The information that is
 *   returned from the DSA is used to set this data structure (see REFERR
 *   error).
 *
 *   The nameRes filed is usually set to OP_NAMERES_NOT_STARTED.
 */

#define OP_NAMERES_NOT_STARTED          'S'
#define OP_NAMERES_PROCEEDING           'P'
#define OP_NAMERES_COMPLETED            'C'

typedef struct _NAMERESOP
{
    UCHAR   nameRes;        /*  status of name resolution.
                             *  Valid values:
                             *    - OP_NAMERES_NOT_STARTED
                             *    - OP_NAMERES_PROCEEDING
                             *    - OP_NAMERES_COMPLETED
                             */
    UCHAR   unusedPad;
    USHORT  nextRDN;        /*  index to the next part of the name to be
                             *  resolved.  This parm only has meaning
                             *  if the operation is proceeding.
                             */
} NAMERESOP;

typedef unsigned char BYTE;


/*
local_extension

A local_extension is similar to the X.500 extension object.
It provides a method for extending the protocol. Local extensions
are Microsoft specific.

Each extension is identified by an OID. In addition, the
extension has a critical boolean, which is true if the extension
is critical (i.e. must be supported for the call to be properly
serviced). The item element points to extension specific
data.
*/

/*
Paged Results

Although technically a local extension, Paged Results is made a
permanent part of the common arguments structure.  It is intended
to work like this:

The common argument structure contains a pointer to the PR restart
data structure provided by the user, if present.  The possible
conditions are:

fPresent FALSE => user didn't request PR; pRestart set to NULL

fPresent TRUE, pRestart NULL => first call (not a restart), PR requested

fPresent TRUE, pRestart != NULL => restart (cotinue) PR call

*/

/*
Unicode strings
Unicode strings is another microsoft extension that allows clients to request
strings of syntax OM_S_UNICODE_STRING to be returned as such. by default,
such strings are translated to OM_S_TELETEX_STRING.
*/

//
// Possible values of the restartType variable in a RESTART struct.
//
#define NTDS_RESTART_PAGED 1
#define NTDS_RESTART_VLV   2

typedef struct _RESTART
{
    // !! Any changes to this struct must leave !!
    // !! the 'data' member 8 byte aligned      !!
    ULONG       restartType;             // Is this a paged search restart or vlv.
    ULONG       structLen;              // The size of this whole structure.
    ULONG       CRC32;                  // the CRC of this whole structure
    ULONG       pad4;                   // four bytes of padding so that the rest
                                        // of the struct will be 8 byte aligned.
    GUID        serverGUID;             // the GUID of the server that created this structure
    DWORD       data[];                 // Hand marshalled data holding the
                                        // restart information.  We use DWORDs
                                        // because most of the packed data is
                                        // DWORD and I want to encourange
                                        // alignment.
} RESTART, * PRESTART;

typedef struct
{
    PRESTART    pRestart;       /* restart data */
    BOOL        fPresent:1;
} PAGED_RESULT;


typedef struct
{
    BOOL           fPresent:1;        // Flag whether this data structure contains
                                      // valid information (whether the client
                                      // asks for VLV results)
    BOOL           fseekToValue:1;    // flag whether we navigate using seekValue or
                                      // targetPosition
    IN ULONG       beforeCount;       // number of entries before target
    IN ULONG       afterCount;        // number of entries after target
    IN OUT ULONG   targetPosition;    // target position (offset from start)
                                      // in = Ci, out = Si
    IN OUT ULONG   contentCount;      // size of container
                                      // in = Cc, out = Sc
    IN ATTRVAL     seekValue;         // the value we seek From

    IN OUT PRESTART pVLVRestart;      // Restart Argument

    DWORD           Err;              // VLV Specific Service Error

} VLV_REQUEST, * PVLV_REQUEST;


typedef struct
{
    BOOL           fPresent:1;        // Flag whether this data structure contains
                                      // valid information (whether the client
                                      // asks for ASQ results)
    BOOL           fMissingAttributesOnGC:1; // Flag whether the search operation
                                             // references attributes that are
                                             // not part of the GC partial attr set


    ATTRTYP        attrType;

    DWORD          Err;               // ASQ Specific Service Error

} ASQ_REQUEST, * PASQ_REQUEST;


/*  These common input arguments are supplied with most directory
    calls.  The service controls provide client options that govern the
    operation.  The operation state specifies if this is  a new or
    continued operation (see OPERATION above).  The aliasRDN is only set
    if this is a continuation of a referral (see REFERR).  It is  set
    from the aliasRDN of the continuation referrence of the referral.

    Note that pReserved must be set to NULL!
*/


typedef struct _COMMARG
{
    SVCCNTL         Svccntl;     /* service controls */
    NAMERESOP       Opstate;     /* the state of the operation */
    ULONG         * pReserved;   /* Must be set to NULL*/
    ULONG           ulSizeLimit; /* size limit */
    ATTRTYP         SortAttr;    /* Attribute to sort on. */
    int             Delta;       /* Number of objects to skip on a list or
                                    search. Negative means walk backwards.  */
    ULONG           StartTick;   /* Tick count of the start of this operation
                                    0 means no time limit.                  */
    ULONG           DeltaTick;   /* Number of ticks to let this operation run.*/
    USHORT          aliasRDN;    /* number of RDN's produced by alias dereferencing */
    ULONG           SortType;    /* 0 - none, 1 - optional sort, 2-mandatory */
    BOOL            fForwardSeek:1;/* should the results of a list or search be
                                      constructed from the next objects, or the
                                      previous objects in whatever index we
                                      use. */
    BOOL            fLazyCommit:1; /* Can JET commit lazily? */
    BOOL            fFindSidWithinNc:1; /* Tells Do Name Res, to find a DS Name
                                         with only a Sid specified to be in
                                         the NC of authoritative Domain for
                                         the domain controller */

    DWORD           MaxTempTableSize;   // max entries per temp table

    PAGED_RESULT    PagedResult; /* Paged Results local extension */
    VLV_REQUEST     VLVRequest;  /* VLV Request local extension   */
    ASQ_REQUEST     ASQRequest;  /* ASQ Request local extension */

} COMMARG;

/* ...and a routine to give you default values.  Use it! */
VOID InitCommarg(COMMARG *pCommArg);

typedef struct _COMMRES {
    BOOL            aliasDeref;
    ULONG           errCode;
    union _DIRERR  *pErrInfo;
} COMMRES;

// Values for SortType
#define SORT_NEVER     0
#define SORT_OPTIONAL  1
#define SORT_MANDATORY 2

/*  This data structure is used on DirRead and DirSearch operations
 *  to specify the type of information the directory should return.  The
 *  client must specify the return of some or all of the object
 *  attributes found.  If only some attributes are to be returned, the
 *  client must provide a list of the desired attribute types.  An
 *  indication of some attributes together with a NULL attribute list
 *  indicates that no attributes are to be returned.  Attributes are
 *  returned only if they are present.  An attributeError with the
 *  PR_PROBLEM_NO_ATTRIBUTE designation will be returned if none of the
 *  selected attributes are present.
 *
 *  The client also specifies whether the attribute types or both the
 *  types and values should be returned.
 */

#define EN_ATTSET_ALL            'A'  /* get all atts                        */
#define EN_ATTSET_ALL_WITH_LIST  'B'  /* get all atts and list               */
#define EN_ATTSET_LIST           'L'  /* get selected atts                   */
#define EN_ATTSET_LIST_DRA       'E'  /* get selected atts, deny special DRA */
#define EN_ATTSET_ALL_DRA        'D'  /* get all atts except special DRA     */
#define EN_ATTSET_LIST_DRA_EXT   'F'  /* get selected atts, deny special DRA */
#define EN_ATTSET_ALL_DRA_EXT    'G'  /* get all atts except special DRA     */
#define EN_ATTSET_LIST_DRA_PUBLIC   'H'  /* get selected atts, deny special DRA, deny secret */
#define EN_ATTSET_ALL_DRA_PUBLIC    'I'  /* get all atts except special DRA, deny secret     */

#define EN_INFOTYPES_TYPES_ONLY  'T'  /* return att types only               */
#define EN_INFOTYPES_TYPES_MAPI  't'  /* types only, obj name in MAPI form   */
#define EN_INFOTYPES_TYPES_VALS  'V'  /* return types and values             */
#define EN_INFOTYPES_SHORTNAMES  'S'  /* Types + values, short DSName format */
#define EN_INFOTYPES_MAPINAMES   'M'  /* Types + values, MAPI DSName format  */

typedef struct _ENTINFSEL
{
    UCHAR        attSel;      /*  Retrieve all or a list of selected atts:
                               *  Valid values:
                               *    see EN_ATTSET_* defines above
                               */
    ATTRBLOCK    AttrTypBlock; /*  counted block of attribute types */
    UCHAR        infoTypes;    /*  Retrieve attribute types or types and values
                                *  Valid values:
                                *     see EN_INFOTYPES_* defines above
                                */
} ENTINFSEL;



/**************************************************************************
 *    Attribute Value Syntax Data Types
 **************************************************************************/

#define SYNTAX_UNDEFINED_TYPE           0
#define SYNTAX_DISTNAME_TYPE            1
#define SYNTAX_OBJECT_ID_TYPE           2
#define SYNTAX_CASE_STRING_TYPE         3
#define SYNTAX_NOCASE_STRING_TYPE       4
#define SYNTAX_PRINT_CASE_STRING_TYPE   5
#define SYNTAX_NUMERIC_STRING_TYPE      6
#define SYNTAX_DISTNAME_BINARY_TYPE     7
#define SYNTAX_BOOLEAN_TYPE             8
#define SYNTAX_INTEGER_TYPE             9
#define SYNTAX_OCTET_STRING_TYPE        10
#define SYNTAX_TIME_TYPE                11
#define SYNTAX_UNICODE_TYPE             12

/* MD specific attribute syntaxes. */
#define SYNTAX_ADDRESS_TYPE             13
#define SYNTAX_DISTNAME_STRING_TYPE    14
#define SYNTAX_NT_SECURITY_DESCRIPTOR_TYPE 15
#define SYNTAX_I8_TYPE                  16
#define SYNTAX_SID_TYPE                 17


/*  All attribute syntaxes are represented as a linear values.  This  means
 *  that an entire attribute value is stored in a contiguous set of bytes
 *  that contain no pointers.  Valid comparisons are defined in dbsyntax.c
 */

typedef UCHAR    SYNTAX_UNDEFINED;
typedef DSNAME   SYNTAX_DISTNAME;
typedef ULONG    SYNTAX_OBJECT_ID;
typedef UCHAR    SYNTAX_CASE_STRING;
typedef UCHAR    SYNTAX_NOCASE_STRING;
typedef UCHAR    SYNTAX_PRINT_CASE_STRING;
typedef UCHAR    SYNTAX_NUMERIC_STRING;
typedef BOOL     SYNTAX_BOOLEAN;
typedef long     SYNTAX_INTEGER;
typedef UCHAR    SYNTAX_OCTET_STRING;
typedef DSTIME   SYNTAX_TIME;
typedef wchar_t  SYNTAX_UNICODE;
typedef UCHAR    SYNTAX_NT_SECURITY_DESCRIPTOR;
typedef LARGE_INTEGER SYNTAX_I8;
typedef UCHAR    SYNTAX_SID;


typedef struct _SYNTAX_ADDR
{
    ULONG structLen;                    // Total length of this structure,
                                        // in BYTES!!!

    union {
        BYTE    byteVal[1];
        wchar_t uVal[1];
    };

} SYNTAX_ADDRESS;

typedef SYNTAX_ADDRESS STRING_LENGTH_PAIR;

/*
 * The following macro's can be used to correctly calculate the structlen
 * of a SYNTAX_ADDRESS from the payload length, or vice versa.
 */
#define PAYLOAD_LEN_FROM_STRUCTLEN( structLen ) \
    ((structLen) - sizeof(ULONG))

#define STRUCTLEN_FROM_PAYLOAD_LEN( stringLen ) \
    ((stringLen) + sizeof(ULONG))


/*  Note: In general, the <String> field of the following structure
 *  should not be directly referenced since the preceding <Name> field
 *  is variable-sized.  Also, one should not should not rely on the
 *  "sizeof()" operator's evaluation of the size of the structure since
 *  the size of the SYNTAX_DISTNAME <Name> will usually be larger than
 *  "sizeof(SYNTAX_DISTNAME)."
 */

typedef struct _SYNTAX_DISTNAME_DATA
{
    DSNAME         Name;                // the Distinguished Name
    SYNTAX_ADDRESS Data;                // The data
} SYNTAX_DISTNAME_STRING, SYNTAX_DISTNAME_BINARY;


/*  The following defines can be used to find <Name> and <Data>
 *  fields and otherwise manipulate _SYNTAX_DISTNAME_BLOB attributes.
 */

/* produce a pointer to the <Name> field: */

#define NAMEPTR( pDN_Blob ) \
    ((DSNAME *) (&(pDN_Blob)->Name))


// Produce the size of a given DISTNAME, padded to the nearest 4 bytes.
#define PADDEDNAMEMASK (~3)
#define PADDEDNAMESIZE(pDN) \
    (((pDN)->structLen + 3) & PADDEDNAMEMASK)

/* produce a pointer to the <Address> field: */
#define DATAPTR( pDN_Blob ) \
    ((SYNTAX_ADDRESS *)(PADDEDNAMESIZE(NAMEPTR(pDN_Blob)) + (char *)(pDN_Blob)))

/* find the combined size of the <Name> and <Data> structures: */
#define NAME_DATA_SIZE( pDN_Blob ) \
    (PADDEDNAMESIZE(NAMEPTR(pDN_Blob)) + DATAPTR(pDN_Blob)->structLen)

/* given a DSNAME and a SYNTAX_ADDRESS, find their combined size: */
#define DERIVE_NAME_DATA_SIZE( pDN, pData ) \
    (PADDEDNAMESIZE(pDN) + (pData)->structLen)

/*  Given a SYNTAX_DISTNAME, a STRING_LENGTH_PAIR, and pre-allocated space
    of the appropriate size, build a _SYNTAX_DISTNAME_BLOB attribute
    by copying in its component parts:
*/

#define BUILD_NAME_DATA( pDN_Blob, pDN, pData ) \
    memcpy( NAMEPTR(pDN_Blob), (pDN)  , (pDN)->structLen ); \
    memcpy( DATAPTR(pDN_Blob), (pData), (pData)->structLen );


/**************************************************************************
 *    Error Data Structures
 **************************************************************************/


/* An ATRERR reports an attribute related problem */

#define ATRERR_BASE                     ( attributeError * DIR_ERROR_BASE )

#define PR_PROBLEM_NO_ATTRIBUTE_OR_VAL      ( ATRERR_BASE + 1 )
#define PR_PROBLEM_INVALID_ATT_SYNTAX       ( ATRERR_BASE + 2 )
#define PR_PROBLEM_UNDEFINED_ATT_TYPE       ( ATRERR_BASE + 3 ) /*DirAddEntry &
                                                                 * DirModEntry
                                                                 * only
                                                                 */
#define PR_PROBLEM_WRONG_MATCH_OPER         ( ATRERR_BASE + 4 )
#define PR_PROBLEM_CONSTRAINT_ATT_TYPE      ( ATRERR_BASE + 5 )
#define PR_PROBLEM_ATT_OR_VALUE_EXISTS      ( ATRERR_BASE + 6 )

/*

   Most of the error data structures (like the ones below) have an on the wire
   data structure version too with a _DRS_WIRE_Vx appended to it, where X is
   the revision.  If this structure is changed, corresponding changes should 
   be made to the WIRE versions, and to the packaging functions 
   draEncodeError() and draDecodeDraErrorDataAndSetThError().
   
*/
typedef struct INTERNAL_FORMAT_PROBLEM
{
    DWORD                   dsid;
    DWORD                   extendedErr;  /* Non-standard error code */
    DWORD                   extendedData;   /* extra data to go with it */
    USHORT                  problem;      /* Attribute problem type,
                                           * valid values defined above
                                           */
    ATTRTYP                 type;         /* the offending attribute type */
    BOOL                    valReturned;  /* indicates that an attribute
                                           * value follows
                                           */
    ATTRVAL                 Val;          /* optionally supplied offending
                                           * att value
                                           */
} INTFORMPROB;

typedef struct PROBLEMLIST
{
    struct PROBLEMLIST FAR *pNextProblem; /* linked-list to next prob att */
    INTFORMPROB intprob;      
} PROBLEMLIST;

typedef struct ATRERR
{
    PDSNAME     pObject;        /* name of the offending object */
    ULONG       count;          /* the number of attribute errors */
    PROBLEMLIST FirstProblem;   /* a linked-list of attribute errors */
} ATRERR;




/*  A NAMERR reports a problem with a name provided as an operation argument.
 *  Note that a problem with the attribute types and/or values in a DistName
 *  used as an operation argument is reported via a NAMERR with problem
 *  NA_PROBLEM_BAD_ATT_SYNTAX rather than as an ATRERR or an UPDERR
 */

#define NAMERR_BASE                         ( nameError * DIR_ERROR_BASE )

#define NA_PROBLEM_NO_OBJECT                ( NAMERR_BASE + 1 )
#define NA_PROBLEM_NO_OBJ_FOR_ALIAS         ( NAMERR_BASE + 2 )
#define NA_PROBLEM_BAD_ATT_SYNTAX           ( NAMERR_BASE + 3 )
#define NA_PROBLEM_ALIAS_NOT_ALLOWED        ( NAMERR_BASE + 4 )
#define NA_PROBLEM_NAMING_VIOLATION         ( NAMERR_BASE + 5 )
#define NA_PROBLEM_BAD_NAME                 ( NAMERR_BASE + 6 )

/*

   Most of the error data structures (like the one below) have an on the wire
   data structure version too with a _DRS_WIRE_Vx appended to it, where X is
   the revision.  If this structure is changed, corresponding changes should 
   be made to the WIRE versions, and to the packaging functions 
   draEncodeError() and draDecodeDraErrorDataAndSetThError().
   
*/
typedef struct NAMERR
{
    DWORD       dsid;
    DWORD       extendedErr;    /* Non-standard error code */
    DWORD       extendedData;   /* extra data to go with it */
    USHORT      problem;        /* The type of name problem, valid values
                                 * defined above.
                                 */
    PDSNAME     pMatched;       /*  the closest name match  */
} NAMERR;


/*  The referral is an indication from a DSA that it was unable to
 *  complete the operation because of either client specified
 *  restrictions or because some DSA's are unavailable.  It provides
 *  information as to the state of the operation and a list of other
 *  DSA's that may be able to satisfy the request.
 *
 *  To continue the request, the client must bind to each referred DSA
 *  and attempt the same operation.  They must specify the CONTREF.target
 *  object name as the search object name. (This may be different from
 *  the original object name because of alias dereferencing.)  The
 *  operation state (opstate) on the common arguments (COMMARG) must be
 *  set from the operation state on the continuation reference CONTREF.
 *  The aliasRDN of the common arguments must be set from the aliasRDN of
 *  the continuation reference.
 */

/*  The access point is the name and address of a DSA to contact.
 *  This is returned from a DSA referral and is used to bind to a
 *  referred DSA (see DirBind).
 */

typedef SYNTAX_DISTNAME_STRING ACCPNT;

/* A list of access points is returned on referrals. */
typedef struct ACCPNTLIST
{
    struct ACCPNTLIST  * pNextAccPnt;     /* linked-list to next ACCPNT */
    ACCPNT             * pAccPnt;         /* this access point */
} ACCPNTLIST;

/* Access Points seem excessively ISO specific, and since everyone on
 * the planet seems to be using TCP/IP and DNS, which use a simple
 * string representation of an address rather than an ISO Presentation
 * Address, we are migrating data structures this way.
 */

// moved up to above the IDL line: typedef UNICODE_STRING DSA_ADDRESS;

typedef struct _DSA_ADDRESS_LIST {
    struct _DSA_ADDRESS_LIST * pNextAddress;
    DSA_ADDRESS              Address;
} DSA_ADDRESS_LIST;

/*  The continuation referrence is returned on a referral to other DSA's
    for the completion of an operation.  The reference contains the name
    of the desired directory object, the state of the partially completed
    operation, some support information that is used to continue and a
    list of other DSA's to contact.
*/

// The CH_REFTYPE_XXXXX were moved up to the CONTREF_DRS_WIRE_V1 area. 

/*

   Most of the error data structures (like the one below) have an on the wire
   data structure version too with a _DRS_WIRE_Vx appended to it, where X is
   the revision.  If this structure is changed, corresponding changes should 
   be made to the WIRE versions, and to the packaging functions 
   draEncodeError() and draDecodeDraErrorDataAndSetThError().
   
*/
typedef struct CONTREF
{
    PDSNAME     pTarget;        /* target name in continuing operation */
    NAMERESOP   OpState;        /* operation status */
    USHORT      aliasRDN;       /* # of RDN's produced by dereferencing */
    USHORT      RDNsInternal;   /* reserved */
    USHORT      refType;        /* reserved */
    USHORT      count;          /* number of access points */
    DSA_ADDRESS_LIST *pDAL;     /* linked list of access points */
    struct CONTREF *pNextContRef; /* linked list of CRs */
    PFILTER     pNewFilter;     /* new filter (optional) */
    BOOL        bNewChoice;     /* is a new choice present? */
    UCHAR       choice;         /* new search choice (optional) */
} CONTREF;


/*

   Most of the error data structures (like the one below) have an on the wire
   data structure version too with a _DRS_WIRE_Vx appended to it, where X is
   the revision.  If this structure is changed, corresponding changes should 
   be made to the WIRE versions, and to the packaging functions 
   draEncodeError() and draDecodeDraErrorDataAndSetThError().
   
*/
typedef struct REFERR
{
    DWORD      dsid;
    DWORD      extendedErr;        /* Non-standard error code */
    DWORD      extendedData;   /* extra data to go with it */
    CONTREF Refer;                 /* alternate DSAs to contact */
} REFERR;


/*  A SECERR reports a problem in carrying out an operation because of
 *  security reasons.
 *
 *  NOTE: for this release only SE_PROBLEM_INSUFF_ACCESS_RIGHTS will be
 *        returned on a security error
 */

#define SECERR_BASE                         ( securityError * DIR_ERROR_BASE )

#define SE_PROBLEM_INAPPROPRIATE_AUTH       ( SECERR_BASE + 1 )
#define SE_PROBLEM_INVALID_CREDENTS         ( SECERR_BASE + 2 )
#define SE_PROBLEM_INSUFF_ACCESS_RIGHTS     ( SECERR_BASE + 3 )
#define SE_PROBLEM_INVALID_SIGNATURE        ( SECERR_BASE + 4 )
#define SE_PROBLEM_PROTECTION_REQUIRED      ( SECERR_BASE + 5 )
#define SE_PROBLEM_NO_INFORMATION           ( SECERR_BASE + 6 )

/*

   Most of the error data structures (like the one below) have an on the wire
   data structure version too with a _DRS_WIRE_Vx appended to it, where X is
   the revision.  If this structure is changed, corresponding changes should 
   be made to the WIRE versions, and to the packaging functions 
   draEncodeError() and draDecodeDraErrorDataAndSetThError().
   
*/
typedef struct SECERR
{
    DWORD      dsid;
    DWORD      extendedErr;    /* Non-standard error code */
    DWORD      extendedData;   /* extra data to go with it */
    USHORT     problem;        /* Problems, valid values defined above */
} SECERR;


/* Service errors */

#define SVCERR_BASE                         ( serviceError * DIR_ERROR_BASE )

#define SV_PROBLEM_BUSY                     ( SVCERR_BASE + 1  )
#define SV_PROBLEM_UNAVAILABLE              ( SVCERR_BASE + 2  )
#define SV_PROBLEM_WILL_NOT_PERFORM         ( SVCERR_BASE + 3  )
#define SV_PROBLEM_CHAINING_REQUIRED        ( SVCERR_BASE + 4  )
#define SV_PROBLEM_UNABLE_TO_PROCEED        ( SVCERR_BASE + 5  )
#define SV_PROBLEM_INVALID_REFERENCE        ( SVCERR_BASE + 6  )
#define SV_PROBLEM_TIME_EXCEEDED            ( SVCERR_BASE + 7  )
#define SV_PROBLEM_ADMIN_LIMIT_EXCEEDED     ( SVCERR_BASE + 8  )
#define SV_PROBLEM_LOOP_DETECTED            ( SVCERR_BASE + 9  )
#define SV_PROBLEM_UNAVAIL_EXTENSION        ( SVCERR_BASE + 10 )
#define SV_PROBLEM_OUT_OF_SCOPE             ( SVCERR_BASE + 11 )
#define SV_PROBLEM_DIR_ERROR                ( SVCERR_BASE + 12 )


/*

   Most of the error data structures (like the one below) have an on the wire
   data structure version too with a _DRS_WIRE_Vx appended to it, where X is
   the revision.  If this structure is changed, corresponding changes should 
   be made to the WIRE versions, and to the packaging functions 
   draEncodeError() and draDecodeDraErrorDataAndSetThError().
   
*/
typedef struct SVCERR
{
    DWORD      dsid;
    DWORD      extendedErr;    /* Non-standard error code */
    DWORD      extendedData;   /* extra data to go with it */
    USHORT     problem;        /* Problems, valid values defined above */
} SVCERR;



/* Update errors */

#define UPDERR_BASE                         ( updError * DIR_ERROR_BASE )

#define UP_PROBLEM_NAME_VIOLATION           ( UPDERR_BASE + 1 )
#define UP_PROBLEM_OBJ_CLASS_VIOLATION      ( UPDERR_BASE + 2 )
#define UP_PROBLEM_CANT_ON_NON_LEAF         ( UPDERR_BASE + 3 )
#define UP_PROBLEM_CANT_ON_RDN              ( UPDERR_BASE + 4 )
#define UP_PROBLEM_ENTRY_EXISTS             ( UPDERR_BASE + 5 )
#define UP_PROBLEM_AFFECTS_MULT_DSAS        ( UPDERR_BASE + 6 )
#define UP_PROBLEM_CANT_MOD_OBJ_CLASS       ( UPDERR_BASE + 7 )

/*

   Most of the error data structures (like the one below) have an on the wire
   data structure version too with a _DRS_WIRE_Vx appended to it, where X is
   the revision.  If this structure is changed, corresponding changes should 
   be made to the WIRE versions, and to the packaging functions 
   draEncodeError() and draDecodeDraErrorDataAndSetThError().
   
*/
typedef struct UPDERR
{
    DWORD      dsid;
    DWORD      extendedErr;    /* Non-standard error code */
    DWORD      extendedData;   /* extra data to go with it */
    USHORT     problem;        /* Problems, valid values defined above */
} UPDERR;


/* problem codes are from errno.h */

/*

   Most of the error data structures (like the one below) have an on the wire
   data structure version too with a _DRS_WIRE_Vx appended to it, where X is
   the revision.  If this structure is changed, corresponding changes should 
   be made to the WIRE versions, and to the packaging functions 
   draEncodeError() and draDecodeDraErrorDataAndSetThError().
   
*/
typedef struct _SYSERR
{
    DWORD      dsid;
    DWORD      extendedErr;
    DWORD      extendedData;   /* extra data to go with it */
    USHORT     problem;
} SYSERR;


/*

   Most of the error data structures (like the one below) have an on the wire
   data structure version too with a _DRS_WIRE_Vx appended to it, where X is
   the revision.  If this structure is changed, corresponding changes should 
   be made to the WIRE versions, and to the packaging functions 
   draEncodeError() and draDecodeDraErrorDataAndSetThError().
   
*/
typedef union _DIRERR
{
    ATRERR  AtrErr;             /* attribute error */
    NAMERR  NamErr;             /* name error      */
    REFERR  RefErr;             /* referral error  */
    SECERR  SecErr;             /* security error  */
    SVCERR  SvcErr;             /* service error   */
    UPDERR  UpdErr;             /* update error    */
    SYSERR  SysErr;             /* system error    */
} DIRERR;


/* Turn back on the warning about the zero-sized array. */
#pragma warning (default: 4200)

/* From mdlocal.h */

unsigned AttrTypeToKey(ATTRTYP attrtyp, WCHAR *pOutBuf);
ATTRTYP KeyToAttrTypeLame(WCHAR * pKey, unsigned cc);

unsigned QuoteRDNValue(const WCHAR * pVal,
                       unsigned ccVal,
                       WCHAR * pQuote,
                       unsigned ccQuoteBufMax);

unsigned UnquoteRDNValue(const WCHAR * pQuote,
                         unsigned ccQuote,
                         WCHAR * pVal);

unsigned GetRDN(const WCHAR **ppDN,
                unsigned *pccDN,
                const WCHAR **ppKey,
                unsigned *pccKey,
                const WCHAR **ppVal,
                unsigned *pccVal);

unsigned GetDefaultSecurityDescriptor(
        ATTRTYP classID,
        ULONG   *pLen,
        PSECURITY_DESCRIPTOR *ppSD
        );

DWORD
UserFriendlyNameToDSName (
        WCHAR *pUfn,
        DWORD ccUfn,
        DSNAME **ppDN
        );


// This function trims a Dsname by the given number of avas.
BOOL TrimDSNameBy(
        DSNAME *pDNSrc,
        ULONG cava,
        DSNAME *pDNDst);


// returns info about the RDN in a DSNAME. This is the external version
// of GetRDNInfo to be called outside of ntdsa
unsigned GetRDNInfoExternal(
                    const DSNAME *pDN,
                    WCHAR *pRDNVal,
                    ULONG *pRDNlen,
                    ATTRTYP *pRDNtype);

// Tests if the RDN is indeed mangled. This is the external version to be
// called outside of ntdsa
BOOL IsMangledRDNExternal(
                    WCHAR * pszRDN,  // Pointer to the RDN
                    ULONG   cchRDN,  // Length of the RDN
                    PULONG  pcchUnmangled OPTIONAL); // Offset in the RDN
                                                     // where mangling
                                                     // starts



// Append an RDN to an existing DSNAME.  Return value is 0 on success.
// A non-zero return value is the size, in bytes, that would have been
// required to hold the output name.  A return of -1 indicates that one
// of the input values was bad (most likely the Attid)
unsigned AppendRDN(DSNAME *pDNBase, // Base name to append from
                   DSNAME *pDNNew,  // Buffer to hold results
                   ULONG ulBufSize, // Size of pDNNew buffer, in bytes
                   WCHAR *pRDNVal,  // RDN value to append
                   ULONG RDNlen,    // length of RDN val, in characters
                                    // 0 means NULL terminated string
                   ATTRTYP AttId);  // RDN attribute type

// Determines the count of name parts (i.e., the level),
// returns 0 or error code
unsigned CountNameParts(const DSNAME *pName, unsigned *pCount);

// Reasons for mangling an RDN.
typedef enum {
    MANGLE_OBJECT_RDN_FOR_DELETION = 0,
    MANGLE_OBJECT_RDN_FOR_NAME_CONFLICT,
    MANGLE_PHANTOM_RDN_FOR_NAME_CONFLICT
} MANGLE_FOR;

// Mangle an RDN to avoid name conflicts.  NOTE: pszRDN must be pre-allocated
// to hold at least MAX_RDN_SIZE WCHARs.
DWORD
MangleRDNWithStatus(
    IN      MANGLE_FOR  eMangleFor,
    IN      GUID *      pGuid,
    IN OUT  WCHAR *     pszRDN,
    IN OUT  DWORD *     pcchRDN
    );

// Detect and decode previously mangled RDN. peMangleFor is optional
BOOL
IsMangledRDN(
    IN           WCHAR      *pszRDN,
    IN           DWORD       cchRDN,
    OUT          GUID       *pGuid,
    OUT OPTIONAL MANGLE_FOR *peMangleFor
    );

/* End: From mdlocal.h */

typedef struct _ServerSitePair {
    WCHAR *         wszDnsServer;
    WCHAR *         wszSite;
} SERVERSITEPAIR;

VOID
DsFreeServersAndSitesForNetLogon(
    SERVERSITEPAIR *         paServerSites
    );

NTSTATUS
DsGetServersAndSitesForNetLogon(
    IN   WCHAR *         pNCDNS,
    OUT  SERVERSITEPAIR ** ppaRes
    );

NTSTATUS
CrackSingleName(
    DWORD       formatOffered,          // one of DS_NAME_FORMAT in ntdsapi.h
    DWORD       dwFlags,                // DS_NAME_FLAG mask
    WCHAR       *pNameIn,               // name to crack
    DWORD       formatDesired,          // one of DS_NAME_FORMAT in ntdsapi.h
    DWORD       *pccDnsDomain,          // char count of following argument
    WCHAR       *pDnsDomain,            // buffer for DNS domain name
    DWORD       *pccNameOut,            // char count of following argument
    WCHAR       *pNameOut,              // buffer for formatted name
    DWORD       *pErr);                 // one of DS_NAME_ERROR in ntdsapi.h

typedef enum
{
    DSCONFIGNAME_DMD = 1,   // Hint: this is the Schema NC.
    DSCONFIGNAME_DSA = 2,
    DSCONFIGNAME_DOMAIN = 3,
    DSCONFIGNAME_CONFIGURATION = 4,
    DSCONFIGNAME_ROOT_DOMAIN = 5,
    DSCONFIGNAME_LDAP_DMD = 6,
    DSCONFIGNAME_PARTITIONS = 7,
    DSCONFIGNAME_DS_SVC_CONFIG = 8,
    DSCONFIGNAMELIST_NCS = 9, // extended command, must use GetConfigurationNamesList().
    DSCONFIGNAME_DOMAIN_CR = 10,
    DSCONFIGNAME_ROOT_DOMAIN_CR = 11
} DSCONFIGNAME;

// The Following are the flags needed to provide the
// GetConfigurationNamesList() more parameters with which to run by.
// The flags differ for each command differ from command to command.

// DSCNL_NCS_ flags have to do with which NCS to get, you will need
// at least one flag from the type of NCs and one from the locality of
// the NCs.

// Note that _NCS_NDNCS does not include Config or Schema NCs, making
// these first 4 flags mututally exclusive sets.  This is more convient
// for getting any list of NCs you want.
#define DSCNL_NCS_DOMAINS         0x00000001
#define DSCNL_NCS_CONFIG          0x00000002
#define DSCNL_NCS_SCHEMA          0x00000004
#define DSCNL_NCS_NDNCS           0x00000008
#define DSCNL_NCS_ALL_NCS         (DSCNL_NCS_DOMAINS | DSCNL_NCS_CONFIG | DSCNL_NCS_SCHEMA | DSCNL_NCS_NDNCS)
// THis flag is the same kind of flag, but not mututally exclusive of the others
#define DSCNL_NCS_ROOT_DOMAIN     0x00000010

// This set of three flags also forms a mututally exclusive set of sets, that
// together form the whole
#define DSCNL_NCS_LOCAL_MASTER    0x00000100
#define DSCNL_NCS_LOCAL_READONLY  0x00000200
#define DSCNL_NCS_REMOTE          0x00000400
#define DSCNL_NCS_ALL_LOCALITIES  (DSCNL_NCS_LOCAL_MASTER | DSCNL_NCS_LOCAL_READONLY | DSCNL_NCS_REMOTE)

NTSTATUS
GetConfigurationNamesList(
    DWORD       which,
    DWORD       dwFlags,
    DWORD *     pcbNames,
    DSNAME **   padsNames);

NTSTATUS
GetDnsRootAlias(
    WCHAR * pDnsRootAlias,
    WCHAR * pRootDnsRootAlias);

NTSTATUS
GetConfigurationName(
    DWORD       which,
    DWORD       *pcbName,
    DSNAME      *pName);

/* From dsatools.h */

void * THAlloc(DWORD size);

void * THReAlloc(void *, DWORD size);

void THFree(void *buff);

// returns TRUE if the two names match (refer to the same object)
extern int
NameMatched(const DSNAME *pDN1, const DSNAME *pDN2);
extern int
NameMatchedStringNameOnly(const DSNAME *pDN1, const DSNAME *pDN2);

// helper function which takes a DSNAME and returns its hashkey
extern DWORD DSNAMEToHashKeyExternal(const DSNAME *pDN);

// helper function which takes a DSNAME and returns its LCMapped version
// this can be used in string comparisons using strcmp
extern CHAR* DSNAMEToMappedStrExternal(const DSNAME *pDN);

// helper function which takes a WCHAR and returns its hashkey
extern DWORD DSStrToHashKeyExternal(const WCHAR *pStr, int cchLen);

// helper function that takes a WCHAR string and returns the LCMapped version
// cchMaxStr is the maximum expected size of the passed in string
extern CHAR * DSStrToMappedStrExternal(const WCHAR *pStr, int cchMaxStr);


/* End: From dsatools.h */

/* New */

// Any change to this enum must be reflected both in the array DsCallerType
// in src\dstrace.c and in the Dump_THSTATE routine in dsexts\md.c
typedef enum _CALLERTYPE {
    CALLERTYPE_NONE = 0,
    CALLERTYPE_SAM,
    CALLERTYPE_DRA,
    CALLERTYPE_LDAP,
    CALLERTYPE_LSA,
    CALLERTYPE_KCC,
    CALLERTYPE_NSPI,
    CALLERTYPE_INTERNAL,
    CALLERTYPE_NTDSAPI
} CALLERTYPE;

#define IsCallerTypeValid( x )  ( ( ( x ) >= CALLERTYPE_SAM ) && ( ( x ) <= CALLERTYPE_NTDSAPI ) )

ULONG THCreate(DWORD);     /* returns 0 on success */
ULONG THDestroy(void);          /* returns 0 on success */
BOOL  THQuery(void);            /* returns 1 if THSTATE exists, 0 if not */
PVOID THSave();
VOID THRestore(PVOID);
VOID THClearErrors();
VOID THRefresh();

// Returns error string associated with THSTATE error; free with THFree().
LPSTR THGetErrorString();

BOOL THVerifyCount(unsigned count);  /* Returns TRUE if thread has exactly   */
                                     /* count thread states, FALSE if not.   */
                                     /* Only works if thread state mapping   */
                                     /* is enabled (chk or under debug),     */
                                     /* returns TRUE if disabled.            */

// obsolete; use THClearErrors() instead
#define SampClearErrors THClearErrors

VOID
SampSetDsa(
   BOOLEAN DsaFlag);

VOID
SampSetLsa(
   BOOLEAN DsaFlag);

/*++

    This routine gets the requested property of the class schema object, for the
    Class specified in ClassId.
Parameters:
    ClassId  The ClassId of the class that we are interseted in
    AttributeId The attribute of the class schema object that we want
    attLen    The length of the attribute value is present in here .
              Caller allocates the buffer in pAttVal and passes its length
              in attLen. If the buffer required is less than the buffer supplied
              then the data is returned in pattVal. Else  the required size is
              returned in attLen.
    pattVal      The value of the attribute is returned in here.

    Security Descriptors returned by this routine are always in a format that
    can be used by the RTL routines.
Return Values:
    STATUS_SUCCESS
    STATUS_NOT_FOUND
    STATUS_BUFFER_TOO_SMALL
--*/
extern
NTSTATUS
SampGetClassAttribute(
     IN     ULONG    ClassId,
     IN     ULONG    Attribute,
     OUT    PULONG   attLen,
     OUT    PVOID    pattVal
     );


/* End: New */

/*************************************************************************
    MINI-DIRECTORY API - MINI-DIRECTORY API - MINI-DIRECTORY API
*************************************************************************/


// All the Dir APIs requires a valid thread state and are atomic.
// I.e. They implicitly begin/end a transaction.  Some in-process
// clients like the LSA wish to perform multi-object transactions,
// AND PLEDGE TO KEEP TRANSACTIONS SHORT!!!  The following defines
// and routines can be used to perform multi-object transactions.
// DirTransactControl() must be called with a valid thread state.
// By default, a thread's transaction control is TRANSACT_BEGIN_END.
// A transaction is ended on error.  It must explicitly be ended via a
// TRANSACT_BEGIN_END or TRANSACT_DONT_BEGIN_END transaction state

typedef enum DirTransactionOption
{
    TRANSACT_BEGIN_END              = 0,
    TRANSACT_DONT_BEGIN_END         = 1,
    TRANSACT_BEGIN_DONT_END         = 2,
    TRANSACT_DONT_BEGIN_DONT_END    = 3
} DirTransactionOption;

VOID
DirTransactControl(
    DirTransactionOption    option);

/*
 * There are some controls that we need to send directly to a DSA that
 * have no correlation to any directory object.  For example, we might
 * need to tell a DSA to recals its hierarchy table, or force it to run
 * garbage collection now, or initiate some FSMO request.  These operation
 * controls are bundled together in this API.  Some operation controls take
 * values as arguments, those are passed through the sized buffer.
 */
typedef enum _OpType {
    OP_CTRL_INVALID = 0,
    OP_CTRL_RID_ALLOC = 1,
    OP_CTRL_BECOME_RID_MASTER = 2,
    OP_CTRL_BECOME_SCHEMA_MASTER = 3,
    OP_CTRL_GARB_COLLECT = 4,
    OP_CTRL_RECALC_HIER = 5,
    OP_CTRL_REPL_TEST_HOOK = 6,
    OP_CTRL_BECOME_DOM_MASTER = 7,
//    OP_CTRL_DECLARE_QUIESCENCE = 8,
    OP_CTRL_SCHEMA_UPDATE_NOW = 9,
    OP_CTRL_BECOME_PDC = 10,
    OP_CTRL_FIXUP_INHERITANCE = 11,
    OP_CTRL_FSMO_GIVEAWAY = 12,
    OP_CTRL_INVALIDATE_RID_POOL = 13,
    OP_CTRL_DUMP_DATABASE = 14,
    OP_CTRL_CHECK_PHANTOMS = 15,
    OP_CTRL_BECOME_INFRASTRUCTURE_MASTER = 16,
    OP_CTRL_BECOME_PDC_WITH_CHECKPOINT = 17,
    OP_CTRL_UPDATE_CACHED_MEMBERSHIPS = 18,
    OP_CTRL_ENABLE_LVR = 19,
    OP_CTRL_LINK_CLEANUP = 20,
    OP_CTRL_SCHEMA_UPGRADE_IN_PROGRESS = 21,
    OP_CTRL_DYNAMIC_OBJECT_CONTROL = 22,
    // Following for test purposes in debug builds only.

#ifdef INCLUDE_UNIT_TESTS
    OP_CTRL_REFCOUNT_TEST = 10000,
    OP_CTRL_TAKE_CHECKPOINT=10001,
    OP_CTRL_ROLE_TRANSFER_STRESS=10002,
    OP_CTRL_ANCESTORS_TEST=10003,
    OP_CTRL_BHCACHE_TEST=10004,
    OP_SC_CACHE_CONSISTENCY_TEST=10005,
    OP_CTRL_PHANTOMIZE=10006,
    OP_CTRL_REMOVE_OBJECT = 10007,
    OP_CTRL_GENERIC_CONTROL = 10008,
    OP_CTRL_PROTECT_OBJECT = 10009,
#endif
#ifdef DBG
    OP_CTRL_EXECUTE_SCRIPT = 10010,
#endif
} OpType;

typedef struct _OPARG {
    OpType     eOp;
    char      *pBuf;            /* optional value */
    ULONG      cbBuf;           /* size of value buffer */
} OPARG;

typedef struct _OPRES {
    COMMRES    CommRes;
    ULONG      ulExtendedRet;
} OPRES;

typedef struct _FSMO_GIVEAWAY_DATA_V1 {

    ULONG Flags;

    ULONG NameLen;
    WCHAR StringName[1];  // variable sized array

} FSMO_GIVEAWAY_DATA_V1, *PFSMO_GIVEAWAY_DATA_V1;

typedef struct _FSMO_GIVEAWAY_DATA_V2 {

    ULONG Flags;

    ULONG NameLen;          // length of DSA DN, excluding null terminator
                            //   (which is required); may be 0

    ULONG NCLen;            // length of NC DN, excluding null terminator
                            //   (which is required); may be 0

    WCHAR Strings[1];       // variable sized array; DSA DN (or '\0' if none)
                            // followed by NC DN (or '\0' if none)

} FSMO_GIVEAWAY_DATA_V2, *PFSMO_GIVEAWAY_DATA_V2;

typedef struct _FSMO_GIVEAWAY_DATA {

    DWORD Version;
    union {
        FSMO_GIVEAWAY_DATA_V1 V1;
        FSMO_GIVEAWAY_DATA_V2 V2;
    };

} FSMO_GIVEAWAY_DATA, *PFSMO_GIVEAWAY_DATA;


//
// Flags for FSMO_GIVEAWAY_DATA_V1
//
#define FSMO_GIVEAWAY_DOMAIN       0x01
#define FSMO_GIVEAWAY_ENTERPRISE   0x02
#define FSMO_GIVEAWAY_NONDOMAIN    0x04


ULONG
DirOperationControl(
                    OPARG   * pOpArg,
                    OPRES  ** ppOpRes
);

/*++
  DirBind
--*/

typedef struct _BINDARG {
    OCTET       Versions;   /*  The client version on BINDARG
                             *  (defaults to "v1988" if not provided,
                             *  i.e. if <Versions.pVal> == NULL or
                             *  <Versions.len> == 0).
                             *  The DSA supported Versions on BINDRES.
                             */
    PDSNAME     pCredents;  /*  The user name
                             */
} BINDARG;


/* The output data structs carries a little more info */

typedef struct _BINDRES {
    OCTET       Versions;   /*  The client version on BINDARG
                             *  (defaults to "v1988" if not provided,
                             *  i.e. if <Versions.pVal> == NULL or
                             *  <Versions.len> == 0).
                             *  The DSA supported Versions on BINDRES.
                             */
    PDSNAME     pCredents;  /*  The DSA name.
                             */
    COMMRES     CommRes;
} BINDRES;

ULONG
DirBind (
    BINDARG               * pBindArg,    /* binding credentials            */
    BINDRES              ** ppBindRes    /* binding results                */
);

/*++
  DirUnBind - currently a placeholder
--*/
ULONG DirUnBind
(
    void
);


/*++
  DirRead
--*/
// These structures holds information about range limits for values on
// attributes in a search.
typedef struct _RANGEINFOITEM {
    ATTRTYP   AttId;
    DWORD     lower;
    DWORD     upper;
} RANGEINFOITEM;

typedef struct _RANGESEL {
    DWORD valueLimit;
    DWORD count;
    RANGEINFOITEM *pRanges;
} RANGEINFSEL;

typedef struct _RANGEINF {
    DWORD count;
    RANGEINFOITEM *pRanges;
} RANGEINF;

typedef struct _RANGEINFLIST {
    struct _RANGEINFLIST *pNext;
    RANGEINF              RangeInf;
} RANGEINFLIST;

typedef struct _READARG
{
    DSNAME        * pObject;    /* object name                           */
    ENTINFSEL FAR * pSel;       /* entry information selection           */
                                /* (null means read all atts and values) */
    RANGEINFSEL   * pSelRange;  /* range information (i.e. max number of */
                                /* values or subrange of values to read  */
                                /* for a given attribute) null = all     */

    COMMARG         CommArg;    /* common arguments                      */
    struct _RESOBJ * pResObj;   /* for internal caching use, leave null */
} READARG;

typedef struct _READRES
{
    ENTINF  entry;               /* entry information                    */
    RANGEINF range;
    COMMRES     CommRes;
} READRES;


ULONG
DirRead (
    READARG FAR   * pReadArg,       /* Read argument                        */
    READRES      ** ppReadRes
);


/*++
  DirCompare
--*/

typedef struct _COMPAREARG
{
    PDSNAME     pObject;        /* object name                             */
    AVA         Assertion;      /*  The specified attribute to match       */
    COMMARG     CommArg;        /*  common arguments                       */
    struct _RESOBJ * pResObj;   /* for internal caching use, leave null */
} COMPAREARG;

typedef struct _COMPARERES
{
    PDSNAME     pObject;        /* Name provided if an alias was
                                 *  dereferrenced.
                                 */
    BOOL        fromMaster;     /* TRUE if the object is from the master   */
    BOOL        matched;        /* True if the match was successful        */
    COMMRES     CommRes;
} COMPARERES;

ULONG
DirCompare(
    COMPAREARG        * pCompareArg, /* Compare argument                   */
    COMPARERES       ** ppCompareRes
);



/*++
  DirList

    This API is used to list the object names of objects that are directly
    subordinate to the given object.

    If the list is incomplete, the PARTIALOUTCOME structure is returned.
    This structure indicates the reason for the failure and a set of DSA's
    to contact to complete the operation.  For this release, this will
    only occur when more selected data exists in this DSA than can be
    returned.  In this case the CONTREF will point back into the same
    DSA.  PARTIALOUTCOME is used as follows:

    If the pPartialOutcomeQualifier is NULL the query is complete.
    If the pointer is not NULL there is more data available.  More data
    can be retrieved by repeating the operation with the same input
    arguments except that the nameRes field of the CommArg structure is
    set to OP_NAMERES_COMPLETE.  Setting this field indicates to the DSA
    that the operation is continuing.  This continued call must use the
    same handle as the original call and must be the next operation
    made with this handle.  Subsequent continuing calls may be applied
    until all data are returned.
--*/

typedef struct _LISTARG
{
    PDSNAME     pObject;            /* object name (base of search)        */
    COMMARG     CommArg;            /* common arguments                    */
    struct _RESOBJ *pResObj;   /* for internal caching use, leave null */
} LISTARG;


typedef struct _CHILDLIST
{
    struct _CHILDLIST    * pNextChild;  /* linked-list to next info entry  */
    RDN FAR              * pChildName;  /* information about this entry    */
    BOOL                   aliasEntry;  /* If true the child is an alias   */
    BOOL                   fromMaster;  /* True if master object           */
} CHILDLIST;

#define PA_PROBLEM_TIME_LIMIT       'T'
#define PA_PROBLEM_SIZE_LIMIT       'S'
#define PA_PROBLEM_ADMIN_LIMIT      'A'

typedef struct _PARTIALOUTCOME
{
    UCHAR   problem;        /*  the reason for incomplete output
                             *   Valid values:
                             *     - PA_PROBLEM_TIME_LIMIT
                             *     - PA_PROBLEM_SIZE_LIMIT
                             *     - PA_PROBLEM_ADMIN_LIMIT
                             */
    UCHAR   unusedPad;
    USHORT  count;            /* count of unexplored DSAs */
    CONTREF *pUnexploredDSAs; /* Other DSA's to visit     */
} PARTIALOUTCOME;


typedef struct _LISTRES
{
    PDSNAME              pBase;          /* Name provided if an alias was
                                          *  dereferrenced.
                                          */
    ULONG                count;          /* number of output entries       */
    CHILDLIST            Firstchild;     /* linked-list of output entries  */

    PARTIALOUTCOME     * pPartialOutcomeQualifier;  /* incomplete operation*/

    PAGED_RESULT    PagedResult;         /* Paged Results local extension  */
    COMMRES              CommRes;
} LISTRES;


ULONG
DirList(
    LISTARG FAR   * pListArg,
    LISTRES      ** ppListRes

);



/*++
  DirSearch
--*/

#define SE_CHOICE_BASE_ONLY                 0
#define SE_CHOICE_IMMED_CHLDRN              1
#define SE_CHOICE_WHOLE_SUBTREE             2


typedef struct _SEARCHARG
{
    PDSNAME     pObject;        /* object name (base of search)              */
    UCHAR       choice;         /* depth of search:
                                 *  Valid values:
                                 *    - SE_CHOICE_BASE_ONLY
                                 *    - SE_CHOICE_IMMED_CHLDRN
                                 *    - SE_CHOICE_BASE_AND_SUBTREE
                                 */
    BOOL        bOneNC;         /* Are results constrained to same NC
                                 * as pObject
                                 */
    PFILTER     pFilter;        /* filter information
                                 *  (NULL if all objects selected)
                                 */
    BOOL        searchAliases;  /* If true, aliases are dereferenced for
                                 *  subtree elements.
                                 *  NOTE: ALWAYS Set to FALSE for this release.
                                 */
    ENTINFSEL * pSelection;     /* entry information selection
                                 *  (null means read all atts and values)
                                 */
    RANGEINFSEL *pSelectionRange;/* range information (i.e. max number of values
                                 * or subrange of values to read for a given
                                 * attribute
                                 */

    BOOL        fPutResultsInSortedTable:1;
                                 /* If set, leave the results in a
                                    temporary sorted Table and don't
                                    return a ENTINFLIST.
                                    The attribute to sort on is specified
                                    in CommArg.SortAttr
                                 */

    COMMARG     CommArg;        /* common arguments                          */
    struct _RESOBJ *pResObj;   /* for internal caching use, leave null */

} SEARCHARG;

typedef struct _SEARCHRES
{
    BOOL        baseProvided;       /* indicates if the base object name
                                     * is provided.  (Only provided when
                                     * an alias has been dereferenced
                                     */
    BOOL        bSorted;            /* indicates that these results have
                                     * been sorted based on the sort
                                     * attribute specified in the commarg
                                     * in the SEARCHARG
                                     */
    PDSNAME     pBase;              /* base object of subtree                */
    ULONG       count;              /* number of output entries              */
    ENTINFLIST  FirstEntInf;        /* linked-list of output entries         */
    RANGEINFLIST FirstRangeInf;     /* linked-list of output range info      */

    PARTIALOUTCOME *pPartialOutcomeQualifier;  /* Defined in DirList     */
                                    /* Indicates incomplete operation        */

    COMMRES       CommRes;          /* Common Results                        */
    PAGED_RESULT  PagedResult;      /* Paged Results extension related       */
    VLV_REQUEST   VLVRequest;       /* VLV Request extension related         */
    ASQ_REQUEST   ASQRequest;       /* ASQ Request extension related         */

    DWORD         SortResultCode;   /* Result code for sorting               */

} SEARCHRES;


ULONG
DirSearch (
    SEARCHARG     * pSearchArg,
    SEARCHRES    ** ppSearchRes
);

typedef BOOL (*PF_PFI)(DWORD hClient, DWORD hServer, void ** ppImpersonateData);
typedef void (*PF_TD)(DWORD hClient, DWORD hServer, ENTINF *pEntInf);
typedef void (*PF_SI)(DWORD hClient, DWORD hServer, void * pImpersonateData);

typedef struct _NOTIFYARG {
    PF_PFI pfPrepareForImpersonate;
    PF_TD  pfTransmitData;
    PF_SI  pfStopImpersonating;
    DWORD  hClient;
} NOTIFYARG;

typedef struct _NOTIFYRES {
    COMMRES     CommRes;
    DWORD       hServer;
} NOTIFYRES;


ULONG
DirNotifyRegister(
                  SEARCHARG *pSearchArg,
                  NOTIFYARG *pNotifyArg,
                  NOTIFYRES **ppNotifyRes
);

ULONG
DirNotifyUnRegister(
                    DWORD hServer,
                    NOTIFYRES **pNotifyRes
);

BOOL
DirPrepareForImpersonate (
        DWORD hClient,
        DWORD hServer,
        void ** ppImpersonateData
        );

VOID
DirStopImpersonating (
        DWORD hClient,
        DWORD hServer,
        void * pImpersonateData
        );


/*++
  DirAddEntry
--*/



typedef struct _ADDARG
{
    PDSNAME     pObject;                /* target object name                */
    ATTRBLOCK   AttrBlock;              /* The block of attributes to add    */
    PROPERTY_META_DATA_VECTOR *         /* Remote meta data vector to merge  */
                pMetaDataVecRemote;     /*   (should be NULL if !fDRA)       */
    COMMARG     CommArg;                /* common input arguments            */
    struct _RESOBJ * pResParent;        /* for internal caching use, leave null */
    struct _CREATENCINFO * pCreateNC;   /* for internal caching use, leave null */
    struct _ADDCROSSREFINFO * pCRInfo;  /* for internal caching use. leave null */

} ADDARG;


/* No result is returned on successful completion of the operation.          */
typedef struct _ADDRES
{
    COMMRES     CommRes;
} ADDRES;

ULONG DirAddEntry
(
    ADDARG        * pAddArg,        /* add argument                          */
    ADDRES       ** ppAddRes
);



/*++
  DirRemoveEntry

    This API is used to delete a directory leaf object.  Non-leaves
    cannot be removed (unless one first removes all of the object's
    children, which, in effect, makes the object itself a leaf).

--*/

typedef struct _REMOVEARG
{
    PDSNAME     pObject;              /* target object name                 */
    BOOL        fPreserveRDN;         /* don't mangle the tombstone RDN     */
    BOOL        fGarbCollectASAP;     /* set deletion time such that the    */
                                      /*   object will be picked up by the  */
                                      /*   next garbage collection and      */
                                      /*   physically deleted               */
    BOOL        fTreeDelete;          /* Try to delete the object and all   */
                                      /* children.  USE SPARINGLY!!!!       */
    BOOL        fDontDelCriticalObj;  /* If set, objects mark critical will */
                                      /* cause the delete to fail.  Used    */
                                      /* with tree delete to avoid disaster */
    PROPERTY_META_DATA_VECTOR *       /* Remote meta data vector to merge   */
                pMetaDataVecRemote;   /*   (should be NULL if !fDRA)        */
    COMMARG     CommArg;              /* common input arguments             */
    struct _RESOBJ *pResObj;       /* for internal caching use, leave null */
} REMOVEARG;

/* No result is returned on successful completion of the operation.         */
typedef struct _REMOVERES
{
    COMMRES     CommRes;
} REMOVERES;

ULONG DirRemoveEntry
(
    REMOVEARG  * pRemoveArg,
    REMOVERES ** ppRemoveRes
);



/*++
  DirModifyEntry
--*/

#define AT_CHOICE_ADD_ATT           'A'
#define AT_CHOICE_REMOVE_ATT        'R'
#define AT_CHOICE_ADD_VALUES        'a'
#define AT_CHOICE_REMOVE_VALUES     'r'
#define AT_CHOICE_REPLACE_ATT       'C'

typedef struct _ATTRMODLIST
{
    struct _ATTRMODLIST * pNextMod;     /* linked-list to next att mod      */

    USHORT      choice;                 /* modification type:
                                         *  Valid values:
                                         *    - AT_CHOICE_ADD_ATT
                                         *    - AT_CHOICE_REMOVE_ATT
                                         *    - AT_CHOICE_ADD_VALUES
                                         *    - AT_CHOICE_REMOVE_VALUES
                                         *    - AT_CHOICE_REPLACE_ATT
                                         */
    ATTR AttrInf;                       /* information about the attribute  */
} ATTRMODLIST;


typedef struct _MODIFYARG
{
    PDSNAME     pObject;                /* target object name               */
    USHORT      count;                  /* num of link modifications        */
    ATTRMODLIST FirstMod;               /* linked-list of attr mods         */
    PROPERTY_META_DATA_VECTOR *         /* Remote meta data vector to merge */
                pMetaDataVecRemote;     /*   (should be NULL if !fDRA)      */
    COMMARG     CommArg;                /* common input arguments           */
    struct _RESOBJ *pResObj;       /* for internal caching use, leave null */
} MODIFYARG;

/* No result is returned on successful completion of the operation.         */
typedef struct _MODIFYRES
{
    COMMRES     CommRes;
} MODIFYRES;

ULONG DirModifyEntry
(
    MODIFYARG  * pModifyArg,
    MODIFYRES ** ppModifyRes
);



/*++
  DirModifyDN

  Rename and object and/or change it's parent.

--*/

typedef struct _MODIFYDNARG
{
    PDSNAME     pObject;                 /* target object name              */
    PDSNAME     pNewParent;              /* name of new parent              */
    ATTR        *pNewRDN;                /* new rdn                         */
    PROPERTY_META_DATA_VECTOR *          /* Remote meta data vector to merge*/
                pMetaDataVecRemote;      /*   (should be NULL if !fDRA)     */
    COMMARG     CommArg;                 /* common input arguments          */
    PWCHAR      pDSAName;                /* destination DSA, cross DSA move */
    DWORD       fAllowPhantomParent;     // whether we allow the parent to be a phantom
                                         // useful if moving object under phantoms
    struct _RESOBJ *pResObj;       /* for internal caching use, leave null */
    struct _RESOBJ * pResParent;    /* for internal caching use, leave null */
} MODIFYDNARG;

/* No result is returned on successful completion of the operation.         */
typedef struct _MODIFYDNRES
{
    COMMRES     CommRes;
} MODIFYDNRES;

ULONG DirModifyDN
(
    MODIFYDNARG    * pModifyDNArg,
    MODIFYDNRES   ** ppModifyDNRes
);


/*++

  DirFind

  A light weight Search, that searches on a unique indexed attribute

--*/
typedef struct _FINDARG {
    ULONG       hDomain;
    ATTRTYP     AttId;
    ATTRVAL     AttrVal;
    COMMARG     CommArg;
    BOOL        fShortNames;
} FINDARG;

typedef struct _FINDRES {
    DSNAME     *pObject;
    COMMRES     CommRes;
} FINDRES;


DWORD DirGetDomainHandle(DSNAME *pDomainDN);

ULONG DirFindEntry
(
    FINDARG    *pFindArg,
    FINDRES    ** ppFindRes
);


/*++
  UpdateDSPerfStats

  Update performance counters held by NTDSA.DLL

  Note that the DSSTAT_ constants map directly to perf block offsets defined
  in the NTDSCTR.H file.  This is done so that UpdateDSPerfStats() can
  operate more efficiently (avoiding a large switch{} statement).

--*/

enum DSSTAT_TYPE
{
    DSSTAT_CREATEMACHINETRIES = 0,
    DSSTAT_CREATEMACHINESUCCESSFUL,
    DSSTAT_CREATEUSERTRIES,
    DSSTAT_CREATEUSERSUCCESSFUL,
    DSSTAT_PASSWORDCHANGES,
    DSSTAT_MEMBERSHIPCHANGES,
    DSSTAT_QUERYDISPLAYS,
    DSSTAT_ENUMERATIONS,
    DSSTAT_ASREQUESTS,
    DSSTAT_TGSREQUESTS,
    DSSTAT_KERBEROSLOGONS,
    DSSTAT_MSVLOGONS,
    DSSTAT_ATQTHREADSTOTAL,
    DSSTAT_ATQTHREADSLDAP,
    DSSTAT_ATQTHREADSOTHER,
    DSSTAT_UNKNOWN,             // always last item
};

// Count of exposed counters with UpdateDSPerfStats()

#define DSSTAT_COUNT            DSSTAT_UNKNOWN

VOID
UpdateDSPerfStats(
    IN DWORD        dwStat,
    IN DWORD        dwOperation,
    IN DWORD        dwChange
);

#define DSINIT_SAMLOOP_BACK      ((ULONG)(1<<0))
#define DSINIT_FIRSTTIME         ((ULONG)(1<<1))

typedef struct _DS_INSTALL_PARAM 
{
    PVOID BootKey;
    DWORD cbBootKey;
    BOOL  fPreferGcInstall;
    DWORD ReplicationEpoch;

    // The sam account name of the local computer
    LPWSTR AccountName;

    // The token of the caller requesting the install
    HANDLE ClientToken;
    
} DS_INSTALL_PARAM,*PDS_INSTALL_PARAM;

#define DSINSTALL_IFM_GC_REQUEST_CANNOT_BE_SERVICED  ((ULONG)(1<<0))

typedef struct _DS_INSTALL_RESULT
{
    DWORD ResultFlags;

    // Flags from the NTDS_INSTALL_* space to indicate
    // what operations have been completed and not undo
    // during initialization.
    ULONG InstallOperationsDone;

} DS_INSTALL_RESULT,*PDS_INSTALL_RESULT;

NTSTATUS
DsInitialize(
    ULONG Flags,
    IN  PDS_INSTALL_PARAM   InParams  OPTIONAL,
    OUT PDS_INSTALL_RESULT  OutParams OPTIONAL
    );

NTSTATUS
DsUninitialize(
    BOOL fExternalOnly
    );

VOID
DsaDisableUpdates(
    VOID
    );

VOID
DsaEnableUpdates(
    VOID
    );


#define NTDS_INSTALL_SERVER_CREATED 0x00000001
#define NTDS_INSTALL_DOMAIN_CREATED 0x00000002
#define NTDS_INSTALL_SERVER_MORPHED 0x00000004

typedef DWORD (*DSA_CALLBACK_STATUS_TYPE)( IN LPWSTR wczStatus );
typedef DWORD (*DSA_CALLBACK_ERROR_TYPE)(  IN PWSTR  Status,
                                           IN DWORD  WinError );
typedef DWORD (*DSA_CALLBACK_CANCEL_TYPE) ( BOOLEAN fCancelOk );
  
VOID
DsaSetInstallCallback(
    IN DSA_CALLBACK_STATUS_TYPE        pfnUpdateStatus,
    IN DSA_CALLBACK_ERROR_TYPE         pfnErrorStatus,
    IN DSA_CALLBACK_CANCEL_TYPE        pfnCancelOperation,
    IN HANDLE                          ClientToken
    );

NTSTATUS
DirErrorToNtStatus(
    IN  DWORD    DirError,
    IN  COMMRES *CommonResult
    );

DWORD
DirErrorToWinError(
    IN  DWORD    DirError,
    IN  COMMRES *CommonResult
    );

ULONG
DirProtectEntry(IN DSNAME *pObj);

LPWSTR
TransportAddrFromMtxAddr(
    IN  MTX_ADDR *  pmtx
    );

MTX_ADDR *
MtxAddrFromTransportAddr(
    IN  LPWSTR    psz
    );

LPWSTR
GuidBasedDNSNameFromDSName(
    IN  DSNAME *  pDN
    );

extern
LPCWSTR
MapSpnServiceClass(WCHAR *);

extern
NTSTATUS
MatchCrossRefBySid(
   IN PSID           SidToMatch,
   OUT PDSNAME       XrefDsName OPTIONAL,
   IN OUT PULONG     XrefNameLen
   );

extern
NTSTATUS
MatchCrossRefByNetbiosName(
   IN LPWSTR         NetbiosName,
   OUT PDSNAME       XrefDsName OPTIONAL,
   IN OUT PULONG     XrefNameLen
   );

extern
NTSTATUS
MatchDomainDnByNetbiosName(
   IN LPWSTR         NetbiosName,
   OUT PDSNAME       DomainDsName OPTIONAL,
   IN OUT PULONG     DomainDsNameLen
   );

NTSTATUS
MatchDomainDnByDnsName(
   IN LPWSTR         DnsName,
   OUT PDSNAME       DomainDsName OPTIONAL,
   IN OUT PULONG     DomainDsNameLen
   );

extern
NTSTATUS
FindNetbiosDomainName(
   IN DSNAME*        DomainDsName,
   OUT LPWSTR        NetbiosName OPTIONAL,
   IN OUT PULONG     NetbiosNameLen
   );

DSNAME *
DsGetDefaultObjCategory(
    IN  ATTRTYP objClass
    );


BOOL
DsCheckConstraint(
        IN ATTRTYP  attID,
        IN ATTRVAL *pAttVal,
        IN BOOL     fVerifyAsRDN
        );

BOOL
IsStringGuid(
    WCHAR       *pwszGuid,
    GUID        *pGuid
    );

#endif // MIDL_PASS not defined

#undef SIZE_IS
#undef SWITCH_IS
#undef CASE

#endif // _ntdsa_h_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\atq\inc\atq2.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1994-1997           **/
/**********************************************************************/

/*
    atq.h

    This module contains async thread queue (atq) for async IO and thread
    pool sharing among various services.

    Brief Description of ATQ:
      For description, please see iis\spec\isatq.doc

*/

#ifndef _ATQ2_H_
#define _ATQ2_H_


dllexp
VOID
AtqGetDatagramAddrs(
    IN  PATQ_CONTEXT patqContext,
    OUT SOCKET *     pSock,
    OUT PVOID *      ppvBuff,
    OUT PVOID *      pEndpointContext,
    OUT SOCKADDR * * ppsockaddrRemote,
    OUT INT *        pcbsockaddrRemote
    );

dllexp
DWORD_PTR
AtqContextGetInfo(
    PATQ_CONTEXT           patqContext,
    enum ATQ_CONTEXT_INFO  atqInfo
    );

dllexp
BOOL
AtqWriteDatagramSocket(
    IN PATQ_CONTEXT  patqContext,
    IN LPWSABUF     pwsaBuffers,
    IN DWORD        dwBufferCount,
    IN OVERLAPPED *  lpo OPTIONAL
    );

#endif // !_ATQ2_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\atq\inc\tracelog.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    tracelog.h

Abstract:

    This module contains public declarations and definitions for creating
    trace logs.

    A trace log is a fast, in-memory, thread safe activity log useful
    for debugging certain classes of problems. They are especially useful
    when debugging reference count bugs.

    Note that the creator of the log has the option of adding "extra"
    bytes to the log header. This can be useful if the creator wants to
    create a set of global logs, each on a linked list.

Author:

    Keith Moore (keithmo)        30-Apr-1997

Revision History:

--*/


#ifndef _TRACELOG_H_
#define _TRACELOG_H_


#if defined(__cplusplus)
extern "C" {
#endif  // __cplusplus


typedef struct _TRACE_LOG {

    //
    // Signature.
    //

    LONG Signature;

    //
    // The total number of entries available in the log.
    //

    LONG LogSize;

    //
    // The index of the next entry to use.
    //

    LONG NextEntry;

    //
    // The byte size of each entry.
    //

    LONG EntrySize;

    //
    // Pointer to the start of the circular buffer.
    //

    PUCHAR LogBuffer;

    //
    // The extra header bytes and actual log entries go here.
    //
    // BYTE ExtraHeaderBytes[ExtraBytesInHeader];
    // BYTE Entries[LogSize][EntrySize];
    //

} TRACE_LOG, *PTRACE_LOG;


//
// Log header signature.
//

#define TRACE_LOG_SIGNATURE   ((DWORD)'gOlT')
#define TRACE_LOG_SIGNATURE_X ((DWORD)'golX')


//
// This macro maps a TRACE_LOG pointer to a pointer to the 'extra'
// data associated with the log.
//

#define TRACE_LOG_TO_EXTRA_DATA(log)    (PVOID)( (log) + 1 )


//
// Manipulators.
//

PTRACE_LOG
CreateTraceLog(
    IN LONG LogSize,
    IN LONG ExtraBytesInHeader,
    IN LONG EntrySize
    );

VOID
DestroyTraceLog(
    IN PTRACE_LOG Log
    );

VOID
WriteTraceLog(
    IN PTRACE_LOG Log,
    IN PVOID Entry
    );

VOID
ResetTraceLog(
    IN PTRACE_LOG Log
    );


#if defined(__cplusplus)
}   // extern "C"
#endif  // __cplusplus


#endif  // _TRACELOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\atq\inc\ntdsadef.h ===
/* Definitions from the NTDSA that are exposed to the rest of NT, but not
 * to the public at large.
 */

#define MAX_RDN_SIZE          255   /* The max size of an relative name value,
                                     * in Unicode characters */
#define MAX_RDN_KEY_SIZE      256    /* The max size of a RDN Key eg: "CN=" */
                                     /* or "OID.1.2...=" */
//
// This named event is set when the delayed start up thread is finished 
// successfully or otherwise.  In-proc clients can use 
// DsWaitUntilDelayedStartupIsDone() wait and recieve the ntstatus of the
// delayed thread.  Out of proc clients can wait on this event; there is 
// no mechanism to retrieve the return code.
//
#define NTDS_DELAYED_STARTUP_COMPLETED_EVENT TEXT("NtdsDelayedStartupCompletedEvent")


/*
 * Bit flags for the (read-only) system-Flags attribute.  Note that low order
 * bits are object class specific, and hence can have different meanings on
 * objects of different classes, the high order bits have constant meaning
 * across all object classes.
 */

/* Object Class independent bits */
// NOTE: These flags MAY have different behaviour in different NCs.
// For example, the FLAG_CONFIG_foo flags only have meaning inside the
// configuration NC.  the FLAG_DOMAIN_foo flags have meaning only outside the
// configuration NC.  
#define FLAG_DISALLOW_DELETE           0x80000000
#define FLAG_CONFIG_ALLOW_RENAME       0x40000000 
#define FLAG_CONFIG_ALLOW_MOVE         0x20000000 
#define FLAG_CONFIG_ALLOW_LIMITED_MOVE 0x10000000 
#define FLAG_DOMAIN_DISALLOW_RENAME    0x08000000
#define FLAG_DOMAIN_DISALLOW_MOVE      0x04000000
#define FLAG_DISALLOW_MOVE_ON_DELETE   0x02000000

/* Object Class specific bits, by object class */

/* CrossReference objects */
#define FLAG_CR_NTDS_NC       0x00000001 // NC is in NTDS (not VC or foreign)
#define FLAG_CR_NTDS_DOMAIN   0x00000002 // NC is a domain (not non-domain NC)
#define FLAG_CR_NTDS_NOT_GC_REPLICATED 0x00000004 // NC is not to be replicated to GCs as a read only replica.

/* Attribute-Schema objects */
#define FLAG_ATTR_NOT_REPLICATED         (0x00000001) // Attribute is not replicated
#define FLAG_ATTR_REQ_PARTIAL_SET_MEMBER (0x00000002) // Attribute is required to be
                                                      //   member of the partial set
#define FLAG_ATTR_IS_CONSTRUCTED         (0x00000004) // Attribute is a constructed att
#define FLAG_ATTR_IS_OPERATIONAL         (0x00000008) // Attribute is an operational att

/* Attribute-Schema or Class-Schema objects */
#define FLAG_SCHEMA_BASE_OBJECT          (0x00000010) // Base schema object

/* Attribute-Schema objects */
// A user may set, but not reset, FLAG_ATTR_IS_RDN in attributeSchema
// objects in the SchemaNC. The user sets FLAG_ATTR_IS_RDN to identify
// which of several attributes with the same attributeId should be
// used as the rdnattid of a new class. Once set, the attribute is
// treated as if it were used as the rdnattid of some class; meaning it
// cannot be reused.
#define FLAG_ATTR_IS_RDN                 (0x00000020) // can be used as key in rdn (key=rdn)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\atq\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_kdcatq_none_12.4.56.0_none_05dce1169e2e0ce4
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_kdcatq_no-public-key_12.4.56.0_x-ww_06af902a
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=kdcatq
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_kdcatq_no-public-key_12.4.56.0_x-ww_06af902a
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_kdcatq_no-public-key_12.4.56.0_x-ww_06af902a.manifest
XP_MANIFEST_PATH=manifests\x86_kdcatq_no-public-key_12.4.56.0_x-ww_06af902a.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_kdcatq_no-public-key_12.4.56.0_x-ww_06af902a.cat
XP_CATALOG_PATH=manifests\x86_kdcatq_no-public-key_12.4.56.0_x-ww_06af902a.cat
XP_PAYLOAD_PATH=x86_kdcatq_no-public-key_12.4.56.0_x-ww_06af902a
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=kdcatq,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\atq\inc\uspud.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1994-1997           **/
/**********************************************************************/

/*
    uspud.h

    This module contains usermode interface to the spud.sys driver.


*/

#ifndef _USPUD_H_
#define _USPUD_H_


#ifdef __cplusplus
extern "C" {
#endif

extern
NTSTATUS
NTAPI
SPUDTransmitFileAndRecv(
    HANDLE                  hSocket,                // Socket handle to use for operation
    PAFD_TRANSMIT_FILE_INFO transmitInfo,           // transmit file req info
    PAFD_RECV_INFO          recvInfo,               // recv req info
    PSPUD_REQ_CONTEXT       reqContext              // context info for req
    );


extern
NTSTATUS
NTAPI
SPUDSendAndRecv(
    HANDLE                  hSocket,                // Socket handle to use for operation
    PAFD_SEND_INFO          sendInfo,               // send req info
    PAFD_RECV_INFO          recvInfo,               // recv req info
    PSPUD_REQ_CONTEXT       reqContext              // context info for req
    );


extern
NTSTATUS
NTAPI
SPUDCancel(
    PSPUD_REQ_CONTEXT       reqContext              // context info for req
    );

extern
NTSTATUS
NTAPI
SPUDCheckStatus(
    PSPUD_REQ_CONTEXT       reqContext              // context info for req
    );

extern
NTSTATUS
NTAPI
SPUDGetCounts(
    PSPUD_COUNTERS      SpudCounts,              // Counters
    DWORD               ClearCounts
    );

extern
NTSTATUS
NTAPI
SPUDInitialize(
    DWORD       Version,        // Version information from spud.h
    HANDLE      hPort           // Handle of completion port for atq
    );

extern
NTSTATUS
NTAPI
SPUDTerminate(
    VOID
    );

extern
NTSTATUS
NTAPI
SPUDCreateFile(
    OUT PHANDLE FileHandle,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG FileAttributes,
    IN ULONG ShareAccess,
    IN ULONG CreateOptions,
    IN SECURITY_INFORMATION SecurityInformation,
    OUT PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN ULONG Length,
    OUT PULONG LengthNeeded,
    IN PVOID pOplock
    );

extern
NTSTATUS
NTAPI
SPUDOplockAcknowledge(
    IN HANDLE FileHandle,
    IN PVOID pOplock
    );

#ifdef __cplusplus
}
#endif

#endif //!_USPUD_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\cryptDLL\crc32.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    crc32.c

Abstract:

    CRC-32 alogorithm

Author:

    MikeSw

Revision History:

    31-Mar-94       MikeSw      Created
    25-Jul-96       ChandanS    Copied from net\svcdlls\ntlmssp\client\crc32.c
    27-Jan-07       MikeSw      Incorporated x86 ASM code for performance

--*/

#include "cryptdllp.h"



#define CRC32_LEN 4


NTSTATUS NTAPI
Crc32Initialize(ULONG dwSeed,
                PCHECKSUM_BUFFER * ppcsBuffer);

NTSTATUS NTAPI
KerbCrc32Initialize(ULONG dwSeed,
                PCHECKSUM_BUFFER * ppcsBuffer);

NTSTATUS NTAPI
Crc32Sum(   PCHECKSUM_BUFFER pcsBuffer,
            ULONG           cbData,
            PUCHAR          pbData );

NTSTATUS NTAPI
Crc32Finalize(  PCHECKSUM_BUFFER pcsBuffer,
                PUCHAR          pbSum);
NTSTATUS NTAPI
KerbCrc32Finalize(  PCHECKSUM_BUFFER pcsBuffer,
                PUCHAR          pbSum);

NTSTATUS NTAPI
Crc32InitializeEx(  PUCHAR Key,
                    ULONG KeySize,
                    ULONG MessageType,
                    PCHECKSUM_BUFFER *pcsBuffer);
NTSTATUS NTAPI
KerbCrc32InitializeEx(  PUCHAR Key,
                        ULONG KeySize,
                        ULONG MessageType,
                        PCHECKSUM_BUFFER *pcsBuffer);

NTSTATUS NTAPI
Crc32Finish(PCHECKSUM_BUFFER *   ppcsBuffer);

CHECKSUM_FUNCTION csfCRC32 = {
    KERB_CHECKSUM_REAL_CRC32,
    CRC32_LEN,
    0,
    Crc32Initialize,
    Crc32Sum,
    Crc32Finalize,
    Crc32Finish,
    Crc32InitializeEx,
    NULL
};


CHECKSUM_FUNCTION csfKERB_CRC32 = {
    KERB_CHECKSUM_CRC32,
    CRC32_LEN,
    0,
    KerbCrc32Initialize,
    Crc32Sum,
    KerbCrc32Finalize,
    Crc32Finish,
    KerbCrc32InitializeEx,
    NULL
};

#ifdef KERNEL_MODE
#pragma alloc_text( PAGEMSG, Crc32Initialize )
#pragma alloc_text( PAGEMSG, Crc32Sum )
#pragma alloc_text( PAGEMSG, Crc32Finalize )
#pragma alloc_text( PAGEMSG, Crc32Finish )
#pragma alloc_text( PAGEMSG, Crc32InitializeEx )
#pragma alloc_text( PAGEMSG, KerbCrc32Initialize )
#pragma alloc_text( PAGEMSG, KerbCrc32Finalize )
#pragma alloc_text( PAGEMSG, KerbCrc32InitializeEx )
#endif

typedef struct _CRC32_CONTEXT {
    ULONG  crc;
} CRC32_CONTEXT, *PCRC32_CONTEXT;



//
// This code comes from Dr. Dobbs Journal, May 1992
//


static unsigned long CRCTable[256] = {
    0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F,
    0xE963A535, 0x9E6495A3, 0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988,
    0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91, 0x1DB71064, 0x6AB020F2,
    0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
    0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9,
    0xFA0F3D63, 0x8D080DF5, 0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172,
    0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B, 0x35B5A8FA, 0x42B2986C,
    0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,
    0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423,
    0xCFBA9599, 0xB8BDA50F, 0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,
    0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D, 0x76DC4190, 0x01DB7106,
    0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
    0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D,
    0x91646C97, 0xE6635C01, 0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E,
    0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457, 0x65B0D9C6, 0x12B7E950,
    0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,
    0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7,
    0xA4D1C46D, 0xD3D6F4FB, 0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0,
    0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9, 0x5005713C, 0x270241AA,
    0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
    0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81,
    0xB7BD5C3B, 0xC0BA6CAD, 0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A,
    0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683, 0xE3630B12, 0x94643B84,
    0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,
    0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB,
    0x196C3671, 0x6E6B06E7, 0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC,
    0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5, 0xD6D6A3E8, 0xA1D1937E,
    0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,
    0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55,
    0x316E8EEF, 0x4669BE79, 0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,
    0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 0xC5BA3BBE, 0xB2BD0B28,
    0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,
    0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F,
    0x72076785, 0x05005713, 0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38,
    0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 0x86D3D2D4, 0xF1D4E242,
    0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,
    0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69,
    0x616BFFD3, 0x166CCF45, 0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2,
    0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB, 0xAED16A4A, 0xD9D65ADC,
    0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
    0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693,
    0x54DE5729, 0x23D967BF, 0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94,
    0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D };


NTSTATUS NTAPI
Crc32Sum(   PCHECKSUM_BUFFER pcsBuffer,
            ULONG           cbBuffer,
            PUCHAR          pvBuffer )
{
    PCRC32_CONTEXT pContext = pcsBuffer;
    unsigned long dwCrc = pContext->crc;
    unsigned char * pbBuffer;

#ifdef _X86_
_asm
{
  mov     ecx, DWORD PTR cbBuffer
  shr     ecx, 2
  mov     eax, ecx
  dec     ecx
  mov     esi, DWORD PTR pvBuffer

  mov     edx, DWORD PTR dwCrc
  test    eax, eax
  je      SHORT $LABEL2
  inc     ecx
$LABEL1:
  mov     ebx, DWORD PTR [esi]
  add     esi, 4

  mov     eax, ebx
  shr     ebx, 8
  xor     eax, edx
  and     eax, 0FFh
  shr     edx, 8
  mov     edi, DWORD PTR CRCTable[eax*4]
  xor     edx, edi

  mov     eax, ebx
  shr     ebx, 8
  xor     eax, edx
  and     eax, 0FFh
  shr     edx, 8
  mov     edi, DWORD PTR CRCTable[eax*4]
  xor     edx, edi

  mov     eax, ebx
  shr     ebx, 8
  xor     eax, edx
  and     eax, 0FFh
  shr     edx, 8
  mov     edi, DWORD PTR CRCTable[eax*4]
  xor     edx, edi

  mov     eax, ebx
;  shr     ebx, 8  -- Not needed on last byte
  xor     eax, edx
  and     eax, 0FFh
  shr     edx, 8
  mov     edi, DWORD PTR CRCTable[eax*4]
  xor     edx, edi

  dec     ecx
  jne     SHORT $LABEL1
$LABEL2:
  mov     DWORD PTR dwCrc, edx
  mov     DWORD PTR pbBuffer, esi
}

    cbBuffer &= 0x3;
#else // _X86_
    pbBuffer = (unsigned char *) pvBuffer;
#endif
    while (cbBuffer-- != 0)
    {
        dwCrc = (dwCrc >> 8) ^ CRCTable[(unsigned char) dwCrc ^ *pbBuffer++];
    }
    pContext->crc= dwCrc;
    return(STATUS_SUCCESS);

}

NTSTATUS NTAPI
Crc32Initialize(ULONG dwSeed,
                PCHECKSUM_BUFFER * ppcsBuffer)
{
    PCRC32_CONTEXT pContext;

#ifdef KERNEL_MODE
    pContext = ExAllocatePool(NonPagedPool, sizeof(CRC32_CONTEXT));
#else
    pContext = malloc(sizeof(CRC32_CONTEXT));
#endif
    if (!pContext)
    {
        return(SEC_E_INSUFFICIENT_MEMORY);
    }

    pContext->crc = 0xffffffff;

    *ppcsBuffer = (PCHECKSUM_BUFFER) pContext;
    return(STATUS_SUCCESS);
}


NTSTATUS NTAPI
KerbCrc32Initialize(
    ULONG dwSeed,
    PCHECKSUM_BUFFER * ppcsBuffer
    )
{
    PCRC32_CONTEXT pContext;

#ifdef KERNEL_MODE
    pContext = ExAllocatePool(NonPagedPool, sizeof(CRC32_CONTEXT));
#else
    pContext = malloc(sizeof(CRC32_CONTEXT));
#endif
    if (!pContext)
    {
        return(SEC_E_INSUFFICIENT_MEMORY);
    }

    pContext->crc = 0;

    *ppcsBuffer = (PCHECKSUM_BUFFER) pContext;
    return(STATUS_SUCCESS);
}


NTSTATUS NTAPI
Crc32Finalize(  PCHECKSUM_BUFFER pcsBuffer,
                PUCHAR          pbSum)
{
    *(PULONG)pbSum = ((PCRC32_CONTEXT)pcsBuffer)->crc ^ 0xffffffff;
    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
KerbCrc32Finalize(
    PCHECKSUM_BUFFER pcsBuffer,
    PUCHAR          pbSum
    )
{
    *(PULONG)pbSum = ((PCRC32_CONTEXT)pcsBuffer)->crc;
    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
Crc32Finish(PCHECKSUM_BUFFER *   ppcsBuffer)
{
#ifdef KERNEL_MODE
    ExFreePool(*ppcsBuffer);
#else
    free(*ppcsBuffer);
#endif
    *ppcsBuffer = NULL;
    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
Crc32InitializeEx(  PUCHAR Key,
                    ULONG KeySize,
                    ULONG MessageType,
                    PCHECKSUM_BUFFER *pcsBuffer)
{
    return(Crc32Initialize(0, pcsBuffer));
}

NTSTATUS NTAPI
KerbCrc32InitializeEx(  PUCHAR Key,
                        ULONG KeySize,
                        ULONG MessageType,
                        PCHECKSUM_BUFFER *pcsBuffer)
{
    return(KerbCrc32Initialize(0, pcsBuffer));
}

=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\atq\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_kdcatq_none_12.4.56.0_none_05dce1169e2e0ce4
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_kdcatq_no-public-key_12.4.56.0_x-ww_06af902a
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=kdcatq
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_kdcatq_no-public-key_12.4.56.0_x-ww_06af902a
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_kdcatq_no-public-key_12.4.56.0_x-ww_06af902a.manifest
XP_MANIFEST_PATH=manifests\x86_kdcatq_no-public-key_12.4.56.0_x-ww_06af902a.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_kdcatq_no-public-key_12.4.56.0_x-ww_06af902a.cat
XP_CATALOG_PATH=manifests\x86_kdcatq_no-public-key_12.4.56.0_x-ww_06af902a.cat
XP_PAYLOAD_PATH=x86_kdcatq_no-public-key_12.4.56.0_x-ww_06af902a
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=kdcatq,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\cryptDLL\cryptdllp.h ===
#define WIN32_NO_STATUS
#include <winternl.h>
#undef WIN32_NO_STATUS
#include <windows.h>
#include <ntstatus.h>
typedef NTSTATUS * PNTSTATUS;
#define _NTDEF_
#include <ntsecapi.h>
#undef _NTDEF_
#include <subauth.h>

#include <string.h>
#include <malloc.h>
#include <process.h>

#include "align.h"
typedef LONG SECURITY_STATUS;
#include "ntrtl.h"

#include <lmcons.h>
#include <security.h>
#include <cryptdll.h>
#include <crypt.h>
#include <randlib.h>

#include "modes.h"
#include <rc4.h>
#include "md4.h"
#include "md5.h"
#include "des.h"
#include "sha.h"

#include <assert.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\cryptDLL\crc32new.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    crc32.c

Abstract:

    CRC-32 alogorithm

Author:

    MikeSw

Revision History:

    31-Mar-94       MikeSw      Created

--*/

#include "crc32.h"

//
// This code comes from Dr. Dobbs Journal, May 1992
//


unsigned long CRCTable[256] = {
    0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F,
    0xE963A535, 0x9E6495A3, 0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988,
    0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91, 0x1DB71064, 0x6AB020F2,
    0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
    0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9,
    0xFA0F3D63, 0x8D080DF5, 0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172,
    0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B, 0x35B5A8FA, 0x42B2986C,
    0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,
    0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423,
    0xCFBA9599, 0xB8BDA50F, 0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,
    0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D, 0x76DC4190, 0x01DB7106,
    0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
    0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D,
    0x91646C97, 0xE6635C01, 0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E,
    0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457, 0x65B0D9C6, 0x12B7E950,
    0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,
    0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7,
    0xA4D1C46D, 0xD3D6F4FB, 0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0,
    0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9, 0x5005713C, 0x270241AA,
    0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
    0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81,
    0xB7BD5C3B, 0xC0BA6CAD, 0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A,
    0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683, 0xE3630B12, 0x94643B84,
    0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,
    0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB,
    0x196C3671, 0x6E6B06E7, 0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC,
    0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5, 0xD6D6A3E8, 0xA1D1937E,
    0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,
    0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55,
    0x316E8EEF, 0x4669BE79, 0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,
    0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 0xC5BA3BBE, 0xB2BD0B28,
    0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,
    0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F,
    0x72076785, 0x05005713, 0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38,
    0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 0x86D3D2D4, 0xF1D4E242,
    0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,
    0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69,
    0x616BFFD3, 0x166CCF45, 0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2,
    0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB, 0xAED16A4A, 0xD9D65ADC,
    0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
    0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693,
    0x54DE5729, 0x23D967BF, 0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94,
    0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D };


void
Crc32(  unsigned long dwCrc,
        unsigned long cbBuffer,
        void * pvBuffer,
        unsigned long * pNewCrc)
{
    unsigned char * pbBuffer = (unsigned char *) pvBuffer;

    while (cbBuffer-- != 0)
    {
        dwCrc = (dwCrc >> 8) ^ CRCTable[(unsigned char) dwCrc ^ *pbBuffer++];
    }
    *pNewCrc = dwCrc;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\cryptDLL\cryptmgr.c ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:        cryptmgr.c
//
// Contents:    Crypto manager
//
//
// History:     xx Dec 91   RichardW    Created
//              04 Jun 92   RichardW    NTized
//
//------------------------------------------------------------------------

#include "cryptdllp.h"


#ifdef KERNEL_MODE
#pragma alloc_text( PAGEMSG, CDRegisterCSystem )
#pragma alloc_text( PAGEMSG, CDBuildVect )
#pragma alloc_text( PAGEMSG, CDBuildIntegrityVect )
#pragma alloc_text( PAGEMSG, CDLocateCSystem )
#pragma alloc_text( PAGEMSG, CDFindCommonCSystem )
#pragma alloc_text( PAGEMSG, CDFindCommonCSystemWithKey )
#endif 

#define MAX_CSYSTEMS    16

CRYPTO_SYSTEM    CSystems[MAX_CSYSTEMS];
ULONG           cCSystems = 0;
ULONG           cIntegrityCSystems = 0;

// Register the crypto system

NTSTATUS NTAPI
CDRegisterCSystem(  PCRYPTO_SYSTEM   pcsNewSystem)
{
    if (cCSystems + 1 < MAX_CSYSTEMS)
    {
        CSystems[cCSystems++] = *pcsNewSystem;
        if ((pcsNewSystem->Attributes & CSYSTEM_INTEGRITY_PROTECTED) != 0)
        {
            cIntegrityCSystems++;
        }
        return(S_OK);
    }
    return(STATUS_INSUFFICIENT_RESOURCES);
}


NTSTATUS NTAPI
CDBuildVect(    ULONG *     pcCSystems,
                ULONG *     pdwEtypes)
{
    ULONG   iCS;

    *pcCSystems = cCSystems;
    if (!pdwEtypes)
    {
        return(S_OK);
    }
    for (iCS = 0; iCS < cCSystems; iCS++)
    {
        *pdwEtypes++ = CSystems[iCS].EncryptionType;
    }
    return(S_OK);
}

NTSTATUS NTAPI
CDBuildIntegrityVect(
    PULONG      pcCSystems,
    PULONG      pdwEtypes)
{
    ULONG   iCS;

    *pcCSystems = cIntegrityCSystems;
    if (!pdwEtypes)
    {
        return(S_OK);
    }
    for (iCS = 0; iCS < cCSystems; iCS++)
    {
        if ((CSystems[iCS].Attributes & CSYSTEM_INTEGRITY_PROTECTED) != 0)
        {
            *pdwEtypes++ = CSystems[iCS].EncryptionType;
        }
    }
    return(S_OK);
}

NTSTATUS NTAPI
CDLocateCSystem(ULONG           dwEtype,
                PCRYPTO_SYSTEM * ppcsSystem)
{
    ULONG   iCS = cCSystems;

    while (iCS--)
    {
        if (CSystems[iCS].EncryptionType == dwEtype)
        {
            *ppcsSystem = &CSystems[iCS];
            return(S_OK);
        }
    }
    return(SEC_E_ETYPE_NOT_SUPP);
}


NTSTATUS NTAPI
CDFindCommonCSystem(ULONG   cEntries,
                    ULONG * pdwEtypes,
                    ULONG * pdwCommonEtype)
{
    ULONG   i, j;

    *pdwCommonEtype = 0;

    for (i = 0; i < cEntries ; i++)
    {
        for (j = 0 ; j < cCSystems ; j++ )
        {
            if (pdwEtypes[i] == CSystems[j].EncryptionType)
            {
                *pdwCommonEtype = pdwEtypes[i];
                return(STATUS_SUCCESS);
            }
        }
    }

    return(SEC_E_ETYPE_NOT_SUPP);
}

NTSTATUS NTAPI
CDFindCommonCSystemWithKey(
    IN ULONG EncryptionEntries,
    IN PULONG EncryptionTypes,
    IN ULONG KeyTypeCount,
    IN PULONG KeyTypes,
    OUT PULONG CommonEtype)
{
    ULONG   i, j, k;

    *CommonEtype = 0;

    for (i = 0; i < EncryptionEntries ; i++)
    {
        for (j = 0 ; j < cCSystems ; j++ )
        {
            if (EncryptionTypes[i] == CSystems[j].EncryptionType)
            {

                //
                // Make sure we have a key for this encryption type
                //

                for (k = 0; k < KeyTypeCount ; k++ )
                {
                    if (KeyTypes[k] == EncryptionTypes[i])
                    {
                        *CommonEtype = EncryptionTypes[i];
                        return(STATUS_SUCCESS);

                    }
                }
            }
        }
    }

    return(SEC_E_ETYPE_NOT_SUPP);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\cryptDLL\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\cryptDLL\cryptdll.c ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:        crypt.c
//
// Contents:    Root DLL file
//
//
// History:     04 Jun 92   RichardW    Created
//
//------------------------------------------------------------------------

#include "cryptdllp.h"


//#define DONT_SUPPORT_OLD_ETYPES 1

//  List Default CryptoSystems here.  If you add anything, be sure to add it
//  in the LoadCSystems() function


extern CRYPTO_SYSTEM     csRC4_HMAC;
extern CRYPTO_SYSTEM     csRC4_HMAC_EXP;
extern CRYPTO_SYSTEM     csRC4_LM;
extern CRYPTO_SYSTEM     csRC4_PLAIN;
extern CRYPTO_SYSTEM     csRC4_PLAIN_EXP;
#ifndef DONT_SUPPORT_OLD_ETYPES
extern CRYPTO_SYSTEM     csRC4_MD4;
extern CRYPTO_SYSTEM     csRC4_HMAC_OLD;
extern CRYPTO_SYSTEM     csRC4_HMAC_OLD_EXP;
extern CRYPTO_SYSTEM     csRC4_PLAIN_OLD;
extern CRYPTO_SYSTEM     csRC4_PLAIN_OLD_EXP;
#endif

extern CRYPTO_SYSTEM     csDES_MD5;
extern CRYPTO_SYSTEM     csDES_CRC32;
extern CRYPTO_SYSTEM     csDES_PLAIN;
extern CRYPTO_SYSTEM     csNULL;

extern CHECKSUM_FUNCTION csfMD4;
extern CHECKSUM_FUNCTION csfMD5;
extern CHECKSUM_FUNCTION csfCRC32;
extern CHECKSUM_FUNCTION csfKERB_CRC32;
extern CHECKSUM_FUNCTION csfSHA;
extern CHECKSUM_FUNCTION csfLM;
extern CHECKSUM_FUNCTION csfRC4_MD5;
extern CHECKSUM_FUNCTION csfDES_MAC_MD5;
extern CHECKSUM_FUNCTION csfMD5_HMAC;
extern CHECKSUM_FUNCTION csfHMAC_MD5;
extern CHECKSUM_FUNCTION csfMD25;
extern CHECKSUM_FUNCTION csfDesMac;
extern CHECKSUM_FUNCTION csfDesMacK;
extern CHECKSUM_FUNCTION csfDesMac1510;
extern CHECKSUM_FUNCTION csfDES_MAC_MD5_1510;

extern RANDOM_NUMBER_GENERATOR    DefaultRng;

SECURITY_STATUS   LoadCSystems(void);
SECURITY_STATUS   LoadCheckSums(void);
BOOLEAN              LoadRngs(void);

#ifdef WIN32_CHICAGO
BOOL Sys003Initialize (PVOID hInstance, ULONG dwReason, PVOID lpReserved);
#endif // WIN32_CHICAGO

int
LibAttach(
    HANDLE  hInstance,
    PVOID   lpReserved)
{
    SECURITY_STATUS   scRet;


    scRet = LoadCSystems();
    scRet = LoadCheckSums();
    (void) LoadRngs();

    if (scRet)
        return(0);
    else
        return(1);
}

#ifndef KERNEL_MODE
#define _DECL_DLLMAIN
#include <process.h>

BOOL WINAPI DllMain (
    HANDLE          hInstance,
    ULONG           dwReason,
    PVOID           lpReserved)
{
#ifdef WIN32_CHICAGO
    if (!Sys003Initialize ((PVOID) hInstance, dwReason, NULL ))
    {
        // Something really bad happened
        return FALSE;
    }
#endif // WIN32_CHICAGO
    if ( dwReason == DLL_PROCESS_ATTACH )
    {
    DisableThreadLibraryCalls ( hInstance );
    return LibAttach ( hInstance, lpReserved );
    }
    else
    return TRUE;

}
#endif // KERNEL_MODE

SECURITY_STATUS
LoadCSystems(void)
{
    //
    // The order here is the order of preference
    //

    CDRegisterCSystem( &csRC4_HMAC);
#ifndef DONT_SUPPORT_OLD_ETYPES
    CDRegisterCSystem( &csRC4_HMAC_OLD);
    CDRegisterCSystem( &csRC4_MD4);
#endif
    CDRegisterCSystem( &csDES_MD5);
    CDRegisterCSystem( &csDES_CRC32);
    CDRegisterCSystem( &csRC4_PLAIN);
    CDRegisterCSystem( &csRC4_PLAIN_EXP);
    CDRegisterCSystem( &csRC4_HMAC_EXP);
#ifndef DONT_SUPPORT_OLD_ETYPES
    CDRegisterCSystem( &csRC4_HMAC_OLD_EXP);
    CDRegisterCSystem( &csRC4_PLAIN_OLD);
    CDRegisterCSystem( &csRC4_PLAIN_OLD_EXP);
#endif
    CDRegisterCSystem( &csDES_PLAIN);


    return(0);

}

SECURITY_STATUS
LoadCheckSums(void)
{
    CDRegisterCheckSum( &csfMD5_HMAC );
    CDRegisterCheckSum( &csfHMAC_MD5 );
    CDRegisterCheckSum( &csfMD4);
    CDRegisterCheckSum( &csfMD5);
    CDRegisterCheckSum( &csfKERB_CRC32);
    CDRegisterCheckSum( &csfDES_MAC_MD5 );
    CDRegisterCheckSum( &csfMD25 );
    CDRegisterCheckSum( &csfDesMac );
    CDRegisterCheckSum( &csfRC4_MD5 );
    CDRegisterCheckSum( &csfCRC32);
#ifndef KERNEL_MODE
    CDRegisterCheckSum( &csfLM );
#endif
    CDRegisterCheckSum( &csfSHA );
    CDRegisterCheckSum( &csfDES_MAC_MD5_1510 );
    CDRegisterCheckSum( &csfDesMac1510 );
    CDRegisterCheckSum( &csfDesMacK );

    return(0);
}

BOOLEAN
LoadRngs(void)
{
    CDRegisterRng(&DefaultRng);
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\cryptDLL\lmwrap.c ===
//
//

#include "cryptdllp.h"


#ifdef WIN32_CHICAGO
NTSTATUS
MyRtlUpcaseUnicodeStringToOemString(
    OUT POEM_STRING DestinationString,
    IN PUNICODE_STRING SourceString,
    IN BOOLEAN AllocateDestinationString
    );
#define RtlUpcaseUnicodeStringToOemString(x, y, z)  MyRtlUpcaseUnicodeStringToOemString(x, y, z)
#endif // WIN32_CHICAGO
typedef struct _LM_STATE_BUFFER {
    LM_OWF_PASSWORD Password;
} LM_STATE_BUFFER, *PLM_STATE_BUFFER;


NTSTATUS NTAPI
LmWrapInitialize(ULONG dwSeed,
                PCHECKSUM_BUFFER * ppcsBuffer);

NTSTATUS NTAPI
LmWrapSum(   PCHECKSUM_BUFFER pcsBuffer,
            ULONG           cbData,
            PUCHAR          pbData );

NTSTATUS NTAPI
LmWrapFinalize(  PCHECKSUM_BUFFER pcsBuffer,
                PUCHAR          pbSum);

NTSTATUS NTAPI
LmWrapFinish(PCHECKSUM_BUFFER *   ppcsBuffer);



CHECKSUM_FUNCTION csfLM = {
    KERB_CHECKSUM_LM,
    LM_OWF_PASSWORD_LENGTH,
    CKSUM_COLLISION,
    LmWrapInitialize,
    LmWrapSum,
    LmWrapFinalize,
    LmWrapFinish
    // Note : missing last function
};


#ifdef KERNEL_MODE
#pragma alloc_text( PAGEMSG, LmWrapInitialize )
#pragma alloc_text( PAGEMSG, LmWrapSum )
#pragma alloc_text( PAGEMSG, LmWrapFinalize )
#pragma alloc_text( PAGEMSG, LmWrapFinish );
#endif 

NTSTATUS NTAPI
LmWrapInitialize(
    ULONG   dwSeed,
    PCHECKSUM_BUFFER *  ppcsBuffer)
{
    PLM_STATE_BUFFER pContext;

#ifdef KERNEL_MODE
    pContext = ExAllocatePool( NonPagedPool, sizeof( LM_STATE_BUFFER ) );
#else
    pContext = LocalAlloc( LMEM_ZEROINIT, sizeof( LM_STATE_BUFFER ) );
#endif

    if ( pContext != NULL )
    {
        *ppcsBuffer = pContext;

        return( SEC_E_OK );
    }

    return( STATUS_INSUFFICIENT_RESOURCES );
}


NTSTATUS
LmCalculateLmPassword(
    IN PUNICODE_STRING NtPassword,
    OUT PCHAR *LmPasswordBuffer
    )

/*++

Routine Description:

    This service converts an NT password into a LM password.

Parameters:

    NtPassword - The Nt password to be converted.

    LmPasswordBuffer - On successful return, points at the LM password
                The buffer should be freed using MIDL_user_free

Return Values:

    STATUS_SUCCESS - LMPassword contains the LM version of the password.

    STATUS_NULL_LM_PASSWORD - The password is too complex to be represented
        by a LM password. The LM password returned is a NULL string.


--*/
{

#define LM_BUFFER_LENGTH    (LM20_PWLEN + 1)

    NTSTATUS       NtStatus;
    ANSI_STRING    LmPassword;

    //
    // Prepare for failure
    //

    *LmPasswordBuffer = NULL;


    //
    // Compute the Ansi version to the Unicode password.
    //
    //  The Ansi version of the Cleartext password is at most 14 bytes long,
    //      exists in a trailing zero filled 15 byte buffer,
    //      is uppercased.
    //

#ifdef KERNEL_MODE
    LmPassword.Buffer = ExAllocatePool(NonPagedPool,LM_BUFFER_LENGTH);
#else
    LmPassword.Buffer = LocalAlloc(0,LM_BUFFER_LENGTH);
#endif
    if (LmPassword.Buffer == NULL) {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    LmPassword.MaximumLength = LmPassword.Length = LM_BUFFER_LENGTH;
    ZeroMemory( LmPassword.Buffer, LM_BUFFER_LENGTH );

    NtStatus = RtlUpcaseUnicodeStringToOemString( &LmPassword, NtPassword, FALSE );


    if ( !NT_SUCCESS(NtStatus) ) {

        //
        // The password is longer than the max LM password length
        //

        NtStatus = STATUS_NULL_LM_PASSWORD; // Informational return code
        ZeroMemory( LmPassword.Buffer, LM_BUFFER_LENGTH );

    }




    //
    // Return a pointer to the allocated LM password
    //

    if (NT_SUCCESS(NtStatus)) {

        *LmPasswordBuffer = LmPassword.Buffer;

    } else {

#ifdef KERNEL_MODE
        ExFreePool(LmPassword.Buffer);
#else
        LocalFree(LmPassword.Buffer);
#endif
    }

    return(NtStatus);
}

NTSTATUS NTAPI
LmWrapSum(
    PCHECKSUM_BUFFER pcsBuffer,
    ULONG           cbData,
    PUCHAR          pbData )
{
    PLM_STATE_BUFFER pContext = (PLM_STATE_BUFFER) pcsBuffer;
    UNICODE_STRING TempString;
    PUCHAR LmPassword;
    NTSTATUS Status;

    TempString.Length = TempString.MaximumLength = (USHORT) cbData;
    TempString.Buffer = (LPWSTR) pbData;

    Status = LmCalculateLmPassword(
                &TempString,
                &LmPassword
                );
    if (!NT_SUCCESS(Status))
    {
        return(Status);
    }

    Status = RtlCalculateLmOwfPassword(
                LmPassword,
                &pContext->Password
                );
#ifdef KERNEL_MODE
    ExFreePool(LmPassword);
#else
    LocalFree(LmPassword);
#endif

    return( Status );

}


NTSTATUS NTAPI
LmWrapFinalize(
    PCHECKSUM_BUFFER pcsBuffer,
    PUCHAR          pbSum)
{
    PLM_STATE_BUFFER pContext = (PLM_STATE_BUFFER) pcsBuffer;


    memcpy(
        pbSum,
        &pContext->Password,
        LM_OWF_PASSWORD_LENGTH
        );

    return( STATUS_SUCCESS );

}

NTSTATUS NTAPI
LmWrapFinish(
    PCHECKSUM_BUFFER *   ppcsBuffer)
{

    ZeroMemory( *ppcsBuffer, sizeof( PLM_STATE_BUFFER ) );

#ifdef KERNEL_MODE
    ExFreePool( *ppcsBuffer );
#else
    LocalFree( *ppcsBuffer );
#endif

    *ppcsBuffer = NULL ;

    return( STATUS_SUCCESS );

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\cryptDLL\csummgr.c ===
//+-----------------------------------------------------------------------
//
// File:        CSUMMGR.c
//
// Contents:    Checksum management functions
//
//
// History:     25 Feb 92,  RichardW,   Created
//
//------------------------------------------------------------------------

#include "cryptdllp.h"


#define MAX_CHECK_SUMS  16

CHECKSUM_FUNCTION    CheckSumFns[MAX_CHECK_SUMS];
ULONG               cCheckSums = 0;

#ifdef KERNEL_MODE
#pragma alloc_text( PAGEMSG, CDRegisterCheckSum )
#pragma alloc_text( PAGEMSG, CDLocateCheckSum )
#endif 

NTSTATUS NTAPI
CDRegisterCheckSum( PCHECKSUM_FUNCTION   pcsfSum)
{
    if (cCheckSums < MAX_CHECK_SUMS)
    {
        CheckSumFns[cCheckSums++] = *pcsfSum;
        return(S_OK);
    }
    return(STATUS_INSUFFICIENT_RESOURCES);
}

NTSTATUS NTAPI
CDLocateCheckSum(   ULONG               dwCheckSumType,
                    PCHECKSUM_FUNCTION * ppcsfSum)
{
    ULONG   iCS = cCheckSums;
    while (iCS--)
    {
        if (CheckSumFns[iCS].CheckSumType == dwCheckSumType)
        {
            *ppcsfSum = &CheckSumFns[iCS];
            return(S_OK);
        }
    }
    return(SEC_E_CHECKSUM_NOT_SUPP);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\cryptDLL\deswrap.c ===
//+-----------------------------------------------------------------------
//
// File:        DESWRAP.C
//
// Contents:    CryptoSystem wrapper functions for DES
//
//
// History:     06-Sep-1996     MikeSw          Created
//
//------------------------------------------------------------------------

//
// Portions of this code (the key generation code) were taken from the
// MIT kerberos distribution.
//

/*
 *
 * Copyright 1989,1990 by the Massachusetts Institute of Technology.
 * All Rights Reserved.
 *
 * Export of this software from the United States of America may
 *   require a specific license from the United States Government.
 *   It is the responsibility of any person or organization contemplating
 *   export to obtain such a license before exporting.
 *
 * WITHIN THAT CONSTRAINT, permission to use, copy, modify, and
 * distribute this software and its documentation for any purpose and
 * without fee is hereby granted, provided that the above copyright
 * notice appear in all copies and that both that copyright notice and
 * this permission notice appear in supporting documentation, and that
 * the name of M.I.T. not be used in advertising or publicity pertaining
 * to distribution of the software without specific, written prior
 * permission.  M.I.T. makes no representations about the suitability of
 * this software for any purpose.  It is provided "as is" without express
 * or implied warranty.
 *
 *
 * Under U.S. law, this software may not be exported outside the US
 * without license from the U.S. Commerce department.
 *
 * These routines form the library interface to the DES facilities.
 *
 * Originally written 8/85 by Steve Miller, MIT Project Athena.
 */

/* des.c - Routines for implementing the FIPS Data Encryption Standard (DES).
 *
 *         Allan Bjorklund, University of Michigan, ITD/RS/DD.
 *         July 24, 1993.
 *
 *         Revisions for PC memory model portability, July 11, 1994.
 *
 *         Removed model portability header and added Win95 DLL
 *         declarations, May 31, 1995.
 *
 *         Made all declarations Win95 and NT specific, September 18, 1995.
 *
 *         Added quad_cksum, October 9, 1995.
 *
 * Copyright (c) 1995,1996 Regents of The University of Michigan.
 * All Rights Reserved.
 *
 *     Permission to use, copy, modify, and distribute this software and
 *     its documentation for any purpose and without fee is hereby granted,
 *     provided that the above copyright notice appears in all copies and
 *     that both that copyright notice and this permission notice appear
 *     in supporting documentation, and that the name of The University
 *     of Michigan not be used in advertising or publicity pertaining to
 *     distribution of the software without specific, written prior
 *     permission. This software is supplied as is without expressed or
 *     implied warranties of any kind.
 *
 * Research Systems Unix Group
 * The University of Michigan
 * c/o Allan Bjorklund
 * 535 W. William Street
 * Ann Arbor, Michigan
 * kerb95@umich.edu
 */

#include "cryptdllp.h"



BOOLEAN
md5Hmac(
    IN PUCHAR pbKeyMaterial,
    IN ULONG cbKeyMaterial,
    IN PUCHAR pbData,
    IN ULONG cbData,
    IN PUCHAR pbData2,
    IN ULONG cbData2,
    OUT PUCHAR HmacData
    );

#define DES_CONFOUNDER_LEN 8

typedef struct _DES_HEADER {
    UCHAR Confounder[DES_CONFOUNDER_LEN];
    UCHAR Checksum[MD5_LEN];
} DES_HEADER, *PDES_HEADER;



typedef struct _DES_STATE_BUFFER {
    PCHECKSUM_FUNCTION ChecksumFunction;
    DESTable KeyTable;
    UCHAR InitializationVector[DES_BLOCKLEN];
} DES_STATE_BUFFER, *PDES_STATE_BUFFER;

typedef struct _DES_MAC_STATE_BUFFER {
    DESTable KeyTable;
    UCHAR Confounder[DES_BLOCKLEN];
    UCHAR InitializationVector[DES_BLOCKLEN];
} DES_MAC_STATE_BUFFER, *PDES_MAC_STATE_BUFFER;

typedef struct _DES_MAC_1510_STATE_BUFFER {
    DESTable KeyTable;
    UCHAR InitializationVector[DES_BLOCKLEN];
    UCHAR Confounder[DES_BLOCKLEN];
    DESTable FinalKeyTable;
} DES_MAC_1510_STATE_BUFFER, *PDES_MAC_1510_STATE_BUFFER;

NTSTATUS NTAPI desPlainInitialize(PUCHAR, ULONG, ULONG, PCRYPT_STATE_BUFFER *);
NTSTATUS NTAPI desPlainExpInitialize(PUCHAR, ULONG, ULONG, PCRYPT_STATE_BUFFER *);
NTSTATUS NTAPI desMd5Initialize(PUCHAR, ULONG, ULONG, PCRYPT_STATE_BUFFER *);
NTSTATUS NTAPI desMd5ExpInitialize(PUCHAR, ULONG, ULONG, PCRYPT_STATE_BUFFER *);
NTSTATUS NTAPI desCrc32Initialize(PUCHAR, ULONG, ULONG, PCRYPT_STATE_BUFFER *);
NTSTATUS NTAPI desEncrypt(PCRYPT_STATE_BUFFER, PUCHAR, ULONG, PUCHAR, PULONG);
NTSTATUS NTAPI desDecrypt(PCRYPT_STATE_BUFFER, PUCHAR, ULONG, PUCHAR, PULONG);
NTSTATUS NTAPI desFinish(PCRYPT_STATE_BUFFER *);
NTSTATUS NTAPI desHashPassword(PUNICODE_STRING, PUCHAR);
NTSTATUS NTAPI desInitRandom(ULONG);
NTSTATUS NTAPI desRandomKey(PUCHAR, ULONG, PUCHAR);
NTSTATUS NTAPI desFinishRandom(void);
NTSTATUS NTAPI desControl(ULONG, PCRYPT_STATE_BUFFER, PUCHAR, ULONG);

NTSTATUS NTAPI desMacGeneralInitializeEx(PUCHAR, ULONG, PUCHAR, ULONG, PCHECKSUM_BUFFER *);

NTSTATUS NTAPI desMacInitialize(ULONG, PCHECKSUM_BUFFER *);
NTSTATUS NTAPI desMacInitializeEx(PUCHAR,ULONG, ULONG, PCHECKSUM_BUFFER *);

NTSTATUS NTAPI desMacKInitializeEx(PUCHAR,ULONG, ULONG, PCHECKSUM_BUFFER *);

NTSTATUS NTAPI desMac1510Initialize(ULONG, PCHECKSUM_BUFFER *);
NTSTATUS NTAPI desMac1510InitializeEx(PUCHAR,ULONG, ULONG, PCHECKSUM_BUFFER *);
NTSTATUS NTAPI desMac1510InitializeEx2(PUCHAR,ULONG, PUCHAR, ULONG, PCHECKSUM_BUFFER *);
NTSTATUS NTAPI desMac1510Finalize(PCHECKSUM_BUFFER, PUCHAR);
NTSTATUS NTAPI desMacSum(PCHECKSUM_BUFFER, ULONG, PUCHAR);
NTSTATUS NTAPI desMacFinalize(PCHECKSUM_BUFFER, PUCHAR);
NTSTATUS NTAPI desMacFinish(PCHECKSUM_BUFFER *);

#ifdef KERNEL_MODE
#pragma alloc_text( PAGEMSG, desPlainInitialize )
#pragma alloc_text( PAGEMSG, desPlainExpInitialize )
#pragma alloc_text( PAGEMSG, desMd5Initialize )
#pragma alloc_text( PAGEMSG, desMd5ExpInitialize )
#pragma alloc_text( PAGEMSG, desCrc32Initialize )
#pragma alloc_text( PAGEMSG, desEncrypt )
#pragma alloc_text( PAGEMSG, desDecrypt )
#pragma alloc_text( PAGEMSG, desFinish )
#pragma alloc_text( PAGEMSG, desHashPassword )
#pragma alloc_text( PAGEMSG, desInitRandom )
#pragma alloc_text( PAGEMSG, desRandomKey )
#pragma alloc_text( PAGEMSG, desFinishRandom )
#pragma alloc_text( PAGEMSG, desControl )
#pragma alloc_text( PAGEMSG, desMacInitialize )
#pragma alloc_text( PAGEMSG, desMacInitializeEx )
#pragma alloc_text( PAGEMSG, desMacSum )
#pragma alloc_text( PAGEMSG, desMacFinalize )
#pragma alloc_text( PAGEMSG, desMacFinish )
#pragma alloc_text( PAGEMSG, desMacGeneralInitializeEx )
#pragma alloc_text( PAGEMSG, desMacKInitializeEx )
#pragma alloc_text( PAGEMSG, desMac1510Initialize )
#pragma alloc_text( PAGEMSG, desMac1510InitializeEx )
#pragma alloc_text( PAGEMSG, desMac1510InitializeEx2 )
#pragma alloc_text( PAGEMSG, desMac1510Finalize )
#endif


CRYPTO_SYSTEM    csDES_MD5 = {
    KERB_ETYPE_DES_CBC_MD5,     // Etype
    DES_BLOCKLEN,               // Blocksize
    KERB_ETYPE_DES_CBC_MD5, // exportable version
    DES_KEYSIZE,                // Key size, in bytes
    sizeof(DES_HEADER),         // header size
    KERB_CHECKSUM_MD5,          // Preferred Checksum
    CSYSTEM_USE_PRINCIPAL_NAME |
        CSYSTEM_INTEGRITY_PROTECTED |
        CSYSTEM_EXPORT_STRENGTH, // Attributes
    L"Kerberos DES-CBC-MD5",    // Text name
    desMd5Initialize,
    desEncrypt,
    desDecrypt,
    desFinish,
    desHashPassword,
    desRandomKey,
    desControl
    };


CRYPTO_SYSTEM    csDES_CRC32 = {
    KERB_ETYPE_DES_CBC_CRC,     // Etype
    DES_BLOCKLEN,               // Blocksize (stream)
    KERB_ETYPE_DES_CBC_CRC,     // exportable version
    DES_KEYSIZE,                // Key size, in bytes
    sizeof(DES_HEADER),         // header size
    KERB_CHECKSUM_CRC32,        // Preferred Checksum
    CSYSTEM_USE_PRINCIPAL_NAME |
        CSYSTEM_INTEGRITY_PROTECTED |
        CSYSTEM_EXPORT_STRENGTH, // Attributes
    L"Kerberos DES-CBC-CRC",    // Text name
    desCrc32Initialize,
    desEncrypt,
    desDecrypt,
    desFinish,
    desHashPassword,
    desRandomKey,
    desControl
    };

CRYPTO_SYSTEM    csDES_PLAIN = {
    KERB_ETYPE_DES_PLAIN,       // Etype
    DES_BLOCKLEN,               // Blocksize
    KERB_ETYPE_DES_PLAIN,       // exportable version
    DES_KEYSIZE,                // Key size, in bytes
    0,                          // header size
    KERB_CHECKSUM_CRC32,        // Preferred Checksum
    CSYSTEM_USE_PRINCIPAL_NAME | CSYSTEM_EXPORT_STRENGTH, // Attributes
    L"Kerberos DES-Plain",        // Text name
    desPlainInitialize,
    desEncrypt,
    desDecrypt,
    desFinish,
    desHashPassword,
    desRandomKey,
    desControl
    };



CHECKSUM_FUNCTION    csfDesMac = {
    KERB_CHECKSUM_DES_MAC,                  // Checksum type
    DES_BLOCKLEN,                           // Checksum length
    CKSUM_KEYED,
    desMacInitialize,
    desMacSum,
    desMacFinalize,
    desMacFinish,
    desMacInitializeEx,
    NULL};

CHECKSUM_FUNCTION    csfDesMacK = {
    KERB_CHECKSUM_KRB_DES_MAC_K,            // Checksum type
    DES_BLOCKLEN,                           // Checksum length
    CKSUM_KEYED,
    desMacInitialize,
    desMacSum,
    desMacFinalize,
    desMacFinish,
    desMacKInitializeEx,
    NULL};

CHECKSUM_FUNCTION    csfDesMac1510 = {
    KERB_CHECKSUM_KRB_DES_MAC,              // Checksum type
    DES_BLOCKLEN * 2,                       // Checksum length
    CKSUM_KEYED,
    desMac1510Initialize,
    desMacSum,
    desMac1510Finalize,
    desMacFinish,                           // just frees the buffer
    desMac1510InitializeEx,
    desMac1510InitializeEx2};


#define SMASK(step) ((1<<step)-1)
#define PSTEP(x,step) (((x)&SMASK(step))^(((x)>>step)&SMASK(step)))
#define PARITY_CHAR(x, y) \
{\
    UCHAR _tmp1_, _tmp2_; \
    _tmp1_ = (UCHAR) PSTEP((x),4); \
    _tmp2_ = (UCHAR) PSTEP(_tmp1_,2); \
    *(y) = (UCHAR) PSTEP(_tmp2_, 1); \
} \


VOID
desFixupKeyParity(
    PUCHAR Key
    )
{
    ULONG Index;
    UCHAR TempChar;
    for (Index=0; Index < DES_BLOCKLEN; Index++)
    {
        Key[Index] &= 0xfe;
        PARITY_CHAR(Key[Index], &TempChar);
        Key[Index] |= 1 ^ TempChar;
    }

}

typedef UCHAR DES_KEYBLOCK[8];

DES_KEYBLOCK desWeakKeys[] = {
    /* weak keys */
    {0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01},
    {0xfe,0xfe,0xfe,0xfe,0xfe,0xfe,0xfe,0xfe},
    {0x1f,0x1f,0x1f,0x1f,0x0e,0x0e,0x0e,0x0e},
    {0xe0,0xe0,0xe0,0xe0,0xf1,0xf1,0xf1,0xf1},

    /* semi-weak */
    {0x01,0xfe,0x01,0xfe,0x01,0xfe,0x01,0xfe},
    {0xfe,0x01,0xfe,0x01,0xfe,0x01,0xfe,0x01},

    {0x1f,0xe0,0x1f,0xe0,0x0e,0xf1,0x0e,0xf1},
    {0xe0,0x1f,0xe0,0x1f,0xf1,0x0e,0xf1,0x0e},

    {0x01,0xe0,0x01,0xe0,0x01,0xf1,0x01,0xf1},
    {0xe0,0x01,0xe0,0x01,0xf1,0x01,0xf1,0x01},

    {0x1f,0xfe,0x1f,0xfe,0x0e,0xfe,0x0e,0xfe},
    {0xfe,0x1f,0xfe,0x1f,0xfe,0x0e,0xfe,0x0e},

    {0x01,0x1f,0x01,0x1f,0x01,0x0e,0x01,0x0e},
    {0x1f,0x01,0x1f,0x01,0x0e,0x01,0x0e,0x01},

    {0xe0,0xfe,0xe0,0xfe,0xf1,0xfe,0xf1,0xfe},
    {0xfe,0xe0,0xfe,0xe0,0xfe,0xf1,0xfe,0xf1}
};

/*
 * mit_des_is_weak_key: returns true iff key is a [semi-]weak des key.
 *
 * Requires: key has correct odd parity.
 */

BOOLEAN
desIsWeakKey(
    PUCHAR Key
    )
{
    ULONG Index;
    DES_KEYBLOCK * WeakKey = desWeakKeys;

    for (Index = 0; Index < sizeof(desWeakKeys)/DES_BLOCKLEN; Index++) {
        if (!memcmp(
                WeakKey++,
                Key,
                DES_BLOCKLEN
                ))
        {
            return( TRUE );
        }
    }

    return(FALSE);
}


NTSTATUS NTAPI
desInitialize(  PUCHAR          pbKey,
                ULONG           KeySize,
                ULONG           MessageType,
                ULONG           Checksum,
                PCRYPT_STATE_BUFFER *  psbBuffer)
{
    NTSTATUS Status;
    UCHAR LocalKey[DES_KEYSIZE];
    PDES_STATE_BUFFER DesKey = NULL;
    PCHECKSUM_FUNCTION ChecksumFunction = NULL;

    //
    // Make sure we were passed an appropriate keytable
    //


    if (KeySize != DES_KEYSIZE)
    {
        return(STATUS_INVALID_PARAMETER);
    }

    memcpy(
        LocalKey,
        pbKey,
        KeySize
        );

    //
    // Get the appropriate checksum here.
    //

    if (Checksum != 0)
    {
        Status = CDLocateCheckSum(
                    Checksum,
                    &ChecksumFunction
                    );
        if (!NT_SUCCESS(Status))
        {
            return(Status);
        }

    }
    else
    {
        ChecksumFunction = NULL;
    }

    //
    // Create the key buffer
    //


#ifdef KERNEL_MODE
    DesKey = ExAllocatePool (NonPagedPool, sizeof(DES_STATE_BUFFER));
#else
    DesKey = LocalAlloc(0, sizeof(DES_STATE_BUFFER));
#endif
    if (DesKey == NULL)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }



    deskey(&DesKey->KeyTable, LocalKey);


    //
    // Initialize the checksum function
    //

    DesKey->ChecksumFunction = ChecksumFunction;

    //
    // DES-CBC-CRC uses the key as the ivec, MD5 and MD4 user zero
    //

    if (Checksum == KERB_CHECKSUM_CRC32)
    {
        memcpy(
            DesKey->InitializationVector,
            LocalKey,
            DES_BLOCKLEN
            );
    }
    else
    {
        ZeroMemory(
            DesKey->InitializationVector,
            DES_BLOCKLEN
            );

    }


    *psbBuffer = (PCRYPT_STATE_BUFFER) DesKey;

    return(STATUS_SUCCESS);

}


NTSTATUS NTAPI
desMd5Initialize(
    IN PUCHAR pbKey,
    IN ULONG KeySize,
    IN ULONG MessageType,
    OUT PCRYPT_STATE_BUFFER *  psbBuffer
    )
{
    return(desInitialize(
                pbKey,
                KeySize,
                MessageType,
                KERB_CHECKSUM_MD5,
                psbBuffer
                ));
}



NTSTATUS NTAPI
desCrc32Initialize(
    IN PUCHAR pbKey,
    IN ULONG KeySize,
    IN ULONG MessageType,
    OUT PCRYPT_STATE_BUFFER *  psbBuffer
    )
{
    return(desInitialize(
                pbKey,
                KeySize,
                MessageType,
                KERB_CHECKSUM_CRC32,
                psbBuffer
                ));
}

NTSTATUS NTAPI
desPlainInitialize(
    IN PUCHAR pbKey,
    IN ULONG KeySize,
    IN ULONG MessageType,
    OUT PCRYPT_STATE_BUFFER *  psbBuffer
    )
{
    return(desInitialize(
                pbKey,
                KeySize,
                MessageType,
                0,              // no checksum
                psbBuffer
                ));
}




//+-------------------------------------------------------------------------
//
//  Function:   BlockDecrypt
//
//  Synopsis:   Encrypts a data buffer using DES
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:      stolen from windows\base\ntcyrpto\scp\nt_crypt.c
//
//
//--------------------------------------------------------------------------



NTSTATUS
BlockEncrypt(
    IN PDES_STATE_BUFFER pKey,
    IN PUCHAR  pbData,
    OUT PULONG pdwDataLen,
    IN ULONG dwBufLen
    )
{
    ULONG   cbPartial, dwPadVal, dwDataLen;
    UCHAR    pbBuf[DES_BLOCKLEN];
    UCHAR   FeedBack[DES_BLOCKLEN];

    dwDataLen = *pdwDataLen;

    //
    // Initialize the feedback buffer to the initialization vector
    //

    memcpy(
        FeedBack,
        pKey->InitializationVector,
        DES_BLOCKLEN
        );

    //
    // check length of the buffer and calculate the pad
    // (if multiple of DES_BLOCKLEN, do a full block of pad)
    //

    cbPartial = (dwDataLen % DES_BLOCKLEN);

    //
    // The original code here put in 8 bytes of padding
    // on an aligned buffer. That is a waste.
    //

    if (cbPartial != 0)
    {
        dwPadVal = DES_BLOCKLEN - cbPartial;
    }
    else
    {
        dwPadVal = 0;
    }

    if (pbData == NULL || dwBufLen < dwDataLen + dwPadVal)
    {
        //
        // set what we need
        //

        *pdwDataLen = dwDataLen + dwPadVal;
        if (pbData == NULL)
        {
            return (STATUS_SUCCESS);
        }
        return(STATUS_BUFFER_OVERFLOW);
    }

    //
    // allocate memory for a temporary buffer
    //


    //
    // Will this cause MIT clients/servers to flail? The caller
    // should pass in only buffers that are already padded to
    // make MIT clients work.
    //

    if (dwPadVal)
    {
        // Fill the pad with a value equal to the
        // length of the padding, so decrypt will
        // know the length of the original data
        // and as a simple integrity check.

        memset(
            pbData + dwDataLen,
            dwPadVal,
            dwPadVal
            );
    }

    dwDataLen += dwPadVal;
    *pdwDataLen = dwDataLen;

    assert((dwDataLen % DES_BLOCKLEN) == 0);

    //
    // pump the full blocks of data through
    //
    while (dwDataLen)
    {
        assert(dwDataLen >= DES_BLOCKLEN);

        //
        // put the plaintext into a temporary
        // buffer, then encrypt the data
        // back into the caller's buffer
        //

        memcpy(pbBuf, pbData, DES_BLOCKLEN);

        CBC(    des,
                DES_BLOCKLEN,
                pbData,
                pbBuf,
                &pKey->KeyTable,
                ENCRYPT,
                FeedBack
                );


        pbData += DES_BLOCKLEN;
        dwDataLen -= DES_BLOCKLEN;
    }
    memcpy(
        pKey->InitializationVector,
        pbData - DES_BLOCKLEN,
        DES_BLOCKLEN
        );


    return(STATUS_SUCCESS);

}


//+-------------------------------------------------------------------------
//
//  Function:   BlockDecrypt
//
//  Synopsis:   Decrypt a block of data encrypted with BlockEncrypt
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
BlockDecrypt(
    IN PDES_STATE_BUFFER pKey,
    IN OUT PUCHAR  pbData,
    IN OUT PULONG pdwDataLen
    )
{
    UCHAR    pbBuf[DES_BLOCKLEN];
    ULONG   dwDataLen, BytePos;
    UCHAR   FeedBack[DES_BLOCKLEN];

    dwDataLen = *pdwDataLen;

    //
    // Check to see if we are decrypting something already
    //

    memcpy(
        FeedBack,
        pKey->InitializationVector,
        DES_BLOCKLEN
        );

    //
    // The data length must be a multiple of the algorithm
    // pad size.
    //
    if (dwDataLen % DES_BLOCKLEN)
    {
        return(STATUS_INVALID_PARAMETER);
    }


    //
    // pump the data through the decryption, including padding
    // NOTE: the total length is a multiple of DES_BLOCKLEN
    //

    for (BytePos = 0; (BytePos + DES_BLOCKLEN) <= dwDataLen; BytePos += DES_BLOCKLEN)
    {
        //
        // put the encrypted text into a temp buffer
        //

        memcpy (pbBuf, pbData + BytePos, DES_BLOCKLEN);


        CBC(
            des,
            DES_BLOCKLEN,
            pbData + BytePos,
            pbBuf,
            &pKey->KeyTable,
            DECRYPT,
            FeedBack
            );



    }

    memcpy(
        pKey->InitializationVector,
        pbBuf,
        DES_BLOCKLEN
        );

    return STATUS_SUCCESS;
}

NTSTATUS NTAPI
desEncrypt(
    IN PCRYPT_STATE_BUFFER psbBuffer,
    IN PUCHAR pbInput,
    IN ULONG cbInput,
    OUT PUCHAR OutputBuffer,
    OUT PULONG OutputLength
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PDES_STATE_BUFFER StateBuffer = (PDES_STATE_BUFFER) psbBuffer;
    PDES_HEADER CryptHeader = (PDES_HEADER) OutputBuffer;
    PCHECKSUM_BUFFER SumBuffer = NULL;
    ULONG LocalOutputLength;

    //
    // If we aren't doing raw DES, prepare a header structure
    //

    if (StateBuffer->ChecksumFunction != NULL)
    {
        //
        // Relocate the buffer and inserat the header
        //

        MoveMemory(
            OutputBuffer + DES_CONFOUNDER_LEN + StateBuffer->ChecksumFunction->CheckSumSize,
            pbInput,
            cbInput
            );
        LocalOutputLength = cbInput + DES_CONFOUNDER_LEN + StateBuffer->ChecksumFunction->CheckSumSize;


        //
        // Zero fill the padding space
        //

        ZeroMemory(
            OutputBuffer+LocalOutputLength,
            ROUND_UP_COUNT(LocalOutputLength,DES_BLOCKLEN) - LocalOutputLength
            );

        LocalOutputLength = ROUND_UP_COUNT(LocalOutputLength,DES_BLOCKLEN);


        ZeroMemory(
            CryptHeader->Checksum,
            StateBuffer->ChecksumFunction->CheckSumSize
            );

        CDGenerateRandomBits(
            CryptHeader->Confounder,
            DES_CONFOUNDER_LEN
            );


        //
        // Checksum the buffer.
        //

        Status = StateBuffer->ChecksumFunction->Initialize(0, &SumBuffer);
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        StateBuffer->ChecksumFunction->Sum(
            SumBuffer,
            LocalOutputLength,
            OutputBuffer
            );
        StateBuffer->ChecksumFunction->Finalize(
            SumBuffer,
            CryptHeader->Checksum
            );
        StateBuffer->ChecksumFunction->Finish(
            &SumBuffer
            );

    }
    else
    {
        //
        // Just copy the buffer
        //

        memcpy(
            OutputBuffer,
            pbInput,
            cbInput
            );

        LocalOutputLength = ROUND_UP_COUNT(cbInput,DES_BLOCKLEN);

        //
        // Zero fill the padding space
        //

        ZeroMemory(
            OutputBuffer+cbInput,
            LocalOutputLength - cbInput
            );

    }

    //
    // Encrypt the buffer.
    //


    *OutputLength = LocalOutputLength;

    Status = BlockEncrypt(
                StateBuffer,
                OutputBuffer,
                OutputLength,
                LocalOutputLength
                );


Cleanup:

    return(Status);
}

NTSTATUS NTAPI
desDecrypt(     PCRYPT_STATE_BUFFER    psbBuffer,
                PUCHAR           pbInput,
                ULONG            cbInput,
                PUCHAR           pbOutput,
                PULONG            cbOutput)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PDES_STATE_BUFFER StateBuffer = (PDES_STATE_BUFFER) psbBuffer;
    PDES_HEADER CryptHeader;
    UCHAR Checksum[MD5_LEN];
    PCHECKSUM_BUFFER SumBuffer = NULL;

    //
    // First decrypt the whole buffer
    //

    if (*cbOutput < cbInput)
    {
        *cbOutput = cbInput;
        return(STATUS_BUFFER_TOO_SMALL);

    }

    memcpy(
        pbOutput,
        pbInput,
        cbInput
        );
    Status = BlockDecrypt(
                StateBuffer,
                pbOutput,
                &cbInput
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    if (StateBuffer->ChecksumFunction != NULL)
    {
        //  checksum length should match alloc buffer length
        if (StateBuffer->ChecksumFunction->CheckSumSize > MD5_LEN)
        {
            //  checksum mismatch
             Status = SEC_E_MESSAGE_ALTERED;
             goto Cleanup;
        }
        //
        // Now verify the checksum
        //

        CryptHeader = (PDES_HEADER) pbOutput;
        memcpy(
            Checksum,
            CryptHeader->Checksum,
            StateBuffer->ChecksumFunction->CheckSumSize
            );

        //
        // Zero the checksum field before computing the checksum of the buffer
        //

        ZeroMemory(
            CryptHeader->Checksum,
            StateBuffer->ChecksumFunction->CheckSumSize
            );

        //
        // Checksum the buffer.
        //

        Status = StateBuffer->ChecksumFunction->Initialize(0, &SumBuffer);
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        StateBuffer->ChecksumFunction->Sum(
            SumBuffer,
            cbInput,
            pbOutput
            );
        StateBuffer->ChecksumFunction->Finalize(
            SumBuffer,
            CryptHeader->Checksum
            );
        StateBuffer->ChecksumFunction->Finish(
            &SumBuffer
            );


        if (!!memcmp(
                CryptHeader->Checksum,
                Checksum,
                StateBuffer->ChecksumFunction->CheckSumSize
                ))
        {
            Status = SEC_E_MESSAGE_ALTERED;
            goto Cleanup;
        }

        //
        // Copy the input to the output without the header

        *cbOutput = cbInput - (DES_CONFOUNDER_LEN + StateBuffer->ChecksumFunction->CheckSumSize);


        MoveMemory(
            pbOutput,
            pbOutput + DES_CONFOUNDER_LEN + StateBuffer->ChecksumFunction->CheckSumSize,
            *cbOutput
            );

    }
    else
    {
        *cbOutput = cbInput;

    }

Cleanup:

    return(Status);
}

NTSTATUS NTAPI
desFinish(      PCRYPT_STATE_BUFFER *  psbBuffer)
{
    PDES_STATE_BUFFER StateBuffer = (PDES_STATE_BUFFER) *psbBuffer;


#ifdef KERNEL_MODE
    ExFreePool(StateBuffer);
#else
    LocalFree(StateBuffer);
#endif
    *psbBuffer = NULL;
    return(S_OK);
}

#define MIN(x,y) (((x) < (y)) ? (x) : (y))

#define XORBLOCK(x,y) \
{ \
    PULONG tx = (PULONG) x; \
    PULONG ty = (PULONG) y; \
    *tx++ ^= *ty++; \
    *tx++ ^= *ty++; \
}

VOID
desCbcChecksum(
    IN PUCHAR Password,
    IN ULONG PasswordLength,
    IN PUCHAR InitialVector,
    IN DESTable * KeyTable,
    OUT PUCHAR OutputKey
    )
{
    ULONG Offset;
    UCHAR Feedback[DES_BLOCKLEN];
    UCHAR Block[DES_BLOCKLEN];

    memcpy(
        Feedback,
        InitialVector,
        DES_BLOCKLEN
        );

    for (Offset = 0; Offset < PasswordLength ; Offset+= 8 )
    {
        ZeroMemory(
            Block,
            DES_BLOCKLEN
            );

        memcpy(
            Block,
            Password+Offset,
            MIN(DES_BLOCKLEN, PasswordLength - Offset)
            );

        XORBLOCK(Block, Feedback);
        des(
            Feedback,
            Block,
            KeyTable,
            ENCRYPT
            );


    }
    memcpy(
        OutputKey,
        Feedback,
        DES_BLOCKLEN
        );

}

#define BITREVERSE(c)   ((UCHAR)((((c & 0x01) ? 0x80 : 0x00)\
                                |((c & 0x02) ? 0x40 : 0x00)\
                                |((c & 0x04) ? 0x20 : 0x00)\
                                |((c & 0x08) ? 0x10 : 0x00)\
                                |((c & 0x10) ? 0x08 : 0x00)\
                                |((c & 0x20) ? 0x04 : 0x00)\
                                |((c & 0x40) ? 0x02 : 0x00))\
                                & 0xFE))

//
// This is the core routine that converts a buffer into a key. It is called
// by desHashPassword and desRandomKey
//

VOID
desHashBuffer(
    IN PUCHAR LocalPassword,
    IN ULONG PasswordLength,
    IN OUT PUCHAR Key
    )
{
    ULONG Index;
    BOOLEAN Forward;
    PUCHAR KeyPointer = Key;
    DESTable KeyTable;

    ZeroMemory(
        Key,
        DES_BLOCKLEN
        );

    //
    // Initialize our temporary parity vector
    //

    //
    // Start fanfolding the bytes into the key
    //

    Forward = TRUE;
    KeyPointer = Key;
    for (Index = 0; Index < PasswordLength ; Index++ )
    {

        if (!Forward)
        {
            *(--KeyPointer) ^= BITREVERSE(LocalPassword[Index] & 0x7F);
        }
        else
        {
            *KeyPointer++  ^= (LocalPassword[Index] & 0x7F) << 1;
        }
        if (((Index+1) & 0x07) == 0)     /* When MOD 8 equals 0 */
        {
            Forward = !Forward;         /* Change direction.   */
        }

    }

    //
    // Fix key parity
    //

    desFixupKeyParity(Key);

    //
    // Check for weak keys.
    //

    if (desIsWeakKey(Key))
    {
        Key[7] ^= 0xf0;
    }

    //
    // Now calculate the des-cbc-mac of the original string
    //

    deskey(&KeyTable, Key);

    //
    // Now compute the CBC checksum of the string
    //

    desCbcChecksum(
        LocalPassword,
        PasswordLength,
        Key,                    // initial vector
        &KeyTable,
        Key                     // output key
        );

    //
    // Fix key parity
    //

    desFixupKeyParity(Key);

    //
    // Check for weak keys.
    //

    if (desIsWeakKey(Key))
    {
        Key[7] ^= 0xf0;
    }
}

NTSTATUS NTAPI
desHashPassword(
    IN PUNICODE_STRING Password,
    OUT PUCHAR Key
    )
{

    PUCHAR LocalPassword = NULL;
    ULONG PasswordLength;
    OEM_STRING OemPassword;
    NTSTATUS Status;


    //
    // First convert the UNICODE string to an OEM string
    //



    Status = RtlUnicodeStringToOemString(
                &OemPassword,
                Password,
                TRUE            // allocate destination
                );

    if (!NT_SUCCESS(Status))
    {
        return(Status);
    }

    //
    // We hash the password according to RFC1510
    //
    // This code is derived from the MIT Kerberos code in string2key.c
    //


    PasswordLength = ROUND_UP_COUNT(OemPassword.Length,8);
#ifdef KERNEL_MODE
    LocalPassword = (PUCHAR) ExAllocatePool(NonPagedPool, PasswordLength);
#else
    LocalPassword = (PUCHAR) LocalAlloc(0, PasswordLength);
#endif
    if (LocalPassword == NULL)
    {
        RtlFreeOemString( &OemPassword );
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    memcpy(
        LocalPassword,
        OemPassword.Buffer,
        OemPassword.Length
        );

    //
    // Zero extend the password
    //

    ZeroMemory(
        LocalPassword + OemPassword.Length,
        PasswordLength - OemPassword.Length
        );


    //
    // Initialize our temporary parity vector
    //
    desHashBuffer(
        LocalPassword,
        PasswordLength,
        Key
        );
    RtlFreeOemString( &OemPassword );
#ifdef KERNEL_MODE
    ExFreePool(LocalPassword);
#else
    LocalFree(LocalPassword);
#endif

    return(STATUS_SUCCESS);
}




NTSTATUS NTAPI
desRandomKey(
    IN OPTIONAL PUCHAR Seed,
    IN ULONG SeedLength,
    OUT PUCHAR pbKey)
{
    UCHAR Buffer[16];
    do
    {
        CDGenerateRandomBits(Buffer,16);

        desHashBuffer(
            Buffer,
            16,
            pbKey
            );

    } while (desIsWeakKey(pbKey));
    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
desControl(
    IN ULONG Function,
    IN PCRYPT_STATE_BUFFER StateBuffer,
    IN PUCHAR InputBuffer,
    IN ULONG InputBufferSize
    )
{
    PDES_STATE_BUFFER DesStateBuffer = (PDES_STATE_BUFFER) StateBuffer;

    if (Function != CRYPT_CONTROL_SET_INIT_VECT)
    {
        return(STATUS_INVALID_PARAMETER);
    }
    if (InputBufferSize != DES_BLOCKLEN)
    {
        return(STATUS_INVALID_PARAMETER);
    }

    memcpy(
        DesStateBuffer->InitializationVector,
        InputBuffer,
        DES_BLOCKLEN
        );
    return(STATUS_SUCCESS);
}


///////////////////////////////////////////////////////////////////////////

NTSTATUS NTAPI
desMacGeneralInitializeEx(
    PUCHAR Key,
    ULONG  KeySize,
    PUCHAR IV,
    ULONG  MessageType,
    PCHECKSUM_BUFFER * ppcsBuffer
    )
{
    PDES_MAC_STATE_BUFFER DesKey = NULL;

    //
    // Make sure we were passed an appropriate keytable
    //


    if (KeySize != DES_KEYSIZE)
    {
        return(STATUS_INVALID_PARAMETER);
    }


#ifdef KERNEL_MODE
    DesKey = ExAllocatePool(NonPagedPool, sizeof(DES_MAC_STATE_BUFFER));
#else
    DesKey = LocalAlloc(0, sizeof(DES_MAC_STATE_BUFFER));
#endif
    if (DesKey == NULL)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // Create the key buffer
    //


    deskey(&DesKey->KeyTable, Key);


    memcpy(
        DesKey->InitializationVector,
        IV,
        DES_BLOCKLEN
        );

    *ppcsBuffer = (PCHECKSUM_BUFFER) DesKey;

    return(STATUS_SUCCESS);

}

NTSTATUS NTAPI
desMacInitializeEx(
    PUCHAR Key,
    ULONG  KeySize,
    ULONG  MessageType,
    PCHECKSUM_BUFFER * ppcsBuffer
    )
{
    UCHAR IV[DES_BLOCKLEN];

    ZeroMemory(
        IV,
        DES_BLOCKLEN
        );

    return desMacGeneralInitializeEx(
                Key,
                KeySize,
                IV,
                MessageType,
                ppcsBuffer
                );
}

NTSTATUS NTAPI
desMacKInitializeEx(
    PUCHAR Key,
    ULONG  KeySize,
    ULONG  MessageType,
    PCHECKSUM_BUFFER * ppcsBuffer
    )
{
    return desMacGeneralInitializeEx(
                Key,
                KeySize,
                Key,
                MessageType,
                ppcsBuffer
                );
}

NTSTATUS NTAPI
desMacInitialize(ULONG               dwSeed,
                PCHECKSUM_BUFFER *   ppcsBuffer)
{
    return(STATUS_NOT_IMPLEMENTED);
}

//
// NOTE - This function is used with both DES_MAC_STATE_BUFFER and
// DES_MAC_1510_STATE_BUFFER as the pcsBuffer parameter, since the
// DES_MAC_1510_STATE_BUFFER is the same as DES_MAC_STATE_BUFFER
// except with an added confounder this should be OK.
//
NTSTATUS NTAPI
desMacSum(
    PCHECKSUM_BUFFER     pcsBuffer,
    ULONG                cbData,
    PUCHAR               pbData)
{
    PDES_MAC_STATE_BUFFER DesKey = (PDES_MAC_STATE_BUFFER) pcsBuffer;
    UCHAR FeedBack[DES_BLOCKLEN];
    UCHAR TempBuffer[DES_BLOCKLEN];
    UCHAR OutputBuffer[DES_BLOCKLEN];
    ULONG Index;

    //
    // Set up the IV for this round - it may be zero or the output of
    // a previous MAC
    //

    memcpy(
        FeedBack,
        DesKey->InitializationVector,
        DES_BLOCKLEN
        );

    for (Index = 0; Index < cbData ; Index += DES_BLOCKLEN )
    {
        //
        // Compute the input buffer, with padding
        //

        if (Index+DES_BLOCKLEN > cbData)
        {
            memset(
                TempBuffer,
                0,
                DES_BLOCKLEN
                );
            memcpy(
                TempBuffer,
                pbData,
                Index & (DES_BLOCKLEN-1)
                );

        }
        else
        {
            memcpy(
                TempBuffer,
                pbData+Index,
                DES_BLOCKLEN
                );
        }


        CBC(    des,
                DES_BLOCKLEN,
                TempBuffer,
                OutputBuffer,
                &DesKey->KeyTable,
                ENCRYPT,
                FeedBack
                );
    }

    //
    // Copy the feedback back into the IV for the next round
    //

    memcpy(
        DesKey->InitializationVector,
        FeedBack,
        DES_BLOCKLEN
        );

    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
desMacFinalize(
    PCHECKSUM_BUFFER pcsBuffer,
    PUCHAR           pbSum)
{
    PDES_MAC_STATE_BUFFER DesKey = (PDES_MAC_STATE_BUFFER) pcsBuffer;

    memcpy(pbSum, DesKey->InitializationVector, DES_BLOCKLEN);
    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
desMacFinish(  PCHECKSUM_BUFFER *   ppcsBuffer)
{
#ifdef KERNEL_MODE
    ExFreePool(*ppcsBuffer);
#else
    LocalFree(*ppcsBuffer);
#endif
    *ppcsBuffer = 0;
    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
desMac1510Initialize(ULONG               dwSeed,
                     PCHECKSUM_BUFFER *   ppcsBuffer)
{
    return(STATUS_NOT_IMPLEMENTED);
}


NTSTATUS NTAPI
desMac1510InitializeEx(
    PUCHAR Key,
    ULONG  KeySize,
    ULONG  MessageType,
    PCHECKSUM_BUFFER * ppcsBuffer
    )
{
    return(STATUS_NOT_IMPLEMENTED);
}

NTSTATUS NTAPI
desMac1510InitializeEx2(
    PUCHAR Key,
    ULONG  KeySize,
    PUCHAR ChecksumToVerify,
    ULONG  MessageType,
    PCHECKSUM_BUFFER * ppcsBuffer
    )
{
    ULONG *pul;
    ULONG *pul2;
    UCHAR FinalKey[DES_KEYSIZE];
    PDES_MAC_1510_STATE_BUFFER DesKey = NULL;

    //
    // Make sure we were passed an appropriate keytable
    //


    if (KeySize != DES_KEYSIZE)
    {
        return(STATUS_INVALID_PARAMETER);
    }


#ifdef KERNEL_MODE
    DesKey = ExAllocatePool(NonPagedPool, sizeof(DES_MAC_1510_STATE_BUFFER));
#else
    DesKey = LocalAlloc(0, sizeof(DES_MAC_1510_STATE_BUFFER));
#endif
    if (DesKey == NULL)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // create the final key table
    //
    pul = (ULONG*)FinalKey;
    pul2 = (ULONG*)Key;
    *pul = *pul2 ^ 0xf0f0f0f0;
    pul = (ULONG*)(FinalKey + sizeof(ULONG));
    pul2 = (ULONG*)(Key + sizeof(ULONG));
    *pul = *pul2 ^ 0xf0f0f0f0;

    deskey(&DesKey->FinalKeyTable, FinalKey);

    //
    // Checksum was not passed in so generate a confounder
    //
    if (NULL == ChecksumToVerify)
    {
        CDGenerateRandomBits(DesKey->Confounder,DES_BLOCKLEN);
    }
    else
    {
        // the IV is all zero so no need to use CBC on first block
        des(DesKey->Confounder, ChecksumToVerify, &DesKey->FinalKeyTable, DECRYPT);
    }

    //
    // Create the key buffer
    //
    deskey(&DesKey->KeyTable, Key);


    // the IV is all zero so no need to use CBC on first block, but the
    // ecncrypted confounder becomes the next IV
    des(DesKey->InitializationVector, DesKey->Confounder, &DesKey->KeyTable, ENCRYPT);

    *ppcsBuffer = (PCHECKSUM_BUFFER) DesKey;

    return(STATUS_SUCCESS);

}

NTSTATUS NTAPI
desMac1510Finalize(
    PCHECKSUM_BUFFER pcsBuffer,
    PUCHAR           pbSum)
{
    UCHAR Feedback[DES_BLOCKLEN];
    PDES_MAC_1510_STATE_BUFFER DesKey = (PDES_MAC_1510_STATE_BUFFER) pcsBuffer;

    // the IV is all zero so no need to use CBC on first block
    des(Feedback, DesKey->Confounder, &DesKey->FinalKeyTable, ENCRYPT);

    memcpy(pbSum, Feedback, DES_BLOCKLEN);

    // use CBC on second block
    CBC(    des,
            DES_BLOCKLEN,
            pbSum + DES_BLOCKLEN,
            DesKey->InitializationVector,
            &DesKey->FinalKeyTable,
            ENCRYPT,
            Feedback
            );

    return(STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\cryptDLL\mdwrap.c ===
//+-----------------------------------------------------------------------
//
// File:        MDWRAP.C
//
// Contents:    MDx Wrapper functions
//
//
// History:     25 Feb 92,  RichardW    Created
//
//------------------------------------------------------------------------


#include "cryptdllp.h"


typedef struct _MD5_DES_STATE_BUFFER {
    PCHECKSUM_BUFFER DesContext;
    MD5_CTX Md5Context;
} MD5_DES_STATE_BUFFER, *PMD5_DES_STATE_BUFFER;

typedef struct _MD5_DES_1510_STATE_BUFFER {
    PCHECKSUM_BUFFER DesContext;
    MD5_CTX Md5Context;
    UCHAR Confounder[DES_BLOCKLEN];
} MD5_DES_1510_STATE_BUFFER, *PMD5_DES_1510_STATE_BUFFER;

typedef struct _MD5_HMAC_STATE_BUFFER {
    MD5_CTX Md5Context;
    ULONG KeySize;
    UCHAR Key[ANYSIZE_ARRAY];
} MD5_HMAC_STATE_BUFFER, *PMD5_HMAC_STATE_BUFFER;


NTSTATUS NTAPI md4Initialize(ULONG, PCHECKSUM_BUFFER *);
NTSTATUS NTAPI md4InitializeEx(PUCHAR,ULONG, ULONG, PCHECKSUM_BUFFER *);
NTSTATUS NTAPI md4Sum(PCHECKSUM_BUFFER, ULONG, PUCHAR);
NTSTATUS NTAPI md4Finalize(PCHECKSUM_BUFFER, PUCHAR);
NTSTATUS NTAPI md4Finish(PCHECKSUM_BUFFER *);

NTSTATUS NTAPI md5Initialize(ULONG, PCHECKSUM_BUFFER *);
NTSTATUS NTAPI md5InitializeEx(PUCHAR, ULONG, ULONG, PCHECKSUM_BUFFER *);
NTSTATUS NTAPI md5Sum(PCHECKSUM_BUFFER, ULONG, PUCHAR);
NTSTATUS NTAPI md5Finalize(PCHECKSUM_BUFFER, PUCHAR);
NTSTATUS NTAPI md5Finish(PCHECKSUM_BUFFER *);


NTSTATUS NTAPI md25Initialize(ULONG, PCHECKSUM_BUFFER *);
NTSTATUS NTAPI md25InitializeEx(PUCHAR, ULONG, ULONG, PCHECKSUM_BUFFER *);
NTSTATUS NTAPI md25Sum(PCHECKSUM_BUFFER, ULONG, PUCHAR);
NTSTATUS NTAPI md25Finalize(PCHECKSUM_BUFFER, PUCHAR);
NTSTATUS NTAPI md25Finish(PCHECKSUM_BUFFER *);


NTSTATUS NTAPI md5DesInitialize(ULONG, PCHECKSUM_BUFFER *);
NTSTATUS NTAPI md5DesInitializeEx(PUCHAR, ULONG, ULONG,  PCHECKSUM_BUFFER *);
NTSTATUS NTAPI md5DesSum(PCHECKSUM_BUFFER, ULONG, PUCHAR);
NTSTATUS NTAPI md5DesFinalize(PCHECKSUM_BUFFER, PUCHAR);
NTSTATUS NTAPI md5DesFinish(PCHECKSUM_BUFFER *);

NTSTATUS NTAPI md5Rc4Initialize(ULONG, PCHECKSUM_BUFFER *);
NTSTATUS NTAPI md5Rc4InitializeEx(PUCHAR, ULONG, ULONG, PCHECKSUM_BUFFER *);
NTSTATUS NTAPI md5Rc4Sum(PCHECKSUM_BUFFER, ULONG, PUCHAR);
NTSTATUS NTAPI md5Rc4Finalize(PCHECKSUM_BUFFER, PUCHAR);
NTSTATUS NTAPI md5Rc4Finish(PCHECKSUM_BUFFER *);

NTSTATUS NTAPI md5HmacInitialize(ULONG, PCHECKSUM_BUFFER *);
NTSTATUS NTAPI md5HmacInitializeEx(PUCHAR, ULONG, ULONG, PCHECKSUM_BUFFER *);
NTSTATUS NTAPI md5Hmac2InitializeEx(PUCHAR, ULONG, ULONG, PCHECKSUM_BUFFER *);

NTSTATUS NTAPI md5HmacSum(PCHECKSUM_BUFFER, ULONG, PUCHAR);
NTSTATUS NTAPI md5HmacFinalize(PCHECKSUM_BUFFER, PUCHAR);
NTSTATUS NTAPI md5HmacFinish(PCHECKSUM_BUFFER *);

NTSTATUS NTAPI md5Des1510InitializeEx(PUCHAR, ULONG, ULONG,  PCHECKSUM_BUFFER *);
NTSTATUS NTAPI md5Des1510InitializeEx2(PUCHAR, ULONG, PUCHAR, ULONG, PCHECKSUM_BUFFER *);
NTSTATUS NTAPI md5Des1510Finalize(PCHECKSUM_BUFFER, PUCHAR);
NTSTATUS NTAPI md5Des1510Finish(PCHECKSUM_BUFFER *);

#ifdef KERNEL_MODE
#pragma alloc_text( PAGEMSG, md25Initialize )
#pragma alloc_text( PAGEMSG, md25InitializeEx )
#pragma alloc_text( PAGEMSG, md25Sum )
#pragma alloc_text( PAGEMSG, md25Finalize )
#pragma alloc_text( PAGEMSG, md25Finish )
#pragma alloc_text( PAGEMSG, md5DesInitialize )
#pragma alloc_text( PAGEMSG, md5DesInitializeEx )
#pragma alloc_text( PAGEMSG, md5DesSum )
#pragma alloc_text( PAGEMSG, md5DesFinalize )
#pragma alloc_text( PAGEMSG, md5DesFinish )
#pragma alloc_text( PAGEMSG, md5Rc4Initialize )
#pragma alloc_text( PAGEMSG, md5Rc4InitializeEx )
#pragma alloc_text( PAGEMSG, md5Rc4Sum )
#pragma alloc_text( PAGEMSG, md5Rc4Finalize )
#pragma alloc_text( PAGEMSG, md5Rc4Finish )
#pragma alloc_text( PAGEMSG, md5HmacInitialize )
#pragma alloc_text( PAGEMSG, md5HmacInitializeEx )
#pragma alloc_text( PAGEMSG, md5Hmac2InitializeEx )
#pragma alloc_text( PAGEMSG, md5HmacSum )
#pragma alloc_text( PAGEMSG, md5HmacFinalize )
#pragma alloc_text( PAGEMSG, md5HmacFinish )
#pragma alloc_text( PAGEMSG, md5Des1510InitializeEx )
#pragma alloc_text( PAGEMSG, md5Des1510InitializeEx2 )
#pragma alloc_text( PAGEMSG, md5Des1510Finalize )
#pragma alloc_text( PAGEMSG, md5Des1510Finish )
#endif 


CHECKSUM_FUNCTION    csfMD4 = {
    KERB_CHECKSUM_MD4,          // Checksum type
    MD4_LEN,                    // Checksum length
    0,
    md4Initialize,
    md4Sum,
    md4Finalize,
    md4Finish,
    md4InitializeEx,
    NULL};

CHECKSUM_FUNCTION    csfMD5 = {
    KERB_CHECKSUM_MD5,          // Checksum type
    MD5_LEN,                    // Checksum length
    0,
    md5Initialize,
    md5Sum,
    md5Finalize,
    md5Finish,
    md5InitializeEx,
    NULL};

CHECKSUM_FUNCTION csfMD25 = {
    KERB_CHECKSUM_MD25,                 // Checksum type
    (MD5_LEN / 2),                      // Checksum length
    CKSUM_KEYED,
    md25Initialize,
    md25Sum,
    md25Finalize,
    md25Finish,
    md25InitializeEx};

CHECKSUM_FUNCTION    csfDES_MAC_MD5 = {
    KERB_CHECKSUM_DES_MAC_MD5,          // Checksum type
    DES_BLOCKLEN,                       // Checksum length
    CKSUM_KEYED,
    md5DesInitialize,
    md5DesSum,
    md5DesFinalize,
    md5DesFinish,
    md5DesInitializeEx,
    NULL};

CHECKSUM_FUNCTION    csfRC4_MD5 = {
    KERB_CHECKSUM_RC4_MD5,              // Checksum type
    MD5_LEN,                            // Checksum length
    CKSUM_KEYED,
    md5Rc4Initialize,
    md5Rc4Sum,
    md5Rc4Finalize,
    md5Rc4Finish,
    md5Rc4InitializeEx,
    NULL};

CHECKSUM_FUNCTION    csfMD5_HMAC = {
    KERB_CHECKSUM_MD5_HMAC,              // Checksum type
    MD5_LEN,                            // Checksum length
    CKSUM_KEYED,
    md5HmacInitialize,
    md5HmacSum,
    md5HmacFinalize,
    md5HmacFinish,
    md5HmacInitializeEx,
    NULL};

CHECKSUM_FUNCTION    csfHMAC_MD5 = {
    KERB_CHECKSUM_HMAC_MD5,              // Checksum type
    MD5_LEN,                            // Checksum length
    CKSUM_KEYED,
    md5HmacInitialize,
    md5HmacSum,
    md5HmacFinalize,
    md5HmacFinish,
    md5Hmac2InitializeEx,
    NULL};

CHECKSUM_FUNCTION    csfDES_MAC_MD5_1510 = {
    KERB_CHECKSUM_MD5_DES,              // Checksum type
    DES_BLOCKLEN + MD5_LEN,             // Checksum length
    CKSUM_KEYED,
    md5DesInitialize,
    md5DesSum,
    md5Des1510Finalize,
    md5Des1510Finish,
    md5Des1510InitializeEx,
    md5Des1510InitializeEx2};

///////////////////////////////////////////////////////////////////////////

NTSTATUS NTAPI
md4Initialize(  ULONG               dwSeed,
                PCHECKSUM_BUFFER *   ppcsBuffer)
{
    MD4_CTX *   pMD4Context;

#ifdef KERNEL_MODE
    pMD4Context = ExAllocatePool(NonPagedPool, sizeof(MD4_CTX));
#else
    pMD4Context = malloc(sizeof(MD4_CTX));
#endif
    if (!pMD4Context)
    {
        return(STATUS_NO_MEMORY);
    }
    MD4Init(pMD4Context);
    *ppcsBuffer = pMD4Context;
    return(STATUS_SUCCESS);

}

NTSTATUS NTAPI
md4InitializeEx(
    PUCHAR Key,
    ULONG  KeySize,
    ULONG  MessageType,
    PCHECKSUM_BUFFER * ppcsBuffer
    )
{
    return(md4Initialize(0, ppcsBuffer));
}


NTSTATUS NTAPI
md4Sum( PCHECKSUM_BUFFER     pcsBuffer,
        ULONG               cbData,
        PUCHAR               pbData)
{
    MD4Update((MD4_CTX *) pcsBuffer, pbData, cbData);
    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
md4Finalize(    PCHECKSUM_BUFFER pcsBuffer,
                PUCHAR           pbSum)
{
    MD4Final((MD4_CTX *) pcsBuffer);
    memcpy(pbSum, ((MD4_CTX *) pcsBuffer)->digest, 16);
    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
md4Finish(  PCHECKSUM_BUFFER *   ppcsBuffer)
{
#ifdef KERNEL_MODE
    ExFreePool(*ppcsBuffer);
#else
    free(*ppcsBuffer);
#endif
    *ppcsBuffer = 0;
    return(STATUS_SUCCESS);
}

///////////////////////////////////////////////////////////////////////////

NTSTATUS NTAPI
md5Initialize(
    ULONG dwSeed,
    PCHECKSUM_BUFFER *  ppcsBuffer)
{
    MD5_CTX *   pMD5Context;

#ifdef KERNEL_MODE
    pMD5Context = ExAllocatePool(NonPagedPool, sizeof(MD5_CTX));
#else
    pMD5Context = malloc(sizeof(MD5_CTX));
#endif
    if (!pMD5Context)
    {
        return(STATUS_NO_MEMORY);
    }
    MD5Init(pMD5Context);
    *ppcsBuffer = pMD5Context;
    return(STATUS_SUCCESS);

}

NTSTATUS NTAPI
md5InitializeEx(
    PUCHAR Key,
    ULONG KeySize,
    ULONG  MessageType,
    PCHECKSUM_BUFFER *  ppcsBuffer)
{
    return(md5Initialize(0, ppcsBuffer));
}


NTSTATUS NTAPI
md5Sum( PCHECKSUM_BUFFER     pcsBuffer,
        ULONG               cbData,
        PUCHAR               pbData)
{
    MD5Update((MD5_CTX *) pcsBuffer, pbData, cbData);
    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
md5Finalize(    PCHECKSUM_BUFFER pcsBuffer,
                PUCHAR           pbSum)
{
    MD5Final((MD5_CTX *) pcsBuffer);
    memcpy(pbSum, ((MD5_CTX *) pcsBuffer)->digest, 16);
    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
md5Finish(  PCHECKSUM_BUFFER *   ppcsBuffer)
{
#ifdef KERNEL_MODE
    ExFreePool(*ppcsBuffer);
#else
    free(*ppcsBuffer);
#endif
    *ppcsBuffer = 0;
    return(STATUS_SUCCESS);
}

///////////////////////////////////////////////////////////////////////////

NTSTATUS NTAPI desPlainInitialize(PUCHAR, ULONG, ULONG, PCRYPT_STATE_BUFFER *);
NTSTATUS NTAPI desEncrypt(PCRYPT_STATE_BUFFER, PUCHAR, ULONG, PUCHAR, PULONG);
NTSTATUS NTAPI desFinish(PCRYPT_STATE_BUFFER *);

NTSTATUS NTAPI desMacInitialize(ULONG, PCHECKSUM_BUFFER *);
NTSTATUS NTAPI desMacInitializeEx(PUCHAR,ULONG, ULONG, PCHECKSUM_BUFFER *);
NTSTATUS NTAPI desMacSum(PCHECKSUM_BUFFER, ULONG, PUCHAR);
NTSTATUS NTAPI desMacFinalize(PCHECKSUM_BUFFER, PUCHAR);
NTSTATUS NTAPI desMacFinish(PCHECKSUM_BUFFER *);

NTSTATUS NTAPI
md25Initialize(
    ULONG dwSeed,
    PCHECKSUM_BUFFER *  ppcsBuffer)
{
    return(STATUS_NOT_IMPLEMENTED);
}

NTSTATUS NTAPI
md25InitializeEx(
    PUCHAR Key,
    ULONG KeySize,
    ULONG  MessageType,
    PCHECKSUM_BUFFER *  ppcsBuffer)
{
    MD5_CTX *   pMD5Context;
    NTSTATUS Status = STATUS_SUCCESS;
    UCHAR TempBuffer[16];
    ULONG OutputSize;
    UCHAR TempKey[DES_KEYSIZE];
    PCRYPT_STATE_BUFFER DesContext = NULL;
    PCRYPTO_SYSTEM DesSystem;
    ULONG Index;

    memset(
        TempBuffer,
        0,
        sizeof(TempBuffer)
        );

    if (KeySize != DES_KEYSIZE)
    {
        return(STATUS_INVALID_PARAMETER);
    }

#ifdef KERNEL_MODE
    pMD5Context = (MD5_CTX *) ExAllocatePool(NonPagedPool,sizeof(MD5_CTX));
#else
    pMD5Context = (MD5_CTX *) LocalAlloc(0,sizeof(MD5_CTX));
#endif
    if (!pMD5Context)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    MD5Init(pMD5Context);

    //
    // Prepare the key by byte reversing it.
    //

    for (Index = 0; Index  < DES_KEYSIZE ; Index++ )
    {
        TempKey[Index] = Key[(DES_KEYSIZE - 1) - Index];
    }

    Status = CDLocateCSystem(
                KERB_ETYPE_DES_PLAIN,
                &DesSystem
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Status = DesSystem->Initialize(
                TempKey,
                DES_KEYSIZE,
                0,              // no options
                &DesContext
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
    Status = DesSystem->Encrypt(
                DesContext,
                TempBuffer,
                sizeof(TempBuffer),
                TempBuffer,
                &OutputSize
                );
    assert(OutputSize == sizeof(TempBuffer));
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    (VOID) DesSystem->Discard(&DesContext);

    //
    // Now MD5 update with the encrypted buffer
    //

    MD5Update(
        pMD5Context,
        TempBuffer,
        sizeof(TempBuffer)
        );


    *ppcsBuffer = (PCHECKSUM_BUFFER) pMD5Context;

Cleanup:
    if (!NT_SUCCESS(Status) && (pMD5Context != NULL))
    {
#ifdef KERNEL_MODE
        ExFreePool(pMD5Context);
#else
        LocalFree(pMD5Context);
#endif
    }
    return(Status);
}


NTSTATUS NTAPI
md25Sum( PCHECKSUM_BUFFER     pcsBuffer,
        ULONG               cbData,
        PUCHAR               pbData)
{
    MD5Update((MD5_CTX *) pcsBuffer, pbData, cbData);
    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
md25Finalize(
    PCHECKSUM_BUFFER pcsBuffer,
    PUCHAR pbSum)
{
    MD5Final((MD5_CTX *) pcsBuffer);
    memcpy(pbSum, ((MD5_CTX *) pcsBuffer)->digest, MD5_LEN/2);
    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
md25Finish(  PCHECKSUM_BUFFER *   ppcsBuffer)
{
#ifdef KERNEL_MODE
    ExFreePool(*ppcsBuffer);
#else
    LocalFree(*ppcsBuffer);
#endif
    *ppcsBuffer = 0;
    return(STATUS_SUCCESS);
}


///////////////////////////////////////////////////////////////////////////


NTSTATUS NTAPI
md5DesInitialize(
    ULONG dwSeed,
    PCHECKSUM_BUFFER *  ppcsBuffer)
{
    return(STATUS_NOT_IMPLEMENTED);
}

NTSTATUS NTAPI
md5DesInitializeEx(
    PUCHAR Key,
    ULONG KeySize,
    ULONG  MessageType,
    PCHECKSUM_BUFFER *  ppcsBuffer)
{
    PMD5_DES_STATE_BUFFER  pMD5Context;
    NTSTATUS Status = STATUS_SUCCESS;

    if (KeySize != DES_KEYSIZE)
    {
        return(STATUS_INVALID_PARAMETER);
    }

#ifdef KERNEL_MODE
    pMD5Context = (PMD5_DES_STATE_BUFFER) ExAllocatePool(NonPagedPool,sizeof(MD5_DES_STATE_BUFFER));
#else
    pMD5Context = (PMD5_DES_STATE_BUFFER) LocalAlloc(0,sizeof(MD5_DES_STATE_BUFFER));
#endif
    if (!pMD5Context)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    MD5Init(&pMD5Context->Md5Context);

    //
    // Compute the initialization for the MD5
    //

    Status = desPlainInitialize(
                Key,
                KeySize,
                0,
                &pMD5Context->DesContext
                );

    if (!NT_SUCCESS(Status))
    {
#ifdef KERNEL_MODE
        ExFreePool(pMD5Context);
#else
        LocalFree(pMD5Context);
#endif
        return(Status);
    }

    *ppcsBuffer = (PCHECKSUM_BUFFER) pMD5Context;
    return(STATUS_SUCCESS);
}


NTSTATUS NTAPI
md5DesSum( PCHECKSUM_BUFFER     pcsBuffer,
        ULONG               cbData,
        PUCHAR               pbData)
{
    PMD5_DES_STATE_BUFFER Context = (PMD5_DES_STATE_BUFFER) pcsBuffer;
    MD5Update(&Context->Md5Context, pbData, cbData);
    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
md5DesFinalize(    PCHECKSUM_BUFFER pcsBuffer,
                PUCHAR           pbSum)
{
    ULONG OutputLength;
    PMD5_DES_STATE_BUFFER Context = (PMD5_DES_STATE_BUFFER) pcsBuffer;
    MD5Final(&Context->Md5Context);

    desEncrypt(
        Context->DesContext,
        Context->Md5Context.digest,
        MD5_LEN,
        Context->Md5Context.digest,
        &OutputLength
        );

    memcpy(
        pbSum,
        Context->Md5Context.digest + MD5_LEN-DES_BLOCKLEN,
        DES_BLOCKLEN
        );

    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
md5DesFinish(  PCHECKSUM_BUFFER *   ppcsBuffer)
{
    PMD5_DES_STATE_BUFFER Context = (PMD5_DES_STATE_BUFFER) *ppcsBuffer;
    desFinish(&Context->DesContext);
#ifdef KERNEL_MODE
    ExFreePool(Context);
#else
    LocalFree(Context);
#endif
    *ppcsBuffer = 0;
    return(STATUS_SUCCESS);
}


///////////////////////////////////////////////////////////////////////////


NTSTATUS NTAPI rc4Md4Initialize(PUCHAR, ULONG, ULONG, PCRYPT_STATE_BUFFER *);
NTSTATUS NTAPI rc4LmInitialize(PUCHAR, ULONG, ULONG, PCRYPT_STATE_BUFFER *);
NTSTATUS NTAPI rc4ShaInitialize(PUCHAR, ULONG, ULONG, PCRYPT_STATE_BUFFER *);
NTSTATUS NTAPI rc4Initialize(PUCHAR, ULONG, ULONG, ULONG, PCRYPT_STATE_BUFFER *);
NTSTATUS NTAPI rc4Encrypt(PCRYPT_STATE_BUFFER, PUCHAR, ULONG, PUCHAR, PULONG);
NTSTATUS NTAPI rc4Decrypt(PCRYPT_STATE_BUFFER, PUCHAR, ULONG, PUCHAR, PULONG);
NTSTATUS NTAPI rc4Finish(PCRYPT_STATE_BUFFER *);

NTSTATUS NTAPI
md5Rc4Initialize(
    ULONG dwSeed,
    PCHECKSUM_BUFFER *  ppcsBuffer)
{
    return(STATUS_NOT_IMPLEMENTED);
}

NTSTATUS NTAPI
md5Rc4InitializeEx(
    PUCHAR Key,
    ULONG KeySize,
    ULONG  MessageType,
    PCHECKSUM_BUFFER *  ppcsBuffer)
{
    PMD5_DES_STATE_BUFFER  pMD5Context;
    NTSTATUS Status = STATUS_SUCCESS;

#ifdef KERNEL_MODE
    pMD5Context = (PMD5_DES_STATE_BUFFER) ExAllocatePool(NonPagedPool,sizeof(MD5_DES_STATE_BUFFER));
#else
    pMD5Context = (PMD5_DES_STATE_BUFFER) LocalAlloc(0,sizeof(MD5_DES_STATE_BUFFER));
#endif
    if (!pMD5Context)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    MD5Init(&pMD5Context->Md5Context);


    Status = rc4Initialize(
                Key,
                KeySize,
                0,              // no options
                0,
                &pMD5Context->DesContext
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


    if (!NT_SUCCESS(Status))
    {
#ifdef KERNEL_MODE
        ExFreePool(pMD5Context);
#else
        LocalFree(pMD5Context);
#endif
        return(Status);
    }

    *ppcsBuffer = (PCHECKSUM_BUFFER) pMD5Context;

Cleanup:
    if (!NT_SUCCESS(Status) && (pMD5Context != NULL))
    {
#ifdef KERNEL_MODE
        ExFreePool(pMD5Context);
#else
        LocalFree(pMD5Context);
#endif
    }
    return(STATUS_SUCCESS);
}


NTSTATUS NTAPI
md5Rc4Sum( PCHECKSUM_BUFFER     pcsBuffer,
        ULONG               cbData,
        PUCHAR               pbData)
{
    PMD5_DES_STATE_BUFFER Context = (PMD5_DES_STATE_BUFFER) pcsBuffer;
    MD5Update(&Context->Md5Context, pbData, cbData);
    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
md5Rc4Finalize(    PCHECKSUM_BUFFER pcsBuffer,
                PUCHAR           pbSum)
{
    PMD5_DES_STATE_BUFFER Context = (PMD5_DES_STATE_BUFFER) pcsBuffer;
    ULONG OutputSize;
    NTSTATUS Status;

    MD5Final(&Context->Md5Context);

    memcpy(
        pbSum,
        Context->Md5Context.digest,
        MD5_LEN
        );
    Status = rc4Encrypt(
                Context->DesContext,
                pbSum,
                MD5_LEN,
                pbSum,
                &OutputSize
                );


    assert(OutputSize == MD5_LEN);

    if (!NT_SUCCESS(Status))
    {
        return(Status);
    }



    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
md5Rc4Finish(  PCHECKSUM_BUFFER *   ppcsBuffer)
{
    PMD5_DES_STATE_BUFFER Context = (PMD5_DES_STATE_BUFFER) *ppcsBuffer;

    (VOID) rc4Finish(&Context->DesContext);
#ifdef KERNEL_MODE
    ExFreePool(Context);
#else
    LocalFree(Context);
#endif
    *ppcsBuffer = 0;
    return(STATUS_SUCCESS);
}


///////////////////////////////////////////////////////////////////////////

BOOLEAN
md5Hmac(
    IN PUCHAR pbKeyMaterial,
    IN ULONG cbKeyMaterial,
    IN PUCHAR pbData,
    IN ULONG cbData,
    IN PUCHAR pbData2,
    IN ULONG cbData2,
    OUT PUCHAR HmacData
    );


NTSTATUS NTAPI
md5HmacInitialize(
    ULONG dwSeed,
    PCHECKSUM_BUFFER *  ppcsBuffer)
{
    return(STATUS_NOT_IMPLEMENTED);
}

NTSTATUS NTAPI
md5HmacInitializeEx(
    PUCHAR Key,
    ULONG KeySize,
    ULONG  MessageType,
    PCHECKSUM_BUFFER *  ppcsBuffer)
{
    PMD5_HMAC_STATE_BUFFER  pMD5Context = NULL;
    NTSTATUS Status = STATUS_SUCCESS;

#ifdef KERNEL_MODE
    pMD5Context = (PMD5_HMAC_STATE_BUFFER) ExAllocatePool(NonPagedPool,sizeof(MD5_HMAC_STATE_BUFFER) + KeySize);
#else
    pMD5Context = (PMD5_HMAC_STATE_BUFFER) LocalAlloc(0,sizeof(MD5_HMAC_STATE_BUFFER) + KeySize);
#endif
    if (!pMD5Context)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    memcpy(
        pMD5Context->Key,
        Key,
        KeySize
        );
    pMD5Context->KeySize = KeySize;

    MD5Init(&pMD5Context->Md5Context);
    MD5Update(&pMD5Context->Md5Context, (PUCHAR) &MessageType, sizeof(ULONG));

    *ppcsBuffer = (PCHECKSUM_BUFFER) pMD5Context;

    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
md5Hmac2InitializeEx(
    PUCHAR Key,
    ULONG KeySize,
    ULONG  MessageType,
    PCHECKSUM_BUFFER *  ppcsBuffer)
{
    PMD5_HMAC_STATE_BUFFER  pMD5Context = NULL;
    NTSTATUS Status = STATUS_SUCCESS;

#ifdef KERNEL_MODE
    pMD5Context = (PMD5_HMAC_STATE_BUFFER) ExAllocatePool(NonPagedPool,sizeof(MD5_HMAC_STATE_BUFFER) + MD5_LEN);
#else
    pMD5Context = (PMD5_HMAC_STATE_BUFFER) LocalAlloc(0,sizeof(MD5_HMAC_STATE_BUFFER) + MD5_LEN);
#endif
    if (!pMD5Context)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    md5Hmac(
        Key,
        KeySize,
        "signaturekey",
        sizeof("signaturekey"),
        NULL,
        0,
        pMD5Context->Key
        );
    pMD5Context->KeySize = MD5_LEN;

    MD5Init(&pMD5Context->Md5Context);
    MD5Update(&pMD5Context->Md5Context, (PUCHAR) &MessageType, sizeof(ULONG));

    *ppcsBuffer = (PCHECKSUM_BUFFER) pMD5Context;

    return(STATUS_SUCCESS);
}


NTSTATUS NTAPI
md5HmacSum( PCHECKSUM_BUFFER     pcsBuffer,
        ULONG               cbData,
        PUCHAR               pbData)
{
    PMD5_HMAC_STATE_BUFFER Context = (PMD5_HMAC_STATE_BUFFER) pcsBuffer;
    MD5Update(&Context->Md5Context, pbData, cbData);
    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
md5HmacFinalize(    PCHECKSUM_BUFFER pcsBuffer,
                PUCHAR           pbSum)
{
    PMD5_HMAC_STATE_BUFFER Context = (PMD5_HMAC_STATE_BUFFER) pcsBuffer;

    MD5Final(&Context->Md5Context);

    if (!md5Hmac(
            Context->Key,
            Context->KeySize,
            Context->Md5Context.digest,
            MD5_LEN,
            NULL,               // no secondary material
            0,
            pbSum))
    {
        return(STATUS_UNSUCCESSFUL);
    }


    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
md5HmacFinish(  PCHECKSUM_BUFFER *   ppcsBuffer)
{
    PMD5_HMAC_STATE_BUFFER Context = (PMD5_HMAC_STATE_BUFFER) *ppcsBuffer;

#ifdef KERNEL_MODE
    ExFreePool(Context);
#else
    LocalFree(Context);
#endif
    *ppcsBuffer = 0;
    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
md5Des1510InitializeEx(
    PUCHAR Key,
    ULONG  KeySize,
    ULONG  MessageType,
    PCHECKSUM_BUFFER * ppcsBuffer
    )
{
    return(STATUS_NOT_IMPLEMENTED);
}

NTSTATUS NTAPI
md5Des1510InitializeEx2(
    PUCHAR Key,
    ULONG  KeySize,
    PUCHAR ChecksumToVerify,
    ULONG  MessageType,
    PCHECKSUM_BUFFER * ppcsBuffer
    )
{
    ULONG *pul;
    ULONG *pul2;
    UCHAR FinalKey[DES_KEYSIZE];
    PMD5_DES_1510_STATE_BUFFER  pContext = NULL;
    ULONG cb = DES_BLOCKLEN;
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // Make sure we were passed an appropriate key
    //

    if (KeySize != DES_KEYSIZE)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

#ifdef KERNEL_MODE
    pContext = (PMD5_DES_1510_STATE_BUFFER) ExAllocatePool(NonPagedPool,sizeof(MD5_DES_1510_STATE_BUFFER));
#else
    pContext = (PMD5_DES_1510_STATE_BUFFER) LocalAlloc(0,sizeof(MD5_DES_1510_STATE_BUFFER));
#endif
    if (!pContext)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // create the final key table
    //
    pul = (ULONG*)FinalKey;
    pul2 = (ULONG*)Key;
    *pul = *pul2 ^ 0xf0f0f0f0;
    pul = (ULONG*)(FinalKey + sizeof(ULONG));
    pul2 = (ULONG*)(Key + sizeof(ULONG));
    *pul = *pul2 ^ 0xf0f0f0f0;

    Status = desPlainInitialize(
                FinalKey,
                DES_KEYSIZE,
                0,
                &pContext->DesContext
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Checksum was not passed in so generate a confounder
    //
    if (NULL == ChecksumToVerify)
    {
        CDGenerateRandomBits(pContext->Confounder,DES_BLOCKLEN);
    }
    else
    {
        // the IV is all zero so no need to use CBC on first block
        Status = desEncrypt(
                        pContext->DesContext,
                        ChecksumToVerify,
                        DES_BLOCKLEN,
                        pContext->Confounder,
                        &cb
                        );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }

    MD5Init(&pContext->Md5Context);

    // hash in the confounder
    MD5Update(&pContext->Md5Context, pContext->Confounder, DES_BLOCKLEN);

    *ppcsBuffer = (PCHECKSUM_BUFFER) pContext;
Cleanup:
    if (Status != STATUS_SUCCESS)
    {
        if (NULL != pContext)
        {
#ifdef KERNEL_MODE
            ExFreePool(pContext);
#else
            LocalFree(pContext);
#endif
        }
    }

    return(Status);

}

NTSTATUS NTAPI
md5Des1510Finalize(
    PCHECKSUM_BUFFER pcsBuffer,
    PUCHAR           pbSum)
{
    UCHAR TmpBuffer[DES_BLOCKLEN * 2];
    PMD5_DES_1510_STATE_BUFFER pContext = (PMD5_DES_1510_STATE_BUFFER) pcsBuffer;
    ULONG cb = DES_BLOCKLEN * 2;
    NTSTATUS Status = STATUS_SUCCESS;

    memcpy(TmpBuffer, pContext->Confounder, DES_BLOCKLEN);
    memcpy(TmpBuffer + DES_BLOCKLEN, pContext->Md5Context.digest, DES_BLOCKLEN);

    Status = desEncrypt(
                    pContext->DesContext,
                    TmpBuffer,
                    DES_BLOCKLEN * 2,
                    pbSum,
                    &cb
                    );

    return(Status);
}

NTSTATUS NTAPI
md5Des1510Finish(  PCHECKSUM_BUFFER *   ppcsBuffer)
{
    PMD5_DES_1510_STATE_BUFFER pContext = (PMD5_DES_1510_STATE_BUFFER) *ppcsBuffer;
    desFinish(&pContext->DesContext);
#ifdef KERNEL_MODE
    ExFreePool(pContext);
#else
    LocalFree(pContext);
#endif
    *ppcsBuffer = 0;
    return(STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\cryptDLL\nullcs.c ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:        nullcs.c
//
// Contents:    Null Crypto system
//
//
// History:
//
//------------------------------------------------------------------------

#include "cryptdllp.h"



NTSTATUS NTAPI ncsInitialize(PUCHAR, ULONG, ULONG, PCRYPT_STATE_BUFFER *);
NTSTATUS NTAPI ncsEncrypt(PCRYPT_STATE_BUFFER, PUCHAR, ULONG, PUCHAR, PULONG);
NTSTATUS NTAPI ncsDecrypt(PCRYPT_STATE_BUFFER, PUCHAR, ULONG, PUCHAR, PULONG);
NTSTATUS NTAPI ncsFinish(PCRYPT_STATE_BUFFER *);
NTSTATUS NTAPI ncsHashPassword(PUNICODE_STRING, PUCHAR);
NTSTATUS NTAPI ncsRandomKey(PUCHAR, ULONG, PUCHAR );
NTSTATUS NTAPI ncsFinishRandom(void);


CRYPTO_SYSTEM    csNULL = {
    KERB_ETYPE_NULL,        // Etype
    1,                      // Blocksize (stream)
    0,                      // no exportable version
    0,                      // Key size, in bytes
    0,                      // no header size
    KERB_CHECKSUM_MD4,      // Checksum algorithm
    0,                      // no attributes
    L"Microsoft NULL CS",   // Text name
    ncsInitialize,
    ncsEncrypt,
    ncsDecrypt,
    ncsFinish,
    ncsHashPassword,
    ncsRandomKey
    };


NTSTATUS NTAPI
ncsInitialize(  PUCHAR pbKey,
                ULONG KeySize,
                ULONG dwOptions,
                PCRYPT_STATE_BUFFER * psbBuffer)
{

    *psbBuffer = NULL;
    return(S_OK);
}

NTSTATUS NTAPI
ncsEncrypt(     PCRYPT_STATE_BUFFER    psbBuffer,
                PUCHAR           pbInput,
                ULONG            cbInput,
                PUCHAR           pbOutput,
                PULONG           cbOutput)
{
    if (pbInput != pbOutput)
        memcpy(pbOutput, pbInput, cbInput);

    *cbOutput = cbInput;
    return(S_OK);
}

NTSTATUS NTAPI
ncsDecrypt(     PCRYPT_STATE_BUFFER    psbBuffer,
                PUCHAR           pbInput,
                ULONG            cbInput,
                PUCHAR           pbOutput,
                PULONG           cbOutput)
{
    if (pbInput != pbOutput)
        memcpy(pbOutput, pbInput, cbInput);
    *cbOutput = cbInput;
    return(S_OK);
}

NTSTATUS NTAPI
ncsFinish(      PCRYPT_STATE_BUFFER *  psbBuffer)
{
    *psbBuffer = NULL;
    return(S_OK);
}


NTSTATUS NTAPI
ncsHashPassword(PUNICODE_STRING pbPassword,
                PUCHAR           pbKey)
{

    return(STATUS_SUCCESS);
}


NTSTATUS NTAPI
ncsRandomKey(
    IN PUCHAR Seed,
    IN ULONG SeedLength,
    OUT PUCHAR pbKey
    )
{
    return(STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\cryptDLL\rc4crypt.c ===
//+-----------------------------------------------------------------------
//
// File:        rc4crypt.c
//
// Contents:    CryptoSystem wrapper functions for RC4 hmac
//
//
// History:     02-Nov-1998     MikeSw          Created
//
//------------------------------------------------------------------------

#include "cryptdllp.h"


typedef struct RC4_KEYSTRUCT  RC4KEY;

#define RC4_CONFOUNDER_LEN  8

typedef struct _RC4_MDx_HEADER {
    UCHAR Checksum[MD5_LEN];
    UCHAR Confounder[RC4_CONFOUNDER_LEN];
} RC4_MDx_HEADER, *PRC4_MDx_HEADER;

typedef struct _RC4_STATE_BUFFER {
    UCHAR BaseKey[MD5_LEN];
    RC4KEY Key;
} RC4_STATE_BUFFER, *PRC4_STATE_BUFFER;

typedef struct _RC4_HMAC_STATE_BUFFER {
    UCHAR Key[MD5_LEN];
} RC4_HMAC_STATE_BUFFER, *PRC4_HMAC_STATE_BUFFER;


NTSTATUS NTAPI rc4PlainInitialize(PUCHAR, ULONG, ULONG, PCRYPT_STATE_BUFFER *);
NTSTATUS NTAPI rc4PlainExpInitialize(PUCHAR, ULONG, ULONG, PCRYPT_STATE_BUFFER *);
NTSTATUS NTAPI rc4HmacInitialize(PUCHAR, ULONG, ULONG, PCRYPT_STATE_BUFFER *);
NTSTATUS NTAPI rc4HmacExpInitialize(PUCHAR, ULONG, ULONG, PCRYPT_STATE_BUFFER *);
NTSTATUS NTAPI rc4HmacEncrypt(PCRYPT_STATE_BUFFER, PUCHAR, ULONG, PUCHAR, PULONG);
NTSTATUS NTAPI rc4HmacDecrypt(PCRYPT_STATE_BUFFER, PUCHAR, ULONG, PUCHAR, PULONG);
NTSTATUS NTAPI rc4HmacPlainEncrypt(PCRYPT_STATE_BUFFER, PUCHAR, ULONG, PUCHAR, PULONG);
NTSTATUS NTAPI rc4HmacPlainDecrypt(PCRYPT_STATE_BUFFER, PUCHAR, ULONG, PUCHAR, PULONG);
NTSTATUS NTAPI rc4HmacFinish(PCRYPT_STATE_BUFFER *);
NTSTATUS NTAPI rc4HmacControl(ULONG, PCRYPT_STATE_BUFFER, PUCHAR, ULONG);
NTSTATUS NTAPI rc4HmacPlainControl(ULONG, PCRYPT_STATE_BUFFER, PUCHAR, ULONG);
NTSTATUS NTAPI rc4HmacRandomKey(PUCHAR, ULONG, PUCHAR);
NTSTATUS NTAPI rc4HmacHashPassword(PUNICODE_STRING, PUCHAR );

#ifdef KERNEL_MODE
#pragma alloc_text(PAGEMSG, rc4PlainInitialize)
#pragma alloc_text(PAGEMSG, rc4PlainExpInitialize )
#pragma alloc_text(PAGEMSG, rc4HmacInitialize )
#pragma alloc_text(PAGEMSG, rc4HmacExpInitialize )
#pragma alloc_text(PAGEMSG, rc4HmacEncrypt )
#pragma alloc_text(PAGEMSG, rc4HmacDecrypt )
#pragma alloc_text(PAGEMSG, rc4HmacPlainEncrypt )
#pragma alloc_text(PAGEMSG, rc4HmacPlainDecrypt )
#pragma alloc_text(PAGEMSG, rc4HmacFinish )
#pragma alloc_text(PAGEMSG, rc4HmacControl )
#pragma alloc_text(PAGEMSG, rc4HmacPlainControl )
#pragma alloc_text(PAGEMSG, rc4HmacRandomKey )
#pragma alloc_text(PAGEMSG, rc4HmacHashPassword )
#endif


CRYPTO_SYSTEM    csRC4_HMAC = {
    KERB_ETYPE_RC4_HMAC_NT,     // Etype
    1,                          // Blocksize (stream)
    KERB_ETYPE_RC4_HMAC_NT_EXP, // Exportable version
    MD4_LEN,                    // Key size, in bytes
    sizeof(RC4_MDx_HEADER),     // header size
    KERB_CHECKSUM_MD4,          // Preferred Checksum
    CSYSTEM_INTEGRITY_PROTECTED, //  attributes
    L"RSADSI RC4-HMAC",          // Text name
    rc4HmacInitialize,
    rc4HmacEncrypt,
    rc4HmacDecrypt,
    rc4HmacFinish,
    rc4HmacHashPassword,
    rc4HmacRandomKey,
    rc4HmacControl
    };


//
// This is not actually export strength - it is a signal that the
// plain version is export strength
//

CRYPTO_SYSTEM    csRC4_HMAC_EXP = {
    KERB_ETYPE_RC4_HMAC_NT_EXP, // Etype
    1,                          // Blocksize (stream)
    KERB_ETYPE_RC4_HMAC_NT_EXP, // Exportable version
    MD4_LEN,                    // Key size, in bytes
    sizeof(RC4_MDx_HEADER),     // header size
    KERB_CHECKSUM_MD4,          // Preferred Checksum
    CSYSTEM_INTEGRITY_PROTECTED | CSYSTEM_EXPORT_STRENGTH, //  attributes
    L"RSADSI RC4-HMAC",          // Text name
    rc4HmacInitialize,
    rc4HmacEncrypt,
    rc4HmacDecrypt,
    rc4HmacFinish,
    rc4HmacHashPassword,
    rc4HmacRandomKey,
    rc4HmacControl
    };


CRYPTO_SYSTEM    csRC4_PLAIN = {
    KERB_ETYPE_RC4_PLAIN,       // Etype
    1,                          // Blocksize (stream)
    KERB_ETYPE_RC4_PLAIN_EXP,   // exportable version
    MD4_LEN,                    // Key size, in bytes
    0,                          // header size
    KERB_CHECKSUM_MD4,          // Preferred Checksum
    0,                          // no attributes
    L"RSADSI RC4",              // Text name
    rc4PlainInitialize,
    rc4HmacPlainEncrypt,
    rc4HmacPlainDecrypt,
    rc4HmacFinish,
    rc4HmacHashPassword,
    rc4HmacRandomKey,
    rc4HmacPlainControl
    };

CRYPTO_SYSTEM    csRC4_PLAIN_EXP = {
    KERB_ETYPE_RC4_PLAIN_EXP,   // Etype
    1,                          // Blocksize (stream)
    KERB_ETYPE_RC4_PLAIN_EXP,   // exportable version
    MD4_LEN,                    // Key size, in bytes
    0,                          // header size
    KERB_CHECKSUM_MD4,          // Preferred Checksum
    CSYSTEM_EXPORT_STRENGTH,    // no attributes
    L"RSADSI RC4-EXP",          // Text name
    rc4PlainExpInitialize,
    rc4HmacPlainEncrypt,
    rc4HmacPlainDecrypt,
    rc4HmacFinish,
    rc4HmacHashPassword,
    rc4HmacRandomKey,
    rc4HmacPlainControl
    };



NTSTATUS NTAPI
rc4HmacHashPassword(
    IN PUNICODE_STRING Password,
    OUT PUCHAR Key
    )
{
    PCHECKSUM_FUNCTION   SumFunction;
    PCHECKSUM_BUFFER     Buffer;
    NTSTATUS     Status;


    Status = CDLocateCheckSum(KERB_CHECKSUM_MD4, &SumFunction);
    if (!NT_SUCCESS(Status))
    {
        return(SEC_E_CHECKSUM_NOT_SUPP);
    }


    Status = SumFunction->Initialize(0, &Buffer);
    if (!NT_SUCCESS(Status))
    {
        return(Status);
    }

    (void) SumFunction->Sum(Buffer, Password->Length, (PUCHAR) Password->Buffer);
    (void) SumFunction->Finalize(Buffer, Key);
    (void) SumFunction->Finish(&Buffer);
    return(STATUS_SUCCESS);
}




//////////////////////////////////////////////////////////////////////////
//
// RC4 HMAC crypt type
//
//////////////////////////////////////////////////////////////////////////

BOOLEAN static
md5Hmac(
    IN PUCHAR pbKeyMaterial,
    IN ULONG cbKeyMaterial,
    IN PUCHAR pbData,
    IN ULONG cbData,
    IN PUCHAR pbData2,
    IN ULONG cbData2,
    OUT PUCHAR HmacData
    )
{
    BOOLEAN fRet = FALSE;
#define HMAC_K_PADSIZE              64
    UCHAR Kipad[HMAC_K_PADSIZE];
    UCHAR Kopad[HMAC_K_PADSIZE];
    UCHAR HMACTmp[HMAC_K_PADSIZE+MD5_LEN];
    ULONG dwBlock;
    MD5_CTX Md5Hash;

    // truncate
    if (cbKeyMaterial > HMAC_K_PADSIZE)
        cbKeyMaterial = HMAC_K_PADSIZE;


    ZeroMemory(Kipad, HMAC_K_PADSIZE);
    memcpy(Kipad, pbKeyMaterial, cbKeyMaterial);

    ZeroMemory(Kopad, HMAC_K_PADSIZE);
    memcpy(Kopad, pbKeyMaterial, cbKeyMaterial);


    //
    // Kipad, Kopad are padded sMacKey. Now XOR across...
    //

    for(dwBlock=0; dwBlock<HMAC_K_PADSIZE/sizeof(ULONG); dwBlock++)
    {
        ((ULONG*)Kipad)[dwBlock] ^= 0x36363636;
        ((ULONG*)Kopad)[dwBlock] ^= 0x5C5C5C5C;
    }


    //
    // prepend Kipad to data, Hash to get H1
    //

    MD5Init(&Md5Hash);
    MD5Update(&Md5Hash, Kipad, HMAC_K_PADSIZE);
    if (cbData != 0)
    {
        MD5Update(&Md5Hash, pbData, cbData);
    }
    if (cbData2 != 0)
    {
        MD5Update(&Md5Hash, pbData2, cbData2);
    }

    // Finish off the hash
    MD5Final(&Md5Hash);

    // prepend Kopad to H1, hash to get HMAC
    memcpy(HMACTmp, Kopad, HMAC_K_PADSIZE);
    memcpy(HMACTmp+HMAC_K_PADSIZE, Md5Hash.digest, MD5_LEN);

    // final hash: output value into passed-in buffer
    MD5Init(&Md5Hash);
    MD5Update(&Md5Hash,HMACTmp, sizeof(HMACTmp));
    MD5Final(&Md5Hash);
    memcpy(
        HmacData,
        Md5Hash.digest,
        MD5_LEN
        );

    return TRUE;
}


NTSTATUS NTAPI
rc4HmacBaseInitialize(
    IN PUCHAR pbKey,
    IN ULONG KeySize,
    IN ULONG MessageType,
    IN BOOLEAN Exportable,
    OUT PCRYPT_STATE_BUFFER *  psbBuffer
    )
{
    PRC4_HMAC_STATE_BUFFER StateBuffer = NULL;
    ULONG LocalKeySize = 0;


    //
    // Compute the HMAC pad
    //


#ifdef KERNEL_MODE
    StateBuffer = (PRC4_HMAC_STATE_BUFFER) ExAllocatePool(NonPagedPool, sizeof(RC4_HMAC_STATE_BUFFER));
#else
    StateBuffer = (PRC4_HMAC_STATE_BUFFER) LocalAlloc(0, sizeof(RC4_HMAC_STATE_BUFFER));
#endif
    if (StateBuffer == NULL)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // If the key is not exportable, shrink it first
    //

    if (!Exportable)
    {
        md5Hmac(
            pbKey,
            KeySize,
            (PUCHAR) &MessageType,
            sizeof(ULONG),
            NULL,
            0,
            StateBuffer->Key
            );
        LocalKeySize = MD5_LEN;
    }
    else
    {
        md5Hmac(
            pbKey,
            KeySize,
            "fiftysixbits",
            sizeof("fiftysixbits"),
            (PUCHAR) &MessageType,
            sizeof(ULONG),
            StateBuffer->Key
            );
        LocalKeySize = 5;       // 40 bits

    }

    //
    // Pad exportable keys with 0xababab
    //

    assert(MD5_LEN >= LocalKeySize);

    memset(
        StateBuffer->Key+LocalKeySize,
        0xab,
        MD5_LEN-LocalKeySize
        );

    *psbBuffer = StateBuffer;
    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
rc4HmacInitialize(
    IN PUCHAR pbKey,
    IN ULONG KeySize,
    IN ULONG MessageType,
    OUT PCRYPT_STATE_BUFFER *  psbBuffer
    )
{
    return(rc4HmacBaseInitialize(
                pbKey,
                KeySize,
                MessageType,
                FALSE,          // not exportable
                psbBuffer
                ));
}


NTSTATUS NTAPI
rc4HmacPlainBaseInitialize(
    IN PUCHAR pbKey,
    IN ULONG KeySize,
    IN ULONG MessageType,
    IN BOOLEAN Exportable,
    OUT PCRYPT_STATE_BUFFER *  psbBuffer
    )
{
    PRC4_STATE_BUFFER StateBuffer = NULL;
    ULONG LocalKeySize = 0;


    //
    // Compute the HMAC pad
    //


#ifdef KERNEL_MODE
    StateBuffer = (PRC4_STATE_BUFFER) ExAllocatePool(NonPagedPool, sizeof(RC4_STATE_BUFFER));
#else
    StateBuffer = (PRC4_STATE_BUFFER) LocalAlloc(0, sizeof(RC4_STATE_BUFFER));
#endif
    if (StateBuffer == NULL)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // If the key is not exportable, shrink it first
    //

    if (!Exportable)
    {
        md5Hmac(
            pbKey,
            KeySize,
            (PUCHAR) &MessageType,
            sizeof(ULONG),
            NULL,
            0,
            StateBuffer->BaseKey
            );
        LocalKeySize = MD5_LEN;
    }
    else
    {
        md5Hmac(
            pbKey,
            KeySize,
            "fortybits",
            sizeof("fortybits"),
            (PUCHAR) &MessageType,
            sizeof(ULONG),
            StateBuffer->BaseKey
            );
        LocalKeySize = 7;       // 56 bits

    }

    //
    // Pad exportable keys with 0xababab
    //

    assert(MD5_LEN >= LocalKeySize);

    memset(
        StateBuffer->BaseKey+LocalKeySize,
        0xab,
        MD5_LEN-LocalKeySize
        );

    //
    // Create the encryption key
    //

    rc4_key(
        &StateBuffer->Key,
        MD5_LEN,
        StateBuffer->BaseKey
        );

    *psbBuffer = StateBuffer;
    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
rc4PlainInitialize(
    IN PUCHAR pbKey,
    IN ULONG KeySize,
    IN ULONG MessageType,
    OUT PCRYPT_STATE_BUFFER *  psbBuffer
    )
{
    return(rc4HmacPlainBaseInitialize(
                pbKey,
                KeySize,
                MessageType,
                FALSE,          // not exportable
                psbBuffer
                ));
}

NTSTATUS NTAPI
rc4PlainExpInitialize(
    IN PUCHAR pbKey,
    IN ULONG KeySize,
    IN ULONG MessageType,
    OUT PCRYPT_STATE_BUFFER *  psbBuffer
    )
{
    return(rc4HmacPlainBaseInitialize(
                pbKey,
                KeySize,                // only use 40 bites
                MessageType,
                TRUE,                   // exportable
                psbBuffer
                ));
}

NTSTATUS NTAPI
rc4HmacControl(
    IN ULONG Function,
    IN PCRYPT_STATE_BUFFER StateBuffer,
    IN PUCHAR InputBuffer,
    IN ULONG InputBufferSize
    )
{

    PRC4_HMAC_STATE_BUFFER HmacStateBuffer = (PRC4_HMAC_STATE_BUFFER) StateBuffer;

    if (Function == CRYPT_CONTROL_SET_INIT_VECT)
    {
        md5Hmac(
            HmacStateBuffer->Key,
            MD5_LEN,
            InputBuffer,
            InputBufferSize,
            NULL,
            0,
            HmacStateBuffer->Key
            );
    }
    else
    {
        return(STATUS_INVALID_PARAMETER);
    }

    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
rc4HmacPlainControl(
    IN ULONG Function,
    IN PCRYPT_STATE_BUFFER StateBuffer,
    IN PUCHAR InputBuffer,
    IN ULONG InputBufferSize
    )
{

    PRC4_STATE_BUFFER HmacStateBuffer = (PRC4_STATE_BUFFER) StateBuffer;

    if (Function == CRYPT_CONTROL_SET_INIT_VECT)
    {
        //
        // create the new initial key
        //

        md5Hmac(
            HmacStateBuffer->BaseKey,
            MD5_LEN,
            InputBuffer,
            InputBufferSize,
            NULL,
            0,
            HmacStateBuffer->BaseKey
            );

        //
        // Create the encryption key
        //

        rc4_key(
            &HmacStateBuffer->Key,
            MD5_LEN,
            HmacStateBuffer->BaseKey
            );

    }
    else
    {
        return(STATUS_INVALID_PARAMETER);
    }

    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
rc4HmacEncrypt(
    IN PCRYPT_STATE_BUFFER psbBuffer,
    IN PUCHAR pbInput,
    IN ULONG cbInput,
    OUT PUCHAR pbOutput,
    OUT PULONG cbOutput
    )
{
    PRC4_HMAC_STATE_BUFFER StateBuffer = (PRC4_HMAC_STATE_BUFFER) psbBuffer;
    PRC4_MDx_HEADER CryptHeader = (PRC4_MDx_HEADER) pbOutput;
    UCHAR LocalKey[MD5_LEN];
    ULONG Offset = 0;
    RC4KEY Rc4Key;

    Offset = sizeof(RC4_MDx_HEADER);
    MoveMemory(
        pbOutput + Offset,
        pbInput,
        cbInput
        );
    *cbOutput = cbInput + Offset;

    //
    // Create the header - the confounder & checksum
    //

    ZeroMemory(
        CryptHeader->Checksum,
        MD5_LEN
        );

    CDGenerateRandomBits(
        CryptHeader->Confounder,
        RC4_CONFOUNDER_LEN
        );

    //
    // Checksum everything but the checksum
    //

    md5Hmac(
        StateBuffer->Key,
        MD5_LEN,
        pbOutput+MD5_LEN,
        *cbOutput-MD5_LEN,
        NULL,
        0,
        CryptHeader->Checksum
        );


    //
    // HMAC the checksum into the key
    //

    md5Hmac(
        StateBuffer->Key,
        MD5_LEN,
        CryptHeader->Checksum,
        MD5_LEN,
        NULL,
        0,
        LocalKey
        );

    rc4_key(
        &Rc4Key,
        MD5_LEN,
        LocalKey
        );

    //
    // Encrypt everything but the checksum
    //

    rc4(&Rc4Key, *cbOutput-MD5_LEN, pbOutput+MD5_LEN);

    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
rc4HmacDecrypt( PCRYPT_STATE_BUFFER    psbBuffer,
                PUCHAR           pbInput,
                ULONG            cbInput,
                PUCHAR           pbOutput,
                PULONG            cbOutput)
{
    PRC4_HMAC_STATE_BUFFER StateBuffer = (PRC4_HMAC_STATE_BUFFER) psbBuffer;
    RC4_MDx_HEADER TempHeader;
    UCHAR TempChecksum[MD5_LEN];
    ULONG Offset = sizeof(RC4_MDx_HEADER);
    UCHAR LocalKey[MD5_LEN];
    RC4KEY Rc4Key;


    if (cbInput < Offset)
    {
        return(STATUS_INVALID_PARAMETER);
    }

    //
    // Copy the input to the output before decrypting
    //

    memcpy(
        &TempHeader,
        pbInput,
        Offset
        );

    *cbOutput = cbInput - Offset;
    MoveMemory(
        pbOutput,
        pbInput + Offset,
        *cbOutput
        );


    //
    // Build the decryption key from the checksum and the
    // real key
    //

    md5Hmac(
        StateBuffer->Key,
        MD5_LEN,
        TempHeader.Checksum,
        MD5_LEN,
        NULL,
        0,
        LocalKey
        );

    rc4_key(
        &Rc4Key,
        MD5_LEN,
        LocalKey
        );


    //
    // Now decrypt the two buffers
    //


    rc4(
        &Rc4Key,
        Offset - MD5_LEN,
        TempHeader.Confounder
        );


    rc4(
        &Rc4Key,
        *cbOutput,
        pbOutput
        );

    //
    // Now verify the checksum. First copy it out of the way, zero the
    // header
    //


    md5Hmac(
        StateBuffer->Key,
        MD5_LEN,
        TempHeader.Confounder,
        Offset-MD5_LEN,
        pbOutput,
        *cbOutput,
        TempChecksum
        );

    if (!memcmp(
            TempHeader.Checksum,
            TempChecksum,
            MD5_LEN
            ) != TRUE)
    {
        return(STATUS_UNSUCCESSFUL);
    }

    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
rc4HmacPlainEncrypt(
    IN PCRYPT_STATE_BUFFER psbBuffer,
    IN PUCHAR pbInput,
    IN ULONG cbInput,
    OUT PUCHAR pbOutput,
    OUT PULONG cbOutput
    )
{
    PRC4_STATE_BUFFER StateBuffer = (PRC4_STATE_BUFFER) psbBuffer;

    *cbOutput = cbInput;
    rc4(
        &StateBuffer->Key,
        cbInput,
        pbInput
        );

    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
rc4HmacPlainDecrypt(
    IN PCRYPT_STATE_BUFFER psbBuffer,
    IN PUCHAR pbInput,
    IN ULONG cbInput,
    OUT PUCHAR pbOutput,
    OUT PULONG cbOutput
    )
{
    PRC4_STATE_BUFFER StateBuffer = (PRC4_STATE_BUFFER) psbBuffer;

    *cbOutput = cbInput;

    rc4(
        &StateBuffer->Key,
        *cbOutput,
        pbOutput
        );
    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
rc4HmacFinish(      PCRYPT_STATE_BUFFER *  psbBuffer)
{
#ifdef KERNEL_MODE
    ExFreePool(*psbBuffer);
#else
    LocalFree(*psbBuffer);
#endif
    *psbBuffer = NULL;
    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
rc4HmacRandomKey(
    IN OPTIONAL PUCHAR Seed,
    IN ULONG SeedLength,
    OUT PUCHAR pbKey
    )
{
    CDGenerateRandomBits(pbKey,MD5_LEN);

    return(STATUS_SUCCESS);

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\cryptDLL\rng.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       rng.c
//
//  Contents:   Random Number Generator
//
//  Classes:
//
//  Functions:
//
//  History:    5-12-93   RichardW   Created
//
//----------------------------------------------------------------------------

#include "cryptdllp.h"


#ifdef KERNEL_MODE
int _fltused = 0x9875;
#endif
#ifdef WIN32_CHICAGO
NTSTATUS MyNtQuerySystemTime (PTimeStamp PTime);
#define NtQuerySystemTime(x) (MyNtQuerySystemTime(x))
#endif // WIN32_CHICAGO


BOOLEAN NTAPI   DefaultRngFn(PUCHAR, ULONG);

#ifdef KERNEL_MODE
#pragma alloc_text( PAGEMSG, DefaultRngFn )
#endif 

#define MAX_RNGS    4

RANDOM_NUMBER_GENERATOR   Rngs[MAX_RNGS];
ULONG                   cRngs = 0;

RANDOM_NUMBER_GENERATOR   DefaultRng = {CD_BUILTIN_RNG,
                                        RNG_PSEUDO_RANDOM,
                                        0,
                                        DefaultRngFn };


BOOLEAN NTAPI
CDGenerateRandomBits(   PUCHAR  pBuffer,
                        ULONG   cbBuffer);

BOOLEAN NTAPI
CDRegisterRng(PRANDOM_NUMBER_GENERATOR    pRng);

BOOLEAN NTAPI
CDLocateRng(ULONG   Id,
            PRANDOM_NUMBER_GENERATOR *    ppRng);

BOOLEAN NTAPI
DefaultRngFn(   PUCHAR      pbBuffer,
                ULONG       cbBuffer);

#ifdef KERNEL_MODE
#pragma alloc_text( PAGEMSG, CDGenerateRandomBits )
#pragma alloc_text( PAGEMSG, CDRegisterRng )
#pragma alloc_text( PAGEMSG, CDLocateRng )
#pragma alloc_text( PAGEMSG, DefaultRngFn )
#endif 


//
// Management functions:
//

BOOLEAN NTAPI
CDGenerateRandomBits(   PUCHAR  pBuffer,
                        ULONG   cbBuffer)
{
    return(Rngs[cRngs-1].GenerateBitstream(pBuffer, cbBuffer));
}


BOOLEAN NTAPI
CDRegisterRng(PRANDOM_NUMBER_GENERATOR    pRng)
{
    if (cRngs < MAX_RNGS)
    {
        Rngs[cRngs++] = *pRng;
        return(TRUE);
    }
    return(FALSE);
}

BOOLEAN NTAPI
CDLocateRng(ULONG   Id,
            PRANDOM_NUMBER_GENERATOR *    ppRng)
{
    ULONG   i;

    for (i = 0; i < MAX_RNGS ; i++ )
    {
        if (Rngs[i].GeneratorId == Id)
        {
            *ppRng = &Rngs[i];
            return(TRUE);
        }
    }

    *ppRng = NULL;
    return(FALSE);

}


#ifndef KERNEL_MODE

#define RND_A   16807
#define RND_M   2147483647
#define RND_Q   127773
#define RND_R   2836

//+-----------------------------------------------------------------------
//
// Function:    Random, private
//
// Synopsis:    Generates a random number [0,1] based on a seed.
//
// Effects:     Modifies seed parameter for multiple calls
//
// Arguments:   [plSeed] -- Pointer to long seed value
//
// Returns:     random number in the range [0,1]
//
// Algorithm:   see CACM, Oct 1988
//
// History:     10 Dec 91   RichardW    Created
//
//------------------------------------------------------------------------

float
Random(ULONG *  plSeed)
{
    long int    lo, hi, test;

    hi = *plSeed / RND_Q;
    lo = *plSeed % RND_Q;
    test = RND_A * lo - RND_R * hi;
    if (test > 0)
    {
        *plSeed = test;
    } else
    {
        *plSeed = test + RND_M;
    }

// This code is correct.  The compiler has a conniption fit about floating
// point constants, so I am forced to disable this warning for this line.

#pragma warning(disable:4056)

    return((float) *plSeed / (float) RND_M);

}
#endif 

BOOLEAN NTAPI
DefaultRngFn(   PUCHAR      pbBuffer,
                ULONG       cbBuffer)
{

    //
    // use the crypto group provided random number generator.
    //

#if 0	//kokwaic
//#if defined(TRUE_WHISTLER) && !defined(WIN32_CHICAGO) && !defined(KERNEL_MODE)

    return RtlGenRandom( pbBuffer, cbBuffer );

//#else
    NewGenRandom(NULL, NULL, pbBuffer, cbBuffer);
    return TRUE;

#endif	//kokwaic

    NewGenRandom(NULL, NULL, pbBuffer, cbBuffer);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\cryptDLL\rc4cwrap.c ===
//+-----------------------------------------------------------------------
//
// File:        RC4CWRAP.C
//
// Contents:    CryptoSystem wrapper functions for RC4
//
//
// History:     25 Feb 92   RichardW    Created
//
//------------------------------------------------------------------------

#include "cryptdllp.h"


//#define DONT_SUPPORT_OLD_ETYPES 1

typedef struct RC4_KEYSTRUCT  RC4KEY;

#define RC4_LEGAL_KEYSIZE   8
#define RC4_CONFOUNDER_LEN  8

typedef struct _RC4_MDx_HEADER {
    UCHAR Confounder[RC4_CONFOUNDER_LEN];
    UCHAR Checksum[MD4_LEN];
} RC4_MDx_HEADER, *PRC4_MDx_HEADER;

typedef struct _RC4_STATE_BUFFER {
    PCHECKSUM_FUNCTION ChecksumFunction;
    PCHECKSUM_BUFFER ChecksumBuffer;
    RC4KEY Key;
} RC4_STATE_BUFFER, *PRC4_STATE_BUFFER;

typedef struct _RC4_HMAC_STATE_BUFFER {
    UCHAR Key[MD5_LEN];
    BOOLEAN IncludeHmac;
} RC4_HMAC_STATE_BUFFER, *PRC4_HMAC_STATE_BUFFER;

NTSTATUS NTAPI rc4Md4Initialize(PUCHAR, ULONG, ULONG, PCRYPT_STATE_BUFFER *);
NTSTATUS NTAPI rc4LmInitialize(PUCHAR, ULONG, ULONG, PCRYPT_STATE_BUFFER *);
#ifndef DONT_SUPPORT_OLD_ETYPES
NTSTATUS NTAPI rc4Plain2Initialize(PUCHAR, ULONG, ULONG, PCRYPT_STATE_BUFFER *);
NTSTATUS NTAPI rc4LmHashPassword(PUNICODE_STRING, PUCHAR);
#endif
NTSTATUS NTAPI rc4Encrypt(PCRYPT_STATE_BUFFER, PUCHAR, ULONG, PUCHAR, PULONG);
NTSTATUS NTAPI rc4Decrypt(PCRYPT_STATE_BUFFER, PUCHAR, ULONG, PUCHAR, PULONG);
NTSTATUS NTAPI rc4Finish(PCRYPT_STATE_BUFFER *);
NTSTATUS NTAPI rc4Md4HashPassword(PUNICODE_STRING, PUCHAR);
NTSTATUS NTAPI rc4Md4RandomKey(PUCHAR, ULONG, PUCHAR);
NTSTATUS NTAPI rc4Control(ULONG, PCRYPT_STATE_BUFFER, PUCHAR, ULONG);

NTSTATUS NTAPI rc4PlainInitializeOld(PUCHAR, ULONG, ULONG, PCRYPT_STATE_BUFFER *);
NTSTATUS NTAPI rc4PlainExpInitializeOld(PUCHAR, ULONG, ULONG, PCRYPT_STATE_BUFFER *);
NTSTATUS NTAPI rc4HmacInitializeOld(PUCHAR, ULONG, ULONG, PCRYPT_STATE_BUFFER *);
NTSTATUS NTAPI rc4HmacExpInitializeOld(PUCHAR, ULONG, ULONG, PCRYPT_STATE_BUFFER *);
NTSTATUS NTAPI rc4HmacEncryptOld(PCRYPT_STATE_BUFFER, PUCHAR, ULONG, PUCHAR, PULONG);
NTSTATUS NTAPI rc4HmacDecryptOld(PCRYPT_STATE_BUFFER, PUCHAR, ULONG, PUCHAR, PULONG);
NTSTATUS NTAPI rc4HmacFinishOld(PCRYPT_STATE_BUFFER *);
NTSTATUS NTAPI rc4HmacControlOld(ULONG, PCRYPT_STATE_BUFFER, PUCHAR, ULONG);
NTSTATUS NTAPI rc4HmacRandomKeyOld(PUCHAR, ULONG, PUCHAR);

#ifdef KERNEL_MODE
#pragma alloc_text( PAGEMSG, rc4Md4Initialize )
#pragma alloc_text( PAGEMSG, rc4LmInitialize )
#pragma alloc_text( PAGEMSG, rc4Encrypt )
#pragma alloc_text( PAGEMSG, rc4Decrypt )
#pragma alloc_text( PAGEMSG, rc4Finish )
#pragma alloc_text( PAGEMSG, rc4Md4HashPassword )
#pragma alloc_text( PAGEMSG, rc4Md4RandomKey )
#pragma alloc_text( PAGEMSG, rc4Control )
#pragma alloc_text( PAGEMSG, rc4PlainInitializeOld )
#pragma alloc_text( PAGEMSG, rc4PlainExpInitializeOld )
#pragma alloc_text( PAGEMSG, rc4HmacInitializeOld )
#pragma alloc_text( PAGEMSG, rc4HmacExpInitializeOld )
#pragma alloc_text( PAGEMSG, rc4HmacDecryptOld )
#pragma alloc_text( PAGEMSG, rc4HmacEncryptOld )
#pragma alloc_text( PAGEMSG, rc4HmacFinishOld )
#pragma alloc_text( PAGEMSG, rc4HmacControlOld )
#pragma alloc_text( PAGEMSG, rc4HmacRandomKeyOld )
#endif

CRYPTO_SYSTEM    csRC4_MD4 = {
    KERB_ETYPE_RC4_MD4,         // Etype
    1,                          // Blocksize (stream)
    0,                          // no exportable version
    MD4_LEN,                    // Key size, in bytes
    sizeof(RC4_MDx_HEADER),     // header size
    KERB_CHECKSUM_MD4,          // Preferred Checksum
    CSYSTEM_INTEGRITY_PROTECTED,   //  attributes
    L"RSADSI RC4-MD4",          // Text name
    rc4Md4Initialize,
    rc4Encrypt,
    rc4Decrypt,
    rc4Finish,
    rc4Md4HashPassword,
    rc4Md4RandomKey,
    rc4Control
    };

#ifndef DONT_SUPPORT_OLD_ETYPES

CRYPTO_SYSTEM    csRC4_LM = {
    KERB_ETYPE_RC4_LM,          // Etype
    1,                          // Blocksize (stream)
    0,                          // no exportable version
    MD4_LEN,                    // State buffer size
    sizeof(RC4_MDx_HEADER),     // header size
    KERB_CHECKSUM_LM,           // Preferred Checksum
    CSYSTEM_INTEGRITY_PROTECTED,   //  attributes
    L"RSADSI RC4-LM",           // Text name
    rc4LmInitialize,
    rc4Encrypt,
    rc4Decrypt,
    rc4Finish,
    rc4LmHashPassword,
    rc4Md4RandomKey,
    rc4Control
    };

CRYPTO_SYSTEM    csRC4_PLAIN2 = {
    KERB_ETYPE_RC4_PLAIN2,      // Etype
    1,                          // Blocksize (stream)
    0,                          // no exportable version
    MD4_LEN,                    // Key size, in bytes
    0,                          // header size
    KERB_CHECKSUM_MD4,          // Preferred Checksum
    0,                          // no attributes
    L"RSADSI RC4-PLAIN",        // Text name
    rc4Plain2Initialize,
    rc4Encrypt,
    rc4Decrypt,
    rc4Finish,
    rc4Md4HashPassword,
    rc4Md4RandomKey,
    rc4Control
    };
#endif

CRYPTO_SYSTEM    csRC4_HMAC_OLD = {
    KERB_ETYPE_RC4_HMAC_OLD,        // Etype
    1,                          // Blocksize (stream)
    KERB_ETYPE_RC4_HMAC_OLD_EXP,// Exportable version
    MD4_LEN,                    // Key size, in bytes
    sizeof(RC4_MDx_HEADER),     // header size
    KERB_CHECKSUM_MD4,          // Preferred Checksum
    CSYSTEM_INTEGRITY_PROTECTED,   //  attributes
    L"RSADSI RC4-HMAC",          // Text name
    rc4HmacInitializeOld,
    rc4HmacEncryptOld,
    rc4HmacDecryptOld,
    rc4HmacFinishOld,
    rc4Md4HashPassword,
    rc4HmacRandomKeyOld,
    rc4HmacControlOld
    };

CRYPTO_SYSTEM    csRC4_HMAC_OLD_EXP = {
    KERB_ETYPE_RC4_HMAC_OLD_EXP,        // Etype
    1,                          // Blocksize (stream)
    KERB_ETYPE_RC4_HMAC_OLD_EXP, // Exportable version
    MD4_LEN,                    // Key size, in bytes
    sizeof(RC4_MDx_HEADER),     // header size
    KERB_CHECKSUM_MD4,          // Preferred Checksum
    CSYSTEM_INTEGRITY_PROTECTED | CSYSTEM_EXPORT_STRENGTH,   //  attributes
    L"RSADSI RC4-HMAC",          // Text name
    rc4HmacInitializeOld,
    rc4HmacEncryptOld,
    rc4HmacDecryptOld,
    rc4HmacFinishOld,
    rc4Md4HashPassword,
    rc4HmacRandomKeyOld,
    rc4HmacControlOld
    };


CRYPTO_SYSTEM    csRC4_PLAIN_OLD = {
    KERB_ETYPE_RC4_PLAIN_OLD,       // Etype
    1,                          // Blocksize (stream)
    KERB_ETYPE_RC4_PLAIN_OLD_EXP,   // exportable version
    MD4_LEN,                    // Key size, in bytes
    0,                          // header size
    KERB_CHECKSUM_MD4,          // Preferred Checksum
    0,                          // no attributes
    L"RSADSI RC4",              // Text name
    rc4PlainInitializeOld,
    rc4HmacEncryptOld,
    rc4HmacDecryptOld,
    rc4HmacFinishOld,
    rc4Md4HashPassword,
    rc4HmacRandomKeyOld,
    rc4HmacControlOld
    };

CRYPTO_SYSTEM    csRC4_PLAIN_OLD_EXP = {
    KERB_ETYPE_RC4_PLAIN_OLD_EXP,   // Etype
    1,                          // Blocksize (stream)
    KERB_ETYPE_RC4_PLAIN_OLD_EXP,   // exportable version
    MD4_LEN,                    // Key size, in bytes
    0,                          // header size
    KERB_CHECKSUM_MD4,          // Preferred Checksum
    CSYSTEM_EXPORT_STRENGTH,    // no attributes
    L"RSADSI RC4-EXP",          // Text name
    rc4PlainExpInitializeOld,
    rc4HmacEncryptOld,
    rc4HmacDecryptOld,
    rc4HmacFinishOld,
    rc4Md4HashPassword,
    rc4HmacRandomKeyOld,
    rc4HmacControlOld
    };


NTSTATUS NTAPI
rc4Initialize(  PUCHAR          pbKey,
                ULONG           KeySize,
                ULONG           MessageType,
                ULONG           ChecksumFunction,
                PCRYPT_STATE_BUFFER *  psbBuffer)
{
    NTSTATUS Status;
    PRC4_STATE_BUFFER    pRC4Key;
    PCHECKSUM_FUNCTION Checksum = NULL;

    //
    // Get the appropriate checksum here.
    //

    if (ChecksumFunction != 0)
    {
        Status = CDLocateCheckSum(
                    ChecksumFunction,
                    &Checksum
                    );
        if (!NT_SUCCESS(Status))
        {
            return(Status);
        }

    }
    //
    // if the key is too short, fail here.
    //

    if (KeySize < RC4_LEGAL_KEYSIZE)
    {
        return(SEC_E_ETYPE_NOT_SUPP);
    }

#ifdef KERNEL_MODE
    pRC4Key = ExAllocatePool(NonPagedPool, sizeof(RC4_STATE_BUFFER));
#else
    pRC4Key = LocalAlloc(0, sizeof(RC4_STATE_BUFFER));
#endif
    if (pRC4Key == NULL)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    rc4_key(&pRC4Key->Key, RC4_LEGAL_KEYSIZE, pbKey);

    //
    // Initialize the checksum function, if we have one.
    //

    pRC4Key->ChecksumFunction = Checksum;

    if (Checksum != NULL)
    {

        Status = Checksum->Initialize(
                    0,
                    &pRC4Key->ChecksumBuffer
                    );
        if (!NT_SUCCESS(Status))
        {
#ifdef KERNEL_MODE
            ExFreePool(pRC4Key);
#else
            LocalFree(pRC4Key);
#endif
            return(Status);
        }
    }

    *psbBuffer = (PCRYPT_STATE_BUFFER) pRC4Key;
    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
rc4Md4Initialize(
    IN PUCHAR pbKey,
    IN ULONG KeySize,
    IN ULONG MessageType,
    OUT PCRYPT_STATE_BUFFER *  psbBuffer
    )
{
    return(rc4Initialize(
                pbKey,
                KeySize,
                MessageType,
                KERB_CHECKSUM_MD4,
                psbBuffer
                ));
}

NTSTATUS NTAPI
rc4LmInitialize(
    IN PUCHAR pbKey,
    IN ULONG KeySize,
    IN ULONG MessageType,
    OUT PCRYPT_STATE_BUFFER *  psbBuffer
    )
{
    return(rc4Initialize(
                pbKey,
                KeySize,
                MessageType,
                KERB_CHECKSUM_LM,
                psbBuffer
                ));
}

#ifndef DONT_SUPPORT_OLD_ETYPES
NTSTATUS NTAPI
rc4Plain2Initialize(
    IN PUCHAR pbKey,
    IN ULONG KeySize,
    IN ULONG MessageType,
    OUT PCRYPT_STATE_BUFFER *  psbBuffer
    )
{
    return(rc4Initialize(
                pbKey,
                KeySize,
                MessageType,
                0,                      // no checksum
                psbBuffer
                ));
}


#endif

NTSTATUS NTAPI
rc4Encrypt(
    IN PCRYPT_STATE_BUFFER psbBuffer,
    IN PUCHAR pbInput,
    IN ULONG cbInput,
    OUT PUCHAR pbOutput,
    OUT PULONG cbOutput
    )
{
    PRC4_STATE_BUFFER StateBuffer = (PRC4_STATE_BUFFER) psbBuffer;
    PRC4_MDx_HEADER CryptHeader = (PRC4_MDx_HEADER) pbOutput;
    ULONG Offset = 0;

    if (StateBuffer->ChecksumFunction != NULL)
    {
        Offset = sizeof(RC4_MDx_HEADER);
    }
    MoveMemory(
        pbOutput + Offset,
        pbInput,
        cbInput
        );
    *cbOutput = cbInput + Offset;


    ZeroMemory(
        CryptHeader,
        Offset
        );

    rc4(&StateBuffer->Key, *cbOutput, pbOutput);

    return( STATUS_SUCCESS );
}

NTSTATUS NTAPI
rc4Decrypt(     PCRYPT_STATE_BUFFER    psbBuffer,
                PUCHAR           pbInput,
                ULONG            cbInput,
                PUCHAR           pbOutput,
                PULONG            cbOutput)
{
    PRC4_STATE_BUFFER StateBuffer = (PRC4_STATE_BUFFER) psbBuffer;
    RC4_MDx_HEADER TempHeader;
    ULONG Offset = 0;

    if (*cbOutput < cbInput)
    {
        *cbOutput = cbInput;
        return(STATUS_BUFFER_TOO_SMALL);
    }
    memcpy(
        pbOutput,
        pbInput,
        cbInput
        );

    rc4(&StateBuffer->Key, cbInput, pbOutput);

    if (StateBuffer->ChecksumFunction != NULL)
    {
        Offset = sizeof(RC4_MDx_HEADER);
    }

    ZeroMemory(
        &TempHeader,
        Offset
        );

    if (!memcmp(
            &TempHeader,
            pbOutput,
            Offset
            ) != TRUE)
    {
        return(STATUS_UNSUCCESSFUL);
    }


    *cbOutput = cbInput - Offset;


    MoveMemory(
        pbOutput,
        pbOutput + Offset,
        *cbOutput
        );


    return( STATUS_SUCCESS );
}

NTSTATUS NTAPI
rc4Finish(      PCRYPT_STATE_BUFFER *  psbBuffer)
{
    PRC4_STATE_BUFFER StateBuffer = (PRC4_STATE_BUFFER) *psbBuffer;


    if (StateBuffer->ChecksumFunction != NULL)
    {
        StateBuffer->ChecksumFunction->Finish(&StateBuffer->ChecksumBuffer);
    }
#ifdef KERNEL_MODE
    ExFreePool(*psbBuffer);
#else
    LocalFree(*psbBuffer);
#endif
    *psbBuffer = NULL;
    return(STATUS_SUCCESS);
}


NTSTATUS NTAPI
rc4HashPassword(
    IN PUNICODE_STRING Password,
    IN ULONG Checksum,
    OUT PUCHAR Key
    )
{
    PCHECKSUM_FUNCTION   SumFunction;
    PCHECKSUM_BUFFER     Buffer;
    NTSTATUS     Status;


    Status = CDLocateCheckSum(Checksum, &SumFunction);
    if (!NT_SUCCESS(Status))
    {
        return(SEC_E_CHECKSUM_NOT_SUPP);
    }


    Status = SumFunction->Initialize(0, &Buffer);
    if (!NT_SUCCESS(Status))
    {
        return(Status);
    }

    (void) SumFunction->Sum(Buffer, Password->Length, (PUCHAR) Password->Buffer);
    (void) SumFunction->Finalize(Buffer, Key);
    (void) SumFunction->Finish(&Buffer);
    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
rc4Md4HashPassword(
    PUNICODE_STRING pbPassword,
    PUCHAR           pbKey)
{
    return(rc4HashPassword( pbPassword, KERB_CHECKSUM_MD4, pbKey));
}

NTSTATUS NTAPI
rc4LmHashPassword(
    PUNICODE_STRING pbPassword,
    PUCHAR           pbKey)
{
    return(rc4HashPassword( pbPassword, KERB_CHECKSUM_LM, pbKey));
}


NTSTATUS NTAPI
rc4RandomKey(
    IN ULONG KeyLength,
    OUT PUCHAR pbKey
    )
{

    CDGenerateRandomBits(pbKey,KeyLength);

    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
rc4Md4RandomKey(
    IN OPTIONAL PUCHAR Seed,
    IN ULONG SeedLength,
    OUT PUCHAR pbKey
    )
{
    memset(
        pbKey,
        0xab,
        MD4_LEN
        );
    return(rc4RandomKey(5,pbKey));
}




NTSTATUS NTAPI
rc4Control(
    IN ULONG Function,
    IN PCRYPT_STATE_BUFFER StateBuffer,
    IN PUCHAR InputBuffer,
    IN ULONG InputBufferSize
    )
{
    UCHAR TempBuffer[128];

    PRC4_STATE_BUFFER Rc4StateBuffer = (PRC4_STATE_BUFFER) StateBuffer;

    if (Function != CRYPT_CONTROL_SET_INIT_VECT)
    {
        return(STATUS_INVALID_PARAMETER);
    }
    if (InputBufferSize > sizeof(TempBuffer))
    {
        return(STATUS_INVALID_PARAMETER);
    }

    //
    // We set the IV by encrypting the supplied buffer and leaving the
    // keystate changed.
    //

    memcpy(
        TempBuffer,
        InputBuffer,
        InputBufferSize
        );
    rc4(&Rc4StateBuffer->Key, InputBufferSize, TempBuffer );

    return(STATUS_SUCCESS);
}

//////////////////////////////////////////////////////////////////////////
//
// RC4 HMAC crypt type
//
//////////////////////////////////////////////////////////////////////////

BOOLEAN
md5Hmac(
    IN PUCHAR pbKeyMaterial,
    IN ULONG cbKeyMaterial,
    IN PUCHAR pbData,
    IN ULONG cbData,
    IN PUCHAR pbData2,
    IN ULONG cbData2,
    OUT PUCHAR HmacData
    )
{
    BOOLEAN fRet = FALSE;
#define HMAC_K_PADSIZE              64
    UCHAR Kipad[HMAC_K_PADSIZE];
    UCHAR Kopad[HMAC_K_PADSIZE];
    UCHAR HMACTmp[HMAC_K_PADSIZE+MD5_LEN];
    ULONG dwBlock;
    MD5_CTX Md5Hash;

    // truncate
    if (cbKeyMaterial > HMAC_K_PADSIZE)
        cbKeyMaterial = HMAC_K_PADSIZE;


    ZeroMemory(Kipad, HMAC_K_PADSIZE);
    memcpy(Kipad, pbKeyMaterial, cbKeyMaterial);

    ZeroMemory(Kopad, HMAC_K_PADSIZE);
    memcpy(Kopad, pbKeyMaterial, cbKeyMaterial);


    //
    // Kipad, Kopad are padded sMacKey. Now XOR across...
    //

    for(dwBlock=0; dwBlock<HMAC_K_PADSIZE/sizeof(ULONG); dwBlock++)
    {
        ((ULONG*)Kipad)[dwBlock] ^= 0x36363636;
        ((ULONG*)Kopad)[dwBlock] ^= 0x5C5C5C5C;
    }


    //
    // prepend Kipad to data, Hash to get H1
    //

    MD5Init(&Md5Hash);
    MD5Update(&Md5Hash, Kipad, HMAC_K_PADSIZE);
    if (cbData != 0)
    {
        MD5Update(&Md5Hash, pbData, cbData);
    }
    if (cbData2 != 0)
    {
        MD5Update(&Md5Hash, pbData2, cbData2);
    }

    // Finish off the hash
    MD5Final(&Md5Hash);

    // prepend Kopad to H1, hash to get HMAC
    memcpy(HMACTmp, Kopad, HMAC_K_PADSIZE);
    memcpy(HMACTmp+HMAC_K_PADSIZE, Md5Hash.digest, MD5_LEN);

    // final hash: output value into passed-in buffer
    MD5Init(&Md5Hash);
    MD5Update(&Md5Hash,HMACTmp, sizeof(HMACTmp));
    MD5Final(&Md5Hash);
    memcpy(
        HmacData,
        Md5Hash.digest,
        MD5_LEN
        );

    return TRUE;
}


NTSTATUS NTAPI
rc4HmacBaseInitializeOld(
    IN PUCHAR pbKey,
    IN ULONG KeySize,
    IN ULONG MessageType,
    IN BOOLEAN IncludeHmac,
    IN BOOLEAN Exportable,
    OUT PCRYPT_STATE_BUFFER *  psbBuffer
    )
{
    PRC4_HMAC_STATE_BUFFER StateBuffer = NULL;
    LPSTR Direction = NULL;
    ULONG DirectionSize = 0;
    LPSTR Usage = NULL;
    ULONG UsageSize = 0;
    ULONG LocalKeySize = 0;


    //
    // Compute the HMAC pad
    //


#ifdef KERNEL_MODE
    StateBuffer = ExAllocatePool(NonPagedPool, sizeof(RC4_HMAC_STATE_BUFFER));
#else
    StateBuffer = LocalAlloc(0, sizeof(RC4_HMAC_STATE_BUFFER));
#endif
    if (StateBuffer == NULL)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // If the key is not exportable, shrink it first
    //

    if (!Exportable)
    {
        md5Hmac(
            pbKey,
            KeySize,
            (PUCHAR) &MessageType,
            sizeof(ULONG),
            NULL,
            0,
            StateBuffer->Key
            );
        LocalKeySize = MD5_LEN;
    }
    else
    {
        md5Hmac(
            pbKey,
            KeySize,
            "fortybits",
            sizeof("fortybits"),
            (PUCHAR) &MessageType,
            sizeof(ULONG),
            StateBuffer->Key
            );
        LocalKeySize = 5;       // 40 bits

    }

    //
    // Pad exportable keys with 0xababab
    //

    memset(
        StateBuffer->Key+LocalKeySize,
        0xab,
        MD5_LEN-LocalKeySize
        );

    StateBuffer->IncludeHmac = IncludeHmac;
    *psbBuffer = StateBuffer;
    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
rc4HmacInitializeOld(
    IN PUCHAR pbKey,
    IN ULONG KeySize,
    IN ULONG MessageType,
    OUT PCRYPT_STATE_BUFFER *  psbBuffer
    )
{
    return(rc4HmacBaseInitializeOld(
                pbKey,
                KeySize,
                MessageType,
                TRUE,           // include hmac
                FALSE,          // not exportable
                psbBuffer
                ));
}


NTSTATUS NTAPI
rc4PlainInitializeOld(
    IN PUCHAR pbKey,
    IN ULONG KeySize,
    IN ULONG MessageType,
    OUT PCRYPT_STATE_BUFFER *  psbBuffer
    )
{
    return(rc4HmacBaseInitializeOld(
                pbKey,
                KeySize,
                MessageType,
                FALSE,          // no hmac
                FALSE,          // not exportable
                psbBuffer
                ));
}

NTSTATUS NTAPI
rc4PlainExpInitializeOld(
    IN PUCHAR pbKey,
    IN ULONG KeySize,
    IN ULONG MessageType,
    OUT PCRYPT_STATE_BUFFER *  psbBuffer
    )
{
    return(rc4HmacBaseInitializeOld(
                pbKey,
                KeySize,                // only use 40 bites
                MessageType,
                FALSE,                  // no hmac
                TRUE,                   // exportable
                psbBuffer
                ));
}

NTSTATUS NTAPI
rc4HmacControlOld(
    IN ULONG Function,
    IN PCRYPT_STATE_BUFFER StateBuffer,
    IN PUCHAR InputBuffer,
    IN ULONG InputBufferSize
    )
{

    PRC4_HMAC_STATE_BUFFER HmacStateBuffer = (PRC4_HMAC_STATE_BUFFER) StateBuffer;

    if (Function == CRYPT_CONTROL_SET_INIT_VECT)
    {
        md5Hmac(
            HmacStateBuffer->Key,
            MD5_LEN,
            InputBuffer,
            InputBufferSize,
            NULL,
            0,
            HmacStateBuffer->Key
            );
    }
    else
    {
        return(STATUS_INVALID_PARAMETER);
    }

    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
rc4HmacEncryptOld(
    IN PCRYPT_STATE_BUFFER psbBuffer,
    IN PUCHAR pbInput,
    IN ULONG cbInput,
    OUT PUCHAR pbOutput,
    OUT PULONG cbOutput
    )
{
    PRC4_HMAC_STATE_BUFFER StateBuffer = (PRC4_HMAC_STATE_BUFFER) psbBuffer;
    PRC4_MDx_HEADER CryptHeader = (PRC4_MDx_HEADER) pbOutput;
    ULONG Offset = 0;
    RC4KEY Rc4Key;

    if (StateBuffer->IncludeHmac)
    {
        Offset = sizeof(RC4_MDx_HEADER);
    }
    else
    {
        Offset = 0;
    }
    MoveMemory(
        pbOutput + Offset,
        pbInput,
        cbInput
        );
    *cbOutput = cbInput + Offset;

    //
    // Create the header - the confounder & checksum
    //

    if (Offset != 0)
    {
        ZeroMemory(
            CryptHeader->Checksum,
            MD4_LEN
            );

        CDGenerateRandomBits(
            CryptHeader->Confounder,
            RC4_CONFOUNDER_LEN
            );

        md5Hmac(
            StateBuffer->Key,
            MD5_LEN,
            pbOutput,
            *cbOutput,
            NULL,
            0,
            CryptHeader->Checksum
            );
    }

    rc4_key(
        &Rc4Key,
        MD5_LEN,
        StateBuffer->Key
        );

    rc4(&Rc4Key, *cbOutput, pbOutput);

    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
rc4HmacDecryptOld( PCRYPT_STATE_BUFFER    psbBuffer,
                PUCHAR           pbInput,
                ULONG            cbInput,
                PUCHAR           pbOutput,
                PULONG            cbOutput)
{
    PRC4_HMAC_STATE_BUFFER StateBuffer = (PRC4_HMAC_STATE_BUFFER) psbBuffer;
    RC4_MDx_HEADER TempHeader;
    UCHAR TempChecksum[MD5_LEN];
    ULONG Offset = sizeof(RC4_MDx_HEADER);
    RC4KEY Rc4Key;

    if (!StateBuffer->IncludeHmac)
    {
        Offset = 0;
    }

    if (cbInput < Offset)
    {
        return(STATUS_INVALID_PARAMETER);
    }

    rc4_key(
        &Rc4Key,
        MD5_LEN,
        StateBuffer->Key
        );

    //
    // Copy the input to the output before decrypting
    //

    memcpy(
        &TempHeader,
        pbInput,
        Offset
        );

    *cbOutput = cbInput - Offset;
    MoveMemory(
        pbOutput,
        pbInput + Offset,
        *cbOutput
        );

    //
    // Now decrypt the two buffers
    //


    if (Offset != 0)
    {
        rc4(
            &Rc4Key,
            Offset,
            (PUCHAR) &TempHeader
            );
    }

    rc4(
        &Rc4Key,
        *cbOutput,
        pbOutput
        );

    //
    // Now verify the checksum. First copy it out of the way, zero the
    // header
    //

    if (Offset != 0)
    {

        memcpy(
            TempChecksum,
            TempHeader.Checksum,
            MD5_LEN
            );

        ZeroMemory(
            TempHeader.Checksum,
            MD5_LEN
            );

        md5Hmac(
            StateBuffer->Key,
            MD5_LEN,
            (PUCHAR) &TempHeader,
            Offset,
            pbOutput,
            *cbOutput,
            TempHeader.Checksum
            );

        if (!memcmp(
                TempHeader.Checksum,
                TempChecksum,
                MD5_LEN
                ) != TRUE)
        {
            return(STATUS_UNSUCCESSFUL);
        }
    }

    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
rc4HmacFinishOld(      PCRYPT_STATE_BUFFER *  psbBuffer)
{
#ifdef KERNEL_MODE
    ExFreePool(*psbBuffer);
#else
    LocalFree(*psbBuffer);
#endif
    *psbBuffer = NULL;
    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
rc4HmacRandomKeyOld(
    IN OPTIONAL PUCHAR Seed,
    IN ULONG SeedLength,
    OUT PUCHAR pbKey
    )
{
    return(rc4RandomKey(MD5_LEN,pbKey));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\cryptDLL\shawrap.c ===
//
//

#include "cryptdllp.h"


NTSTATUS NTAPI
ShaWrapInitialize(ULONG dwSeed,
                PCHECKSUM_BUFFER * ppcsBuffer);

NTSTATUS NTAPI
ShaWrapInitializeEx(PUCHAR Seed, ULONG dwSeedLength, ULONG MessageType,
                PCHECKSUM_BUFFER * ppcsBuffer);


NTSTATUS NTAPI
ShaWrapSum(   PCHECKSUM_BUFFER pcsBuffer,
            ULONG           cbData,
            PUCHAR          pbData );

NTSTATUS NTAPI
ShaWrapFinalize(  PCHECKSUM_BUFFER pcsBuffer,
                PUCHAR          pbSum);

NTSTATUS NTAPI
ShaWrapFinish(PCHECKSUM_BUFFER *   ppcsBuffer);



CHECKSUM_FUNCTION csfSHA = {
    KERB_CHECKSUM_SHA1,
    A_SHA_DIGEST_LEN,
    CKSUM_COLLISION,
    ShaWrapInitialize,
    ShaWrapSum,
    ShaWrapFinalize,
    ShaWrapFinish,
    ShaWrapInitializeEx,
    NULL
};

#ifdef KERNEL_MODE
#pragma alloc_text( PAGEMSG, ShaWrapInitialize )
#pragma alloc_text( PAGEMSG, ShaWrapSum )
#pragma alloc_text( PAGEMSG, ShaWrapFinalize )
#pragma alloc_text( PAGEMSG, ShaWrapFinish )
#pragma alloc_text( PAGEMSG, ShaWrapInitializeEx )
#endif 

NTSTATUS NTAPI
ShaWrapInitialize(
    ULONG   dwSeed,
    PCHECKSUM_BUFFER *  ppcsBuffer)
{
    A_SHA_CTX * pContext;

#ifdef KERNEL_MODE
    pContext = ExAllocatePool( NonPagedPool, sizeof( A_SHA_CTX ) );
#else
    pContext = LocalAlloc( LMEM_FIXED, sizeof( A_SHA_CTX ) );
#endif

    if ( pContext )
    {
        A_SHAInit( pContext );

        *ppcsBuffer = pContext;

        return( SEC_E_OK );
    }

    return( STATUS_NO_MEMORY );
}

NTSTATUS NTAPI
ShaWrapInitializeEx(
    PUCHAR Seed,
    ULONG SeedLength,
    ULONG MessageType,
    PCHECKSUM_BUFFER *  ppcsBuffer)
{
    A_SHA_CTX * pContext;

#ifdef KERNEL_MODE
    pContext = ExAllocatePool( NonPagedPool, sizeof( A_SHA_CTX ) );
#else
    pContext = LocalAlloc( LMEM_FIXED, sizeof( A_SHA_CTX ) );
#endif

    if ( pContext )
    {
        A_SHAInit( pContext );

        *ppcsBuffer = pContext;

        return( SEC_E_OK );
    }

    return( STATUS_NO_MEMORY );
}


NTSTATUS NTAPI
ShaWrapSum(
    PCHECKSUM_BUFFER pcsBuffer,
    ULONG           cbData,
    PUCHAR          pbData )
{
    A_SHA_CTX * pContext;

    pContext = (A_SHA_CTX *) pcsBuffer ;

    A_SHAUpdate( pContext, pbData, cbData );

    return( STATUS_SUCCESS );

}


NTSTATUS NTAPI
ShaWrapFinalize(
    PCHECKSUM_BUFFER pcsBuffer,
    PUCHAR          pbSum)
{
    A_SHA_CTX * pContext;

    pContext = (A_SHA_CTX *) pcsBuffer ;

    A_SHAFinal( pContext, pbSum );

    return( STATUS_SUCCESS );

}

NTSTATUS NTAPI
ShaWrapFinish(
    PCHECKSUM_BUFFER *   ppcsBuffer)
{

    ZeroMemory( *ppcsBuffer, sizeof( A_SHA_CTX ) );

#ifdef KERNEL_MODE
    ExFreePool( *ppcsBuffer );
#else
    LocalFree( *ppcsBuffer );
#endif

    *ppcsBuffer = NULL ;

    return( STATUS_SUCCESS );

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\cryptDLL\inc\modes.h ===
#ifndef __MODES_H__
#define __MODES_H__

#ifndef RSA32API
#define RSA32API __stdcall
#endif

/* modes.h

    Defines the generic routines used to do chaining modes with a
    block cipher.
*/


#ifdef __cplusplus
extern "C" {
#endif

// constants for operations
#define ENCRYPT     1
#define DECRYPT     0

/* CBC()
 *
 * Performs a XOR on the plaintext with the previous ciphertext
 *
 * Parameters:
 *
 *      output      Input buffer    -- MUST be RC2_BLOCKLEN
 *      input       Output buffer   -- MUST be RC2_BLOCKLEN
 *      keyTable
 *      op      ENCRYPT, or DECRYPT
 *      feedback    feedback register
 *
 */
void
RSA32API
CBC(
         void   RSA32API Cipher(UCHAR *, UCHAR *, void *, int),
         ULONG  dwBlockLen,
         UCHAR   *output,
         UCHAR   *input,
         void   *keyTable,
         int    op,
         UCHAR   *feedback
         );


/* CFB (cipher feedback)
 *
 *
 * Parameters:
 *
 *
 *      output      Input buffer    -- MUST be RC2_BLOCKLEN
 *      input       Output buffer   -- MUST be RC2_BLOCKLEN
 *      keyTable
 *      op      ENCRYPT, or DECRYPT
 *      feedback    feedback register
 *
 */
void
RSA32API
CFB(
         void   RSA32API Cipher(UCHAR *, UCHAR *, void *, int),
         ULONG  dwBlockLen,
         UCHAR   *output,
         UCHAR   *input,
         void   *keyTable,
         int    op,
         UCHAR   *feedback
         );


#ifdef __cplusplus
}
#endif

#endif // __MODES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\cryptDLL\inc\randlib.h ===
/*++

Copyright (c) 1993, 1998  Microsoft Corporation

Module Name:

    randlib.h

Abstract:

    Exported procedures for core cryptographic random number generation.

Author:

    Scott Field (sfield)    27-Oct-98

Revision History:

      Oct 11 1996 jeffspel moved from ntagimp1.h
      Aug 27 1997 sfield   Increase RAND_CTXT_LEN
      Aug 15 1998 sfield   Kernel mode and general cleanup

--*/

#ifndef __RANDLIB_H__
#define __RANDLIB_H__

#ifndef RSA32API
#define RSA32API __stdcall
#endif

#ifdef __cplusplus
extern "C" {
#endif


typedef struct {
    unsigned long   cbSize;
    unsigned long   Flags;
    unsigned char   *pbRandSeed;
    unsigned long   cbRandSeed;
} RNG_CONTEXT, *PRNG_CONTEXT, *LPRNG_CONTEXT;

#define RNG_FLAG_REKEY_ONLY 1


//
// primary random number generation interface
// Functions return TRUE for success, FALSE for failure.
//

unsigned int
RSA32API
NewGenRandomEx(
    IN      RNG_CONTEXT *pRNGContext,
    IN  OUT unsigned char *pbRandBuffer,
    IN      unsigned long cbRandBuffer
    );


unsigned int
RSA32API
NewGenRandom(
    IN  OUT unsigned char **ppbRandSeed,    // initial seed value (ignored if already set)
    IN      unsigned long *pcbRandSeed,
    IN  OUT unsigned char *pbBuffer,
    IN      unsigned long dwLength
    );

//
// RNG seed set and query
//

unsigned int
RSA32API
InitRand(
    IN  OUT unsigned char **ppbRandSeed,    // new seed value to set (over-writes current)
    IN      unsigned long *pcbRandSeed
    );

unsigned int
RSA32API
DeInitRand(
    IN  OUT unsigned char *pbRandSeed,      // output of current seed
    IN      unsigned long cbRandSeed
    );


//
// RNG initializers for DLL_PROCESS_ATTACH, DLL_PROCESS_DETACH
//

unsigned int
RSA32API
InitializeRNG(
    VOID *pvReserved
    );

void
RSA32API
ShutdownRNG(
    VOID *pvReserved
    );



//
// RC4 thread safe primitives, for the bold users who stream data from RC4
// themselves.
//


//
// rc4_safe_startup called to initialize internal structures.
// typically called during DLL_PROCESS_ATTACH type initialiation code.
//

unsigned int
RSA32API
rc4_safe_startup(
    IN OUT  void **ppContext
    );

unsigned int
RSA32API
rc4_safe_startup_np(
    IN OUT  void **ppContext
    );


//
// typically call rc4_safe_shutdown during DLL_PROCESS_DETACH, with the
// value obtained during rc4_safe_startup
//

void
RSA32API
rc4_safe_shutdown(
    IN      void *pContext
    );

void
RSA32API
rc4_safe_shutdown_np(
    IN      void *pContext
    );


//
// select a safe entry.
// outputs: entry index
//          bytes used for specified index.  0xffffffff indicates caller
//          MUST call rc4_safe_key to initialize the key.
//          caller decides when to rekey based on non-zero output of pBytesUsed
//          example is RNG re-keying when pBytesUsed >= 16384
//


void
RSA32API
rc4_safe_select(
    IN      void *pContext,
    OUT     unsigned int *pEntry,
    OUT     unsigned int *pBytesUsed
    );

void
RSA32API
rc4_safe_select_np(
    IN      void *pContext,
    OUT     unsigned int *pEntry,
    OUT     unsigned int *pBytesUsed
    );

//
// initialize the key specified by Entry index.
//  key material is size cb, pointer to key is pv.
// this routine is the safe version of rc4_key()
//

void
RSA32API
rc4_safe_key(
    IN      void *pContext,
    IN      unsigned int Entry,
    IN      unsigned int cb,
    IN      const void *pv
    );

void
RSA32API
rc4_safe_key_np(
    IN      void *pContext,
    IN      unsigned int Entry, // 0xffffffff for default
    IN      unsigned int cb,
    IN      const void *pv
    );

//
// encrypt using the key specified by Entry index.
// buffer of size cb at location pv is encrypted.
// this routine is the safe version of rc4()
//

void
RSA32API
rc4_safe(
    IN      void *pContext,
    IN      unsigned int Entry,
    IN      unsigned int cb,
    IN      void *pv
    );

void
RSA32API
rc4_safe_np(
    IN      void *pContext,
    IN      unsigned int Entry,
    IN      unsigned int cb,
    IN      void *pv
    );


#ifdef __cplusplus
}
#endif

#endif // __RANDLIB_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\cryptDLL\inc\md4.h ===
#ifndef __MD4_H__
#define __MD4_H__

#ifndef RSA32API
#define RSA32API __stdcall
#endif

/*
** ********************************************************************
** md4.h -- Header file for implementation of                        **
** MD4 Message Digest Algorithm                                      **
** Updated: 2/13/90 by Ronald L. Rivest                              **
** (C) 1990 RSA Data Security, Inc.                                  **
** ********************************************************************
*/

#ifdef __cplusplus
extern "C" {
#endif

// MD4Update Errors
#define MD4_SUCCESS         0
#define MD4_TOO_BIG         1
#define MD4_ALREADY_DONE    2

// MD4 Digest length -- 4 word result == 16 bytes
#define MD4DIGESTLEN 16

// Block size of MD4 -- Assumes 8 bits per byte
#define MD4BLOCKSIZE 64
#define MD4BYTESTOBITS(bytes) ((bytes)*8)   // MDupdate wants bits

/* MDstruct is the data structure for a message digest computation.
*/
typedef struct {
  unsigned long buffer[4]; /* Holds 4-word result of MD computation */
  unsigned char count[8]; /* Number of bits processed so far */
  unsigned int done;      /* Nonzero means MD computation finished */
} MDstruct, *MDptr;

/* MDbegin(MD)
** Input: MD -- an MDptr
** Initialize the MDstruct prepatory to doing a message digest
** computation.
**
** MTS: Assumes MDPtr is locked against simultaneous use.
*/
extern void MDbegin(MDptr);

/* MDupdate(MD,X,count)
** Input: MD -- an MDptr
**     X -- a pointer to an array of unsigned characters.
**        count -- the number of bits of X to use (an unsigned int).
** Updates MD using the first "count" bits of X.
** The array pointed to by X is not modified.
** If count is not a multiple of 8, MDupdate uses high bits of
** last byte.
** This is the basic input routine for a user.
** The routine terminates the MD computation when count < MD4BLOCKSIZE, so
** every MD computation should end with one call to MDupdate with a
** count less than MD4BLOCKSIZE.  Zero is OK for a count.
**
** Return values:
**      MD4_SUCCESS:        success
**      MD4_TOO_LONG:       Hash is already terminated
**      MD4_ALREADY_DONE:   Length is invalid (too big)
**
** MTS: Assumes MDPtr is locked against simultaneous use.
**
**
** NOTE: MDupdate wants the length in BITS
*/
extern int MDupdate(MDptr, const unsigned char *pbData, int wLen);



/*

    This second implementation of MD4 entry points is the newer style,
    optimized implementation, compatible with newer code expecting these
    entry point names.

    Scott Field (sfield)    21-Oct-97

*/


#ifndef UINT4
#define UINT4   unsigned long
#endif

/* Data structure for MD4 (Message Digest) computation */
typedef struct {
  UINT4 state[4];                                   /* state (ABCD) */
  UINT4 count[2];        /* number of bits, modulo 2^64 (lsb first) */
  unsigned char buffer[64];                         /* input buffer */
  unsigned char digest[16];    /* actual digest after MD4Final call */
} MD4_CTX;

#define MD4_LEN 16

void RSA32API MD4Init (MD4_CTX *);
void RSA32API MD4Update (MD4_CTX *, unsigned char *, unsigned int);
void RSA32API MD4Final (MD4_CTX * );

#ifdef __cplusplus
}
#endif

#endif __MD4_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\cryptDLL\inc\rc4.h ===
#ifndef __RC4_H__
#define __RC4_H__

#ifndef RSA32API
#define RSA32API __stdcall
#endif

#ifdef __cplusplus
extern "C" {
#endif

/* Key structure */
#if defined(_WIN64) && !defined(MIDL_PASS)
__declspec(align(8))
#endif
typedef struct RC4_KEYSTRUCT
{
  unsigned char S[256];     /* State table */
  unsigned char i,j;        /* Indices */
} RC4_KEYSTRUCT;

/* rc4_key()
 *
 * Generate the key control structure.  Key can be any size.
 *
 * Parameters:
 *   Key        A KEYSTRUCT structure that will be initialized.
 *   dwLen      Size of the key, in bytes.
 *   pbKey      Pointer to the key.
 *
 * MTS: Assumes pKS is locked against simultaneous use.
 */
void RSA32API rc4_key(struct RC4_KEYSTRUCT *pKS, unsigned int dwLen, unsigned char *pbKey);

/* rc4()
 *
 * Performs the actual encryption
 *
 * Parameters:
 *
 *   pKS        Pointer to the KEYSTRUCT created using rc4_key().
 *   dwLen      Size of buffer, in bytes.
 *   pbuf       Buffer to be encrypted.
 *
 * MTS: Assumes pKS is locked against simultaneous use.
 */
void RSA32API rc4(struct RC4_KEYSTRUCT *pKS, unsigned int dwLen, unsigned char *pbuf);

#ifdef __cplusplus
}
#endif

#endif // __RC4_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\cryptDLL\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_kdccrypt_none_12.4.56.0_none_b40b13bda35adcd4
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_kdccrypt_no-public-key_12.4.56.0_x-ww_1159faba
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=kdccrypt
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_kdccrypt_no-public-key_12.4.56.0_x-ww_1159faba
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_kdccrypt_no-public-key_12.4.56.0_x-ww_1159faba.manifest
XP_MANIFEST_PATH=manifests\x86_kdccrypt_no-public-key_12.4.56.0_x-ww_1159faba.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_kdccrypt_no-public-key_12.4.56.0_x-ww_1159faba.cat
XP_CATALOG_PATH=manifests\x86_kdccrypt_no-public-key_12.4.56.0_x-ww_1159faba.cat
XP_PAYLOAD_PATH=x86_kdccrypt_no-public-key_12.4.56.0_x-ww_1159faba
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=kdccrypt,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\cryptDLL\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_kdccrypt_none_12.4.56.0_none_b40b13bda35adcd4
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_kdccrypt_no-public-key_12.4.56.0_x-ww_1159faba
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=kdccrypt
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_kdccrypt_no-public-key_12.4.56.0_x-ww_1159faba
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_kdccrypt_no-public-key_12.4.56.0_x-ww_1159faba.manifest
XP_MANIFEST_PATH=manifests\x86_kdccrypt_no-public-key_12.4.56.0_x-ww_1159faba.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_kdccrypt_no-public-key_12.4.56.0_x-ww_1159faba.cat
XP_CATALOG_PATH=manifests\x86_kdccrypt_no-public-key_12.4.56.0_x-ww_1159faba.cat
XP_PAYLOAD_PATH=x86_kdccrypt_no-public-key_12.4.56.0_x-ww_1159faba
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=kdccrypt,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\debuglib\assert.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       assert.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    4-03-95   RichardW   Created
//
//----------------------------------------------------------------------------

#include "debuglib.h"

typedef ULONG (NTAPI * DBGPROMPT)(PCH, PCH, ULONG);

#define DSYSASSERT_FAILED   0x00000001
#define DSYSASSERT_ERROR    0x00000002
#define DSYSASSERT_WARN     0x00000004

DWORD           __AssertInfoLevel = DSYSASSERT_FAILED;
DebugModule     __AssertModule = {NULL, &__AssertInfoLevel, 0, 7,
                                    NULL, 0, 0, "Assert",
                                    {"FAILED", "Error", "Warning", "",
                                     "", "", "", "",
                                     "", "", "", "", "", "", "", "",
                                     "", "", "", "", "", "", "", "",
                                     "", "", "", "", "", "", "", "" }
                                    };

DebugModule *   __pAssertModule = &__AssertModule;

VOID
__AssertDebugOut(
    ULONG Mask,
    CHAR * Format,
    ... )
{
    va_list ArgList;
    va_start(ArgList, Format);
    _DebugOut( __pAssertModule, Mask, Format, ArgList);
}

BOOL
DbgpStartDebuggerOnMyself(BOOL UseKernelDebugger)
{
    WCHAR   cch[80];
    STARTUPINFO StartupInfo;
    PROCESS_INFORMATION ProcessInformation;
    HANDLE  hEvent;

    hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

    swprintf_s(cch, sizeof(cch)/sizeof(WCHAR), L"ntsd %s -p %ld -e %p -g", (UseKernelDebugger ? L"-d" : L""),
                        GetCurrentProcessId(), hEvent);


    ZeroMemory(&StartupInfo, sizeof(STARTUPINFO));

    StartupInfo.cb = sizeof(STARTUPINFO);
    if (!UseKernelDebugger)
    {
        StartupInfo.lpDesktop = TEXT("WinSta0\\Default");
    }

    if (CreateProcess(  NULL,
                        cch,
                        NULL,
                        NULL,
                        TRUE,
                        HIGH_PRIORITY_CLASS,
                        NULL,
                        NULL,
                        &StartupInfo,
                        &ProcessInformation) )
    {
        CloseHandle(ProcessInformation.hProcess);
        CloseHandle(ProcessInformation.hThread);
        WaitForSingleObject(hEvent, 60000);
        CloseHandle(hEvent);
        return(TRUE);
    }
    else
    {
        __AssertDebugOut( DSYSASSERT_ERROR, "Could not start debugger '%ws', %d\n", cch, GetLastError());
        return(FALSE);
    }

}


VOID
_DsysAssertEx(
    PVOID FailedAssertion,
    PVOID FileName,
    ULONG LineNumber,
    PCHAR Message,
    ULONG ContinueCode
    )
{
    CHAR        Response[2];
    HMODULE     hNtDll;
    DBGPROMPT   DbgPromptFn;


    if (DbgpHeader)
    {
        __pAssertModule->pHeader = DbgpHeader;
        if (DbgpHeader->fDebug & DEBUG_DISABLE_ASRT)
        {
            __AssertDebugOut( DSYSASSERT_WARN, "Assertion at %s:%d disabled\n",
                            FileName, LineNumber);
            return;
        }
    }

    if (Message)
        __AssertDebugOut( DSYSASSERT_FAILED, "%s: %s (%s:%d)\n",
                    Message, FailedAssertion, FileName, LineNumber);
     else
        __AssertDebugOut( DSYSASSERT_FAILED, "%s (%s:%d)\n",
                    FailedAssertion, FileName, LineNumber);

    switch (ContinueCode)
    {

        case DSYSDBG_ASSERT_BREAK:
            __AssertDebugOut( DSYSASSERT_FAILED, "\tBreakpoint\n");
            DebugBreak();
            break;

        case DSYSDBG_ASSERT_CONTINUE:
            __AssertDebugOut( DSYSASSERT_WARN, "\tContinuing\n");
            return;

        case DSYSDBG_ASSERT_SUSPEND:
            __AssertDebugOut( DSYSASSERT_WARN, "\tSuspending Thread %d\n", GetCurrentThreadId());
            SuspendThread(GetCurrentThread());
            return;

        case DSYSDBG_ASSERT_DEBUGGER:
            if (IsDebuggerPresent())
            {
                DebugBreak();
            }
            else
            {
                if (DbgpHeader)
                {
                    if ((DbgpHeader->fDebug & DEBUG_PROMPTS) == 0)
                    {
                        DbgpStartDebuggerOnMyself(DbgpHeader->fDebug & DEBUG_USE_KDEBUG);
                        DebugBreak();
                        break;
                    }
                }

                hNtDll = LoadLibrary(TEXT("ntdll.dll"));
                if (hNtDll)
                {
                    DbgPromptFn = (DBGPROMPT) GetProcAddress(hNtDll, "DbgPrompt");
                }
                else
                {
                    DbgPromptFn = NULL;
                }

                while (TRUE)
                {

                    if (DbgPromptFn)
                    {
                        DbgPromptFn( "Start Debugger, Break, Ignore (dbi)?",
                                    Response, sizeof(Response));

                        switch (Response[0])
                        {
                            case 'i':
                            case 'I':
                                return;

                            case 'd':
                            case 'D':
                                DbgpStartDebuggerOnMyself(DbgpHeader ? (DbgpHeader->fDebug & DEBUG_USE_KDEBUG) : TRUE );

                            case 'b':
                            case 'B':
                                DebugBreak();
                                return;
                        }
                    }
                    else
                    {
                        DbgpStartDebuggerOnMyself(TRUE);
                        DebugBreak();
                        return;
                    }
                }


            }
            break;

        default:
            __AssertDebugOut( DSYSASSERT_ERROR, "Unknown continue code for assert: %d\n",
                        ContinueCode);
            return;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\debuglib\dbglibp.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       dbglibp.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    5-01-95   RichardW   Created
//
//----------------------------------------------------------------------------

//
// Common defines for the debug library
//

extern  PDebugHeader        DbgpHeader;
extern  DebugModule         __CompatModule;
extern  DebugHeader         __CompatHeader;

extern  DebugModule *       __pCompatModule;
extern  DebugModule *       __pExceptionModule;
extern  DebugModule *       __pAssertModule;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\debuglib\debug.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       debug.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    3-14-95   RichardW   Created
//
//----------------------------------------------------------------------------

#include "debuglib.h"

PDebugHeader        DbgpHeader = NULL;

DebugModule * *     DbgpFixupModules[] = {  &__pAssertModule,
                                            &__pExceptionModule,
                                            NULL };

CHAR                szDebugSection[] = "DSysDebug";
CHAR                szDebugFlags[] = "DebugFlags";

DEBUG_KEY           DbgpKeys[] = { {DEBUG_NO_DEBUGIO,   "NoDebugger"},
                                   {DEBUG_TIMESTAMP,    "TimeStamp"},
                                   {DEBUG_DEBUGGER_OK,  "DebuggerOk"},
                                   {DEBUG_LOGFILE,      "Logfile"},
                                   {DEBUG_AUTO_DEBUG,   "AutoDebug"},
                                   {DEBUG_USE_KDEBUG,   "UseKD"},
                                   {DEBUG_HEAP_CHECK,   "HeapCheck"},
                                   {DEBUG_MULTI_THREAD, "MultiThread"},
                                   {DEBUG_DISABLE_ASRT, "DisableAssert"},
                                   {DEBUG_PROMPTS,      "AssertPrompts"},
                                   {DEBUG_BREAK_ON_ERROR,"BreakOnError"},
                                   {0,                  NULL }
                                 };

#define DEBUG_NUMBER_OF_KEYS    ((sizeof(DbgpKeys) / sizeof(DEBUG_KEY)) - 1)

#define _ALIGN(x,a) (x & (a-1) ? (x + a) & ~(a - 1) : x);

#define ALIGN_8(x)  _ALIGN(x, 8)
#define ALIGN_16(x) _ALIGN(x, 16)

#ifdef WIN64
#define DBG_ALIGN   ALIGN_16
#else 
#define DBG_ALIGN   ALIGN_8
#endif 

#define DEBUGMEM_ALLOCATED  0x00000001

typedef struct _DebugMemory {
    struct _DebugMemory *   pNext;
    DWORD                   Size;
    DWORD                   Flags;
} DebugMemory, * PDebugMemory;


#ifdef DEBUG_DEBUG
#define LockDebugHeader(p)      EnterCriticalSection(&((p)->csDebug)); OutputDebugStringA("Lock")
#define UnlockDebugHeader(p)    LeaveCriticalSection(&((p)->csDebug)); OutputDebugStringA("Unlock")
#else
#define LockDebugHeader(p)      EnterCriticalSection(&((p)->csDebug))
#define UnlockDebugHeader(p)    LeaveCriticalSection(&((p)->csDebug))
#endif

//+---------------------------------------------------------------------------
//
//  Function:   DbgpComputeMappingName
//
//  Synopsis:   Computes the mapping object name
//
//  Arguments:  [pszName] -- place to stick the name (no more than 32 wchars)
//
//  History:    3-22-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
void
DbgpComputeMappingName(PWSTR pszName, size_t nBufLen)
{
    swprintf_s(pszName, nBufLen, L"Debug.Memory.%x", GetCurrentProcessId());
}


//+---------------------------------------------------------------------------
//
//  Function:   DbgpInitializeMM
//
//  Synopsis:   Initializes our simple memory manager within the shared mem
//              section.
//
//  Arguments:  [pHeader] -- Header to initialize
//
//  History:    3-22-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
DbgpInitializeMM(PDebugHeader   pHeader)
{
    PDebugMemory    pMem;

    pMem = (PDebugMemory) (pHeader + 1);
    pMem->pNext = NULL;
    pMem->Size = pHeader->CommitRange - (sizeof(DebugHeader) + sizeof(DebugMemory));
    pHeader->pFreeList = pMem;
}


//+---------------------------------------------------------------------------
//
//  Function:   DbgpAlloc
//
//  Synopsis:   Very, very simple allocator
//
//  Arguments:  [pHeader] -- Header from which to allocate
//              [cSize]   -- size to allocate
//
//  History:    3-22-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PVOID
DbgpAlloc(
    PDebugHeader    pHeader,
    DWORD           cSize)
{
    PDebugMemory    pSearch;
    PDebugMemory    pLargest = NULL;
    PDebugMemory    pNew;
    DWORD           cLargest;

    cLargest = 0;
    cSize = DBG_ALIGN(cSize);

    //
    // Very, very simple allocator.  Search free list for an exact match,
    //

    pSearch = (PDebugMemory) pHeader->pFreeList;
    while (pSearch)
    {
        if ( ( pSearch->Flags & DEBUGMEM_ALLOCATED ) == 0 )
        {
            if ( pSearch->Size == cSize )
            {
                break;
            }

            if (pSearch->Size > cLargest)
            {
                pLargest = pSearch;
                cLargest = pSearch->Size;
            }
            
        }

        pSearch = pSearch->pNext;

    }

    //
    // If no match yet
    //

    if (!pSearch)
    {
        //
        // If the largest free block is still too small,
        //

        if (cLargest < (cSize + sizeof(DebugMemory) * 2) ||
            NULL == pLargest )
        {
            //
            // Extend the mapped range
            //
            if (pHeader->CommitRange < pHeader->ReserveRange)
            {
                if ( VirtualAlloc(
                            (PUCHAR) pHeader + pHeader->CommitRange,
                            pHeader->PageSize,
                            MEM_COMMIT,
                            PAGE_READWRITE ) )
                {
                    pNew = (PDebugMemory) ((PUCHAR) pHeader + pHeader->CommitRange );
                    pHeader->CommitRange += pHeader->PageSize ;
                    pNew->Size = pHeader->PageSize - sizeof( DebugMemory );
                    pNew->pNext = pHeader->pFreeList ;
                    pHeader->pFreeList = pNew ;

                    return DbgpAlloc( pHeader, cSize );
                }
                else 
                {
                    return NULL ;
                }
            }
            return(NULL);
        }

        //
        // Otherwise, split the largest block into something better...
        //

        pNew = (PDebugMemory) ((PUCHAR) pLargest + (cSize + sizeof(DebugMemory)) );

        pNew->Size = pLargest->Size - (cSize + sizeof(DebugMemory) * 2);
        pNew->pNext = pLargest->pNext ;
        pNew->Flags = 0;

        pLargest->Size = cSize;
        pLargest->Flags |= DEBUGMEM_ALLOCATED;
        pLargest->pNext = pNew;

        return((PVOID) (pLargest + 1) );
    }
    else
    {
        pSearch->Flags |= DEBUGMEM_ALLOCATED ;

        return((PVOID) (pSearch + 1) );
    }

    return(NULL);
}

//+---------------------------------------------------------------------------
//
//  Function:   DbgpFree
//
//  Synopsis:   Returns memory to the shared mem segment
//
//  Arguments:  [pHeader] -- Shared memory header
//              [pMemory] -- Memory to free
//
//  History:    3-22-95   RichardW   Created
//
//  Notes:      No compaction.
//
//----------------------------------------------------------------------------
VOID
DbgpFree(
    PDebugHeader    pHeader,
    PVOID           pMemory)
{
    PDebugMemory    pMem;

    pMem = (PDebugMemory) ((PUCHAR) pMemory - sizeof(DebugMemory));
    pMem->Flags &= ~DEBUGMEM_ALLOCATED;
    ZeroMemory( pMemory, pMem->Size );
}

//+---------------------------------------------------------------------------
//
//  Function:   DbgpFindModule
//
//  Synopsis:   Locates a module based on a name
//
//  Arguments:  [pHeader] -- Header to search
//              [pszName] -- module to find
//
//  History:    3-22-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PDebugModule
DbgpFindModule(
    PDebugHeader    pHeader,
    CHAR *          pszName)
{
    PDebugModule    pSearch;

    pSearch = pHeader->pModules;
    while (pSearch)
    {
        if (_strcmpi(pSearch->pModuleName, pszName) == 0)
        {
            return(pSearch);
        }
        pSearch = pSearch->pNext;
    }

    return(NULL);
}


//+---------------------------------------------------------------------------
//
//  Function:   DbgpCopyModule
//
//  Synopsis:   Copies a module into a new module.  Used for the builtins.
//              note, no references to the code module that the builtin lived
//              in is kept.  This way, the module can unload.
//
//  Arguments:  [pHeader] --
//              [pSource] --
//              [ppDest]  --
//
//  Requires:   Header must be locked.
//
//  Returns:    0 for failure, non-zero for success
//
//  History:    7-19-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
DbgpCopyModule(
    PDebugHeader    pHeader,
    PDebugModule    pSource,
    PDebugModule *  ppDest)
{
    PDebugModule    pModule;
    DWORD           i;
    DWORD           cStringSpace;
    PCHAR           pStrings;

    *ppDest = NULL;

    cStringSpace = strlen(pSource->pModuleName) + 1;

    for (i = 0; i < 32 ; i++ )
    {
        if (pSource->TagLevels[i])
        {
            cStringSpace += (strlen(pSource->TagLevels[i]) + 1);
        }
    }

    //
    // Allocate an extra DWORD to store the infolevel.
    //

    pModule = DbgpAlloc(pHeader, sizeof(DebugModule) + sizeof( DWORD ) );
    if (!pModule)
    {
        return(0);
    }

    pStrings = DbgpAlloc(pHeader, cStringSpace);

    if ( !pStrings )
    {
        DbgpFree( pHeader, pModule );

        return 0 ;
    }

    pModule->pModuleName = pStrings;

    cStringSpace = strlen(pSource->pModuleName) + 1;

    strcpy(pModule->pModuleName, pSource->pModuleName);

    pStrings += cStringSpace;

    for (i = 0; i < 32 ; i++ )
    {
        if (pSource->TagLevels[i])
        {
            pModule->TagLevels[i] = pStrings;
            cStringSpace = strlen(pSource->TagLevels[i]) + 1;
            strcpy(pStrings, pSource->TagLevels[i]);
            pStrings += cStringSpace;
        }
        else
        {
            pSource->TagLevels[i] = NULL;
        }
    }

    //
    // Add this in to the global list
    //
    pModule->pNext = pHeader->pModules;
    pHeader->pModules = pModule;

    //
    // Do not increment module count - this is a builtin
    //

    //
    // Copy the rest of the interesting stuff
    //
    pModule->pInfoLevel = (PDWORD) (pModule + 1);
    *pModule->pInfoLevel = *pSource->pInfoLevel;

    pModule->InfoLevel = pSource->InfoLevel;
    pModule->fModule = pSource->fModule | DEBUGMOD_BUILTIN_MODULE ;
    pModule->pHeader = pHeader;
    pModule->TotalOutput = pSource->TotalOutput;
    pModule->Reserved = 0;

    *ppDest = pModule;

    return(1);

}

//+---------------------------------------------------------------------------
//
//  Function:   DbgpAttachBuiltinModules
//
//  Synopsis:   Attaches the builtin library modules to the global shared
//              list
//
//  Arguments:  [pHeader] --
//
//  History:    7-19-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
DbgpAttachBuiltinModules(
    PDebugHeader    pHeader)
{
    PDebugModule    pModule;
    PDebugModule    pFixup;
    DWORD           i;
    BOOL            Success = FALSE;

    i = 0;
    while (DbgpFixupModules[i])
    {
        pFixup = *DbgpFixupModules[i];

        pModule = DbgpFindModule(pHeader, pFixup->pModuleName);
        if (pModule)
        {
            *DbgpFixupModules[i] = pModule;
            Success = TRUE;
        }
        else
        {
            if (DbgpCopyModule(pHeader, pFixup, &pModule))
            {
                *DbgpFixupModules[i] = pModule;
                Success = TRUE;
            }

        }

        i++;
    }

    return(Success);

}

//+---------------------------------------------------------------------------
//
//  Function:   DbgpBuildModule
//
//  Synopsis:   Initializes a Module, builds the string table
//
//  Arguments:  [pModule]    -- Module pointer
//              [pHeader]    -- Header
//              [pKeys]      -- Key table
//              [pszName]    -- Name
//              [pInfoLevel] -- Pointer to info level
//
//  History:    4-03-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
DbgpBuildModule(
    PDebugModule    pModule,
    PDebugHeader    pHeader,
    PDEBUG_KEY      pKeys,
    PCHAR           pszName,
    PDWORD          pInfoLevel)
{
    PCHAR           pStringData;
    DWORD           cStringData;
    DWORD           cKeys;
    DWORD           i;
    DWORD           KeyIndex;
    DWORD           BitScan;


    //
    // Easy stuff to start..
    //

    pModule->pInfoLevel = pInfoLevel;
    pModule->pHeader = pHeader;


    cStringData = strlen(pszName) + 1;

    //
    // Search through the list of masks and string tags, computing
    // the size needed for containing them all.  If a tag has more
    // than one bit set, reject it.
    //
    for (i = 0; i < 32 ; i++ )
    {
        if (pKeys[i].Mask)
        {
            if (pKeys[i].Mask & (pKeys[i].Mask - 1))
            {
                continue;
            }
        }
        if (pKeys[i].Tag)
        {
            cStringData += strlen(pKeys[i].Tag) + 1;
        }
        else
        {
            break;
        }
    }

    //
    // We know how many keys there are, and how big a space they need.
    //
    cKeys = i;

    pStringData = DbgpAlloc(pHeader, cStringData);

    if ( !pStringData )
    {
        return 0 ;
    }

    pModule->pModuleName = pStringData;
    strcpy(pStringData, pszName);
    pStringData += strlen(pStringData) + 1;

    for (i = 0, KeyIndex = 0; i < cKeys ; i++ )
    {
        if (pKeys[i].Mask & (pKeys[i].Mask - 1))
        {
            continue;
        }

        if (!(pKeys[i].Mask & (1 << KeyIndex)))
        {
            //
            // Grr, out of order.  Do a bit-wise scan.
            //

            KeyIndex = 0;
            BitScan = 1;
            while ((pKeys[i].Mask & BitScan) == 0)
            {
                BitScan <<= 1;
                KeyIndex ++;
            }
        }

        pModule->TagLevels[KeyIndex] = pStringData;
        strcpy(pStringData, pKeys[i].Tag);
        pStringData += strlen(pKeys[i].Tag) + 1;

        KeyIndex++;
    }

    return(cKeys);
}


//+---------------------------------------------------------------------------
//
//  Function:   DbgpGetBitmask
//
//  Synopsis:   Based on a parameter line and a key table, builds the bitmask
//
//  Arguments:  [pKeys]          --
//              [cKeys]          --
//              [pszLine]        --
//              [ParameterIndex] --
//              [ParameterValue] --
//
//  History:    4-03-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
DbgpGetBitmask(
    DEBUG_KEY *     pKeys,
    DWORD           cKeys,
    PCHAR           pszLine,
    DWORD           ParameterIndex,
    PCHAR           ParameterValue)
{
    PCHAR   pszSearch;
    PCHAR   pszParam;
    PCHAR   pszScan;
    DWORD   i;
    DWORD   Mask;
    DWORD   cbParameter = 0;
    DWORD   Compare;
    CHAR    Saved;


    if (ParameterIndex < cKeys)
    {
        cbParameter = strlen(pKeys[ParameterIndex].Tag);
    }

    Mask = 0;

    pszSearch = pszLine;

    //
    // Scan through the line, searching for flags.  Note:  do NOT use strtok,
    // since that is not exported by ntdll, and we would not be able to make
    // security.dll
    //

    while (*pszSearch)
    {
        pszScan = pszSearch;
        while ((*pszScan) && (*pszScan != ','))
        {
            pszScan++;
        }
        Saved = *pszScan;
        *pszScan = '\0';

        for (i = 0; i < cKeys ; i++ )
        {
            if (i == ParameterIndex)
            {
                if (_strnicmp(pKeys[i].Tag, pszSearch, cbParameter) == 0)
                {
                    pszParam = strchr(pszSearch, ':');
                    if (pszParam)
                    {
                        strcpy(ParameterValue, pszParam+1);
                    }
                    Mask |= pKeys[i].Mask;
                }

            }
            else
            {
                if (_strcmpi(pKeys[i].Tag, pszSearch) == 0)
                {
                    Mask |= pKeys[i].Mask;
                }

            }
        }

        *pszScan = Saved;
        if (Saved)
        {
            while ((*pszScan) && ((*pszScan == ',') || (*pszScan == ' ')))
            {
                pszScan++;
            }
        }
        pszSearch = pszScan;
    }

    return(Mask);

}


//+---------------------------------------------------------------------------
//
//  Function:   DbgpInitializeDebug
//
//  Synopsis:   Initialize the base memory
//
//  Arguments:  [pHeader] --
//
//  History:    4-03-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
DbgpInitializeDebug(
    PDebugHeader    pHeader)
{
    CHAR    szExeName[MAX_PATH];
    PCHAR   pszExeName;
    PCHAR   dot;
    DWORD   cbExeName;
    CHAR    LogFile[MAX_PATH];
    CHAR    Line[MAX_PATH];
    PDebugModule    pModule;
    HANDLE Token ;
    TOKEN_STATISTICS TokenStat ;
    ULONG Size ;
    LUID LocalSys = SYSTEM_LUID ;


    //
    // Plug the debug section in first
    //

    pModule = DbgpAlloc(pHeader, sizeof(DebugModule));
    if (!pModule)
    {
        return;
    }

    DbgpBuildModule(pModule,
                    pHeader,
                    DbgpKeys,
                    DEBUG_MODULE_NAME,
                    &pHeader->fDebug);

    GetModuleFileNameA(NULL, szExeName, MAX_PATH);
    pszExeName = strrchr(szExeName, '\\');
    if (pszExeName)
    {
        pszExeName++;
    }
    else
    {
        pszExeName = szExeName;
    }

    dot = strrchr(pszExeName, '.');
    if (dot)
    {
        *dot = '\0';
    }

    cbExeName = (DWORD) (dot - pszExeName);
    pHeader->pszExeName = DbgpAlloc(pHeader, cbExeName + 1);
    if (pHeader->pszExeName)
    {
        strcpy(pHeader->pszExeName, pszExeName);
    }

    LogFile[0] = '\0';

    if (GetProfileStringA(  szDebugSection,
                            pszExeName,
                            "",
                            Line,
                            MAX_PATH))
    {
        pHeader->fDebug = DbgpGetBitmask(   DbgpKeys,
                                            DEBUG_NUMBER_OF_KEYS,
                                            Line,
                                            3,
                                            LogFile);

    }

    //
    // If running as local system, turn on the kd flag.  That
    // way,

    if ( OpenProcessToken( GetCurrentProcess(),
                           TOKEN_QUERY,
                           &Token ) )
    {
        if ( GetTokenInformation( Token,
                                  TokenStatistics,
                                  &TokenStat,
                                  sizeof( TokenStat ),
                                  &Size ) )
        {
            if ( (TokenStat.AuthenticationId.LowPart == LocalSys.LowPart ) &&
                 (TokenStat.AuthenticationId.HighPart == LocalSys.HighPart ) )
            {
                pHeader->fDebug |= DEBUG_USE_KDEBUG ;
            }
        }

        CloseHandle( Token );
    }

    if (GetProfileStringA(  szDebugSection,
                            szDebugFlags,
                            "",
                            Line,
                            MAX_PATH))
    {
        pHeader->fDebug |= DbgpGetBitmask(  DbgpKeys,
                                            DEBUG_NUMBER_OF_KEYS,
                                            Line,
                                            3,
                                            LogFile);

    }

    if ( pHeader->fDebug & DEBUG_USE_KDEBUG )
    {
        //
        // Verify that there is a kernel debugger
        //

        SYSTEM_KERNEL_DEBUGGER_INFORMATION KdInfo ;
        NTSTATUS Status ;

        Status = NtQuerySystemInformation(
                    SystemKernelDebuggerInformation,
                    &KdInfo,
                    sizeof( KdInfo ),
                    NULL );

        if ( NT_SUCCESS( Status ) )
        {
            if ( !KdInfo.KernelDebuggerEnabled )
            {
                pHeader->fDebug &= ~(DEBUG_USE_KDEBUG) ;
            }
        }

    }

    if (pHeader->fDebug & DEBUG_LOGFILE)
    {
        if (LogFile[0] == '\0')
        {
            strcpy(LogFile, szExeName);
            strcat(LogFile, ".log");
        }
        pHeader->hLogFile = CreateFileA(LogFile,
                                        GENERIC_READ | GENERIC_WRITE,
                                        FILE_SHARE_READ,
                                        NULL,
                                        CREATE_ALWAYS,
                                        FILE_ATTRIBUTE_NORMAL |
                                        FILE_FLAG_WRITE_THROUGH,
                                        NULL);

    }

    pHeader->pModules = pModule;
    pHeader->pGlobalModule = pModule;
    pModule->pInfoLevel = &pHeader->fDebug;
    pModule->InfoLevel = pHeader->fDebug;

    DbgpAttachBuiltinModules(pHeader);
}

//+---------------------------------------------------------------------------
//
//  Function:   DbgpOpenLogFileRandom
//
//  Synopsis:   Opens the logfile dynamically
//
//  Arguments:  [pHeader] --
//
//  History:    4-27-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
DbgpOpenLogFileRandom(
    PDebugHeader        pHeader)
{
    WCHAR   szLogPath[MAX_PATH];
    DWORD   dwPath;
    PWSTR   pszDot;

    dwPath = GetModuleFileName(NULL, szLogPath, MAX_PATH);
    szLogPath[ MAX_PATH - 1 ] = L'\0';

    pszDot = wcsrchr(szLogPath, L'.');
    if (!pszDot)
    {
        pszDot = &szLogPath[dwPath];
    }

    wcscpy(pszDot, L".log");

    LockDebugHeader(pHeader);

    pHeader->hLogFile = CreateFileW(szLogPath,
                                    GENERIC_READ | GENERIC_WRITE,
                                    FILE_SHARE_READ,
                                    NULL,
                                    CREATE_ALWAYS,
                                    FILE_ATTRIBUTE_NORMAL |
                                    FILE_FLAG_WRITE_THROUGH,
                                    NULL);

    if (pHeader->hLogFile == INVALID_HANDLE_VALUE)
    {
        pHeader->fDebug &= ~(DEBUG_LOGFILE);
        UnlockDebugHeader(pHeader);
        return(FALSE);
    }
    UnlockDebugHeader(pHeader);

    return(TRUE);
}



//+---------------------------------------------------------------------------
//
//  Function:   DbgpOpenOrCreateSharedMem
//
//  Synopsis:   Returns a pointer to the shared memory segment,
//              creating it if necessary.  Header is LOCKED on return
//
//  Arguments:  (none)
//
//  History:    3-22-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PVOID
DbgpOpenOrCreateSharedMem(DWORD Flags)
{
    HANDLE              hMapping;
    WCHAR               szMappingName[32];
    PDebugHeader        pHeader;
    SYSTEM_INFO         SysInfo;

    if (DbgpHeader)
    {
        LockDebugHeader(DbgpHeader);
        return(DbgpHeader);
    }

    GetSystemInfo(&SysInfo);

    DbgpComputeMappingName(szMappingName, sizeof(szMappingName)/sizeof(WCHAR));
    hMapping = OpenFileMapping( FILE_MAP_ALL_ACCESS,
                                FALSE,
                                szMappingName);

    if (hMapping)
    {
        //
        // Ok, someone else has created the section.  So, we just need to map
        // it.
        //

        pHeader = MapViewOfFileEx(  hMapping,
                                    FILE_MAP_READ | FILE_MAP_WRITE,
                                    0,
                                    0,
                                    SysInfo.dwPageSize,
                                    NULL);

        if ( pHeader )
        {
            if (pHeader != pHeader->pvSection)
            {
                DbgpHeader = pHeader->pvSection;
            }
            else
            {
                DbgpHeader = pHeader;
            }
            
            UnmapViewOfFile(pHeader);
        }
        else
        {

            DbgpHeader = NULL ;
        }


        //
        // Now that we have the other guy's address, we can throw away this
        // one.
        //
        CloseHandle(hMapping);

        if ( DbgpHeader )
        {
            LockDebugHeader(DbgpHeader);

            DbgpAttachBuiltinModules(DbgpHeader);
            
        }


        return(DbgpHeader);

    }

    if (Flags & DSYSDBG_OPEN_ONLY)
    {
        return(NULL);
    }


    hMapping = CreateFileMapping(   INVALID_HANDLE_VALUE,
                                    NULL, //&sa,
                                    PAGE_READWRITE | SEC_RESERVE,
                                    0,
                                    SysInfo.dwAllocationGranularity,
                                    szMappingName);
    if (hMapping)
    {
        pHeader = MapViewOfFileEx(hMapping,
                                FILE_MAP_READ | FILE_MAP_WRITE,
                                0,
                                0,
                                SysInfo.dwAllocationGranularity,
                                NULL);

        if (!pHeader)
        {
            return(NULL);
        }

        //
        // Commit the view, so we can initialize the header
        //

        pHeader = (PDebugHeader) VirtualAlloc(  pHeader,
                                                SysInfo.dwPageSize,
                                                MEM_COMMIT,
                                                PAGE_READWRITE);

        pHeader->Tag = DEBUG_TAG;
        pHeader->pvSection = pHeader;
        pHeader->hMapping = hMapping;
        pHeader->hLogFile = INVALID_HANDLE_VALUE;
        pHeader->CommitRange = SysInfo.dwPageSize;
        pHeader->ReserveRange = SysInfo.dwAllocationGranularity;
        pHeader->PageSize = SysInfo.dwPageSize;
        pHeader->pModules = NULL;
        pHeader->pFreeList = NULL;
        pHeader->pBufferList = &pHeader->DefaultBuffer ;
        pHeader->DefaultBuffer.Next = NULL ;

        InitializeCriticalSection(&pHeader->csDebug);

        LockDebugHeader(pHeader);

        DbgpInitializeMM(pHeader);
        DbgpInitializeDebug(pHeader);

        DbgpHeader = pHeader;

        return(pHeader);
    }

    return(NULL);
}

//+---------------------------------------------------------------------------
//
//  Function:   DbgpLoadValidateRoutine
//
//  Synopsis:   Loads RtlValidateProcessHeaps() from ntdll
//
//  Arguments:  [pHeader] --
//
//  History:    5-02-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
DbgpLoadValidateRoutine(PDebugHeader    pHeader)
{
    HMODULE hNtDll;

    hNtDll = LoadLibrary(TEXT("ntdll.dll"));
    if (hNtDll)
    {
        pHeader->pfnValidate = (HEAPVALIDATE) GetProcAddress(hNtDll, "RtlValidateProcessHeaps");
        if (!pHeader->pfnValidate)
        {
            pHeader->fDebug &= ~(DEBUG_HEAP_CHECK);
        }

        //
        // We can safely free this handle, since kernel32 and advapi32 DLLs
        // both use ntdll, so the refcount won't go to zero.
        //
        FreeLibrary(hNtDll);
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   _InitDebug
//
//  Synopsis:   Workhorse of the initializers
//
//  Arguments:  [pInfoLevel]     -- Pointer to module specific infolevel
//              [ppControlBlock] -- Pointer to module specific control pointer
//              [szName]         -- Name
//              [pKeys]          -- Key data
//
//  History:    3-22-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
_InitDebug(
    DWORD       Flags,
    DWORD *     pInfoLevel,
    PVOID *     ppControlBlock,
    CHAR *      szName,
    PDEBUG_KEY  pKeys)
{
    PDebugHeader    pHeader;
    PDebugModule    pModule;
    CHAR            Line[MAX_PATH];
    DWORD           cKeys;
    DWORD           i;

    if ( (*ppControlBlock) && (*ppControlBlock != INVALID_HANDLE_VALUE) )
    {
        //
        // Already Initialized
        //
        return ;
    }

    *ppControlBlock = NULL;

    //
    // Find the shared section.
    //

    pHeader = DbgpOpenOrCreateSharedMem(Flags);

    if (!pHeader)
    {
        if (Flags & DSYSDBG_DEMAND_OPEN)
        {
            *ppControlBlock = (PVOID) INVALID_HANDLE_VALUE;
        }
        return;
    }

    //
    // See if we have already registered (dll being loaded several times)
    // if not, allocate a new module.
    //

    pModule = DbgpFindModule(pHeader, szName);
    if (!pModule)
    {
        pModule = DbgpAlloc(pHeader, sizeof(DebugModule) );
        if (!pModule)
        {
            UnlockDebugHeader(pHeader);
            return;
        }
    }
    else
    {
        //
        // Found module already loaded.  Check to see that everything
        // lines up:
        //

        if ( pModule->pInfoLevel != pInfoLevel )
        {
            //
            // Uh oh, there's a module with our name already loaded,
            // but the pointers don't match.  So, let's create our
            // own now.
            //

            pModule = DbgpAlloc( pHeader, sizeof( DebugModule ) );

            if ( !pModule )
            {
                UnlockDebugHeader( pHeader );
                return;
            }
        }
        else 
        {
            *ppControlBlock = pModule;
            UnlockDebugHeader(pHeader);
            return;

        }

    }


    //
    // Initialize module
    //
    cKeys = DbgpBuildModule(pModule,
                            pHeader,
                            pKeys,
                            szName,
                            pInfoLevel);


    //
    // Now, load up info levels from ini or registry
    // First, try a module specific entry.
    //

    if (GetProfileStringA(szName, szDebugFlags, "", Line, MAX_PATH))
    {
        pModule->InfoLevel = DbgpGetBitmask(pKeys,
                                            cKeys,
                                            Line,
                                            0xFFFFFFFF,
                                            NULL );
    }

    if (pHeader->pszExeName)
    {
        if (GetProfileStringA(szName, pHeader->pszExeName, "", Line, MAX_PATH))
        {
            pModule->InfoLevel = DbgpGetBitmask(pKeys,
                                                cKeys,
                                                Line,
                                                0xFFFFFFFF,
                                                NULL );

        }
    }

    //  HACK - Make Default DBG / DEBUG_SUPPORT dependent.  See dsysdbg.h
    if (GetProfileStringA(szDebugSection, szName, SZ_DEFAULT_PROFILE_STRING, Line, MAX_PATH))
    {
        pModule->InfoLevel |= DbgpGetBitmask(   pKeys,
                                                cKeys,
                                                Line,
                                                0xFFFFFFFF,
                                                NULL );

    }

    *pModule->pInfoLevel = pModule->InfoLevel;

    pModule->pNext = pHeader->pModules;
    pHeader->pModules = pModule;
    pHeader->ModuleCount++ ;
    *ppControlBlock = pModule;

    UnlockDebugHeader(pHeader);
}

VOID
_UnloadDebug(
    PVOID pControlBlock
    )
{
    PDebugHeader    pHeader;
    PDebugModule    pModule;
    PDebugModule    pScan ;
    BOOL FreeIt = FALSE ;

    pModule = (PDebugModule) pControlBlock ;

    if ( !pModule )
    {
        return ;
    }

    if ( pModule->pInfoLevel == NULL )
    {
        return ;
    }

    pHeader = pModule->pHeader ;

    LockDebugHeader( pHeader );

    pScan = pHeader->pModules ;

    if ( pScan == pModule )
    {
        pHeader->pModules = pModule->pNext ;
    }
    else 
    {
        while ( pScan && ( pScan->pNext != pModule ) )
        {
            pScan = pScan->pNext ;
        }

        if ( pScan )
        {
            pScan->pNext = pModule->pNext ;
        }

        pModule->pNext = NULL ;
    }

    DbgpFree( pHeader, pModule->pModuleName );

    DbgpFree( pHeader, pModule );

    pHeader->ModuleCount-- ;

    if ( pHeader->ModuleCount == 0 )
    {
        FreeIt = TRUE ;
    }

    UnlockDebugHeader( pHeader );

    if ( FreeIt )
    {
        if ( pHeader->hLogFile != INVALID_HANDLE_VALUE )
        {
            CloseHandle( pHeader->hLogFile );
        }

        if ( pHeader->hMapping )
        {
            CloseHandle( pHeader->hMapping );
        }

        DeleteCriticalSection( &pHeader->csDebug );

        UnmapViewOfFile( pHeader );

    }
}


//+---------------------------------------------------------------------------
//
//  Function:   DbgpGetTextBuffer
//
//  Synopsis:   Gets a text buffer from the header, allocating if necessary
//
//  Arguments:  [pHeader] --
//
//  History:    3-19-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PDEBUG_TEXT_BUFFER
DbgpGetTextBuffer(
    PDebugHeader pHeader
    )
{
    PDEBUG_TEXT_BUFFER pBuffer ;

    LockDebugHeader( pHeader );

    if ( pHeader->pBufferList )
    {
        pBuffer = pHeader->pBufferList ;

        pHeader->pBufferList = pBuffer->Next ;

    }
    else
    {
        pBuffer = DbgpAlloc( pHeader, sizeof( DEBUG_TEXT_BUFFER ) );
    }

    UnlockDebugHeader( pHeader );

    if ( pBuffer )
    {
        pBuffer->Next = NULL ;
    }

    return pBuffer ;
}

//+---------------------------------------------------------------------------
//
//  Function:   DbgpReleaseTextBuffer
//
//  Synopsis:   Releases a text buffer back to the pool of buffers
//
//  Arguments:  [pHeader] --
//              [pBuffer] --
//
//  History:    3-19-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
DbgpReleaseTextBuffer(
    PDebugHeader pHeader,
    PDEBUG_TEXT_BUFFER pBuffer
    )
{
    LockDebugHeader( pHeader );

    pBuffer->Next = pHeader->pBufferList ;

    pHeader->pBufferList = pBuffer ;

    UnlockDebugHeader( pHeader );
}

//+---------------------------------------------------------------------------
//
//  Function:   _DebugOut
//
//  Synopsis:   Workhorse for the debug out functions
//
//  Arguments:  [pControl] -- Control pointer
//              [Mask]     -- Event mask
//              [Format]   -- format string
//              [ArgList]  -- va_list...
//
//  History:    3-22-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
_DebugOut(
    PVOID       pControl,
    ULONG       Mask,
    CHAR *      Format,
    va_list     ArgList)
{
    PDebugModule pModule;
    int          Level = 0;
    int          PrefixSize = 0;
    int          TotalSize;
    BOOL         fLocked;
    BOOL         fClean;
    PCHAR        Tag;
    BOOL         Break = FALSE ;
    PDEBUG_TEXT_BUFFER pBuffer ;

    pModule = (PDebugModule) pControl;

    if ( pModule == NULL )
    {
        return ;
    }

    if ( pModule->pInfoLevel == NULL )
    {
        return ;
    }

    if (pModule == INVALID_HANDLE_VALUE)
    {
        if (Mask & DSYSDBG_FORCE)
        {
            NOTHING ;
        }
        else
            return;
    }

    if (pModule->fModule & DEBUGMOD_CHANGE_INFOLEVEL)
    {
        *pModule->pInfoLevel = pModule->InfoLevel;
        pModule->fModule &= ~(DEBUGMOD_CHANGE_INFOLEVEL);
    }

    if (pModule->pHeader->pGlobalModule->fModule & DEBUGMOD_CHANGE_INFOLEVEL)
    {
        pModule->pHeader->fDebug = pModule->pHeader->pGlobalModule->InfoLevel;
        pModule->pHeader->pGlobalModule->fModule &= ~(DEBUGMOD_CHANGE_INFOLEVEL);
    }

    pModule->InfoLevel = *pModule->pInfoLevel;

    if (pModule->pHeader->fDebug & DEBUG_MULTI_THREAD)
    {
        LockDebugHeader(pModule->pHeader);
        fLocked = TRUE;
    }
    else
        fLocked = FALSE;


    if (pModule->pHeader->fDebug & DEBUG_HEAP_CHECK)
    {
        if (!pModule->pHeader->pfnValidate)
        {
            DbgpLoadValidateRoutine(pModule->pHeader);
        }
        if (pModule->pHeader->pfnValidate)
        {
            pModule->pHeader->pfnValidate();
        }
    }

    fClean = ((Mask & DSYSDBG_CLEAN) != 0);

    if ( ( Mask & DEB_ERROR ) &&
         ( pModule->pHeader->fDebug & DEBUG_BREAK_ON_ERROR ) )
    {
        Break = TRUE ;
    }

    pBuffer = DbgpGetTextBuffer( pModule->pHeader );

    if ( !pBuffer )
    {
        OutputDebugStringA( "_DebugOut : Out of memory\n" );
        if ( fLocked )
        {
            UnlockDebugHeader( pModule->pHeader );
            
        }
        return;
    }

    if (Mask & (pModule->InfoLevel | DSYSDBG_FORCE))
    {

        if (Mask & DSYSDBG_FORCE)
        {
            Tag = "FORCE";
        }
        else
        {
            while (!(Mask & 1))
            {
                Level++;
                Mask >>= 1;
            }
            Tag = pModule->TagLevels[Level];
        }


        //
        // Make the prefix first:  "Process.Thread> Module-Tag:
        //

        if (!fClean)
        {
            if (pModule->pHeader->fDebug & DEBUG_TIMESTAMP)
            {
                SYSTEMTIME  stTime;

                GetLocalTime(&stTime);

                PrefixSize = sprintf(pBuffer->TextBuffer,
                        "[%2d/%2d %02d:%02d:%02d] %d.%d> %s-%s: ",
                        stTime.wMonth, stTime.wDay,
                        stTime.wHour, stTime.wMinute, stTime.wSecond,
                        GetCurrentProcessId(),
                        GetCurrentThreadId(), pModule->pModuleName,
                        Tag);

            }
            else

            {

                PrefixSize = sprintf(pBuffer->TextBuffer, "%d.%d> %s-%s: ",
                        GetCurrentProcessId(), GetCurrentThreadId(),
                        pModule->pModuleName, Tag);

            }
        }

        if ((TotalSize = _vsnprintf(&pBuffer->TextBuffer[PrefixSize],
                                    DEBUG_TEXT_BUFFER_SIZE - PrefixSize,
                                    Format, ArgList)) < 0)
        {
            //
            // Less than zero indicates that the string could not be
            // fitted into the buffer.  Output a special message indicating
            // that:
            //

            OutputDebugStringA("dsysdbg:  Could not pack string into 512 bytes\n");
        }
        else
        {
            TotalSize += PrefixSize;

            if ((pModule->pHeader->fDebug & DEBUG_NO_DEBUGIO) == 0 )
            {
                OutputDebugStringA( pBuffer->TextBuffer );
            }

            if ((pModule->pHeader->fDebug & DEBUG_LOGFILE))
            {
                if (pModule->pHeader->hLogFile == INVALID_HANDLE_VALUE)
                {
                    DbgpOpenLogFileRandom(pModule->pHeader);
                }

                WriteFile(  pModule->pHeader->hLogFile,
                            pBuffer->TextBuffer,
                            (DWORD) TotalSize,
                            (PDWORD) &PrefixSize,
                            NULL );
            }

            pModule->pHeader->TotalWritten += TotalSize;
            pModule->TotalOutput += TotalSize;
        }

    }
    if (fLocked)
    {
        UnlockDebugHeader(pModule->pHeader);
    }

    DbgpReleaseTextBuffer( pModule->pHeader, pBuffer );

    if ( Break )
    {
        OutputDebugStringA( "BreakOnError\n" );
        DebugBreak();
    }
}

VOID
_DbgSetOption(
    PVOID   pControl,
    DWORD   Option,
    BOOL    On,
    BOOL    Global
    )
{
    PDebugModule pModule;

    pModule = (PDebugModule) pControl ;

    if ( pModule )
    {
        if ( Global )
        {
            pModule = pModule->pHeader->pGlobalModule ;
        }

        if ( On )
        {
            pModule->InfoLevel |= Option ;
            *pModule->pInfoLevel |= Option ;
        }
        else
        {
            pModule->InfoLevel &= (~Option) ;
            *pModule->pInfoLevel &= (~Option) ;
        }
    }
}

VOID
_DbgSetLoggingOption(
    PVOID   pControl,
    BOOL    On
    )
{
    PDebugModule pModule;

    pModule = (PDebugModule)pControl;

    if ( pModule )
    {   
       if (((pModule->pHeader->fDebug & DEBUG_LOGFILE) == 0) && On )// off, turn it on
       {                                            
          pModule->pHeader->fDebug |= DEBUG_LOGFILE;
       } 
       else if ((pModule->pHeader->fDebug & DEBUG_LOGFILE) && !On) // on, turn it off
       {
          pModule->pHeader->fDebug &= (~DEBUG_LOGFILE);
          if ( pModule->pHeader->hLogFile != INVALID_HANDLE_VALUE )
          {
             CloseHandle( pModule->pHeader->hLogFile );
             pModule->pHeader->hLogFile = INVALID_HANDLE_VALUE;
          }
       }                                               
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\debuglib\debuglib.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       debuglib.h
//
//  Contents:   DebugLib includes
//
//  Classes:
//
//  Functions:
//
//  History:    3-28-95   RichardW   Created
//
//----------------------------------------------------------------------------

#define WIN32_NO_STATUS
#include <winsock2.h>
#include <winternl.h>
#undef WIN32_NO_STATUS
#include <windows.h>
#include <ntstatus.h>
typedef NTSTATUS * PNTSTATUS;
#define _NTDEF_
#include <ntsecapi.h>
#undef _NTDEF_
#include <subauth.h>
#include <wincrypt.h>

#include <string.h>
#include <wchar.h>
#include <stdio.h>
#include <align.h>
//#include <alloca.h>
#include <malloc.h>

#include <dsysdbg.h>

#include <debugp.h>

#include "general_stubs.h"
#include "dbglibp.h"

#include <assert.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\debuglib\compat.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       compat.c
//
//  Contents:   Compatibility routines for old callers
//
//  Classes:
//
//  Functions:
//
//  History:    3-14-95   RichardW   Created
//
//----------------------------------------------------------------------------

#include "debuglib.h"
#include <debnot.h>

DWORD           __CompatInfoLevel = 3;
DebugModule     __CompatGlobal = {NULL, NULL, 0, 0, &__CompatHeader};
DebugHeader     __CompatHeader = {DEBUG_TAG, NULL, INVALID_HANDLE_VALUE,
                                    INVALID_HANDLE_VALUE, 0, &__CompatGlobal};
DebugModule     __CompatModule = {NULL, &__CompatInfoLevel, 0, 3,
                                    &__CompatHeader, 0, 0, "Compat",
                                    {"Error", "Warning", "Trace", "",
                                     "IError", "IWarning", "ITrace", "",
                                     "", "", "", "", "", "", "", "",
                                     "", "", "", "", "", "", "", "",
                                     "", "", "", "", "", "", "", "" }
                                    };
DebugModule *   __pCompatModule = &__CompatModule;


void
vdprintf(
    unsigned long ulCompMask,
    char const *pszComp,
    char const *ppszfmt,
    va_list  ArgList)
{
    __CompatModule.pModuleName = (char *) pszComp;
    if (DbgpHeader)
    {
        __CompatModule.pHeader = DbgpHeader;
    }
    _DebugOut(__pCompatModule, ulCompMask, (char *) ppszfmt, ArgList);
}


void
Win4AssertEx(
    char const * szFile,
    int iLine,
    char const * szMessage)
{
    CHAR    szDebug[MAX_PATH];

    if (szMessage)
    {
        _snprintf(szDebug, MAX_PATH, "%d.%d> ASSERTION FAILED: %s, %s:%d\n",
                    GetCurrentProcessId(), GetCurrentThreadId(),
                    szMessage, szFile, iLine);
    }
    else
    {
        _snprintf(szDebug, MAX_PATH, "%d.%d> ASSERTION FAILED %s:%d\n",
                    GetCurrentProcessId(), GetCurrentThreadId(),
                    szFile, iLine);
    }

    OutputDebugStringA(szDebug);

    DebugBreak();

}


//+------------------------------------------------------------
// Function:    SetWin4InfoLevel(unsigned long ulNewLevel)
//
// Synopsis:    Sets the global info level for debugging output
// Returns:     Old info level
//
//-------------------------------------------------------------

unsigned long
SetWin4InfoLevel(
    unsigned long ulNewLevel)
{

    return(ulNewLevel);
}


//+------------------------------------------------------------
// Function:    _SetWin4InfoMask(unsigned long ulNewMask)
//
// Synopsis:    Sets the global info mask for debugging output
// Returns:     Old info mask
//
//-------------------------------------------------------------

unsigned long
SetWin4InfoMask(
    unsigned long ulNewMask)
{
    return(ulNewMask);
}


//+------------------------------------------------------------
// Function:    _SetWin4AssertLevel(unsigned long ulNewLevel)
//
// Synopsis:    Sets the global assert level for debugging output
// Returns:     Old assert level
//
//-------------------------------------------------------------

typedef unsigned long (APINOT * SetWin4AssertLevelFn)( unsigned long ulNewLevel );

unsigned long
SetWin4AssertLevel(
    unsigned long ulNewLevel)
{
    SetWin4AssertLevelFn OleSetWin4AssertLevel;
    HMODULE Module;

    Module = GetModuleHandle(L"ole32.dll");


    if (Module != NULL)
    {
        OleSetWin4AssertLevel = (SetWin4AssertLevelFn) GetProcAddress(Module, "SetWin4AssertLevel");
        if (OleSetWin4AssertLevel != NULL)
        {
            OleSetWin4AssertLevel(ulNewLevel);
        }
    }

    return(ulNewLevel);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\debuglib\except.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       except.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    6-19-95   RichardW   Created
//
//----------------------------------------------------------------------------

#include "debuglib.h"

#define DEB_TRACE           0x00000004
#define DSYS_EXCEPT_BREAK   0x00000008

DWORD           __ExceptionsInfoLevel = 0x1;
DebugModule     __ExceptionsModule = {NULL, &__ExceptionsInfoLevel, 0, 7,
                                    NULL, 0, 0, "Exceptions",
                                    {"Error", "Warning", "Trace", "Break",
                                     "", "", "", "",
                                     "", "", "", "", "", "", "", "",
                                     "", "", "", "", "", "", "", "",
                                     "", "", "", "", "", "", "", "" }
                                    };

DebugModule *   __pExceptionModule = &__ExceptionsModule;

#define DebugOut(x) __ExceptionsDebugOut x

typedef struct _ExName {
    LONG    ExceptionCode;
    PSTR    Name;
} ExName, * PExName;

ExName  __ExceptNames[] = { {EXCEPTION_ACCESS_VIOLATION,    "Access Violation"},
                            {EXCEPTION_ARRAY_BOUNDS_EXCEEDED, "Bounds Exceeded"},
                            {EXCEPTION_BREAKPOINT,          "Break Point"},
                            {EXCEPTION_DATATYPE_MISALIGNMENT, "Alignment (Data)"},
                            {EXCEPTION_FLT_DENORMAL_OPERAND, "(Float) Denormal Operand"},
                            {EXCEPTION_FLT_DIVIDE_BY_ZERO,  "(Float) Divide By Zero"},
                            {EXCEPTION_FLT_INEXACT_RESULT,  "(Float) Inexact Result"},
                            {EXCEPTION_FLT_INVALID_OPERATION, "(Float) Invalid Op"},
                            {EXCEPTION_FLT_OVERFLOW, "(Float) Overflow"},
                            {EXCEPTION_FLT_STACK_CHECK, "(Float) Stack Check"},
                            {EXCEPTION_FLT_UNDERFLOW, "(Float) Underflow"},
                            {EXCEPTION_ILLEGAL_INSTRUCTION, "Illegal Instruction"},
                            {EXCEPTION_IN_PAGE_ERROR, "In Page Error"},
                            {EXCEPTION_INT_DIVIDE_BY_ZERO, "Divide By Zero"},
                            {EXCEPTION_INT_OVERFLOW, "Overflow"},
                            {EXCEPTION_INVALID_DISPOSITION, "Illegal Disposition"},
                            {EXCEPTION_NONCONTINUABLE_EXCEPTION, "Can't Continue"},
                            {EXCEPTION_PRIV_INSTRUCTION, "Privileged Instruction"},
                            {EXCEPTION_SINGLE_STEP, "Single Step"},
                            {EXCEPTION_STACK_OVERFLOW, "Stack OverFlow"},
                            {0xC0000194, "Deadlock"},

                           };

VOID
__ExceptionsDebugOut(
    ULONG Mask,
    CHAR * Format,
    ... )
{
    va_list ArgList;
    va_start(ArgList, Format);
    _DebugOut( __pExceptionModule, Mask, Format, ArgList);
}

BOOL
DbgpDumpExceptionRecord(
    PEXCEPTION_RECORD   pExceptRecord)
{
    PSTR    pszExcept;
    BOOL    StopOnException;
    DWORD   i;
    ULONG   InfoLevel = NT_SUCCESS(pExceptRecord->ExceptionCode) ? DEB_TRACE : DEB_ERROR;

    StopOnException = FALSE;
    pszExcept = NULL;
    for (i = 0; i < sizeof(__ExceptNames) / sizeof(ExName) ; i++ )
    {
        if (pExceptRecord->ExceptionCode == __ExceptNames[i].ExceptionCode)
        {
            pszExcept = __ExceptNames[i].Name;
            break;
        }
    }

    if (pszExcept)
    {
        DebugOut((InfoLevel, "Exception %#x (%s)\n",
                        pExceptRecord->ExceptionCode, pszExcept));
    }
    else
        DebugOut((InfoLevel, "Exception %#x\n", pExceptRecord->ExceptionCode));

    DebugOut((InfoLevel, "   %s\n",
                pExceptRecord->ExceptionFlags & EXCEPTION_NONCONTINUABLE ?
                "Non-Continuable" : "Continuable"));
    DebugOut((InfoLevel, "   Address    %#x\n", pExceptRecord->ExceptionAddress));
    switch (pExceptRecord->ExceptionCode)
    {
        case EXCEPTION_ACCESS_VIOLATION:
        case EXCEPTION_DATATYPE_MISALIGNMENT:
            DebugOut((InfoLevel, "   %s at address %#x\n",
                pExceptRecord->ExceptionInformation[0] ? "Write" : "Read",
                pExceptRecord->ExceptionInformation[1] ));
            StopOnException = TRUE;
            break;

        case STATUS_POSSIBLE_DEADLOCK:
            DebugOut((InfoLevel, "  Resource at %#x\n",
                pExceptRecord->ExceptionInformation[0] ));
            StopOnException = TRUE;
            break;

        default:
            // StopOnException = TRUE;
            DebugOut((InfoLevel, "  %d Parameters\n", pExceptRecord->NumberParameters));
            for (i = 0; i < pExceptRecord->NumberParameters ; i++ )
            {
                DebugOut((InfoLevel, "    [%d] %#x\n", i,
                    pExceptRecord->ExceptionInformation[i] ));
            }
            break;
    }

    return(StopOnException);
}

VOID
DbgpDumpContextRecord(
    PCONTEXT    pContext,
    BOOL        StopOnException)
{
    ULONG InfoLevel = StopOnException ? DEB_ERROR : DEB_TRACE;
#ifdef _MIPS_
    DebugOut((InfoLevel, "MIPS Context Record at %x\n", pContext));
    if (pContext->ContextFlags & CONTEXT_INTEGER)
    {
        DebugOut((InfoLevel, "at=%08x v0=%08x v1=%08x a0=%08x\n",
            pContext->IntAt, pContext->IntV0, pContext->IntV1, pContext->IntA0));
        DebugOut((InfoLevel, "a1=%08x a2=%08x a3=%08x t0=%08x\n",
            pContext->IntA1, pContext->IntA2, pContext->IntA3, pContext->IntT0));
        DebugOut((InfoLevel, "t1=%08x t2=%08x t3=%08x t4=%08x\n",
            pContext->IntT1, pContext->IntT2, pContext->IntT3, pContext->IntT4));
        DebugOut((InfoLevel, "t5=%08x t6=%08x t7=%08x s0=%08x\n",
            pContext->IntT5, pContext->IntT6, pContext->IntT7, pContext->IntS0));
        DebugOut((InfoLevel, "s1=%08x s2=%08x s3=%08x s4=%08x\n",
            pContext->IntS1, pContext->IntS2, pContext->IntS3, pContext->IntS4));
        DebugOut((InfoLevel, "s5=%08x s6=%08x s7=%08x t8=%08x\n",
            pContext->IntS5, pContext->IntS6, pContext->IntS7, pContext->IntT8));
        DebugOut((InfoLevel, "t9=%08x s8=%08x hi=%08x lo=%08x\n",
            pContext->IntT9, pContext->IntS8, pContext->IntLo, pContext->IntHi));
        DebugOut((InfoLevel, "k0=%08x k1=%08x gp=%08x sp=%08x\n",
            pContext->IntK0, pContext->IntK1, pContext->IntGp, pContext->IntSp));
        DebugOut((InfoLevel, "ra=%08x\n",
            pContext->IntRa));

    }
    if (pContext->ContextFlags & CONTEXT_CONTROL)
    {
        DebugOut((InfoLevel, "Fir=%08x Psr=%08x\n", pContext->Fir,
            pContext->Psr));
    }

#elif _X86_
    DebugOut((InfoLevel, "x86 Context Record at %x\n", pContext));
    if (pContext->ContextFlags & CONTEXT_DEBUG_REGISTERS)
    {
        DebugOut((InfoLevel, "Dr0=%08x Dr1=%08x Dr2=%08x Dr3=%08x \n",
                    pContext->Dr0, pContext->Dr1, pContext->Dr2, pContext->Dr3));
        DebugOut((InfoLevel, "Dr6=%08x Dr7=%08x\n",
                    pContext->Dr6, pContext->Dr7));
    }
    if (pContext->ContextFlags & CONTEXT_SEGMENTS)
    {
        DebugOut((InfoLevel, "gs=%08x fs=%08x es=%08x ds=%08x\n",
                    pContext->SegGs, pContext->SegFs, pContext->SegEs,
                    pContext->SegDs));
    }
    if (pContext->ContextFlags & CONTEXT_INTEGER)
    {
        DebugOut((InfoLevel, "edi=%08x esi=%08x ebx=%08x\n",
                pContext->Edi, pContext->Esi, pContext->Ebx));
        DebugOut((InfoLevel, "edx=%08x ecx=%08x eax=%08x\n",
                pContext->Edx, pContext->Ecx, pContext->Eax));
    }
    if (pContext->ContextFlags & CONTEXT_CONTROL)
    {
        DebugOut((InfoLevel, "ebp=%08x eip=%08x cs=%08x\n",
                pContext->Ebp, pContext->Eip, pContext->SegCs));
        DebugOut((InfoLevel, "flags=%08x esp=%08x ss=%08x\n",
                pContext->EFlags, pContext->Esp, pContext->SegSs));
    }

#elif _ALPHA_
    DebugOut((InfoLevel, "ALPHA Context Record at %x\n", pContext));

#elif _PPC_
    DebugOut((InfoLevel, "PPC Context Record at %x\n", pContext));

#else
    DebugOut((InfoLevel, "Unknown Context Record, %x\n", pContext));

#endif

}

VOID
DbgpDumpException(
    PEXCEPTION_POINTERS pExceptInfo)
{
    BOOL StopOnException;

    StopOnException = DbgpDumpExceptionRecord(pExceptInfo->ExceptionRecord);
    DbgpDumpContextRecord( pExceptInfo->ContextRecord, StopOnException );

    if (StopOnException &&
        ((__ExceptionsInfoLevel & DSYS_EXCEPT_BREAK) != 0))
    {
        DsysAssertMsgEx(FALSE, "Skip Exceptions", DSYSDBG_ASSERT_DEBUGGER);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\debuglib\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_dsysdbg_none_12.4.56.0_none_91f1274d164f1a16
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_dsysdbg_no-public-key_12.4.56.0_x-ww_a7bd0f76
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=dsysdbg
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_dsysdbg_no-public-key_12.4.56.0_x-ww_a7bd0f76
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_dsysdbg_no-public-key_12.4.56.0_x-ww_a7bd0f76.manifest
XP_MANIFEST_PATH=manifests\x86_dsysdbg_no-public-key_12.4.56.0_x-ww_a7bd0f76.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_dsysdbg_no-public-key_12.4.56.0_x-ww_a7bd0f76.cat
XP_CATALOG_PATH=manifests\x86_dsysdbg_no-public-key_12.4.56.0_x-ww_a7bd0f76.cat
XP_PAYLOAD_PATH=x86_dsysdbg_no-public-key_12.4.56.0_x-ww_a7bd0f76
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=dsysdbg,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\debuglib\inc\debugp.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       debugp.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    3-21-95   RichardW   Created
//
//----------------------------------------------------------------------------

#ifndef __DEBUGP_H__
#define __DEBUGP_H__

#define DEBUGMOD_CHANGE_INFOLEVEL   0x00000001
#define DEBUGMOD_BUILTIN_MODULE     0x00000002

struct _DebugHeader;

typedef struct _DebugModule {
    struct _DebugModule *   pNext;
    DWORD *                 pInfoLevel;
    DWORD                   fModule;
    DWORD                   InfoLevel;
    struct _DebugHeader *   pHeader;
    DWORD                   TotalOutput;
    DWORD                   Reserved;
    PCHAR                   pModuleName;      
    PCHAR                   TagLevels[32];
} DebugModule, * PDebugModule;


#define DEBUG_TAG   'gubD'

#define DEBUG_NO_DEBUGIO    0x00000001      // Do not use OutputDebugString
#define DEBUG_TIMESTAMP     0x00000002      // Stamp date/time
#define DEBUG_DEBUGGER_OK   0x00000004      // We're running in a debugger
#define DEBUG_LOGFILE       0x00000008      // Send to log file
#define DEBUG_AUTO_DEBUG    0x00000010      // Start up in debugger
#define DEBUG_USE_KDEBUG    0x00000020      // Use KD
#define DEBUG_DISABLE_ASRT  0x00000100      // Disable asserts
#define DEBUG_PROMPTS       0x00000200      // No prompts for asserts

#define DEBUG_MODULE_NAME   "DsysDebug"

typedef BOOLEAN (NTAPI * HEAPVALIDATE)(VOID);

#define DEBUG_TEXT_BUFFER_SIZE  (512 - sizeof( PVOID ))

typedef struct _DEBUG_TEXT_BUFFER {
    struct _DEBUG_TEXT_BUFFER * Next ;
    CHAR TextBuffer[ DEBUG_TEXT_BUFFER_SIZE ];
} DEBUG_TEXT_BUFFER, * PDEBUG_TEXT_BUFFER ;

typedef struct _DebugHeader {
    DWORD               Tag;            // Check tag
    DWORD               fDebug;         // Global Flags
    PVOID               pvSection;      // Base address of section
    HANDLE              hMapping;       // Mapping handle
    HANDLE              hLogFile;       // Log file handle
    PDebugModule        pGlobalModule;  // Global Flags module
    PDebugModule        pModules;       // List of modules
    HEAPVALIDATE        pfnValidate;    // Heap Validator
    PVOID               pFreeList;      // Free list for allocator
    PCHAR               pszExeName;     // Exe Name
    PDEBUG_TEXT_BUFFER  pBufferList ;   // List of debug string buffers
    CRITICAL_SECTION    csDebug;        // Critical section
    DWORD               CommitRange;    // Range of memory committed
    DWORD               ReserveRange;   // Range of memory reserved
    DWORD               PageSize;       // Page size;
    DWORD               TotalWritten;   // Total Output of debug stuff
    DWORD               ModuleCount ;   // Module Count (not including builtins)
    DEBUG_TEXT_BUFFER   DefaultBuffer ; // One default buffer
} DebugHeader, * PDebugHeader;






#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\debuglib\test.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       test.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    3-21-95   RichardW   Created
//
//----------------------------------------------------------------------------

#include "debuglib.h"


DECLARE_DEBUG2(Test);
DECLARE_DEBUG2(Test2);

DEFINE_DEBUG2(Test);
DEFINE_DEBUG2(Test2);

PVOID
DbgpAlloc(
    PDebugHeader    pHeader,
    DWORD           cSize);

VOID
DbgpFree(
    PDebugHeader    pHeader,
    PVOID           pMemory);


DEBUG_KEY   MyKeys[] = { {  1, "Error" },
                         {  2, "Warning" },
                         {  4, "Trace" },
                         {  8, "Yikes" },
                         {  0, NULL }
                       };

int
ExceptionFilter(
    LPEXCEPTION_POINTERS    p)
{
    DsysException(p);
    return(EXCEPTION_EXECUTE_HANDLER);
}

__cdecl main (int argc, char *argv[])
{
    char wait[40];
    PUCHAR  p;
    CHAR c;
    DWORD ChunkSize = 1024 ;
    PUCHAR Mem[ 16 ];
    ULONG i ;
    PDebugModule Alloc ;


    TestInitDebug(MyKeys);

    p = NULL;

    TestDebugPrint(1, "This is an error %d\n", 10);
    TestDebugPrint(2, "This is a warning!\n");

    Test2InitDebug(MyKeys);

    Test2DebugPrint(4, "Should be a trace\n");

    printf("Waiting...");
    gets(wait);

    try
    {
        c = *p;
    }
    except (ExceptionFilter(GetExceptionInformation()))
    {
        TestDebugPrint(1, "That AV'd\n");
    }

    DsysAssert(p);

    printf("Waiting...");
    gets(wait);

    Test2DebugPrint(8, "This is a yikes!\n");

    DsysAssertMsg(argc == 1, "Test Assertion");

    Test2DebugPrint(4, "yada yada\n");

    //
    // Load and unload:
    //

    Test2UnloadDebug();
    TestUnloadDebug();

    Test2InitDebug( MyKeys );
    Test2DebugPrint( 1, "Reload test2\n");
    TestInitDebug( MyKeys );
    TestDebugPrint( 1, "Reload test\n");

    Test2UnloadDebug();
    TestUnloadDebug();
    Test2DebugPrint(1, "Safe test\n" );
    Test2InitDebug( MyKeys );
    Test2DebugPrint(1, "Prints now\n" );


    //
    // Allocation tests:
    //

    Alloc = (PDebugModule) Test2ControlBlock ;

    for ( i = 0 ; i < 16 ; i++ )
    {
        Mem[ i ] = DbgpAlloc( Alloc->pHeader, ChunkSize );

    }

    for ( i = 0 ; i < 16 ; i++ )
    {
        DbgpFree( Alloc->pHeader, Mem[ i ] );
    }

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\iislib\iislibp.h ===
#pragma once

#undef UNICODE
#undef _UNICODE

#include <windows.h>
#include <pudebug.h>
#include <reftrace.h>
#include <stktrace.h>
#include <tracelog.h>
#include <stdio.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\debuglib\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_dsysdbg_none_12.4.56.0_none_91f1274d164f1a16
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_dsysdbg_no-public-key_12.4.56.0_x-ww_a7bd0f76
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=dsysdbg
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_dsysdbg_no-public-key_12.4.56.0_x-ww_a7bd0f76
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_dsysdbg_no-public-key_12.4.56.0_x-ww_a7bd0f76.manifest
XP_MANIFEST_PATH=manifests\x86_dsysdbg_no-public-key_12.4.56.0_x-ww_a7bd0f76.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_dsysdbg_no-public-key_12.4.56.0_x-ww_a7bd0f76.cat
XP_CATALOG_PATH=manifests\x86_dsysdbg_no-public-key_12.4.56.0_x-ww_a7bd0f76.cat
XP_PAYLOAD_PATH=x86_dsysdbg_no-public-key_12.4.56.0_x-ww_a7bd0f76
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=dsysdbg,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\iislib\stktrace.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    stktrace.c

Abstract:

    Implements IISCaptureStackBackTrace().

Author:

    Keith Moore (keithmo)        30-Apr-1997

Revision History:

--*/

#include "iislibp.h"


typedef
USHORT
(NTAPI * PFN_RTL_CAPTURE_STACK_BACK_TRACE)(
    IN ULONG FramesToSkip,
    IN ULONG FramesToCapture,
    OUT PVOID *BackTrace,
    OUT PULONG BackTraceHash
    );

PFN_RTL_CAPTURE_STACK_BACK_TRACE g_pfnRtlCaptureStackBackTrace = NULL;



USHORT
NTAPI
DummyCaptureStackBackTrace(
    IN ULONG FramesToSkip,
    IN ULONG FramesToCapture,
    OUT PVOID *BackTrace,
    OUT PULONG BackTraceHash
    )
/*++

Routine Description:

    Dummy implementation of RtlCaptureStackBackTrace() for Win9x.

Arguments:

    See IISCaptureStackBackTrace() below.

Return Value:

    USHORT - Always 0.

--*/
{

    return 0;

}   // DummyRtlCaptureStackBackTrace


USHORT
NTAPI
IISCaptureStackBackTrace(
    IN ULONG FramesToSkip,
    IN ULONG FramesToCapture,
    OUT PVOID *BackTrace,
    OUT PULONG BackTraceHash
    )
/*++

Routine Description:

    Wrapper around RtlCaptureStackBackTrace(). Attempts to capture the
    stack backtrace leading up to the current instruction counter.
    Doesn't work very well on RISC platforms, and is often confused on
    X86 when FPO is enabled.

Arguments:

    FramesToSkip - The number of stack frames to skip before capturing.

    FramesToCapture - The number of stack frames to capture.

    BackTrace - Receives the captured frames.

    BackTraceHash - Some kind of hash thingie.

Return Value:

    USHORT - The number of frames captured.

--*/
{

    //
    // Initialize if necessary.
    //

    if( g_pfnRtlCaptureStackBackTrace == NULL ) {

        HMODULE mod;
        PFN_RTL_CAPTURE_STACK_BACK_TRACE proc = NULL;

        //
        // Note that it is perfectly safe to use GetModuleHandle() here
        // rather than LoadLibrary(), for the following reasons:
        //
        //     1. Under NT, NTDLL.DLL is a "well known" DLL that *never*
        //        gets detached from the process. It's very special.
        //
        //     2. Under Win95, NTDLL.DLL doesn't export the
        //        RtlCaptureStackBackTrace() function, so we will not be
        //        referencing any routines within the DLL.
        //
        // Also note that we retrieve the function pointer into a local
        // variable, not directly into the global. This prevents a nasty
        // race condition that can occur when two threads try to
        // initialize g_pfnRtlCaptureStackBackTrace simultaneously.
        //

        mod = GetModuleHandle( "ntdll.dll" );

        if( mod != NULL ) {
            proc = (PFN_RTL_CAPTURE_STACK_BACK_TRACE)
                GetProcAddress( mod, "RtlCaptureStackBackTrace" );
        }

        if( proc == NULL ) {
            g_pfnRtlCaptureStackBackTrace = &DummyCaptureStackBackTrace;
        } else {
            g_pfnRtlCaptureStackBackTrace = proc;
        }

    }

    return (g_pfnRtlCaptureStackBackTrace)(
               FramesToSkip,
               FramesToCapture,
               BackTrace,
               BackTraceHash
               );

}   // IISCaptureStackBackTrace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\iislib\reftrace.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    reftrace.c

Abstract:

    This module implements a reference count tracing facility.

Author:

    Keith Moore (keithmo)        01-May-1997

Revision History:

--*/

#include "iislibp.h"



PTRACE_LOG
CreateRefTraceLog(
    IN LONG LogSize,
    IN LONG ExtraBytesInHeader
    )
/*++

Routine Description:

    Creates a new (empty) ref count trace log buffer.

Arguments:

    LogSize - The number of entries in the log.

    ExtraBytesInHeader - The number of extra bytes to include in the
        log header. This is useful for adding application-specific
        data to the log.

Return Value:

    PTRACE_LOG - Pointer to the newly created log if successful,
        NULL otherwise.

--*/
{

    return CreateTraceLog(
               LogSize,
               ExtraBytesInHeader,
               sizeof(REF_TRACE_LOG_ENTRY)
               );

}   // CreateRefTraceLog


VOID
DestroyRefTraceLog(
    IN PTRACE_LOG Log
    )
/*++

Routine Description:

    Destroys a ref count trace log buffer created with CreateRefTraceLog().

Arguments:

    Log - The ref count trace log buffer to destroy.

Return Value:

    None.

--*/
{

    DestroyTraceLog( Log );

}   // DestroyRefTraceLog


//
// N.B. For PuDbgCaptureContext() to work properly, the calling function
// *must* be __cdecl, and must have a "normal" stack frame. So, we decorate
// PuDbgAssertFailed() with the __cdecl modifier and disable the frame pointer
// omission (FPO) optimization.
//

#pragma optimize( "y", off )    // disable frame pointer omission (FPO)

VOID
WriteRefTraceLog(
    IN PTRACE_LOG Log,
    IN LONG NewRefCount,
    IN PVOID Context
    )
/*++

Routine Description:

    Writes a new entry to the specified ref count trace log. The entry
    written contains the updated reference count and a stack backtrace
    leading up to the current caller.

Arguments:

    Log - The log to write to.

    NewRefCount - The updated reference count.

    Context - An uninterpreted context to associate with the log entry.

Return Value:

    None.

--*/
{

    WriteRefTraceLogEx(
        Log,
        NewRefCount,
        Context,
        (PVOID) -1, // suppress use of optional extra contexts
        (PVOID) -1,
        (PVOID) -1
        );

}   // WriteRefTraceLog




VOID
WriteRefTraceLogEx(
    IN PTRACE_LOG Log,
    IN LONG NewRefCount,
    IN PVOID Context,
    IN PVOID Context1, // optional extra context
    IN PVOID Context2, // optional extra context
    IN PVOID Context3  // optional extra context
    )
/*++

Routine Description:

    Writes a new "extended" entry to the specified ref count trace log.
    The entry written contains the updated reference count, stack backtrace
    leading up to the current caller and extra context information.

Arguments:

    Log - The log to write to.

    NewRefCount - The updated reference count.

    Context  - An uninterpreted context to associate with the log entry.
    Context1 - An uninterpreted context to associate with the log entry.
    Context2 - An uninterpreted context to associate with the log entry.
    Context3 - An uninterpreted context to associate with the log entry.

    NOTE Context1/2/3 are "optional" in that the caller may suppress
    debug display of these values by passing -1 for each of them.

Return Value:

    None

--*/
{

    REF_TRACE_LOG_ENTRY entry;
    ULONG hash;
    DWORD cStackFramesSkipped;

    //
    // Initialize the entry.
    //

    ZeroMemory(
        &entry,
        sizeof(entry)
        );

    //
    //  Set log entry members.
    //

    entry.NewRefCount = NewRefCount;
    entry.Context = Context;
    entry.Thread = GetCurrentThreadId();
    entry.Context1 = Context1;
    entry.Context2 = Context2;
    entry.Context3 = Context3;

    //
    // Capture the stack backtrace. Normally, we skip two stack frames:
    // one for this routine, and one for IISCaptureStackBackTrace() itself.
    // For non-Ex callers who come in via WriteRefTraceLog,
    // we skip three stack frames.
    //

    if (    entry.Context1 == (PVOID) -1 
         && entry.Context2 == (PVOID) -1
         && entry.Context3 == (PVOID) -1
         ) {

         cStackFramesSkipped = 3;

    } else {
    
         cStackFramesSkipped = 2;

    }

    IISCaptureStackBackTrace(
        cStackFramesSkipped,
        REF_TRACE_LOG_STACK_DEPTH,
        entry.Stack,
        &hash
        );

    //
    // Write it to the log.
    //

    WriteTraceLog(
        Log,
        &entry
        );

}   // WriteRefTraceLogEx
#pragma optimize( "", on )      // restore frame pointer omission (FPO)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\iislib\pudebug.c ===
/*++

    Copyright (c) 1994  Microsoft Corporation

    Module  Name :
        pudebug.c

    Abstract:

        This module defines functions required for
         Debugging and logging messages for a dynamic program.

    Author:
         Murali R. Krishnan ( MuraliK )    10-Sept-1994
         Modified to be moved to common dll in 22-Dec-1994.

    Revisions:
         MuraliK  16-May-1995  Code to load and save debug flags from registry
         MuraliK  16-Nov-1995  Remove DbgPrint (undoc api)
--*/


/************************************************************
 * Include Headers
 ************************************************************/

#include "iislibp.h"

/*************************************************************
 * Global Variables and Default Values
 *************************************************************/

# define MAX_PRINTF_OUTPUT  ( 10240)

# define DEFAULT_DEBUG_FLAGS_VALUE  ( 0)
# define DEBUG_FLAGS_REGISTRY_LOCATION_A   "DebugFlags"


/*************************************************************
 *   Functions
 *************************************************************/

LPDEBUG_PRINTS
  PuCreateDebugPrintsObject(
    IN const char *         pszPrintLabel,
    IN DWORD                dwOutputFlags)
/*++
   This function creates a new DEBUG_PRINTS object for the required
     program.

   Arguments:
      pszPrintLabel     pointer to null-terminated string containing
                         the label for program's debugging output
      dwOutputFlags     DWORD containing the output flags to be used.

   Returns:
       pointer to a new DEBUG_PRINTS object on success.
       Returns NULL on failure.
--*/
{

   LPDEBUG_PRINTS   pDebugPrints;

   pDebugPrints = GlobalAlloc( GPTR, sizeof( DEBUG_PRINTS));

   if ( pDebugPrints != NULL) {

        if ( strlen( pszPrintLabel) < MAX_LABEL_LENGTH) {

            strcpy( pDebugPrints->m_rgchLabel, pszPrintLabel);
        } else {
            strncpy( pDebugPrints->m_rgchLabel,
                     pszPrintLabel, MAX_LABEL_LENGTH - 1);
            pDebugPrints->m_rgchLabel[MAX_LABEL_LENGTH-1] = '\0';
                // terminate string
        }

        memset( pDebugPrints->m_rgchLogFilePath, 0, MAX_PATH);
        memset( pDebugPrints->m_rgchLogFileName, 0, MAX_PATH);

        pDebugPrints->m_LogFileHandle = INVALID_HANDLE_VALUE;

        pDebugPrints->m_dwOutputFlags = dwOutputFlags;
        pDebugPrints->m_StdErrHandle  = GetStdHandle( STD_ERROR_HANDLE);
        pDebugPrints->m_fInitialized = TRUE;
    }


   return ( pDebugPrints);
} // PuCreateDebugPrintsObject()




LPDEBUG_PRINTS
  PuDeleteDebugPrintsObject(
    IN OUT LPDEBUG_PRINTS pDebugPrints)
/*++
    This function cleans up the pDebugPrints object and
      frees the allocated memory.

    Arguments:
       pDebugPrints     poitner to the DEBUG_PRINTS object.

    Returns:
        NULL  on  success.
        pDebugPrints() if the deallocation failed.

--*/
{
    if ( pDebugPrints != NULL) {

        DWORD dwError = PuCloseDbgPrintFile( pDebugPrints);

        if ( dwError != NO_ERROR) {

            SetLastError( dwError);
        } else {

            pDebugPrints = GlobalFree( pDebugPrints);
        }
    }

    return ( pDebugPrints);

} // PuDeleteDebugPrintsObject()




VOID
PuSetDbgOutputFlags(
    IN OUT LPDEBUG_PRINTS   pDebugPrints,
    IN DWORD                dwFlags)
{

    if ( pDebugPrints == NULL) {

        SetLastError( ERROR_INVALID_PARAMETER);
    } else {

        pDebugPrints->m_dwOutputFlags = dwFlags;
    }

    return;
} // PuSetDbgOutputFlags()



DWORD
PuGetDbgOutputFlags(
    IN const LPDEBUG_PRINTS      pDebugPrints)
{
    return ( pDebugPrints != NULL) ? pDebugPrints->m_dwOutputFlags : 0;

} // PuGetDbgOutputFlags()


static DWORD
PuOpenDbgFileLocal(
   IN OUT LPDEBUG_PRINTS pDebugPrints)
{

    if ( pDebugPrints->m_LogFileHandle != INVALID_HANDLE_VALUE) {

        //
        // Silently return as a file handle exists.
        //
        return ( NO_ERROR);
    }

    pDebugPrints->m_LogFileHandle =
                      CreateFile( pDebugPrints->m_rgchLogFileName,
                                  GENERIC_WRITE,
                                  FILE_SHARE_READ | FILE_SHARE_WRITE,
                                  NULL,
                                  OPEN_ALWAYS,
                                  FILE_ATTRIBUTE_NORMAL,
                                  NULL);

    if ( pDebugPrints->m_LogFileHandle == INVALID_HANDLE_VALUE) {

        CHAR  pchBuffer[1024];
        DWORD dwError = GetLastError();

        wsprintfA( pchBuffer,
                  " Critical Error: Unable to Open File %s. Error = %d\n",
                  pDebugPrints->m_rgchLogFileName, dwError);
        OutputDebugString( pchBuffer);

        return ( dwError);
    }

    return ( NO_ERROR);
} // PuOpenDbgFileLocal()





DWORD
PuOpenDbgPrintFile(
   IN OUT LPDEBUG_PRINTS      pDebugPrints,
   IN const char *            pszFileName,
   IN const char *            pszPathForFile)
/*++

  Opens a Debugging log file. This function can be called to set path
  and name of the debugging file.

  Arguments:
     pszFileName           pointer to null-terminated string containing
                            the name of the file.

     pszPathForFile        pointer to null-terminated string containing the
                            path for the given file.
                           If NULL, then the old place where dbg files were
                           stored is used or if none,
                           default windows directory will be used.

   Returns:
       Win32 error codes. NO_ERROR on success.

--*/
{

    if ( pszFileName == NULL || pDebugPrints == NULL) {

        return ( ERROR_INVALID_PARAMETER);
    }

    //
    //  Setup the Path information. if necessary.
    //

    if ( pszPathForFile != NULL) {

        // Path is being changed.

        if ( strlen( pszPathForFile) < MAX_PATH) {

            strcpy( pDebugPrints->m_rgchLogFilePath, pszPathForFile);
        } else {

            return ( ERROR_INVALID_PARAMETER);
        }
    } else {

        if ( pDebugPrints->m_rgchLogFilePath[0] == '\0' &&  // no old path
            !GetWindowsDirectory( pDebugPrints->m_rgchLogFilePath, MAX_PATH)) {

            //
            //  Unable to get the windows default directory. Use current dir
            //

            strcpy( pDebugPrints->m_rgchLogFilePath, ".");
        }
    }

    //
    // Should need be, we need to create this directory for storing file
    //


    //
    // Form the complete Log File name and open the file.
    //
    if ( (strlen( pszFileName) + strlen( pDebugPrints->m_rgchLogFilePath))
         >= MAX_PATH) {

        return ( ERROR_NOT_ENOUGH_MEMORY);
    }

    //  form the complete path
    strcpy( pDebugPrints->m_rgchLogFileName, pDebugPrints->m_rgchLogFilePath);

    if ( pDebugPrints->m_rgchLogFileName[ strlen(pDebugPrints->m_rgchLogFileName) - 1]
        != '\\') {
        // Append a \ if necessary
        strcat( pDebugPrints->m_rgchLogFileName, "\\");
    };
    strcat( pDebugPrints->m_rgchLogFileName, pszFileName);

    return  PuOpenDbgFileLocal( pDebugPrints);

} // PuOpenDbgPrintFile()




DWORD
PuReOpenDbgPrintFile(
    IN OUT LPDEBUG_PRINTS    pDebugPrints)
/*++

  This function closes any open log file and reopens a new copy.
  If necessary. It makes a backup copy of the file.

--*/
{

    PuCloseDbgPrintFile( pDebugPrints);      // close any existing file.

    if ( pDebugPrints->m_dwOutputFlags & DbgOutputBackup) {

        // MakeBkupCopy();

        OutputDebugString( " Error: MakeBkupCopy() Not Yet Implemented\n");
    }

    return PuOpenDbgFileLocal( pDebugPrints);

} // PuReOpenDbgPrintFile()




DWORD
PuCloseDbgPrintFile(
    IN OUT LPDEBUG_PRINTS    pDebugPrints)
{
    DWORD dwError = NO_ERROR;

    if ( pDebugPrints == NULL ) {
        dwError = ERROR_INVALID_PARAMETER;
    } else {

        if ( pDebugPrints->m_LogFileHandle != INVALID_HANDLE_VALUE) {

            FlushFileBuffers( pDebugPrints->m_LogFileHandle);

            if ( !CloseHandle( pDebugPrints->m_LogFileHandle)) {

                CHAR pchBuffer[1024];

                dwError = GetLastError();

                wsprintf( pchBuffer,
                          "CloseDbgPrintFile() : CloseHandle( %p) failed."
                          " Error = %d\n",
                          pDebugPrints->m_LogFileHandle,
                          dwError);
                OutputDebugString( pchBuffer);
            }

            pDebugPrints->m_LogFileHandle = INVALID_HANDLE_VALUE;
        }
    }

    return ( dwError);
} // DEBUG_PRINTS::CloseDbgPrintFile()


VOID
PuDbgPrint(
   IN OUT LPDEBUG_PRINTS      pDebugPrints,
   IN const char *            pszFilePath,
   IN int                     nLineNum,
   IN const char *            pszFormat,
   ...)
/*++

   Main function that examines the incoming message and prints out a header
    and the message.

--*/
{
   LPCSTR pszFileName = strrchr( pszFilePath, '\\');
   char pszOutput[ MAX_PRINTF_OUTPUT + 2];
   LPCSTR pszMsg = "";
   INT  cchOutput;
   INT  cchPrologue;
   va_list argsList;
   DWORD dwErr;


   //
   //  Skip the complete path name and retain file name in pszName
   //

   if ( pszFileName== NULL) {

      pszFileName = pszFilePath;  // if skipping \\ yields nothing use whole path.
   }

# ifdef _PRINT_REASONS_INCLUDED_

  switch (pr) {

     case PrintError:
        pszMsg = "ERROR: ";
        break;

     case PrintWarning:
        pszMsg = "WARNING: ";
        break;

     case PrintCritical:
        pszMsg = "FATAL ERROR ";
        break;

     case PrintAssertion:
        pszMsg = "ASSERTION Failed ";
        break;

     case PrintLog:
        pfnPrintFunction = &DEBUG_PRINTS::DebugPrintNone;
     default:
        break;

  } /* switch */

# endif // _PRINT_REASONS_INClUDED_

  dwErr = GetLastError();

  // Format the message header

  cchPrologue = wsprintf( pszOutput, "%s (%lu)[ %12s : %05d]",
                        pDebugPrints->m_rgchLabel,
                        GetCurrentThreadId(),
                        pszFileName, nLineNum);

  // Format the incoming message using vsnprintf() so that the overflows are
  //  captured

  va_start( argsList, pszFormat);

  cchOutput = _vsnprintf( pszOutput + cchPrologue,
                          MAX_PRINTF_OUTPUT - cchPrologue - 1,
                          pszFormat, argsList);
  va_end( argsList);

  //
  // The string length is long, we get back -1.
  //   so we get the string length for partial data.
  //

  if ( cchOutput == -1 ) {

      //
      // terminate the string properly,
      //   since _vsnprintf() does not terminate properly on failure.
      //
      cchOutput = MAX_PRINTF_OUTPUT;
      pszOutput[ cchOutput] = '\0';
  }

  //
  // Send the outputs to respective files.
  //

  if ( pDebugPrints->m_dwOutputFlags & DbgOutputStderr) {

      DWORD nBytesWritten;

      ( VOID) WriteFile( pDebugPrints->m_StdErrHandle,
                         pszOutput,
                         strlen( pszOutput),
                         &nBytesWritten,
                         NULL);
  }

  if ( pDebugPrints->m_dwOutputFlags & DbgOutputLogFile &&
       pDebugPrints->m_LogFileHandle != INVALID_HANDLE_VALUE) {

      DWORD nBytesWritten;

      //
      // Truncation of log files. Not yet implemented.

      ( VOID) WriteFile( pDebugPrints->m_LogFileHandle,
                         pszOutput,
                         strlen( pszOutput),
                         &nBytesWritten,
                         NULL);

  }


  if ( pDebugPrints->m_dwOutputFlags & DbgOutputKdb) {

      OutputDebugString( pszOutput);
   }

  SetLastError( dwErr );

  return;

} // PuDbgPrint()



VOID
 PuDbgDump(
   IN OUT LPDEBUG_PRINTS   pDebugPrints,
   IN const char *         pszFilePath,
   IN int                  nLineNum,
   IN const char *         pszDump
   )
{
   LPCSTR pszFileName = strrchr( pszFilePath, '\\');
   LPCSTR pszMsg = "";
   DWORD dwErr;
   DWORD cbDump;


   //
   //  Skip the complete path name and retain file name in pszName
   //

   if ( pszFileName== NULL) {

      pszFileName = pszFilePath;
   }

   dwErr = GetLastError();

   // No message header for this dump
   cbDump = strlen( pszDump);

   //
   // Send the outputs to respective files.
   //

   if ( pDebugPrints->m_dwOutputFlags & DbgOutputStderr) {

       DWORD nBytesWritten;

       ( VOID) WriteFile( pDebugPrints->m_StdErrHandle,
                          pszDump,
                          cbDump,
                          &nBytesWritten,
                          NULL);
   }

   if ( pDebugPrints->m_dwOutputFlags & DbgOutputLogFile &&
        pDebugPrints->m_LogFileHandle != INVALID_HANDLE_VALUE) {

       DWORD nBytesWritten;

       //
       // Truncation of log files. Not yet implemented.

       ( VOID) WriteFile( pDebugPrints->m_LogFileHandle,
                          pszDump,
                          cbDump,
                          &nBytesWritten,
                          NULL);

   }

   if ( pDebugPrints->m_dwOutputFlags & DbgOutputKdb) {

       OutputDebugString( pszDump);
   }

   SetLastError( dwErr );

  return;
} // PuDbgDump()

//
// N.B. For PuDbgCaptureContext() to work properly, the calling function
// *must* be __cdecl, and must have a "normal" stack frame. So, we decorate
// PuDbgAssertFailed() with the __cdecl modifier and disable the frame pointer
// omission (FPO) optimization.
//

#pragma optimize( "y", off )    // disable frame pointer omission (FPO)
VOID
__cdecl
PuDbgAssertFailed(
    IN OUT LPDEBUG_PRINTS         pDebugPrints,
    IN const char *               pszFilePath,
    IN int                        nLineNum,
    IN const char *               pszExpression,
    IN const char *               pszMessage)
/*++
    This function calls assertion failure and records assertion failure
     in log file.

--*/
{
    CONTEXT context;

    PuDbgCaptureContext( &context );

    PuDbgPrint( pDebugPrints, pszFilePath, nLineNum,
                " Assertion (%s) Failed: %s\n"
                " use !cxr %lx to dump context\n",
                pszExpression,
                pszMessage,
                &context);

    DebugBreak();

    return;
} // PuDbgAssertFailed()
#pragma optimize( "", on )      // restore frame pointer omission (FPO)



VOID
PuDbgPrintCurrentTime(
    IN OUT LPDEBUG_PRINTS         pDebugPrints,
    IN const char *               pszFilePath,
    IN int                        nLineNum
    )
/*++
  This function generates the current time and prints it out to debugger
   for tracing out the path traversed, if need be.

  Arguments:
      pszFile    pointer to string containing the name of the file
      lineNum    line number within the file where this function is called.

  Returns:
      NO_ERROR always.
--*/
{
    PuDbgPrint( pDebugPrints, pszFilePath, nLineNum,
                " TickCount = %u\n",
                GetTickCount()
                );

    return;
} // PrintOutCurrentTime()




DWORD
PuLoadDebugFlagsFromReg(IN HKEY hkey, IN DWORD dwDefault)
/*++
  This function reads the debug flags assumed to be stored in
   the location  "DebugFlags" under given key.
  If there is any error the default value is returned.
--*/
{
    DWORD err;
    DWORD dwDebug = dwDefault;
    DWORD  dwBuffer;
    DWORD  cbBuffer = sizeof(dwBuffer);
    DWORD  dwType;

    if( hkey != NULL )
    {
        err = RegQueryValueExA( hkey,
                               DEBUG_FLAGS_REGISTRY_LOCATION_A,
                               NULL,
                               &dwType,
                               (LPBYTE)&dwBuffer,
                               &cbBuffer );

        if( ( err == NO_ERROR ) && ( dwType == REG_DWORD ) )
        {
            dwDebug = dwBuffer;
        }
    }

    return dwDebug;
} // PuLoadDebugFlagsFromReg()




DWORD
PuLoadDebugFlagsFromRegStr(IN LPCSTR pszRegKey, IN DWORD dwDefault)
/*++
Description:
  This function reads the debug flags assumed to be stored in
   the location  "DebugFlags" under given key location in registry.
  If there is any error the default value is returned.

Arguments:
  pszRegKey - pointer to registry key location from where to read the key from
  dwDefault - default values in case the read from registry fails

Returns:
   Newly read value on success
   If there is any error the dwDefault is returned.
--*/
{
    HKEY        hkey = NULL;

    DWORD dwVal = dwDefault;

    DWORD dwError = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                  pszRegKey,
                                  0,
                                  KEY_ALL_ACCESS,
                                  &hkey);
    if ( dwError == NO_ERROR) {
        dwVal = PuLoadDebugFlagsFromReg( hkey, dwDefault);
        RegCloseKey( hkey);
        hkey = NULL;
    }

    return ( dwVal);
} // PuLoadDebugFlagsFromRegStr()





DWORD
PuSaveDebugFlagsInReg(IN HKEY hkey, IN DWORD dwDbg)
/*++
  Saves the debug flags in registry. On failure returns the error code for
   the operation that failed.

--*/
{
    DWORD err;

    if( hkey == NULL ) {

        err = ERROR_INVALID_PARAMETER;
    } else {

        err = RegSetValueExA(hkey,
                             DEBUG_FLAGS_REGISTRY_LOCATION_A,
                             0,
                             REG_DWORD,
                             (LPBYTE)&dwDbg,
                             sizeof(dwDbg) );
    }

    return (err);
} // PuSaveDebugFlagsInReg()


//
// Dummy PuDbgCaptureContext(), only used if we're ever built for
// a target processor other than x86 or alpha.
//

VOID
PuDbgCaptureContext (
    OUT PCONTEXT ContextRecord
    )
{
    //
    // This space intentionally left blank.
    //

}   // PuDbgCaptureContext


/****************************** End of File ******************************/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\iislib\inc\tracelog.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    tracelog.h

Abstract:

    This module contains public declarations and definitions for creating
    trace logs.

    A trace log is a fast, in-memory, thread safe activity log useful
    for debugging certain classes of problems. They are especially useful
    when debugging reference count bugs.

    Note that the creator of the log has the option of adding "extra"
    bytes to the log header. This can be useful if the creator wants to
    create a set of global logs, each on a linked list.

Author:

    Keith Moore (keithmo)        30-Apr-1997

Revision History:

--*/


#ifndef _TRACELOG_H_
#define _TRACELOG_H_


#if defined(__cplusplus)
extern "C" {
#endif  // __cplusplus


typedef struct _TRACE_LOG {

    //
    // Signature.
    //

    LONG Signature;

    //
    // The total number of entries available in the log.
    //

    LONG LogSize;

    //
    // The index of the next entry to use.
    //

    LONG NextEntry;

    //
    // The byte size of each entry.
    //

    LONG EntrySize;

    //
    // Pointer to the start of the circular buffer.
    //

    PUCHAR LogBuffer;

    //
    // The extra header bytes and actual log entries go here.
    //
    // BYTE ExtraHeaderBytes[ExtraBytesInHeader];
    // BYTE Entries[LogSize][EntrySize];
    //

} TRACE_LOG, *PTRACE_LOG;


//
// Log header signature.
//

#define TRACE_LOG_SIGNATURE   ((DWORD)'gOlT')
#define TRACE_LOG_SIGNATURE_X ((DWORD)'golX')


//
// This macro maps a TRACE_LOG pointer to a pointer to the 'extra'
// data associated with the log.
//

#define TRACE_LOG_TO_EXTRA_DATA(log)    (PVOID)( (log) + 1 )


//
// Manipulators.
//

PTRACE_LOG
CreateTraceLog(
    IN LONG LogSize,
    IN LONG ExtraBytesInHeader,
    IN LONG EntrySize
    );

VOID
DestroyTraceLog(
    IN PTRACE_LOG Log
    );

VOID
WriteTraceLog(
    IN PTRACE_LOG Log,
    IN PVOID Entry
    );

VOID
ResetTraceLog(
    IN PTRACE_LOG Log
    );


#if defined(__cplusplus)
}   // extern "C"
#endif  // __cplusplus


#endif  // _TRACELOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\iislib\tracelog.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    tracelog.c

Abstract:

    This module implements a trace log.

    A trace log is a fast, in-memory, thread safe activity log useful
    for debugging certain classes of problems. They are especially useful
    when debugging reference count bugs.

Author:

    Keith Moore (keithmo)        30-Apr-1997

Revision History:

--*/


#include "iislibp.h"


#define ALLOC_MEM(cb) (PVOID)LocalAlloc( LPTR, (cb) )
#define FREE_MEM(ptr) (VOID)LocalFree( (HLOCAL)(ptr) )



PTRACE_LOG
CreateTraceLog(
    IN LONG LogSize,
    IN LONG ExtraBytesInHeader,
    IN LONG EntrySize
    )
/*++

Routine Description:

    Creates a new (empty) trace log buffer.

Arguments:

    LogSize - The number of entries in the log.

    ExtraBytesInHeader - The number of extra bytes to include in the
        log header. This is useful for adding application-specific
        data to the log.

    EntrySize - The size (in bytes) of each entry.

Return Value:

    PTRACE_LOG - Pointer to the newly created log if successful,
        NULL otherwise.

--*/
{

    LONG totalSize;
    PTRACE_LOG log;

    //
    // Sanity check the parameters.
    //

    DBG_ASSERT( LogSize > 0 );
    DBG_ASSERT( EntrySize > 0 );
    DBG_ASSERT( ( EntrySize & 3 ) == 0 );

    //
    // Allocate & initialize the log structure.
    //

    totalSize = sizeof(*log) + ( LogSize * EntrySize ) + ExtraBytesInHeader;
    DBG_ASSERT( totalSize > 0 );

    log = (PTRACE_LOG)ALLOC_MEM( totalSize );

    //
    // Initialize it.
    //

    if( log != NULL ) {

        ZeroMemory( log, totalSize );

        log->Signature = TRACE_LOG_SIGNATURE;
        log->LogSize = LogSize;
        log->NextEntry = -1;
        log->EntrySize = EntrySize;
        log->LogBuffer = (PUCHAR)( log + 1 ) + ExtraBytesInHeader;
    }

    return log;

}   // CreateTraceLog


VOID
DestroyTraceLog(
    IN PTRACE_LOG Log
    )
/*++

Routine Description:

    Destroys a trace log buffer created with CreateTraceLog().

Arguments:

    Log - The trace log buffer to destroy.

Return Value:

    None.

--*/
{
	if ( Log != NULL ) {
        DBG_ASSERT( Log->Signature == TRACE_LOG_SIGNATURE );

        Log->Signature = TRACE_LOG_SIGNATURE_X;
        FREE_MEM( Log );
    }

}   // DestroyTraceLog


VOID
WriteTraceLog(
    IN PTRACE_LOG Log,
    IN PVOID Entry
    )
/*++

Routine Description:

    Writes a new entry to the specified trace log.

Arguments:

    Log - The log to write to.

    Entry - Pointer to the data to write. This buffer is assumed to be
        Log->EntrySize bytes long.

Return Value:

    None

--*/
{

    PUCHAR target;
    LONG index;

    DBG_ASSERT( Log != NULL );
    DBG_ASSERT( Log->Signature == TRACE_LOG_SIGNATURE );
    DBG_ASSERT( Entry != NULL );

    //
    // Find the next slot, copy the entry to the slot.
    //

    index = InterlockedIncrement( &Log->NextEntry ) % Log->LogSize;
    target = Log->LogBuffer + ( index * Log->EntrySize );

    memcpy(
        target,
        Entry,
        Log->EntrySize
        );

}   // WriteTraceLog


VOID
ResetTraceLog(
    IN PTRACE_LOG Log
    )
{

    DBG_ASSERT( Log != NULL );
    DBG_ASSERT( Log->Signature == TRACE_LOG_SIGNATURE );

    ZeroMemory(
        ( Log + 1 ),
        Log->LogSize * Log->EntrySize
        );

    Log->NextEntry = -1;

}   // ResetTraceLog
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\iislib\win32obj.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    win32obj.c

Abstract:

    This module contains helper functions for creating debug-specific
    named Win32 objects. Functions are included for named events,
    semaphores, and mutexes.

    Object names created by these routines have the following format:

        filename.ext:line_number member:address PID:pid

    Where:

        filename.ext = The file name where the object was created.

        line_number = The line number within the file.

        member = The member/global variable name where the handle is
            stored. This name is provided by the caller, but is usually
            of the form "g_Global" for globals and "CLASS::m_Member" for
            class members.

        address = An address, used to guarantee uniqueness of the objects
            created. This is provided by the caller. For global variables,
            this is typically the address of the global. For class members,
            this is typically the address of the containing class.

        pid = The current process ID. This ensures uniqueness across all
            processes.

    Here are a couple of examples:

        main.cxx:796 g_hShutdownEvent:683a42bc PID:373

        resource.cxx:136 RTL_RESOURCE::SharedSemaphore:00250970 PID:373

Author:

    Keith Moore (keithmo)        23-Sep-1997

Revision History:

--*/


#include "iislibp.h"


#define MAX_OBJECT_NAME 256 // chars


LONG g_PuDbgEventsCreated = 0;
LONG g_PuDbgSemaphoresCreated = 0;
LONG g_PuDbgMutexesCreated = 0;



LPSTR
PuDbgpBuildObjectName(
    IN LPSTR ObjectNameBuffer,
    IN LPSTR FileName,
    IN ULONG LineNumber,
    IN LPSTR MemberName,
    IN PVOID Address
    )

/*++

Routine Description:

    Internal routine that builds an appropriate object name based on
    the file name, line number, member name, address, and process ID.

Arguments:

    ObjectNameBuffer - Pointer to the target buffer for the name.

    FileName - The filename of the source creating the object. This
        is __FILE__ of the caller.

    LineNumber - The line number within the source. This is __LINE__
        of the caller.

    MemberName - The member/global variable name where the object handle
        is to be stored.

    Address - The address of the containing structure/class or of the
        global itself.

Return Value:

    LPSTR - Pointer to ObjectNameBuffer if successful, NULL otherwise.

    N.B. This routine always returns NULL when running under Win9x.

--*/

{

    PLATFORM_TYPE platformType;
    LPSTR fileNamePart;
    LPSTR result;

    //
    // We have no convenient way to dump objects w/ names from
    // Win9x, so we'll only enable this functionality under NT.
    //

    platformType = IISGetPlatformType();
    result = NULL;

    if( platformType == PtNtServer ||
        platformType == PtNtWorkstation ) {

        //
        // Find the filename part of the incoming source file name.
        //

        fileNamePart = strrchr( FileName, '\\' );

        if( fileNamePart == NULL ) {
            fileNamePart = strrchr( FileName, '/' );
        }

        if( fileNamePart == NULL ) {
            fileNamePart = strrchr( FileName, ':' );
        }

        if( fileNamePart == NULL ) {
            fileNamePart = FileName;
        } else {
            fileNamePart++;
        }

        //
        // Ensure we don't overwrite our object name buffer.
        //

        if( ( sizeof(":1234567890 :12345678 PID:1234567890") +
              strlen( fileNamePart ) +
              strlen( MemberName ) ) < MAX_OBJECT_NAME ) {

            wsprintfA(
                ObjectNameBuffer,
                "%s:%lu %s:%08lp PID:%lu",
                fileNamePart,
                LineNumber,
                MemberName,
                Address,
                GetCurrentProcessId()
                );

            result = ObjectNameBuffer;

        }

    }

    return result;

}   // PuDbgpBuildObjectName


HANDLE
PuDbgCreateEvent(
    IN LPSTR FileName,
    IN ULONG LineNumber,
    IN LPSTR MemberName,
    IN PVOID Address,
    IN BOOL ManualReset,
    IN BOOL InitialState
    )

/*++

Routine Description:

    Creates a new event object.

Arguments:

    FileName - The filename of the source creating the object. This
        is __FILE__ of the caller.

    LineNumber - The line number within the source. This is __LINE__
        of the caller.

    MemberName - The member/global variable name where the object handle
        is to be stored.

    Address - The address of the containing structure/class or of the
        global itself.

    ManualReset - TRUE to create a manual reset event, FALSE to create
        an automatic reset event.

    InitialState - The intitial state of the event object.

Return Value:

    HANDLE - Handle to the object if successful, NULL otherwise.

--*/

{

    LPSTR objName;
    HANDLE objHandle;
    CHAR objNameBuffer[MAX_OBJECT_NAME];

    objName = PuDbgpBuildObjectName(
                  objNameBuffer,
                  FileName,
                  LineNumber,
                  MemberName,
                  Address
                  );

    objHandle = CreateEventA(
                    NULL,                       // lpEventAttributes
                    ManualReset,                // bManualReset
                    InitialState,               // bInitialState
                    objName                     // lpName
                    );

    if( objHandle != NULL ) {
        InterlockedIncrement( &g_PuDbgEventsCreated );
    }

    return objHandle;

}   // PuDbgCreateEvent


HANDLE
PuDbgCreateSemaphore(
    IN LPSTR FileName,
    IN ULONG LineNumber,
    IN LPSTR MemberName,
    IN PVOID Address,
    IN LONG InitialCount,
    IN LONG MaximumCount
    )

/*++

Routine Description:

    Creates a new semaphore object.

Arguments:

    FileName - The filename of the source creating the object. This
        is __FILE__ of the caller.

    LineNumber - The line number within the source. This is __LINE__
        of the caller.

    MemberName - The member/global variable name where the object handle
        is to be stored.

    Address - The address of the containing structure/class or of the
        global itself.

    InitialCount - The initial count of the semaphore.

    MaximumCount - The maximum count of the semaphore.

Return Value:

    HANDLE - Handle to the object if successful, NULL otherwise.

--*/

{

    LPSTR objName;
    HANDLE objHandle;
    CHAR objNameBuffer[MAX_OBJECT_NAME];

    objName = PuDbgpBuildObjectName(
                  objNameBuffer,
                  FileName,
                  LineNumber,
                  MemberName,
                  Address
                  );

    objHandle = CreateSemaphoreA(
                    NULL,                       // lpSemaphoreAttributes
                    InitialCount,               // lInitialCount
                    MaximumCount,               // lMaximumCount
                    objName                     // lpName
                    );

    if( objHandle != NULL ) {
        InterlockedIncrement( &g_PuDbgSemaphoresCreated );
    }

    return objHandle;

}   // PuDbgCreateSemaphore


HANDLE
PuDbgCreateMutex(
    IN LPSTR FileName,
    IN ULONG LineNumber,
    IN LPSTR MemberName,
    IN PVOID Address,
    IN BOOL InitialOwner
    )

/*++

Routine Description:

    Creates a new mutex object.

Arguments:

    FileName - The filename of the source creating the object. This
        is __FILE__ of the caller.

    LineNumber - The line number within the source. This is __LINE__
        of the caller.

    MemberName - The member/global variable name where the object handle
        is to be stored.

    Address - The address of the containing structure/class or of the
        global itself.

    InitialOwner - TRUE if the mutex should be created "owned".

Return Value:

    HANDLE - Handle to the object if successful, NULL otherwise.

--*/

{

    LPSTR objName;
    HANDLE objHandle;
    CHAR objNameBuffer[MAX_OBJECT_NAME];

    objName = PuDbgpBuildObjectName(
                  objNameBuffer,
                  FileName,
                  LineNumber,
                  MemberName,
                  Address
                  );

    objHandle = CreateMutexA(
                    NULL,                       // lpMutexAttributes
                    InitialOwner,               // bInitialOwner,
                    objName                     // lpName
                    );

    if( objHandle != NULL ) {
        InterlockedIncrement( &g_PuDbgMutexesCreated );
    }

    return objHandle;

}   // PuDbgCreateMutex
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\iislib\isplat.cxx ===
/*++

    Copyright (c) 1996  Microsoft Corporation

    Module  Name :
        isplat.cxx

    Abstract:

        This module defines functions for determining platform types

    Author:

        Johnson Apacible    (johnsona)      19-Nov-1996

        Murali Krishnan     (MuraliK)       17-Apr-1997
                   Added CriticalSectionWith SpinCount stuff
--*/
#undef UNICODE
#undef _UNICODE

extern "C" {

#include <windows.h>
#include <pudebug.h>

}   // extern "C"


#if DBG
#define IIS_PRINTF( x )        { char buff[256]; wsprintf x; OutputDebugString( buff ); }
#else
#define IIS_PRINTF( x )
#endif

DECLARE_PLATFORM_TYPE();

/*
    HACK HACK HACK
    In an attempt to decouple this code from ntpublic, this must stop using
    ntdll. The bad news is that we use ntdll to get the platform type of
    the system we're running on. The good news is that we only ever run on
    servers. So I'm just returning PtNtServer all the time now.

    EVEN MORE HACK
    g_PlatformType is obviously not useful here, but other code seems to like
    it. I'll remove that if I can do so easily.
*/
extern "C"
PLATFORM_TYPE
IISGetPlatformType(
        VOID
        )
{
    if ( g_PlatformType != PtInvalid ) {
        return(g_PlatformType);
    }
    g_PlatformType = PtNtServer;
    return(g_PlatformType);
} // IISGetPlatformType



/************************************************************
 *  Critical Section With Spin Count thunks
 ************************************************************/

typedef
DWORD
(WINAPI * PFN_SET_CRITICAL_SECTION_SPIN_COUNT)(
    LPCRITICAL_SECTION lpCriticalSection,
    DWORD dwSpinCount
   );

PFN_SET_CRITICAL_SECTION_SPIN_COUNT  g_pfnSetCSSpinCount = NULL;


DWORD WINAPI
FakeSetCriticalSectionSpinCount(
    LPCRITICAL_SECTION lpCriticalSection,
    DWORD dwSpinCount
   )
/*++
Description:
  This function fakes setting critical section spin count.
  See IISSetCriticalSectionSpinCount() for details

Returns:
   0 - since we are faking the set of cs with spin count
--*/
{
    UNREFERENCED_PARAMETER( lpCriticalSection);
    UNREFERENCED_PARAMETER( dwSpinCount);

    // For faked critical sections, the previous spin count is just ZERO!
    return (0);
} // FakeSetCriticalSectionSpinCount()


static VOID
LoadNtFunctionPointers(VOID)
/*++
Description:
  This function loads the entry point for SetCriticalSectionSpinCount()
  API from Kernel32.dll. If the entry point is missing, the function
  pointer will point to a fake routine which does nothing. Otherwise,
  it will point to the real function.

  It dynamically loads the kernel32.dll to find the entry ponit and then
  unloads it after getting the address. For the resulting function
  pointer to work correctly one has to ensure that the kernel32.dll is
  linked with the dll/exe which links to this file.
--*/
{
    if ( g_pfnSetCSSpinCount == NULL ) {

        HINSTANCE tmpInstance;

        //
        // load kernel32 and get NT specific entry points
        //

        tmpInstance = LoadLibrary("kernel32.dll");
        if ( tmpInstance != NULL ) {

            g_pfnSetCSSpinCount = (PFN_SET_CRITICAL_SECTION_SPIN_COUNT )
                GetProcAddress( tmpInstance, "SetCriticalSectionSpinCount");

            if ( g_pfnSetCSSpinCount == NULL ) {
                // the set CS Spincount function is not availble.
                //  Just thunk it.
                g_pfnSetCSSpinCount = FakeSetCriticalSectionSpinCount;
            }

            //
            // We can free this because we are statically linked to it
            //

            FreeLibrary(tmpInstance);
        }
        else
        {
            // the set CS Spincount function is not availble.
            //  Just thunk it.
            g_pfnSetCSSpinCount = FakeSetCriticalSectionSpinCount;
        }
    }

    return;
} // LoadNtFunctionPointers()


extern "C"
DWORD
IISSetCriticalSectionSpinCount(
    LPCRITICAL_SECTION lpCriticalSection,
    DWORD dwSpinCount
   )
/*++
Description:
  This function is used to call the appropriate underlying functions to
   set the spin count for the supplied critical section.
  The original function is supposed to be exported out of kernel32.dll from NT
  4.0 SP3. If the func is not available from the dll, we will use a fake
  function.

Arguments:
  lpCriticalSection
      Points to the critical section object.

  dwSpinCount
      Supplies the spin count for the critical section object. For UP systems,
      the spin count is ignored and the critical section spin
      count is set to 0. For MP systems, if contention occurs, instead of
      waiting on a semaphore associated with the critical section,
      the calling thread will spin for spin count iterations before doing the
      hard wait. If the critical section becomes free during the spin,
      a wait is avoided.

Returns:
   The previous spin count for the critical section is returned.
--*/
{
    if ( g_pfnSetCSSpinCount == NULL ) {
        LoadNtFunctionPointers();
    }

    // Pass the inputs to the global function pointer which is already setup.
    return ( g_pfnSetCSSpinCount( lpCriticalSection, dwSpinCount));

} // IISSetCriticalSectionSpinCount()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\iislib\inc\stktrace.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    stktrace.h

Abstract:

    This module contains public declarations and definitions for capturing
    stack back traces.

Author:

    Keith Moore (keithmo)        30-Apr-1997

Revision History:

--*/


#ifndef _STKTRACE_H_
#define _STKTRACE_H_


#if defined(__cplusplus)
extern "C" {
#endif  // __cplusplus


USHORT
NTAPI
IISCaptureStackBackTrace(
    IN ULONG FramesToSkip,
    IN ULONG FramesToCapture,
    OUT PVOID *BackTrace,
    OUT PULONG BackTraceHash
    );


#if defined(__cplusplus)
}   // extern "C"
#endif  // __cplusplus


#endif  // _STKTRACE_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\iislib\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_isdebug_none_12.4.56.0_none_6cb30340cfc5af6d
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_isdebug_no-public-key_12.4.56.0_x-ww_eb73a39f
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=isdebug
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_isdebug_no-public-key_12.4.56.0_x-ww_eb73a39f
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_isdebug_no-public-key_12.4.56.0_x-ww_eb73a39f.manifest
XP_MANIFEST_PATH=manifests\x86_isdebug_no-public-key_12.4.56.0_x-ww_eb73a39f.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_isdebug_no-public-key_12.4.56.0_x-ww_eb73a39f.cat
XP_CATALOG_PATH=manifests\x86_isdebug_no-public-key_12.4.56.0_x-ww_eb73a39f.cat
XP_PAYLOAD_PATH=x86_isdebug_no-public-key_12.4.56.0_x-ww_eb73a39f
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=isdebug,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\inc\md5.h ===
#ifndef __MD5_H__
#define __MD5_H__

#ifndef RSA32API
#define RSA32API __stdcall
#endif

/*
 ***********************************************************************
 ** md5.h -- Header file for implementation of MD5                    **
 ** RSA Data Security, Inc. MD5 Message-Digest Algorithm              **
 ** Created: 2/17/90 RLR                                              **
 ** Revised: 12/27/90 SRD,AJ,BSK,JT Reference C version               **
 ** Revised (for MD5): RLR 4/27/91                                    **
 **   -- G modified to have y&~z instead of y&z                       **
 **   -- FF, GG, HH modified to add in last register done             **
 **   -- Access pattern: round 2 works mod 5, round 3 works mod 3     **
 **   -- distinct additive constant for each step                     **
 **   -- round 4 added, working mod 7                                 **
 ***********************************************************************
 */

/*
 ***********************************************************************
 ** Copyright (C) 1990, RSA Data Security, Inc. All rights reserved.  **
 **                                                                   **
 ** License to copy and use this software is granted provided that    **
 ** it is identified as the "RSA Data Security, Inc. MD5 Message-     **
 ** Digest Algorithm" in all material mentioning or referencing this  **
 ** software or this function.                                        **
 **                                                                   **
 ** License is also granted to make and use derivative works          **
 ** provided that such works are identified as "derived from the RSA  **
 ** Data Security, Inc. MD5 Message-Digest Algorithm" in all          **
 ** material mentioning or referencing the derived work.              **
 **                                                                   **
 ** RSA Data Security, Inc. makes no representations concerning       **
 ** either the merchantability of this software or the suitability    **
 ** of this software for any particular purpose.  It is provided "as  **
 ** is" without express or implied warranty of any kind.              **
 **                                                                   **
 ** These notices must be retained in any copies of any part of this  **
 ** documentation and/or software.                                    **
 ***********************************************************************
 */

#ifdef __cplusplus
extern "C" {
#endif

/* Data structure for MD5 (Message-Digest) computation */
typedef struct {
  ULONG i[2];                          /* number of _bits_ handled mod 2^64 */
  ULONG buf[4];                                           /* scratch buffer */
  unsigned char in[64];                                     /* input buffer */
  unsigned char digest[16];            /* actual digest after MD5Final call */
  ULONG FinishFlag;
} MD5_CTX;


#define MD5DIGESTLEN    16
#define MD5_LEN         MD5DIGESTLEN    // second def for WinNT source compatibility

#define PROTO_LIST(list)    list


/*
 * MTS: Each of these assumes MD5_CTX is locked against simultaneous use.
 */
void RSA32API MD5Init PROTO_LIST ((MD5_CTX *));
void RSA32API MD5Update PROTO_LIST ((MD5_CTX *, const unsigned char *, unsigned int));
void RSA32API MD5Final PROTO_LIST ((MD5_CTX *));

#ifdef __cplusplus
}
#endif

#endif // __MD5_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\iislib\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_isdebug_none_12.4.56.0_none_6cb30340cfc5af6d
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_isdebug_no-public-key_12.4.56.0_x-ww_eb73a39f
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=isdebug
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_isdebug_no-public-key_12.4.56.0_x-ww_eb73a39f
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_isdebug_no-public-key_12.4.56.0_x-ww_eb73a39f.manifest
XP_MANIFEST_PATH=manifests\x86_isdebug_no-public-key_12.4.56.0_x-ww_eb73a39f.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_isdebug_no-public-key_12.4.56.0_x-ww_eb73a39f.cat
XP_CATALOG_PATH=manifests\x86_isdebug_no-public-key_12.4.56.0_x-ww_eb73a39f.cat
XP_PAYLOAD_PATH=x86_isdebug_no-public-key_12.4.56.0_x-ww_eb73a39f
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=isdebug,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\inc\config.h ===
/*++

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    Config.h

Abstract:

    This header file defines the function prototypes of the temporary
    helper routines to get configuration information from the NT
    configuration files.

Author:

    Rita Wong (ritaw) 22-May-1991

Environment:

    Only runs under NT.

Notes:

    You must include the following before this file:

            windef.h OR windows.h  // Win32 type definitions

Revision History:

    22-May-1991 RitaW
        Created.
    27-Nov-1991 JohnRo
        Prepare for revised config handlers.  Added revision history.
    08-Jan-1992 JohnRo
        Added SECT_NT_REPLICATOR.
    13-Feb-1992 JohnRo
        Moved section name equates to <confname.h>.
        Include <netdebug.h> and <lmcons.h> here instead of everywhere else.
        Added NetpDbgDisplayConfigSection().
        Added NetpDeleteConfigKeyword() and NetpNumberOfConfigKeywords().
        Added Netp{Get,Set}Config{Bool,Dword}.
    14-Mar-1992 JohnRo
        Get rid of old config helper callers.
    23-Mar-1992 JohnRo
        Get rid of old config helpers.
    08-May-1992 JohnRo
        Add LPTSTR array routines.
    08-Jul-1992 JohnRo
        RAID 10503: srv mgr: repl dialog doesn't come up.
    25-Feb-1993 JohnRo
        RAID 12914: avoid double close and free mem in NetpCloseConfigData().
    07-Apr-1993 JohnRo
        RAID 5483: server manager: wrong path given in repl dialog.

--*/


#ifndef CONFIG_H
#define CONFIG_H


#include <lmcons.h>     // NET_API_STATUS.
#include <netdebug.h>   // LPDEBUG_STRING.
#include <strarray.h>   // LPTSTR_ARRAY.


//
// Opaque pointer for net config handles.  (The real structure is in ConfigP.h,
// and should only be used by NetLib routines.)
//
typedef LPVOID LPNET_CONFIG_HANDLE;


//
// Note that the routines in this file only accept the SECT_NT_ versions.
// See <confname.h> for more details.
//


// NetpOpenConfigData opens the Paramaters section of a given service.
NET_API_STATUS WINAPI
NetpOpenConfigData(
    OUT LPNET_CONFIG_HANDLE *ConfigHandle,
    IN LPTSTR UncServerName OPTIONAL,
    IN LPTSTR SectionName,              // Must be a SECT_NT_ name.
    IN BOOL ReadOnly
    );

// NetpOpenConfigDataEx opens any area of a given service.
NET_API_STATUS
NetpOpenConfigDataEx(
    OUT LPNET_CONFIG_HANDLE *ConfigHandle,
    IN LPTSTR UncServerName OPTIONAL,
    IN LPTSTR SectionName,              // Must be a SECT_NT_ name.
    IN LPTSTR AreaUnderSection OPTIONAL,
    IN BOOL ReadOnly
    );

// NetpOpenConfigData opens the Paramaters section of a given service.
NET_API_STATUS
NetpOpenConfigDataWithPath(
    OUT LPNET_CONFIG_HANDLE *ConfigHandle,
    IN LPTSTR UncServerName OPTIONAL,
    IN LPTSTR SectionName,              // Must be a SECT_NT_ name.
    IN BOOL ReadOnly
    );

// NetpOpenConfigDataEx opens any area of a given service.
NET_API_STATUS
NetpOpenConfigDataWithPathEx(
    OUT LPNET_CONFIG_HANDLE *ConfigHandle,
    IN LPTSTR UncServerName OPTIONAL,
    IN LPTSTR SectionName,              // Must be a SECT_NT_ name.
    IN LPTSTR AreaUnderSection OPTIONAL,
    IN BOOL ReadOnly
    );

// Delete a keyword and its value.
// Return NERR_CfgParamNotFound if the keyword isn't present.
NET_API_STATUS
NetpDeleteConfigKeyword (
    IN LPNET_CONFIG_HANDLE ConfigHandle,
    IN LPTSTR Keyword
    );

NET_API_STATUS
NetpExpandConfigString(
    IN  LPCTSTR  UncServerName OPTIONAL,
    IN  LPCTSTR  UnexpandedString,
    OUT LPTSTR * ValueBufferPtr         // Must be freed by NetApiBufferFree().
    );

// If NetpOpenConfigData fails, try calling NetpHandleConfigFailure to decide
// what to do about it.
NET_API_STATUS
NetpHandleConfigFailure(
    IN LPDEBUG_STRING DebugName,        // Name of routine.
    IN NET_API_STATUS ApiStatus,        // NetpOpenConfigData's error code.
    IN LPTSTR ServerNameValue OPTIONAL,
    OUT LPBOOL TryDownlevel
    );

// Get a boolean value.  Return ERROR_INVALID_DATA if value isn't boolean.
// Return NERR_CfgParamNotFound if the keyword isn't present.
NET_API_STATUS
NetpGetConfigBool (
    IN LPNET_CONFIG_HANDLE ConfigHandle,
    IN LPTSTR Keyword,
    IN BOOL DefaultValue,
    OUT LPBOOL ValueBuffer
    );

// Get an unsigned numeric value.  Return ERROR_INVALID_DATA if value isn't
// numeric.
// Return NERR_CfgParamNotFound if the keyword isn't present.
NET_API_STATUS
NetpGetConfigDword (
    IN LPNET_CONFIG_HANDLE ConfigHandle,
    IN LPTSTR Keyword,
    IN DWORD DefaultValue,
    OUT LPDWORD ValueBuffer
    );

// Return null-null array of strings.
// Return NERR_CfgParamNotFound if the keyword isn't present.
NET_API_STATUS WINAPI
NetpGetConfigTStrArray(
    IN LPNET_CONFIG_HANDLE ConfigHandle,
    IN LPTSTR Keyword,
    OUT LPTSTR_ARRAY * ValueBuffer      // Must be freed by NetApiBufferFree().
    );

// Return string value for a given keyword.
// Return NERR_CfgParamNotFound if the keyword isn't present.
NET_API_STATUS
NetpGetConfigValue (
    IN LPNET_CONFIG_HANDLE ConfigHandle,
    IN LPTSTR Keyword,
    OUT LPTSTR * ValueBuffer            // Must be freed by NetApiBufferFree().
    );

NET_API_STATUS
NetpEnumConfigSectionValues(
    IN LPNET_CONFIG_HANDLE ConfigHandle,
    OUT LPTSTR * KeywordBuffer,         // Must be freed by NetApiBufferFree().
    OUT LPTSTR * ValueBuffer,           // Must be freed by NetApiBufferFree().
    IN BOOL FirstTime
    );

NET_API_STATUS
NetpNumberOfConfigKeywords (
    IN LPNET_CONFIG_HANDLE ConfigHandle,
    OUT LPDWORD Count
    );

NET_API_STATUS
NetpSetConfigValue(
    IN LPNET_CONFIG_HANDLE ConfigHandle,
    IN LPTSTR Keyword,
    IN LPTSTR Value
    );

NET_API_STATUS WINAPI
NetpCloseConfigData(
    IN OUT LPNET_CONFIG_HANDLE ConfigHandle
    );


#endif // ndef CONFIG_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\inc\crypt.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1989  Microsoft Corporation

Module Name:

    crypt.h

Abstract:

    This module contains the public data structures and API definitions
    needed to utilize the encryption library


Author:

    David Chalmers (Davidc) 21-October-1991

Revision History:

    Scott Field (SField)    09-October-2000
        Add RNG and Memory encryption interfaces

--*/


#ifndef _NTCRYPT_
#define _NTCRYPT_

#ifndef MIDL_PASS    // Don't confuse MIDL

#ifndef RPC_NO_WINDOWS_H // Don't let rpc.h include windows.h
#define RPC_NO_WINDOWS_H
#endif // RPC_NO_WINDOWS_H

#include <rpc.h>
#endif // MIDL_PASS

#ifdef __cplusplus
extern "C" {
#endif

/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Core encryption types                                               //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

#define BLOCK_KEY_LENGTH            7

typedef struct _BLOCK_KEY {
    CHAR    data[BLOCK_KEY_LENGTH];
}                                   BLOCK_KEY;
typedef BLOCK_KEY *                 PBLOCK_KEY;




/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Arbitrary length data encryption types                              //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

typedef struct _CRYPT_BUFFER {
    ULONG   Length;         // Number of valid bytes in buffer
    ULONG   MaximumLength;  // Number of bytes pointed to by Buffer
    PVOID   Buffer;
} CRYPT_BUFFER;
typedef CRYPT_BUFFER *  PCRYPT_BUFFER;

typedef CRYPT_BUFFER    CLEAR_DATA;
typedef CLEAR_DATA *    PCLEAR_DATA;

typedef CRYPT_BUFFER    DATA_KEY;
typedef DATA_KEY *      PDATA_KEY;

typedef CRYPT_BUFFER    CYPHER_DATA;
typedef CYPHER_DATA *   PCYPHER_DATA;



/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Lan Manager data types                                              //
//                                                                     //
/////////////////////////////////////////////////////////////////////////


//
// Define a LanManager compatible password
//
// A LanManager password is a null-terminated ansi string consisting of a
// maximum of 14 characters (not including terminator)
//

typedef CHAR *                      PLM_PASSWORD;



//
// Define the result of the 'One Way Function' (OWF) on a LM password
//

#define LM_OWF_PASSWORD_LENGTH      (CYPHER_BLOCK_LENGTH * 2)


//
// Define the challenge sent by the Lanman server during logon
//

#define LM_CHALLENGE_LENGTH         CLEAR_BLOCK_LENGTH


//
// Define the response sent by redirector in response to challenge from server
//

#define LM_RESPONSE_LENGTH          (CYPHER_BLOCK_LENGTH * 3)

typedef struct _LM_RESPONSE {
    CYPHER_BLOCK  data[3];
}                                   LM_RESPONSE;
typedef LM_RESPONSE *               PLM_RESPONSE;



//
// Define the result of the reversible encryption of an OWF'ed password.
//

#define ENCRYPTED_LM_OWF_PASSWORD_LENGTH (CYPHER_BLOCK_LENGTH * 2)

typedef struct _ENCRYPTED_LM_OWF_PASSWORD {
    CYPHER_BLOCK data[2];
}                                   ENCRYPTED_LM_OWF_PASSWORD;
typedef ENCRYPTED_LM_OWF_PASSWORD * PENCRYPTED_LM_OWF_PASSWORD;



//
// Define the session key maintained by the redirector and server
//

#define LM_SESSION_KEY_LENGTH       LM_CHALLENGE_LENGTH

typedef LM_CHALLENGE                LM_SESSION_KEY;
typedef LM_SESSION_KEY *            PLM_SESSION_KEY;



//
// Define the index type used to encrypt OWF Passwords
//

typedef LONG                        CRYPT_INDEX;
typedef CRYPT_INDEX *               PCRYPT_INDEX;



/////////////////////////////////////////////////////////////////////////
//                                                                     //
// 'NT' encryption types that are used to duplicate existing LM        //
//      functionality with improved algorithms.                        //
//                                                                     //
/////////////////////////////////////////////////////////////////////////


typedef UNICODE_STRING              NT_PASSWORD;
typedef NT_PASSWORD *               PNT_PASSWORD;


#define NT_OWF_PASSWORD_LENGTH      LM_OWF_PASSWORD_LENGTH


#define NT_CHALLENGE_LENGTH         LM_CHALLENGE_LENGTH



#define NT_RESPONSE_LENGTH          LM_RESPONSE_LENGTH

typedef LM_RESPONSE                 NT_RESPONSE;
typedef NT_RESPONSE *               PNT_RESPONSE;


#define ENCRYPTED_NT_OWF_PASSWORD_LENGTH ENCRYPTED_LM_OWF_PASSWORD_LENGTH

typedef ENCRYPTED_LM_OWF_PASSWORD   ENCRYPTED_NT_OWF_PASSWORD;
typedef ENCRYPTED_NT_OWF_PASSWORD * PENCRYPTED_NT_OWF_PASSWORD;


#define NT_SESSION_KEY_LENGTH       LM_SESSION_KEY_LENGTH

typedef LM_SESSION_KEY              NT_SESSION_KEY;
typedef NT_SESSION_KEY *            PNT_SESSION_KEY;



/////////////////////////////////////////////////////////////////////////
//                                                                     //
// 'NT' encryption types for new functionality not present in LM       //
//                                                                     //
/////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////
//                                                                        //
// Encryption library API macros                                          //
//                                                                        //
// To conceal the purpose of these functions to someone dumping out the   //
// encryption dll they have been purposefully given unhelpful names.      //
// Each has an associated macro that should be used by system components  //
// to access these routines in a readable way.                            //
//                                                                        //
////////////////////////////////////////////////////////////////////////////

#define RtlEncryptBlock                 SystemFunction001
#define RtlDecryptBlock                 SystemFunction002
#define RtlEncryptStdBlock              SystemFunction003
#define RtlEncryptData                  SystemFunction004
#define RtlDecryptData                  SystemFunction005
#define RtlCalculateLmOwfPassword       SystemFunction006
#define RtlCalculateNtOwfPassword       SystemFunction007
#define RtlCalculateLmResponse          SystemFunction008
#define RtlCalculateNtResponse          SystemFunction009
#define RtlCalculateUserSessionKeyLm    SystemFunction010
#define RtlCalculateUserSessionKeyNt    SystemFunction011
#define RtlEncryptLmOwfPwdWithLmOwfPwd  SystemFunction012
#define RtlDecryptLmOwfPwdWithLmOwfPwd  SystemFunction013
#define RtlEncryptNtOwfPwdWithNtOwfPwd  SystemFunction014
#define RtlDecryptNtOwfPwdWithNtOwfPwd  SystemFunction015
#define RtlEncryptLmOwfPwdWithLmSesKey  SystemFunction016
#define RtlDecryptLmOwfPwdWithLmSesKey  SystemFunction017
#define RtlEncryptNtOwfPwdWithNtSesKey  SystemFunction018
#define RtlDecryptNtOwfPwdWithNtSesKey  SystemFunction019
#define RtlEncryptLmOwfPwdWithUserKey   SystemFunction020
#define RtlDecryptLmOwfPwdWithUserKey   SystemFunction021
#define RtlEncryptNtOwfPwdWithUserKey   SystemFunction022
#define RtlDecryptNtOwfPwdWithUserKey   SystemFunction023
#define RtlEncryptLmOwfPwdWithIndex     SystemFunction024
#define RtlDecryptLmOwfPwdWithIndex     SystemFunction025
#define RtlEncryptNtOwfPwdWithIndex     SystemFunction026
#define RtlDecryptNtOwfPwdWithIndex     SystemFunction027
#define RtlGetUserSessionKeyClient      SystemFunction028
#define RtlGetUserSessionKeyServer      SystemFunction029
#define RtlEqualLmOwfPassword           SystemFunction030
#define RtlEqualNtOwfPassword           SystemFunction031
#define RtlEncryptData2                 SystemFunction032
#define RtlDecryptData2                 SystemFunction033
#define RtlGetUserSessionKeyClientBinding SystemFunction034
#define RtlCheckSignatureInFile         SystemFunction035

#define RtlGenRandom                    SystemFunction036
#define RtlEncryptMemory                SystemFunction040
#define RtlDecryptMemory                SystemFunction041


////////////////////////////////////////////////////////////////////////////
//                                                                        //
// Encryption library API function prototypes                             //
//                                                                        //
////////////////////////////////////////////////////////////////////////////


//
// Core block encryption functions
//

NTSTATUS 
RtlEncryptBlock(
    IN PCLEAR_BLOCK ClearBlock,
    IN PBLOCK_KEY BlockKey,
    OUT PCYPHER_BLOCK CypherBlock
    );

NTSTATUS
RtlDecryptBlock(
    IN PCYPHER_BLOCK CypherBlock,
    IN PBLOCK_KEY BlockKey,
    OUT PCLEAR_BLOCK ClearBlock
    );

NTSTATUS
RtlEncryptStdBlock(
    IN PBLOCK_KEY BlockKey,
    OUT PCYPHER_BLOCK CypherBlock
    );

//
// Arbitrary length data encryption functions
//

NTSTATUS
RtlEncryptData(
    IN PCLEAR_DATA ClearData,
    IN PDATA_KEY DataKey,
    OUT PCYPHER_DATA CypherData
    );

NTSTATUS
RtlDecryptData(
    IN PCYPHER_DATA CypherData,
    IN PDATA_KEY DataKey,
    OUT PCLEAR_DATA ClearData
    );

//
// Faster arbitrary length data encryption functions (using RC4)
//

NTSTATUS
RtlEncryptData2(
    IN OUT PCRYPT_BUFFER    pData,
    IN PDATA_KEY            pKey
    );

NTSTATUS
RtlDecryptData2(
    IN OUT PCRYPT_BUFFER    pData,
    IN PDATA_KEY            pKey
    );

//
// Password hashing functions (One Way Function)
//

NTSTATUS NTAPI
RtlCalculateLmOwfPassword(
    IN PLM_PASSWORD LmPassword,
    OUT PLM_OWF_PASSWORD LmOwfPassword
    );

NTSTATUS
RtlCalculateNtOwfPassword(
    IN PNT_PASSWORD NtPassword,
    OUT PNT_OWF_PASSWORD NtOwfPassword
    );



//
// OWF password comparison functions
//

BOOLEAN
RtlEqualLmOwfPassword(
    IN PLM_OWF_PASSWORD LmOwfPassword1,
    IN PLM_OWF_PASSWORD LmOwfPassword2
    );

BOOLEAN
RtlEqualNtOwfPassword(
    IN PNT_OWF_PASSWORD NtOwfPassword1,
    IN PNT_OWF_PASSWORD NtOwfPassword2
    );



//
// Functions for calculating response to server challenge
//

NTSTATUS
RtlCalculateLmResponse(
    IN PLM_CHALLENGE LmChallenge,
    IN PLM_OWF_PASSWORD LmOwfPassword,
    OUT PLM_RESPONSE LmResponse
    );


NTSTATUS
RtlCalculateNtResponse(
    IN PNT_CHALLENGE NtChallenge,
    IN PNT_OWF_PASSWORD NtOwfPassword,
    OUT PNT_RESPONSE NtResponse
    );




//
// Functions for calculating User Session Key.
//

//
// Calculate a User Session Key from LM data
//
NTSTATUS
RtlCalculateUserSessionKeyLm(
    IN PLM_RESPONSE LmResponse,
    IN PLM_OWF_PASSWORD LmOwfPassword,
    OUT PUSER_SESSION_KEY UserSessionKey
    );

//
// Calculate a User Session Key from NT data
//
NTSTATUS
RtlCalculateUserSessionKeyNt(
    IN PNT_RESPONSE NtResponse,
    IN PNT_OWF_PASSWORD NtOwfPassword,
    OUT PUSER_SESSION_KEY UserSessionKey
    );





//
// OwfPassword encryption functions
//


//
// Encrypt OwfPassword using OwfPassword as the key
//
NTSTATUS
RtlEncryptLmOwfPwdWithLmOwfPwd(
    IN PLM_OWF_PASSWORD DataLmOwfPassword,
    IN PLM_OWF_PASSWORD KeyLmOwfPassword,
    OUT PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword
    );

NTSTATUS
RtlDecryptLmOwfPwdWithLmOwfPwd(
    IN PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword,
    IN PLM_OWF_PASSWORD KeyLmOwfPassword,
    OUT PLM_OWF_PASSWORD DataLmOwfPassword
    );


NTSTATUS
RtlEncryptNtOwfPwdWithNtOwfPwd(
    IN PNT_OWF_PASSWORD DataNtOwfPassword,
    IN PNT_OWF_PASSWORD KeyNtOwfPassword,
    OUT PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword
    );

NTSTATUS
RtlDecryptNtOwfPwdWithNtOwfPwd(
    IN PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword,
    IN PNT_OWF_PASSWORD KeyNtOwfPassword,
    OUT PNT_OWF_PASSWORD DataNtOwfPassword
    );


//
// Encrypt OwfPassword using SessionKey as the key
//
NTSTATUS
RtlEncryptLmOwfPwdWithLmSesKey(
    IN PLM_OWF_PASSWORD LmOwfPassword,
    IN PLM_SESSION_KEY LmSessionKey,
    OUT PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword
    );

NTSTATUS
RtlDecryptLmOwfPwdWithLmSesKey(
    IN PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword,
    IN PLM_SESSION_KEY LmSessionKey,
    OUT PLM_OWF_PASSWORD LmOwfPassword
    );


NTSTATUS
RtlEncryptNtOwfPwdWithNtSesKey(
    IN PNT_OWF_PASSWORD NtOwfPassword,
    IN PNT_SESSION_KEY NtSessionKey,
    OUT PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword
    );

NTSTATUS
RtlDecryptNtOwfPwdWithNtSesKey(
    IN PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword,
    IN PNT_SESSION_KEY NtSessionKey,
    OUT PNT_OWF_PASSWORD NtOwfPassword
    );


//
// Encrypt OwfPassword using UserSessionKey as the key
//
NTSTATUS
RtlEncryptLmOwfPwdWithUserKey(
    IN PLM_OWF_PASSWORD LmOwfPassword,
    IN PUSER_SESSION_KEY UserSessionKey,
    OUT PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword
    );

NTSTATUS
RtlDecryptLmOwfPwdWithUserKey(
    IN PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword,
    IN PUSER_SESSION_KEY UserSessionKey,
    OUT PLM_OWF_PASSWORD LmOwfPassword
    );

NTSTATUS
RtlEncryptNtOwfPwdWithUserKey(
    IN PNT_OWF_PASSWORD NtOwfPassword,
    IN PUSER_SESSION_KEY UserSessionKey,
    OUT PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword
    );

NTSTATUS
RtlDecryptNtOwfPwdWithUserKey(
    IN PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword,
    IN PUSER_SESSION_KEY UserSessionKey,
    OUT PNT_OWF_PASSWORD NtOwfPassword
    );


//
// Encrypt OwfPassword using an index as the key
//
NTSTATUS
RtlEncryptLmOwfPwdWithIndex(
    IN PLM_OWF_PASSWORD LmOwfPassword,
    IN PCRYPT_INDEX Index,
    OUT PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword
    );

NTSTATUS
RtlDecryptLmOwfPwdWithIndex(
    IN PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword,
    IN PCRYPT_INDEX Index,
    OUT PLM_OWF_PASSWORD LmOwfPassword
    );


NTSTATUS
RtlEncryptNtOwfPwdWithIndex(
    IN PNT_OWF_PASSWORD NtOwfPassword,
    IN PCRYPT_INDEX Index,
    OUT PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword
    );

NTSTATUS
RtlDecryptNtOwfPwdWithIndex(
    IN PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword,
    IN PCRYPT_INDEX Index,
    OUT PNT_OWF_PASSWORD NtOwfPassword
    );

ULONG
RtlCheckSignatureInFile(
    IN PWSTR File
    );

BOOLEAN
RtlGenRandom(
    OUT PVOID RandomBuffer,
    IN  ULONG RandomBufferLength
    );


//
// The buffer passed into RtlEncryptMemory and RtlDecryptMemory
// must be a multiple of this length.
//

#define RTL_ENCRYPT_MEMORY_SIZE 8

//
// Allow Encrypt/Decrypt across process boundaries.
// eg: encrypted buffer passed across LPC to another process which calls RtlDecryptMemory.
//

#define RTL_ENCRYPT_OPTION_CROSS_PROCESS    0x01


NTSTATUS
RtlEncryptMemory(
    IN OUT  PVOID Memory,
    IN      ULONG MemoryLength,
    IN      ULONG OptionFlags
    );

NTSTATUS
RtlDecryptMemory(
    IN OUT  PVOID Memory,
    IN      ULONG MemoryLength,
    IN      ULONG OptionFlags
    );


//
// Get the user session key for an RPC connection
//

#ifndef MIDL_PASS    // Don't confuse MIDL
NTSTATUS
RtlGetUserSessionKeyClient(
    IN PVOID RpcContextHandle,
    OUT PUSER_SESSION_KEY UserSessionKey
    );

NTSTATUS
RtlGetUserSessionKeyClientBinding(
    IN PVOID RpcBindingHandle,
    OUT HANDLE *RedirHandle,
    OUT PUSER_SESSION_KEY UserSessionKey
    );

NTSTATUS
RtlGetUserSessionKeyServer(
    IN PVOID RpcContextHandle OPTIONAL,
    OUT PUSER_SESSION_KEY UserSessionKey
    );
#endif // MIDL_PASS

#ifdef __cplusplus
}   // extern "C"
#endif

#endif // _NTCRYPT_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\inc\dsysdbg.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       dsysdbg.h
//
//  Contents:   Merged all the debug code together
//
//  Classes:
//
//  Functions:
//
//  History:    3-14-95   RichardW   Created
//
//----------------------------------------------------------------------------

#ifndef __DSYSDBG_H__
#define __DSYSDBG_H__

#ifdef __cplusplus
extern "C" {
#endif

#include <stdarg.h>

typedef struct _DEBUG_KEY {
    DWORD   Mask;
    PCHAR   Tag;
} DEBUG_KEY, * PDEBUG_KEY;

#define DSYSDBG_OPEN_ONLY       0x00000001
#define DSYSDBG_DEMAND_OPEN     0x00000002
#define DSYSDBG_BREAK_ON_ERROR  0x00000004

#define DSYSDBG_ASSERT_CONTINUE 0
#define DSYSDBG_ASSERT_BREAK    1
#define DSYSDBG_ASSERT_SUSPEND  2
#define DSYSDBG_ASSERT_PROMPT   4
#define DSYSDBG_ASSERT_DEBUGGER 5

//
// Global Flags exposed to callers:
//

#define DEBUG_HEAP_CHECK    0x00000040      // Check Heap on every debug out
#define DEBUG_MULTI_THREAD  0x00000080      // Use critical section in header
#define DEBUG_BREAK_ON_ERROR 0x00000400     // Break on an error out

VOID    _DsysAssertEx(PVOID FailedAssertion, PVOID FileName, ULONG LineNumber,
                        PCHAR Message, ULONG ContinueCode);
VOID    _DebugOut(PVOID pControl, ULONG Mask, CHAR * Format, va_list ArgList);
VOID    _InitDebug(DWORD Flags, DWORD * InfoLevel, PVOID * Control, char * ModuleName, PDEBUG_KEY pKey);
VOID    _UnloadDebug( PVOID pControl );
VOID    _DbgSetOption(PVOID pControl, DWORD Flag, BOOL On, BOOL Global);
VOID    _DbgSetLoggingOption(PVOID pControl, BOOL On);
VOID    DbgpDumpException(PVOID p);

//  Hack to allow retail builds to include debug support
//  define RETAIL_LOG_SUPPORT in your sources to do it!
#ifdef RETAIL_LOG_SUPPORT
#define DEBUG_SUPPORT
#else
#if DBG
#define DEBUG_SUPPORT
#endif
#endif


#ifdef DEBUG_SUPPORT
//
// Use this in your header file.  It declares the variables that we need
//

#define DECLARE_DEBUG2(comp)                                \
extern PVOID    comp##ControlBlock;                         \
extern DWORD    comp##InfoLevel;                            \
void   comp##DebugPrint(ULONG Mask, CHAR * Format, ... );   \

//
// Use this when you control when you are initialized, for example a DLL or
// EXE.  This defines the wrapper functions that will call into dsysdbg.lib
//

#define DEFINE_DEBUG2(comp)                                 \
PVOID   comp##ControlBlock = NULL ;                         \
DWORD   comp##InfoLevel;                                    \
PVOID   comp##__DebugKeys;                                  \
void comp##DebugPrint(                                      \
    ULONG Mask,                                             \
    CHAR * Format,                                          \
    ... )                                                   \
{                                                           \
    va_list ArgList;                                        \
    va_start(ArgList, Format);                              \
    _DebugOut( comp##ControlBlock, Mask, Format, ArgList);  \
}                                                           \
void                                                        \
comp##InitDebugEx(DWORD Flags, PDEBUG_KEY pKey)             \
{                                                           \
    comp##__DebugKeys = pKey;                               \
    _InitDebug(Flags, & comp##InfoLevel, & comp##ControlBlock, #comp, pKey); \
}                                                           \
void                                                        \
comp##InitDebug(PDEBUG_KEY  pKey)                           \
{                                                           \
    _InitDebug(0, & comp##InfoLevel, & comp##ControlBlock, #comp, pKey); \
}                                                           \
void                                                        \
comp##SetOption(DWORD Option, BOOL On, BOOL Global)         \
{                                                           \
    _DbgSetOption( comp##ControlBlock, Option, On, Global); \
}                                                           \
void                                                        \
comp##SetLoggingOption(BOOL On)                             \
{                                                           \
   _DbgSetLoggingOption(comp##ControlBlock, On);            \
}                                                           \
void                                                        \
comp##UnloadDebug(void)                                     \
{                                                           \
    _UnloadDebug( comp##ControlBlock );                     \
    comp##ControlBlock = NULL ;                             \
}


//
// Use this when you don't control when you are initialized, e.g. a static
// library like the gluon code.
//
#define DEFINE_DEBUG_DEFER(comp,keys)                       \
PVOID       comp##ControlBlock = INVALID_HANDLE_VALUE;      \
DWORD       comp##InfoLevel;                    \
PDEBUG_KEY  comp##__DebugKeys = keys;                       \
void comp##DebugPrint(                                      \
    ULONG Mask,                                             \
    CHAR * Format,                                          \
    ... )                                                   \
{                                                           \
    va_list ArgList;                                        \
    va_start(ArgList, Format);                              \
    if (comp##ControlBlock == INVALID_HANDLE_VALUE)         \
    {                                                       \
        _InitDebug(DSYSDBG_DEMAND_OPEN, & comp##InfoLevel, & comp##ControlBlock, #comp, comp##__DebugKeys); \
    }                                                       \
    _DebugOut( comp##ControlBlock, Mask, Format, ArgList);  \
}                                                           \
void                                                        \
comp##InitDebugEx(DWORD Flags, PDEBUG_KEY pKey)             \
{                                                           \
    comp##__DebugKeys = pKey;                               \
    _InitDebug(Flags, & comp##InfoLevel, & comp##ControlBlock, #comp, pKey); \
}                                                           \
void                                                        \
comp##InitDebug(PDEBUG_KEY  pKey)                           \
{                                                           \
    _InitDebug(DSYSDBG_DEMAND_OPEN, & comp##InfoLevel, & comp##ControlBlock, #comp, pKey); \
}                                                           \
void                                                        \
comp##UnloadDebug(void)                                     \
{                                                           \
    _UnloadDebug( comp##ControlBlock );                     \
}


#else   // NOT DEBUG_SUPPORT

//
// Empty defines for the retail case:
//
#define DECLARE_DEBUG2(comp)

#define DEFINE_DEBUG2(comp)

#define DEFINE_DEBUG_DEFER(x, y)


#endif // DEBUG_SUPPORT 



#if DBG
//
// Moved assertions to new section, so no asserts occur in retail builds
// with DEBUG_SUPPORT. 
//
// Assertions:  Most should use DsysAssert or DsysAssertMsg.  These forward on
// the call to dsysdbg.lib, with the continue code set to drop into the
// debugger.  The more sophisticated can call DsysAssertEx, which allows you
// to specify one of the assert codes from above:
//

#define DsysAssertEx(exp, ContinueCode) \
            if (!(exp)) \
                _DsysAssertEx( #exp, __FILE__, __LINE__, NULL, ContinueCode);

#define DsysAssertMsgEx(exp, Message, ContinueCode) \
            if (!(exp)) \
                _DsysAssertEx( #exp, __FILE__, __LINE__, Message, ContinueCode);

#define DsysAssertMsg(exp, Message) DsysAssertMsgEx(exp, Message, DSYSDBG_ASSERT_DEBUGGER)


#define DsysAssert(exp) DsysAssertMsgEx(exp, NULL, DSYSDBG_ASSERT_DEBUGGER)

#define DsysException(p)    DbgpDumpException(p)

#define SZ_DEFAULT_PROFILE_STRING   "Error"         

#else // retail builds cannot contain asserts...


#define DsysAssertEx(x,y)
#define DsysAssertMsgEx(x, y, z)
#define DsysAssert(x)
#define DsysAssertMsg(x, y)

#define DsysException(p)

#define SZ_DEFAULT_PROFILE_STRING   ""

#endif // dbg


#ifndef DEB_ERROR
#define DEB_ERROR   0x00000001
#endif

#ifndef DEB_WARN
#define DEB_WARN    0x00000002
#endif

#ifndef DEB_TRACE
#define DEB_TRACE   0x00000004
#endif

#define DSYSDBG_FORCE   0x80000000
#define DSYSDBG_CLEAN   0x40000000


#ifdef __cplusplus
}
#endif // __cplusplus

#endif // __DSYSDBG_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\inc\cryptdll.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:        cryptdll.h
//
// Contents:    How to use the crypt support dll
//
//
// History:     04 Jun 92   RichardW    Created
//
//------------------------------------------------------------------------

#ifndef __CRYPTDLL_H__
#define __CRYPTDLL_H__

typedef PVOID   PCRYPT_STATE_BUFFER;

typedef NTSTATUS (NTAPI * PCRYPT_INITIALIZE_FN)(
    PUCHAR,
    ULONG,
    ULONG,
    PCRYPT_STATE_BUFFER *
    );

typedef NTSTATUS (NTAPI * PCRYPT_ENCRYPT_FN)(
    PCRYPT_STATE_BUFFER StateBuffer,
    PUCHAR InputBuffer,
    ULONG InputBufferSize,
    PUCHAR OutputBuffer,
    PULONG OutputBufferSize
    );

typedef NTSTATUS (NTAPI * PCRYPT_DECRYPT_FN)(
    PCRYPT_STATE_BUFFER StateBuffer,
    PUCHAR InputBuffer,
    ULONG InputBufferSize,
    PUCHAR OutputBuffer,
    PULONG OutputBufferSize
    );

typedef NTSTATUS (NTAPI * PCRYPT_DISCARD_FN)(
    PCRYPT_STATE_BUFFER *
    );

typedef NTSTATUS (NTAPI * PCRYPT_HASH_STRING_FN)(
    PUNICODE_STRING String,
    PUCHAR Buffer
    );
typedef NTSTATUS (NTAPI * PCRYPT_RANDOM_KEY_FN)(
    OPTIONAL PUCHAR Seed,
    OPTIONAL ULONG SeedLength,
    PUCHAR Key
    );

typedef NTSTATUS (NTAPI * PCRYPT_CONTROL_FN)(
    IN ULONG Function,
    IN PCRYPT_STATE_BUFFER StateBuffer,
    IN PUCHAR InputBuffer,
    IN ULONG InputBufferSize
    );

//
// functions for CryptControl
#define CRYPT_CONTROL_SET_INIT_VECT     0x1


typedef struct _CRYPTO_SYSTEM {
    ULONG EncryptionType;
    ULONG BlockSize;
    ULONG ExportableEncryptionType;
    ULONG KeySize;
    ULONG HeaderSize;
    ULONG PreferredCheckSum;
    ULONG Attributes;
    PWSTR Name;
    PCRYPT_INITIALIZE_FN Initialize;
    PCRYPT_ENCRYPT_FN Encrypt;
    PCRYPT_DECRYPT_FN Decrypt;
    PCRYPT_DISCARD_FN Discard;
    PCRYPT_HASH_STRING_FN HashString;
    PCRYPT_RANDOM_KEY_FN RandomKey;
    PCRYPT_CONTROL_FN Control;
} CRYPTO_SYSTEM, *PCRYPTO_SYSTEM;

#define CSYSTEM_USE_PRINCIPAL_NAME      0x01
#define CSYSTEM_EXPORT_STRENGTH         0x02
#define CSYSTEM_INTEGRITY_PROTECTED     0x04

NTSTATUS NTAPI
CDRegisterCSystem(PCRYPTO_SYSTEM);

NTSTATUS NTAPI
CDBuildVect(
    PULONG EncryptionTypesAvailable,
    PULONG EncryptionTypes
    );

NTSTATUS NTAPI
CDBuildIntegrityVect(
    PULONG      pcCSystems,
    PULONG      pdwEtypes
    );


NTSTATUS NTAPI
CDLocateCSystem(
    ULONG EncryptionType,
    PCRYPTO_SYSTEM * CryptoSystem
    );


NTSTATUS NTAPI
CDFindCommonCSystem(
    ULONG EncryptionTypeCount,
    PULONG EncryptionTypes,
    PULONG CommonEncryptionType
    );

NTSTATUS NTAPI
CDFindCommonCSystemWithKey(
    IN ULONG EncryptionEntries,
    IN PULONG EncryptionTypes,
    IN ULONG KeyTypeCount,
    IN PULONG KeyTypes,
    OUT PULONG CommonEtype
    );



////////////////////////////////////////////////////////////////////

typedef PVOID PCHECKSUM_BUFFER;

typedef NTSTATUS (NTAPI * PCHECKSUM_INITIALIZE_FN)(ULONG, PCHECKSUM_BUFFER *);
typedef NTSTATUS (NTAPI * PCHECKSUM_INITIALIZEEX_FN)(PUCHAR,ULONG, ULONG, PCHECKSUM_BUFFER *);
// add the ex2 function to allow the checksum to be passed in for verification
// this is passed in the 4th parameter
// this is necessary for checksums which use confounders, where the confounder must
// be pulled from the checksum in order to calculate a new checksum when verifying
typedef NTSTATUS (NTAPI * PCHECKSUM_INITIALIZEEX2_FN)(PUCHAR, ULONG, PUCHAR, ULONG, PCHECKSUM_BUFFER *);
typedef NTSTATUS (NTAPI * PCHECKSUM_SUM_FN)(PCHECKSUM_BUFFER, ULONG, PUCHAR);
typedef NTSTATUS (NTAPI * PCHECKSUM_FINALIZE_FN)(PCHECKSUM_BUFFER, PUCHAR);
typedef NTSTATUS (NTAPI * PCHECKSUM_FINISH_FN)(PCHECKSUM_BUFFER *);

typedef struct _CHECKSUM_FUNCTION {
    ULONG CheckSumType;
    ULONG CheckSumSize;
    ULONG Attributes;
    PCHECKSUM_INITIALIZE_FN Initialize;
    PCHECKSUM_SUM_FN Sum;
    PCHECKSUM_FINALIZE_FN Finalize;
    PCHECKSUM_FINISH_FN Finish;
    PCHECKSUM_INITIALIZEEX_FN InitializeEx;
    PCHECKSUM_INITIALIZEEX2_FN InitializeEx2;  // allows passing in the checksum on intialization for verification 
} CHECKSUM_FUNCTION, *PCHECKSUM_FUNCTION;

#define CKSUM_COLLISION     0x00000001
#define CKSUM_KEYED         0x00000002


#define CHECKSUM_SHA1       131

NTSTATUS NTAPI
CDRegisterCheckSum( PCHECKSUM_FUNCTION);


NTSTATUS NTAPI
CDLocateCheckSum( ULONG, PCHECKSUM_FUNCTION *);



//////////////////////////////////////////////////////////////



typedef BOOLEAN (NTAPI * PRANDOM_NUMBER_GENERATOR_FN)(PUCHAR, ULONG);


typedef struct _RANDOM_NUMBER_GENERATOR {
    ULONG GeneratorId;
    ULONG Attributes;
    ULONG Seed;
    PRANDOM_NUMBER_GENERATOR_FN GenerateBitstream;
} RANDOM_NUMBER_GENERATOR, *PRANDOM_NUMBER_GENERATOR;

#define RNG_PSEUDO_RANDOM   0x00000001  // Pseudo-random function
#define RNG_NOISE_CIRCUIT   0x00000002  // Noise circuit (ZNR diode, eg)
#define RNG_NATURAL_PHENOM  0x00000004  // Natural sampler (geiger counter)

BOOLEAN NTAPI
CDGenerateRandomBits(PUCHAR pBuffer,
                     ULONG  cbBuffer);

BOOLEAN NTAPI
CDRegisterRng(PRANDOM_NUMBER_GENERATOR    pRng);

BOOLEAN NTAPI
CDLocateRng(ULONG                       Id,
            PRANDOM_NUMBER_GENERATOR *    ppRng);

#define CD_BUILTIN_RNG  1


///////////////////////////////////////////////////////////
//
// Error codes
//
///////////////////////////////////////////////////////////


#define SEC_E_ETYPE_NOT_SUPP            0x80080341
#define SEC_E_CHECKSUM_NOT_SUPP         0x80080342
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\inc\msasn1.h ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation 1997-1998, All rights reserved. */

#ifndef __MS_ASN1_H__
#define __MS_ASN1_H__

#include <pshpack8.h> /* Assume 8 byte packing throughout */

#ifdef __cplusplus
extern "C" {
#endif

/* ------ Basic integer types ------ */

typedef unsigned char   ASN1uint8_t;
typedef signed char     ASN1int8_t;

typedef unsigned short  ASN1uint16_t;
typedef signed short    ASN1int16_t;

typedef unsigned long   ASN1uint32_t;
typedef signed long     ASN1int32_t;


/* ------ Function modifiers ------ */

#ifdef ASN1LIB
#define ASN1_PUBLIC
#elif defined(ASN1C)
#define ASN1_PUBLIC
#else
#define ASN1_PUBLIC     __declspec(dllimport)
#endif
#define ASN1API         __stdcall
#define ASN1CALL        __stdcall


/* ------ Basic ASN.1 types ------ */

typedef ASN1uint8_t ASN1octet_t;

typedef ASN1uint8_t ASN1bool_t;

typedef struct tagASN1intx_t
{
    ASN1uint32_t length;
    ASN1octet_t *value;
}
    ASN1intx_t;

typedef struct tagASN1octetstring_t
{
    ASN1uint32_t length;
    ASN1octet_t *value;
}
    ASN1octetstring_t;

typedef struct tagASN1octetstring2_t
{
    ASN1uint32_t length;
    ASN1octet_t value[1];
}
    ASN1octetstring2_t;

typedef struct ASN1iterator_s
{
    struct ASN1iterator_s *next;
    void *value;
}
    ASN1iterator_t;

typedef struct tagASN1bitstring_t
{
    ASN1uint32_t length;
    ASN1octet_t *value;
}
    ASN1bitstring_t;

typedef char ASN1char_t;

typedef struct tagASN1charstring_t
{
    ASN1uint32_t length;
    ASN1char_t *value;
}
    ASN1charstring_t;

typedef ASN1uint16_t ASN1char16_t;

typedef struct tagASN1char16string_t
{
    ASN1uint32_t length;
    ASN1char16_t *value;
}
    ASN1char16string_t;

typedef ASN1uint32_t ASN1char32_t;

typedef struct tagASN1char32string_t
{
    ASN1uint32_t length;
    ASN1char32_t *value;
}
    ASN1char32string_t;

typedef ASN1char_t *ASN1ztcharstring_t;
typedef ASN1char16_t *ASN1ztchar16string_t;
typedef ASN1char32_t *ASN1ztchar32string_t;

typedef struct tagASN1wstring_t
{
    ASN1uint32_t length;
    WCHAR *value;
}
    ASN1wstring_t;

typedef struct ASN1objectidentifier_s
{
    struct ASN1objectidentifier_s *next;
    ASN1uint32_t value;
}
    *ASN1objectidentifier_t;

typedef struct tagASN1objectidentifier2_t
{
    ASN1uint16_t count;
    ASN1uint32_t value[16];
}
    ASN1objectidentifier2_t;

typedef struct tagASN1encodedOID_t
{
    ASN1uint16_t length;
    ASN1octet_t  *value;
}
    ASN1encodedOID_t;

typedef struct tagASN1stringtableentry_t
{
    ASN1char32_t lower;
    ASN1char32_t upper;
    ASN1uint32_t value;
}
    ASN1stringtableentry_t;

typedef struct tagASN1stringtable_t
{
    ASN1uint32_t length;
    ASN1stringtableentry_t *values;
}
    ASN1stringtable_t;

typedef ASN1ztcharstring_t ASN1objectdescriptor_t;

typedef struct tagASN1generalizedtime_t
{
    ASN1uint16_t year;
    ASN1uint8_t month;
    ASN1uint8_t day;
    ASN1uint8_t hour;
    ASN1uint8_t minute;
    ASN1uint8_t second;
    ASN1uint16_t millisecond;
    ASN1bool_t universal;
    ASN1int16_t diff;
}
    ASN1generalizedtime_t;

typedef struct tagASN1utctime_t
{
    ASN1uint8_t year;
    ASN1uint8_t month;
    ASN1uint8_t day;
    ASN1uint8_t hour;
    ASN1uint8_t minute;
    ASN1uint8_t second;
    ASN1bool_t universal;
    ASN1int16_t diff;
}
    ASN1utctime_t;

typedef struct tagASN1open_t
{
    // encoded
    ASN1uint32_t    length;
    union
    {
        void           *encoded;
        void           *value;
    };
}
    ASN1open_t;

typedef enum tagASN1blocktype_e
{
    ASN1_DER_SET_OF_BLOCK,
}
    ASN1blocktype_e;

typedef ASN1int32_t     ASN1enum_t;     // enumerated type

typedef ASN1uint16_t    ASN1choice_t;   // choice

typedef ASN1uint32_t    ASN1magic_t;

/* ------ Current version of this ASN.1 software ------ */

#define ASN1_MAKE_VERSION(major,minor)  (((major) << 16) | (minor))
#define ASN1_THIS_VERSION               ASN1_MAKE_VERSION(1,0)

enum
{
    ASN1_CHOICE_BASE      = 1,
    ASN1_CHOICE_INVALID   = -1,     // invalid choice
    ASN1_CHOICE_EXTENSION = 0,      // extension choice
};



/*
   Error codes for decoding functions:
   - err == 0:    data has been successfully decoded
   - err <  0:    fatal error has occured, no data has been generated
                  err contains the error number
   - err >  0:    non-fatal event has occured, data has been generated
                  err is a bit set of occured events
 */

typedef enum tagASN1error_e
{
    ASN1_SUCCESS        = 0,            /* success */

    // Teles specific error codes
    ASN1_ERR_INTERNAL   = (-1001),      /* internal error */
    ASN1_ERR_EOD        = (-1002),      /* unexpected end of data */
    ASN1_ERR_CORRUPT    = (-1003),      /* corrupted data */
    ASN1_ERR_LARGE      = (-1004),      /* value too large */
    ASN1_ERR_CONSTRAINT = (-1005),      /* constraint violated */
    ASN1_ERR_MEMORY     = (-1006),      /* out of memory */
    ASN1_ERR_OVERFLOW   = (-1007),      /* buffer overflow */
    ASN1_ERR_BADPDU     = (-1008),      /* function not supported for this pdu*/
    ASN1_ERR_BADARGS    = (-1009),      /* bad arguments to function call */
    ASN1_ERR_BADREAL    = (-1010),      /* bad real value */
    ASN1_ERR_BADTAG     = (-1011),      /* bad tag value met */
    ASN1_ERR_CHOICE     = (-1012),      /* bad choice value */
    ASN1_ERR_RULE       = (-1013),      /* bad encoding rule */
    ASN1_ERR_UTF8       = (-1014),      /* bad unicode (utf8) */

    // New error codes
    ASN1_ERR_PDU_TYPE   = (-1051),      /* bad pdu type */
    ASN1_ERR_NYI        = (-1052),      /* not yet implemented */

    // Teles specific warning codes
    ASN1_WRN_EXTENDED   = 1001,         /* skipped unknown extension(s) */
    ASN1_WRN_NOEOD      = 1002,         /* end of data expected */
}
    ASN1error_e;

#define ASN1_SUCCEEDED(ret)     (((int) (ret)) >= 0)
#define ASN1_FAILED(ret)        (((int) (ret)) < 0)


/* ------ Encoding rules ------ */

typedef enum
{
    ASN1_PER_RULE_ALIGNED       = 0x0001,
    ASN1_PER_RULE_UNALIGNED     = 0x0002, // not supported
    ASN1_PER_RULE               = ASN1_PER_RULE_ALIGNED | ASN1_PER_RULE_UNALIGNED,

    ASN1_BER_RULE_BER           = 0x0100,
    ASN1_BER_RULE_CER           = 0x0200,
    ASN1_BER_RULE_DER           = 0x0400,
    ASN1_BER_RULE               = ASN1_BER_RULE_BER | ASN1_BER_RULE_CER | ASN1_BER_RULE_DER,
}
    ASN1encodingrule_e;

/* ------ public structures ------ */

typedef struct ASN1encoding_s   *ASN1encoding_t;
typedef struct ASN1decoding_s   *ASN1decoding_t;

typedef ASN1int32_t (ASN1CALL *ASN1PerEncFun_t)(ASN1encoding_t enc, void *data);
typedef ASN1int32_t (ASN1CALL *ASN1PerDecFun_t)(ASN1decoding_t enc, void *data);
typedef struct tagASN1PerFunArr_t
{
    const ASN1PerEncFun_t *apfnEncoder;
    const ASN1PerDecFun_t *apfnDecoder;
}
    ASN1PerFunArr_t;

typedef ASN1int32_t (ASN1CALL *ASN1BerEncFun_t)(ASN1encoding_t enc, ASN1uint32_t tag, void *data);
typedef ASN1int32_t (ASN1CALL *ASN1BerDecFun_t)(ASN1decoding_t enc, ASN1uint32_t tag, void *data);
typedef struct tagASN1BerFunArr_t
{
    const ASN1BerEncFun_t *apfnEncoder;
    const ASN1BerDecFun_t *apfnDecoder;
}
    ASN1BerFunArr_t;

typedef void (ASN1CALL *ASN1GenericFun_t)(void);
typedef void (ASN1CALL *ASN1FreeFun_t)(void *data);

typedef struct tagASN1module_t
{
    ASN1magic_t             nModuleName;
    ASN1encodingrule_e      eRule;
    ASN1uint32_t            dwFlags;
    ASN1uint32_t            cPDUs;

    const ASN1FreeFun_t    *apfnFreeMemory;
    const ASN1uint32_t     *acbStructSize;
    union
    {
        ASN1PerFunArr_t     PER;
        ASN1BerFunArr_t     BER;
    };
}
    *ASN1module_t;


struct ASN1encoding_s
{
    ASN1magic_t         magic;  /* magic for this structure */
    ASN1uint32_t        version;/* version number of this library */
    ASN1module_t        module; /* module this encoding_t depends to */
    ASN1octet_t        *buf;    /* buffer to encode into */
    ASN1uint32_t        size;   /* current size of buffer */
    ASN1uint32_t        len;    /* len of encoded data in buffer */
    ASN1error_e         err;    /* error code for last encoding */
    ASN1uint32_t        bit;
    ASN1octet_t        *pos;
    ASN1uint32_t        cbExtraHeader;
    ASN1encodingrule_e  eRule;
    ASN1uint32_t        dwFlags;
};

struct ASN1decoding_s
{
    ASN1magic_t         magic;  /* magic for this structure */
    ASN1uint32_t        version;/* version number of this library */
    ASN1module_t        module; /* module this decoding_t depends to */
    ASN1octet_t        *buf;    /* buffer to decode from */
    ASN1uint32_t        size;   /* size of buffer */
    ASN1uint32_t        len;    /* len of decoded data in buffer */
    ASN1error_e         err;    /* error code for last decoding */
    ASN1uint32_t        bit;
    ASN1octet_t        *pos;
    ASN1encodingrule_e  eRule;
    ASN1uint32_t        dwFlags;
};


/* --- flags for functions --- */

#define ASN1DECFREE_NON_PDU_ID    ((ASN1uint32_t) -1)

enum
{
    ASN1FLAGS_NONE              = 0x00000000L, /* no flags */
    ASN1FLAGS_NOASSERT          = 0x00001000L, /* no asertion */
};

enum
{
    ASN1ENCODE_APPEND           = 0x00000001L, /* append to current buffer*/
    ASN1ENCODE_REUSEBUFFER      = 0x00000004L, /* empty destination buffer */
    ASN1ENCODE_SETBUFFER        = 0x00000008L, /* use a user-given destination buffer */
    ASN1ENCODE_ALLOCATEBUFFER   = 0x00000010L, /* do not free/reuse buffer */
    ASN1ENCODE_NOASSERT         = ASN1FLAGS_NOASSERT, /* no asertion */
};

enum
{
    ASN1DECODE_APPENDED         = 0x00000001L, /* continue behind last pdu*/
    ASN1DECODE_REWINDBUFFER     = 0x00000004L, /* rescan from buffer start*/
    ASN1DECODE_SETBUFFER        = 0x00000008L, /* use a user-given src buffer */
    ASN1DECODE_AUTOFREEBUFFER   = 0x00000010L, /* Assume responsibility for allocated buffer */
    ASN1DECODE_NOASSERT         = ASN1FLAGS_NOASSERT, /* no asertion */
};

/* ------ public basic ASN.1 API ------ */

extern ASN1_PUBLIC ASN1module_t ASN1API ASN1_CreateModule
(
    ASN1uint32_t            nVersion,
    ASN1encodingrule_e      eRule,
    ASN1uint32_t            dwFlags, /* ASN1FLAGS_NONE or ASN1FLAGS_NOASSERT */
    ASN1uint32_t            cPDU,
    const ASN1GenericFun_t  apfnEncoder[],
    const ASN1GenericFun_t  apfnDecoder[],
    const ASN1FreeFun_t     apfnFreeMemory[],
    const ASN1uint32_t      acbStructSize[],
    ASN1magic_t             nModuleName
);

extern ASN1_PUBLIC void ASN1API ASN1_CloseModule
(
    ASN1module_t        pModule
);

extern ASN1_PUBLIC ASN1error_e ASN1API ASN1_CreateEncoder
(
    ASN1module_t        pModule,
    ASN1encoding_t     *ppEncoderInfo,
    ASN1octet_t        *pbBuf,
    ASN1uint32_t        cbBufSize,
    ASN1encoding_t      pParent
);

extern ASN1_PUBLIC ASN1error_e ASN1API ASN1_Encode
(
    ASN1encoding_t      pEncoderInfo,
    void               *pDataStruct,
    ASN1uint32_t        nPduNum,
    ASN1uint32_t        dwFlags,
    ASN1octet_t        *pbBuf,
    ASN1uint32_t        cbBufSize
);

extern ASN1_PUBLIC void ASN1API ASN1_CloseEncoder
(
    ASN1encoding_t      pEncoderInfo
);

extern ASN1_PUBLIC void ASN1API ASN1_CloseEncoder2
(
    ASN1encoding_t      pEncoderInfo
);

extern ASN1_PUBLIC ASN1error_e ASN1API ASN1_CreateDecoder
(
    ASN1module_t        pModule,
    ASN1decoding_t     *ppDecoderInfo,
    ASN1octet_t        *pbBuf,
    ASN1uint32_t        cbBufSize,
    ASN1decoding_t      pParent
);

extern ASN1_PUBLIC ASN1error_e ASN1API ASN1_CreateDecoderEx
(
    ASN1module_t        pModule,
    ASN1decoding_t     *ppDecoderInfo,
    ASN1octet_t        *pbBuf,
    ASN1uint32_t        cbBufSize,
    ASN1decoding_t      pParent,
    ASN1uint32_t        dwFlags
);

extern ASN1_PUBLIC ASN1error_e ASN1API ASN1_Decode
(
    ASN1decoding_t      pDecoderInfo,
    void              **ppDataStruct,
    ASN1uint32_t        nPduNum,
    ASN1uint32_t        dwFlags,
    ASN1octet_t        *pbBuf,
    ASN1uint32_t        cbBufSize
);

extern ASN1_PUBLIC void ASN1API ASN1_CloseDecoder
(
    ASN1decoding_t      pDecoderInfo
);


extern ASN1_PUBLIC void ASN1API ASN1_FreeEncoded
(
    ASN1encoding_t      pEncoderInfo,
    void               *pBuf
);

extern ASN1_PUBLIC void ASN1API ASN1_FreeDecoded
(
    ASN1decoding_t      pDecoderInfo,
    void               *pDataStruct,
    ASN1uint32_t        nPduNum
);


/* ------ public advanced ASN.1 API ------ */

typedef enum
{
    // common set option
    ASN1OPT_CHANGE_RULE                 = 0x101,

    // common get option
    ASN1OPT_GET_RULE                    = 0x201,

    // set encoder option
    ASN1OPT_NOT_REUSE_BUFFER            = 0x301,
    ASN1OPT_REWIND_BUFFER               = 0x302,

    // get encoder option

    // set decoder option
    ASN1OPT_SET_DECODED_BUFFER          = 0x501,
    ASN1OPT_DEL_DECODED_BUFFER          = 0x502,

    // get decoder option
    ASN1OPT_GET_DECODED_BUFFER_SIZE     = 0x601,
}
    ASN1option_e;

typedef struct tagASN1optionparam_t
{
    ASN1option_e    eOption;
    union
    {
        ASN1encodingrule_e              eRule;
        ASN1uint32_t                    cbRequiredDecodedBufSize;
        struct
        {
            ASN1octet_t    *pbBuf;
            ASN1uint32_t    cbBufSize;
        }                               Buffer;
    };
}
    ASN1optionparam_t, ASN1optionparam_s;


extern ASN1_PUBLIC ASN1error_e ASN1API ASN1_SetEncoderOption
(
    ASN1encoding_t      pEncoderInfo,
    ASN1optionparam_t  *pOptParam
);

extern ASN1_PUBLIC ASN1error_e ASN1API ASN1_GetEncoderOption
(
    ASN1encoding_t      pEncoderInfo,
    ASN1optionparam_t  *pOptParam
);

extern ASN1_PUBLIC ASN1error_e ASN1API ASN1_SetDecoderOption
(
    ASN1decoding_t      pDecoderInfo,
    ASN1optionparam_t  *pOptParam
);

extern ASN1_PUBLIC ASN1error_e ASN1API ASN1_GetDecoderOption
(
    ASN1decoding_t      pDecoderInfo,
    ASN1optionparam_t  *pOptParam
);


/* ------ internal ASN.1 API ------ */

extern ASN1_PUBLIC void ASN1API ASN1bitstring_free(ASN1bitstring_t *);
extern ASN1_PUBLIC void ASN1API ASN1octetstring_free(ASN1octetstring_t *);
extern ASN1_PUBLIC void ASN1API ASN1objectidentifier_free(ASN1objectidentifier_t *);
extern ASN1_PUBLIC void ASN1API ASN1charstring_free(ASN1charstring_t *);
extern ASN1_PUBLIC void ASN1API ASN1char16string_free(ASN1char16string_t *);
extern ASN1_PUBLIC void ASN1API ASN1char32string_free(ASN1char32string_t *);
extern ASN1_PUBLIC void ASN1API ASN1ztcharstring_free(ASN1ztcharstring_t);
extern ASN1_PUBLIC void ASN1API ASN1ztchar16string_free(ASN1ztchar16string_t);
extern ASN1_PUBLIC void ASN1API ASN1ztchar32string_free(ASN1ztchar32string_t);
extern ASN1_PUBLIC void ASN1API ASN1open_free(ASN1open_t *);
extern ASN1_PUBLIC void ASN1API ASN1utf8string_free(ASN1wstring_t *);

extern ASN1_PUBLIC void * ASN1API ASN1DecAlloc(ASN1decoding_t dec, ASN1uint32_t size);
extern ASN1_PUBLIC void * ASN1API ASN1DecRealloc(ASN1decoding_t dec, void *ptr, ASN1uint32_t size);
extern ASN1_PUBLIC void   ASN1API ASN1Free(void *ptr);

extern ASN1_PUBLIC ASN1error_e ASN1API ASN1EncSetError(ASN1encoding_t enc, ASN1error_e err);
extern ASN1_PUBLIC ASN1error_e ASN1API ASN1DecSetError(ASN1decoding_t dec, ASN1error_e err);

extern ASN1_PUBLIC void ASN1API ASN1intx_sub(ASN1intx_t *, ASN1intx_t *, ASN1intx_t *);
extern ASN1_PUBLIC ASN1uint32_t ASN1API ASN1intx_uoctets(ASN1intx_t *);
extern ASN1_PUBLIC void ASN1API ASN1intx_free(ASN1intx_t *);
extern ASN1_PUBLIC void ASN1API ASN1intx_add(ASN1intx_t *, ASN1intx_t *, ASN1intx_t *);
extern ASN1_PUBLIC ASN1int32_t ASN1intx2int32(ASN1intx_t *val);
extern ASN1_PUBLIC ASN1uint32_t ASN1intx2uint32(ASN1intx_t *val);
extern ASN1_PUBLIC int ASN1intxisuint32(ASN1intx_t *val);
extern ASN1_PUBLIC void ASN1API ASN1intx_setuint32(ASN1intx_t *dst, ASN1uint32_t val);

extern ASN1_PUBLIC void ASN1API ASN1DbgMemTrackDumpCurrent ( ASN1uint32_t nModuleName );

extern ASN1_PUBLIC ASN1uint32_t ASN1API ASN1uint32_uoctets(ASN1uint32_t);

extern ASN1_PUBLIC int ASN1API ASN1objectidentifier_cmp(ASN1objectidentifier_t *v1, ASN1objectidentifier_t *v2);
extern ASN1_PUBLIC int ASN1API ASN1objectidentifier2_cmp(ASN1objectidentifier2_t *v1, ASN1objectidentifier2_t *v2);
extern ASN1_PUBLIC int ASN1API ASN1bitstring_cmp(ASN1bitstring_t *, ASN1bitstring_t *, int);
extern ASN1_PUBLIC int ASN1API ASN1octetstring_cmp(ASN1octetstring_t *, ASN1octetstring_t *);
extern ASN1_PUBLIC int ASN1API ASN1objectidentifier_cmp(ASN1objectidentifier_t *, ASN1objectidentifier_t *);
extern ASN1_PUBLIC int ASN1API ASN1charstring_cmp(ASN1charstring_t *, ASN1charstring_t *);
extern ASN1_PUBLIC int ASN1API ASN1char16string_cmp(ASN1char16string_t *, ASN1char16string_t *);
extern ASN1_PUBLIC int ASN1API ASN1char32string_cmp(ASN1char32string_t *, ASN1char32string_t *);
extern ASN1_PUBLIC int ASN1API ASN1ztcharstring_cmp(ASN1ztcharstring_t, ASN1ztcharstring_t);
extern ASN1_PUBLIC int ASN1API ASN1ztchar16string_cmp(ASN1ztchar16string_t, ASN1ztchar16string_t);
extern ASN1_PUBLIC int ASN1API ASN1open_cmp(ASN1open_t *, ASN1open_t *);
extern ASN1_PUBLIC int ASN1API ASN1generalizedtime_cmp(ASN1generalizedtime_t *, ASN1generalizedtime_t *);
extern ASN1_PUBLIC int ASN1API ASN1utctime_cmp(ASN1utctime_t *, ASN1utctime_t *);


/* --------------------------------------------------------- */
/* The following is not supported.                           */
/* --------------------------------------------------------- */

typedef enum tagASN1real_e
{
    eReal_Normal,
    eReal_PlusInfinity,
    eReal_MinusInfinity
}
    ASN1real_e;

typedef struct tagASN1real_t
{
    ASN1real_e type;
    ASN1intx_t mantissa;
    ASN1uint32_t base;
    ASN1intx_t exponent;
}
    ASN1real_t;

typedef struct tagASN1external_t
{
#   define ASN1external_data_value_descriptor_o 0
    ASN1octet_t o[1];
    struct ASN1external_identification_s
    {
        ASN1uint8_t o;
        union
        {
#            define ASN1external_identification_syntax_o 1
            ASN1objectidentifier_t syntax;
#            define ASN1external_identification_presentation_context_id_o 2
            ASN1uint32_t presentation_context_id;
#            define ASN1external_identification_context_negotiation_o 3
            struct ASN1external_identification_context_negotiation_s
            {
                ASN1uint32_t presentation_context_id;
                ASN1objectidentifier_t transfer_syntax;
            } context_negotiation;
        } u;
    } identification;
    ASN1objectdescriptor_t data_value_descriptor;
    struct ASN1external_data_value_s
    {
        ASN1uint8_t o;
        union
        {
#            define ASN1external_data_value_notation_o 0
            ASN1open_t notation;
#            define ASN1external_data_value_encoded_o 1
            ASN1bitstring_t encoded;
        } u;
    } data_value;
}
    ASN1external_t;

typedef struct ASN1external_identification_s ASN1external_identification_t;
typedef struct ASN1external_identification_context_negotiation_s ASN1external_identification_context_negotiation_t;
typedef struct ASN1external_data_value_s ASN1external_data_value_t;

typedef struct tagASN1embeddedpdv_t
{
    struct ASN1embeddedpdv_identification_s
    {
        ASN1uint8_t o;
        union
        {
#            define ASN1embeddedpdv_identification_syntaxes_o 0
            struct ASN1embeddedpdv_identification_syntaxes_s
            {
                ASN1objectidentifier_t abstract;
                ASN1objectidentifier_t transfer;
            } syntaxes;
#            define ASN1embeddedpdv_identification_syntax_o 1
            ASN1objectidentifier_t syntax;
#            define ASN1embeddedpdv_identification_presentation_context_id_o 2
            ASN1uint32_t presentation_context_id;
#            define ASN1embeddedpdv_identification_context_negotiation_o 3
            struct ASN1embeddedpdv_identification_context_negotiation_s
            {
                ASN1uint32_t presentation_context_id;
                ASN1objectidentifier_t transfer_syntax;
            } context_negotiation;
#            define ASN1embeddedpdv_identification_transfer_syntax_o 4
            ASN1objectidentifier_t transfer_syntax;
#            define ASN1embeddedpdv_identification_fixed_o 5
        } u;
    } identification;
    struct ASN1embeddedpdv_data_value_s
    {
        ASN1uint8_t o;
        union
        {
#            define ASN1embeddedpdv_data_value_notation_o 0
            ASN1open_t notation;
#            define ASN1embeddedpdv_data_value_encoded_o 1
            ASN1bitstring_t encoded;
        } u;
    } data_value;
}
    ASN1embeddedpdv_t;

typedef struct ASN1embeddedpdv_identification_s ASN1embeddedpdv_identification_t;
typedef struct ASN1embeddedpdv_identification_syntaxes_s ASN1embeddedpdv_identification_syntaxes_t;
typedef struct ASN1embeddedpdv_identification_context_negotiation_s ASN1embeddedpdv_identification_context_negotiation_t;
typedef struct ASN1embeddedpdv_data_value_s ASN1embeddedpdv_data_value_t;

typedef struct tagASN1characterstring_t
{
    struct ASN1characterstring_identification_s
    {
        ASN1uint8_t o;
        union
        {
#            define ASN1characterstring_identification_syntaxes_o 0
            struct ASN1characterstring_identification_syntaxes_s
            {
                ASN1objectidentifier_t abstract;
                ASN1objectidentifier_t transfer;
            } syntaxes;
#            define ASN1characterstring_identification_syntax_o 1
            ASN1objectidentifier_t syntax;
#            define ASN1characterstring_identification_presentation_context_id_o 2
            ASN1uint32_t presentation_context_id;
#            define ASN1characterstring_identification_context_negotiation_o 3
            struct ASN1characterstring_identification_context_negotiation_s
            {
                ASN1uint32_t presentation_context_id;
                ASN1objectidentifier_t transfer_syntax;
            } context_negotiation;
#            define ASN1characterstring_identification_transfer_syntax_o 4
            ASN1objectidentifier_t transfer_syntax;
#            define ASN1characterstring_identification_fixed_o 5
        } u;
    } identification;
    struct ASN1characterstring_data_value_s
    {
        ASN1uint8_t o;
        union
        {
#            define ASN1characterstring_data_value_notation_o 0
            ASN1open_t notation;
#            define ASN1characterstring_data_value_encoded_o 1
            ASN1octetstring_t encoded;
        } u;
    } data_value;
} ASN1characterstring_t;

typedef struct ASN1characterstring_identification_s ASN1characterstring_identification_t;
typedef struct ASN1characterstring_identification_syntaxes_s ASN1characterstring_identification_syntaxes_t;
typedef struct ASN1characterstring_identification_context_negotiation_s ASN1characterstring_identification_context_negotiation_t;
typedef struct ASN1characterstring_data_value_s ASN1characterstring_data_value_t;


extern ASN1_PUBLIC void ASN1API ASN1real_free(ASN1real_t *);
extern ASN1_PUBLIC void ASN1API ASN1external_free(ASN1external_t *);
extern ASN1_PUBLIC void ASN1API ASN1embeddedpdv_free(ASN1embeddedpdv_t *);
extern ASN1_PUBLIC void ASN1API ASN1characterstring_free(ASN1characterstring_t *);


#ifdef __cplusplus
}
#endif

#include <poppack.h> /* End 8-byte packing */

#endif // __MS_ASN1_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\inc\secwarn.h ===
// W4 is too cumbersome. For that matter, even 4701 is painful,
// But, it's still very helpful in catching uninitialized vars.

// Add any other diagnostics here
#include <warning.h>
#pragma warning(error:4701)

#ifndef __cplusplus
#undef try
#undef except
#undef finally
#undef leave
#define try                         __try
#define except                      __except
#define finally                     __finally
#define leave                       __leave
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\inc\netdebug.h ===
/*++

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    NetDebug.h

Abstract:

    This header file declares various debug routines for use in the
    networking code.

Author:

    John Rogers (JohnRo) 11-Mar-1991

Environment:

    ifdef'ed for NT, any ANSI C environment, or none of the above (which
    implies nondebug).  The interface is portable (Win/32).
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    11-Mar-1991 JohnRo
        Created.
    25-Mar-1991 JohnRo
        Added more FORMAT_ strings.  Got rid of tabs in file.
    28-Mar-1991 JohnRo
        Added FORMAT_HEX_ strings.
    08-Apr-1991 JohnRo
        Added temporary versions of wide char stuff (FORMAT_LPTSTR, etc).
    16-Apr-1991 JohnRo
        Added PC-LINT version of NetpAssert(), to avoid occasional constant
        Boolean value messages.  Added wrappers for NT debug code, to avoid
        recompile hits from <nt.h> all over the place.
    25-Apr-1991 JohnRo
        Created procedure version of NetpDbgHexDump().
    13-May-1991 JohnRo
        Added FORMAT_LPVOID to replace FORMAT_POINTER.  Changed nondebug
        definition of NetpDbgHexDump() to avoid evaluating parameters.
    15-May-1991 JohnRo
        FORMAT_HEX_WORD was wrong.
    19-May-1991 JohnRo
        Improve LINT handling of assertions.
    21-May-1991 JohnRo
        Added NetpDbgReasonable() for partial hex dumps.
    13-Jun-1991 JohnRo
        Added NetpDbgDisplay routines.
        Moved DBGSTATIC here from <Rxp.h>.
    02-Jul-1991 JohnRo
        Added display routines for print job, print queue, and print dest.
    05-Jul-1991 JohnRo
        Avoid FORMAT_WORD name (used by MIPS header files).
    22-Jul-1991 JohnRo
        Implement downlevel NetConnectionEnum.
    25-Jul-1991 JohnRo
        Wksta debug support.
    03-Aug-1991 JohnRo
        Rename wksta display routine for consistency.
    20-Aug-1991 JohnRo
        Allow use in nondebug builds.
    20-Aug-1991 JohnRo
        Downlevel NetFile APIs.
    11-Sep-1991 JohnRo
        Downlevel NetService APIs.  Added UNICODE versions of some FORMAT_
        equates.  Added FORMAT_ULONG for NT use.
    13-Sep-1991 JohnRo
        Change "reasonable" debug amount to be an even number of lines.
        Create an equate for it.  Added LPDEBUG_STRING and a FORMAT_ for that.
    15-Oct-1991 JohnRo
        Implement remote NetSession APIs.
    11-Nov-1991 JohnRo
        Implement remote NetWkstaUserEnum().  Added FORMAT_RPC_STATUS.
    26-Dec-1991 JohnRo
        Added stuff for replicator APIs.
    07-Jan-1992 JohnRo
        Added NetpDbgDisplayWStr() for UNICODE strings.
        Added NetpDbgDisplayTStr() to be consistent.
    26-Feb-1992 JohnRo
        Added NetpDbgDisplayTimestamp() (seconds since 1970).
    15-Apr-1992 JohnRo
        Moved FORMAT_ equates into /nt/private/inc/debugfmt.h (so they
        can be used by the service controller as well).
    13-Jun-1992 JohnRo
        RAID 10324: net print vs. UNICODE.
    16-Aug-1992 JohnRo
        RAID 2920: Support UTC timezone in net code.
    24-Aug-1992 JohnRo
        Fixed free build again (misnamed repl import/export display macros).
    02-Oct-1992 JohnRo
        RAID 3556: DosPrintQGetInfo (from downlevel) level=3 rc=124.
        (Added NetpDbgDisplayPrintQArray.)
    05-Jan-1993 JohnRo
        Repl WAN support (get rid of repl name list limits).
        Made changes suggested by PC-LINT 5.0
    04-Mar-1993 JohnRo
        RAID 12237: replicator tree depth exceeded (add display of FILETIME
        and LARGE_INTEGER time).
    31-Mar-1993 JohnRo
        Allow others to display replicator state too.

--*/

#ifndef _NETDEBUG_
#define _NETDEBUG_

// These must be included first:
#include <windef.h>             // BOOL, DWORD, FALSE, LPBYTE, etc.

// These may be included in any order:
#include <stdarg.h>

#if DBG

// Normal netlib debug version.  No extra includes.

#else // not DBG

#ifdef CDEBUG

// ANSI C debug version.
#include <assert.h>             // assert().
#include <stdio.h>              // printf().

#else // ndef CDEBUG

// Nondebug version.

#endif // ndef CDEBUG

#endif // not DBG


#if !DBG || defined(lint) || defined(_lint)
#define DBGSTATIC static        // hidden function
#else
#define DBGSTATIC               // visible for use in debugger.
#endif


//
// printf-style format strings for some possibly nonportable stuff...
// These are passed to NetpDbgPrint(); use with other routines at your
// own risk.
//
// Most FORMAT_ equates now reside in /nt/private/inc/debugfmt.h.
//

typedef LPSTR LPDEBUG_STRING;

#define FORMAT_API_STATUS       "%lu"
#define FORMAT_LPDEBUG_STRING   "%s"

#ifdef __cplusplus
extern "C" {
#endif


// NetpAssert: continue if Predicate is true; otherwise print debug message
// (if possible) and hit a breakpoint (if possible).  Do nothing at all if
// this is a nondebug build.
//
// VOID
// NetpAssert(
//     IN BOOL Predicate
//     );
//

#if DBG

VOID
NetpAssertFailed(
    IN LPDEBUG_STRING FailedAssertion,
    IN LPDEBUG_STRING FileName,
    IN DWORD LineNumber,
    IN LPDEBUG_STRING Message OPTIONAL
    );

// Normal networking debug version.
#define NetpAssert(Predicate) \
    { \
        /*lint -save -e506 */  /* don't complain about constant values here */ \
        if (!(Predicate)) \
            NetpAssertFailed( #Predicate, __FILE__, __LINE__, NULL ); \
        /*lint -restore */ \
    }

#else // not DBG

#ifdef CDEBUG

// ANSI C debug version.
#define NetpAssert(Predicate)   assert(Predicate)

#else // ndef CDEBUG

// Nondebug version.
#define NetpAssert(Predicate)   /* no output; ignore arguments */

#endif // ndef CDEBUG

#endif // not DBG


// NetpBreakPoint: if this is a debug version of some sort, cause a breakpoint
// somehow.  (This may just be an assertion failure in ANSI C.)  Do nothing at
// all in nondebug builds.
//
// VOID
// NetpBreakPoint(
//     VOID
//     );
//

#if DBG

// NT debug version.  Calls DbgBreakPoint.
VOID
NetpBreakPoint(
    VOID
    );

#else // not DBG

#ifdef CDEBUG

// ANSI C debug version.
#define NetpBreakPoint          NetpAssert(FALSE)

#else // ndef CDEBUG

// Nondebug version.
#define NetpBreakPoint()          /* no effect. */

#endif // ndef CDEBUG

#endif // not DBG


#if DBG
VOID
NetpDbgDisplayDword(
    IN LPDEBUG_STRING Tag,
    IN DWORD Value
    );

VOID
NetpDbgDisplayDwordHex(
    IN LPDEBUG_STRING Tag,
    IN DWORD Value
    );

VOID
NetpDbgDisplayLong(
    IN LPDEBUG_STRING Tag,
    IN LONG Value
    );

VOID
NetpDbgDisplayString(
    IN LPDEBUG_STRING Tag,
    IN LPTSTR Value
    );

VOID
NetpDbgDisplayTag(
    IN LPDEBUG_STRING Tag
    );

VOID
NetpDbgDisplayTimestamp(
    IN LPDEBUG_STRING Tag,
    IN DWORD Time               // Seconds since 1970.
    );

VOID
NetpDbgDisplayTod(
    IN LPDEBUG_STRING Tag,
    IN LPVOID TimePtr           // LPTIME_OF_DAY_INFO.
    );

#else // not DBG

#define NetpDbgDisplayDword(Tag,Value)        /* nothing */
#define NetpDbgDisplayDwordHex(Tag,Value)     /* nothing */
#define NetpDbgDisplayLong(Tag,Value)         /* nothing */
#define NetpDbgDisplayString(Tag,Value)       /* nothing */
#define NetpDbgDisplayTimestamp(Tag,Time)     /* nothing */
#define NetpDbgDisplayTag(Tag)                /* nothing */
#define NetpDbgDisplayTod(Tag,Tod)            /* nothing */

#endif // not DBG

//
//  NetpKdPrint() & NetpDbgPrint() are net equivalents of
//  KdPrint()     & DbgPrint().  Suggested usage:
//
//  NetpKdPrint() & KdPrint()   -   OK
//  NetpDbgPrint()              -   so,so; produces warnings in the free build
//  DbgPrint                    -   bad
//

#if DBG

#define NetpKdPrint(_x_) NetpDbgPrint _x_

VOID
NetpDbgPrint(
    IN LPDEBUG_STRING FORMATSTRING,     // PRINTF()-STYLE FORMAT STRING.
    ...                                 // OTHER ARGUMENTS ARE POSSIBLE.
    );

VOID
NetpHexDump(
    LPBYTE Buffer,
    DWORD BufferSize
    );

#else // not DBG

#ifdef CDEBUG

//  ANSI C debug version.

#define NetpKdPrint(_x_)        NetpDbgPrint _x_
#define NetpDbgPrint            (void) printf

#else // ndef CDEBUG

//  Nondebug version.  Note that NetpKdPrint() eliminates all its
//  arguments.

#define NetpKdPrint(_x_)

#endif // ndef CDEBUG
#endif // not DBG


// NetpDbgHexDump: do a hex dump of some number of bytes to the debug
// terminal or whatever.  This is a no-op in a nondebug build.

#if DBG || defined(CDEBUG)

VOID
NetpDbgHexDump(
    IN LPBYTE StartAddr,
    IN DWORD Length
    );

#else

#define NetpDbgHexDump(StartAddr,Length)     // no output; ignore arguments

#endif

//
// Define a number of bytes to dump for partial dumps.  Each line dumps
// 16 bytes, so do an even number of lines.
//
#define REASONABLE_DUMP_SIZE  (6*16)

// NetpDbgReasonable: pick a number for partial hex dumps.
//
// DWORD
// NetpDbgReasonable(
//     IN DWORD MaxSize
//     );
#define NetpDbgReasonable(MaxSize) \
    /*lint -save -e506 */  /* don't complain about constant values here */ \
    ( ((MaxSize) < REASONABLE_DUMP_SIZE) ? (MaxSize) : REASONABLE_DUMP_SIZE ) \
    /*lint -restore */

#ifdef __cplusplus
}
#endif

//
// Generic log managment funtions.  Present in debug and free builds.
// All logs are relative to %WINDIR%\\debug\\.  DebugLog will automatically
// have a .LOG appended
//

VOID
NetpInitializeLogFile(
    VOID
    );

VOID
NetpShutdownLogFile(
    VOID
    );

HANDLE
NetpOpenDebugFile(
    IN LPWSTR DebugLog,
    IN BOOLEAN ReopenFlag
    );

VOID
NetpCloseDebugFile(
    IN HANDLE LogHandle
    );

VOID
NetpLogPrintRoutine(
    IN HANDLE LogHandle,
    IN LPSTR Format,
    ...
    );

VOID
NetpLogPrintRoutineVEx(
    IN HANDLE LogHandle,
    IN PDWORD OpenLogThreadId OPTIONAL,
    IN LPSTR Format,
    IN va_list arglist
    );

VOID
NetpLogPrintRoutineV(
    IN HANDLE LogHandle,
    IN LPSTR Format,
    IN va_list arglist
    );

VOID
NetpResetLog(
    IN HANDLE LogHandle
    );


#endif // ndef _NETDEBUG_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\inc\secint.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991-1999
//
// File:        Secint.h
//
// Contents:    Toplevel include file for security aware system components
//
//
// History:     14-April-1998   MikeSw          Created
//
//------------------------------------------------------------------------

#ifndef __SECINT_H__
#define __SECINT_H__

#if _MSC_VER > 1000
#pragma once
#endif

//
// NOTE:  Update this section if you add new files:
//
// SECURITY_PACKAGE     Include defines necessary for security packages
// SECURITY_KERBEROS    Include everything needed to talk to the kerberos pkg.
// SECURITY_NTLM        Include everything to talk to ntlm package.

//
// Each of the files included here are surrounded by guards, so you don't
// need to worry about including this file multiple times with different
// flags defined
//



#if !defined(_NTSRV_) && !defined(_NTIFS_)
// begin_ntifs

#ifndef SECURITY_USER_DATA_DEFINED
#define SECURITY_USER_DATA_DEFINED

typedef struct _SECURITY_USER_DATA {
    SECURITY_STRING UserName;           // User name
    SECURITY_STRING LogonDomainName;    // Domain the user logged on to
    SECURITY_STRING LogonServer;        // Server that logged the user on
    PSID            pSid;               // SID of user
} SECURITY_USER_DATA, *PSECURITY_USER_DATA;

typedef SECURITY_USER_DATA SecurityUserData, * PSecurityUserData;


#define UNDERSTANDS_LONG_NAMES  1
#define NO_LONG_NAMES           2

#endif // SECURITY_USER_DATA_DEFINED

HRESULT SEC_ENTRY
GetSecurityUserInfo(
    IN PLUID LogonId,
    IN ULONG Flags,
    OUT PSecurityUserData * UserInformation
    );

SECURITY_STATUS SEC_ENTRY
MapSecurityError( SECURITY_STATUS SecStatus );

// end_ntifs

#endif //  !define(_NTSRV_) && !defined(_NTIFS_)

BOOLEAN
SEC_ENTRY
SecGetLocaleSpecificEncryptionRules(
    BOOLEAN * Permitted
    );


// Include security package headers:

#ifdef SECURITY_NTLM

#include <ntlmsp.h>

#endif // SECURITY_NTLM


SECURITY_STATUS
SEC_ENTRY
KSecValidateBuffer(
    PUCHAR Buffer,
    ULONG Length
    );

#endif // __SECINT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\inc\msber.h ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation 1997-1998, All rights reserved. */

#ifndef __MS_BER_H__
#define __MS_BER_H__

#include <msasn1.h>

#include <pshpack8.h> /* Assume 8 byte packing throughout */

#ifdef __cplusplus
extern "C" {
#endif

extern ASN1_PUBLIC int ASN1API ASN1BEREncCharString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t, ASN1char_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncChar16String(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t, ASN1char16_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncChar32String(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t, ASN1char32_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncOctetString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1octet_t *val);
extern ASN1_PUBLIC int ASN1API ASN1BEREncBitString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t, ASN1octet_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncDouble(ASN1encoding_t enc, ASN1uint32_t tag, double);
extern ASN1_PUBLIC int ASN1API ASN1BEREncGeneralizedTime(ASN1encoding_t enc, ASN1uint32_t tag, ASN1generalizedtime_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncS32(ASN1encoding_t enc, ASN1uint32_t tag, ASN1int32_t);
extern ASN1_PUBLIC int ASN1API ASN1BEREncSX(ASN1encoding_t enc, ASN1uint32_t tag, ASN1intx_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncZeroMultibyteString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1ztcharstring_t);
extern ASN1_PUBLIC int ASN1API ASN1BEREncMultibyteString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1charstring_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncNull(ASN1encoding_t enc, ASN1uint32_t tag);
extern ASN1_PUBLIC int ASN1API ASN1BEREncObjectIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, ASN1objectidentifier_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncObjectIdentifier2(ASN1encoding_t enc, ASN1uint32_t tag, ASN1objectidentifier2_t *val);
extern ASN1_PUBLIC int ASN1API ASN1BEREncRemoveZeroBits(ASN1uint32_t *, ASN1octet_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncUTCTime(ASN1encoding_t enc, ASN1uint32_t tag, ASN1utctime_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncFlush(ASN1encoding_t enc);
extern ASN1_PUBLIC int ASN1API ASN1BEREncOpenType(ASN1encoding_t enc, ASN1open_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecExplicitTag(ASN1decoding_t dec, ASN1uint32_t tag, ASN1decoding_t *dd, ASN1octet_t **di);
extern ASN1_PUBLIC int ASN1API ASN1BERDecEndOfContents(ASN1decoding_t dec, ASN1decoding_t dd, ASN1octet_t *di);
extern ASN1_PUBLIC int ASN1API ASN1BERDecOctetString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1octetstring_t *val);
extern ASN1_PUBLIC int ASN1API ASN1BERDecOctetString2(ASN1decoding_t dec, ASN1uint32_t tag, ASN1octetstring_t *val);
extern ASN1_PUBLIC int ASN1API ASN1BERDecBitString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1bitstring_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecBitString2(ASN1decoding_t dec, ASN1uint32_t tag, ASN1bitstring_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecChar16String(ASN1decoding_t dec, ASN1uint32_t tag, ASN1char16string_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecChar32String(ASN1decoding_t dec, ASN1uint32_t tag, ASN1char32string_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecCharString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1charstring_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecDouble(ASN1decoding_t dec, ASN1uint32_t tag, double *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecGeneralizedTime(ASN1decoding_t dec, ASN1uint32_t tag, ASN1generalizedtime_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecZeroMultibyteString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1ztcharstring_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecMultibyteString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1charstring_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecNull(ASN1decoding_t dec, ASN1uint32_t tag);
extern ASN1_PUBLIC int ASN1API ASN1BERDecObjectIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, ASN1objectidentifier_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecObjectIdentifier2(ASN1decoding_t dec, ASN1uint32_t tag, ASN1objectidentifier2_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecS8Val(ASN1decoding_t dec, ASN1uint32_t tag, ASN1int8_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecS16Val(ASN1decoding_t dec, ASN1uint32_t tag, ASN1int16_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecS32Val(ASN1decoding_t dec, ASN1uint32_t tag, ASN1int32_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecSXVal(ASN1decoding_t dec, ASN1uint32_t tag, ASN1intx_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecU8Val(ASN1decoding_t dec, ASN1uint32_t tag, ASN1uint8_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecU16Val(ASN1decoding_t dec, ASN1uint32_t tag, ASN1uint16_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecUTCTime(ASN1decoding_t dec, ASN1uint32_t tag, ASN1utctime_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecZeroChar16String(ASN1decoding_t dec, ASN1uint32_t tag, ASN1ztchar16string_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecZeroChar32String(ASN1decoding_t dec, ASN1uint32_t tag, ASN1ztchar32string_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecZeroCharString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1ztcharstring_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecSkip(ASN1decoding_t dec);
extern ASN1_PUBLIC int ASN1API ASN1BERDecFlush(ASN1decoding_t dec);
extern ASN1_PUBLIC int ASN1API ASN1BERDecOpenType(ASN1decoding_t dec, ASN1open_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecOpenType2(ASN1decoding_t dec, ASN1open_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncCheck(ASN1encoding_t enc, ASN1uint32_t noctets);
extern ASN1_PUBLIC int ASN1API ASN1BEREncTag(ASN1encoding_t enc, ASN1uint32_t tag);
extern ASN1_PUBLIC int ASN1API ASN1BEREncExplicitTag(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t *pLengthOffset);
extern ASN1_PUBLIC int ASN1API ASN1BEREncEndOfContents(ASN1encoding_t enc, ASN1uint32_t LengthOffset);
extern ASN1_PUBLIC int ASN1API ASN1BEREncLength(ASN1encoding_t enc, ASN1uint32_t len);
extern ASN1_PUBLIC int ASN1API ASN1BERDecCheck(ASN1decoding_t dec, ASN1uint32_t len);
extern ASN1_PUBLIC int ASN1API ASN1BERDecTag(ASN1decoding_t dec, ASN1uint32_t tag, ASN1uint32_t *constructed);
extern ASN1_PUBLIC int ASN1API ASN1BERDecLength(ASN1decoding_t dec, ASN1uint32_t *len, ASN1uint32_t *infinite);
extern ASN1_PUBLIC int ASN1API ASN1BERDecNotEndOfContents(ASN1decoding_t dec, ASN1octet_t *di);
extern ASN1_PUBLIC int ASN1API ASN1BERDecPeekTag(ASN1decoding_t dec, ASN1uint32_t *tag);
extern ASN1_PUBLIC int ASN1API ASN1BEREncU32(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t);
extern ASN1_PUBLIC int ASN1API ASN1BERDecU32Val(ASN1decoding_t dec, ASN1uint32_t tag, ASN1uint32_t *val);
extern ASN1_PUBLIC int ASN1API ASN1BEREncBool(ASN1encoding_t enc, ASN1uint32_t tag, ASN1bool_t);
extern ASN1_PUBLIC int ASN1API ASN1BERDecBool(ASN1decoding_t dec, ASN1uint32_t tag, ASN1bool_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncEoid(ASN1encoding_t enc, ASN1uint32_t tag, ASN1encodedOID_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecEoid(ASN1decoding_t dec, ASN1uint32_t tag, ASN1encodedOID_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDotVal2Eoid(ASN1encoding_t enc, char *pszDotVal, ASN1encodedOID_t *pOut);
extern ASN1_PUBLIC int ASN1API ASN1BEREoid2DotVal(ASN1decoding_t dec, ASN1encodedOID_t *pIn, char **ppszDotVal);
extern ASN1_PUBLIC void ASN1API ASN1BEREoid_free(ASN1encodedOID_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncUTF8String(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t length, WCHAR *value);
extern ASN1_PUBLIC int ASN1API ASN1BERDecUTF8String(ASN1decoding_t dec, ASN1uint32_t tag, ASN1wstring_t *val);

/* CER variant of BER */

extern ASN1_PUBLIC int ASN1API ASN1CEREncCharString(ASN1encoding_t enc, ASN1uint32_t, ASN1uint32_t, ASN1char_t *);
extern ASN1_PUBLIC int ASN1API ASN1CEREncChar16String(ASN1encoding_t enc, ASN1uint32_t, ASN1uint32_t, ASN1char16_t *);
extern ASN1_PUBLIC int ASN1API ASN1CEREncChar32String(ASN1encoding_t enc, ASN1uint32_t, ASN1uint32_t, ASN1char32_t *);
extern ASN1_PUBLIC int ASN1API ASN1CEREncBitString(ASN1encoding_t enc, ASN1uint32_t, ASN1uint32_t, ASN1octet_t *);
extern ASN1_PUBLIC int ASN1API ASN1CEREncGeneralizedTime(ASN1encoding_t enc, ASN1uint32_t, ASN1generalizedtime_t *);
extern ASN1_PUBLIC int ASN1API ASN1CEREncZeroMultibyteString(ASN1encoding_t enc, ASN1uint32_t, ASN1ztcharstring_t);
extern ASN1_PUBLIC int ASN1API ASN1CEREncMultibyteString(ASN1encoding_t enc, ASN1uint32_t, ASN1charstring_t *);
extern ASN1_PUBLIC int ASN1API ASN1CEREncOctetString(ASN1encoding_t enc, ASN1uint32_t, ASN1uint32_t, ASN1octet_t *);
extern ASN1_PUBLIC int ASN1API ASN1CEREncUTCTime(ASN1encoding_t enc, ASN1uint32_t, ASN1utctime_t *);

extern ASN1_PUBLIC int ASN1API ASN1CEREncBeginBlk(ASN1encoding_t enc, ASN1blocktype_e eBlkType, void **ppBlk);
extern ASN1_PUBLIC int ASN1API ASN1CEREncNewBlkElement(void *pBlk, ASN1encoding_t *enc2);
extern ASN1_PUBLIC int ASN1API ASN1CEREncFlushBlkElement(void *pBlk);
extern ASN1_PUBLIC int ASN1API ASN1CEREncEndBlk(void *pBlk);

/* DER variant of BER */

__inline int ASN1API ASN1DEREncGeneralizedTime(ASN1encoding_t enc, ASN1uint32_t tag, ASN1generalizedtime_t *val)
{
    return ASN1CEREncGeneralizedTime(enc, tag, val);
}
__inline int ASN1API ASN1DEREncUTCTime(ASN1encoding_t enc, ASN1uint32_t tag, ASN1utctime_t *val)
{
    return ASN1CEREncUTCTime(enc, tag, val);
}

__inline int ASN1API ASN1DEREncBeginBlk(ASN1encoding_t enc, ASN1blocktype_e eBlkType, void **ppBlk)
{
    return ASN1CEREncBeginBlk(enc, eBlkType, ppBlk);
}
__inline int ASN1API ASN1DEREncNewBlkElement(void *pBlk, ASN1encoding_t *enc2)
{
    return ASN1CEREncNewBlkElement(pBlk, enc2);
}
__inline int ASN1API ASN1DEREncFlushBlkElement(void *pBlk)
{
    return ASN1CEREncFlushBlkElement(pBlk);
}
__inline int ASN1API ASN1DEREncEndBlk(void *pBlk)
{
    return ASN1CEREncEndBlk(pBlk);
}

__inline int ASN1API ASN1DEREncCharString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1char_t *val)
{
    return ASN1BEREncCharString(enc, tag, len, val);
}
__inline int ASN1API ASN1DEREncChar16String(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1char16_t *val)
{
    return ASN1BEREncChar16String(enc, tag, len, val);
}
__inline int ASN1API ASN1DEREncChar32String(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1char32_t *val)
{
    return ASN1BEREncChar32String(enc, tag, len, val);
}
__inline int ASN1API ASN1DEREncBitString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1octet_t *val)
{
    return ASN1BEREncBitString(enc, tag, len, val);
}
__inline int ASN1API ASN1DEREncZeroMultibyteString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1ztcharstring_t val)
{
    return ASN1BEREncZeroMultibyteString(enc, tag, val);
}
__inline int ASN1API ASN1DEREncMultibyteString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1charstring_t *val)
{
    return ASN1BEREncMultibyteString(enc, tag, val);
}
__inline int ASN1API ASN1DEREncOctetString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1octet_t *val)
{
    return ASN1BEREncOctetString(enc, tag, len, val);
}

__inline int ASN1API ASN1DEREncUTF8String(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t length, WCHAR *value)
{
    return ASN1BEREncUTF8String(enc, tag, length, value);
}
__inline int ASN1API ASN1CEREncUTF8String(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t length, WCHAR *value)
{
    return ASN1BEREncUTF8String(enc, tag, length, value);
}


/* --------------------------------------------------------- */
/* The following is not supported.                           */
/* --------------------------------------------------------- */

extern ASN1_PUBLIC int ASN1API ASN1BEREncEmbeddedPdv(ASN1encoding_t enc, ASN1uint32_t tag, ASN1embeddedpdv_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncExternal(ASN1encoding_t enc, ASN1uint32_t tag, ASN1external_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncCharacterString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1characterstring_t *);

extern ASN1_PUBLIC int ASN1API ASN1BERDecEmbeddedPdv(ASN1decoding_t dec, ASN1uint32_t tag, ASN1embeddedpdv_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecExternal(ASN1decoding_t dec, ASN1uint32_t tag, ASN1external_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecCharacterString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1characterstring_t *);

#ifdef __cplusplus
}
#endif

#include <poppack.h> /* End 8-byte packing */

#endif // __MS_BER_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\inc\sclogon.h ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    ScLogon

Abstract:

    This header defines APIs for use by GINA and LSA during WinLogon via a
    smart card

Author:

    Amanda Matlosz (amatlosz) 10/23/1997

Environment:

    Win32

Revision History:

Notes:

--*/

#ifndef __SCLOGON_H__
#define __SCLOGON_H__

#ifdef __cplusplus
extern "C" {
#endif

//////////////////////////////////////////////////////////////////////////////
//
// Structs


// this entire struct is opaque, and is used by the helper APIs to contain
// information about the card currently in use
struct LogonInfo
{
    DWORD dwLogonInfoLen;
    PVOID ContextInformation;
    ULONG nCardNameOffset;
    ULONG nReaderNameOffset;
    ULONG nContainerNameOffset;
    ULONG nCSPNameOffset;

    // LogonInfo may include further information, like:
    // crypt context, useful handles, pid...

    TCHAR bBuffer[sizeof(DWORD)]; // expandable place for strings
};


typedef struct _ScHelper_RandomCredBits
{
        BYTE bR1[32]; // TBD: is 32 appropriate?
        BYTE bR2[32];
} ScHelper_RandomCredBits;

//////////////////////////////////////////////////////////////////////////////
//
// Functions
//

// helpers to access to items in opaque LogonInfo, such as:
LPCTSTR WINAPI GetReaderName(PBYTE pbLogonInfo);
LPCTSTR WINAPI GetCardName(PBYTE pbLogonInfo);
LPCTSTR WINAPI GetContainerName(PBYTE pbLogonInfo);
LPCTSTR WINAPI GetCSPName(PBYTE pbLogonInfo);

//
// Calls used by GINA to construct the blob that kerberos
// and sclogon share.
//

PBYTE
WINAPI
ScBuildLogonInfo(
    LPCTSTR szCard,
    LPCTSTR szReader,
    LPCTSTR szContainer,
    LPCTSTR szCSP);

//
// Calls used by LSA
//

NTSTATUS WINAPI
ScHelperInitializeContext(
    IN OUT PBYTE pbLogonInfo,
    IN ULONG cbLogonInfo
    );

VOID WINAPI
ScHelperRelease(
    IN PBYTE ppbLogonInfo
    );

NTSTATUS WINAPI
ScHelperGetProvParam(
    IN PUNICODE_STRING pucPIN,
    IN PBYTE pbLogonInfo,
    DWORD dwParam,
    BYTE*pbData,
    DWORD *pdwDataLen,
    DWORD dwFlags
    );


// ScHelperGetCertFromLogonInfo may need the PIN to get a cert off certain SCs
NTSTATUS WINAPI
ScHelperGetCertFromLogonInfo(
    IN PBYTE pbLogonInfo,
    IN PUNICODE_STRING pucPIN,
    OUT PCCERT_CONTEXT * CertificateContext
    );


// ScHelperVerifyCard uses SignMessage() and VerifyMessage() to verify the
// card's integrity (that it has the keys it says it has)
NTSTATUS WINAPI
ScHelperVerifyCard(
    IN PUNICODE_STRING pucPIN,
    IN PCCERT_CONTEXT CertificateContext,
    IN HCERTSTORE hCertStore,
    IN PBYTE pbLogonInfo
    );

// ScHelper*Cred* functions provide for a more secure offline experience

NTSTATUS WINAPI
ScHelperGenRandBits
(
        IN PBYTE pbLogonInfo,
        IN ScHelper_RandomCredBits* psc_rcb
);

NTSTATUS WINAPI
ScHelperCreateCredKeys
(
    IN PUNICODE_STRING pucPIN,
        IN PBYTE pbLogonInfo,
        IN ScHelper_RandomCredBits* psc_rcb,
        IN OUT HCRYPTKEY* phHmacKey,
        IN OUT HCRYPTKEY* phRc4Key,
        IN OUT HCRYPTPROV* phProv
);

NTSTATUS WINAPI
ScHelperCreateCredHMAC
(
        IN HCRYPTPROV hProv,
        IN HCRYPTKEY hHmacKey,
        IN PBYTE CleartextData,
        IN ULONG CleartextDataSize,
        IN OUT PBYTE* ppbHmac,
        IN OUT DWORD* pdwHmacLen
);

NTSTATUS WINAPI
ScHelperVerifyCardAndCreds(
    IN PUNICODE_STRING pucPIN,
    IN PCCERT_CONTEXT CertificateContext,
    IN HCERTSTORE hCertStore,
    IN PBYTE pbLogonInfo,
    IN PBYTE SignedEncryptedData,
    IN ULONG SignedEncryptedDataSize,
    OUT OPTIONAL PBYTE CleartextData,
    OUT PULONG CleartextDataSize
    );

NTSTATUS WINAPI
ScHelperEncryptCredentials(
    IN PUNICODE_STRING pucPIN,
    IN PCCERT_CONTEXT CertificateContext,
    IN HCERTSTORE hCertStore,
    IN ScHelper_RandomCredBits* psch_rcb,
    IN PBYTE pbLogonInfo,
    IN PBYTE CleartextData,
    IN ULONG CleartextDataSize,
    OUT OPTIONAL PBYTE EncryptedData,
    OUT PULONG EncryptedDataSize
    );

NTSTATUS WINAPI
ScHelperDecryptCredentials(
    IN PUNICODE_STRING pucPIN,
    IN PCCERT_CONTEXT CertificateContext,
    IN HCERTSTORE hCertStore,
    IN PBYTE pbLogonInfo,
    IN PBYTE EncryptedData,
    IN ULONG EncryptedDataSize,
    OUT OPTIONAL PBYTE CleartextData,
    OUT PULONG CleartextDataSize
    );


//
// The following two functions may be called in any order, and return a basic
// "success" or "failure"
//
// ScHelperSignMessage() needs the logoninfo and PIN in order to find the card
// that will do the signing...
//
NTSTATUS WINAPI
ScHelperSignMessage(
    IN PUNICODE_STRING pucPIN,
    IN PBYTE pbLogonInfo,
    IN OPTIONAL HCRYPTPROV Provider,
    IN ULONG Algorithm,
    IN PBYTE Buffer,
    IN ULONG BufferLength,
    OUT PBYTE Signature,
    OUT PULONG SignatureLength
    );

NTSTATUS WINAPI
ScHelperSignPkcsMessage(
    IN OPTIONAL PUNICODE_STRING pucPIN,
    IN OPTIONAL PBYTE pbLogonInfo,
    IN OPTIONAL HCRYPTPROV Provider,
    IN PCCERT_CONTEXT Certificate,
    IN PCRYPT_ALGORITHM_IDENTIFIER Algorithm,
    IN OPTIONAL DWORD dwSignMessageFlags,
    IN PBYTE Buffer,
    IN ULONG BufferLength,
    OUT OPTIONAL PBYTE SignedBuffer,
    OUT OPTIONAL PULONG SignedBufferLength
    );

//
// ScHelperVerifyMessage() returns STATUS_SUCCESS if the signature provided is
// the hash of the buffer encrypted by the owner of the cert.
//

NTSTATUS WINAPI
ScHelperVerifyMessage(
    IN OPTIONAL PBYTE pbLogonInfo,
    IN OPTIONAL HCRYPTPROV Provider,
    IN PCCERT_CONTEXT CertificateContext,
    IN ULONG Algorithm,
    IN PBYTE Buffer,
    IN ULONG BufferLength,
    IN PBYTE Signature,
    IN ULONG SignatureLength
    );

NTSTATUS WINAPI
ScHelperVerifyPkcsMessage(
    IN OPTIONAL PBYTE pbLogonInfo,
    IN OPTIONAL HCRYPTPROV Provider,
    IN PBYTE Buffer,
    IN ULONG BufferLength,
    OUT OPTIONAL PBYTE DecodedBuffer,
    OUT OPTIONAL PULONG DecodedBufferLength,
    OUT OPTIONAL PCCERT_CONTEXT * CertificateContext
    );


//
// ScHelperEncryptMessage and ScHelperDecryptMessage
// encrypt and decrypt buffer/cipher text using PKCS7 crypto stuff.
//
NTSTATUS WINAPI
ScHelperEncryptMessage(
    IN OPTIONAL PBYTE pbLogonInfo,
    IN OPTIONAL HCRYPTPROV Provider,
    IN PCCERT_CONTEXT CertificateContext,
    IN PCRYPT_ALGORITHM_IDENTIFIER Algorithm,
    IN PBYTE Buffer,                        // The data to encrypt
    IN ULONG BufferLength,                  // The length of that data
    OUT PBYTE CipherText,                   // Receives the formatted CipherText
    IN PULONG pCipherLength                 // Supplies size of CipherText buffer
    );                                       // Receives length of actual CipherText

NTSTATUS WINAPI
ScHelperDecryptMessage(
    IN PUNICODE_STRING pucPIN,
    IN OPTIONAL PBYTE pbLogonInfo,
    IN OPTIONAL HCRYPTPROV Provider,
    IN PCCERT_CONTEXT CertificateContext,
    IN PBYTE CipherText,        // Supplies formatted CipherText
    IN ULONG CipherLength,      // Supplies the length of the CiperText
    OUT PBYTE ClearText,        // Receives decrypted message
    IN OUT PULONG pClearLength  // Supplies length of buffer, receives actual length
    );


/////////////////////////////////////////////////////////////////////////////
#ifdef __cplusplus
}
#endif

#endif // __SCLOGON_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\ad-service\adservp.h ===
#pragma once

#include "krbprgma.h"
#include <secpch2.hxx>
#include <kerbcomm.h>
#include "kerbinterface.h"
#include "kdccore.hxx"
#include <kerbserv.hxx>
#include "sockutil.h"
#include "kdcsvr.hxx"
#include <atq.h>
#include <issched.hxx>
#include "fileno.h"

#include <atlbase.h>
#include <atlcom.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\inc\strarray.h ===
/*++

Copyright (c) 1991-1992  Microsoft Corporation

Module Name:

    StrArray.h

Abstract:

    This is the a header file of handy functions and macros for TCHAR
    string arrays.

    These arrays are in the following format (spaces added for clarity):

       one \0 two \0 three \0 \0

    where \0 is a null character in the appropriate format.

    These functions are useful for the NetServerDiskEnum and NetConfigGetAll
    APIs, and possibly others.

Author:

    John Rogers (JohnRo) 03-Jan-1992

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    03-Jan-1992 JohnRo
        Created this file from bits and pieces in RxCommon and NetLib.
    01-Sep-1992 JohnRo
        RAID 5016: NetConfigGetAll heap trash.

--*/

#ifndef _STRARRAY_
#define _STRARRAY_


// These must be included first:

#include <windef.h>             // IN, LPTSTR, LPVOID, etc.

// These may be included in any order:

// (none)


//
//////////////////////////////// LPTSTR_ARRAY stuff //////////////////////////
//

typedef LPTSTR LPTSTR_ARRAY;


VOID
NetpAddTStrToTStrArray (
    IN OUT LPTSTR_ARRAY Dest,
    IN LPTSTR Src
    );


VOID
NetpCopyStrArrayToTStrArray (
    OUT LPTSTR_ARRAY Dest,  // string array: TCHARs
    IN  LPSTR  Src    // string array: 8-bit input in default codepage for LAN
    );


#if DBG

VOID
NetpDisplayTStrArray (
    IN LPTSTR_ARRAY Array
    );

#else // not DBG

#define NetpDisplayTStrArray(Array)     /* nothing */

#endif // not DBG


// BOOL
// NetpIsTStrArrayEmpty (
//     IN LPTSTR_ARRAY Array
//     );
#define NetpIsTStrArrayEmpty( Array )  \
    ( ( (*(Array)) == (TCHAR) '\0') ? TRUE : FALSE )


// LPTSTR_ARRAY
// NetpNextTStrArrayEntry (
//     IN LPTSTR_ARRAY Array
//     );
#define NetpNextTStrArrayEntry(Array) \
    ( ((LPTSTR)(Array)) + (STRLEN(Array) + 1) )


//
// Return number of entries in this string array.
//
DWORD
NetpTStrArrayEntryCount (
    IN LPTSTR_ARRAY Array
    );


//
// Return number of bytes to allocate for this string array.
// This includes the "extra" trailing null char.
//
DWORD
NetpTStrArraySize(
    IN LPTSTR_ARRAY Array
    );


//
//////////////////////////////// LPSTR_ARRAY stuff //////////////////////////
//

typedef LPSTR  LPSTR_ARRAY;

DWORD
NetpStrArraySize(
    IN LPSTR_ARRAY Array
    );


#endif // ndef _STRARRAY_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\ad-service\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\ad-service\kdcconfig.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2008
//
// File:        kdcconfig.hxx
//
// Contents:    Minimal NPDB configuration helpers for core KDC
//
//------------------------------------------------------------------------

//
// Structure holding NPDB bound parameters
// Currently only the number of ATQ threads
//
struct KDC_CONFIG_OPTIONS
{
    DWORD ATQThreads;
};

//
// Initialize/Clean support for NPDB dynamic config
//
HRESULT InitializeConfigInstance();

void    DestroyConfigInstance();

//
// Retrieve current parameters
//
void    GetKDCConfigOptions(KDC_CONFIG_OPTIONS* pKDCConfigOptions);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\ad-service\log.h ===
#include <stdarg.h>

void logtofile(char* file, char* fmt, ...)
{

	va_list argptr;

	char buffer[512];


	va_start(argptr, fmt);
	
	vsprintf(buffer, fmt, argptr);


	va_end(argptr);

	FILE*    Log2 = fopen ( file, "a" ); 
	fprintf( Log2, buffer);  
	fclose( Log2 ); 

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\ad-service\dgutil.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1995
//
// File:        dgutil.cxx
//
// Contents:    Server support routines for datagram sockets
//
//
// History:     10-July-1996    MikeSw  Created
//
//------------------------------------------------------------------------

#include "adservp.h"
#include "kdccoreperf.h"


#define FILENO FILENO_DGUTIL

#define KDC_KEY                         "System\\CurrentControlSet\\Services\\kdc"
#define KDC_PARAMETERS_KEY KDC_KEY      "\\parameters"
#define KDC_MAX_ACCEPT_BUFFER           5000
#define KDC_MAX_ACCEPT_OUTSTANDING      5
#define KDC_ACCEPT_TIMEOUT              100
#define KDC_LISTEN_BACKLOG              10
#define KDC_CONTEXT_TIMEOUT             50

#define KDC_DATAGRAM_MIN_BUF_SIZE       0x8000      // 32k
#define KDC_DATAGRAM_DEF_BUF_SIZE       0x10000     // 64k
#define KDC_DATAGRAM_MAX_BUF_SIZE       0x40000     // 256k

extern BOOLEAN KdcSocketsInitialized;

typedef struct _KDC_DATAGRAM_ENDPOINT {
    SOCKADDR LocalAddress;
    PKDC_GET_TICKET_ROUTINE EndpointFunction;
    PVOID Endpoint;
} KDC_DATAGRAM_ENDPOINT, *PKDC_DATAGRAM_ENDPOINT;

PKDC_DATAGRAM_ENDPOINT DatagramEndpoints = NULL;
ULONG DatagramEndpointCount = 0;
CRITICAL_SECTION DatagramEndpointLock;

SOCKET KdcWinsockPnpSocket = INVALID_SOCKET;
HANDLE KdcWinsockPnpEvent = NULL;
HANDLE KdcPnpEventChangeHandle = NULL;



//+-------------------------------------------------------------------------
//
//  Function:   KdcAtqDgIoCompletion
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KdcAtqDgIoCompletion(
    IN PVOID Context,
    IN DWORD BytesWritten,
    IN DWORD CompletionStatus,
    IN OVERLAPPED * lpo
    )
{
    KERBERR KerbErr;
    PVOID Buffer;
    SOCKADDR * RemoteAddress = NULL;
    INT AddressSize;
    PATQ_CONTEXT AtqContext = (PATQ_CONTEXT) Context;
    SOCKET NewSocket = INVALID_SOCKET;
    KERB_MESSAGE_BUFFER InputMessage;
    KERB_MESSAGE_BUFFER OutputMessage;
    ULONG_PTR KdcContext;
    WSABUF SocketBuffer;
    PKDC_DATAGRAM_ENDPOINT Endpoint;
    TRACER(L"KdcAtqDgIoCompletion", NULL);
    
    TRACE(KDC,KdcAtqDgIoCompletion, DEB_FUNCTION);

    if (Context == NULL)
    {
        return;
    }

    KdcContext = AtqContextGetInfo(
                    AtqContext,
                    ATQ_INFO_COMPLETION_CONTEXT
                    );

    //
    // If the context is 1, then this is the completion from a write, so close
    // this down.
    //

    if (KdcContext == 1)
    {
        lpo = NULL;
    }

    //
    // If a client connects and then disconnects gracefully ,we will get a
    // completion with zero bytes and success status.
    //

    if ((BytesWritten == 0) && (CompletionStatus == NO_ERROR))
    {
        CompletionStatus = WSAECONNABORTED;
    }


    if ((CompletionStatus != NO_ERROR) || (lpo == NULL) || !KdcSocketsInitialized)
    {
        D_DebugLog((DEB_T_SOCK,"IoCompletion: CompletionStatus = 0x%x\n",CompletionStatus));
        D_DebugLog((DEB_T_SOCK,"IoCompletion: lpo = %p\n",lpo));
        D_DebugLog((DEB_T_SOCK, "Freeing context %p\n",AtqContext));

        if (CompletionStatus == ERROR_OPERATION_ABORTED)
        {
            AtqCloseSocket( AtqContext, TRUE );
            AtqFreeContext( (PATQ_CONTEXT) AtqContext, FALSE );
        }
        else
        {
            AtqFreeContext( (PATQ_CONTEXT) AtqContext, TRUE );
        }

        return;
    }

    AtqGetDatagramAddrs(
        AtqContext,
        &NewSocket,
        &Buffer,
        (PVOID *) &Endpoint,
        &RemoteAddress,
        &AddressSize
        );

    //
    // If the remote address is port 88, don't respond, as we don't
    // want to be vulnerable to a loopback attack.
    //

    if ((AddressSize >= sizeof(SOCKADDR_IN) &&
        ((((SOCKADDR_IN *) RemoteAddress)->sin_port ==  KERB_KDC_PORT) ||
        (((SOCKADDR_IN *) RemoteAddress)->sin_port ==  KERB_KPASSWD_PORT))))
    {
        //
        // Just free up the context so it can be reused.
        //

        AtqFreeContext( (PATQ_CONTEXT) AtqContext, TRUE );
        return;
    }




    //fester
    D_DebugLog((DEB_T_SOCK, "Bytes written - %x\n", BytesWritten));

    //
    // There is a buffer, so use it to do the KDC thang.
    //

    InputMessage.BufferSize = BytesWritten;
    InputMessage.Buffer = (PUCHAR) Buffer;
    OutputMessage.Buffer = NULL;

    
    //
    // This assert is here to help locate bug 154963.
    // If it fires, contact Todds
    //
    DsysAssert(DatagramEndpointCount != 0);

    // Perf counters for read
    KdcPerfCounterFunction(KDCCOREPERF_ATQ_RECV_BYTES_RATE, FLAG_COUNTER_INCREMENT, BytesWritten);
    KdcPerfCounterFunction(KDCCOREPERF_ATQ_RECV_PACKETS_RATE, FLAG_COUNTER_INCREMENT, 1);

    KerbErr = Endpoint->EndpointFunction(
        NULL,           // no atq context for retries
        RemoteAddress,
        &Endpoint->LocalAddress,
        &InputMessage,
        &OutputMessage
        );

    //
    // If there is a response, write it back to the sender.
    // We expect at least some level of message validity before
    // we'll return anything.
    //

    // Increment for every request
    KdcPerfCounterFunction(KDCCOREPERF_GOODRESPONSE_PERCENT_BASE, FLAG_COUNTER_INCREMENT, 1);
    KdcPerfCounterFunction(KDCCOREPERF_BADRESPONSE_PERCENT_BASE, FLAG_COUNTER_INCREMENT, 1);
    KdcPerfCounterFunction(KDCCOREPERF_BUSYRESPONSE_PERCENT_BASE, FLAG_COUNTER_INCREMENT, 1);
    KdcPerfCounterFunction(KDCCOREPERF_NORESPONSE_PERCENT_BASE, FLAG_COUNTER_INCREMENT, 1);

    if (OutputMessage.Buffer != NULL && KerbErr != KDC_ERR_NO_RESPONSE)
    {
        DsysAssert(OutputMessage.BufferSize < KDC_MAX_ACCEPT_BUFFER);

        memcpy(
            Buffer,
            OutputMessage.Buffer,
            OutputMessage.BufferSize
            );

        KdcFreeEncodedData(OutputMessage.Buffer);

        SocketBuffer.buf = (char *) Buffer;
        SocketBuffer.len = OutputMessage.BufferSize;

        AtqContextSetInfo(
            AtqContext,
            ATQ_INFO_COMPLETION_CONTEXT,
            1       
            );

        // Perf counters for write
        KdcPerfCounterFunction(KDCCOREPERF_ATQ_XMIT_BYTES_RATE, FLAG_COUNTER_INCREMENT, OutputMessage.BufferSize);
        KdcPerfCounterFunction(KDCCOREPERF_ATQ_XMIT_PACKETS_RATE, FLAG_COUNTER_INCREMENT, 1);

        if (KerbErr == KDC_ERR_NONE ||
            KerbErr == KDC_ERR_PREAUTH_REQUIRED)
        {
            KdcPerfCounterFunction(KDCCOREPERF_GOODRESPONSE_RATE, FLAG_COUNTER_INCREMENT, 1);
            KdcPerfCounterFunction(KDCCOREPERF_GOODRESPONSE_PERCENT, FLAG_COUNTER_INCREMENT, 100); // 1 * 100 (to convert to percent)
        }
        else if (KerbErr == KDC_ERR_SERVICE_NOTYET)
        {
            KdcPerfCounterFunction(KDCCOREPERF_BUSYRESPONSE_RATE, FLAG_COUNTER_INCREMENT, 1);
            KdcPerfCounterFunction(KDCCOREPERF_BUSYRESPONSE_PERCENT, FLAG_COUNTER_INCREMENT, 100); // 1 * 100 (to convert to percent)
        }
        else
        {
            KdcPerfCounterFunction(KDCCOREPERF_BADRESPONSE_RATE, FLAG_COUNTER_INCREMENT, 1);
            KdcPerfCounterFunction(KDCCOREPERF_BADRESPONSE_PERCENT, FLAG_COUNTER_INCREMENT, 100); // 1 * 100 (to convert to percent)
        }

        AtqWriteDatagramSocket(
            (PATQ_CONTEXT) AtqContext,
            &SocketBuffer,
            1,              // 1 buffer
            NULL            // no OVERLAPPED
            );
    }
    else
    {
        if (OutputMessage.Buffer != NULL)
        {
            MIDL_user_free(OutputMessage.Buffer);
            OutputMessage.Buffer = NULL;
        }
        //
        // Just free up the context so it can be reused.
        //

        AtqFreeContext( (PATQ_CONTEXT) AtqContext, TRUE );

        // Perf counters for no response
        KdcPerfCounterFunction(KDCCOREPERF_NORESPONSE_RATE, FLAG_COUNTER_INCREMENT, 1);
        KdcPerfCounterFunction(KDCCOREPERF_NORESPONSE_PERCENT, FLAG_COUNTER_INCREMENT, 100); // 1 * 100 (to convert to percent)

    }

}



//+-------------------------------------------------------------------------
//
//  Function:   KdcCreateDgAtqEndpoint
//
//  Synopsis:   Sets up a datagram endpoint
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KdcCreateDgAtqEndpoint(
    IN USHORT Port,
    IN PVOID EndpointContext,
    IN ULONG IpAddress,
    OUT PVOID * Endpoint
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    TRACER(L"KdcCreateDgAtqEndpoint", (PVOID *) &Status);
    ATQ_ENDPOINT_CONFIGURATION EndpointConfig;
    int RecvBufSize;

    DWORD cbType = 0;
    DWORD Value = 0;
    DWORD cbSize = 0;
    DWORD dwErr = ERROR_SUCCESS;
    DWORD dwDatagramWSBufSize = 0;

    HKEY hAtqParams = NULL;

    //
    // Create the endpoint config
    //

    EndpointConfig.ListenPort = Port;
    EndpointConfig.IpAddress = IpAddress;
    EndpointConfig.cbAcceptExRecvBuffer = KDC_MAX_ACCEPT_BUFFER;
    EndpointConfig.nAcceptExOutstanding = KDC_MAX_ACCEPT_OUTSTANDING;
    EndpointConfig.AcceptExTimeout = KDC_ACCEPT_TIMEOUT;

    EndpointConfig.pfnConnect = NULL;
    EndpointConfig.pfnConnectEx = KdcAtqDgIoCompletion;
    EndpointConfig.pfnIoCompletion = KdcAtqDgIoCompletion;

    EndpointConfig.fDatagram = TRUE;
    EndpointConfig.fLockDownPort = TRUE;

    // @@@ I like reverse queuing. See atq.h:392
    EndpointConfig.fReverseQueuing = FALSE;

    //
    // get the default value for the datagram buffer size
    //
    dwErr = RegOpenKeyExW(
               HKEY_LOCAL_MACHINE,
               L"System\\CurrentControlSet\\Services\\Kdc\\Parameters\\Atq",
               0,
               KEY_READ,
               &hAtqParams
               );

    if ( dwErr == ERROR_SUCCESS )
    {
        DsysAssert(hAtqParams);

        cbSize = sizeof(dwDatagramWSBufSize);
        dwErr = RegQueryValueExW(
                   hAtqParams,
                   L"DatagramWSBufSize",
                   NULL,
                   &cbType,
                   (LPBYTE)&dwDatagramWSBufSize,
                   &cbSize
                   );

        //
        // sanity checking
        //
        if (dwErr == ERROR_SUCCESS &&
            cbType == REG_DWORD &&
            cbSize == sizeof(DWORD) &&
            (dwDatagramWSBufSize <= KDC_DATAGRAM_MAX_BUF_SIZE) &&
            (dwDatagramWSBufSize >= KDC_DATAGRAM_MIN_BUF_SIZE) )
        {
            EndpointConfig.cbDatagramWSBufSize = dwDatagramWSBufSize;
        }
        else
        {
            EndpointConfig.cbDatagramWSBufSize = KDC_DATAGRAM_DEF_BUF_SIZE;
        }

        RegCloseKey(hAtqParams);
    }
    else
    {
        EndpointConfig.cbDatagramWSBufSize = KDC_DATAGRAM_DEF_BUF_SIZE;
    }

    *Endpoint = AtqCreateEndpoint(
                    &EndpointConfig,
                    EndpointContext
                    );
    if (*Endpoint == NULL)
    {
        DebugLog((DEB_ERROR,"Failed to create ATQ endpoint\n"));
        Status = STATUS_UNSUCCESSFUL;
        goto Cleanup;
    }

    //
    // Start the endpoint
    //

    if (!AtqStartEndpoint(*Endpoint))
    {
        DebugLog((DEB_ERROR, "Failed to add ATQ endpoint\n"));
        Status = STATUS_UNSUCCESSFUL;
        goto Cleanup;
    }
Cleanup:
    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KdcGetAddressListFromWinsock
//
//  Synopsis:   gets the list of addresses from a winsock ioctl
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KdcGetAddressListFromWinsock(
    OUT LPSOCKET_ADDRESS_LIST * SocketAddressList
    )
{
    ULONG BytesReturned = 150;
    LPSOCKET_ADDRESS_LIST AddressList = NULL;
    INT i,j;
    ULONG NetStatus = STATUS_SUCCESS;
    TRACER(L"KdcGetAddressListFromWinsock", NULL);
    
    for (;;) {

        //
        // Allocate a buffer that should be big enough.
        //

        if ( AddressList != NULL ) {
            MIDL_user_free( AddressList );
        }

        AddressList = (LPSOCKET_ADDRESS_LIST) MIDL_user_allocate( BytesReturned );

        if ( AddressList == NULL ) {
            NetStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        //
        // Get the list of IP addresses
        //

        NetStatus = WSAIoctl( KdcWinsockPnpSocket,
                              SIO_ADDRESS_LIST_QUERY,
                              NULL, // No input buffer
                              0,    // No input buffer
                              (PVOID) AddressList,
                              BytesReturned,
                              &BytesReturned,
                              NULL, // No overlapped,
                              NULL );   // Not async

        if ( NetStatus != 0 ) {
            NetStatus = WSAGetLastError();
            //
            // If the buffer isn't big enough, try again.
            //
            if ( NetStatus == WSAEFAULT ) {
                continue;
            }

            DebugLog((DEB_ERROR,"LdapUdpPnpBind: Cannot WSAIoctl SIO_ADDRESS_LIST_QUERY %ld %ld\n",
                      NetStatus, BytesReturned));
            goto Cleanup;
        }

        break;
    }

    //
    // Weed out any zero IP addresses and other invalid addresses
    //

    for ( i = 0, j = 0; i < AddressList->iAddressCount; i++ ) {
        PSOCKET_ADDRESS SocketAddress;

        //
        // Copy this address to the front of the list.
        //
        AddressList->Address[j] = AddressList->Address[i];

        //
        // If the address isn't valid,
        //  skip it.
        //
        SocketAddress = &AddressList->Address[j];

        if ( SocketAddress->iSockaddrLength == 0 ||
             SocketAddress->lpSockaddr == NULL ||
             SocketAddress->lpSockaddr->sa_family != AF_INET ||
             ((PSOCKADDR_IN)(SocketAddress->lpSockaddr))->sin_addr.s_addr == 0 ) {


        } else {

            //
            // Otherwise keep it.
            //

            j++;
        }
    }
    AddressList->iAddressCount = j;
    *SocketAddressList = AddressList;
    AddressList = NULL;
Cleanup:
    if (AddressList != NULL)
    {
        MIDL_user_free(AddressList);
    }
    if (NetStatus != ERROR_SUCCESS)
    {
        return  (STATUS_UNSUCCESSFUL);
    }
    else
    {
        return  (STATUS_SUCCESS);
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   KdcUpdateAddressesWorker
//
//  Synopsis:   Updates the IP addresses used for datagram sockest by
//              stopping the endpoints and then starting them with the
//              new addresses
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


ULONG
KdcUpdateAddressesWorker(
    IN KERBERR (NTAPI *pfnKdcGetTicket)(
            IN OPTIONAL PVOID Context,
            IN OPTIONAL PSOCKADDR ClientAddress,
            IN OPTIONAL PSOCKADDR ServerAddress,
            IN PKERB_MESSAGE_BUFFER InputMessage,
            OUT PKERB_MESSAGE_BUFFER OutputMessage
            )
    )            
{
    ULONG Index;
    INT IntIndex;
    ULONG EndpointIndex = 0;
    NTSTATUS Status = STATUS_SUCCESS;
    TRACER(L"KdcUpdateAddressesWorker", (PVOID *) &Status);
    
    LPSOCKET_ADDRESS_LIST AddressList = NULL;
    DWORD NetStatus;
    DWORD BytesReturned ;

    EnterCriticalSection(&DatagramEndpointLock);

    D_DebugLog(( DEB_TRACE, "KdcUpdateAddressesWorker\n" ));

    //
    // Tell winsock we want address list changes on this socket:
    //
    if ( KdcWinsockPnpSocket != INVALID_SOCKET )
    {
        NetStatus = WSAIoctl(
                        KdcWinsockPnpSocket,
                        SIO_ADDRESS_LIST_CHANGE,
                        NULL,
                        0,
                        NULL,
                        0,
                        &BytesReturned,
                        NULL,
                        NULL );

        if ( NetStatus != 0 )
        {
            NetStatus = WSAGetLastError();
            if ( NetStatus != WSAEWOULDBLOCK )
            {
                DebugLog((DEB_ERROR,"WSAIoctl failed with %ld\n", NetStatus ));
                Status = STATUS_UNSUCCESSFUL;
                goto Cleanup;
            }
        }
    }
    //
    // Cleanup any old endpoints
    //

    if (DatagramEndpoints != NULL)
    {
        for (Index = 0; Index < DatagramEndpointCount ; Index++ )
        {
            if (DatagramEndpoints[Index].Endpoint != NULL)
            {
                (VOID) AtqStopEndpoint( DatagramEndpoints[Index].Endpoint );
                (VOID) AtqCloseEndpoint( DatagramEndpoints[Index].Endpoint );
            }
        }
        MIDL_user_free(DatagramEndpoints);
        DatagramEndpoints = NULL;
        DatagramEndpointCount = 0;
    }

    //
    // Get the list of socket addresses
    //

    Status = KdcGetAddressListFromWinsock(
                &AddressList
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Create new endpoints
    //

    DatagramEndpoints = (PKDC_DATAGRAM_ENDPOINT) MIDL_user_allocate(
                            sizeof(KDC_DATAGRAM_ENDPOINT) * AddressList->iAddressCount * 2
                            );
    if (DatagramEndpoints == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }
    ZeroMemory(
        DatagramEndpoints,
        sizeof(KDC_DATAGRAM_ENDPOINT) * AddressList->iAddressCount * 2
        );

    //
    // Create an endpoint for the KDC and for KPASSWD for each transport
    //


    for (IntIndex = 0; IntIndex < AddressList->iAddressCount ; IntIndex++ )
    {
        memcpy(
            &DatagramEndpoints[EndpointIndex].LocalAddress,
            AddressList->Address[IntIndex].lpSockaddr,
            sizeof(SOCKADDR_IN)
            );
        DatagramEndpoints[EndpointIndex].EndpointFunction = pfnKdcGetTicket;

        Status = KdcCreateDgAtqEndpoint(
                    KERB_KDC_PORT,
                    &DatagramEndpoints[EndpointIndex],
                    ((PSOCKADDR_IN) &DatagramEndpoints[EndpointIndex].LocalAddress)->sin_addr.s_addr,
                    &DatagramEndpoints[EndpointIndex].Endpoint
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        EndpointIndex++;

#ifdef KPASSWD
        //
        // Create the KPASSWD endpoint
        //

        memcpy(
            &DatagramEndpoints[EndpointIndex].LocalAddress,
            AddressList->Address[IntIndex].lpSockaddr,
            sizeof(SOCKADDR_IN)
            );
        DatagramEndpoints[EndpointIndex].EndpointFunction = KdcChangePassword;

        Status = KdcCreateDgAtqEndpoint(
                    KERB_KPASSWD_PORT,
                    &DatagramEndpoints[EndpointIndex],
                    ((PSOCKADDR_IN) &DatagramEndpoints[EndpointIndex].LocalAddress)->sin_addr.s_addr,
                    &DatagramEndpoints[EndpointIndex].Endpoint
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        EndpointIndex++;
#endif
    }

    DatagramEndpointCount = EndpointIndex;

Cleanup:
    if (!NT_SUCCESS(Status))
    {
        if (DatagramEndpoints != NULL)
        {
            for (Index = 0; Index < EndpointIndex ; Index++ )
            {
                if (DatagramEndpoints[Index].Endpoint != NULL)
                {
                    (VOID) AtqStopEndpoint( DatagramEndpoints[Index].Endpoint );
                    (VOID) AtqCloseEndpoint( DatagramEndpoints[Index].Endpoint );
                }
            }
            MIDL_user_free(DatagramEndpoints);
            DatagramEndpoints = NULL;
            DatagramEndpointCount = 0;
        }

    }

    if (AddressList != NULL)
    {
        MIDL_user_free(AddressList);
    }
    LeaveCriticalSection(&DatagramEndpointLock);
    return((ULONG) Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   KdcUpdateAddressesThread
//
//  Synopsis:   Waits for the KdcWinsockPnpEvent to fire, then calls 
//            KdcUpdateAddressesWorker
//
//  Effects:
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
KdcUpdateAddressesThread(
    IN KERBERR (NTAPI *pfnKdcGetTicket)(
            IN OPTIONAL PVOID Context,
            IN OPTIONAL PSOCKADDR ClientAddress,
            IN OPTIONAL PSOCKADDR ServerAddress,
            IN PKERB_MESSAGE_BUFFER InputMessage,
            OUT PKERB_MESSAGE_BUFFER OutputMessage
            )
    )            
{
    NTSTATUS WaitStatus, Status;
    
    // Never returns
    for (;;)
    {
        WaitStatus = WaitForSingleObject(KdcWinsockPnpEvent, INFINITE);
        if ( WaitStatus == WAIT_OBJECT_0 ) {

            Status = KdcUpdateAddressesWorker( pfnKdcGetTicket );
            if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_ERROR,
                      "KdcUpdateAddressesThread: Worker error %ld %ld\n",
                      GetLastError(),
                      Status ));
            }

        } else {

                DebugLog((DEB_ERROR,
                         "KdcUpdateAddressesThread: error %ld %ld\n",
                         GetLastError(),
                         WaitStatus ));
            Sleep(5*1000);    // Slow down a failing loop

        }
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   KdcInitializeSockets
//
//  Synopsis:   Initializes the KDCs socket handling code
//
//  Effects:
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KdcInitializeDatagramSockets(
    KERBERR (NTAPI *pfnKdcGetTicket)(
            IN OPTIONAL PVOID Context,
            IN OPTIONAL PSOCKADDR ClientAddress,
            IN OPTIONAL PSOCKADDR ServerAddress,
            IN PKERB_MESSAGE_BUFFER InputMessage,
            OUT PKERB_MESSAGE_BUFFER OutputMessage
            )
    )            
{
    NTSTATUS Status = STATUS_SUCCESS;
    TRACER(L"KdcInitializeDatagramSockets", (PVOID *) &Status);
    DWORD NetStatus;
    

    TRACE(KDC,KdcDatagramInitializeSockets, DEB_FUNCTION);


    InitializeCriticalSection(&DatagramEndpointLock);

    //
    // Initialize the asynchronous thread queue.
    
    //

    if (!AtqInitialize(0))
    {
        DebugLog((DEB_ERROR,"Failed to initialize ATQ\n"));
        Status = STATUS_UNSUCCESSFUL;
        goto Cleanup;
    }

    //
    // Open a socket to get winsock PNP notifications on.
    //

    KdcWinsockPnpSocket = WSASocket( AF_INET,
                           SOCK_DGRAM,
                           0, // PF_INET,
                           NULL,
                           0,
                           0 );

    if ( KdcWinsockPnpSocket == INVALID_SOCKET ) {

        NetStatus = WSAGetLastError();
        DebugLog((DEB_ERROR,"WSASocket failed with %ld\n", NetStatus ));
        Status = STATUS_UNSUCCESSFUL;
        goto Cleanup;
    }


    //
    // Open an event to wait on.
    //

    KdcWinsockPnpEvent = CreateEvent(
                                  NULL,     // No security ettibutes
                                  FALSE,    // Auto reset
                                  FALSE,    // Initially not signaled
                                  NULL);    // No Name

    if ( KdcWinsockPnpEvent == NULL ) {
        NetStatus = GetLastError();
        DebugLog((DEB_ERROR,"Cannot create Winsock PNP event %ld\n", NetStatus ));
        Status = STATUS_UNSUCCESSFUL;
        goto Cleanup;
    }

    //
    // Associate the event with new addresses becoming available on the socket.
    //

    NetStatus = WSAEventSelect( KdcWinsockPnpSocket, KdcWinsockPnpEvent, FD_ADDRESS_LIST_CHANGE );

    if ( NetStatus != 0 ) {
        NetStatus = WSAGetLastError();
        DebugLog((DEB_ERROR,"Can't WSAEventSelect %ld\n", NetStatus ));
        Status = STATUS_UNSUCCESSFUL;
        goto Cleanup;
    }

    Status = (NTSTATUS) KdcUpdateAddressesWorker( pfnKdcGetTicket );
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to udpate datagram addresses\n"));
        goto Cleanup;
    }

    D_DebugLog((DEB_TRACE, "Successfully started ATQ listening\n"));


    if ( KdcPnpEventChangeHandle == NULL ) {
        KdcPnpEventChangeHandle = CreateThread(
            NULL,
            0,
            (LPTHREAD_START_ROUTINE)KdcUpdateAddressesThread,
            pfnKdcGetTicket,
            0,
            NULL
            );
        if (KdcPnpEventChangeHandle == NULL)
        {
            DebugLog((DEB_ERROR,"Failed to register KDC pnp event change handle.\n"));
        }
    }

Cleanup:

    if (!NT_SUCCESS(Status))
    {
        KdcShutdownSockets();
    }
    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KdcShutdownDatagramSockets
//
//  Synopsis:   Shuts down the KDC socket handling code
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KdcShutdownDatagramSockets(
    VOID
    )
{
    ULONG Index;
    TRACER(L"KdcShutdownDatagramSockets", NULL);
    TRACE(KDC,KdcShutdownSockets, DEB_FUNCTION);

    EnterCriticalSection(&DatagramEndpointLock);


    if ( KdcPnpEventChangeHandle != NULL ) {
        CloseHandle(KdcPnpEventChangeHandle);
        KdcPnpEventChangeHandle = NULL;
    }

    if ( KdcWinsockPnpEvent != NULL ) {
        CloseHandle(KdcWinsockPnpEvent);
        KdcWinsockPnpEvent = NULL;
    }

    if ( KdcWinsockPnpSocket != INVALID_SOCKET ) {
        closesocket(KdcWinsockPnpSocket);
        KdcWinsockPnpSocket = INVALID_SOCKET;
    }

    //
    // Go through the list of contexts and close them all.
    //

    if (DatagramEndpoints != NULL)
    {
        for (Index = 0; Index < DatagramEndpointCount ; Index++ )
        {
            if (DatagramEndpoints[Index].Endpoint != NULL)
            {
                (VOID) AtqStopEndpoint( DatagramEndpoints[Index].Endpoint );
                (VOID) AtqCloseEndpoint( DatagramEndpoints[Index].Endpoint );
            }
        }
        MIDL_user_free(DatagramEndpoints);
        DatagramEndpoints = NULL;
        DatagramEndpointCount = 0;
    }

    if (!AtqTerminate())
    {
        DebugLog((DEB_ERROR, "Failed to terminate ATQ!!!\n"));
    }

    LeaveCriticalSection(&DatagramEndpointLock);
    DeleteCriticalSection(&DatagramEndpointLock);

    return(STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\ad-service\kdcconfig.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2008
//
// File:        kdcconfig.cxx
//
// Contents:    Minimal NPDB configuration helpers for core KDC
//
// Notes:       Logging was done via typical DebugLog macros. Arguably
//              this is harder to use than the typical xbox logging
//              however it is in-line with what this project does
//------------------------------------------------------------------------
#include "adservp.h"

#include <commonconfig.h>
#include <ConfigListener.h>
#include <addref.h>
#include <xeventids.h>
#include <xmgmt.h>

#include "kdcconfig.h"

#import "CommonConfig.tlb" raw_interfaces_only, no_smart_pointers
using namespace XblConfig;

#import "XblHealthcheck.tlb" raw_interfaces_only, no_smart_pointers
using namespace XblHealthcheck;

class CKDCConfigListener;

//
// The class wraps around IConfig interface
//
class CKDCConfig
{
public:

    CKDCConfig();
    ~CKDCConfig();

    HRESULT Init();
    void Close();

    HRESULT Reload(struct ISettingChangeEventArgs *eventArgs);

    void GetKDCConfigOptions(KDC_CONFIG_OPTIONS* pKDCConfigOptions)
    {
        if( pKDCConfigOptions )
        {
            pKDCConfigOptions->ATQThreads = m_KDCConfigOptions.ATQThreads;
        }
    }

protected:

    HRESULT GetDWORDSetting(CComBSTR& bsSetting, DWORD* pdwNewValue, CComBSTR& bsValue = CComBSTR(NULL));

    KDC_CONFIG_OPTIONS m_KDCConfigOptions;
    
    CComPtr<IConfig> m_pConfig;

    CKDCConfigListener* m_pConfigListener;

    CComPtr<IHealthInterop> m_pHealthInterop;
};

//
// Derived class from the base listener class
//
class CKDCConfigListener : public CConfigListenerBase
{
    IMPLEMENT_REFCOUNT_COM

public:

    CKDCConfigListener() : m_pConfig(NULL)
    { 
    }

    virtual ~CKDCConfigListener() 
    {
    }

    virtual STDMETHODIMP SettingChange(struct ISettingChangeEventArgs * e)
    {
        return m_pConfig->Reload(e);
    }

    STDMETHODIMP QueryInterface( REFIID riid, void** ppObj )
    {
        HRESULT hr;

        if(ppObj == NULL)
        {
            return E_POINTER;
        }

        if(riid == IID_IUnknown)
        {
            *ppObj = (void*)(IUnknown*)this;
            hr = S_OK;
            AddRef();
        }
        else if(riid == __uuidof(IConfigListener))
        {
            *ppObj = (void*)(IConfigListener*)this;
            hr = S_OK;
            AddRef();
        }
        else
        {
            hr = E_NOINTERFACE;
        }

        return hr;
    }

    void RegisterConfig(CKDCConfig* pConfig)
    {
        //
        // one could perform various validation on the pointers
        // but the call pattern/usage makes this unnecessary
        //
        m_pConfig = pConfig;
    }

private:
    //
    //reference used for setting change call forwarding purposes
    //
    CKDCConfig* m_pConfig;
};

//
// CKDCConfig method implementation
//
CKDCConfig::CKDCConfig() :
    m_pConfig(NULL),
    m_pConfigListener(NULL),
    m_pHealthInterop(NULL)
{
    m_KDCConfigOptions.ATQThreads = ATQ_CONFIG_PARM_DEFAULT;
}

CKDCConfig::~CKDCConfig()
{
    Close();
}

//
// This methods initializes the listener interface and performs the
// first time load.
//
HRESULT CKDCConfig::Init()
{
    HRESULT hr = S_OK;
    CComBSTR bstrComponent;

    hr = m_pConfig.CoCreateInstance(__uuidof(ConfigInterop));
    if (FAILED(hr))
    {
        DebugLog((DEB_ERROR, "CKDCConfig::Init() - Failed to CoCreateInstance(ConfigInterop), hr=0x%08X", hr ));
        goto lDone;
    }

    m_pConfigListener = new CKDCConfigListener();
    if (m_pConfigListener != NULL)
    {
        m_pConfigListener->RegisterConfig(this);

        hr = m_pConfig->putref_ConfigListener(m_pConfigListener);
    }
    else
    {
        DebugLog((DEB_ERROR, "CKDCConfig::Init() - Failed to allocate memory"));
        hr = E_OUTOFMEMORY;
    }

    if (FAILED(hr))
    {
        DebugLog((DEB_ERROR, "CKDCConfig::Init() - Failed to register Config Listener object, hr=0x%08X", hr ));
        goto lDone;
    }

    hr = m_pHealthInterop.CoCreateInstance( __uuidof(HealthInterop) );
    if ( FAILED(hr) )
    {
        XomNtEvent(
            XEVENT_KDC_CONFIG_HEALTHINTEROP_CREATE,
            "CKDCConfig::Init() failed to instantiate HealthInterop "
            "with hr: 0x%08X. Verify xblhealthcheck.dll is in the GAC and it "
            "has been registered with regasm. Also verify the various XBL "
            "platform DLLs are in the GAC as well.", 
            hr
            );

        goto lDone;
    }

    // and fire up the http health listener
    m_pConfig->get_ComponentName(&bstrComponent);
    for (int i = 0; i < 12; i++) 
    {
        hr = m_pHealthInterop->Initialize(bstrComponent, (LONG_PTR)::GetModuleHandle(NULL));
        // create the health interop instances 
        if (!FAILED(hr)) 
        {
            break;
        }

        // Wait a bit so that we can try again.
        Sleep(500);
    }
    if ( FAILED(hr) )
    {
        XomNtEvent(
            XEVENT_KDC_CONFIG_HEALTHINTEROP_INIT,
            "CKDCConfig::Init() failed to call Initialize on the "
            "HealthInterop instance with hr: 0x%08X. Verify xblhealthcheck.dll "
            "is installed correclty in the GAC",
            hr
            );

        goto lDone;
    }

    //
    // First time load
    //
    hr = Reload(NULL);

lDone:

    return hr;
}

void CKDCConfig::Close()
{
    if (m_pConfig && m_pConfigListener)
    {
        m_pConfig->putref_ConfigListener(NULL);
        m_pConfigListener->Release();
        m_pConfigListener = NULL;
    }

    if (m_pConfig)
    {
        m_pConfig.Release();
        m_pConfig = NULL;
    }

    if (m_pHealthInterop)
    {
        m_pHealthInterop.Release();
        m_pHealthInterop = NULL;
    }
}

HRESULT CKDCConfig::Reload(struct ISettingChangeEventArgs * eventArgs)
{
    HRESULT hr = S_OK;
    DWORD dwRetValue = 0;

    if (eventArgs == NULL)
    {
        //
        // this means it's the call during the startup path
        //
        hr = GetDWORDSetting(Setting_kdcsvc_core_ATQThreads, &dwRetValue);
        if ( SUCCEEDED(hr) )
        {
            m_KDCConfigOptions.ATQThreads = dwRetValue;
        }
    }
    else
    {
        // else dynamic config change.
        
        CComBSTR SettingChange;
        CComBSTR bsValueNew;

        hr = eventArgs->get_Setting(&SettingChange);
        if (FAILED(hr))
        {
            DebugLog((DEB_ERROR, "CKDCConfig::Reload() - Failed to get_Setting(), hr=0x%08X", hr ));
            goto lDone;
        }
        
        hr = eventArgs->get_ValueNew(&bsValueNew);
        if (FAILED(hr))
        {
            DebugLog((DEB_ERROR, "CKDCConfig::Reload() - Failed to get_ValueNew(), hr=0x%08X", hr ));
            goto lDone;
        }
        
        //
        // Note: If a significant number of settings are added here consider
        // separating this logic into another method
        //
        if (SettingChange == Setting_kdcsvc_core_ATQThreads)
        {
            //
            // The small race condition below is acceptable in real life considering
            // the cost of locking
            //
            hr = GetDWORDSetting(SettingChange, &dwRetValue, bsValueNew);
            if ( FAILED(hr) )
            {
                DebugLog((DEB_ERROR, "CKDCConfig::Reload() - Failed to GetDWORDSetting(), hr=0x%08X", hr ));
                goto lDone;
            }

            DWORD dwOldValue = (DWORD)AtqGetInfo(AtqMaxPoolThreads);

            //
            // we intentionally support only increasing the value via this mechanism
            //
            if( (dwRetValue > dwOldValue) && (dwRetValue <= (DWORD)AtqGetInfo(AtqPoolThreadsLimit)) )
            {
                m_KDCConfigOptions.ATQThreads = dwRetValue;
                AtqSetInfo(AtqMaxPoolThreads, m_KDCConfigOptions.ATQThreads);

                hr = S_OK;
            }
            else
            {
                DebugLog((DEB_ERROR, "CKDCConfig::Reload() - Reject change (%d, %d)", dwOldValue, dwRetValue));
                hr = E_FAIL;
            }

            //
            // In addition one can batch change requests to avoid config change storms
            // The KDC providers seem OK with not caring about this scenario, hence no measures
            // are taken for core either.
            //
        }
    }

lDone:
    
    return hr;
}

HRESULT CKDCConfig::GetDWORDSetting(CComBSTR& bsSetting, DWORD* pdwNewValue, CComBSTR& bsValue)
{
    return S_OK;
}

//
// This is the global instance
//
CKDCConfig g_KDCConfigInstance;

HRESULT InitializeConfigInstance()
{
    return g_KDCConfigInstance.Init();
}

void DestroyConfigInstance()
{
    g_KDCConfigInstance.Close();
}

void GetKDCConfigOptions(KDC_CONFIG_OPTIONS* pKDCConfigOptions)
{
    g_KDCConfigInstance.GetKDCConfigOptions(pKDCConfigOptions);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\ad-service\kdcevent.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    kdcevent.h

Abstract:

    Definitions for POP3 Server Events

Author:

    RichardW,  3 Mar 95

Revision History:

Notes:

    This file is generated by the MC tool from the pop3evnt.mc file.

--*/


#ifndef __KDCEVENT_H__
#define __KDCEVENT_H__

//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3


//
// MessageId: CATEGORY_KDC
//
// MessageText:
//
//  KDC
//
#define CATEGORY_KDC                     0x00000001L

//
// MessageId: CATEGORY_MAX_CATEGORY
//
// MessageText:
//
//  Max
//
#define CATEGORY_MAX_CATEGORY            0x00000002L

//
// MessageId: KDCEVENT_UNKNOWN_PRINCIPAL
//
// MessageText:
//
//  Could not find principal %1
//
#define KDCEVENT_UNKNOWN_PRINCIPAL       0x80000003L

//
// MessageId: KDCEVENT_FAILED_DOMAIN_CREDS
//
// MessageText:
//
//  Domain %1 propagated to us but did not authenticate
//
#define KDCEVENT_FAILED_DOMAIN_CREDS     0x80000004L

//
// MessageId: KDCEVENT_POLICY_UPDATE_FAILED
//
// MessageText:
//
//  The KDC failed to update policy class %1. The error is in the data.
//
#define KDCEVENT_POLICY_UPDATE_FAILED    0xC0000005L

//
// MessageId: KDCEVENT_DOMAIN_LIST_UPDATE_FAILED
//
// MessageText:
//
//  The KDC failed to update the trusted domain list. The error is in the data.
//
#define KDCEVENT_DOMAIN_LIST_UPDATE_FAILED 0xC0000006L

//
// MessageId: KDCEVENT_SAM_CALL_FAILED
//
// MessageText:
//
//  The Security Account Manager failed a KDC request in an unexpected way. The
//  error is in the data field. The account name was %1 and lookup type %2.
//
#define KDCEVENT_SAM_CALL_FAILED         0xC0000007L

//
// MessageId: KDCEVENT_NO_KEY_TYPE
//
// MessageText:
//
//  The account %1 did not have a suitable key for generating a Kerberos ticket.
//  If the encryption type is supported, changing or setting the password will
//  generate a proper key.  The missing key type may be in the data field.
//
#define KDCEVENT_NO_KEY_TYPE             0xC0000008L

//
// MessageId: KDCEVENT_KRBTGT_PASSWORD_CHANGED
//
// MessageText:
//
//  The password on the KRBTGT account was changed.
//
#define KDCEVENT_KRBTGT_PASSWORD_CHANGED 0x00000009L

//
// MessageId: KDCEVENT_KRBTGT_PASSWORD_CHANGE_FAILED
//
// MessageText:
//
//  The attempt to change the password on the KRBTGT account failed. The error
//  code is in the data field
//
#define KDCEVENT_KRBTGT_PASSWORD_CHANGE_FAILED 0xC000000AL

//
// MessageId: KDCEVENT_NAME_NOT_UNIQUE
//
// MessageText:
//
//  There are multiple accounts with name %1 of type %2.
//
#define KDCEVENT_NAME_NOT_UNIQUE         0xC000000BL

//
// MessageId: KDCEVENT_FAILED_TRANSITIVE_TRUST
//
// MessageText:
//
//  A request failed from client realm %1 for a ticket in realm %2.  
//  This failed because a trust link between the realms is non transitive.
//
#define KDCEVENT_FAILED_TRANSITIVE_TRUST 0x8000000CL

//
// MessageId: KDCEVENT_CORRUPT_CREDENTIALS
//
// MessageText:
//
//  The account for %1 has corrupt keys stored in the DS.  Changing
//  or setting the password should restore correct keys.
//
#define KDCEVENT_CORRUPT_CREDENTIALS     0xC000000DL

//
// MessageId: KDCEVENT_NO_KEY_UNION_AS
//
// MessageText:
//
//  While processing an AS request, the account %1 did not have a suitable key 
//  for generating a Kerberos ticket.  
//  The requested etypes were %2.  
//  The accounts available etypes were %3. 
//  If the encryption type is supported, changing or setting the password will
//  generate a proper key.  
//
#define KDCEVENT_NO_KEY_UNION_AS         0xC000000EL

//
// MessageId: KDCEVENT_INVALID_FORWARDED_AS_REQ
//
// MessageText:
//
//  The request for an AS ticket for client %1 was forwarded to the PDC.  An 
//  invalid response to this forwarded request was detected and could indicate an
//  attempt to spoof your PDC.  There may be additional information in the data field. 
//
#define KDCEVENT_INVALID_FORWARDED_AS_REQ 0xC000000FL

//
// MessageId: KDCEVENT_NO_KEY_UNION_TGS
//
// MessageText:
//
//  While processing a TGS request for the target server %1, the account %2 did not 
//  have a suitable key for generating a Kerberos ticket.  
//  The requested etypes were %3.  
//  The accounts available etypes were %4. 
//  If the encryption type is supported, changing or setting the password will
//  generate a proper key.  
//
#define KDCEVENT_NO_KEY_UNION_TGS        0xC0000010L

//
// MessageId: KDCEVENT_INVALID_POLICY
//
// MessageText:
//
//  When updating policy class %1, the KDC encountered invalid policy data
//  and has failed to update the policy.
//
#define KDCEVENT_INVALID_POLICY          0xC0000011L

//
// MessageId: KDCEVENT_PAC_VERIFICATION_FAILURE
//
// MessageText:
//
//  During TGS processing, the KDC was unable to verify the signature on the 
//  PAC from %1. This indicates the PAC was modified.
//
#define KDCEVENT_PAC_VERIFICATION_FAILURE 0xC0000012L

//
// MessageId: KDCEVENT_NO_KDC_CERTIFICATE
//
// MessageText:
//
//  This event indicates an attempt was made to use smartcard logon, 
//  but the KDC is unable to use the PKINIT protocol because it is missing a 
//  suitable certificate.  
//
#define KDCEVENT_NO_KDC_CERTIFICATE      0x80000013L

//
// MessageId: KDCEVENT_INVALID_KDC_CERTIFICATE
//
// MessageText:
//
//  The currently selected KDC certificate was once valid, but now is invalid
//  and no suitable replacement was found.  Smartcard logon may not function correctly
//  if this problem is not remedied.  Have the system administrator check on the 
//  state of the domain's public key infrastructure.  The chain status is in 
//  the error data.
//
#define KDCEVENT_INVALID_KDC_CERTIFICATE 0x80000014L

//
// MessageId: KDCEVENT_INVALID_CLIENT_CERTIFICATE
//
// MessageText:
//
//  The client certificate for the user %1 is not valid, and resulted in a 
//  failed smartcard logon.  Please contact the user for more information 
//  about the certificate they're attempting to use for smartcard logon.  The 
//  chain status is in the error data.
//
#define KDCEVENT_INVALID_CLIENT_CERTIFICATE 0x80000015L

//
// MessageId: KDCEVENT_TRUST_LOOP
//
// MessageText:
//
//  The KDC encountered a trust loop when building a list of trusted domains.  
//  This indicates that the route to the domain %1 from this KDC has more than 
//  one possible trust path.
//
#define KDCEVENT_TRUST_LOOP              0x80000016L


#endif // __KDCEVENT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\ad-service\sockutil.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1995
//
// File:        sockutil.h
//
// Contents:    Prototypes and types for KDC socket utility functions
//
//
// History:     12-July-1996    MikeSw          Created
//
//------------------------------------------------------------------------

#ifndef __SOCKUTIL_H__
#define __SOCKUTIL_H__

#include <winsock2.h>

#define MIDL_user_allocate(_n_)	KdcAllocMemory(_n_)
#define MIDL_user_free(_pv_)	KdcFreeMemory(_pv_)

typedef struct _KDC_ATQ_CONTEXT {
    LIST_ENTRY Next;
    ULONG References;
    PVOID AtqContext;
    PVOID EndpointContext;
    OVERLAPPED * lpo;
    SOCKADDR Address;
    SOCKADDR LocalAddress;
    PBYTE WriteBuffer;
    ULONG WriteBufferLength;
    ULONG Flags;
    ULONG UsedBufferLength;
    ULONG BufferLength;
    ULONG ExpectedMessageSize;
    PUCHAR Buffer;
} KDC_ATQ_CONTEXT, *PKDC_ATQ_CONTEXT;

#define KDC_ATQ_WRITE_CONTEXT   0x1
#define KDC_ATQ_READ_CONTEXT    0x2
#define KDC_ATQ_SOCKET_CLOSED   0x4
#define KDC_ATQ_SOCKET_USED     (KDC_ATQ_WRITE_CONTEXT | KDC_ATQ_READ_CONTEXT)
#define KDC_MAX_BUFFER_LENGTH 0x20000        // maximum size receive buffer = 128k





NTSTATUS
KdcInitializeSockets(
            KERBERR (NTAPI *pfnKdcGetTicket)(
                    IN OPTIONAL PVOID Context,
                    IN OPTIONAL PSOCKADDR ClientAddress,
                    IN OPTIONAL PSOCKADDR ServerAddress,
                    IN PKERB_MESSAGE_BUFFER InputMessage,
                    OUT PKERB_MESSAGE_BUFFER OutputMessage
                    ),
            IKdcCore *,
            const ATQ_CONFIG_PARM *pAtqConfigParm
    );

NTSTATUS
KdcShutdownSockets(
    VOID
    );

NTSTATUS
KdcInitializeDatagramReceiver(
    VOID
    );

KERBERR
KdcAtqRetrySocketRead(
    IN PKDC_ATQ_CONTEXT * Context,
    IN PKERB_MESSAGE_BUFFER OldMessage
    );

#endif // __SOCKUTIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\ad-service\sockutil.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1995
//
// File:        sockutil.cxx
//
// Contents:    Server support routines for sockets
//
//
// History:     10-July-1996    MikeSw  Created
//
//------------------------------------------------------------------------

#include "adservp.h"


#define KDC_KEY                         "System\\CurrentControlSet\\Services\\kdc"
#define KDC_PARAMETERS_KEY KDC_KEY      "\\parameters"
#define KDC_MAX_ACCEPT_BUFFER           5000
#define KDC_MAX_ACCEPT_OUTSTANDING      5
#define KDC_ACCEPT_TIMEOUT              100
#define KDC_LISTEN_BACKLOG              10
#define KDC_CONTEXT_TIMEOUT             50

BOOLEAN KdcSocketsInitialized = FALSE;
PVOID KdcEndpoint = NULL;
PVOID KpasswdEndpoint = NULL;
CRITICAL_SECTION KdcAtqContextLock;
LIST_ENTRY KdcAtqContextList;




NTSTATUS
KdcInitializeDatagramSockets(
        KERBERR (NTAPI *pfnKdcGetTicket)(
            IN OPTIONAL PVOID Context,
            IN OPTIONAL PSOCKADDR ClientAddress,
            IN OPTIONAL PSOCKADDR ServerAddress,
            IN PKERB_MESSAGE_BUFFER InputMessage,
            OUT PKERB_MESSAGE_BUFFER OutputMessage
    )
    );

NTSTATUS
KdcShutdownDatagramSockets(
    VOID
    );



//+-------------------------------------------------------------------------
//
//  Function:   KdcAtqCloseSocket
//
//  Synopsis:   Wrapper to close socket to avoid socket leaks
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
VOID
KdcAtqCloseSocket(
    IN PKDC_ATQ_CONTEXT Context
    )
{
    D_DebugLog ((DEB_T_SOCK, "Closing socket for 0x%x\n", Context));
    AtqCloseSocket((PATQ_CONTEXT) Context->AtqContext, TRUE);
    Context->Flags |= KDC_ATQ_SOCKET_CLOSED;
}




//+-------------------------------------------------------------------------
//
//  Function:   KdcAtqReferenceContext
//
//  Synopsis:   References a kdc ATQ context by one
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KdcAtqReferenceContext(
    IN PKDC_ATQ_CONTEXT Context
    )
{
    D_DebugLog ((DEB_T_SOCK, "Referencing KdcContext 0x%x\n", Context));
    EnterCriticalSection(&KdcAtqContextLock);
    Context->References++;
    LeaveCriticalSection(&KdcAtqContextLock);
}


//+-------------------------------------------------------------------------
//
//  Function:   KdcAtqDereferenceContext
//
//  Synopsis:   Dereferences a context & unlinks & frees it when the
//              ref count goes to zero
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


BOOLEAN
KdcAtqDereferenceContext(
    IN PKDC_ATQ_CONTEXT * KdcContext
    )
{
    PKDC_ATQ_CONTEXT Context = *KdcContext;
    BOOLEAN Deleted = FALSE;

    TRACER(L"KdcAtqDereferenceContext", (PVOID *) &Deleted);
    D_DebugLog ((DEB_T_SOCK, "Dereferencing KdcContext 0x%x\n", Context));

    if (Context == NULL)
    {
        goto Cleanup;
    }

    EnterCriticalSection(&KdcAtqContextLock);
    Context->References--;

    if (Context->References == 0)
    {
        Deleted = TRUE;
        RemoveEntryList(
            &Context->Next
            );
    }
    LeaveCriticalSection(&KdcAtqContextLock);

    if (Deleted)
    {

        if (((Context->Flags &  KDC_ATQ_SOCKET_USED) != 0) &&
            ((Context->Flags & KDC_ATQ_SOCKET_CLOSED) == 0))
        {
            KdcAtqCloseSocket( Context );
        }


        D_DebugLog ((DEB_T_SOCK, "Deleting KdcContext 0x%x\n", Context));
        AtqFreeContext( (PATQ_CONTEXT) Context->AtqContext, TRUE );

        if (Context->WriteBuffer != NULL)
        {
            KdcFreeEncodedData(Context->WriteBuffer);
        }
        if (Context->Buffer != NULL)
        {
            MIDL_user_free(Context->Buffer);
        }
        MIDL_user_free(Context);
        *KdcContext = NULL;

    }

Cleanup:
    return(Deleted);

}


//+-------------------------------------------------------------------------
//
//  Function:   KdcAtqCreateContext
//
//  Synopsis:   Creates & links an ATQ context
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------



PKDC_ATQ_CONTEXT
KdcAtqCreateContext(
    IN PATQ_CONTEXT AtqContext,
    IN PVOID EndpointContext,
    IN LPOVERLAPPED lpo,
    IN PSOCKADDR ClientAddress,
    IN PSOCKADDR ServerAddress
    )
{
    TRACER(L"KdcAtqCreateContext", NULL);
    PKDC_ATQ_CONTEXT KdcContext;

    if (!KdcSocketsInitialized)
    {
        return(NULL);
    }

    KdcContext = (PKDC_ATQ_CONTEXT) MIDL_user_allocate(sizeof(KDC_ATQ_CONTEXT));
    if (KdcContext != NULL)
    {
        ZeroMemory(
            KdcContext,
            sizeof(KDC_ATQ_CONTEXT)
            );
        KdcContext->AtqContext = AtqContext;
        KdcContext->Flags = KDC_ATQ_WRITE_CONTEXT;
        KdcContext->BufferLength = KERB_MAX_KDC_REQUEST_SIZE;
        KdcContext->UsedBufferLength = 0;
        KdcContext->lpo = lpo;
        KdcContext->EndpointContext = EndpointContext;
        KdcContext->ExpectedMessageSize = 0;
        KdcContext->WriteBuffer = NULL;
        KdcContext->References = 2;             // one for the list, one for this copy

        memcpy(
            &KdcContext->Address,
            ClientAddress,
            sizeof(SOCKADDR)
            );
        memcpy(
            &KdcContext->LocalAddress,
            ServerAddress,
            sizeof(SOCKADDR)
            );

        KdcContext->Buffer = (PUCHAR) MIDL_user_allocate(KERB_MAX_KDC_REQUEST_SIZE);
        if (KdcContext->Buffer == NULL)
        {
            MIDL_user_free(KdcContext);
            KdcContext = NULL;
        }
        else
        {
            EnterCriticalSection( &KdcAtqContextLock );
            InsertHeadList(&KdcAtqContextList, &KdcContext->Next);
            LeaveCriticalSection( &KdcAtqContextLock );
        }
    }
    D_DebugLog ((DEB_T_SOCK, "Creating KdcContext 0x%x\n", KdcContext));
    return(KdcContext);
}

//+-------------------------------------------------------------------------
//
//  Function:   KdcAtqConnectEx
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KdcAtqConnectEx(
    IN PVOID Context,
    IN DWORD BytesWritten,
    IN DWORD CompletionStatus,
    IN OVERLAPPED * lpo
    )
{
    KERBERR KerbErr;
    PKDC_ATQ_CONTEXT KdcContext = NULL;
    PATQ_CONTEXT AtqContext = (PATQ_CONTEXT) Context;
    SOCKADDR * LocalAddress = NULL;
    SOCKADDR * RemoteAddress = NULL;
    SOCKET NewSocket = INVALID_SOCKET;
    KERB_MESSAGE_BUFFER InputMessage;
    KERB_MESSAGE_BUFFER OutputMessage;
    PVOID Buffer;
    PKDC_GET_TICKET_ROUTINE EndpointFunction = NULL;
    ULONG TotalBytes;


    TRACER(L"KdcAtqConnectEx", NULL);
    TRACE(KDC,KdcAtqConnectEx, DEB_FUNCTION);

    if ((CompletionStatus != NO_ERROR) || !KdcSocketsInitialized)
    {
        D_DebugLog((DEB_T_SOCK," ConnectEx: CompletionStatus = 0x%x\n",CompletionStatus));
        AtqCloseSocket( AtqContext, TRUE );
        D_DebugLog((DEB_T_SOCK, "Freeing context %p\n",AtqContext));
        AtqFreeContext( AtqContext, TRUE );
        return;
    }

    //
    // Get the address information including the first write buffer
    //

    AtqGetAcceptExAddrs(
        AtqContext,
        &NewSocket,
        &Buffer,
        (PVOID *) &EndpointFunction,
        &LocalAddress,
        &RemoteAddress
        );

    //
    // Verify that the size is something OK before continuing on
    //

    //
    // Read the number of bytes off the front of the message
    //
    if (BytesWritten >= sizeof(ULONG))
    {
        TotalBytes = ntohl(*(PULONG)Buffer);
        if (TotalBytes >= KDC_MAX_BUFFER_LENGTH)
        {
            D_DebugLog((DEB_T_SOCK, "Received huge buffer - %x, bailing out now\n", TotalBytes));
            AtqCloseSocket( AtqContext, TRUE );
            AtqFreeContext( AtqContext, TRUE );
            return;
        }

    }
    else
    {
        AtqCloseSocket( AtqContext, TRUE );
        AtqFreeContext( AtqContext, TRUE );
        return;
    }



    //
    // If the remote address is port 88 or 464, don't respond, as we don't
    // want to be vulnerable to a loopback attack.
    //

    if ((((SOCKADDR_IN *) RemoteAddress)->sin_port == KERB_KDC_PORT) ||
        (((SOCKADDR_IN *) RemoteAddress)->sin_port == KERB_KPASSWD_PORT))
    {
        //
        // Just free up the context so it can be reused.
        //
        AtqCloseSocket( AtqContext, TRUE );
        AtqFreeContext( AtqContext, TRUE );
        return;
    }


    //
    // Set the timeout for future IOs on this context
    //

    AtqContextSetInfo(
        AtqContext,
        ATQ_INFO_TIMEOUT,
        KDC_CONTEXT_TIMEOUT
        );

    //
    // Create a context
    //

    KdcContext = KdcAtqCreateContext(
                    AtqContext,
                    EndpointFunction,
                    lpo,
                    RemoteAddress,
                    LocalAddress
                    );

    if (KdcContext == NULL)
    {
        AtqCloseSocket( AtqContext, TRUE );
        AtqFreeContext( AtqContext, TRUE );
        return;
    }

    AtqContextSetInfo(
        AtqContext,
        ATQ_INFO_COMPLETION_CONTEXT,
        (ULONG_PTR) KdcContext
        );


    //
    // If we didn't receive all the data, go ahead and read more
    //

    KdcContext->ExpectedMessageSize = TotalBytes + sizeof(ULONG);

    if (KdcContext->ExpectedMessageSize > BytesWritten)
    {
        InputMessage.BufferSize = BytesWritten;
        InputMessage.Buffer = (PUCHAR) Buffer;


        KerbErr = KdcAtqRetrySocketRead(
            &KdcContext,
            &InputMessage
            );

        if (!KERB_SUCCESS(KerbErr))
        {
            DebugLog((DEB_ERROR, "Closing connection due to RetrySocketRead error\n"));
            DsysAssert(KdcContext->References == 1);
        }

        KdcAtqDereferenceContext(&KdcContext);
        return;
    }
    InputMessage.BufferSize = BytesWritten - sizeof(ULONG);
    InputMessage.Buffer = (PUCHAR) Buffer + sizeof(ULONG);
    OutputMessage.Buffer = NULL;


    //
    // Call either the KdcGetTicket or KdcChangePassword function, based
    // on which endpoint was used
    //

    KerbErr = EndpointFunction(
                    &KdcContext,
                    &KdcContext->Address,
                    &KdcContext->LocalAddress,
                    &InputMessage,
                    &OutputMessage
                    );

    if ((KerbErr != KDC_ERR_NONE) || (OutputMessage.BufferSize != 0))
    {

        //
        // We expect at least some level of message validity before
        // we'll return anything.
        //
        if (KerbErr == KDC_ERR_NO_RESPONSE)
        {
            // TBD:  Log an "attack" event here.
            DebugLog((DEB_ERROR, "Bad buffer recieved, closing socket\n"));
            KdcAtqCloseSocket(KdcContext);
            KdcAtqDereferenceContext(&KdcContext);
        }
        else
        {
            ULONG NetworkSize;
            WSABUF Buffers[2];

            NetworkSize = htonl(OutputMessage.BufferSize);

            Buffers[0].len = sizeof(DWORD);
            Buffers[0].buf = (PCHAR) &NetworkSize;

            Buffers[1].len = OutputMessage.BufferSize;
            Buffers[1].buf = (PCHAR) OutputMessage.Buffer;
            KdcContext->WriteBufferLength = OutputMessage.BufferSize;
            KdcContext->WriteBuffer = OutputMessage.Buffer;

            OutputMessage.Buffer = NULL;

            //
            // Reference the context for the read
            //

            KdcAtqReferenceContext(KdcContext);

            if (!AtqWriteSocket(
                    (PATQ_CONTEXT) KdcContext->AtqContext,
                    Buffers,
                    2,
                    lpo
                    ))
            {
                DebugLog((DEB_ERROR,"Failed to write kdc reply to atq: %0x%x\n",GetLastError()));
                KdcAtqDereferenceContext(&KdcContext);
            }
        }

    }
    if (OutputMessage.Buffer != NULL)
    {
        MIDL_user_free(OutputMessage.Buffer);
    }

    KdcAtqDereferenceContext(&KdcContext);

}


//+-------------------------------------------------------------------------
//
//  Function:   KdcAtqIoCompletion
//
//  Synopsis:   Callback routine for an io completion on a TCP socket
//              for the KDC
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KdcAtqIoCompletion(
    IN PVOID Context,
    IN DWORD BytesWritten,
    IN DWORD CompletionStatus,
    IN OVERLAPPED * lpo
    )
{
    PKDC_ATQ_CONTEXT KdcContext;
    KERB_MESSAGE_BUFFER InputMessage;
    KERB_MESSAGE_BUFFER OutputMessage;
    PKDC_GET_TICKET_ROUTINE EndpointFunction = NULL;

    TRACE(KDC,KdcAtqIoCompletion, DEB_FUNCTION);
    TRACER(L"KdcAtqIoCompletion", NULL);
    if (Context == NULL)
    {
        return;
    }

    //
    // If a client connects and then disconnects gracefully ,we will get a
    // completion with zero bytes and success status.
    //

    if ((BytesWritten == 0) && (CompletionStatus == NO_ERROR))
    {
        CompletionStatus = WSAECONNABORTED;
    }


    KdcContext = (PKDC_ATQ_CONTEXT) Context;


    if ((CompletionStatus != NO_ERROR) || (lpo == NULL) || !KdcSocketsInitialized)
    {
        D_DebugLog((DEB_T_SOCK,"IoCompletion: CompletionStatus = 0x%x\n",CompletionStatus));
        D_DebugLog((DEB_T_SOCK,"IoCompletion: lpo = %p\n",lpo));



        KdcAtqCloseSocket(  KdcContext );

        D_DebugLog((DEB_T_SOCK, "Freeing context %p\n",KdcContext->AtqContext));

        //
        // If the overlapped structure is not null, then there is an
        // outstanding IO that just completed, so dereference the context
        // to remove that i/o. Otherwise leave the reference there, as we will
        // probably be called back when the io terminates.
        //

        if (lpo != NULL)
        {
            KdcAtqDereferenceContext(&KdcContext);
        }

        goto Cleanup;
    }


    //
    // NOTE: after reading or writing to a context, the context should
    // not be touched because a completion may have occurred on another
    // thread that may delete the context.
    //

    if ((KdcContext->Flags & KDC_ATQ_READ_CONTEXT) != 0)
    {
        KERBERR KerbErr;
        ULONG TotalBytes = 0;

        //
        // Read the number of bytes off the front of the message
        //

        if (KdcContext->UsedBufferLength == 0)
        {
            if (BytesWritten >= sizeof(ULONG))
            {
                KdcContext->ExpectedMessageSize = ntohl(*(PULONG)KdcContext->Buffer);
            }
            else
            {
                DebugLog((DEB_ERROR,"Read completion with no data!\n"));
                goto Cleanup;
            }
        }

        //
        // Figure out if we've already read all the data we need
        //

        TotalBytes = KdcContext->UsedBufferLength + BytesWritten;
        if (TotalBytes < KdcContext->ExpectedMessageSize)
        {
            InputMessage.BufferSize = BytesWritten ;
            InputMessage.Buffer = (PUCHAR) KdcContext->Buffer;

            KerbErr = KdcAtqRetrySocketRead(
                            &KdcContext,
                            &InputMessage
                            );

            if (!KERB_SUCCESS(KerbErr))
            {
                //fester
                DebugLog((DEB_ERROR, "Closing connection due to RetrySocketRead error\n"));
                DsysAssert(KdcContext->References == 1);

            }

            goto Cleanup;
        }
        TotalBytes = ntohl(*(PULONG)KdcContext->Buffer);
        KdcContext->ExpectedMessageSize = TotalBytes + sizeof(ULONG);

        if (KdcContext->UsedBufferLength + BytesWritten < KdcContext->ExpectedMessageSize)
        {
            InputMessage.BufferSize = BytesWritten ;
            InputMessage.Buffer = (PUCHAR) KdcContext->Buffer;

            KerbErr = KdcAtqRetrySocketRead(
                            &KdcContext,
                            &InputMessage
                            );

            if (!KERB_SUCCESS(KerbErr))
            {
                //fester
                DebugLog((DEB_ERROR, "Closing connection due to RetrySocketRead error\n"));
                DsysAssert(KdcContext->References == 1);
            }

            goto Cleanup;
        }

        //
        // There is a buffer, so use it to do the KDC thang.
        //

        KdcContext->lpo = lpo;
        InputMessage.BufferSize = (KdcContext->UsedBufferLength + BytesWritten) - sizeof(ULONG);
        InputMessage.Buffer = KdcContext->Buffer + sizeof(ULONG);
        OutputMessage.Buffer = NULL;

        EndpointFunction = (PKDC_GET_TICKET_ROUTINE) KdcContext->EndpointContext;

        KerbErr = EndpointFunction(
                        &KdcContext,
                        &KdcContext->Address,
                        &KdcContext->LocalAddress,
                        &InputMessage,
                        &OutputMessage
                        );

        if ((KerbErr != KDC_ERR_NONE) || (OutputMessage.BufferSize != 0))
        {
            //
            // We expect at least some level of message validity before
            // we'll return anything.
            //
            if (KerbErr == KDC_ERR_NO_RESPONSE)
            {
                // TBD:  Log an "attack" event here.
                KdcAtqCloseSocket(KdcContext);
                KdcAtqDereferenceContext(&KdcContext);
            }
            else
            {
                ULONG NetworkSize;
                WSABUF Buffers[2];

                NetworkSize = htonl(OutputMessage.BufferSize);

                Buffers[0].len = sizeof(DWORD);
                Buffers[0].buf = (PCHAR) &NetworkSize;

                Buffers[1].len = OutputMessage.BufferSize;
                Buffers[1].buf = (PCHAR) OutputMessage.Buffer;
                KdcContext->WriteBufferLength = OutputMessage.BufferSize;
                KdcContext->WriteBuffer = OutputMessage.Buffer;

                OutputMessage.Buffer = NULL;

                //
                // If there was no output message, don't send one.
                //

                KdcContext->Flags |= KDC_ATQ_WRITE_CONTEXT;
                KdcContext->Flags &= ~KDC_ATQ_READ_CONTEXT;
                //
                // Refernce the context for the write.
                //

                KdcAtqReferenceContext(KdcContext);

                if (!AtqWriteSocket(
                    (PATQ_CONTEXT) KdcContext->AtqContext,
                    Buffers,
                    2,
                    lpo
                    ))
                {
                    DebugLog((DEB_ERROR,"Failed to write KDC reply: 0x%x\n",GetLastError()));
                    KdcAtqCloseSocket(  KdcContext );
                    KdcAtqDereferenceContext(&KdcContext);
                }

            }


            if (OutputMessage.Buffer != NULL)
            {
                KdcFreeEncodedData(OutputMessage.Buffer);
            }
        }
    }
    else
    {
        KdcContext->Flags |= KDC_ATQ_READ_CONTEXT;
        KdcContext->Flags &= ~KDC_ATQ_WRITE_CONTEXT;

        //
        // Ignore the true size of the buffer
        //

        KdcContext->BufferLength = KERB_MAX_KDC_REQUEST_SIZE;
        KdcContext->UsedBufferLength = 0;
        KdcContext->ExpectedMessageSize = 0;
        if (KdcContext->WriteBuffer != NULL)
        {
            KdcFreeEncodedData(KdcContext->WriteBuffer);

            KdcContext->WriteBuffer = NULL;
        }

        //
        // Reference the context for the read
        //

        KdcAtqReferenceContext(KdcContext);

        if (!AtqReadFile(
                (PATQ_CONTEXT) KdcContext->AtqContext,
                KdcContext->Buffer,
                KERB_MAX_KDC_REQUEST_SIZE,
                lpo
                ))
        {
            DebugLog((DEB_ERROR,"Failed to read file for %d bytes: 0x%x\n",KERB_MAX_KDC_REQUEST_SIZE,GetLastError()));
            KdcAtqCloseSocket(  KdcContext );

            //
            // Dereference the reference we just added
            //

            KdcAtqDereferenceContext(&KdcContext);

            //
            // Derefernece the reference on the list
            //

            KdcAtqDereferenceContext(&KdcContext);

        }

    }

Cleanup:
    if (KdcContext != NULL)
    {
        KdcAtqDereferenceContext(&KdcContext);
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   KdcAtqRetrySocketRead
//
//  Synopsis:   Retries a read if not all the data was read
//
//  Effects:    posts an AtqReadSocket
//
//  Arguments:  Context - The KDC context to retry the read on
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KdcAtqRetrySocketRead(
    IN PKDC_ATQ_CONTEXT * Context,
    IN PKERB_MESSAGE_BUFFER OldMessage
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    PKDC_ATQ_CONTEXT KdcContext = *Context;
    PBYTE NewBuffer = NULL;
    ULONG NewBufferLength;

    TRACER(L"KdcAtqRetrySocketRead", (PVOID *) &KerbErr);
    D_DebugLog(( DEB_T_SOCK, "RetrySocketRead:  Expected size = %#x, current size %#x\n",
                KdcContext->ExpectedMessageSize,
                KdcContext->UsedBufferLength));

    if (KdcContext->ExpectedMessageSize != 0)
    {
        NewBufferLength = KdcContext->ExpectedMessageSize;
    }
    else
    {
        //
        // Set max buffer length at 128k
        //
        if (KdcContext->BufferLength < KDC_MAX_BUFFER_LENGTH)
        {
            NewBufferLength = KdcContext->BufferLength + KERB_MAX_KDC_REQUEST_SIZE;
        }
        else
        {
            KerbErr = KRB_ERR_GENERIC;
            goto cleanup;
        }
    }

    if (NewBufferLength > KDC_MAX_BUFFER_LENGTH)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto cleanup;
    }

    //
    // If the expected message size doesn't fit in the current buffer,
    // allocate a new one.
    //

    if (NewBufferLength > KdcContext->BufferLength)
    {
        D_DebugLog(( DEB_T_SOCK, "Allocating a new buffer for context %x\n",
                    Context ));

        NewBuffer = (PBYTE) MIDL_user_allocate( NewBufferLength );

        if (NewBuffer == NULL)
        {
            KerbErr = KRB_ERR_GENERIC;
            goto cleanup;
        }

        if ( KdcContext->Buffer == OldMessage->Buffer )
        {
            //
            // we resized while the buffer was in use.  Copy the data and touch up
            // the pointers below
            //

            memcpy(
                    NewBuffer,
                    OldMessage->Buffer,         // same as KdcContext->Buffer
                    OldMessage->BufferSize );

            OldMessage->Buffer = NewBuffer ;
        }

        MIDL_user_free(KdcContext->Buffer);

        KdcContext->Buffer = NewBuffer;
        KdcContext->BufferLength = NewBufferLength;
        NewBuffer = NULL;
    }

    if (KdcContext->Buffer != OldMessage->Buffer)
    {
        MoveMemory(
            KdcContext->Buffer,
            OldMessage->Buffer,
            OldMessage->BufferSize
            );

    }

    KdcContext->UsedBufferLength = KdcContext->UsedBufferLength + OldMessage->BufferSize;
    KdcContext->Flags |= KDC_ATQ_READ_CONTEXT;
    KdcContext->Flags &= ~(KDC_ATQ_WRITE_CONTEXT);

    //
    // Reference the context for the read
    //

    KdcAtqReferenceContext(KdcContext);

    if (!AtqReadFile(
            (PATQ_CONTEXT) KdcContext->AtqContext,
            (PUCHAR) KdcContext->Buffer + KdcContext->UsedBufferLength,
            KdcContext->BufferLength - KdcContext->UsedBufferLength,
            KdcContext->lpo
            ))
    {
        DebugLog((DEB_ERROR,"Failed to read file for %d bytes: 0x%x\n",KdcContext->BufferLength - KdcContext->UsedBufferLength, GetLastError));

        //
        // Dereference the reference we just added
        //

        KdcAtqDereferenceContext(&KdcContext);
        KerbErr = KRB_ERR_GENERIC;
        goto cleanup;
    }

cleanup:

    if (!KERB_SUCCESS(KerbErr))
    {
        KdcAtqCloseSocket( KdcContext );
        KdcAtqDereferenceContext(&KdcContext);
    }

    return(KerbErr);

}


//+-------------------------------------------------------------------------
//
//  Function:   KdcAtqConnection
//
//  Synopsis:   Connection handling routine for KDC ATQ code
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KdcAtqConnect(
    IN SOCKET sNew,
    IN LPSOCKADDR_IN pSockAddr,
    IN PVOID EndpointContext,
    IN PVOID EndpointObject
    )
{
    TRACE(KDC,KdcAtqConnect, DEB_FUNCTION);
    DebugLog((DEB_T_SOCK,"KdcAtqConnect called\n"));
}

//+-------------------------------------------------------------------------
//
//  Function:   KdcInitializeSockets
//
//  Synopsis:   Initializes the KDCs socket handling code
//
//  Effects:
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KdcInitializeSockets(
            KERBERR (NTAPI *pfnKdcGetTicket)(
                    IN OPTIONAL PVOID Context,
                    IN OPTIONAL PSOCKADDR ClientAddress,
                    IN OPTIONAL PSOCKADDR ServerAddress,
                    IN PKERB_MESSAGE_BUFFER InputMessage,
                    OUT PKERB_MESSAGE_BUFFER OutputMessage
                    ),
            IKdcCore *pIKdcCore,
            const ATQ_CONFIG_PARM *pAtqConfigParm
)
{
    //
    //  Unlike the transport in Passport, KdcAllocMemory and KdcFreeMemory are used
    //  directly instead of via IKdcCore.
    //
    UNREFERENCED_PARAMETER(pIKdcCore);
    
    NTSTATUS Status = STATUS_SUCCESS;
    ATQ_ENDPOINT_CONFIGURATION EndpointConfig;
    BOOLEAN AtqInitCalled = FALSE;

    TRACE(KDC,KdcInitializeSockets, DEB_FUNCTION);
    TRACER(L"KdcAtqDereferenceContext", (PVOID *) &Status);


    //
    // Initialize the asynchronous thread queue.
    //

    if (!AtqInitialize(0))
    {
        DebugLog((DEB_ERROR,"Failed to initialize ATQ\n"));
        Status = STATUS_UNSUCCESSFUL;
        goto Cleanup;
    }
    AtqInitCalled = TRUE;

    //  use any provided ATQ configuration parameters
    if ( pAtqConfigParm )
    {
        if (pAtqConfigParm->dwThreads != ATQ_CONFIG_PARM_DEFAULT)
        {
            AtqSetInfo(AtqMaxPoolThreads, pAtqConfigParm->dwThreads);
        }

        // defaults to 0; system decides.
        if (pAtqConfigParm->dwConcurrentThreads != ATQ_CONFIG_PARM_DEFAULT)
        {
            AtqSetInfo(AtqMaxConcurrency, pAtqConfigParm->dwConcurrentThreads);
        }

        // defaults to 12 hours
        if (pAtqConfigParm->dwsecThreadTimeOut != ATQ_CONFIG_PARM_DEFAULT)
        {
            AtqSetInfo(AtqThreadTimeout, pAtqConfigParm->dwsecThreadTimeOut);
        }            

        // defaults to 1 KB
        if (pAtqConfigParm->dwMinKBTimeOut != ATQ_CONFIG_PARM_DEFAULT)
        {
            AtqSetInfo(AtqMinKbSec, pAtqConfigParm->dwMinKBTimeOut);
        }            
    }

    InitializeCriticalSection(&KdcAtqContextLock);

    InitializeListHead(&KdcAtqContextList);


    //
    // Create the KDC endpoint
    //

    EndpointConfig.ListenPort = KERB_KDC_PORT;
    EndpointConfig.IpAddress = INADDR_ANY;
    EndpointConfig.cbAcceptExRecvBuffer = KDC_MAX_ACCEPT_BUFFER;
    EndpointConfig.nAcceptExOutstanding = KDC_MAX_ACCEPT_OUTSTANDING;
    EndpointConfig.AcceptExTimeout = KDC_ACCEPT_TIMEOUT;

    EndpointConfig.pfnConnect = KdcAtqConnect;
    EndpointConfig.pfnConnectEx = KdcAtqConnectEx;
    EndpointConfig.pfnIoCompletion = KdcAtqIoCompletion;

    EndpointConfig.fDatagram = FALSE;
    EndpointConfig.fLockDownPort = TRUE;

    //
    // Support TCP unless otherwise defined
    //
#ifndef KDC_DOES_NOT_SUPPORT_TCP
    KdcEndpoint = AtqCreateEndpoint(
                    &EndpointConfig,
                    pfnKdcGetTicket
                    );
    if (KdcEndpoint == NULL)
    {
        DebugLog((DEB_ERROR,"Failed to create ATQ endpoint\n"));
        Status = STATUS_UNSUCCESSFUL;
        goto Cleanup;
    }

    //
    // Start the endpoint
    //

    if (!AtqStartEndpoint(KdcEndpoint))
    {
        DebugLog((DEB_ERROR, "Failed to add ATQ endpoint\n"));
        Status = STATUS_UNSUCCESSFUL;
        goto Cleanup;
    }
#endif // KDC_DOES_NOT_SUPPORT_TCP

#ifdef KPASSWD
    //
    // Create the KPASSWD endpoint
    //

    EndpointConfig.ListenPort = KERB_KPASSWD_PORT;

    KpasswdEndpoint = AtqCreateEndpoint(
                        &EndpointConfig,
                        KdcChangePassword
                        );
    if (KpasswdEndpoint == NULL)
    {
        DebugLog((DEB_ERROR,"Failed to create ATQ endpoint for kpasswd\n"));
        Status = STATUS_UNSUCCESSFUL;
        goto Cleanup;
    }

    //
    // Start the endpoint
    //

    if (!AtqStartEndpoint(KpasswdEndpoint))
    {
        DebugLog((DEB_ERROR, "Failed to add ATQ endpoint\n"));
        Status = STATUS_UNSUCCESSFUL;
        goto Cleanup;
    }

    D_DebugLog((DEB_TRACE, "Successfully started ATQ listening for kpasswd\n"));
#endif // KPASSWD
    
    Status = KdcInitializeDatagramSockets(pfnKdcGetTicket);
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    KdcSocketsInitialized = TRUE;


Cleanup:

    if (!NT_SUCCESS(Status))
    {
        if (KdcEndpoint != NULL)
        {
            (VOID) AtqStopEndpoint( KdcEndpoint );
            (VOID) AtqCloseEndpoint( KdcEndpoint );
            KdcEndpoint = NULL;
        }

        if (KpasswdEndpoint != NULL)
        {
            (VOID) AtqStopEndpoint( KpasswdEndpoint );
            (VOID) AtqCloseEndpoint( KpasswdEndpoint );
            KpasswdEndpoint = NULL;
        }

        if (AtqInitCalled)
        {
            AtqTerminate();
        }
    }
    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KdcShutdownSockets
//
//  Synopsis:   Shuts down the KDC socket handling code
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KdcShutdownSockets(
    VOID
    )
{
    PKDC_ATQ_CONTEXT Context;
    PLIST_ENTRY ListEntry;

    TRACE(KDC,KdcShutdownSockets, DEB_FUNCTION);
    TRACER(L"KdcShutdownSockets", NULL);
    
    if (!KdcSocketsInitialized)
    {
        return(STATUS_SUCCESS);
    }


    //
    // Go through the list of contexts and close them all.
    //

    EnterCriticalSection( &KdcAtqContextLock );

    KdcSocketsInitialized = FALSE;

    for (ListEntry = KdcAtqContextList.Flink;
        (ListEntry != &KdcAtqContextList) && (ListEntry != NULL) ;
        ListEntry = ListEntry->Flink )
    {
        Context = CONTAINING_RECORD(ListEntry, KDC_ATQ_CONTEXT, Next);

        //
        // If this is a read or write context, free close the associated
        // socket. (Endpoint contexts don't have sockets).
        //

        if (Context->Flags & ( KDC_ATQ_WRITE_CONTEXT | KDC_ATQ_READ_CONTEXT))
        {
            KdcAtqCloseSocket( Context );
        }


    }

    LeaveCriticalSection( &KdcAtqContextLock );

    if (KdcEndpoint != NULL)
    {
        (VOID) AtqStopEndpoint( KdcEndpoint );
        (VOID) AtqCloseEndpoint( KdcEndpoint );
        KdcEndpoint = NULL;
    }
    if (KpasswdEndpoint != NULL)
    {
        (VOID) AtqStopEndpoint( KpasswdEndpoint );
        (VOID) AtqCloseEndpoint( KpasswdEndpoint );
        KpasswdEndpoint = NULL;
    }

    KdcShutdownDatagramSockets();

    if (!AtqTerminate())
    {
        DebugLog((DEB_ERROR, "Failed to terminate ATQ!!!\n"));
    }
    DeleteCriticalSection(&KdcAtqContextLock);

    return(STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\ad-service\service.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2001
//
// File:        service.cxx
//
// Contents:    Start the standalone KDC service
//
//
// History:
//
//------------------------------------------------------------------------


#include "adservp.h"
#include "ntservice.h"
#include "lmcons.h"
#include "lmaccess.h"

#include "kdccoreperf.h"
#include <perfapi.h>
#include <xeventids.h>
#include <xmgmt.h>

#include "kdcconfig.h"

#ifndef ARRAYSIZE
#define ARRAYSIZE(x) (sizeof(x)/sizeof(*(x)))
#endif

#import "CommonConfig.tlb" raw_interfaces_only, no_smart_pointers

//
//  TODO: kokwaic 12/31/01
//
//  There is no sample trace dll, and ad-service\service.cxx does not load any trace dll.
//  This definition is to get around unresolved external exposed by the TRACE macros in
//  the transport: sockutil/dgutil.  When there is a sample trace dll that service.cxx loads,
//  this TLS will be meaningful.
//
DWORD   g_TraceTlsIndex = TLS_OUT_OF_INDEXES;

VOID
UpdateServiceStatus(
    DWORD   dwState
    );


void logtofile(char* file, char* fmt, ...)
{
	va_list argptr;
	char buffer[512];
	va_start(argptr, fmt);
	vsprintf(buffer, fmt, argptr);
	va_end(argptr);

	FILE*    Log2 = fopen ( file, "a" ); 
	fprintf( Log2, buffer);  
	fclose( Log2 ); 
}

// KDCCORE performance counters
PERFCOUNTER g_KdcCorePerfCtrs[] =
{
    // note: could also do it manually easily enough
    #include <kdccoreperf.cpp>
};

PERFOBJECT g_KdcCorePerfObject;

// ---------------------------------------------------------------------------------------
// KdcCoreInitPerfCounters - generic-ish function to initialize our perf counters.
// ---------------------------------------------------------------------------------------
HRESULT KdcCoreInitPerfCounters(
    IN DWORD                dwPerfObjIndex,
    IN OUT PERFCOUNTER *    pPerfCtrs,
    IN DWORD                dwNumPerfCtrs,
    IN OUT PERFOBJECT *     pPerfObj)
{
    XOMASSERT(NULL != pPerfCtrs);
    XOMASSERT(0 < dwNumPerfCtrs);
    XOMASSERT(NULL != pPerfObj);
    
    HRESULT hr = S_OK;

    pPerfObj->dwPerfIndex = dwPerfObjIndex;
    pPerfObj->hPerfObject = CreatePerfObject(
        dwPerfObjIndex,
        0,
        (void **) &pPerfObj->pbPerfCtrDataStart);

    if( NULL == pPerfObj->hPerfObject)
    {
        hr = E_UNEXPECTED;
        goto Exit;
    }

    for( DWORD dwCtr = 0; dwCtr < dwNumPerfCtrs; dwCtr++ )
    {
        // Ignore any perf objects (categories) in the array
        if (pPerfCtrs[ dwCtr ].ctrType == XQPC_OBJECT)
        {
            continue;
        }

        DWORD dwCounterDataOffset = CreatePerfCounter(
            pPerfCtrs[ dwCtr ].dwPerfType,
            pPerfCtrs[ dwCtr ].lDataScale,
            pPerfCtrs[ dwCtr ].dwDataSize,
            pPerfObj->hPerfObject,
            pPerfCtrs[ dwCtr ].dwPerfIndex,
            NULL );

        // This executes during service start up, so an assert is REALLY not friendly.
        //XOMASSERT( 0xffffffff != dwCounterDataOffset );
        if ( 0xffffffff == dwCounterDataOffset )
        {
            // This probably means the perf counters were not installed correctly.  
            // Something about the indices is off -- too many perf counters found, too 
            // few, out of bands index, etc. Try reinstalling them.
            return E_FAIL;
        }

        pPerfCtrs[ dwCtr ].pbPerfCtrData = pPerfObj->pbPerfCtrDataStart + dwCounterDataOffset;

        //
        // Zero every counter on startup
        //
        ZeroMemory(
            pPerfCtrs[ dwCtr ].pbPerfCtrData,
            pPerfCtrs[ dwCtr ].dwDataSize );
    }

Exit:
    return hr;
}


// ---------------------------------------------------------------------------------------
// AtqPerfCounterCallbackFunction - callback called when an ATQ perf counter needs 
// updating.  dwStat is a ATQ_PERFCTR_* value.
//
// See defintion in atq.h
// ---------------------------------------------------------------------------------------
VOID AtqPerfCounterCallbackFunction(
    IN DWORD            dwStat,
    IN DWORD            dwOperation,
    IN DWORD            dwVal
    )
{
    DWORD dwPerfCtr;

    // Map an ATQ_PERFCTR_* value to a real perf counter
    switch (dwStat)
    {
    case ATQ_PERFCTR_WORKERTHREAD_CREATED:
        dwPerfCtr = KDCCOREPERF_ATQ_WORKERTHREAD_CREATED_COUNTER;
        break;
    case ATQ_PERFCTR_WORKERTHREAD_ALIVE:
        dwPerfCtr = KDCCOREPERF_ATQ_WORKERTHREAD_ALIVE_CURRENT;
        break;
    case ATQ_PERFCTR_WORKERTHREAD_ACTIVE:
        dwPerfCtr = KDCCOREPERF_ATQ_WORKERTHREAD_ACTIVE_CURRENT;
        break;
    case ATQ_PERFCTR_WORKERTHREAD_AVAILABLE:
        dwPerfCtr = KDCCOREPERF_ATQ_WORKERTHREAD_AVAILABLE_CURRENT;
        break;
    case ATQ_PERFCTR_RECV_BYTES:
        dwPerfCtr = KDCCOREPERF_ATQ_RECV_BYTES_RATE;
        break;
    case ATQ_PERFCTR_XMIT_BYTES:
        dwPerfCtr = KDCCOREPERF_ATQ_XMIT_BYTES_RATE;
        break;
    case ATQ_PERFCTR_RECV_PACKETS:
        dwPerfCtr = KDCCOREPERF_ATQ_RECV_PACKETS_RATE;
        break;
    case ATQ_PERFCTR_XMIT_PACKETS:
        dwPerfCtr = KDCCOREPERF_ATQ_XMIT_PACKETS_RATE;
        break;
    default:
        XOMASSERT(FALSE);
        return;
    }

    KdcPerfCounterFunction(dwPerfCtr, dwOperation, dwVal);
}

// ---------------------------------------------------------------------------------------
// KdcPerfCounterFunction - called when a perf counter needs updating. dwPerfCtr is a 
// KDCCOREPERF_* value.
//
// See defintion in atq.h
// ---------------------------------------------------------------------------------------
VOID KdcPerfCounterFunction(
    IN DWORD            dwPerfCtr,
    IN DWORD            dwOperation,
    IN DWORD            dwVal
    )
{

    // Find the index. We include the perf object at index 0, so we only need to divide by 
    // 2 (since the perf counters are numered every other).//
//    DWORD dwCounterIndex = ((dwPerfCtr - g_KdcCorePerfObject.dwPerfIndex) / 2);
//    XOMASSERT(dwCounterIndex < ARRAYSIZE(g_KdcCorePerfCtrs));
//    if (dwCounterIndex >= ARRAYSIZE(g_KdcCorePerfCtrs))
//    {
///        return;
//    }
//
    // Take action atomically
//    PERFCOUNTER *pc = &g_KdcCorePerfCtrs[dwCounterIndex];
//    if (pc->ctrType == XQPC_QWORD)
//    {
//        LONGLONG qwVal = (LONGLONG)dwVal;
  //      switch (dwOperation)
///        {
 //       case FLAG_COUNTER_INCREMENT:
  //          InterlockedExchangeAdd64((LONGLONG*)pc->pbPerfCtrData, qwVal);
 //           break;
 //       case FLAG_COUNTER_DECREMENT:
  //          InterlockedExchangeAdd64((LONGLONG*)pc->pbPerfCtrData, -qwVal);
 //           break;
 //       case FLAG_COUNTER_SET:
 //           *((LONGLONG*)pc->pbPerfCtrData) = qwVal;
  //          break;
  //      }

   // }
  //  else if (pc->ctrType == XQPC_DWORD)
 //   {
 //       LONG lVal = (LONG)dwVal;
 //       switch (dwOperation)
 //       {
 //       case FLAG_COUNTER_INCREMENT:
//            InterlockedExchangeAdd((LONG*)pc->pbPerfCtrData, lVal);
 //           break;
//        case FLAG_COUNTER_DECREMENT:
//            InterlockedExchangeAdd((LONG*)pc->pbPerfCtrData, -lVal);
//            break;
//        case FLAG_COUNTER_SET:
//            *((LONG*)pc->pbPerfCtrData) = lVal;
//            break;
//        }
//    }
//    else
//    {
 //       XOMASSERT(FALSE);
 //   }

}



// ---------------------------------------------------------------------------------------
// CKdcService - an NT service built on the CNTService common code
// ---------------------------------------------------------------------------------------

class CKdcService : public CNTService
{
public:

    // Constructor / Destructor ----------------------------------------------------------

    CKdcService() :
        CNTService(
            L"XKDC",
            L"XBox Live Kerberos Key Distribution Center",
            L"Provides tickets for Xbox Live Services",
            L"kdccoreperf",
            Component_kdcsvc )
    {
    }

    // CNTService ------------------------------------------------------------------------

    virtual DWORD GrantLogonRights(LPCWSTR szAccount)
    {
        NET_API_STATUS              err         = 0;
        LOCALGROUP_MEMBERS_INFO_3   localgroup_members;


        localgroup_members.lgrmi3_domainandname = (LPWSTR)szAccount;

        err = NetLocalGroupAddMembers(
                               NULL,                        // Act on local machine's groups
                               L"Administrators",           // Group name 
                               3,                           // Input structure type 
                               (LPBYTE)&localgroup_members, // Input buffer 
                               1 );                         // Count

        switch ( err )
        {
            case 0:
                InstallInfo("User %S successfully added to local Administrators group", szAccount);
                break;
            case ERROR_MEMBER_IN_ALIAS:
                InstallInfo("User %S already in local Administrators group", szAccount);
                break;
            default:
                InstallError("Failed adding User %S to local Administrators group: %d\n", szAccount, err);
                return err;
                break;
        }

        return __super::GrantLogonRights(szAccount);
    }

    virtual DWORD UninstallCounters(LPCWSTR pszServiceName)
    {
        // Must match the registry key where the counters are stored
        return CNTService::UninstallCounters(L"kdc");
    }


    virtual HRESULT InitService( DWORD dwArgc, LPTSTR* ppszArgv )
    {
        return S_OK;
    }

    virtual HRESULT RunService( BOOL* pfServiceRan )
    {
        HRESULT hr = S_OK;
        KDCCORE_PARAMS KdcParams = {0};
        ATQ_CONFIG_PARM AtqParms = {ATQ_CONFIG_PARM_DEFAULT,
                                    ATQ_CONFIG_PARM_DEFAULT,
                                    ATQ_CONFIG_PARM_DEFAULT,
                                    ATQ_CONFIG_PARM_DEFAULT};


		
		printf("Buttsex1\n");					
        // Need this if we want to log events
        g_xomcentral.Init("KdcCore", NULL, "kdcsvc");

        // Init perf counters here
//        hr = KdcCoreInitPerfCounters(
//            KDCCOREPERF_SERVER_OBJECT_GLOBAL,
//            g_KdcCorePerfCtrs,
//            ARRAYSIZE(g_KdcCorePerfCtrs),
//            &g_KdcCorePerfObject);
//        if (FAILED(hr))
//        {
//            // ungghhhhh...  trying to be "user-friendly" and "helpful" here.
//            DWORD dwFirstCounter = 0;
//            DWORD dwLastCounter = 0;
//            DWORD dwFirstHelp = 0;
//           DWORD dwLastHelp = 0;
//            HRESULT hrWhy = GetCounterBasis(dwFirstCounter, dwLastCounter, dwFirstHelp, dwLastHelp);
//            printf(
//               "KdcCoreInitPerfCounters failed with hr=0x%08X. Detailed info from GetCounterBasis:\n"
//                "hr=0x%08X \n"
//                "FirstCounter=%d, LastCounter=%d, NumCounters=%d \n"
//                "FirstHelp=%d, LastHelp=%d, NumHelp=%d",
//                hr, hrWhy, dwFirstCounter, dwLastCounter, (dwLastCounter - dwFirstCounter) / 2,
//                dwFirstHelp, dwLastHelp, (dwLastHelp - dwFirstHelp) / 2);
//            
//            return hr;
//        }
        
        // Register for ATQ perf counter callbacks
        AtqSetInfo(AtqUpdatePerfCounterCallback, (DWORD_PTR)AtqPerfCounterCallbackFunction);


        KdcParams.pfnSetStatus = UpdateServiceStatus;
        KdcParams.pszProviders = NULL;
        KdcParams.pszTraceDll = NULL;
    
        KdcParams.pfnStartTransport = (FNKDC_START_TRANSPORT)KdcInitializeSockets;
        KdcParams.pfnStopTransport = KdcShutdownSockets;

        hr = InitializeConfigInstance();
        if (FAILED(hr))
        {
			logtofile("c:\\ad-service.log", "KDC Config initialize failed, hr = 0x%08x", hr);
            printf(
                "KDC Config initialize failed, hr = 0x%08x", hr );
            // yes, it is quite important to stop the KDC for an error here
            return hr;
        }
        else
        {
            //
            // Use NPDB configuration just for ATQ # of threads for now
            //
           // KDC_CONFIG_OPTIONS KDCConfigOptions = {0};
           // GetKDCConfigOptions(&KDCConfigOptions);
            AtqParms.dwThreads = 5; //KDCConfigOptions.ATQThreads;
        }

        //
        // passing a pointer to a stack variable is fine - the execution is
        // synchronous and the data is not passed around after that.
        //
        KdcParams.pAtqConfigParm = &AtqParms;
        
        // This will wait until shutdown time
        if( !NT_SUCCESS( KdcServiceMain( &KdcParams ) ) )
        {
			logtofile("c:\\ad-service.log", "KdcServiceMain failed");
            return E_FAIL;
        }

        return hr;
    }

    virtual void TermService()
    {
        KdcShutDown( L"Service: Shutdown" );

        DestroyConfigInstance();
    }

    void Checkpoint( DWORD dwWaitHint )
    {
        CNTService::Checkpoint( dwWaitHint );
    }
};

CKdcService   g_KdcService;
CNTService * g_pService = &g_KdcService;

VOID
UpdateServiceStatus(
    DWORD   dwState
    )
{
    if ((dwState == SERVICE_START_PENDING) || (dwState == SERVICE_STOP_PENDING))
    {
        g_KdcService.Checkpoint( 10000 );
    }
}

// ---------------------------------------------------------------------------------------
// Main entrypoint
// ---------------------------------------------------------------------------------------

//DWORD __cdecl wmain( int argc, WCHAR ** argv )
//{
//    // Pass control to the service layer
//    return g_KdcService.ProcessMain( argc, argv );
//}

DWORD __cdecl wmain( int argc, WCHAR ** argv )
{
	printf("Buttsex\n");
    // Pass control to the service layer
    //return g_KdcService.ProcessMain( argc, argv );
	return g_KdcService.ProcessMain( argc, argv );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\ad-service\obj\i386\kdcevent.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    kdcevent.h

Abstract:

    Definitions for POP3 Server Events

Author:

    RichardW,  3 Mar 95

Revision History:

Notes:

    This file is generated by the MC tool from the pop3evnt.mc file.

--*/


#ifndef __KDCEVENT_H__
#define __KDCEVENT_H__

//
//  Values are 32 bit values laid out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3


//
// MessageId: CATEGORY_KDC
//
// MessageText:
//
// KDC
//
#define CATEGORY_KDC                     0x00000001L

//
// MessageId: CATEGORY_MAX_CATEGORY
//
// MessageText:
//
// Max
//
#define CATEGORY_MAX_CATEGORY            0x00000002L

//
// MessageId: KDCEVENT_UNKNOWN_PRINCIPAL
//
// MessageText:
//
// Could not find principal %1
//
#define KDCEVENT_UNKNOWN_PRINCIPAL       0x80000003L

//
// MessageId: KDCEVENT_FAILED_DOMAIN_CREDS
//
// MessageText:
//
// Domain %1 propagated to us but did not authenticate
//
#define KDCEVENT_FAILED_DOMAIN_CREDS     0x80000004L

//
// MessageId: KDCEVENT_POLICY_UPDATE_FAILED
//
// MessageText:
//
// The KDC failed to update policy class %1. The error is in the data.
//
#define KDCEVENT_POLICY_UPDATE_FAILED    0xC0000005L

//
// MessageId: KDCEVENT_DOMAIN_LIST_UPDATE_FAILED
//
// MessageText:
//
// The KDC failed to update the trusted domain list. The error is in the data.
//
#define KDCEVENT_DOMAIN_LIST_UPDATE_FAILED 0xC0000006L

//
// MessageId: KDCEVENT_SAM_CALL_FAILED
//
// MessageText:
//
// The Security Account Manager failed a KDC request in an unexpected way. The
// error is in the data field. The account name was %1 and lookup type %2.
//
#define KDCEVENT_SAM_CALL_FAILED         0xC0000007L

//
// MessageId: KDCEVENT_NO_KEY_TYPE
//
// MessageText:
//
// The account %1 did not have a suitable key for generating a Kerberos ticket.
// If the encryption type is supported, changing or setting the password will
// generate a proper key.  The missing key type may be in the data field.
//
#define KDCEVENT_NO_KEY_TYPE             0xC0000008L

//
// MessageId: KDCEVENT_KRBTGT_PASSWORD_CHANGED
//
// MessageText:
//
// The password on the KRBTGT account was changed.
//
#define KDCEVENT_KRBTGT_PASSWORD_CHANGED 0x00000009L

//
// MessageId: KDCEVENT_KRBTGT_PASSWORD_CHANGE_FAILED
//
// MessageText:
//
// The attempt to change the password on the KRBTGT account failed. The error
// code is in the data field
//
#define KDCEVENT_KRBTGT_PASSWORD_CHANGE_FAILED 0xC000000AL

//
// MessageId: KDCEVENT_NAME_NOT_UNIQUE
//
// MessageText:
//
// There are multiple accounts with name %1 of type %2.
//
#define KDCEVENT_NAME_NOT_UNIQUE         0xC000000BL

//
// MessageId: KDCEVENT_FAILED_TRANSITIVE_TRUST
//
// MessageText:
//
// A request failed from client realm %1 for a ticket in realm %2.  
// This failed because a trust link between the realms is non transitive.
//
#define KDCEVENT_FAILED_TRANSITIVE_TRUST 0x8000000CL

//
// MessageId: KDCEVENT_CORRUPT_CREDENTIALS
//
// MessageText:
//
// The account for %1 has corrupt keys stored in the DS.  Changing
// or setting the password should restore correct keys.
//
#define KDCEVENT_CORRUPT_CREDENTIALS     0xC000000DL

//
// MessageId: KDCEVENT_NO_KEY_UNION_AS
//
// MessageText:
//
// While processing an AS request, the account %1 did not have a suitable key 
// for generating a Kerberos ticket.  
// The requested etypes were %2.  
// The accounts available etypes were %3. 
// If the encryption type is supported, changing or setting the password will
// generate a proper key.  
//
#define KDCEVENT_NO_KEY_UNION_AS         0xC000000EL

//
// MessageId: KDCEVENT_INVALID_FORWARDED_AS_REQ
//
// MessageText:
//
// The request for an AS ticket for client %1 was forwarded to the PDC.  An 
// invalid response to this forwarded request was detected and could indicate an
// attempt to spoof your PDC.  There may be additional information in the data field. 
//
#define KDCEVENT_INVALID_FORWARDED_AS_REQ 0xC000000FL

//
// MessageId: KDCEVENT_NO_KEY_UNION_TGS
//
// MessageText:
//
// While processing a TGS request for the target server %1, the account %2 did not 
// have a suitable key for generating a Kerberos ticket.  
// The requested etypes were %3.  
// The accounts available etypes were %4. 
// If the encryption type is supported, changing or setting the password will
// generate a proper key.  
//
#define KDCEVENT_NO_KEY_UNION_TGS        0xC0000010L

//
// MessageId: KDCEVENT_INVALID_POLICY
//
// MessageText:
//
// When updating policy class %1, the KDC encountered invalid policy data
// and has failed to update the policy.
//
#define KDCEVENT_INVALID_POLICY          0xC0000011L

//
// MessageId: KDCEVENT_PAC_VERIFICATION_FAILURE
//
// MessageText:
//
// During TGS processing, the KDC was unable to verify the signature on the 
// PAC from %1. This indicates the PAC was modified.
//
#define KDCEVENT_PAC_VERIFICATION_FAILURE 0xC0000012L

//
// MessageId: KDCEVENT_NO_KDC_CERTIFICATE
//
// MessageText:
//
// This event indicates an attempt was made to use smartcard logon, 
// but the KDC is unable to use the PKINIT protocol because it is missing a 
// suitable certificate.  
//
#define KDCEVENT_NO_KDC_CERTIFICATE      0x80000013L

//
// MessageId: KDCEVENT_INVALID_KDC_CERTIFICATE
//
// MessageText:
//
// The currently selected KDC certificate was once valid, but now is invalid
// and no suitable replacement was found.  Smartcard logon may not function correctly
// if this problem is not remedied.  Have the system administrator check on the 
// state of the domain's public key infrastructure.  The chain status is in 
// the error data.
//
#define KDCEVENT_INVALID_KDC_CERTIFICATE 0x80000014L

//
// MessageId: KDCEVENT_INVALID_CLIENT_CERTIFICATE
//
// MessageText:
//
// The client certificate for the user %1 is not valid, and resulted in a 
// failed smartcard logon.  Please contact the user for more information 
// about the certificate they're attempting to use for smartcard logon.  The 
// chain status is in the error data.
//
#define KDCEVENT_INVALID_CLIENT_CERTIFICATE 0x80000015L

//
// MessageId: KDCEVENT_TRUST_LOOP
//
// MessageText:
//
// The KDC encountered a trust loop when building a list of trusted domains.  
// This indicates that the route to the domain %1 from this KDC has more than 
// one possible trust path.
//
#define KDCEVENT_TRUST_LOOP              0x80000016L


#endif // __KDCEVENT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\ad-service\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_kdcsvc_none_12.4.56.0_none_05e01e129e2ade76
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_kdcsvc_no-public-key_12.4.56.0_x-ww_237706ac
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=kdcsvc
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_kdcsvc_no-public-key_12.4.56.0_x-ww_237706ac
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_kdcsvc_no-public-key_12.4.56.0_x-ww_237706ac.manifest
XP_MANIFEST_PATH=manifests\x86_kdcsvc_no-public-key_12.4.56.0_x-ww_237706ac.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_kdcsvc_no-public-key_12.4.56.0_x-ww_237706ac.cat
XP_CATALOG_PATH=manifests\x86_kdcsvc_no-public-key_12.4.56.0_x-ww_237706ac.cat
XP_PAYLOAD_PATH=x86_kdcsvc_no-public-key_12.4.56.0_x-ww_237706ac
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=kdcsvc,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\ad-service\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_kdcsvc_none_12.4.56.0_none_05e01e129e2ade76
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_kdcsvc_no-public-key_12.4.56.0_x-ww_237706ac
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=kdcsvc
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_kdcsvc_no-public-key_12.4.56.0_x-ww_237706ac
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_kdcsvc_no-public-key_12.4.56.0_x-ww_237706ac.manifest
XP_MANIFEST_PATH=manifests\x86_kdcsvc_no-public-key_12.4.56.0_x-ww_237706ac.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_kdcsvc_no-public-key_12.4.56.0_x-ww_237706ac.cat
XP_CATALOG_PATH=manifests\x86_kdcsvc_no-public-key_12.4.56.0_x-ww_237706ac.cat
XP_PAYLOAD_PATH=x86_kdcsvc_no-public-key_12.4.56.0_x-ww_237706ac
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=kdcsvc,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\ad-service\objd\i386\kdcevent.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    kdcevent.h

Abstract:

    Definitions for POP3 Server Events

Author:

    RichardW,  3 Mar 95

Revision History:

Notes:

    This file is generated by the MC tool from the pop3evnt.mc file.

--*/


#ifndef __KDCEVENT_H__
#define __KDCEVENT_H__

//
//  Values are 32 bit values laid out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3


//
// MessageId: CATEGORY_KDC
//
// MessageText:
//
// KDC
//
#define CATEGORY_KDC                     0x00000001L

//
// MessageId: CATEGORY_MAX_CATEGORY
//
// MessageText:
//
// Max
//
#define CATEGORY_MAX_CATEGORY            0x00000002L

//
// MessageId: KDCEVENT_UNKNOWN_PRINCIPAL
//
// MessageText:
//
// Could not find principal %1
//
#define KDCEVENT_UNKNOWN_PRINCIPAL       0x80000003L

//
// MessageId: KDCEVENT_FAILED_DOMAIN_CREDS
//
// MessageText:
//
// Domain %1 propagated to us but did not authenticate
//
#define KDCEVENT_FAILED_DOMAIN_CREDS     0x80000004L

//
// MessageId: KDCEVENT_POLICY_UPDATE_FAILED
//
// MessageText:
//
// The KDC failed to update policy class %1. The error is in the data.
//
#define KDCEVENT_POLICY_UPDATE_FAILED    0xC0000005L

//
// MessageId: KDCEVENT_DOMAIN_LIST_UPDATE_FAILED
//
// MessageText:
//
// The KDC failed to update the trusted domain list. The error is in the data.
//
#define KDCEVENT_DOMAIN_LIST_UPDATE_FAILED 0xC0000006L

//
// MessageId: KDCEVENT_SAM_CALL_FAILED
//
// MessageText:
//
// The Security Account Manager failed a KDC request in an unexpected way. The
// error is in the data field. The account name was %1 and lookup type %2.
//
#define KDCEVENT_SAM_CALL_FAILED         0xC0000007L

//
// MessageId: KDCEVENT_NO_KEY_TYPE
//
// MessageText:
//
// The account %1 did not have a suitable key for generating a Kerberos ticket.
// If the encryption type is supported, changing or setting the password will
// generate a proper key.  The missing key type may be in the data field.
//
#define KDCEVENT_NO_KEY_TYPE             0xC0000008L

//
// MessageId: KDCEVENT_KRBTGT_PASSWORD_CHANGED
//
// MessageText:
//
// The password on the KRBTGT account was changed.
//
#define KDCEVENT_KRBTGT_PASSWORD_CHANGED 0x00000009L

//
// MessageId: KDCEVENT_KRBTGT_PASSWORD_CHANGE_FAILED
//
// MessageText:
//
// The attempt to change the password on the KRBTGT account failed. The error
// code is in the data field
//
#define KDCEVENT_KRBTGT_PASSWORD_CHANGE_FAILED 0xC000000AL

//
// MessageId: KDCEVENT_NAME_NOT_UNIQUE
//
// MessageText:
//
// There are multiple accounts with name %1 of type %2.
//
#define KDCEVENT_NAME_NOT_UNIQUE         0xC000000BL

//
// MessageId: KDCEVENT_FAILED_TRANSITIVE_TRUST
//
// MessageText:
//
// A request failed from client realm %1 for a ticket in realm %2.  
// This failed because a trust link between the realms is non transitive.
//
#define KDCEVENT_FAILED_TRANSITIVE_TRUST 0x8000000CL

//
// MessageId: KDCEVENT_CORRUPT_CREDENTIALS
//
// MessageText:
//
// The account for %1 has corrupt keys stored in the DS.  Changing
// or setting the password should restore correct keys.
//
#define KDCEVENT_CORRUPT_CREDENTIALS     0xC000000DL

//
// MessageId: KDCEVENT_NO_KEY_UNION_AS
//
// MessageText:
//
// While processing an AS request, the account %1 did not have a suitable key 
// for generating a Kerberos ticket.  
// The requested etypes were %2.  
// The accounts available etypes were %3. 
// If the encryption type is supported, changing or setting the password will
// generate a proper key.  
//
#define KDCEVENT_NO_KEY_UNION_AS         0xC000000EL

//
// MessageId: KDCEVENT_INVALID_FORWARDED_AS_REQ
//
// MessageText:
//
// The request for an AS ticket for client %1 was forwarded to the PDC.  An 
// invalid response to this forwarded request was detected and could indicate an
// attempt to spoof your PDC.  There may be additional information in the data field. 
//
#define KDCEVENT_INVALID_FORWARDED_AS_REQ 0xC000000FL

//
// MessageId: KDCEVENT_NO_KEY_UNION_TGS
//
// MessageText:
//
// While processing a TGS request for the target server %1, the account %2 did not 
// have a suitable key for generating a Kerberos ticket.  
// The requested etypes were %3.  
// The accounts available etypes were %4. 
// If the encryption type is supported, changing or setting the password will
// generate a proper key.  
//
#define KDCEVENT_NO_KEY_UNION_TGS        0xC0000010L

//
// MessageId: KDCEVENT_INVALID_POLICY
//
// MessageText:
//
// When updating policy class %1, the KDC encountered invalid policy data
// and has failed to update the policy.
//
#define KDCEVENT_INVALID_POLICY          0xC0000011L

//
// MessageId: KDCEVENT_PAC_VERIFICATION_FAILURE
//
// MessageText:
//
// During TGS processing, the KDC was unable to verify the signature on the 
// PAC from %1. This indicates the PAC was modified.
//
#define KDCEVENT_PAC_VERIFICATION_FAILURE 0xC0000012L

//
// MessageId: KDCEVENT_NO_KDC_CERTIFICATE
//
// MessageText:
//
// This event indicates an attempt was made to use smartcard logon, 
// but the KDC is unable to use the PKINIT protocol because it is missing a 
// suitable certificate.  
//
#define KDCEVENT_NO_KDC_CERTIFICATE      0x80000013L

//
// MessageId: KDCEVENT_INVALID_KDC_CERTIFICATE
//
// MessageText:
//
// The currently selected KDC certificate was once valid, but now is invalid
// and no suitable replacement was found.  Smartcard logon may not function correctly
// if this problem is not remedied.  Have the system administrator check on the 
// state of the domain's public key infrastructure.  The chain status is in 
// the error data.
//
#define KDCEVENT_INVALID_KDC_CERTIFICATE 0x80000014L

//
// MessageId: KDCEVENT_INVALID_CLIENT_CERTIFICATE
//
// MessageText:
//
// The client certificate for the user %1 is not valid, and resulted in a 
// failed smartcard logon.  Please contact the user for more information 
// about the certificate they're attempting to use for smartcard logon.  The 
// chain status is in the error data.
//
#define KDCEVENT_INVALID_CLIENT_CERTIFICATE 0x80000015L

//
// MessageId: KDCEVENT_TRUST_LOOP
//
// MessageText:
//
// The KDC encountered a trust loop when building a list of trusted domains.  
// This indicates that the route to the domain %1 from this KDC has more than 
// one possible trust path.
//
#define KDCEVENT_TRUST_LOOP              0x80000016L


#endif // __KDCEVENT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\common\commonp.h ===
#pragma once


#include "krbprgma.h"

#define WIN32_NO_STATUS
#include <winsock2.h>
#include <winternl.h>
#undef WIN32_NO_STATUS
#include <windows.h>
#include <ntstatus.h>
typedef NTSTATUS * PNTSTATUS;
#define _NTDEF_
#include <ntsecapi.h>
#undef _NTDEF_
#include <subauth.h>
#include <wincrypt.h>

#include <secpch2.hxx>
#include <lmcons.h>
#include <dsgetdc.h>

#include "ntrtl.h"

#include <kerbcomm.h>
#include <kerberr.h>
#include <kerbinterface.h>
#include "krb5.h"
#include <kdcsvr.hxx>

#include <authen.hxx>
#include <tostring.hxx>

#include <md5.h>
#include <malloc.h>
#include <sddl.h>

#include <assert.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\common\crypt.cxx ===
//+-----------------------------------------------------------------------
//
// File:        crypt.c
//
// Contents:    cryptography routines for building EncryptedData structs
//
//
// History:     17-Dec-91,  RichardW    Created
//              25-Feb-92,  RichardW    Revised for CryptoSystems
//
//------------------------------------------------------------------------

#include "commonp.h"


#define CONFOUNDER_SIZE     8
#define CHECKSUM_SIZE       sizeof(CheckSum)


//+-------------------------------------------------------------------------
//
//  Function:   KerbEncryptData
//
//  Synopsis:   shim for KerbEncryptDataEx
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
NTAPI
KerbEncryptData(
    OUT PKERB_ENCRYPTED_DATA EncryptedData,
    IN ULONG DataSize,
    IN const UCHAR * Data,
    IN ULONG Algorithm,
    IN const KERB_ENCRYPTION_KEY * Key
    )
{
    return(KerbEncryptDataEx(
                EncryptedData,
                DataSize,
                Data,
                Algorithm,
                KERB_NO_KEY_VERSION,
                0,              // no usage flags
                Key
                ) );
}


//+---------------------------------------------------------------------------
//
//  Function:   KerbEncryptDataEx
//
//  Synopsis:   Turns cleartext into cipher text
//
//  Effects:    In place encryption of data
//
//  Arguments:  Data - Contains data to be encrypted
//              DataSize - Contains length of data in bytes
//              Algorithm - Algorithm to be used for encryption/checksum
//      KeyVersion - KERB_NO_KEY_VERSION or kvno for KERB_ENCRYPTED_DATA
//              UsageFlags - Flags indicating usage (client/serve, encryption/authentication)
//              Key - Key to use for encryption
//
//
//
//  Notes:
//
//----------------------------------------------------------------------------

KERBERR
NTAPI
KerbEncryptDataEx(
    OUT PKERB_ENCRYPTED_DATA EncryptedData,
    IN ULONG DataSize,
    IN const UCHAR * Data,
    IN ULONG Algorithm,
    IN ULONG KeyVersion,
    IN ULONG UsageFlags,
    IN const KERB_ENCRYPTION_KEY * Key
    )
{
    PCRYPTO_SYSTEM pcsCrypt = NULL;
    PCRYPT_STATE_BUFFER psbCryptBuffer = NULL;
    NTSTATUS Status = STATUS_SUCCESS;

    Status = CDLocateCSystem(Algorithm, &pcsCrypt);
    if (!NT_SUCCESS(Status))
    {
        return KDC_ERR_ETYPE_NOTSUPP;
    }

    //
    // Initialize header
    //

    EncryptedData->encryption_type = Algorithm;

    Status = pcsCrypt->Initialize(
                const_cast<PUCHAR>(Key->keyvalue.value),
                Key->keyvalue.length,
                UsageFlags,
                &psbCryptBuffer
                );

    if (!NT_SUCCESS(Status))
    {
        return KRB_ERR_GENERIC;
    }

    Status =  pcsCrypt->Encrypt(
                psbCryptBuffer,
                const_cast<PUCHAR>(Data),
                DataSize,
                EncryptedData->cipher_text.value,
                &EncryptedData->cipher_text.length
                );

    (void) pcsCrypt->Discard(&psbCryptBuffer);

    if (!NT_SUCCESS(Status))
    {
        return KRB_ERR_GENERIC;
    }

    if (KeyVersion != KERB_NO_KEY_VERSION)
    {
        EncryptedData->version = KeyVersion;
        EncryptedData->bit_mask |= version_present;
    }

    return KDC_ERR_NONE;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbDecryptData
//
//  Synopsis:   Shim for KerbDecryptDataEx with no usage flags
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
NTAPI
KerbDecryptData(
    IN const KERB_ENCRYPTED_DATA * EncryptedData,
    IN const KERB_ENCRYPTION_KEY * pkKey,
    OUT PULONG DataSize,
    OUT PUCHAR Data
    )
{
    return(KerbDecryptDataEx(
            EncryptedData,
            pkKey,
            0,          // no usage flags
            DataSize,
            Data
            ) );
}


//+---------------------------------------------------------------------------
//
//  Function:   KerbDecryptDataEx
//
//  Synopsis:   Decrypts an EncryptedData structure
//
//  Effects:
//
//  Arguments:  [pedData] -- EncryptedData
//              [pkKey]   -- Key to use
//
//  History:    4-16-93   RichardW   Created Comment
//
//----------------------------------------------------------------------------

KERBERR
NTAPI
KerbDecryptDataEx(
    IN const KERB_ENCRYPTED_DATA * EncryptedData,
    IN const KERB_ENCRYPTION_KEY * pkKey,
    IN ULONG UsageFlags,
    OUT PULONG DataSize,
    OUT PUCHAR Data
    )
{
    PCRYPTO_SYSTEM       pcsCrypt = NULL;
    PCRYPT_STATE_BUFFER psbCryptBuffer = NULL;
    NTSTATUS     Status = STATUS_SUCCESS;

    Status = CDLocateCSystem(
                EncryptedData->encryption_type,
                &pcsCrypt
                );

    if (!NT_SUCCESS(Status))
    {
        return KDC_ERR_ETYPE_NOTSUPP;
    }

    if (EncryptedData->cipher_text.length & (pcsCrypt->BlockSize - 1))
    {
        return KRB_ERR_GENERIC;
    }

    Status = pcsCrypt->Initialize(
                const_cast<UCHAR*>(pkKey->keyvalue.value),
                pkKey->keyvalue.length,
                UsageFlags,
                &psbCryptBuffer
                );

    if (!NT_SUCCESS(Status))
    {
        return KRB_ERR_GENERIC;
    }

    Status = pcsCrypt->Decrypt(
                psbCryptBuffer,
                EncryptedData->cipher_text.value,
                EncryptedData->cipher_text.length,
                const_cast<UCHAR*>(Data),
                DataSize
                );

    (VOID) pcsCrypt->Discard(&psbCryptBuffer);

    if (!NT_SUCCESS(Status))
    {
        return KRB_AP_ERR_MODIFIED;
    }
    else
    {
        return KDC_ERR_NONE;
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbGetEncryptionOverhead
//
//  Synopsis:   Gets the extra space required for encryption to store the ckecksum
//
//  Effects:
//
//  Arguments:  Algorithm - the algorithm to use
//              Overhead - receives the overhead in bytes
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS or KRB_E_ETYPE_NOSUPP
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KerbGetEncryptionOverhead(
    IN ULONG Algorithm,
    OUT PULONG Overhead,
    OUT OPTIONAL PULONG BlockSize
    )
{
    PCRYPTO_SYSTEM       pcsCrypt;
    NTSTATUS Status = STATUS_SUCCESS;

    Status = CDLocateCSystem(Algorithm, &pcsCrypt);
    if (!NT_SUCCESS(Status))
    {
        return KDC_ERR_ETYPE_NOTSUPP;
    }

    *Overhead = pcsCrypt->HeaderSize;
    if (ARGUMENT_PRESENT(BlockSize))
    {
        *BlockSize = pcsCrypt->BlockSize;
    }

    return KDC_ERR_NONE;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbAllocateEncryptionBuffer
//
//  Synopsis:   Allocates the space required for encryption with a given
//              key
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KerbAllocateEncryptionBuffer(
    IN ULONG EncryptionType,
    IN ULONG BufferSize,
    OUT PUINT EncryptionBufferSize,
    OUT PBYTE * EncryptionBuffer
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    ULONG EncryptionOverhead = 0;
    ULONG BlockSize = 0;

    KerbErr = KerbGetEncryptionOverhead(
                EncryptionType,
                &EncryptionOverhead,
                &BlockSize
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    *EncryptionBufferSize = (UINT) ROUND_UP_COUNT(EncryptionOverhead + BufferSize, BlockSize);

    *EncryptionBuffer =  (PBYTE) MIDL_user_allocate(*EncryptionBufferSize);

    if (*EncryptionBuffer == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
    }

Cleanup:

    return KerbErr;
}


KERBERR
KerbAllocateEncryptionBufferWrapper(
    IN IKerbCrypt *piCrypt,
    IN ULONG EncryptionType,
    IN ULONG BufferSize,
    OUT unsigned long * EncryptionBufferSize,
    OUT PBYTE * EncryptionBuffer
    )
{
    KERBERR KerbErr = piCrypt->GetCiphertextSize(
                           EncryptionType,
                           BufferSize,
                           EncryptionBufferSize
                           );

    if (KERB_SUCCESS(KerbErr))
    {
        *EncryptionBuffer = (PBYTE)MIDL_user_allocate(*EncryptionBufferSize);
        if (*EncryptionBuffer == NULL)
        {
            KerbErr = KRB_ERR_GENERIC;
        }
    }

    return KerbErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\common\authen.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       authen.cxx
//
//  Contents:   Authenticator verification code
//
//  Classes:    CAuthenticatorList
//
//  Functions:  Compare, AuthenAllocate, AuthenFree
//
//  History:    4-04-93   WadeR   Created
//
//----------------------------------------------------------------------------

#include "commonp.h"


typedef struct _KERB_AUTHEN_HEADER
{
    LARGE_INTEGER tsTime;
    ULONG Count;
    BYTE Checksum[MD5DIGESTLEN];
} KERB_AUTHEN_HEADER, *PKERB_AUTHEN_HEADER;

#define KERB_MAX_AUTHEN_SIZE 1024


//+---------------------------------------------------------------------------
//
//  Function:   Compare
//
//  Synopsis:   Compares two KerbInternalAuthenticators for RTL_GENERIC_TABLE
//
//  Effects:    none.
//
//  Arguments:  [Table]        -- ignored
//              [FirstStruct]  --
//              [SecondStruct] --
//
//  Returns:    GenericEqual, GenericLessThan, GenericGreaterThan.
//
//  Algorithm:  Sorts by TimeStamp first, than nonce, then principal, and
//              finally by realm
//
//  History:    4-04-93   WadeR   Created
//
//  Notes:      This must impose a complete ordering.  The table package
//              will not allow an authenticator to be inserted in the table
//              if it is equal (according to this function) to one already
//              there.
//
//----------------------------------------------------------------------------

RTL_GENERIC_COMPARE_RESULTS
NTAPI
Compare(
    IN struct _RTL_GENERIC_TABLE *Table,
    IN PVOID FirstStruct,
    IN PVOID SecondStruct
    )
{
    PKERB_AUTHEN_HEADER pOne, pTwo;
    RTL_GENERIC_COMPARE_RESULTS ret;
    int comp;
    pOne = (PKERB_AUTHEN_HEADER) FirstStruct ;
    pTwo = (PKERB_AUTHEN_HEADER) SecondStruct ;

    DsysAssert( (pOne != NULL) && (pTwo != NULL) );

    if ( (pOne == NULL) || (pTwo == NULL) )
    {
        return GenericEqual;                            //Flow shouldn't reach here
    }
    comp = memcmp( pOne->Checksum,
                   pTwo->Checksum,
                   MD5DIGESTLEN );
    if (comp > 0)
    {
        ret = GenericGreaterThan;
    }
    else if (comp < 0)
    {
        ret = GenericLessThan;
    }
    else
    {
        ret = GenericEqual;
    }

    return ret;
}


//+---------------------------------------------------------------------------
//
//  Function:   AuthenAllocate
//
//  Synopsis:   Memory allocator for RTL_GENERIC_TABLE
//
//  Effects:    Allcoates memory.
//
//  Arguments:  [Table]    -- ignored
//              [ByteSize] -- number of bytes to allocate
//
//  Signals:    Throws exception on failure.
//
//  History:    4-04-93   WadeR   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

PVOID
NTAPI
AuthenAllocate(
    IN struct _RTL_GENERIC_TABLE *Table,
    IN CLONG ByteSize
    )
{
    return ( MIDL_user_allocate( ByteSize ));
}


//+---------------------------------------------------------------------------
//
//  Function:   AuthenFree
//
//  Synopsis:   Memory deallacotor for the RTL_GENERIC_TABLE.
//
//  Effects:    frees memory.
//
//  Arguments:  [Table]  -- ingnored
//              [Buffer] -- buffer to free
//
//  History:    4-04-93   WadeR   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

VOID
NTAPI
AuthenFree(
    IN struct _RTL_GENERIC_TABLE *Table,
    IN PVOID Buffer
    )
{
    MIDL_user_free ( Buffer );
}


//+---------------------------------------------------------------------------
//
//  Member:     CAuthenticatorList::CAuthenticatorList
//
//  Synopsis:   Initializes the authenticator list.
//
//  Effects:    Calls RtlInitializeGenericTable (does not allocate memory).
//
//  Arguments:  [tsMax] -- Maximum acceptable age for an authenticator.
//
//  History:    4-04-93   WadeR   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

CAuthenticatorList::CAuthenticatorList(
    IN LARGE_INTEGER tsMax,
    IN ULONG maxCount,
    IN BOOLEAN debugme
    )
    : _tsMaxAge(tsMax),
      _uMaxCount(maxCount),
      _fDebug(debugme),
      _fMutexInitialized(FALSE)
{
    RtlInitializeGenericTable(
        &_Table,
        Compare,
        AuthenAllocate,
        AuthenFree,
        NULL
        );
}


//+---------------------------------------------------------------------------
//
//  Member:     CAuthenticatorList::~CAuthenticatorList
//
//  Synopsis:   Destructor removes all authenticators in the list.
//
//  Effects:    Frees memory
//
//  Arguments:  (none)
//
//  Algorithm:  Uses "Age" to remove everything.
//
//  History:    4-04-93   WadeR   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

CAuthenticatorList::~CAuthenticatorList()
{
    LARGE_INTEGER tsForever;
    SetMaxTimeStamp( tsForever );
    (void) Age( tsForever );
    DsysAssert( RtlIsGenericTableEmpty( &_Table ) );

    if (_fMutexInitialized)
    {
        DeleteCriticalSection(&_Mutex);
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CAuthenticatorList::Init
//
//  Synopsis:   Can't return values from a C++ destructor -- initialization
//              that can fail should go here
//
//  Effects:
//
//  Arguments:
//
//  Algorithm:
//
//  History:    5-24-94   WadeR   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

NTSTATUS
CAuthenticatorList::Init()
{
    InitializeCriticalSection(&_Mutex);
    _fMutexInitialized = TRUE;
    return STATUS_SUCCESS;
}


//+---------------------------------------------------------------------------
//
//  Member:     CAuthenticatorList::SetMaxAge
//
//  Synopsis:   Changes the new maximum age for an Authenticator.
//
//  Effects:    May cause some authenticators to be aged out.
//
//  Arguments:  [tsNewMaxAge] --
//
//  Algorithm:
//
//  History:    24-May-94   wader   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void
CAuthenticatorList::SetMaxAge(
    IN LARGE_INTEGER tsNewMaxAge
    )
{
    LARGE_INTEGER tsNow;
    LARGE_INTEGER tsCutoff;

    _tsMaxAge = tsNewMaxAge;

    GetSystemTimeAsFileTime((PFILETIME) &tsNow );

    tsCutoff.QuadPart = tsNow.QuadPart - _tsMaxAge.QuadPart;

    (void) Age( tsCutoff );
}


//+---------------------------------------------------------------------------
//
//  Member:     CAuthenticatorList::Age
//
//  Synopsis:   Deletes all entries from the table that are earlier than
//              the given time.
//
//  Effects:    Frees memory
//
//  Arguments:  [tsCutoffTime] -- Delete all elements before this time.
//
//  Returns:    number of elements deleted.
//
//  Algorithm:  Get the oldest element in the table.  If it is older than
//              the time, delete it and loop back.  Else return.
//
//  History:    4-04-93   WadeR   Created
//
//  Notes:      The table contains the packed forms of Authenticators (as
//              created by PackAuthenticator in Kerbsupp).  The TimeStamp
//              must be first.
//
//----------------------------------------------------------------------------

ULONG
CAuthenticatorList::Age(
    IN const LARGE_INTEGER& tsCutoffTime
    )
{
    PKERB_AUTHEN_HEADER pahOldest;

    BOOL fDeleted;
    ULONG cDeleted = 0;

    do
    {
        // Number 0 is the oldest element in the table.
        pahOldest = (PKERB_AUTHEN_HEADER) RtlGetElementGenericTable( &_Table, 0 );
        if ((pahOldest != NULL) &&
            (pahOldest->tsTime.QuadPart < tsCutoffTime.QuadPart))
        {
            fDeleted = RtlDeleteElementGenericTable( &_Table, pahOldest );
            DsysAssert( fDeleted );
            cDeleted++;
        }
        else
        {
            fDeleted = FALSE;
        }
    } while ( fDeleted );

    return cDeleted;
}


//+---------------------------------------------------------------------------
//
//  Member:     CAuthenticatorList::Check
//
//  Synopsis:   Determines if an authenticator is valid.
//
//  Effects:    Allocates memory
//
//  Arguments:  [pedAuth] -- Authenticator to check (decrypted, but marshalled)
//
//  Returns:    KDC_ERR_NONE if authenticator is OK.
//              KRB_AP_ERR_SKEW if authenticator is expired (assumes clock skew).
//              KRB_AP_ERR_REPEAT if authenticator has been used already.
//              some other error if something throws an exception.
//
//  Signals:    none.
//
//  Modifies:   _Table
//
//  History:    4-04-93   WadeR   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

KERBERR
CAuthenticatorList::Check(
    IN const VOID * Buffer,
    IN ULONG BufferLength,
    IN OPTIONAL const VOID * OptionalBuffer,
    IN OPTIONAL ULONG OptionalBufferLength,
    IN const LARGE_INTEGER * Time,
    IN BOOLEAN Insert,
    IN BOOLEAN PurgeEntry
    )
{
    PKERB_AUTHEN_HEADER pDataInTable = NULL;
    KERBERR KerbErr = KDC_ERR_NONE;

    //
    // Hold the mutex until we have finished the insert and the Age
    // operations.
    //

    EnterCriticalSection(&_Mutex);

    __try
    {
        LARGE_INTEGER tsNow;
        LARGE_INTEGER tsCutoffPast;
        LARGE_INTEGER tsCutoffFuture;

        //
        // Determine the cut off time.
        //

        GetSystemTimeAsFileTime((PFILETIME) &tsNow );

        tsCutoffPast.QuadPart = tsNow.QuadPart - _tsMaxAge.QuadPart;
        tsCutoffFuture.QuadPart = tsNow.QuadPart + _tsMaxAge.QuadPart; 

        if ((Time->QuadPart < tsCutoffPast.QuadPart) ||
            (Time->QuadPart > tsCutoffFuture.QuadPart))
        {
            KerbErr = KRB_AP_ERR_SKEW;
        }
        else
        {
            BOOLEAN fIsNew;
            KERB_AUTHEN_HEADER Header;
            MD5_CTX Md5Context;

            //
            // Store the first chunk of the authenticator. If the authenticator
            // doesn't fit on the stack, allocate some space on the heap.
            //

            Header.tsTime = *Time;
            MD5Init(
                &Md5Context
                );

            MD5Update(
                &Md5Context,
                (const BYTE *) Buffer,
                BufferLength
                );

            if ((OptionalBuffer != NULL) && (OptionalBufferLength != 0))
            {
                MD5Update(
                    &Md5Context,
                    (const BYTE *) OptionalBuffer,
                    OptionalBufferLength
                    );
            }

            MD5Final(
                &Md5Context
                );

            memcpy(
                Header.Checksum,
                Md5Context.digest,
                MD5DIGESTLEN
                );   

            if (Insert)
            {
                pDataInTable = (PKERB_AUTHEN_HEADER) RtlInsertElementGenericTable( 
                                                        &_Table,
                                                        &Header,
                                                        sizeof( KERB_AUTHEN_HEADER ),
                                                        &fIsNew
                                                        );

                if ( fIsNew )
                {
                    pDataInTable->Count = 1;
                    if (_fDebug)
                    {
                        D_DebugLog((DEB_ERROR, "NEW cache entry\n"));
                    }
                }
                else if ( ++(pDataInTable->Count) >= _uMaxCount )
                {
                    KerbErr = KRB_AP_ERR_REPEAT;
                    if (_fDebug)
                    {
                        D_DebugLog((DEB_ERROR, "Repeat <on insert>\n"));
                    } 
                }
            }
            else
            {
                pDataInTable = (PKERB_AUTHEN_HEADER)RtlLookupElementGenericTable(
                                                            &_Table,
                                                            &Header 
                                                            );

                if (NULL != pDataInTable)
                {    
                    if (PurgeEntry)
                    {
                        DsysAssert(RtlDeleteElementGenericTable(&_Table, pDataInTable));
                        if (_fDebug)
                        {
                            D_DebugLog((DEB_ERROR, "Purged cache entry\n"));
                        }                                                   
                    }
                    else if (pDataInTable->Count >= _uMaxCount)
                    {   
                        KerbErr = KRB_AP_ERR_REPEAT;
                        if (_fDebug)
                        {
                            D_DebugLog((DEB_ERROR, "Repeat detected \n"));
                        } 
                    }
                }
            }
        }
            
        // Age out the old ones.

        (void) Age( tsCutoffPast );
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        KerbErr = KRB_ERR_GENERIC;
    }

    LeaveCriticalSection(&_Mutex);

    return KerbErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\common\debug.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       debug.h
//
//  Contents:   Debug definitions that shouldn't be necessary
//              in the retail build.
//
//  History:    28-Jun-93   WadeR   Created
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifndef __DEBUG_H__
#define __DEBUG_H__

#ifdef __cplusplus
extern "C"
{
#endif

#include <dsysdbg.h>

#ifdef __cplusplus
}
#endif

#define DEB_T_SOCK  0x00001000

#if DBG
#define DEBUG_SUPPORT
#endif 

#ifdef DEBUG_SUPPORT

    #undef DEF_INFOLEVEL
    #define DEF_INFOLEVEL       (DEB_ERROR | DEB_WARN)

    DECLARE_DEBUG2(KSupp);
    
    #define KerbPrintKdcName(Level,Name) KerbPrintKdcNameEx(KSuppInfoLevel, (Level),(Name))
    #define DebugLog(_x_)       KSuppDebugPrint _x_

#else

    #define DebugLog(_x_)       
    #define KerbPrintKdcName(_x_)   

#endif  // DBG

#define MAX_EXPR_LEN        50


////////////////////////////////////////////////////////////////////
//
//  Name:       RET_IF_ERROR
//
//  Synopsis:   Evaluates an expression, returns from the caller if error.
//
//  Arguments:  l    - Error level to print error message at.
//              e    - expression to evaluate
//
// NOTE: THIS MACRO WILL RETURN FROM THE CALLING FUNCTION ON ERROR!!!!
//
// This will execute the expression (e), and check the return code.  If the
// return code indicates a failure, it prints an error message and returns
// from the calling function.
//
#define RET_IF_ERROR(l,e)                                           \
    {   NTSTATUS X_hr_XX__=(e) ;                                              \
        if (!NT_SUCCESS(X_hr_XX__)) {                                           \
            DebugLog(( (l), (sizeof( #e ) > MAX_EXPR_LEN)?          \
                                "%s(%d):\n\t %.*s ... == 0x%X\n"    \
                            :                                       \
                                "%s(%d):\n\t %.*s == 0x%X\n"        \
                    , __FILE__, __LINE__, MAX_EXPR_LEN, #e, X_hr_XX__ ));  \
            return(X_hr_XX__);                                             \
        }                                                           \
    }




////////////////////////////////////////////////////////////////////
//
//  Name:       WARN_IF_ERROR
//
//  Synopsis:   Evaluates an expression, prints warning if error.
//
//  Arguments:  l    - Error level to print warning at.
//              e    - expression to evaluate
//
//  Notes:      This calls DebugLog(()) to print.  In retail, it just
//              evaluates the expression.
//
#if DBG
#define WARN_IF_ERROR(l,e)                                          \
    {   NTSTATUS X_hr_XX__=(e) ;                                              \
        if (!NT_SUCCESS(X_hr_XX__)) {                                           \
            DebugLog(( (l), (sizeof( #e ) > MAX_EXPR_LEN)?          \
                                "%s(%d):\n\t %.*s ... == 0x%X\n"    \
                            :                                       \
                                "%s(%d):\n\t %.*s == 0x%X\n"        \
                    , __FILE__, __LINE__, MAX_EXPR_LEN, #e, X_hr_XX__ ));  \
        }                                                           \
    }

#define D_KerbPrintKdcName(l,n) KerbPrintKdcName(l,n)
#define D_DebugLog(_x_)    DebugLog(_x_)

#else // not DBG

#define WARN_IF_ERROR(l,e)  (e)
#define D_KerbPrintKdcName(l,n)
#define D_DebugLog(_x_)
#endif


#endif // __DEBUG_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\common\keygen.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:        keygen.c
//
// Contents:    Key generation unit, with very random numbers
//
//
// History:     created, 10 Dec 91, richardw
//              modified - 14 Nov 2001 yordanr
//              Add function to compute session key for requests
//              with Pa-compound-identity
//
//------------------------------------------------------------------------

#include "commonp.h"


//+---------------------------------------------------------------------------
//
//  Function:   KerbRandomFill
//
//  Synopsis:   Generates random data in the buffer.
//
//  Arguments:  [pbBuffer] --
//              [cbBuffer] --
//
//  History:    5-20-93   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

KERBERR NTAPI
KerbRandomFill(
    IN PUCHAR      pbBuffer,
    IN ULONG       cbBuffer
    )
{
    if (!CDGenerateRandomBits(pbBuffer, cbBuffer))
    {
        return KRB_ERR_GENERIC;
    }

    return KDC_ERR_NONE;
}


//+-----------------------------------------------------------------------
//
// Function:    KerbMakeKey, public
//
// Synopsis:    Create a random desKey
//
// Effects:     fills a desKey with (more or less) cryptographically random
//              bytes.
//
// Arguments:   [EncryptionType]        - Encryption type of key
//              [NewKey] -- Key to create
//
// Returns:     KDC_ERR_NONE or KRB_ERR_GENERIC
//
//
// History:     10 Dec 91   RichardW    Created
//
//------------------------------------------------------------------------

KERBERR NTAPI
KerbMakeKey(
    IN ULONG EncryptionType,
    OUT PKERB_ENCRYPTION_KEY NewKey
    )
{
    KERBERR Status = KDC_ERR_NONE;
    NTSTATUS NtStatus;
    PCRYPTO_SYSTEM CryptoSystem;

    NewKey->keyvalue.value = NULL;

    //
    // Locate the crypto system
    //

    NtStatus = CDLocateCSystem(
                EncryptionType,
                &CryptoSystem
                );

    if (!NT_SUCCESS(NtStatus))
    {
        Status = KDC_ERR_ETYPE_NOTSUPP;
        goto Cleanup;
    }

    NewKey->keyvalue.value = (PUCHAR) MIDL_user_allocate(CryptoSystem->KeySize);
    if (NewKey->keyvalue.value == NULL)
    {
        Status = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    NtStatus = CryptoSystem->RandomKey(
                NULL,   // no seed
                0,      // no seed length
                NewKey->keyvalue.value
                );
    if (!NT_SUCCESS(NtStatus))
    {
        Status = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    NewKey->keyvalue.length = CryptoSystem->KeySize;
    NewKey->keytype = EncryptionType;

Cleanup:

    if (!KERB_SUCCESS(Status) && NewKey->keyvalue.value != NULL)
    {
        MIDL_user_free(NewKey->keyvalue.value);
        NewKey->keyvalue.value = NULL;
    }

    return Status;
}


//+-----------------------------------------------------------------------
//
// Function:    KerbCreateKeyFromBuffer
//
// Synopsis:    Create a KERB_ENCRYPT_KEY from a buffer
//
// Effects:
//
// Arguments:   NewKey -- Key to create
//              Buffer -- Buffer to create key
//              BufferSize - Length of buffer in bytes
//
// Returns:     KDC_ERR_NONE or KRB_ERR_GENERIC
//
//
// History:     21-May-1996     Created         MikeSw
//
//------------------------------------------------------------------------

KERBERR NTAPI
KerbCreateKeyFromBuffer(
    OUT PKERB_ENCRYPTION_KEY NewKey,
    IN const UCHAR * Buffer,
    IN ULONG BufferSize,
    IN ULONG EncryptionType
    )
{
    NewKey->keytype = EncryptionType;
    NewKey->keyvalue.length = BufferSize;
    NewKey->keyvalue.value = const_cast<UCHAR*>(Buffer);
    return KDC_ERR_NONE;
}


//+-----------------------------------------------------------------------
//
// Function:    KerbDuplicateKey
//
// Synopsis:    Duplicates a KERB_ENCRYPT_KEY
//
// Effects:     Allocates memory
//
// Arguments:   NewKey -- Key to create
//              Key - key to duplicate
//
// Returns:     KDC_ERR_NONE or KRB_ERR_GENERIC
//
//
// History:     21-May-1996     Created         MikeSw
//
//------------------------------------------------------------------------

KERBERR NTAPI
KerbDuplicateKey(
    OUT PKERB_ENCRYPTION_KEY NewKey,
    IN const KERB_ENCRYPTION_KEY * Key
    )
{
    memcpy( NewKey, Key, sizeof( KERB_ENCRYPTION_KEY ));
    NewKey->keyvalue.value = (PUCHAR) MIDL_user_allocate(Key->keyvalue.length);
    if (NewKey->keyvalue.value == NULL)
    {
        return KRB_ERR_GENERIC;
    }

    memcpy(
        NewKey->keyvalue.value,
        Key->keyvalue.value,
        Key->keyvalue.length
        );

    return KDC_ERR_NONE;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbFreeKey
//
//  Synopsis:   Frees a key created by KerbMakeKey or KerbCreateKeyFromBuffer
//
//  Effects:
//
//  Arguments:  Key - the key to free
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbFreeKey(
    IN PKERB_ENCRYPTION_KEY Key
    )
{
    if (Key->keyvalue.value != NULL)
    {
        MIDL_user_free(Key->keyvalue.value);
        Key->keyvalue.value = NULL;
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbMakeExportableKey
//
//  Synopsis:   Takes a keytype and makes a new key that uses export-strength
//              encryption from the key
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KerbMakeExportableKey(
    IN ULONG KeyType,
    OUT PKERB_ENCRYPTION_KEY NewKey
    )
{
    KERBERR Status = KDC_ERR_NONE;
    NTSTATUS NtStatus;
    PCRYPTO_SYSTEM CryptoSystem;

    NewKey->keyvalue.value = NULL;

    //
    // Locate the crypto system
    //

    NtStatus = CDLocateCSystem(
                KeyType,
                &CryptoSystem
                );

    if (!NT_SUCCESS(NtStatus) || (CryptoSystem->ExportableEncryptionType == 0))
    {
        Status = KDC_ERR_ETYPE_NOTSUPP;
        goto Cleanup;
    }

    NtStatus = CDLocateCSystem(
                   CryptoSystem->ExportableEncryptionType,
                   &CryptoSystem
                   );

    if (!NT_SUCCESS(NtStatus))
    {
        Status = KDC_ERR_ETYPE_NOTSUPP;
        goto Cleanup;
    }

    NewKey->keyvalue.value = (PUCHAR) MIDL_user_allocate(CryptoSystem->KeySize);
    if (NewKey->keyvalue.value == NULL)
    {
        Status = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    NtStatus = CryptoSystem->RandomKey(
                NULL,   // no seed
                0,      // no seed length
                NewKey->keyvalue.value
                );

    if (!NT_SUCCESS(NtStatus))
    {
        Status = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    NewKey->keyvalue.length = CryptoSystem->KeySize;
    NewKey->keytype = CryptoSystem->EncryptionType;

Cleanup:

    if (!KERB_SUCCESS(Status) && NewKey->keyvalue.value != NULL)
    {
        MIDL_user_free(NewKey->keyvalue.value);
        NewKey->keyvalue.value = NULL;
    }

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbIsKeyExportable
//
//  Synopsis:   Checks to see if a key is exportable
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

BOOLEAN
KerbIsKeyExportable(
    IN const KERB_ENCRYPTION_KEY * Key
    )
{
    NTSTATUS NtStatus;
    PCRYPTO_SYSTEM CryptoSystem;
    //
    // Locate the crypto system
    //

    NtStatus = CDLocateCSystem(
                (ULONG) Key->keytype,
                &CryptoSystem
                );

    if (!NT_SUCCESS(NtStatus))
    {
        return FALSE;
    }

    if ((CryptoSystem->Attributes & CSYSTEM_EXPORT_STRENGTH) != 0)
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   ComputePaCompIdentityKey
//
//  Synopsis:   computes sub-session when pa-compound-identity
//              is present
//
//  Effects:
//
//  Arguments:  pSessionKey -   [in, out] session key from the ticket on input,
//                              on output it is overwritten with the new computed
//                              session key
//              cKeys       -   [in] number of additional keys
//              ppPAKeys    -   [in] array of additional keys
//
//  Requires:
//
//  Returns:    new key based on the master session keys and additional keys.
//              the keys are hmac'd to produce the new key
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
NTAPI
KerbComputePaCompIdentityKey(
    IN OUT PKERB_ENCRYPTION_KEY   pSessionKey,
    IN ULONG                      cKeys,
    IN const KERB_ENCRYPTION_KEY *ppPAKeys
    )
{
    LONG   ctype;
    NTSTATUS    Status;
    PCHECKSUM_FUNCTION pcsChecksum = NULL;
    PBYTE   pHmacBuffer = NULL;
    PCHECKSUM_BUFFER pcsBuffer = NULL;
    PCRYPTO_SYSTEM  pCSystem = NULL;

    Status = CDLocateCSystem(pSessionKey->keytype,
                             &pCSystem);

    if (!NT_SUCCESS(Status))
    {
        return  Status;
    }

    //
    //  figure out what chksum type to use
    //

    switch (pSessionKey->keytype)
    {
    //  hmac for DES types
    case KERB_ETYPE_DES_CBC_MD5_NT:
    case KERB_ETYPE_DES_CBC_CRC:
    case KERB_ETYPE_DES_CBC_MD4:
    case KERB_ETYPE_DES_CBC_MD5:
        ctype = KERB_CHECKSUM_MD5_DES;
        break;
    default:
        //  anything else is rc4_md5
        ctype = KERB_CHECKSUM_HMAC_MD5;
    }

    Status = CDLocateCheckSum(
                 ctype,
                 &pcsChecksum
                 );

    if ( !NT_SUCCESS( Status ))
    {
        goto Error;
    }

    //
    //  now check if the chksum size is big enough
    //

    if (pcsChecksum->CheckSumSize < pCSystem->KeySize)
    {
        DsysAssert(FALSE);
        return  STATUS_INVALID_PARAMETER;
    }

    //  alloc hmac buffer on the stack
    pHmacBuffer = (PBYTE)_alloca(pcsChecksum->CheckSumSize);

    if (pcsChecksum->InitializeEx2)
    {
        Status = pcsChecksum->InitializeEx2(
                     pSessionKey->keyvalue.value,
                     pSessionKey->keyvalue.length,
                     NULL,
                     KERB_PA_COMPOUND_IDENTITY_REPLY_SALT,
                     &pcsBuffer
                     );
    }
    else
    {
        Status = pcsChecksum->InitializeEx(
                     pSessionKey->keyvalue.value,
                     pSessionKey->keyvalue.length,
                     KERB_PA_COMPOUND_IDENTITY_REPLY_SALT,
                     &pcsBuffer
                     );
    }

    if ( !NT_SUCCESS( Status )) {

        goto Error;
    }

    for (ULONG  iKey = 0; iKey < cKeys; iKey++)
    {
        Status = pcsChecksum->Sum(
                     pcsBuffer,
                     ppPAKeys[iKey].keyvalue.length,
                     ppPAKeys[iKey].keyvalue.value
                     );
        if ( !NT_SUCCESS( Status )) {

            goto Error;
        }
    }

    //
    //  extract the HMAC
    //
    Status = pcsChecksum->Finalize(pcsBuffer, pHmacBuffer);
    if ( !NT_SUCCESS( Status )) {

        goto Error;
    }

Error:

    if (pcsChecksum)
    {
        pcsChecksum->Finish(&pcsBuffer);
        if (pcsChecksum->CheckSumSize < pSessionKey->keyvalue.length)
        {
            DsysAssert(FALSE);
            Status = STATUS_INVALID_PARAMETER;
        }
    }

    if (NT_SUCCESS(Status))
    {
        //  init the return key
        memcpy(pSessionKey->keyvalue.value,
               pHmacBuffer,
               pSessionKey->keyvalue.length);
    }

    return  Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\common\krb5.c ===
#include "krbprgma.h" 
#include <windows.h>
#include "krb5.h"

ASN1module_t KRB5_Module = NULL;

static int ASN1CALL ASN1Enc_PKERB_AUTHORIZATION_DATA_LIST(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_AUTHORIZATION_DATA_LIST *val);
static int ASN1CALL ASN1Enc_PKERB_IF_RELEVANT_AUTH_DATA(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_IF_RELEVANT_AUTH_DATA *val);
static int ASN1CALL ASN1Enc_KERB_PA_PAC_REQUEST_EX_pac_sections(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PA_PAC_REQUEST_EX_pac_sections *val);
static int ASN1CALL ASN1Enc_KERB_KDC_REQUEST_BODY_encryption_type(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_KDC_REQUEST_BODY_encryption_type *val);
static int ASN1CALL ASN1Enc_PKERB_TICKET_EXTENSIONS_Seq(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_TICKET_EXTENSIONS_Seq *val);
static int ASN1CALL ASN1Enc_KERB_PRINCIPAL_NAME_name_string(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PRINCIPAL_NAME_name_string *val);
static int ASN1CALL ASN1Enc_PKERB_LAST_REQUEST_Seq(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_LAST_REQUEST_Seq *val);
static int ASN1CALL ASN1Enc_PKERB_AUTHORIZATION_DATA_Seq(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_AUTHORIZATION_DATA_Seq *val);
static int ASN1CALL ASN1Enc_PKERB_HOST_ADDRESSES_Seq(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_HOST_ADDRESSES_Seq *val);
static int ASN1CALL ASN1Enc_KERB_HOST_ADDRESS(ASN1encoding_t enc, ASN1uint32_t tag, KERB_HOST_ADDRESS *val);
static int ASN1CALL ASN1Enc_PKERB_HOST_ADDRESSES(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_HOST_ADDRESSES *val);
static int ASN1CALL ASN1Enc_PKERB_AUTHORIZATION_DATA(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_AUTHORIZATION_DATA *val);
static int ASN1CALL ASN1Enc_PKERB_LAST_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_LAST_REQUEST *val);
static int ASN1CALL ASN1Enc_KERB_PRINCIPAL_NAME(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PRINCIPAL_NAME *val);
static int ASN1CALL ASN1Enc_PKERB_TICKET_EXTENSIONS(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_TICKET_EXTENSIONS *val);
static int ASN1CALL ASN1Enc_KERB_TRANSITED_ENCODING(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TRANSITED_ENCODING *val);
static int ASN1CALL ASN1Enc_KERB_PA_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_DATA *val);
static int ASN1CALL ASN1Enc_PKERB_PREAUTH_DATA_LIST(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_PREAUTH_DATA_LIST *val);
static int ASN1CALL ASN1Enc_KERB_SAFE_BODY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SAFE_BODY *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_PRIV(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_PRIV *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_CRED(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_CRED *val);
static int ASN1CALL ASN1Enc_KERB_ERROR(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ERROR *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_DATA *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTION_KEY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTION_KEY *val);
static int ASN1CALL ASN1Enc_KERB_CHECKSUM(ASN1encoding_t enc, ASN1uint32_t tag, KERB_CHECKSUM *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_TIMESTAMP(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_TIMESTAMP *val);
static int ASN1CALL ASN1Enc_KERB_SALTED_ENCRYPTED_TIMESTAMP(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SALTED_ENCRYPTED_TIMESTAMP *val);
static int ASN1CALL ASN1Enc_KERB_ETYPE_INFO_ENTRY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ETYPE_INFO_ENTRY *val);
static int ASN1CALL ASN1Enc_PKERB_ETYPE_INFO(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_ETYPE_INFO *val);
static int ASN1CALL ASN1Enc_KERB_TGT_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TGT_REQUEST *val);
static int ASN1CALL ASN1Enc_KERB_PKCS_SIGNATURE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PKCS_SIGNATURE *val);
static int ASN1CALL ASN1Enc_KERB_ALGORITHM_IDENTIFIER(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ALGORITHM_IDENTIFIER *val);
static int ASN1CALL ASN1Enc_KERB_SIGNATURE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SIGNATURE *val);
static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REP(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PK_AS_REP *val);
static int ASN1CALL ASN1Enc_KERB_ENVELOPED_KEY_PACKAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENVELOPED_KEY_PACKAGE *val);
static int ASN1CALL ASN1Enc_KERB_REPLY_KEY_PACKAGE2(ASN1encoding_t enc, ASN1uint32_t tag, KERB_REPLY_KEY_PACKAGE2 *val);
static int ASN1CALL ASN1Enc_KERB_REPLY_KEY_PACKAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_REPLY_KEY_PACKAGE *val);
static int ASN1CALL ASN1Enc_KERB_KDC_DH_KEY_INFO(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KDC_DH_KEY_INFO *val);
static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REQ(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PK_AS_REQ *val);
static int ASN1CALL ASN1Enc_KERB_KERBEROS_NAME(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KERBEROS_NAME *val);
static int ASN1CALL ASN1Enc_KERB_PK_AUTHENTICATOR(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PK_AUTHENTICATOR *val);
static int ASN1CALL ASN1Enc_KERB_SUBJECT_PUBLIC_KEY_INFO(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SUBJECT_PUBLIC_KEY_INFO *val);
static int ASN1CALL ASN1Enc_KERB_DH_PARAMTER(ASN1encoding_t enc, ASN1uint32_t tag, KERB_DH_PARAMTER *val);
static int ASN1CALL ASN1Enc_KERB_CERTIFICATE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_CERTIFICATE *val);
static int ASN1CALL ASN1Enc_KERB_TYPED_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TYPED_DATA *val);
static int ASN1CALL ASN1Enc_KERB_KDC_ISSUED_AUTH_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KDC_ISSUED_AUTH_DATA *val);
static int ASN1CALL ASN1Enc_KERB_PA_SERV_REFERRAL(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_SERV_REFERRAL *val);
static int ASN1CALL ASN1Enc_KERB_PA_PAC_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PAC_REQUEST *val);
static int ASN1CALL ASN1Enc_KERB_CHANGE_PASSWORD_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_CHANGE_PASSWORD_DATA *val);
static int ASN1CALL ASN1Enc_KERB_ERROR_METHOD_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ERROR_METHOD_DATA *val);
static int ASN1CALL ASN1Enc_KERB_EXT_ERROR(ASN1encoding_t enc, ASN1uint32_t tag, KERB_EXT_ERROR *val);
static int ASN1CALL ASN1Enc_KERB_PA_FOR_USER(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_FOR_USER *val);
static int ASN1CALL ASN1Enc_KERB_PA_PAC_REQUEST_EX(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PAC_REQUEST_EX *val);
static int ASN1CALL ASN1Enc_KERB_KDC_ISSUED_AUTH_DATA_elements(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_KDC_ISSUED_AUTH_DATA_elements *val);
static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REQ2_trusted_certifiers(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ2_trusted_certifiers *val);
static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REQ2_user_certs(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ2_user_certs *val);
static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REP2_kdc_cert(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PA_PK_AS_REP2_kdc_cert *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data *val);
static int ASN1CALL ASN1Enc_KERB_KDC_REPLY_preauth_data(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_KDC_REPLY_preauth_data *val);
static int ASN1CALL ASN1Enc_KERB_KDC_REQUEST_preauth_data(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_KDC_REQUEST_preauth_data *val);
static int ASN1CALL ASN1Enc_KERB_TICKET(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TICKET *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_TICKET(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_TICKET *val);
static int ASN1CALL ASN1Enc_KERB_AUTHENTICATOR(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AUTHENTICATOR *val);
static int ASN1CALL ASN1Enc_KERB_KDC_REQUEST_BODY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KDC_REQUEST_BODY *val);
static int ASN1CALL ASN1Enc_KERB_KDC_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KDC_REPLY *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_KDC_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_KDC_REPLY *val);
static int ASN1CALL ASN1Enc_KERB_AP_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AP_REQUEST *val);
static int ASN1CALL ASN1Enc_KERB_AP_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AP_REPLY *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_AP_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_AP_REPLY *val);
static int ASN1CALL ASN1Enc_KERB_SAFE_MESSAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SAFE_MESSAGE *val);
static int ASN1CALL ASN1Enc_KERB_PRIV_MESSAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PRIV_MESSAGE *val);
static int ASN1CALL ASN1Enc_KERB_CRED(ASN1encoding_t enc, ASN1uint32_t tag, KERB_CRED *val);
static int ASN1CALL ASN1Enc_KERB_CRED_INFO(ASN1encoding_t enc, ASN1uint32_t tag, KERB_CRED_INFO *val);
static int ASN1CALL ASN1Enc_KERB_TGT_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TGT_REPLY *val);
static int ASN1CALL ASN1Enc_KERB_SIGNED_REPLY_KEY_PACKAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SIGNED_REPLY_KEY_PACKAGE *val);
static int ASN1CALL ASN1Enc_KERB_SIGNED_KDC_PUBLIC_VALUE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SIGNED_KDC_PUBLIC_VALUE *val);
static int ASN1CALL ASN1Enc_KERB_TRUSTED_CAS(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TRUSTED_CAS *val);
static int ASN1CALL ASN1Enc_KERB_AUTH_PACKAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AUTH_PACKAGE *val);
static int ASN1CALL ASN1Enc_KERB_PA_COMPOUND_IDENTITY(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PA_COMPOUND_IDENTITY *val);
static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REQ_trusted_certifiers(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ_trusted_certifiers *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_CRED_ticket_info(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_ENCRYPTED_CRED_ticket_info *val);
static int ASN1CALL ASN1Enc_KERB_CRED_tickets(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_CRED_tickets *val);
static int ASN1CALL ASN1Enc_KERB_KDC_REQUEST_BODY_additional_tickets(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_KDC_REQUEST_BODY_additional_tickets *val);
static int ASN1CALL ASN1Enc_KERB_KDC_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KDC_REQUEST *val);
static int ASN1CALL ASN1Enc_KERB_MARSHALLED_REQUEST_BODY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_MARSHALLED_REQUEST_BODY *val);
static int ASN1CALL ASN1Enc_KERB_AS_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AS_REPLY *val);
static int ASN1CALL ASN1Enc_KERB_TGS_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TGS_REPLY *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_AS_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_AS_REPLY *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_TGS_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_TGS_REPLY *val);
static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REP2(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PK_AS_REP2 *val);
static int ASN1CALL ASN1Enc_KERB_SIGNED_AUTH_PACKAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SIGNED_AUTH_PACKAGE *val);
static int ASN1CALL ASN1Enc_KERB_AS_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AS_REQUEST *val);
static int ASN1CALL ASN1Enc_KERB_TGS_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TGS_REQUEST *val);
static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REQ2(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PK_AS_REQ2 *val);
static int ASN1CALL ASN1Dec_PKERB_AUTHORIZATION_DATA_LIST(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_AUTHORIZATION_DATA_LIST *val);
static int ASN1CALL ASN1Dec_PKERB_IF_RELEVANT_AUTH_DATA(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_IF_RELEVANT_AUTH_DATA *val);
static int ASN1CALL ASN1Dec_KERB_PA_PAC_REQUEST_EX_pac_sections(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PA_PAC_REQUEST_EX_pac_sections *val);
static int ASN1CALL ASN1Dec_KERB_KDC_REQUEST_BODY_encryption_type(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_KDC_REQUEST_BODY_encryption_type *val);
static int ASN1CALL ASN1Dec_PKERB_TICKET_EXTENSIONS_Seq(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_TICKET_EXTENSIONS_Seq *val);
static int ASN1CALL ASN1Dec_KERB_PRINCIPAL_NAME_name_string(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PRINCIPAL_NAME_name_string *val);
static int ASN1CALL ASN1Dec_PKERB_LAST_REQUEST_Seq(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_LAST_REQUEST_Seq *val);
static int ASN1CALL ASN1Dec_PKERB_AUTHORIZATION_DATA_Seq(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_AUTHORIZATION_DATA_Seq *val);
static int ASN1CALL ASN1Dec_PKERB_HOST_ADDRESSES_Seq(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_HOST_ADDRESSES_Seq *val);
static int ASN1CALL ASN1Dec_KERB_HOST_ADDRESS(ASN1decoding_t dec, ASN1uint32_t tag, KERB_HOST_ADDRESS *val);
static int ASN1CALL ASN1Dec_PKERB_HOST_ADDRESSES(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_HOST_ADDRESSES *val);
static int ASN1CALL ASN1Dec_PKERB_AUTHORIZATION_DATA(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_AUTHORIZATION_DATA *val);
static int ASN1CALL ASN1Dec_PKERB_LAST_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_LAST_REQUEST *val);
static int ASN1CALL ASN1Dec_KERB_PRINCIPAL_NAME(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PRINCIPAL_NAME *val);
static int ASN1CALL ASN1Dec_PKERB_TICKET_EXTENSIONS(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_TICKET_EXTENSIONS *val);
static int ASN1CALL ASN1Dec_KERB_TRANSITED_ENCODING(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TRANSITED_ENCODING *val);
static int ASN1CALL ASN1Dec_KERB_PA_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_DATA *val);
static int ASN1CALL ASN1Dec_PKERB_PREAUTH_DATA_LIST(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_PREAUTH_DATA_LIST *val);
static int ASN1CALL ASN1Dec_KERB_SAFE_BODY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SAFE_BODY *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_PRIV(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_PRIV *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_CRED(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_CRED *val);
static int ASN1CALL ASN1Dec_KERB_ERROR(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ERROR *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_DATA *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTION_KEY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTION_KEY *val);
static int ASN1CALL ASN1Dec_KERB_CHECKSUM(ASN1decoding_t dec, ASN1uint32_t tag, KERB_CHECKSUM *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_TIMESTAMP(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_TIMESTAMP *val);
static int ASN1CALL ASN1Dec_KERB_SALTED_ENCRYPTED_TIMESTAMP(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SALTED_ENCRYPTED_TIMESTAMP *val);
static int ASN1CALL ASN1Dec_KERB_ETYPE_INFO_ENTRY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ETYPE_INFO_ENTRY *val);
static int ASN1CALL ASN1Dec_PKERB_ETYPE_INFO(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_ETYPE_INFO *val);
static int ASN1CALL ASN1Dec_KERB_TGT_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TGT_REQUEST *val);
static int ASN1CALL ASN1Dec_KERB_PKCS_SIGNATURE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PKCS_SIGNATURE *val);
static int ASN1CALL ASN1Dec_KERB_ALGORITHM_IDENTIFIER(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ALGORITHM_IDENTIFIER *val);
static int ASN1CALL ASN1Dec_KERB_SIGNATURE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SIGNATURE *val);
static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REP(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PK_AS_REP *val);
static int ASN1CALL ASN1Dec_KERB_ENVELOPED_KEY_PACKAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENVELOPED_KEY_PACKAGE *val);
static int ASN1CALL ASN1Dec_KERB_REPLY_KEY_PACKAGE2(ASN1decoding_t dec, ASN1uint32_t tag, KERB_REPLY_KEY_PACKAGE2 *val);
static int ASN1CALL ASN1Dec_KERB_REPLY_KEY_PACKAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_REPLY_KEY_PACKAGE *val);
static int ASN1CALL ASN1Dec_KERB_KDC_DH_KEY_INFO(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KDC_DH_KEY_INFO *val);
static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REQ(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PK_AS_REQ *val);
static int ASN1CALL ASN1Dec_KERB_KERBEROS_NAME(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KERBEROS_NAME *val);
static int ASN1CALL ASN1Dec_KERB_PK_AUTHENTICATOR(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PK_AUTHENTICATOR *val);
static int ASN1CALL ASN1Dec_KERB_SUBJECT_PUBLIC_KEY_INFO(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SUBJECT_PUBLIC_KEY_INFO *val);
static int ASN1CALL ASN1Dec_KERB_DH_PARAMTER(ASN1decoding_t dec, ASN1uint32_t tag, KERB_DH_PARAMTER *val);
static int ASN1CALL ASN1Dec_KERB_CERTIFICATE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_CERTIFICATE *val);
static int ASN1CALL ASN1Dec_KERB_TYPED_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TYPED_DATA *val);
static int ASN1CALL ASN1Dec_KERB_KDC_ISSUED_AUTH_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KDC_ISSUED_AUTH_DATA *val);
static int ASN1CALL ASN1Dec_KERB_PA_SERV_REFERRAL(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_SERV_REFERRAL *val);
static int ASN1CALL ASN1Dec_KERB_PA_PAC_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PAC_REQUEST *val);
static int ASN1CALL ASN1Dec_KERB_CHANGE_PASSWORD_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_CHANGE_PASSWORD_DATA *val);
static int ASN1CALL ASN1Dec_KERB_ERROR_METHOD_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ERROR_METHOD_DATA *val);
static int ASN1CALL ASN1Dec_KERB_EXT_ERROR(ASN1decoding_t dec, ASN1uint32_t tag, KERB_EXT_ERROR *val);
static int ASN1CALL ASN1Dec_KERB_PA_FOR_USER(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_FOR_USER *val);
static int ASN1CALL ASN1Dec_KERB_PA_PAC_REQUEST_EX(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PAC_REQUEST_EX *val);
static int ASN1CALL ASN1Dec_KERB_KDC_ISSUED_AUTH_DATA_elements(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_KDC_ISSUED_AUTH_DATA_elements *val);
static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REQ2_trusted_certifiers(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ2_trusted_certifiers *val);
static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REQ2_user_certs(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ2_user_certs *val);
static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REP2_kdc_cert(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PA_PK_AS_REP2_kdc_cert *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data *val);
static int ASN1CALL ASN1Dec_KERB_KDC_REPLY_preauth_data(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_KDC_REPLY_preauth_data *val);
static int ASN1CALL ASN1Dec_KERB_KDC_REQUEST_preauth_data(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_KDC_REQUEST_preauth_data *val);
static int ASN1CALL ASN1Dec_KERB_TICKET(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TICKET *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_TICKET(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_TICKET *val);
static int ASN1CALL ASN1Dec_KERB_AUTHENTICATOR(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AUTHENTICATOR *val);
static int ASN1CALL ASN1Dec_KERB_KDC_REQUEST_BODY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KDC_REQUEST_BODY *val);
static int ASN1CALL ASN1Dec_KERB_KDC_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KDC_REPLY *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_KDC_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_KDC_REPLY *val);
static int ASN1CALL ASN1Dec_KERB_AP_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AP_REQUEST *val);
static int ASN1CALL ASN1Dec_KERB_AP_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AP_REPLY *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_AP_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_AP_REPLY *val);
static int ASN1CALL ASN1Dec_KERB_SAFE_MESSAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SAFE_MESSAGE *val);
static int ASN1CALL ASN1Dec_KERB_PRIV_MESSAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PRIV_MESSAGE *val);
static int ASN1CALL ASN1Dec_KERB_CRED(ASN1decoding_t dec, ASN1uint32_t tag, KERB_CRED *val);
static int ASN1CALL ASN1Dec_KERB_CRED_INFO(ASN1decoding_t dec, ASN1uint32_t tag, KERB_CRED_INFO *val);
static int ASN1CALL ASN1Dec_KERB_TGT_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TGT_REPLY *val);
static int ASN1CALL ASN1Dec_KERB_SIGNED_REPLY_KEY_PACKAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SIGNED_REPLY_KEY_PACKAGE *val);
static int ASN1CALL ASN1Dec_KERB_SIGNED_KDC_PUBLIC_VALUE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SIGNED_KDC_PUBLIC_VALUE *val);
static int ASN1CALL ASN1Dec_KERB_TRUSTED_CAS(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TRUSTED_CAS *val);
static int ASN1CALL ASN1Dec_KERB_AUTH_PACKAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AUTH_PACKAGE *val);
static int ASN1CALL ASN1Dec_KERB_PA_COMPOUND_IDENTITY(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PA_COMPOUND_IDENTITY *val);
static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REQ_trusted_certifiers(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ_trusted_certifiers *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_CRED_ticket_info(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_ENCRYPTED_CRED_ticket_info *val);
static int ASN1CALL ASN1Dec_KERB_CRED_tickets(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_CRED_tickets *val);
static int ASN1CALL ASN1Dec_KERB_KDC_REQUEST_BODY_additional_tickets(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_KDC_REQUEST_BODY_additional_tickets *val);
static int ASN1CALL ASN1Dec_KERB_KDC_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KDC_REQUEST *val);
static int ASN1CALL ASN1Dec_KERB_MARSHALLED_REQUEST_BODY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_MARSHALLED_REQUEST_BODY *val);
static int ASN1CALL ASN1Dec_KERB_AS_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AS_REPLY *val);
static int ASN1CALL ASN1Dec_KERB_TGS_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TGS_REPLY *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_AS_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_AS_REPLY *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_TGS_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_TGS_REPLY *val);
static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REP2(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PK_AS_REP2 *val);
static int ASN1CALL ASN1Dec_KERB_SIGNED_AUTH_PACKAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SIGNED_AUTH_PACKAGE *val);
static int ASN1CALL ASN1Dec_KERB_AS_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AS_REQUEST *val);
static int ASN1CALL ASN1Dec_KERB_TGS_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TGS_REQUEST *val);
static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REQ2(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PK_AS_REQ2 *val);
static void ASN1CALL ASN1Free_PKERB_AUTHORIZATION_DATA_LIST(PKERB_AUTHORIZATION_DATA_LIST *val);
static void ASN1CALL ASN1Free_PKERB_IF_RELEVANT_AUTH_DATA(PKERB_IF_RELEVANT_AUTH_DATA *val);
static void ASN1CALL ASN1Free_KERB_PA_PAC_REQUEST_EX_pac_sections(PKERB_PA_PAC_REQUEST_EX_pac_sections *val);
static void ASN1CALL ASN1Free_KERB_KDC_REQUEST_BODY_encryption_type(PKERB_KDC_REQUEST_BODY_encryption_type *val);
static void ASN1CALL ASN1Free_PKERB_TICKET_EXTENSIONS_Seq(PKERB_TICKET_EXTENSIONS_Seq *val);
static void ASN1CALL ASN1Free_KERB_PRINCIPAL_NAME_name_string(PKERB_PRINCIPAL_NAME_name_string *val);
static void ASN1CALL ASN1Free_PKERB_LAST_REQUEST_Seq(PKERB_LAST_REQUEST_Seq *val);
static void ASN1CALL ASN1Free_PKERB_AUTHORIZATION_DATA_Seq(PKERB_AUTHORIZATION_DATA_Seq *val);
static void ASN1CALL ASN1Free_PKERB_HOST_ADDRESSES_Seq(PKERB_HOST_ADDRESSES_Seq *val);
static void ASN1CALL ASN1Free_KERB_HOST_ADDRESS(KERB_HOST_ADDRESS *val);
static void ASN1CALL ASN1Free_PKERB_HOST_ADDRESSES(PPKERB_HOST_ADDRESSES *val);
static void ASN1CALL ASN1Free_PKERB_AUTHORIZATION_DATA(PPKERB_AUTHORIZATION_DATA *val);
static void ASN1CALL ASN1Free_PKERB_LAST_REQUEST(PPKERB_LAST_REQUEST *val);
static void ASN1CALL ASN1Free_KERB_PRINCIPAL_NAME(KERB_PRINCIPAL_NAME *val);
static void ASN1CALL ASN1Free_PKERB_TICKET_EXTENSIONS(PPKERB_TICKET_EXTENSIONS *val);
static void ASN1CALL ASN1Free_KERB_TRANSITED_ENCODING(KERB_TRANSITED_ENCODING *val);
static void ASN1CALL ASN1Free_KERB_PA_DATA(KERB_PA_DATA *val);
static void ASN1CALL ASN1Free_PKERB_PREAUTH_DATA_LIST(PPKERB_PREAUTH_DATA_LIST *val);
static void ASN1CALL ASN1Free_KERB_SAFE_BODY(KERB_SAFE_BODY *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTED_PRIV(KERB_ENCRYPTED_PRIV *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTED_CRED(KERB_ENCRYPTED_CRED *val);
static void ASN1CALL ASN1Free_KERB_ERROR(KERB_ERROR *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTED_DATA(KERB_ENCRYPTED_DATA *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTION_KEY(KERB_ENCRYPTION_KEY *val);
static void ASN1CALL ASN1Free_KERB_CHECKSUM(KERB_CHECKSUM *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTED_TIMESTAMP(KERB_ENCRYPTED_TIMESTAMP *val);
static void ASN1CALL ASN1Free_KERB_SALTED_ENCRYPTED_TIMESTAMP(KERB_SALTED_ENCRYPTED_TIMESTAMP *val);
static void ASN1CALL ASN1Free_KERB_ETYPE_INFO_ENTRY(KERB_ETYPE_INFO_ENTRY *val);
static void ASN1CALL ASN1Free_PKERB_ETYPE_INFO(PPKERB_ETYPE_INFO *val);
static void ASN1CALL ASN1Free_KERB_TGT_REQUEST(KERB_TGT_REQUEST *val);
static void ASN1CALL ASN1Free_KERB_PKCS_SIGNATURE(KERB_PKCS_SIGNATURE *val);
static void ASN1CALL ASN1Free_KERB_ALGORITHM_IDENTIFIER(KERB_ALGORITHM_IDENTIFIER *val);
static void ASN1CALL ASN1Free_KERB_SIGNATURE(KERB_SIGNATURE *val);
static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REP(KERB_PA_PK_AS_REP *val);
static void ASN1CALL ASN1Free_KERB_ENVELOPED_KEY_PACKAGE(KERB_ENVELOPED_KEY_PACKAGE *val);
static void ASN1CALL ASN1Free_KERB_REPLY_KEY_PACKAGE2(KERB_REPLY_KEY_PACKAGE2 *val);
static void ASN1CALL ASN1Free_KERB_REPLY_KEY_PACKAGE(KERB_REPLY_KEY_PACKAGE *val);
static void ASN1CALL ASN1Free_KERB_KDC_DH_KEY_INFO(KERB_KDC_DH_KEY_INFO *val);
static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REQ(KERB_PA_PK_AS_REQ *val);
static void ASN1CALL ASN1Free_KERB_KERBEROS_NAME(KERB_KERBEROS_NAME *val);
static void ASN1CALL ASN1Free_KERB_PK_AUTHENTICATOR(KERB_PK_AUTHENTICATOR *val);
static void ASN1CALL ASN1Free_KERB_SUBJECT_PUBLIC_KEY_INFO(KERB_SUBJECT_PUBLIC_KEY_INFO *val);
static void ASN1CALL ASN1Free_KERB_CERTIFICATE(KERB_CERTIFICATE *val);
static void ASN1CALL ASN1Free_KERB_TYPED_DATA(KERB_TYPED_DATA *val);
static void ASN1CALL ASN1Free_KERB_KDC_ISSUED_AUTH_DATA(KERB_KDC_ISSUED_AUTH_DATA *val);
static void ASN1CALL ASN1Free_KERB_PA_SERV_REFERRAL(KERB_PA_SERV_REFERRAL *val);
static void ASN1CALL ASN1Free_KERB_CHANGE_PASSWORD_DATA(KERB_CHANGE_PASSWORD_DATA *val);
static void ASN1CALL ASN1Free_KERB_ERROR_METHOD_DATA(KERB_ERROR_METHOD_DATA *val);
static void ASN1CALL ASN1Free_KERB_PA_FOR_USER(KERB_PA_FOR_USER *val);
static void ASN1CALL ASN1Free_KERB_PA_PAC_REQUEST_EX(KERB_PA_PAC_REQUEST_EX *val);
static void ASN1CALL ASN1Free_KERB_KDC_ISSUED_AUTH_DATA_elements(PKERB_KDC_ISSUED_AUTH_DATA_elements *val);
static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REQ2_trusted_certifiers(PKERB_PA_PK_AS_REQ2_trusted_certifiers *val);
static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REQ2_user_certs(PKERB_PA_PK_AS_REQ2_user_certs *val);
static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REP2_kdc_cert(PKERB_PA_PK_AS_REP2_kdc_cert *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data(PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data *val);
static void ASN1CALL ASN1Free_KERB_KDC_REPLY_preauth_data(PKERB_KDC_REPLY_preauth_data *val);
static void ASN1CALL ASN1Free_KERB_KDC_REQUEST_preauth_data(PKERB_KDC_REQUEST_preauth_data *val);
static void ASN1CALL ASN1Free_KERB_TICKET(KERB_TICKET *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTED_TICKET(KERB_ENCRYPTED_TICKET *val);
static void ASN1CALL ASN1Free_KERB_AUTHENTICATOR(KERB_AUTHENTICATOR *val);
static void ASN1CALL ASN1Free_KERB_KDC_REQUEST_BODY(KERB_KDC_REQUEST_BODY *val);
static void ASN1CALL ASN1Free_KERB_KDC_REPLY(KERB_KDC_REPLY *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTED_KDC_REPLY(KERB_ENCRYPTED_KDC_REPLY *val);
static void ASN1CALL ASN1Free_KERB_AP_REQUEST(KERB_AP_REQUEST *val);
static void ASN1CALL ASN1Free_KERB_AP_REPLY(KERB_AP_REPLY *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTED_AP_REPLY(KERB_ENCRYPTED_AP_REPLY *val);
static void ASN1CALL ASN1Free_KERB_SAFE_MESSAGE(KERB_SAFE_MESSAGE *val);
static void ASN1CALL ASN1Free_KERB_PRIV_MESSAGE(KERB_PRIV_MESSAGE *val);
static void ASN1CALL ASN1Free_KERB_CRED(KERB_CRED *val);
static void ASN1CALL ASN1Free_KERB_CRED_INFO(KERB_CRED_INFO *val);
static void ASN1CALL ASN1Free_KERB_TGT_REPLY(KERB_TGT_REPLY *val);
static void ASN1CALL ASN1Free_KERB_SIGNED_REPLY_KEY_PACKAGE(KERB_SIGNED_REPLY_KEY_PACKAGE *val);
static void ASN1CALL ASN1Free_KERB_SIGNED_KDC_PUBLIC_VALUE(KERB_SIGNED_KDC_PUBLIC_VALUE *val);
static void ASN1CALL ASN1Free_KERB_TRUSTED_CAS(KERB_TRUSTED_CAS *val);
static void ASN1CALL ASN1Free_KERB_AUTH_PACKAGE(KERB_AUTH_PACKAGE *val);
static void ASN1CALL ASN1Free_KERB_PA_COMPOUND_IDENTITY(PKERB_PA_COMPOUND_IDENTITY *val);
static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REQ_trusted_certifiers(PKERB_PA_PK_AS_REQ_trusted_certifiers *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTED_CRED_ticket_info(PKERB_ENCRYPTED_CRED_ticket_info *val);
static void ASN1CALL ASN1Free_KERB_CRED_tickets(PKERB_CRED_tickets *val);
static void ASN1CALL ASN1Free_KERB_KDC_REQUEST_BODY_additional_tickets(PKERB_KDC_REQUEST_BODY_additional_tickets *val);
static void ASN1CALL ASN1Free_KERB_KDC_REQUEST(KERB_KDC_REQUEST *val);
static void ASN1CALL ASN1Free_KERB_MARSHALLED_REQUEST_BODY(KERB_MARSHALLED_REQUEST_BODY *val);
static void ASN1CALL ASN1Free_KERB_AS_REPLY(KERB_AS_REPLY *val);
static void ASN1CALL ASN1Free_KERB_TGS_REPLY(KERB_TGS_REPLY *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTED_AS_REPLY(KERB_ENCRYPTED_AS_REPLY *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTED_TGS_REPLY(KERB_ENCRYPTED_TGS_REPLY *val);
static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REP2(KERB_PA_PK_AS_REP2 *val);
static void ASN1CALL ASN1Free_KERB_SIGNED_AUTH_PACKAGE(KERB_SIGNED_AUTH_PACKAGE *val);
static void ASN1CALL ASN1Free_KERB_AS_REQUEST(KERB_AS_REQUEST *val);
static void ASN1CALL ASN1Free_KERB_TGS_REQUEST(KERB_TGS_REQUEST *val);
static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REQ2(KERB_PA_PK_AS_REQ2 *val);

typedef ASN1BerEncFun_t ASN1EncFun_t;
static const ASN1EncFun_t encfntab[51] = {
    (ASN1EncFun_t) ASN1Enc_PKERB_AUTHORIZATION_DATA_LIST,
    (ASN1EncFun_t) ASN1Enc_PKERB_IF_RELEVANT_AUTH_DATA,
    (ASN1EncFun_t) ASN1Enc_PKERB_PREAUTH_DATA_LIST,
    (ASN1EncFun_t) ASN1Enc_KERB_ENCRYPTED_PRIV,
    (ASN1EncFun_t) ASN1Enc_KERB_ENCRYPTED_CRED,
    (ASN1EncFun_t) ASN1Enc_KERB_ERROR,
    (ASN1EncFun_t) ASN1Enc_KERB_ENCRYPTED_DATA,
    (ASN1EncFun_t) ASN1Enc_KERB_ENCRYPTION_KEY,
    (ASN1EncFun_t) ASN1Enc_KERB_CHECKSUM,
    (ASN1EncFun_t) ASN1Enc_KERB_ENCRYPTED_TIMESTAMP,
    (ASN1EncFun_t) ASN1Enc_KERB_SALTED_ENCRYPTED_TIMESTAMP,
    (ASN1EncFun_t) ASN1Enc_PKERB_ETYPE_INFO,
    (ASN1EncFun_t) ASN1Enc_KERB_TGT_REQUEST,
    (ASN1EncFun_t) ASN1Enc_KERB_PKCS_SIGNATURE,
    (ASN1EncFun_t) ASN1Enc_KERB_PA_PK_AS_REP,
    (ASN1EncFun_t) ASN1Enc_KERB_REPLY_KEY_PACKAGE2,
    (ASN1EncFun_t) ASN1Enc_KERB_REPLY_KEY_PACKAGE,
    (ASN1EncFun_t) ASN1Enc_KERB_KDC_DH_KEY_INFO,
    (ASN1EncFun_t) ASN1Enc_KERB_PA_PK_AS_REQ,
    (ASN1EncFun_t) ASN1Enc_KERB_DH_PARAMTER,
    (ASN1EncFun_t) ASN1Enc_KERB_TYPED_DATA,
    (ASN1EncFun_t) ASN1Enc_KERB_KDC_ISSUED_AUTH_DATA,
    (ASN1EncFun_t) ASN1Enc_KERB_PA_SERV_REFERRAL,
    (ASN1EncFun_t) ASN1Enc_KERB_PA_PAC_REQUEST,
    (ASN1EncFun_t) ASN1Enc_KERB_CHANGE_PASSWORD_DATA,
    (ASN1EncFun_t) ASN1Enc_KERB_ERROR_METHOD_DATA,
    (ASN1EncFun_t) ASN1Enc_KERB_EXT_ERROR,
    (ASN1EncFun_t) ASN1Enc_KERB_PA_FOR_USER,
    (ASN1EncFun_t) ASN1Enc_KERB_PA_PAC_REQUEST_EX,
    (ASN1EncFun_t) ASN1Enc_KERB_TICKET,
    (ASN1EncFun_t) ASN1Enc_KERB_ENCRYPTED_TICKET,
    (ASN1EncFun_t) ASN1Enc_KERB_AUTHENTICATOR,
    (ASN1EncFun_t) ASN1Enc_KERB_AP_REQUEST,
    (ASN1EncFun_t) ASN1Enc_KERB_AP_REPLY,
    (ASN1EncFun_t) ASN1Enc_KERB_ENCRYPTED_AP_REPLY,
    (ASN1EncFun_t) ASN1Enc_KERB_SAFE_MESSAGE,
    (ASN1EncFun_t) ASN1Enc_KERB_PRIV_MESSAGE,
    (ASN1EncFun_t) ASN1Enc_KERB_CRED,
    (ASN1EncFun_t) ASN1Enc_KERB_TGT_REPLY,
    (ASN1EncFun_t) ASN1Enc_KERB_SIGNED_REPLY_KEY_PACKAGE,
    (ASN1EncFun_t) ASN1Enc_KERB_AUTH_PACKAGE,
    (ASN1EncFun_t) ASN1Enc_KERB_PA_COMPOUND_IDENTITY,
    (ASN1EncFun_t) ASN1Enc_KERB_MARSHALLED_REQUEST_BODY,
    (ASN1EncFun_t) ASN1Enc_KERB_AS_REPLY,
    (ASN1EncFun_t) ASN1Enc_KERB_TGS_REPLY,
    (ASN1EncFun_t) ASN1Enc_KERB_ENCRYPTED_AS_REPLY,
    (ASN1EncFun_t) ASN1Enc_KERB_ENCRYPTED_TGS_REPLY,
    (ASN1EncFun_t) ASN1Enc_KERB_PA_PK_AS_REP2,
    (ASN1EncFun_t) ASN1Enc_KERB_AS_REQUEST,
    (ASN1EncFun_t) ASN1Enc_KERB_TGS_REQUEST,
    (ASN1EncFun_t) ASN1Enc_KERB_PA_PK_AS_REQ2,
};
typedef ASN1BerDecFun_t ASN1DecFun_t;
static const ASN1DecFun_t decfntab[51] = {
    (ASN1DecFun_t) ASN1Dec_PKERB_AUTHORIZATION_DATA_LIST,
    (ASN1DecFun_t) ASN1Dec_PKERB_IF_RELEVANT_AUTH_DATA,
    (ASN1DecFun_t) ASN1Dec_PKERB_PREAUTH_DATA_LIST,
    (ASN1DecFun_t) ASN1Dec_KERB_ENCRYPTED_PRIV,
    (ASN1DecFun_t) ASN1Dec_KERB_ENCRYPTED_CRED,
    (ASN1DecFun_t) ASN1Dec_KERB_ERROR,
    (ASN1DecFun_t) ASN1Dec_KERB_ENCRYPTED_DATA,
    (ASN1DecFun_t) ASN1Dec_KERB_ENCRYPTION_KEY,
    (ASN1DecFun_t) ASN1Dec_KERB_CHECKSUM,
    (ASN1DecFun_t) ASN1Dec_KERB_ENCRYPTED_TIMESTAMP,
    (ASN1DecFun_t) ASN1Dec_KERB_SALTED_ENCRYPTED_TIMESTAMP,
    (ASN1DecFun_t) ASN1Dec_PKERB_ETYPE_INFO,
    (ASN1DecFun_t) ASN1Dec_KERB_TGT_REQUEST,
    (ASN1DecFun_t) ASN1Dec_KERB_PKCS_SIGNATURE,
    (ASN1DecFun_t) ASN1Dec_KERB_PA_PK_AS_REP,
    (ASN1DecFun_t) ASN1Dec_KERB_REPLY_KEY_PACKAGE2,
    (ASN1DecFun_t) ASN1Dec_KERB_REPLY_KEY_PACKAGE,
    (ASN1DecFun_t) ASN1Dec_KERB_KDC_DH_KEY_INFO,
    (ASN1DecFun_t) ASN1Dec_KERB_PA_PK_AS_REQ,
    (ASN1DecFun_t) ASN1Dec_KERB_DH_PARAMTER,
    (ASN1DecFun_t) ASN1Dec_KERB_TYPED_DATA,
    (ASN1DecFun_t) ASN1Dec_KERB_KDC_ISSUED_AUTH_DATA,
    (ASN1DecFun_t) ASN1Dec_KERB_PA_SERV_REFERRAL,
    (ASN1DecFun_t) ASN1Dec_KERB_PA_PAC_REQUEST,
    (ASN1DecFun_t) ASN1Dec_KERB_CHANGE_PASSWORD_DATA,
    (ASN1DecFun_t) ASN1Dec_KERB_ERROR_METHOD_DATA,
    (ASN1DecFun_t) ASN1Dec_KERB_EXT_ERROR,
    (ASN1DecFun_t) ASN1Dec_KERB_PA_FOR_USER,
    (ASN1DecFun_t) ASN1Dec_KERB_PA_PAC_REQUEST_EX,
    (ASN1DecFun_t) ASN1Dec_KERB_TICKET,
    (ASN1DecFun_t) ASN1Dec_KERB_ENCRYPTED_TICKET,
    (ASN1DecFun_t) ASN1Dec_KERB_AUTHENTICATOR,
    (ASN1DecFun_t) ASN1Dec_KERB_AP_REQUEST,
    (ASN1DecFun_t) ASN1Dec_KERB_AP_REPLY,
    (ASN1DecFun_t) ASN1Dec_KERB_ENCRYPTED_AP_REPLY,
    (ASN1DecFun_t) ASN1Dec_KERB_SAFE_MESSAGE,
    (ASN1DecFun_t) ASN1Dec_KERB_PRIV_MESSAGE,
    (ASN1DecFun_t) ASN1Dec_KERB_CRED,
    (ASN1DecFun_t) ASN1Dec_KERB_TGT_REPLY,
    (ASN1DecFun_t) ASN1Dec_KERB_SIGNED_REPLY_KEY_PACKAGE,
    (ASN1DecFun_t) ASN1Dec_KERB_AUTH_PACKAGE,
    (ASN1DecFun_t) ASN1Dec_KERB_PA_COMPOUND_IDENTITY,
    (ASN1DecFun_t) ASN1Dec_KERB_MARSHALLED_REQUEST_BODY,
    (ASN1DecFun_t) ASN1Dec_KERB_AS_REPLY,
    (ASN1DecFun_t) ASN1Dec_KERB_TGS_REPLY,
    (ASN1DecFun_t) ASN1Dec_KERB_ENCRYPTED_AS_REPLY,
    (ASN1DecFun_t) ASN1Dec_KERB_ENCRYPTED_TGS_REPLY,
    (ASN1DecFun_t) ASN1Dec_KERB_PA_PK_AS_REP2,
    (ASN1DecFun_t) ASN1Dec_KERB_AS_REQUEST,
    (ASN1DecFun_t) ASN1Dec_KERB_TGS_REQUEST,
    (ASN1DecFun_t) ASN1Dec_KERB_PA_PK_AS_REQ2,
};
static const ASN1FreeFun_t freefntab[51] = {
    (ASN1FreeFun_t) ASN1Free_PKERB_AUTHORIZATION_DATA_LIST,
    (ASN1FreeFun_t) ASN1Free_PKERB_IF_RELEVANT_AUTH_DATA,
    (ASN1FreeFun_t) ASN1Free_PKERB_PREAUTH_DATA_LIST,
    (ASN1FreeFun_t) ASN1Free_KERB_ENCRYPTED_PRIV,
    (ASN1FreeFun_t) ASN1Free_KERB_ENCRYPTED_CRED,
    (ASN1FreeFun_t) ASN1Free_KERB_ERROR,
    (ASN1FreeFun_t) ASN1Free_KERB_ENCRYPTED_DATA,
    (ASN1FreeFun_t) ASN1Free_KERB_ENCRYPTION_KEY,
    (ASN1FreeFun_t) ASN1Free_KERB_CHECKSUM,
    (ASN1FreeFun_t) ASN1Free_KERB_ENCRYPTED_TIMESTAMP,
    (ASN1FreeFun_t) ASN1Free_KERB_SALTED_ENCRYPTED_TIMESTAMP,
    (ASN1FreeFun_t) ASN1Free_PKERB_ETYPE_INFO,
    (ASN1FreeFun_t) ASN1Free_KERB_TGT_REQUEST,
    (ASN1FreeFun_t) ASN1Free_KERB_PKCS_SIGNATURE,
    (ASN1FreeFun_t) ASN1Free_KERB_PA_PK_AS_REP,
    (ASN1FreeFun_t) ASN1Free_KERB_REPLY_KEY_PACKAGE2,
    (ASN1FreeFun_t) ASN1Free_KERB_REPLY_KEY_PACKAGE,
    (ASN1FreeFun_t) ASN1Free_KERB_KDC_DH_KEY_INFO,
    (ASN1FreeFun_t) ASN1Free_KERB_PA_PK_AS_REQ,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) ASN1Free_KERB_TYPED_DATA,
    (ASN1FreeFun_t) ASN1Free_KERB_KDC_ISSUED_AUTH_DATA,
    (ASN1FreeFun_t) ASN1Free_KERB_PA_SERV_REFERRAL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) ASN1Free_KERB_CHANGE_PASSWORD_DATA,
    (ASN1FreeFun_t) ASN1Free_KERB_ERROR_METHOD_DATA,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) ASN1Free_KERB_PA_FOR_USER,
    (ASN1FreeFun_t) ASN1Free_KERB_PA_PAC_REQUEST_EX,
    (ASN1FreeFun_t) ASN1Free_KERB_TICKET,
    (ASN1FreeFun_t) ASN1Free_KERB_ENCRYPTED_TICKET,
    (ASN1FreeFun_t) ASN1Free_KERB_AUTHENTICATOR,
    (ASN1FreeFun_t) ASN1Free_KERB_AP_REQUEST,
    (ASN1FreeFun_t) ASN1Free_KERB_AP_REPLY,
    (ASN1FreeFun_t) ASN1Free_KERB_ENCRYPTED_AP_REPLY,
    (ASN1FreeFun_t) ASN1Free_KERB_SAFE_MESSAGE,
    (ASN1FreeFun_t) ASN1Free_KERB_PRIV_MESSAGE,
    (ASN1FreeFun_t) ASN1Free_KERB_CRED,
    (ASN1FreeFun_t) ASN1Free_KERB_TGT_REPLY,
    (ASN1FreeFun_t) ASN1Free_KERB_SIGNED_REPLY_KEY_PACKAGE,
    (ASN1FreeFun_t) ASN1Free_KERB_AUTH_PACKAGE,
    (ASN1FreeFun_t) ASN1Free_KERB_PA_COMPOUND_IDENTITY,
    (ASN1FreeFun_t) ASN1Free_KERB_MARSHALLED_REQUEST_BODY,
    (ASN1FreeFun_t) ASN1Free_KERB_AS_REPLY,
    (ASN1FreeFun_t) ASN1Free_KERB_TGS_REPLY,
    (ASN1FreeFun_t) ASN1Free_KERB_ENCRYPTED_AS_REPLY,
    (ASN1FreeFun_t) ASN1Free_KERB_ENCRYPTED_TGS_REPLY,
    (ASN1FreeFun_t) ASN1Free_KERB_PA_PK_AS_REP2,
    (ASN1FreeFun_t) ASN1Free_KERB_AS_REQUEST,
    (ASN1FreeFun_t) ASN1Free_KERB_TGS_REQUEST,
    (ASN1FreeFun_t) ASN1Free_KERB_PA_PK_AS_REQ2,
};
static const ULONG sizetab[51] = {
    SIZE_KRB5_Module_PDU_0,
    SIZE_KRB5_Module_PDU_1,
    SIZE_KRB5_Module_PDU_2,
    SIZE_KRB5_Module_PDU_3,
    SIZE_KRB5_Module_PDU_4,
    SIZE_KRB5_Module_PDU_5,
    SIZE_KRB5_Module_PDU_6,
    SIZE_KRB5_Module_PDU_7,
    SIZE_KRB5_Module_PDU_8,
    SIZE_KRB5_Module_PDU_9,
    SIZE_KRB5_Module_PDU_10,
    SIZE_KRB5_Module_PDU_11,
    SIZE_KRB5_Module_PDU_12,
    SIZE_KRB5_Module_PDU_13,
    SIZE_KRB5_Module_PDU_14,
    SIZE_KRB5_Module_PDU_15,
    SIZE_KRB5_Module_PDU_16,
    SIZE_KRB5_Module_PDU_17,
    SIZE_KRB5_Module_PDU_18,
    SIZE_KRB5_Module_PDU_19,
    SIZE_KRB5_Module_PDU_20,
    SIZE_KRB5_Module_PDU_21,
    SIZE_KRB5_Module_PDU_22,
    SIZE_KRB5_Module_PDU_23,
    SIZE_KRB5_Module_PDU_24,
    SIZE_KRB5_Module_PDU_25,
    SIZE_KRB5_Module_PDU_26,
    SIZE_KRB5_Module_PDU_27,
    SIZE_KRB5_Module_PDU_28,
    SIZE_KRB5_Module_PDU_29,
    SIZE_KRB5_Module_PDU_30,
    SIZE_KRB5_Module_PDU_31,
    SIZE_KRB5_Module_PDU_32,
    SIZE_KRB5_Module_PDU_33,
    SIZE_KRB5_Module_PDU_34,
    SIZE_KRB5_Module_PDU_35,
    SIZE_KRB5_Module_PDU_36,
    SIZE_KRB5_Module_PDU_37,
    SIZE_KRB5_Module_PDU_38,
    SIZE_KRB5_Module_PDU_39,
    SIZE_KRB5_Module_PDU_40,
    SIZE_KRB5_Module_PDU_41,
    SIZE_KRB5_Module_PDU_42,
    SIZE_KRB5_Module_PDU_43,
    SIZE_KRB5_Module_PDU_44,
    SIZE_KRB5_Module_PDU_45,
    SIZE_KRB5_Module_PDU_46,
    SIZE_KRB5_Module_PDU_47,
    SIZE_KRB5_Module_PDU_48,
    SIZE_KRB5_Module_PDU_49,
    SIZE_KRB5_Module_PDU_50,
};

/* forward declarations of values: */
/* definitions of value components: */
/* definitions of values: */

void ASN1CALL KRB5_Module_Startup(void)
{
    KRB5_Module = ASN1_CreateModule(0x10000, ASN1_BER_RULE_DER, ASN1FLAGS_NOASSERT, 51, (const ASN1GenericFun_t *) encfntab, (const ASN1GenericFun_t *) decfntab, freefntab, sizetab, 0x3562726b);
}

void ASN1CALL KRB5_Module_Cleanup(void)
{
    ASN1_CloseModule(KRB5_Module);
    KRB5_Module = NULL;
}

static int ASN1CALL ASN1Enc_PKERB_AUTHORIZATION_DATA_LIST(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_AUTHORIZATION_DATA_LIST *val)
{
    if (!ASN1Enc_PKERB_AUTHORIZATION_DATA(enc, tag, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_AUTHORIZATION_DATA_LIST(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_AUTHORIZATION_DATA_LIST *val)
{
    if (!ASN1Dec_PKERB_AUTHORIZATION_DATA(dec, tag, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_AUTHORIZATION_DATA_LIST(PKERB_AUTHORIZATION_DATA_LIST *val)
{
    if (val) {
	ASN1Free_PKERB_AUTHORIZATION_DATA(val);
    }
}

static int ASN1CALL ASN1Enc_PKERB_IF_RELEVANT_AUTH_DATA(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_IF_RELEVANT_AUTH_DATA *val)
{
    if (!ASN1Enc_PKERB_AUTHORIZATION_DATA(enc, tag, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_IF_RELEVANT_AUTH_DATA(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_IF_RELEVANT_AUTH_DATA *val)
{
    if (!ASN1Dec_PKERB_AUTHORIZATION_DATA(dec, tag, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_IF_RELEVANT_AUTH_DATA(PKERB_IF_RELEVANT_AUTH_DATA *val)
{
    if (val) {
	ASN1Free_PKERB_AUTHORIZATION_DATA(val);
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_PAC_REQUEST_EX_pac_sections(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PA_PAC_REQUEST_EX_pac_sections *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_PA_PAC_REQUEST_EX_pac_sections f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1BEREncS32(enc, 0x2, f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_PAC_REQUEST_EX_pac_sections(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PA_PAC_REQUEST_EX_pac_sections *val)
{
    PKERB_PA_PAC_REQUEST_EX_pac_sections *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PKERB_PA_PAC_REQUEST_EX_pac_sections)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1BERDecS32Val(dd, 0x2, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_PAC_REQUEST_EX_pac_sections(PKERB_PA_PAC_REQUEST_EX_pac_sections *val)
{
    PKERB_PA_PAC_REQUEST_EX_pac_sections f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_KDC_REQUEST_BODY_encryption_type(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_KDC_REQUEST_BODY_encryption_type *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_KDC_REQUEST_BODY_encryption_type f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000008, &nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1BEREncS32(enc, 0x2, f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_KDC_REQUEST_BODY_encryption_type(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_KDC_REQUEST_BODY_encryption_type *val)
{
    PKERB_KDC_REQUEST_BODY_encryption_type *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000008, &dd0, &di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PKERB_KDC_REQUEST_BODY_encryption_type)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1BERDecS32Val(dd, 0x2, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_KDC_REQUEST_BODY_encryption_type(PKERB_KDC_REQUEST_BODY_encryption_type *val)
{
    PKERB_KDC_REQUEST_BODY_encryption_type f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_PKERB_TICKET_EXTENSIONS_Seq(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_TICKET_EXTENSIONS_Seq *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->te_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->te_data).length, ((val)->te_data).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_TICKET_EXTENSIONS_Seq(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_TICKET_EXTENSIONS_Seq *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->te_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->te_data))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_TICKET_EXTENSIONS_Seq(PKERB_TICKET_EXTENSIONS_Seq *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->te_data);
    }
}

static int ASN1CALL ASN1Enc_KERB_PRINCIPAL_NAME_name_string(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PRINCIPAL_NAME_name_string *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_PRINCIPAL_NAME_name_string f;
    ASN1uint32_t nLenOff;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	t = lstrlenA(f->value);
	if (!ASN1DEREncCharString(enc, 0x1b, t, f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PRINCIPAL_NAME_name_string(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PRINCIPAL_NAME_name_string *val)
{
    PKERB_PRINCIPAL_NAME_name_string *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PKERB_PRINCIPAL_NAME_name_string)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1BERDecZeroCharString(dd, 0x1b, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PRINCIPAL_NAME_name_string(PKERB_PRINCIPAL_NAME_name_string *val)
{
    PKERB_PRINCIPAL_NAME_name_string f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1ztcharstring_free(f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_PKERB_LAST_REQUEST_Seq(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_LAST_REQUEST_Seq *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->last_request_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->last_request_value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_LAST_REQUEST_Seq(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_LAST_REQUEST_Seq *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->last_request_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->last_request_value))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_LAST_REQUEST_Seq(PKERB_LAST_REQUEST_Seq *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_PKERB_AUTHORIZATION_DATA_Seq(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_AUTHORIZATION_DATA_Seq *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->auth_data_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->auth_data).length, ((val)->auth_data).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_AUTHORIZATION_DATA_Seq(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_AUTHORIZATION_DATA_Seq *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->auth_data_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->auth_data))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_AUTHORIZATION_DATA_Seq(PKERB_AUTHORIZATION_DATA_Seq *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->auth_data);
    }
}

static int ASN1CALL ASN1Enc_PKERB_HOST_ADDRESSES_Seq(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_HOST_ADDRESSES_Seq *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->address_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->address).length, ((val)->address).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_HOST_ADDRESSES_Seq(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_HOST_ADDRESSES_Seq *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->address_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->address))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_HOST_ADDRESSES_Seq(PKERB_HOST_ADDRESSES_Seq *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->address);
    }
}

static int ASN1CALL ASN1Enc_KERB_HOST_ADDRESS(ASN1encoding_t enc, ASN1uint32_t tag, KERB_HOST_ADDRESS *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->addr_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->address).length, ((val)->address).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_HOST_ADDRESS(ASN1decoding_t dec, ASN1uint32_t tag, KERB_HOST_ADDRESS *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->addr_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->address))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_HOST_ADDRESS(KERB_HOST_ADDRESS *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->address);
    }
}

static int ASN1CALL ASN1Enc_PKERB_HOST_ADDRESSES(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_HOST_ADDRESSES *val)
{
    PPKERB_HOST_ADDRESSES f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_PKERB_HOST_ADDRESSES_Seq(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_HOST_ADDRESSES(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_HOST_ADDRESSES *val)
{
    PPKERB_HOST_ADDRESSES *f;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PPKERB_HOST_ADDRESSES)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_PKERB_HOST_ADDRESSES_Seq(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_HOST_ADDRESSES(PPKERB_HOST_ADDRESSES *val)
{
    PPKERB_HOST_ADDRESSES f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_PKERB_HOST_ADDRESSES_Seq(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_PKERB_AUTHORIZATION_DATA(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_AUTHORIZATION_DATA *val)
{
    PPKERB_AUTHORIZATION_DATA f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_PKERB_AUTHORIZATION_DATA_Seq(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_AUTHORIZATION_DATA(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_AUTHORIZATION_DATA *val)
{
    PPKERB_AUTHORIZATION_DATA *f;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PPKERB_AUTHORIZATION_DATA)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_PKERB_AUTHORIZATION_DATA_Seq(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_AUTHORIZATION_DATA(PPKERB_AUTHORIZATION_DATA *val)
{
    PPKERB_AUTHORIZATION_DATA f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_PKERB_AUTHORIZATION_DATA_Seq(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_PKERB_LAST_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_LAST_REQUEST *val)
{
    PPKERB_LAST_REQUEST f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_PKERB_LAST_REQUEST_Seq(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_LAST_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_LAST_REQUEST *val)
{
    PPKERB_LAST_REQUEST *f;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PPKERB_LAST_REQUEST)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_PKERB_LAST_REQUEST_Seq(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_LAST_REQUEST(PPKERB_LAST_REQUEST *val)
{
    PPKERB_LAST_REQUEST f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_PKERB_LAST_REQUEST_Seq(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_PRINCIPAL_NAME(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PRINCIPAL_NAME *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->name_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME_name_string(enc, 0, &(val)->name_string))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PRINCIPAL_NAME(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PRINCIPAL_NAME *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->name_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME_name_string(dd, 0, &(val)->name_string))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PRINCIPAL_NAME(KERB_PRINCIPAL_NAME *val)
{
    if (val) {
	ASN1Free_KERB_PRINCIPAL_NAME_name_string(&(val)->name_string);
    }
}

static int ASN1CALL ASN1Enc_PKERB_TICKET_EXTENSIONS(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_TICKET_EXTENSIONS *val)
{
    PPKERB_TICKET_EXTENSIONS f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_PKERB_TICKET_EXTENSIONS_Seq(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_TICKET_EXTENSIONS(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_TICKET_EXTENSIONS *val)
{
    PPKERB_TICKET_EXTENSIONS *f;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PPKERB_TICKET_EXTENSIONS)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_PKERB_TICKET_EXTENSIONS_Seq(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_TICKET_EXTENSIONS(PPKERB_TICKET_EXTENSIONS *val)
{
    PPKERB_TICKET_EXTENSIONS f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_PKERB_TICKET_EXTENSIONS_Seq(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_TRANSITED_ENCODING(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TRANSITED_ENCODING *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->transited_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->contents).length, ((val)->contents).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_TRANSITED_ENCODING(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TRANSITED_ENCODING *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->transited_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->contents))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_TRANSITED_ENCODING(KERB_TRANSITED_ENCODING *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->contents);
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_DATA *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->preauth_data_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->preauth_data).length, ((val)->preauth_data).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_DATA *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->preauth_data_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->preauth_data))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_DATA(KERB_PA_DATA *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->preauth_data);
    }
}

static int ASN1CALL ASN1Enc_PKERB_PREAUTH_DATA_LIST(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_PREAUTH_DATA_LIST *val)
{
    PPKERB_PREAUTH_DATA_LIST f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_KERB_PA_DATA(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_PREAUTH_DATA_LIST(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_PREAUTH_DATA_LIST *val)
{
    PPKERB_PREAUTH_DATA_LIST *f;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PPKERB_PREAUTH_DATA_LIST)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_KERB_PA_DATA(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_PREAUTH_DATA_LIST(PPKERB_PREAUTH_DATA_LIST *val)
{
    PPKERB_PREAUTH_DATA_LIST f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_KERB_PA_DATA(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_SAFE_BODY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SAFE_BODY *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->user_data).length, ((val)->user_data).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->timestamp))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	    return 0;
	if (!ASN1BEREncS32(enc, 0x2, (val)->usec))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	    return 0;
	if (!ASN1BEREncU32(enc, 0x2, (val)->sequence_number))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_HOST_ADDRESS(enc, 0, &(val)->sender_address))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x10) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000005, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_HOST_ADDRESS(enc, 0, &(val)->recipient_address))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_SAFE_BODY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SAFE_BODY *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->user_data))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->timestamp))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->usec))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecU32Val(dd0, 0x2, (ASN1uint32_t *) &(val)->sequence_number))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_HOST_ADDRESS(dd0, 0, &(val)->sender_address))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000005) {
	(val)->o[0] |= 0x10;
	if (!ASN1BERDecExplicitTag(dd, 0x80000005, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_HOST_ADDRESS(dd0, 0, &(val)->recipient_address))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_SAFE_BODY(KERB_SAFE_BODY *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->user_data);
	if ((val)->o[0] & 0x80) {
	}
	ASN1Free_KERB_HOST_ADDRESS(&(val)->sender_address);
	if ((val)->o[0] & 0x10) {
	    ASN1Free_KERB_HOST_ADDRESS(&(val)->recipient_address);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_PRIV(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_PRIV *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000001c, &nExplTagLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->user_data).length, ((val)->user_data).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->timestamp))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	    return 0;
	if (!ASN1BEREncS32(enc, 0x2, (val)->usec))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	    return 0;
	if (!ASN1BEREncU32(enc, 0x2, (val)->sequence_number))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_HOST_ADDRESS(enc, 0, &(val)->sender_address))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x10) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000005, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_HOST_ADDRESS(enc, 0, &(val)->recipient_address))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_PRIV(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_PRIV *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000001c, &pExplTagDec0, &pbExplTagDataEnd0))
	return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->user_data))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->timestamp))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->usec))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecU32Val(dd0, 0x2, (ASN1uint32_t *) &(val)->sequence_number))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_HOST_ADDRESS(dd0, 0, &(val)->sender_address))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000005) {
	(val)->o[0] |= 0x10;
	if (!ASN1BERDecExplicitTag(dd, 0x80000005, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_HOST_ADDRESS(dd0, 0, &(val)->recipient_address))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTED_PRIV(KERB_ENCRYPTED_PRIV *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->user_data);
	if ((val)->o[0] & 0x80) {
	}
	ASN1Free_KERB_HOST_ADDRESS(&(val)->sender_address);
	if ((val)->o[0] & 0x10) {
	    ASN1Free_KERB_HOST_ADDRESS(&(val)->recipient_address);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_CRED(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_CRED *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000001d, &nExplTagLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    if (!ASN1Enc_KERB_ENCRYPTED_CRED_ticket_info(enc, 0, &(val)->ticket_info))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1BEREncS32(enc, 0x2, (val)->nonce))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->timestamp))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	    return 0;
	if (!ASN1BEREncS32(enc, 0x2, (val)->usec))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_HOST_ADDRESS(enc, 0, &(val)->sender_address))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000005, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_HOST_ADDRESS(enc, 0, &(val)->recipient_address))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_CRED(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_CRED *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000001d, &pExplTagDec0, &pbExplTagDataEnd0))
	return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1Dec_KERB_ENCRYPTED_CRED_ticket_info(dd, 0, &(val)->ticket_info))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->nonce))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->timestamp))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->usec))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000004) {
	(val)->o[0] |= 0x10;
	if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_HOST_ADDRESS(dd0, 0, &(val)->sender_address))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000005) {
	(val)->o[0] |= 0x8;
	if (!ASN1BERDecExplicitTag(dd, 0x80000005, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_HOST_ADDRESS(dd0, 0, &(val)->recipient_address))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTED_CRED(KERB_ENCRYPTED_CRED *val)
{
    if (val) {
	ASN1Free_KERB_ENCRYPTED_CRED_ticket_info(&(val)->ticket_info);
	if ((val)->o[0] & 0x40) {
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_KERB_HOST_ADDRESS(&(val)->sender_address);
	}
	if ((val)->o[0] & 0x8) {
	    ASN1Free_KERB_HOST_ADDRESS(&(val)->recipient_address);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_ERROR(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ERROR *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000001e, &nExplTagLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->message_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->client_time))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	    return 0;
	if (!ASN1BEREncS32(enc, 0x2, (val)->client_usec))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->server_time))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000005, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->server_usec))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000006, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->error_code))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x20) {
	t = lstrlenA((val)->client_realm);
	if (!ASN1BEREncExplicitTag(enc, 0x80000007, &nLenOff0))
	    return 0;
	if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->client_realm))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000008, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->client_name))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    t = lstrlenA((val)->realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000009, &nLenOff0))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->realm))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x8000000a, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->server_name))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x8) {
	if (!ASN1BEREncExplicitTag(enc, 0x8000000b, &nLenOff0))
	    return 0;
	if (!ASN1DEREncCharString(enc, 0x1b, ((val)->error_text).length, ((val)->error_text).value))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1BEREncExplicitTag(enc, 0x8000000c, &nLenOff0))
	    return 0;
	if (!ASN1DEREncOctetString(enc, 0x4, ((val)->error_data).length, ((val)->error_data).value))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ERROR(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ERROR *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000001e, &pExplTagDec0, &pbExplTagDataEnd0))
	return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->message_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->client_time))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->client_usec))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->server_time))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000005, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->server_usec))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000006, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->error_code))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000007) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecExplicitTag(dd, 0x80000007, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->client_realm))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000008) {
	(val)->o[0] |= 0x10;
	if (!ASN1BERDecExplicitTag(dd, 0x80000008, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->client_name))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000009, &dd0, &di0))
	return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->realm))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x8000000a, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->server_name))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x8000000b) {
	(val)->o[0] |= 0x8;
	if (!ASN1BERDecExplicitTag(dd, 0x8000000b, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecCharString(dd0, 0x1b, &(val)->error_text))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x8000000c) {
	(val)->o[0] |= 0x4;
	if (!ASN1BERDecExplicitTag(dd, 0x8000000c, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->error_data))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ERROR(KERB_ERROR *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	}
	if ((val)->o[0] & 0x20) {
	    ASN1ztcharstring_free((val)->client_realm);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_KERB_PRINCIPAL_NAME(&(val)->client_name);
	}
	ASN1ztcharstring_free((val)->realm);
	ASN1Free_KERB_PRINCIPAL_NAME(&(val)->server_name);
	if ((val)->o[0] & 0x8) {
	    ASN1charstring_free(&(val)->error_text);
	}
	if ((val)->o[0] & 0x4) {
	    ASN1octetstring_free(&(val)->error_data);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_DATA *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->encryption_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->cipher_text).length, ((val)->cipher_text).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_DATA *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->encryption_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->cipher_text))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTED_DATA(KERB_ENCRYPTED_DATA *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->cipher_text);
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTION_KEY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTION_KEY *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->keytype))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->keyvalue).length, ((val)->keyvalue).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTION_KEY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTION_KEY *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->keytype))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->keyvalue))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTION_KEY(KERB_ENCRYPTION_KEY *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->keyvalue);
    }
}

static int ASN1CALL ASN1Enc_KERB_CHECKSUM(ASN1encoding_t enc, ASN1uint32_t tag, KERB_CHECKSUM *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->checksum_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->checksum).length, ((val)->checksum).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_CHECKSUM(ASN1decoding_t dec, ASN1uint32_t tag, KERB_CHECKSUM *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->checksum_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->checksum))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_CHECKSUM(KERB_CHECKSUM *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->checksum);
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_TIMESTAMP(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_TIMESTAMP *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->timestamp))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1BEREncS32(enc, 0x2, (val)->usec))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_TIMESTAMP(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_TIMESTAMP *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->timestamp))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->usec))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTED_TIMESTAMP(KERB_ENCRYPTED_TIMESTAMP *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_KERB_SALTED_ENCRYPTED_TIMESTAMP(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SALTED_ENCRYPTED_TIMESTAMP *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->timestamp))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1BEREncS32(enc, 0x2, (val)->usec))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->salt).length, ((val)->salt).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_SALTED_ENCRYPTED_TIMESTAMP(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SALTED_ENCRYPTED_TIMESTAMP *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->timestamp))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->usec))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->salt))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_SALTED_ENCRYPTED_TIMESTAMP(KERB_SALTED_ENCRYPTED_TIMESTAMP *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->salt);
    }
}

static int ASN1CALL ASN1Enc_KERB_ETYPE_INFO_ENTRY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ETYPE_INFO_ENTRY *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->encryption_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1DEREncOctetString(enc, 0x4, ((val)->salt).length, ((val)->salt).value))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ETYPE_INFO_ENTRY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ETYPE_INFO_ENTRY *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->encryption_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->salt))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ETYPE_INFO_ENTRY(KERB_ETYPE_INFO_ENTRY *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1octetstring_free(&(val)->salt);
	}
    }
}

static int ASN1CALL ASN1Enc_PKERB_ETYPE_INFO(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_ETYPE_INFO *val)
{
    PPKERB_ETYPE_INFO f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_KERB_ETYPE_INFO_ENTRY(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_ETYPE_INFO(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_ETYPE_INFO *val)
{
    PPKERB_ETYPE_INFO *f;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PPKERB_ETYPE_INFO)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_KERB_ETYPE_INFO_ENTRY(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_ETYPE_INFO(PPKERB_ETYPE_INFO *val)
{
    PPKERB_ETYPE_INFO f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_KERB_ETYPE_INFO_ENTRY(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_TGT_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TGT_REQUEST *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->message_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->server_name))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	t = lstrlenA((val)->server_realm);
	if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	    return 0;
	if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->server_realm))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_TGT_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TGT_REQUEST *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->message_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->server_name))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->server_realm))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_TGT_REQUEST(KERB_TGT_REQUEST *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_KERB_PRINCIPAL_NAME(&(val)->server_name);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1ztcharstring_free((val)->server_realm);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_PKCS_SIGNATURE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PKCS_SIGNATURE *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->encryption_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->signature).length, ((val)->signature).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PKCS_SIGNATURE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PKCS_SIGNATURE *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->encryption_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->signature))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PKCS_SIGNATURE(KERB_PKCS_SIGNATURE *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->signature);
    }
}

static int ASN1CALL ASN1Enc_KERB_ALGORITHM_IDENTIFIER(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ALGORITHM_IDENTIFIER *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncObjectIdentifier(enc, 0x6, &(val)->algorithm))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncOpenType(enc, &(val)->parameters))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ALGORITHM_IDENTIFIER(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ALGORITHM_IDENTIFIER *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecObjectIdentifier(dd, 0x6, &(val)->algorithm))
	return 0;
    if (ASN1BERDecPeekTag(dd, &t)) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecOpenType2(dd, &(val)->parameters))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ALGORITHM_IDENTIFIER(KERB_ALGORITHM_IDENTIFIER *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->algorithm);
	if ((val)->o[0] & 0x80) {
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_SIGNATURE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SIGNATURE *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ALGORITHM_IDENTIFIER(enc, 0, &(val)->signature_algorithm))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncBitString(enc, 0x3, ((val)->pkcs_signature).length, ((val)->pkcs_signature).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_SIGNATURE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SIGNATURE *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ALGORITHM_IDENTIFIER(dd0, 0, &(val)->signature_algorithm))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecBitString(dd0, 0x3, &(val)->pkcs_signature))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_SIGNATURE(KERB_SIGNATURE *val)
{
    if (val) {
	ASN1Free_KERB_ALGORITHM_IDENTIFIER(&(val)->signature_algorithm);
	ASN1bitstring_free(&(val)->pkcs_signature);
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REP(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PK_AS_REP *val)
{
    switch ((val)->choice) {
    case 1:
	if (!ASN1DEREncOctetString(enc, 0x80000000, ((val)->u.dh_signed_data).length, ((val)->u.dh_signed_data).value))
	    return 0;
	break;
    case 2:
	if (!ASN1DEREncOctetString(enc, 0x80000001, ((val)->u.key_package).length, ((val)->u.key_package).value))
	    return 0;
	break;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REP(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PK_AS_REP *val)
{
    ASN1uint32_t t;
    if (!ASN1BERDecPeekTag(dec, &t))
	return 0;
    switch (t) {
    case 0x80000000:
	(val)->choice = 1;
	if (!ASN1BERDecOctetString(dec, 0x80000000, &(val)->u.dh_signed_data))
	    return 0;
	break;
    case 0x80000001:
	(val)->choice = 2;
	if (!ASN1BERDecOctetString(dec, 0x80000001, &(val)->u.key_package))
	    return 0;
	break;
    default:
	ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REP(KERB_PA_PK_AS_REP *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1octetstring_free(&(val)->u.dh_signed_data);
	    break;
	case 2:
	    ASN1octetstring_free(&(val)->u.key_package);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_ENVELOPED_KEY_PACKAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENVELOPED_KEY_PACKAGE *val)
{
    ASN1uint32_t nLenOff0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_ENCRYPTED_DATA(enc, 0, &(val)->u.encrypted_data))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
	break;
    case 2:
	if (!ASN1DEREncOctetString(enc, 0x80000004, ((val)->u.pkinit_enveloped_data).length, ((val)->u.pkinit_enveloped_data).value))
	    return 0;
	break;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENVELOPED_KEY_PACKAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENVELOPED_KEY_PACKAGE *val)
{
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecPeekTag(dec, &t))
	return 0;
    switch (t) {
    case 0x80000001:
	(val)->choice = 1;
	if (!ASN1BERDecExplicitTag(dec, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_ENCRYPTED_DATA(dd0, 0, &(val)->u.encrypted_data))
	    return 0;
	if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	    return 0;
	break;
    case 0x80000004:
	(val)->choice = 2;
	if (!ASN1BERDecOctetString(dec, 0x80000004, &(val)->u.pkinit_enveloped_data))
	    return 0;
	break;
    default:
	ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENVELOPED_KEY_PACKAGE(KERB_ENVELOPED_KEY_PACKAGE *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_KERB_ENCRYPTED_DATA(&(val)->u.encrypted_data);
	    break;
	case 2:
	    ASN1octetstring_free(&(val)->u.pkinit_enveloped_data);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_REPLY_KEY_PACKAGE2(ASN1encoding_t enc, ASN1uint32_t tag, KERB_REPLY_KEY_PACKAGE2 *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ENCRYPTION_KEY(enc, 0, &(val)->reply_key))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->nonce))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	    return 0;
	if (!ASN1DEREncBitString(enc, 0x3, ((val)->subject_public_key).length, ((val)->subject_public_key).value))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_REPLY_KEY_PACKAGE2(ASN1decoding_t dec, ASN1uint32_t tag, KERB_REPLY_KEY_PACKAGE2 *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ENCRYPTION_KEY(dd0, 0, &(val)->reply_key))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->nonce))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecBitString(dd0, 0x3, &(val)->subject_public_key))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_REPLY_KEY_PACKAGE2(KERB_REPLY_KEY_PACKAGE2 *val)
{
    if (val) {
	ASN1Free_KERB_ENCRYPTION_KEY(&(val)->reply_key);
	if ((val)->o[0] & 0x80) {
	    ASN1bitstring_free(&(val)->subject_public_key);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_REPLY_KEY_PACKAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_REPLY_KEY_PACKAGE *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ENCRYPTION_KEY(enc, 0, &(val)->reply_key))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->nonce))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_REPLY_KEY_PACKAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_REPLY_KEY_PACKAGE *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ENCRYPTION_KEY(dd0, 0, &(val)->reply_key))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->nonce))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_REPLY_KEY_PACKAGE(KERB_REPLY_KEY_PACKAGE *val)
{
    if (val) {
	ASN1Free_KERB_ENCRYPTION_KEY(&(val)->reply_key);
    }
}

static int ASN1CALL ASN1Enc_KERB_KDC_DH_KEY_INFO(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KDC_DH_KEY_INFO *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->nonce))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncBitString(enc, 0x3, ((val)->subject_public_key).length, ((val)->subject_public_key).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_KDC_DH_KEY_INFO(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KDC_DH_KEY_INFO *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->nonce))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecBitString(dd0, 0x3, &(val)->subject_public_key))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_KDC_DH_KEY_INFO(KERB_KDC_DH_KEY_INFO *val)
{
    if (val) {
	ASN1bitstring_free(&(val)->subject_public_key);
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REQ(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PK_AS_REQ *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x80000000, ((val)->signed_auth_pack).length, ((val)->signed_auth_pack).value))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_KERB_PA_PK_AS_REQ_trusted_certifiers(enc, 0, &(val)->trusted_certifiers))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1DEREncOctetString(enc, 0x80000003, ((val)->kdc_cert).length, ((val)->kdc_cert).value))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1DEREncOctetString(enc, 0x80000004, ((val)->encryption_cert).length, ((val)->encryption_cert).value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REQ(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PK_AS_REQ *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecOctetString(dd, 0x80000000, &(val)->signed_auth_pack))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_KERB_PA_PK_AS_REQ_trusted_certifiers(dd, 0, &(val)->trusted_certifiers))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecOctetString(dd, 0x80000003, &(val)->kdc_cert))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000004) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecOctetString(dd, 0x80000004, &(val)->encryption_cert))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REQ(KERB_PA_PK_AS_REQ *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->signed_auth_pack);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_KERB_PA_PK_AS_REQ_trusted_certifiers(&(val)->trusted_certifiers);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1octetstring_free(&(val)->kdc_cert);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1octetstring_free(&(val)->encryption_cert);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_KERBEROS_NAME(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KERBEROS_NAME *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t t;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    t = lstrlenA((val)->realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->realm))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->principal_name))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_KERBEROS_NAME(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KERBEROS_NAME *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->realm))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->principal_name))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_KERBEROS_NAME(KERB_KERBEROS_NAME *val)
{
    if (val) {
	ASN1ztcharstring_free((val)->realm);
	ASN1Free_KERB_PRINCIPAL_NAME(&(val)->principal_name);
    }
}

static int ASN1CALL ASN1Enc_KERB_PK_AUTHENTICATOR(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PK_AUTHENTICATOR *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->kdc_name))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    t = lstrlenA((val)->kdc_realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->kdc_realm))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->cusec))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->client_time))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->nonce))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PK_AUTHENTICATOR(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PK_AUTHENTICATOR *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->kdc_name))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->kdc_realm))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->cusec))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->client_time))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->nonce))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PK_AUTHENTICATOR(KERB_PK_AUTHENTICATOR *val)
{
    if (val) {
	ASN1Free_KERB_PRINCIPAL_NAME(&(val)->kdc_name);
	ASN1ztcharstring_free((val)->kdc_realm);
    }
}

static int ASN1CALL ASN1Enc_KERB_SUBJECT_PUBLIC_KEY_INFO(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SUBJECT_PUBLIC_KEY_INFO *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ALGORITHM_IDENTIFIER(enc, 0, &(val)->algorithm))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncBitString(enc, 0x3, ((val)->subjectPublicKey).length, ((val)->subjectPublicKey).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_SUBJECT_PUBLIC_KEY_INFO(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SUBJECT_PUBLIC_KEY_INFO *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ALGORITHM_IDENTIFIER(dd0, 0, &(val)->algorithm))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecBitString(dd0, 0x3, &(val)->subjectPublicKey))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_SUBJECT_PUBLIC_KEY_INFO(KERB_SUBJECT_PUBLIC_KEY_INFO *val)
{
    if (val) {
	ASN1Free_KERB_ALGORITHM_IDENTIFIER(&(val)->algorithm);
	ASN1bitstring_free(&(val)->subjectPublicKey);
    }
}

static int ASN1CALL ASN1Enc_KERB_DH_PARAMTER(ASN1encoding_t enc, ASN1uint32_t tag, KERB_DH_PARAMTER *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->prime))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->base))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	    return 0;
	if (!ASN1BEREncS32(enc, 0x2, (val)->private_value_length))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_DH_PARAMTER(ASN1decoding_t dec, ASN1uint32_t tag, KERB_DH_PARAMTER *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->prime))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->base))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->private_value_length))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_KERB_CERTIFICATE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_CERTIFICATE *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->cert_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->cert_data).length, ((val)->cert_data).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_CERTIFICATE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_CERTIFICATE *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->cert_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->cert_data))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_CERTIFICATE(KERB_CERTIFICATE *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->cert_data);
    }
}

static int ASN1CALL ASN1Enc_KERB_TYPED_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TYPED_DATA *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->data_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->data_value).length, ((val)->data_value).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_TYPED_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TYPED_DATA *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->data_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->data_value))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_TYPED_DATA(KERB_TYPED_DATA *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->data_value);
    }
}

static int ASN1CALL ASN1Enc_KERB_KDC_ISSUED_AUTH_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KDC_ISSUED_AUTH_DATA *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_SIGNATURE(enc, 0, &(val)->checksum))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_KDC_ISSUED_AUTH_DATA_elements(enc, 0, &(val)->elements))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_KDC_ISSUED_AUTH_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KDC_ISSUED_AUTH_DATA *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_SIGNATURE(dd0, 0, &(val)->checksum))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1Dec_KERB_KDC_ISSUED_AUTH_DATA_elements(dd, 0, &(val)->elements))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_KDC_ISSUED_AUTH_DATA(KERB_KDC_ISSUED_AUTH_DATA *val)
{
    if (val) {
	ASN1Free_KERB_SIGNATURE(&(val)->checksum);
	ASN1Free_KERB_KDC_ISSUED_AUTH_DATA_elements(&(val)->elements);
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_SERV_REFERRAL(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_SERV_REFERRAL *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->referred_server_name))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    t = lstrlenA((val)->referred_server_realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->referred_server_realm))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_SERV_REFERRAL(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_SERV_REFERRAL *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->referred_server_name))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->referred_server_realm))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_SERV_REFERRAL(KERB_PA_SERV_REFERRAL *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_KERB_PRINCIPAL_NAME(&(val)->referred_server_name);
	}
	ASN1ztcharstring_free((val)->referred_server_realm);
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_PAC_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PAC_REQUEST *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncBool(enc, 0x1, (val)->include_pac))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_PAC_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PAC_REQUEST *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecBool(dd0, 0x1, &(val)->include_pac))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_KERB_CHANGE_PASSWORD_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_CHANGE_PASSWORD_DATA *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->new_password).length, ((val)->new_password).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->target_name))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	t = lstrlenA((val)->target_realm);
	if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	    return 0;
	if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->target_realm))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_CHANGE_PASSWORD_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_CHANGE_PASSWORD_DATA *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->new_password))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->target_name))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->target_realm))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_CHANGE_PASSWORD_DATA(KERB_CHANGE_PASSWORD_DATA *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->new_password);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_KERB_PRINCIPAL_NAME(&(val)->target_name);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1ztcharstring_free((val)->target_realm);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_ERROR_METHOD_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ERROR_METHOD_DATA *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->data_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	    return 0;
	if (!ASN1DEREncOctetString(enc, 0x4, ((val)->data_value).length, ((val)->data_value).value))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ERROR_METHOD_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ERROR_METHOD_DATA *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->data_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->data_value))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ERROR_METHOD_DATA(KERB_ERROR_METHOD_DATA *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1octetstring_free(&(val)->data_value);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_EXT_ERROR(ASN1encoding_t enc, ASN1uint32_t tag, KERB_EXT_ERROR *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->status))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->klininfo))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->flags))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_EXT_ERROR(ASN1decoding_t dec, ASN1uint32_t tag, KERB_EXT_ERROR *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->status))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->klininfo))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->flags))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_KERB_PA_FOR_USER(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_FOR_USER *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->userName))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    t = lstrlenA((val)->userRealm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->userRealm))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_CHECKSUM(enc, 0, &(val)->cksum))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    t = lstrlenA((val)->authentication_package);
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->authentication_package))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	    return 0;
	if (!ASN1DEREncOctetString(enc, 0x4, ((val)->authorization_data).length, ((val)->authorization_data).value))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_FOR_USER(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_FOR_USER *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->userName))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->userRealm))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_CHECKSUM(dd0, 0, &(val)->cksum))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->authentication_package))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000004) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->authorization_data))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_FOR_USER(KERB_PA_FOR_USER *val)
{
    if (val) {
	ASN1Free_KERB_PRINCIPAL_NAME(&(val)->userName);
	ASN1ztcharstring_free((val)->userRealm);
	ASN1Free_KERB_CHECKSUM(&(val)->cksum);
	ASN1ztcharstring_free((val)->authentication_package);
	if ((val)->o[0] & 0x80) {
	    ASN1octetstring_free(&(val)->authorization_data);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_PAC_REQUEST_EX(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PAC_REQUEST_EX *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncBool(enc, 0x1, (val)->include_pac))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_KERB_PA_PAC_REQUEST_EX_pac_sections(enc, 0, &(val)->pac_sections))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_PAC_REQUEST_EX(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PAC_REQUEST_EX *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecBool(dd0, 0x1, &(val)->include_pac))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_KERB_PA_PAC_REQUEST_EX_pac_sections(dd, 0, &(val)->pac_sections))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_PAC_REQUEST_EX(KERB_PA_PAC_REQUEST_EX *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_KERB_PA_PAC_REQUEST_EX_pac_sections(&(val)->pac_sections);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_KDC_ISSUED_AUTH_DATA_elements(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_KDC_ISSUED_AUTH_DATA_elements *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_KDC_ISSUED_AUTH_DATA_elements f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_KERB_PA_DATA(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_KDC_ISSUED_AUTH_DATA_elements(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_KDC_ISSUED_AUTH_DATA_elements *val)
{
    PKERB_KDC_ISSUED_AUTH_DATA_elements *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PKERB_KDC_ISSUED_AUTH_DATA_elements)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_KERB_PA_DATA(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_KDC_ISSUED_AUTH_DATA_elements(PKERB_KDC_ISSUED_AUTH_DATA_elements *val)
{
    PKERB_KDC_ISSUED_AUTH_DATA_elements f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_KERB_PA_DATA(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REQ2_trusted_certifiers(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ2_trusted_certifiers *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_PA_PK_AS_REQ2_trusted_certifiers f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REQ2_trusted_certifiers(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ2_trusted_certifiers *val)
{
    PKERB_PA_PK_AS_REQ2_trusted_certifiers *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PKERB_PA_PK_AS_REQ2_trusted_certifiers)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REQ2_trusted_certifiers(PKERB_PA_PK_AS_REQ2_trusted_certifiers *val)
{
    PKERB_PA_PK_AS_REQ2_trusted_certifiers f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_KERB_PRINCIPAL_NAME(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REQ2_user_certs(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ2_user_certs *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_PA_PK_AS_REQ2_user_certs f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_KERB_CERTIFICATE(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REQ2_user_certs(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ2_user_certs *val)
{
    PKERB_PA_PK_AS_REQ2_user_certs *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PKERB_PA_PK_AS_REQ2_user_certs)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_KERB_CERTIFICATE(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REQ2_user_certs(PKERB_PA_PK_AS_REQ2_user_certs *val)
{
    PKERB_PA_PK_AS_REQ2_user_certs f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_KERB_CERTIFICATE(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REP2_kdc_cert(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PA_PK_AS_REP2_kdc_cert *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_PA_PK_AS_REP2_kdc_cert f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000003, &nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_KERB_CERTIFICATE(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REP2_kdc_cert(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PA_PK_AS_REP2_kdc_cert *val)
{
    PKERB_PA_PK_AS_REP2_kdc_cert *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000003, &dd0, &di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PKERB_PA_PK_AS_REP2_kdc_cert)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_KERB_CERTIFICATE(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REP2_kdc_cert(PKERB_PA_PK_AS_REP2_kdc_cert *val)
{
    PKERB_PA_PK_AS_REP2_kdc_cert f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_KERB_CERTIFICATE(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x8000000c, &nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_KERB_PA_DATA(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data *val)
{
    PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x8000000c, &dd0, &di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_KERB_PA_DATA(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data(PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data *val)
{
    PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_KERB_PA_DATA(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_KDC_REPLY_preauth_data(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_KDC_REPLY_preauth_data *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_KDC_REPLY_preauth_data f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_KERB_PA_DATA(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_KDC_REPLY_preauth_data(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_KDC_REPLY_preauth_data *val)
{
    PKERB_KDC_REPLY_preauth_data *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PKERB_KDC_REPLY_preauth_data)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_KERB_PA_DATA(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_KDC_REPLY_preauth_data(PKERB_KDC_REPLY_preauth_data *val)
{
    PKERB_KDC_REPLY_preauth_data f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_KERB_PA_DATA(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_KDC_REQUEST_preauth_data(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_KDC_REQUEST_preauth_data *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_KDC_REQUEST_preauth_data f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000003, &nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_KERB_PA_DATA(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_KDC_REQUEST_preauth_data(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_KDC_REQUEST_preauth_data *val)
{
    PKERB_KDC_REQUEST_preauth_data *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000003, &dd0, &di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PKERB_KDC_REQUEST_preauth_data)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_KERB_PA_DATA(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_KDC_REQUEST_preauth_data(PKERB_KDC_REQUEST_preauth_data *val)
{
    PKERB_KDC_REQUEST_preauth_data f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_KERB_PA_DATA(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_TICKET(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TICKET *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x40000001, &nExplTagLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->ticket_version))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    t = lstrlenA((val)->realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->realm))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->server_name))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ENCRYPTED_DATA(enc, 0, &(val)->encrypted_part))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	    return 0;
	if (!ASN1Enc_PKERB_TICKET_EXTENSIONS(enc, 0, &(val)->ticket_extensions))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_TICKET(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TICKET *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x40000001, &pExplTagDec0, &pbExplTagDataEnd0))
	return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->ticket_version))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->realm))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->server_name))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ENCRYPTED_DATA(dd0, 0, &(val)->encrypted_part))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000004) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_PKERB_TICKET_EXTENSIONS(dd0, 0, &(val)->ticket_extensions))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_TICKET(KERB_TICKET *val)
{
    if (val) {
	ASN1ztcharstring_free((val)->realm);
	ASN1Free_KERB_PRINCIPAL_NAME(&(val)->server_name);
	ASN1Free_KERB_ENCRYPTED_DATA(&(val)->encrypted_part);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_PKERB_TICKET_EXTENSIONS(&(val)->ticket_extensions);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_TICKET(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_TICKET *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x40000003, &nExplTagLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1DEREncBitString(enc, 0x3, ((val)->flags).length, ((val)->flags).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ENCRYPTION_KEY(enc, 0, &(val)->key))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    t = lstrlenA((val)->client_realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->client_realm))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->client_name))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_TRANSITED_ENCODING(enc, 0, &(val)->transited))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000005, &nLenOff0))
	return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->authtime))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000006, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->starttime))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000007, &nLenOff0))
	return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->endtime))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000008, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->renew_until))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000009, &nLenOff0))
	    return 0;
	if (!ASN1Enc_PKERB_HOST_ADDRESSES(enc, 0, &(val)->client_addresses))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1BEREncExplicitTag(enc, 0x8000000a, &nLenOff0))
	    return 0;
	if (!ASN1Enc_PKERB_AUTHORIZATION_DATA(enc, 0, &(val)->authorization_data))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_TICKET(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_TICKET *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x40000003, &pExplTagDec0, &pbExplTagDataEnd0))
	return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecBitString(dd0, 0x3, &(val)->flags))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ENCRYPTION_KEY(dd0, 0, &(val)->key))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->client_realm))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->client_name))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_TRANSITED_ENCODING(dd0, 0, &(val)->transited))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000005, &dd0, &di0))
	return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->authtime))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000006) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000006, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->starttime))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000007, &dd0, &di0))
	return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->endtime))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000008) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000008, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->renew_until))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000009) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecExplicitTag(dd, 0x80000009, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_PKERB_HOST_ADDRESSES(dd0, 0, &(val)->client_addresses))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x8000000a) {
	(val)->o[0] |= 0x10;
	if (!ASN1BERDecExplicitTag(dd, 0x8000000a, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_PKERB_AUTHORIZATION_DATA(dd0, 0, &(val)->authorization_data))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTED_TICKET(KERB_ENCRYPTED_TICKET *val)
{
    if (val) {
	ASN1bitstring_free(&(val)->flags);
	ASN1Free_KERB_ENCRYPTION_KEY(&(val)->key);
	ASN1ztcharstring_free((val)->client_realm);
	ASN1Free_KERB_PRINCIPAL_NAME(&(val)->client_name);
	ASN1Free_KERB_TRANSITED_ENCODING(&(val)->transited);
	if ((val)->o[0] & 0x80) {
	}
	if ((val)->o[0] & 0x40) {
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_PKERB_HOST_ADDRESSES(&(val)->client_addresses);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_PKERB_AUTHORIZATION_DATA(&(val)->authorization_data);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_AUTHENTICATOR(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AUTHENTICATOR *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x40000002, &nExplTagLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->authenticator_version))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    t = lstrlenA((val)->client_realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->client_realm))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->client_name))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_CHECKSUM(enc, 0, &(val)->checksum))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->client_usec))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000005, &nLenOff0))
	return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->client_time))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000006, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_ENCRYPTION_KEY(enc, 0, &(val)->subkey))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000007, &nLenOff0))
	    return 0;
	if (!ASN1BEREncSX(enc, 0x2, &(val)->sequence_number))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000008, &nLenOff0))
	    return 0;
	if (!ASN1Enc_PKERB_AUTHORIZATION_DATA(enc, 0, &(val)->authorization_data))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_AUTHENTICATOR(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AUTHENTICATOR *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x40000002, &pExplTagDec0, &pbExplTagDataEnd0))
	return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->authenticator_version))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->client_realm))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->client_name))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_CHECKSUM(dd0, 0, &(val)->checksum))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->client_usec))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000005, &dd0, &di0))
	return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->client_time))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000006) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000006, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_ENCRYPTION_KEY(dd0, 0, &(val)->subkey))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000007) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecExplicitTag(dd, 0x80000007, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecSXVal(dd0, 0x2, &(val)->sequence_number))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000008) {
	(val)->o[0] |= 0x10;
	if (!ASN1BERDecExplicitTag(dd, 0x80000008, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_PKERB_AUTHORIZATION_DATA(dd0, 0, &(val)->authorization_data))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_AUTHENTICATOR(KERB_AUTHENTICATOR *val)
{
    if (val) {
	ASN1ztcharstring_free((val)->client_realm);
	ASN1Free_KERB_PRINCIPAL_NAME(&(val)->client_name);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_KERB_CHECKSUM(&(val)->checksum);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_KERB_ENCRYPTION_KEY(&(val)->subkey);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1intx_free(&(val)->sequence_number);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_PKERB_AUTHORIZATION_DATA(&(val)->authorization_data);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_KDC_REQUEST_BODY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KDC_REQUEST_BODY *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1DEREncBitString(enc, 0x3, ((val)->kdc_options).length, ((val)->kdc_options).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->client_name))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    t = lstrlenA((val)->realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->realm))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->server_name))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->starttime))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000005, &nLenOff0))
	return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->endtime))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x10) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000006, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->renew_until))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000007, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->nonce))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_KDC_REQUEST_BODY_encryption_type(enc, 0, &(val)->encryption_type))
	return 0;
    if ((val)->o[0] & 0x8) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000009, &nLenOff0))
	    return 0;
	if (!ASN1Enc_PKERB_HOST_ADDRESSES(enc, 0, &(val)->addresses))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1BEREncExplicitTag(enc, 0x8000000a, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_ENCRYPTED_DATA(enc, 0, &(val)->enc_authorization_data))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x2) {
	if (!ASN1Enc_KERB_KDC_REQUEST_BODY_additional_tickets(enc, 0, &(val)->additional_tickets))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_KDC_REQUEST_BODY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KDC_REQUEST_BODY *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecBitString(dd0, 0x3, &(val)->kdc_options))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->client_name))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->realm))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->server_name))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000004) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->starttime))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000005, &dd0, &di0))
	return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->endtime))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000006) {
	(val)->o[0] |= 0x10;
	if (!ASN1BERDecExplicitTag(dd, 0x80000006, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->renew_until))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000007, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->nonce))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1Dec_KERB_KDC_REQUEST_BODY_encryption_type(dd, 0, &(val)->encryption_type))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000009) {
	(val)->o[0] |= 0x8;
	if (!ASN1BERDecExplicitTag(dd, 0x80000009, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_PKERB_HOST_ADDRESSES(dd0, 0, &(val)->addresses))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x8000000a) {
	(val)->o[0] |= 0x4;
	if (!ASN1BERDecExplicitTag(dd, 0x8000000a, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_ENCRYPTED_DATA(dd0, 0, &(val)->enc_authorization_data))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x8000000b) {
	(val)->o[0] |= 0x2;
	if (!ASN1Dec_KERB_KDC_REQUEST_BODY_additional_tickets(dd, 0, &(val)->additional_tickets))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_KDC_REQUEST_BODY(KERB_KDC_REQUEST_BODY *val)
{
    if (val) {
	ASN1bitstring_free(&(val)->kdc_options);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_KERB_PRINCIPAL_NAME(&(val)->client_name);
	}
	ASN1ztcharstring_free((val)->realm);
	if ((val)->o[0] & 0x40) {
	    ASN1Free_KERB_PRINCIPAL_NAME(&(val)->server_name);
	}
	if ((val)->o[0] & 0x20) {
	}
	if ((val)->o[0] & 0x10) {
	}
	ASN1Free_KERB_KDC_REQUEST_BODY_encryption_type(&(val)->encryption_type);
	if ((val)->o[0] & 0x8) {
	    ASN1Free_PKERB_HOST_ADDRESSES(&(val)->addresses);
	}
	if ((val)->o[0] & 0x4) {
	    ASN1Free_KERB_ENCRYPTED_DATA(&(val)->enc_authorization_data);
	}
	if ((val)->o[0] & 0x2) {
	    ASN1Free_KERB_KDC_REQUEST_BODY_additional_tickets(&(val)->additional_tickets);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_KDC_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KDC_REPLY *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->message_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_KERB_KDC_REPLY_preauth_data(enc, 0, &(val)->preauth_data))
	    return 0;
    }
    t = lstrlenA((val)->client_realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->client_realm))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->client_name))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000005, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_TICKET(enc, 0, &(val)->ticket))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000006, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ENCRYPTED_DATA(enc, 0, &(val)->encrypted_part))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_KDC_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KDC_REPLY *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->message_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_KERB_KDC_REPLY_preauth_data(dd, 0, &(val)->preauth_data))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->client_realm))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->client_name))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000005, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_TICKET(dd0, 0, &(val)->ticket))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000006, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ENCRYPTED_DATA(dd0, 0, &(val)->encrypted_part))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_KDC_REPLY(KERB_KDC_REPLY *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_KERB_KDC_REPLY_preauth_data(&(val)->preauth_data);
	}
	ASN1ztcharstring_free((val)->client_realm);
	ASN1Free_KERB_PRINCIPAL_NAME(&(val)->client_name);
	ASN1Free_KERB_TICKET(&(val)->ticket);
	ASN1Free_KERB_ENCRYPTED_DATA(&(val)->encrypted_part);
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_KDC_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_KDC_REPLY *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ENCRYPTION_KEY(enc, 0, &(val)->session_key))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1Enc_PKERB_LAST_REQUEST(enc, 0, &(val)->last_request))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->nonce))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->key_expiration))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	return 0;
    if (!ASN1DEREncBitString(enc, 0x3, ((val)->flags).length, ((val)->flags).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000005, &nLenOff0))
	return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->authtime))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000006, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->starttime))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000007, &nLenOff0))
	return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->endtime))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x20) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000008, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->renew_until))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    t = lstrlenA((val)->server_realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000009, &nLenOff0))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->server_realm))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x8000000a, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->server_name))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x10) {
	if (!ASN1BEREncExplicitTag(enc, 0x8000000b, &nLenOff0))
	    return 0;
	if (!ASN1Enc_PKERB_HOST_ADDRESSES(enc, 0, &(val)->client_addresses))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Enc_KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data(enc, 0, &(val)->encrypted_pa_data))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_KDC_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_KDC_REPLY *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ENCRYPTION_KEY(dd0, 0, &(val)->session_key))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1Dec_PKERB_LAST_REQUEST(dd0, 0, &(val)->last_request))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->nonce))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->key_expiration))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	return 0;
    if (!ASN1BERDecBitString(dd0, 0x3, &(val)->flags))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000005, &dd0, &di0))
	return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->authtime))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000006) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000006, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->starttime))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000007, &dd0, &di0))
	return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->endtime))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000008) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecExplicitTag(dd, 0x80000008, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->renew_until))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000009, &dd0, &di0))
	return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->server_realm))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x8000000a, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->server_name))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x8000000b) {
	(val)->o[0] |= 0x10;
	if (!ASN1BERDecExplicitTag(dd, 0x8000000b, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_PKERB_HOST_ADDRESSES(dd0, 0, &(val)->client_addresses))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x8000000c) {
	(val)->o[0] |= 0x8;
	if (!ASN1Dec_KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data(dd, 0, &(val)->encrypted_pa_data))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTED_KDC_REPLY(KERB_ENCRYPTED_KDC_REPLY *val)
{
    if (val) {
	ASN1Free_KERB_ENCRYPTION_KEY(&(val)->session_key);
	ASN1Free_PKERB_LAST_REQUEST(&(val)->last_request);
	if ((val)->o[0] & 0x80) {
	}
	ASN1bitstring_free(&(val)->flags);
	if ((val)->o[0] & 0x40) {
	}
	if ((val)->o[0] & 0x20) {
	}
	ASN1ztcharstring_free((val)->server_realm);
	ASN1Free_KERB_PRINCIPAL_NAME(&(val)->server_name);
	if ((val)->o[0] & 0x10) {
	    ASN1Free_PKERB_HOST_ADDRESSES(&(val)->client_addresses);
	}
	if ((val)->o[0] & 0x8) {
	    ASN1Free_KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data(&(val)->encrypted_pa_data);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_AP_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AP_REQUEST *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000000e, &nExplTagLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->message_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1DEREncBitString(enc, 0x3, ((val)->ap_options).length, ((val)->ap_options).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_TICKET(enc, 0, &(val)->ticket))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ENCRYPTED_DATA(enc, 0, &(val)->authenticator))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_AP_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AP_REQUEST *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000000e, &pExplTagDec0, &pbExplTagDataEnd0))
	return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->message_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1BERDecBitString(dd0, 0x3, &(val)->ap_options))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_TICKET(dd0, 0, &(val)->ticket))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ENCRYPTED_DATA(dd0, 0, &(val)->authenticator))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_AP_REQUEST(KERB_AP_REQUEST *val)
{
    if (val) {
	ASN1bitstring_free(&(val)->ap_options);
	ASN1Free_KERB_TICKET(&(val)->ticket);
	ASN1Free_KERB_ENCRYPTED_DATA(&(val)->authenticator);
    }
}

static int ASN1CALL ASN1Enc_KERB_AP_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AP_REPLY *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000000f, &nExplTagLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->message_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ENCRYPTED_DATA(enc, 0, &(val)->encrypted_part))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_AP_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AP_REPLY *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000000f, &pExplTagDec0, &pbExplTagDataEnd0))
	return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->message_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ENCRYPTED_DATA(dd0, 0, &(val)->encrypted_part))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_AP_REPLY(KERB_AP_REPLY *val)
{
    if (val) {
	ASN1Free_KERB_ENCRYPTED_DATA(&(val)->encrypted_part);
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_AP_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_AP_REPLY *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000001b, &nExplTagLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->client_time))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->client_usec))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_ENCRYPTION_KEY(enc, 0, &(val)->subkey))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	    return 0;
	if (!ASN1BEREncU32(enc, 0x2, (val)->sequence_number))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_AP_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_AP_REPLY *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000001b, &pExplTagDec0, &pbExplTagDataEnd0))
	return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->client_time))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->client_usec))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_ENCRYPTION_KEY(dd0, 0, &(val)->subkey))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecU32Val(dd0, 0x2, (ASN1uint32_t *) &(val)->sequence_number))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTED_AP_REPLY(KERB_ENCRYPTED_AP_REPLY *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_KERB_ENCRYPTION_KEY(&(val)->subkey);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_SAFE_MESSAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SAFE_MESSAGE *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x40000014, &nExplTagLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->message_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_SAFE_BODY(enc, 0, &(val)->safe_body))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_CHECKSUM(enc, 0, &(val)->checksum))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_SAFE_MESSAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SAFE_MESSAGE *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x40000014, &pExplTagDec0, &pbExplTagDataEnd0))
	return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->message_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_SAFE_BODY(dd0, 0, &(val)->safe_body))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_CHECKSUM(dd0, 0, &(val)->checksum))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_SAFE_MESSAGE(KERB_SAFE_MESSAGE *val)
{
    if (val) {
	ASN1Free_KERB_SAFE_BODY(&(val)->safe_body);
	ASN1Free_KERB_CHECKSUM(&(val)->checksum);
    }
}

static int ASN1CALL ASN1Enc_KERB_PRIV_MESSAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PRIV_MESSAGE *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x40000015, &nExplTagLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->message_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ENCRYPTED_DATA(enc, 0, &(val)->encrypted_part))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PRIV_MESSAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PRIV_MESSAGE *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x40000015, &pExplTagDec0, &pbExplTagDataEnd0))
	return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->message_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ENCRYPTED_DATA(dd0, 0, &(val)->encrypted_part))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PRIV_MESSAGE(KERB_PRIV_MESSAGE *val)
{
    if (val) {
	ASN1Free_KERB_ENCRYPTED_DATA(&(val)->encrypted_part);
    }
}

static int ASN1CALL ASN1Enc_KERB_CRED(ASN1encoding_t enc, ASN1uint32_t tag, KERB_CRED *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x40000016, &nExplTagLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->message_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_CRED_tickets(enc, 0, &(val)->tickets))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ENCRYPTED_DATA(enc, 0, &(val)->encrypted_part))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_CRED(ASN1decoding_t dec, ASN1uint32_t tag, KERB_CRED *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x40000016, &pExplTagDec0, &pbExplTagDataEnd0))
	return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->message_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1Dec_KERB_CRED_tickets(dd, 0, &(val)->tickets))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ENCRYPTED_DATA(dd0, 0, &(val)->encrypted_part))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_CRED(KERB_CRED *val)
{
    if (val) {
	ASN1Free_KERB_CRED_tickets(&(val)->tickets);
	ASN1Free_KERB_ENCRYPTED_DATA(&(val)->encrypted_part);
    }
}

static int ASN1CALL ASN1Enc_KERB_CRED_INFO(ASN1encoding_t enc, ASN1uint32_t tag, KERB_CRED_INFO *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ENCRYPTION_KEY(enc, 0, &(val)->key))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	t = lstrlenA((val)->principal_realm);
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->principal_realm))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->principal_name))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	    return 0;
	if (!ASN1DEREncBitString(enc, 0x3, ((val)->flags).length, ((val)->flags).value))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->authtime))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000005, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->starttime))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000006, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->endtime))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x2) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000007, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->renew_until))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x1) {
	t = lstrlenA((val)->service_realm);
	if (!ASN1BEREncExplicitTag(enc, 0x80000008, &nLenOff0))
	    return 0;
	if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->service_realm))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[1] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000009, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->service_name))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[1] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x8000000a, &nLenOff0))
	    return 0;
	if (!ASN1Enc_PKERB_HOST_ADDRESSES(enc, 0, &(val)->client_addresses))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_CRED_INFO(ASN1decoding_t dec, ASN1uint32_t tag, KERB_CRED_INFO *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 2);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ENCRYPTION_KEY(dd0, 0, &(val)->key))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->principal_realm))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->principal_name))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecBitString(dd0, 0x3, &(val)->flags))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000004) {
	(val)->o[0] |= 0x10;
	if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->authtime))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000005) {
	(val)->o[0] |= 0x8;
	if (!ASN1BERDecExplicitTag(dd, 0x80000005, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->starttime))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000006) {
	(val)->o[0] |= 0x4;
	if (!ASN1BERDecExplicitTag(dd, 0x80000006, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->endtime))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000007) {
	(val)->o[0] |= 0x2;
	if (!ASN1BERDecExplicitTag(dd, 0x80000007, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->renew_until))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000008) {
	(val)->o[0] |= 0x1;
	if (!ASN1BERDecExplicitTag(dd, 0x80000008, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->service_realm))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000009) {
	(val)->o[1] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000009, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->service_name))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x8000000a) {
	(val)->o[1] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x8000000a, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_PKERB_HOST_ADDRESSES(dd0, 0, &(val)->client_addresses))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_CRED_INFO(KERB_CRED_INFO *val)
{
    if (val) {
	ASN1Free_KERB_ENCRYPTION_KEY(&(val)->key);
	if ((val)->o[0] & 0x80) {
	    ASN1ztcharstring_free((val)->principal_realm);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_KERB_PRINCIPAL_NAME(&(val)->principal_name);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1bitstring_free(&(val)->flags);
	}
	if ((val)->o[0] & 0x10) {
	}
	if ((val)->o[0] & 0x8) {
	}
	if ((val)->o[0] & 0x4) {
	}
	if ((val)->o[0] & 0x2) {
	}
	if ((val)->o[0] & 0x1) {
	    ASN1ztcharstring_free((val)->service_realm);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_KERB_PRINCIPAL_NAME(&(val)->service_name);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_PKERB_HOST_ADDRESSES(&(val)->client_addresses);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_TGT_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TGT_REPLY *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->message_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_TICKET(enc, 0, &(val)->ticket))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_TGT_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TGT_REPLY *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->message_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_TICKET(dd0, 0, &(val)->ticket))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_TGT_REPLY(KERB_TGT_REPLY *val)
{
    if (val) {
	ASN1Free_KERB_TICKET(&(val)->ticket);
    }
}

static int ASN1CALL ASN1Enc_KERB_SIGNED_REPLY_KEY_PACKAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SIGNED_REPLY_KEY_PACKAGE *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_REPLY_KEY_PACKAGE2(enc, 0, &(val)->reply_key_package))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_SIGNATURE(enc, 0, &(val)->reply_key_signature))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_SIGNED_REPLY_KEY_PACKAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SIGNED_REPLY_KEY_PACKAGE *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_REPLY_KEY_PACKAGE2(dd0, 0, &(val)->reply_key_package))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_SIGNATURE(dd0, 0, &(val)->reply_key_signature))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_SIGNED_REPLY_KEY_PACKAGE(KERB_SIGNED_REPLY_KEY_PACKAGE *val)
{
    if (val) {
	ASN1Free_KERB_REPLY_KEY_PACKAGE2(&(val)->reply_key_package);
	ASN1Free_KERB_SIGNATURE(&(val)->reply_key_signature);
    }
}

static int ASN1CALL ASN1Enc_KERB_SIGNED_KDC_PUBLIC_VALUE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SIGNED_KDC_PUBLIC_VALUE *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_SUBJECT_PUBLIC_KEY_INFO(enc, 0, &(val)->kdc_public_value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_SIGNATURE(enc, 0, &(val)->kdc_public_value_sig))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_SIGNED_KDC_PUBLIC_VALUE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SIGNED_KDC_PUBLIC_VALUE *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_SUBJECT_PUBLIC_KEY_INFO(dd0, 0, &(val)->kdc_public_value))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_SIGNATURE(dd0, 0, &(val)->kdc_public_value_sig))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_SIGNED_KDC_PUBLIC_VALUE(KERB_SIGNED_KDC_PUBLIC_VALUE *val)
{
    if (val) {
	ASN1Free_KERB_SUBJECT_PUBLIC_KEY_INFO(&(val)->kdc_public_value);
	ASN1Free_KERB_SIGNATURE(&(val)->kdc_public_value_sig);
    }
}

static int ASN1CALL ASN1Enc_KERB_TRUSTED_CAS(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TRUSTED_CAS *val)
{
    ASN1uint32_t nLenOff0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_KERBEROS_NAME(enc, 0, &(val)->u.principal_name))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
	break;
    case 2:
	if (!ASN1DEREncOctetString(enc, 0x80000001, ((val)->u.ca_name).length, ((val)->u.ca_name).value))
	    return 0;
	break;
    case 3:
	if (!ASN1DEREncOctetString(enc, 0x80000002, ((val)->u.issuer_and_serial).length, ((val)->u.issuer_and_serial).value))
	    return 0;
	break;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_TRUSTED_CAS(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TRUSTED_CAS *val)
{
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecPeekTag(dec, &t))
	return 0;
    switch (t) {
    case 0x80000000:
	(val)->choice = 1;
	if (!ASN1BERDecExplicitTag(dec, 0x80000000, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_KERBEROS_NAME(dd0, 0, &(val)->u.principal_name))
	    return 0;
	if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	    return 0;
	break;
    case 0x80000001:
	(val)->choice = 2;
	if (!ASN1BERDecOctetString(dec, 0x80000001, &(val)->u.ca_name))
	    return 0;
	break;
    case 0x80000002:
	(val)->choice = 3;
	if (!ASN1BERDecOctetString(dec, 0x80000002, &(val)->u.issuer_and_serial))
	    return 0;
	break;
    default:
	ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_KERB_TRUSTED_CAS(KERB_TRUSTED_CAS *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_KERB_KERBEROS_NAME(&(val)->u.principal_name);
	    break;
	case 2:
	    ASN1octetstring_free(&(val)->u.ca_name);
	    break;
	case 3:
	    ASN1octetstring_free(&(val)->u.issuer_and_serial);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_AUTH_PACKAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AUTH_PACKAGE *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_PK_AUTHENTICATOR(enc, 0, &(val)->pk_authenticator))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_SUBJECT_PUBLIC_KEY_INFO(enc, 0, &(val)->client_public_value))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_AUTH_PACKAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AUTH_PACKAGE *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_PK_AUTHENTICATOR(dd0, 0, &(val)->pk_authenticator))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_SUBJECT_PUBLIC_KEY_INFO(dd0, 0, &(val)->client_public_value))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_AUTH_PACKAGE(KERB_AUTH_PACKAGE *val)
{
    if (val) {
	ASN1Free_KERB_PK_AUTHENTICATOR(&(val)->pk_authenticator);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_KERB_SUBJECT_PUBLIC_KEY_INFO(&(val)->client_public_value);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_COMPOUND_IDENTITY(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PA_COMPOUND_IDENTITY *val)
{
    PKERB_PA_COMPOUND_IDENTITY f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_KERB_TICKET(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_COMPOUND_IDENTITY(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PA_COMPOUND_IDENTITY *val)
{
    PKERB_PA_COMPOUND_IDENTITY *f;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PKERB_PA_COMPOUND_IDENTITY)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_KERB_TICKET(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_COMPOUND_IDENTITY(PKERB_PA_COMPOUND_IDENTITY *val)
{
    PKERB_PA_COMPOUND_IDENTITY f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_KERB_TICKET(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REQ_trusted_certifiers(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ_trusted_certifiers *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_PA_PK_AS_REQ_trusted_certifiers f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_KERB_TRUSTED_CAS(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REQ_trusted_certifiers(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ_trusted_certifiers *val)
{
    PKERB_PA_PK_AS_REQ_trusted_certifiers *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PKERB_PA_PK_AS_REQ_trusted_certifiers)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_KERB_TRUSTED_CAS(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REQ_trusted_certifiers(PKERB_PA_PK_AS_REQ_trusted_certifiers *val)
{
    PKERB_PA_PK_AS_REQ_trusted_certifiers f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_KERB_TRUSTED_CAS(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_CRED_ticket_info(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_ENCRYPTED_CRED_ticket_info *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_ENCRYPTED_CRED_ticket_info f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_KERB_CRED_INFO(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_CRED_ticket_info(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_ENCRYPTED_CRED_ticket_info *val)
{
    PKERB_ENCRYPTED_CRED_ticket_info *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PKERB_ENCRYPTED_CRED_ticket_info)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_KERB_CRED_INFO(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTED_CRED_ticket_info(PKERB_ENCRYPTED_CRED_ticket_info *val)
{
    PKERB_ENCRYPTED_CRED_ticket_info f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_KERB_CRED_INFO(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_CRED_tickets(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_CRED_tickets *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_CRED_tickets f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_KERB_TICKET(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_CRED_tickets(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_CRED_tickets *val)
{
    PKERB_CRED_tickets *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PKERB_CRED_tickets)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_KERB_TICKET(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_CRED_tickets(PKERB_CRED_tickets *val)
{
    PKERB_CRED_tickets f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_KERB_TICKET(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_KDC_REQUEST_BODY_additional_tickets(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_KDC_REQUEST_BODY_additional_tickets *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_KDC_REQUEST_BODY_additional_tickets f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x8000000b, &nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_KERB_TICKET(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_KDC_REQUEST_BODY_additional_tickets(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_KDC_REQUEST_BODY_additional_tickets *val)
{
    PKERB_KDC_REQUEST_BODY_additional_tickets *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x8000000b, &dd0, &di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PKERB_KDC_REQUEST_BODY_additional_tickets)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_KERB_TICKET(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_KDC_REQUEST_BODY_additional_tickets(PKERB_KDC_REQUEST_BODY_additional_tickets *val)
{
    PKERB_KDC_REQUEST_BODY_additional_tickets f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_KERB_TICKET(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_KDC_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KDC_REQUEST *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->message_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_KERB_KDC_REQUEST_preauth_data(enc, 0, &(val)->preauth_data))
	    return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_KDC_REQUEST_BODY(enc, 0, &(val)->request_body))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_KDC_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KDC_REQUEST *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->message_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_KERB_KDC_REQUEST_preauth_data(dd, 0, &(val)->preauth_data))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_KDC_REQUEST_BODY(dd0, 0, &(val)->request_body))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_KDC_REQUEST(KERB_KDC_REQUEST *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_KERB_KDC_REQUEST_preauth_data(&(val)->preauth_data);
	}
	ASN1Free_KERB_KDC_REQUEST_BODY(&(val)->request_body);
    }
}

static int ASN1CALL ASN1Enc_KERB_MARSHALLED_REQUEST_BODY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_MARSHALLED_REQUEST_BODY *val)
{
    if (!ASN1Enc_KERB_KDC_REQUEST_BODY(enc, tag, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_MARSHALLED_REQUEST_BODY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_MARSHALLED_REQUEST_BODY *val)
{
    if (!ASN1Dec_KERB_KDC_REQUEST_BODY(dec, tag, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_MARSHALLED_REQUEST_BODY(KERB_MARSHALLED_REQUEST_BODY *val)
{
    if (val) {
	ASN1Free_KERB_KDC_REQUEST_BODY(val);
    }
}

static int ASN1CALL ASN1Enc_KERB_AS_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AS_REPLY *val)
{
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000000b, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_KDC_REPLY(enc, 0, val))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_AS_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AS_REPLY *val)
{
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000000b, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_KDC_REPLY(dd0, 0, val))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_AS_REPLY(KERB_AS_REPLY *val)
{
    if (val) {
	ASN1Free_KERB_KDC_REPLY(val);
    }
}

static int ASN1CALL ASN1Enc_KERB_TGS_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TGS_REPLY *val)
{
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000000d, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_KDC_REPLY(enc, 0, val))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_TGS_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TGS_REPLY *val)
{
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000000d, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_KDC_REPLY(dd0, 0, val))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_TGS_REPLY(KERB_TGS_REPLY *val)
{
    if (val) {
	ASN1Free_KERB_KDC_REPLY(val);
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_AS_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_AS_REPLY *val)
{
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x40000019, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ENCRYPTED_KDC_REPLY(enc, 0, val))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_AS_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_AS_REPLY *val)
{
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x40000019, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ENCRYPTED_KDC_REPLY(dd0, 0, val))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTED_AS_REPLY(KERB_ENCRYPTED_AS_REPLY *val)
{
    if (val) {
	ASN1Free_KERB_ENCRYPTED_KDC_REPLY(val);
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_TGS_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_TGS_REPLY *val)
{
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000001a, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ENCRYPTED_KDC_REPLY(enc, 0, val))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_TGS_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_TGS_REPLY *val)
{
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000001a, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ENCRYPTED_KDC_REPLY(dd0, 0, val))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTED_TGS_REPLY(KERB_ENCRYPTED_TGS_REPLY *val)
{
    if (val) {
	ASN1Free_KERB_ENCRYPTED_KDC_REPLY(val);
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REP2(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PK_AS_REP2 *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_ENCRYPTED_DATA(enc, 0, &(val)->key_package))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ENVELOPED_KEY_PACKAGE(enc, 0, &(val)->temp_key_package))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_SIGNED_KDC_PUBLIC_VALUE(enc, 0, &(val)->signed_kdc_public_value))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_KERB_PA_PK_AS_REP2_kdc_cert(enc, 0, &(val)->kdc_cert))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REP2(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PK_AS_REP2 *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_ENCRYPTED_DATA(dd0, 0, &(val)->key_package))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ENVELOPED_KEY_PACKAGE(dd0, 0, &(val)->temp_key_package))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_SIGNED_KDC_PUBLIC_VALUE(dd0, 0, &(val)->signed_kdc_public_value))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x20;
	if (!ASN1Dec_KERB_PA_PK_AS_REP2_kdc_cert(dd, 0, &(val)->kdc_cert))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REP2(KERB_PA_PK_AS_REP2 *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_KERB_ENCRYPTED_DATA(&(val)->key_package);
	}
	ASN1Free_KERB_ENVELOPED_KEY_PACKAGE(&(val)->temp_key_package);
	if ((val)->o[0] & 0x40) {
	    ASN1Free_KERB_SIGNED_KDC_PUBLIC_VALUE(&(val)->signed_kdc_public_value);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_KERB_PA_PK_AS_REP2_kdc_cert(&(val)->kdc_cert);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_SIGNED_AUTH_PACKAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SIGNED_AUTH_PACKAGE *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_AUTH_PACKAGE(enc, 0, &(val)->auth_package))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_SIGNATURE(enc, 0, &(val)->auth_package_signature))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_SIGNED_AUTH_PACKAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SIGNED_AUTH_PACKAGE *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_AUTH_PACKAGE(dd0, 0, &(val)->auth_package))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_SIGNATURE(dd0, 0, &(val)->auth_package_signature))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_SIGNED_AUTH_PACKAGE(KERB_SIGNED_AUTH_PACKAGE *val)
{
    if (val) {
	ASN1Free_KERB_AUTH_PACKAGE(&(val)->auth_package);
	ASN1Free_KERB_SIGNATURE(&(val)->auth_package_signature);
    }
}

static int ASN1CALL ASN1Enc_KERB_AS_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AS_REQUEST *val)
{
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000000a, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_KDC_REQUEST(enc, 0, val))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_AS_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AS_REQUEST *val)
{
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000000a, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_KDC_REQUEST(dd0, 0, val))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_AS_REQUEST(KERB_AS_REQUEST *val)
{
    if (val) {
	ASN1Free_KERB_KDC_REQUEST(val);
    }
}

static int ASN1CALL ASN1Enc_KERB_TGS_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TGS_REQUEST *val)
{
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000000c, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_KDC_REQUEST(enc, 0, val))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_TGS_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TGS_REQUEST *val)
{
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000000c, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_KDC_REQUEST(dd0, 0, val))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_TGS_REQUEST(KERB_TGS_REQUEST *val)
{
    if (val) {
	ASN1Free_KERB_KDC_REQUEST(val);
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REQ2(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PK_AS_REQ2 *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_SIGNED_AUTH_PACKAGE(enc, 0, &(val)->signed_auth_pack))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_KERB_PA_PK_AS_REQ2_user_certs(enc, 0, &(val)->user_certs))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_KERB_PA_PK_AS_REQ2_trusted_certifiers(enc, 0, &(val)->trusted_certifiers))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	    return 0;
	if (!ASN1BEREncS32(enc, 0x2, (val)->serial_number))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REQ2(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PK_AS_REQ2 *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_SIGNED_AUTH_PACKAGE(dd0, 0, &(val)->signed_auth_pack))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_KERB_PA_PK_AS_REQ2_user_certs(dd, 0, &(val)->user_certs))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x40;
	if (!ASN1Dec_KERB_PA_PK_AS_REQ2_trusted_certifiers(dd, 0, &(val)->trusted_certifiers))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->serial_number))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REQ2(KERB_PA_PK_AS_REQ2 *val)
{
    if (val) {
	ASN1Free_KERB_SIGNED_AUTH_PACKAGE(&(val)->signed_auth_pack);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_KERB_PA_PK_AS_REQ2_user_certs(&(val)->user_certs);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_KERB_PA_PK_AS_REQ2_trusted_certifiers(&(val)->trusted_certifiers);
	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\common\names.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:        tickets.c
//
// Contents:    Ticket bundling code
//
//
// History:      6 Dec 91,  RichardW    Created
//              04 Jun 92   RichardW    NT-ized
//              08-Jun-93   WadeR       Converted to C++, rewrote packing code
//
//------------------------------------------------------------------------

#include "commonp.h"


#define KERB_NAME_PREFIX L"Kerberos:"
UNICODE_STRING KerbNamePrefix = {sizeof(KERB_NAME_PREFIX) - sizeof(WCHAR), sizeof(KERB_NAME_PREFIX), KERB_NAME_PREFIX };
UNICODE_STRING KerbNameSeparator = {sizeof(WCHAR), 2*sizeof(WCHAR), L"/" };
UNICODE_STRING KerbDomainSeparator = {sizeof(WCHAR), 2*sizeof(WCHAR), L"@" };


LPWSTR
KerbAllocWStrFromUtf8Str(
    IN LPCSTR Utf8String
    )

/*++

Routine Description:

    Convert a UTF8 (zero terminated) string to the corresponding UNICODE
    string.

Arguments:

    Utf8String - Specifies the UTF8 zero terminated string to convert.


Return Value:

    NULL - There was some error in the conversion.

    Otherwise, it returns a pointer to the zero terminated UNICODE string in
    an allocated buffer.  The buffer must be freed using NetApiBufferFree.

--*/

{
    LPWSTR UnicodeString = NULL;
    int UnicodeStringLen;

    //
    // Determine the length of the Unicode string.
    //

    UnicodeStringLen = MultiByteToWideChar(
#ifndef WIN32_CHICAGO
                        CP_UTF8,
#else // WIN32_CHICAGO
                        CP_OEMCP,
#endif // WIN32_CHICAGO
                        0,      // All characters can be mapped.
                        Utf8String,
                        -1,             // calculate length
                        UnicodeString,
                        0 );

    if ( UnicodeStringLen == 0 ) {
        return NULL;
    }

    //
    // Allocate a buffer for the Unicode string.
    //

    UnicodeString = (LPWSTR) MIDL_user_allocate( (UnicodeStringLen+1)*sizeof(WCHAR) );

    if ( UnicodeString == NULL ) {
        return NULL;
    }

    //
    // Translate the string to Unicode.
    //

    UnicodeStringLen = MultiByteToWideChar(
#ifndef WIN32_CHICAGO
                        CP_UTF8,
#else // WIN32_CHICAGO
                        CP_OEMCP,
#endif // WIN32_CHICAGO
                        0,      // All characters can be mapped.
                        Utf8String,
                        -1,
                        UnicodeString,
                        UnicodeStringLen );

    if ( UnicodeStringLen == 0 ) {
        MIDL_user_free( UnicodeString );
        return NULL;
    }

    UnicodeString[UnicodeStringLen] = L'\0';

    return UnicodeString;
}


NTSTATUS
KerbUnicodeStringFromUtf8Str(
    IN LPCSTR Utf8String,
    OUT PUNICODE_STRING UnicodeString
    )

/*++

Routine Description:

    Convert a UTF8 (zero terminated) string to the corresponding UNICODE
    string.

Arguments:

    Utf8String - Specifies the UTF8 zero terminated string to convert.
    UnicodeString - Receives the converted unicode string


Return Value:

    NULL - There was some error in the conversion.

    Otherwise, it returns a pointer to the zero terminated UNICODE string in
    an allocated buffer.  The buffer must be freed using NetApiBufferFree.

--*/

{
    int UnicodeStringLen;

    //
    // Determine the length of the Unicode string.
    //

    UnicodeStringLen = MultiByteToWideChar(
#ifndef WIN32_CHICAGO
                        CP_UTF8,
#else // WIN32_CHICAGO
                        CP_OEMCP,
#endif // WIN32_CHICAGO
                        0,      // All characters can be mapped.
                        Utf8String,
                        -1,             // calculate length
                        UnicodeString->Buffer,
                        0 );

    if ( UnicodeStringLen == 0 ) {
        return STATUS_SUCCESS;
    }

    //
    // The conversion routine returns space for a null terminator, so
    // adjust for that.
    //

    UnicodeString->Length = (USHORT) (UnicodeStringLen - 1) * sizeof(WCHAR);

    if (UnicodeString->MaximumLength < UnicodeString->Length + sizeof(WCHAR)) {
        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    // Translate the string to Unicode.
    //

    UnicodeStringLen = MultiByteToWideChar(
#ifndef WIN32_CHICAGO
                        CP_UTF8,
#else // WIN32_CHICAGO
                        CP_OEMCP,
#endif // WIN32_CHICAGO
                        0,      // All characters can be mapped.
                        Utf8String,
                        -1,
                        UnicodeString->Buffer,
                        UnicodeStringLen );

    DsysAssert( UnicodeStringLen != 0 );

    UnicodeString->Buffer[UnicodeStringLen-1] = L'\0';
    UnicodeString->Length = (USHORT)((UnicodeStringLen-1) * sizeof(WCHAR));
    UnicodeString->MaximumLength = (USHORT)(UnicodeStringLen * sizeof(WCHAR));

    return STATUS_SUCCESS;
}


LPSTR
KerbAllocUtf8StrFromUnicodeString(
    IN const UNICODE_STRING * UnicodeString
    )

/*++

Routine Description:

    Convert a Unicode (zero terminated) string to the corresponding UTF8
    string.

Arguments:

    UnicodeString - Specifies the Unicode zero terminated string to convert.


Return Value:

    NULL - There was some error in the conversion.

    Otherwise, it returns a pointer to the zero terminated UTF8 string in
    an allocated buffer.  The buffer must be freed using NetApiBufferFree.

--*/

{
    LPSTR Utf8String = NULL;
    int Utf8StringLen;

    //
    // If the length is zero, return a null string.
    //

    if (UnicodeString->Length == 0)
    {
        Utf8String = (LPSTR) MIDL_user_allocate(sizeof(CHAR));
        if (Utf8String != NULL)
        {
            *Utf8String = '\0';
        }
        return(Utf8String);
    }
    //
    // Determine the length of the Unicode string.
    //

    Utf8StringLen = WideCharToMultiByte(
#ifndef WIN32_CHICAGO
                        CP_UTF8,
#else // WIN32_CHICAGO
                        CP_OEMCP,
#endif // WIN32_CHICAGO
                        0,      // All characters can be mapped.
                        UnicodeString->Buffer,
                        UnicodeString->Length / sizeof(WCHAR),
                        Utf8String,
                        0,
                        NULL,
                        NULL );

    if ( Utf8StringLen == 0 ) {

        return NULL;
    }

    //
    // Allocate a buffer for the Unicode string.
    //

    Utf8String = (LPSTR) MIDL_user_allocate( Utf8StringLen+1 );

    if ( Utf8String == NULL ) {
        return NULL;
    }

    //
    // Translate the string to Unicode.
    //

    Utf8StringLen = WideCharToMultiByte(
#ifndef WIN32_CHICAGO
                        CP_UTF8,
#else // WIN32_CHICAGO
                        CP_OEMCP,
#endif // WIN32_CHICAGO
                        0,      // All characters can be mapped.
                        UnicodeString->Buffer,
                        UnicodeString->Length / sizeof(WCHAR),
                        Utf8String,
                        Utf8StringLen,
                        NULL,
                        NULL );

    if ( Utf8StringLen == 0 ) {
        MIDL_user_free( Utf8String );
        return NULL;
    }

    Utf8String[Utf8StringLen] = '\0';

    return Utf8String;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbUnicodeStringToKerbString
//
//  Synopsis:   Converts a UNICODE_STRING to a kerberos-ansi string
//
//  Effects:    allocates destination with MIDL_user_allocate
//
//  Arguments:  KerbString - receives ansi-ized string
//              String - containes source unicode string
//
//  Requires:
//
//  Returns:    KDC_ERR_NONE or KRB_ERR_GENERIC
//
//  Notes:      This routine hides the details of whether we use UTF-8 or
//              unicode->ansi conversion
//
//
//--------------------------------------------------------------------------

KERBERR
__stdcall
KerbUnicodeStringToKerbString(
    OUT PSTRING KerbString,
    IN const UNICODE_STRING * String
    )
{
    STRING TempString;

    if (!ARGUMENT_PRESENT(KerbString))
    {
        return KRB_ERR_GENERIC;
    }

    TempString.Buffer = KerbAllocUtf8StrFromUnicodeString(String);
    if (TempString.Buffer == NULL)
    {
        return KRB_ERR_GENERIC;
    }

    RtlInitString(
        &TempString,
        TempString.Buffer
        );

    *KerbString = TempString;
    return KDC_ERR_NONE;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbStringToUnicodeString
//
//  Synopsis:   Converts a kerberos string to a unicode string
//
//  Effects:    allocates result string with MIDL_user_allocate
//
//  Arguments:  String      - resulting string
//              KerbString  - source string
//
//  Requires:
//
//  Returns:    KDC_ERR_NONE    conversion successful
//              KRB_ERR_GENERIC out of memory
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KerbStringToUnicodeString(
    OUT PUNICODE_STRING String,
    IN const STRING * KerbString
    )
{
    LPSTR TerminatedString;
    UNICODE_STRING TempString;

    if ( !ARGUMENT_PRESENT(KerbString) ||
         !ARGUMENT_PRESENT(String))
    {
        return KRB_ERR_GENERIC;
    }

    //
    // Null terminate the string
    //

    if ((KerbString->MaximumLength > KerbString->Length) &&
        (KerbString->Buffer[KerbString->Length] == '\0'))
    {
        TerminatedString = KerbString->Buffer;
    }
    else
    {
        TerminatedString = (LPSTR) MIDL_user_allocate(KerbString->Length + sizeof(CHAR));
        if (TerminatedString == NULL)
        {
            return KRB_ERR_GENERIC;
        }

        memcpy(
            TerminatedString,
            KerbString->Buffer,
            KerbString->Length
            );
        TerminatedString[KerbString->Length] = '\0';
    }

    TempString.Buffer = KerbAllocWStrFromUtf8Str(
                            TerminatedString
                            );

    if (TerminatedString != KerbString->Buffer)
    {
        MIDL_user_free(TerminatedString);
    }

    if (TempString.Buffer == NULL)
    {
        return(KRB_ERR_GENERIC);
    }

    RtlInitUnicodeString(
        &TempString,
        TempString.Buffer
        );

    *String = TempString;

    return KDC_ERR_NONE;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbComparePrincipalNames
//
//  Synopsis:   Compares two principal names for equality
//
//  Effects:
//
//  Arguments:  Name1 - the first principal name
//              Name2 - the second principal name
//
//  Requires:
//
//  Returns:    TRUE for eqaulity, FALSE for non-equality.
//
//  Notes:
//
//
//--------------------------------------------------------------------------
BOOLEAN
KerbComparePrincipalNames(
    IN const KERB_PRINCIPAL_NAME * Name1,
    IN const KERB_PRINCIPAL_NAME * Name2
    )
{
    BOOLEAN Result = TRUE;
    PKERB_PRINCIPAL_NAME_ELEM NextName1, NextName2;

    if ((Name1 == NULL) && (Name2 == NULL))
    {
        return TRUE;
    }
    else if ((Name1 == NULL) || (Name2 == NULL))
    {
        return FALSE;
    }

    //
    // If the name types are known, make sure they match.
    //

    if ((Name1->name_type != KRB_NT_UNKNOWN) &&
        (Name2->name_type != KRB_NT_UNKNOWN) &&
        (Name1->name_type != Name2->name_type))
    {
        Result = FALSE;
        goto Cleanup;
    }

    NextName1 = Name1->name_string;
    NextName2 = Name2->name_string;

    while ((NextName1 != NULL) && (NextName2 != NULL))
    {
        if (lstrcmpiA(
                NextName1->value,
                NextName2->value
                ) != 0)
        {
            Result = FALSE;
            goto Cleanup;
        }

        NextName1 = NextName1->next;
        NextName2 = NextName2->next;
    }

    //
    // if one has more names than the other, fail
    //

    if (!((NextName1 == NULL) && (NextName2 == NULL)))
    {
        Result = FALSE;
        goto Cleanup;
    }

    return TRUE;

Cleanup:

    return Result;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbCompareRealmNames
//
//  Synopsis:   Compares two realm names for equality
//
//  Effects:
//
//  Arguments:  Realm1 - First realm to compare
//              Realm2 - Second realm to compare
//
//  Requires:
//
//  Returns:    TRUE if they are equal, FALSE otherwise
//
//  Notes:
//
//
//--------------------------------------------------------------------------

BOOLEAN
KerbCompareRealmNames(
    IN const KERB_REALM * Realm1,
    IN const KERB_REALM * Realm2
    )
{
    INT len1;
    INT len2;

    if ((Realm1 == NULL) && (Realm2 == NULL))
    {
        return TRUE;
    }
    else if ((Realm1 == NULL) || (Realm2 == NULL))
    {
        return FALSE;
    }

    len1 = (INT) strlen( *Realm1 );
    len2 = (INT) strlen( *Realm2 );

    //
    // Check if any trailing '.' need to be stripped off
    //

    if ( len2 != len1 )
    {
        if ( len2 == len1+1 )
        {
            if ( (*Realm2)[len1] != '.' )
            {
                return FALSE;
            }

            //
            //  len1 is comparable length
            //
        }
        else if ( len2+1 == len1 )
        {
            if ( (*Realm1)[len2] != '.' )
            {
                return FALSE;
            }

            //
            //  len1 is set to comparable length
            //

            len1 = len2;
        }
        else
        {
            return FALSE;
        }
    }

    //
    //  compare only comparable length of string
    //

    return( !_strnicmp( *Realm1, *Realm2, len1 ) );
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbCompareUnicodeRealmNames
//
//  Synopsis:   Compares two realm names for equality
//
//  Effects:
//
//  Arguments:  Realm1 - First realm to compare
//              Realm2 - Second realm to compare
//
//  Requires:
//
//  Returns:    TRUE if they are equal, FALSE otherwise
//
//  Notes:
//
//
//--------------------------------------------------------------------------

BOOLEAN
KerbCompareUnicodeRealmNames(
    IN const UNICODE_STRING * Domain1,
    IN const UNICODE_STRING * Domain2
    )
{
    UNICODE_STRING Realm1 = {0};
    UNICODE_STRING Realm2 = {0};

    if ((Domain1 == NULL) && (Domain2 == NULL))
    {
        return TRUE;
    }
    else if ((Domain1 == NULL) || (Domain2 == NULL))
    {
        return FALSE;
    }
    else if ((Domain1->Buffer == NULL) && (Domain2->Buffer == NULL))
    {
        return TRUE;
    }
    else if ((Domain1->Buffer == NULL) || (Domain2->Buffer == NULL))
    {
        return FALSE;
    }

    Realm1 = *Domain1;
    Realm2 = *Domain2;

    //
    // Check if any trailing '.' need to be stripped off
    //

    if ( Realm2.Length != Realm1.Length )
    {
        if ( Realm2.Length == Realm1.Length+sizeof(WCHAR) )
        {
            if ( Realm2.Buffer[Realm1.Length / sizeof(WCHAR)] != '.' )
            {
                return FALSE;
            }
            else
            {
                Realm2.Length = Realm1.Length;
            }

        }
        else if ( Realm2.Length+sizeof(WCHAR) == Realm1.Length )
        {
            if ( Realm1.Buffer[Realm2.Length / sizeof(WCHAR)] != '.' )
            {
                return FALSE;
            }
            else
            {
                Realm1.Length = Realm2.Length;
            }
        }
        else
        {
            return FALSE;
        }
    }

    //
    //  compare only comparable length of string
    //

    return( RtlEqualUnicodeString( &Realm1, &Realm2, TRUE ));
}


//+-------------------------------------------------------------------------
//
//  Function:   KdcFreeKdcName
//
//  Synopsis:   Frees all parts of a KDC name structure
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbFreeKdcName(
    IN PKERB_INTERNAL_NAME *  KdcName
    )
{
    if (*KdcName != NULL)
    {
        MIDL_user_free(*KdcName);
    }

    *KdcName = NULL;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbConvertPrincipalNameToKdcName
//
//  Synopsis:   Converts a principal name to a KDC name and allocates
//              output with MIDL_user_allocate
//
//  Effects:
//
//  Arguments:  OutputName      resulting name
//              PrincipalName   original name
//
//  Requires:
//
//  Returns:    KDC_ERR_NONE    success
//              KRB_ERR_GENERIC out of memory or error in conversion
//
//  Notes:
//
//--------------------------------------------------------------------------

KERBERR
KerbConvertPrincipalNameToKdcName(
    OUT PKERB_INTERNAL_NAME * OutputName,
    IN const KERB_PRINCIPAL_NAME * PrincipalName
    )
{
    NTSTATUS Status;
    KERBERR KerbErr = KDC_ERR_NONE;
    ULONG NameCount = 0;
    ULONG Index;
    STRING Names[MAX_NAME_ELEMENTS+1];
    PKERB_PRINCIPAL_NAME_ELEM NameElement;
    PKERB_INTERNAL_NAME KdcName = NULL;
    ULONG NameSize = 0;
    USHORT NameLength = 0;
    PUCHAR Where;

    NameElement = PrincipalName->name_string;

    while (NameElement!= NULL)
    {
        RtlInitString(
            &Names[NameCount],
            NameElement->value
            );
        NameLength += (Names[NameCount].Length + 1) * sizeof(WCHAR);
        NameCount++;
        NameElement = NameElement->next;
        if (NameCount > MAX_NAME_ELEMENTS)
        {
            D_DebugLog((DEB_ERROR,"Too many name parts: %d\n",NameCount));
            return KRB_ERR_GENERIC;
        }
    }

    //
    // Now we have the count of parts, so allocate the destination structure
    //

    if (NameCount == 0)
    {
        D_DebugLog((DEB_ERROR,"Illegal name with zero parts\n"));
        return KRB_ERR_GENERIC;
    }

    NameSize = KERB_INTERNAL_NAME_SIZE(NameCount) + NameLength;
    KdcName = (PKERB_INTERNAL_NAME) MIDL_user_allocate(NameSize);
    if (KdcName == NULL)
    {
        return KRB_ERR_GENERIC;
    }

    ZeroMemory(
        KdcName,
        NameSize
        );
    KdcName->NameCount = (USHORT) NameCount;
    KdcName->NameType = (USHORT) PrincipalName->name_type;

    Where = (PUCHAR) KdcName + KERB_INTERNAL_NAME_SIZE(NameCount);

    //
    // Now convert all the strings from the temporary array into
    // UNICODE_STRINGs in the final array
    //

    for (Index = 0; Index < NameCount ; Index++ )
    {
        KdcName->Names[Index].Length = 0;
        KdcName->Names[Index].MaximumLength = NameLength;
        KdcName->Names[Index].Buffer = (LPWSTR) Where;
        Status = KerbUnicodeStringFromUtf8Str(
                    Names[Index].Buffer,
                    &KdcName->Names[Index]
                    );
        if (!NT_SUCCESS(Status))
        {
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }
        Where += KdcName->Names[Index].MaximumLength;
        NameLength = NameLength - KdcName->Names[Index].MaximumLength;
    }

    *OutputName = KdcName;
    KdcName = NULL;

Cleanup:

    if (KdcName != NULL)
    {
        KerbFreeKdcName(&KdcName);
    }

    return KerbErr;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbCovnertKdcNameToPrincipalName
//
//  Synopsis:   Converts a KDC name to a Principal name & allocates output with
//              MIDL_user_allocate
//
//  Effects:
//
//  Arguments:  PrincipalName   result of conversion
//              KdcName         original name
//
//  Requires:
//
//  Returns:    KDC_ERR_NONE    indicates success
//              KRB_ERR_GENERIC error in conversion or out of memory
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KerbConvertKdcNameToPrincipalName(
    OUT PKERB_PRINCIPAL_NAME PrincipalName,
    IN const KERB_INTERNAL_NAME * KdcName
    )
{
    PKERB_PRINCIPAL_NAME_ELEM Elem;
    PKERB_PRINCIPAL_NAME_ELEM * Last;
    STRING TempKerbString;
    KERBERR KerbErr = KDC_ERR_NONE;
    ULONG Index;

    PrincipalName->name_type = (int) KdcName->NameType;
    PrincipalName->name_string = NULL;
    Last = &PrincipalName->name_string;

    //
    // Index through the KDC name and add each element to the list
    //

    for (Index = 0; Index < KdcName->NameCount ; Index++ )
    {
        KerbErr = KerbUnicodeStringToKerbString(
                    &TempKerbString,
                    &KdcName->Names[Index]
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }
        Elem = (PKERB_PRINCIPAL_NAME_ELEM) MIDL_user_allocate(sizeof(KERB_PRINCIPAL_NAME_ELEM));
        if (Elem == NULL)
        {
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }
        Elem->value = TempKerbString.Buffer;
        Elem->next = NULL;
        *Last = Elem;
        Last = &Elem->next;
    }

Cleanup:

    if (!KERB_SUCCESS(KerbErr))
    {
        //
        // Cleanup the principal name
        //

        KerbFreePrincipalName(PrincipalName);
    }

    return KerbErr;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbEqualKdcNames
//
//  Synopsis:   Compares to KDC names for equality
//
//  Effects:
//
//  Arguments:  Name1, Name2 - names to compare
//
//  Requires:
//
//  Returns:    TRUE if the names are identical
//
//  Notes:
//
//
//--------------------------------------------------------------------------

BOOLEAN
KerbEqualKdcNames(
    IN const KERB_INTERNAL_NAME * Name1,
    IN const KERB_INTERNAL_NAME * Name2
    )
{
    BOOLEAN Equal = TRUE;
    ULONG Index;

    if ((Name1 == NULL) && (Name2 == NULL))
    {
        return TRUE;
    }
    else if ((Name1 == NULL) || (Name2 == NULL))
    {
        return FALSE;
    }
    //
    // Special case some Microsoft name types
    //

    if (Name1->NameCount != Name2->NameCount)
    {
        Equal = FALSE;
    }
    else
    {
        for (Index = 0; Index < Name1->NameCount ; Index++ )
        {
            if (!RtlEqualUnicodeString(
                    &Name1->Names[Index],
                    &Name2->Names[Index],
                    TRUE                        // case insensitive
                    ))
            {
                Equal = FALSE;
                break;
            }
        }
    }

    return Equal;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbComparePrincipalNameToKdcName
//
//  Synopsis:   Compares a princial name to a kDc name by first converting
//              and then comparing.
//
//  Effects:
//
//  Arguments:  PrincipalName   principal name to compare
//              KdcName         KDC name to compare
//              Result          result of comparison
//
//  Requires:
//
//  Returns:    KDC_ERR_NONE    comparison successful, Result has the result
//              KRB_ERR_GENERIC out of memory
//
//  Notes:
//
//--------------------------------------------------------------------------

KERBERR
KerbCompareKdcNameToPrincipalName(
    IN const KERB_PRINCIPAL_NAME * PrincipalName,
    IN const KERB_INTERNAL_NAME * KdcName,
    OUT PBOOLEAN Result
    )
{
    PKERB_INTERNAL_NAME TempName = NULL;

    if (!KERB_SUCCESS(KerbConvertPrincipalNameToKdcName(
                        &TempName,
                        PrincipalName
                        )))
    {
        return KRB_ERR_GENERIC;
    }

    *Result = KerbEqualKdcNames( TempName, KdcName );

    KerbFreeKdcName( &TempName );

    return KDC_ERR_NONE;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbDuplicateKdcName
//
//  Synopsis:   Duplicates an internal name by copying the pointer and
//              referencing the structure.
//
//  Effects:
//
//  Arguments:  Destination         used to return the duplicate
//              Source              source string
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS                  everything OK
//              STATUS_INVALID_PARAMETER        check your input
//              STATUS_INSUFFICIENT_RESOURCES   out of memory
//
//  Notes:
//
//--------------------------------------------------------------------------

NTSTATUS
__stdcall
KerbDuplicateKdcName(
    OUT PKERB_INTERNAL_NAME * Destination,
    IN const KERB_INTERNAL_NAME * Source
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    USHORT Index;
    PKERB_INTERNAL_NAME KdcName = NULL;
    ULONG NameSize = 0;
    ULONG NameLength = 0;
    PUCHAR Where;

    //
    // Now we have the count of parts, so allocate the destination structure
    //

    if (Source->NameCount == 0)
    {
        D_DebugLog((DEB_ERROR,"Illegal name with zero parts\n"));
        return STATUS_INVALID_PARAMETER;
    }

    for (Index = 0; Index < Source->NameCount ; Index++ )
    {
        NameLength += Source->Names[Index].Length + sizeof(WCHAR);
    }

    NameSize = KERB_INTERNAL_NAME_SIZE(Source->NameCount) + NameLength;
    KdcName = (PKERB_INTERNAL_NAME) MIDL_user_allocate(NameSize);
    if (KdcName == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    ZeroMemory(
        KdcName,
        NameSize
        );

    KdcName->NameCount = (USHORT) Source->NameCount;
    Where = (PUCHAR) KdcName + KERB_INTERNAL_NAME_SIZE(Source->NameCount);

    //
    // Now convert all the strings from the temporary array into
    // UNICODE_STRINGs in the final array
    //

    for (Index = 0; Index < Source->NameCount ; Index++ )
    {
        KdcName->Names[Index].Length = Source->Names[Index].Length;
        KdcName->Names[Index].MaximumLength = Source->Names[Index].Length + sizeof(WCHAR);
        KdcName->Names[Index].Buffer = (LPWSTR) Where;
        memcpy(
            Where,
            Source->Names[Index].Buffer,
            Source->Names[Index].Length
            );
        KdcName->Names[Index].Buffer[Source->Names[Index].Length / sizeof(WCHAR)] = L'\0';
        Where += KdcName->Names[Index].MaximumLength;
    }

    KdcName->NameType = Source->NameType;
    *Destination = KdcName;
    KdcName = NULL;

    if (KdcName != NULL)
    {
        KerbFreeKdcName(&KdcName);
    }

    return Status;
}


#ifdef RETAIL_LOG_SUPPORT
VOID
KerbPrintKdcNameEx(
    IN ULONG DebugLevel,
    IN ULONG InfoLevel,
    IN const KERB_INTERNAL_NAME * Name
    )
{
    ULONG Index;
    if ((InfoLevel & DebugLevel) != 0)
    {
        for (Index = 0; Index < Name->NameCount ; Index++ )
        {
            DebugLog((DebugLevel | DSYSDBG_CLEAN," %wZ ",&Name->Names[Index]));
        }
        DebugLog((DebugLevel | DSYSDBG_CLEAN, "\n"));
    }
}


VOID
KerbPrintPrincipalName(
    IN ULONG DebugLevel,
    IN const KERB_PRINCIPAL_NAME * Name
    )
{
    KERBERR KerbErr;
    PKERB_INTERNAL_NAME KdcName = NULL;

    KerbErr = KerbConvertPrincipalNameToKdcName(
                  &KdcName,
                  Name
                  );

    if (KERB_SUCCESS(KerbErr))
    {
        KerbPrintKdcNameEx(DebugLevel, DebugLevel, KdcName);
        KerbFreeKdcName(&KdcName);
    }
}


VOID
KerbPrintKerbRealm(
    IN ULONG DebugLevel,
    IN const KERB_REALM * Realm
    )
{
    KERBERR KerbErr;
    UNICODE_STRING RealmName = {0};

    KerbErr = KerbConvertRealmToUnicodeString(
                            &RealmName,
                            Realm
                            );

    if (KERB_SUCCESS(KerbErr))
    {
        DebugLog((DebugLevel, "%wZ\n", &RealmName));
        KerbFreeString(&RealmName);
    }
}

#endif

//+-------------------------------------------------------------------------
//
//  Function:   KerbConvertStringToKdcName
//
//  Synopsis:   Converts a string to a KRB_NT_MS_PRINCIPAL kdc name
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KerbConvertStringToKdcName(
    OUT PKERB_INTERNAL_NAME * PrincipalName,
    IN const UNICODE_STRING * String
    )
{
    PKERB_INTERNAL_NAME LocalName = NULL;

    LocalName = (PKERB_INTERNAL_NAME) MIDL_user_allocate(KERB_INTERNAL_NAME_SIZE(1) + String->Length + sizeof(WCHAR));
    if (LocalName == NULL)
    {
        return(KRB_ERR_GENERIC);
    }

    LocalName->NameCount = 1;
    LocalName->NameType = KRB_NT_MS_PRINCIPAL;
    LocalName->Names[0].Length = String->Length;
    LocalName->Names[0].MaximumLength = String->Length + sizeof(WCHAR);
    LocalName->Names[0].Buffer = (LPWSTR) ((PUCHAR) LocalName + KERB_INTERNAL_NAME_SIZE(1));
    memcpy(
        LocalName->Names[0].Buffer,
        String->Buffer,
        String->Length
        );
    LocalName->Names[0].Buffer[String->Length/sizeof(WCHAR)] = L'\0';

    *PrincipalName = LocalName;

    return KDC_ERR_NONE;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbConvertKdcNameToString
//
//  Synopsis:   Converts a KdcName to a '/' separated unicode string.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KerbConvertKdcNameToString(
    OUT PUNICODE_STRING String,
    IN const KERB_INTERNAL_NAME * PrincipalName,
    IN OPTIONAL const UNICODE_STRING * RealmName
    )
{
    USHORT StringLength = 0;
    ULONG Index;
    PBYTE Where;

    if (!ARGUMENT_PRESENT(PrincipalName) || !ARGUMENT_PRESENT(String))
    {
        return KRB_ERR_GENERIC;
    }

    //
    // Count up the size of the name parts
    //
    for (Index = 0; Index < PrincipalName->NameCount ; Index++ )
    {
        StringLength = StringLength + PrincipalName->Names[Index].Length;
    }

    if (ARGUMENT_PRESENT(RealmName) && (RealmName->Length != 0))
    {
        StringLength += sizeof(WCHAR) + RealmName->Length;
    }

    //
    // Add in '/' separators and a null terminator
    //

    DsysAssert(PrincipalName->NameCount > 0);
    StringLength += (USHORT) PrincipalName->NameCount * sizeof(WCHAR);

    String->Buffer = (LPWSTR) MIDL_user_allocate(StringLength);
    if (String->Buffer == NULL)
    {
        return KRB_ERR_GENERIC;
    }

    String->MaximumLength = StringLength;
    String->Length = StringLength - sizeof(WCHAR);

    Where = (PBYTE) String->Buffer;

    for (Index = 0; Index < PrincipalName->NameCount ; Index++ )
    {
        //
        // Add a '/' before every segment but the first
        //

        if (Index != 0)
        {
            *((LPWSTR)(Where)) = L'/';
            Where += sizeof(WCHAR);
        }
        memcpy(
            Where,
            PrincipalName->Names[Index].Buffer,
            PrincipalName->Names[Index].Length
            );
        Where += PrincipalName->Names[Index].Length;
    }
    if (ARGUMENT_PRESENT(RealmName) && (RealmName->Length != 0))
    {
        *((LPWSTR)(Where)) = L'@';
        Where += sizeof(WCHAR);

        memcpy(
            Where,
            RealmName->Buffer,
            RealmName->Length
            );
        Where += RealmName->Length;
    }

    *((LPWSTR)(Where)) = L'\0';
    Where += sizeof(WCHAR);
    DsysAssert(Where - (PUCHAR) String->Buffer == (LONG) StringLength);

    return KDC_ERR_NONE;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbBuildFullServiceName
//
//  Synopsis:   Combines a service name and domain name to make a full
//              service name.
//
//  Effects:
//
//  Arguments:  DomainName - Domain name of service
//              Servicename - Name of service
//              FullServiceName - Receives full service name
//
//  Requires:
//
//  Returns:    KDC_ERR_NONE or KRB_ERR_GENERIC
//
//  Notes:      This is dependent on our DS naming conventions
//
//
//--------------------------------------------------------------------------

KERBERR
KerbBuildFullServiceName(
    IN const UNICODE_STRING * DomainName,
    IN const UNICODE_STRING * ServiceName,
    OUT PUNICODE_STRING FullServiceName
    )
{
    PUCHAR Where;

    FullServiceName->Buffer = NULL;


    FullServiceName->Length = DomainName->Length +
                              ServiceName->Length +
                              sizeof(WCHAR);

    FullServiceName->MaximumLength =
        FullServiceName->Length + sizeof(WCHAR);

    FullServiceName->Buffer = (LPWSTR) MIDL_user_allocate(
                                            FullServiceName->MaximumLength
                                            );
    if (FullServiceName->Buffer == NULL)
    {
        return KRB_ERR_GENERIC;
    }

    Where = (PUCHAR) FullServiceName->Buffer;

    memcpy(
        FullServiceName->Buffer,
        DomainName->Buffer,
        DomainName->Length
        );
    Where += DomainName->Length;

    if ((DomainName->Length !=0) && (ServiceName->Length != 0))
    {
        *(LPWSTR) Where = L'\\';
        Where += sizeof(WCHAR);
    }

    memcpy(
        Where,
        ServiceName->Buffer,
        ServiceName->Length
        );

    Where += ServiceName->Length;
    FullServiceName->Length = (USHORT)(Where - (PUCHAR) FullServiceName->Buffer);
    *(LPWSTR) Where = L'\0';

    return KDC_ERR_NONE;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbBuildEmailName
//
//  Synopsis:   Combines a service name and domain name to make an email
//              name = "service@domain".
//
//
//  Effects:
//
//  Arguments:  DomainName - Domain name of service
//              Servicename - Name of service
//              FullServiceName - Receives full service name
//
//  Requires:
//
//  Returns:    KDC_ERR_NONE or KRB_ERR_GENERIC
//
//  Notes:      This is dependent on our DS naming conventions
//
//
//--------------------------------------------------------------------------

KERBERR
KerbBuildEmailName(
    IN const UNICODE_STRING * DomainName,
    IN const UNICODE_STRING * ServiceName,
    OUT PUNICODE_STRING EmailName
    )
{
    PUCHAR Where;

    EmailName->Buffer = NULL;

    EmailName->Length = DomainName->Length +
                              ServiceName->Length +
                              sizeof(WCHAR);

    EmailName->MaximumLength =
        EmailName->Length + sizeof(WCHAR);

    EmailName->Buffer = (LPWSTR) MIDL_user_allocate(
                                            EmailName->MaximumLength
                                            );
    if (EmailName->Buffer == NULL)
    {
        return KRB_ERR_GENERIC;
    }

    Where = (PUCHAR) EmailName->Buffer;

    memcpy(
        EmailName->Buffer,
        ServiceName->Buffer,
        ServiceName->Length
        );
    Where += ServiceName->Length;

    *(LPWSTR) Where = L'@';
    Where += sizeof(WCHAR);

    memcpy(
        Where,
        DomainName->Buffer,
        DomainName->Length
        );

    Where += DomainName->Length;
    EmailName->Length = (USHORT)(Where - (PUCHAR) EmailName->Buffer);
    *(LPWSTR) Where = L'\0';

    return KDC_ERR_NONE;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbBuildUnicodeSpn
//
//  Synopsis:   Builds a 2 part SPN
//
//  Effects:
//
//  Arguments:  DomainName - Domain name of service
//              ServiceName - Name of service
//              Spn - Receives full service name
//
//  Requires:
//
//  Returns:    KDC_ERR_NONE or KRB_ERR_GENERIC
//
//  Notes:      This is dependent on our DS naming conventions
//
//
//--------------------------------------------------------------------------

KERBERR
KerbBuildUnicodeSpn(
    IN const UNICODE_STRING * DomainName,
    IN const UNICODE_STRING * ServiceName,
    OUT PUNICODE_STRING UnicodeSpn
    )
{
    PWSTR Spn, tmp;
    ULONG BuffSize;

    BuffSize = DomainName->MaximumLength +
                ServiceName->MaximumLength +
                (sizeof(WCHAR) * 2);

    Spn = (PWSTR) MIDL_user_allocate(BuffSize);
    if (NULL == Spn)
    {
        return KRB_ERR_GENERIC;
    }

    tmp = Spn;

    memcpy(
        Spn,
        ServiceName->Buffer,
        ServiceName->Length
        );

    tmp += (ServiceName->Length / sizeof(WCHAR));
    *tmp = L'/';

    memcpy(
        ++tmp,
        DomainName->Buffer,
        DomainName->Length
        );

    tmp += (DomainName->Length / sizeof(WCHAR));
    *tmp = L'\0';

    RtlInitUnicodeString(
        UnicodeSpn,
        Spn
        );

    return KDC_ERR_NONE;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbBuildFullServiceKdcName
//
//  Synopsis:   Combines a service name and domain name to make a full
//              service name. If the name type is MS_PRINCIPAL they are
//              combined into one portion of the name, otherise left in
//              two portions
//
//  Effects:
//
//  Arguments:  DomainName - Domain name of service
//              ServiceName - Name of service
//              NameType - Type of name to produce
//              FullServiceName - Receives full service name
//
//  Requires:
//
//  Returns:    KDC_ERR_NONE or KRB_ERR_GENERIC
//
//  Notes:      This is dependent on our DS naming conventions
//
//
//--------------------------------------------------------------------------

KERBERR
KerbBuildFullServiceKdcName(
    IN const UNICODE_STRING * DomainName,
    IN const UNICODE_STRING * ServiceName,
    IN ULONG NameType,
    OUT PKERB_INTERNAL_NAME * FullServiceName
    )
{
    return( KerbBuildFullServiceKdcNameWithSid(
                 DomainName,
                 ServiceName,
                 NULL,
                 NameType,
                 FullServiceName
                 ));
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbBuildKpasswdName
//
//  Synopsis:   Builds the name of the kpasswd service
//
//  Effects:
//
//  Arguments:  KpasswdName     used to return the result
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS
//              STATUS_INSUFFICIENT_RESOURCES
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbBuildKpasswdName(
    OUT PKERB_INTERNAL_NAME * KpasswdName
    )
{
    UNICODE_STRING KpasswdServiceNames[2];

    //
    // Build the service name for the ticket
    //

    RtlInitUnicodeString(
        &KpasswdServiceNames[0],
        KERB_KPASSWD_FIRST_NAME
        );

    RtlInitUnicodeString(
        &KpasswdServiceNames[1],
        KERB_KPASSWD_SECOND_NAME
        );

    if (!KERB_SUCCESS(KerbBuildFullServiceKdcName(
                        &KpasswdServiceNames[1],
                        &KpasswdServiceNames[0],
                        KRB_NT_SRV_INST,
                        KpasswdName
                        )))
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    return STATUS_SUCCESS;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbBuildFullServiceKdcNameWithSid
//
//  Synopsis:   Combines a service name and domain name to make a full
//              service name. If the name type is MS_PRINCIPAL they are
//              combined into one portion of the name, otherise left in
//              two portions. If a sid is presenet, it is tacked on as
//              the last segment of the name
//
//  Effects:
//
//  Arguments:  DomainName - Domain name of service
//              ServiceName - Name of service
//              Sid - Optionally contains the sid to use
//              NameType - Type of name to produce
//              FullServiceName - Receives full service name
//
//  Requires:
//
//  Returns:    KDC_ERR_NONE or KRB_ERR_GENERIC
//
//  Notes:      This is dependent on our DS naming conventions
//
//
//--------------------------------------------------------------------------

KERBERR
KerbBuildFullServiceKdcNameWithSid(
    IN const UNICODE_STRING * DomainName,
    IN const UNICODE_STRING * ServiceName,
    IN OPTIONAL PSID Sid,
    IN ULONG NameType,
    OUT PKERB_INTERNAL_NAME * FullServiceName
    )
{
    PKERB_INTERNAL_NAME FinalName = NULL;
    PUCHAR Where;
    ULONG NameParts;
    ULONG NameLength = 0;
    WCHAR SidBuffer[256];
    UNICODE_STRING SidString;

    SidString.Length = 0;
    SidString.MaximumLength = sizeof(SidBuffer);
    SidString.Buffer = SidBuffer;

    if ((NameType == KRB_NT_MS_PRINCIPAL) ||
        (NameType == KRB_NT_MS_PRINCIPAL_AND_ID))

    {
        NameParts = 1;
        NameLength = DomainName->Length + ServiceName->Length + 2*sizeof(WCHAR);
    }
    else if ((NameType == KRB_NT_PRINCIPAL) ||
            (NameType == KRB_NT_PRINCIPAL_AND_ID) ||
            (NameType == KRB_NT_ENTERPRISE_PRINCIPAL) ||
            (NameType == KRB_NT_ENT_PRINCIPAL_AND_ID))
    {
        NameParts = 1;
        NameLength = ServiceName->Length + sizeof(WCHAR);
    }
    else
    {
        NameParts = 2;
        NameLength = DomainName->Length + ServiceName->Length + 2*sizeof(WCHAR);
    }

    //
    // If a SID is present, add another name part
    //

    if (ARGUMENT_PRESENT(Sid))
    {
        NTSTATUS Status;
        Status = KerbConvertSidToString(
                    Sid,
                    &SidString,
                    FALSE               // don't allocate
                    );
        if (!NT_SUCCESS(Status))
        {
            return KRB_ERR_GENERIC;
        }
        NameParts++;
        NameLength += SidString.Length + sizeof(WCHAR);
    }

    *FullServiceName = NULL;

    FinalName = (PKERB_INTERNAL_NAME) MIDL_user_allocate(KERB_INTERNAL_NAME_SIZE(NameParts) + NameLength);
    if (FinalName == NULL)
    {
        //
        // BUGBUG: not freeing SidString
        //
        return KRB_ERR_GENERIC;
    }

    ZeroMemory(
        FinalName,
        KERB_INTERNAL_NAME_SIZE(NameParts) + NameLength
        );

    Where = (PUCHAR) FinalName + KERB_INTERNAL_NAME_SIZE(NameParts);
    FinalName->NameType = (USHORT) NameType;
    FinalName->NameCount = (USHORT) NameParts;

    if ((NameType == KRB_NT_MS_PRINCIPAL) ||
        (NameType == KRB_NT_MS_PRINCIPAL_AND_ID))
    {
        //
        // If the domain name does not have an initial '\', reserve space for one
        //

        FinalName->Names[0].Buffer = (LPWSTR) Where;

        // This is dependent on our naming conventions.
        //
        // The full service name is the '\' domain name ':' service name.
        //

        FinalName->Names[0].Length = DomainName->Length +
                                  ServiceName->Length +
                                  sizeof(WCHAR);

        FinalName->Names[0].MaximumLength =
            FinalName->Names[0].Length + sizeof(WCHAR);


        memcpy(
            FinalName->Names[0].Buffer,
            DomainName->Buffer,
            DomainName->Length
            );
        Where += DomainName->Length;

        if ((DomainName->Length !=0) && (ServiceName->Length != 0))
        {
            *(LPWSTR) Where = L'\\';
            Where += sizeof(WCHAR);
        }

        memcpy(
            Where,
            ServiceName->Buffer,
            ServiceName->Length
            );

        Where += ServiceName->Length;
        FinalName->Names[0].Length = (USHORT)(Where - (PUCHAR) FinalName->Names[0].Buffer);
        *(LPWSTR) Where = L'\0';
    }
    else if ((NameType == KRB_NT_PRINCIPAL) ||
             (NameType == KRB_NT_PRINCIPAL_AND_ID) ||
             (NameType == KRB_NT_ENTERPRISE_PRINCIPAL)||
             (NameType == KRB_NT_ENT_PRINCIPAL_AND_ID))
    {
        //
        // Principals have no domain name
        //

        FinalName->Names[0].Length = ServiceName->Length;
        FinalName->Names[0].MaximumLength = ServiceName->Length + sizeof(WCHAR);
        FinalName->Names[0].Buffer = (LPWSTR) Where;

        memcpy(
            Where,
            ServiceName->Buffer,
            ServiceName->Length
            );
        Where += ServiceName->Length;
        *((LPWSTR) Where) = L'\0';
    }
    else
    {
        FinalName->Names[0].Length = ServiceName->Length;
        FinalName->Names[0].MaximumLength = ServiceName->Length + sizeof(WCHAR);
        FinalName->Names[0].Buffer = (LPWSTR) Where;

        memcpy(
            Where,
            ServiceName->Buffer,
            ServiceName->Length
            );
        Where += ServiceName->Length;
        *((LPWSTR) Where) = L'\0';
        Where += sizeof(WCHAR);

        FinalName->Names[1].Length = DomainName->Length;
        FinalName->Names[1].MaximumLength = DomainName->Length + sizeof(WCHAR);
        FinalName->Names[1].Buffer = (LPWSTR) Where;

        memcpy(
            Where,
            DomainName->Buffer,
            DomainName->Length
            );
        Where += DomainName->Length;
        *((LPWSTR) Where) = L'\0';
        Where += sizeof(WCHAR);
    }

    //
    // Append the string, if present
    //

    if (ARGUMENT_PRESENT(Sid))
    {
        FinalName->Names[NameParts-1].Length = SidString.Length;
        FinalName->Names[NameParts-1].MaximumLength = SidString.Length + sizeof(WCHAR);
        FinalName->Names[NameParts-1].Buffer = (LPWSTR) Where;

        memcpy(
            Where,
            SidString.Buffer,
            SidString.Length
            );
        Where += SidString.Length;
        *((LPWSTR) Where) = L'\0';
    }

    *FullServiceName = FinalName;

    return KDC_ERR_NONE;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbExtractSidFromKdcName
//
//  Synopsis:   Extracts the sid portion from a KDC name with a sid. This
//              routine also decrements the name count so that future
//              users of the name don't see the sid.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KerbExtractSidFromKdcName(
    IN OUT PKERB_INTERNAL_NAME Name,
    OUT PSID * Sid
    )
{
    NTSTATUS Status;

    //
    // If no sid was present, return succes
    //

    //
    // The sid is in the last portion of the name.
    //

    Status = KerbConvertStringToSid(
                &Name->Names[Name->NameCount-1],
                Sid
                );
    if (NT_SUCCESS(Status))
    {
        Name->NameCount--;
    }
    else
    {
        //
        // If the name wasn't a sid, return success. If it was another
        // problem, return an error
        //

        if (Status != STATUS_INVALID_PARAMETER)
        {
            return KRB_ERR_GENERIC;
        }
    }

    return KDC_ERR_NONE;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbDuplicateStringEx
//
//  Synopsis:   Duplicates a UNICODE_STRING. If the source string buffer is
//              NULL the destionation will be too.  The EX function doesn't
//              automatically NULL terminate your buffer...
//
//  Effects:    allocates memory with LsaFunctions.AllocateLsaHeap
//
//  Arguments:  DestinationString - Receives a copy of the source string
//              SourceString - String to copy
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS - the copy succeeded
//              STATUS_INSUFFICIENT_RESOURCES - the call to allocate
//                  memory failed.
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbDuplicateStringEx(
    OUT PUNICODE_STRING DestinationString,
    IN OPTIONAL const UNICODE_STRING * SourceString,
    IN BOOLEAN NullTerminate
    )
{
    USHORT NullChar = (NullTerminate ? (USHORT) sizeof(WCHAR) : (USHORT) 0);

    if ((SourceString == NULL) || (SourceString->Buffer == NULL))
    {
        DestinationString->Buffer = NULL;
        DestinationString->Length = DestinationString->MaximumLength = 0;
        return STATUS_SUCCESS;
    }

    DestinationString->Buffer = (LPWSTR) MIDL_user_allocate(SourceString->Length + NullChar);
    if (DestinationString->Buffer == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    DestinationString->Length = SourceString->Length;
    DestinationString->MaximumLength = SourceString->Length + NullChar;
    memcpy(
        DestinationString->Buffer,
        SourceString->Buffer,
        SourceString->Length
        );

    if (NullTerminate)
    {
        DestinationString->Buffer[SourceString->Length/sizeof(WCHAR)] = L'\0';
    }

    return STATUS_SUCCESS;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbDuplicateString
//
//  Synopsis:   Duplicates a UNICODE_STRING. If the source string buffer is
//              NULL the destionation will be too.
//
//  Effects:    allocates memory with LsaFunctions.AllocateLsaHeap
//
//  Arguments:  DestinationString - Receives a copy of the source string
//              SourceString - String to copy
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS - the copy succeeded
//              STATUS_INSUFFICIENT_RESOURCES - the call to allocate
//                  memory failed.
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbDuplicateString(
    OUT PUNICODE_STRING DestinationString,
    IN OPTIONAL const UNICODE_STRING * SourceString
    )
{
    return(KerbDuplicateStringEx(
                DestinationString,
                SourceString,
                TRUE
                ));
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbBuildNullTerminatedString
//
//  Synopsis:   Converts a UNICODE_STRING to a NULL-termianted string
//
//  Effects:    allocates return with MIDL_user_allocate
//
//  Arguments:  String - string to null terminate.
//
//  Requires:
//
//  Returns:    NULL on error, a pointer on success
//
//  Notes:      an input string with a NULL buffer pointe results in a
//              return string consisting of just "\0"
//
//
//--------------------------------------------------------------------------

LPWSTR
KerbBuildNullTerminatedString(
    IN const UNICODE_STRING * String
    )
{
    LPWSTR ReturnString;

    ReturnString = (LPWSTR) MIDL_user_allocate(String->Length + sizeof(WCHAR));
    if (ReturnString == NULL)
    {
        return(NULL);
    }
    if (String->Buffer != NULL)
    {
        memcpy(
            ReturnString,
            String->Buffer,
            String->Length
            );
    }

    ReturnString[String->Length/sizeof(WCHAR)] = L'\0';

    return ReturnString;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbFreeString
//
//  Synopsis:   Frees a string allocated by KerbDuplicateString
//
//  Effects:
//
//  Arguments:  String - Optionally points to a UNICODE_STRING
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
__stdcall
KerbFreeString(
    IN OPTIONAL PUNICODE_STRING String
    )
{
    if (ARGUMENT_PRESENT(String) && String->Buffer != NULL)
    {
        MIDL_user_free(String->Buffer);
        String->Buffer = NULL;
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbFreeRealm
//
//  Synopsis:   Frees a realm allcoated with KerbConvertXXXToRealm
//
//  Effects:    null out the realm.
//
//  Arguments:  Realm - Realm to free
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbFreeRealm(
    IN PKERB_REALM Realm
    )
{
    if (*Realm != NULL)
    {
        MIDL_user_free(*Realm);
        *Realm = NULL;
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbCompareUnicodeRealmToKerbRealm
//
//  Synopsis:   Compares a kerb_realm to a unicode kerb realm
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KerbCompareUnicodeRealmToKerbRealm(
    IN const KERB_REALM * KerbRealm,
    IN const UNICODE_STRING * UnicodeRealm,
    OUT PBOOLEAN Result
    )
{
    KERB_REALM TempName = NULL;

    if (!KERB_SUCCESS(KerbConvertUnicodeStringToRealm(
                        &TempName,
                        UnicodeRealm
                        )))
    {
        return KRB_ERR_GENERIC;
    }

    *Result = KerbCompareRealmNames(&TempName, KerbRealm);

    KerbFreeRealm( &TempName );

    return KDC_ERR_NONE;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbFreePrincipalName
//
//  Synopsis:   Frees a principal name allocated with KerbConvertxxxToPrincipalName
//
//  Effects:    zeros out principal name so it won't be freed again
//
//  Arguments:  Name - The name to free
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbFreePrincipalName(
    IN PKERB_PRINCIPAL_NAME Name
    )
{
    PKERB_PRINCIPAL_NAME_ELEM Elem,NextElem;

    Elem = Name->name_string;
    while (Elem != NULL)
    {
        if (Elem->value != NULL)
        {
            MIDL_user_free(Elem->value);
        }
        NextElem = Elem->next;
        MIDL_user_free(Elem);
        Elem = NextElem;
    }
    Name->name_string = NULL;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbConvertUnicodeStringToRealm
//
//  Synopsis:   Converts a unicode-string form of a domain name to a
//              KERB_REALM structure.
//
//  Effects:
//
//  Arguments:  Realm - the realm
//              String - The string to convert
//
//  Requires:
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KerbConvertUnicodeStringToRealm(
    OUT PKERB_REALM Realm,
    IN const UNICODE_STRING * String
    )
{
    KERBERR Status;
    STRING TempString;

    RtlInitString(
        &TempString,
        NULL
        );

    *Realm = NULL;
    Status = KerbUnicodeStringToKerbString(
                &TempString,
                String
                );

    if (!KERB_SUCCESS(Status))
    {
        return Status;
    }

    *Realm = TempString.Buffer;

    return KDC_ERR_NONE;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbConvertRealmToUnicodeString
//
//  Synopsis:   Converts a KERB_REALM structure to a unicode-string form
//              of a domain name.
//
//  Effects:
//
//  Arguments:  String - the unicode realm name
//              Realm - the realm to convert
//
//  Requires:
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KerbConvertRealmToUnicodeString(
    OUT PUNICODE_STRING String,
    IN const KERB_REALM * Realm
    )
{
    KERBERR Status;
    STRING TempString;

    RtlInitString(
        &TempString,
        *Realm
        );

    Status = KerbStringToUnicodeString(
                String,
                &TempString
                );

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbDuplicateRealm
//
//  Synopsis:   Duplicates a realm name
//
//  Effects:
//
//  Arguments:  Realm - the realm
//              SourceRealm - The realm to duplicate
//
//  Requires:
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KerbDuplicateRealm(
    OUT PKERB_REALM Realm,
    IN KERB_REALM SourceRealm
    )
{
    ULONG RealmLength;

    if (ARGUMENT_PRESENT(SourceRealm))
    {
        RealmLength = lstrlenA(SourceRealm);
        *Realm = (PCHAR) MIDL_user_allocate(RealmLength + sizeof(CHAR));
        if (*Realm == NULL)
        {
            return KRB_ERR_GENERIC;
        }
        memcpy(
            *Realm,
            SourceRealm,
            RealmLength + sizeof(CHAR)
            );
    }
    else
    {
        *Realm = NULL;
    }

    return KDC_ERR_NONE;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbCompareStringToPrincipalName
//
//  Synopsis:   Compares a unicode string name to a principal name for
//              equality
//
//  Effects:
//
//  Arguments:  PrincipalName - kerberos principal name
//              String - String name
//
//  Requires:
//
//  Returns:    TRUE if one of the principal names matches the string name
//
//  Notes:
//
//
//--------------------------------------------------------------------------

BOOLEAN
KerbCompareStringToPrincipalName(
    IN const KERB_PRINCIPAL_NAME * PrincipalName,
    IN const UNICODE_STRING * String
    )
{
    KERBERR Status;
    BOOLEAN FoundMatch = FALSE;
    UNICODE_STRING TempString;
    ULONG NameType;

    RtlInitUnicodeString(
        &TempString,
        NULL
        );

    Status = KerbConvertPrincipalNameToString(
                &TempString,
                &NameType,
                PrincipalName
                );

    if (!KERB_SUCCESS(Status))
    {
        //
        // BUGBUG: out of memory is not the same thing as "not equal"
        //

        return FALSE;
    }

    if (RtlEqualUnicodeString(
            &TempString,
            String,
            TRUE                        // case insensitive
            ))
    {
        FoundMatch = TRUE;
    }

    KerbFreeString(&TempString);

    return FoundMatch;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbConvertStringToPrincipalName
//
//  Synopsis:   converts a string to a principal name
//
//  Effects:    allocate memory
//
//  Arguments:  PrincipalName - receives the principal name
//              String - the string name to convert
//
//  Requires:
//
//  Returns:    KDC_ERR_NONE or STATUS_INSUFFICIENT_MEMORY
//
//  Notes:      principalname->name_value must be freed with MIDL_user_free and
//                  principalname->name_value->value must be freed with
//                  MIDL_user_Free.
//
//
//--------------------------------------------------------------------------

KERBERR
KerbConvertStringToPrincipalName(
    OUT PKERB_PRINCIPAL_NAME PrincipalName,
    IN const UNICODE_STRING * String,
    IN ULONG NameType
    )
{
    PKERB_PRINCIPAL_NAME_ELEM Elem;
    STRING TempKerbString;
    KERBERR Status = KDC_ERR_NONE;
    UNICODE_STRING TempElemString;
    UNICODE_STRING TempString;
    ULONG Index;

    ZeroMemory(
        PrincipalName,
        sizeof(KERB_PRINCIPAL_NAME)
        );

    PrincipalName->name_type = (int) NameType;

    //
    // MS principals are stuck all in one string
    //

    if (NameType == KRB_NT_MS_PRINCIPAL)
    {
        Status = KerbUnicodeStringToKerbString(
                    &TempKerbString,
                    String
                    );

        if (!KERB_SUCCESS(Status))
        {
            goto Cleanup;
        }

        Elem = (PKERB_PRINCIPAL_NAME_ELEM) MIDL_user_allocate(sizeof(KERB_PRINCIPAL_NAME_ELEM));
        if (Elem == NULL)
        {
            MIDL_user_free(TempKerbString.Buffer);
            Status = KRB_ERR_GENERIC;
            goto Cleanup;
        }

        Elem->value = TempKerbString.Buffer;
        Elem->next = PrincipalName->name_string;
        PrincipalName->name_string = Elem;

        Status = KDC_ERR_NONE;
        goto Cleanup;
    }
    else
    {
        //
        // Go through the string. If we hit  a '\\' separator, split
        // the name there into another component.
        //

        TempString = *String;
        Index = 0;

        while (Index <= TempString.Length / sizeof(WCHAR))
        {
            if ((Index == TempString.Length/sizeof(WCHAR)) ||
                (TempString.Buffer[Index] == L'\\') )
            {
                //
                // Build the element string
                //

                TempElemString.Buffer = TempString.Buffer;
                TempElemString.MaximumLength = (USHORT) Index * sizeof(WCHAR);
                TempElemString.Length = TempElemString.MaximumLength;

                Status = KerbUnicodeStringToKerbString(
                            &TempKerbString,
                            &TempElemString
                            );

                if (!KERB_SUCCESS(Status))
                {
                    goto Cleanup;
                }
                Elem = (PKERB_PRINCIPAL_NAME_ELEM) MIDL_user_allocate(sizeof(KERB_PRINCIPAL_NAME_ELEM));
                if (Elem == NULL)
                {
                    MIDL_user_free(TempKerbString.Buffer);
                    Status = KRB_ERR_GENERIC;
                    goto Cleanup;
                }
                Elem->value = TempKerbString.Buffer;
                Elem->next = PrincipalName->name_string;
                PrincipalName->name_string = Elem;

                //
                // Reset the string to be the remains of the name
                //

                if (Index != TempString.Length / sizeof(WCHAR))
                {
                    TempString.Buffer = TempString.Buffer + Index + 1;
                    TempString.Length -= (USHORT) (Index+1) * sizeof(WCHAR);
                    TempString.MaximumLength -= (USHORT) (Index+1) * sizeof(WCHAR);
                    Index = 0;
                }
                else
                {
                    break;
                }
            }
            else
            {
                Index++;
            }
        }
    }

Cleanup:

    if (!KERB_SUCCESS(Status))
    {
        KerbFreePrincipalName(PrincipalName);
    }

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbDuplicatePrincipalName
//
//  Synopsis:   Duplicates  a principal name
//
//  Effects:    allocate memory
//
//  Arguments:  PrincipalName - receives the principal name
//              SourcePrincipalName - the name to copy
//
//  Requires:
//
//  Returns:    KDC_ERR_NONE or STATUS_INSUFFICIENT_MEMORY
//
//  Notes:      principalname->name_value must be freed with MIDL_user_free and
//                  principalname->name_value->value must be freed with
//                  MIDL_user_Free.
//
//
//--------------------------------------------------------------------------

KERBERR
KerbDuplicatePrincipalName(
    OUT PKERB_PRINCIPAL_NAME PrincipalName,
    IN const KERB_PRINCIPAL_NAME * SourcePrincipalName
    )
{
    KERBERR Status = KDC_ERR_NONE;
    ULONG NameLen;
    PKERB_PRINCIPAL_NAME_ELEM SourceElem;
    PKERB_PRINCIPAL_NAME_ELEM DestElem;
    PKERB_PRINCIPAL_NAME_ELEM * NextElem;

    ZeroMemory(
        PrincipalName,
        sizeof(KERB_PRINCIPAL_NAME)
        );

    //
    // Fill in correct name type
    //

    PrincipalName->name_type = SourcePrincipalName->name_type;
    SourceElem = SourcePrincipalName->name_string;
    NextElem = &PrincipalName->name_string;

    *NextElem = NULL;
    while (SourceElem != NULL)
    {
        DestElem = (PKERB_PRINCIPAL_NAME_ELEM) MIDL_user_allocate(sizeof(KERB_PRINCIPAL_NAME_ELEM));
        if (DestElem == NULL)
        {
            Status = KRB_ERR_GENERIC;
            goto Cleanup;
        }
        NameLen = lstrlenA(SourceElem->value);

        DestElem->value = (PCHAR) MIDL_user_allocate(NameLen + sizeof(CHAR));
        if (DestElem->value == NULL)
        {
            MIDL_user_free(DestElem);
            Status = KRB_ERR_GENERIC;
            goto Cleanup;
        }
        memcpy(
            DestElem->value,
            SourceElem->value,
            NameLen + sizeof(CHAR)
        );
        DestElem->next = NULL;
        *NextElem = DestElem;
        NextElem = &DestElem->next;
        SourceElem = SourceElem->next;
    }

Cleanup:

    if (!KERB_SUCCESS(Status))
    {
        KerbFreePrincipalName(PrincipalName);
    }

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbConvertPrincipalNameToString
//
//  Synopsis:   Converts a KERB_PRINCIPAL_NAME to a unicode string
//
//  Effects:
//
//  Arguments:  String          receives the resulting string
//              NameType        receives the name type
//              PrincipalName   name to convert
//
//  Requires:
//
//  Returns:    KDC_ERR_NONE        success
//              KRB_ERR_GENERIC     out of memory
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KerbConvertPrincipalNameToString(
    OUT PUNICODE_STRING String,
    OUT PULONG NameType,
    IN const KERB_PRINCIPAL_NAME * PrincipalName
    )
{
    KERBERR KerbErr;
    STRING TempAnsiString;
    ULONG StringLength = 0;
    ULONG NameParts = 0;
    ULONG Index;
    PCHAR Where;
    PKERB_PRINCIPAL_NAME_ELEM NameElements[MAX_NAME_ELEMENTS+1];

    *NameType = (ULONG) PrincipalName->name_type;
    NameElements[NameParts] = PrincipalName->name_string;

    while (NameElements[NameParts] != NULL)
    {
        //
        // add in a separator plus the length of the element
        //

        StringLength += lstrlenA(NameElements[NameParts]->value) + 1;
        NameElements[NameParts+1] = NameElements[NameParts]->next;
        NameParts++;
        if (NameParts >= MAX_NAME_ELEMENTS)
        {
            D_DebugLog((DEB_ERROR,"Too many name parts: %d\n",NameParts));
            return KRB_ERR_GENERIC;
        }
    }

    //
    // Make sure there is at least one name part
    //

    if (NameParts == 0)
    {
        return KRB_ERR_GENERIC;
    }

    //
    // Now build the name, backwards to front, with '\\' separators
    //

    TempAnsiString.Length = (USHORT) StringLength - sizeof(CHAR);
    TempAnsiString.MaximumLength = (USHORT) StringLength;
    TempAnsiString.Buffer = (LPSTR) MIDL_user_allocate(StringLength);
    if (TempAnsiString.Buffer == NULL)
    {
        return KRB_ERR_GENERIC;
    }

    Where = TempAnsiString.Buffer;
    for (Index = 0; Index < NameParts; Index++ )
    {
        ULONG NameLength = lstrlenA(NameElements[Index]->value);
        memcpy(
            Where,
            NameElements[Index]->value,
            NameLength
            );

        Where += NameLength;

        //
        // Add either a separating '\' or a trailing '\0'
        //

        if (Index != NameParts - 1)
        {
            *Where = '/';
        }
        else
        {
            *Where = '\0';
        }
        Where++;
    }

    DsysAssert(Where - TempAnsiString.Buffer == TempAnsiString.MaximumLength);

    KerbErr = KerbStringToUnicodeString(
                String,
                &TempAnsiString
                );
    MIDL_user_free(TempAnsiString.Buffer);

    return KerbErr;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbConvertPrincipalNameToFullServiceString
//
//  Synopsis:   Converts a KERB_PRINCIPAL_NAME to a unicode string with
//              a realm name
//
//  Effects:
//
//  Arguments:  String          receives the resulting string
//              PrincipalName   name to convert
//              RealmName       realm to convert
//
//  Requires:
//
//  Returns:    KDC_ERR_NONE        success
//              KRB_ERR_GENERIC     out of memory
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KerbConvertPrincipalNameToFullServiceString(
    OUT PUNICODE_STRING String,
    IN const KERB_PRINCIPAL_NAME * PrincipalName,
    IN KERB_REALM RealmName
    )
{
    KERBERR KerbErr;
    STRING TempAnsiString;
    ULONG StringLength = 0;
    ULONG NameParts = 0;
    ULONG NameLength;
    ULONG Index;
    PCHAR Where;
    PKERB_PRINCIPAL_NAME_ELEM NameElements[MAX_NAME_ELEMENTS+1];

    NameElements[NameParts] = PrincipalName->name_string;
    while (NameElements[NameParts] != NULL)
    {
        //
        // add in a separator plus the length of the element
        //

        StringLength += lstrlenA(NameElements[NameParts]->value) + 1;
        NameElements[NameParts+1] = NameElements[NameParts]->next;
        NameParts++;
        if (NameParts >= MAX_NAME_ELEMENTS)
        {
            D_DebugLog((DEB_ERROR,"Too many name parts: %d\n",NameParts));
            return(KRB_ERR_GENERIC);
        }
    }

    //
    // Make sure there is at least one name part
    //

    if (NameParts == 0)
    {
        return KRB_ERR_GENERIC;
    }

    //
    // Add in space for the "@" and the realm
    //

    StringLength += lstrlenA(RealmName) + 1;

    //
    // Now build the name, backwards to front, with '\\' separators
    //

    TempAnsiString.Length = (USHORT) StringLength - sizeof(CHAR);
    TempAnsiString.MaximumLength = (USHORT) StringLength;
    TempAnsiString.Buffer = (LPSTR) MIDL_user_allocate(StringLength);
    if (TempAnsiString.Buffer == NULL)
    {
        return KRB_ERR_GENERIC;
    }

    Where = TempAnsiString.Buffer;
    for (Index = 0; Index < NameParts; Index++ )
    {
        NameLength = lstrlenA(NameElements[Index]->value);
        memcpy(
            Where,
            NameElements[Index]->value,
            NameLength
            );

        Where += NameLength;

        //
        // Add either a separating '\' or a trailing '\0'
        //

        if (Index != NameParts - 1)
        {
            *Where = '/';
        }
        else
        {
            *Where = '@';
        }
        Where++;
    }

    NameLength = lstrlenA(RealmName);
    memcpy(
        Where,
        RealmName,
        NameLength
        );

    Where += NameLength;

    //
    // Add either a trailing '\0'
    //

    *Where = '\0';
    Where++;

    DsysAssert(Where - TempAnsiString.Buffer == TempAnsiString.MaximumLength);

    KerbErr = KerbStringToUnicodeString(
                String,
                &TempAnsiString
                );
    MIDL_user_free(TempAnsiString.Buffer);

    return KerbErr;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbBuildKeySalt
//
//  Synopsis:   Combines a service name and domain name to make a key salt.
//              For machine account it is DOMAINNAMEhostmachinenamedomainname
//              For users it is DOMAINNAMEusername
//              For trusted domains it is DOMAINNAMEkrbtgtservicename
//
//  Effects:
//
//  Arguments:  DomainName - Domain name of service
//              Servicename - Name of service
//              AccountType - Type of account, which changes the salt
//              KeySalt - Receives the key salt
//
//  Requires:
//
//  Returns:    KDC_ERR_NONE or KRB_ERR_GENERIC
//
//  Notes:      This is dependent on our DS naming conventions
//
//
//--------------------------------------------------------------------------

KERBERR
__stdcall
KerbBuildKeySalt(
    IN const UNICODE_STRING * DomainName,
    IN const UNICODE_STRING * ServiceName,
    IN KERB_ACCOUNT_TYPE AccountType,
    OUT PUNICODE_STRING KeySalt
    )
{
    PUCHAR Where;
    USHORT FinalLength;
    USHORT DeadSpace = 0;
    ULONG Index;

    KeySalt->Buffer = NULL;

    //
    // If there is no domain name, this is a UPN so build a UPN salt.
    //

    if (DomainName->Length == 0)
    {
        return(KerbBuildKeySaltFromUpn(
                    ServiceName,
                    KeySalt ));
    }

    FinalLength = DomainName->Length +
                  ServiceName->Length;

    //
    // Add in any fixed strings, such as "host" for machines or "krbtgt" for
    // interdomain accounts
    //

    if (AccountType == MachineAccount)
    {
        //
        // Check to see if the name is already a "host/..." name. If so,
        // we don't need to do this work.
        //

        if ((ServiceName->Length > sizeof(KERB_HOST_STRING) &&
            (_wcsnicmp(
                ServiceName->Buffer,
                KERB_HOST_STRING,
                (sizeof(KERB_HOST_STRING) - sizeof(WCHAR)) / sizeof(WCHAR)) == 0) &&
            (ServiceName->Buffer[(sizeof(KERB_HOST_STRING) - sizeof(WCHAR)) / sizeof(WCHAR)] == L'/')))
        {
            AccountType = UserAccount;
        }
        else
        {
            FinalLength += sizeof(KERB_HOST_STRING) - sizeof(WCHAR);

            //
            // Add in the rest of the DNS name of the principal
            // as well
            //

            FinalLength += DomainName->Length + sizeof(WCHAR);
        }
    }
    else if (AccountType == DomainTrustAccount)
    {
        FinalLength += sizeof(KDC_PRINCIPAL_NAME) - sizeof(WCHAR);
    }
    else if (AccountType == UnknownAccount)
    {
        for (Index = 0; Index < ServiceName->Length/ sizeof(WCHAR) ; Index++ )
        {
            if (ServiceName->Buffer[Index] == L'/')
            {
                DeadSpace += sizeof(WCHAR);
            }
        }
        FinalLength = FinalLength - DeadSpace;
    }

    KeySalt->Length = 0;
    KeySalt->MaximumLength =
        FinalLength + sizeof(WCHAR);

    KeySalt->Buffer = (LPWSTR) MIDL_user_allocate(
                                            KeySalt->MaximumLength
                                            );
    if (KeySalt->Buffer == NULL)
    {
        return KRB_ERR_GENERIC;
    }

    Where = (PUCHAR) KeySalt->Buffer;

    memcpy(
        KeySalt->Buffer,
        DomainName->Buffer,
        DomainName->Length
        );
    KeySalt->Length = KeySalt->Length + DomainName->Length;

    Where += DomainName->Length;

    //
    // Add in any fixed strings, such as "host" for machines or "krbtgt" for
    // interdomain accounts
    //

    if (AccountType == MachineAccount)
    {
        USHORT DontCopyChars = 0;
        UNICODE_STRING LowerCase = {0};
        NTSTATUS Status;

        memcpy(
            Where,
            KERB_HOST_STRING,
            sizeof(KERB_HOST_STRING) - sizeof(WCHAR)
            );
        Where += sizeof(KERB_HOST_STRING) - sizeof(WCHAR);

        //
        // The service name may have a '$' at the end - if so, don't copy
        // it.
        //

        if ((ServiceName->Length >= sizeof(WCHAR)) &&
            (ServiceName->Buffer[-1 + ServiceName->Length / sizeof(WCHAR)] == L'$'))
        {
            DontCopyChars = 1;
        }

        LowerCase.Buffer = (LPWSTR) Where;

        memcpy(
            Where,
            ServiceName->Buffer,
            ServiceName->Length - sizeof(WCHAR) * DontCopyChars
            );

        Where += ServiceName->Length - sizeof(WCHAR) * DontCopyChars;
        LowerCase.Length += ServiceName->Length - sizeof(WCHAR) * DontCopyChars;

        //
        // add in the rest of the DNS name of the server
        //


        *(LPWSTR) Where = L'.';
        Where += sizeof(WCHAR);
        LowerCase.Length += sizeof(WCHAR);

        memcpy(
            Where,
            DomainName->Buffer,
            DomainName->Length
            );
        Where += DomainName->Length;
        LowerCase.Length = LowerCase.Length + DomainName->Length;

        LowerCase.MaximumLength = LowerCase.Length;

        Status = RtlDowncaseUnicodeString(
                    &LowerCase,
                    &LowerCase,
                    FALSE
                    );

        DsysAssert(NT_SUCCESS(Status));

    }
    else if (AccountType == DomainTrustAccount)
    {
        ULONG DontCopyChars = 0;

        memcpy(
            Where,
            KDC_PRINCIPAL_NAME,
            sizeof(KDC_PRINCIPAL_NAME) - sizeof(WCHAR)
            );
        Where += sizeof(KDC_PRINCIPAL_NAME) - sizeof(WCHAR);

        //
        // The service name may have a '$' at the end - if so, don't copy
        // it.
        //

        if ((ServiceName->Length >= sizeof(WCHAR)) &&
            (ServiceName->Buffer[-1 + ServiceName->Length / sizeof(WCHAR)] == L'$'))
        {
            DontCopyChars = 1;
        }

        memcpy(
            Where,
            ServiceName->Buffer,
            ServiceName->Length - sizeof(WCHAR) * DontCopyChars
            );

        Where += ServiceName->Length - sizeof(WCHAR) * DontCopyChars;

    }
    else if (AccountType == UnknownAccount)
    {
        //
        // Pull out an '/' from unknown accounts
        //

        for (Index = 0; Index < ServiceName->Length / sizeof(WCHAR) ; Index++)
        {
            if (ServiceName->Buffer[Index] != L'/')
            {
                *((LPWSTR) Where) = ServiceName->Buffer[Index];
                Where += sizeof(WCHAR);
            }
        }
    }
    else
    {
        for (Index = 0; Index < ServiceName->Length / sizeof(WCHAR); Index++ )
        {
            if (ServiceName->Buffer[Index] != L'/')
            {
                *((LPWSTR)Where) = ServiceName->Buffer[Index];
                Where += sizeof(WCHAR);
            }
        }
    }

    KeySalt->Length = (USHORT)(Where - (PUCHAR) KeySalt->Buffer);
    *(LPWSTR) Where = L'\0';

    return KDC_ERR_NONE;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbBuildKeySaltFromUpn
//
//  Synopsis:   Creaes salt from a UPN
//
//  Effects:
//              For users it is DOMAINNAMEusername
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KerbBuildKeySaltFromUpn(
    IN const UNICODE_STRING * Upn,
    OUT PUNICODE_STRING Salt
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    UNICODE_STRING RealUpn = {0};
    UNICODE_STRING RealmName = {0};
    UNICODE_STRING LocalSalt = {0};
    ULONG Index;

    //
    // If there is an "@" in UPN, strip it out & use the dns domain name
    //

    RealUpn = *Upn;
    for (Index = 0; Index < RealUpn.Length/sizeof(WCHAR) ; Index++ )
    {
        if (RealUpn.Buffer[Index] == L'@')
        {
            RealUpn.Length = (USHORT) (Index * sizeof(WCHAR));
            RealmName.Buffer = &RealUpn.Buffer[Index+1];
            RealmName.Length = Upn->Length - RealUpn.Length - sizeof(WCHAR);
            RealmName.MaximumLength = RealmName.Length;
            break;
        }
    }
    if (RealmName.Length == 0)
    {
        KerbErr = KDC_ERR_C_PRINCIPAL_UNKNOWN;
        goto Cleanup;
    }

    //
    // Create the salt. It starts off with the domain name & then has the
    // UPN without any of the / pieces
    //

    LocalSalt.MaximumLength = RealmName.Length + RealUpn.Length;
    LocalSalt.Length = 0;
    LocalSalt.Buffer = (LPWSTR) MIDL_user_allocate(LocalSalt.MaximumLength);
    if (LocalSalt.Buffer == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    memcpy(
        LocalSalt.Buffer,
        RealmName.Buffer,
        RealmName.Length
        );
    LocalSalt.Length = LocalSalt.Length + RealmName.Length;

    //
    // Add in the real upn but leave out any "/" marks
    //

    for (Index = 0; Index < RealUpn.Length/sizeof(WCHAR) ; Index++ )
    {
        if (RealUpn.Buffer[Index] != L'/')
        {
            LocalSalt.Buffer[LocalSalt.Length / sizeof(WCHAR)] = RealUpn.Buffer[Index];
            LocalSalt.Length += sizeof(WCHAR);
        }
    }

    //
    // We have to lowercase the username for users
    //

#ifndef WIN32_CHICAGO
    CharLowerBuff(&(LocalSalt.Buffer[RealmName.Length/sizeof(WCHAR)]), RealUpn.Length/sizeof(WCHAR));
#endif // WIN32_CHICAGO

    *Salt = LocalSalt;

Cleanup:

    return KerbErr;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbConvertSidToString
//
//  Synopsis:   Converts a sid to a string using RtlConvertSidToUnicodeString
//              but with a different allocator.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
__stdcall
KerbConvertSidToString(
    IN PSID Sid,
    OUT PUNICODE_STRING String,
    IN BOOLEAN AllocateDestination
    )
{
    NTSTATUS Status;
    WCHAR Buffer[256];
    UNICODE_STRING TempString;

    if (AllocateDestination)
    {
        TempString.Length = 0;
        TempString.MaximumLength = sizeof(Buffer);
        TempString.Buffer = Buffer;
    }
    else
    {
         TempString = *String;
    }

    Status = RtlConvertSidToUnicodeString(
                &TempString,
                Sid,
                FALSE
                );

    if (NT_SUCCESS(Status))
    {
        if (!AllocateDestination)
        {
            *String = TempString;
        }
        else
        {
            String->Buffer = (LPWSTR) MIDL_user_allocate(TempString.Length+sizeof(WCHAR));
            if (String->Buffer == NULL)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
            else
            {
                String->Length = TempString.Length;
                String->MaximumLength = TempString.Length+sizeof(WCHAR);
                memcpy(
                    String->Buffer,
                    TempString.Buffer,
                    TempString.Length
                    );
                String->Buffer[TempString.Length / sizeof(WCHAR)] = L'\0';
            }
        }
    }

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbConvertStringToSid
//
//  Synopsis:   Converts back a sid from KerbConvertSidToString. If the
//              string is malformed, it will return STATUS_INVALID_PARAMTER
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbConvertStringToSid(
    IN const UNICODE_STRING * String,
    OUT PSID * Sid
    )
{
    NTSTATUS Status;
    WCHAR Buffer[256];
    PSID SidT;

    *Sid = NULL;

    if ( String->Length + sizeof( WCHAR ) <= sizeof( Buffer )) {

        memcpy( Buffer, String->Buffer, String->Length );

    } else {

        return STATUS_INVALID_PARAMETER;
    }

    Buffer[String->Length / sizeof( WCHAR )] = L'\0';

    if ( ConvertStringSidToSidW(
             Buffer,
             &SidT )) {

        Status = KerbDuplicateSid(
                     Sid,
                     SidT
                     );

        LocalFree( SidT );

    } else {

        switch( GetLastError()) {

        case ERROR_NOT_ENOUGH_MEMORY:

            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;

        case ERROR_INVALID_SID:

            Status = STATUS_INVALID_PARAMETER;
            break;

        default:
            DsysAssert( FALSE ); // add mapping for the error code
            Status = STATUS_INVALID_PARAMETER;
            break;
        }
    }

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbBuildAltSecId
//
//  Synopsis:   Builds the name for the alt-sec-id field lookup
//
//  Effects:    Converts a principal name from name1 name2 name3 to
//              "kerberos:name1/name2/name3@realm"
//
//  Arguments:  AlternateName
//              PrincipalName
//              Realm
//              UnicodeRealm
//
//  Requires:
//
//  Returns:    KDC_ERR_NONE
//              KDC_ERR_C_PRINCIPAL_UNKNOWN
//              KRB_ERR_GENERIC
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KerbBuildAltSecId(
    OUT PUNICODE_STRING AlternateName,
    IN const KERB_INTERNAL_NAME * PrincipalName,
    IN OPTIONAL const KERB_REALM * Realm,
    IN OPTIONAL const UNICODE_STRING * UnicodeRealm
    )
{
    ULONG StringLength = sizeof(KERB_NAME_PREFIX) - sizeof(WCHAR);
    ULONG Index;
    UNICODE_STRING TempString = {0};
    UNICODE_STRING LocalRealm = {0};
    KERBERR KerbErr = KDC_ERR_NONE;

    *AlternateName = TempString;

    if (ARGUMENT_PRESENT(UnicodeRealm))
    {
        LocalRealm = *UnicodeRealm;
    }
    else if (ARGUMENT_PRESENT(Realm))
    {
        KerbErr = KerbConvertRealmToUnicodeString(
                    &LocalRealm,
                    Realm
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }
    }

    if (PrincipalName->NameCount == 0)
    {
        return KDC_ERR_C_PRINCIPAL_UNKNOWN;
    }

    //
    // Add in the size of all the components of the name plus a separtor
    // or a null terminator.
    //

    for (Index = 0; Index < PrincipalName->NameCount; Index++ )
    {
        StringLength += PrincipalName->Names[Index].Length + sizeof(WCHAR);
    }

    if (LocalRealm.Length != 0)
    {
        StringLength += sizeof(WCHAR) + // for @
                        LocalRealm.Length;
    }

    //
    // Now build the name, front to back (differently from KerbConvertPrincipalNameToString()
    //

    TempString.Buffer = (LPWSTR) MIDL_user_allocate(StringLength);
    if (TempString.Buffer == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }
    TempString.Length = 0;
    TempString.MaximumLength = (USHORT) StringLength;

    //
    // Now start appending the various portions to the string
    //

    RtlAppendUnicodeStringToString(
        &TempString,
        &KerbNamePrefix
        );

    for (Index = 0; Index < PrincipalName->NameCount ; Index++ )
    {
        if (Index != 0)
        {
            RtlAppendUnicodeStringToString(
                &TempString,
                &KerbNameSeparator
                );
        }

        RtlAppendUnicodeStringToString(
            &TempString,
            &PrincipalName->Names[Index]
            );
    }

    if (LocalRealm.Length != 0)
    {
        RtlAppendUnicodeStringToString(
            &TempString,
            &KerbDomainSeparator
            );
        RtlAppendUnicodeStringToString(
            &TempString,
            &LocalRealm
            );
    }

    *AlternateName = TempString;

Cleanup:

    if (!ARGUMENT_PRESENT(UnicodeRealm))
    {
        KerbFreeString(&LocalRealm);
    }

    return KerbErr;
}


#ifndef WIN32_CHICAGO

//+-------------------------------------------------------------------------
//
//  Function:   KerbGetPrincipalNameFromCertificate
//
//  Synopsis:   Derives the principal name from a certificate
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbGetPrincipalNameFromCertificate(
    IN PCCERT_CONTEXT ClientCert,
    OUT PUNICODE_STRING String
    )
{
    UNICODE_STRING NameString = {0};
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG   ExtensionIndex = 0;
    PCERT_ALT_NAME_INFO AltName=NULL;
    PCERT_NAME_VALUE    PrincipalNameBlob = NULL;
    LPWSTR              CertNameString = NULL;

    CRYPT_DECODE_PARA   DecodePara = {sizeof(CRYPT_DECODE_PARA),
                                      MIDL_user_allocate,
                                      MIDL_user_free };

    //
    // Get the client name from the cert
    //

    // See if cert has UPN in AltSubjectName->otherName
    for(ExtensionIndex = 0;
        ExtensionIndex < ClientCert->pCertInfo->cExtension;
        ExtensionIndex++)
    {
        if(strcmp(ClientCert->pCertInfo->rgExtension[ExtensionIndex].pszObjId,
                  szOID_SUBJECT_ALT_NAME2) == 0)
        {
            DWORD               AltNameStructSize = 0;
            ULONG               CertAltNameIndex = 0;
            if(CryptDecodeObjectEx(ClientCert->dwCertEncodingType,
                                X509_ALTERNATE_NAME,
                                ClientCert->pCertInfo->rgExtension[ExtensionIndex].Value.pbData,
                                ClientCert->pCertInfo->rgExtension[ExtensionIndex].Value.cbData,
                                CRYPT_DECODE_ALLOC_FLAG,
                                &DecodePara,
                                (PVOID)&AltName,
                                &AltNameStructSize))
            {

                for(CertAltNameIndex = 0; CertAltNameIndex < AltName->cAltEntry; CertAltNameIndex++)
                {
                    PCERT_ALT_NAME_ENTRY AltNameEntry = &AltName->rgAltEntry[CertAltNameIndex];
                    if((CERT_ALT_NAME_OTHER_NAME  == AltNameEntry->dwAltNameChoice) &&
                       (NULL != AltNameEntry->pOtherName) &&
                       (0 == strcmp(szOID_NT_PRINCIPAL_NAME, AltNameEntry->pOtherName->pszObjId)))
                    {
                        DWORD            PrincipalNameBlobSize = 0;

                        // We found a UPN!
                        if(CryptDecodeObjectEx(ClientCert->dwCertEncodingType,
                                            X509_UNICODE_ANY_STRING,
                                            AltNameEntry->pOtherName->Value.pbData,
                                            AltNameEntry->pOtherName->Value.cbData,
                                            CRYPT_DECODE_ALLOC_FLAG,
                                            &DecodePara,
                                            (PVOID)&PrincipalNameBlob,
                                            &PrincipalNameBlobSize))
                        {

                            RtlInitUnicodeString(&NameString, (LPCWSTR)PrincipalNameBlob->Value.pbData);

                            if(NameString.Length)
                            {
                                break;
                            }

                            MIDL_user_free(PrincipalNameBlob);
                            PrincipalNameBlob = NULL;
                        }

                    }
                }
                if(NameString.Length)
                {
                    break;
                }
                MIDL_user_free(AltName);
                AltName = NULL;
            }
        }
    }
    /*
    Beta 3 code.  We no longer honor the CN in the certificate

    if(0 == NameString.Length)
    {
        if (!(NameLength = CertGetNameStringW(
                ClientCert,
                CERT_NAME_ATTR_TYPE,
                0,                          // no flags
                szOID_COMMON_NAME,          // type parameter
                NULL,
                0
                )))
        {
            Status = GetLastError();
            DebugLog((DEB_ERROR,"Failed to get name from cert: %d.\n",Status));
            goto Cleanup;
        }
        CertNameString = (LPWSTR) MIDL_user_allocate(NameLength * sizeof(WCHAR));
        if (CertNameString == NULL)
        {
            Status = STATUS_NO_MEMORY;
            goto Cleanup;
        }
        if (!(NameLength = CertGetNameStringW(
                ClientCert,
                CERT_NAME_ATTR_TYPE,
                0,                          // no flags
                szOID_COMMON_NAME,          // type parameter
                CertNameString,
                NameLength
                )))
        {
            Status = GetLastError();
            DebugLog((DEB_ERROR,"Failed to get name from cert: %d.\n",Status));
            goto Cleanup;
        }



        RtlInitUnicodeString(
            String,
            CertNameString
            );
        CertNameString = NULL;

    }
    else
    {

    */

    if(0 != NameString.Length)
    {
        Status = KerbDuplicateString(String, &NameString);
        if (!NT_SUCCESS(Status))
        {
            D_DebugLog((DEB_ERROR,"Failed to normalize name "));
            // KerbPrintKdcName(DEB_ERROR,ClientName);
            goto Cleanup;
        }

        D_DebugLog((DEB_TRACE,"UPN from certificate is %wZ\n",&NameString));
    }
    else
    {
        Status = STATUS_INVALID_PARAMETER;
        D_DebugLog((DEB_ERROR,"No valid name in Sclogon certificate\n"));
        goto Cleanup;
    }

Cleanup:

    if(PrincipalNameBlob)
    {
        MIDL_user_free(PrincipalNameBlob);
    }
    if(AltName)
    {
        MIDL_user_free(AltName);
    }
    if(CertNameString)
    {
        MIDL_user_free(CertNameString);
    }

    return Status;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\common\newlock.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    newlock.c

Abstract:

    Multi-reader, Single-writer, adapted from Michael Parkes Rockall allocator project

    UpdateSemaphore() uses InterlockedExchangePointer() rather than the previous
    overly complex method.


Author:

    Scott Field (SField) 02-Jan-2001

--*/

#include <windows.h>

#include "newlock.h"


VOID
DeleteExclusiveOwner(
        PSHARELOCK pShareLock
        );

VOID
NewExclusiveOwner(
        PSHARELOCK pShareLock,
        LONG NewOwner
        );

BOOLEAN
SleepWaitingForLock(
        PSHARELOCK pShareLock,
        DWORD Sleep
        );

VOID
UpdateSemaphore(
    IN PSHARELOCK pShareLock
    );

BOOLEAN
WaitForExclusiveLock(
        PSHARELOCK pShareLock,
        DWORD Sleep
        );

BOOLEAN
WaitForShareLock(
    PSHARELOCK pShareLock,
    DWORD Sleep
    );

VOID
WakeAllSleepers(
    PSHARELOCK pShareLock
    );

DWORD
NumberOfCpus(
    VOID
    );






BOOLEAN
InitializeSharedLock(
        PSHARELOCK pShareLock
        )
{
    ZeroMemory( pShareLock, sizeof(*pShareLock) );
    pShareLock->MaxSpins = 4096;

    //
    // BUGBUG: should be 0x7fffffff ?
    //

    pShareLock->MaxUsers = 256;
    pShareLock->MaxShareLockUsers = 256;

    //
    // in this implementation, we pre-allocate the semaphore to prevent failures during acquire
    //

    pShareLock->Semaphore = CreateSemaphoreW(
                                NULL,
                                0,
                                pShareLock->MaxShareLockUsers,
                                NULL
                                );

    if(pShareLock->Semaphore != NULL)
    {
        return TRUE;
    }

    return FALSE;
}

VOID
DeleteSharedLock(
        PSHARELOCK pShareLock
        )
{

    if( pShareLock->Semaphore != NULL )
    {
        CloseHandle( pShareLock->Semaphore );
    }

#ifdef ENABLE_LOCK_STATISTICS
    {
    LONG TotalExclusiveLocks = pShareLock->TotalExclusiveLocks;
    LONG TotalShareLocks = pShareLock->TotalShareLocks;
    LONG TotalTimeouts = pShareLock->TotalTimeouts;
    LONG TotalWaits = pShareLock->TotalWaits;
    LONG TotalSpins = pShareLock->TotalSpins;
    LONG TotalSleeps = pShareLock->TotalWaits;
    CHAR String[ 1024 ];

    wsprintfA(String,
    "Sharelock: %d exclusive, %d shared, %d timeouts, "
    "%d locks per wait, %d spins per wait, %d waits per sleep.\n",
        TotalExclusiveLocks,
        TotalShareLocks,
        TotalTimeouts,
        ((TotalExclusiveLocks + TotalShareLocks) / ((TotalWaits <= 0) ? 1 : TotalWaits)),
        (TotalSpins / ((TotalWaits <= 0) ? 1 : TotalWaits)),
        (TotalWaits / ((TotalSleeps <= 0) ? 1 : TotalSleeps))
        );
    OutputDebugStringA(String);
    }

#endif

    ZeroMemory( pShareLock, sizeof(*pShareLock) );
}



BOOLEAN
ClaimExclusiveLock(
        PSHARELOCK pShareLock,
        DWORD Sleep
        )
{

#ifdef ENABLE_RECURSIVE_LOCKS
    REGISTER LONG ThreadId = GetCurrentThreadId();

	//
	//   We may already own an exclusive lock. If so 
	//   we increment the recursive count otherwise 
	//   we have to wait.
	//
	if ( pShareLock->Owner != ThreadId )
	{
#endif
		//
		//   We need to increment the exclusive count
		//   to prevent the lock from being shared and
		//   the total number of users count.
		//
        (VOID) InterlockedIncrement( (PLONG)& pShareLock->Exclusive );
        (VOID) InterlockedIncrement( (PLONG)& pShareLock->TotalUsers );

		if ( pShareLock->TotalUsers != 1 )
        {
			//
			//   We have to wait.  If we are not allowed 
			//   to sleep or we have timed out then exit.
			//
			if ( ! WaitForExclusiveLock( pShareLock, Sleep ) )
			{
                return FALSE;
            }
		}
#ifdef ENABLE_RECURSIVE_LOCKS

		//
		//   Register the new exclusive owner
		//   of the lock.
		//
		NewExclusiveOwner( pShareLock, ThreadId );
	}
	else
	{
        pShareLock->Recursive ++;
    }
#endif
#ifdef ENABLE_LOCK_STATISTICS

	//
	//   Update the statistics.
	//
    (VOID) InterlockedIncrement( & pShareLock->TotalExclusiveLocks );
#endif

    return TRUE;
}

BOOLEAN
ClaimShareLock(
        PSHARELOCK pShareLock,
        DWORD Sleep
        )
{

#ifdef ENABLE_RECURSIVE_LOCKS
    REGISTER LONG ThreadId = GetCurrentThreadId();

	//
	//   We may already own an exclusive lock. If so 
	//   we increment the recursive count otherwise 
	//   we have to wait.
	//
	if ( pShareLock->Owner != ThreadId )
	{
#endif
		//
		//   We need to increment the total number of 
		//   users count to prevent the lock from being 
		//   claimed for exclusive use.
		//
        (VOID) InterlockedIncrement( (PLONG)& pShareLock->TotalUsers );

		if ( (pShareLock->Exclusive > 0) || (pShareLock->TotalUsers > pShareLock->MaxUsers) )
		{
			//
			//   We have to wait.  If we are not allowed 
			//   to sleep or we have timed out then exit.
			//
			if ( ! WaitForShareLock( pShareLock, Sleep ) )
			{
                return FALSE;
            }
		}
#ifdef ENABLE_RECURSIVE_LOCKS
	}
	else
	{
        pShareLock->Recursive ++;
    }
#endif
#ifdef ENABLE_LOCK_STATISTICS

	//
	//   Update the statistics.
	//
    (VOID) InterlockedIncrement( & pShareLock->TotalShareLocks );
#endif

	return TRUE;
}


VOID
ReleaseExclusiveLock(
        PSHARELOCK pShareLock
        )
{

#ifdef ENABLE_RECURSIVE_LOCKS
	//
	//   When we have recursive lock calls we do not 
	//   release the lock until we have exited to the 
	//   top level.
	//
	if ( pShareLock->Recursive <= 0 )
	{
		//
		//   Delete the exclusive owner information.
		//
		DeleteExclusiveOwner( pShareLock );

#endif
		//
		//   Release an exclusive lock.
		//

        InterlockedDecrement( (PLONG)& pShareLock->TotalUsers );
        InterlockedDecrement( (PLONG)& pShareLock->Exclusive );

		//
		//   Wakeup anyone who is asleep waiting.
		//
		if ( pShareLock->Waiting > 0 )
		{
            WakeAllSleepers( pShareLock );
        }
#ifdef ENABLE_RECURSIVE_LOCKS
	}
	else
	{
        pShareLock->Recursive --;
    }
#endif
}

VOID
ReleaseShareLock(
        PSHARELOCK pShareLock
        )
{

#ifdef ENABLE_RECURSIVE_LOCKS
	//
	//   When we have recursive lock calls we do not 
	//   release the lock until we have exited to the 
	//   top level.
	//
	if ( pShareLock->Recursive <= 0 )
	{
#endif

		//
		//   Release a shared lock.
		//
        InterlockedDecrement( (PLONG)& pShareLock->TotalUsers );

		//
		//   Wakeup anyone who is asleep waiting.
		//
		if ( pShareLock->Waiting > 0 )
		{
            WakeAllSleepers( pShareLock );
        }

#ifdef ENABLE_RECURSIVE_LOCKS
	}
	else
	{
        pShareLock->Recursive --;
    }
#endif

}


VOID
ChangeExclusiveLockToSharedLock(
        PSHARELOCK pShareLock
        )
{
#ifdef ENABLE_RECURSIVE_LOCKS
    //
    //   When we have recursive lock calls we do not 
    //   release the lock until we have exited to the 
    //   top level.
    //
    if ( pShareLock->Recursive <= 0 )
    {
        //
        //   Delete the exclusive owner information.
        //
        DeleteExclusiveOwner( pShareLock );

#endif
        //
        //   Simply decrement the exclusive count.
        //   This allows the lock to be shared.
        //
        (VOID) InterlockedDecrement( (PLONG)& pShareLock->Exclusive );
#ifdef ENABLE_RECURSIVE_LOCKS
    }
#endif
#ifdef ENABLE_LOCK_STATISTICS

    //
    //   Update the statistics.
    //
    (VOID) InterlockedIncrement( (PLONG)& pShareLock->TotalShareLocks );
#endif

}

BOOLEAN
ChangeSharedLockToExclusiveLock(
        PSHARELOCK pShareLock,
        DWORD Sleep
        )
{

#ifdef ENABLE_RECURSIVE_LOCKS
    REGISTER LONG ThreadId = GetCurrentThreadId();

    //
    //   We may already own an exclusive lock. If so 
    //   we increment the recursive count otherwise 
    //   we have to wait.
    //
    if ( pShareLock->Owner != ThreadId )
    {
#endif      
        //
        //   We need to increment the exclusive count
        //   to prevent the lock from being shared.
        //
        (VOID) InterlockedIncrement( (PLONG)& pShareLock->Exclusive );

        //
        //   If the total number of users is one then
        //   we have the lock exclusively otherwise we
        //   may need to wait.
        //
        if ( pShareLock->TotalUsers != 1 )
        {
            //
            //   We have to wait.  If we are not allowed 
            //   to sleep or we have timed out then exit.
            //
            if ( ! WaitForExclusiveLock( pShareLock, Sleep ) )
            {
                return FALSE;
            }
        }
#ifdef ENABLE_RECURSIVE_LOCKS

        //
        //   Register the new exclusive owner
        //   of the lock.
        //
        NewExclusiveOwner( pShareLock, ThreadId );
    }
#endif

#ifdef ENABLE_LOCK_STATISTICS

    //
    //   Update the statistics.
    //
    (VOID) InterlockedIncrement( (PLONG)& pShareLock->TotalExclusiveLocks );
#endif

    return TRUE;

}


VOID
DeleteExclusiveOwner(
        PSHARELOCK pShareLock
        )
{
#ifdef ENABLE_RECURSIVE_LOCKS
    pShareLock->Owner = NULL; 
#else 
    UNREFERENCED_PARAMETER( pShareLock );
#endif
}

VOID
NewExclusiveOwner(
        PSHARELOCK pShareLock,
        LONG NewOwner
        )
{
#ifdef ENABLE_RECURSIVE_LOCKS
    pShareLock->Owner = NewOwner; 
#else 
    UNREFERENCED_PARAMETER( pShareLock );
    UNREFERENCED_PARAMETER( NewOwner );
#endif
}


BOOLEAN
SleepWaitingForLock(
    IN PSHARELOCK pShareLock,
    IN DWORD Sleep
    )
{
	//
	//   We do not create the semaphore until somebody tries
	//   to sleep on it for the first time.
	//
	if ( pShareLock->Semaphore == NULL )
	{
        UpdateSemaphore( pShareLock );
    }

	//
	//   We would normally hope to find a semaphore avaiable
	//   ready for a sleep but the OS may decline the request 
	//   If this is the case we exit without sleeping.
	//
	if ( pShareLock->Semaphore != NULL )
	{
		//
		//   We have been spinning waiting for the lock but it
		//   has not become free.  Hence, it is now time to 
		//   give up and sleep for a while.
		//
        (VOID) InterlockedIncrement( (PLONG)& pShareLock->Waiting );

		//
		//   Just before we go to sleep we do one final check
		//   to make sure that the lock is still busy and that
		//   there is someone to wake us up when it becomes free.
		//
		if ( pShareLock->TotalUsers > 0 )
		{
#ifdef ENABLE_LOCK_STATISTICS
			//
			//   Count the number of times we have slept on this lock.
			//
            (VOID) InterlockedIncrement( (PLONG)& pShareLock->TotalSleeps );

#endif
			//
			//   When we sleep we awoken when the lock becomes free
			//   or when we timeout.  If we timeout we simply exit
			//   after decrementing various counters.
			//
            if(WaitForSingleObject( pShareLock->Semaphore, Sleep ) != WAIT_OBJECT_0)
			{ 
#ifdef ENABLE_LOCK_STATISTICS
				//
				//   Count the number of times we have timed out 
				//   on this lock.
				//
                (VOID) InterlockedIncrement( (PLONG)& pShareLock->TotalTimeouts );
#endif
				return FALSE; 
			}
		}
		else
		{
			//
			//   Lucky - the lock was just freed so lets
			//   decrement the sleep count and exit without
			//   sleeping.
			// 
            (VOID) InterlockedDecrement( (PLONG)& pShareLock->Waiting );
		}
	}
	
	return TRUE;
}


BOOLEAN
UpdateMaxSpins(
        PSHARELOCK pShareLock,
        LONG NewMaxSpins
        )
{
	if ( NewMaxSpins > 0 )
	{ 
		pShareLock->MaxSpins = NewMaxSpins; 

    	return TRUE;
	}
    else {
        return FALSE;
    }

}


BOOLEAN
UpdateMaxUsers(
        PSHARELOCK pShareLock,
        LONG NewMaxUsers
        )
{
	//
	//   We need to verify the new value makes sense.
	//
	if ( (NewMaxUsers > 0) && (NewMaxUsers <= pShareLock->MaxShareLockUsers) )
	{
		ClaimExclusiveLock( pShareLock, INFINITE );

		//
		//   Update the maximum number of users.
		//
		
        pShareLock->MaxUsers = NewMaxUsers;
		
		ReleaseExclusiveLock( pShareLock );

		return TRUE;
	}
    else {
        return FALSE;
    }
}


VOID
UpdateSemaphore(
    IN PSHARELOCK pShareLock
    )
{
    if( pShareLock->Semaphore == NULL )
    {
        HANDLE Semaphore;

        Semaphore = CreateSemaphoreW(
                                NULL,
                                0,
                                pShareLock->MaxShareLockUsers,
                                NULL
                                );

        if( InterlockedCompareExchangePointer(
                        &pShareLock->Semaphore,
                        Semaphore,
                        NULL
                        ) != NULL )
        {
            CloseHandle( Semaphore );
        }
    }
}



BOOLEAN
WaitForExclusiveLock(
        PSHARELOCK pShareLock,
        DWORD Sleep
        )
{
	REGISTER LONG Cpus = ((LONG) NumberOfCpus());

#ifdef ENABLE_LOCK_STATISTICS
    REGISTER LONG Spins = 0;
    REGISTER LONG Waits = 0;

#endif
	//
	//   We will loop round in this function until the
	//   following condition becomes false.
	//
	while ( pShareLock->TotalUsers != 1 )
	{
		//
		//   The lock is busy so release it and spin waiting
		//   for it to become free.
		//
        (VOID) InterlockedDecrement( (PLONG)& pShareLock->TotalUsers );
    
		//
		//   We will only try spinning and sleeping if we
		//   are permitted to do so by the parameters.
		//   
		if ( Sleep != 0 )
		{
            REGISTER LONG Count;
    
			//
			//   If there are already more threads waiting 
			//   than the number of CPUs then the odds of 
			//   getting the lock by spinning are slim, when 
			//   there is only one CPU the chance is zero, so 
			//   just bypass this step.
			//
			if ( (Cpus > 1) && (Cpus > pShareLock->Waiting) )
			{
				//
				//   Wait by spinning and repeatedly testing the
				//   spinlock.  We exit when the lock becomes free 
				//   or the spin limit is exceeded.
				//
				for 
					( 
						Count = pShareLock->MaxSpins;
						(Count > 0) && (pShareLock->TotalUsers > 0);
						Count -- 
					);
#ifdef ENABLE_LOCK_STATISTICS

				//
				//   Update the statistics.
				//
				Spins += (pShareLock->MaxSpins - Count);
				Waits ++;
#endif
			}
			else
			{
                Count = 0;
            }

			//
			//   We have exhusted our spin count so it is time to
			//   sleep waiting for the lock to clear.
			//
			if ( Count == 0 )
			{
				//
				//   We have decide that we need to sleep but are
				//   still holding an exclusive lock so lets drop it
				//   before sleeping.
				//
                (VOID) InterlockedDecrement( (PLONG)& pShareLock->Exclusive );

				//
				//   We have decied that it is time to go to sleep
				//   when we wake up the lock should be available
				//   (or just aquired) unless we have timed out in
				//   wich case we exit.
				//
				if ( ! SleepWaitingForLock( pShareLock, Sleep ) )
				{
                    return FALSE;
                }

				//
				//   We have woken up again so lets reclaim the
				//   exclusive lock we had earlier.
				//
                (VOID) InterlockedIncrement( (PLONG)& pShareLock->Exclusive );
			}
		}
		else
		{ 
			//
			//   We have decide that we need to exit but are still
			//   holding an exclusive lock.  so lets drop it and leave.
			//
            (VOID) InterlockedDecrement( (PLONG)& pShareLock->Exclusive );

			return FALSE;
		} 
		
        //
		//   Lets test the lock again.
		//
        (VOID) InterlockedIncrement( (PLONG)& pShareLock->TotalUsers );
    }

#ifdef ENABLE_LOCK_STATISTICS

	//
	//   Update the statistics.
	//
    (VOID) InterlockedExchangeAdd( & pShareLock->TotalSpins, Spins );
    (VOID) InterlockedExchangeAdd( & pShareLock->TotalWaits, Waits );
#endif

	return TRUE;
}


BOOLEAN
WaitForShareLock(
    PSHARELOCK pShareLock,
    DWORD Sleep
    )
{
	REGISTER LONG Cpus = ((LONG) NumberOfCpus());
#ifdef ENABLE_LOCK_STATISTICS
    REGISTER LONG Spins = 0;
    REGISTER LONG Waits = 0;

#endif
	//
	//   We will loop round in this function until the
	//   following condition becomes false.
	//
	while ( (pShareLock->Exclusive > 0) || (pShareLock->TotalUsers > pShareLock->MaxUsers) )
    {
		//
		//   The lock is busy so release it and spin waiting
		//   for it to become free.
		//
        (VOID) InterlockedDecrement( (PLONG)& pShareLock->TotalUsers );

		//
		//   We will only try spinning and sleeping if we
		//   are permitted to do so by the parameters.
		//   
		if ( Sleep != 0 )
		{
            REGISTER LONG Count;
    
			//
			//   If there are already more threads waiting 
			//   than the number of CPUs then the odds of 
			//   getting the lock by spinning are slim, when 
			//   there is only one CPU the chance is zero, so 
			//   just bypass this step.
			//
			if ( (Cpus > 1) && (Cpus > pShareLock->Waiting) )
			{
				//
				//   Wait by spinning and repeatedly testing the
				//   spinlock.  We exit when the lock becomes free 
				//   or the spin limit is exceeded.
				//
				for 
					( 
						Count = pShareLock->MaxSpins;
						(Count > 0) 
							&& 
						((pShareLock->Exclusive > 0) || (pShareLock->TotalUsers >= pShareLock->MaxUsers));
						Count -- 
					);
#ifdef ENABLE_LOCK_STATISTICS

				//
				//   Update the statistics.
				//
				Spins += (pShareLock->MaxSpins - Count);
				Waits ++;
#endif
			}
			else
			{
                Count = 0;
            }

			//
			//   We have exhusted our spin count so it is time to
			//   sleep waiting for the lock to clear.
			//
			if ( Count == 0 )
			{
				//
				//   We have decied that it is time to go to sleep
				//   when we wake up the lock should be available
				//   (or just aquired) unless we have timed out in
				//   wich case we exit.
				//
				if ( ! SleepWaitingForLock( pShareLock, Sleep ) )
				{
                    return FALSE;
                }
            }
		}
		else
		{
            return FALSE;
        }

		//
		//   Lets test the lock again.
		//
        (VOID) InterlockedIncrement( (PLONG)& pShareLock->TotalUsers );
	    	
    }
#ifdef ENABLE_LOCK_STATISTICS

	//
	//   Update the statistics.
	//
    (VOID) InterlockedExchangeAdd( (PLONG)& pShareLock->TotalSpins, Spins );
    (VOID) InterlockedExchangeAdd( (PLONG)& pShareLock->TotalWaits, Waits );
#endif

	return TRUE;
}


VOID
WakeAllSleepers(
    PSHARELOCK pShareLock
    )
{
    REGISTER LONG Wakeup = InterlockedExchange( (PLONG)& pShareLock->Waiting, 0 );

	//
	//   We make sure there is still someone to be woken 
	//   up if not we check that the count has not become
	//   negative.
	//
    if ( Wakeup > 0 )
    {
		REGISTER LONG Cpus = ((LONG) NumberOfCpus());

		//
		//   We will only wake enough threads to ensure that 
		//   there is one active thread per CPU.  So if an 
		//   application has hundreds of threads we will try 
		//   prevent the system from becoming swampped.
		//
		if ( Wakeup > Cpus )
    	{
            (VOID) InterlockedExchangeAdd( (PLONG)& pShareLock->Waiting,(Wakeup - Cpus) );
			Wakeup = Cpus; 
		}

        //
        //   Wake up all sleepers as the lock has just been freed.
        //   It is a straight race to decide who gets the lock next.
        //
        if ( ! ReleaseSemaphore( pShareLock->Semaphore, Wakeup, NULL ) )
        {
            DebugBreak();
        }
    }
    else
    {
        //
        //   When multiple threads pass through the critical  
        //   section it is possible for the 'Waiting' count  
		//   to become negative.  This should be very rare but 
		//   such a negative value needs to be preserved. 
        //
		
        if ( Wakeup < 0 )
		{
            (VOID) InterlockedExchangeAdd( (PLONG)& pShareLock->Waiting, Wakeup );
        }
    }
}


DWORD
NumberOfCpus(
    VOID
    )
{
    static DWORD dwProcessorCount;
    SYSTEM_INFO si;


    //
    // BUGBUG: this routine should be inlined?
    //

    if( dwProcessorCount != 0 )
    {
        return dwProcessorCount;
    }

    GetSystemInfo( &si );
    
    dwProcessorCount = si.dwNumberOfProcessors;

    return dwProcessorCount;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\common\restrict.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:        restrict.cxx
//
// Contents:    Logon restriction code
//
//
// History:      4-Aug-1996     MikeSw          Created from tickets.cxx
//
//------------------------------------------------------------------------

#include "commonp.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\common\tickets.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:        tickets.c
//
// Contents:    Ticket bundling code
//
//
// History:      6 Dec 91,  RichardW    Created
//              04 Jun 92   RichardW    NT-ized
//              08-Jun-93   WadeR       Converted to C++, rewrote packing code
//
//------------------------------------------------------------------------

#include "commonp.h"


#define FILENO  FILENO_TICKETS

//
// Debugging support.
//

#ifndef WIN32_CHICAGO
#ifdef DEBUG_SUPPORT

DEBUG_KEY   KSuppDebugKeys[] = { {DEB_ERROR, "Error"},
                                 {DEB_WARN,  "Warning"},
                                 {DEB_TRACE, "Trace"},
                                 {DEB_T_SOCK, "Sock"},
                                 {0, NULL }
                                 };
#endif

DEFINE_DEBUG_DEFER(KSupp, KSuppDebugKeys);
#endif // WIN32_CHICAGO


BOOLEAN TicketsInitialized;
BOOLEAN KerbUseFastDecodeAlloc = FALSE;

#define I_LsaIThreadAlloc MIDL_user_allocate
#define I_LsaIThreadFree MIDL_user_free

//+-------------------------------------------------------------------------
//
//  Function:   KerbConvertGeneralizedTimeToLargeInt
//
//  Synopsis:   Converts a generalized time (ASN.1 format) to a large integer
//              (NT format)
//
//  Effects:
//
//  Arguments:  TimeStamp - receives NT-style time
//              ClientTime - client generalized time
//              ClientUsec - client micro second count
//
//  Requires:   none
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbConvertGeneralizedTimeToLargeInt(
    OUT PTimeStamp TimeStamp,
    IN const KERB_TIME * ClientTime,
    IN int ClientUsec
    )
{
    KERB_TIME ZeroTime = {0};
    SYSTEMTIME TimeFields;

    ZeroTime.universal = TRUE;

    //
    // Skip this check after 3/1/97 - no clients should send this sort of
    // zero time
    //

    if (!memcmp(
            &ZeroTime,
            ClientTime,
            sizeof(KERB_TIME)
            ))
    {
#ifndef WIN32_CHICAGO
        TimeStamp->QuadPart = 0;
#else // WIN32_CHICAGO
        *TimeStamp = 0;
#endif // WIN32_CHICAGO
        return;
    }

    //
    // Check for MIT zero time
    //

    ZeroTime.year = 1970;
    ZeroTime.month = 1;
    ZeroTime.day = 1;

    if (!memcmp(
            &ZeroTime,
            ClientTime,
            sizeof(KERB_TIME)
            ))
    {
#ifndef WIN32_CHICAGO
        TimeStamp->QuadPart = 0;
#else // WIN32_CHICAGO
        *TimeStamp = 0;
#endif // WIN32_CHICAGO
        return;
    }
    else
    {
        TimeFields.wYear = ClientTime->year;
        TimeFields.wMonth = ClientTime->month;
        TimeFields.wDay = ClientTime->day;
        TimeFields.wHour = ClientTime->hour;
        TimeFields.wMinute = ClientTime->minute;
        TimeFields.wSecond = ClientTime->second;
        TimeFields.wMilliseconds = ClientTime->millisecond;  // to convert from micro to milli
        TimeFields.wDayOfWeek = 0;

        SystemTimeToFileTime(&TimeFields, (LPFILETIME) TimeStamp );

        //
        // add in any micro seconds
        //

        TimeStamp->QuadPart += ClientUsec * 10;
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbConvertLargeIntToGeneralizedTime
//
//  Synopsis:   Converts a large integer to ageneralized time
//
//  Effects:
//
//  Arguments:  ClientTime - receives generalized time
//              ClientUsec - receives micro second count
//              TimeStamp - contains NT-style time
//
//  Requires:   none
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbConvertLargeIntToGeneralizedTime(
    OUT PKERB_TIME ClientTime,
    OUT OPTIONAL long * ClientUsec,
    IN const TimeStamp * TimeStamp
    )
{
    SYSTEMTIME TimeFields;

    //
    // Special case zero time
    //

#ifndef WIN32_CHICAGO
    if (TimeStamp->QuadPart == 0)
#else // WIN32_CHICAGO
    if (*TimeStamp == 0)
#endif // WIN32_CHICAGO
    {
        ZeroMemory(
            ClientTime,
            sizeof(KERB_TIME)
            );
        //
        // For MIT compatibility, time zero is 1/1/70
        //

        ClientTime->year = 1970;
        ClientTime->month = 1;
        ClientTime->day = 1;

        if (ARGUMENT_PRESENT(ClientUsec))

        {
            *ClientUsec  = 0;
        }
        ClientTime->universal = TRUE;
    }
    else
    {
        FileTimeToSystemTime((LPFILETIME) TimeStamp, &TimeFields );

        //
        // Generalized times can only contains years up to four digits.
        //

        if (TimeFields.wYear > 2037)
        {
            ClientTime->year = 2037;
        }
        else
        {
            ClientTime->year = TimeFields.wYear;
        }

        ClientTime->month = (ASN1uint8_t) TimeFields.wMonth;
        ClientTime->day = (ASN1uint8_t) TimeFields.wDay;
        ClientTime->hour = (ASN1uint8_t) TimeFields.wHour;
        ClientTime->minute = (ASN1uint8_t) TimeFields.wMinute;
        ClientTime->second = (ASN1uint8_t) TimeFields.wSecond;

        //
        // MIT kerberos does not support millseconds
        //

        ClientTime->millisecond = 0;

        if (ARGUMENT_PRESENT(ClientUsec))
        {
            //
            // Since we don't include milliseconds above, use the whole
            // thing here.
            //

            *ClientUsec = (TimeStamp->LowPart / 10) % 1000000;
        }

        ClientTime->diff = 0;
        ClientTime->universal = TRUE;
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbFreeHostAddresses
//
//  Synopsis:   Frees a host address  allocated with KerbBuildHostAddresses
//
//  Effects:
//
//  Arguments:  Addresses - The name to free
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbFreeHostAddresses(
    IN PKERB_HOST_ADDRESSES Addresses
    )
{
    PKERB_HOST_ADDRESSES Elem,NextElem;

    Elem = Addresses;
    while (Elem != NULL)
    {
        if (Elem->value.address.value != NULL)
        {
            MIDL_user_free(Elem->value.address.value);
        }
        NextElem = Elem->next;
        MIDL_user_free(Elem);
        Elem = NextElem;
    }
}

#ifndef WIN32_CHICAGO

//+-------------------------------------------------------------------------
//
//  Function:   KerbCheckTimeSkew
//
//  Synopsis:   Verifies the supplied time is within the skew of another
//              supplied time
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

BOOLEAN
KerbCheckTimeSkew(
    IN const TimeStamp * CurrentTime,
    IN const TimeStamp * ClientTime,
    IN const TimeStamp * AllowedSkew
    )
{
    TimeStamp TimePlus, TimeMinus;

    TimePlus.QuadPart = CurrentTime->QuadPart + AllowedSkew->QuadPart;
    TimeMinus.QuadPart = CurrentTime->QuadPart - AllowedSkew->QuadPart;

    if ((ClientTime->QuadPart > TimePlus.QuadPart) ||
        (ClientTime->QuadPart < TimeMinus.QuadPart))
    {
        return FALSE;
    }

    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbVerifyTicket
//
//  Synopsis:   Verifies that the specified ticket is valid by checking
//              for valid times, flags, and server principal name. This is
//              called by KerbCheckTicket to verify an AP request and by the
//              KDC to verify additional tickets in TGS request
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KerbVerifyTicket(
    IN CKerbRequest * pReq,
    IN const KERB_TICKET * PackedTicket,
    IN ULONG NameCount,
    IN OPTIONAL const UNICODE_STRING * ServiceNames,
    IN OPTIONAL const UNICODE_STRING * ServiceRealm,
    IN IKerbPrincipal * piService,
    IN OPTIONAL const TimeStamp * SkewTime,
    OUT PKERB_ENCRYPTED_TICKET * DecryptedTicket,
    OUT PKERB_EXT_ERROR pExtendedError
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    UNICODE_STRING TicketRealm = {0};
    PKERB_ENCRYPTED_TICKET EncryptPart = NULL;
    TimeStamp TimePlus, TimeMinus, TimeNow, StartTime,EndTime, Time2Plus;
    ULONG TicketFlags = 0;

#ifdef notedef
    if ( ARGUMENT_PRESENT(ServiceNames) )
    {
        ULONG Index;

        KerbErr = KRB_AP_ERR_NOT_US;

        //
        // Loop through names looking for a match
        //

        for (Index = 0; Index < NameCount ; Index++ )
        {
            if (KerbCompareStringToPrincipalName(
                &PackedTicket->server_name,
                &ServiceNames[Index]
                ) )
            {
                KerbErr = KDC_ERR_NONE;
                break;
            }

        }
        if (!KERB_SUCCESS(KerbErr))
        {
            DebugLog(( DEB_WARN, "KLIN(%x) Ticket (%s) not for this service (%wZ).\n",
                                 KLIN(FILENO, __LINE__),
                                 PackedTicket->server_name.name_string->value,
                                 &ServiceNames[0] ));
            goto Cleanup;
        }
    }


    if (ARGUMENT_PRESENT(ServiceRealm))
    {
        KerbErr = KerbConvertRealmToUnicodeString(
                    &TicketRealm,
                    &PackedTicket->realm
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }

        if (!KerbCompareUnicodeRealmNames(
                &TicketRealm,
                ServiceRealm
                ))
        {
            KerbErr = KRB_AP_ERR_NOT_US;
            DebugLog(( DEB_WARN, "KLIN(%x) Ticket (%wZ) not for this realm (%wZ).\n",
                                 KLIN(FILENO, __LINE__), &TicketRealm, ServiceRealm ));
            goto Cleanup;

        }
    }
#endif

    //
    // Unpack ticket.
    //

    KerbErr = KerbUnpackTicket(
                    pReq->GetEncryptionTypes(),
                    PackedTicket,
                    piService,
                    &EncryptPart,
                    pExtendedError
                    );
    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_WARN, "KLIN(%x) KerbUnpackTicket failed: 0x%x",
            KLIN(FILENO, __LINE__), KerbErr));
        goto Cleanup;
    }


    if (PackedTicket->ticket_version != KERBEROS_VERSION)
    {
        DebugLog(( DEB_WARN, "KLIN(%x) Ticket has bad version %d\n",
            KLIN(FILENO, __LINE__),PackedTicket->ticket_version ));
        KerbErr = KRB_AP_ERR_BADVERSION;
        goto Cleanup;
    }



    //
    // If the caller provided a skew time, check the times on the ticket.
    // Otherwise it is up to the caller to check that the ticket times are
    // correct
    //


    if (ARGUMENT_PRESENT(SkewTime))
    {
        //
        // Check the times on the ticket.  We do this last because when the KDC
        // wants to renew a ticket, the timestamps may be incorrect, but it will
        // accept the ticket anyway.  This way the KDC can be certain when the
        // times are wrong that everything else is OK.
        //

        GetSystemTimeAsFileTime((PFILETIME) &TimeNow );

    #ifndef WIN32_CHICAGO
        TimePlus.QuadPart = TimeNow.QuadPart + SkewTime->QuadPart;
        Time2Plus.QuadPart = TimePlus.QuadPart + SkewTime->QuadPart;
        TimeMinus.QuadPart = TimeNow.QuadPart - SkewTime->QuadPart;
    #else // WIN32_CHICAGO
        TimePlus = TimeNow + *SkewTime;
        Time2Plus = TimePlus + *SkewTime;
        TimeMinus = TimeNow - *SkewTime;
    #endif // WIN32_CHICAGO

        KerbConvertGeneralizedTimeToLargeInt(
            &EndTime,
            &EncryptPart->endtime,
            0
            );

        //
        // Did the ticket expire already?
        //

    #ifndef WIN32_CHICAGO
        if ( EndTime.QuadPart < TimeMinus.QuadPart )
    #else // WIN32_CHICAGO
        if ( EndTime < TimeMinus )
    #endif // WIN32_CHICAGO
        {
            DebugLog(( DEB_WARN, "KLIN(%x) KerbCheckTicket: ticket is expired.\n",
                KLIN(FILENO, __LINE__)));

#ifdef XBOX_KDC         
            KerbErr = KDC_ERR_TGT_REVOKED;
#else           
            KerbErr = KRB_AP_ERR_TKT_EXPIRED;
#endif          
            goto Cleanup;
        }

        //
        // Is the ticket  valid yet?
        //

        if (EncryptPart->bit_mask & KERB_ENCRYPTED_TICKET_starttime_present)
        {
            KerbConvertGeneralizedTimeToLargeInt(
                &StartTime,
                &EncryptPart->KERB_ENCRYPTED_TICKET_starttime,
                0
                );


            TicketFlags = KerbConvertFlagsToUlong(
                            &EncryptPart->flags
                            );
            //
            // BUG 403734: Look into this a bit more
            // We don't check for tickets that aren't valid yet, as
            // our KDC doesn't normally hand out post dated tickets. As long
            // as the end time is valid, that is good enough for us.
            //

            //
            // Does the ticket start in the future? Allow twice the skew in
            // the reverse direction.
            //
    #ifndef WIN32_CHICAGO
            if ( (StartTime.QuadPart > Time2Plus.QuadPart) ||
    #else // WIN32_CHICAGO
            if ( (StartTime > Time2Plus) ||
    #endif // WIN32_CHICAGO
                ((TicketFlags & KERB_TICKET_FLAGS_invalid) != 0 ))
            {
                KerbErr = KRB_AP_ERR_TKT_NYV;
                goto Cleanup;
            }
        }
    }

    //
    //  finally check if the session key in the ecrypted part needs
    //  to be changed
    //  that will be the case if compound identity is present
    //
    if (pReq->m_piCompId)
    {
        ULONG   cKeys = 0;
        const KERB_ENCRYPTION_KEY *pcKeys;
        NTSTATUS    Status = pReq->m_piCompId->GetTgtKeys(&cKeys, &pcKeys);
        if (NT_SUCCESS(Status))
        {
            //  change the session key
            Status = KerbComputePaCompIdentityKey(&EncryptPart->key,
                                              cKeys,
                                              pcKeys);
            if (!NT_SUCCESS(Status))
            {
                //  key derivation failed
                //  treat this as preauth error
                KerbErr = KDC_ERR_PREAUTH_FAILED;
                DebugLog(( DEB_WARN,
                "KLIN(%x) KerbCheckTicket: failed to derived compid key 0x%lx.\n",
                KLIN(FILENO, __LINE__), Status));
                goto    Cleanup;
            }
        }
    }


    *DecryptedTicket = EncryptPart;
    EncryptPart = NULL;

Cleanup:
    if (EncryptPart != NULL)
    {
        KerbFreeTicket(EncryptPart);
    }
    KerbFreeString(&TicketRealm);
    return(KerbErr);
}

//+---------------------------------------------------------------------------
//
//  Function:   KerbCheckTicket
//
//  Synopsis:   Decrypts a ticket and authenticator, verifies them.
//
//  Effects:    decrypts the ticket and authenticator (in place) allocates mem.
//
//  Arguments:  [PackedTicket]    -- Encrypted ticket
//              [PackedTicketSize] - Size of encrypted ticket
//              [pedAuth]         -- Encrypted authenticator
//              [pkKey]           -- Key to decrypt ticket with
//              [alAuthenList]    -- List of authenticators to check against
//              [NameCount]       -- Count of service names
//              [pwzServiceName]  -- Name of service (may be NULL).
//              [CheckForReplay]  -- If TRUE, check authenticator cache for replay
//              [KdcRequest]      -- If TRUE, this is the ticket in a TGS req
//              [pkitTicket]      -- Decrypted ticket
//              [pkiaAuth]        -- Decrypted authenticator
//              [pkTicketKey]     -- Session key from ticket
//              [pkSessionKey]    -- Session key to use
//
//  Returns:    KDC_ERR_NONE if everything is OK, else error.
//
//  History:    4-04-93   WadeR   Created
//
//  Notes:      The caller must call KerbFreeTicket and
//              KerbFreeAuthenticator on pkitTicket and pkiaAuth,
//              respectively.
//
//              If pwzServiceName == NULL, it won't check the service name.
//
//              See sections 3.2.3 and A.10 of the Kerberos V5 R5.2 spec
//
//----------------------------------------------------------------------------

KERBERR NTAPI
KerbCheckTicket(
    IN  CKerbRequest   *piReq,
    IN  PKERB_TICKET PackedTicket,
    IN  PKERB_ENCRYPTED_DATA EncryptedAuthenticator,
    IN  IKerbPrincipal *piServ,
    IN  OUT CAuthenticatorList * AuthenticatorList,
    IN  const TimeStamp *SkewTime,
    IN  ULONG NameCount,
    IN  PUNICODE_STRING ServiceNames,
    IN  PUNICODE_STRING ServiceRealm,
    IN  BOOLEAN CheckForReplay,
    IN  BOOLEAN KdcRequest,
    OUT PKERB_ENCRYPTED_TICKET * EncryptTicket,
    OUT PKERB_AUTHENTICATOR  * Authenticator,
    OUT OPTIONAL PKERB_ENCRYPTION_KEY pkTicketKey,
    OUT PKERB_ENCRYPTION_KEY pkSessionKey,
    OUT PBOOLEAN UseSubKey,
    OUT PKERB_EXT_ERROR pExtendedError
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    PKERB_ENCRYPTED_TICKET EncryptPart = NULL;
    LARGE_INTEGER AuthenticatorTime;


    //
    // The caller will free these, so we must make sure they are valid
    // if we return before putting anything in them.  This will zero out
    // all of the pointers in them, so it's safe to free them later.
    //

    *EncryptTicket = NULL;
    *Authenticator = NULL;
    *UseSubKey = FALSE;

    ZeroMemory(
        pkSessionKey,
        sizeof(KERB_ENCRYPTION_KEY)
        );
    if (ARGUMENT_PRESENT(pkTicketKey))
    {
        *pkTicketKey = *pkSessionKey;
    }


    //
    // Is the ticket for this service?
    // ServerName in ticket is different length then ServerName passed in,
    // or same length but contents don't match.



    //
    // If either of KerbUnpackTicket or KerbUnpackAuthenticator
    // get bad data, they could access violate.
    //

    __try
    {

        KerbErr = KerbVerifyTicket(
                    piReq,
                    PackedTicket,
                    NameCount,
                    ServiceNames,
                    ServiceRealm,
                    piServ,
                    SkewTime,
                    &EncryptPart,
                    pExtendedError
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            __leave;
        }

        //
        // Unpack Authenticator.
        //

        KerbErr = KerbUnpackAuthenticator(
                    &EncryptPart->key,
                    EncryptedAuthenticator,
                    KdcRequest,
                    Authenticator
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            DebugLog((DEB_WARN,"KerbUnpackAuthenticator failed: 0x%x\n", KerbErr) );
            __leave;
        }



        //
        // Check the contents of the authenticator
        //
        if ((*Authenticator)->authenticator_version != KERBEROS_VERSION)
        {
            DebugLog(( DEB_WARN, "Authenticator has bad version %d\n",
                                  (*Authenticator)->authenticator_version ));
            KerbErr = KRB_AP_ERR_BADVERSION;
            __leave;
        }


        if (!KerbComparePrincipalNames(
                &EncryptPart->client_name,
                &(*Authenticator)->client_name
                ) ||
            !KerbCompareRealmNames(
                &EncryptPart->client_realm,
                &(*Authenticator)->client_realm
                ) )
        {
            DebugLog(( DEB_WARN, "Authenticator principal != ticket principal\n"));
            KerbErr = KRB_AP_ERR_BADMATCH;
            __leave;
        }

        KerbConvertGeneralizedTimeToLargeInt(
            &AuthenticatorTime,
            &(*Authenticator)->client_time,
            (*Authenticator)->client_usec
            );

        {
            //  check time skew
            //  outside authenticator cache
            LARGE_INTEGER tsNow;
            GetSystemTimeAsFileTime((PFILETIME) &tsNow );
            if (!KerbCheckTimeSkew(&tsNow, &AuthenticatorTime, SkewTime))
            {
                KerbErr = KRB_AP_ERR_SKEW;
                __leave;
            }

        }
        //
        // Make sure the authenticator isn't a repeat, or too old.
        //

        if (CheckForReplay)
        {

            AuthenticatorList->SetMaxAge(*SkewTime);
            KerbErr = (KERBERR) AuthenticatorList->Check(
                                    EncryptedAuthenticator->cipher_text.value,
                                    EncryptedAuthenticator->cipher_text.length,
                                    NULL,
                                    0,
                                    &AuthenticatorTime,
                                    TRUE
                                    );
            if (!KERB_SUCCESS(KerbErr))
            {
                DebugLog((DEB_WARN,"Failed authenticator check: 0x%x\n",KerbErr));
                __leave;
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        // Any exceptions are likely from bad ticket data being unmarshalled.
        DebugLog(( DEB_WARN, "Exception 0x%X in KerbCheckTicket (likely bad ticket or auth.\n",
            GetExceptionCode() ));
        KerbErr = KRB_AP_ERR_BADVERSION;
    }

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }
    //
    // Extract the correct session key.  If the Sub-session key in the
    // Authenticator is present, use it.  Otherwise, use the session key
    // from the ticket.
    //

    if (((*Authenticator)->bit_mask & KERB_AUTHENTICATOR_subkey_present) != 0)
    {
        D_DebugLog(( DEB_TRACE, "Using sub session key from authenticator.\n" ));
        KerbErr = KerbDuplicateKey(
                    pkSessionKey,
                    &(*Authenticator)->KERB_AUTHENTICATOR_subkey
                    );
        *UseSubKey = TRUE;
    }
    else
    {
        KerbErr = KerbDuplicateKey(
                    pkSessionKey,
                    &EncryptPart->key
                    );
    }
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    //
    // The reply has to be encrypted with the ticket key, not the new
    // session key
    //

    if (ARGUMENT_PRESENT(pkTicketKey))
    {
        KerbErr = KerbDuplicateKey(
                    pkTicketKey,
                    &EncryptPart->key
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }
    }


    *EncryptTicket = EncryptPart;
    EncryptPart = NULL;

Cleanup:
    if (EncryptPart != NULL)
    {
        KerbFreeTicket(EncryptPart);
    }
    if (!KERB_SUCCESS(KerbErr))
    {
        KerbFreeKey(pkSessionKey);
        if (ARGUMENT_PRESENT(pkTicketKey))
        {
            KerbFreeKey(pkTicketKey);
        }
    }

    return(KerbErr);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbDuplicateSid
//
//  Synopsis:   Duplicates a SID
//
//  Effects:    allocates memory with LsaFunctions.AllocateLsaHeap
//
//  Arguments:  DestinationSid - Receives a copy of the SourceSid
//              SourceSid - SID to copy
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS - the copy succeeded
//              STATUS_INSUFFICIENT_RESOURCES - the call to allocate memory
//                  failed
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbDuplicateSid(
    OUT PSID * DestinationSid,
    IN PSID SourceSid
    )
{
    ULONG SidSize;

    if (!RtlValidSid(SourceSid))
    {
        return STATUS_INVALID_PARAMETER;
    }

    DsysAssert(RtlValidSid(SourceSid));

    SidSize = RtlLengthSid(SourceSid);
    *DestinationSid = (PSID) MIDL_user_allocate( SidSize );
    if (*DestinationSid == NULL)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }
    memcpy(
        *DestinationSid,
        SourceSid,
        SidSize
        );
    return(STATUS_SUCCESS);
}

#endif // WIN32_CHICAGO


//
// Ticket pack/unpack code.
//

//+---------------------------------------------------------------------------
//
//  Function:   KerbPackTicket
//
//  Synopsis:   Packs a KerbInternalTicket to a KerbTicket
//
//  Effects:    Allocates the KerbTicket via MIDL.
//
//  Arguments:  [InternalTicket] -- Internal ticket to pack. Those fields
//                      reused in the packed ticket are zeroed.
//              [pkKey]      -- Key to pack it with
//              [EncryptionType] -- Encryption type to use
//              [PackedTicket] -- (out) encrypted ticket. Only the encrypt_part
//                      is allocated.
//
//  History:    08-Jun-93   WadeR   Created
//
//  Notes:      The MES encoding needs to be changed to ASN1 encoding
//
//----------------------------------------------------------------------------

KERBERR NTAPI
KerbPackTicket(
    IN CKerbRequest *pReq,
    IN PKERB_TICKET InternalTicket,
    IN IKerbPrincipal *piServ,
    IN PKERB_CRYPT_LIST EncryptionTypes,
    OUT PKERB_TICKET PackedTicket,
    OUT PKERB_EXT_ERROR pExtendedError
    )
{
    KERBERR       KerbErr = KDC_ERR_NONE;
    PKERB_ENCRYPTED_TICKET EncryptedTicket = NULL;
    ULONG           cbEncryptedPart;
    KERB_TICKET     TemporaryTicket;
    PUCHAR          MarshalledEncryptPart = NULL;
    IKerbCrypt  *piCrypt = NULL;
    ULONG   EncryptionType = pReq->GetCommonEType();
    //  get the crypt interface from the server princ
    pReq->GetIPrincService()->GetIKdbProvider()->GetIKerbCrypt(&piCrypt);
    if (!piCrypt)
    {
        return  KRB_ERR_GENERIC;
    }

    //
    // Pack the data into the encrypted portion.
    //

    ZeroMemory(
        &TemporaryTicket,
        sizeof(KERB_TICKET)
        );

    EncryptedTicket = (PKERB_ENCRYPTED_TICKET) InternalTicket->encrypted_part.cipher_text.value;


    KerbErr = KerbPackData(
                EncryptedTicket,
                KERB_ENCRYPTED_TICKET_PDU,
                &cbEncryptedPart,
                &MarshalledEncryptPart
                );


    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"Failed to marshall ticket: 0x%x\n",KerbErr));
        goto Cleanup;
    }

    //
    // And encrypt it.
    //



    TemporaryTicket = *InternalTicket;

    ZeroMemory(
        &InternalTicket->realm,
        sizeof(KERB_REALM)
        );

    ZeroMemory(
        &InternalTicket->server_name,
        sizeof(KERB_PRINCIPAL_NAME)
        );

    //
    //  clear them in case it fail and we will not free the wrong buffer
    //
    TemporaryTicket.encrypted_part.cipher_text.length = 0;
    TemporaryTicket.encrypted_part.cipher_text.value  = NULL;

    // get common etype size
    KerbErr = KerbAllocateEncryptionBufferWrapper(
                piCrypt,
                EncryptionType,
                cbEncryptedPart,
                &TemporaryTicket.encrypted_part.cipher_text.length,
                &TemporaryTicket.encrypted_part.cipher_text.value
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }


    D_DebugLog(( DEB_TRACE, "Using kvno=%d for encrypting ticket.\n",
                 piServ->GetKeyVersion() ));
    KerbErr = piServ->Encrypt(pReq->GetEncryptionTypes(),
                              KERB_TICKET_SALT,
                              MarshalledEncryptPart,
                              cbEncryptedPart,
                              &TemporaryTicket.encrypted_part,
                              pExtendedError);
#if 0
    KerbErr = KerbEncryptDataEx(
                &TemporaryTicket.encrypted_part,
                cbEncryptedPart,
                MarshalledEncryptPart,
                EncryptionType,
                pkKey->KeyVersion,
                KERB_TICKET_SALT,
                &pkKey->Key
                );
#endif
    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"Failed to encrypt data: 0x%x\n",KerbErr));
        goto Cleanup;
    }

    *PackedTicket = TemporaryTicket;

Cleanup:
    if (MarshalledEncryptPart != NULL)
    {
        MIDL_user_free(MarshalledEncryptPart);
    }

    if (!KERB_SUCCESS(KerbErr))
    {
        if (TemporaryTicket.encrypted_part.cipher_text.value != NULL)
        {
            MIDL_user_free(TemporaryTicket.encrypted_part.cipher_text.value);
        }

    }
    return(KerbErr);
}


//+---------------------------------------------------------------------------
//
//  Function:   KerbUnpackTicket
//
//  Synopsis:   Decrypts and unpacks the encyrpted part of aticket.
//
//  Effects:    Allocates memory, decrypts pktTicket in place
//
//  Arguments:  [PackedTicket]  -- ticket to unpack
//              [PackedTicketSize] -- length of packed ticket
//              [pkKey]      -- key to unpack it with
//              [InternalTicket] -- (out) unpacked ticket
//
//  Returns:    KDC_ERR_NONE or error from decrypt
//
//  Signals:    Any exception the MIDL unpacking code throws.
//
//  History:    09-Jun-93   WadeR   Created
//
//  Notes:      Free InternalTicket with KerbFreeTicket, below.
//
//----------------------------------------------------------------------------

KERBERR NTAPI
KerbUnpackTicket(
    IN const KERB_CRYPT_LIST * pEtypes,
    IN const KERB_TICKET * PackedTicket,
    IN PIKerbPrincipal piService,
    OUT PKERB_ENCRYPTED_TICKET * InternalTicket,
    OUT PKERB_EXT_ERROR pExtendedError
    )
{
    KERBERR   KerbErr = KDC_ERR_NONE;
    PUCHAR EncryptedPart = NULL;
    ULONG EncryptSize;
    PKERB_ENCRYPTED_TICKET EncryptedTicket = NULL;

    //
    // Now decrypt the encrypted part of the ticket
    //

    EncryptedPart = (PUCHAR) MIDL_user_allocate(PackedTicket->encrypted_part.cipher_text.length);
    if (EncryptedPart == NULL)
    {
        return KRB_ERR_GENERIC;
    }

    EncryptSize = PackedTicket->encrypted_part.cipher_text.length;
    KerbErr = piService->Decrypt(
                  pEtypes,
                  KERB_TICKET_SALT,
                  &PackedTicket->encrypted_part,
                  EncryptedPart,
                  &EncryptSize,
                  NULL,
                  pExtendedError
                  );

    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"Failed to decrypt ticket: 0x%x\n",KerbErr));

#if DBG
        //
        // Who's this ticket *supposed* to be for?
        //
        KerbPrintPrincipalName(DEB_ERROR, &PackedTicket->server_name);
        KerbPrintKerbRealm(DEB_ERROR, &PackedTicket->realm);
#endif

        goto Cleanup;
    }

    KerbErr = KerbUnpackData(
                  EncryptedPart,
                  EncryptSize,
                  KERB_ENCRYPTED_TICKET_PDU,
                  (PVOID *) &EncryptedTicket
                  );

    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"Failed to unmarshall ticket: 0x%x\n",KerbErr));
        goto Cleanup;
    }

    *InternalTicket = EncryptedTicket;

Cleanup:

    if (EncryptedPart != NULL)
    {
        MIDL_user_free(EncryptedPart);
    }

    return KerbErr;
}


//+---------------------------------------------------------------------------
//
//  Function:   KerbCreateAuthenticator
//
//  Synopsis:   Creates an authenticator for a client to pass to a service
//
//  Effects:    Encrypts pedAuthenticator
//
//  Arguments:  [pkKey]            -- (in) session key from the ticket this
//                                         authenticator is for.
//              [dwEncrType]       -- (in) Desired encryption type
//              [dwSeq]            -- (in) nonce for authenticator
//              [ClientName]       -- (in) name of principal
//              [ClientRealm]      -- (in) logon realm of principal
//              [SkewTime]         -- (in) Skew of server's time
//              [pkSubKey]         -- (in) desired sub key (may be NULL)
//              [GssChecksum]      -- (in) optional checksum message to put in authenticator
//              [KdcRequest]       -- (in) If TRUE, this is an authenticator for a KDC request
//                                              and we use a different salt
//              [Authenticator]-- (out) completed authenticator
//
//  History:    4-28-93   WadeR   Created
//
//  Notes:      If pkKey is NULL, a null subkey is used.
//
//
//----------------------------------------------------------------------------

KERBERR NTAPI
KerbCreateAuthenticator(
    IN IKerbCrypt   *piCrypt,
    IN PKERB_ENCRYPTION_KEY pkKey,
    IN ULONG EncryptionType,
    IN ULONG SequenceNumber,
    IN PKERB_INTERNAL_NAME ClientName,
    IN PUNICODE_STRING ClientRealm,
    IN OPTIONAL PTimeStamp SkewTime,
    IN PKERB_ENCRYPTION_KEY pkSubKey,
    IN OPTIONAL PKERB_CHECKSUM GssChecksum,
    IN BOOLEAN KdcRequest,
    OUT PKERB_ENCRYPTED_DATA Authenticator
    )
{
    KERB_AUTHENTICATOR InternalAuthenticator;
    PKERB_AUTHENTICATOR AuthPointer = &InternalAuthenticator;
    ULONG cbAuthenticator;
    PUCHAR PackedAuthenticator = NULL;
    KERBERR KerbErr = KDC_ERR_NONE;
    TimeStamp TimeToUse;

    Authenticator->cipher_text.value = NULL;

    ZeroMemory(
        &InternalAuthenticator,
        sizeof(KERB_AUTHENTICATOR)
        );

    // Build an authenticator

    InternalAuthenticator.authenticator_version = KERBEROS_VERSION;

    // Use "InitString" because we will marshall and then discard the
    // InternalAthenticator.  Therefore it's not a problem having the
    // string point to memory we don't own.

    KerbErr = KerbConvertUnicodeStringToRealm(
                &InternalAuthenticator.client_realm,
                ClientRealm
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }


    KerbErr = KerbConvertKdcNameToPrincipalName(
                &InternalAuthenticator.client_name,
                ClientName
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    //
    // Stick the correct time in the authenticator
    //

    GetSystemTimeAsFileTime((PFILETIME)&TimeToUse);
    if (ARGUMENT_PRESENT(SkewTime))
    {
#ifndef WIN32_CHICAGO
        TimeToUse.QuadPart += SkewTime->QuadPart;
#else // WIN32_CHICAGO
        TimeToUse += *SkewTime;
#endif // WIN32_CHICAGO
    }

    KerbConvertLargeIntToGeneralizedTime(
        &InternalAuthenticator.client_time,
        &InternalAuthenticator.client_usec,
        &TimeToUse
        );

    InternalAuthenticator.bit_mask |= KERB_AUTHENTICATOR_sequence_number_present;

    ASN1intx_setuint32(
        &InternalAuthenticator.KERB_AUTHENTICATOR_sequence_number,
        SequenceNumber
        );
    if (InternalAuthenticator.KERB_AUTHENTICATOR_sequence_number.value == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    if (ARGUMENT_PRESENT(pkSubKey))
    {
        InternalAuthenticator.bit_mask |= KERB_AUTHENTICATOR_subkey_present;
        InternalAuthenticator.KERB_AUTHENTICATOR_subkey = *pkSubKey;
    }

    //
    // If the GSS checksum is present, include it and set it in the bitmask
    //

    if (ARGUMENT_PRESENT(GssChecksum))
    {
        InternalAuthenticator.checksum = *GssChecksum;
        InternalAuthenticator.bit_mask |= checksum_present;
    }

    KerbErr = KerbPackData(
                AuthPointer,
                KERB_AUTHENTICATOR_PDU,
                &cbAuthenticator,
                &PackedAuthenticator
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"Failed to marshall authenticator: 0x%x\n",KerbErr));
        goto Cleanup;
    }

    //
    // Now we need to encrypt the buffer
    //

        KerbErr = KerbAllocateEncryptionBufferWrapper(
                piCrypt,
                EncryptionType,
                cbAuthenticator,
                &Authenticator->cipher_text.length,
                &Authenticator->cipher_text.value
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }


    KerbErr = KerbEncryptDataEx(
                Authenticator,
                cbAuthenticator,
                PackedAuthenticator,
                EncryptionType,
                KERB_NO_KEY_VERSION,
                KdcRequest ? KERB_TGS_REQ_AP_REQ_AUTH_SALT : KERB_AP_REQ_AUTH_SALT,
                pkKey
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"Failed to encrypt data: 0x%x\n",KerbErr));
        goto Cleanup;
    }


Cleanup:
    KerbFreePrincipalName(&InternalAuthenticator.client_name);
    KerbFreeRealm(&InternalAuthenticator.client_realm);
    if (InternalAuthenticator.KERB_AUTHENTICATOR_sequence_number.value != NULL)
    {
        ASN1intx_free(&InternalAuthenticator.KERB_AUTHENTICATOR_sequence_number);
    }
    if (PackedAuthenticator != NULL)
    {
        MIDL_user_free(PackedAuthenticator);

    }
    return(KerbErr);
}




//+-------------------------------------------------------------------------
//
//  Function:   KerbUnpackAuthenticator
//
//  Synopsis:   Unpacks and decrypts an authenticator
//
//  Effects:    allocates memory for output authenticator
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------



KERBERR NTAPI
KerbUnpackAuthenticator(
    IN PKERB_ENCRYPTION_KEY Key,
    IN PKERB_ENCRYPTED_DATA EncryptedAuthenticator,
    IN BOOLEAN KdcRequest,
    OUT PKERB_AUTHENTICATOR * Authenticator
    )
{
    KERBERR  KerbErr = KDC_ERR_NONE;
    PUCHAR EncryptedPart;
    ULONG EncryptedSize;
    ULONG Pdu = KERB_AUTHENTICATOR_PDU;

    *Authenticator = NULL;
    //
    // Decrypt it
    //


    EncryptedPart = (PUCHAR) MIDL_user_allocate(EncryptedAuthenticator->cipher_text.length);
    if (EncryptedPart == NULL)
    {
        return(KRB_ERR_GENERIC);
    }

    EncryptedSize = EncryptedAuthenticator->cipher_text.length;
    KerbErr = KerbDecryptDataEx(
                EncryptedAuthenticator,
                Key,
                KdcRequest ? KERB_TGS_REQ_AP_REQ_AUTH_SALT : KERB_AP_REQ_AUTH_SALT,
                &EncryptedSize,
                EncryptedPart
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"Failed to decrypt authenticator: 0x%x\n",KerbErr));
        goto Cleanup;
    }

    //
    // Unpack it
    //

    KerbErr = KerbUnpackData(
                EncryptedPart,
                EncryptedSize,
                Pdu,
                (PVOID *) Authenticator
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"Failed to unmarshall authenticator: 0x%x\n",KerbErr));
        goto Cleanup;
    }

Cleanup:
    if (EncryptedPart != NULL)
    {
        MIDL_user_free(EncryptedPart);
    }
    if (!KERB_SUCCESS(KerbErr) && (*Authenticator != NULL))
    {
        MIDL_user_free(*Authenticator);
        *Authenticator = NULL;
    }
    return(KerbErr);
}



//
// KDC Reply stuff
//



//+-------------------------------------------------------------------------
//
//  Function:   KerbPackKdcReplyBody
//
//  Synopsis:   Marshalls a the body of a KDC reply
//
//  Effects:    allocates value of encrypted reply
//
//  Arguments:  ReplyBody - The reply body to marshall
//              Key - The key to encrypt the reply
//              EncryptionType - the algorithm to encrypt with
//              Pdu - Pdu to pack with, eith AS or TGS reply
//              EncryptedReplyBody - receives the encrypted and marshalled reply
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


KERBERR NTAPI
KerbPackKdcReplyBody(
    IN CKerbRequest*    pReq,
    IN PKERB_ENCRYPTED_KDC_REPLY ReplyBody,
    IN PKERB_ENCRYPTION_KEY Key,
    IN OPTIONAL IKerbPrincipal *piPrinc,
    //  key version is used only with principal encryption
    //  in this case the version comes from the principal interface
//    IN ULONG KeyVersion,
    IN PKERB_CRYPT_LIST EncryptionTypes,
    IN ULONG Pdu,
    OUT PKERB_ENCRYPTED_DATA EncryptedReply,
    OUT PKERB_EXT_ERROR pExtendedError
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    ULONG BodySize;
    PUCHAR MarshalledReply = NULL;
    ULONG TotalSize;
    //  use key or principal
    BOOLEAN fUseKey = (Key && Key->keytype!= 0 && Key->keyvalue.length != 0);
    ULONG   ulEType = fUseKey ? Key->keytype : pReq->GetCommonEType();
    IKerbCrypt  *piCrypt = NULL;
    //  get the crypt interface from the server princ
    pReq->GetIPrincService()->GetIKdbProvider()->GetIKerbCrypt(&piCrypt);

    EncryptedReply->cipher_text.value = NULL;


    KerbErr = KerbPackData(
                ReplyBody,
                Pdu,
                &BodySize,
                &MarshalledReply
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"Failed to marshall kdc reply body: 0x%x\n",KerbErr));
        goto Cleanup;
    }



    //
    // Now we need to encrypt this into the encrypted  data structure.
    //


    //
    //  find out the needed size
    //
    KerbErr = piCrypt->GetCiphertextSize(ulEType, BodySize, &TotalSize);
    if (!KERB_SUCCESS(KerbErr))
    {
        goto    Cleanup;
    }

    EncryptedReply->cipher_text.length = TotalSize;
    EncryptedReply->cipher_text.value = (PUCHAR) MIDL_user_allocate(TotalSize);
    if (EncryptedReply->cipher_text.value == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    //
    // Now encrypt the buffer
    //
    if (fUseKey)
    {
        //  use provider's crypt
        KerbErr = piCrypt->Encrypt(Key,
                                   KERB_NO_KEY_VERSION,
             (Pdu == KERB_AS_REPLY_PDU) ? KERB_AS_REP_SALT : KERB_TGS_REP_SALT,
                                   MarshalledReply,
                                   BodySize,
                                   EncryptedReply);


    }
    else
    {
        //  use principal's encryption
        //  BUGBUG todo: key version for the principal?
        KerbErr = piPrinc->Encrypt(pReq->GetEncryptionTypes(),
             (Pdu == KERB_AS_REPLY_PDU) ? KERB_AS_REP_SALT : KERB_TGS_REP_SALT,
                                   MarshalledReply,
                                   BodySize,
                                   EncryptedReply,
                                   pExtendedError);

    }

Cleanup:
    if (MarshalledReply != NULL)
    {
        MIDL_user_free(MarshalledReply);
    }
    if (!KERB_SUCCESS(KerbErr) && (EncryptedReply->cipher_text.value != NULL))
    {
        MIDL_user_free(EncryptedReply->cipher_text.value);
        EncryptedReply->cipher_text.value = NULL;
    }
    return(KerbErr);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbUnpackKdcReplyBody
//
//  Synopsis:   Unpacks a KDC reply body
//
//  Effects:
//
//  Arguments:  EncryptedReplyBody - an encrypted marshalled reply body.
//              Key - Key to decrypt the reply.
//              Pdu - PDU of reply body (eithe AS or TGS)
//              ReplyBody - receives the decrypted reply body, allocated with
//                      MIDL_user_allocate.
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


KERBERR NTAPI
KerbUnpackKdcReplyBody(
    IN PKERB_ENCRYPTED_DATA EncryptedReplyBody,
    IN PKERB_ENCRYPTION_KEY Key,
    IN ULONG Pdu,
    OUT PKERB_ENCRYPTED_KDC_REPLY * ReplyBody
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    PUCHAR MarshalledReply = NULL;
    ULONG ReplySize;

    *ReplyBody = NULL;
    MarshalledReply = (PUCHAR) MIDL_user_allocate(EncryptedReplyBody->cipher_text.length);

    if (MarshalledReply == NULL)
    {
        return(KRB_ERR_GENERIC);
    }

    //
    // First decrypt the buffer
    //

    ReplySize = EncryptedReplyBody->cipher_text.length;
    KerbErr = KerbDecryptDataEx(
                EncryptedReplyBody,
                Key,
                (Pdu == KERB_AS_REPLY_PDU) ? KERB_AS_REP_SALT : KERB_TGS_REP_SALT,
                &ReplySize,
                MarshalledReply
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    KerbErr = KerbUnpackData(
                MarshalledReply,
                ReplySize,
                Pdu,
                (PVOID *) ReplyBody
                );

    if (!KERB_SUCCESS(KerbErr))
    {

        //
        // MIT KDCs send back TGS reply bodies instead of AS reply bodies
        // so try TGS here
        //

        if (Pdu == KERB_ENCRYPTED_AS_REPLY_PDU)
        {
            KerbErr = KerbUnpackData(
                        MarshalledReply,
                        ReplySize,
                        KERB_ENCRYPTED_TGS_REPLY_PDU,
                        (PVOID *) ReplyBody
                        );

        }
        if (!KERB_SUCCESS(KerbErr))
        {
            DebugLog((DEB_ERROR,"Failed to unmarshall kdc reply body: 0x%x\n",KerbErr));
            goto Cleanup;
        }

    }
Cleanup:
    if (MarshalledReply != NULL)
    {
        MIDL_user_free(MarshalledReply);
    }
    if (!KERB_SUCCESS(KerbErr) && (*ReplyBody != NULL))
    {
        MIDL_user_free(*ReplyBody);
        *ReplyBody = NULL;
    }
    return(KerbErr);
}




//+-------------------------------------------------------------------------
//
//  Function:   KerbFindAuthDataEntry
//
//  Synopsis:   Finds a specific entry in an authorization data structure
//
//  Effects:
//
//  Arguments:  EntryId - ID of the entry to locate
//              AuthData - the authorization data to search
//
//  Requires:
//
//  Returns:    NULL if it wasn't found of the auth data entry
//
//  Notes:
//
//
//--------------------------------------------------------------------------

const KERB_AUTHORIZATION_DATA *
KerbFindAuthDataEntry(
    IN ULONG EntryId,
    IN const KERB_AUTHORIZATION_DATA * AuthData
    )
{
    const KERB_AUTHORIZATION_DATA * TempData = AuthData;

    while (TempData != NULL)
    {
        if (TempData->value.auth_data_type == (int) EntryId)
        {
            break;
        }
        TempData = TempData->next;
    }

    return TempData;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbFindPreAuthDataEntry
//
//  Synopsis:   Finds a specific entry in an authorization data structure
//
//  Effects:
//
//  Arguments:  EntryId - ID of the entry to locate
//              AuthData - the authorization data to search
//
//  Requires:
//
//  Returns:    NULL if it wasn't found of the auth data entry
//
//  Notes:
//
//
//--------------------------------------------------------------------------

PKERB_PA_DATA
KerbFindPreAuthDataEntry(
    IN ULONG EntryId,
    IN PKERB_PA_DATA_LIST AuthData
    )
{
    PKERB_PA_DATA_LIST TempData = AuthData;

    while (TempData != NULL)
    {
        if (TempData->value.preauth_data_type == (int) EntryId)
        {
            break;
        }
        TempData = TempData->next;
    }
    return(TempData  != NULL ? &TempData->value : NULL);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbFreePreAuthData
//
//  Synopsis:   Frees a pa-data list
//
//  Effects:
//
//  Arguments:  PreAuthData - data to free
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbFreePreAuthData(
    IN OPTIONAL PKERB_PA_DATA_LIST PreAuthData
    )
{
    PKERB_PA_DATA_LIST Next,Last;

    Next = PreAuthData;

    while (Next != NULL)
    {
        Last = Next->next;
        if (Next->value.preauth_data.value != NULL)
        {
            MIDL_user_free(Next->value.preauth_data.value);
        }
        MIDL_user_free(Next);
        Next = Last;
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbFreeAuthData
//
//  Synopsis:   Frees and auth data structure that was allocated in
//              pieces
//
//  Effects:    frees with MIDL_user_Free
//
//  Arguments:  AuthData - the auth data to free
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KerbFreeAuthData(
    IN PKERB_AUTHORIZATION_DATA AuthData
    )
{
    PKERB_AUTHORIZATION_DATA TempData1,TempData2;

    TempData1 = AuthData;
    while (TempData1 != NULL)
    {
        TempData2 = TempData1->next;
        if (TempData1->value.auth_data.value != NULL)
        {
            MIDL_user_free(TempData1->value.auth_data.value);
        }
        MIDL_user_free(TempData1);
        TempData1 = TempData2;
    }
}




//+-------------------------------------------------------------------------
//
//  Function:   KerbCopyAndAppendAuthData
//
//  Synopsis:   copies the elements from the input auth data and appends
//              them to the end of the output auth data.
//
//  Effects:    allocates each auth data with MIDL_user_allocate
//
//  Arguments:  OutputAuthData - receives list of append auth data
//              InputAuthData - optionally contains auth data to append
//
//  Requires:
//
//  Returns:    KDC_ERR_NONE or KRB_ERR_GENERIC;
//
//  Notes:      on failure output auth data will be freed and set to NULL.
//
//
//--------------------------------------------------------------------------


KERBERR
KerbCopyAndAppendAuthData(
    OUT PKERB_AUTHORIZATION_DATA * OutputAuthData,
    IN PKERB_AUTHORIZATION_DATA InputAuthData
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    PKERB_AUTHORIZATION_DATA  *LastEntry = OutputAuthData;
    PKERB_AUTHORIZATION_DATA TempEntry = NULL;

    //
    // Find the end of the list
    //

    while (*LastEntry != NULL)
    {
        LastEntry = &((*LastEntry)->next);
    }

    while (InputAuthData != NULL)
    {
        //
        // copy the existing entry
        //

        TempEntry = (PKERB_AUTHORIZATION_DATA) MIDL_user_allocate(sizeof(KERB_AUTHORIZATION_DATA));
        if (TempEntry == NULL)
        {
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }
        TempEntry->value.auth_data.length = InputAuthData->value.auth_data.length;
        TempEntry->value.auth_data_type = InputAuthData->value.auth_data_type;
        TempEntry->next = NULL;

        TempEntry->value.auth_data.value = (PUCHAR) MIDL_user_allocate(InputAuthData->value.auth_data.length);

        if (TempEntry->value.auth_data.value == NULL)
        {
            MIDL_user_free(TempEntry);
            goto Cleanup;
        }

        memcpy(
            TempEntry->value.auth_data.value,
            InputAuthData->value.auth_data.value,
            InputAuthData->value.auth_data.length
            );

        //
        // add it to the end of the list
        //

        *LastEntry = TempEntry;
        LastEntry = &TempEntry->next;
        InputAuthData = InputAuthData->next;
    }

    KerbErr = KDC_ERR_NONE;

Cleanup:
    if (!KERB_SUCCESS(KerbErr))
    {
        KerbFreeAuthData(*OutputAuthData);
        *OutputAuthData = NULL;
    }
    return(KerbErr);
}





//+-------------------------------------------------------------------------
//
//  Function:   KerbConvertCryptListToArray
//
//  Synopsis:   Converts a linked-list crypt vector to an array of ULONGs
//
//  Effects:    allocates return with MIDL_user_allocate
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KerbConvertCryptListToArray(
    OUT PULONG * ETypeArray,
    OUT PULONG ETypeCount,
    IN PKERB_CRYPT_LIST CryptList
    )

{
    KERBERR Status = KDC_ERR_NONE;
    PKERB_CRYPT_LIST NextEType;
    ULONG ClientETypeCount;
    PULONG ClientETypes = NULL;

    //
    // Build a vector of the client encrypt types
    //

    NextEType = CryptList;

    ClientETypeCount = 0;
    while (NextEType != NULL)
    {
        ClientETypeCount++;
        NextEType = NextEType->next;
    }

    ClientETypes = (PULONG) MIDL_user_allocate(sizeof(ULONG) * ClientETypeCount);
    if (ClientETypes == NULL)
    {
        Status = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    NextEType = CryptList;

    ClientETypeCount = 0;
    while (NextEType != NULL)
    {
        ClientETypes[ClientETypeCount] = NextEType->value;
        ClientETypeCount++;
        NextEType = NextEType->next;
    }
    *ETypeCount = ClientETypeCount;
    *ETypeArray = ClientETypes;

Cleanup:
    return(Status);

}


//+-------------------------------------------------------------------------
//
//  Function:   KerbConvertArrayToCryptList
//
//  Synopsis:   Converts an array of encryption to types to a linked list
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


KERBERR
KerbConvertArrayToCryptList(
    OUT PKERB_CRYPT_LIST * CryptList,
    IN PULONG ETypeArray,
    IN ULONG ETypeCount
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    ULONG Index;
    PKERB_CRYPT_LIST ListHead = NULL;
    PKERB_CRYPT_LIST ListTail = NULL;
    PKERB_CRYPT_LIST NewListEntry = NULL;

    //
    // If there no encryption types, bail out now.
    //

    if (ETypeCount == 0)
    {
        *CryptList = NULL;
        return(KDC_ERR_NONE);
    }

    for (Index = 0; Index < ETypeCount ; Index++ )
    {
        NewListEntry = (PKERB_CRYPT_LIST) MIDL_user_allocate(sizeof(KERB_CRYPT_LIST));
        if (NewListEntry == NULL)
        {
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }
        NewListEntry->value = ETypeArray[Index];
        NewListEntry->next = NULL;
        if (ListTail != NULL)
        {
            ListTail->next = NewListEntry;
        }
        else
        {
            DsysAssert(ListHead == NULL);
            ListHead = NewListEntry;
        }
        ListTail = NewListEntry;
    }

    *CryptList = ListHead;
    ListHead = NULL;

Cleanup:
    while (ListHead != NULL)
    {
        NewListEntry = ListHead->next;
        MIDL_user_free(ListHead);
        ListHead = NewListEntry;
    }

    return(KerbErr);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbConvertKeysToCryptList
//
//  Synopsis:   Converts an array of keys to types to a linked list
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


KERBERR
KerbConvertKeysToCryptList(
    OUT PKERB_CRYPT_LIST * CryptList,
    IN PKERB_STORED_CREDENTIAL Keys
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    ULONG Index;
    PKERB_CRYPT_LIST ListHead = NULL;
    PKERB_CRYPT_LIST ListTail = NULL;
    PKERB_CRYPT_LIST NewListEntry = NULL;

    //
    // If there no encryption types, bail out now.
    //

    if (Keys->CredentialCount == 0)
    {
        *CryptList = NULL;
        return(KDC_ERR_NONE);
    }

    for (Index = 0; Index < Keys->CredentialCount ; Index++ )
    {
        NewListEntry = (PKERB_CRYPT_LIST) MIDL_user_allocate(sizeof(KERB_CRYPT_LIST));
        if (NewListEntry == NULL)
        {
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }
        NewListEntry->value = Keys->Credentials[Index].Key.keytype;
        NewListEntry->next = NULL;
        if (ListTail != NULL)
        {
            ListTail->next = NewListEntry;
        }
        else
        {
            DsysAssert(ListHead == NULL);
            ListHead = NewListEntry;
        }
        ListTail = NewListEntry;
    }

    *CryptList = ListHead;
    ListHead = NULL;

Cleanup:
    while (ListHead != NULL)
    {
        NewListEntry = ListHead->next;
        MIDL_user_free(ListHead);
        ListHead = NewListEntry;
    }

    return(KerbErr);
}



//+-------------------------------------------------------------------------
//
//  Function:   KerbFreeCryptList
//
//  Synopsis:   Frees a list of crypt types
//
//  Effects:
//
//  Arguments:  CryptList - List to free
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbFreeCryptList(
    IN PKERB_CRYPT_LIST CryptList
    )
{
    PKERB_CRYPT_LIST ListHead = CryptList;
    PKERB_CRYPT_LIST NewListEntry;

    while (ListHead != NULL)
    {
        NewListEntry = ListHead->next;
        MIDL_user_free(ListHead);
        ListHead = NewListEntry;
    }

}



//+-------------------------------------------------------------------------
//
//  Function:   KerbCreateApRequest
//
//  Synopsis:   builds an AP request message
//
//  Effects:    allocates memory with MIDL_user_allocate
//
//  Arguments:  ClientName - Name of client
//              ClientRealm - Realm of client
//              SessionKey - Session key for the ticket
//              SubSessionKey - obtional sub Session key for the authenticator
//              Nonce - Nonce to use in authenticator
//              ServiceTicket - Ticket for service to put in request
//              ApOptions - Options to stick in AP request
//              GssChecksum - Checksum for GSS compatibility containing
//                      context options and delegation info.
//              KdcRequest - if TRUE, this is an AP request for a TGS req
//              ServerSkewTime - Optional skew of server's time
//              RequestSize - Receives size of the marshalled request
//              Request - Receives the marshalled request
//
//  Requires:
//
//  Returns:    KDC_ERR_NONE on success, KRB_ERR_GENERIC on memory or
//              marshalling failure
//
//  Notes:
//
//
//--------------------------------------------------------------------------



KERBERR
KerbCreateApRequest(
    IN IKerbCrypt   *piCrypt,
    IN PKERB_INTERNAL_NAME ClientName,
    IN PUNICODE_STRING ClientRealm,
    IN PKERB_ENCRYPTION_KEY SessionKey,
    IN OPTIONAL PKERB_ENCRYPTION_KEY SubSessionKey,
    IN ULONG Nonce,
    IN PKERB_TICKET ServiceTicket,
    IN ULONG ApOptions,
    IN OPTIONAL PKERB_CHECKSUM GssChecksum,
    IN OPTIONAL PTimeStamp ServerSkewTime,
    IN BOOLEAN KdcRequest,
    OUT PULONG RequestSize,
    OUT PUCHAR * Request
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    KERB_AP_REQUEST ApRequest;
    ULONG ApFlags;

    *Request = NULL;
    ZeroMemory(
        &ApRequest,
        sizeof(KERB_AP_REQUEST)
        );

    //
    // Fill in the AP request structure.
    //

    ApRequest.version = KERBEROS_VERSION;
    ApRequest.message_type = KRB_AP_REQ;
    ApFlags = KerbConvertUlongToFlagUlong(ApOptions);
    ApRequest.ap_options.value = (PUCHAR) &ApFlags;
    ApRequest.ap_options.length = sizeof(ULONG) * 8;
    ApRequest.ticket = *ServiceTicket;

    //
    // Create the authenticator for the request
    //



    KerbErr = KerbCreateAuthenticator(
                piCrypt,
                SessionKey,
                SessionKey->keytype,
                Nonce,
                ClientName,
                ClientRealm,
                ServerSkewTime,
                SubSessionKey,
                GssChecksum,
                KdcRequest,
                &ApRequest.authenticator
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"Failed to build authenticator: 0x%x\n",
            KerbErr ));
        goto Cleanup;
    }

    //
    // Now marshall the request
    //

    KerbErr = KerbPackApRequest(
                &ApRequest,
                RequestSize,
                Request
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"Failed to pack AP request: 0x%x\n",KerbErr));
        goto Cleanup;
    }

Cleanup:
    if (ApRequest.authenticator.cipher_text.value != NULL)
    {
        MIDL_user_free(ApRequest.authenticator.cipher_text.value);
    }
    return(KerbErr);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbInitAsn
//
//  Synopsis:   Initializes asn1 marshalling code
//
//  Effects:
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:    KDC_ERR_NONE on success, KRB_ERR_GENERIC on failure
//
//  Notes:
//
//
//--------------------------------------------------------------------------
BOOL fKRB5ModuleStarted = FALSE;

KERBERR
KerbInitAsn(
    IN OUT ASN1encoding_t * pEnc,
        IN OUT ASN1decoding_t * pDec
    )
{
    KERBERR KerbErr = KRB_ERR_GENERIC;
    ASN1error_e Asn1Err;

        if (!fKRB5ModuleStarted)
        {
                fKRB5ModuleStarted = TRUE;
                KRB5_Module_Startup();
        }

        if (pEnc != NULL)
        {
                Asn1Err = ASN1_CreateEncoder(
                                         KRB5_Module,
                                         pEnc,
                                         NULL,           // pbBuf
                                         0,              // cbBufSize
                                         NULL            // pParent
                                         );
        }
        else
        {
                Asn1Err = ASN1_CreateDecoder(
                                         KRB5_Module,
                                         pDec,
                                         NULL,           // pbBuf
                                         0,              // cbBufSize
                                         NULL            // pParent
                                         );
        }

        if (ASN1_SUCCESS != Asn1Err)
        {
                DebugLog((DEB_ERROR, "Failed to init ASN1: 0x%x\n",Asn1Err));
                goto Cleanup;
        }

    KerbErr = KDC_ERR_NONE;

Cleanup:

    return(KerbErr);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbTermAsn
//
//  Synopsis:   terminates an ASN world
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KerbTermAsn(
        IN ASN1encoding_t pEnc,
        IN ASN1decoding_t pDec
    )
{
    if (pEnc != NULL)
        {
                ASN1_CloseEncoder(pEnc);
        }
        else if (pDec != NULL)
        {
                ASN1_CloseDecoder(pDec);
        }

        //KRB5_Module_Cleanup();
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbPackData
//
//  Synopsis:   Packs a datatype using ASN.1 encoding
//
//  Effects:    allocates memory with MIDL_user_allocate
//
//  Arguments:  Data - The message to marshall/pack.
//              PduValue - The PDU for the message type
//              DataSize - receives the size of the marshalled message in
//                      bytes.
//              MarshalledData - receives a pointer to the marshalled
//                      message buffer.
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR NTAPI
KerbPackData(
    IN PVOID Data,
    IN ULONG PduValue,
    OUT PULONG DataSize,
    OUT PUCHAR * MarshalledData
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    ASN1encoding_t pEnc = NULL;
        ASN1error_e Asn1Err;

    KerbErr = KerbInitAsn(
                &pEnc,          // we are encoding
                NULL
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    //
    // Encode the data type.
    //

    D_DebugLog((DEB_TRACE,"encoding pdu #%d\n",PduValue));
    Asn1Err = ASN1_Encode(
                pEnc,
                Data,
                PduValue,
                ASN1ENCODE_ALLOCATEBUFFER,
                NULL,                       // pbBuf
                0                           // cbBufSize
                );

    if (!ASN1_SUCCEEDED(Asn1Err))
    {
        DebugLog((DEB_ERROR,"Failed to encode data: %d\n",Asn1Err));
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }
    else
    {
        //
        // when the oss compiler was used the allocation routines were configurable.
        // therefore, the encoded data could just be free'd using our
        // deallocator.  in the new model we cannot configure the allocation routines
        // for encoding.

        // so we do not have to go and change every place where a free
        // of an encoded buffer is done, use our allocator to allocate a new buffer,
        // then copy the encoded data to it, and free the buffer that was allocated by
        // the encoding engine.  THIS SHOULD BE CHANGED FOR BETTER PERFORMANCE
        //

        *MarshalledData = (PUCHAR) MIDL_user_allocate(pEnc->len);
        if (*MarshalledData == NULL)
        {
            KerbErr = KRB_ERR_GENERIC;
            *DataSize = 0;
        }
        else
        {
            memcpy(*MarshalledData, pEnc->buf, pEnc->len);
            *DataSize = pEnc->len;

        }

        ASN1_FreeEncoded(pEnc, pEnc->buf);
    }

Cleanup:

    KerbTermAsn(pEnc, NULL);

    return(KerbErr);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbUnpackData
//
//  Synopsis:   Unpacks an message from the ASN.1 encoding
//
//  Effects:
//
//  Arguments:  Data - Buffer containing the reply message.
//              DataSize - Size of the reply message in bytes
//              Reply - receives a KERB_ENCRYPTED_DATA structure allocated with
//                      MIDL_user_allocate.
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR NTAPI
KerbUnpackData(
    IN const UCHAR * Data,
    IN ULONG DataSize,
    IN ULONG PduValue,
    OUT PVOID * DecodedData
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    ASN1decoding_t pDec = NULL;
    ASN1error_e Asn1Err;

    if ((DataSize == 0) || (Data == NULL))
    {
        DebugLog((DEB_ERROR,"Trying to unpack NULL data\n"));
        return KRB_ERR_GENERIC;
    }

    KerbErr = KerbInitAsn(
                  NULL,
                  &pDec           // we are decoding
                  );

    if (!KERB_SUCCESS(KerbErr))
    {
        return KerbErr;
    }

    *DecodedData = NULL;
    Asn1Err = ASN1_Decode(
                  pDec,
                  DecodedData,
                  PduValue,
                  ASN1DECODE_SETBUFFER,
                  const_cast<BYTE *>(Data),
                  DataSize
                  );

    if (!ASN1_SUCCEEDED(Asn1Err))
    {
        if ((ASN1_ERR_BADARGS == Asn1Err) ||
            (ASN1_ERR_EOD == Asn1Err))
        {
            D_DebugLog((DEB_TRACE,"More input required to decode data %d.\n",PduValue));
            KerbErr = KDC_ERR_MORE_DATA;
        }
        else
        {
            if (ASN1_ERR_BADTAG != Asn1Err)
            {
                DebugLog((DEB_ERROR,"Failed to decode data: %d\n", Asn1Err ));
            }
            KerbErr = KRB_ERR_GENERIC;
        }

        *DecodedData = NULL;
    }

    KerbTermAsn(NULL, pDec);

    return KerbErr;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbFreeData
//
//  Synopsis:   Frees a structure unpacked by the ASN1 decoder
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbFreeData(
    IN ULONG PduValue,
    IN PVOID Data
    )
{
    ASN1decoding_t pDec = NULL;

    if (ARGUMENT_PRESENT(Data))
    {
        KERBERR KerbErr;
        KerbErr = KerbInitAsn(
                      NULL,
                      &pDec       // this is a decoded structure
                      );

        if (KERB_SUCCESS(KerbErr))
        {
            ASN1_FreeDecoded(pDec, Data, PduValue);

            KerbTermAsn(NULL, pDec);
        }
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbFreeTicketExtensions
//
//  Synopsis:   Frees a host address  allocated with KerbDuplicateTicketExtensions
//
//  Effects:
//
//  Arguments:  Addresses - The name to free
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbFreeTicketExtensions(
    IN PKERB_TICKET_EXTENSIONS Extensions
    )
{
    PKERB_TICKET_EXTENSIONS Elem,NextElem;

    Elem = Extensions;
    while (Elem != NULL)
    {
        if (Elem->value.te_data.value != NULL)
        {
            MIDL_user_free(Elem->value.te_data.value);
        }
        NextElem = Elem->next;
        MIDL_user_free(Elem);
        Elem = NextElem;
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbDuplicateTicketExtensions
//
//  Synopsis:   duplicates the ticket extensions field from a ticket
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KerbDuplicateTicketExtensions(
    OUT PKERB_TICKET_EXTENSIONS * Dest,
    IN const KERB_TICKET_EXTENSIONS * Source
    )
{
    KERBERR Status = KDC_ERR_NONE;
    const KERB_TICKET_EXTENSIONS  * SourceElem;
    PKERB_TICKET_EXTENSIONS DestElem;
    PKERB_TICKET_EXTENSIONS * NextElem;

    *Dest = NULL;

    SourceElem = Source;
    NextElem = Dest;

    while (SourceElem != NULL)
    {
        DestElem = (PKERB_TICKET_EXTENSIONS) MIDL_user_allocate(sizeof(KERB_TICKET_EXTENSIONS));
        if (DestElem == NULL)
        {
            Status = KRB_ERR_GENERIC;
            goto Cleanup;
        }
        *DestElem = *SourceElem;
        DestElem->value.te_data.value = (PUCHAR) MIDL_user_allocate(SourceElem->value.te_data.length);
        if (DestElem->value.te_data.value == NULL)
        {
            MIDL_user_free(DestElem);
            Status = KRB_ERR_GENERIC;
            goto Cleanup;
        }
        memcpy(
            DestElem->value.te_data.value,
            SourceElem->value.te_data.value,
            SourceElem->value.te_data.length
            );
        DestElem->next = NULL;
        *NextElem = DestElem;
        NextElem = &DestElem->next;
        SourceElem = SourceElem->next;
    }

Cleanup:

    if (!KERB_SUCCESS(Status))
    {
        KerbFreeTicketExtensions(*Dest);
        *Dest = NULL;
    }

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbDuplicateTicket
//
//  Synopsis:   Duplicates a ticket so the original may be freed
//
//  Effects:
//
//  Arguments:  Dest - Destination, receives duplicate
//              Source - Source ticket
//
//  Requires:
//
//  Returns:    KDC_ERR_NONE or KRB_ERR_GENERIC;
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR NTAPI
KerbDuplicateTicket(
    OUT PKERB_TICKET Dest,
    IN const KERB_TICKET * Source
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;

    ZeroMemory(
        Dest,
        sizeof(KERB_TICKET)
        );

    Dest->ticket_version = Source->ticket_version;
    KerbErr = KerbDuplicatePrincipalName(
                  &Dest->server_name,
                  &Source->server_name
                  );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    KerbErr = KerbDuplicateRealm(
                  &Dest->realm,
                  Source->realm
                  );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    KerbErr = KerbDuplicateTicketExtensions(
                &Dest->ticket_extensions,
                Source->ticket_extensions
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    Dest->encrypted_part = Source->encrypted_part;
    Dest->encrypted_part.cipher_text.value = (PUCHAR) MIDL_user_allocate(Dest->encrypted_part.cipher_text.length);
    if (Dest->encrypted_part.cipher_text.value == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    memcpy(
        Dest->encrypted_part.cipher_text.value,
        Source->encrypted_part.cipher_text.value,
        Dest->encrypted_part.cipher_text.length
        );

Cleanup:

    if (!KERB_SUCCESS(KerbErr))
    {
        KerbFreeDuplicatedTicket(Dest);
    }

    return KerbErr;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbFreeDuplicatedTicket
//
//  Synopsis:   Frees ticket duplicated with KerbDuplicateTicket
//
//  Effects:    frees memory
//
//  Arguments:  Ticket - ticket to free
//
//  Requires:
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbFreeDuplicatedTicket(
    IN PKERB_TICKET Ticket
    )
{
    KerbFreePrincipalName(
        &Ticket->server_name
        );
    KerbFreeRealm(
        &Ticket->realm
        );
    if (Ticket->encrypted_part.cipher_text.value != NULL)
    {
        MIDL_user_free(Ticket->encrypted_part.cipher_text.value);
    }
    KerbFreeTicketExtensions(
        Ticket->ticket_extensions
        );
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbBuildErrorMessageEx
//
//  Synopsis:   Builds an error message
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:    marshalled error message, to be freed with MIDL_user_free
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KerbBuildErrorMessageEx(
    IN KERBERR ErrorCode,
    IN OPTIONAL const KERB_EXT_ERROR * pExtendedError,
    IN const UNICODE_STRING * ServerRealm,
    IN const KERB_INTERNAL_NAME * ServerName,
    IN OPTIONAL const UNICODE_STRING * ClientRealm,
    IN OPTIONAL const BYTE * ErrorData,
    IN ULONG ErrorDataSize,
    OUT PULONG ErrorMessageSize,
    OUT PUCHAR * ErrorMessage
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    KERB_ERROR Error;
    PBYTE ExtErrorData = NULL;
    ULONG ExtErrorSize = 0;
    TimeStamp TimeNow;

    GetSystemTimeAsFileTime(
        (PFILETIME) &TimeNow
        );

    ZeroMemory(
        &Error,
        sizeof(KERB_ERROR)
        );

    DsysAssert(ErrorCode != KDC_ERR_MORE_DATA);

    Error.version = KERBEROS_VERSION;
    Error.message_type = KRB_ERROR;

    KerbConvertLargeIntToGeneralizedTime(
        &Error.server_time,
        &Error.server_usec,
        &TimeNow
        );

    Error.error_code = ErrorCode;

    //
    // Ignore errors because this is already an error return
    //
    if (ServerRealm)
    {
        KerbErr = KerbConvertUnicodeStringToRealm(
                      &Error.realm,
                      ServerRealm
                      );
        if ( !KERB_SUCCESS( KerbErr ))
        {
            goto Cleanup;
        }
    }


    if (ARGUMENT_PRESENT(ClientRealm) && (ClientRealm->Buffer != NULL))
    {
        KerbErr = KerbConvertUnicodeStringToRealm(
                      &Error.client_realm,
                      ClientRealm
                      );

        if ( !KERB_SUCCESS( KerbErr ))
        {
            goto Cleanup;
        }

        Error.bit_mask |= client_realm_present;
    }

    if (ServerName)
    {
        KerbErr = KerbConvertKdcNameToPrincipalName(
                      &Error.server_name,
                      ServerName
                      );

        if ( !KERB_SUCCESS( KerbErr ))
        {
            goto Cleanup;
        }
    }

#ifndef XBOX_KDC
    //
    // Small problem here.  We may have preauth data that we want
    // to return to the client, instead of extended errors.  To
    // avoid this, we just make sure that we only return extended
    // errors if no ErrorData previously set.
    //
    if (ARGUMENT_PRESENT(ErrorData))
    {
        Error.error_data.length = (int) ErrorDataSize;
        Error.error_data.value = const_cast<ASN1octet_t *>(ErrorData);
        Error.bit_mask |= error_data_present;
    }
    else if (ARGUMENT_PRESENT(pExtendedError) && !EXT_ERROR_SUCCESS((*pExtendedError)))
    {
       KerbErr = KerbBuildExtendedError(
                     pExtendedError,
                     &ExtErrorSize,
                     &ExtErrorData
                     );

       if (!KERB_SUCCESS(KerbErr)) // Don't add err on failure
       {
          DebugLog((DEB_WARN, "Failed To pack extended error!\n"));
          goto Cleanup;
       }

       Error.bit_mask |= error_data_present;
       Error.error_data.length = (int) ExtErrorSize;
       Error.error_data.value = ExtErrorData;
    }
#else

    // Okay. pExtendedError is passed around everywhere. Some code sets "status" to the nt 
    // status and "flags" to the line number. Other, more correct, code uses 
    // FILL_EXT_ERROR to set "status" to the nt status, "klininfo" to the file # & line # 
    // using the KILIN() macro.
    //
    // Despite all of this, we NEVER use the extended error. We do not return it to the 
    // client in any way, nor would the client interpret it correctly anyway. It does not 
    // understand the KERB_ERROR_METHOD_DATA structure.
    //
    // So we're going to hack up the extended error to represent the data, which can be up 
    // to 40 bytes, that needs to be returned to the client for the KRB5_PADATA_XBOX_ECHO 
    // preauth structure. This is all the extended error is used for. It must be returned 
    // in the error_data structure of the error message. The easiest and safest way to 
    // hack it up was to simply add fields to it for the echo data.

    if (ErrorCode == KDC_ERR_PREAUTH_REQUIRED &&
        ARGUMENT_PRESENT(pExtendedError) && 
        pExtendedError->echo_length > 0)
    {
        assert(pExtendedError->echo_length <= sizeof(pExtendedError->echo_data));

        Error.bit_mask |= error_data_present;
        Error.error_data.length = pExtendedError->echo_length;
        Error.error_data.value = (ASN1octet_t*)(pExtendedError->echo_data);
    }
    
    // This should be the nonce of the request. 
    Error.error_text.length = (int) ErrorDataSize;
    Error.error_text.value = (ASN1char_t *)(ErrorData);
    Error.bit_mask |= error_text_present;
#endif

Cleanup:

    KerbErr = KerbPackData(
                  &Error,
                  KERB_ERROR_PDU,
                  ErrorMessageSize,
                  ErrorMessage
                  );

    KerbFreeRealm(
        &Error.realm
        );

    KerbFreeRealm(
        &Error.client_realm
        );

    KerbFreePrincipalName(
        &Error.server_name
        );

    if (NULL != ExtErrorData)
    {
       MIDL_user_free(ExtErrorData);
    }

    return KerbErr;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbBuildExtendedError
//
//  Synopsis:   Packs the extended error data structure into a
//              KERB_ERROR_METHOD_DATA structure for return to
//              client
//
//  Effects:
//
//  Arguments:  pExtendedError, pointer to extended error
//
//  Requires:
//
//  Returns:    KERBERR to indicate successful packing
//
//--------------------------------------------------------------------------

KERBERR
KerbBuildExtendedError(
   IN const KERB_EXT_ERROR * pExtendedError,
   OUT PULONG ExtErrorSize,
   OUT PBYTE * ExtErrorData
   )
{
   KERB_ERROR_METHOD_DATA  ErrorMethodData;
   KERBERR  KerbErr;

   ErrorMethodData.bit_mask = 0;
   ErrorMethodData.data_type = KERB_ERR_TYPE_EXTENDED;
   ErrorMethodData.bit_mask |= data_value_present;
   ErrorMethodData.data_value.value = (PBYTE) pExtendedError;
   ErrorMethodData.data_value.length = sizeof(KERB_EXT_ERROR);

   KerbErr = KerbPackData(
                 &ErrorMethodData,
                 KERB_ERROR_METHOD_DATA_PDU,
                 ExtErrorSize,
                 ExtErrorData
                 );

   return KerbErr;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbGetKeyFromList
//
//  Synopsis:   Gets the key of the appropriate encryption type off the list
//
//  Effects:
//
//  Arguments:  Passwords - list of keys
//              EncryptionType - Encryption type to use
//
//  Requires:
//
//  Returns:    The found key, or NULL if one wasn't found
//
//  Notes:
//
//
//--------------------------------------------------------------------------

const KERB_ENCRYPTION_KEY *
KerbGetKeyFromList(
    IN const KERB_STORED_CREDENTIAL * Passwords,
    IN ULONG EncryptionType
    )
{
    ULONG Index;

    if (!ARGUMENT_PRESENT(Passwords))
    {
        return NULL;
    }

    for (Index = 0; Index < Passwords->CredentialCount ; Index++ )
    {
        if (Passwords->Credentials[Index].Key.keytype == (int) EncryptionType)
        {
            return &Passwords->Credentials[Index].Key;
        }
    }

    return NULL;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbGetKeyFromListEx
//
//  Synopsis:   Locate key in list and return it.
//
//  Effects:
//
//  Arguments:  Passwords - list of keys
//              EncryptionType - Encryption type to use
//
//  Requires:
//
//  Returns:    The found key, or NULL if one wasn't found
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbGetKeyFromListEx(
    IN const KERB_STORED_CREDENTIAL * Passwords,
    IN ULONG EncryptionType,
    OUT const KERB_KEY_DATA * * KeyData
    )
{
    ULONG Index;

    if (!ARGUMENT_PRESENT(Passwords))
    {
        return STATUS_INVALID_PARAMETER_1;
    }

    for (Index = 0; Index < Passwords->CredentialCount; Index++)
    {
        if (Passwords->Credentials[Index].Key.keytype == (int) EncryptionType)
        {
            *KeyData = &Passwords->Credentials[Index];
            return STATUS_SUCCESS;
        }
    }

    return STATUS_NOT_FOUND;
}


NTSTATUS
KerbGetKeyFromListEx(
    IN const KERB_STORED_CREDENTIAL * Passwords,
    IN ULONG EncryptionType,
    OUT const KERB_ENCRYPTION_KEY * * Key
    )
{
    ULONG Index;

    if (!ARGUMENT_PRESENT(Passwords))
    {
        return STATUS_INVALID_PARAMETER_1;
    }

    for (Index = 0; Index < Passwords->CredentialCount ; Index++ )
    {
        if (Passwords->Credentials[Index].Key.keytype == (int) EncryptionType)
        {
            *Key = &Passwords->Credentials[Index].Key;
            return STATUS_SUCCESS;
        }
    }

    return STATUS_NOT_FOUND;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbFindCommonCryptSystem
//
//  Synopsis:   Finds a common crypt system including availablity
//              of passwords.
//
//  Effects:
//
//  Arguments:  CryptList - List of client's crypto systems
//              Passwords - List of passwords
//              MorePassword - Optionally another list of passwords to consider
//              CommonCryptSystem - Receives common crypo system ID
//              Key - Receives key for common crypt system
//
//  Requires:
//
//  Returns:    KDC_ERR_ETYPE_NOTSUPP if no common system can be found
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KerbFindCommonCryptSystem(
    IN const KERB_CRYPT_LIST * CryptList,
    IN const KERB_STORED_CREDENTIAL * Passwords,
    IN OPTIONAL const KERB_STORED_CREDENTIAL * MorePasswords,
    OUT PULONG CommonCryptSystem,
    OUT const KERB_KEY_DATA * * Key
    )
{
    ULONG PasswordTypes[KERB_MAX_CRYPTO_SYSTEMS] = {0};
    PULONG pCryptoSystems = NULL;
    ULONG CryptoSystems[KERB_MAX_CRYPTO_SYSTEMS];
    ULONG PasswordCount;
    ULONG CryptoCount;
    ULONG Index;
    const KERB_CRYPT_LIST * NextEType;
    ULONG Index2;
    ULONG CredentialCount;
    KERBERR KerbErr = KDC_ERR_ETYPE_NOTSUPP;

    if ((Passwords == NULL ) || (CryptList == NULL))
    {
        DebugLog((DEB_ERROR, "Null password or crypt list passed to KerbFindCommonCryptSystem\n"));
        return KDC_ERR_ETYPE_NOTSUPP;
    }

    PasswordCount = Passwords->CredentialCount;

    if (PasswordCount >= KERB_MAX_CRYPTO_SYSTEMS)
    {
        D_DebugLog((DEB_ERROR, "Got more than 20 crypto systems in password list\n"));
        DsysAssert(PasswordCount < KERB_MAX_CRYPTO_SYSTEMS);
        return KDC_ERR_ETYPE_NOTSUPP;
    }

    CredentialCount = 0;
    for (Index = 0; Index < PasswordCount ; Index++ )
    {
        if (ARGUMENT_PRESENT(MorePasswords))
        {
            for (Index2 = 0; Index2 < MorePasswords->CredentialCount; Index2++ )
            {
                if (Passwords->Credentials[Index].Key.keytype == MorePasswords->Credentials[Index2].Key.keytype)
                {
                    PasswordTypes[CredentialCount++] = (ULONG) Passwords->Credentials[Index].Key.keytype;
                    break;
                }
            }
        }
        else
        {
            PasswordTypes[CredentialCount++] = (ULONG) Passwords->Credentials[Index].Key.keytype;
        }
    }

    CryptoCount = 0;
    NextEType = CryptList;

    while (NextEType != NULL)
    {
        NextEType = NextEType->next;
        CryptoCount++;

        // restrict to 100 crypt systems, even on a slowbuffer.
        if (CryptoCount > KERB_MAX_CRYPTO_SYSTEMS_SLOWBUFF)
        {
            return KDC_ERR_ETYPE_NOTSUPP;
        }
    }

    if (CryptoCount >= KERB_MAX_CRYPTO_SYSTEMS)
    {
        pCryptoSystems = (PULONG) MIDL_user_allocate(CryptoCount * sizeof(ULONG));
        if (NULL == pCryptoSystems)
        {
            return KRB_ERR_GENERIC;
        }
    }
    else // fast buff
    {
        pCryptoSystems = CryptoSystems;
    }

    //
    // populate values
    //

    NextEType = CryptList;
    Index = 0;

    while (NextEType != NULL)
    {
        pCryptoSystems[Index] = NextEType->value;
        NextEType = NextEType->next;
        Index++;
    }

    DsysAssert(Index == CryptoCount);

    if (!NT_SUCCESS(CDFindCommonCSystemWithKey(
            CryptoCount,
            pCryptoSystems,
            PasswordCount,
            PasswordTypes,
            CommonCryptSystem
            )))
    {
        DebugLog((DEB_ERROR, "KLIN(%x) Missing common crypt system\n", KLIN(FILENO, __LINE__)));
        goto Cleanup;
    }

    //
    // Now find the key to return.
    //

    for (Index = 0; Index < Passwords->CredentialCount ; Index++ )
    {
        if (Passwords->Credentials[Index].Key.keytype == (int) *CommonCryptSystem)
        {
            *Key = &Passwords->Credentials[Index];
            KerbErr = KDC_ERR_NONE;
        }
    }

    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"KLIN(%x) Couldn't find password type after finding common csystem!\n",
                  KLIN(FILENO, __LINE__)));
    }

Cleanup:

    if ((pCryptoSystems != NULL) &&
        (pCryptoSystems != CryptoSystems))
    {
        MIDL_user_free(pCryptoSystems);
    }

    return KerbErr;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbMapKerbError
//
//  Synopsis:   Maps a kerb error to an NTSTATUS
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbMapKerbError(
    IN KERBERR KerbError
    )
{
    NTSTATUS Status;
    switch(KerbError) {
    case KDC_ERR_NONE:
        Status = STATUS_SUCCESS;
        break;
    case KDC_ERR_CLIENT_REVOKED:
        Status = STATUS_ACCOUNT_DISABLED;
        break;
    case KDC_ERR_KEY_EXPIRED:
        Status = STATUS_PASSWORD_EXPIRED;
        break;
    case KRB_ERR_GENERIC:
        Status = STATUS_INSUFFICIENT_RESOURCES;
        break;
    case KRB_AP_ERR_SKEW:
    case KRB_AP_ERR_TKT_NYV:
    // Note this was added because of the following scenario:
    // Let's say the dc and the client have the correct time. And the
    // server's time is off. We aren't going to get rid of the ticket for the
    // server on the client because it hasn't expired yet. But, the server
    // thinks it has. If event logging was turned on, then admins could look
    // at the server's event log and potentially deduce that the server's
    // time is off relative to the dc.
    case KRB_AP_ERR_TKT_EXPIRED:
        Status = STATUS_TIME_DIFFERENCE_AT_DC;
        break;
    case KDC_ERR_POLICY:
        Status = STATUS_ACCOUNT_RESTRICTION;
        break;
    case KDC_ERR_C_PRINCIPAL_UNKNOWN:
        Status = STATUS_NO_SUCH_USER;
        break;
    case KDC_ERR_S_PRINCIPAL_UNKNOWN:
        Status = STATUS_NO_TRUST_SAM_ACCOUNT;
        break;
    case KRB_AP_ERR_MODIFIED:
    case KDC_ERR_PREAUTH_FAILED:
        Status = STATUS_WRONG_PASSWORD;
        break;
    case KRB_ERR_RESPONSE_TOO_BIG:
        Status = STATUS_INVALID_BUFFER_SIZE;
        break;
    case KDC_ERR_PADATA_TYPE_NOSUPP:
        Status = STATUS_NOT_SUPPORTED;
        break;
    case KRB_AP_ERR_NOT_US:
        Status = SEC_E_WRONG_PRINCIPAL;
        break;

    case KDC_ERR_SVC_UNAVAILABLE:
        Status = STATUS_NO_LOGON_SERVERS;
        break;
    case KDC_ERR_WRONG_REALM:
        Status = STATUS_NO_LOGON_SERVERS;
        break;
    case KDC_ERR_CANT_VERIFY_CERTIFICATE:
        Status = TRUST_E_SYSTEM_ERROR;
        break;
    case KDC_ERR_INVALID_CERTIFICATE:
        Status = STATUS_INVALID_PARAMETER;
        break;
    case KDC_ERR_REVOKED_CERTIFICATE:
        Status = CRYPT_E_REVOKED;
        break;
    case KDC_ERR_REVOCATION_STATUS_UNKNOWN:
        Status = CRYPT_E_NO_REVOCATION_CHECK;
        break;
    case KDC_ERR_REVOCATION_STATUS_UNAVAILABLE:
        Status = CRYPT_E_REVOCATION_OFFLINE;
        break;
    case KDC_ERR_CLIENT_NAME_MISMATCH:
    case KERB_PKINIT_CLIENT_NAME_MISMATCH:
    case KDC_ERR_KDC_NAME_MISMATCH:
        Status = STATUS_PKINIT_NAME_MISMATCH;
        break;
    case KDC_ERR_PATH_NOT_ACCEPTED:
        Status = STATUS_TRUST_FAILURE;
        break;
    case KDC_ERR_ETYPE_NOTSUPP:
        Status = STATUS_KDC_UNKNOWN_ETYPE;
        break;
    case KRB_AP_ERR_NOKEY:
        Status = STATUS_NO_KERB_KEY;
        break;
    default:
        Status = STATUS_LOGON_FAILURE;
    }

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbMakeDomainRelativeSid
//
//  Synopsis:   Given a domain Id and a relative ID create the corresponding
//              SID allocated with MIDL_user_allocate.
//
//  Effects:
//
//  Arguments:  DomainId - The template SID to use.
//
//                  RelativeId - The relative Id to append to the DomainId.
//
//  Requires:
//
//  Returns:    Sid - Returns a pointer to a buffer allocated from
//              MIDL_user_allocate containing the resultant Sid.
//
//  Notes:
//
//
//--------------------------------------------------------------------------

PSID
KerbMakeDomainRelativeSid(
    IN PSID DomainId,
    IN ULONG RelativeId
    )
{
    UCHAR DomainIdSubAuthorityCount;
    ULONG Size;
    PSID Sid;

    //
    // Allocate a Sid which has one more sub-authority than the domain ID.
    //

    DomainIdSubAuthorityCount = *(RtlSubAuthorityCountSid( DomainId ));
    Size = RtlLengthRequiredSid(DomainIdSubAuthorityCount+1);

    if ((Sid = MIDL_user_allocate( Size )) == NULL )
    {
        return NULL;
    }

    //
    // Initialize the new SID to have the same inital value as the
    // domain ID.
    //

    if ( !NT_SUCCESS( RtlCopySid( Size, Sid, DomainId ) ) ) {
        MIDL_user_free( Sid );
        return NULL;
    }

    //
    // Adjust the sub-authority count and
    //  add the relative Id unique to the newly allocated SID
    //

    (*(RtlSubAuthorityCountSid( Sid ))) ++;
    *RtlSubAuthoritySid( Sid, DomainIdSubAuthorityCount ) = RelativeId;

    return Sid;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbFreeCertificateList
//
//  Synopsis:   Frees a list of certificates created by KerbCreateCertificateList
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbFreeCertificateList(
    IN PKERB_CERTIFICATE_LIST Certificates
    )
{
    PKERB_CERTIFICATE_LIST Last,Next;

    Last = NULL;
    Next = Certificates;
    while (Next != NULL)
    {
        Last = Next;
        Next = Next->next;
        if (Last->value.cert_data.value != NULL)
        {
            MIDL_user_free(Last->value.cert_data.value);
        }
        MIDL_user_free(Last);
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbCreateCertificateList
//
//  Synopsis:   Creates a list of certificates from a cert context
//
//  Effects:
//
//  Arguments:  Certficates - receives list of certificates.
//              CertContext - Context containing certificates
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KerbCreateCertificateList(
    OUT PKERB_CERTIFICATE_LIST * Certificates,
    IN PCCERT_CONTEXT CertContext
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    PKERB_CERTIFICATE_LIST ListEntry = NULL;

    if (!ARGUMENT_PRESENT(CertContext))
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }
    //
    // Croft up a bogus certificate entry
    //

    ListEntry = (PKERB_CERTIFICATE_LIST) MIDL_user_allocate(sizeof(KERB_CERTIFICATE_LIST));
    if (ListEntry == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }
    ListEntry->next = NULL;
    ListEntry->value.cert_type = KERB_CERTIFICATE_TYPE_X509;
    ListEntry->value.cert_data.length = CertContext->cbCertEncoded;
    ListEntry->value.cert_data.value = (PUCHAR) MIDL_user_allocate(ListEntry->value.cert_data.length);
    if (ListEntry->value.cert_data.value == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }
    memcpy(
        ListEntry->value.cert_data.value,
        CertContext->pbCertEncoded,
        CertContext->cbCertEncoded
        );
    *Certificates = ListEntry;
    ListEntry = NULL;

Cleanup:

    KerbFreeCertificateList(ListEntry);
    return KerbErr;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbConvertFlagsToUlong
//
//  Synopsis:   Converts a bit-stream flags field into a ULONG
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

ULONG
KerbConvertFlagsToUlong(
    IN const VOID * Flags
    )
{
    ULONG Output = 0;
    PUCHAR OutputPointer = &((PUCHAR) &Output)[3];
    ULONG Index = 0;
    PKERB_TICKET_FLAGS InternalFlags = (PKERB_TICKET_FLAGS) Flags;
    ULONG InternalLength;

    if (InternalFlags->length > 32)
    {
        InternalLength = 32;
    }
    else
    {
        InternalLength = (ULONG) InternalFlags->length;
    }

    while (InternalLength > 7)
    {
        *OutputPointer = InternalFlags->value[Index++];
        OutputPointer--;
        InternalLength -= 8;
    }

    //
    // Copy the remaining bits, masking off what should be zero
    //

    if (InternalLength != 0)
    {
        *OutputPointer = (UCHAR) (InternalFlags->value[Index] & ~((1 << (8-InternalLength)) - 1));
    }

    return Output;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbConvertUlongToFlagUlong
//
//  Synopsis:   Converts the byte order of a ULONG into that used by flags
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

ULONG
KerbConvertUlongToFlagUlong(
    IN ULONG Flag
    )
{
    ULONG ReturnFlag;

    ((PUCHAR) &ReturnFlag)[0] = ((PUCHAR) &Flag)[3];
    ((PUCHAR) &ReturnFlag)[1] = ((PUCHAR) &Flag)[2];
    ((PUCHAR) &ReturnFlag)[2] = ((PUCHAR) &Flag)[1];
    ((PUCHAR) &ReturnFlag)[3] = ((PUCHAR) &Flag)[0];

    return ReturnFlag;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbCompareObjectIds
//
//  Synopsis:   Compares two object IDs for equality
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

BOOLEAN
KerbCompareObjectIds(
    IN const KERB_OBJECT_ID * Object1,
    IN const KERB_OBJECT_ID * Object2
    )
{
    while (Object1 != NULL)
    {
        if (Object2 == NULL)
        {
            return FALSE;
        }

        if (Object1->value != Object2->value)
        {
            return FALSE;
        }

        Object1 = Object1->next;
        Object2 = Object2->next;
    }

    if (Object2 != NULL)
    {
        return FALSE;
    }
    else
    {
        return TRUE;
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   KdcGetClientNetbiosAddress
//
//  Synopsis:   Gets the client's netbios address from the list of
//              addresses it sends.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KerbGetClientNetbiosAddress(
    OUT PUNICODE_STRING ClientNetbiosAddress,
    IN const KERB_HOST_ADDRESSES * Addresses
    )
{
    const KERB_HOST_ADDRESSES * TempAddress = Addresses;
    STRING TempString;
    KERBERR KerbErr;

    RtlInitUnicodeString(
        ClientNetbiosAddress,
        NULL
        );

    while (TempAddress != NULL)
    {
        //
        // Check for netbios
        //

        if (TempAddress->value.address_type == KERB_ADDRTYPE_NETBIOS)
        {
            //
            // Copy out the string
            //

            TempString.Buffer = (PCHAR) TempAddress->value.address.value;
            TempString.Length = TempString.MaximumLength = (USHORT) TempAddress->value.address.length;

            KerbErr = KerbStringToUnicodeString(
                        ClientNetbiosAddress,
                        &TempString
                        );

            if (KERB_SUCCESS(KerbErr))
            {
                //
                // Strip trailing spaces
                //

                if (ClientNetbiosAddress->Length >= sizeof(WCHAR))
                {
                    while ((ClientNetbiosAddress->Length > 0) &&
                           (ClientNetbiosAddress->Buffer[(ClientNetbiosAddress->Length / sizeof(WCHAR))-1] == L' '))
                    {
                        ClientNetbiosAddress->Length -= sizeof(WCHAR);
                    }

                    return KDC_ERR_NONE;
                }
            }
            else
            {
                return KerbErr;
            }

        }

        TempAddress = TempAddress->next;
    }

    //
    // It is o.k. to not have a netbios name
    //

    return KDC_ERR_NONE;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbGetPacFromAuthData
//
//  Synopsis:   Gets the PAC from the auth data list
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KerbGetPacFromAuthData(
    IN const KERB_AUTHORIZATION_DATA * AuthData,
    OUT PKERB_IF_RELEVANT_AUTH_DATA * * ReturnIfRelevantData,
    OUT const KERB_AUTHORIZATION_DATA * * Pac
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    const KERB_AUTHORIZATION_DATA * PacAuthData = NULL;
    const KERB_AUTHORIZATION_DATA * RelevantAuthData = NULL;
    PKERB_IF_RELEVANT_AUTH_DATA * IfRelevantData = NULL;

    *ReturnIfRelevantData = NULL;
    *Pac = NULL;

    //
    // Look for the if-relevant data
    //

    RelevantAuthData = KerbFindAuthDataEntry(
                           KERB_AUTH_DATA_IF_RELEVANT,
                           AuthData
                           );

    if (RelevantAuthData != NULL)
    {
        //
        // Unpack it
        //

        KerbErr = KerbUnpackData(
                    RelevantAuthData->value.auth_data.value,
                    RelevantAuthData->value.auth_data.length,
                    PKERB_IF_RELEVANT_AUTH_DATA_PDU,
                    (PVOID *) &IfRelevantData
                    );

        if (KERB_SUCCESS(KerbErr))
        {
            //
            // Look for the PAC in the if-relevant data
            //

            PacAuthData = KerbFindAuthDataEntry(
                              KERB_AUTH_DATA_PAC,
                              *IfRelevantData
                              );
        }
        else
        {
            //
            // We don't mind if we couldn't unpack it.
            // Tickets do not always have PAC information.
            //

            KerbErr = KDC_ERR_NONE;
        }
    }

    //
    // If we didn't find it in the if-relevant data, look outside
    //

    if (PacAuthData == NULL)
    {
        PacAuthData = KerbFindAuthDataEntry(
                          KERB_AUTH_DATA_PAC,
                          AuthData
                          );
    }

    //
    // Copy the PAC to return it
    //

    if (PacAuthData != NULL)
    {
        *Pac = PacAuthData;
    }

    *ReturnIfRelevantData = IfRelevantData;
    IfRelevantData = NULL;

    return KerbErr;
}


#if DBG
#define KERB_DEBUG_WARN_LEVEL   0x0002
//+-------------------------------------------------------------------------
//
//  Function:   DebugDisplayTime
//
//  Synopsis:   Displays a FILETIME
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

void
DebugDisplayTime(
    IN ULONG DebugLevel,
    IN const FILETIME * pFileTime
    )
{
    SYSTEMTIME SystemTime;

    if (DebugLevel & KERB_DEBUG_WARN_LEVEL)
    {
        FileTimeToSystemTime(pFileTime, &SystemTime);

        DebugLog((DEB_ERROR," %02d:%02d:%02d - %02d %02d %04d\n",
                 SystemTime.wHour,SystemTime.wMinute,SystemTime.wSecond,
                 SystemTime.wDay,SystemTime.wMonth,SystemTime.wYear));
    }
    return;
}
#endif


//+-------------------------------------------------------------------------
//
//  Function:   VerifyClientAddress
//
//  Synopsis:   Verifies that the client address is present in the address list
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:    TRUE if the address checks out OK, FALSE otherwise
//
//  Notes:
//
//
//--------------------------------------------------------------------------

BOOLEAN
KerbVerifyClientAddress(
    IN const SOCKADDR * ClientAddress,
    IN const KERB_HOST_ADDRESSES * Addresses
    )
{
    const KERB_HOST_ADDRESSES * TempAddress = Addresses;
    BOOLEAN IpAddressesPresent = FALSE;

    //
    // ISSUE-2001/03/05-markpu
    // This routine is inadequate in that it only deals with IPv4
    // addresses.  Address matching has to be more elaborate than that.
    //

    while (TempAddress != NULL)
    {
        if ( TempAddress->value.address_type == KERB_ADDRTYPE_INET &&
             ClientAddress->sa_family == AF_INET )
        {
            struct sockaddr_in * InetAddress = (struct sockaddr_in *) ClientAddress;

            IpAddressesPresent = TRUE;

            //
            // Check that the addresses match
            //

            if (TempAddress->value.address.length == sizeof(ULONG))
            {
                if (!memcmp(
                        TempAddress->value.address.value,
                        &InetAddress->sin_addr.S_un.S_addr,
                        sizeof(ULONG)))
                {
                    return TRUE;
                }
            }
        }

        TempAddress = TempAddress->next;
    }

    D_DebugLog((DEB_WARN,"Client address not in address list\n"));

    //
    // If there were no IP addresses in the ticket, return TRUE, since we
    // probably are in a situation where only netbios addresses are in the
    // ticket, so the socket address matched none of them
    //

    return !IpAddressesPresent;
}

//
//  find an ETYPE matching the requested types and the ones
//  supported
//
KERBERR
KerbFindCommonEType(
    IN const KERB_CRYPT_LIST * ReqEtypes,
    IN ULONG cEtypes,
    IN const ULONG * pculETypes,
    OUT PULONG pulMatch
    )
{
    KERBERR KerbErr = KDC_ERR_ETYPE_NOTSUPP;
    while(ReqEtypes && !KERB_SUCCESS(KerbErr))
    {
        for (ULONG iType = 0; iType < cEtypes; iType++)
        {
            if ((ULONG)ReqEtypes->value == pculETypes[iType])
            {
                *pulMatch = pculETypes[iType];
                KerbErr = KDC_ERR_NONE;
                break;
            }
        }
        ReqEtypes = ReqEtypes->next;
    }
    return  KerbErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\common\passwd.cxx ===
//+-----------------------------------------------------------------------
//
// File:        passwd.c
//
// Contents:    Password hashing routine
//
//
// History:     12-20-91, RichardW, created
//
//------------------------------------------------------------------------

#include "commonp.h"


//
// Globals used for allowing the replacement of the StringToKey functions
//
HCRYPTPROV KerbGlobalStrToKeyProvider = 0;

//+-------------------------------------------------------------------------
//
//  Function:   CheckForOutsideStringToKey
//
//  Synopsis:   Call CryptoAPI to query to see if a CSP is registered
//              of the type PROV_REPLACE_OWF.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns: STATUS_SUCCESS if it succeeds, otherwise STATUS_UNSUCCESSFUL
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
CheckForOutsideStringToKey()
{
    HCRYPTPROV hProv = 0;

    KerbGlobalStrToKeyProvider = 0;

    //
    // Try to acquire a context to a CSP which is used for OWF replacement
    //
    if (!CryptAcquireContext(&hProv,
                             NULL,
                             NULL,
                             PROV_REPLACE_OWF,
                             CRYPT_VERIFYCONTEXT))
    {
        return;
    }

    KerbGlobalStrToKeyProvider = hProv;

    return;
}


//+-------------------------------------------------------------------------
//
//  Function:   UseOutsideStringToKey
//
//  Synopsis:   Calls the CSP to do an outside StringToKey function
//              using the hashing entry points of CryptoAPI.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
UseOutsideStringToKey(
    IN PUNICODE_STRING pPassword,
    IN ULONG cbKey,
    OUT PUCHAR pbKey
    )
{
    HCRYPTHASH hHash = 0;
    ULONG cb;
    NTSTATUS Status = STATUS_UNSUCCESSFUL;

    //
    // create the hash
    //
    if (!CryptCreateHash(KerbGlobalStrToKeyProvider,
                         CALG_HASH_REPLACE_OWF,
                         0,
                         0,
                         &hHash))
    {
        goto Cleanup;
    }

    //
    // hash the password
    //

    if (!CryptHashData(hHash,
                       (PUCHAR)pPassword->Buffer,
                       pPassword->Length,
                       0))
    {
        if (NTE_BAD_DATA == GetLastError())
        {
            Status = NTE_BAD_DATA;
        }
        goto Cleanup;
    }

    //
    // Get the HP_HASHVAL, this is the key
    //
    cb = cbKey;
    if (!CryptGetHashParam(hHash,
                           HP_HASHVAL,
                           pbKey,
                           &cb,
                           0))
    {
        if (NTE_BAD_LEN == GetLastError())
        {
            Status = NTE_BAD_DATA;
        }
        goto Cleanup;
    }

    Status = STATUS_SUCCESS;
Cleanup:
    if (0 != hHash)
    {
        CryptDestroyHash(hHash);
    }
    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbHashPasswordEx
//
//  Synopsis:   Hashes a password into a kerberos encryption key
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


KERBERR NTAPI
KerbHashPasswordEx(
    IN  IKerbCrypt          *pIKerbCrypt,
    IN  PUNICODE_STRING      pustrPassword,
    IN  PUNICODE_STRING      pustrPrincipalName,
    IN  ETYPE                Etype,
    OUT PKERB_ENCRYPTION_KEY *ppKey
    )
{
    UNICODE_STRING      ustrCombinedName;
    NTSTATUS            Status;
    KERBERR             KerbErr;
    CRYPTATT            CryptAttr;
    ULONG               cbKey;
    ULONG               ulTemp = 0;
    PKERB_ENCRYPTION_KEY pKey = NULL;

    *ppKey = NULL;

    RtlInitUnicodeString(
        &ustrCombinedName,
        NULL
        );

    //
    // Locate the crypto system
    //
    KerbErr = pIKerbCrypt->GetAttributes(
                                Etype,
                                &CryptAttr
                                );
    if (!KERB_SUCCESS(KerbErr))
        goto Cleanup;

    //
    // Check to see if the principal name must be appended to the password
    //

    if ((CryptAttr & CSYSTEM_USE_PRINCIPAL_NAME) != 0)
    {
        ulTemp = (ULONG) pustrPassword->Length + (ULONG) pustrPrincipalName->Length;

        if (ulTemp > (USHORT) -1)
        {
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }

        ustrCombinedName.Length = (USHORT) ulTemp;
        ustrCombinedName.MaximumLength = ustrCombinedName.Length;
        ustrCombinedName.Buffer = (LPWSTR) MIDL_user_allocate(ustrCombinedName.Length);
        if (ustrCombinedName.Buffer == NULL)
        {
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }
        memcpy(
            ustrCombinedName.Buffer,
            pustrPassword->Buffer,
            pustrPassword->Length
            );
        memcpy(
            ustrCombinedName.Buffer + pustrPassword->Length/sizeof(WCHAR),
            pustrPrincipalName->Buffer,
            pustrPrincipalName->Length
            );
    }
    else
    {
        ustrCombinedName = *pustrPassword;
    }

    //
    // Get the preferred checksum
    //


    Status = pIKerbCrypt->GetKeySize(
                            Etype,
                            &cbKey
                            );
    if (!NT_SUCCESS(Status))
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    pKey = (PKERB_ENCRYPTION_KEY)MIDL_user_allocate(sizeof(KERB_ENCRYPTION_KEY)+cbKey);
    if (pKey == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }
    //
    //  need to initialize before calling HashString
    //
    pKey->keyvalue.length = cbKey;
    pKey->keyvalue.value  = (PBYTE)pKey + sizeof(KERB_ENCRYPTION_KEY);

    Status = pIKerbCrypt->HashString(
                Etype,
                &ustrCombinedName,
                pKey->keyvalue.value,
                &pKey->keyvalue.length
                );

    if (!NT_SUCCESS(Status))
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    assert(pKey->keyvalue.length == cbKey);

    pKey->keytype = Etype;
    *ppKey = pKey;
    pKey = NULL;
    KerbErr = KDC_ERR_NONE;

Cleanup:
    if (pKey)
        MIDL_user_free(pKey);

    if ((ustrCombinedName.Buffer != pustrPassword->Buffer) &&
        (ustrCombinedName.Buffer != NULL))
    {
        MIDL_user_free(ustrCombinedName.Buffer);
    }


    return(KerbErr);
}



//+-------------------------------------------------------------------------
//
//  Function:   KerbHashPassword
//
//  Synopsis:   Hashes a password into a kerberos encryption key
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


KERBERR NTAPI
KerbHashPassword(
    IN  IKerbCrypt      *pIKerbCrypt,
    IN PUNICODE_STRING Password,
    IN ULONG EncryptionType,
    OUT PKERB_ENCRYPTION_KEY *ppKey
    )
{
    UNICODE_STRING TempString;
    RtlInitUnicodeString(
        &TempString,
        NULL
        );
    return( KerbHashPasswordEx(
                pIKerbCrypt,
                Password,
                &TempString,                   // no principal name
                EncryptionType,
                ppKey
                ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\common\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_kerbcomm_none_12.4.56.0_none_b9d45e2b91fc1e6c
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_kerbcomm_no-public-key_12.4.56.0_x-ww_1975ecec
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=kerbcomm
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_kerbcomm_no-public-key_12.4.56.0_x-ww_1975ecec
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_kerbcomm_no-public-key_12.4.56.0_x-ww_1975ecec.manifest
XP_MANIFEST_PATH=manifests\x86_kerbcomm_no-public-key_12.4.56.0_x-ww_1975ecec.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_kerbcomm_no-public-key_12.4.56.0_x-ww_1975ecec.cat
XP_CATALOG_PATH=manifests\x86_kerbcomm_no-public-key_12.4.56.0_x-ww_1975ecec.cat
XP_PAYLOAD_PATH=x86_kerbcomm_no-public-key_12.4.56.0_x-ww_1975ecec
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=kerbcomm,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\common\sockets.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       sockets.cxx
//
//  Contents:   Code for kerberos client sockets
//
//  Classes:
//
//  Functions:
//
//  History:    26-Jul-1996     MikeSw          Created
//
//----------------------------------------------------------------------------

#include "commonp.h"


LONG SocketStarts = -1;
ULONG TcpFragLength = 0x7fffffff ;
ULONG TcpFragDelay = 0 ;

//+-------------------------------------------------------------------------
//
//  Function:   KerbInitializeSockets
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbInitializeSockets(
    IN WORD VersionRequired,
    IN ULONG MinSockets,
    OUT BOOLEAN *TcpNotInstalled
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    int Error;
    WSADATA SocketData;
#ifndef WIN32_CHICAGO
    WSAPROTOCOL_INFO *lpProtocolBuf = NULL;
    DWORD dwBufLen = 0;
    INT protocols[2];
    int nRet = 0;
#endif // WIN32_CHICAGO

    //
    // Initialze sockets
    //

    *TcpNotInstalled = FALSE;

    if (InterlockedIncrement(&SocketStarts) != 0)
    {
        return(STATUS_SUCCESS);
    }

    Error = WSAStartup(VersionRequired, &SocketData);
    if (Error != 0)
    {
        DebugLog((DEB_ERROR,"WSAStartup failed: 0x%x\n",Error));
        Status = STATUS_NO_LOGON_SERVERS;
        goto Cleanup;
    }


    //
    // Make sure the version is high enough for us
    //

    if ((LOBYTE(SocketData.wVersion) < HIBYTE(VersionRequired)) ||
        (((LOBYTE(SocketData.wVersion) == HIBYTE(VersionRequired)) &&
         (HIBYTE(SocketData.wVersion) < LOBYTE(VersionRequired)))))
    {
        DebugLog((DEB_ERROR,"Invalid socket version: wanted 0x%x, got 0x%x\n",
            VersionRequired, SocketData.wVersion));
        Status = STATUS_NO_LOGON_SERVERS;
        goto Cleanup;
    }

    if (SocketData.iMaxSockets < MinSockets)
    {
        DebugLog((DEB_ERROR,"Not enough sockets available: wanted %d, got %d\n",
            MinSockets, SocketData.iMaxSockets ));
        Status = STATUS_NO_LOGON_SERVERS;
        goto Cleanup;
    }

#ifndef WIN32_CHICAGO
    //
    // Check if TCP is an available xport
    //

    protocols[0] = IPPROTO_TCP;                                             
    protocols[1] = NULL;                                                    
    nRet = WSAEnumProtocols(protocols, lpProtocolBuf, &dwBufLen);           
    if (nRet == 0)                                                          
    {                                                                       
        //                                                                  
        // Tcp is not installed as a xport.                                 
        //                                                                  
                                                                        
        D_DebugLog((DEB_T_SOCK,"WSAEnumProtocols returned 0x%x.\n", nRet));
        *TcpNotInstalled = TRUE;                                             
    }
#endif // WIN32_CHICAGO
Cleanup:
    if (!NT_SUCCESS(Status))
    {
        if (SocketStarts != -1)
        {
            WSACleanup();
            InterlockedDecrement(&SocketStarts);
        }
    }
    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbCleanupSockets
//
//  Synopsis:   Cleansup socket handling code
//
//  Effects:    calls WSACleanup()
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KerbCleanupSockets(
    )
{
    if (InterlockedDecrement(&SocketStarts) < 0)
    {
        WSACleanup();
    }

}


//+-------------------------------------------------------------------------
//
//  Function:   KerbCloseSocket
//
//  Synopsis:   Closes a socket binding handle
//
//  Effects:    calls closesocket on the handle
//
//  Arguments:  SocketHandle - handle to close
//
//  Requires:
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbCloseSocket(
    IN SOCKET SocketHandle
    )
{
    int SockError;
    if (SocketHandle != 0)
    {
        SockError = closesocket(SocketHandle);
        if (SockError != 0)
        {
            DebugLog((DEB_ERROR,"CloseSocket failed: last error = %d\n",WSAGetLastError()));
        }
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbBindSocketByAddress
//
//  Synopsis:   Binds to the KDC socket on the specified address
//
//  Effects:
//
//  Arguments:  Address - Address to bind to
//              AddressType - Address type, as specified by DC locator
//              ContextHandle - Receives bound socket
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbBindSocketByAddress(
    IN PUNICODE_STRING Address,
    IN ULONG AddressType,
    IN BOOLEAN UseDatagram,
    IN USHORT PortNumber,
    OUT SOCKET * ContextHandle
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    SOCKET ClientSocket = INVALID_SOCKET;
    struct sockaddr_in ServerAddress;
    struct sockaddr_in ClientAddress;
    LPHOSTENT ServerInfo = NULL;
    STRING AnsiAddress = {0};

    AnsiAddress.Buffer = NULL;

    Status = RtlUnicodeStringToAnsiString(
                &AnsiAddress,
                Address,
                TRUE
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


    ClientSocket = socket(
                    PF_INET,
                    (UseDatagram ? SOCK_DGRAM : SOCK_STREAM),
                    0
                    );
    if (ClientSocket == INVALID_SOCKET)
    {
        DebugLog((DEB_ERROR,"Failed to create socket: %d\n",WSAGetLastError()));
        Status = STATUS_NO_LOGON_SERVERS;
        goto Cleanup;
    }

    if (UseDatagram)
    {
        //
        // Bind client socket to any local interface and port
        //

        ClientAddress.sin_family = AF_INET;
        ClientAddress.sin_addr.s_addr = INADDR_ANY;
        ClientAddress.sin_port = 0;                 // no specific port

        if (bind(
                ClientSocket,
                (LPSOCKADDR) &ClientAddress,
                sizeof(ClientAddress)
                ) == SOCKET_ERROR )
        {
            DebugLog((DEB_ERROR,"Failed to bind client socket: %d\n",WSAGetLastError()));
            Status = STATUS_NO_LOGON_SERVERS;
            goto Cleanup;
        }
    }

    if (AddressType == DS_INET_ADDRESS)
    {
        ULONG InetAddress;
        //
        // Get the address of the server
        //

        InetAddress = inet_addr(AnsiAddress.Buffer);


        if (InetAddress == SOCKET_ERROR)
        {
            DebugLog((DEB_ERROR,"Failed to convert %Z to address: %d\n", &AnsiAddress, WSAGetLastError()));
            Status = STATUS_NO_LOGON_SERVERS;
            goto Cleanup;
        }

        ServerAddress.sin_family = AF_INET;

        memcpy(
            &ServerAddress.sin_addr,
            &InetAddress,
            sizeof(ULONG)
            );

    }
    else
    {
        //
        // Get the address of the server
        //

        ServerInfo = gethostbyname(AnsiAddress.Buffer);
        if (ServerInfo == NULL)
        {
            DebugLog((DEB_ERROR,"Failed to get host %Z by name: %d\n", &AnsiAddress, WSAGetLastError()));
            Status = STATUS_NO_LOGON_SERVERS;
            goto Cleanup;
        }

        ServerAddress.sin_family = ServerInfo->h_addrtype;

        memcpy(
            &ServerAddress.sin_addr,
            ServerInfo->h_addr,
            sizeof(ULONG)
            );

    }

    ServerAddress.sin_port = htons(PortNumber);

    if (connect(
            ClientSocket,
            (LPSOCKADDR) &ServerAddress,
            sizeof(ServerAddress)
            ) == SOCKET_ERROR)
    {
        DebugLog((DEB_ERROR,"Failed to connect to server %Z: %d\n",&AnsiAddress, WSAGetLastError()));
        Status = STATUS_NO_LOGON_SERVERS;
        goto Cleanup;
    }
    *ContextHandle = ClientSocket;
    D_DebugLog((DEB_TRACE,"Successfully bound to %Z\n",&AnsiAddress));

Cleanup:
    if (AnsiAddress.Buffer != NULL)
    {
        RtlFreeAnsiString(&AnsiAddress);
    }
    if (!NT_SUCCESS(Status))
    {
        if (ClientSocket != INVALID_SOCKET)
        {
            closesocket(ClientSocket);
        }
    }
    return(Status);


}


//+-------------------------------------------------------------------------
//
//  Function:   KerbCallKdc
//
//  Synopsis:   Socket client stub for calling the KDC.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbCallKdc(
    IN PUNICODE_STRING KdcAddress,
    IN ULONG AddressType,
    IN ULONG Timeout,
    IN BOOLEAN UseDatagram,
    IN USHORT PortNumber,
    IN PKERB_MESSAGE_BUFFER Input,
    OUT PKERB_MESSAGE_BUFFER Output
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG Bytes;
    int NumberReady;
    SOCKET Socket = 0;
    PUCHAR RemainingBuffer;
    ULONG RemainingSize;
    fd_set ReadHandles;
    struct timeval TimeoutTime;
    ULONG NetworkSize;
    BOOLEAN RetriedOnce = FALSE;

#ifndef WIN32_CHICAGO
    WSABUF Buffers[2] = {0};
    LPWSABUF SendBuffers = NULL;
    ULONG BufferCount = 0;
    int SendStatus;
#endif // WIN32_CHICAGO

    //
    // Start out by binding to the KDC
    //

    DebugLog((DEB_TRACE, "Calling KDC: %S\n", KdcAddress->Buffer));

    Status = KerbBindSocketByAddress(
                KdcAddress,
                AddressType,
                UseDatagram,
                PortNumber,
                &Socket
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    RemainingBuffer = Input->Buffer;
    RemainingSize = Input->BufferSize;

#ifndef WIN32_CHICAGO

    //
    // Use winsock2
    //

    Buffers[0].len = sizeof(ULONG);
    NetworkSize = htonl(RemainingSize);
    Buffers[0].buf = (PCHAR) &NetworkSize;
    Buffers[1].len = Input->BufferSize;
    Buffers[1].buf = (PCHAR) Input->Buffer;

    if (UseDatagram)
    {
        BufferCount = 1;
        SendBuffers = &Buffers[1];
        RemainingSize = Buffers[1].len;
    }
    else
    {
        BufferCount = 2;
        SendBuffers = &Buffers[0];
        RemainingSize = Buffers[0].len + Buffers[1].len;
    }

RetrySend:

    SendStatus = WSASend(
                    Socket,
                    SendBuffers,
                    BufferCount,
                    &Bytes,
                    0,          // no flags
                    NULL,               // no overlapped
                    NULL                // no completion routine
                    );

    if ((SendStatus != 0) || (Bytes == 0))
    {
        DsysAssert(SendStatus == SOCKET_ERROR);
        DebugLog((DEB_ERROR,"Failed to send data: %d\n",WSAGetLastError()));
        Status = SEC_E_NO_AUTHENTICATING_AUTHORITY;
        goto Cleanup;
    }
    if (Bytes < RemainingSize)
    {
        RemainingSize -= Bytes;
        if (Bytes > SendBuffers->len)
        {
            //
            // We sent the whole of a buffer, so move on to the next
            //

            Bytes -= SendBuffers->len;

            DsysAssert(BufferCount > 1);
            BufferCount--;
            SendBuffers++;
            SendBuffers->len -= Bytes;
            SendBuffers->buf += Bytes;
        }
        else
        {
            SendBuffers->len -= Bytes;
            SendBuffers->buf += Bytes;
        }
        goto RetrySend;
    }




#else // WIN32_CHICAGO

    //
    // Use winsock1 for win9x
    //

    //
    // For TCP, send length first
    //

RetrySend:

    if (!UseDatagram)
    {
        NetworkSize = htonl(RemainingSize);
        Bytes = send(Socket, (char *)&NetworkSize,sizeof(ULONG), 0);
        if (Bytes != sizeof(ULONG) )
        {
            DebugLog((DEB_ERROR,"Failed to send TCP packet length: bytes sent = %d, last err = %d\n",
                Bytes,
                WSAGetLastError()));
            Status = SEC_E_NO_AUTHENTICATING_AUTHORITY;
            goto Cleanup;
        }
    }
    do
    {
        if (!UseDatagram)
        {
            if ( RemainingSize > TcpFragLength )
            {
                SendSize = TcpFragLength ;
            }
            else
            {
                SendSize = RemainingSize ;
            }
            if ( TcpFragDelay )
            {
                Sleep( TcpFragDelay );
            }
        }
        else
        {
            SendSize = RemainingSize ;
        }
        D_DebugLog(( DEB_T_SOCK, "Sending %x bytes to %wZ\n",
                        SendSize, KdcAddress ));
        Bytes = send(Socket, (char *) RemainingBuffer, SendSize, 0);
        if (Bytes == SOCKET_ERROR)
        {
            DebugLog((DEB_ERROR,"Failed to send data: %d\n",WSAGetLastError()));
            Status = SEC_E_NO_AUTHENTICATING_AUTHORITY;
            goto Cleanup;
        }
        if (Bytes != SendSize)
        {
            DebugLog((DEB_ERROR,"Failed to send all data - only send %d out of %d\n",
                Bytes, RemainingSize ));
            Status = SEC_E_NO_AUTHENTICATING_AUTHORITY;
            goto Cleanup;
        }
        RemainingBuffer += Bytes;
        RemainingSize -= Bytes;
    } while ((Bytes != 0) && (RemainingSize != 0));

#endif

    //
    // Now select on the socket and wait for a response
    // ReadHandles and TimeoutTime must be reset each time, cause winsock
    // zeroes them out in case of error

    ReadHandles.fd_count = 1;
    ReadHandles.fd_array[0] = Socket;
    TimeoutTime.tv_sec = Timeout;
    TimeoutTime.tv_usec = 0;

    D_DebugLog(( DEB_T_SOCK, "Socket being used for select is 0x%x\n", ReadHandles.fd_array[0] ));
    NumberReady = select(
                    1,
                    &ReadHandles,
                    NULL,
                    NULL,
                    &TimeoutTime
                    );
    if ((NumberReady == SOCKET_ERROR) ||
        (NumberReady == 0))
    {

        DebugLog((DEB_ERROR,"Failed to select on response on socket 0x%x from kdc: %d\n", ReadHandles.fd_array[0], WSAGetLastError()));

        DebugLog((DEB_ERROR,"select returned  %d\n",NumberReady));

        //
        // Retry again and wait.
        //

        if ((NumberReady == 0) && (!RetriedOnce))
        {
            RetriedOnce = TRUE;
            goto RetrySend;
        }
        Status = STATUS_NO_LOGON_SERVERS;
        goto Cleanup;
    }


    //
    // Now receive the data
    //

    if (UseDatagram)
    {
        Output->BufferSize = KERB_MAX_KDC_RESPONSE_SIZE;
        Output->Buffer = (PUCHAR) MIDL_user_allocate(KERB_MAX_KDC_RESPONSE_SIZE);
        if (Output->Buffer == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        Bytes = recv(
                    Socket,
                    (char *) Output->Buffer,
                    Output->BufferSize,
                    0
                    );
        if ((Bytes == SOCKET_ERROR) || (Bytes == 0))
        {
            DebugLog((DEB_ERROR,"Failed to receive socket data: %d\n",WSAGetLastError()));
            Status = SEC_E_NO_AUTHENTICATING_AUTHORITY;
            goto Cleanup;
        }
        Output->BufferSize = Bytes;
    }
    else
    {
        Bytes = recv(
                    Socket,
                    (char *) &NetworkSize,
                    sizeof(ULONG),
                    0
                    );
        if (Bytes != sizeof(ULONG) )
        {
            DebugLog((DEB_ERROR,"Failed to receive socket data: %d\n",WSAGetLastError()));
            Status = SEC_E_NO_AUTHENTICATING_AUTHORITY;
            goto Cleanup;
        }
        RemainingSize = ntohl(NetworkSize);
        Output->BufferSize = RemainingSize;
        Output->Buffer = (PUCHAR) MIDL_user_allocate(RemainingSize);
        if (Output->Buffer == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        while (RemainingSize != 0)
        {
            //
            // Make sure there is data ready
            //

            D_DebugLog(( DEB_T_SOCK, "Socket being used for select is 0x%x\n", ReadHandles.fd_array[0] ));
            NumberReady = select(
                            1,
                            &ReadHandles,
                            NULL,
                            NULL,
                            &TimeoutTime
                            );
            if ((NumberReady == SOCKET_ERROR) ||
                (NumberReady == 0))
            {
                DebugLog((DEB_ERROR,"Failed to select on response on socket 0x%x from kdc: %d\n", ReadHandles.fd_array[0], WSAGetLastError()));

                DebugLog((DEB_ERROR,"select returned  %d\n",NumberReady));

                Status = STATUS_NO_LOGON_SERVERS;
                goto Cleanup;
            }

            //
            // Receive the data
            //

            Bytes = recv(
                        Socket,
                        (char *) Output->Buffer + Output->BufferSize - RemainingSize,
                        RemainingSize,
                        0
                        );
            if ((Bytes == SOCKET_ERROR) || (Bytes == 0))
            {
                DebugLog((DEB_ERROR,"Failed to receive socket data: %d\n",WSAGetLastError()));
                Status = SEC_E_NO_AUTHENTICATING_AUTHORITY;
                goto Cleanup;
            }
            RemainingSize -= Bytes;
        }
    }

Cleanup:
    if (Socket != 0)
    {
        KerbCloseSocket(Socket);
    }
    if (!NT_SUCCESS(Status))
    {
        if (Output->Buffer != NULL)
        {
            MIDL_user_free(Output->Buffer);
            Output->Buffer = NULL;
        }
    }
    return(Status);



}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\common\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_kerbcomm_none_12.4.56.0_none_b9d45e2b91fc1e6c
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_kerbcomm_no-public-key_12.4.56.0_x-ww_1975ecec
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=kerbcomm
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_kerbcomm_no-public-key_12.4.56.0_x-ww_1975ecec
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_kerbcomm_no-public-key_12.4.56.0_x-ww_1975ecec.manifest
XP_MANIFEST_PATH=manifests\x86_kerbcomm_no-public-key_12.4.56.0_x-ww_1975ecec.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_kerbcomm_no-public-key_12.4.56.0_x-ww_1975ecec.cat
XP_CATALOG_PATH=manifests\x86_kerbcomm_no-public-key_12.4.56.0_x-ww_1975ecec.cat
XP_PAYLOAD_PATH=x86_kerbcomm_no-public-key_12.4.56.0_x-ww_1975ecec
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=kerbcomm,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\idl_prebuilt\kdccoreevents.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    kdcevent.h

Abstract:

    Definitions for POP3 Server Events

Author:

    RichardW,  3 Mar 95

Revision History:
	vikask, 5 Dec, 2001
Notes:

   
--*/


#ifndef __KDCCOREEVENTS_H__
#define __KDCCOREEVENTS_H__

//
//  Values are 32 bit values laid out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3


//
// MessageId: EVCAT_CORE
//
// MessageText:
//
//  KDC Core
//
#define EVCAT_CORE                       0x00000001L

//
// MessageId: EVCAT_PROVIDER
//
// MessageText:
//
//  KDC Provider
//
#define EVCAT_PROVIDER                   0x00000002L

//
// MessageId: EVCAT_SERVICE
//
// MessageText:
//
//  KDC Service
//
#define EVCAT_SERVICE                    0x00000003L

//
// MessageId: CATEGORY_MAX_CATEGORY
//
// MessageText:
//
//  Max
//
#define CATEGORY_MAX_CATEGORY            0x00000004L

//
// MessageId: PPROVIDER_UNLOADED
//
// MessageText:
//
//  Passport Provider unloaded
//
#define PPROVIDER_UNLOADED               0x40000005L

//
// MessageId: PROVIDER_LOADED
//
// MessageText:
//
//  Provider in (%1) was loaded successfully
//
#define PROVIDER_LOADED                  0xC0000006L

//
// MessageId: PROVIDER_LOAD_FAILED
//
// MessageText:
//
//  Couldn't load provider in (%1) 
//
#define PROVIDER_LOAD_FAILED             0xC0000007L

//
// MessageId: KDCEVENT_UNKNOWN_PRINCIPAL
//
// MessageText:
//
//  Could not find principal %1
//
#define KDCEVENT_UNKNOWN_PRINCIPAL       0x80000008L

//
// MessageId: KDCEVENT_FAILED_DOMAIN_CREDS
//
// MessageText:
//
//  Domain %1 propagated to us but did not authenticate
//
#define KDCEVENT_FAILED_DOMAIN_CREDS     0x80000009L

//
// MessageId: KDCEVENT_POLICY_UPDATE_FAILED
//
// MessageText:
//
//  The KDC failed to update policy class %1. The error is in the data.
//
#define KDCEVENT_POLICY_UPDATE_FAILED    0xC000000AL

//
// MessageId: KDCEVENT_DOMAIN_LIST_UPDATE_FAILED
//
// MessageText:
//
//  The KDC failed to update the trusted domain list. The error is in the data.
//
#define KDCEVENT_DOMAIN_LIST_UPDATE_FAILED 0xC000000BL

//
// MessageId: KDCEVENT_SAM_CALL_FAILED
//
// MessageText:
//
//  The Security Account Manager failed a KDC request in an unexpected way. The
//  error is in the data field. The account name was %1 and lookup type %2.
//
#define KDCEVENT_SAM_CALL_FAILED         0xC000000CL

//
// MessageId: KDCEVENT_NO_KEY_TYPE
//
// MessageText:
//
//  The account %1 did not have a suitable key for generating a Kerberos ticket.
//  If the encryption type is supported, changing or setting the password will
//  generate a proper key.  The missing key type may be in the data field.
//
#define KDCEVENT_NO_KEY_TYPE             0xC000000DL

//
// MessageId: KDCEVENT_KRBTGT_PASSWORD_CHANGED
//
// MessageText:
//
//  The password on the KRBTGT account was changed.
//
#define KDCEVENT_KRBTGT_PASSWORD_CHANGED 0x0000000EL

//
// MessageId: KDCEVENT_KRBTGT_PASSWORD_CHANGE_FAILED
//
// MessageText:
//
//  The attempt to change the password on the KRBTGT account failed. The error
//  code is in the data field
//
#define KDCEVENT_KRBTGT_PASSWORD_CHANGE_FAILED 0xC000000FL

//
// MessageId: KDCEVENT_NAME_NOT_UNIQUE
//
// MessageText:
//
//  There are multiple accounts with name %1 of type %2.
//
#define KDCEVENT_NAME_NOT_UNIQUE         0xC0000010L

//
// MessageId: KDCEVENT_FAILED_TRANSITIVE_TRUST
//
// MessageText:
//
//  A request failed from client realm %1 for a ticket in realm %2.  
//  This failed because a trust link between the realms is non transitive.
//
#define KDCEVENT_FAILED_TRANSITIVE_TRUST 0x80000011L

//
// MessageId: KDCEVENT_CORRUPT_CREDENTIALS
//
// MessageText:
//
//  The account for %1 has corrupt keys stored in the DS.  Changing
//  or setting the password should restore correct keys.
//
#define KDCEVENT_CORRUPT_CREDENTIALS     0xC0000012L

//
// MessageId: KDCEVENT_NO_KEY_UNION_AS
//
// MessageText:
//
//  While processing an AS request, the account %1 did not have a suitable key 
//  for generating a Kerberos ticket.  
//  The requested etypes were %2.  
//  The accounts available etypes were %3. 
//  If the encryption type is supported, changing or setting the password will
//  generate a proper key.  
//
#define KDCEVENT_NO_KEY_UNION_AS         0xC0000013L

//
// MessageId: KDCEVENT_INVALID_FORWARDED_AS_REQ
//
// MessageText:
//
//  The request for an AS ticket for client %1 was forwarded to the PDC.  An 
//  invalid response to this forwarded request was detected and could indicate an
//  attempt to spoof your PDC.  There may be additional information in the data field. 
//
#define KDCEVENT_INVALID_FORWARDED_AS_REQ 0xC0000014L

//
// MessageId: KDCEVENT_NO_KEY_UNION_TGS
//
// MessageText:
//
//  While processing a TGS request for the target server %1, the account %2 did not 
//  have a suitable key for generating a Kerberos ticket.  
//  The requested etypes were %3.  
//  The accounts available etypes were %4. 
//  If the encryption type is supported, changing or setting the password will
//  generate a proper key.  
//
#define KDCEVENT_NO_KEY_UNION_TGS        0xC0000015L

//
// MessageId: KDCEVENT_INVALID_POLICY
//
// MessageText:
//
//  When updating policy class %1, the KDC encountered invalid policy data
//  and has failed to update the policy.
//
#define KDCEVENT_INVALID_POLICY          0xC0000016L

//
// MessageId: KDCEVENT_PAC_VERIFICATION_FAILURE
//
// MessageText:
//
//  During TGS processing, the KDC was unable to verify the signature on the 
//  PAC from %1. This indicates the PAC was modified.
//
#define KDCEVENT_PAC_VERIFICATION_FAILURE 0xC0000017L

//
// MessageId: KDCEVENT_NO_KDC_CERTIFICATE
//
// MessageText:
//
//  This event indicates an attempt was made to use smartcard logon, 
//  but the KDC is unable to use the PKINIT protocol because it is missing a 
//  suitable certificate.  
//
#define KDCEVENT_NO_KDC_CERTIFICATE      0x80000018L

//
// MessageId: KDCEVENT_INVALID_KDC_CERTIFICATE
//
// MessageText:
//
//  The currently selected KDC certificate was once valid, but now is invalid
//  and no suitable replacement was found.  Smartcard logon may not function correctly
//  if this problem is not remedied.  Have the system administrator check on the 
//  state of the domain's public key infrastructure.  The chain status is in 
//  the error data.
//
#define KDCEVENT_INVALID_KDC_CERTIFICATE 0x80000019L

//
// MessageId: KDCEVENT_INVALID_CLIENT_CERTIFICATE
//
// MessageText:
//
//  The client certificate for the user %1 is not valid, and resulted in a 
//  failed smartcard logon.  Please contact the user for more information 
//  about the certificate they're attempting to use for smartcard logon.  The 
//  chain status is in the error data.
//
#define KDCEVENT_INVALID_CLIENT_CERTIFICATE 0x8000001AL

//
// MessageId: KDCEVENT_TRUST_LOOP
//
// MessageText:
//
//  The KDC encountered a trust loop when building a list of trusted domains.  
//  This indicates that the route to the domain %1 from this KDC has more than 
//  one possible trust path.
//
#define KDCEVENT_TRUST_LOOP              0x8000001BL


#endif // __KDCEVENT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\idl_prebuilt\pacimp.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1993
//
// File:        pacimp.h
//
// Contents:    imports for pac.idl
//
//
// History:     4-Aug-1993      MikeSw  Created
//
//------------------------------------------------------------------------

//typedef void * I_RPC_HANDLE;
//#include <rpc.h>

//#if 0
//#ifndef _WINSOCK2API_
//#include <winsock2.h>
//#endif
//#endif

#define WIN32_NO_STATUS
#include <winternl.h>
#include <windows.h>
#undef WIN32_NO_STATUS
#include <ntstatus.h>
typedef NTSTATUS * PNTSTATUS;
#define _NTDEF_
#include <ntsecapi.h>
#undef _NTDEF_
#include <subauth.h>
#include <wincrypt.h>

#include <pacpat.hxx>

#include <windef.h>

#define WIN32_NO_STATUS
#include <winbase.h>
#undef WIN32_NO_STATUS
#include <crypt.h>

#include <lmcons.h>

#define SECURITY_PACKAGE
#include <security.h>
#include <secint.h>

#include <NTSecPkg.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\idl_prebuilt\pacndr.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0486 */
/* Compiler settings for pacndr.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, oldnames, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#include "midles.h"

#ifndef __pacndr_h__
#define __pacndr_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

/* header files for imported files */
#include "pacimp.h"

#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __Pac_INTERFACE_DEFINED__
#define __Pac_INTERFACE_DEFINED__

/* interface Pac */
/* [explicit_handle][unique][version][uuid] */ 

typedef struct _PAC_SID_AND_ATTRIBUTES
    {
    PISID Sid;
    ULONG Attributes;
    } 	PAC_SID_AND_ATTRIBUTES;

typedef struct _PAC_SID_AND_ATTRIBUTES *PPAC_SID_AND_ATTRIBUTES;

typedef struct _PAC_LUID_AND_ATTRIBUTES
    {
    LUID Luid;
    ULONG Attributes;
    } 	PAC_LUID_AND_ATTRIBUTES;

typedef struct _PAC_LUID_AND_ATTRIBUTES *PPAC_LUID_AND_ATTRIBUTES;

typedef struct _PAC_TOKEN_GROUPS
    {
    ULONG GroupCount;
    PAC_SID_AND_ATTRIBUTES Groups[ 1 ];
    } 	PAC_TOKEN_GROUPS;

typedef struct _PAC_TOKEN_GROUPS *PPAC_TOKEN_GROUPS;

typedef struct _PAC_TOKEN_PRIVILEGES
    {
    ULONG PrivilegeCount;
    PAC_LUID_AND_ATTRIBUTES Privileges[ 1 ];
    } 	PAC_TOKEN_PRIVILEGES;

typedef struct _PAC_TOKEN_PRIVILEGES *PPAC_TOKEN_PRIVILEGES;

typedef struct _KERB_TOKEN_RESTRICTIONS
    {
    ULONG Flags;
    PPAC_TOKEN_GROUPS GroupsToDisable;
    PPAC_TOKEN_GROUPS RestrictedSids;
    PPAC_TOKEN_PRIVILEGES PrivilegesToDelete;
    } 	KERB_TOKEN_RESTRICTIONS;

typedef /* [allocate][decode][encode] */ struct _KERB_TOKEN_RESTRICTIONS *PKERB_TOKEN_RESTRICTIONS;

typedef PAC_NETLOGON_VALIDATION_SAM_INFO3 PAC_IDL_VALIDATION_INFO;

typedef /* [allocate][decode][encode] */ PAC_NETLOGON_VALIDATION_SAM_INFO3 *PPAC_IDL_VALIDATION_INFO;

typedef SECPKG_SUPPLEMENTAL_CRED_ARRAY PAC_IDL_CREDENTIAL_DATA;

typedef /* [allocate][decode][encode] */ SECPKG_SUPPLEMENTAL_CRED_ARRAY *PPAC_IDL_CREDENTIAL_DATA;



extern RPC_IF_HANDLE Pac_ClientIfHandle;
extern RPC_IF_HANDLE Pac_ServerIfHandle;
#endif /* __Pac_INTERFACE_DEFINED__ */

/* Additional Prototypes for ALL interfaces */


size_t
PKERB_TOKEN_RESTRICTIONS_AlignSize(
    handle_t _MidlEsHandle,
    PKERB_TOKEN_RESTRICTIONS * _pType);

size_t
PPAC_IDL_VALIDATION_INFO_AlignSize(
    handle_t _MidlEsHandle,
    PPAC_IDL_VALIDATION_INFO * _pType);

size_t
PPAC_IDL_CREDENTIAL_DATA_AlignSize(
    handle_t _MidlEsHandle,
    PPAC_IDL_CREDENTIAL_DATA * _pType);


void
PKERB_TOKEN_RESTRICTIONS_Encode(
    handle_t _MidlEsHandle,
    PKERB_TOKEN_RESTRICTIONS * _pType);

void
PPAC_IDL_VALIDATION_INFO_Encode(
    handle_t _MidlEsHandle,
    PPAC_IDL_VALIDATION_INFO * _pType);

void
PPAC_IDL_CREDENTIAL_DATA_Encode(
    handle_t _MidlEsHandle,
    PPAC_IDL_CREDENTIAL_DATA * _pType);


void
PKERB_TOKEN_RESTRICTIONS_Decode(
    handle_t _MidlEsHandle,
    PKERB_TOKEN_RESTRICTIONS * _pType);

void
PPAC_IDL_VALIDATION_INFO_Decode(
    handle_t _MidlEsHandle,
    PPAC_IDL_VALIDATION_INFO * _pType);

void
PPAC_IDL_CREDENTIAL_DATA_Decode(
    handle_t _MidlEsHandle,
    PPAC_IDL_CREDENTIAL_DATA * _pType);


void
PKERB_TOKEN_RESTRICTIONS_Free(
    handle_t _MidlEsHandle,
    PKERB_TOKEN_RESTRICTIONS * _pType);

void
PPAC_IDL_VALIDATION_INFO_Free(
    handle_t _MidlEsHandle,
    PPAC_IDL_VALIDATION_INFO * _pType);

void
PPAC_IDL_CREDENTIAL_DATA_Free(
    handle_t _MidlEsHandle,
    PPAC_IDL_CREDENTIAL_DATA * _pType);

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\idl_prebuilt\pacndr_c.c ===
/* this ALWAYS GENERATED file contains the RPC client stubs */


 /* File created by MIDL compiler version 7.00.0486 */
/* Compiler settings for pacndr.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, oldnames, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)


#pragma warning( disable: 4049 )  /* more than 64k source lines */
#if _MSC_VER >= 1200
#pragma warning(push)
#endif

#pragma warning( disable: 4211 )  /* redefine extern to static */
#pragma warning( disable: 4232 )  /* dllimport identity*/
#pragma warning( disable: 4024 )  /* array to pointer mapping*/
#pragma warning( disable: 4100 ) /* unreferenced arguments in x86 call */

#pragma optimize("", off ) 

#include <string.h>

#include "pacndr.h"

#define TYPE_FORMAT_STRING_SIZE   751                               
#define PROC_FORMAT_STRING_SIZE   1                                 
#define EXPR_FORMAT_STRING_SIZE   1                                 
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   0            

typedef struct _pacndr_MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } pacndr_MIDL_TYPE_FORMAT_STRING;

typedef struct _pacndr_MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } pacndr_MIDL_PROC_FORMAT_STRING;

typedef struct _pacndr_MIDL_EXPR_FORMAT_STRING
    {
    long          Pad;
    unsigned char  Format[ EXPR_FORMAT_STRING_SIZE ];
    } pacndr_MIDL_EXPR_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};


extern const pacndr_MIDL_TYPE_FORMAT_STRING pacndr__MIDL_TypeFormatString;
extern const pacndr_MIDL_PROC_FORMAT_STRING pacndr__MIDL_ProcFormatString;
extern const pacndr_MIDL_EXPR_FORMAT_STRING pacndr__MIDL_ExprFormatString;

#define GENERIC_BINDING_TABLE_SIZE   0            


/* Pickling interface: Pac, ver. 1.0,
   GUID={0x00000001,0x0001,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x71}} */



static const RPC_CLIENT_INTERFACE Pac___RpcClientInterface =
    {
    sizeof(RPC_CLIENT_INTERFACE),
    {{0x00000001,0x0001,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x71}},{1,0}},
    {{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}},
    0,
    0,
    0,
    0,
    0,
    0x00000000
    };
RPC_IF_HANDLE Pac_ClientIfHandle = (RPC_IF_HANDLE)& Pac___RpcClientInterface;

extern const MIDL_STUB_DESC Pac_StubDesc;

static RPC_BINDING_HANDLE Pac__MIDL_AutoBindHandle;

static MIDL_TYPE_PICKLING_INFO __MIDL_TypePicklingInfo =
    {
    0x33205054, /* Signature & version: TP 1 */
    0x3, /* Flags: Oicf NewCorrDesc */
    0,
    0,
    0,
    };

size_t
PKERB_TOKEN_RESTRICTIONS_AlignSize(
    handle_t _MidlEsHandle,
    PKERB_TOKEN_RESTRICTIONS * _pType)
{
    return NdrMesTypeAlignSize2(
                        _MidlEsHandle,
                        ( PMIDL_TYPE_PICKLING_INFO  )&__MIDL_TypePicklingInfo,
                        &Pac_StubDesc,
                        ( PFORMAT_STRING  )&pacndr__MIDL_TypeFormatString.Format[2],
                        _pType);
}

void
PKERB_TOKEN_RESTRICTIONS_Encode(
    handle_t _MidlEsHandle,
    PKERB_TOKEN_RESTRICTIONS * _pType)
{
    NdrMesTypeEncode2(
                     _MidlEsHandle,
                     ( PMIDL_TYPE_PICKLING_INFO  )&__MIDL_TypePicklingInfo,
                     &Pac_StubDesc,
                     ( PFORMAT_STRING  )&pacndr__MIDL_TypeFormatString.Format[2],
                     _pType);
}

void
PKERB_TOKEN_RESTRICTIONS_Decode(
    handle_t _MidlEsHandle,
    PKERB_TOKEN_RESTRICTIONS * _pType)
{
    NdrMesTypeDecode2(
                     _MidlEsHandle,
                     ( PMIDL_TYPE_PICKLING_INFO  )&__MIDL_TypePicklingInfo,
                     &Pac_StubDesc,
                     ( PFORMAT_STRING  )&pacndr__MIDL_TypeFormatString.Format[2],
                     _pType);
}

void
PKERB_TOKEN_RESTRICTIONS_Free(
    handle_t _MidlEsHandle,
    PKERB_TOKEN_RESTRICTIONS * _pType)
{
    NdrMesTypeFree2(
                   _MidlEsHandle,
                   ( PMIDL_TYPE_PICKLING_INFO  )&__MIDL_TypePicklingInfo,
                   &Pac_StubDesc,
                   ( PFORMAT_STRING  )&pacndr__MIDL_TypeFormatString.Format[2],
                   _pType);
}

size_t
PPAC_IDL_VALIDATION_INFO_AlignSize(
    handle_t _MidlEsHandle,
    PPAC_IDL_VALIDATION_INFO * _pType)
{
    return NdrMesTypeAlignSize2(
                        _MidlEsHandle,
                        ( PMIDL_TYPE_PICKLING_INFO  )&__MIDL_TypePicklingInfo,
                        &Pac_StubDesc,
                        ( PFORMAT_STRING  )&pacndr__MIDL_TypeFormatString.Format[196],
                        _pType);
}

void
PPAC_IDL_VALIDATION_INFO_Encode(
    handle_t _MidlEsHandle,
    PPAC_IDL_VALIDATION_INFO * _pType)
{
    NdrMesTypeEncode2(
                     _MidlEsHandle,
                     ( PMIDL_TYPE_PICKLING_INFO  )&__MIDL_TypePicklingInfo,
                     &Pac_StubDesc,
                     ( PFORMAT_STRING  )&pacndr__MIDL_TypeFormatString.Format[196],
                     _pType);
}

void
PPAC_IDL_VALIDATION_INFO_Decode(
    handle_t _MidlEsHandle,
    PPAC_IDL_VALIDATION_INFO * _pType)
{
    NdrMesTypeDecode2(
                     _MidlEsHandle,
                     ( PMIDL_TYPE_PICKLING_INFO  )&__MIDL_TypePicklingInfo,
                     &Pac_StubDesc,
                     ( PFORMAT_STRING  )&pacndr__MIDL_TypeFormatString.Format[196],
                     _pType);
}

void
PPAC_IDL_VALIDATION_INFO_Free(
    handle_t _MidlEsHandle,
    PPAC_IDL_VALIDATION_INFO * _pType)
{
    NdrMesTypeFree2(
                   _MidlEsHandle,
                   ( PMIDL_TYPE_PICKLING_INFO  )&__MIDL_TypePicklingInfo,
                   &Pac_StubDesc,
                   ( PFORMAT_STRING  )&pacndr__MIDL_TypeFormatString.Format[196],
                   _pType);
}

size_t
PPAC_IDL_CREDENTIAL_DATA_AlignSize(
    handle_t _MidlEsHandle,
    PPAC_IDL_CREDENTIAL_DATA * _pType)
{
    return NdrMesTypeAlignSize2(
                        _MidlEsHandle,
                        ( PMIDL_TYPE_PICKLING_INFO  )&__MIDL_TypePicklingInfo,
                        &Pac_StubDesc,
                        ( PFORMAT_STRING  )&pacndr__MIDL_TypeFormatString.Format[630],
                        _pType);
}

void
PPAC_IDL_CREDENTIAL_DATA_Encode(
    handle_t _MidlEsHandle,
    PPAC_IDL_CREDENTIAL_DATA * _pType)
{
    NdrMesTypeEncode2(
                     _MidlEsHandle,
                     ( PMIDL_TYPE_PICKLING_INFO  )&__MIDL_TypePicklingInfo,
                     &Pac_StubDesc,
                     ( PFORMAT_STRING  )&pacndr__MIDL_TypeFormatString.Format[630],
                     _pType);
}

void
PPAC_IDL_CREDENTIAL_DATA_Decode(
    handle_t _MidlEsHandle,
    PPAC_IDL_CREDENTIAL_DATA * _pType)
{
    NdrMesTypeDecode2(
                     _MidlEsHandle,
                     ( PMIDL_TYPE_PICKLING_INFO  )&__MIDL_TypePicklingInfo,
                     &Pac_StubDesc,
                     ( PFORMAT_STRING  )&pacndr__MIDL_TypeFormatString.Format[630],
                     _pType);
}

void
PPAC_IDL_CREDENTIAL_DATA_Free(
    handle_t _MidlEsHandle,
    PPAC_IDL_CREDENTIAL_DATA * _pType)
{
    NdrMesTypeFree2(
                   _MidlEsHandle,
                   ( PMIDL_TYPE_PICKLING_INFO  )&__MIDL_TypePicklingInfo,
                   &Pac_StubDesc,
                   ( PFORMAT_STRING  )&pacndr__MIDL_TypeFormatString.Format[630],
                   _pType);
}


#if !defined(__RPC_WIN32__)
#error  Invalid build platform for this stub.
#endif
#if !(TARGET_IS_NT51_OR_LATER)
#error You need a Windows XP or later to run this stub because it uses these features:
#error   #error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
#error This app will fail with the RPC_X_WRONG_STUB_VERSION error.
#endif


static const pacndr_MIDL_PROC_FORMAT_STRING pacndr__MIDL_ProcFormatString =
    {
        0,
        {

			0x0
        }
    };

static const pacndr_MIDL_TYPE_FORMAT_STRING pacndr__MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/*  4 */	NdrFcShort( 0x96 ),	/* Offset= 150 (154) */
/*  6 */	
			0x1d,		/* FC_SMFARRAY */
			0x0,		/* 0 */
/*  8 */	NdrFcShort( 0x6 ),	/* 6 */
/* 10 */	0x2,		/* FC_CHAR */
			0x5b,		/* FC_END */
/* 12 */	
			0x15,		/* FC_STRUCT */
			0x0,		/* 0 */
/* 14 */	NdrFcShort( 0x6 ),	/* 6 */
/* 16 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 18 */	NdrFcShort( 0xfff4 ),	/* Offset= -12 (6) */
/* 20 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 22 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 24 */	NdrFcShort( 0x4 ),	/* 4 */
/* 26 */	0x4,		/* Corr desc: FC_USMALL */
			0x0,		/*  */
/* 28 */	NdrFcShort( 0xfff9 ),	/* -7 */
/* 30 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 32 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 34 */	
			0x17,		/* FC_CSTRUCT */
			0x3,		/* 3 */
/* 36 */	NdrFcShort( 0x8 ),	/* 8 */
/* 38 */	NdrFcShort( 0xfff0 ),	/* Offset= -16 (22) */
/* 40 */	0x2,		/* FC_CHAR */
			0x2,		/* FC_CHAR */
/* 42 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 44 */	NdrFcShort( 0xffe0 ),	/* Offset= -32 (12) */
/* 46 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 48 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 50 */	NdrFcShort( 0x8 ),	/* 8 */
/* 52 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 54 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 56 */	NdrFcShort( 0x0 ),	/* 0 */
/* 58 */	NdrFcShort( 0x0 ),	/* 0 */
/* 60 */	0x12, 0x0,	/* FC_UP */
/* 62 */	NdrFcShort( 0xffe4 ),	/* Offset= -28 (34) */
/* 64 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 66 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 68 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 70 */	NdrFcShort( 0x8 ),	/* 8 */
/* 72 */	0x9,		/* Corr desc: FC_ULONG */
			0x0,		/*  */
/* 74 */	NdrFcShort( 0xfffc ),	/* -4 */
/* 76 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 78 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 80 */	NdrFcShort( 0xffe0 ),	/* Offset= -32 (48) */
/* 82 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 84 */	
			0x18,		/* FC_CPSTRUCT */
			0x3,		/* 3 */
/* 86 */	NdrFcShort( 0x4 ),	/* 4 */
/* 88 */	NdrFcShort( 0xffec ),	/* Offset= -20 (68) */
/* 90 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 92 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 94 */	NdrFcShort( 0x8 ),	/* 8 */
/* 96 */	NdrFcShort( 0x4 ),	/* 4 */
/* 98 */	NdrFcShort( 0x1 ),	/* 1 */
/* 100 */	NdrFcShort( 0x4 ),	/* 4 */
/* 102 */	NdrFcShort( 0x4 ),	/* 4 */
/* 104 */	0x12, 0x0,	/* FC_UP */
/* 106 */	NdrFcShort( 0xffb8 ),	/* Offset= -72 (34) */
/* 108 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 110 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 112 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 114 */	NdrFcShort( 0x8 ),	/* 8 */
/* 116 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 118 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 120 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 122 */	NdrFcShort( 0xc ),	/* 12 */
/* 124 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 126 */	NdrFcShort( 0xfff2 ),	/* Offset= -14 (112) */
/* 128 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 130 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 132 */	NdrFcShort( 0xc ),	/* 12 */
/* 134 */	0x9,		/* Corr desc: FC_ULONG */
			0x0,		/*  */
/* 136 */	NdrFcShort( 0xfffc ),	/* -4 */
/* 138 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 140 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 142 */	NdrFcShort( 0xffea ),	/* Offset= -22 (120) */
/* 144 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 146 */	
			0x17,		/* FC_CSTRUCT */
			0x3,		/* 3 */
/* 148 */	NdrFcShort( 0x4 ),	/* 4 */
/* 150 */	NdrFcShort( 0xffec ),	/* Offset= -20 (130) */
/* 152 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 154 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 156 */	NdrFcShort( 0x10 ),	/* 16 */
/* 158 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 160 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 162 */	NdrFcShort( 0x4 ),	/* 4 */
/* 164 */	NdrFcShort( 0x4 ),	/* 4 */
/* 166 */	0x12, 0x0,	/* FC_UP */
/* 168 */	NdrFcShort( 0xffac ),	/* Offset= -84 (84) */
/* 170 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 172 */	NdrFcShort( 0x8 ),	/* 8 */
/* 174 */	NdrFcShort( 0x8 ),	/* 8 */
/* 176 */	0x12, 0x0,	/* FC_UP */
/* 178 */	NdrFcShort( 0xffa2 ),	/* Offset= -94 (84) */
/* 180 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 182 */	NdrFcShort( 0xc ),	/* 12 */
/* 184 */	NdrFcShort( 0xc ),	/* 12 */
/* 186 */	0x12, 0x0,	/* FC_UP */
/* 188 */	NdrFcShort( 0xffd6 ),	/* Offset= -42 (146) */
/* 190 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 192 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 194 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 196 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 198 */	NdrFcShort( 0xe0 ),	/* Offset= 224 (422) */
/* 200 */	
			0x1d,		/* FC_SMFARRAY */
			0x0,		/* 0 */
/* 202 */	NdrFcShort( 0x10 ),	/* 16 */
/* 204 */	0x2,		/* FC_CHAR */
			0x5b,		/* FC_END */
/* 206 */	
			0x1d,		/* FC_SMFARRAY */
			0x3,		/* 3 */
/* 208 */	NdrFcShort( 0x28 ),	/* 40 */
/* 210 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 212 */	
			0x1c,		/* FC_CVARRAY */
			0x1,		/* 1 */
/* 214 */	NdrFcShort( 0x2 ),	/* 2 */
/* 216 */	0x17,		/* Corr desc:  field pointer, FC_USHORT */
			0x55,		/* FC_DIV_2 */
/* 218 */	NdrFcShort( 0x32 ),	/* 50 */
/* 220 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 222 */	0x17,		/* Corr desc:  field pointer, FC_USHORT */
			0x55,		/* FC_DIV_2 */
/* 224 */	NdrFcShort( 0x30 ),	/* 48 */
/* 226 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 228 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 230 */	
			0x1c,		/* FC_CVARRAY */
			0x1,		/* 1 */
/* 232 */	NdrFcShort( 0x2 ),	/* 2 */
/* 234 */	0x17,		/* Corr desc:  field pointer, FC_USHORT */
			0x55,		/* FC_DIV_2 */
/* 236 */	NdrFcShort( 0x3a ),	/* 58 */
/* 238 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 240 */	0x17,		/* Corr desc:  field pointer, FC_USHORT */
			0x55,		/* FC_DIV_2 */
/* 242 */	NdrFcShort( 0x38 ),	/* 56 */
/* 244 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 246 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 248 */	
			0x1c,		/* FC_CVARRAY */
			0x1,		/* 1 */
/* 250 */	NdrFcShort( 0x2 ),	/* 2 */
/* 252 */	0x17,		/* Corr desc:  field pointer, FC_USHORT */
			0x55,		/* FC_DIV_2 */
/* 254 */	NdrFcShort( 0x42 ),	/* 66 */
/* 256 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 258 */	0x17,		/* Corr desc:  field pointer, FC_USHORT */
			0x55,		/* FC_DIV_2 */
/* 260 */	NdrFcShort( 0x40 ),	/* 64 */
/* 262 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 264 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 266 */	
			0x1c,		/* FC_CVARRAY */
			0x1,		/* 1 */
/* 268 */	NdrFcShort( 0x2 ),	/* 2 */
/* 270 */	0x17,		/* Corr desc:  field pointer, FC_USHORT */
			0x55,		/* FC_DIV_2 */
/* 272 */	NdrFcShort( 0x4a ),	/* 74 */
/* 274 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 276 */	0x17,		/* Corr desc:  field pointer, FC_USHORT */
			0x55,		/* FC_DIV_2 */
/* 278 */	NdrFcShort( 0x48 ),	/* 72 */
/* 280 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 282 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 284 */	
			0x1c,		/* FC_CVARRAY */
			0x1,		/* 1 */
/* 286 */	NdrFcShort( 0x2 ),	/* 2 */
/* 288 */	0x17,		/* Corr desc:  field pointer, FC_USHORT */
			0x55,		/* FC_DIV_2 */
/* 290 */	NdrFcShort( 0x52 ),	/* 82 */
/* 292 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 294 */	0x17,		/* Corr desc:  field pointer, FC_USHORT */
			0x55,		/* FC_DIV_2 */
/* 296 */	NdrFcShort( 0x50 ),	/* 80 */
/* 298 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 300 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 302 */	
			0x1c,		/* FC_CVARRAY */
			0x1,		/* 1 */
/* 304 */	NdrFcShort( 0x2 ),	/* 2 */
/* 306 */	0x17,		/* Corr desc:  field pointer, FC_USHORT */
			0x55,		/* FC_DIV_2 */
/* 308 */	NdrFcShort( 0x5a ),	/* 90 */
/* 310 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 312 */	0x17,		/* Corr desc:  field pointer, FC_USHORT */
			0x55,		/* FC_DIV_2 */
/* 314 */	NdrFcShort( 0x58 ),	/* 88 */
/* 316 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 318 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 320 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 322 */	NdrFcShort( 0x8 ),	/* 8 */
/* 324 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 326 */	NdrFcShort( 0x6c ),	/* 108 */
/* 328 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 330 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 332 */	NdrFcShort( 0xff24 ),	/* Offset= -220 (112) */
/* 334 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 336 */	
			0x1c,		/* FC_CVARRAY */
			0x1,		/* 1 */
/* 338 */	NdrFcShort( 0x2 ),	/* 2 */
/* 340 */	0x17,		/* Corr desc:  field pointer, FC_USHORT */
			0x55,		/* FC_DIV_2 */
/* 342 */	NdrFcShort( 0x8a ),	/* 138 */
/* 344 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 346 */	0x17,		/* Corr desc:  field pointer, FC_USHORT */
			0x55,		/* FC_DIV_2 */
/* 348 */	NdrFcShort( 0x88 ),	/* 136 */
/* 350 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 352 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 354 */	
			0x1c,		/* FC_CVARRAY */
			0x1,		/* 1 */
/* 356 */	NdrFcShort( 0x2 ),	/* 2 */
/* 358 */	0x17,		/* Corr desc:  field pointer, FC_USHORT */
			0x55,		/* FC_DIV_2 */
/* 360 */	NdrFcShort( 0x92 ),	/* 146 */
/* 362 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 364 */	0x17,		/* Corr desc:  field pointer, FC_USHORT */
			0x55,		/* FC_DIV_2 */
/* 366 */	NdrFcShort( 0x90 ),	/* 144 */
/* 368 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 370 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 372 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 374 */	NdrFcShort( 0x8 ),	/* 8 */
/* 376 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 378 */	NdrFcShort( 0xc4 ),	/* 196 */
/* 380 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 382 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 384 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 386 */	NdrFcShort( 0x8 ),	/* 8 */
/* 388 */	NdrFcShort( 0x0 ),	/* 0 */
/* 390 */	NdrFcShort( 0x1 ),	/* 1 */
/* 392 */	NdrFcShort( 0x0 ),	/* 0 */
/* 394 */	NdrFcShort( 0x0 ),	/* 0 */
/* 396 */	0x12, 0x0,	/* FC_UP */
/* 398 */	NdrFcShort( 0xfe94 ),	/* Offset= -364 (34) */
/* 400 */	
			0x5b,		/* FC_END */

			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 402 */	0x0,		/* 0 */
			NdrFcShort( 0xfe9d ),	/* Offset= -355 (48) */
			0x5b,		/* FC_END */
/* 406 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 408 */	NdrFcShort( 0x8 ),	/* 8 */
/* 410 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 412 */	NdrFcShort( 0xd0 ),	/* 208 */
/* 414 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 416 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 418 */	NdrFcShort( 0xfece ),	/* Offset= -306 (112) */
/* 420 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 422 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 424 */	NdrFcShort( 0xd8 ),	/* 216 */
/* 426 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 428 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 430 */	NdrFcShort( 0x34 ),	/* 52 */
/* 432 */	NdrFcShort( 0x34 ),	/* 52 */
/* 434 */	0x12, 0x0,	/* FC_UP */
/* 436 */	NdrFcShort( 0xff20 ),	/* Offset= -224 (212) */
/* 438 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 440 */	NdrFcShort( 0x3c ),	/* 60 */
/* 442 */	NdrFcShort( 0x3c ),	/* 60 */
/* 444 */	0x12, 0x0,	/* FC_UP */
/* 446 */	NdrFcShort( 0xff28 ),	/* Offset= -216 (230) */
/* 448 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 450 */	NdrFcShort( 0x44 ),	/* 68 */
/* 452 */	NdrFcShort( 0x44 ),	/* 68 */
/* 454 */	0x12, 0x0,	/* FC_UP */
/* 456 */	NdrFcShort( 0xff30 ),	/* Offset= -208 (248) */
/* 458 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 460 */	NdrFcShort( 0x4c ),	/* 76 */
/* 462 */	NdrFcShort( 0x4c ),	/* 76 */
/* 464 */	0x12, 0x0,	/* FC_UP */
/* 466 */	NdrFcShort( 0xff38 ),	/* Offset= -200 (266) */
/* 468 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 470 */	NdrFcShort( 0x54 ),	/* 84 */
/* 472 */	NdrFcShort( 0x54 ),	/* 84 */
/* 474 */	0x12, 0x0,	/* FC_UP */
/* 476 */	NdrFcShort( 0xff40 ),	/* Offset= -192 (284) */
/* 478 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 480 */	NdrFcShort( 0x5c ),	/* 92 */
/* 482 */	NdrFcShort( 0x5c ),	/* 92 */
/* 484 */	0x12, 0x0,	/* FC_UP */
/* 486 */	NdrFcShort( 0xff48 ),	/* Offset= -184 (302) */
/* 488 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 490 */	NdrFcShort( 0x70 ),	/* 112 */
/* 492 */	NdrFcShort( 0x70 ),	/* 112 */
/* 494 */	0x12, 0x0,	/* FC_UP */
/* 496 */	NdrFcShort( 0xff50 ),	/* Offset= -176 (320) */
/* 498 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 500 */	NdrFcShort( 0x8c ),	/* 140 */
/* 502 */	NdrFcShort( 0x8c ),	/* 140 */
/* 504 */	0x12, 0x0,	/* FC_UP */
/* 506 */	NdrFcShort( 0xff56 ),	/* Offset= -170 (336) */
/* 508 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 510 */	NdrFcShort( 0x94 ),	/* 148 */
/* 512 */	NdrFcShort( 0x94 ),	/* 148 */
/* 514 */	0x12, 0x0,	/* FC_UP */
/* 516 */	NdrFcShort( 0xff5e ),	/* Offset= -162 (354) */
/* 518 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 520 */	NdrFcShort( 0x98 ),	/* 152 */
/* 522 */	NdrFcShort( 0x98 ),	/* 152 */
/* 524 */	0x12, 0x0,	/* FC_UP */
/* 526 */	NdrFcShort( 0xfe14 ),	/* Offset= -492 (34) */
/* 528 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 530 */	NdrFcShort( 0xc8 ),	/* 200 */
/* 532 */	NdrFcShort( 0xc8 ),	/* 200 */
/* 534 */	0x12, 0x0,	/* FC_UP */
/* 536 */	NdrFcShort( 0xff5c ),	/* Offset= -164 (372) */
/* 538 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 540 */	NdrFcShort( 0xcc ),	/* 204 */
/* 542 */	NdrFcShort( 0xcc ),	/* 204 */
/* 544 */	0x12, 0x0,	/* FC_UP */
/* 546 */	NdrFcShort( 0xfe00 ),	/* Offset= -512 (34) */
/* 548 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 550 */	NdrFcShort( 0xd4 ),	/* 212 */
/* 552 */	NdrFcShort( 0xd4 ),	/* 212 */
/* 554 */	0x12, 0x0,	/* FC_UP */
/* 556 */	NdrFcShort( 0xff6a ),	/* Offset= -150 (406) */
/* 558 */	
			0x5b,		/* FC_END */

			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 560 */	0x0,		/* 0 */
			NdrFcShort( 0xfe3f ),	/* Offset= -449 (112) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 564 */	0x0,		/* 0 */
			NdrFcShort( 0xfe3b ),	/* Offset= -453 (112) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 568 */	0x0,		/* 0 */
			NdrFcShort( 0xfe37 ),	/* Offset= -457 (112) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 572 */	0x0,		/* 0 */
			NdrFcShort( 0xfe33 ),	/* Offset= -461 (112) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 576 */	0x0,		/* 0 */
			NdrFcShort( 0xfe2f ),	/* Offset= -465 (112) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 580 */	0x0,		/* 0 */
			NdrFcShort( 0xfe2b ),	/* Offset= -469 (112) */
			0x6,		/* FC_SHORT */
/* 584 */	0x6,		/* FC_SHORT */
			0x8,		/* FC_LONG */
/* 586 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 588 */	0x8,		/* FC_LONG */
			0x6,		/* FC_SHORT */
/* 590 */	0x6,		/* FC_SHORT */
			0x8,		/* FC_LONG */
/* 592 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 594 */	0x8,		/* FC_LONG */
			0x6,		/* FC_SHORT */
/* 596 */	0x6,		/* FC_SHORT */
			0x8,		/* FC_LONG */
/* 598 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 600 */	0x8,		/* FC_LONG */
			0x6,		/* FC_SHORT */
/* 602 */	0x6,		/* FC_SHORT */
			0x8,		/* FC_LONG */
/* 604 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 606 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 608 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 610 */	NdrFcShort( 0xfe66 ),	/* Offset= -410 (200) */
/* 612 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 614 */	0x8,		/* FC_LONG */
			0x6,		/* FC_SHORT */
/* 616 */	0x6,		/* FC_SHORT */
			0x8,		/* FC_LONG */
/* 618 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 620 */	0x0,		/* 0 */
			NdrFcShort( 0xfe61 ),	/* Offset= -415 (206) */
			0x8,		/* FC_LONG */
/* 624 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 626 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 628 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 630 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 632 */	NdrFcShort( 0x52 ),	/* Offset= 82 (714) */
/* 634 */	
			0x1c,		/* FC_CVARRAY */
			0x1,		/* 1 */
/* 636 */	NdrFcShort( 0x2 ),	/* 2 */
/* 638 */	0x17,		/* Corr desc:  field pointer, FC_USHORT */
			0x55,		/* FC_DIV_2 */
/* 640 */	NdrFcShort( 0x2 ),	/* 2 */
/* 642 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 644 */	0x17,		/* Corr desc:  field pointer, FC_USHORT */
			0x55,		/* FC_DIV_2 */
/* 646 */	NdrFcShort( 0x0 ),	/* 0 */
/* 648 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 650 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 652 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 654 */	NdrFcShort( 0x1 ),	/* 1 */
/* 656 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 658 */	NdrFcShort( 0x8 ),	/* 8 */
/* 660 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 662 */	0x2,		/* FC_CHAR */
			0x5b,		/* FC_END */
/* 664 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 666 */	NdrFcShort( 0x10 ),	/* 16 */
/* 668 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 670 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 672 */	NdrFcShort( 0x4 ),	/* 4 */
/* 674 */	NdrFcShort( 0x4 ),	/* 4 */
/* 676 */	0x12, 0x0,	/* FC_UP */
/* 678 */	NdrFcShort( 0xffd4 ),	/* Offset= -44 (634) */
/* 680 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 682 */	NdrFcShort( 0xc ),	/* 12 */
/* 684 */	NdrFcShort( 0xc ),	/* 12 */
/* 686 */	0x12, 0x0,	/* FC_UP */
/* 688 */	NdrFcShort( 0xffdc ),	/* Offset= -36 (652) */
/* 690 */	
			0x5b,		/* FC_END */

			0x6,		/* FC_SHORT */
/* 692 */	0x6,		/* FC_SHORT */
			0x8,		/* FC_LONG */
/* 694 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 696 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 698 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 700 */	NdrFcShort( 0x10 ),	/* 16 */
/* 702 */	0x9,		/* Corr desc: FC_ULONG */
			0x0,		/*  */
/* 704 */	NdrFcShort( 0xfffc ),	/* -4 */
/* 706 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 708 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 710 */	NdrFcShort( 0xffd2 ),	/* Offset= -46 (664) */
/* 712 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 714 */	
			0x18,		/* FC_CPSTRUCT */
			0x3,		/* 3 */
/* 716 */	NdrFcShort( 0x4 ),	/* 4 */
/* 718 */	NdrFcShort( 0xffec ),	/* Offset= -20 (698) */
/* 720 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 722 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 724 */	NdrFcShort( 0x10 ),	/* 16 */
/* 726 */	NdrFcShort( 0x4 ),	/* 4 */
/* 728 */	NdrFcShort( 0x2 ),	/* 2 */
/* 730 */	NdrFcShort( 0x8 ),	/* 8 */
/* 732 */	NdrFcShort( 0x8 ),	/* 8 */
/* 734 */	0x12, 0x0,	/* FC_UP */
/* 736 */	NdrFcShort( 0xff9a ),	/* Offset= -102 (634) */
/* 738 */	NdrFcShort( 0x10 ),	/* 16 */
/* 740 */	NdrFcShort( 0x10 ),	/* 16 */
/* 742 */	0x12, 0x0,	/* FC_UP */
/* 744 */	NdrFcShort( 0xffa4 ),	/* Offset= -92 (652) */
/* 746 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 748 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */

			0x0
        }
    };

static const unsigned short Pac_FormatStringOffsetTable[] =
    {
    0
    };


static const MIDL_STUB_DESC Pac_StubDesc = 
    {
    (void *)& Pac___RpcClientInterface,
    MIDL_user_allocate,
    MIDL_user_free,
    &Pac__MIDL_AutoBindHandle,
    0,
    0,
    0,
    0,
    pacndr__MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x60000, /* Ndr library version */
    0,
    0x70001e6, /* MIDL Version 7.0.486 */
    0,
    0,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0
    };
#pragma optimize("", on )
#if _MSC_VER >= 1200
#pragma warning(pop)
#endif


#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\inc\exterr.h ===
//+-----------------------------------------------------------------------
//
// File:        exterr.h
//
// Contents:    Kerberos extended error structures and macros
//
// History:     23-Feb-2000    Todds   Created
//             
//
//------------------------------------------------------------------------

#ifndef __EXTERR_H__
#define __EXTERR_H__

//
// This macro is universally used for extended errors
//
#define EXT_ERROR_SUCCESS(s)             (NT_SUCCESS(s.status))

//
// defines for flags member of KERB_EXT_ERROR structure
//
#define  EXT_ERROR_CLIENT_INFO      0x1   // this is an extended error for use by client
// is there a useful NTSTATUS embedded in returned error?
#define  EXT_CLIENT_INFO_PRESENT(p)    ((NULL != p) && (p->flags&EXT_ERROR_CLIENT_INFO) && (p->status)) 





#endif // __EXTERR_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\inc\kdb.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001
//
//  File:       kdb.h
//
//  Contents:
//
//  History:    5/10/2001    richardw     Created
//----------------------------------------------------------------------------

#ifndef __KDB_H__
#define __KDB_H__

#include <kdcsvr.hxx>

extern UNICODE_STRING KrbtgtName;
#if 0
PKDB_REALM
KdbGetRealm(
    KDB_HANDLE KdbHandle
    );
#endif

KERBERR
KdbRealmLocate(
    IN OPTIONAL PUNICODE_STRING Realm,
    OUT PIKdbProvider *ppiKdb
    );



extern IEvent *coreEventObject;
/*
//  KdbReportEventW(
//                IN IEvent::TYPE                     EventType,
//                IN DWORD                            dwEventId,
//                IN DWORD                            dwRawDataSize,
//                IN const PBYTE                      pbRawData,
//                IN WORD                              dwStringCount,
//                ...
//                )
//  Example Usage:
//  KdbReportEventW(
//                IEvent::INFORMATION_TYPE,
//                PROVIDER_LOADED,
//                0,
//                NULL,
//                1,
//                lpszProvider                              //WCHAR *
//                );
                
*/
#define KdbReportEventW  if (coreEventObject) coreEventObject->ReportEventFullW

/*
//  KdbReportEventU(
//                IN IEvent::TYPE                     EventType,
//                IN DWORD                            dwEventId,
//                IN DWORD                            dwRawDataSize,
//                IN const PBYTE                      pbRawData,
//                IN WORD                              dwUnicodeStringCount,
//                ...
//                )
//  Example Usage:
//  KdbReportEventU(
//                IEvent::INFORMATION_TYPE,
//                PROVIDER_LOADED,
//                0,
//                NULL,
//                1,
//                pustrProvider                              //PUNICODE_STRING
//                );
                
*/
#define KdbReportEventU if (coreEventObject) coreEventObject->ReportEventFullU

NTSTATUS
KdbAuditEvent(
    IN PIKdbProvider       KdbHandle,      // Realm handle
    IN KDC_AUDIT_EVENT  AuditId,
    IN PIKerbRequest  pIKerbRequest,
    IN PKERBERR         KerbStatus,
    IN PULONG           KdcOptions,
    IN PKERB_CRYPT_LIST EncryptionType,
    IN PULONG           PreauthType,
    IN PSOCKADDR        ClientAddress
    );

/*
NTSTATUS
KdbAuditEvent(
    IN PIKdbProvider    KdbHandle,
    IN KDC_AUDIT_EVENT  AuditId,
    IN PIKerbPrincipal  ClientInfo,
    IN PIKerbPrincipal  ServiceInfo,
    IN PKERBERR         KerbStatus,
    IN PULONG           KdcOptions,
    IN PKERB_CRYPT_LIST pETypes,
    IN PULONG           PreauthType,
    IN PSOCKADDR        ClientAddress
    );
*/
NTSTATUS
KdbPerfCount(
    IN PIKdbProvider    kdb_handle,
    IN KERB_PERF_COUNTER counter
    );

#endif // __KDB_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\inc\fileno.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       fileno.h
//
//  Stolen from DS line number obfuscation macros
//
//--------------------------------------------------------------------------

//
// fileno.h - defines symbolic constants  for kerberos c code
// files. File numbers are 16 bit values. The high byte is the directory number and
// the low byte is the file number within the directory.
//

// Why not make the macro have just one arg, since line is always
// __LINE__?  Because if we did then __LINE__ would be evaluated here,
// rather than at the invocation of the macro, and so would always
// have the value 11.
#define KLIN(fileno,line) (((fileno) << 16) | (line))

//
//  *** NOTE: ***
//
//  If you add FILENO_*'s to this list, be sure to make a corresponding update
//  to kerberos\utest\klin.c so that dsid.exe can properly decode the DSID
//  corresponding to the new file.
//
//  If you add DIRNO_*'s to this list, be sure to make a corresponding update
//  to ds\src\dscommon\dsvent.c - rEventSourceMappings[].
//

// define directory numbers

#define DIRNO_CLIENT2   (0)                             // \client2
#define DIRNO_COMMON2   (1 << 8)                        // \common2
#define DIRNO_KERNEL    (2 << 8)                        // \kernel
#define DIRNO_RTL       (3 << 8)                        // \rtl
#define DIRNO_SERVER    (4 << 8)                        // \server
#define DIRNO_KDB	(5 << 8)			// \server\layers

// client2 directory
#define FILENO_BNDCACHE         (DIRNO_CLIENT2 + 0)      // bndcache.cxx
#define FILENO_CREDAPI          (DIRNO_CLIENT2 + 1)      // credapi.cxx
#define FILENO_CREDMGR          (DIRNO_CLIENT2 + 2)      // credmgr.cxx
#define FILENO_CTXTAPI          (DIRNO_CLIENT2 + 3)      // ctxtapi.cxx
#define FILENO_CTXTMGR          (DIRNO_CLIENT2 + 4)      // ctxtmgr.cxx
#define FILENO_GSSUTIL          (DIRNO_CLIENT2 + 5)      // gssutil.cxx
#define FILENO_KERBEROS         (DIRNO_CLIENT2 + 6)      // kerberos.cxx
#define FILENO_KERBLIST         (DIRNO_CLIENT2 + 7)      // kerblist.cxx
#define FILENO_KERBPASS         (DIRNO_CLIENT2 + 8)      // kerbpass.cxx
#define FILENO_KERBTICK         (DIRNO_CLIENT2 + 9)      // kerbtick.cxx
#define FILENO_KERBUTIL         (DIRNO_CLIENT2 + 10)     // kerbutil.cxx
#define FILENO_KERBWOW          (DIRNO_CLIENT2 + 11)     // kerbwow.cxx
#define FILENO_KRBEVENT         (DIRNO_CLIENT2 + 12)     // krbevent.cxx
#define FILENO_KRBTOKEN         (DIRNO_CLIENT2 + 13)     // krbtoken.cxx
#define FILENO_LOGONAPI         (DIRNO_CLIENT2 + 14)     // logonapi.cxx
#define FILENO_MISCAPI          (DIRNO_CLIENT2 + 15)     // miscapi.cxx
#define FILENO_MITUTIL          (DIRNO_CLIENT2 + 16)     // mitutil.cxx
#define FILENO_PKAUTH           (DIRNO_CLIENT2 + 17)     // pkauth.cxx
#define FILENO_PROXYAPI         (DIRNO_CLIENT2 + 18)     // proxyapi.cxx
#define FILENO_RPCUTIL          (DIRNO_CLIENT2 + 19)     // rpcutil.cxx
#define FILENO_SIDCACHE         (DIRNO_CLIENT2 + 20)     // sidcache.cxx
#define FILENO_TIMESYNC         (DIRNO_CLIENT2 + 21)     // timesync.cxx
#define FILENO_TKTCACHE         (DIRNO_CLIENT2 + 22)     // tktcache.cxx
#define FILENO_TKTLOGON         (DIRNO_CLIENT2 + 23)     // tktlogon.cxx
#define FILENO_USERAPI          (DIRNO_CLIENT2 + 24)     // userapi.cxx
#define FILENO_USERLIST         (DIRNO_CLIENT2 + 25)     // userlist.cxx
                       
// common2 directory
#define FILENO_AUTHEN           (DIRNO_COMMON2 + 0)       // authen.cxx
#define FILENO_CRYPT            (DIRNO_COMMON2 + 1)       // crypt.c
#define FILENO_KEYGEN           (DIRNO_COMMON2 + 2)       // keygen.c
#define FILENO_KRB5             (DIRNO_COMMON2 + 3)       // krb5.c
#define FILENO_NAMES            (DIRNO_COMMON2 + 4)       // names.cxx
#define FILENO_PASSWD           (DIRNO_COMMON2 + 5)       // passwd.c
#define FILENO_RESTRICT         (DIRNO_COMMON2 + 6)       // restrict.cxx
#define FILENO_SOCKETS          (DIRNO_COMMON2 + 7)       // sockets.cxx
#define FILENO_TICKETS          (DIRNO_COMMON2 + 8)       // tickets.cxx


// kernel directory
#define FILENO_CPGSSUTL            (DIRNO_KERNEL + 0)         // cpgssutl.cxx
#define FILENO_CTXTMGR2            (DIRNO_KERNEL + 1)         // ctxtmgr.cxx
#define FILENO_KERBLIST2           (DIRNO_KERNEL + 2)         // kerblist.cxx
#define FILENO_KRNLAPI             (DIRNO_KERNEL + 3)         // krnlapi.cxxc

// RTL directory       
#define FILENO_AUTHDATA         (DIRNO_RTL + 0)     // authdata.cxx
#define FILENO_CRACKPAC         (DIRNO_RTL + 1)     // crackpac.cxx
#define FILENO_CRED             (DIRNO_RTL + 2)     // cred.cxx
#define FILENO_CREDLIST         (DIRNO_RTL + 3)     // credlist.cxx
#define FILENO_CREDLOCK         (DIRNO_RTL + 4)     // credlock.cxx
#define FILENO_DBUTIL           (DIRNO_RTL + 5)     // dbutil.cxx
#define FILENO_DBOPEN           (DIRNO_RTL + 6)     // domain.cxx
#define FILENO_DOMCACHE         (DIRNO_RTL + 7)     // domcache.cxx
#define FILENO_FILTER           (DIRNO_RTL + 8)     // filter.cxx
#define FILENO_MAPERR           (DIRNO_RTL + 9)     // maperr.cxx
#define FILENO_MAPSECER         (DIRNO_RTL + 10)    // mapsecerr.cxx
#define FILENO_MISCID           (DIRNO_RTL + 11)    // miscid.cxx
#define FILENO_PAC              (DIRNO_RTL + 12)    // pac.cxx
#define FILENO_PAC2             (DIRNO_RTL + 13)    // pac2.cxx
#define FILENO_PARMCHK          (DIRNO_RTL + 14)    // parmchk.cxx
#define FILENO_REG	            (DIRNO_RTL + 15)    // reg.cxx
#define FILENO_SECSTR           (DIRNO_RTL + 16)    // secstr.cxx
#define FILENO_SERVICES         (DIRNO_RTL + 17)    // services.c
#define FILENO_STRING           (DIRNO_RTL + 18)    // string.cxx
#define FILENO_TIMESERV         (DIRNO_RTL + 19)    // timeserv.cxx
#define FILENO_TOKENUTL         (DIRNO_RTL + 20)    // tokenutl.cxx
#define FILENO_TRNSPORT         (DIRNO_RTL + 21)    // trnsport.cxx

// Server directory       
#define FILENO_DEBUG            (DIRNO_SERVER + 0)     // debug.cxx
#define FILENO_DGUTIL           (DIRNO_SERVER + 1)     // dgutil.cxx
#define FILENO_EVENTS           (DIRNO_SERVER + 2)     // events.cxx
#define FILENO_GETAS            (DIRNO_SERVER + 3)     // getas.cxx
#define FILENO_GETTGS           (DIRNO_SERVER + 4)     // gettgs.cxx
#define FILENO_KDC              (DIRNO_SERVER + 5)     // kdc.cxx
#define FILENO_KDCTRACE         (DIRNO_SERVER + 6)     // kdctrace.cxx
#define FILENO_KPASSWD          (DIRNO_SERVER + 7)     // kpasswd.cxx
#define FILENO_NOTIFY2          (DIRNO_SERVER + 8)     // notify2.cxx
#define FILENO_SRVPAC           (DIRNO_SERVER + 9)     // pac.cxx
#define FILENO_PKSERV           (DIRNO_SERVER + 10)    // pkserv.cxx
#define FILENO_REFER            (DIRNO_SERVER + 11)    // refer.cxx
#define FILENO_RPCIF            (DIRNO_SERVER + 12)    // rpcif.cxx
#define FILENO_SECDATA          (DIRNO_SERVER + 13)    // secdata.cxx
#define FILENO_SOCKUTIL         (DIRNO_SERVER + 14)    // sockutil.cxx
#define FILENO_TKTUTIL          (DIRNO_SERVER + 15)    // tktutil.cxx
#define FILENO_TRANSIT          (DIRNO_SERVER + 16)    // transit.cxx

// KDB interface
#define FILENO_KDBSAM		(DIRNO_KDB + 0)	       // kdbsam.cxx
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\idl_prebuilt\pacndr_s.c ===
/* this ALWAYS GENERATED file contains the RPC server stubs */


 /* File created by MIDL compiler version 7.00.0486 */
/* Compiler settings for pacndr.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, oldnames, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)


#pragma warning( disable: 4049 )  /* more than 64k source lines */
#if _MSC_VER >= 1200
#pragma warning(push)
#endif

#pragma warning( disable: 4211 )  /* redefine extern to static */
#pragma warning( disable: 4232 )  /* dllimport identity*/
#pragma warning( disable: 4024 )  /* array to pointer mapping*/
#pragma warning( disable: 4100 ) /* unreferenced arguments in x86 call */

#pragma optimize("", off ) 

#include <string.h>
#include "pacndr.h"

#define TYPE_FORMAT_STRING_SIZE   751                               
#define PROC_FORMAT_STRING_SIZE   1                                 
#define EXPR_FORMAT_STRING_SIZE   1                                 
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   0            

typedef struct _pacndr_MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } pacndr_MIDL_TYPE_FORMAT_STRING;

typedef struct _pacndr_MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } pacndr_MIDL_PROC_FORMAT_STRING;

typedef struct _pacndr_MIDL_EXPR_FORMAT_STRING
    {
    long          Pad;
    unsigned char  Format[ EXPR_FORMAT_STRING_SIZE ];
    } pacndr_MIDL_EXPR_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};

extern const pacndr_MIDL_TYPE_FORMAT_STRING pacndr__MIDL_TypeFormatString;
extern const pacndr_MIDL_PROC_FORMAT_STRING pacndr__MIDL_ProcFormatString;
extern const pacndr_MIDL_EXPR_FORMAT_STRING pacndr__MIDL_ExprFormatString;

#if !defined(__RPC_WIN32__)
#error  Invalid build platform for this stub.
#endif
#if !(TARGET_IS_NT51_OR_LATER)
#error You need a Windows XP or later to run this stub because it uses these features:
#error   #error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
#error This app will fail with the RPC_X_WRONG_STUB_VERSION error.
#endif


static const pacndr_MIDL_PROC_FORMAT_STRING pacndr__MIDL_ProcFormatString =
    {
        0,
        {

			0x0
        }
    };

static const pacndr_MIDL_TYPE_FORMAT_STRING pacndr__MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/*  4 */	NdrFcShort( 0x96 ),	/* Offset= 150 (154) */
/*  6 */	
			0x1d,		/* FC_SMFARRAY */
			0x0,		/* 0 */
/*  8 */	NdrFcShort( 0x6 ),	/* 6 */
/* 10 */	0x2,		/* FC_CHAR */
			0x5b,		/* FC_END */
/* 12 */	
			0x15,		/* FC_STRUCT */
			0x0,		/* 0 */
/* 14 */	NdrFcShort( 0x6 ),	/* 6 */
/* 16 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 18 */	NdrFcShort( 0xfff4 ),	/* Offset= -12 (6) */
/* 20 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 22 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 24 */	NdrFcShort( 0x4 ),	/* 4 */
/* 26 */	0x4,		/* Corr desc: FC_USMALL */
			0x0,		/*  */
/* 28 */	NdrFcShort( 0xfff9 ),	/* -7 */
/* 30 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 32 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 34 */	
			0x17,		/* FC_CSTRUCT */
			0x3,		/* 3 */
/* 36 */	NdrFcShort( 0x8 ),	/* 8 */
/* 38 */	NdrFcShort( 0xfff0 ),	/* Offset= -16 (22) */
/* 40 */	0x2,		/* FC_CHAR */
			0x2,		/* FC_CHAR */
/* 42 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 44 */	NdrFcShort( 0xffe0 ),	/* Offset= -32 (12) */
/* 46 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 48 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 50 */	NdrFcShort( 0x8 ),	/* 8 */
/* 52 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 54 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 56 */	NdrFcShort( 0x0 ),	/* 0 */
/* 58 */	NdrFcShort( 0x0 ),	/* 0 */
/* 60 */	0x12, 0x0,	/* FC_UP */
/* 62 */	NdrFcShort( 0xffe4 ),	/* Offset= -28 (34) */
/* 64 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 66 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 68 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 70 */	NdrFcShort( 0x8 ),	/* 8 */
/* 72 */	0x9,		/* Corr desc: FC_ULONG */
			0x0,		/*  */
/* 74 */	NdrFcShort( 0xfffc ),	/* -4 */
/* 76 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 78 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 80 */	NdrFcShort( 0xffe0 ),	/* Offset= -32 (48) */
/* 82 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 84 */	
			0x18,		/* FC_CPSTRUCT */
			0x3,		/* 3 */
/* 86 */	NdrFcShort( 0x4 ),	/* 4 */
/* 88 */	NdrFcShort( 0xffec ),	/* Offset= -20 (68) */
/* 90 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 92 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 94 */	NdrFcShort( 0x8 ),	/* 8 */
/* 96 */	NdrFcShort( 0x4 ),	/* 4 */
/* 98 */	NdrFcShort( 0x1 ),	/* 1 */
/* 100 */	NdrFcShort( 0x4 ),	/* 4 */
/* 102 */	NdrFcShort( 0x4 ),	/* 4 */
/* 104 */	0x12, 0x0,	/* FC_UP */
/* 106 */	NdrFcShort( 0xffb8 ),	/* Offset= -72 (34) */
/* 108 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 110 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 112 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 114 */	NdrFcShort( 0x8 ),	/* 8 */
/* 116 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 118 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 120 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 122 */	NdrFcShort( 0xc ),	/* 12 */
/* 124 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 126 */	NdrFcShort( 0xfff2 ),	/* Offset= -14 (112) */
/* 128 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 130 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 132 */	NdrFcShort( 0xc ),	/* 12 */
/* 134 */	0x9,		/* Corr desc: FC_ULONG */
			0x0,		/*  */
/* 136 */	NdrFcShort( 0xfffc ),	/* -4 */
/* 138 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 140 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 142 */	NdrFcShort( 0xffea ),	/* Offset= -22 (120) */
/* 144 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 146 */	
			0x17,		/* FC_CSTRUCT */
			0x3,		/* 3 */
/* 148 */	NdrFcShort( 0x4 ),	/* 4 */
/* 150 */	NdrFcShort( 0xffec ),	/* Offset= -20 (130) */
/* 152 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 154 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 156 */	NdrFcShort( 0x10 ),	/* 16 */
/* 158 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 160 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 162 */	NdrFcShort( 0x4 ),	/* 4 */
/* 164 */	NdrFcShort( 0x4 ),	/* 4 */
/* 166 */	0x12, 0x0,	/* FC_UP */
/* 168 */	NdrFcShort( 0xffac ),	/* Offset= -84 (84) */
/* 170 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 172 */	NdrFcShort( 0x8 ),	/* 8 */
/* 174 */	NdrFcShort( 0x8 ),	/* 8 */
/* 176 */	0x12, 0x0,	/* FC_UP */
/* 178 */	NdrFcShort( 0xffa2 ),	/* Offset= -94 (84) */
/* 180 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 182 */	NdrFcShort( 0xc ),	/* 12 */
/* 184 */	NdrFcShort( 0xc ),	/* 12 */
/* 186 */	0x12, 0x0,	/* FC_UP */
/* 188 */	NdrFcShort( 0xffd6 ),	/* Offset= -42 (146) */
/* 190 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 192 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 194 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 196 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 198 */	NdrFcShort( 0xe0 ),	/* Offset= 224 (422) */
/* 200 */	
			0x1d,		/* FC_SMFARRAY */
			0x0,		/* 0 */
/* 202 */	NdrFcShort( 0x10 ),	/* 16 */
/* 204 */	0x2,		/* FC_CHAR */
			0x5b,		/* FC_END */
/* 206 */	
			0x1d,		/* FC_SMFARRAY */
			0x3,		/* 3 */
/* 208 */	NdrFcShort( 0x28 ),	/* 40 */
/* 210 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 212 */	
			0x1c,		/* FC_CVARRAY */
			0x1,		/* 1 */
/* 214 */	NdrFcShort( 0x2 ),	/* 2 */
/* 216 */	0x17,		/* Corr desc:  field pointer, FC_USHORT */
			0x55,		/* FC_DIV_2 */
/* 218 */	NdrFcShort( 0x32 ),	/* 50 */
/* 220 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 222 */	0x17,		/* Corr desc:  field pointer, FC_USHORT */
			0x55,		/* FC_DIV_2 */
/* 224 */	NdrFcShort( 0x30 ),	/* 48 */
/* 226 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 228 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 230 */	
			0x1c,		/* FC_CVARRAY */
			0x1,		/* 1 */
/* 232 */	NdrFcShort( 0x2 ),	/* 2 */
/* 234 */	0x17,		/* Corr desc:  field pointer, FC_USHORT */
			0x55,		/* FC_DIV_2 */
/* 236 */	NdrFcShort( 0x3a ),	/* 58 */
/* 238 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 240 */	0x17,		/* Corr desc:  field pointer, FC_USHORT */
			0x55,		/* FC_DIV_2 */
/* 242 */	NdrFcShort( 0x38 ),	/* 56 */
/* 244 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 246 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 248 */	
			0x1c,		/* FC_CVARRAY */
			0x1,		/* 1 */
/* 250 */	NdrFcShort( 0x2 ),	/* 2 */
/* 252 */	0x17,		/* Corr desc:  field pointer, FC_USHORT */
			0x55,		/* FC_DIV_2 */
/* 254 */	NdrFcShort( 0x42 ),	/* 66 */
/* 256 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 258 */	0x17,		/* Corr desc:  field pointer, FC_USHORT */
			0x55,		/* FC_DIV_2 */
/* 260 */	NdrFcShort( 0x40 ),	/* 64 */
/* 262 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 264 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 266 */	
			0x1c,		/* FC_CVARRAY */
			0x1,		/* 1 */
/* 268 */	NdrFcShort( 0x2 ),	/* 2 */
/* 270 */	0x17,		/* Corr desc:  field pointer, FC_USHORT */
			0x55,		/* FC_DIV_2 */
/* 272 */	NdrFcShort( 0x4a ),	/* 74 */
/* 274 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 276 */	0x17,		/* Corr desc:  field pointer, FC_USHORT */
			0x55,		/* FC_DIV_2 */
/* 278 */	NdrFcShort( 0x48 ),	/* 72 */
/* 280 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 282 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 284 */	
			0x1c,		/* FC_CVARRAY */
			0x1,		/* 1 */
/* 286 */	NdrFcShort( 0x2 ),	/* 2 */
/* 288 */	0x17,		/* Corr desc:  field pointer, FC_USHORT */
			0x55,		/* FC_DIV_2 */
/* 290 */	NdrFcShort( 0x52 ),	/* 82 */
/* 292 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 294 */	0x17,		/* Corr desc:  field pointer, FC_USHORT */
			0x55,		/* FC_DIV_2 */
/* 296 */	NdrFcShort( 0x50 ),	/* 80 */
/* 298 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 300 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 302 */	
			0x1c,		/* FC_CVARRAY */
			0x1,		/* 1 */
/* 304 */	NdrFcShort( 0x2 ),	/* 2 */
/* 306 */	0x17,		/* Corr desc:  field pointer, FC_USHORT */
			0x55,		/* FC_DIV_2 */
/* 308 */	NdrFcShort( 0x5a ),	/* 90 */
/* 310 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 312 */	0x17,		/* Corr desc:  field pointer, FC_USHORT */
			0x55,		/* FC_DIV_2 */
/* 314 */	NdrFcShort( 0x58 ),	/* 88 */
/* 316 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 318 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 320 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 322 */	NdrFcShort( 0x8 ),	/* 8 */
/* 324 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 326 */	NdrFcShort( 0x6c ),	/* 108 */
/* 328 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 330 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 332 */	NdrFcShort( 0xff24 ),	/* Offset= -220 (112) */
/* 334 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 336 */	
			0x1c,		/* FC_CVARRAY */
			0x1,		/* 1 */
/* 338 */	NdrFcShort( 0x2 ),	/* 2 */
/* 340 */	0x17,		/* Corr desc:  field pointer, FC_USHORT */
			0x55,		/* FC_DIV_2 */
/* 342 */	NdrFcShort( 0x8a ),	/* 138 */
/* 344 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 346 */	0x17,		/* Corr desc:  field pointer, FC_USHORT */
			0x55,		/* FC_DIV_2 */
/* 348 */	NdrFcShort( 0x88 ),	/* 136 */
/* 350 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 352 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 354 */	
			0x1c,		/* FC_CVARRAY */
			0x1,		/* 1 */
/* 356 */	NdrFcShort( 0x2 ),	/* 2 */
/* 358 */	0x17,		/* Corr desc:  field pointer, FC_USHORT */
			0x55,		/* FC_DIV_2 */
/* 360 */	NdrFcShort( 0x92 ),	/* 146 */
/* 362 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 364 */	0x17,		/* Corr desc:  field pointer, FC_USHORT */
			0x55,		/* FC_DIV_2 */
/* 366 */	NdrFcShort( 0x90 ),	/* 144 */
/* 368 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 370 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 372 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 374 */	NdrFcShort( 0x8 ),	/* 8 */
/* 376 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 378 */	NdrFcShort( 0xc4 ),	/* 196 */
/* 380 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 382 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 384 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 386 */	NdrFcShort( 0x8 ),	/* 8 */
/* 388 */	NdrFcShort( 0x0 ),	/* 0 */
/* 390 */	NdrFcShort( 0x1 ),	/* 1 */
/* 392 */	NdrFcShort( 0x0 ),	/* 0 */
/* 394 */	NdrFcShort( 0x0 ),	/* 0 */
/* 396 */	0x12, 0x0,	/* FC_UP */
/* 398 */	NdrFcShort( 0xfe94 ),	/* Offset= -364 (34) */
/* 400 */	
			0x5b,		/* FC_END */

			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 402 */	0x0,		/* 0 */
			NdrFcShort( 0xfe9d ),	/* Offset= -355 (48) */
			0x5b,		/* FC_END */
/* 406 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 408 */	NdrFcShort( 0x8 ),	/* 8 */
/* 410 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 412 */	NdrFcShort( 0xd0 ),	/* 208 */
/* 414 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 416 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 418 */	NdrFcShort( 0xfece ),	/* Offset= -306 (112) */
/* 420 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 422 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 424 */	NdrFcShort( 0xd8 ),	/* 216 */
/* 426 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 428 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 430 */	NdrFcShort( 0x34 ),	/* 52 */
/* 432 */	NdrFcShort( 0x34 ),	/* 52 */
/* 434 */	0x12, 0x0,	/* FC_UP */
/* 436 */	NdrFcShort( 0xff20 ),	/* Offset= -224 (212) */
/* 438 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 440 */	NdrFcShort( 0x3c ),	/* 60 */
/* 442 */	NdrFcShort( 0x3c ),	/* 60 */
/* 444 */	0x12, 0x0,	/* FC_UP */
/* 446 */	NdrFcShort( 0xff28 ),	/* Offset= -216 (230) */
/* 448 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 450 */	NdrFcShort( 0x44 ),	/* 68 */
/* 452 */	NdrFcShort( 0x44 ),	/* 68 */
/* 454 */	0x12, 0x0,	/* FC_UP */
/* 456 */	NdrFcShort( 0xff30 ),	/* Offset= -208 (248) */
/* 458 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 460 */	NdrFcShort( 0x4c ),	/* 76 */
/* 462 */	NdrFcShort( 0x4c ),	/* 76 */
/* 464 */	0x12, 0x0,	/* FC_UP */
/* 466 */	NdrFcShort( 0xff38 ),	/* Offset= -200 (266) */
/* 468 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 470 */	NdrFcShort( 0x54 ),	/* 84 */
/* 472 */	NdrFcShort( 0x54 ),	/* 84 */
/* 474 */	0x12, 0x0,	/* FC_UP */
/* 476 */	NdrFcShort( 0xff40 ),	/* Offset= -192 (284) */
/* 478 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 480 */	NdrFcShort( 0x5c ),	/* 92 */
/* 482 */	NdrFcShort( 0x5c ),	/* 92 */
/* 484 */	0x12, 0x0,	/* FC_UP */
/* 486 */	NdrFcShort( 0xff48 ),	/* Offset= -184 (302) */
/* 488 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 490 */	NdrFcShort( 0x70 ),	/* 112 */
/* 492 */	NdrFcShort( 0x70 ),	/* 112 */
/* 494 */	0x12, 0x0,	/* FC_UP */
/* 496 */	NdrFcShort( 0xff50 ),	/* Offset= -176 (320) */
/* 498 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 500 */	NdrFcShort( 0x8c ),	/* 140 */
/* 502 */	NdrFcShort( 0x8c ),	/* 140 */
/* 504 */	0x12, 0x0,	/* FC_UP */
/* 506 */	NdrFcShort( 0xff56 ),	/* Offset= -170 (336) */
/* 508 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 510 */	NdrFcShort( 0x94 ),	/* 148 */
/* 512 */	NdrFcShort( 0x94 ),	/* 148 */
/* 514 */	0x12, 0x0,	/* FC_UP */
/* 516 */	NdrFcShort( 0xff5e ),	/* Offset= -162 (354) */
/* 518 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 520 */	NdrFcShort( 0x98 ),	/* 152 */
/* 522 */	NdrFcShort( 0x98 ),	/* 152 */
/* 524 */	0x12, 0x0,	/* FC_UP */
/* 526 */	NdrFcShort( 0xfe14 ),	/* Offset= -492 (34) */
/* 528 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 530 */	NdrFcShort( 0xc8 ),	/* 200 */
/* 532 */	NdrFcShort( 0xc8 ),	/* 200 */
/* 534 */	0x12, 0x0,	/* FC_UP */
/* 536 */	NdrFcShort( 0xff5c ),	/* Offset= -164 (372) */
/* 538 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 540 */	NdrFcShort( 0xcc ),	/* 204 */
/* 542 */	NdrFcShort( 0xcc ),	/* 204 */
/* 544 */	0x12, 0x0,	/* FC_UP */
/* 546 */	NdrFcShort( 0xfe00 ),	/* Offset= -512 (34) */
/* 548 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 550 */	NdrFcShort( 0xd4 ),	/* 212 */
/* 552 */	NdrFcShort( 0xd4 ),	/* 212 */
/* 554 */	0x12, 0x0,	/* FC_UP */
/* 556 */	NdrFcShort( 0xff6a ),	/* Offset= -150 (406) */
/* 558 */	
			0x5b,		/* FC_END */

			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 560 */	0x0,		/* 0 */
			NdrFcShort( 0xfe3f ),	/* Offset= -449 (112) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 564 */	0x0,		/* 0 */
			NdrFcShort( 0xfe3b ),	/* Offset= -453 (112) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 568 */	0x0,		/* 0 */
			NdrFcShort( 0xfe37 ),	/* Offset= -457 (112) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 572 */	0x0,		/* 0 */
			NdrFcShort( 0xfe33 ),	/* Offset= -461 (112) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 576 */	0x0,		/* 0 */
			NdrFcShort( 0xfe2f ),	/* Offset= -465 (112) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 580 */	0x0,		/* 0 */
			NdrFcShort( 0xfe2b ),	/* Offset= -469 (112) */
			0x6,		/* FC_SHORT */
/* 584 */	0x6,		/* FC_SHORT */
			0x8,		/* FC_LONG */
/* 586 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 588 */	0x8,		/* FC_LONG */
			0x6,		/* FC_SHORT */
/* 590 */	0x6,		/* FC_SHORT */
			0x8,		/* FC_LONG */
/* 592 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 594 */	0x8,		/* FC_LONG */
			0x6,		/* FC_SHORT */
/* 596 */	0x6,		/* FC_SHORT */
			0x8,		/* FC_LONG */
/* 598 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 600 */	0x8,		/* FC_LONG */
			0x6,		/* FC_SHORT */
/* 602 */	0x6,		/* FC_SHORT */
			0x8,		/* FC_LONG */
/* 604 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 606 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 608 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 610 */	NdrFcShort( 0xfe66 ),	/* Offset= -410 (200) */
/* 612 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 614 */	0x8,		/* FC_LONG */
			0x6,		/* FC_SHORT */
/* 616 */	0x6,		/* FC_SHORT */
			0x8,		/* FC_LONG */
/* 618 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 620 */	0x0,		/* 0 */
			NdrFcShort( 0xfe61 ),	/* Offset= -415 (206) */
			0x8,		/* FC_LONG */
/* 624 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 626 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 628 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 630 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 632 */	NdrFcShort( 0x52 ),	/* Offset= 82 (714) */
/* 634 */	
			0x1c,		/* FC_CVARRAY */
			0x1,		/* 1 */
/* 636 */	NdrFcShort( 0x2 ),	/* 2 */
/* 638 */	0x17,		/* Corr desc:  field pointer, FC_USHORT */
			0x55,		/* FC_DIV_2 */
/* 640 */	NdrFcShort( 0x2 ),	/* 2 */
/* 642 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 644 */	0x17,		/* Corr desc:  field pointer, FC_USHORT */
			0x55,		/* FC_DIV_2 */
/* 646 */	NdrFcShort( 0x0 ),	/* 0 */
/* 648 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 650 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 652 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 654 */	NdrFcShort( 0x1 ),	/* 1 */
/* 656 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 658 */	NdrFcShort( 0x8 ),	/* 8 */
/* 660 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 662 */	0x2,		/* FC_CHAR */
			0x5b,		/* FC_END */
/* 664 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 666 */	NdrFcShort( 0x10 ),	/* 16 */
/* 668 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 670 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 672 */	NdrFcShort( 0x4 ),	/* 4 */
/* 674 */	NdrFcShort( 0x4 ),	/* 4 */
/* 676 */	0x12, 0x0,	/* FC_UP */
/* 678 */	NdrFcShort( 0xffd4 ),	/* Offset= -44 (634) */
/* 680 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 682 */	NdrFcShort( 0xc ),	/* 12 */
/* 684 */	NdrFcShort( 0xc ),	/* 12 */
/* 686 */	0x12, 0x0,	/* FC_UP */
/* 688 */	NdrFcShort( 0xffdc ),	/* Offset= -36 (652) */
/* 690 */	
			0x5b,		/* FC_END */

			0x6,		/* FC_SHORT */
/* 692 */	0x6,		/* FC_SHORT */
			0x8,		/* FC_LONG */
/* 694 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 696 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 698 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 700 */	NdrFcShort( 0x10 ),	/* 16 */
/* 702 */	0x9,		/* Corr desc: FC_ULONG */
			0x0,		/*  */
/* 704 */	NdrFcShort( 0xfffc ),	/* -4 */
/* 706 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 708 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 710 */	NdrFcShort( 0xffd2 ),	/* Offset= -46 (664) */
/* 712 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 714 */	
			0x18,		/* FC_CPSTRUCT */
			0x3,		/* 3 */
/* 716 */	NdrFcShort( 0x4 ),	/* 4 */
/* 718 */	NdrFcShort( 0xffec ),	/* Offset= -20 (698) */
/* 720 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 722 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 724 */	NdrFcShort( 0x10 ),	/* 16 */
/* 726 */	NdrFcShort( 0x4 ),	/* 4 */
/* 728 */	NdrFcShort( 0x2 ),	/* 2 */
/* 730 */	NdrFcShort( 0x8 ),	/* 8 */
/* 732 */	NdrFcShort( 0x8 ),	/* 8 */
/* 734 */	0x12, 0x0,	/* FC_UP */
/* 736 */	NdrFcShort( 0xff9a ),	/* Offset= -102 (634) */
/* 738 */	NdrFcShort( 0x10 ),	/* 16 */
/* 740 */	NdrFcShort( 0x10 ),	/* 16 */
/* 742 */	0x12, 0x0,	/* FC_UP */
/* 744 */	NdrFcShort( 0xffa4 ),	/* Offset= -92 (652) */
/* 746 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 748 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */

			0x0
        }
    };
#pragma optimize("", on )
#if _MSC_VER >= 1200
#pragma warning(pop)
#endif


#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\inc\kdcext.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    kdcext.h

Abstract:

    This module defines the Kerberos Extensions interfaces for Auth Data, PreAuth data,
        and ticket extensions.

Revision History:
        6/29/2001       PaulLe          Split from JBrezak original

--*/

#ifndef _KDCEXT_H_
#define _KDCEXT_H_

//
// KDC Private Context Data
//
// Extensions carry a private context data pointer for the
// life of the KDC request that can be used for provider
// specific data that can be shared across different extensions.
//
typedef struct _KDC_REQUEST_CONTEXT_PRIVATE *PKDC_REQUEST_CTX_PRIVATE;
    
typedef NTSTATUS (*KDC_CTX_FREE_FN) (
    PKDC_REQUEST_CTX_PRIVATE Context
);

typedef struct _KDC_REQUEST_CONTEXT_PRIVATE {
    PVOID               Context;
    KDC_CTX_FREE_FN     FreeFn;
} KDC_REQUEST_CTX_PRIVATE, *PKDC_REQUEST_CTX_PRIVATE;

typedef struct _KDC_REQUEST_CONTEXT {
    INT                 NumberOfContexts;
    KDC_REQUEST_CTX_PRIVATE     Contexts[ANYSIZE_ARRAY];
} KDC_REQUEST_CONTEXT, *PKDC_REQUEST_CONTEXT;


//
// KDC Extension Handlers
//

//
// Authorization Data
//

typedef struct _KDC_AD_HANDLER *PKDC_AD_HANDLER;

typedef KERBERR (*KDC_AD_CHECK_FN) (
    IN PKDC_AD_HANDLER          This,
    IN KDB_HANDLE               KdbHandle,
    IN KERB_SERVICE_ID          Service,
    IN OPTIONAL PKDB_PRINC_INFO ClientInfo,
    IN PKDB_PRINC_INFO          ServerInfo,
    IN PKERB_KDC_REQUEST_BODY   Request,
    IN OPTIONAL CONST ULONG     PreauthType,
    IN OPTIONAL PKERB_ENCRYPTION_KEY SessionKey,
    IN OPTIONAL PKERB_ENCRYPTION_KEY OldServerKey,
    IN PKERB_ENCRYPTION_KEY     NewServerKey,
    IN PKERB_ENCRYPTED_TICKET   EncryptedTicket,
    IN PKERB_AUTHORIZATION_DATA AuthData,
    OUT PKERB_EXT_ERROR         ExtendedError,
    IN OUT PKDC_REQUEST_CONTEXT ReqContext
);


typedef KERBERR (*KDC_AD_RETURN_FN) (
    IN PKDC_AD_HANDLER          This,
    IN KDB_HANDLE               KdbHandle,
    IN KERB_SERVICE_ID          Service,
    IN OPTIONAL PKDB_PRINC_INFO ClientInfo,
    IN PKDB_PRINC_INFO          ServerInfo,
    IN PKERB_KDC_REQUEST_BODY   Request,
    IN OPTIONAL CONST ULONG     PreauthType,
    IN OPTIONAL PKERB_ENCRYPTION_KEY SessionKey,
    IN OPTIONAL PKERB_ENCRYPTION_KEY OldServerKey,
    IN PKERB_ENCRYPTION_KEY     NewServerKey,
    IN PKERB_ENCRYPTED_TICKET EncryptedTicket,
    OUT PKERB_AUTHORIZATION_DATA *AuthData,
    OUT PKERB_EXT_ERROR         ExtendedError,
    IN OUT PKDC_REQUEST_CONTEXT ReqContext
);

typedef struct _KDC_AD_HANDLER {
    PVOID               ad_state;
    KDC_AD_CHECK_FN     ad_check;
    KDC_AD_RETURN_FN    ad_return;
    KDC_CTX_FREE_FN     ctx_free;
} KDC_AD_HANDLER, *PKDC_AD_HANDLER;


//
// Pre-authentication Data
//

typedef struct _KDC_PADATA_HANDLER *PKDC_PADATA_HANDLER;

typedef KERBERR (*KDC_PADATA_GET_FN) (
    IN PKDC_PADATA_HANDLER      This,
    IN KDB_HANDLE               KdbHandle,
    IN KERB_SERVICE_ID          service,
    IN PKDB_PRINC_INFO          client_info,
    IN PKERB_KDC_REQUEST_BODY   request,
    OUT PKERB_PA_DATA_LIST      *padata,
    IN OUT PKDC_REQUEST_CONTEXT req_context
);

typedef KERBERR (*KDC_PADATA_CHECK_FN) (
    IN PKDC_PADATA_HANDLER      This,
    IN KDB_HANDLE               KdbHandle,
    IN KERB_SERVICE_ID          service,
    IN PKDB_PRINC_INFO          client_info,
    IN PKERB_KDC_REQUEST_BODY   request,
    IN PKERB_PA_DATA_LIST       in_padata,
    OUT OPTIONAL PKERB_ENCRYPTION_KEY   ticket_enc_key,
    OUT PUNICODE_STRING         transited_realms,
    OUT PKERB_PA_DATA_LIST      *out_padata,
    OUT PKERB_EXT_ERROR         extended_error,
    IN OUT PKDC_REQUEST_CONTEXT req_context
);

typedef KERBERR (*KDC_PADATA_RETURN_FN) (
    IN PKDC_PADATA_HANDLER      This,
    IN KDB_HANDLE               KdbHandle,
    IN KERB_SERVICE_ID          service,
    IN PKDB_PRINC_INFO          client_info,
    IN PKDB_PRINC_INFO          server_info,
    IN PKERB_KDC_REQUEST_BODY   request,
    IN CONST ULONG              preauth_type,   // from previous checkPAData
    IN PKERB_ENCRYPTION_KEY     session_key,    // session key (encrypted_ticket->key)
    IN PKERB_ENCRYPTION_KEY     service_key,
    OUT PKERB_PA_DATA_LIST      *out_padata,
    IN OUT PKDC_REQUEST_CONTEXT req_context
);

typedef struct _KDC_PADATA_HANDLER {
    DWORD                       pa_type;
    DWORD                       pa_flags;
#define KERB_PADATA_REQUIRED            0x00000001 // needed to satisfy PA required
#define KERB_PADATA_SUFFICIENT          0x00000002 // satisfy pa required
#define KERB_PADATA_AS                  0x00000004 // usable from AS
#define KERB_PADATA_TGS                 0x00000008 // usable from TGS
    PVOID                       pa_state;
    KDC_PADATA_GET_FN           pa_get;
    KDC_PADATA_CHECK_FN         pa_check;
    KDC_PADATA_RETURN_FN        pa_return;
    KDC_CTX_FREE_FN             ctx_free;
} KDC_PADATA_HANDLER, *PKDC_PADATA_HANDLER;


//
// Ticket Extensions
//

typedef struct _KDC_TICKET_EXT_HANDLER *PKDC_TICKET_EXT_HANDLER;

typedef KERBERR (*KDC_TIX_VALIDATE_FN) (
    IN PKDC_TICKET_EXT_HANDLER  This,
    IN KERB_SERVICE_ID          service,
    IN PKDB_PRINC_INFO          client_info,
    IN PKDB_PRINC_INFO          server_info,
    IN PKERB_KDC_REQUEST_BODY   request,
    IN PKERB_STORED_CREDENTIAL  ticket_key,
    IN PKERB_STORED_CREDENTIAL  session_key,
    IN PKERB_TICKET_EXTENSIONS  in_ticketext,
    OUT PKERBERR                kerb_error,
    IN OUT PKDC_REQUEST_CONTEXT req_context
);

typedef KERBERR (*KDC_TIX_RETURN_FN) (
    IN PKDC_TICKET_EXT_HANDLER  This,
    IN KERB_SERVICE_ID          service,
    IN PKDB_PRINC_INFO          client_info,
    IN PKDB_PRINC_INFO          server_info,
    IN PKERB_KDC_REQUEST_BODY   request,
    IN PKERB_STORED_CREDENTIAL  ticket_key,
    IN PKERB_STORED_CREDENTIAL  session_key,
    OUT PKERB_TICKET_EXTENSIONS *out_ticketext,
    IN OUT PKDC_REQUEST_CONTEXT req_context
);

typedef struct _KDC_TICKET_EXT_HANDLER {
    PVOID                       tix_state;
    KDC_TIX_VALIDATE_FN         tix_validate;
    KDC_TIX_RETURN_FN           tix_return;
    KDC_CTX_FREE_FN             ctx_free;
} KDC_TICKET_EXT_HANDLER, *PKDC_TICKET_EXT_HANDLER;


//
// PAC extension handler
//

#ifndef _PAC_INFO_BUFFER_
#define _PAC_INFO_BUFFER_
typedef struct _PAC_INFO_BUFFER {
    ULONG ulType;
    ULONG cbBufferSize;
    union {
        PBYTE Data;
        ULONG64 Offset;
    };
} PAC_INFO_BUFFER, *PPAC_INFO_BUFFER;
#endif

typedef struct _KDC_PAC_HANDLER *PKDC_PAC_HANDLER;

typedef KERBERR (*PAC_BUILD_FN) (
    IN PKDC_PAC_HANDLER         This,
    IN KDB_HANDLE               KdbHandle,
    IN PKDB_PRINC_INFO          UserInfo,
    IN BOOLEAN                  IsUpdate,
    IN PKERB_ENCRYPTED_TICKET   EncryptedTicket,
    IN OPTIONAL PKERB_ENCRYPTION_KEY CredentialKey,
    IN OUT PPAC_INFO_BUFFER     *PacData,
    OUT PKERB_EXT_ERROR         ExtendedError,
    IN OUT PKDC_REQUEST_CONTEXT ReqContext
    );

typedef struct _KDC_PAC_HANDLER {
    PVOID               pac_state;
    ULONG               pac_type;
    PAC_BUILD_FN        pac_build;
    KDC_CTX_FREE_FN     ctx_free;
} KDC_PAC_HANDLER, *PKDC_PAC_HANDLER;

//
// KDC exported functions
//
// Utility functions provided by the KDC for extension handlers
//

extern "C"
NTSTATUS
WINAPI
KdcAddADHandler(
    IN SHORT            num_handlers,
    IN PKDC_AD_HANDLER  handlers,
    OUT OPTIONAL LONG   *ContextHandleIndex
);

extern "C"
NTSTATUS
WINAPI
KdcDeleteADHandler(
    IN LONG ContextHandleIndex
);

extern "C"
NTSTATUS
WINAPI
KdcAddPADataHandler(
    IN SHORT            num_handlers,
    IN PKDC_PADATA_HANDLER handlers,
    OUT OPTIONAL LONG   *ContextHandleIndex
);

extern "C"
NTSTATUS
WINAPI
KdcDeletePADataHandler(
    IN LONG ContextHandleIndex
);

extern "C"
NTSTATUS
WINAPI
KdcAddTicketExtHandler(
    IN SHORT            num_handlers,
    IN PKDC_TICKET_EXT_HANDLER handlers,
    OUT OPTIONAL LONG   *ContextHandleIndex
);

extern "C"
NTSTATUS
WINAPI
KdcDeleteTicketExtHandler(
    IN LONG ContextHandleIndex
);

extern "C"
NTSTATUS
WINAPI
KdcAddPacHandler(
    IN SHORT            num_handlers,
    IN PKDC_PAC_HANDLER  handlers,
    OUT OPTIONAL LONG   *ContextHandleIndex
);

extern "C"
NTSTATUS
WINAPI
KdcDeletePacHandler(
    IN LONG ContextHandleIndex
);

#endif // _KDCEXT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\inc\kdcfilt.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    kdcfilt.h

Abstract:

    This module defines the Kerberos extensible filters interface.

Revision History:

--*/

#ifndef _KDCFILT_H_
#define _KDCFILT_H_

#ifdef __cplusplus
extern "C" {
#endif

//
// KDC Filters
//
// Used for provider specific augmented functions in
// the protocol request.
//
typedef NTSTATUS (*KDC_AS_REQ_FILTER_FN) (
    IN PKDB_PRINC_INFO		client_info,
    IN PKDB_PRINC_INFO		server_info,
    IN PKERB_HOST_ADDRESS	client_address,
    IN OUT PKDC_REQUEST_CONTEXT req_context,
    IN OUT LARGE_INTEGER	ticket_lifetime,
    OUT PKERBERR		extended_error
);

typedef NTSTATUS (*KDC_TGS_REQ_FILTER_FN) (
    IN PKDB_PRINC_INFO		client_info,
    IN PKDB_PRINC_INFO		server_info,
    IN PKERB_HOST_ADDRESS	client_address,
    IN OUT PKDC_REQUEST_CONTEXT req_context,
    IN OUT LARGE_INTEGER	ticket_lifetime,
    OUT PKERBERR		extended_error
);

typedef NTSTATUS (*KDC_AP_REQ_FILTER_FN) (
    IN PKDB_PRINC_INFO		client_info,
    IN PKDB_PRINC_INFO		server_info,
    IN PKERB_AP_REQUEST		request,
    IN PKERB_ENCRYPTED_TICKET	encrypt_part,
    IN OUT PKDC_REQUEST_CONTEXT req_context,
    OUT PKERBERR		extended_error
);
	
typedef NTSTATUS (*KDC_KRB_ERROR_FILTER_FN) (
    IN PKDB_PRINC_INFO		princ_info,
    IN PKDC_REQUEST_CONTEXT	req_context,
    IN OUT PKERB_ERROR		kerb_error_msg
);

typedef NTSTATUS (*KDC_REP_FILTER_FN) (
    IN KERBERR			kerb_status,
    IN PKERB_MESSAGE_BUFFER 	request_message,
    IN OUT PKERB_MESSAGE_BUFFER reply_message,
    IN PKDC_REQUEST_CONTEXT	req_context
);

typedef struct _KDC_FILTERS {
    KDC_AS_REQ_FILTER_FN	kdc_as_req_filter;
    KDC_TGS_REQ_FILTER_FN	kdc_tgs_req_filter;
    KDC_AP_REQ_FILTER_FN	kdc_ap_req_filter;
    KDC_KRB_ERROR_FILTER_FN	kdc_krb_error_filter;
    KDC_REP_FILTER_FN		kdc_rep_filter;
} KDC_FILTERS, *PKDC_FILTERS;


#ifdef __cplusplus
}
#endif

#endif // _KDCFILT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\inc\kdckdb.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    kdckdb.h

Abstract:

    This module defines the Kerberos KDC Database interfaces.

Revision History:

--*/

#ifndef _KDCKDB_H_
#define _KDCKDB_H_


#ifdef __cplusplus
extern "C" {
#endif

//
// Common declarations (also defined in kerbcred.h for client)
//
#ifndef _KERB_ACCOUNT_TYPE_DEFINED_
#define _KERB_ACCOUNT_TYPE_DEFINED_
typedef enum _KERB_ACCOUNT_TYPE {
    UserAccount,
    MachineAccount,
    DomainTrustAccount,
    UnknownAccount
} KERB_ACCOUNT_TYPE, *PKERB_ACCOUNT_TYPE;
#endif

//
// Key storage structures
//
// Defined Salt types
//
#ifndef _KERB_KEY_DATA_DEFINED_
#define _KERB_KEY_DATA_DEFINED_
typedef enum {
    KerbKdbSaltTypeDefault = 0,
    KerbKdbSaltTypePassword,
    KerbKdbSaltTypeNoRealm,
    KerbKdbSaltTypeOnlyRealm,
    KerbKdbSaltTypeSpeial,
    KerbKdbSaltTypeAFS3
} KERB_KDB_SALTTYPE, *PKERB_KDB_SALTTYPE;

//
// Key data header
//
typedef struct _KERB_KEY_DATA {
    ULONG               KeyVersion;     // Kerberos kvno for long term keys
                                        // Use KERB_NO_KEY_VERSION for session
                                        // keys
    KERB_KDB_SALTTYPE   SaltType;
    UNICODE_STRING      Salt;           // if not SALTTYPE_DEFAULT
    KERB_ENCRYPTION_KEY Key;            // Use ASN.1 definition (krb5.h)
} KERB_KEY_DATA, *PKERB_KEY_DATA; 

typedef struct _KERB_STORED_CREDENTIAL {
    USHORT              PreferredKeyIndex;      // Prefer use of this key when
                                                // Creating service tickets
    USHORT              CredentialCount;
    UNICODE_STRING      DefaultSalt;
    KERB_KEY_DATA       Credentials[ANYSIZE_ARRAY];
} KERB_STORED_CREDENTIAL, *PKERB_STORED_CREDENTIAL;
#endif
    
//
// A multipart principal name
//
#ifndef _KERB_INTERNAL_NAME_
#define _KERB_INTERNAL_NAME_
#define MAX_NAME_ELEMENTS 20
typedef struct _KERB_INTERNAL_NAME {
    SHORT NameType;
    USHORT NameCount;
    UNICODE_STRING Names[ANYSIZE_ARRAY];
} KERB_INTERNAL_NAME, *PKERB_INTERNAL_NAME;
#endif

#ifndef DEF_KERB_SERVICE_ID
#define DEF_KERB_SERVICE_ID
//
// Shorthand for service making a particular function call
//
typedef enum {
    KerbAs = 0,
    KerbTgs,
    KerbAp,
    KerbChangePassword,
    KerbSetPassword,
} KERB_SERVICE_ID;
#endif //DEF_KERB_SERVICE_ID

//
// Container for provider specific info
//
typedef struct _KDB_PROV_INFO {
    GUID        Type;
    UINT        Length;
    PVOID       Data;
} KDB_PROV_INFO, *PKDB_PROV_INFO;

typedef struct _KDB_PROV_INFOs {
    UINT                NumberOfEntries;
    PKDB_PROV_INFO      Entries[ANYSIZE_ARRAY];
} KDB_PROV_INFOS, *PKDB_PROV_INFOS;

//
// Generic form of a principal
//
typedef struct _KDB_PRINC_INFO {
    DWORD               DataFlags;                      // What data is present
#define KERB_KDB_DATA_ALL               0xffffffff
#define KERB_KDB_DATA_LOGON_TIME        0x00000001
#define KERB_KDB_DATA_KEYS              0x00000002
    PKERB_INTERNAL_NAME Princ;                          // multipart principal
    PUNICODE_STRING     Realm;                          // and the realm
    DWORD               Flags;
#define KERB_KDB_DISALLOW_POSTDATED     0x00000001
#define KERB_KDB_DISALLOW_FORWARDABLE   0x00000002
#define KERB_KDB_DISALLOW_RENEWABLE     0x00000004
#define KERB_KDB_DISALLOW_PROXIABLE     0x00000008
#define KERB_KDB_REQUIRE_USER2USER      0x00000010
#define KERB_KDB_DISALLOW_S4U2PROXY     0x00000020
#define KERB_KDB_DISALLOW_ALL_TIX       0x00000040
#define KERB_KDB_REQUIRES_PRE_AUTH      0x00000080
#define KERB_KDB_REQUIRES_PWCHANGE      0x00000100
#define KERB_KDB_DISALLOW_SVR           0x00000200
#define KERB_KDB_OK_AS_DELEGATE         0x00000400
    KERB_ACCOUNT_TYPE   PrincipalType;          // Special account type
    LARGE_INTEGER       MaxLifeTime;            // Max ticket lifetime
    LARGE_INTEGER       MaxRenewTime;           // Max renew lifetime
    LARGE_INTEGER       LastModified;           // Time principal modified
    LARGE_INTEGER       Expiration;             // Time principal expires
    LARGE_INTEGER       LastLogon;              // KERB_KDB_DATA_LOGON_TIME
    LARGE_INTEGER       LastFailedLogon;        // KERB_KDB_DATA_LOGON_TIME
#ifndef KERB_KDB_TIME_NEVER    
#define KERB_KDB_TIME_NEVER (-1)
#endif
    SOCKADDR            LastLogonClient;        // KERB_KDC_DATA_LOGON_TIME
    PKDB_PROV_INFOS     ProvInfo;               // KERB_KDB_DATA_ALL
    PKERB_STORED_CREDENTIAL Keys;               // KERB_KDB_DATA_KEYS
    PKERB_STORED_CREDENTIAL OldKeys;            // KERB_KDB_DATA_KEYS
} KDB_PRINC_INFO, *PKDB_PRINC_INFO;

// Forward reference for a PKDC_KDB
typedef struct _KDC_KDB *PKDC_KDB;

//
// Describe a realm
//
typedef struct _KDB_REALM {
    PKDC_KDB            pKdb;           // pointer to the vtable
    UNICODE_STRING      Name;
    PVOID               Data;           // Private data extension
    DWORD               Flags;
#define KERB_KDB_REALM_REFERRAL 0x00000001      // Can generate referrals to other realms
#define KERB_KDB_REALM_DOES_PAC 0x00000002      // Realm produces data for a PAC
    PKERB_INTERNAL_NAME KrbtgtName;
    //PCCERT_CONTEXT    KdcRealmCert;           // ToDo: Add certificate for Realm
} KDB_REALM, *PKDB_REALM;

//
// KDC_KDB interface functions
//
// Functions are required to implement unless "optional"


typedef NTSTATUS (*KDC_KDB_OPEN_FN)(
    IN PKDB_REALM               This
);

typedef NTSTATUS (*KDC_KDB_CLOSE_FN)(
    IN PKDB_REALM               This
);

typedef KERBERR (*KDC_KDB_GET_PRINCIPAL_FN) (
    IN PKDB_REALM               This,
    IN CONST PKERB_INTERNAL_NAME Principal,
    IN OPTIONAL CONST PUNICODE_STRING Realm,    // Needed for xrealm and group expansion
    IN CONST ULONG              Flags,
#define KDC_KDB_GET_PRINC_CLIENT                0x00000001      // Client princ
#define KDC_KDB_GET_PRINC_SERVER                0x00000002      // Server princ
#define KDC_KDB_GET_PRINC_FOLLOW_REFERRALS      0x00000004      // Allow refer
#define KDC_KDB_GET_PRINC_TRUST_INBOUND         0x00000008      // indicates name need not be outbound trust only
#define KDC_KDB_GET_PRINC_CANONICALIZE          0x00000010      // indicates that the client said This name should be canonicalized at the GC
#define KDC_KDB_GET_PRINC_MAPPING               0x00000020      // Client princ that is mapped to the requested identity (called during PAC mapping)
    IN CONST KERB_SERVICE_ID    ServiceId,
    OUT PKDB_PRINC_INFO         *PrincInfo,
    OUT PNTSTATUS               Status
);

typedef KERBERR (*KDC_KDB_PUT_PRINCIPAL_FN) (
    IN PKDB_REALM               This,
    IN CONST PKERB_INTERNAL_NAME Principal,     // Is this needed?
    IN CONST KERB_SERVICE_ID    ServiceId,
    IN PKDB_PRINC_INFO          PrincInfo,
    OUT PNTSTATUS               Status
);

typedef NTSTATUS (*KDC_KDB_FREE_PRINCIPAL_FN) (
    IN PKDB_REALM       This,
    IN PKDB_PRINC_INFO  PrincInfo
);

//
// Per KDB event log function - optional
//
OPTIONAL typedef NTSTATUS (*KDC_KDB_REPORT_EVENT_FN) (
    IN PKDB_REALM       This,
    IN WORD             EventType,
    IN DWORD            EventId,
    IN DWORD            RawDataSize,
    IN PVOID            RawData,
    IN DWORD            NumStrings,
    ...
);

//
// Per KDB audit log function - optional
//
#ifndef DEF_KDC_AUDIT_EVENT
#define DEF_KDC_AUDIT_EVENT
typedef enum
{
    AsTicket = 0,
    AsFailure,
    PreauthFailure,
    TgsSuccess,
    TgsFailure,
    TicketRenewSuccess,
    TgsTicketRequest
} KDC_AUDIT_EVENT, *PKDC_AUDIT_EVENT;
#endif
    
OPTIONAL typedef NTSTATUS (*KDC_KDB_AUDIT_EVENT_FN)(
    IN PKDB_REALM       This,
    IN KDC_AUDIT_EVENT  AuditId,
    IN PKDB_PRINC_INFO  ClientInfo,
    IN PKDB_PRINC_INFO  ServiceInfo,
    IN PKERBERR         KerbStatus,
    IN PULONG           KdcOptions,
    IN PULONG           EncryptionType,
    IN PULONG           PreauthType,
    IN PSOCKADDR        ClientAddress   OPTIONAL
);

#ifndef DEF_KERB_PERF_COUNTER
#define DEF_KERB_PERF_COUNTER
typedef enum {
    KerbKdcAsReqCounter = 0,
    KerbKdcAsReferralCounter,
    KerbKdcTgsReqCounter,
    KerbKdcTgsReferralCounter,
    KerbKdcTgsS4U2SelfCounter,
    KerbKdcTgsS4U2ProxyCounter
} KERB_PERF_COUNTER;
#endif

OPTIONAL typedef NTSTATUS (*KDC_KDB_PERF_COUNT_FN) (
    IN PKDB_REALM        This,
    IN KERB_PERF_COUNTER Counter
);
    
typedef struct _KDC_KDB {
    KDC_KDB_OPEN_FN             kdb_open;
    KDC_KDB_CLOSE_FN            kdb_close;
    KDC_KDB_GET_PRINCIPAL_FN    kdb_get_principal;
    KDC_KDB_PUT_PRINCIPAL_FN    kdb_put_principal;
    KDC_KDB_FREE_PRINCIPAL_FN   kdb_free_principal;
    KDC_KDB_REPORT_EVENT_FN     kdb_report_event;
    KDC_KDB_AUDIT_EVENT_FN      kdb_audit_event;
    KDC_KDB_PERF_COUNT_FN       kdb_perf_count;
} KDC_KDB, *PKDC_KDB;

//
// Function pointer to start and stop extensions
//

#define KDC_EXT_MAIN "KdcExtMain"

extern "C"
typedef NTSTATUS (*KDC_EXT_MAIN_FN) (
    IN DWORD Reason     // DLL_PROCESS_ATTACH || DLL_PROCESS_DETACH
    );
    
//
// Register realm handlers
//
extern "C"
NTSTATUS
WINAPI
KdbAddRealmHandler(
    IN PKDB_REALM KdbRealm
    );

extern "C"
NTSTATUS
WINAPI
KdbDeleteRealmHandler(
    IN PUNICODE_STRING  Realm
    );

//
// Locate ProvInfo in KDB_PRINC_INFO
//

extern "C"
PVOID
NTAPI
KdbLocateProvInfo(
    IN PKDB_PRINC_INFO Info,
    IN CONST GUID * CONST Type,
    OUT PUINT pLength
    );


#ifdef __cplusplus
}
#endif

typedef PKDB_REALM KDB_HANDLE;

#endif // _KDCKDB_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\inc\kdcexp.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1997
//
// File:        kdcexp.h
//
// Contents:    Private Exports from kdcsvc.dll
//
//
// History:     27-June-1997    MikeSw          Created
//
//------------------------------------------------------------------------


#ifndef __KDCEXP_H__
#define __KDCEXP_H__

#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus

NTSTATUS
KdcVerifyPac(
    IN ULONG ChecksumSize,
    IN PUCHAR Checksum,
    IN ULONG SignatureType,
    IN ULONG SignatureSize,
    IN PUCHAR Signature
    );


#define KDC_VERIFY_PAC_NAME "KdcVerifyPac"
typedef NTSTATUS
(NTAPI *PKDC_VERIFY_PAC_ROUTINE)(
    IN ULONG ChecksumSize,
    IN PUCHAR Checksum,
    IN ULONG SignatureType,
    IN ULONG SignatureSize,
    IN PUCHAR Signature
    );

KERBERR
NTAPI
KdcGetTicket(
    IN OPTIONAL PVOID Context,
    IN OPTIONAL PSOCKADDR ClientAddress,
    IN OPTIONAL PSOCKADDR ServerAddress,
    IN PKERB_MESSAGE_BUFFER InputMessage,
    OUT PKERB_MESSAGE_BUFFER OutputMessage
    );

#define KDC_GET_TICKET_NAME "KdcGetTicket"
typedef KERBERR
(NTAPI *PKDC_GET_TICKET_ROUTINE) (
    IN OPTIONAL PVOID Context,
    IN OPTIONAL PSOCKADDR ClientAddress,
    IN OPTIONAL PSOCKADDR ServerAddress,
    IN PKERB_MESSAGE_BUFFER InputMessage,
    OUT PKERB_MESSAGE_BUFFER OutputMessage
    );


#define KDC_CHANGE_PASSWORD_NAME "KdcChangePassword"

KERBERR
KdcChangePassword(
    IN OPTIONAL PVOID Context,
    IN OPTIONAL PSOCKADDR ClientAddress,
    IN OPTIONAL PSOCKADDR ServerAddress,
    IN PKERB_MESSAGE_BUFFER InputMessage,
    OUT PKERB_MESSAGE_BUFFER OutputMessage
    );

VOID WINAPI
KdcFreeMemory(
     IN PVOID Ptr
     );

#define KDC_FREE_MEMORY_NAME "KdcFreeMemory"

typedef VOID
(NTAPI * PKDC_FREE_MEMORY_ROUTINE) (
    IN PVOID Ptr
    );

BOOLEAN
KdcUpdateKrbtgtPassword(
    IN PUNICODE_STRING DnsDomainName,
    IN PLARGE_INTEGER MaxPasswordAge
    );

//
// Exported routines from kerberos.dll
//

NTSTATUS
KerbMakeKdcCall(
    IN PUNICODE_STRING RealmName,
    IN OPTIONAL PUNICODE_STRING AccountName,
    IN BOOLEAN CallPDC,
    IN BOOLEAN UseTcp,
    IN PKERB_MESSAGE_BUFFER RequestMessage,
    IN OUT PKERB_MESSAGE_BUFFER ReplyMessage,
    IN ULONG AdditionalFlags,
    OUT PBOOLEAN CalledPDC
    );

VOID
KerbFree(
    IN PVOID Buffer
    );


NTSTATUS
KerbCreateTokenFromTicket(
    IN PKERB_ENCRYPTED_TICKET InternalTicket,
    IN PKERB_AUTHENTICATOR Authenticator,
    IN ULONG ContextFlags,
    IN PKERB_ENCRYPTION_KEY TicketKey,
    IN PUNICODE_STRING ServiceDomain,
    OUT PLUID NewLogonId,
    OUT PSID * UserSid,
    OUT PHANDLE NewTokenHandle,
    OUT PUNICODE_STRING ClientName,
    OUT PUNICODE_STRING ClientDomain
    );

BOOLEAN
KerbIsInitialized(
);

NTSTATUS
KerbKdcCallBack(
);

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // __KDCEXP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\inc\kerbcred.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        kerbcred.h
//
// Contents:    structures for kerberos primary and supplemental credentials
//
//
// History:     20-Aug-1996     MikeSw          Created
//
//------------------------------------------------------------------------

#ifndef __KERBCRED_H__
#define __KERBCRED_H__

//
// Kerberos primary credentials store keys suitable for different
// encryption types.
//
#ifndef _KRB5_Module_H_
typedef struct _KERB_RPC_OCTET_STRING {
    unsigned long length;
#ifdef MIDL_PASS
    [size_is(length)]
#endif // MIDL_PASS
    unsigned char *value;
} KERB_RPC_OCTET_STRING;

typedef struct _KERB_ENCRYPTION_KEY {
    long keytype;
    KERB_RPC_OCTET_STRING keyvalue;
} KERB_ENCRYPTION_KEY;
#endif // _KRB5_Module_H_


#ifndef _KERB_KEY_DATA_DEFINED_
#define _KERB_KEY_DATA_DEFINED_
typedef enum {
    KerbKdbSaltTypeDefault = 0,
    KerbKdbSaltTypePassword,
    KerbKdbSaltTypeNoRealm,
    KerbKdbSaltTypeOnlyRealm,
    KerbKdbSaltTypeSpeial,
    KerbKdbSaltTypeAFS3
} KERB_KDB_SALTTYPE, *PKERB_KDB_SALTTYPE;

typedef struct _KERB_KEY_DATA {
    ULONG		KeyVersion;	
    KERB_KDB_SALTTYPE	SaltType;
    UNICODE_STRING	Salt;		// if not SALTTYPE_DEFAULT
    KERB_ENCRYPTION_KEY Key;		// Use ASN.1 definition (krb5.h)
} KERB_KEY_DATA, *PKERB_KEY_DATA; 

typedef struct _KERB_STORED_CREDENTIAL {
    USHORT		PreferredKeyIndex;
    USHORT		CredentialCount;
    UNICODE_STRING 	DefaultSalt;
    KERB_KEY_DATA	Credentials[ANYSIZE_ARRAY];
} KERB_STORED_CREDENTIAL, *PKERB_STORED_CREDENTIAL;

#endif

#endif // __KERBCRED_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\inc\kerbdefs.h ===
//+-----------------------------------------------------------------------
//
// File:        kerbdefs.h
//
// Contents:    definitions for common kerberos constants
//
//
// History:     18-Jan-2007     Created         Kgoodier
//
// Yanked from kerbcomm.h
//
//------------------------------------------------------------------------

#ifndef _KERBDEFS_H_
#define _KERBDEFS_H_


//////////////////////////////////////////////////////////////////////////
//
// Definitions (for lack of a better place)
//
//////////////////////////////////////////////////////////////////////////

//
// Message types
//

#define KRB_AS_REQ      10      // Request for initial authentication
#define KRB_AS_REP      11      // Response to  KRB_AS_REQ request
#define KRB_TGS_REQ     12      // Request for authentication based on TGT
#define KRB_TGS_REP     13      // Response to KRB_TGS_REQ request
#define KRB_AP_REQ      14      // application request to server
#define KRB_AP_REP      15      // Response to KRB_AP_REQ_MUTUAL
#define KRB_TGT_REQ     16      // Request for TGT for user-to-user
#define KRB_TGT_REP     17      // Reply to TGT request
#define KRB_SAFE        20      // Safe (checksummed) application message
#define KRB_PRIV        21      // Private (encrypted) application message
#define KRB_CRED        22      // Private (encrypted) message to forward
                                // credentials
#define KRB_ERROR       30      // Error response


//
// Pre-auth data types

#define KRB5_PADATA_NONE                0
#define KRB5_PADATA_AP_REQ              1
#define KRB5_PADATA_TGS_REQ             KRB5_PADATA_AP_REQ
#define KRB5_PADATA_ENC_TIMESTAMP       2
#define KRB5_PADATA_PW_SALT             3
#define KRB5_PADATA_ENC_UNIX_TIME       5  /* timestamp encrypted in key */
#define KRB5_PADATA_ENC_SANDIA_SECURID  6  /* SecurId passcode */
#define KRB5_PADATA_SESAME              7  /* Sesame project */
#define KRB5_PADATA_OSF_DCE             8  /* OSF DCE */
#define KRB5_CYBERSAFE_SECUREID         9  /* Cybersafe */
#define KRB5_PADATA_AFS3_SALT           10 /* Cygnus */
#define KRB5_PADATA_ETYPE_INFO          11 /* Etype info for preauth */
#define KRB5_PADATA_SAM_CHALLENGE       12 /* draft challenge system */
#define KRB5_PADATA_SAM_RESPONSE        13 /* draft challenge system response */
#define KRB5_PADATA_PK_AS_REQ           14 /* pkinit */
#define KRB5_PADATA_PK_AS_REP           15 /* pkinit */
#define KRB5_PADATA_PK_AS_SIGN          16 /* pkinit */
#define KRB5_PADATA_PK_KEY_REQ          17 /* pkinit */
#define KRB5_PADATA_PK_KEY_REP          18 /* pkinit */
#define KRB5_PADATA_REFERRAL_INFO       20 /* referral names for canonicalization */
#define KRB5_PADATA_S4U                 21
#define KRB5_PADATA_PAC_REQUEST         128 /* allow client do request or ignore PAC */
#define KRB5_PADATA_FOR_USER            129 /* target client identity */
#define KRB5_PADATA_COMPOUND_IDENTITY   130 /* authenticate multiple identities */
#define KRB5_PADATA_PAC_REQUEST_EX      131 /* allow client do request, ignore PAC or specify what sections */

//
// Authorization data types
//
#define KERB_AUTH_OSF_DCE       64
#define KERB_AUTH_SESAME        65

//
// NT authorization data type definitions
//

#define KERB_AUTH_DATA_PAC              128     // entry id for a PAC in authorization data
#define KERB_AUTH_PROXY_ANNOTATION      139     // entry id for a proxy logon annotation string

#define KERB_AUTH_DATA_IF_RELEVANT      1       // entry id for optional auth data
#define KERB_AUTH_DATA_KDC_ISSUED       4       // entry id for data generated & signed by KDC
#define KERB_AUTH_DATA_TOKEN_RESTRICTIONS 141   // entry id for token restrictions
//
// Transited realm compression types:
//

#define DOMAIN_X500_COMPRESS            1

//
// Certificate types for PKINIT
//

#define KERB_CERTIFICATE_TYPE_X509      1
#define KERB_CERTIFICATE_TYPE_PGP       2

//
// Signature & seal types used by PKINIT
//

#define KERB_PKINIT_SIGNATURE_ALG               CALG_MD5
#define KERB_PKINIT_EXPORT_SEAL_OID             szOID_RSA_RC2CBC
#define KERB_PKINIT_EXPORT_SEAL_ETYPE           KERB_ETYPE_RC2_CBC_ENV
#define KERB_PKINIT_SEAL_ETYPE                  KERB_ETYPE_DES_EDE3_CBC_ENV
#define KERB_PKINIT_SEAL_OID                    szOID_RSA_DES_EDE3_CBC
#define KERB_PKINIT_SIGNATURE_OID               szOID_RSA_MD5RSA
#define KERB_PKINIT_KDC_CERT_TYPE               szOID_PKIX_KP_SERVER_AUTH

#ifdef szOID_KP_SMARTCARD_LOGON
#define KERB_PKINIT_CLIENT_CERT_TYPE szOID_KP_SMARTCARD_LOGON
#else
#define KERB_PKINIT_CLIENT_CERT_TYPE "1.3.6.1.4.1.311.20.2.2"
#endif



//
// KDC service principal
//

#define KDC_PRINCIPAL_NAME              L"krbtgt"
#define KDC_PRINCIPAL_NAME_A            "krbtgt"
#define KERB_HOST_STRING_A              "host"
#define KERB_HOST_STRING                L"host"
#define KERB_KPASSWD_FIRST_NAME         L"kadmin"
#define KERB_KPASSWD_SECOND_NAME        L"changepw"


//
// address types - corresponds to GSS types
//
#define KERB_ADDRTYPE_UNSPEC           0x0
#define KERB_ADDRTYPE_LOCAL            0x1
#define KERB_ADDRTYPE_INET             0x2
#define KERB_ADDRTYPE_IMPLINK          0x3
#define KERB_ADDRTYPE_PUP              0x4
#define KERB_ADDRTYPE_CHAOS            0x5
#define KERB_ADDRTYPE_NS               0x6
#define KERB_ADDRTYPE_NBS              0x7
#define KERB_ADDRTYPE_ECMA             0x8
#define KERB_ADDRTYPE_DATAKIT          0x9
#define KERB_ADDRTYPE_CCITT            0xA
#define KERB_ADDRTYPE_SNA              0xB
#define KERB_ADDRTYPE_DECnet           0xC
#define KERB_ADDRTYPE_DLI              0xD
#define KERB_ADDRTYPE_LAT              0xE
#define KERB_ADDRTYPE_HYLINK           0xF
#define KERB_ADDRTYPE_APPLETALK        0x10
#define KERB_ADDRTYPE_BSC              0x11
#define KERB_ADDRTYPE_DSS              0x12
#define KERB_ADDRTYPE_OSI              0x13
#define KERB_ADDRTYPE_NETBIOS          0x14
#define KERB_ADDRTYPE_X25              0x15


//
// Misc. Flags
//

#define KERB_EXPORT_KEY_FLAG 0x20000000

//
// SALT flags for encryption, from rfc1510 update 3des enctype
//

#define KERB_ENC_TIMESTAMP_SALT         1
#define KERB_TICKET_SALT                2
#define KERB_AS_REP_SALT                3
#define KERB_TGS_REQ_SESSKEY_SALT       4
#define KERB_TGS_REQ_SUBKEY_SALT        5
#define KERB_TGS_REQ_AP_REQ_AUTH_CKSUM_SALT     6
#define KERB_TGS_REQ_AP_REQ_AUTH_SALT   7
#define KERB_TGS_REP_SALT               8
#define KERB_TGS_REP_SUBKEY_SALT        9
#define KERB_AP_REQ_AUTH_CKSUM_SALT     10
#define KERB_AP_REQ_AUTH_SALT           11
#define KERB_AP_REP_SALT                12
#define KERB_PRIV_SALT                  13
#define KERB_CRED_SALT                  14
#define KERB_SAFE_SALT                  15
#define KERB_NON_KERB_SALT              16
#define KERB_NON_KERB_CKSUM_SALT        17
#define KERB_KERB_ERROR_SALT            18
#define KERB_KDC_ISSUED_CKSUM_SALT      19
#define KERB_MANDATORY_TKT_EXT_CKSUM_SALT       20
#define KERB_AUTH_DATA_TKT_EXT_CKSUM_SALT       21

//
// Microsoft specific salts
//

// BugBug: Remove this once the code is changed
#define KERB_PA_WITH_IDENTITY_SALT      1024
//

#define KERB_PA_COMPOUND_IDENTITY_REPLY_SALT    1024

//
// SALT flags for pre-auth encryption
//
#define KERB_PA_XBOX_REQUEST_SALT               1200
#define KERB_PA_XBOX_SERVICE_REQUEST_SALT       1201
#define KERB_PA_XBOX_SERVICE_ADDRESS_SALT       1202
#define KERB_PA_XBOX_ACCOUNT_CREATION_SALT      1203

//
// Types for AP error data
//

#define KERB_AP_ERR_TYPE_NTSTATUS             1
#define KERB_AP_ERR_TYPE_SKEW_RECOVERY        2

//
// Types for extended errors
//
#define KERB_ERR_TYPE_EXTENDED                3

//
// PKINIT method errors
//
#define KERB_PKINIT_UNSPEC_ERROR        0       // not specified
#define KERB_PKINIT_BAD_PUBLIC_KEY      1       // cannot verify public key
#define KERB_PKINIT_INVALID_CERT        2       // invalid certificate
#define KERB_PKINIT_REVOKED_CERT        3       // revoked certificate
#define KERB_PKINIT_INVALID_KDC_NAME    4       // invalid KDC name
#define KERB_PKINIT_CLIENT_NAME_MISMATCH 5      // client name mismatch

//
// Flag bit defines for use with the LogonRestrictionsFlag parameter
// passed to the KerbCheckLogonRestrictions function
//
#define     KDC_RESTRICT_PKINIT_USED            1
#define     KDC_RESTRICT_IGNORE_PW_EXPIRATION   2

//
// HACK for MAX_UNICODE_STRING, as KerbDuplicateString & others add a NULL
// terminator when doing the duplication
//
#define KERB_MAX_UNICODE_STRING (UNICODE_STRING_MAX_BYTES - sizeof(WCHAR))

//
// No Key version (common for session keys)
//
#define KERB_NO_KEY_VERSION     0

#define KERBFLAG_LOGON                  0x1
#define KERBFLAG_INTERACTIVE            0x2

//
// KDC-Kerberos interaction
//

#define KDC_START_EVENT                 L"\\Security\\KdcStartEvent"

#define KERB_MAX_CRYPTO_SYSTEMS 20
#define KERB_MAX_CRYPTO_SYSTEMS_SLOWBUFF 100

#define KERB_DEFAULT_AP_REQ_CSUM        KERB_CHECKSUM_MD5
#define KERB_DEFAULT_PREAUTH_TYPE       0

//
// Registry parameters
//

#define KERB_PATH                       L"System\\CurrentControlSet\\Control\\Lsa\\Kerberos"
#define KERB_PARAMETER_PATH             L"System\\CurrentControlSet\\Control\\Lsa\\Kerberos\\Parameters"
#define KERB_PARAMETER_SKEWTIME         L"SkewTime"
#define KERB_PARAMETER_MAX_UDP_PACKET   L"MaxPacketSize"
#define KERB_PARAMETER_START_TIME       L"StartupTime"
#define KERB_PARAMETER_KDC_CALL_TIMEOUT L"KdcWaitTime"
#define KERB_PARAMETER_KDC_BACKOFF_TIME L"KdcBackoffTime"
#define KERB_PARAMETER_KDC_SEND_RETRIES L"KdcSendRetries"
#define KERB_PARAMETER_USE_SID_CACHE    L"UseSidCache"
#define KERB_PARAMETER_LOG_LEVEL        L"LogLevel"
#define KERB_PARAMETER_DEFAULT_ETYPE    L"DefaultEncryptionType"
#define KERB_PARAMETER_FAR_KDC_TIMEOUT  L"FarKdcTimeout"
#define KERB_PARAMETER_NEAR_KDC_TIMEOUT L"NearKdcTimeout"
#define KERB_PARAMETER_STRONG_ENC_DG    L"StronglyEncryptDatagram"
#define KERB_PARAMETER_MAX_REFERRAL_COUNT L"MaxReferralCount"
#define KERB_PARAMETER_MAX_TOKEN_SIZE   L"MaxTokenSize"
#define KERB_PARAMETER_SPN_CACHE_TIMEOUT L"SpnCacheTimeout"
#define KERB_PARAMETER_RETRY_PDC        L"RetryPDC"
#define KERB_PARAMETER_REQUEST_OPTIONS      L"RequestOptions"
#define KERB_PARAMETER_CLIENT_IP_ADDRESSES  L"ClientIpAddresses"
#define KERB_PARAMETER_TGT_RENEWAL_TIME L"TgtRenewalTime"

//
// Registry defaults
//

#define KERB_DEFAULT_LOGLEVEL 0
#define KERB_DEFAULT_USE_SIDCACHE FALSE
#define KERB_DEFAULT_USE_STRONG_ENC_DG FALSE
#define KERB_DEFAULT_CLIENT_IP_ADDRESSES 0
#define KERB_DEFAULT_TGT_RENEWAL_TIME 300

//
// These are arbitrary sizes for max request and responses sizes for datagram
// requests.
//

#define KERB_MAX_KDC_RESPONSE_SIZE      4000
#define KERB_MAX_DATAGRAM_SIZE          2000
#define KERB_MAX_RETRIES                3
#define KERB_MAX_REFERRAL_COUNT         10

//
// timeout values in minutes
//

#define KERB_BINDING_FAR_DC_TIMEOUT     10
#define KERB_BINDING_NEAR_DC_TIMEOUT    30
#define KERB_SPN_CACHE_TIMEOUT          15
#define KERB_DEFAULT_SKEWTIME           5

//
// timeout values in seconds
//

#define KERB_KDC_CALL_TIMEOUT                   5
#define KERB_KDC_CALL_TIMEOUT_BACKOFF           5
#define KERB_KDC_WAIT_TIME      120

//
// BER encoding values
//

#define KERB_BER_APPLICATION_TAG 0xc0
#define KERB_BER_APPLICATION_MASK 0x1f
#define KERB_TGS_REQ_TAG 12
#define KERB_AS_REQ_TAG 10
#define KERB_TGS_REP_TAG 13
#define KERB_AS_REP_TAG 11
#define KERB_ERROR_TAG 30


#endif // _KERBDEFS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\inc\kerbcomm.h ===
//+-----------------------------------------------------------------------
//
// File:        kerbcomm.h
//
// Contents:    prototypes for common kerberos routines
//
//
// History:     15-May-1996     Created         MikeSw
//
//------------------------------------------------------------------------

#ifndef _KERBCOMM_H_
#define _KERBCOMM_H_

#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus
#include <rpc.h>
#include <rpcndr.h>
#include <windef.h>
#include <stdio.h>
#include <limits.h>
#include <winbase.h>
#include <winsock2.h>
#include <krb5.h>
#include <cryptdll.h>
#include <align.h>
#ifdef __cplusplus
}
#endif // _cplusplus
#include <krb5p.h>
#include <kerberr.h>
#include <exterr.h>
#include <kerbcred.h>
#include <kerbnames.h>
#ifndef WIN32_CHICAGO
// SECURITY_WIN32 is already defined
#include <security.h>
#endif // WIN32_CHICAGO

//
//  bring in transport related definitions used by both transport (ie service) and kdccore
//
#include "kerbtrans.h"

//
//  bring in defines that used to be right here
//
#include "kerbdefs.h"

//////////////////////////////////////////////////////////////////////////
//
// Structures
//
//////////////////////////////////////////////////////////////////////////

typedef struct _KERB_PREAUTH_DATA {
    ULONG Flags;
} KERB_PREAUTH_DATA, *PKERB_PREAUTH_DATA;


//
// Prototypes
//
struct IKerbPrincipal; // fwd decl
struct  IKerbRequest;
struct  IKerbCrypt;
#ifdef __cplusplus

class CAuthenticatorList;
class   CKerbRequest;

KERBERR NTAPI
KerbCheckTicket(
    IN  CKerbRequest    *piReq,
    IN  PKERB_TICKET PackedTicket,
    IN  PKERB_ENCRYPTED_DATA EncryptedAuthenticator,
    //  use principal interface instead of enc key
    IN  IKerbPrincipal *piServer,
    IN  OUT CAuthenticatorList * AuthenticatorList,
    IN  const TimeStamp *SkewTime,
    IN  ULONG ServiceNameCount,
    IN  OPTIONAL PUNICODE_STRING ServiceName,
    IN  OPTIONAL PUNICODE_STRING ServiceRealm,
    IN  BOOLEAN CheckForReplay,
    IN  BOOLEAN KdcRequest,
    OUT PKERB_ENCRYPTED_TICKET * EncryptTicket,
    OUT PKERB_AUTHENTICATOR  * Authenticator,
    OUT PKERB_ENCRYPTION_KEY pkSessionKey,
    OUT OPTIONAL PKERB_ENCRYPTION_KEY pkTicketKey,
    OUT PBOOLEAN UseSubKey,
    OUT PKERB_EXT_ERROR pExtendedError
    );

extern "C" {

#endif // __cplusplus

KERBERR
KerbVerifyTicket(
    IN CKerbRequest * pReq,
    IN const KERB_TICKET * PackedTicket,
    IN ULONG NameCount,
    IN OPTIONAL const UNICODE_STRING * ServiceNames,
    IN OPTIONAL const UNICODE_STRING * ServiceRealm,
    IN IKerbPrincipal * piServicePrinc,
    IN OPTIONAL const TimeStamp * SkewTime,
    OUT PKERB_ENCRYPTED_TICKET * DecryptedTicket,
    OUT PKERB_EXT_ERROR pExtendedError
    );

//
//  use principal crypto to pack the ticket instead
//  of explicit key
//
KERBERR NTAPI
KerbPackTicket(
    IN CKerbRequest     *piReq,
    IN PKERB_TICKET     InternalTicket,
    IN IKerbPrincipal  *piPrinc,
    IN PKERB_CRYPT_LIST EncryptionTypes,
    OUT PKERB_TICKET    PackedTicket,
    OUT PKERB_EXT_ERROR pExtendedError
    );

VOID
KerbPrintPrincipalName(
    IN ULONG DebugLevel,
    IN const KERB_PRINCIPAL_NAME * Name
    );

VOID
KerbPrintKerbRealm(
    IN ULONG DebugLevel,
    IN const KERB_REALM * Realm
    );

KERBERR NTAPI
KerbUnpackTicket(
    IN const KERB_CRYPT_LIST  * pETypes,
    IN const KERB_TICKET * PackedTicket,
    IN IKerbPrincipal *piService,
    OUT PKERB_ENCRYPTED_TICKET * InternalTicket,
    OUT PKERB_EXT_ERROR pExtendedError
    );

// VOID NTAPI
// KerbFreeTicket(
//     IN PKERB_ENCRYPTED_TICKET Ticket
//     );

#define KerbFreeTicket( Ticket ) \
    KerbFreeData( \
        KERB_ENCRYPTED_TICKET_PDU, \
        (Ticket) \
        )

KERBERR NTAPI
KerbDuplicateTicket(
    OUT PKERB_TICKET DestinationTicket,
    IN PKERB_TICKET SourceTicket
    );

VOID
KerbFreeDuplicatedTicket(
    IN PKERB_TICKET Ticket
    );

VOID
CheckForOutsideStringToKey();

KERBERR NTAPI
KerbHashPassword(
    IN IKerbCrypt       *pIKerbCrypt,
    IN PUNICODE_STRING Password,
    IN ULONG EncryptionType,
    OUT PKERB_ENCRYPTION_KEY *ppKey
    );

KERBERR NTAPI
KerbHashPasswordEx(
    IN IKerbCrypt       *pIKerbCrypt,
    IN PUNICODE_STRING  Password,
    IN PUNICODE_STRING  PrincipalName,
    IN ULONG            EncryptionType,
    OUT PKERB_ENCRYPTION_KEY *ppKey
    );

KERBERR NTAPI
KerbMakeKey(
    IN ULONG EncryptionType,
    OUT PKERB_ENCRYPTION_KEY NewKey
    );

BOOLEAN
KerbIsKeyExportable(
    IN const KERB_ENCRYPTION_KEY * Key
    );

KERBERR
KerbMakeExportableKey(
    IN ULONG KeyType,
    OUT PKERB_ENCRYPTION_KEY NewKey
    );

KERBERR NTAPI
KerbCreateKeyFromBuffer(
    OUT PKERB_ENCRYPTION_KEY NewKey,
    IN const UCHAR * Buffer,
    IN ULONG BufferSize,
    IN ULONG EncryptionType
    );

KERBERR NTAPI
KerbDuplicateKey(
    OUT PKERB_ENCRYPTION_KEY NewKey,
    IN const KERB_ENCRYPTION_KEY * Key
    );

VOID
KerbFreeKey(
    IN PKERB_ENCRYPTION_KEY Key
    );

const KERB_ENCRYPTION_KEY *
KerbGetKeyFromList(
    IN const KERB_STORED_CREDENTIAL * Passwords,
    IN ULONG EncryptionType
    );

KERBERR
KerbFindCommonCryptSystem(
    IN const KERB_CRYPT_LIST * CryptList,
    IN const KERB_STORED_CREDENTIAL * Passwords,
    IN OPTIONAL const KERB_STORED_CREDENTIAL * MorePasswords,
    OUT PULONG CommonCryptSystem,
    OUT const KERB_KEY_DATA * * Key
    );

KERBERR
KerbProcessPaCompoundIdentity(CKerbRequest *pKdcReq, PKERB_EXT_ERROR pExtErr);

//  used by client and kdccode to compute new session key
//  for pa-with-identity
NTSTATUS
KerbComputePaCompIdentityKey(
    IN  OUT PKERB_ENCRYPTION_KEY pSessionKey,
    IN   ULONG                cKeys,
    IN const KERB_ENCRYPTION_KEY *ppPAKeys
    );

//  used by client and kdccode to compute new session key
//  for pa-with-identity
NTSTATUS
KerbComputePaCompIdentityKeyForPrincipal(
    IN ULONG                      etype,
    IN IKerbRequest*              pIKdcReq,
    OUT KERB_ENCRYPTION_KEY**     ppNewKey,
    IN ULONG                      cKeys,
    IN const KERB_ENCRYPTION_KEY  *ppPAKeys
    );

//
//  one used by the new interface
//
KERBERR
KerbFindCommonEType(
    IN const KERB_CRYPT_LIST * ReqEtypes,
    IN ULONG cEtypes,
    IN const ULONG * pculETypes,
    OUT PULONG pulMatch
    );

KERBERR NTAPI
KerbRandomFill(
    IN OUT PUCHAR pbBuffer,
    IN ULONG cbBuffer
    );

KERBERR NTAPI
KerbCreateAuthenticator(
    IN IKerbCrypt   *piCrypt,
    IN PKERB_ENCRYPTION_KEY pkKey,
    IN ULONG EncryptionType,
    IN ULONG SequenceNumber,
    IN PKERB_INTERNAL_NAME ClientName,
    IN PUNICODE_STRING ClientRealm,
    IN OPTIONAL PTimeStamp skewTime,
    IN PKERB_ENCRYPTION_KEY pkSubKey,
    IN OPTIONAL PKERB_CHECKSUM GssChecksum,
    IN BOOLEAN KdcRequest,
    OUT PKERB_ENCRYPTED_DATA Authenticator
    );

KERBERR NTAPI
KerbUnpackAuthenticator(
    IN PKERB_ENCRYPTION_KEY Key,
    IN PKERB_ENCRYPTED_DATA EncryptedAuthenticator,
    IN BOOLEAN KdcRequest,
    OUT PKERB_AUTHENTICATOR * Authenticator
    );

// VOID NTAPI
// KerbFreeAuthenticator(
//     IN PKERB_AUTHENTICATOR Authenticator
//     );

#define KerbFreeAuthenticator( Authenticator ) \
    KerbFreeData( \
        KERB_AUTHENTICATOR_PDU, \
        (Authenticator) \
        )
//
//  use principal OR key to encrypt
//  if key is not present, principal crypto is used
//
KERBERR NTAPI
KerbPackKdcReplyBody(
    IN CKerbRequest*    pReq,
    IN PKERB_ENCRYPTED_KDC_REPLY ReplyBody,
    IN PKERB_ENCRYPTION_KEY Key,
    IN OPTIONAL IKerbPrincipal *piPrinc,
    //  key version is used only with principal encryption
    //  in this case the version comes from the principal interface
//    IN ULONG KeyVersion,
    IN PKERB_CRYPT_LIST EncryptionTypes,
    IN ULONG Pdu,
    OUT PKERB_ENCRYPTED_DATA EncryptedReply,
    OUT PKERB_EXT_ERROR pExtendedError
    );

KERBERR NTAPI
KerbUnpackKdcReplyBody(
    IN PKERB_ENCRYPTED_DATA EncryptedReplyBody,
    IN PKERB_ENCRYPTION_KEY Key,
    IN ULONG Pdu,
    OUT PKERB_ENCRYPTED_KDC_REPLY * ReplyBody
    );

KERBERR NTAPI
KerbPackData(
    IN PVOID Data,
    IN ULONG PduValue,
    OUT PULONG DataSize,
    OUT PUCHAR * MarshalledData
    );

KERBERR NTAPI
KerbUnpackData(
    IN const UCHAR * Data,
    IN ULONG DataSize,
    IN ULONG PduValue,
    OUT PVOID * DecodedData
    );

// KERBERR NTAPI
// KerbPackAsReply(
//     IN PKERB_KDC_REPLY ReplyMessage,
//     OUT PULONG ReplySize,
//     OUT PUCHAR * MarshalledReply
//     );

#define KerbPackAsReply( ReplyMessage, ReplySize, MarshalledReply ) \
    KerbPackData( \
        (PVOID) (ReplyMessage), \
        KERB_AS_REPLY_PDU, \
        (ReplySize), \
        (MarshalledReply) \
        )

// KERBERR NTAPI
// KerbUnpackAsReply(
//     IN PUCHAR ReplyMessage,
//     IN ULONG ReplySize,
//     OUT PKERB_KDC_REPLY * Reply
//     );

#define KerbUnpackAsReply( ReplyMessage, ReplySize, Reply ) \
    KerbUnpackData( \
        (ReplyMessage), \
        (ReplySize), \
        KERB_AS_REPLY_PDU, \
        (PVOID *) (Reply) \
        )

// VOID
// KerbFreeAsReply(
//    IN PKERB_KDC_REPLY Request
//    );

#define KerbFreeAsReply( Request) \
    KerbFreeData( \
        KERB_AS_REPLY_PDU, \
        (PVOID) (Request) \
        )

// KERBERR NTAPI
// KerbPackTgsReply(
//     IN PKERB_KDC_REPLY ReplyMessage,
//     OUT PULONG ReplySize,
//     OUT PUCHAR * MarshalledReply
//     );

#define KerbPackTgsReply( ReplyMessage, ReplySize, MarshalledReply ) \
    KerbPackData( \
        (PVOID) (ReplyMessage), \
        KERB_TGS_REPLY_PDU, \
        (ReplySize), \
        (MarshalledReply) \
        )

// KERBERR NTAPI
// KerbUnpackTgsReply(
//     IN PUCHAR ReplyMessage,
//     IN ULONG ReplySize,
//     OUT PKERB_KDC_REPLY * Reply
//     );

#define KerbUnpackTgsReply( ReplyMessage, ReplySize, Reply ) \
    KerbUnpackData( \
        (ReplyMessage), \
        (ReplySize), \
        KERB_TGS_REPLY_PDU, \
        (PVOID *) (Reply) \
        )

// VOID
// KerbFreeTgsReply(
//    IN PKERB_KDC_REPLY Request
//    );

#define KerbFreeTgsReply( Request) \
    KerbFreeData( \
        KERB_TGS_REPLY_PDU, \
        (PVOID) (Request) \
        )

// VOID
// KerbFreeKdcReplyBody(
//    IN PKERB_ENCRYPTED_KDC_REPLY Request
//    );

#define KerbFreeKdcReplyBody( Request) \
    KerbFreeData( \
        KERB_ENCRYPTED_TGS_REPLY_PDU, \
        (PVOID) (Request) \
        )

// KERBERR NTAPI
// KerbPackAsRequest(
//     IN PKERB_KDC_REQUEST RequestMessage,
//     OUT PULONG RequestSize,
//     OUT PUCHAR * MarshalledRequest
//     );

#define KerbPackAsRequest( RequestMessage, RequestSize, MarshalledRequest )\
    KerbPackData( \
        (PVOID) (RequestMessage), \
        KERB_AS_REQUEST_PDU, \
        (RequestSize), \
        (MarshalledRequest) \
        )

// KERBERR NTAPI
// KerbUnpackAsRequest(
//     IN PUCHAR RequestMessage,
//     IN ULONG RequestSize,
//     OUT PKERB_KDC_REQUEST * Request
//     );

#define KerbUnpackAsRequest( RequestMessage, RequestSize, Request ) \
    KerbUnpackData( \
        (RequestMessage), \
        (RequestSize), \
        KERB_AS_REQUEST_PDU, \
        (PVOID *) (Request) \
        )

// VOID
// KerbFreeAsRequest(
//    IN PKERB_KDC_REQUEST Request
//    );

#define KerbFreeAsRequest( Request) \
    KerbFreeData( \
        KERB_TGS_REQUEST_PDU, \
        (PVOID) (Request) \
        )

// KERBERR NTAPI
// KerbPackTgsRequest(
//     IN PKERB_KDC_REQUEST RequestMessage,
//     OUT PULONG RequestSize,
//     OUT PUCHAR * MarshalledRequest
//     );

#define KerbPackTgsRequest( RequestMessage, RequestSize, MarshalledRequest )\
    KerbPackData( \
        (PVOID) (RequestMessage), \
        KERB_TGS_REQUEST_PDU, \
        (RequestSize), \
        (MarshalledRequest) \
        )

// KERBERR NTAPI
// KerbUnpackTgsRequest(
//     IN PUCHAR RequestMessage,
//     IN ULONG RequestSize,
//     OUT PKERB_KDC_REQUEST * Request
//     );

#define KerbUnpackTgsRequest( RequestMessage, RequestSize, Request ) \
    KerbUnpackData( \
        (RequestMessage), \
        (RequestSize), \
        KERB_TGS_REQUEST_PDU, \
        (PVOID *) (Request) \
        )

// VOID
// KerbFreeTgsRequest(
//    IN PKERB_KDC_REQUEST Request
//    );

#define KerbFreeTgsRequest( Request) \
    KerbFreeData( \
        KERB_TGS_REQUEST_PDU, \
        (PVOID) (Request) \
        )

// KERBERR NTAPI
// KerbPackEncryptedData(
//     IN PKERB_ENCRYPTED_DATA EncryptedData,
//     OUT PULONG DataSize,
//     OUT PUCHAR * MarshalledData
//     );

#define KerbPackEncryptedData( EncryptedData, DataSize, MarshalledData ) \
    KerbPackData( \
        (PVOID) (EncryptedData), \
        KERB_ENCRYPTED_DATA_PDU, \
        (DataSize), \
        (PUCHAR *) (MarshalledData) \
        )

// KERBERR NTAPI
// KerbUnpackEncryptedData(
//     IN PUCHAR EncryptedData,
//    IN ULONG DataSize,
//    OUT PKERB_ENCRYPTED_DATA * Data
//    );

#define KerbUnpackEncryptedData( EncryptedData,DataSize,Data ) \
    KerbUnpackData( \
        (EncryptedData), \
        (DataSize), \
        KERB_ENCRYPTED_DATA_PDU, \
        (PVOID *) (Data) \
        )

// VOID
// KerbFreeEncryptedData(
//    IN PKERB_ENCRYPTED_DATA EncryptedData
//    );

#define KerbFreeEncryptedData( EncryptedData) \
    KerbFreeData( \
        KERB_ENCRYPTED_DATA_PDU, \
        (PVOID) (EncryptedData) \
        )

#ifdef notdef
// KERBERR NTAPI
// KerbPackAuthData(
//     IN PKERB_AUTHORIZATION_DATA AuthData,
//     OUT PULONG AuthDataSize,
//     OUT PUCHAR * MarshalledAuthData
//     );

#define KerbPackAuthData( AuthData, AuthDataSize, MarshalledAuthData ) \
    KerbPackData( \
        (PVOID) (AuthData), \
        KERB_AUTHORIZATION_DATA_PDU, \
        (AuthDataSize), \
        (MarshalledAuthData) \
        )

// KERBERR NTAPI
// KerbUnpackAuthData(
//     IN PUCHAR PackedAuthData,
//     IN ULONG AuthDataSize,
//     OUT PKERB_AUTHORIZATION_DATA * AuthData
//     );

#define KerbUnpackAuthData( PackedAuthData, AuthDataSize, AuthData ) \
    KerbUnpackData( \
        (PackedAuthData), \
        (AuthDataSize), \
        KERB_AUTHORIZATION_DATA_PDU, \
        (PVOID *) (AuthData) \
        )

// VOID
// KerbFreeAuthData(
//    IN PKERB_AUTH_DATA AuthData
//    );

#define KerbFreeAuthData( AuthData) \
    KerbFreeData( \
        KERB_AUTHORIZATION_DATA_PDU, \
        (PVOID) (AuthData) \
        )

#endif // notdef

VOID
KerbFreeAuthData(
   IN PKERB_AUTHORIZATION_DATA AuthData
   );

// KERBERR NTAPI
// KerbPackApRequest(
//     IN PKERB_AP_REQUEST ApRequestMessage,
//     OUT PULONG ApRequestSize,
//     OUT PUCHAR * MarshalledApRequest
//     );

#define KerbPackApRequest( ApRequestMessage, ApRequestSize, MarshalledApRequest ) \
    KerbPackData( \
        (PVOID) (ApRequestMessage), \
        KERB_AP_REQUEST_PDU, \
        (ApRequestSize), \
        (MarshalledApRequest) \
        )

// KERBERR NTAPI
// KerbUnpackApRequest(
//    IN PUCHAR ApRequestMessage,
//    IN ULONG ApRequestSize,
//    OUT PKERB_AP_REQUEST * ApRequest
//    );

#define KerbUnpackApRequest( ApRequestMessage,ApRequestSize, ApRequest) \
    KerbUnpackData( \
        (ApRequestMessage), \
        (ApRequestSize), \
        KERB_AP_REQUEST_PDU, \
        (PVOID *) (ApRequest) \
        )

// VOID
// KerbFreeApRequest(
//    IN PKERB_AP_REQUEST Request
//    );

#define KerbFreeApRequest( Request) \
    KerbFreeData( \
        KERB_AP_REQUEST_PDU, \
        (PVOID) (Request) \
        )


// KERBERR NTAPI
// KerbPackApReply(
//     IN PKERB_AP_REPLY ApReplyMessage,
//     OUT PULONG ApReplySize,
//     OUT PUCHAR * MarshalledApReply
//     );

#define KerbPackApReply( ApReplyMessage, ApReplySize, MarshalledApReply ) \
    KerbPackData( \
        (PVOID) (ApReplyMessage), \
        KERB_AP_REPLY_PDU, \
        (ApReplySize), \
        (MarshalledApReply) \
        )

// KERBERR NTAPI
// KerbUnpackApReply(
//     IN PUCHAR ApReplyMessage,
//     IN ULONG ApReplySize,
//     OUT PKERB_AP_REPLY * ApReply
//    );

#define KerbUnpackApReply( ApReplyMessage,ApReplySize, ApReply) \
    KerbUnpackData( \
        (ApReplyMessage), \
        (ApReplySize), \
        KERB_AP_REPLY_PDU, \
        (PVOID *) (ApReply) \
        )

// VOID
// KerbFreeApReply(
//    IN PKERB_AP_REPLY Reply
//    );

#define KerbFreeApReply( Reply) \
    KerbFreeData( \
        KERB_AP_REPLY_PDU, \
        (PVOID) (Reply) \
        )

// KERBERR NTAPI
// KerbPackApReplyBody(
//     IN PKERB_ENCRYPTED_AP_REPLY ApReplyBodyMessage,
//     OUT PULONG ApReplyBodySize,
//     OUT PUCHAR * MarshalledApReplyBody
//    );

#define KerbPackApReplyBody( ApReplyBodyMessage, ApReplyBodySize, MarshalledApReplyBody ) \
    KerbPackData( \
        (PVOID) (ApReplyBodyMessage), \
        KERB_ENCRYPTED_AP_REPLY_PDU, \
        (ApReplyBodySize), \
        (MarshalledApReplyBody) \
        )

// KERBERR NTAPI
// KerbUnpackApReplyBody(
//     IN PUCHAR ApReplyBodyMessage,
//     IN ULONG ApReplyBodySize,
//     OUT PKERB_ENCRYPTED_AP_REPLY * ApReplyBody
//    );

#define KerbUnpackApReplyBody( ApReplyBodyMessage,ApReplyBodySize, ApReplyBody) \
    KerbUnpackData( \
        (ApReplyBodyMessage), \
        (ApReplyBodySize), \
        KERB_ENCRYPTED_AP_REPLY_PDU, \
        (PVOID *) (ApReplyBody) \
        )

// VOID
// KerbFreeApReplyBody(
//    IN PKERB_ENCRYPTED_AP_REPLY ReplyBody
//    );

#define KerbFreeApReplyBody( ReplyBody) \
    KerbFreeData( \
        KERB_ENCRYPTED_AP_REPLY_PDU, \
        (PVOID) (ReplyBody) \
        )

// KERBERR NTAPI
// KerbUnmarshallTicket(
//     IN PUCHAR TicketMessage,
//     IN ULONG TicketSize,
//     OUT PKERB_ENCRYPTED_TICKET * Ticket
//     );

#define KerbUnmarshallTicket( TicketMessage, TicketSize, Ticket ) \
    KerbUnpackData( \
        (TicketMessage), \
        (TicketSize), \
        KERB_ENCRYPTED_TICKET_PDU, \
        (PVOID *) (Ticket) \
        )

// KERBERR NTAPI
// KerbPackEncryptedCred(
//     IN PKERB_ENCRYPTED_CRED EncryptedCred,
//     OUT PULONG CredSize,
//     OUT PUCHAR * MarshalledCred
//     );

#define KerbPackEncryptedCred( EncryptedCred, CredSize, MarshalledCred ) \
    KerbPackData( \
        (PVOID) (EncryptedCred), \
        KERB_ENCRYPTED_CRED_PDU, \
        (CredSize), \
        (MarshalledCred) \
        )

// KERBERR NTAPI
// KerbUnpackEncryptedCred(
//     IN PUCHAR EncryptedCred,
//    IN ULONG CredSize,
//    OUT PKERB_ENCRYPTED_CRED * Cred
//    );

#define KerbUnpackEncryptedCred( EncryptedCred,CredSize,Cred ) \
    KerbUnpackData( \
        (EncryptedCred), \
        (CredSize), \
        KERB_ENCRYPTED_CRED_PDU, \
        (PVOID *) (Cred) \
        )

// VOID
// KerbFreeEncryptedCred(
//    IN PKERB_ENCRYPTED_CRED EncryptedCred
//    );

#define KerbFreeEncryptedCred( EncryptedCred) \
    KerbFreeData( \
        KERB_ENCRYPTED_CRED_PDU, \
        (PVOID) (EncryptedCred) \
        )

// KERBERR NTAPI
// KerbPackKerbCred(
//     IN PKERB_CRED KerbCred,
//     OUT PULONG KerbCredSize,
//     OUT PUCHAR * MarshalledKerbCred
//     );

#define KerbPackKerbCred( KerbCred, KerbCredSize, MarshalledKerbCred ) \
    KerbPackData( \
        (PVOID) (KerbCred), \
        KERB_CRED_PDU, \
        (KerbCredSize), \
        (MarshalledKerbCred) \
        )

// KERBERR NTAPI
// KerbUnpackKerbCred(
//    IN PUCHAR MarshalledKerbCred,
//    IN ULONG KerbCredSize,
//    OUT PKERB_CRED * KerbCred
//    );

#define KerbUnpackKerbCred( MarshalledKerbCred,KerbCredSize,KerbCred ) \
    KerbUnpackData( \
        (MarshalledKerbCred), \
        (KerbCredSize), \
        KERB_CRED_PDU, \
        (PVOID *) (KerbCred) \
        )

// VOID
// KerbFreeKerbCred(
//    IN PKERB_CRED KerbCred
//    );

#define KerbFreeKerbCred( KerbCred) \
    KerbFreeData( \
        KERB_CRED_PDU, \
        (PVOID) (KerbCred) \
        )

// KERBERR NTAPI
// KerbPackKerbError(
//     IN PKERB_ERROR ErrorMessage,
//     OUT PULONG ErrorSize,
//     OUT PUCHAR * MarshalledError
//     );

#define KerbPackKerbError( ErrorMessage, ErrorSize, MarshalledError ) \
    KerbPackData( \
        (PVOID) (ErrorMessage), \
        KERB_ERROR_PDU, \
        (ErrorSize), \
        (MarshalledError) \
        )

// KERBERR NTAPI
// KerbUnpackKerbError(
//     IN PUCHAR ErrorMessage,
//     IN ULONG ErrorSize,
//     OUT PKERB_ERROR * Error
//     );

#define KerbUnpackKerbError( ErrorMessage, ErrorSize, Error ) \
    KerbUnpackData( \
        (ErrorMessage), \
        (ErrorSize), \
        KERB_ERROR_PDU, \
        (PVOID *) (Error) \
        )

// VOID
// KerbFreeKerbError(
//    IN PKERB_ERROR Request
//    );

#define KerbFreeKerbError( Error ) \
    KerbFreeData( \
        KERB_ERROR_PDU, \
        (PVOID) (Error) \
        )

// KERBERR NTAPI
// KerbPackEncryptedTime(
//     IN PKERB_ENCRYPTED_TIMESTAMP EncryptedTimeMessage,
//     OUT PULONG EncryptedTimeSize,
//     OUT PUCHAR * MarshalledEncryptedTime
//     );

#define KerbPackEncryptedTime( EncryptedTimeMessage, EncryptedTimeSize, MarshalledEncryptedTime ) \
    KerbPackData( \
        (PVOID) (EncryptedTimeMessage), \
        KERB_ENCRYPTED_TIMESTAMP_PDU, \
        (EncryptedTimeSize), \
        (MarshalledEncryptedTime) \
        )

// KERBERR NTAPI
// KerbUnpackEncryptedTime(
//     IN PUCHAR EncryptedTimeMessage,
//     IN ULONG EncryptedTimeSize,
//     OUT PKERB_ENCRYPTED_TIMESTAMP * EncryptedTime
//     );

#define KerbUnpackEncryptedTime( EncryptedTimeMessage, EncryptedTimeSize, EncryptedTime ) \
    KerbUnpackData( \
        (EncryptedTimeMessage), \
        (EncryptedTimeSize), \
        KERB_ENCRYPTED_TIMESTAMP_PDU, \
        (PVOID *) (EncryptedTime) \
        )

// VOID
// KerbFreeEncryptedTime(
//    IN PKERB_ENCRYPTED_TIMESTAMP EncryptedTime
//    );

#define KerbFreeEncryptedTime( EncryptedTime ) \
    KerbFreeData( \
        KERB_ENCRYPTED_TIMESTAMP_PDU, \
        (PVOID) (EncryptedTime) \
        )

KERBERR
KerbAllocateEncryptionBuffer(
    IN ULONG EncryptionType,
    IN ULONG BufferSize,
    OUT PUINT EncryptionBufferSize,
    OUT PBYTE * EncryptionBuffer
    );

KERBERR
KerbAllocateEncryptionBufferWrapper(
    IN IKerbCrypt *piCrypt,
    IN ULONG EncryptionType,
    IN ULONG BufferSize,
    OUT unsigned long * EncryptionBufferSize,
    OUT PBYTE * EncryptionBuffer
    );

KERBERR NTAPI
KerbEncryptData(
    OUT PKERB_ENCRYPTED_DATA EncryptedData,
    IN ULONG DataSize,
    IN const UCHAR * Data,
    IN ULONG Algorithm,
    IN const KERB_ENCRYPTION_KEY * Key
    );

KERBERR NTAPI
KerbDecryptData(
    IN const KERB_ENCRYPTED_DATA * EncryptedData,
    IN const KERB_ENCRYPTION_KEY * pkKey,
    OUT PULONG DataSize,
    OUT PUCHAR Data
    );

KERBERR NTAPI
KerbEncryptDataEx(
    OUT PKERB_ENCRYPTED_DATA EncryptedData,
    IN ULONG DataSize,
    IN const UCHAR * Data,
    IN ULONG Algorithm,
    IN ULONG KeyVersion,
    IN ULONG UsageFlags,
    IN const KERB_ENCRYPTION_KEY * Key
    );

KERBERR NTAPI
KerbDecryptDataEx(
    IN const KERB_ENCRYPTED_DATA * EncryptedData,
    IN const KERB_ENCRYPTION_KEY * pkKey,
    IN ULONG UsageFlags,
    OUT PULONG DataSize,
    OUT PUCHAR Data
    );

#ifndef WIN32_CHICAGO
KERBERR NTAPI
KerbCheckSumVerify(
    IN PUCHAR pbBuffer,
    IN ULONG cbBuffer,
    OUT PKERB_CHECKSUM pcsCheck
    );

KERBERR NTAPI
KerbCheckSum(
    PUCHAR pbData,
    ULONG cbData,
    PCHECKSUM_FUNCTION pcsfSum,
    PKERB_CHECKSUM pcsCheckSum
    );
#endif // WIN32_CHICAGO

KERBERR
KerbGetEncryptionOverhead(
    IN ULONG Algorithm,
    OUT PULONG Overhead,
    OUT OPTIONAL PULONG BlockSize
    );

NTSTATUS
KerbDuplicateSid(
    OUT PSID * DestinationSid,
    IN PSID SourceSid
    );

NTSTATUS
KerbConvertStringToSid(
    IN const UNICODE_STRING * String,
    OUT PSID * Sid
    );

NTSTATUS
__stdcall
KerbConvertSidToString(
    IN PSID Sid,
    OUT PUNICODE_STRING String,
    IN BOOLEAN AllocateDestination
    );

KERBERR
KerbExtractSidFromKdcName(
    IN OUT PKERB_INTERNAL_NAME Name,
    OUT PSID * Sid
    );

KERBERR
KerbBuildFullServiceKdcNameWithSid(
    IN const UNICODE_STRING * DomainName,
    IN const UNICODE_STRING * ServiceName,
    IN OPTIONAL PSID Sid,
    IN ULONG NameType,
    OUT PKERB_INTERNAL_NAME * FullServiceName
    );

NTSTATUS
KerbDuplicateString(
    OUT PUNICODE_STRING DestinationString,
    IN OPTIONAL const UNICODE_STRING * SourceString
    );

LPWSTR
KerbBuildNullTerminatedString(
    IN const UNICODE_STRING * String
    );

VOID
__stdcall
KerbFreeString(
    IN OPTIONAL PUNICODE_STRING String
    );

VOID
KerbFreeRealm(
    IN PKERB_REALM Realm
    );

KERBERR
KerbCompareUnicodeRealmToKerbRealm(
    IN const KERB_REALM * KerbRealm,
    IN const UNICODE_STRING * UnicodeRealm,
    OUT PBOOLEAN Result
    );

VOID
KerbFreePrincipalName(
    IN PKERB_PRINCIPAL_NAME Name
    );

#ifndef WIN32_CHICAGO
KERBERR
KerbCheckLogonRestrictions(
    IN PVOID UserHandle,
    IN PUNICODE_STRING Workstation,
    IN PUSER_ALL_INFORMATION UserAll,
    IN ULONG LogonRestrictionsFlags,
    OUT PTimeStamp LogoffTime,
    OUT PNTSTATUS RetStatus
    );

#include <pacndr.h>
NTSTATUS
PAC_EncodeTokenRestrictions(
    IN PKERB_TOKEN_RESTRICTIONS TokenRestrictions,
    OUT PBYTE * EncodedData,
    OUT PULONG DataSize
    );

NTSTATUS
PAC_DecodeTokenRestrictions(
    IN PBYTE EncodedData,
    IN ULONG DataSize,
    OUT PKERB_TOKEN_RESTRICTIONS * TokenRestrictions
    );



#define KERB_TOKEN_RESTRICTION_DISABLE_GROUPS   1
#define KERB_TOKEN_RESTRICTION_RESTRICT_SIDS    2
#define KERB_TOKEN_RESTRICTION_DELETE_PRIVS     4


#endif // WIN32_CHICAGO


VOID
KerbConvertLargeIntToGeneralizedTime(
    OUT PKERB_TIME ClientTime,
    OUT OPTIONAL long * ClientUsec,
    IN const TimeStamp * TimeStamp
    );

VOID
KerbConvertGeneralizedTimeToLargeInt(
    OUT PTimeStamp TimeStamp,
    IN const KERB_TIME * ClientTime,
    IN int ClientUsec
    );

BOOLEAN
KerbCheckTimeSkew(
    IN const TimeStamp * CurrentTime,
    IN const TimeStamp * ClientTime,
    IN const TimeStamp * AllowedSkew
    );

KERBERR
KerbConvertArrayToCryptList(
    OUT PKERB_CRYPT_LIST * CryptList,
    IN PULONG ETypeArray,
    IN ULONG ETypeCount
    );

KERBERR
KerbConvertKeysToCryptList(
    OUT PKERB_CRYPT_LIST * CryptList,
    IN PKERB_STORED_CREDENTIAL Keys
    );

KERBERR
KerbConvertCryptListToArray(
    OUT PULONG * ETypeArray,
    OUT PULONG ETypeCount,
    IN PKERB_CRYPT_LIST CryptList
    );

VOID
KerbFreeCryptList(
    IN PKERB_CRYPT_LIST CryptList
    );

const KERB_AUTHORIZATION_DATA *
KerbFindAuthDataEntry(
    IN ULONG EntryId,
    IN const KERB_AUTHORIZATION_DATA * AuthData
    );

PKERB_PA_DATA
KerbFindPreAuthDataEntry(
    IN ULONG EntryId,
    IN PKERB_PA_DATA_LIST AuthData
    );

VOID
KerbFreePreAuthData(
    IN OPTIONAL PKERB_PA_DATA_LIST PreAuthData
    );

KERBERR
KerbCopyAndAppendAuthData(
    OUT PKERB_AUTHORIZATION_DATA * OutputAuthData,
    IN PKERB_AUTHORIZATION_DATA InputAuthData
    );

KERBERR
KerbGetPacFromAuthData(
    IN const KERB_AUTHORIZATION_DATA * AuthData,
    OUT PKERB_IF_RELEVANT_AUTH_DATA ** ReturnIfRelevantData,
    OUT const KERB_AUTHORIZATION_DATA * * Pac
    );
KERBERR
KerbCreateApRequest(
    IN IKerbCrypt   *piCrypt,
    IN PKERB_INTERNAL_NAME ClientName,
    IN PUNICODE_STRING ClientRealm,
    IN PKERB_ENCRYPTION_KEY SessionKey,
    IN PKERB_ENCRYPTION_KEY SubSessionKey,
    IN ULONG Nonce,
    IN PKERB_TICKET ServiceTicket,
    IN ULONG ApOptions,
    IN OPTIONAL PKERB_CHECKSUM GssChecksum,
    IN OPTIONAL PTimeStamp ServerSkewTime,
    IN BOOLEAN KdcRequest,
    OUT PULONG RequestSize,
    OUT PUCHAR * Request
    );

KERBERR
KerbBuildErrorMessageEx(
    IN KERBERR ErrorCode,
    IN OPTIONAL const KERB_EXT_ERROR * pExtendedError,
    IN const UNICODE_STRING * ServerRealm,
    IN const KERB_INTERNAL_NAME * ServerName,
    IN OPTIONAL const UNICODE_STRING * ClientRealm,
    IN OPTIONAL const BYTE * ErrorData,
    IN ULONG ErrorDataSize,
    OUT PULONG ErrorMessageSize,
    OUT PUCHAR * ErrorMessage
    );

KERBERR
KerbBuildExtendedError(
   IN const KERB_EXT_ERROR * pExtendedError,
   OUT PULONG ExtErrorSize,
   OUT PBYTE * ExtErrorData
   );

#ifdef __cplusplus
}   // extern "C"

NTSTATUS
KerbGetKeyFromListEx(
    IN const KERB_STORED_CREDENTIAL * Passwords,
    IN ULONG EncryptionType,
    OUT const KERB_ENCRYPTION_KEY * * Key
    );

NTSTATUS
KerbGetKeyFromListEx(
    IN const KERB_STORED_CREDENTIAL * Passwords,
    IN ULONG EncryptionType,
    OUT const KERB_KEY_DATA * * KeyData
    );

#endif

//
// Socket functions
//

NTSTATUS
KerbInitializeSockets(
    IN WORD VersionRequired,
    IN ULONG MinSockets,
    OUT BOOLEAN *TcpNotInstalled
    );

VOID
KerbCleanupSockets(
    );

NTSTATUS
KerbCallKdc(
    IN PUNICODE_STRING KdcAddress,
    IN ULONG AddressType,
    IN ULONG Timeout,
    IN BOOLEAN UseDatagram,
    IN USHORT PortNumber,
    IN PKERB_MESSAGE_BUFFER Input,
    OUT PKERB_MESSAGE_BUFFER Output
    );

NTSTATUS
KerbMapKerbError(
    IN KERBERR KerbError
    );

VOID
KerbFreeHostAddresses(
    IN PKERB_HOST_ADDRESSES Addresses
    );

KERBERR
KerbDuplicateHostAddresses(
    OUT PKERB_HOST_ADDRESSES * DestAddresses,
    IN PKERB_HOST_ADDRESSES SourceAddresses
    );

PSID
KerbMakeDomainRelativeSid(
    IN PSID DomainId,
    IN ULONG RelativeId
    );

ULONG
KerbConvertFlagsToUlong(
    IN const VOID * Flags
    );

ULONG
KerbConvertUlongToFlagUlong(
    IN ULONG Flag
    );

BOOLEAN
KerbCompareObjectIds(
    IN const KERB_OBJECT_ID * Object1,
    IN const KERB_OBJECT_ID * Object2
    );

KERBERR
KerbGetClientNetbiosAddress(
    OUT PUNICODE_STRING ClientNetbiosAddress,
    IN PKERB_HOST_ADDRESSES Addresses
    );

#ifdef __WINCRYPT_H__
KERBERR
KerbCreateCertificateList(
    OUT PKERB_CERTIFICATE_LIST * Certificates,
    IN PCCERT_CONTEXT CertContext
    );

VOID
KerbFreeCertificateList(
    IN PKERB_CERTIFICATE_LIST Certificates
    );

NTSTATUS
KerbGetPrincipalNameFromCertificate(
    IN PCCERT_CONTEXT ClientCert,
    OUT PUNICODE_STRING String
    );
#endif //  __WINCRYPT_H__


NTSTATUS
KerbDuplicateStringEx(
    OUT PUNICODE_STRING DestinationString,
    IN OPTIONAL const UNICODE_STRING * SourceString,
    IN BOOLEAN NullTerminate
    );

BOOLEAN
KerbVerifyClientAddress(
    IN const SOCKADDR * ClientAddress,
    IN const KERB_HOST_ADDRESSES * Addresses
    );

#if DBG

void
DebugDisplayTime(
    IN ULONG DebugLevel,
    IN const FILETIME * pFileTime
    );
#endif

//
//  prototypes for functions shared with the providers
//
extern "C"
void *
WINAPI
KdcAllocMemory(
    IN size_t Size
    );

extern "C"
void *
WINAPI
KdcReallocMemory(
    IN void * Address,
    IN size_t Size
    );

extern "C"
void
WINAPI
KdcFreeMemory(
    IN void * Address
    );

//
//  Data packing and unpacking utilities.
//  TODO: remove since they are not used in the provider
//

KERBERR __stdcall KdcUnpackData(
    IN PUCHAR   pbData,
    IN ULONG    ulDataSize,
    IN ULONG    ulPduValue,
    OUT PVOID * ppvDecodedData
    );

KERBERR __stdcall KdcPackData(
    IN PVOID    pvData,
    IN ULONG    ulPduValue,
    OUT PULONG  pulDataSize,
    OUT PUCHAR * ppbMarshalledData
    );

VOID
WINAPI
KerbFreeData(
    IN ULONG PduValue,
    IN PVOID Data
    );

#endif // _KERBCOMM_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\inc\kpasswd.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        kpasswd.h
//
// Contents:    types for Kerberos change password
//
//
// History:     30-Sep-1998     MikeSw          Created
//
//------------------------------------------------------------------------

#ifndef __KPASSWD_H__
#define __KPASSWD_H__


//
// Name of the kpasswd service
//


#define KERB_KPASSWD_NAME L"kadmin"

#define KERB_KPASSWD_VERSION 0x0001
#define KERB_KPASSWD_SET_VERSION 0xff80

#define SET_SHORT(_field_, _short_) \
{ \
    (_field_)[0] = (BYTE) (((_short_)&0xff00) >> 8); \
    (_field_)[1] = (BYTE) (_short_)&0xff; \
}

#define GET_SHORT( _short_,_field_) \
{ \
    (_short_) = ((_field_)[0] << 8) + (_field_)[1]; \
}

//
// Type for a kpasswd request
//

#include <pshpack1.h>
typedef struct _KERB_KPASSWD_REQ {
    BYTE MessageLength[2];
    BYTE Version[2];
    BYTE ApReqLength[2];
    BYTE Data[ANYSIZE_ARRAY];   // for KERB_AP_REQUEST-REQ and KERB_PRIV
} KERB_KPASSWD_REQ, *PKERB_KPASSWD_REQ;

//
// type for a kpasswd reply
//

typedef struct _KERB_KPASSWD_REP {
    BYTE MessageLength[2];
    BYTE Version[2];
    BYTE ApRepLength[2];
    BYTE Data[ANYSIZE_ARRAY];   // for KERB_AP_REPLY and KERB_PRIV or KERB_ERROR
} KERB_KPASSWD_REP, *PKERB_KPASSWD_REP;


//
// Type for a set password request
//

typedef struct _KERB_SET_PASSWORD_REQ {
    BYTE MessageLength[2];
    BYTE Version[2];
    BYTE ApReqLength[2];
    BYTE Data[ANYSIZE_ARRAY];   // for KERB_AP_REQUEST-REQ and KERB_PRIV
} KERB_SET_PASSWORD_REQ, *PKERB_SET_PASSWORD_REQ;

//
// type for a set password reply
//

typedef struct _KERB_SET_PASSWORD_REP {
    BYTE MessageLength[2];
    BYTE Version[2];
    BYTE ApRepLength[2];
    BYTE Data[ANYSIZE_ARRAY];   // for KERB_AP_REPLY and KERB_PRIV or KERB_ERROR
} KERB_SET_PASSWORD_REP, *PKERB_SET_PASSWORD_REP;
#include <poppack.h>

//
// Result codes:
//

#define KERB_KPASSWD_SUCCESS            0x0000
#define KERB_KPASSWD_MALFORMED          0x0001
#define KERB_KPASSWD_ERROR              0x0002
#define KERB_KPASSWD_AUTHENTICATION     0x0003
#define KERB_KPASSWD_POLICY             0x0004
#define KERB_KPASSWD_AUTHORIZATION      0x0005
#endif // __KERBLIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\inc\kerberr.h ===
//+-----------------------------------------------------------------------
//
// File:        kerberr.h
//
// Contents:    Security Status codes
//
// History:     <Whenever>  RichardW    Created secscode.h
//              26-May-93   RichardW    fixed dependency & conflict with scode.h
//              02-Jun-93   WadeR   Added FAILED and SUCCEDED macros
//              14-Jun-93   WadeR   Added "proper" kerberos errors, changed
//                                  to hex.
//              07-Jul-93   WadeR   Removed FAILED and SUCCEEDED macros
//              20-Sep-93   WadeR   Moved to $(SECURITY)\h\kerberr.h
//
//------------------------------------------------------------------------

#ifndef __KERBERR_H__
#define __KERBERR_H__




// Component specific errors:

//
// KERBERR is a kerberos-specific error. Make it a pointer to a structure
// to make sure we only return the correct error.
//

typedef LONG KERBERR, *PKERBERR;

#define KERB_SUCCESS(_kerberr_) ((KERBERR)(_kerberr_) == KDC_ERR_NONE)

// These are the error codes as defined by the Kerberos V5 R5.2
// spec, section 8.3


#define KDC_ERR_NONE                  ((KERBERR) 0x0 ) // 0 No error
#define KDC_ERR_NAME_EXP              ((KERBERR) 0x1 ) // 1 Client's entry in database has expired
#define KDC_ERR_SERVICE_EXP           ((KERBERR) 0x2 ) // 2 Server's entry in database has expired
#define KDC_ERR_BAD_PVNO              ((KERBERR) 0x3 ) // 3 Requested protocol version number not supported
#define KDC_ERR_C_OLD_MAST_KVNO       ((KERBERR) 0x4 ) // 4 Client's key encrypted in old master key
#define KDC_ERR_S_OLD_MAST_KVNO       ((KERBERR) 0x5 ) // 5 Server's key encrypted in old master key
#define KDC_ERR_C_PRINCIPAL_UNKNOWN   ((KERBERR) 0x6 ) // 6 Client not found in Kerberos database
#define KDC_ERR_S_PRINCIPAL_UNKNOWN   ((KERBERR) 0x7 ) // 7 Server not found in Kerberos database
#define KDC_ERR_PRINCIPAL_NOT_UNIQUE  ((KERBERR) 0x8 ) // 8 Multiple principal entries in database
#define KDC_ERR_NULL_KEY              ((KERBERR) 0x9 ) // 9 The client or server has a null key
#define KDC_ERR_CANNOT_POSTDATE       ((KERBERR) 0xA ) // 10 Ticket not eligible for postdating
#define KDC_ERR_NEVER_VALID           ((KERBERR) 0xB ) // 11 Requested start time is later than end time
#define KDC_ERR_POLICY                ((KERBERR) 0xC ) // 12 KDC policy rejects request
#define KDC_ERR_BADOPTION             ((KERBERR) 0xD ) // 13 KDC cannot accommodate requested option
#define KDC_ERR_ETYPE_NOTSUPP         ((KERBERR) 0xE ) // 14 KDC has no support for encryption type
#define KDC_ERR_SUMTYPE_NOSUPP        ((KERBERR) 0xF ) // 15 KDC has no support for checksum type
#define KDC_ERR_PADATA_TYPE_NOSUPP    ((KERBERR) 0x10 ) // 16 KDC has no support for padata type
#define KDC_ERR_TRTYPE_NO_SUPP        ((KERBERR) 0x11 ) // 17 KDC has no support for transited type
#define KDC_ERR_CLIENT_REVOKED        ((KERBERR) 0x12 ) // 18 Clients credentials have been revoked
#define KDC_ERR_SERVICE_REVOKED       ((KERBERR) 0x13 ) // 19 Credentials for server have been revoked
#define KDC_ERR_TGT_REVOKED           ((KERBERR) 0x14 ) // 20 TGT has been revoked
#define KDC_ERR_CLIENT_NOTYET         ((KERBERR) 0x15 ) // 21 Client not yet valid - try again later
#define KDC_ERR_SERVICE_NOTYET        ((KERBERR) 0x16 ) // 22 Server not yet valid - try again later
#define KDC_ERR_KEY_EXPIRED           ((KERBERR) 0x17 ) // 23 Password has expired - change password to reset
#define KDC_ERR_PREAUTH_FAILED        ((KERBERR) 0x18 ) // 24 Pre-authentication information was invalid
#define KDC_ERR_PREAUTH_REQUIRED      ((KERBERR) 0x19 ) // 25 Additional pre-authenticationrequired [40]
#define KDC_ERR_SERVER_NOMATCH        ((KERBERR) 0x1A ) // 26 Requested server and ticket don't match
#define KDC_ERR_MUST_USE_USER2USER    ((KERBERR) 0x1B ) // 27 Server principal valid for user2user only
#define KDC_ERR_PATH_NOT_ACCEPTED     ((KERBERR) 0x1C ) // 28 KDC Policy rejects transited path
#define KDC_ERR_SVC_UNAVAILABLE       ((KERBERR) 0x1D ) // 29 A service is not available
#define KRB_AP_ERR_BAD_INTEGRITY      ((KERBERR) 0x1F ) // 31 Integrity check on decrypted field failed
#define KRB_AP_ERR_TKT_EXPIRED        ((KERBERR) 0x20 ) // 32 Ticket expired
#define KRB_AP_ERR_TKT_NYV            ((KERBERR) 0x21 ) // 33 Ticket not yet valid
#define KRB_AP_ERR_REPEAT             ((KERBERR) 0x22 ) // 34 Request is a replay
#define KRB_AP_ERR_NOT_US             ((KERBERR) 0x23 ) // 35 The ticket isn't for us
#define KRB_AP_ERR_BADMATCH           ((KERBERR) 0x24 ) // 36 Ticket and authenticator don't match
#define KRB_AP_ERR_SKEW               ((KERBERR) 0x25 ) // 37 Clock skew too great
#define KRB_AP_ERR_BADADDR            ((KERBERR) 0x26 ) // 38 Incorrect net address
#define KRB_AP_ERR_BADVERSION         ((KERBERR) 0x27 ) // 39 Protocol version mismatch
#define KRB_AP_ERR_MSG_TYPE           ((KERBERR) 0x28 ) // 40 Invalid msg type
#define KRB_AP_ERR_MODIFIED           ((KERBERR) 0x29 ) // 41 Message stream modified
#define KRB_AP_ERR_BADORDER           ((KERBERR) 0x2A ) // 42 Message out of order
#define KRB_AP_ERR_ILL_CR_TKT         ((KERBERR) 0x2B ) // 43 Illegal cross realm ticket
#define KRB_AP_ERR_BADKEYVER          ((KERBERR) 0x2C ) // 44 Specified version of key is not available
#define KRB_AP_ERR_NOKEY              ((KERBERR) 0x2D ) // 45 Service key not available
#define KRB_AP_ERR_MUT_FAIL           ((KERBERR) 0x2E ) // 46 Mutual authentication failed
#define KRB_AP_ERR_BADDIRECTION       ((KERBERR) 0x2F ) // 47 Incorrect message direction
#define KRB_AP_ERR_METHOD             ((KERBERR) 0x30 ) // 48 Alternative authentication method required
#define KRB_AP_ERR_BADSEQ             ((KERBERR) 0x31 ) // 49 Incorrect sequence number in message
#define KRB_AP_ERR_INAPP_CKSUM        ((KERBERR) 0x32 ) // 50 Inappropriate type of checksum in message
#define KRB_AP_PATH_NOT_ACCEPTED      ((KERBERR) 0x33 ) // 51 Policy rejects transited path
#define KRB_ERR_RESPONSE_TOO_BIG      ((KERBERR) 0x34 ) // 52 Response too big for UDP, retry with TCP
#define KRB_ERR_GENERIC               ((KERBERR) 0x3C ) // 60 Generic error (description in e-text)
#define KRB_ERR_FIELD_TOOLONG         ((KERBERR) 0x3D ) // 61 Field is too long for this implementation
#define KDC_ERR_CLIENT_NOT_TRUSTED    ((KERBERR) 0x3E ) // 62 (pkinit)
#define KDC_ERR_KDC_NOT_TRUSTED       ((KERBERR) 0x3F ) // 63 (pkinit)
#define KDC_ERR_INVALID_SIG           ((KERBERR) 0x40 ) // 64 (pkinit)
#define KDC_ERR_KEY_TOO_WEAK          ((KERBERR) 0x41 ) // 65 (pkinit)
#define KDC_ERR_CERTIFICATE_MISMATCH  ((KERBERR) 0x42 ) // 66 (pkinit)
#define KRB_AP_ERR_NO_TGT             ((KERBERR) 0x43 ) // 67 (user-to-user)
#define KDC_ERR_WRONG_REALM           ((KERBERR) 0x44 ) // 68 (user-to-user)
#define KRB_AP_ERR_USER_TO_USER_REQUIRED ((KERBERR) 0x45 ) // 69 (user-to-user)
#define KDC_ERR_CANT_VERIFY_CERTIFICATE ((KERBERR) 0x46 ) // 70 (pkinit)
#define KDC_ERR_INVALID_CERTIFICATE     ((KERBERR) 0x47 ) // 71 (pkinit)
#define KDC_ERR_REVOKED_CERTIFICATE     ((KERBERR) 0x48 ) // 72 (pkinit)
#define KDC_ERR_REVOCATION_STATUS_UNKNOWN ((KERBERR) 0x49 ) // 73 (pkinit)
#define KDC_ERR_REVOCATION_STATUS_UNAVAILABLE ((KERBERR) 0x4a ) // 74 (pkinit)
#define KDC_ERR_CLIENT_NAME_MISMATCH    ((KERBERR) 0x4b ) // 75 (pkinit)
#define KDC_ERR_KDC_NAME_MISMATCH       ((KERBERR) 0x4c ) // 76 (pkinit)
#define KDC_ERR_PASSPORT_PUID_MISMATCH  ((KERBERR) 0x4d ) // 77 ASKDC - RPS Ticket Puid doesn't belong to Principal 

//
// These are local definitions that should not be sent over the network
//

#define KDC_ERR_MORE_DATA             ((KERBERR) 0x80000001 )
#define KDC_ERR_NOT_RUNNING           ((KERBERR) 0x80000002 )
#define KDC_ERR_NO_RESPONSE           ((KERBERR) 0x80000003 ) // used when we don't get a certain level of "goodness" in our response.

#endif // __KERBERR_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\inc\krb5p.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        krb5p.h
//
// Contents:    pointer type definitions for ASN.1 stub types
//
//
// History:     8-May-1996      Created         MikeSw
//
//------------------------------------------------------------------------

#ifndef __KERB5P_H__
#define __KERB5P_H__

typedef KERB_HOST_ADDRESS *PKERB_HOST_ADDRESS;
typedef KERB_PRINCIPAL_NAME *PKERB_PRINCIPAL_NAME;
typedef KERB_REALM *PKERB_REALM;
typedef KERB_TIME *PKERB_TIME;
typedef KERB_ENCRYPTED_DATA *PKERB_ENCRYPTED_DATA;
typedef KERB_TICKET *PKERB_TICKET;
typedef KERB_TRANSITED_ENCODING *PKERB_TRANSITED_ENCODING;
typedef KERB_ENCRYPTION_KEY *PKERB_ENCRYPTION_KEY;
typedef KERB_ENCRYPTED_TICKET *PKERB_ENCRYPTED_TICKET;
typedef KERB_CHECKSUM *PKERB_CHECKSUM;
typedef KERB_AUTHENTICATOR *PKERB_AUTHENTICATOR;
typedef KERB_PA_DATA *PKERB_PA_DATA;
typedef KERB_KDC_REQUEST_BODY *PKERB_KDC_REQUEST_BODY;
typedef KERB_KDC_REQUEST *PKERB_KDC_REQUEST;
typedef KERB_AS_REQUEST *PKERB_AS_REQUEST;
typedef KERB_TGS_REQUEST *PKERB_TGS_REQUEST;
typedef KERB_KDC_REPLY *PKERB_KDC_REPLY;
typedef KERB_AS_REPLY *PKERB_AS_REPLY;
typedef KERB_TGS_REPLY *PKERB_TGS_REPLY;
typedef KERB_ENCRYPTED_KDC_REPLY *PKERB_ENCRYPTED_KDC_REPLY;
typedef KERB_ENCRYPTED_AS_REPLY *PKERB_ENCRYPTED_AS_REPLY;
typedef KERB_ENCRYPTED_TGS_REPLY *PKERB_ENCRYPTED_TGS_REPLY;
typedef KERB_AP_OPTIONS *PKERB_AP_OPTIONS;
typedef KERB_AP_REQUEST *PKERB_AP_REQUEST;
typedef KERB_AP_REPLY *PKERB_AP_REPLY;
typedef KERB_ENCRYPTED_AP_REPLY *PKERB_ENCRYPTED_AP_REPLY;
typedef KERB_SAFE_BODY *PKERB_SAFE_BODY;
typedef KERB_SAFE_MESSAGE *PKERB_SAFE_MESSAGE;
typedef KERB_PRIV_MESSAGE *PKERB_PRIV_MESSAGE;
typedef KERB_ENCRYPTED_PRIV *PKERB_ENCRYPTED_PRIV;
typedef KERB_ERROR *PKERB_ERROR;
typedef KERB_EXT_ERROR *PKERB_EXT_ERROR;
typedef KERB_ERROR_METHOD_DATA *PKERB_ERROR_METHOD_DATA;
typedef struct PKERB_AUTHORIZATION_DATA_s KERB_AUTHORIZATION_DATA;
typedef struct PKERB_TICKET_EXTENSIONS_s KERB_TICKET_EXTENSIONS;
typedef KERB_CRED *PKERB_CRED;
typedef KERB_ENCRYPTED_CRED *PKERB_ENCRYPTED_CRED;
typedef KERB_CRED_INFO *PKERB_CRED_INFO;
typedef struct PKERB_LAST_REQUEST_s KERB_LAST_REQUEST;
typedef struct PKERB_HOST_ADDRESSES_s KERB_HOST_ADDRESSES;
typedef struct PKERB_ETYPE_INFO_s KERB_ETYPE_INFO;
typedef KERB_ETYPE_INFO_ENTRY * PKERB_ETYPE_INFO_ENTRY;
typedef KERB_ENCRYPTED_TIMESTAMP *PKERB_ENCRYPTED_TIMESTAMP;
typedef struct PKERB_PREAUTH_DATA_LIST_s KERB_PREAUTH_DATA_LIST, *PKERB_PREAUTH_DATA_LIST;
typedef KERB_TICKET_FLAGS *PKERB_TICKET_FLAGS;
typedef KERB_PA_PAC_REQUEST *PKERB_PA_PAC_REQUEST;
typedef KERB_PA_PAC_REQUEST_EX *PKERB_PA_PAC_REQUEST_EX;
typedef KERB_PA_FOR_USER *PKERB_PA_FOR_USER;

#ifndef MIDL_PASS

typedef struct KERB_PRINCIPAL_NAME_name_string_s KERB_PRINCIPAL_NAME_ELEM, *PKERB_PRINCIPAL_NAME_ELEM;
typedef struct KERB_KDC_REQUEST_BODY_encryption_type_s KERB_CRYPT_LIST, *PKERB_CRYPT_LIST;
typedef struct KERB_KDC_REQUEST_BODY_additional_tickets_s KERB_TICKET_LIST, *PKERB_TICKET_LIST;
typedef struct KERB_KDC_REQUEST_preauth_data_s KERB_PA_DATA_LIST, *PKERB_PA_DATA_LIST;
typedef struct KERB_KDC_REPLY_preauth_data_s KERB_REPLY_PA_DATA_LIST, *PKERB_REPLY_PA_DATA_LIST;
typedef struct KERB_CRED_tickets_s KERB_CRED_TICKET_LIST, *PKERB_CRED_TICKET_LIST;
typedef struct KERB_ENCRYPTED_CRED_ticket_info_s KERB_CRED_INFO_LIST, *PKERB_CRED_INFO_LIST;
typedef struct KERB_PA_PK_AS_REQ2_user_certs_s KERB_CERTIFICATE_LIST, *PKERB_CERTIFICATE_LIST;
typedef struct KERB_PA_PK_AS_REQ2_trusted_certifiers_s KERB_CERTIFIER_LIST, *PKERB_CERTIFIER_LIST;
typedef struct KERB_KDC_ISSUED_AUTH_DATA_elements_s KERB_KDC_AUTH_DATA_LIST, *PKERB_KDC_AUTH_DATA_LIST;

#endif // MIDL_PASS

typedef KERB_KDC_ISSUED_AUTH_DATA *PKERB_KDC_ISSUED_AUTH_DATA;
typedef struct PKERB_IF_RELEVANT_AUTH_DATA_ KERB_IF_RELEVANT_AUTH_DATA;
typedef KERB_DH_PARAMTER *PKERB_DH_PARAMTER;
typedef KERB_PA_PK_AS_REQ *PKERB_PA_PK_AS_REQ;
typedef KERB_PA_PK_AS_REQ2 *PKERB_PA_PK_AS_REQ2;
typedef KERB_SIGNED_AUTH_PACKAGE *PKERB_SIGNED_AUTH_PACKAGE;
typedef KERB_AUTH_PACKAGE *PKERB_AUTH_PACKAGE;
typedef KERB_PK_AUTHENTICATOR *PKERB_PK_AUTHENTICATOR;
typedef KERB_SIGNED_REPLY_KEY_PACKAGE *PKERB_SIGNED_REPLY_KEY_PACKAGE;
typedef struct ASN1objectidentifier_s KERB_OBJECT_ID, *PKERB_OBJECT_ID;
typedef KERB_REPLY_KEY_PACKAGE *PKERB_REPLY_KEY_PACKAGE;
typedef KERB_PA_PK_AS_REP *PKERB_PA_PK_AS_REP;
typedef KERB_PA_PK_AS_REP2 *PKERB_PA_PK_AS_REP2;
typedef KERB_CERTIFICATE *PKERB_CERTIFICATE;
typedef KERB_SIGNED_KDC_PUBLIC_VALUE *PKERB_SIGNED_KDC_PUBLIC_VALUE;
typedef KERB_SUBJECT_PUBLIC_KEY_INFO *PKERB_SUBJECT_PUBLIC_KEY_INFO;
typedef KERB_ALGORITHM_IDENTIFIER *PKERB_ALGORITHM_IDENTIFIER;
typedef KERB_SIGNATURE *PKERB_SIGNATURE;
typedef KERB_TGT_REPLY *PKERB_TGT_REPLY;
typedef KERB_TGT_REQUEST *PKERB_TGT_REQUEST;
typedef KERB_PA_SERV_REFERRAL *PKERB_PA_SERV_REFERRAL;
typedef KERB_CHANGE_PASSWORD_DATA *PKERB_CHANGE_PASSWORD_DATA;
#define                     KERB_KDC_OPTIONS_reserved 0x80000000
#define                     KERB_KDC_OPTIONS_forwardable 0x40000000
#define                     KERB_KDC_OPTIONS_forwarded 0x20000000
#define                     KERB_KDC_OPTIONS_proxiable 0x10000000
#define                     KERB_KDC_OPTIONS_proxy 0x08000000
#define                     KERB_KDC_OPTIONS_postdated 0x02000000
#define                     KERB_KDC_OPTIONS_allow_postdate 0x04000000
#define                     KERB_KDC_OPTIONS_unused7 0x01000000
#define                     KERB_KDC_OPTIONS_renewable 0x00800000
#define                     KERB_KDC_OPTIONS_unused9 0x00400000
#define                     KERB_KDC_OPTIONS_name_canonicalize 0x00010000
#define                     KERB_KDC_OPTIONS_cname_in_addl_tkt 0x00020000
#define                     KERB_KDC_OPTIONS_cname_in_pa_data  0x00040000
#define                     KERB_KDC_OPTIONS_renewable_ok 0x00000010
#define                     KERB_KDC_OPTIONS_enc_tkt_in_skey 0x00000008
#define                     KERB_KDC_OPTIONS_renew 0x00000002
#define                     KERB_KDC_OPTIONS_validate 0x00000001


#define                     KERB_AP_OPTIONS_reserved 0x80000000
#define                     KERB_AP_OPTIONS_use_session_key 0x40000000
#define                     KERB_AP_OPTIONS_mutual_required 0x20000000
#define                     KERB_AP_OPTIONS_reserved1 0x00000001

//
// these #define's are done for the conversion from the old oss compiler to the
// new telis compiler.
//
#define KERB_AUTHENTICATOR_sequence_number                      sequence_number
#define KERB_ENCRYPTED_TICKET_client_addresses          client_addresses
#define KERB_ENCRYPTED_TICKET_renew_until                       renew_until
#define KERB_CRED_INFO_renew_until                                      renew_until
#define KERB_KDC_REQUEST_BODY_renew_until                       renew_until
#define KERB_KDC_REQUEST_BODY_server_name                       server_name
#define KERB_KDC_REQUEST_preauth_data                           preauth_data
#define KERB_AUTHENTICATOR_sequence_number                      sequence_number
#define KERB_ENCRYPTED_AP_REPLY_sequence_number         sequence_number
#define KERB_AUTHENTICATOR_subkey                                       subkey
#define KERB_ENCRYPTED_AP_REPLY_subkey                          subkey
#define KERB_TGT_REQUEST_server_name                            server_name
#define KERB_ERROR_client_name                                          client_name
#define KERB_ENCRYPTED_TIMESTAMP_usec                           usec
#define KERB_KDC_REQUEST_BODY_client_name                       client_name
#define KERB_KDC_REPLY_preauth_data                                     preauth_data
#define KERB_ENCRYPTED_TIMESTAMP_usec                           usec
#define KERB_ENCRYPTED_KDC_REPLY_starttime                      starttime
#define KERB_CRED_INFO_starttime                                        starttime
#define KERB_ENCRYPTED_KDC_REPLY_renew_until            renew_until
#define KERB_ENCRYPTED_TICKET_authorization_data        authorization_data
#define KERB_ENCRYPTED_TICKET_starttime                         starttime
#define KERB_ENCRYPTED_PRIV_sequence_number                     sequence_number
#define KERB_KDC_REQUEST_BODY_starttime                         starttime
#define KERB_ENCRYPTED_KDC_REPLY_client_addresses       client_addresses


#endif // __KERB5P_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\inc\kerbnames.h ===
#ifndef _KERBNAMES_H_
#define _KERBNAMES_H_

//
// This is the maximum number of elements in a KERB_INTERNAL_NAME
//

#ifndef _KERB_INTERNAL_NAME_
#define _KERB_INTERNAL_NAME_

#define MAX_NAME_ELEMENTS 20

typedef struct _KERB_INTERNAL_NAME {
    SHORT NameType;
    USHORT NameCount;
    UNICODE_STRING Names[ANYSIZE_ARRAY];
} KERB_INTERNAL_NAME, *PKERB_INTERNAL_NAME;
#endif

#ifndef _KERB_ACCOUNT_TYPE_DEFINED_
#define _KERB_ACCOUNT_TYPE_DEFINED_
typedef enum _KERB_ACCOUNT_TYPE {
    UserAccount,
    MachineAccount,
    DomainTrustAccount,
    UnknownAccount
} KERB_ACCOUNT_TYPE, *PKERB_ACCOUNT_TYPE;
#endif

#ifdef __cplusplus
extern "C"
{

#endif // __cplusplus

KERBERR
KerbConvertStringToPrincipalName(
    OUT PKERB_PRINCIPAL_NAME PrincipalName,
    IN const UNICODE_STRING * String,
    IN ULONG NameType
    );

KERBERR
KerbDuplicatePrincipalName(
    OUT PKERB_PRINCIPAL_NAME PrincipalName,
    IN const KERB_PRINCIPAL_NAME * SourcePrincipalName
    );

KERBERR
KerbConvertPrincipalNameToString(
    OUT PUNICODE_STRING String,
    OUT PULONG NameType,
    IN const KERB_PRINCIPAL_NAME * PrincipalName
    );

KERBERR
KerbConvertPrincipalNameToFullServiceString(
    OUT PUNICODE_STRING String,
    IN const KERB_PRINCIPAL_NAME * PrincipalName,
    IN KERB_REALM RealmName
    );

BOOLEAN
KerbComparePrincipalNames(
    IN const KERB_PRINCIPAL_NAME * Name1,
    IN const KERB_PRINCIPAL_NAME * Name2
    );

KERBERR
KerbConvertUnicodeStringToRealm(
    OUT PKERB_REALM Realm,
    IN const UNICODE_STRING * String
    );

KERBERR
KerbConvertRealmToUnicodeString(
    OUT PUNICODE_STRING String,
    IN const KERB_REALM * Realm
    );

KERBERR
KerbDuplicateRealm(
    OUT PKERB_REALM Realm,
    IN KERB_REALM SourceRealm
    );

BOOLEAN
KerbCompareRealmNames(
    IN const KERB_REALM * Realm1,
    IN const KERB_REALM * Realm2
    );

BOOLEAN
KerbCompareUnicodeRealmNames(
    IN const UNICODE_STRING * Domain1,
    IN const UNICODE_STRING * Domain2
    );

BOOLEAN
KerbCompareStringToPrincipalName(
    IN const KERB_PRINCIPAL_NAME * PrincipalName,
    IN const UNICODE_STRING * String
    );

KERBERR
KerbBuildFullServiceName(
    IN const UNICODE_STRING * DomainName,
    IN const UNICODE_STRING * ServiceName,
    OUT PUNICODE_STRING FullServiceName
    );

KERBERR
KerbBuildUnicodeSpn(
    IN const UNICODE_STRING * DomainName,
    IN const UNICODE_STRING * ServiceName,
    OUT PUNICODE_STRING UnicodeSpn
    );

KERBERR
KerbBuildEmailName(
    IN const UNICODE_STRING * DomainName,
    IN const UNICODE_STRING * ServiceName,
    OUT PUNICODE_STRING EmailName
    );

KERBERR
KerbBuildFullServiceKdcName(
    IN const UNICODE_STRING * DomainName,
    IN const UNICODE_STRING * ServiceName,
    IN ULONG NameType,
    OUT PKERB_INTERNAL_NAME * FullServiceName
    );

KERBERR
KerbBuildAltSecId(
    OUT PUNICODE_STRING AlternateName,
    IN const KERB_INTERNAL_NAME * PrincipalName,
    IN OPTIONAL const KERB_REALM * Realm,
    IN OPTIONAL const UNICODE_STRING * UnicodeRealm
    );
    
KERBERR
__stdcall
KerbBuildKeySalt(
    IN const UNICODE_STRING * DomainName,
    IN const UNICODE_STRING * ServiceName,
    IN KERB_ACCOUNT_TYPE AccountType,
    OUT PUNICODE_STRING KeySalt
    );

KERBERR
KerbBuildKeySaltFromUpn(
    IN const UNICODE_STRING * Upn,
    OUT PUNICODE_STRING Salt
    );

///CCC
KERBERR
__stdcall
KerbUnicodeStringToKerbString(
    OUT PSTRING KerbString,
    IN const UNICODE_STRING * String
    );

KERBERR
KerbStringToUnicodeString(
    OUT PUNICODE_STRING String,
    IN const STRING * KerbString
    );

BOOLEAN
KerbMbStringToUnicodeString(
      PUNICODE_STRING     pDest,
      char *              pszString
      );
      
VOID
KerbFreeKdcName(
    IN PKERB_INTERNAL_NAME * KdcName
    );

KERBERR
KerbConvertPrincipalNameToKdcName(
    OUT PKERB_INTERNAL_NAME * OutputName,
    IN const KERB_PRINCIPAL_NAME * PrincipalName
    );

KERBERR
KerbConvertKdcNameToPrincipalName(
    OUT PKERB_PRINCIPAL_NAME PrincipalName,
    IN const KERB_INTERNAL_NAME * KdcName
    );

BOOLEAN
KerbEqualKdcNames(
    IN const KERB_INTERNAL_NAME * Name1,
    IN const KERB_INTERNAL_NAME * Name2
    );

KERBERR
KerbCompareKdcNameToPrincipalName(
    IN const KERB_PRINCIPAL_NAME * PrincipalName,
    IN const KERB_INTERNAL_NAME * KdcName,
    OUT PBOOLEAN Result
    );

VOID
KerbPrintKdcNameEx(
    IN ULONG DebugLevel,
    IN ULONG InfoLevel,
    IN const KERB_INTERNAL_NAME * Name
    );

#define KERB_INTERNAL_NAME_SIZE(NameCount) (sizeof(KERB_INTERNAL_NAME) + ((NameCount) - ANYSIZE_ARRAY) * sizeof(UNICODE_STRING))

KERBERR
KerbConvertStringToKdcName(
    OUT PKERB_INTERNAL_NAME * PrincipalName,
    IN const UNICODE_STRING * String
    );

NTSTATUS
KerbBuildKpasswdName(
    OUT PKERB_INTERNAL_NAME * KpasswdName
    );

KERBERR
KerbConvertKdcNameToString(
    OUT PUNICODE_STRING String,
    IN const KERB_INTERNAL_NAME * PrincipalName,
    IN const UNICODE_STRING * Realm
    );

NTSTATUS
__stdcall
KerbDuplicateKdcName(
    OUT PKERB_INTERNAL_NAME * Destination,
    IN const KERB_INTERNAL_NAME * Source
    );

NTSTATUS
KerbDuplicateStringEx(
    OUT PUNICODE_STRING DestinationString,
    IN OPTIONAL const UNICODE_STRING * SourceString,
    IN BOOLEAN NullTerminate
    );

VOID
__stdcall
KerbFreeString(
    IN OPTIONAL PUNICODE_STRING String
    );

VOID
KerbFreeRealm(
    IN PKERB_REALM Realm
    );

VOID
KerbFreePrincipalName(
    IN PKERB_PRINCIPAL_NAME Name
    );

NTSTATUS
__stdcall
KerbConvertSidToString(
    IN PSID Sid,
    OUT PUNICODE_STRING String,
    IN BOOLEAN AllocateDestination
    );
#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\inc\krb5.h ===
#ifndef _KRB5_Module_H_
#define _KRB5_Module_H_

#include "msber.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef struct KERB_PA_PAC_REQUEST_EX_pac_sections_s * PKERB_PA_PAC_REQUEST_EX_pac_sections;

typedef struct KERB_KDC_REQUEST_BODY_encryption_type_s * PKERB_KDC_REQUEST_BODY_encryption_type;

typedef struct KERB_PRINCIPAL_NAME_name_string_s * PKERB_PRINCIPAL_NAME_name_string;

typedef struct PKERB_HOST_ADDRESSES_s * PPKERB_HOST_ADDRESSES;

typedef struct PKERB_AUTHORIZATION_DATA_s * PPKERB_AUTHORIZATION_DATA;

typedef struct PKERB_LAST_REQUEST_s * PPKERB_LAST_REQUEST;

typedef struct PKERB_TICKET_EXTENSIONS_s * PPKERB_TICKET_EXTENSIONS;

typedef struct PKERB_PREAUTH_DATA_LIST_s * PPKERB_PREAUTH_DATA_LIST;

typedef struct PKERB_ETYPE_INFO_s * PPKERB_ETYPE_INFO;

typedef struct KERB_KDC_ISSUED_AUTH_DATA_elements_s * PKERB_KDC_ISSUED_AUTH_DATA_elements;

typedef struct KERB_PA_PK_AS_REQ2_trusted_certifiers_s * PKERB_PA_PK_AS_REQ2_trusted_certifiers;

typedef struct KERB_PA_PK_AS_REQ2_user_certs_s * PKERB_PA_PK_AS_REQ2_user_certs;

typedef struct KERB_PA_PK_AS_REP2_kdc_cert_s * PKERB_PA_PK_AS_REP2_kdc_cert;

typedef struct KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data_s * PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data;

typedef struct KERB_KDC_REPLY_preauth_data_s * PKERB_KDC_REPLY_preauth_data;

typedef struct KERB_KDC_REQUEST_preauth_data_s * PKERB_KDC_REQUEST_preauth_data;

typedef struct KERB_PA_COMPOUND_IDENTITY_s * PKERB_PA_COMPOUND_IDENTITY;

typedef struct KERB_PA_PK_AS_REQ_trusted_certifiers_s * PKERB_PA_PK_AS_REQ_trusted_certifiers;

typedef struct KERB_ENCRYPTED_CRED_ticket_info_s * PKERB_ENCRYPTED_CRED_ticket_info;

typedef struct KERB_CRED_tickets_s * PKERB_CRED_tickets;

typedef struct KERB_KDC_REQUEST_BODY_additional_tickets_s * PKERB_KDC_REQUEST_BODY_additional_tickets;

typedef ASN1ztcharstring_t KERB_PRINCIPAL_NAME_name_string_Seq;

typedef ASN1int32_t KERB_KDC_REQUEST_BODY_encryption_type_Seq;

typedef ASN1int32_t KERB_PA_PAC_REQUEST_EX_pac_sections_Seq;

typedef ASN1ztcharstring_t KERB_REALM;

typedef PPKERB_AUTHORIZATION_DATA PKERB_AUTHORIZATION_DATA_LIST;
#define PKERB_AUTHORIZATION_DATA_LIST_PDU 0
#define SIZE_KRB5_Module_PDU_0 sizeof(PKERB_AUTHORIZATION_DATA_LIST)

typedef ASN1bitstring_t KERB_KDC_OPTIONS;

typedef ASN1generalizedtime_t KERB_TIME;

typedef ASN1intx_t KERB_SEQUENCE_NUMBER_LARGE;

typedef ASN1uint32_t KERB_SEQUENCE_NUMBER;

typedef ASN1bitstring_t KERB_TICKET_FLAGS;

typedef ASN1bitstring_t KERB_AP_OPTIONS;

typedef ASN1open_t NOCOPYANY;

typedef ASN1int32_t KERB_CERTIFICATE_SERIAL_NUMBER;

typedef PPKERB_AUTHORIZATION_DATA PKERB_IF_RELEVANT_AUTH_DATA;
#define PKERB_IF_RELEVANT_AUTH_DATA_PDU 1
#define SIZE_KRB5_Module_PDU_1 sizeof(PKERB_IF_RELEVANT_AUTH_DATA)

typedef struct KERB_PA_PAC_REQUEST_EX_pac_sections_s {
    PKERB_PA_PAC_REQUEST_EX_pac_sections next;
    KERB_PA_PAC_REQUEST_EX_pac_sections_Seq value;
} KERB_PA_PAC_REQUEST_EX_pac_sections_Element, *KERB_PA_PAC_REQUEST_EX_pac_sections;

typedef struct KERB_KDC_REQUEST_BODY_encryption_type_s {
    PKERB_KDC_REQUEST_BODY_encryption_type next;
    KERB_KDC_REQUEST_BODY_encryption_type_Seq value;
} KERB_KDC_REQUEST_BODY_encryption_type_Element, *KERB_KDC_REQUEST_BODY_encryption_type;

typedef struct PKERB_TICKET_EXTENSIONS_Seq {
    ASN1int32_t te_type;
    ASN1octetstring_t te_data;
} PKERB_TICKET_EXTENSIONS_Seq;

typedef struct KERB_PRINCIPAL_NAME_name_string_s {
    PKERB_PRINCIPAL_NAME_name_string next;
    KERB_PRINCIPAL_NAME_name_string_Seq value;
} KERB_PRINCIPAL_NAME_name_string_Element, *KERB_PRINCIPAL_NAME_name_string;

typedef struct PKERB_LAST_REQUEST_Seq {
    ASN1int32_t last_request_type;
    KERB_TIME last_request_value;
} PKERB_LAST_REQUEST_Seq;

typedef struct PKERB_AUTHORIZATION_DATA_Seq {
    ASN1int32_t auth_data_type;
    ASN1octetstring_t auth_data;
} PKERB_AUTHORIZATION_DATA_Seq;

typedef struct PKERB_HOST_ADDRESSES_Seq {
    ASN1int32_t address_type;
    ASN1octetstring_t address;
} PKERB_HOST_ADDRESSES_Seq;

typedef struct KERB_HOST_ADDRESS {
    ASN1int32_t addr_type;
    ASN1octetstring_t address;
} KERB_HOST_ADDRESS;

typedef struct PKERB_HOST_ADDRESSES_s {
    PPKERB_HOST_ADDRESSES next;
    PKERB_HOST_ADDRESSES_Seq value;
} PKERB_HOST_ADDRESSES_Element, *PKERB_HOST_ADDRESSES;

typedef struct PKERB_AUTHORIZATION_DATA_s {
    PPKERB_AUTHORIZATION_DATA next;
    PKERB_AUTHORIZATION_DATA_Seq value;
} PKERB_AUTHORIZATION_DATA_Element, *PKERB_AUTHORIZATION_DATA;

typedef struct PKERB_LAST_REQUEST_s {
    PPKERB_LAST_REQUEST next;
    PKERB_LAST_REQUEST_Seq value;
} PKERB_LAST_REQUEST_Element, *PKERB_LAST_REQUEST;

typedef struct KERB_PRINCIPAL_NAME {
    ASN1int32_t name_type;
    PKERB_PRINCIPAL_NAME_name_string name_string;
} KERB_PRINCIPAL_NAME;

typedef struct PKERB_TICKET_EXTENSIONS_s {
    PPKERB_TICKET_EXTENSIONS next;
    PKERB_TICKET_EXTENSIONS_Seq value;
} PKERB_TICKET_EXTENSIONS_Element, *PKERB_TICKET_EXTENSIONS;

typedef struct KERB_TRANSITED_ENCODING {
    ASN1int32_t transited_type;
    ASN1octetstring_t contents;
} KERB_TRANSITED_ENCODING;

typedef struct KERB_PA_DATA {
    ASN1int32_t preauth_data_type;
    ASN1octetstring_t preauth_data;
} KERB_PA_DATA;

typedef struct PKERB_PREAUTH_DATA_LIST_s {
    PPKERB_PREAUTH_DATA_LIST next;
    KERB_PA_DATA value;
} PKERB_PREAUTH_DATA_LIST_Element, *PKERB_PREAUTH_DATA_LIST;
#define PKERB_PREAUTH_DATA_LIST_PDU 2
#define SIZE_KRB5_Module_PDU_2 sizeof(PKERB_PREAUTH_DATA_LIST_Element)

typedef struct KERB_SAFE_BODY {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1octetstring_t user_data;
#   define KERB_SAFE_BODY_timestamp_present 0x80
    KERB_TIME timestamp;
#   define KERB_SAFE_BODY_usec_present 0x40
    ASN1int32_t usec;
#   define KERB_SAFE_BODY_sequence_number_present 0x20
    KERB_SEQUENCE_NUMBER sequence_number;
    KERB_HOST_ADDRESS sender_address;
#   define KERB_SAFE_BODY_recipient_address_present 0x10
    KERB_HOST_ADDRESS recipient_address;
} KERB_SAFE_BODY;

typedef struct KERB_ENCRYPTED_PRIV {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1octetstring_t user_data;
#   define KERB_ENCRYPTED_PRIV_timestamp_present 0x80
    KERB_TIME timestamp;
#   define KERB_ENCRYPTED_PRIV_usec_present 0x40
    ASN1int32_t usec;
#   define KERB_ENCRYPTED_PRIV_sequence_number_present 0x20
    KERB_SEQUENCE_NUMBER sequence_number;
    KERB_HOST_ADDRESS sender_address;
#   define KERB_ENCRYPTED_PRIV_recipient_address_present 0x10
    KERB_HOST_ADDRESS recipient_address;
} KERB_ENCRYPTED_PRIV;
#define KERB_ENCRYPTED_PRIV_PDU 3
#define SIZE_KRB5_Module_PDU_3 sizeof(KERB_ENCRYPTED_PRIV)

typedef struct KERB_ENCRYPTED_CRED {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    PKERB_ENCRYPTED_CRED_ticket_info ticket_info;
#   define nonce_present 0x80
    ASN1int32_t nonce;
#   define KERB_ENCRYPTED_CRED_timestamp_present 0x40
    KERB_TIME timestamp;
#   define KERB_ENCRYPTED_CRED_usec_present 0x20
    ASN1int32_t usec;
#   define sender_address_present 0x10
    KERB_HOST_ADDRESS sender_address;
#   define KERB_ENCRYPTED_CRED_recipient_address_present 0x8
    KERB_HOST_ADDRESS recipient_address;
} KERB_ENCRYPTED_CRED;
#define KERB_ENCRYPTED_CRED_PDU 4
#define SIZE_KRB5_Module_PDU_4 sizeof(KERB_ENCRYPTED_CRED)

typedef struct KERB_ERROR {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t version;
    ASN1int32_t message_type;
#   define client_time_present 0x80
    KERB_TIME client_time;
#   define client_usec_present 0x40
    ASN1int32_t client_usec;
    KERB_TIME server_time;
    ASN1int32_t server_usec;
    ASN1int32_t error_code;
#   define client_realm_present 0x20
    KERB_REALM client_realm;
#   define KERB_ERROR_client_name_present 0x10
    KERB_PRINCIPAL_NAME client_name;
    KERB_REALM realm;
    KERB_PRINCIPAL_NAME server_name;
#   define error_text_present 0x8
    ASN1charstring_t error_text;
#   define error_data_present 0x4
    ASN1octetstring_t error_data;
} KERB_ERROR;
#define KERB_ERROR_PDU 5
#define SIZE_KRB5_Module_PDU_5 sizeof(KERB_ERROR)

typedef struct KERB_ENCRYPTED_DATA {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t encryption_type;
#   define version_present 0x80
    ASN1int32_t version;
    ASN1octetstring_t cipher_text;
} KERB_ENCRYPTED_DATA;
#define KERB_ENCRYPTED_DATA_PDU 6
#define SIZE_KRB5_Module_PDU_6 sizeof(KERB_ENCRYPTED_DATA)

typedef struct KERB_ENCRYPTION_KEY {
    ASN1int32_t keytype;
    ASN1octetstring_t keyvalue;
} KERB_ENCRYPTION_KEY;
#define KERB_ENCRYPTION_KEY_PDU 7
#define SIZE_KRB5_Module_PDU_7 sizeof(KERB_ENCRYPTION_KEY)

typedef struct KERB_CHECKSUM {
    ASN1int32_t checksum_type;
    ASN1octetstring_t checksum;
} KERB_CHECKSUM;
#define KERB_CHECKSUM_PDU 8
#define SIZE_KRB5_Module_PDU_8 sizeof(KERB_CHECKSUM)

typedef struct KERB_ENCRYPTED_TIMESTAMP {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_TIME timestamp;
#   define KERB_ENCRYPTED_TIMESTAMP_usec_present 0x80
    ASN1int32_t usec;
} KERB_ENCRYPTED_TIMESTAMP;
#define KERB_ENCRYPTED_TIMESTAMP_PDU 9
#define SIZE_KRB5_Module_PDU_9 sizeof(KERB_ENCRYPTED_TIMESTAMP)

typedef struct KERB_SALTED_ENCRYPTED_TIMESTAMP {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_TIME timestamp;
#   define KERB_SALTED_ENCRYPTED_TIMESTAMP_usec_present 0x80
    ASN1int32_t usec;
    ASN1octetstring_t salt;
} KERB_SALTED_ENCRYPTED_TIMESTAMP;
#define KERB_SALTED_ENCRYPTED_TIMESTAMP_PDU 10
#define SIZE_KRB5_Module_PDU_10 sizeof(KERB_SALTED_ENCRYPTED_TIMESTAMP)

typedef struct KERB_ETYPE_INFO_ENTRY {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t encryption_type;
#   define salt_present 0x80
    ASN1octetstring_t salt;
} KERB_ETYPE_INFO_ENTRY;

typedef struct PKERB_ETYPE_INFO_s {
    PPKERB_ETYPE_INFO next;
    KERB_ETYPE_INFO_ENTRY value;
} PKERB_ETYPE_INFO_Element, *PKERB_ETYPE_INFO;
#define PKERB_ETYPE_INFO_PDU 11
#define SIZE_KRB5_Module_PDU_11 sizeof(PKERB_ETYPE_INFO_Element)

typedef struct KERB_TGT_REQUEST {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t version;
    ASN1int32_t message_type;
#   define KERB_TGT_REQUEST_server_name_present 0x80
    KERB_PRINCIPAL_NAME server_name;
#   define server_realm_present 0x40
    KERB_REALM server_realm;
} KERB_TGT_REQUEST;
#define KERB_TGT_REQUEST_PDU 12
#define SIZE_KRB5_Module_PDU_12 sizeof(KERB_TGT_REQUEST)

typedef struct KERB_PKCS_SIGNATURE {
    ASN1int32_t encryption_type;
    ASN1octetstring_t signature;
} KERB_PKCS_SIGNATURE;
#define KERB_PKCS_SIGNATURE_PDU 13
#define SIZE_KRB5_Module_PDU_13 sizeof(KERB_PKCS_SIGNATURE)

typedef struct KERB_ALGORITHM_IDENTIFIER {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1objectidentifier_t algorithm;
#   define parameters_present 0x80
    NOCOPYANY parameters;
} KERB_ALGORITHM_IDENTIFIER;

typedef struct KERB_SIGNATURE {
    KERB_ALGORITHM_IDENTIFIER signature_algorithm;
    ASN1bitstring_t pkcs_signature;
} KERB_SIGNATURE;

typedef struct KERB_PA_PK_AS_REP {
    ASN1choice_t choice;
    union {
#	define dh_signed_data_chosen 1
	ASN1octetstring_t dh_signed_data;
#	define key_package_chosen 2
	ASN1octetstring_t key_package;
    } u;
} KERB_PA_PK_AS_REP;
#define KERB_PA_PK_AS_REP_PDU 14
#define SIZE_KRB5_Module_PDU_14 sizeof(KERB_PA_PK_AS_REP)

typedef struct KERB_ENVELOPED_KEY_PACKAGE {
    ASN1choice_t choice;
    union {
#	define encrypted_data_chosen 1
	KERB_ENCRYPTED_DATA encrypted_data;
#	define pkinit_enveloped_data_chosen 2
	ASN1octetstring_t pkinit_enveloped_data;
    } u;
} KERB_ENVELOPED_KEY_PACKAGE;

typedef struct KERB_REPLY_KEY_PACKAGE2 {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_ENCRYPTION_KEY reply_key;
    ASN1int32_t nonce;
#   define subject_public_key_present 0x80
    ASN1bitstring_t subject_public_key;
} KERB_REPLY_KEY_PACKAGE2;
#define KERB_REPLY_KEY_PACKAGE2_PDU 15
#define SIZE_KRB5_Module_PDU_15 sizeof(KERB_REPLY_KEY_PACKAGE2)

typedef struct KERB_REPLY_KEY_PACKAGE {
    KERB_ENCRYPTION_KEY reply_key;
    ASN1int32_t nonce;
} KERB_REPLY_KEY_PACKAGE;
#define KERB_REPLY_KEY_PACKAGE_PDU 16
#define SIZE_KRB5_Module_PDU_16 sizeof(KERB_REPLY_KEY_PACKAGE)

typedef struct KERB_KDC_DH_KEY_INFO {
    ASN1int32_t nonce;
    ASN1bitstring_t subject_public_key;
} KERB_KDC_DH_KEY_INFO;
#define KERB_KDC_DH_KEY_INFO_PDU 17
#define SIZE_KRB5_Module_PDU_17 sizeof(KERB_KDC_DH_KEY_INFO)

typedef struct KERB_PA_PK_AS_REQ {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1octetstring_t signed_auth_pack;
#   define KERB_PA_PK_AS_REQ_trusted_certifiers_present 0x80
    PKERB_PA_PK_AS_REQ_trusted_certifiers trusted_certifiers;
#   define KERB_PA_PK_AS_REQ_kdc_cert_present 0x40
    ASN1octetstring_t kdc_cert;
#   define encryption_cert_present 0x20
    ASN1octetstring_t encryption_cert;
} KERB_PA_PK_AS_REQ;
#define KERB_PA_PK_AS_REQ_PDU 18
#define SIZE_KRB5_Module_PDU_18 sizeof(KERB_PA_PK_AS_REQ)

typedef struct KERB_KERBEROS_NAME {
    KERB_REALM realm;
    KERB_PRINCIPAL_NAME principal_name;
} KERB_KERBEROS_NAME;

typedef struct KERB_PK_AUTHENTICATOR {
    KERB_PRINCIPAL_NAME kdc_name;
    KERB_REALM kdc_realm;
    ASN1int32_t cusec;
    KERB_TIME client_time;
    ASN1int32_t nonce;
} KERB_PK_AUTHENTICATOR;

typedef struct KERB_SUBJECT_PUBLIC_KEY_INFO {
    KERB_ALGORITHM_IDENTIFIER algorithm;
    ASN1bitstring_t subjectPublicKey;
} KERB_SUBJECT_PUBLIC_KEY_INFO;

typedef struct KERB_DH_PARAMTER {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t prime;
    ASN1int32_t base;
#   define private_value_length_present 0x80
    ASN1int32_t private_value_length;
} KERB_DH_PARAMTER;
#define KERB_DH_PARAMTER_PDU 19
#define SIZE_KRB5_Module_PDU_19 sizeof(KERB_DH_PARAMTER)

typedef struct KERB_CERTIFICATE {
    ASN1int32_t cert_type;
    ASN1octetstring_t cert_data;
} KERB_CERTIFICATE;

typedef struct KERB_TYPED_DATA {
    ASN1int32_t data_type;
    ASN1octetstring_t data_value;
} KERB_TYPED_DATA;
#define KERB_TYPED_DATA_PDU 20
#define SIZE_KRB5_Module_PDU_20 sizeof(KERB_TYPED_DATA)

typedef struct KERB_KDC_ISSUED_AUTH_DATA {
    KERB_SIGNATURE checksum;
    PKERB_KDC_ISSUED_AUTH_DATA_elements elements;
} KERB_KDC_ISSUED_AUTH_DATA;
#define KERB_KDC_ISSUED_AUTH_DATA_PDU 21
#define SIZE_KRB5_Module_PDU_21 sizeof(KERB_KDC_ISSUED_AUTH_DATA)

typedef struct KERB_PA_SERV_REFERRAL {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define referred_server_name_present 0x80
    KERB_PRINCIPAL_NAME referred_server_name;
    KERB_REALM referred_server_realm;
} KERB_PA_SERV_REFERRAL;
#define KERB_PA_SERV_REFERRAL_PDU 22
#define SIZE_KRB5_Module_PDU_22 sizeof(KERB_PA_SERV_REFERRAL)

typedef struct KERB_PA_PAC_REQUEST {
    ASN1bool_t include_pac;
} KERB_PA_PAC_REQUEST;
#define KERB_PA_PAC_REQUEST_PDU 23
#define SIZE_KRB5_Module_PDU_23 sizeof(KERB_PA_PAC_REQUEST)

typedef struct KERB_CHANGE_PASSWORD_DATA {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1octetstring_t new_password;
#   define target_name_present 0x80
    KERB_PRINCIPAL_NAME target_name;
#   define target_realm_present 0x40
    KERB_REALM target_realm;
} KERB_CHANGE_PASSWORD_DATA;
#define KERB_CHANGE_PASSWORD_DATA_PDU 24
#define SIZE_KRB5_Module_PDU_24 sizeof(KERB_CHANGE_PASSWORD_DATA)

typedef struct KERB_ERROR_METHOD_DATA {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t data_type;
#   define data_value_present 0x80
    ASN1octetstring_t data_value;
} KERB_ERROR_METHOD_DATA;
#define KERB_ERROR_METHOD_DATA_PDU 25
#define SIZE_KRB5_Module_PDU_25 sizeof(KERB_ERROR_METHOD_DATA)

typedef struct KERB_EXT_ERROR {
    ASN1int32_t status;
    ASN1int32_t klininfo;
    ASN1int32_t flags;
//#ifdef XBOX_KDC
    ASN1uint32_t echo_length;
    ASN1octet_t echo_data[40];
//#endif
} KERB_EXT_ERROR;
#define KERB_EXT_ERROR_PDU 26
#define SIZE_KRB5_Module_PDU_26 sizeof(KERB_EXT_ERROR)

typedef struct KERB_PA_FOR_USER {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_PRINCIPAL_NAME userName;
    KERB_REALM userRealm;
    KERB_CHECKSUM cksum;
    ASN1ztcharstring_t authentication_package;
#   define KERB_PA_FOR_USER_authorization_data_present 0x80
    ASN1octetstring_t authorization_data;
} KERB_PA_FOR_USER;
#define KERB_PA_FOR_USER_PDU 27
#define SIZE_KRB5_Module_PDU_27 sizeof(KERB_PA_FOR_USER)

typedef struct KERB_PA_PAC_REQUEST_EX {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t include_pac;
#   define pac_sections_present 0x80
    PKERB_PA_PAC_REQUEST_EX_pac_sections pac_sections;
} KERB_PA_PAC_REQUEST_EX;
#define KERB_PA_PAC_REQUEST_EX_PDU 28
#define SIZE_KRB5_Module_PDU_28 sizeof(KERB_PA_PAC_REQUEST_EX)

typedef struct KERB_KDC_ISSUED_AUTH_DATA_elements_s {
    PKERB_KDC_ISSUED_AUTH_DATA_elements next;
    KERB_PA_DATA value;
} KERB_KDC_ISSUED_AUTH_DATA_elements_Element, *KERB_KDC_ISSUED_AUTH_DATA_elements;

typedef struct KERB_PA_PK_AS_REQ2_trusted_certifiers_s {
    PKERB_PA_PK_AS_REQ2_trusted_certifiers next;
    KERB_PRINCIPAL_NAME value;
} KERB_PA_PK_AS_REQ2_trusted_certifiers_Element, *KERB_PA_PK_AS_REQ2_trusted_certifiers;

typedef struct KERB_PA_PK_AS_REQ2_user_certs_s {
    PKERB_PA_PK_AS_REQ2_user_certs next;
    KERB_CERTIFICATE value;
} KERB_PA_PK_AS_REQ2_user_certs_Element, *KERB_PA_PK_AS_REQ2_user_certs;

typedef struct KERB_PA_PK_AS_REP2_kdc_cert_s {
    PKERB_PA_PK_AS_REP2_kdc_cert next;
    KERB_CERTIFICATE value;
} KERB_PA_PK_AS_REP2_kdc_cert_Element, *KERB_PA_PK_AS_REP2_kdc_cert;

typedef struct KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data_s {
    PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data next;
    KERB_PA_DATA value;
} KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data_Element, *KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data;

typedef struct KERB_KDC_REPLY_preauth_data_s {
    PKERB_KDC_REPLY_preauth_data next;
    KERB_PA_DATA value;
} KERB_KDC_REPLY_preauth_data_Element, *KERB_KDC_REPLY_preauth_data;

typedef struct KERB_KDC_REQUEST_preauth_data_s {
    PKERB_KDC_REQUEST_preauth_data next;
    KERB_PA_DATA value;
} KERB_KDC_REQUEST_preauth_data_Element, *KERB_KDC_REQUEST_preauth_data;

typedef struct KERB_TICKET {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t ticket_version;
    KERB_REALM realm;
    KERB_PRINCIPAL_NAME server_name;
    KERB_ENCRYPTED_DATA encrypted_part;
#   define ticket_extensions_present 0x80
    PPKERB_TICKET_EXTENSIONS ticket_extensions;
} KERB_TICKET;
#define KERB_TICKET_PDU 29
#define SIZE_KRB5_Module_PDU_29 sizeof(KERB_TICKET)

typedef struct KERB_ENCRYPTED_TICKET {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_TICKET_FLAGS flags;
    KERB_ENCRYPTION_KEY key;
    KERB_REALM client_realm;
    KERB_PRINCIPAL_NAME client_name;
    KERB_TRANSITED_ENCODING transited;
    KERB_TIME authtime;
#   define KERB_ENCRYPTED_TICKET_starttime_present 0x80
    KERB_TIME starttime;
    KERB_TIME endtime;
#   define KERB_ENCRYPTED_TICKET_renew_until_present 0x40
    KERB_TIME renew_until;
#   define KERB_ENCRYPTED_TICKET_client_addresses_present 0x20
    PPKERB_HOST_ADDRESSES client_addresses;
#   define KERB_ENCRYPTED_TICKET_authorization_data_present 0x10
    PPKERB_AUTHORIZATION_DATA authorization_data;
} KERB_ENCRYPTED_TICKET;
#define KERB_ENCRYPTED_TICKET_PDU 30
#define SIZE_KRB5_Module_PDU_30 sizeof(KERB_ENCRYPTED_TICKET)

typedef struct KERB_AUTHENTICATOR {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t authenticator_version;
    KERB_REALM client_realm;
    KERB_PRINCIPAL_NAME client_name;
#   define checksum_present 0x80
    KERB_CHECKSUM checksum;
    ASN1int32_t client_usec;
    KERB_TIME client_time;
#   define KERB_AUTHENTICATOR_subkey_present 0x40
    KERB_ENCRYPTION_KEY subkey;
#   define KERB_AUTHENTICATOR_sequence_number_present 0x20
    KERB_SEQUENCE_NUMBER_LARGE sequence_number;
#   define KERB_AUTHENTICATOR_authorization_data_present 0x10
    PPKERB_AUTHORIZATION_DATA authorization_data;
} KERB_AUTHENTICATOR;
#define KERB_AUTHENTICATOR_PDU 31
#define SIZE_KRB5_Module_PDU_31 sizeof(KERB_AUTHENTICATOR)

typedef struct KERB_KDC_REQUEST_BODY {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_KDC_OPTIONS kdc_options;
#   define KERB_KDC_REQUEST_BODY_client_name_present 0x80
    KERB_PRINCIPAL_NAME client_name;
    KERB_REALM realm;
#   define KERB_KDC_REQUEST_BODY_server_name_present 0x40
    KERB_PRINCIPAL_NAME server_name;
#   define KERB_KDC_REQUEST_BODY_starttime_present 0x20
    KERB_TIME starttime;
    KERB_TIME endtime;
#   define KERB_KDC_REQUEST_BODY_renew_until_present 0x10
    KERB_TIME renew_until;
    ASN1int32_t nonce;
    PKERB_KDC_REQUEST_BODY_encryption_type encryption_type;
#   define addresses_present 0x8
    PPKERB_HOST_ADDRESSES addresses;
#   define enc_authorization_data_present 0x4
    KERB_ENCRYPTED_DATA enc_authorization_data;
#   define additional_tickets_present 0x2
    PKERB_KDC_REQUEST_BODY_additional_tickets additional_tickets;
} KERB_KDC_REQUEST_BODY;

typedef struct KERB_KDC_REPLY {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t version;
    ASN1int32_t message_type;
#   define KERB_KDC_REPLY_preauth_data_present 0x80
    PKERB_KDC_REPLY_preauth_data preauth_data;
    KERB_REALM client_realm;
    KERB_PRINCIPAL_NAME client_name;
    KERB_TICKET ticket;
    KERB_ENCRYPTED_DATA encrypted_part;
} KERB_KDC_REPLY;

typedef struct KERB_ENCRYPTED_KDC_REPLY {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_ENCRYPTION_KEY session_key;
    PPKERB_LAST_REQUEST last_request;
    ASN1int32_t nonce;
#   define key_expiration_present 0x80
    KERB_TIME key_expiration;
    KERB_TICKET_FLAGS flags;
    KERB_TIME authtime;
#   define KERB_ENCRYPTED_KDC_REPLY_starttime_present 0x40
    KERB_TIME starttime;
    KERB_TIME endtime;
#   define KERB_ENCRYPTED_KDC_REPLY_renew_until_present 0x20
    KERB_TIME renew_until;
    KERB_REALM server_realm;
    KERB_PRINCIPAL_NAME server_name;
#   define KERB_ENCRYPTED_KDC_REPLY_client_addresses_present 0x10
    PPKERB_HOST_ADDRESSES client_addresses;
#   define encrypted_pa_data_present 0x8
    PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data encrypted_pa_data;
} KERB_ENCRYPTED_KDC_REPLY;

typedef struct KERB_AP_REQUEST {
    ASN1int32_t version;
    ASN1int32_t message_type;
    KERB_AP_OPTIONS ap_options;
    KERB_TICKET ticket;
    KERB_ENCRYPTED_DATA authenticator;
} KERB_AP_REQUEST;
#define KERB_AP_REQUEST_PDU 32
#define SIZE_KRB5_Module_PDU_32 sizeof(KERB_AP_REQUEST)

typedef struct KERB_AP_REPLY {
    ASN1int32_t version;
    ASN1int32_t message_type;
    KERB_ENCRYPTED_DATA encrypted_part;
} KERB_AP_REPLY;
#define KERB_AP_REPLY_PDU 33
#define SIZE_KRB5_Module_PDU_33 sizeof(KERB_AP_REPLY)

typedef struct KERB_ENCRYPTED_AP_REPLY {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_TIME client_time;
    ASN1int32_t client_usec;
#   define KERB_ENCRYPTED_AP_REPLY_subkey_present 0x80
    KERB_ENCRYPTION_KEY subkey;
#   define KERB_ENCRYPTED_AP_REPLY_sequence_number_present 0x40
    KERB_SEQUENCE_NUMBER sequence_number;
} KERB_ENCRYPTED_AP_REPLY;
#define KERB_ENCRYPTED_AP_REPLY_PDU 34
#define SIZE_KRB5_Module_PDU_34 sizeof(KERB_ENCRYPTED_AP_REPLY)

typedef struct KERB_SAFE_MESSAGE {
    ASN1int32_t version;
    ASN1int32_t message_type;
    KERB_SAFE_BODY safe_body;
    KERB_CHECKSUM checksum;
} KERB_SAFE_MESSAGE;
#define KERB_SAFE_MESSAGE_PDU 35
#define SIZE_KRB5_Module_PDU_35 sizeof(KERB_SAFE_MESSAGE)

typedef struct KERB_PRIV_MESSAGE {
    ASN1int32_t version;
    ASN1int32_t message_type;
    KERB_ENCRYPTED_DATA encrypted_part;
} KERB_PRIV_MESSAGE;
#define KERB_PRIV_MESSAGE_PDU 36
#define SIZE_KRB5_Module_PDU_36 sizeof(KERB_PRIV_MESSAGE)

typedef struct KERB_CRED {
    ASN1int32_t version;
    ASN1int32_t message_type;
    PKERB_CRED_tickets tickets;
    KERB_ENCRYPTED_DATA encrypted_part;
} KERB_CRED;
#define KERB_CRED_PDU 37
#define SIZE_KRB5_Module_PDU_37 sizeof(KERB_CRED)

typedef struct KERB_CRED_INFO {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    KERB_ENCRYPTION_KEY key;
#   define principal_realm_present 0x80
    KERB_REALM principal_realm;
#   define principal_name_present 0x40
    KERB_PRINCIPAL_NAME principal_name;
#   define flags_present 0x20
    KERB_TICKET_FLAGS flags;
#   define authtime_present 0x10
    KERB_TIME authtime;
#   define KERB_CRED_INFO_starttime_present 0x8
    KERB_TIME starttime;
#   define endtime_present 0x4
    KERB_TIME endtime;
#   define KERB_CRED_INFO_renew_until_present 0x2
    KERB_TIME renew_until;
#   define service_realm_present 0x1
    KERB_REALM service_realm;
#   define service_name_present 0x8000
    KERB_PRINCIPAL_NAME service_name;
#   define KERB_CRED_INFO_client_addresses_present 0x4000
    PPKERB_HOST_ADDRESSES client_addresses;
} KERB_CRED_INFO;

typedef struct KERB_TGT_REPLY {
    ASN1int32_t version;
    ASN1int32_t message_type;
    KERB_TICKET ticket;
} KERB_TGT_REPLY;
#define KERB_TGT_REPLY_PDU 38
#define SIZE_KRB5_Module_PDU_38 sizeof(KERB_TGT_REPLY)

typedef struct KERB_SIGNED_REPLY_KEY_PACKAGE {
    KERB_REPLY_KEY_PACKAGE2 reply_key_package;
    KERB_SIGNATURE reply_key_signature;
} KERB_SIGNED_REPLY_KEY_PACKAGE;
#define KERB_SIGNED_REPLY_KEY_PACKAGE_PDU 39
#define SIZE_KRB5_Module_PDU_39 sizeof(KERB_SIGNED_REPLY_KEY_PACKAGE)

typedef struct KERB_SIGNED_KDC_PUBLIC_VALUE {
    KERB_SUBJECT_PUBLIC_KEY_INFO kdc_public_value;
    KERB_SIGNATURE kdc_public_value_sig;
} KERB_SIGNED_KDC_PUBLIC_VALUE;

typedef struct KERB_TRUSTED_CAS {
    ASN1choice_t choice;
    union {
#	define principal_name_chosen 1
	KERB_KERBEROS_NAME principal_name;
#	define ca_name_chosen 2
	ASN1octetstring_t ca_name;
#	define issuer_and_serial_chosen 3
	ASN1octetstring_t issuer_and_serial;
    } u;
} KERB_TRUSTED_CAS;

typedef struct KERB_AUTH_PACKAGE {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_PK_AUTHENTICATOR pk_authenticator;
#   define client_public_value_present 0x80
    KERB_SUBJECT_PUBLIC_KEY_INFO client_public_value;
} KERB_AUTH_PACKAGE;
#define KERB_AUTH_PACKAGE_PDU 40
#define SIZE_KRB5_Module_PDU_40 sizeof(KERB_AUTH_PACKAGE)

typedef struct KERB_PA_COMPOUND_IDENTITY_s {
    PKERB_PA_COMPOUND_IDENTITY next;
    KERB_TICKET value;
} KERB_PA_COMPOUND_IDENTITY_Element, *KERB_PA_COMPOUND_IDENTITY;
#define KERB_PA_COMPOUND_IDENTITY_PDU 41
#define SIZE_KRB5_Module_PDU_41 sizeof(KERB_PA_COMPOUND_IDENTITY_Element)

typedef struct KERB_PA_PK_AS_REQ_trusted_certifiers_s {
    PKERB_PA_PK_AS_REQ_trusted_certifiers next;
    KERB_TRUSTED_CAS value;
} KERB_PA_PK_AS_REQ_trusted_certifiers_Element, *KERB_PA_PK_AS_REQ_trusted_certifiers;

typedef struct KERB_ENCRYPTED_CRED_ticket_info_s {
    PKERB_ENCRYPTED_CRED_ticket_info next;
    KERB_CRED_INFO value;
} KERB_ENCRYPTED_CRED_ticket_info_Element, *KERB_ENCRYPTED_CRED_ticket_info;

typedef struct KERB_CRED_tickets_s {
    PKERB_CRED_tickets next;
    KERB_TICKET value;
} KERB_CRED_tickets_Element, *KERB_CRED_tickets;

typedef struct KERB_KDC_REQUEST_BODY_additional_tickets_s {
    PKERB_KDC_REQUEST_BODY_additional_tickets next;
    KERB_TICKET value;
} KERB_KDC_REQUEST_BODY_additional_tickets_Element, *KERB_KDC_REQUEST_BODY_additional_tickets;

typedef struct KERB_KDC_REQUEST {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t version;
    ASN1int32_t message_type;
#   define KERB_KDC_REQUEST_preauth_data_present 0x80
    PKERB_KDC_REQUEST_preauth_data preauth_data;
    KERB_KDC_REQUEST_BODY request_body;
} KERB_KDC_REQUEST;

typedef KERB_KDC_REQUEST_BODY KERB_MARSHALLED_REQUEST_BODY;
#define KERB_MARSHALLED_REQUEST_BODY_PDU 42
#define SIZE_KRB5_Module_PDU_42 sizeof(KERB_MARSHALLED_REQUEST_BODY)

typedef KERB_KDC_REPLY KERB_AS_REPLY;
#define KERB_AS_REPLY_PDU 43
#define SIZE_KRB5_Module_PDU_43 sizeof(KERB_AS_REPLY)

typedef KERB_KDC_REPLY KERB_TGS_REPLY;
#define KERB_TGS_REPLY_PDU 44
#define SIZE_KRB5_Module_PDU_44 sizeof(KERB_TGS_REPLY)

typedef KERB_ENCRYPTED_KDC_REPLY KERB_ENCRYPTED_AS_REPLY;
#define KERB_ENCRYPTED_AS_REPLY_PDU 45
#define SIZE_KRB5_Module_PDU_45 sizeof(KERB_ENCRYPTED_AS_REPLY)

typedef KERB_ENCRYPTED_KDC_REPLY KERB_ENCRYPTED_TGS_REPLY;
#define KERB_ENCRYPTED_TGS_REPLY_PDU 46
#define SIZE_KRB5_Module_PDU_46 sizeof(KERB_ENCRYPTED_TGS_REPLY)

typedef struct KERB_PA_PK_AS_REP2 {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define key_package_present 0x80
    KERB_ENCRYPTED_DATA key_package;
    KERB_ENVELOPED_KEY_PACKAGE temp_key_package;
#   define signed_kdc_public_value_present 0x40
    KERB_SIGNED_KDC_PUBLIC_VALUE signed_kdc_public_value;
#   define KERB_PA_PK_AS_REP2_kdc_cert_present 0x20
    PKERB_PA_PK_AS_REP2_kdc_cert kdc_cert;
} KERB_PA_PK_AS_REP2;
#define KERB_PA_PK_AS_REP2_PDU 47
#define SIZE_KRB5_Module_PDU_47 sizeof(KERB_PA_PK_AS_REP2)

typedef struct KERB_SIGNED_AUTH_PACKAGE {
    KERB_AUTH_PACKAGE auth_package;
    KERB_SIGNATURE auth_package_signature;
} KERB_SIGNED_AUTH_PACKAGE;

typedef KERB_KDC_REQUEST KERB_AS_REQUEST;
#define KERB_AS_REQUEST_PDU 48
#define SIZE_KRB5_Module_PDU_48 sizeof(KERB_AS_REQUEST)

typedef KERB_KDC_REQUEST KERB_TGS_REQUEST;
#define KERB_TGS_REQUEST_PDU 49
#define SIZE_KRB5_Module_PDU_49 sizeof(KERB_TGS_REQUEST)

typedef struct KERB_PA_PK_AS_REQ2 {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_SIGNED_AUTH_PACKAGE signed_auth_pack;
#   define user_certs_present 0x80
    PKERB_PA_PK_AS_REQ2_user_certs user_certs;
#   define KERB_PA_PK_AS_REQ2_trusted_certifiers_present 0x40
    PKERB_PA_PK_AS_REQ2_trusted_certifiers trusted_certifiers;
#   define serial_number_present 0x20
    KERB_CERTIFICATE_SERIAL_NUMBER serial_number;
} KERB_PA_PK_AS_REQ2;
#define KERB_PA_PK_AS_REQ2_PDU 50
#define SIZE_KRB5_Module_PDU_50 sizeof(KERB_PA_PK_AS_REQ2)


extern ASN1module_t KRB5_Module;
extern void ASN1CALL KRB5_Module_Startup(void);
extern void ASN1CALL KRB5_Module_Cleanup(void);

/* Prototypes of element functions for SEQUENCE OF and SET OF constructs */

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* _KRB5_Module_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\inc\newlock.h ===
#ifdef __cplusplus
extern "C" {
#endif 
//
// BUGBUG: fix these definitions.
//

#define VOLATILE volatile
#define REGISTER register

//#define ENABLE_LOCK_STATISTICS

typedef struct {
        //
        //   Private data.
        //
        LONG                        MaxSpins;
        LONG                        MaxUsers;
        LONG                        MaxShareLockUsers;

        VOLATILE LONG               Exclusive;
        VOLATILE LONG               TotalUsers;

#ifdef ENABLE_RECURSIVE_LOCKS
        LONG                        Owner;
        LONG                        Recursive;
#endif

        HANDLE                      Semaphore;
        VOLATILE LONG               Waiting;

#ifdef ENABLE_LOCK_STATISTICS

        //
        //   Counters for debugging builds.
        //
        VOLATILE LONG               TotalExclusiveLocks;
        VOLATILE LONG               TotalShareLocks;
        VOLATILE LONG               TotalSleeps;
        VOLATILE LONG               TotalSpins;
        VOLATILE LONG               TotalTimeouts;
        VOLATILE LONG               TotalWaits;
#endif

} SHARELOCK, *PSHARELOCK;



BOOLEAN
InitializeSharedLock(
        PSHARELOCK pShareLock
        );

VOID
DeleteSharedLock(
        PSHARELOCK pShareLock
        );

BOOLEAN
ClaimExclusiveLock(
        PSHARELOCK pShareLock,
        DWORD Sleep
        );

BOOLEAN
ClaimShareLock(
        PSHARELOCK pShareLock,
        DWORD Sleep
        );

VOID
ReleaseExclusiveLock(
        PSHARELOCK pShareLock
        );

VOID
ReleaseShareLock(
        PSHARELOCK pShareLock
        );

VOID
ChangeExclusiveLockToSharedLock(
        PSHARELOCK pShareLock
        );

BOOLEAN
ChangeSharedLockToExclusiveLock(
        PSHARELOCK pShareLock,
        DWORD Sleep
        );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\inc\pacuall.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001
//
//  File:       pacuall.h
//
//  Contents:   KERB_PAC_USER_ALL_INFORMATION structure
//
//  Classes:
//
//  Functions:
//
//  History:    31-Aug-2001    JBrezak
//
//----------------------------------------------------------------------------
#ifndef __PACUALL_H__
#define __PACUALL_H__

#include <pshpack4.h>
typedef struct _KERB_PAC_USER_ALL_INFORMATION {
    LARGE_INTEGER LastLogon;
    LARGE_INTEGER PasswordLastSet;
    LARGE_INTEGER PasswordCanChange;
    LARGE_INTEGER PasswordMustChange;
    UNICODE_STRING UserName;
    UNICODE_STRING FullName;
    UNICODE_STRING HomeDirectory;
    UNICODE_STRING HomeDirectoryDrive;
    UNICODE_STRING ScriptPath;
    UNICODE_STRING ProfilePath;
    UNICODE_STRING Parameters;
    UNICODE_STRING LmOwfPassword;
    UNICODE_STRING NtOwfPassword;
    PSID RealmSid;
    ULONG GroupCount;
    PSID_AND_ATTRIBUTES Groups;
    ULONG UserId;                                   // If 0, first Group is User Sid
    ULONG PrimaryGroupId;
    ULONG UserAccountControl;
    USHORT BadPasswordCount;
    USHORT LogonCount;
    BOOLEAN LmPasswordPresent;
    BOOLEAN NtPasswordPresent;
} KERB_PAC_USER_ALL_INFORMATION, *PKERB_PAC_USER_ALL_INFORMATION;
#include <poppack.h>
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\ntpublic_stubs\align.h ===
/*++

Copyright (c) 1988-1992  Microsoft Corporation

Module Name:

    Align.h

Abstract:


Author:

    John Rogers (JohnRo) 15-May-1991

Environment:

    This code assumes that sizeof(DWORD) >= sizeof(LPVOID).

Revision History:

    15-May-1991 JohnRo
        Created align.h for NT/LAN from OS/2 1.2 HPFS pbmacros.h.
    19-Jun-1991 JohnRo
        Make sure pointer-to-wider-then-byte doesn't get messed up.
    10-Jul-1991 JohnRo
        Added ALIGN_BYTE and ALIGN_CHAR for completeness.
    21-Aug-1991 CliffV
        Fix ROUND_DOWN_* to include ~
    03-Dec-1991 JohnRo
        Worst-case on MIPS is 8-byte alignment.
        Added COUNT_IS_ALIGNED() and POINTER_IS_ALIGNED() macros.
    26-Jun-1992 JohnRo
        RAID 9933: ALIGN_WORST should be 8 for x86 builds.

--*/

#ifndef _ALIGN_
#define _ALIGN_


// BOOL
// COUNT_IS_ALIGNED(
//     IN DWORD Count,
//     IN DWORD Pow2      // undefined if this isn't a power of 2.
//     );
//
#define COUNT_IS_ALIGNED(Count,Pow2) \
        ( ( ( (Count) & (((Pow2)-1)) ) == 0) ? TRUE : FALSE )

// BOOL
// POINTER_IS_ALIGNED(
//     IN LPVOID Ptr,
//     IN DWORD Pow2      // undefined if this isn't a power of 2.
//     );
//
#define POINTER_IS_ALIGNED(Ptr,Pow2) \
        ( ( ( ((ULONG_PTR)(Ptr)) & (((Pow2)-1)) ) == 0) ? TRUE : FALSE )


#define ROUND_DOWN_COUNT(Count,Pow2) \
        ( (Count) & (~(((LONG)(Pow2))-1)) )

#define ROUND_DOWN_POINTER(Ptr,Pow2) \
        ( (LPVOID) ROUND_DOWN_COUNT( ((ULONG_PTR)(Ptr)), (Pow2) ) )


// If Count is not already aligned, then
// round Count up to an even multiple of "Pow2".  "Pow2" must be a power of 2.
//
// DWORD
// ROUND_UP_COUNT(
//     IN DWORD Count,
//     IN DWORD Pow2
//     );
#define ROUND_UP_COUNT(Count,Pow2) \
        ( ((Count)+(Pow2)-1) & (~(((LONG)(Pow2))-1)) )

// LPVOID
// ROUND_UP_POINTER(
//     IN LPVOID Ptr,
//     IN DWORD Pow2
//     );

// If Ptr is not already aligned, then round it up until it is.
#define ROUND_UP_POINTER(Ptr,Pow2) \
        ( (LPVOID) ( (((ULONG_PTR)(Ptr))+(Pow2)-1) & (~(((LONG)(Pow2))-1)) ) )


// Usage: myPtr = ROUND_UP_POINTER( unalignedPtr, ALIGN_LPVOID )

#define ALIGN_BYTE              sizeof(UCHAR)
#define ALIGN_CHAR              sizeof(CHAR)
#define ALIGN_DESC_CHAR         sizeof(DESC_CHAR)
#define ALIGN_DWORD             sizeof(DWORD)
#define ALIGN_LONG              sizeof(LONG)
#define ALIGN_LPBYTE            sizeof(LPBYTE)
#define ALIGN_LPDWORD           sizeof(LPDWORD)
#define ALIGN_LPSTR             sizeof(LPSTR)
#define ALIGN_LPTSTR            sizeof(LPTSTR)
#define ALIGN_LPVOID            sizeof(LPVOID)
#define ALIGN_LPWORD            sizeof(LPWORD)
#define ALIGN_TCHAR             sizeof(TCHAR)
#define ALIGN_WCHAR             sizeof(WCHAR)
#define ALIGN_WORD              sizeof(WORD)

//
// For now, use a hardcoded constant. however, this should be visited again
// and maybe changed to sizeof(QUAD).
//

#define ALIGN_QUAD              8

#if defined(_X86_)

#define ALIGN_WORST             8

#elif defined(_AMD64_)

#define ALIGN_WORST             8

#elif defined(_ALPHA_)

//
// Worst-case alignment on ALPHA is 8 bytes (for double).  Specify this here,
// in case our allocator is used for structures containing this.  (That is,
// even though NT/LAN doesn't need this for our data structures, let's be
// permissive.) The alignment requirements apply to Alpha.
//

#define ALIGN_WORST             8

#elif defined(_IA64_)

//
// IA64 note for QUAD: The NT QUAD type definition is NOT the EM 16byte quad type.
//                     Because of some NT constraints, QUAD type size cannot be changed.
//

#define ALIGN_WORST             16

#else  // none of the above

#error "Unknown alignment requirements for align.h"

#endif  // none of the above

#endif  // _ALIGN_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\ntpublic_stubs\general_stubs.h ===
#pragma once

//
// Determine if an argument is present by testing the value of the pointer
// to the argument value.
//

#define ARGUMENT_PRESENT(ArgumentPointer)    (\
    (CHAR *)((ULONG_PTR)(ArgumentPointer)) != (CHAR *)(NULL) )


#define NTLMSP_NAME_SIZE        (sizeof(NTLMSP_NAME) - sizeof(WCHAR))  // ntifs

typedef struct _SYSTEM_KERNEL_DEBUGGER_INFORMATION {
    BOOLEAN KernelDebuggerEnabled;
    BOOLEAN KernelDebuggerNotPresent;
} SYSTEM_KERNEL_DEBUGGER_INFORMATION, *PSYSTEM_KERNEL_DEBUGGER_INFORMATION;

#ifndef SystemKernelDebuggerInformation
#define SystemKernelDebuggerInformation 35
#endif

#ifndef NOTHING
#define NOTHING
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\pubinc\kerbcred.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        kerbcred.h
//
// Contents:    structures for kerberos primary and supplemental credentials
//
//
// History:     20-Aug-1996     MikeSw          Created
//
//------------------------------------------------------------------------

#ifndef __KERBCRED_H__
#define __KERBCRED_H__

//
// Kerberos primary credentials store keys suitable for different
// encryption types.
//
#ifndef _KRB5_Module_H_
typedef struct _KERB_RPC_OCTET_STRING {
    unsigned long length;
#ifdef MIDL_PASS
    [size_is(length)]
#endif // MIDL_PASS
    unsigned char *value;
} KERB_RPC_OCTET_STRING;

typedef struct _KERB_ENCRYPTION_KEY {
    long keytype;
    KERB_RPC_OCTET_STRING keyvalue;
} KERB_ENCRYPTION_KEY;
#endif // _KRB5_Module_H_


#ifndef _KERB_KEY_DATA_DEFINED_
#define _KERB_KEY_DATA_DEFINED_
typedef enum {
    KerbKdbSaltTypeDefault = 0,
    KerbKdbSaltTypePassword,
    KerbKdbSaltTypeNoRealm,
    KerbKdbSaltTypeOnlyRealm,
    KerbKdbSaltTypeSpeial,
    KerbKdbSaltTypeAFS3
} KERB_KDB_SALTTYPE, *PKERB_KDB_SALTTYPE;

typedef struct _KERB_KEY_DATA {
    ULONG		KeyVersion;	
    KERB_KDB_SALTTYPE	SaltType;
    UNICODE_STRING	Salt;		// if not SALTTYPE_DEFAULT
    KERB_ENCRYPTION_KEY Key;		// Use ASN.1 definition (krb5.h)
} KERB_KEY_DATA, *PKERB_KEY_DATA; 

typedef struct _KERB_STORED_CREDENTIAL {
    USHORT		PreferredKeyIndex;
    USHORT		CredentialCount;
    UNICODE_STRING 	DefaultSalt;
    KERB_KEY_DATA	Credentials[ANYSIZE_ARRAY];
} KERB_STORED_CREDENTIAL, *PKERB_STORED_CREDENTIAL;

#endif

#endif // __KERBCRED_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\inc\krbprgma.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    krbprgma.h

Abstract:

    This file contains compiler pragmas to disable specific warnings to
    let Kerberos compile at warning level 4

Author:

    Jonathan Schwartz (jschwart)  25-Apr-2000

Environment:

    User Mode -Win32

Revision History:

    25-Apr-2000
        created

--*/

// Unreferenced formal parameter

#pragma warning (disable: 4100)

// Named type definition in parentheses

#pragma warning (disable: 4115)

// Conditional expression is constant

#pragma warning (disable: 4127)

// Zero-sized array in struct/union

#pragma warning (disable: 4200)

// Nameless struct/union

#pragma warning (disable: 4201)

// Redefined extern to static

#pragma warning (disable: 4211)

// Bit field types other than int

#pragma warning (disable: 4214)

// Address of dllimport is not static

#pragma warning (disable: 4232)

// Cast truncates constant value

#pragma warning (disable: 4310)

// Structure was padded due to __declspec(align())

#pragma warning (disable: 4324)

// LHS indirection alignment greater than argument alignment

#pragma warning (disable: 4327)

// Pointer indirection alignment greater than argument alignment

#pragma warning (disable: 4328)

// Removal of unused inline functions

#pragma warning (disable: 4514)

// Assignment within conditional expression

#pragma warning (disable: 4706)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\pubinc\pacuall.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001
//
//  File:       pacuall.h
//
//  Contents:   KERB_PAC_USER_ALL_INFORMATION structure
//
//  Classes:
//
//  Functions:
//
//  History:    31-Aug-2001    JBrezak
//
//----------------------------------------------------------------------------
#ifndef __PACUALL_H__
#define __PACUALL_H__

#include <pshpack4.h>
typedef struct _KERB_PAC_USER_ALL_INFORMATION {
    LARGE_INTEGER LastLogon;
    LARGE_INTEGER PasswordLastSet;
    LARGE_INTEGER PasswordCanChange;
    LARGE_INTEGER PasswordMustChange;
    UNICODE_STRING UserName;
    UNICODE_STRING FullName;
    UNICODE_STRING HomeDirectory;
    UNICODE_STRING HomeDirectoryDrive;
    UNICODE_STRING ScriptPath;
    UNICODE_STRING ProfilePath;
    UNICODE_STRING Parameters;
    UNICODE_STRING LmOwfPassword;
    UNICODE_STRING NtOwfPassword;
    PSID RealmSid;
    ULONG GroupCount;
    PSID_AND_ATTRIBUTES Groups;
    ULONG UserId;                                   // If 0, first Group is User Sid
    ULONG PrimaryGroupId;
    ULONG UserAccountControl;
    USHORT BadPasswordCount;
    USHORT LogonCount;
    BOOLEAN LmPasswordPresent;
    BOOLEAN NtPasswordPresent;
} KERB_PAC_USER_ALL_INFORMATION, *PKERB_PAC_USER_ALL_INFORMATION;
#include <poppack.h>
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\inc\secmisc.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:        secmisc.h
//
//  Contents:    Helper functions and macros for security packages
//
//  Classes:
//
//  Functions:
//
//  History:    10-Dec-91 Richardw    Created
//
//--------------------------------------------------------------------------

#ifndef __SECMISC_H__
#define __SECMISC_H__

#ifdef __cplusplus
extern "C" {
#endif



///////////////////////////////////////////////////////////////////////////
//
//  Common TimeStamp Manipulation Functions
//
///////////////////////////////////////////////////////////////////////////


// Functions to get/set current local time, or time in UTC:

void    GetCurrentTimeStamp(PLARGE_INTEGER);

// Some convenient "functions"




//
//  BOOL
//  TSIsZero(PLARGE_INTEGER pTS)
//
#define TSIsZero(pTS)   ((pTS)->QuadPart == 0)


#define SetMaxTimeStamp(ts)      \
        (ts).HighPart = 0x7FFFFFFF; \
        (ts).LowPart = 0xFFFFFFFF;

#define SetZeroTimeStamp(ts)      \
        (ts).QuadPart = 0;

void    AddSecondsToTimeStamp(PLARGE_INTEGER, ULONG);
BOOLEAN TSIsNearlyLessThan(PLARGE_INTEGER, PLARGE_INTEGER, PLARGE_INTEGER, LONG);
ULONG   TimeStampDiffInSeconds( PLARGE_INTEGER t1, PLARGE_INTEGER t2);

#define TS_NO_TEND          0
#define TS_TEND_TO_FALSE    1
#define TS_TEND_TO_TRUE     2



// RPC transport constants and routines

#define TRANS_NB        0
#define TRANS_XNS       1
#define TRANS_TCPIP     2
#define TRANS_NP        3

NTSTATUS
GetRpcTransports(PDWORD         pTransports);


NTSTATUS
NewQueryValue(  HKEY            hKey,
                LPWSTR          Key,
                PBYTE *         pValue,
                PULONG          pcbValue);

NTSTATUS
GetMachineName( LPWSTR *        pszMachName);

NTSTATUS
GetLocalDomain( LPWSTR *        pszLocalDomain);

typedef enum _MACHINE_STATE {
    Standalone,
    Workstation,
    StandardServer,
    BackupDomainController,
    DomainController
} MACHINE_STATE;

MACHINE_STATE
GetMachineState(VOID);


//
// Misc. checking routines
//

void
SRtlCheckSecBufferDesc( PSecBufferDesc pData);

void
SRtlCheckSecBuffer( PSecBuffer pBuffer);






#ifdef __cplusplus
}
#endif


#endif  // __SECMISC_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\ntpublic_stubs\ntrtl.h ===
/*++ BUILD Version: 0005    // Increment this if a change has global effects

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    ntrtl.h

Abstract:

    Include file for NT runtime routines that are callable by both
    kernel mode code in the executive and user mode code in various
    NT subsystems.

Author:

    Steve Wood (stevewo) 31-Mar-1989

Environment:

    These routines are dynamically linked in the caller's executable and
    are callable in either kernel mode or user mode.

Revision History:

--*/

#ifndef _NTRTL_
#define _NTRTL_

#if defined (_MSC_VER)
#if ( _MSC_VER >= 800 )
#pragma warning(disable:4514)
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4001)
#pragma warning(disable:4201)
#pragma warning(disable:4214)
#endif
#if (_MSC_VER > 1020)
#pragma once
#endif
#endif

// begin_ntddk begin_wdm begin_winnt begin_ntifs begin_nthal
//
// for move macros
//
#ifdef _MAC
#ifndef _INC_STRING
#include <string.h>
#endif /* _INC_STRING */
#else
#include <string.h>
#endif // _MAC

// end_ntddk end_wdm end_winnt end_ntifs end_nthal

#ifdef __cplusplus
extern "C" {
#endif

//
// XONLINE
//
#if defined(_M_IX86)
#define FASTCALL _fastcall
#else
#define FASTCALL
#endif

typedef ULONG CLONG;

typedef short CSHORT;

typedef USHORT RTL_ATOM, *PRTL_ATOM;

typedef enum _NT_PRODUCT_TYPE {
    NtProductWinNt = 1,
    NtProductLanManNt,
    NtProductServer
} NT_PRODUCT_TYPE, *PNT_PRODUCT_TYPE;

typedef struct _CLIENT_ID {
    HANDLE UniqueProcess;
    HANDLE UniqueThread;
} CLIENT_ID;
typedef CLIENT_ID *PCLIENT_ID;

typedef struct _SECTION_IMAGE_INFORMATION {
    PVOID TransferAddress;
    ULONG ZeroBits;
    SIZE_T MaximumStackSize;
    SIZE_T CommittedStackSize;
    ULONG SubSystemType;
    union {
        struct {
            USHORT SubSystemMinorVersion;
            USHORT SubSystemMajorVersion;
        };
        ULONG SubSystemVersion;
    };
    ULONG GpValue;
    USHORT ImageCharacteristics;
    USHORT DllCharacteristics;
    USHORT Machine;
    BOOLEAN ImageContainsCode;
    BOOLEAN Spare1;
    ULONG LoaderFlags;
    ULONG Reserved[ 2 ];
} SECTION_IMAGE_INFORMATION, *PSECTION_IMAGE_INFORMATION;

typedef struct _CLIENT_ID64 {
    ULONGLONG  UniqueProcess;
    ULONGLONG  UniqueThread;
} CLIENT_ID64;

typedef struct _SECTION_IMAGE_INFORMATION64 {
    ULONGLONG TransferAddress;
    ULONG ZeroBits;
    ULONGLONG MaximumStackSize;
    ULONGLONG CommittedStackSize;
    ULONG SubSystemType;
    union {
        struct {
            USHORT SubSystemMinorVersion;
            USHORT SubSystemMajorVersion;
        };
        ULONG SubSystemVersion;
    };
    ULONG GpValue;
    USHORT ImageCharacteristics;
    USHORT DllCharacteristics;
    USHORT Machine;
    BOOLEAN ImageContainsCode;
    BOOLEAN Spare1;
    ULONG LoaderFlags;
    ULONG Reserved[ 2 ];
} SECTION_IMAGE_INFORMATION64, *PSECTION_IMAGE_INFORMATION64;

#define ARGUMENT_PRESENT(ArgumentPointer)    (\
    (CHAR *)((ULONG_PTR)(ArgumentPointer)) != (CHAR *)(NULL) )

#define MAXIMUM_LEADBYTES   12

typedef struct _CPTABLEINFO {
    USHORT CodePage;                    // code page number
    USHORT MaximumCharacterSize;        // max length (bytes) of a char
    USHORT DefaultChar;                 // default character (MB)
    USHORT UniDefaultChar;              // default character (Unicode)
    USHORT TransDefaultChar;            // translation of default char (Unicode)
    USHORT TransUniDefaultChar;         // translation of Unic default char (MB)
    USHORT DBCSCodePage;                // Non 0 for DBCS code pages
    UCHAR  LeadByte[MAXIMUM_LEADBYTES]; // lead byte ranges
    PUSHORT MultiByteTable;             // pointer to MB translation table
    PVOID   WideCharTable;              // pointer to WC translation table
    PUSHORT DBCSRanges;                 // pointer to DBCS ranges
    PUSHORT DBCSOffsets;                // pointer to DBCS offsets
} CPTABLEINFO, *PCPTABLEINFO;

typedef struct _NLSTABLEINFO {
    CPTABLEINFO OemTableInfo;
    CPTABLEINFO AnsiTableInfo;
    PUSHORT UpperCaseTable;             // 844 format upcase table
    PUSHORT LowerCaseTable;             // 844 format lower case table
} NLSTABLEINFO, *PNLSTABLEINFO;

//
// end XONLINE
//

//
// Inverted runtime function table support.
//
// These routines are called by kernel and user code and are not exported.
//

#if defined(_AMD64_) || defined(_IA64_)

#define MAXIMUM_INVERTED_FUNCTION_TABLE_SIZE 160

typedef struct _INVERTED_FUNCTION_TABLE_ENTRY {
    PRUNTIME_FUNCTION FunctionTable;
    PVOID ImageBase;
    ULONG SizeOfImage;
    ULONG SizeOfTable;

#if defined(_IA64_)

    ULONG64 Gp;

#endif

} INVERTED_FUNCTION_TABLE_ENTRY, *PINVERTED_FUNCTION_TABLE_ENTRY;

typedef struct _INVERTED_FUNCTION_TABLE {
    ULONG CurrentSize;
    ULONG MaximumSize;
    BOOLEAN Overflow;
    INVERTED_FUNCTION_TABLE_ENTRY TableEntry[MAXIMUM_INVERTED_FUNCTION_TABLE_SIZE];
} INVERTED_FUNCTION_TABLE, *PINVERTED_FUNCTION_TABLE;

VOID
RtlInsertInvertedFunctionTable (
    PINVERTED_FUNCTION_TABLE InvertedTable,
    PVOID ImageBase,
    ULONG SizeOfImage
    );

VOID
RtlRemoveInvertedFunctionTable (
    PINVERTED_FUNCTION_TABLE InvertedTable,
    PVOID ImageBase
    );

#endif // defined(_AMD64_) || defined(_IA64_)

//
// Define interlocked sequenced list structure.
//
// begin_ntddk begin_wdm begin_nthal begin_ntifs begin_ntndis begin_ntosp begin_winnt

#ifndef _SLIST_HEADER_
#define _SLIST_HEADER_

#if defined(_WIN64)

//
// The type SINGLE_LIST_ENTRY is not suitable for use with SLISTs.  For
// WIN64, an entry on an SLIST is required to be 16-byte aligned, while a
// SINGLE_LIST_ENTRY structure has only 8 byte alignment.
//
// Therefore, all SLIST code should use the SLIST_ENTRY type instead of the
// SINGLE_LIST_ENTRY type.
//

#pragma warning(push)
#pragma warning(disable:4324)   // structure padded due to align()
typedef struct DECLSPEC_ALIGN(16) _SLIST_ENTRY *PSLIST_ENTRY;
typedef struct DECLSPEC_ALIGN(16) _SLIST_ENTRY {
    PSLIST_ENTRY Next;
} SLIST_ENTRY;
#pragma warning(pop)

#else

#define SLIST_ENTRY SINGLE_LIST_ENTRY
#define _SLIST_ENTRY _SINGLE_LIST_ENTRY
#define PSLIST_ENTRY PSINGLE_LIST_ENTRY

#endif

#if defined(_WIN64)

typedef struct DECLSPEC_ALIGN(16) _SLIST_HEADER {
    ULONGLONG Alignment;
    ULONGLONG Region;
} SLIST_HEADER;

typedef struct _SLIST_HEADER *PSLIST_HEADER;

#else

typedef union _SLIST_HEADER {
    ULONGLONG Alignment;
    struct {
        SLIST_ENTRY Next;
        USHORT Depth;
        USHORT Sequence;
    };
} SLIST_HEADER, *PSLIST_HEADER;

#endif

#endif

// end_ntddk end_wdm end_nthal end_ntifs end_ntndis end_ntosp end_winnt

VOID
RtlMakeStackTraceDataPresent(
    VOID
    );

// begin_winnt

NTSYSAPI
VOID
NTAPI
RtlInitializeSListHead (
    IN PSLIST_HEADER ListHead
    );

NTSYSAPI
PSLIST_ENTRY
RtlFirstEntrySList (
    IN const SLIST_HEADER *ListHead
    );

NTSYSAPI
PSLIST_ENTRY
NTAPI
RtlInterlockedPopEntrySList (
    IN PSLIST_HEADER ListHead
    );

NTSYSAPI
PSLIST_ENTRY
NTAPI
RtlInterlockedPushEntrySList (
    IN PSLIST_HEADER ListHead,
    IN PSLIST_ENTRY ListEntry
    );

NTSYSAPI
PSLIST_ENTRY
NTAPI
RtlInterlockedFlushSList (
    IN PSLIST_HEADER ListHead
    );

NTSYSAPI
USHORT
NTAPI
RtlQueryDepthSList (
    IN PSLIST_HEADER ListHead
    );

// end_winnt

PSLIST_ENTRY
FASTCALL
RtlInterlockedPushListSList (
     IN PSLIST_HEADER ListHead,
     IN PSLIST_ENTRY List,
     IN PSLIST_ENTRY ListEnd,
     IN ULONG Count
     );


// begin_ntddk begin_wdm begin_nthal begin_ntifs begin_ntndis
//
// If debugging support enabled, define an ASSERT macro that works.  Otherwise
// define the ASSERT macro to expand to an empty expression.
//
// The ASSERT macro has been updated to be an expression instead of a statement.
//

NTSYSAPI
VOID
NTAPI
RtlAssert(
    PVOID FailedAssertion,
    PVOID FileName,
    ULONG LineNumber,
    PCHAR Message
    );

#if DBG

#define ASSERT( exp ) \
    ((!(exp)) ? \
        (RtlAssert( #exp, __FILE__, __LINE__, NULL ),FALSE) : \
        TRUE)

#define ASSERTMSG( msg, exp ) \
    ((!(exp)) ? \
        (RtlAssert( #exp, __FILE__, __LINE__, msg ),FALSE) : \
        TRUE)

#define RTL_SOFT_ASSERT(_exp) \
    ((!(_exp)) ? \
        (DbgPrint("%s(%d): Soft assertion failed\n   Expression: %s\n", __FILE__, __LINE__, #_exp),FALSE) : \
        TRUE)

#define RTL_SOFT_ASSERTMSG(_msg, _exp) \
    ((!(_exp)) ? \
        (DbgPrint("%s(%d): Soft assertion failed\n   Expression: %s\n   Message: %s\n", __FILE__, __LINE__, #_exp, (_msg)),FALSE) : \
        TRUE)

#define RTL_VERIFY         ASSERT
#define RTL_VERIFYMSG      ASSERTMSG

#define RTL_SOFT_VERIFY    RTL_SOFT_ASSERT
#define RTL_SOFT_VERIFYMSG RTL_SOFT_ASSERTMSG

#else
#define ASSERT( exp )         ((void) 0)
#define ASSERTMSG( msg, exp ) ((void) 0)

#define RTL_SOFT_ASSERT(_exp)          ((void) 0)
#define RTL_SOFT_ASSERTMSG(_msg, _exp) ((void) 0)

#define RTL_VERIFY( exp )         ((exp) ? TRUE : FALSE)
#define RTL_VERIFYMSG( msg, exp ) ((exp) ? TRUE : FALSE)

#define RTL_SOFT_VERIFY(_exp)         ((_exp) ? TRUE : FALSE)
#define RTL_SOFT_VERIFYMSG(msg, _exp) ((_exp) ? TRUE : FALSE)

#endif // DBG

// end_ntddk end_wdm end_nthal end_ntifs end_ntndis

// begin_ntddk begin_wdm begin_nthal begin_ntifs begin_ntndis
//
//  Doubly-linked list manipulation routines.
//


//
//  VOID
//  InitializeListHead32(
//      PLIST_ENTRY32 ListHead
//      );
//

#define InitializeListHead32(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = PtrToUlong((ListHead)))

#if !defined(MIDL_PASS) && !defined(SORTPP_PASS)


VOID
FORCEINLINE
InitializeListHead(
    IN PLIST_ENTRY ListHead
    )
{
    ListHead->Flink = ListHead->Blink = ListHead;
}

//
//  BOOLEAN
//  IsListEmpty(
//      PLIST_ENTRY ListHead
//      );
//

#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))



BOOLEAN
FORCEINLINE
RemoveEntryList(
    IN PLIST_ENTRY Entry
    )
{
    PLIST_ENTRY Blink;
    PLIST_ENTRY Flink;

    Flink = Entry->Flink;
    Blink = Entry->Blink;
    Blink->Flink = Flink;
    Flink->Blink = Blink;
    return (BOOLEAN)(Flink == Blink);
}

PLIST_ENTRY
FORCEINLINE
RemoveHeadList(
    IN PLIST_ENTRY ListHead
    )
{
    PLIST_ENTRY Flink;
    PLIST_ENTRY Entry;

    Entry = ListHead->Flink;
    Flink = Entry->Flink;
    ListHead->Flink = Flink;
    Flink->Blink = ListHead;
    return Entry;
}



PLIST_ENTRY
FORCEINLINE
RemoveTailList(
    IN PLIST_ENTRY ListHead
    )
{
    PLIST_ENTRY Blink;
    PLIST_ENTRY Entry;

    Entry = ListHead->Blink;
    Blink = Entry->Blink;
    ListHead->Blink = Blink;
    Blink->Flink = ListHead;
    return Entry;
}


VOID
FORCEINLINE
InsertTailList(
    IN PLIST_ENTRY ListHead,
    IN PLIST_ENTRY Entry
    )
{
    PLIST_ENTRY Blink;

    Blink = ListHead->Blink;
    Entry->Flink = ListHead;
    Entry->Blink = Blink;
    Blink->Flink = Entry;
    ListHead->Blink = Entry;
}


VOID
FORCEINLINE
InsertHeadList(
    IN PLIST_ENTRY ListHead,
    IN PLIST_ENTRY Entry
    )
{
    PLIST_ENTRY Flink;

    Flink = ListHead->Flink;
    Entry->Flink = Flink;
    Entry->Blink = ListHead;
    Flink->Blink = Entry;
    ListHead->Flink = Entry;
}


//
//
//  PSINGLE_LIST_ENTRY
//  PopEntryList(
//      PSINGLE_LIST_ENTRY ListHead
//      );
//

#define PopEntryList(ListHead) \
    (ListHead)->Next;\
    {\
        PSINGLE_LIST_ENTRY FirstEntry;\
        FirstEntry = (ListHead)->Next;\
        if (FirstEntry != NULL) {     \
            (ListHead)->Next = FirstEntry->Next;\
        }                             \
    }


//
//  VOID
//  PushEntryList(
//      PSINGLE_LIST_ENTRY ListHead,
//      PSINGLE_LIST_ENTRY Entry
//      );
//

#define PushEntryList(ListHead,Entry) \
    (Entry)->Next = (ListHead)->Next; \
    (ListHead)->Next = (Entry)

#endif // !MIDL_PASS

// end_wdm end_nthal end_ntifs end_ntndis


// end_ntddk


// begin_ntifs

//
// This enumerated type is used as the function return value of the function
// that is used to search the tree for a key. FoundNode indicates that the
// function found the key. Insert as left indicates that the key was not found
// and the node should be inserted as the left child of the parent. Insert as
// right indicates that the key was not found and the node should be inserted
//  as the right child of the parent.
//
typedef enum _TABLE_SEARCH_RESULT{
    TableEmptyTree,
    TableFoundNode,
    TableInsertAsLeft,
    TableInsertAsRight
} TABLE_SEARCH_RESULT;

//
//  The results of a compare can be less than, equal, or greater than.
//

typedef enum _RTL_GENERIC_COMPARE_RESULTS {
    GenericLessThan,
    GenericGreaterThan,
    GenericEqual
} RTL_GENERIC_COMPARE_RESULTS;

//
//  Define the Avl version of the generic table package.  Note a generic table
//  should really be an opaque type.  We provide routines to manipulate the structure.
//
//  A generic table is package for inserting, deleting, and looking up elements
//  in a table (e.g., in a symbol table).  To use this package the user
//  defines the structure of the elements stored in the table, provides a
//  comparison function, a memory allocation function, and a memory
//  deallocation function.
//
//  Note: the user compare function must impose a complete ordering among
//  all of the elements, and the table does not allow for duplicate entries.
//

//
// Add an empty typedef so that functions can reference the
// a pointer to the generic table struct before it is declared.
//

struct _RTL_AVL_TABLE;

//
//  The comparison function takes as input pointers to elements containing
//  user defined structures and returns the results of comparing the two
//  elements.
//

typedef
RTL_GENERIC_COMPARE_RESULTS
(NTAPI *PRTL_AVL_COMPARE_ROUTINE) (
    struct _RTL_AVL_TABLE *Table,
    PVOID FirstStruct,
    PVOID SecondStruct
    );

//
//  The allocation function is called by the generic table package whenever
//  it needs to allocate memory for the table.
//

typedef
PVOID
(NTAPI *PRTL_AVL_ALLOCATE_ROUTINE) (
    struct _RTL_AVL_TABLE *Table,
    CLONG ByteSize
    );

//
//  The deallocation function is called by the generic table package whenever
//  it needs to deallocate memory from the table that was allocated by calling
//  the user supplied allocation function.
//

typedef
VOID
(NTAPI *PRTL_AVL_FREE_ROUTINE) (
    struct _RTL_AVL_TABLE *Table,
    PVOID Buffer
    );

//
//  The match function takes as input the user data to be matched and a pointer
//  to some match data, which was passed along with the function pointer.  It
//  returns TRUE for a match and FALSE for no match.
//
//  RTL_AVL_MATCH_FUNCTION returns
//      STATUS_SUCCESS if the IndexRow matches
//      STATUS_NO_MATCH if the IndexRow does not match, but the enumeration should
//          continue
//      STATUS_NO_MORE_MATCHES if the IndexRow does not match, and the enumeration
//          should terminate
//


typedef
NTSTATUS
(NTAPI *PRTL_AVL_MATCH_FUNCTION) (
    struct _RTL_AVL_TABLE *Table,
    PVOID UserData,
    PVOID MatchData
    );

//
//  Define the balanced tree links and Balance field.  (No Rank field
//  defined at this time.)
//
//  Callers should treat this structure as opaque!
//
//  The root of a balanced binary tree is not a real node in the tree
//  but rather points to a real node which is the root.  It is always
//  in the table below, and its fields are used as follows:
//
//      Parent      Pointer to self, to allow for detection of the root.
//      LeftChild   NULL
//      RightChild  Pointer to real root
//      Balance     Undefined, however it is set to a convenient value
//                  (depending on the algorithm) prior to rebalancing
//                  in insert and delete routines.
//

typedef struct _RTL_BALANCED_LINKS {
    struct _RTL_BALANCED_LINKS *Parent;
    struct _RTL_BALANCED_LINKS *LeftChild;
    struct _RTL_BALANCED_LINKS *RightChild;
    CHAR Balance;
    UCHAR Reserved[3];
} RTL_BALANCED_LINKS;
typedef RTL_BALANCED_LINKS *PRTL_BALANCED_LINKS;

//
//  To use the generic table package the user declares a variable of type
//  GENERIC_TABLE and then uses the routines described below to initialize
//  the table and to manipulate the table.  Note that the generic table
//  should really be an opaque type.
//

typedef struct _RTL_AVL_TABLE {
    RTL_BALANCED_LINKS BalancedRoot;
    PVOID OrderedPointer;
    ULONG WhichOrderedElement;
    ULONG NumberGenericTableElements;
    ULONG DepthOfTree;
    PRTL_BALANCED_LINKS RestartKey;
    ULONG DeleteCount;
    PRTL_AVL_COMPARE_ROUTINE CompareRoutine;
    PRTL_AVL_ALLOCATE_ROUTINE AllocateRoutine;
    PRTL_AVL_FREE_ROUTINE FreeRoutine;
    PVOID TableContext;
} RTL_AVL_TABLE;
typedef RTL_AVL_TABLE *PRTL_AVL_TABLE;

//
//  The procedure InitializeGenericTable takes as input an uninitialized
//  generic table variable and pointers to the three user supplied routines.
//  This must be called for every individual generic table variable before
//  it can be used.
//

NTSYSAPI
VOID
NTAPI
RtlInitializeGenericTableAvl (
    PRTL_AVL_TABLE Table,
    PRTL_AVL_COMPARE_ROUTINE CompareRoutine,
    PRTL_AVL_ALLOCATE_ROUTINE AllocateRoutine,
    PRTL_AVL_FREE_ROUTINE FreeRoutine,
    PVOID TableContext
    );

//
//  The function InsertElementGenericTable will insert a new element
//  in a table.  It does this by allocating space for the new element
//  (this includes AVL links), inserting the element in the table, and
//  then returning to the user a pointer to the new element.  If an element
//  with the same key already exists in the table the return value is a pointer
//  to the old element.  The optional output parameter NewElement is used
//  to indicate if the element previously existed in the table.  Note: the user
//  supplied Buffer is only used for searching the table, upon insertion its
//  contents are copied to the newly created element.  This means that
//  pointer to the input buffer will not point to the new element.
//

NTSYSAPI
PVOID
NTAPI
RtlInsertElementGenericTableAvl (
    PRTL_AVL_TABLE Table,
    PVOID Buffer,
    CLONG BufferSize,
    PBOOLEAN NewElement OPTIONAL
    );

//
//  The function InsertElementGenericTableFull will insert a new element
//  in a table.  It does this by allocating space for the new element
//  (this includes AVL links), inserting the element in the table, and
//  then returning to the user a pointer to the new element.  If an element
//  with the same key already exists in the table the return value is a pointer
//  to the old element.  The optional output parameter NewElement is used
//  to indicate if the element previously existed in the table.  Note: the user
//  supplied Buffer is only used for searching the table, upon insertion its
//  contents are copied to the newly created element.  This means that
//  pointer to the input buffer will not point to the new element.
//  This routine is passed the NodeOrParent and SearchResult from a
//  previous RtlLookupElementGenericTableFull.
//

NTSYSAPI
PVOID
NTAPI
RtlInsertElementGenericTableFullAvl (
    PRTL_AVL_TABLE Table,
    PVOID Buffer,
    CLONG BufferSize,
    PBOOLEAN NewElement OPTIONAL,
    PVOID NodeOrParent,
    TABLE_SEARCH_RESULT SearchResult
    );

//
//  The function DeleteElementGenericTable will find and delete an element
//  from a generic table.  If the element is located and deleted the return
//  value is TRUE, otherwise if the element is not located the return value
//  is FALSE.  The user supplied input buffer is only used as a key in
//  locating the element in the table.
//

NTSYSAPI
BOOLEAN
NTAPI
RtlDeleteElementGenericTableAvl (
    PRTL_AVL_TABLE Table,
    PVOID Buffer
    );

//
//  The function LookupElementGenericTable will find an element in a generic
//  table.  If the element is located the return value is a pointer to
//  the user defined structure associated with the element, otherwise if
//  the element is not located the return value is NULL.  The user supplied
//  input buffer is only used as a key in locating the element in the table.
//

NTSYSAPI
PVOID
NTAPI
RtlLookupElementGenericTableAvl (
    PRTL_AVL_TABLE Table,
    PVOID Buffer
    );

//
//  The function LookupElementGenericTableFull will find an element in a generic
//  table.  If the element is located the return value is a pointer to
//  the user defined structure associated with the element.  If the element is not
//  located then a pointer to the parent for the insert location is returned.  The
//  user must look at the SearchResult value to determine which is being returned.
//  The user can use the SearchResult and parent for a subsequent FullInsertElement
//  call to optimize the insert.
//

NTSYSAPI
PVOID
NTAPI
RtlLookupElementGenericTableFullAvl (
    PRTL_AVL_TABLE Table,
    PVOID Buffer,
    OUT PVOID *NodeOrParent,
    OUT TABLE_SEARCH_RESULT *SearchResult
    );

//
//  The function EnumerateGenericTable will return to the caller one-by-one
//  the elements of of a table.  The return value is a pointer to the user
//  defined structure associated with the element.  The input parameter
//  Restart indicates if the enumeration should start from the beginning
//  or should return the next element.  If the are no more new elements to
//  return the return value is NULL.  As an example of its use, to enumerate
//  all of the elements in a table the user would write:
//
//      for (ptr = EnumerateGenericTable(Table, TRUE);
//           ptr != NULL;
//           ptr = EnumerateGenericTable(Table, FALSE)) {
//              :
//      }
//
//  NOTE:   This routine does not modify the structure of the tree, but saves
//          the last node returned in the generic table itself, and for this
//          reason requires exclusive access to the table for the duration of
//          the enumeration.
//

NTSYSAPI
PVOID
NTAPI
RtlEnumerateGenericTableAvl (
    PRTL_AVL_TABLE Table,
    BOOLEAN Restart
    );

//
//  The function EnumerateGenericTableWithoutSplaying will return to the
//  caller one-by-one the elements of of a table.  The return value is a
//  pointer to the user defined structure associated with the element.
//  The input parameter RestartKey indicates if the enumeration should
//  start from the beginning or should return the next element.  If the
//  are no more new elements to return the return value is NULL.  As an
//  example of its use, to enumerate all of the elements in a table the
//  user would write:
//
//      RestartKey = NULL;
//      for (ptr = EnumerateGenericTableWithoutSplaying(Table, &RestartKey);
//           ptr != NULL;
//           ptr = EnumerateGenericTableWithoutSplaying(Table, &RestartKey)) {
//              :
//      }
//
//  If RestartKey is NULL, the package will start from the least entry in the
//  table, otherwise it will start from the last entry returned.
//
//  NOTE:   This routine does not modify either the structure of the tree
//          or the generic table itself, but must insure that no deletes
//          occur for the duration of the enumeration, typically by having
//          at least shared access to the table for the duration.
//

NTSYSAPI
PVOID
NTAPI
RtlEnumerateGenericTableWithoutSplayingAvl (
    PRTL_AVL_TABLE Table,
    PVOID *RestartKey
    );

//
//  The function EnumerateGenericTableLikeADirectory will return to the
//  caller one-by-one the elements of of a table.  The return value is a
//  pointer to the user defined structure associated with the element.
//  The input parameter RestartKey indicates if the enumeration should
//  start from the beginning or should return the next element.  If the
//  are no more new elements to return the return value is NULL.  As an
//  example of its use, to enumerate all of the elements in a table the
//  user would write:
//
//      RestartKey = NULL;
//      for (ptr = EnumerateGenericTableLikeADirectory(Table, &RestartKey, ...);
//           ptr != NULL;
//           ptr = EnumerateGenericTableLikeADirectory(Table, &RestartKey, ...)) {
//              :
//      }
//
//  If RestartKey is NULL, the package will start from the least entry in the
//  table, otherwise it will start from the last entry returned.
//
//  NOTE:   This routine does not modify either the structure of the tree
//          or the generic table itself.  The table must only be acquired
//          shared for the duration of this call, and all synchronization
//          may optionally be dropped between calls.  Enumeration is always
//          correctly resumed in the most efficient manner possible via the
//          IN OUT parameters provided.
//
//  ******  Explain NextFlag.  Directory enumeration resumes from a key
//          requires more thought.  Also need the match pattern and IgnoreCase.
//          Should some structure be introduced to carry it all?
//

NTSYSAPI
PVOID
NTAPI
RtlEnumerateGenericTableLikeADirectory (
    IN PRTL_AVL_TABLE Table,
    IN PRTL_AVL_MATCH_FUNCTION MatchFunction,
    IN PVOID MatchData,
    IN ULONG NextFlag,
    IN OUT PVOID *RestartKey,
    IN OUT PULONG DeleteCount,
    IN OUT PVOID Buffer
    );

//
// The function GetElementGenericTable will return the i'th element
// inserted in the generic table.  I = 0 implies the first element,
// I = (RtlNumberGenericTableElements(Table)-1) will return the last element
// inserted into the generic table.  The type of I is ULONG.  Values
// of I > than (NumberGenericTableElements(Table)-1) will return NULL.  If
// an arbitrary element is deleted from the generic table it will cause
// all elements inserted after the deleted element to "move up".

NTSYSAPI
PVOID
NTAPI
RtlGetElementGenericTableAvl (
    PRTL_AVL_TABLE Table,
    ULONG I
    );

//
// The function NumberGenericTableElements returns a ULONG value
// which is the number of generic table elements currently inserted
// in the generic table.

NTSYSAPI
ULONG
NTAPI
RtlNumberGenericTableElementsAvl (
    PRTL_AVL_TABLE Table
    );

//
//  The function IsGenericTableEmpty will return to the caller TRUE if
//  the input table is empty (i.e., does not contain any elements) and
//  FALSE otherwise.
//

NTSYSAPI
BOOLEAN
NTAPI
RtlIsGenericTableEmptyAvl (
    PRTL_AVL_TABLE Table
    );

//
//  As an aid to allowing existing generic table users to do (in most
//  cases) a single-line edit to switch over to Avl table use, we
//  have the following defines and inline routine definitions which
//  redirect calls and types.  Note that the type override (performed
//  by #define below) will not work in the unexpected event that someone
//  has used a pointer or type specifier in their own #define, since
//  #define processing is one pass and does not nest.  The __inline
//  declarations below do not have this limitation, however.
//
//  To switch to using Avl tables, add the following line before your
//  includes:
//
//  #define RTL_USE_AVL_TABLES 0
//

#ifdef RTL_USE_AVL_TABLES

#undef PRTL_GENERIC_COMPARE_ROUTINE
#undef PRTL_GENERIC_ALLOCATE_ROUTINE
#undef PRTL_GENERIC_FREE_ROUTINE
#undef RTL_GENERIC_TABLE
#undef PRTL_GENERIC_TABLE

#define PRTL_GENERIC_COMPARE_ROUTINE PRTL_AVL_COMPARE_ROUTINE
#define PRTL_GENERIC_ALLOCATE_ROUTINE PRTL_AVL_ALLOCATE_ROUTINE
#define PRTL_GENERIC_FREE_ROUTINE PRTL_AVL_FREE_ROUTINE
#define RTL_GENERIC_TABLE RTL_AVL_TABLE
#define PRTL_GENERIC_TABLE PRTL_AVL_TABLE

#define RtlInitializeGenericTable               RtlInitializeGenericTableAvl
#define RtlInsertElementGenericTable            RtlInsertElementGenericTableAvl
#define RtlInsertElementGenericTableFull        RtlInsertElementGenericTableFullAvl
#define RtlDeleteElementGenericTable            RtlDeleteElementGenericTableAvl
#define RtlLookupElementGenericTable            RtlLookupElementGenericTableAvl
#define RtlLookupElementGenericTableFull        RtlLookupElementGenericTableFullAvl
#define RtlEnumerateGenericTable                RtlEnumerateGenericTableAvl
#define RtlEnumerateGenericTableWithoutSplaying RtlEnumerateGenericTableWithoutSplayingAvl
#define RtlGetElementGenericTable               RtlGetElementGenericTableAvl
#define RtlNumberGenericTableElements           RtlNumberGenericTableElementsAvl
#define RtlIsGenericTableEmpty                  RtlIsGenericTableEmptyAvl

#endif // RTL_USE_AVL_TABLES


//
//  Define the splay links and the associated manipuliation macros and
//  routines.  Note that the splay_links should be an opaque type.
//  Routine are provided to traverse and manipulate the structure.
//

typedef struct _RTL_SPLAY_LINKS {
    struct _RTL_SPLAY_LINKS *Parent;
    struct _RTL_SPLAY_LINKS *LeftChild;
    struct _RTL_SPLAY_LINKS *RightChild;
} RTL_SPLAY_LINKS;
typedef RTL_SPLAY_LINKS *PRTL_SPLAY_LINKS;

//
//  The macro procedure InitializeSplayLinks takes as input a pointer to
//  splay link and initializes its substructure.  All splay link nodes must
//  be initialized before they are used in the different splay routines and
//  macros.
//
//  VOID
//  RtlInitializeSplayLinks (
//      PRTL_SPLAY_LINKS Links
//      );
//

#define RtlInitializeSplayLinks(Links) {    \
    PRTL_SPLAY_LINKS _SplayLinks;            \
    _SplayLinks = (PRTL_SPLAY_LINKS)(Links); \
    _SplayLinks->Parent = _SplayLinks;   \
    _SplayLinks->LeftChild = NULL;       \
    _SplayLinks->RightChild = NULL;      \
    }

//
//  The macro function Parent takes as input a pointer to a splay link in a
//  tree and returns a pointer to the splay link of the parent of the input
//  node.  If the input node is the root of the tree the return value is
//  equal to the input value.
//
//  PRTL_SPLAY_LINKS
//  RtlParent (
//      PRTL_SPLAY_LINKS Links
//      );
//

#define RtlParent(Links) (           \
    (PRTL_SPLAY_LINKS)(Links)->Parent \
    )

//
//  The macro function LeftChild takes as input a pointer to a splay link in
//  a tree and returns a pointer to the splay link of the left child of the
//  input node.  If the left child does not exist, the return value is NULL.
//
//  PRTL_SPLAY_LINKS
//  RtlLeftChild (
//      PRTL_SPLAY_LINKS Links
//      );
//

#define RtlLeftChild(Links) (           \
    (PRTL_SPLAY_LINKS)(Links)->LeftChild \
    )

//
//  The macro function RightChild takes as input a pointer to a splay link
//  in a tree and returns a pointer to the splay link of the right child of
//  the input node.  If the right child does not exist, the return value is
//  NULL.
//
//  PRTL_SPLAY_LINKS
//  RtlRightChild (
//      PRTL_SPLAY_LINKS Links
//      );
//

#define RtlRightChild(Links) (           \
    (PRTL_SPLAY_LINKS)(Links)->RightChild \
    )

//
//  The macro function IsRoot takes as input a pointer to a splay link
//  in a tree and returns TRUE if the input node is the root of the tree,
//  otherwise it returns FALSE.
//
//  BOOLEAN
//  RtlIsRoot (
//      PRTL_SPLAY_LINKS Links
//      );
//

#define RtlIsRoot(Links) (                          \
    (RtlParent(Links) == (PRTL_SPLAY_LINKS)(Links)) \
    )

//
//  The macro function IsLeftChild takes as input a pointer to a splay link
//  in a tree and returns TRUE if the input node is the left child of its
//  parent, otherwise it returns FALSE.
//
//  BOOLEAN
//  RtlIsLeftChild (
//      PRTL_SPLAY_LINKS Links
//      );
//

#define RtlIsLeftChild(Links) (                                   \
    (RtlLeftChild(RtlParent(Links)) == (PRTL_SPLAY_LINKS)(Links)) \
    )

//
//  The macro function IsRightChild takes as input a pointer to a splay link
//  in a tree and returns TRUE if the input node is the right child of its
//  parent, otherwise it returns FALSE.
//
//  BOOLEAN
//  RtlIsRightChild (
//      PRTL_SPLAY_LINKS Links
//      );
//

#define RtlIsRightChild(Links) (                                   \
    (RtlRightChild(RtlParent(Links)) == (PRTL_SPLAY_LINKS)(Links)) \
    )

//
//  The macro procedure InsertAsLeftChild takes as input a pointer to a splay
//  link in a tree and a pointer to a node not in a tree.  It inserts the
//  second node as the left child of the first node.  The first node must not
//  already have a left child, and the second node must not already have a
//  parent.
//
//  VOID
//  RtlInsertAsLeftChild (
//      PRTL_SPLAY_LINKS ParentLinks,
//      PRTL_SPLAY_LINKS ChildLinks
//      );
//

#define RtlInsertAsLeftChild(ParentLinks,ChildLinks) { \
    PRTL_SPLAY_LINKS _SplayParent;                      \
    PRTL_SPLAY_LINKS _SplayChild;                       \
    _SplayParent = (PRTL_SPLAY_LINKS)(ParentLinks);     \
    _SplayChild = (PRTL_SPLAY_LINKS)(ChildLinks);       \
    _SplayParent->LeftChild = _SplayChild;          \
    _SplayChild->Parent = _SplayParent;             \
    }

//
//  The macro procedure InsertAsRightChild takes as input a pointer to a splay
//  link in a tree and a pointer to a node not in a tree.  It inserts the
//  second node as the right child of the first node.  The first node must not
//  already have a right child, and the second node must not already have a
//  parent.
//
//  VOID
//  RtlInsertAsRightChild (
//      PRTL_SPLAY_LINKS ParentLinks,
//      PRTL_SPLAY_LINKS ChildLinks
//      );
//

#define RtlInsertAsRightChild(ParentLinks,ChildLinks) { \
    PRTL_SPLAY_LINKS _SplayParent;                       \
    PRTL_SPLAY_LINKS _SplayChild;                        \
    _SplayParent = (PRTL_SPLAY_LINKS)(ParentLinks);      \
    _SplayChild = (PRTL_SPLAY_LINKS)(ChildLinks);        \
    _SplayParent->RightChild = _SplayChild;          \
    _SplayChild->Parent = _SplayParent;              \
    }

//
//  The Splay function takes as input a pointer to a splay link in a tree
//  and splays the tree.  Its function return value is a pointer to the
//  root of the splayed tree.
//

NTSYSAPI
PRTL_SPLAY_LINKS
NTAPI
RtlSplay (
    PRTL_SPLAY_LINKS Links
    );

//
//  The Delete function takes as input a pointer to a splay link in a tree
//  and deletes that node from the tree.  Its function return value is a
//  pointer to the root of the tree.  If the tree is now empty, the return
//  value is NULL.
//

NTSYSAPI
PRTL_SPLAY_LINKS
NTAPI
RtlDelete (
    PRTL_SPLAY_LINKS Links
    );

//
//  The DeleteNoSplay function takes as input a pointer to a splay link in a tree,
//  the caller's pointer to the root of the tree and deletes that node from the
//  tree.  Upon return the caller's pointer to the root node will correctly point
//  at the root of the tree.
//
//  It operationally differs from RtlDelete only in that it will not splay the tree.
//

NTSYSAPI
VOID
NTAPI
RtlDeleteNoSplay (
    PRTL_SPLAY_LINKS Links,
    PRTL_SPLAY_LINKS *Root
    );

//
//  The SubtreeSuccessor function takes as input a pointer to a splay link
//  in a tree and returns a pointer to the successor of the input node of
//  the substree rooted at the input node.  If there is not a successor, the
//  return value is NULL.
//

NTSYSAPI
PRTL_SPLAY_LINKS
NTAPI
RtlSubtreeSuccessor (
    PRTL_SPLAY_LINKS Links
    );

//
//  The SubtreePredecessor function takes as input a pointer to a splay link
//  in a tree and returns a pointer to the predecessor of the input node of
//  the substree rooted at the input node.  If there is not a predecessor,
//  the return value is NULL.
//

NTSYSAPI
PRTL_SPLAY_LINKS
NTAPI
RtlSubtreePredecessor (
    PRTL_SPLAY_LINKS Links
    );

//
//  The RealSuccessor function takes as input a pointer to a splay link
//  in a tree and returns a pointer to the successor of the input node within
//  the entire tree.  If there is not a successor, the return value is NULL.
//

NTSYSAPI
PRTL_SPLAY_LINKS
NTAPI
RtlRealSuccessor (
    PRTL_SPLAY_LINKS Links
    );

//
//  The RealPredecessor function takes as input a pointer to a splay link
//  in a tree and returns a pointer to the predecessor of the input node
//  within the entire tree.  If there is not a predecessor, the return value
//  is NULL.
//

NTSYSAPI
PRTL_SPLAY_LINKS
NTAPI
RtlRealPredecessor (
    PRTL_SPLAY_LINKS Links
    );


//
//  Define the generic table package.  Note a generic table should really
//  be an opaque type.  We provide routines to manipulate the structure.
//
//  A generic table is package for inserting, deleting, and looking up elements
//  in a table (e.g., in a symbol table).  To use this package the user
//  defines the structure of the elements stored in the table, provides a
//  comparison function, a memory allocation function, and a memory
//  deallocation function.
//
//  Note: the user compare function must impose a complete ordering among
//  all of the elements, and the table does not allow for duplicate entries.
//

//
//  Do not do the following defines if using Avl
//

#ifndef RTL_USE_AVL_TABLES

//
// Add an empty typedef so that functions can reference the
// a pointer to the generic table struct before it is declared.
//

struct _RTL_GENERIC_TABLE;

//
//  The comparison function takes as input pointers to elements containing
//  user defined structures and returns the results of comparing the two
//  elements.
//

typedef
RTL_GENERIC_COMPARE_RESULTS
(NTAPI *PRTL_GENERIC_COMPARE_ROUTINE) (
    struct _RTL_GENERIC_TABLE *Table,
    PVOID FirstStruct,
    PVOID SecondStruct
    );

//
//  The allocation function is called by the generic table package whenever
//  it needs to allocate memory for the table.
//

typedef
PVOID
(NTAPI *PRTL_GENERIC_ALLOCATE_ROUTINE) (
    struct _RTL_GENERIC_TABLE *Table,
    CLONG ByteSize
    );

//
//  The deallocation function is called by the generic table package whenever
//  it needs to deallocate memory from the table that was allocated by calling
//  the user supplied allocation function.
//

typedef
VOID
(NTAPI *PRTL_GENERIC_FREE_ROUTINE) (
    struct _RTL_GENERIC_TABLE *Table,
    PVOID Buffer
    );

//
//  To use the generic table package the user declares a variable of type
//  GENERIC_TABLE and then uses the routines described below to initialize
//  the table and to manipulate the table.  Note that the generic table
//  should really be an opaque type.
//

typedef struct _RTL_GENERIC_TABLE {
    PRTL_SPLAY_LINKS TableRoot;
    LIST_ENTRY InsertOrderList;
    PLIST_ENTRY OrderedPointer;
    ULONG WhichOrderedElement;
    ULONG NumberGenericTableElements;
    PRTL_GENERIC_COMPARE_ROUTINE CompareRoutine;
    PRTL_GENERIC_ALLOCATE_ROUTINE AllocateRoutine;
    PRTL_GENERIC_FREE_ROUTINE FreeRoutine;
    PVOID TableContext;
} RTL_GENERIC_TABLE;
typedef RTL_GENERIC_TABLE *PRTL_GENERIC_TABLE;

//
//  The procedure InitializeGenericTable takes as input an uninitialized
//  generic table variable and pointers to the three user supplied routines.
//  This must be called for every individual generic table variable before
//  it can be used.
//

NTSYSAPI
VOID
NTAPI
RtlInitializeGenericTable (
    PRTL_GENERIC_TABLE Table,
    PRTL_GENERIC_COMPARE_ROUTINE CompareRoutine,
    PRTL_GENERIC_ALLOCATE_ROUTINE AllocateRoutine,
    PRTL_GENERIC_FREE_ROUTINE FreeRoutine,
    PVOID TableContext
    );

//
//  The function InsertElementGenericTable will insert a new element
//  in a table.  It does this by allocating space for the new element
//  (this includes splay links), inserting the element in the table, and
//  then returning to the user a pointer to the new element.  If an element
//  with the same key already exists in the table the return value is a pointer
//  to the old element.  The optional output parameter NewElement is used
//  to indicate if the element previously existed in the table.  Note: the user
//  supplied Buffer is only used for searching the table, upon insertion its
//  contents are copied to the newly created element.  This means that
//  pointer to the input buffer will not point to the new element.
//

NTSYSAPI
PVOID
NTAPI
RtlInsertElementGenericTable (
    PRTL_GENERIC_TABLE Table,
    PVOID Buffer,
    CLONG BufferSize,
    PBOOLEAN NewElement OPTIONAL
    );

//
//  The function InsertElementGenericTableFull will insert a new element
//  in a table.  It does this by allocating space for the new element
//  (this includes splay links), inserting the element in the table, and
//  then returning to the user a pointer to the new element.  If an element
//  with the same key already exists in the table the return value is a pointer
//  to the old element.  The optional output parameter NewElement is used
//  to indicate if the element previously existed in the table.  Note: the user
//  supplied Buffer is only used for searching the table, upon insertion its
//  contents are copied to the newly created element.  This means that
//  pointer to the input buffer will not point to the new element.
//  This routine is passed the NodeOrParent and SearchResult from a
//  previous RtlLookupElementGenericTableFull.
//

NTSYSAPI
PVOID
NTAPI
RtlInsertElementGenericTableFull (
    PRTL_GENERIC_TABLE Table,
    PVOID Buffer,
    CLONG BufferSize,
    PBOOLEAN NewElement OPTIONAL,
    PVOID NodeOrParent,
    TABLE_SEARCH_RESULT SearchResult
    );

//
//  The function DeleteElementGenericTable will find and delete an element
//  from a generic table.  If the element is located and deleted the return
//  value is TRUE, otherwise if the element is not located the return value
//  is FALSE.  The user supplied input buffer is only used as a key in
//  locating the element in the table.
//

NTSYSAPI
BOOLEAN
NTAPI
RtlDeleteElementGenericTable (
    PRTL_GENERIC_TABLE Table,
    PVOID Buffer
    );

//
//  The function LookupElementGenericTable will find an element in a generic
//  table.  If the element is located the return value is a pointer to
//  the user defined structure associated with the element, otherwise if
//  the element is not located the return value is NULL.  The user supplied
//  input buffer is only used as a key in locating the element in the table.
//

NTSYSAPI
PVOID
NTAPI
RtlLookupElementGenericTable (
    PRTL_GENERIC_TABLE Table,
    PVOID Buffer
    );

//
//  The function LookupElementGenericTableFull will find an element in a generic
//  table.  If the element is located the return value is a pointer to
//  the user defined structure associated with the element.  If the element is not
//  located then a pointer to the parent for the insert location is returned.  The
//  user must look at the SearchResult value to determine which is being returned.
//  The user can use the SearchResult and parent for a subsequent FullInsertElement
//  call to optimize the insert.
//

NTSYSAPI
PVOID
NTAPI
RtlLookupElementGenericTableFull (
    PRTL_GENERIC_TABLE Table,
    PVOID Buffer,
    OUT PVOID *NodeOrParent,
    OUT TABLE_SEARCH_RESULT *SearchResult
    );

//
//  The function EnumerateGenericTable will return to the caller one-by-one
//  the elements of of a table.  The return value is a pointer to the user
//  defined structure associated with the element.  The input parameter
//  Restart indicates if the enumeration should start from the beginning
//  or should return the next element.  If the are no more new elements to
//  return the return value is NULL.  As an example of its use, to enumerate
//  all of the elements in a table the user would write:
//
//      for (ptr = EnumerateGenericTable(Table, TRUE);
//           ptr != NULL;
//           ptr = EnumerateGenericTable(Table, FALSE)) {
//              :
//      }
//
//
//  PLEASE NOTE:
//
//      If you enumerate a GenericTable using RtlEnumerateGenericTable, you
//      will flatten the table, turning it into a sorted linked list.
//      To enumerate the table without perturbing the splay links, use
//      RtlEnumerateGenericTableWithoutSplaying

NTSYSAPI
PVOID
NTAPI
RtlEnumerateGenericTable (
    PRTL_GENERIC_TABLE Table,
    BOOLEAN Restart
    );

//
//  The function EnumerateGenericTableWithoutSplaying will return to the
//  caller one-by-one the elements of of a table.  The return value is a
//  pointer to the user defined structure associated with the element.
//  The input parameter RestartKey indicates if the enumeration should
//  start from the beginning or should return the next element.  If the
//  are no more new elements to return the return value is NULL.  As an
//  example of its use, to enumerate all of the elements in a table the
//  user would write:
//
//      RestartKey = NULL;
//      for (ptr = EnumerateGenericTableWithoutSplaying(Table, &RestartKey);
//           ptr != NULL;
//           ptr = EnumerateGenericTableWithoutSplaying(Table, &RestartKey)) {
//              :
//      }
//
//  If RestartKey is NULL, the package will start from the least entry in the
//  table, otherwise it will start from the last entry returned.
//
//
//  Note that unlike RtlEnumerateGenericTable, this routine will NOT perturb
//  the splay order of the tree.
//

NTSYSAPI
PVOID
NTAPI
RtlEnumerateGenericTableWithoutSplaying (
    PRTL_GENERIC_TABLE Table,
    PVOID *RestartKey
    );

//
// The function GetElementGenericTable will return the i'th element
// inserted in the generic table.  I = 0 implies the first element,
// I = (RtlNumberGenericTableElements(Table)-1) will return the last element
// inserted into the generic table.  The type of I is ULONG.  Values
// of I > than (NumberGenericTableElements(Table)-1) will return NULL.  If
// an arbitrary element is deleted from the generic table it will cause
// all elements inserted after the deleted element to "move up".

NTSYSAPI
PVOID
NTAPI
RtlGetElementGenericTable(
    PRTL_GENERIC_TABLE Table,
    ULONG I
    );

//
// The function NumberGenericTableElements returns a ULONG value
// which is the number of generic table elements currently inserted
// in the generic table.

NTSYSAPI
ULONG
NTAPI
RtlNumberGenericTableElements(
    PRTL_GENERIC_TABLE Table
    );

//
//  The function IsGenericTableEmpty will return to the caller TRUE if
//  the input table is empty (i.e., does not contain any elements) and
//  FALSE otherwise.
//

NTSYSAPI
BOOLEAN
NTAPI
RtlIsGenericTableEmpty (
    PRTL_GENERIC_TABLE Table
    );

#endif // RTL_USE_AVL_TABLES

// end_ntifs

//
//  Heap Allocator
//

NTSYSAPI
NTSTATUS
NTAPI
RtlInitializeHeapManager(
    VOID
    );

// begin_ntifs

typedef NTSTATUS
(NTAPI * PRTL_HEAP_COMMIT_ROUTINE)(
    IN PVOID Base,
    IN OUT PVOID *CommitAddress,
    IN OUT PSIZE_T CommitSize
    );

typedef struct _RTL_HEAP_PARAMETERS {
    ULONG Length;
    SIZE_T SegmentReserve;
    SIZE_T SegmentCommit;
    SIZE_T DeCommitFreeBlockThreshold;
    SIZE_T DeCommitTotalFreeThreshold;
    SIZE_T MaximumAllocationSize;
    SIZE_T VirtualMemoryThreshold;
    SIZE_T InitialCommit;
    SIZE_T InitialReserve;
    PRTL_HEAP_COMMIT_ROUTINE CommitRoutine;
    SIZE_T Reserved[ 2 ];
} RTL_HEAP_PARAMETERS, *PRTL_HEAP_PARAMETERS;

NTSYSAPI
PVOID
NTAPI
RtlCreateHeap(
    IN ULONG Flags,
    IN PVOID HeapBase OPTIONAL,
    IN SIZE_T ReserveSize OPTIONAL,
    IN SIZE_T CommitSize OPTIONAL,
    IN PVOID Lock OPTIONAL,
    IN PRTL_HEAP_PARAMETERS Parameters OPTIONAL
    );

//
// XONLINE
//

// #define HEAP_NO_SERIALIZE               0x00000001      // winnt

//
// end XONLINE
//
#define HEAP_GROWABLE                   0x00000002      // winnt
#define HEAP_GENERATE_EXCEPTIONS        0x00000004      // winnt
#define HEAP_ZERO_MEMORY                0x00000008      // winnt
#define HEAP_REALLOC_IN_PLACE_ONLY      0x00000010      // winnt
#define HEAP_TAIL_CHECKING_ENABLED      0x00000020      // winnt
#define HEAP_FREE_CHECKING_ENABLED      0x00000040      // winnt
#define HEAP_DISABLE_COALESCE_ON_FREE   0x00000080      // winnt

#define HEAP_CREATE_ALIGN_16            0x00010000      // winnt Create heap with 16 byte alignment (obsolete)
#define HEAP_CREATE_ENABLE_TRACING      0x00020000      // winnt Create heap call tracing enabled (obsolete)

#define HEAP_SETTABLE_USER_VALUE        0x00000100
#define HEAP_SETTABLE_USER_FLAG1        0x00000200
#define HEAP_SETTABLE_USER_FLAG2        0x00000400
#define HEAP_SETTABLE_USER_FLAG3        0x00000800
#define HEAP_SETTABLE_USER_FLAGS        0x00000E00

#define HEAP_CLASS_0                    0x00000000      // process heap
#define HEAP_CLASS_1                    0x00001000      // private heap
#define HEAP_CLASS_2                    0x00002000      // Kernel Heap
#define HEAP_CLASS_3                    0x00003000      // GDI heap
#define HEAP_CLASS_4                    0x00004000      // User heap
#define HEAP_CLASS_5                    0x00005000      // Console heap
#define HEAP_CLASS_6                    0x00006000      // User Desktop heap
#define HEAP_CLASS_7                    0x00007000      // Csrss Shared heap
#define HEAP_CLASS_8                    0x00008000      // Csr Port heap
#define HEAP_CLASS_MASK                 0x0000F000

#define HEAP_MAXIMUM_TAG                0x0FFF              // winnt
#define HEAP_GLOBAL_TAG                 0x0800
#define HEAP_PSEUDO_TAG_FLAG            0x8000              // winnt
#define HEAP_TAG_SHIFT                  18                  // winnt

//
// XONLINE
//

// #define HEAP_MAKE_TAG_FLAGS( b, o ) ((ULONG)((b) + ((o) << 18)))  // winnt

//
// end XONLINE
// 
#define HEAP_TAG_MASK                  (HEAP_MAXIMUM_TAG << HEAP_TAG_SHIFT)

#define HEAP_CREATE_VALID_MASK         (HEAP_NO_SERIALIZE |             \
                                        HEAP_GROWABLE |                 \
                                        HEAP_GENERATE_EXCEPTIONS |      \
                                        HEAP_ZERO_MEMORY |              \
                                        HEAP_REALLOC_IN_PLACE_ONLY |    \
                                        HEAP_TAIL_CHECKING_ENABLED |    \
                                        HEAP_FREE_CHECKING_ENABLED |    \
                                        HEAP_DISABLE_COALESCE_ON_FREE | \
                                        HEAP_CLASS_MASK |               \
                                        HEAP_CREATE_ALIGN_16 |          \
                                        HEAP_CREATE_ENABLE_TRACING)

NTSYSAPI
PVOID
NTAPI
RtlDestroyHeap(
    IN PVOID HeapHandle
    );

NTSYSAPI
PVOID
NTAPI
RtlAllocateHeap(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN SIZE_T Size
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlFreeHeap(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress
    );

// end_ntifs

NTSYSAPI
SIZE_T
NTAPI
RtlSizeHeap(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlZeroHeap(
    IN PVOID HeapHandle,
    IN ULONG Flags
    );

NTSYSAPI
VOID
NTAPI
RtlProtectHeap(
    IN PVOID HeapHandle,
    IN BOOLEAN MakeReadOnly
    );

//
// See NTURTL.H for remaining, user mode only heap functions.
//

//
// The types PACQUIRE_LOCK_ROUTINE and PRELEASE_LOCK_ROUTINE are prototypes
// for routines to acquire and release locks in kernel and user mode.
//

typedef
NTSTATUS
(NTAPI *PRTL_INITIALIZE_LOCK_ROUTINE) (
    PVOID Lock
    );

typedef
NTSTATUS
(NTAPI *PRTL_ACQUIRE_LOCK_ROUTINE) (
    PVOID Lock
    );

typedef
NTSTATUS
(NTAPI *PRTL_RELEASE_LOCK_ROUTINE) (
    PVOID Lock
    );

typedef
NTSTATUS
(NTAPI *PRTL_DELETE_LOCK_ROUTINE) (
    PVOID Lock
    );

typedef
BOOLEAN
(NTAPI *PRTL_OKAY_TO_LOCK_ROUTINE) (
    IN PVOID Lock
    );

NTSYSAPI
ULONG
NTAPI
RtlGetNtGlobalFlags(
    VOID
    );


//
//  Functions to capture a stack back trace
//
// begin_ntddk begin_nthal begin_ntifs begin_ntndis

#if defined (_MSC_VER) && ( _MSC_VER >= 900 )

PVOID
_ReturnAddress (
    VOID
    );

#pragma intrinsic(_ReturnAddress)

#endif

#if (defined(_M_AMD64) || defined(_M_IA64)) && !defined(_REALLY_GET_CALLERS_CALLER_)

#define RtlGetCallersAddress(CallersAddress, CallersCaller) \
    *CallersAddress = (PVOID)_ReturnAddress(); \
    *CallersCaller = NULL;

#else

NTSYSAPI
VOID
NTAPI
RtlGetCallersAddress(
    OUT PVOID *CallersAddress,
    OUT PVOID *CallersCaller
    );

#endif

NTSYSAPI
ULONG
NTAPI
RtlWalkFrameChain (
    OUT PVOID *Callers,
    IN ULONG Count,
    IN ULONG Flags
    );

// end_ntddk end_nthal end_ntifs end_ntndis

NTSYSAPI
USHORT
NTAPI
RtlLogStackBackTrace(
    VOID
    );

// begin_winnt

NTSYSAPI
VOID
NTAPI
RtlCaptureContext (
    OUT PCONTEXT ContextRecord
    );

// end_winnt

NTSYSAPI
USHORT
NTAPI
RtlCaptureStackBackTrace(
   IN ULONG FramesToSkip,
   IN ULONG FramesToCapture,
   OUT PVOID *BackTrace,
   OUT PULONG BackTraceHash OPTIONAL
   );

#define MAX_STACK_DEPTH 32

typedef struct _RTL_PROCESS_BACKTRACE_INFORMATION {
    PCHAR SymbolicBackTrace;        // Not filled in
    ULONG TraceCount;
    USHORT Index;
    USHORT Depth;
    PVOID BackTrace[ MAX_STACK_DEPTH ];
} RTL_PROCESS_BACKTRACE_INFORMATION, *PRTL_PROCESS_BACKTRACE_INFORMATION;

typedef struct _RTL_PROCESS_BACKTRACES {
    ULONG CommittedMemory;
    ULONG ReservedMemory;
    ULONG NumberOfBackTraceLookups;
    ULONG NumberOfBackTraces;
    RTL_PROCESS_BACKTRACE_INFORMATION BackTraces[ 1 ];
} RTL_PROCESS_BACKTRACES, *PRTL_PROCESS_BACKTRACES;

//
// Capture stack context
//

typedef struct _RTL_STACK_CONTEXT_ENTRY {

    ULONG_PTR Address; // stack address
    ULONG_PTR Data;    // stack contents

} RTL_STACK_CONTEXT_ENTRY, * PRTL_STACK_CONTEXT_ENTRY;

typedef struct _RTL_STACK_CONTEXT {

    ULONG NumberOfEntries;
    RTL_STACK_CONTEXT_ENTRY Entry[1];

} RTL_STACK_CONTEXT, * PRTL_STACK_CONTEXT;

NTSYSAPI
ULONG
NTAPI
RtlCaptureStackContext (
    OUT PULONG_PTR Callers,
    OUT PRTL_STACK_CONTEXT Context,
    IN ULONG Limit
    );

//
// Trace database support (User/Kernel mode).
//

#define RTL_TRACE_IN_USER_MODE       0x00000001
#define RTL_TRACE_IN_KERNEL_MODE     0x00000002
#define RTL_TRACE_USE_NONPAGED_POOL  0x00000004
#define RTL_TRACE_USE_PAGED_POOL     0x00000008

//
// RTL_TRACE_BLOCK
//

typedef struct _RTL_TRACE_BLOCK {

    ULONG Magic;
    ULONG Count;
    ULONG Size;

    SIZE_T UserCount;
    SIZE_T UserSize;
    PVOID UserContext;

    struct _RTL_TRACE_BLOCK * Next;
    PVOID * Trace;

} RTL_TRACE_BLOCK, * PRTL_TRACE_BLOCK;

//
// RTL_TRACE_HASH_FUNCTION
//

typedef ULONG (* RTL_TRACE_HASH_FUNCTION) (ULONG Count, PVOID * Trace);

//
// RTL_TRACE_DATABASE
//

typedef struct _RTL_TRACE_DATABASE * PRTL_TRACE_DATABASE;

//
// RTL_TRACE_ENUMERATE
//

typedef struct _RTL_TRACE_ENUMERATE {

    PRTL_TRACE_DATABASE Database;
    ULONG Index;
    PRTL_TRACE_BLOCK Block;

} RTL_TRACE_ENUMERATE, * PRTL_TRACE_ENUMERATE;

//
// Trace database interfaces
//

PRTL_TRACE_DATABASE
RtlTraceDatabaseCreate (
    IN ULONG Buckets,
    IN SIZE_T MaximumSize OPTIONAL,
    IN ULONG Flags, // OPTIONAL in User mode
    IN ULONG Tag,   // OPTIONAL in User mode
    IN RTL_TRACE_HASH_FUNCTION HashFunction OPTIONAL
    );

BOOLEAN
RtlTraceDatabaseDestroy (
    IN PRTL_TRACE_DATABASE Database
    );

BOOLEAN
RtlTraceDatabaseValidate (
    IN PRTL_TRACE_DATABASE Database
    );

BOOLEAN
RtlTraceDatabaseAdd (
    IN PRTL_TRACE_DATABASE Database,
    IN ULONG Count,
    IN PVOID * Trace,
    OUT PRTL_TRACE_BLOCK * TraceBlock OPTIONAL
    );

BOOLEAN
RtlTraceDatabaseFind (
    PRTL_TRACE_DATABASE Database,
    IN ULONG Count,
    IN PVOID * Trace,
    OUT PRTL_TRACE_BLOCK * TraceBlock OPTIONAL
    );

BOOLEAN
RtlTraceDatabaseEnumerate (
    PRTL_TRACE_DATABASE Database,
    OUT PRTL_TRACE_ENUMERATE Enumerate,
    OUT PRTL_TRACE_BLOCK * TraceBlock
    );

VOID
RtlTraceDatabaseLock (
    IN PRTL_TRACE_DATABASE Database
    );

VOID
RtlTraceDatabaseUnlock (
    IN PRTL_TRACE_DATABASE Database
    );



#if defined(_IA64_)

VOID
RtlCopyIa64FloatRegisterContext(
    IN PFLOAT128 Destination,
    IN PFLOAT128 Source,
    IN ULONGLONG Length
    );

VOID
RtlpCaptureRnats (
   IN OUT PCONTEXT ContextRecord
   );

#if !defined(MIDL_PASS)

FORCEINLINE
ULONGLONG
RtlpRseShrinkByNumber(
    ULONGLONG Bsp,
    LONGLONG NumReg
    )
 /*++

 Routine Description:

    This function calculates a new bsp by shrinking the current frame
    by a given number.

    Algorithm:

     a new bsp = (bsp - num_registers*8 - ((62 - bsp [8:3] + num_registers)/63)*8)

     (62 - bsp [8:3] + numbers)/63 could be translated to:
        if ((62 - bsp [8:3] + num_registers) >= 63) then 1 extra shrink
        if (((62 - bsp [8:3] + num_registers) - 63) >= 63) then 2 extra shrink
        otherwise 0 bsp shrink

     ((62 - bsp [8:3] + num_register) >= 63) is equal to (num_registers - bsp [8:3] > 0)
     (((62 - bsp [8:3] + num_registers) - 63) >= 63) is equal to (num_registers - bsp [8:3] > 63)

    therefore,

       if (number_registers - bsp [8:3] > 0) then bsp - num_registers*8 - 1*8
       if (number_registers - bsp [8:3] > 63) then bsp - num_registers*8 - 2*8
       otherwise bsp - num_registers*8

  Arguments:

     Bsp - Supplies the BSP value

     NumReg - Supplies the number of register to shrink

  Return Value:

     A new BSP value is returned.

 --*/
 {
     ULONGLONG NewBsp;
     IA64_BSP TempBsp;
     LONGLONG Bsp83;

     TempBsp.ull = Bsp;
     NewBsp = Bsp - (NumReg << 3);
     Bsp83 = (LONGLONG)TempBsp.sb.bsp83;
     if ((NumReg - Bsp83) > 0) {
         NewBsp -= 8;
     }
     if ((NumReg - Bsp83) > 63) {
         NewBsp -= 8;
     }
     return NewBsp;
 }

FORCEINLINE
ULONGLONG
RtlpRseGrowByNumber(
    ULONGLONG Bsp,
    LONGLONG NumReg
    )
 /*++

 Routine Description:

     This function calculates a new BSP by growing the current frame by
     the SOF (Size of Frame) of a given frame maker.

 Algorithm:

     a new bsp = (bsp + (num_registers*8) + ((bsp [8:3] + num_registers)/63)*8)

     (bsp [8:3] + num_registers)/63 could be translated to:

        if bsp [8:3] + num_registers >= 63 then grows 1 extra
        if bsp [8:3] + num_registers >= 126 then grows 2 extra
        otherwise grows 0 extra

 Arguments:

     Bsp - Supplies the BSP value

     NumReg - Supplies the number of register to grow

 Return Value:

     A new BSP value is returned.

 --*/
{
    ULONGLONG NewBsp;
    IA64_BSP TempBsp;
     LONGLONG Bsp83;

    TempBsp.ull = Bsp;
    NewBsp = Bsp + (NumReg << 3);
    Bsp83 = (LONGLONG)TempBsp.sb.bsp83;
    if ((NumReg + Bsp83) >= 63) {
        NewBsp += 8;
    }
    if ((NumReg + Bsp83) >= 126) {
        NewBsp += 8;
    }
    return NewBsp;
}

FORCEINLINE
ULONGLONG
RtlpRseShrinkBySOF (
    ULONGLONG BSP,
    ULONGLONG PFS
    )
{
    IA64_PFS TempPfs;

    TempPfs.ull = PFS;
    return RtlpRseShrinkByNumber(BSP, TempPfs.sb.pfs_sof);
}

FORCEINLINE
ULONGLONG
RtlpRseShrinkBySOL (
    ULONGLONG BSP,
    ULONGLONG PFS
    )
{
    IA64_PFS TempPfs;
    TempPfs.ull = PFS;
    return RtlpRseShrinkByNumber(BSP, TempPfs.sb.pfs_sol);
}

FORCEINLINE
ULONGLONG
RtlpRseGrowBySOF (
    ULONGLONG BSP,
    ULONGLONG PFS
    )
{
    IA64_PFS TempPfs;
    TempPfs.ull = PFS ;
    return RtlpRseGrowByNumber(BSP, TempPfs.sb.pfs_sof);
}

FORCEINLINE
ULONGLONG
RtlpRseGrowBySOL (
    ULONGLONG BSP,
    ULONGLONG PFS
    )
{
    IA64_PFS TempPfs;
    TempPfs.ull = PFS;
    return RtlpRseGrowByNumber(BSP, TempPfs.sb.pfs_sol);
 }

FORCEINLINE
ULONGLONG
RtlpRseRNatCollectOffset(
    ULONGLONG BSP
    )
{
    IA64_BSP TempBsp;
    TempBsp.ull = BSP;
    return (TempBsp.sb.bsp83);
}

FORCEINLINE
PULONGLONG
RtlpRseRNatAddress(
    ULONGLONG BSP
    )
{
    IA64_BSP TempBsp;
    TempBsp.ull = BSP;
    TempBsp.sb.bsp83 = 63;
    return ((PULONGLONG)TempBsp.ull);
}

#endif // MIDL_PASS

#endif // _IA64_

//
// Subroutines for dealing with Win32 ATOMs.  Used by kernel mode window
// manager and user mode implementation of Win32 ATOM API calls in KERNEL32
//

#define RTL_ATOM_MAXIMUM_INTEGER_ATOM   (RTL_ATOM)0xC000
#define RTL_ATOM_INVALID_ATOM           (RTL_ATOM)0x0000
#define RTL_ATOM_TABLE_DEFAULT_NUMBER_OF_BUCKETS 37
#define RTL_ATOM_MAXIMUM_NAME_LENGTH    255
#define RTL_ATOM_PINNED 0x01

NTSYSAPI
NTSTATUS
NTAPI
RtlInitializeAtomPackage(
    IN ULONG AllocationTag
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateAtomTable(
    IN ULONG NumberOfBuckets,
    OUT PVOID *AtomTableHandle
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlDestroyAtomTable(
    IN PVOID AtomTableHandle
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlEmptyAtomTable(
    IN PVOID AtomTableHandle,
    IN BOOLEAN IncludePinnedAtoms
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlAddAtomToAtomTable(
    IN PVOID AtomTableHandle,
    IN PWSTR AtomName OPTIONAL,
    IN OUT PRTL_ATOM Atom OPTIONAL
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlLookupAtomInAtomTable(
    IN PVOID AtomTableHandle,
    IN PWSTR AtomName,
    OUT PRTL_ATOM Atom OPTIONAL
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlDeleteAtomFromAtomTable(
    IN PVOID AtomTableHandle,
    IN RTL_ATOM Atom
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlPinAtomInAtomTable(
    IN PVOID AtomTableHandle,
    IN RTL_ATOM Atom
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlQueryAtomInAtomTable(
    IN PVOID AtomTableHandle,
    IN RTL_ATOM Atom,
    OUT PULONG AtomUsage OPTIONAL,
    OUT PULONG AtomFlags OPTIONAL,
    IN OUT PWSTR AtomName OPTIONAL,
    IN OUT PULONG AtomNameLength OPTIONAL
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlQueryAtomsInAtomTable(
    IN PVOID AtomTableHandle,
    IN ULONG MaximumNumberOfAtoms,
    OUT PULONG NumberOfAtoms,
    OUT PRTL_ATOM Atoms
    );


// begin_ntddk begin_wdm begin_nthal
//
// Subroutines for dealing with the Registry
//
// end_ntddk end_wdm end_nthal

NTSYSAPI
BOOLEAN
NTAPI
RtlGetNtProductType(
    PNT_PRODUCT_TYPE    NtProductType
    );


NTSYSAPI
NTSTATUS
NTAPI
RtlFormatCurrentUserKeyPath (
    OUT PUNICODE_STRING CurrentUserKeyPath
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlOpenCurrentUser(
    IN ULONG DesiredAccess,
    OUT PHANDLE CurrentUserKey
    );

// begin_ntddk begin_wdm begin_nthal begin_ntifs

typedef NTSTATUS (NTAPI * PRTL_QUERY_REGISTRY_ROUTINE)(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    );

typedef struct _RTL_QUERY_REGISTRY_TABLE {
    PRTL_QUERY_REGISTRY_ROUTINE QueryRoutine;
    ULONG Flags;
    PWSTR Name;
    PVOID EntryContext;
    ULONG DefaultType;
    PVOID DefaultData;
    ULONG DefaultLength;

} RTL_QUERY_REGISTRY_TABLE, *PRTL_QUERY_REGISTRY_TABLE;


//
// The following flags specify how the Name field of a RTL_QUERY_REGISTRY_TABLE
// entry is interpreted.  A NULL name indicates the end of the table.
//

#define RTL_QUERY_REGISTRY_SUBKEY   0x00000001  // Name is a subkey and remainder of
                                                // table or until next subkey are value
                                                // names for that subkey to look at.

#define RTL_QUERY_REGISTRY_TOPKEY   0x00000002  // Reset current key to original key for
                                                // this and all following table entries.

#define RTL_QUERY_REGISTRY_REQUIRED 0x00000004  // Fail if no match found for this table
                                                // entry.

#define RTL_QUERY_REGISTRY_NOVALUE  0x00000008  // Used to mark a table entry that has no
                                                // value name, just wants a call out, not
                                                // an enumeration of all values.

#define RTL_QUERY_REGISTRY_NOEXPAND 0x00000010  // Used to suppress the expansion of
                                                // REG_MULTI_SZ into multiple callouts or
                                                // to prevent the expansion of environment
                                                // variable values in REG_EXPAND_SZ

#define RTL_QUERY_REGISTRY_DIRECT   0x00000020  // QueryRoutine field ignored.  EntryContext
                                                // field points to location to store value.
                                                // For null terminated strings, EntryContext
                                                // points to UNICODE_STRING structure that
                                                // that describes maximum size of buffer.
                                                // If .Buffer field is NULL then a buffer is
                                                // allocated.
                                                //

#define RTL_QUERY_REGISTRY_DELETE   0x00000040  // Used to delete value keys after they
                                                // are queried.

NTSYSAPI
NTSTATUS
NTAPI
RtlQueryRegistryValues(
    IN ULONG RelativeTo,
    IN PCWSTR Path,
    IN PRTL_QUERY_REGISTRY_TABLE QueryTable,
    IN PVOID Context,
    IN PVOID Environment OPTIONAL
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlWriteRegistryValue(
    IN ULONG RelativeTo,
    IN PCWSTR Path,
    IN PCWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlDeleteRegistryValue(
    IN ULONG RelativeTo,
    IN PCWSTR Path,
    IN PCWSTR ValueName
    );

// end_wdm

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateRegistryKey(
    IN ULONG RelativeTo,
    IN PWSTR Path
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlCheckRegistryKey(
    IN ULONG RelativeTo,
    IN PWSTR Path
    );

// begin_wdm
//
// The following values for the RelativeTo parameter determine what the
// Path parameter to RtlQueryRegistryValues is relative to.
//

#define RTL_REGISTRY_ABSOLUTE     0   // Path is a full path
#define RTL_REGISTRY_SERVICES     1   // \Registry\Machine\System\CurrentControlSet\Services
#define RTL_REGISTRY_CONTROL      2   // \Registry\Machine\System\CurrentControlSet\Control
#define RTL_REGISTRY_WINDOWS_NT   3   // \Registry\Machine\Software\Microsoft\Windows NT\CurrentVersion
#define RTL_REGISTRY_DEVICEMAP    4   // \Registry\Machine\Hardware\DeviceMap
#define RTL_REGISTRY_USER         5   // \Registry\User\CurrentUser
#define RTL_REGISTRY_MAXIMUM      6
#define RTL_REGISTRY_HANDLE       0x40000000    // Low order bits are registry handle
#define RTL_REGISTRY_OPTIONAL     0x80000000    // Indicates the key node is optional

// end_ntddk end_wdm end_nthal end_ntifs

//
//  Some simple Rtl routines for random number and
//  hexadecimal conversion
//

//
// XONLINE
//
#if 0
NTSYSAPI
ULONG
NTAPI
RtlUniform (
    PULONG Seed
    );
#endif
//
// end XONLINE
//
NTSYSAPI                                            // ntifs
ULONG                                               // ntifs
NTAPI                                               // ntifs
RtlRandom (                                         // ntifs
    PULONG Seed                                     // ntifs
    );                                              // ntifs

NTSYSAPI                                            // ntifs
ULONG                                               // ntifs
NTAPI                                               // ntifs
RtlRandomEx (                                         // ntifs
    PULONG Seed                                     // ntifs
    );                                              // ntifs

NTSTATUS
RtlComputeImportTableHash(
    IN  HANDLE hFile,
    IN  PCHAR Hash,
    IN  ULONG ImportTableHashRevision
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlIntegerToChar (
    ULONG Value,
    ULONG Base,
    LONG OutputLength,
    PSZ String
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlIntegerToUnicode (
    IN ULONG Value,
    IN ULONG Base OPTIONAL,
    IN LONG OutputLength,
    OUT PWSTR String
    );


//
// XONLINE
//
#if 0
NTSYSAPI                                            // ntddk ntifs
NTSTATUS                                            // ntddk ntifs
NTAPI                                               // ntddk ntifs
RtlCharToInteger (                                  // ntddk ntifs
    PCSZ String,                                    // ntddk ntifs
    ULONG Base,                                     // ntddk ntifs
    PULONG Value                                    // ntddk ntifs
    );                                              // ntddk ntifs
#endif
//
// end XONLINE
//

NTSYSAPI
NTSTATUS
NTAPI
RtlLargeIntegerToChar (
    PLARGE_INTEGER Value,
    ULONG Base OPTIONAL,
    LONG OutputLength,
    PSZ String
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlLargeIntegerToUnicode (
    IN PLARGE_INTEGER Value,
    IN ULONG Base OPTIONAL,
    IN LONG OutputLength,
    OUT PWSTR String
    );

// begin_ntosp

//
//  Some simple Rtl routines for IP address <-> string literal conversion
//

struct in_addr;
struct in6_addr;

NTSYSAPI
PSTR
NTAPI
RtlIpv4AddressToStringA (
    IN const struct in_addr *Addr,
    OUT PSTR S
    );

NTSYSAPI
PSTR
NTAPI
RtlIpv6AddressToStringA (
    IN const struct in6_addr *Addr,
    OUT PSTR S
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlIpv4AddressToStringExA(
    IN const struct in_addr *Address,
    IN USHORT Port,
    OUT PSTR AddressString,
    IN OUT PULONG AddressStringLength
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlIpv6AddressToStringExA(
    IN const struct in6_addr *Address,
    IN ULONG ScopeId,
    IN USHORT Port,
    OUT PSTR AddressString,
    IN OUT PULONG AddressStringLength
    );

NTSYSAPI
PWSTR
NTAPI
RtlIpv4AddressToStringW (
    IN const struct in_addr *Addr,
    OUT PWSTR S
    );

NTSYSAPI
PWSTR
NTAPI
RtlIpv6AddressToStringW (
    IN const struct in6_addr *Addr,
    OUT PWSTR S
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlIpv4AddressToStringExW(
    IN const struct in_addr *Address,
    IN USHORT Port,
    OUT PWSTR AddressString,
    IN OUT PULONG AddressStringLength
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlIpv6AddressToStringExW(
    IN const struct in6_addr *Address,
    IN ULONG ScopeId,
    IN USHORT Port,
    OUT PWSTR AddressString,
    IN OUT PULONG AddressStringLength
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlIpv4StringToAddressA (
    IN PCSTR S,
    IN BOOLEAN Strict,
    OUT PCSTR *Terminator,
    OUT struct in_addr *Addr
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlIpv6StringToAddressA (
    IN PCSTR S,
    OUT PCSTR *Terminator,
    OUT struct in6_addr *Addr
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlIpv4StringToAddressExA (
    IN PCSTR AddressString,
    IN BOOLEAN Strict,
    OUT struct in_addr *Address,
    OUT PUSHORT Port
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlIpv6StringToAddressExA (
    IN PCSTR AddressString,
    OUT struct in6_addr *Address,
    OUT PULONG ScopeId,
    OUT PUSHORT Port
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlIpv4StringToAddressW (
    IN PCWSTR S,
    IN BOOLEAN Strict,
    OUT LPCWSTR *Terminator,
    OUT struct in_addr *Addr
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlIpv6StringToAddressW (
    IN PCWSTR S,
    OUT PCWSTR *Terminator,
    OUT struct in6_addr *Addr
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlIpv4StringToAddressExW (
    IN PCWSTR AddressString,
    IN BOOLEAN Strict,
    OUT struct in_addr *Address,
    OUT PUSHORT Port
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlIpv6StringToAddressExW (
    IN PCWSTR AddressString,
    OUT struct in6_addr *Address,
    OUT PULONG ScopeId,
    OUT PUSHORT Port
    );

#ifdef UNICODE
#define RtlIpv4AddressToString RtlIpv4AddressToStringW
#define RtlIpv6AddressToString RtlIpv6AddressToStringW
#define RtlIpv4StringToAddress RtlIpv4StringToAddressW
#define RtlIpv6StringToAddress RtlIpv6StringToAddressW
#define RtlIpv6StringToAddressEx RtlIpv6StringToAddressExW
#define RtlIpv4AddressToStringEx RtlIpv4AddressToStringExW
#define RtlIpv6AddressToStringEx RtlIpv6AddressToStringExW
#define RtlIpv4StringToAddressEx RtlIpv4StringToAddressExW
#else
#define RtlIpv4AddressToString RtlIpv4AddressToStringA
#define RtlIpv6AddressToString RtlIpv6AddressToStringA
#define RtlIpv4StringToAddress RtlIpv4StringToAddressA
#define RtlIpv6StringToAddress RtlIpv6StringToAddressA
#define RtlIpv6StringToAddressEx RtlIpv6StringToAddressExA
#define RtlIpv4AddressToStringEx RtlIpv4AddressToStringExA
#define RtlIpv6AddressToStringEx RtlIpv6AddressToStringExA
#define RtlIpv4StringToAddressEx RtlIpv4StringToAddressExA
#endif // UNICODE

// end_ntosp

// begin_ntddk begin_wdm begin_nthal begin_ntifs

NTSYSAPI
NTSTATUS
NTAPI
RtlIntegerToUnicodeString (
    ULONG Value,
    ULONG Base,
    PUNICODE_STRING String
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlInt64ToUnicodeString (
    IN ULONGLONG Value,
    IN ULONG Base OPTIONAL,
    IN OUT PUNICODE_STRING String
    );

#ifdef _WIN64
#define RtlIntPtrToUnicodeString(Value, Base, String) RtlInt64ToUnicodeString(Value, Base, String)
#else
#define RtlIntPtrToUnicodeString(Value, Base, String) RtlIntegerToUnicodeString(Value, Base, String)
#endif

NTSYSAPI
NTSTATUS
NTAPI
RtlUnicodeStringToInteger (
    PCUNICODE_STRING String,
    ULONG Base,
    PULONG Value
    );


//
//  String manipulation routines
//

#ifdef _NTSYSTEM_

#define NLS_MB_CODE_PAGE_TAG NlsMbCodePageTag
#define NLS_MB_OEM_CODE_PAGE_TAG NlsMbOemCodePageTag

#else

#define NLS_MB_CODE_PAGE_TAG (*NlsMbCodePageTag)
#define NLS_MB_OEM_CODE_PAGE_TAG (*NlsMbOemCodePageTag)

#endif // _NTSYSTEM_

extern BOOLEAN NLS_MB_CODE_PAGE_TAG;     // TRUE -> Multibyte CP, FALSE -> Singlebyte
extern BOOLEAN NLS_MB_OEM_CODE_PAGE_TAG; // TRUE -> Multibyte CP, FALSE -> Singlebyte

//
// XONLINE
//
#if 0
NTSYSAPI
VOID
NTAPI
RtlInitString(
    PSTRING DestinationString,
    PCSZ SourceString
    );

NTSYSAPI
VOID
NTAPI
RtlInitAnsiString(
    PANSI_STRING DestinationString,
    PCSZ SourceString
    );


NTSYSAPI
VOID
NTAPI
RtlInitUnicodeString(
    PUNICODE_STRING DestinationString,
    PCWSTR SourceString
    );

#endif
//
// end XONLINE
//

#define RtlInitEmptyUnicodeString(_ucStr,_buf,_bufSize) \
    ((_ucStr)->Buffer = (_buf), \
     (_ucStr)->Length = 0, \
     (_ucStr)->MaximumLength = (USHORT)(_bufSize))

// end_ntddk end_wdm

NTSYSAPI
NTSTATUS
NTAPI
RtlInitUnicodeStringEx(
    PUNICODE_STRING DestinationString,
    PCWSTR SourceString
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlInitAnsiStringEx(
    OUT PANSI_STRING DestinationString,
    IN PCSZ SourceString OPTIONAL
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlCreateUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PCWSTR SourceString
    );

// end_ntifs

NTSYSAPI
BOOLEAN
NTAPI
RtlEqualDomainName(
    IN PCUNICODE_STRING String1,
    IN PCUNICODE_STRING String2
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlEqualComputerName(
    IN PCUNICODE_STRING String1,
    IN PCUNICODE_STRING String2
    );

NTSTATUS
RtlDnsHostNameToComputerName(
    OUT PUNICODE_STRING ComputerNameString,
    IN PCUNICODE_STRING DnsHostNameString,
    IN BOOLEAN AllocateComputerNameString
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlCreateUnicodeStringFromAsciiz(
    OUT PUNICODE_STRING DestinationString,
    IN PCSZ SourceString
    );

// begin_ntddk begin_ntifs

NTSYSAPI
VOID
NTAPI
RtlCopyString(
    PSTRING DestinationString,
    const STRING * SourceString
    );

NTSYSAPI
CHAR
NTAPI
RtlUpperChar (
    CHAR Character
    );

NTSYSAPI
LONG
NTAPI
RtlCompareString(
    const STRING * String1,
    const STRING * String2,
    BOOLEAN CaseInSensitive
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlEqualString(
    const STRING * String1,
    const STRING * String2,
    BOOLEAN CaseInSensitive
    );

// end_ntddk end_ntifs

NTSYSAPI
BOOLEAN
NTAPI
RtlPrefixString(
    const STRING * String1,
    const STRING * String2,
    BOOLEAN CaseInSensitive
    );

// begin_ntddk begin_ntifs

NTSYSAPI
VOID
NTAPI
RtlUpperString(
    PSTRING DestinationString,
    const STRING * SourceString
    );

// end_ntddk end_ntifs

NTSYSAPI
NTSTATUS
NTAPI
RtlAppendAsciizToString (
    PSTRING Destination,
    PCSZ Source
    );

// begin_ntifs

NTSYSAPI
NTSTATUS
NTAPI
RtlAppendStringToString (
    PSTRING Destination,
    const STRING * Source
    );

// begin_ntddk begin_wdm
//
// NLS String functions
//

//
// XONLINE
//
#if 0
NTSYSAPI
NTSTATUS
NTAPI
RtlAnsiStringToUnicodeString(
    PUNICODE_STRING DestinationString,
    PCANSI_STRING SourceString,
    BOOLEAN AllocateDestinationString
    );
#endif
//
// end XONLINE
// 
// end_ntddk end_wdm end_nthal end_ntifs

NTSYSAPI
WCHAR
NTAPI
RtlAnsiCharToUnicodeChar(
    PUCHAR *SourceCharacter
    );

// begin_ntddk begin_wdm begin_nthal begin_ntifs begin_ntndis

//
// XONLINE
//
#if 0
NTSYSAPI
NTSTATUS
NTAPI
RtlUnicodeStringToAnsiString(
    PANSI_STRING DestinationString,
    PCUNICODE_STRING SourceString,
    BOOLEAN AllocateDestinationString
    );
#endif
//
// end XONLINE
//

// end_ntddk end_wdm end_nthal end_ntifs end_ntndis

NTSYSAPI
NTSTATUS
NTAPI
RtlUpcaseUnicodeStringToAnsiString(
    PANSI_STRING DestinationString,
    PCUNICODE_STRING SourceString,
    BOOLEAN AllocateDestinationString
    );

// begin_ntifs

NTSYSAPI
NTSTATUS
NTAPI
RtlOemStringToUnicodeString(
    PUNICODE_STRING DestinationString,
    PCOEM_STRING SourceString,
    BOOLEAN AllocateDestinationString
    );

//
// XONLINE
//
#if 0
NTSYSAPI
NTSTATUS
NTAPI
RtlUnicodeStringToOemString(
    POEM_STRING DestinationString,
    PCUNICODE_STRING SourceString,
    BOOLEAN AllocateDestinationString
    );
#endif 0
//
// end XONLINE
//

NTSYSAPI
NTSTATUS
NTAPI
RtlUpcaseUnicodeStringToOemString(
    POEM_STRING DestinationString,
    PCUNICODE_STRING SourceString,
    BOOLEAN AllocateDestinationString
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlOemStringToCountedUnicodeString(
    PUNICODE_STRING DestinationString,
    PCOEM_STRING SourceString,
    BOOLEAN AllocateDestinationString
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlUnicodeStringToCountedOemString(
    POEM_STRING DestinationString,
    PCUNICODE_STRING SourceString,
    BOOLEAN AllocateDestinationString
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlUpcaseUnicodeStringToCountedOemString(
    POEM_STRING DestinationString,
    PCUNICODE_STRING SourceString,
    BOOLEAN AllocateDestinationString
    );

// begin_ntddk begin_wdm begin_ntndis

NTSYSAPI
LONG
NTAPI
RtlCompareUnicodeString(
    PCUNICODE_STRING String1,
    PCUNICODE_STRING String2,
    BOOLEAN CaseInSensitive
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlEqualUnicodeString(
    PCUNICODE_STRING String1,
    PCUNICODE_STRING String2,
    BOOLEAN CaseInSensitive
    );

#define HASH_STRING_ALGORITHM_DEFAULT   (0)
#define HASH_STRING_ALGORITHM_X65599    (1)
#define HASH_STRING_ALGORITHM_INVALID   (0xffffffff)

NTSYSAPI
NTSTATUS
NTAPI
RtlHashUnicodeString(
    IN const UNICODE_STRING *String,
    IN BOOLEAN CaseInSensitive,
    IN ULONG HashAlgorithm,
    OUT PULONG HashValue
    );

// end_ntddk end_wdm end_ntndis

NTSYSAPI
NTSTATUS
NTAPI
RtlValidateUnicodeString(
    IN ULONG Flags,
    IN const UNICODE_STRING *String
    );

#define RTL_DUPLICATE_UNICODE_STRING_NULL_TERMINATE (0x00000001)
#define RTL_DUPLICATE_UNICODE_STRING_ALLOCATE_NULL_STRING (0x00000002)

NTSYSAPI
NTSTATUS
NTAPI
RtlDuplicateUnicodeString(
    IN ULONG Flags,
    IN const UNICODE_STRING *StringIn,
    OUT UNICODE_STRING *StringOut
    );

// begin_ntddk begin_ntndis

NTSYSAPI
BOOLEAN
NTAPI
RtlPrefixUnicodeString(
    IN PCUNICODE_STRING String1,
    IN PCUNICODE_STRING String2,
    IN BOOLEAN CaseInSensitive
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlUpcaseUnicodeString(
    PUNICODE_STRING DestinationString,
    PCUNICODE_STRING SourceString,
    BOOLEAN AllocateDestinationString
    );

// end_ntddk end_ntifs end_ntndis

#define RTL_FIND_CHAR_IN_UNICODE_STRING_START_AT_END        (0x00000001)
#define RTL_FIND_CHAR_IN_UNICODE_STRING_COMPLEMENT_CHAR_SET (0x00000002)
#define RTL_FIND_CHAR_IN_UNICODE_STRING_CASE_INSENSITIVE    (0x00000004)

NTSYSAPI
NTSTATUS
NTAPI
RtlFindCharInUnicodeString(
    IN ULONG Flags,
    IN PCUNICODE_STRING StringToSearch,
    IN PCUNICODE_STRING CharSet,
    OUT USHORT *NonInclusivePrefixLength
    );

// begin_ntifs

NTSTATUS
RtlDowncaseUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PCUNICODE_STRING SourceString,
    IN BOOLEAN AllocateDestinationString
    );

// end_ntifs

// begin_ntddk begin_wdm begin_nthal begin_ntifs begin_ntndis

NTSYSAPI
VOID
NTAPI
RtlCopyUnicodeString(
    PUNICODE_STRING DestinationString,
    PCUNICODE_STRING SourceString
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlAppendUnicodeStringToString (
    PUNICODE_STRING Destination,
    PCUNICODE_STRING Source
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlAppendUnicodeToString (
    PUNICODE_STRING Destination,
    PCWSTR Source
    );

// end_ntndis end_wdm

NTSYSAPI
WCHAR
NTAPI
RtlUpcaseUnicodeChar(
    WCHAR SourceCharacter
    );

NTSYSAPI
WCHAR
NTAPI
RtlDowncaseUnicodeChar(
    WCHAR SourceCharacter
    );

// begin_wdm

//
// XONLINE
//
#if 0
NTSYSAPI
VOID
NTAPI
RtlFreeUnicodeString(
    PUNICODE_STRING UnicodeString
    );

NTSYSAPI
VOID
NTAPI
RtlFreeAnsiString(
    PANSI_STRING AnsiString
    );

// end_ntddk end_wdm end_nthal

NTSYSAPI
VOID
NTAPI
RtlFreeOemString(
    POEM_STRING OemString
    );
#endif 0
//
// end XONLINE
//

// begin_wdm
NTSYSAPI
ULONG
NTAPI
RtlxUnicodeStringToAnsiSize(
    PCUNICODE_STRING UnicodeString
    );

//
//  NTSYSAPI
//  ULONG
//  NTAPI
//  RtlUnicodeStringToAnsiSize(
//      PUNICODE_STRING UnicodeString
//      );
//

#define RtlUnicodeStringToAnsiSize(STRING) (                  \
    NLS_MB_CODE_PAGE_TAG ?                                    \
    RtlxUnicodeStringToAnsiSize(STRING) :                     \
    ((STRING)->Length + sizeof(UNICODE_NULL)) / sizeof(WCHAR) \
)

// end_wdm

NTSYSAPI
ULONG
NTAPI
RtlxUnicodeStringToOemSize(
    PCUNICODE_STRING UnicodeString
    );

//
//  NTSYSAPI
//  ULONG
//  NTAPI
//  RtlUnicodeStringToOemSize(
//      PUNICODE_STRING UnicodeString
//      );
//

#define RtlUnicodeStringToOemSize(STRING) (                   \
    NLS_MB_OEM_CODE_PAGE_TAG ?                                \
    RtlxUnicodeStringToOemSize(STRING) :                      \
    ((STRING)->Length + sizeof(UNICODE_NULL)) / sizeof(WCHAR) \
)

// end_ntifs

//
//  ULONG
//  RtlUnicodeStringToCountedOemSize(
//      PUNICODE_STRING UnicodeString
//      );
//

#define RtlUnicodeStringToCountedOemSize(STRING) (                   \
    (ULONG)(RtlUnicodeStringToOemSize(STRING) - sizeof(ANSI_NULL)) \
    )

// begin_ntddk begin_wdm begin_ntifs

NTSYSAPI
ULONG
NTAPI
RtlxAnsiStringToUnicodeSize(
    PCANSI_STRING AnsiString
    );

//
//  NTSYSAPI
//  ULONG
//  NTAPI
//  RtlAnsiStringToUnicodeSize(
//      PANSI_STRING AnsiString
//      );
//

#define RtlAnsiStringToUnicodeSize(STRING) (                 \
    NLS_MB_CODE_PAGE_TAG ?                                   \
    RtlxAnsiStringToUnicodeSize(STRING) :                    \
    ((STRING)->Length + sizeof(ANSI_NULL)) * sizeof(WCHAR) \
)

// end_ntddk end_wdm

NTSYSAPI
ULONG
NTAPI
RtlxOemStringToUnicodeSize(
    PCOEM_STRING OemString
    );
//
//  NTSYSAPI
//  ULONG
//  NTAPI
//  RtlOemStringToUnicodeSize(
//      POEM_STRING OemString
//      );
//

#define RtlOemStringToUnicodeSize(STRING) (                  \
    NLS_MB_OEM_CODE_PAGE_TAG ?                               \
    RtlxOemStringToUnicodeSize(STRING) :                     \
    ((STRING)->Length + sizeof(ANSI_NULL)) * sizeof(WCHAR) \
)

//
//  ULONG
//  RtlOemStringToCountedUnicodeSize(
//      POEM_STRING OemString
//      );
//

#define RtlOemStringToCountedUnicodeSize(STRING) (                    \
    (ULONG)(RtlOemStringToUnicodeSize(STRING) - sizeof(UNICODE_NULL)) \
    )

NTSYSAPI
NTSTATUS
NTAPI
RtlMultiByteToUnicodeN(
    PWSTR UnicodeString,
    ULONG MaxBytesInUnicodeString,
    PULONG BytesInUnicodeString,
    PCSTR MultiByteString,
    ULONG BytesInMultiByteString
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlMultiByteToUnicodeSize(
    PULONG BytesInUnicodeString,
    PCSTR MultiByteString,
    ULONG BytesInMultiByteString
    );

//
// XONLINE
//
#if 0
NTSYSAPI
NTSTATUS
NTAPI
RtlUnicodeToMultiByteSize(
    PULONG BytesInMultiByteString,
    IN PWSTR UnicodeString,
    ULONG BytesInUnicodeString
    );
#endif
//
// end XONLINE
//

NTSYSAPI
NTSTATUS
NTAPI
RtlUnicodeToMultiByteN(
    PCHAR MultiByteString,
    ULONG MaxBytesInMultiByteString,
    PULONG BytesInMultiByteString,
    PWSTR UnicodeString,
    ULONG BytesInUnicodeString
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlUpcaseUnicodeToMultiByteN(
    PCHAR MultiByteString,
    ULONG MaxBytesInMultiByteString,
    PULONG BytesInMultiByteString,
    PWSTR UnicodeString,
    ULONG BytesInUnicodeString
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlOemToUnicodeN(
    PWSTR UnicodeString,
    ULONG MaxBytesInUnicodeString,
    PULONG BytesInUnicodeString,
    IN PCHAR OemString,
    ULONG BytesInOemString
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlUnicodeToOemN(
    PCHAR OemString,
    ULONG MaxBytesInOemString,
    PULONG BytesInOemString,
    PWSTR UnicodeString,
    ULONG BytesInUnicodeString
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlUpcaseUnicodeToOemN(
    PCHAR OemString,
    ULONG MaxBytesInOemString,
    PULONG BytesInOemString,
    PWSTR UnicodeString,
    ULONG BytesInUnicodeString
    );

// end_ntifs

NTSYSAPI
NTSTATUS
NTAPI
RtlConsoleMultiByteToUnicodeN(
    OUT PWCH UnicodeString,
    IN ULONG MaxBytesInUnicodeString,
    OUT PULONG BytesInUnicodeString OPTIONAL,
    IN PCH MultiByteString,
    IN ULONG BytesInMultiByteString,
    OUT PULONG pdwSpecialChar );

// begin_winnt

#define IS_TEXT_UNICODE_ASCII16               0x0001
#define IS_TEXT_UNICODE_REVERSE_ASCII16       0x0010

#define IS_TEXT_UNICODE_STATISTICS            0x0002
#define IS_TEXT_UNICODE_REVERSE_STATISTICS    0x0020

#define IS_TEXT_UNICODE_CONTROLS              0x0004
#define IS_TEXT_UNICODE_REVERSE_CONTROLS      0x0040

#define IS_TEXT_UNICODE_SIGNATURE             0x0008
#define IS_TEXT_UNICODE_REVERSE_SIGNATURE     0x0080

#define IS_TEXT_UNICODE_ILLEGAL_CHARS         0x0100
#define IS_TEXT_UNICODE_ODD_LENGTH            0x0200
#define IS_TEXT_UNICODE_DBCS_LEADBYTE         0x0400
#define IS_TEXT_UNICODE_NULL_BYTES            0x1000

#define IS_TEXT_UNICODE_UNICODE_MASK          0x000F
#define IS_TEXT_UNICODE_REVERSE_MASK          0x00F0
#define IS_TEXT_UNICODE_NOT_UNICODE_MASK      0x0F00
#define IS_TEXT_UNICODE_NOT_ASCII_MASK        0xF000

// end_winnt

NTSYSAPI
BOOLEAN
NTAPI
RtlIsTextUnicode(
    IN CONST VOID* Buffer,
    IN ULONG Size,
    IN OUT PULONG Result OPTIONAL
    );

// begin_ntifs

typedef
PVOID
(NTAPI *PRTL_ALLOCATE_STRING_ROUTINE) (
    SIZE_T NumberOfBytes
    );

typedef
VOID
(NTAPI *PRTL_FREE_STRING_ROUTINE) (
    PVOID Buffer
    );

extern const PRTL_ALLOCATE_STRING_ROUTINE RtlAllocateStringRoutine;
extern const PRTL_FREE_STRING_ROUTINE RtlFreeStringRoutine;


//
//  Defines and Routines for handling GUID's.
//

// begin_ntddk begin_wdm begin_nthal

// begin_ntminiport

#include <guiddef.h>

// end_ntminiport

#ifndef DEFINE_GUIDEX
    #define DEFINE_GUIDEX(name) EXTERN_C const CDECL GUID name
#endif // !defined(DEFINE_GUIDEX)

#ifndef STATICGUIDOF
    #define STATICGUIDOF(guid) STATIC_##guid
#endif // !defined(STATICGUIDOF)

#ifndef __IID_ALIGNED__
    #define __IID_ALIGNED__
    #ifdef __cplusplus
        inline int IsEqualGUIDAligned(REFGUID guid1, REFGUID guid2)
        {
            return ((*(PLONGLONG)(&guid1) == *(PLONGLONG)(&guid2)) && (*((PLONGLONG)(&guid1) + 1) == *((PLONGLONG)(&guid2) + 1)));
        }
    #else // !__cplusplus
        #define IsEqualGUIDAligned(guid1, guid2) \
            ((*(PLONGLONG)(guid1) == *(PLONGLONG)(guid2)) && (*((PLONGLONG)(guid1) + 1) == *((PLONGLONG)(guid2) + 1)))
    #endif // !__cplusplus
#endif // !__IID_ALIGNED__

NTSYSAPI
NTSTATUS
NTAPI
RtlStringFromGUID(
    IN REFGUID Guid,
    OUT PUNICODE_STRING GuidString
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlGUIDFromString(
    IN PUNICODE_STRING GuidString,
    OUT GUID* Guid
    );

// end_ntddk end_wdm end_nthal

//
//  Routine for generating 8.3 names from long names.
//

//
//  The context structure is used when generating 8.3 names.  The caller must
//  always zero out the structure before starting a new generation sequence
//

typedef struct _GENERATE_NAME_CONTEXT {

    //
    //  The structure is divided into two strings.  The Name, and extension.
    //  Each part contains the value that was last inserted in the name.
    //  The length values are in terms of wchars and not bytes.  We also
    //  store the last index value used in the generation collision algorithm.
    //

    USHORT Checksum;
    BOOLEAN ChecksumInserted;

    UCHAR NameLength;         // not including extension
    WCHAR NameBuffer[8];      // e.g., "ntoskrnl"

    ULONG ExtensionLength;    // including dot
    WCHAR ExtensionBuffer[4]; // e.g., ".exe"

    ULONG LastIndexValue;

} GENERATE_NAME_CONTEXT;
typedef GENERATE_NAME_CONTEXT *PGENERATE_NAME_CONTEXT;

NTSYSAPI
VOID
NTAPI
RtlGenerate8dot3Name (
    IN PUNICODE_STRING Name,
    IN BOOLEAN AllowExtendedCharacters,
    IN OUT PGENERATE_NAME_CONTEXT Context,
    OUT PUNICODE_STRING Name8dot3
    );

//
// XONLINE
//
#if 0
NTSYSAPI
BOOLEAN
NTAPI
RtlIsNameLegalDOS8Dot3 (
    IN PUNICODE_STRING Name,
    IN OUT POEM_STRING OemName OPTIONAL,
    IN OUT PBOOLEAN NameContainsSpaces OPTIONAL
    );
#endif
//
// end XONLINE
//

BOOLEAN
RtlIsValidOemCharacter (
    IN PWCHAR Char
    );

// end_ntifs

//
//  Thread Context manipulation routines.
//

NTSYSAPI
VOID
NTAPI
RtlInitializeContext(
    HANDLE Process,
    PCONTEXT Context,
    PVOID Parameter,
    PVOID InitialPc,
    PVOID InitialSp
    );


NTSYSAPI
NTSTATUS
NTAPI
RtlRemoteCall(
    HANDLE Process,
    HANDLE Thread,
    PVOID CallSite,
    ULONG ArgumentCount,
    PULONG_PTR Arguments,
    BOOLEAN PassContext,
    BOOLEAN AlreadySuspended
    );


//
// Process/Thread Environment Block allocation functions.
//

NTSYSAPI
VOID
NTAPI
RtlAcquirePebLock(
    VOID
    );

NTSYSAPI
VOID
NTAPI
RtlReleasePebLock(
    VOID
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlAllocateFromPeb(
    ULONG Size,
    PVOID *Block
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlFreeToPeb(
    PVOID Block,
    ULONG Size
    );

NTSYSAPI
NTSTATUS
STDAPIVCALLTYPE
RtlSetProcessIsCritical(
    IN  BOOLEAN  NewValue,
    OUT PBOOLEAN OldValue OPTIONAL,
    IN  BOOLEAN  CheckFlag
    );

NTSYSAPI
NTSTATUS
STDAPIVCALLTYPE
RtlSetThreadIsCritical(
    IN  BOOLEAN  NewValue,
    OUT PBOOLEAN OldValue OPTIONAL,
    IN  BOOLEAN  CheckFlag
    );

//
// Environment Variable API calls
//

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateEnvironment(
    BOOLEAN CloneCurrentEnvironment,
    PVOID *Environment
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlDestroyEnvironment(
    PVOID Environment
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlSetCurrentEnvironment(
    PVOID Environment,
    PVOID *PreviousEnvironment
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlSetEnvironmentVariable(
    PVOID *Environment,
    PCUNICODE_STRING Name,
    PCUNICODE_STRING Value
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlQueryEnvironmentVariable_U (
    PVOID Environment,
    PCUNICODE_STRING Name,
    PUNICODE_STRING Value
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlExpandEnvironmentStrings_U(
    IN PVOID Environment OPTIONAL,
    IN PCUNICODE_STRING Source,
    OUT PUNICODE_STRING Destination,
    OUT PULONG ReturnedLength OPTIONAL
    );

// begin_ntifs
//
//  Prefix package types and procedures.
//
//  Note that the following two record structures should really be opaque
//  to the user of this package.  The only information about the two
//  structures available for the user should be the size and alignment
//  of the structures.
//

typedef struct _PREFIX_TABLE_ENTRY {
    CSHORT NodeTypeCode;
    CSHORT NameLength;
    struct _PREFIX_TABLE_ENTRY *NextPrefixTree;
    RTL_SPLAY_LINKS Links;
    PSTRING Prefix;
} PREFIX_TABLE_ENTRY;
typedef PREFIX_TABLE_ENTRY *PPREFIX_TABLE_ENTRY;

typedef struct _PREFIX_TABLE {
    CSHORT NodeTypeCode;
    CSHORT NameLength;
    PPREFIX_TABLE_ENTRY NextPrefixTree;
} PREFIX_TABLE;
typedef PREFIX_TABLE *PPREFIX_TABLE;

//
//  The procedure prototypes for the prefix package
//

NTSYSAPI
VOID
NTAPI
PfxInitialize (
    PPREFIX_TABLE PrefixTable
    );

NTSYSAPI
BOOLEAN
NTAPI
PfxInsertPrefix (
    PPREFIX_TABLE PrefixTable,
    PSTRING Prefix,
    PPREFIX_TABLE_ENTRY PrefixTableEntry
    );

NTSYSAPI
VOID
NTAPI
PfxRemovePrefix (
    PPREFIX_TABLE PrefixTable,
    PPREFIX_TABLE_ENTRY PrefixTableEntry
    );

NTSYSAPI
PPREFIX_TABLE_ENTRY
NTAPI
PfxFindPrefix (
    PPREFIX_TABLE PrefixTable,
    PSTRING FullName
    );

//
//  The following definitions are for the unicode version of the prefix
//  package.
//

typedef struct _UNICODE_PREFIX_TABLE_ENTRY {
    CSHORT NodeTypeCode;
    CSHORT NameLength;
    struct _UNICODE_PREFIX_TABLE_ENTRY *NextPrefixTree;
    struct _UNICODE_PREFIX_TABLE_ENTRY *CaseMatch;
    RTL_SPLAY_LINKS Links;
    PUNICODE_STRING Prefix;
} UNICODE_PREFIX_TABLE_ENTRY;
typedef UNICODE_PREFIX_TABLE_ENTRY *PUNICODE_PREFIX_TABLE_ENTRY;

typedef struct _UNICODE_PREFIX_TABLE {
    CSHORT NodeTypeCode;
    CSHORT NameLength;
    PUNICODE_PREFIX_TABLE_ENTRY NextPrefixTree;
    PUNICODE_PREFIX_TABLE_ENTRY LastNextEntry;
} UNICODE_PREFIX_TABLE;
typedef UNICODE_PREFIX_TABLE *PUNICODE_PREFIX_TABLE;

NTSYSAPI
VOID
NTAPI
RtlInitializeUnicodePrefix (
    PUNICODE_PREFIX_TABLE PrefixTable
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlInsertUnicodePrefix (
    PUNICODE_PREFIX_TABLE PrefixTable,
    PUNICODE_STRING Prefix,
    PUNICODE_PREFIX_TABLE_ENTRY PrefixTableEntry
    );

NTSYSAPI
VOID
NTAPI
RtlRemoveUnicodePrefix (
    PUNICODE_PREFIX_TABLE PrefixTable,
    PUNICODE_PREFIX_TABLE_ENTRY PrefixTableEntry
    );

NTSYSAPI
PUNICODE_PREFIX_TABLE_ENTRY
NTAPI
RtlFindUnicodePrefix (
    PUNICODE_PREFIX_TABLE PrefixTable,
    PUNICODE_STRING FullName,
    ULONG CaseInsensitiveIndex
    );

NTSYSAPI
PUNICODE_PREFIX_TABLE_ENTRY
NTAPI
RtlNextUnicodePrefix (
    PUNICODE_PREFIX_TABLE PrefixTable,
    BOOLEAN Restart
    );

//
//
//  Compression package types and procedures.
//

#define COMPRESSION_FORMAT_NONE          (0x0000)   // winnt
#define COMPRESSION_FORMAT_DEFAULT       (0x0001)   // winnt
#define COMPRESSION_FORMAT_LZNT1         (0x0002)   // winnt

#define COMPRESSION_ENGINE_STANDARD      (0x0000)   // winnt
#define COMPRESSION_ENGINE_MAXIMUM       (0x0100)   // winnt
#define COMPRESSION_ENGINE_HIBER         (0x0200)   // winnt

//
//  Compressed Data Information structure.  This structure is
//  used to describe the state of a compressed data buffer,
//  whose uncompressed size is known.  All compressed chunks
//  described by this structure must be compressed with the
//  same format.  On compressed reads, this entire structure
//  is an output, and on compressed writes the entire structure
//  is an input.
//

typedef struct _COMPRESSED_DATA_INFO {

    //
    //  Code for the compression format (and engine) as
    //  defined in ntrtl.h.  Note that COMPRESSION_FORMAT_NONE
    //  and COMPRESSION_FORMAT_DEFAULT are invalid if
    //  any of the described chunks are compressed.
    //

    USHORT CompressionFormatAndEngine;

    //
    //  Since chunks and compression units are expected to be
    //  powers of 2 in size, we express then log2.  So, for
    //  example (1 << ChunkShift) == ChunkSizeInBytes.  The
    //  ClusterShift indicates how much space must be saved
    //  to successfully compress a compression unit - each
    //  successfully compressed compression unit must occupy
    //  at least one cluster less in bytes than an uncompressed
    //  compression unit.
    //

    UCHAR CompressionUnitShift;
    UCHAR ChunkShift;
    UCHAR ClusterShift;
    UCHAR Reserved;

    //
    //  This is the number of entries in the CompressedChunkSizes
    //  array.
    //

    USHORT NumberOfChunks;

    //
    //  This is an array of the sizes of all chunks resident
    //  in the compressed data buffer.  There must be one entry
    //  in this array for each chunk possible in the uncompressed
    //  buffer size.  A size of FSRTL_CHUNK_SIZE indicates the
    //  corresponding chunk is uncompressed and occupies exactly
    //  that size.  A size of 0 indicates that the corresponding
    //  chunk contains nothing but binary 0's, and occupies no
    //  space in the compressed data.  All other sizes must be
    //  less than FSRTL_CHUNK_SIZE, and indicate the exact size
    //  of the compressed data in bytes.
    //

    ULONG CompressedChunkSizes[ANYSIZE_ARRAY];

} COMPRESSED_DATA_INFO;
typedef COMPRESSED_DATA_INFO *PCOMPRESSED_DATA_INFO;

NTSYSAPI
NTSTATUS
NTAPI
RtlGetCompressionWorkSpaceSize (
    IN USHORT CompressionFormatAndEngine,
    OUT PULONG CompressBufferWorkSpaceSize,
    OUT PULONG CompressFragmentWorkSpaceSize
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlCompressBuffer (
    IN USHORT CompressionFormatAndEngine,
    IN PUCHAR UncompressedBuffer,
    IN ULONG UncompressedBufferSize,
    OUT PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    IN ULONG UncompressedChunkSize,
    OUT PULONG FinalCompressedSize,
    IN PVOID WorkSpace
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlDecompressBuffer (
    IN USHORT CompressionFormat,
    OUT PUCHAR UncompressedBuffer,
    IN ULONG UncompressedBufferSize,
    IN PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    OUT PULONG FinalUncompressedSize
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlDecompressFragment (
    IN USHORT CompressionFormat,
    OUT PUCHAR UncompressedFragment,
    IN ULONG UncompressedFragmentSize,
    IN PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    IN ULONG FragmentOffset,
    OUT PULONG FinalUncompressedSize,
    IN PVOID WorkSpace
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlDescribeChunk (
    IN USHORT CompressionFormat,
    IN OUT PUCHAR *CompressedBuffer,
    IN PUCHAR EndOfCompressedBufferPlus1,
    OUT PUCHAR *ChunkBuffer,
    OUT PULONG ChunkSize
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlReserveChunk (
    IN USHORT CompressionFormat,
    IN OUT PUCHAR *CompressedBuffer,
    IN PUCHAR EndOfCompressedBufferPlus1,
    OUT PUCHAR *ChunkBuffer,
    IN ULONG ChunkSize
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlDecompressChunks (
    OUT PUCHAR UncompressedBuffer,
    IN ULONG UncompressedBufferSize,
    IN PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    IN PUCHAR CompressedTail,
    IN ULONG CompressedTailSize,
    IN PCOMPRESSED_DATA_INFO CompressedDataInfo
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlCompressChunks (
    IN PUCHAR UncompressedBuffer,
    IN ULONG UncompressedBufferSize,
    OUT PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    IN OUT PCOMPRESSED_DATA_INFO CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN PVOID WorkSpace
    );

// end_ntifs

//
//  Image loading functions
//

#define DOS_MAX_COMPONENT_LENGTH 255
#define DOS_MAX_PATH_LENGTH (DOS_MAX_COMPONENT_LENGTH + 5 )

typedef struct _CURDIR {
    UNICODE_STRING DosPath;
    HANDLE Handle;
} CURDIR, *PCURDIR;

//
// Low order 2 bits of handle value used as flag bits.
//

#define RTL_USER_PROC_CURDIR_CLOSE      0x00000002
#define RTL_USER_PROC_CURDIR_INHERIT    0x00000003

typedef struct _RTL_DRIVE_LETTER_CURDIR {
    USHORT Flags;
    USHORT Length;
    ULONG TimeStamp;
    STRING DosPath;
} RTL_DRIVE_LETTER_CURDIR, *PRTL_DRIVE_LETTER_CURDIR;

#define RTL_MAX_DRIVE_LETTERS 32
#define RTL_DRIVE_LETTER_VALID (USHORT)0x0001

typedef struct _RTL_USER_PROCESS_PARAMETERS {
    ULONG MaximumLength;
    ULONG Length;

    ULONG Flags;
    ULONG DebugFlags;

    HANDLE ConsoleHandle;
    ULONG  ConsoleFlags;
    HANDLE StandardInput;
    HANDLE StandardOutput;
    HANDLE StandardError;

    CURDIR CurrentDirectory;        // ProcessParameters
    UNICODE_STRING DllPath;         // ProcessParameters
    UNICODE_STRING ImagePathName;   // ProcessParameters
    UNICODE_STRING CommandLine;     // ProcessParameters
    PVOID Environment;              // NtAllocateVirtualMemory

    ULONG StartingX;
    ULONG StartingY;
    ULONG CountX;
    ULONG CountY;
    ULONG CountCharsX;
    ULONG CountCharsY;
    ULONG FillAttribute;

    ULONG WindowFlags;
    ULONG ShowWindowFlags;
    UNICODE_STRING WindowTitle;     // ProcessParameters
    UNICODE_STRING DesktopInfo;     // ProcessParameters
    UNICODE_STRING ShellInfo;       // ProcessParameters
    UNICODE_STRING RuntimeData;     // ProcessParameters
    RTL_DRIVE_LETTER_CURDIR CurrentDirectores[ RTL_MAX_DRIVE_LETTERS ];
} RTL_USER_PROCESS_PARAMETERS, *PRTL_USER_PROCESS_PARAMETERS;

//
// Possible bit values for Flags field.
//

#define RTL_USER_PROC_PARAMS_NORMALIZED     0x00000001
#define RTL_USER_PROC_PROFILE_USER          0x00000002
#define RTL_USER_PROC_PROFILE_KERNEL        0x00000004
#define RTL_USER_PROC_PROFILE_SERVER        0x00000008
#define RTL_USER_PROC_RESERVE_1MB           0x00000020
#define RTL_USER_PROC_RESERVE_16MB          0x00000040
#define RTL_USER_PROC_CASE_SENSITIVE        0x00000080
#define RTL_USER_PROC_DISABLE_HEAP_DECOMMIT 0x00000100
#define RTL_USER_PROC_DLL_REDIRECTION_LOCAL 0x00001000
#define RTL_USER_PROC_APP_MANIFEST_PRESENT  0x00002000

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateProcessParameters(
    PRTL_USER_PROCESS_PARAMETERS *ProcessParameters,
    PUNICODE_STRING ImagePathName,
    PUNICODE_STRING DllPath,
    PUNICODE_STRING CurrentDirectory,
    PUNICODE_STRING CommandLine,
    PVOID Environment,
    PUNICODE_STRING WindowTitle,
    PUNICODE_STRING DesktopInfo,
    PUNICODE_STRING ShellInfo,
    PUNICODE_STRING RuntimeData
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlDestroyProcessParameters(
    PRTL_USER_PROCESS_PARAMETERS ProcessParameters
    );

NTSYSAPI
PRTL_USER_PROCESS_PARAMETERS
NTAPI
RtlNormalizeProcessParams(
    PRTL_USER_PROCESS_PARAMETERS ProcessParameters
    );

NTSYSAPI
PRTL_USER_PROCESS_PARAMETERS
NTAPI
RtlDeNormalizeProcessParams(
    PRTL_USER_PROCESS_PARAMETERS ProcessParameters
    );

typedef NTSTATUS (*PUSER_PROCESS_START_ROUTINE)(
    PRTL_USER_PROCESS_PARAMETERS ProcessParameters
    );

typedef NTSTATUS (*PUSER_THREAD_START_ROUTINE)(
    PVOID ThreadParameter
    );

typedef struct _RTL_USER_PROCESS_INFORMATION {
    ULONG Length;
    HANDLE Process;
    HANDLE Thread;
    CLIENT_ID ClientId;
    SECTION_IMAGE_INFORMATION ImageInformation;
} RTL_USER_PROCESS_INFORMATION, *PRTL_USER_PROCESS_INFORMATION;

//
// This structure is used only by Wow64 processes. The offsets
// of structure elements should the same as viewed by a native Win64 application.
//
typedef struct _RTL_USER_PROCESS_INFORMATION64 {
    ULONG Length;
    LONGLONG Process;
    LONGLONG Thread;
    CLIENT_ID64 ClientId;
    SECTION_IMAGE_INFORMATION64 ImageInformation;
} RTL_USER_PROCESS_INFORMATION64, *PRTL_USER_PROCESS_INFORMATION64;

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateUserProcess(
    PUNICODE_STRING NtImagePathName,
    ULONG Attributes,
    PRTL_USER_PROCESS_PARAMETERS ProcessParameters,
    PSECURITY_DESCRIPTOR ProcessSecurityDescriptor,
    PSECURITY_DESCRIPTOR ThreadSecurityDescriptor,
    HANDLE ParentProcess,
    BOOLEAN InheritHandles,
    HANDLE DebugPort,
    HANDLE ExceptionPort,
    PRTL_USER_PROCESS_INFORMATION ProcessInformation
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateUserThread(
    HANDLE Process,
    PSECURITY_DESCRIPTOR ThreadSecurityDescriptor,
    BOOLEAN CreateSuspended,
    ULONG StackZeroBits,
    SIZE_T MaximumStackSize OPTIONAL,
    SIZE_T InitialStackSize OPTIONAL,
    PUSER_THREAD_START_ROUTINE StartAddress,
    PVOID Parameter,
    PHANDLE Thread,
    PCLIENT_ID ClientId
    );

DECLSPEC_NORETURN
NTSYSAPI
VOID
NTAPI
RtlExitUserThread (
    IN NTSTATUS ExitStatus
    );

NTSYSAPI
VOID
NTAPI
RtlFreeUserThreadStack(
    HANDLE hProcess,
    HANDLE hThread
    );

NTSYSAPI
PVOID
NTAPI
RtlPcToFileHeader(
    PVOID PcValue,
    PVOID *BaseOfImage
    );

#define RTL_IMAGE_NT_HEADER_EX_FLAG_NO_RANGE_CHECK (0x00000001)

NTSYSAPI
NTSTATUS
NTAPI
RtlImageNtHeaderEx(
    ULONG Flags,
    PVOID Base,
    ULONG64 Size,
    OUT PIMAGE_NT_HEADERS * OutHeaders
    );

NTSYSAPI
PIMAGE_NT_HEADERS
NTAPI
RtlImageNtHeader(
    PVOID Base
    );

#define RTL_MEG                   (1024UL * 1024UL)
#define RTLP_IMAGE_MAX_DOS_HEADER ( 256UL * RTL_MEG)

#if !defined(MIDL_PASS)
__inline
PIMAGE_NT_HEADERS
NTAPI
RtlpImageNtHeader (
    IN PVOID Base
    )

/*++

Routine Description:

    This function returns the address of the NT Header.

Arguments:

    Base - Supplies the base of the image.

Return Value:

    Returns the address of the NT Header.

--*/

{
    PIMAGE_NT_HEADERS NtHeaders = NULL;
#ifndef _MAC
    if (Base != NULL && Base != (PVOID)-1) {
        __try {
            if ((((PIMAGE_DOS_HEADER)Base)->e_magic == IMAGE_DOS_SIGNATURE) &&
                ((ULONG)((PIMAGE_DOS_HEADER)Base)->e_lfanew < RTLP_IMAGE_MAX_DOS_HEADER)) {
                NtHeaders = (PIMAGE_NT_HEADERS)((PCHAR)Base + ((PIMAGE_DOS_HEADER)Base)->e_lfanew);
                if (NtHeaders->Signature != IMAGE_NT_SIGNATURE) {
                    NtHeaders = NULL;
                }
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER) {
            NtHeaders = NULL;
        }
    }
#endif //_MAC
    return NtHeaders;
}
#endif

NTSYSAPI
PVOID
NTAPI
RtlAddressInSectionTable (
    IN PIMAGE_NT_HEADERS NtHeaders,
    IN PVOID BaseOfImage,
    IN ULONG VirtualAddress
    );

NTSYSAPI
PIMAGE_SECTION_HEADER
NTAPI
RtlSectionTableFromVirtualAddress (
    IN PIMAGE_NT_HEADERS NtHeaders,
    IN PVOID BaseOfImage,
    IN ULONG VirtualAddress
    );

NTSYSAPI
PVOID
NTAPI
RtlImageDirectoryEntryToData(
    PVOID BaseOfImage,
    BOOLEAN MappedAsImage,
    USHORT DirectoryEntry,
    PULONG Size
    );

#if defined(_WIN64)
NTSYSAPI
PVOID
RtlImageDirectoryEntryToData32 (
    IN PVOID Base,
    IN BOOLEAN MappedAsImage,
    IN USHORT DirectoryEntry,
    OUT PULONG Size
    );
#else
    #define RtlImageDirectoryEntryToData32 RtlImageDirectoryEntryToData
#endif

NTSYSAPI
PIMAGE_SECTION_HEADER
NTAPI
RtlImageRvaToSection(
    IN PIMAGE_NT_HEADERS NtHeaders,
    IN PVOID Base,
    IN ULONG Rva
    );

NTSYSAPI
PVOID
NTAPI
RtlImageRvaToVa(
    IN PIMAGE_NT_HEADERS NtHeaders,
    IN PVOID Base,
    IN ULONG Rva,
    IN OUT PIMAGE_SECTION_HEADER *LastRvaSection OPTIONAL
    );


// begin_ntddk begin_wdm begin_nthal begin_ntifs
//
// Fast primitives to compare, move, and zero memory
//

// begin_winnt begin_ntndis

NTSYSAPI
SIZE_T
NTAPI
RtlCompareMemory (
    const VOID *Source1,
    const VOID *Source2,
    SIZE_T Length
    );

#define RtlEqualMemory(Destination,Source,Length) (!memcmp((Destination),(Source),(Length)))

#if defined(_M_AMD64)

NTSYSAPI
VOID
NTAPI
RtlCopyMemory (
    VOID UNALIGNED *Destination,
    CONST VOID UNALIGNED *Source,
    SIZE_T Length
    );

NTSYSAPI
VOID
NTAPI
RtlMoveMemory (
    VOID UNALIGNED *Destination,
    CONST VOID UNALIGNED *Source,
    SIZE_T Length
    );

NTSYSAPI
VOID
NTAPI
RtlFillMemory (
    VOID UNALIGNED *Destination,
    SIZE_T Length,
    IN UCHAR Fill
    );

NTSYSAPI
VOID
NTAPI
RtlZeroMemory (
    VOID UNALIGNED *Destination,
    SIZE_T Length
    );

#else

#define RtlMoveMemory(Destination,Source,Length) memmove((Destination),(Source),(Length))
#define RtlCopyMemory(Destination,Source,Length) memcpy((Destination),(Source),(Length))
#define RtlFillMemory(Destination,Length,Fill) memset((Destination),(Fill),(Length))
#define RtlZeroMemory(Destination,Length) memset((Destination),0,(Length))

#endif

//
// XONLINE
//
#if 0
#if !defined(MIDL_PASS)
FORCEINLINE
PVOID
RtlSecureZeroMemory(
    IN PVOID ptr,
    IN SIZE_T cnt
    )
{
    volatile char *vptr = (volatile char *)ptr;
    while (cnt) {
        *vptr = 0;
        vptr++;
        cnt--;
    }
    return ptr;
}
#endif
#endif
//
// end XONLINE
//

// end_ntndis end_winnt

#define RtlCopyBytes RtlCopyMemory
#define RtlZeroBytes RtlZeroMemory
#define RtlFillBytes RtlFillMemory

#if defined(_M_AMD64)

NTSYSAPI
VOID
NTAPI
RtlCopyMemoryNonTemporal (
   VOID UNALIGNED *Destination,
   CONST VOID UNALIGNED *Source,
   SIZE_T Length
   );

#else

#define RtlCopyMemoryNonTemporal RtlCopyMemory

#endif

NTSYSAPI
VOID
FASTCALL
RtlPrefetchMemoryNonTemporal(
    IN PVOID Source,
    IN SIZE_T Length
    );

// end_ntddk end_wdm end_nthal

NTSYSAPI
SIZE_T
NTAPI
RtlCompareMemoryUlong (
    PVOID Source,
    SIZE_T Length,
    ULONG Pattern
    );

#if defined(_M_AMD64)

#define RtlFillMemoryUlong(Destination, Length, Pattern)                    \
    __stosd((PULONG)(Destination), Pattern, (Length) / 4)
     
#define RtlFillMemoryUlonglong(Destination, Length, Pattern)                \
    __stosq((PULONG64)(Destination), Pattern, (Length) / 8)
     
#else

NTSYSAPI
VOID
NTAPI
RtlFillMemoryUlong (
   PVOID Destination,
   SIZE_T Length,
   ULONG Pattern
   );

NTSYSAPI
VOID
NTAPI
RtlFillMemoryUlonglong (
   PVOID Destination,
   SIZE_T Length,
   ULONGLONG Pattern
   );

#endif

// end_ntifs

//
//  Debugging support functions.
//

typedef struct _RTL_PROCESS_LOCK_INFORMATION {
    PVOID Address;
    USHORT Type;
    USHORT CreatorBackTraceIndex;

    HANDLE OwningThread;        // from the thread's ClientId->UniqueThread
    LONG LockCount;
    ULONG ContentionCount;
    ULONG EntryCount;

    //
    // The following fields are only valid for Type == RTL_CRITSECT_TYPE
    //

    LONG RecursionCount;

    //
    // The following fields are only valid for Type == RTL_RESOURCE_TYPE
    //

    ULONG NumberOfWaitingShared;
    ULONG NumberOfWaitingExclusive;
} RTL_PROCESS_LOCK_INFORMATION, *PRTL_PROCESS_LOCK_INFORMATION;


typedef struct _RTL_PROCESS_LOCKS {
    ULONG NumberOfLocks;
    RTL_PROCESS_LOCK_INFORMATION Locks[ 1 ];
} RTL_PROCESS_LOCKS, *PRTL_PROCESS_LOCKS;


#if defined(_AMD64_) || defined(_IA64_)
#include "pshpck16.h"        // CONTEXT is 16-byte aligned on win64
#endif

//
// Exception dispatcher's log of recent exceptions
//

#define MAX_EXCEPTION_LOG 10
#define MAX_EXCEPTION_LOG_DATA_SIZE 5

#pragma warning(push)
#pragma warning(disable:4324)

typedef struct _LAST_EXCEPTION_LOG {
    EXCEPTION_RECORD ExceptionRecord;
    CONTEXT ContextRecord;
    ULONG   ControlPc;
    EXCEPTION_DISPOSITION Disposition;
    // On x86 this contains a frame registration record; 4 dwords
    // on RISC machines, it is a RUNTIME_FUNCTION record.
    ULONG HandlerData[MAX_EXCEPTION_LOG_DATA_SIZE];
} LAST_EXCEPTION_LOG, *PLAST_EXCEPTION_LOG;

#pragma warning(pop)

#if defined(_AMD64_) || defined(_IA64_)
#include "poppack.h"
#endif


NTSYSAPI
VOID
NTAPI
RtlInitializeExceptionLog(
    IN ULONG Entries
    );

NTSYSAPI
LONG
NTAPI
RtlUnhandledExceptionFilter(
    IN struct _EXCEPTION_POINTERS *ExceptionInfo
    );

NTSYSAPI
LONG
NTAPI
RtlUnhandledExceptionFilter2(
    IN struct _EXCEPTION_POINTERS *ExceptionInfo,
    IN CONST CHAR*                 Function
    );

VOID
NTAPI
DbgUserBreakPoint(
    VOID
    );

// begin_ntddk begin_wdm begin_nthal begin_ntifs begin_ntndis
//
// Define kernel debugger print prototypes and macros.
//
// N.B. The following function cannot be directly imported because there are
//      a few places in the source tree where this function is redefined.
//

VOID
NTAPI
DbgBreakPoint(
    VOID
    );

// end_wdm

NTSYSAPI
VOID
NTAPI
DbgBreakPointWithStatus(
    IN ULONG Status
    );

// begin_wdm

#define DBG_STATUS_CONTROL_C        1
#define DBG_STATUS_SYSRQ            2
#define DBG_STATUS_BUGCHECK_FIRST   3
#define DBG_STATUS_BUGCHECK_SECOND  4
#define DBG_STATUS_FATAL            5
#define DBG_STATUS_DEBUG_CONTROL    6
#define DBG_STATUS_WORKER           7

#if DBG

#define KdPrint(_x_) DbgPrint _x_
// end_wdm
#define KdPrintEx(_x_) DbgPrintEx _x_
#define vKdPrintEx(_x_) vDbgPrintEx _x_
#define vKdPrintExWithPrefix(_x_) vDbgPrintExWithPrefix _x_
// begin_wdm
#define KdBreakPoint() DbgBreakPoint()

// end_wdm

#define KdBreakPointWithStatus(s) DbgBreakPointWithStatus(s)

// begin_wdm

#else

#define KdPrint(_x_)
// end_wdm
#define KdPrintEx(_x_)
#define vKdPrintEx(_x_)
#define vKdPrintExWithPrefix(_x_)
// begin_wdm
#define KdBreakPoint()

// end_wdm

#define KdBreakPointWithStatus(s)

// begin_wdm

#endif

#ifndef _DBGNT_

ULONG
__cdecl
DbgPrint(
    PCH Format,
    ...
    );

// end_wdm

ULONG
__cdecl
DbgPrintEx(
    IN ULONG ComponentId,
    IN ULONG Level,
    IN PCH Format,
    ...
    );

#ifdef _VA_LIST_DEFINED

ULONG
vDbgPrintEx(
    IN ULONG ComponentId,
    IN ULONG Level,
    IN PCH Format,
    va_list arglist
    );

ULONG
vDbgPrintExWithPrefix(
    IN PCH Prefix,
    IN ULONG ComponentId,
    IN ULONG Level,
    IN PCH Format,
    va_list arglist
    );

#endif

ULONG
__cdecl
DbgPrintReturnControlC(
    PCH Format,
    ...
    );

NTSYSAPI
NTSTATUS
DbgQueryDebugFilterState(
    IN ULONG ComponentId,
    IN ULONG Level
    );

NTSYSAPI
NTSTATUS
DbgSetDebugFilterState(
    IN ULONG ComponentId,
    IN ULONG Level,
    IN BOOLEAN State
    );

// begin_wdm

#endif // _DBGNT_

// end_ntddk end_wdm end_nthal end_ntifs end_ntndis

NTSYSAPI
ULONG
NTAPI
DbgPrompt(
    PCH Prompt,
    PCH Response,
    ULONG MaximumResponseLength
    );

NTSYSAPI
VOID
NTAPI
DbgLoadImageSymbols(
    PSTRING FileName,
    PVOID ImageBase,
    ULONG_PTR ProcessId
    );

NTSYSAPI
VOID
NTAPI
DbgUnLoadImageSymbols(
    PSTRING FileName,
    PVOID ImageBase,
    ULONG_PTR ProcessId
    );

NTSYSAPI
VOID
NTAPI
DbgCommandString(
    PCH Name,
    PCH Command
    );

// internal only
VOID
DebugService2(
    PVOID Arg1,
    PVOID Arg2,
    ULONG Service
    );


// begin_ntddk begin_wdm begin_nthal begin_ntifs
//
// Large integer arithmetic routines.
//

//
// Large integer add - 64-bits + 64-bits -> 64-bits
//

#if !defined(MIDL_PASS)

DECLSPEC_DEPRECATED_DDK         // Use native __int64 math
__inline
LARGE_INTEGER
NTAPI
RtlLargeIntegerAdd (
    LARGE_INTEGER Addend1,
    LARGE_INTEGER Addend2
    )
{
    LARGE_INTEGER Sum;

    Sum.QuadPart = Addend1.QuadPart + Addend2.QuadPart;
    return Sum;
}

//
// Enlarged integer multiply - 32-bits * 32-bits -> 64-bits
//

DECLSPEC_DEPRECATED_DDK         // Use native __int64 math
__inline
LARGE_INTEGER
NTAPI
RtlEnlargedIntegerMultiply (
    LONG Multiplicand,
    LONG Multiplier
    )
{
    LARGE_INTEGER Product;

    Product.QuadPart = (LONGLONG)Multiplicand * (ULONGLONG)Multiplier;
    return Product;
}

//
// Unsigned enlarged integer multiply - 32-bits * 32-bits -> 64-bits
//

DECLSPEC_DEPRECATED_DDK         // Use native __int64 math
__inline
LARGE_INTEGER
NTAPI
RtlEnlargedUnsignedMultiply (
    ULONG Multiplicand,
    ULONG Multiplier
    )
{
    LARGE_INTEGER Product;

    Product.QuadPart = (ULONGLONG)Multiplicand * (ULONGLONG)Multiplier;
    return Product;
}

//
// Enlarged integer divide - 64-bits / 32-bits > 32-bits
//

DECLSPEC_DEPRECATED_DDK         // Use native __int64 math
__inline
ULONG
NTAPI
RtlEnlargedUnsignedDivide (
    IN ULARGE_INTEGER Dividend,
    IN ULONG Divisor,
    IN PULONG Remainder OPTIONAL
    )
{
    ULONG Quotient;

    Quotient = (ULONG)(Dividend.QuadPart / Divisor);
    if (ARGUMENT_PRESENT(Remainder)) {
        *Remainder = (ULONG)(Dividend.QuadPart % Divisor);
    }

    return Quotient;
}

//
// Large integer negation - -(64-bits)
//

DECLSPEC_DEPRECATED_DDK         // Use native __int64 math
__inline
LARGE_INTEGER
NTAPI
RtlLargeIntegerNegate (
    LARGE_INTEGER Subtrahend
    )
{
    LARGE_INTEGER Difference;

    Difference.QuadPart = -Subtrahend.QuadPart;
    return Difference;
}

//
// Large integer subtract - 64-bits - 64-bits -> 64-bits.
//

DECLSPEC_DEPRECATED_DDK         // Use native __int64 math
__inline
LARGE_INTEGER
NTAPI
RtlLargeIntegerSubtract (
    LARGE_INTEGER Minuend,
    LARGE_INTEGER Subtrahend
    )
{
    LARGE_INTEGER Difference;

    Difference.QuadPart = Minuend.QuadPart - Subtrahend.QuadPart;
    return Difference;
}

//
// Extended large integer magic divide - 64-bits / 32-bits -> 64-bits
//

#if defined(_AMD64_)

DECLSPEC_DEPRECATED_DDK         // Use native __int64 math
__inline
LARGE_INTEGER
NTAPI
RtlExtendedMagicDivide (
    LARGE_INTEGER Dividend,
    LARGE_INTEGER MagicDivisor,
    CCHAR ShiftCount
    )

{

    LARGE_INTEGER Quotient;

    if (Dividend.QuadPart >= 0) {
        Quotient.QuadPart = UnsignedMultiplyHigh(Dividend.QuadPart,
                                                 (ULONG64)MagicDivisor.QuadPart);

    } else {
        Quotient.QuadPart = UnsignedMultiplyHigh(-Dividend.QuadPart,
                                                 (ULONG64)MagicDivisor.QuadPart);
    }

    Quotient.QuadPart = (ULONG64)Quotient.QuadPart >> ShiftCount;
    if (Dividend.QuadPart < 0) {
        Quotient.QuadPart = - Quotient.QuadPart;
    }

    return Quotient;
}

#endif // defined(_AMD64_)

#if defined(_X86_) || defined(_IA64_)

DECLSPEC_DEPRECATED_DDK         // Use native __int64 math
NTSYSAPI
LARGE_INTEGER
NTAPI
RtlExtendedMagicDivide (
    LARGE_INTEGER Dividend,
    LARGE_INTEGER MagicDivisor,
    CCHAR ShiftCount
    );

#endif // defined(_X86_) || defined(_IA64_)

#if defined(_AMD64_) || defined(_IA64_)

//
// Large Integer divide - 64-bits / 32-bits -> 64-bits
//

DECLSPEC_DEPRECATED_DDK         // Use native __int64 math
__inline
LARGE_INTEGER
NTAPI
RtlExtendedLargeIntegerDivide (
    LARGE_INTEGER Dividend,
    ULONG Divisor,
    PULONG Remainder OPTIONAL
    )
{
    LARGE_INTEGER Quotient;

    Quotient.QuadPart = (ULONG64)Dividend.QuadPart / Divisor;
    if (ARGUMENT_PRESENT(Remainder)) {
        *Remainder = (ULONG)(Dividend.QuadPart % Divisor);
    }

    return Quotient;
}

// end_wdm
//
// Large Integer divide - 64-bits / 64-bits -> 64-bits
//

DECLSPEC_DEPRECATED_DDK         // Use native __int64 math
__inline
LARGE_INTEGER
NTAPI
RtlLargeIntegerDivide (
    LARGE_INTEGER Dividend,
    LARGE_INTEGER Divisor,
    PLARGE_INTEGER Remainder OPTIONAL
    )
{
    LARGE_INTEGER Quotient;

    Quotient.QuadPart = Dividend.QuadPart / Divisor.QuadPart;
    if (ARGUMENT_PRESENT(Remainder)) {
        Remainder->QuadPart = Dividend.QuadPart % Divisor.QuadPart;
    }

    return Quotient;
}

// begin_wdm
//
// Extended integer multiply - 32-bits * 64-bits -> 64-bits
//

DECLSPEC_DEPRECATED_DDK         // Use native __int64 math
__inline
LARGE_INTEGER
NTAPI
RtlExtendedIntegerMultiply (
    LARGE_INTEGER Multiplicand,
    LONG Multiplier
    )
{
    LARGE_INTEGER Product;

    Product.QuadPart = Multiplicand.QuadPart * Multiplier;
    return Product;
}

#else

//
// Large Integer divide - 64-bits / 32-bits -> 64-bits
//

DECLSPEC_DEPRECATED_DDK         // Use native __int64 math
NTSYSAPI
LARGE_INTEGER
NTAPI
RtlExtendedLargeIntegerDivide (
    LARGE_INTEGER Dividend,
    ULONG Divisor,
    PULONG Remainder
    );

// end_wdm
//
// Large Integer divide - 64-bits / 64-bits -> 64-bits
//

DECLSPEC_DEPRECATED_DDK         // Use native __int64 math
NTSYSAPI
LARGE_INTEGER
NTAPI
RtlLargeIntegerDivide (
    LARGE_INTEGER Dividend,
    LARGE_INTEGER Divisor,
    PLARGE_INTEGER Remainder
    );

// begin_wdm
//
// Extended integer multiply - 32-bits * 64-bits -> 64-bits
//

DECLSPEC_DEPRECATED_DDK         // Use native __int64 math
NTSYSAPI
LARGE_INTEGER
NTAPI
RtlExtendedIntegerMultiply (
    LARGE_INTEGER Multiplicand,
    LONG Multiplier
    );

#endif // defined(_AMD64_) || defined(_IA64_)

//
// Large integer and - 64-bite & 64-bits -> 64-bits.
//

#if PRAGMA_DEPRECATED_DDK
#pragma deprecated(RtlLargeIntegerAnd)      // Use native __int64 math
#endif
#define RtlLargeIntegerAnd(Result, Source, Mask) \
    Result.QuadPart = Source.QuadPart & Mask.QuadPart

//
// Convert signed integer to large integer.
//

DECLSPEC_DEPRECATED_DDK         // Use native __int64 math
__inline
LARGE_INTEGER
NTAPI
RtlConvertLongToLargeInteger (
    LONG SignedInteger
    )
{
    LARGE_INTEGER Result;

    Result.QuadPart = SignedInteger;
    return Result;
}

//
// Convert unsigned integer to large integer.
//

DECLSPEC_DEPRECATED_DDK         // Use native __int64 math
__inline
LARGE_INTEGER
NTAPI
RtlConvertUlongToLargeInteger (
    ULONG UnsignedInteger
    )
{
    LARGE_INTEGER Result;

    Result.QuadPart = UnsignedInteger;
    return Result;
}

//
// Large integer shift routines.
//

DECLSPEC_DEPRECATED_DDK         // Use native __int64 math
__inline
LARGE_INTEGER
NTAPI
RtlLargeIntegerShiftLeft (
    LARGE_INTEGER LargeInteger,
    CCHAR ShiftCount
    )
{
    LARGE_INTEGER Result;

    Result.QuadPart = LargeInteger.QuadPart << ShiftCount;
    return Result;
}

DECLSPEC_DEPRECATED_DDK         // Use native __int64 math
__inline
LARGE_INTEGER
NTAPI
RtlLargeIntegerShiftRight (
    LARGE_INTEGER LargeInteger,
    CCHAR ShiftCount
    )
{
    LARGE_INTEGER Result;

    Result.QuadPart = (ULONG64)LargeInteger.QuadPart >> ShiftCount;
    return Result;
}

DECLSPEC_DEPRECATED_DDK         // Use native __int64 math
__inline
LARGE_INTEGER
NTAPI
RtlLargeIntegerArithmeticShift (
    LARGE_INTEGER LargeInteger,
    CCHAR ShiftCount
    )
{
    LARGE_INTEGER Result;

    Result.QuadPart = LargeInteger.QuadPart >> ShiftCount;
    return Result;
}


//
// Large integer comparison routines.
//

#if PRAGMA_DEPRECATED_DDK
#pragma deprecated(RtlLargeIntegerGreaterThan)      // Use native __int64 math
#pragma deprecated(RtlLargeIntegerGreaterThanOrEqualTo)      // Use native __int64 math
#pragma deprecated(RtlLargeIntegerEqualTo)      // Use native __int64 math
#pragma deprecated(RtlLargeIntegerNotEqualTo)      // Use native __int64 math
#pragma deprecated(RtlLargeIntegerLessThan)      // Use native __int64 math
#pragma deprecated(RtlLargeIntegerLessThanOrEqualTo)      // Use native __int64 math
#pragma deprecated(RtlLargeIntegerGreaterThanZero)      // Use native __int64 math
#pragma deprecated(RtlLargeIntegerGreaterOrEqualToZero)      // Use native __int64 math
#pragma deprecated(RtlLargeIntegerEqualToZero)      // Use native __int64 math
#pragma deprecated(RtlLargeIntegerNotEqualToZero)      // Use native __int64 math
#pragma deprecated(RtlLargeIntegerLessThanZero)      // Use native __int64 math
#pragma deprecated(RtlLargeIntegerLessOrEqualToZero)      // Use native __int64 math
#endif

#define RtlLargeIntegerGreaterThan(X,Y) (                              \
    (((X).HighPart == (Y).HighPart) && ((X).LowPart > (Y).LowPart)) || \
    ((X).HighPart > (Y).HighPart)                                      \
)

#define RtlLargeIntegerGreaterThanOrEqualTo(X,Y) (                      \
    (((X).HighPart == (Y).HighPart) && ((X).LowPart >= (Y).LowPart)) || \
    ((X).HighPart > (Y).HighPart)                                       \
)

#define RtlLargeIntegerEqualTo(X,Y) (                              \
    !(((X).LowPart ^ (Y).LowPart) | ((X).HighPart ^ (Y).HighPart)) \
)

#define RtlLargeIntegerNotEqualTo(X,Y) (                          \
    (((X).LowPart ^ (Y).LowPart) | ((X).HighPart ^ (Y).HighPart)) \
)

#define RtlLargeIntegerLessThan(X,Y) (                                 \
    (((X).HighPart == (Y).HighPart) && ((X).LowPart < (Y).LowPart)) || \
    ((X).HighPart < (Y).HighPart)                                      \
)

#define RtlLargeIntegerLessThanOrEqualTo(X,Y) (                         \
    (((X).HighPart == (Y).HighPart) && ((X).LowPart <= (Y).LowPart)) || \
    ((X).HighPart < (Y).HighPart)                                       \
)

#define RtlLargeIntegerGreaterThanZero(X) (       \
    (((X).HighPart == 0) && ((X).LowPart > 0)) || \
    ((X).HighPart > 0 )                           \
)

#define RtlLargeIntegerGreaterOrEqualToZero(X) ( \
    (X).HighPart >= 0                            \
)

#define RtlLargeIntegerEqualToZero(X) ( \
    !((X).LowPart | (X).HighPart)       \
)

#define RtlLargeIntegerNotEqualToZero(X) ( \
    ((X).LowPart | (X).HighPart)           \
)

#define RtlLargeIntegerLessThanZero(X) ( \
    ((X).HighPart < 0)                   \
)

#define RtlLargeIntegerLessOrEqualToZero(X) (           \
    ((X).HighPart < 0) || !((X).LowPart | (X).HighPart) \
)

#endif // !defined(MIDL_PASS)

//
//  Time conversion routines
//

typedef struct _TIME_FIELDS {
    CSHORT Year;        // range [1601...]
    CSHORT Month;       // range [1..12]
    CSHORT Day;         // range [1..31]
    CSHORT Hour;        // range [0..23]
    CSHORT Minute;      // range [0..59]
    CSHORT Second;      // range [0..59]
    CSHORT Milliseconds;// range [0..999]
    CSHORT Weekday;     // range [0..6] == [Sunday..Saturday]
} TIME_FIELDS;
typedef TIME_FIELDS *PTIME_FIELDS;

// end_ntddk end_wdm end_ntifs

NTSYSAPI
BOOLEAN
NTAPI
RtlCutoverTimeToSystemTime(
    PTIME_FIELDS CutoverTime,
    PLARGE_INTEGER SystemTime,
    PLARGE_INTEGER CurrentSystemTime,
    BOOLEAN ThisYear
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlSystemTimeToLocalTime (
    IN PLARGE_INTEGER SystemTime,
    OUT PLARGE_INTEGER LocalTime
    );

//
// XONLINE
//
#if 0
NTSYSAPI
NTSTATUS
NTAPI
RtlLocalTimeToSystemTime (
    IN PLARGE_INTEGER LocalTime,
    OUT PLARGE_INTEGER SystemTime
    );
#endif
//
// end XONLINE
//

//
//  A 64 bit Time value -> time field record
//

NTSYSAPI
VOID
NTAPI
RtlTimeToElapsedTimeFields (
    IN PLARGE_INTEGER Time,
    OUT PTIME_FIELDS TimeFields
    );

// begin_ntddk begin_wdm begin_ntifs

NTSYSAPI
VOID
NTAPI
RtlTimeToTimeFields (
    PLARGE_INTEGER Time,
    PTIME_FIELDS TimeFields
    );

//
//  A time field record (Weekday ignored) -> 64 bit Time value
//

NTSYSAPI
BOOLEAN
NTAPI
RtlTimeFieldsToTime (
    PTIME_FIELDS TimeFields,
    PLARGE_INTEGER Time
    );

// end_ntddk end_wdm

//
//  A 64 bit Time value -> Seconds since the start of 1980
//

NTSYSAPI
BOOLEAN
NTAPI
RtlTimeToSecondsSince1980 (
    PLARGE_INTEGER Time,
    PULONG ElapsedSeconds
    );

//
//  Seconds since the start of 1980 -> 64 bit Time value
//

NTSYSAPI
VOID
NTAPI
RtlSecondsSince1980ToTime (
    ULONG ElapsedSeconds,
    PLARGE_INTEGER Time
    );

//
//  A 64 bit Time value -> Seconds since the start of 1970
//

//
// XONLINE
//
#if 0
NTSYSAPI
BOOLEAN
NTAPI
RtlTimeToSecondsSince1970 (
    PLARGE_INTEGER Time,
    PULONG ElapsedSeconds
    );
#endif 0
//
// end XONLINE
//

//
//  Seconds since the start of 1970 -> 64 bit Time value
//

NTSYSAPI
VOID
NTAPI
RtlSecondsSince1970ToTime (
    ULONG ElapsedSeconds,
    PLARGE_INTEGER Time
    );

// end_nthal end_ntifs

//
// Time Zone Information structure and procedures
//

typedef struct _RTL_TIME_ZONE_INFORMATION {
    LONG Bias;
    WCHAR StandardName[ 32 ];
    TIME_FIELDS StandardStart;
    LONG StandardBias;
    WCHAR DaylightName[ 32 ];
    TIME_FIELDS DaylightStart;
    LONG DaylightBias;
} RTL_TIME_ZONE_INFORMATION, *PRTL_TIME_ZONE_INFORMATION;


NTSYSAPI
NTSTATUS
NTAPI
RtlQueryTimeZoneInformation(
    OUT PRTL_TIME_ZONE_INFORMATION TimeZoneInformation
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlSetTimeZoneInformation(
    IN PRTL_TIME_ZONE_INFORMATION TimeZoneInformation
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlSetActiveTimeBias(
    IN LONG ActiveBias
    );

// begin_ntddk begin_wdm begin_nthal begin_ntifs
//
// The following macros store and retrieve USHORTS and ULONGS from potentially
// unaligned addresses, avoiding alignment faults.  they should probably be
// rewritten in assembler
//

#define SHORT_SIZE  (sizeof(USHORT))
#define SHORT_MASK  (SHORT_SIZE - 1)
#define LONG_SIZE       (sizeof(LONG))
#define LONGLONG_SIZE   (sizeof(LONGLONG))
#define LONG_MASK       (LONG_SIZE - 1)
#define LONGLONG_MASK   (LONGLONG_SIZE - 1)
#define LOWBYTE_MASK 0x00FF

#define FIRSTBYTE(VALUE)  ((VALUE) & LOWBYTE_MASK)
#define SECONDBYTE(VALUE) (((VALUE) >> 8) & LOWBYTE_MASK)
#define THIRDBYTE(VALUE)  (((VALUE) >> 16) & LOWBYTE_MASK)
#define FOURTHBYTE(VALUE) (((VALUE) >> 24) & LOWBYTE_MASK)

//
// if MIPS Big Endian, order of bytes is reversed.
//

#define SHORT_LEAST_SIGNIFICANT_BIT  0
#define SHORT_MOST_SIGNIFICANT_BIT   1

#define LONG_LEAST_SIGNIFICANT_BIT       0
#define LONG_3RD_MOST_SIGNIFICANT_BIT    1
#define LONG_2ND_MOST_SIGNIFICANT_BIT    2
#define LONG_MOST_SIGNIFICANT_BIT        3

//++
//
// VOID
// RtlStoreUshort (
//     PUSHORT ADDRESS
//     USHORT VALUE
//     )
//
// Routine Description:
//
// This macro stores a USHORT value in at a particular address, avoiding
// alignment faults.
//
// Arguments:
//
//     ADDRESS - where to store USHORT value
//     VALUE - USHORT to store
//
// Return Value:
//
//     none.
//
//--

#define RtlStoreUshort(ADDRESS,VALUE)                     \
         if ((ULONG_PTR)(ADDRESS) & SHORT_MASK) {         \
             ((PUCHAR) (ADDRESS))[SHORT_LEAST_SIGNIFICANT_BIT] = (UCHAR)(FIRSTBYTE(VALUE));    \
             ((PUCHAR) (ADDRESS))[SHORT_MOST_SIGNIFICANT_BIT ] = (UCHAR)(SECONDBYTE(VALUE));   \
         }                                                \
         else {                                           \
             *((PUSHORT) (ADDRESS)) = (USHORT) VALUE;     \
         }


//++
//
// VOID
// RtlStoreUlong (
//     PULONG ADDRESS
//     ULONG VALUE
//     )
//
// Routine Description:
//
// This macro stores a ULONG value in at a particular address, avoiding
// alignment faults.
//
// Arguments:
//
//     ADDRESS - where to store ULONG value
//     VALUE - ULONG to store
//
// Return Value:
//
//     none.
//
// Note:
//     Depending on the machine, we might want to call storeushort in the
//     unaligned case.
//
//--

#define RtlStoreUlong(ADDRESS,VALUE)                      \
         if ((ULONG_PTR)(ADDRESS) & LONG_MASK) {          \
             ((PUCHAR) (ADDRESS))[LONG_LEAST_SIGNIFICANT_BIT      ] = (UCHAR)(FIRSTBYTE(VALUE));    \
             ((PUCHAR) (ADDRESS))[LONG_3RD_MOST_SIGNIFICANT_BIT   ] = (UCHAR)(SECONDBYTE(VALUE));   \
             ((PUCHAR) (ADDRESS))[LONG_2ND_MOST_SIGNIFICANT_BIT   ] = (UCHAR)(THIRDBYTE(VALUE));    \
             ((PUCHAR) (ADDRESS))[LONG_MOST_SIGNIFICANT_BIT       ] = (UCHAR)(FOURTHBYTE(VALUE));   \
         }                                                \
         else {                                           \
             *((PULONG) (ADDRESS)) = (ULONG) (VALUE);     \
         }

//++
//
// VOID
// RtlStoreUlonglong (
//     PULONGLONG ADDRESS
//     ULONG VALUE
//     )
//
// Routine Description:
//
// This macro stores a ULONGLONG value in at a particular address, avoiding
// alignment faults.
//
// Arguments:
//
//     ADDRESS - where to store ULONGLONG value
//     VALUE - ULONGLONG to store
//
// Return Value:
//
//     none.
//
//--

#define RtlStoreUlonglong(ADDRESS,VALUE)                        \
         if ((ULONG_PTR)(ADDRESS) & LONGLONG_MASK) {            \
             RtlStoreUlong((ULONG_PTR)(ADDRESS),                \
                           (ULONGLONG)(VALUE) & 0xFFFFFFFF);    \
             RtlStoreUlong((ULONG_PTR)(ADDRESS)+sizeof(ULONG),  \
                           (ULONGLONG)(VALUE) >> 32);           \
         } else {                                               \
             *((PULONGLONG)(ADDRESS)) = (ULONGLONG)(VALUE);     \
         }

//++
//
// VOID
// RtlStoreUlongPtr (
//     PULONG_PTR ADDRESS
//     ULONG_PTR VALUE
//     )
//
// Routine Description:
//
// This macro stores a ULONG_PTR value in at a particular address, avoiding
// alignment faults.
//
// Arguments:
//
//     ADDRESS - where to store ULONG_PTR value
//     VALUE - ULONG_PTR to store
//
// Return Value:
//
//     none.
//
//--

#ifdef _WIN64

#define RtlStoreUlongPtr(ADDRESS,VALUE)                         \
         RtlStoreUlonglong(ADDRESS,VALUE)

#else

#define RtlStoreUlongPtr(ADDRESS,VALUE)                         \
         RtlStoreUlong(ADDRESS,VALUE)

#endif

//++
//
// VOID
// RtlRetrieveUshort (
//     PUSHORT DESTINATION_ADDRESS
//     PUSHORT SOURCE_ADDRESS
//     )
//
// Routine Description:
//
// This macro retrieves a USHORT value from the SOURCE address, avoiding
// alignment faults.  The DESTINATION address is assumed to be aligned.
//
// Arguments:
//
//     DESTINATION_ADDRESS - where to store USHORT value
//     SOURCE_ADDRESS - where to retrieve USHORT value from
//
// Return Value:
//
//     none.
//
//--

#define RtlRetrieveUshort(DEST_ADDRESS,SRC_ADDRESS)                   \
         if ((ULONG_PTR)SRC_ADDRESS & SHORT_MASK) {                       \
             ((PUCHAR) DEST_ADDRESS)[0] = ((PUCHAR) SRC_ADDRESS)[0];  \
             ((PUCHAR) DEST_ADDRESS)[1] = ((PUCHAR) SRC_ADDRESS)[1];  \
         }                                                            \
         else {                                                       \
             *((PUSHORT) DEST_ADDRESS) = *((PUSHORT) SRC_ADDRESS);    \
         }                                                            \

//++
//
// VOID
// RtlRetrieveUlong (
//     PULONG DESTINATION_ADDRESS
//     PULONG SOURCE_ADDRESS
//     )
//
// Routine Description:
//
// This macro retrieves a ULONG value from the SOURCE address, avoiding
// alignment faults.  The DESTINATION address is assumed to be aligned.
//
// Arguments:
//
//     DESTINATION_ADDRESS - where to store ULONG value
//     SOURCE_ADDRESS - where to retrieve ULONG value from
//
// Return Value:
//
//     none.
//
// Note:
//     Depending on the machine, we might want to call retrieveushort in the
//     unaligned case.
//
//--

#define RtlRetrieveUlong(DEST_ADDRESS,SRC_ADDRESS)                    \
         if ((ULONG_PTR)SRC_ADDRESS & LONG_MASK) {                        \
             ((PUCHAR) DEST_ADDRESS)[0] = ((PUCHAR) SRC_ADDRESS)[0];  \
             ((PUCHAR) DEST_ADDRESS)[1] = ((PUCHAR) SRC_ADDRESS)[1];  \
             ((PUCHAR) DEST_ADDRESS)[2] = ((PUCHAR) SRC_ADDRESS)[2];  \
             ((PUCHAR) DEST_ADDRESS)[3] = ((PUCHAR) SRC_ADDRESS)[3];  \
         }                                                            \
         else {                                                       \
             *((PULONG) DEST_ADDRESS) = *((PULONG) SRC_ADDRESS);      \
         }
// end_ntddk end_wdm

//++
//
// PCHAR
// RtlOffsetToPointer (
//     PVOID Base,
//     ULONG Offset
//     )
//
// Routine Description:
//
// This macro generates a pointer which points to the byte that is 'Offset'
// bytes beyond 'Base'. This is useful for referencing fields within
// self-relative data structures.
//
// Arguments:
//
//     Base - The address of the base of the structure.
//
//     Offset - An unsigned integer offset of the byte whose address is to
//         be generated.
//
// Return Value:
//
//     A PCHAR pointer to the byte that is 'Offset' bytes beyond 'Base'.
//
//
//--

#define RtlOffsetToPointer(B,O)  ((PCHAR)( ((PCHAR)(B)) + ((ULONG_PTR)(O))  ))


//++
//
// ULONG
// RtlPointerToOffset (
//     PVOID Base,
//     PVOID Pointer
//     )
//
// Routine Description:
//
// This macro calculates the offset from Base to Pointer.  This is useful
// for producing self-relative offsets for structures.
//
// Arguments:
//
//     Base - The address of the base of the structure.
//
//     Pointer - A pointer to a field, presumably within the structure
//         pointed to by Base.  This value must be larger than that specified
//         for Base.
//
// Return Value:
//
//     A ULONG offset from Base to Pointer.
//
//
//--

#define RtlPointerToOffset(B,P)  ((ULONG)( ((PCHAR)(P)) - ((PCHAR)(B))  ))

// end_ntifs

// begin_ntifs begin_ntddk begin_wdm
//
//  BitMap routines.  The following structure, routines, and macros are
//  for manipulating bitmaps.  The user is responsible for allocating a bitmap
//  structure (which is really a header) and a buffer (which must be longword
//  aligned and multiple longwords in size).
//

typedef struct _RTL_BITMAP {
    ULONG SizeOfBitMap;                     // Number of bits in bit map
    PULONG Buffer;                          // Pointer to the bit map itself
} RTL_BITMAP;
typedef RTL_BITMAP *PRTL_BITMAP;

//
//  The following routine initializes a new bitmap.  It does not alter the
//  data currently in the bitmap.  This routine must be called before
//  any other bitmap routine/macro.
//

NTSYSAPI
VOID
NTAPI
RtlInitializeBitMap (
    PRTL_BITMAP BitMapHeader,
    PULONG BitMapBuffer,
    ULONG SizeOfBitMap
    );

//
//  The following three routines clear, set, and test the state of a
//  single bit in a bitmap.
//

NTSYSAPI
VOID
NTAPI
RtlClearBit (
    PRTL_BITMAP BitMapHeader,
    ULONG BitNumber
    );

NTSYSAPI
VOID
NTAPI
RtlSetBit (
    PRTL_BITMAP BitMapHeader,
    ULONG BitNumber
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlTestBit (
    PRTL_BITMAP BitMapHeader,
    ULONG BitNumber
    );

//
//  The following two routines either clear or set all of the bits
//  in a bitmap.
//

NTSYSAPI
VOID
NTAPI
RtlClearAllBits (
    PRTL_BITMAP BitMapHeader
    );

NTSYSAPI
VOID
NTAPI
RtlSetAllBits (
    PRTL_BITMAP BitMapHeader
    );

//
//  The following two routines locate a contiguous region of either
//  clear or set bits within the bitmap.  The region will be at least
//  as large as the number specified, and the search of the bitmap will
//  begin at the specified hint index (which is a bit index within the
//  bitmap, zero based).  The return value is the bit index of the located
//  region (zero based) or -1 (i.e., 0xffffffff) if such a region cannot
//  be located
//

NTSYSAPI
ULONG
NTAPI
RtlFindClearBits (
    PRTL_BITMAP BitMapHeader,
    ULONG NumberToFind,
    ULONG HintIndex
    );

NTSYSAPI
ULONG
NTAPI
RtlFindSetBits (
    PRTL_BITMAP BitMapHeader,
    ULONG NumberToFind,
    ULONG HintIndex
    );

//
//  The following two routines locate a contiguous region of either
//  clear or set bits within the bitmap and either set or clear the bits
//  within the located region.  The region will be as large as the number
//  specified, and the search for the region will begin at the specified
//  hint index (which is a bit index within the bitmap, zero based).  The
//  return value is the bit index of the located region (zero based) or
//  -1 (i.e., 0xffffffff) if such a region cannot be located.  If a region
//  cannot be located then the setting/clearing of the bitmap is not performed.
//

NTSYSAPI
ULONG
NTAPI
RtlFindClearBitsAndSet (
    PRTL_BITMAP BitMapHeader,
    ULONG NumberToFind,
    ULONG HintIndex
    );

NTSYSAPI
ULONG
NTAPI
RtlFindSetBitsAndClear (
    PRTL_BITMAP BitMapHeader,
    ULONG NumberToFind,
    ULONG HintIndex
    );

//
//  The following two routines clear or set bits within a specified region
//  of the bitmap.  The starting index is zero based.
//

NTSYSAPI
VOID
NTAPI
RtlClearBits (
    PRTL_BITMAP BitMapHeader,
    ULONG StartingIndex,
    ULONG NumberToClear
    );

NTSYSAPI
VOID
NTAPI
RtlSetBits (
    PRTL_BITMAP BitMapHeader,
    ULONG StartingIndex,
    ULONG NumberToSet
    );

//
//  The following routine locates a set of contiguous regions of clear
//  bits within the bitmap.  The caller specifies whether to return the
//  longest runs or just the first found lcoated.  The following structure is
//  used to denote a contiguous run of bits.  The two routines return an array
//  of this structure, one for each run located.
//

typedef struct _RTL_BITMAP_RUN {

    ULONG StartingIndex;
    ULONG NumberOfBits;

} RTL_BITMAP_RUN;
typedef RTL_BITMAP_RUN *PRTL_BITMAP_RUN;

NTSYSAPI
ULONG
NTAPI
RtlFindClearRuns (
    PRTL_BITMAP BitMapHeader,
    PRTL_BITMAP_RUN RunArray,
    ULONG SizeOfRunArray,
    BOOLEAN LocateLongestRuns
    );

//
//  The following routine locates the longest contiguous region of
//  clear bits within the bitmap.  The returned starting index value
//  denotes the first contiguous region located satisfying our requirements
//  The return value is the length (in bits) of the longest region found.
//

NTSYSAPI
ULONG
NTAPI
RtlFindLongestRunClear (
    PRTL_BITMAP BitMapHeader,
    PULONG StartingIndex
    );

//
//  The following routine locates the first contiguous region of
//  clear bits within the bitmap.  The returned starting index value
//  denotes the first contiguous region located satisfying our requirements
//  The return value is the length (in bits) of the region found.
//

NTSYSAPI
ULONG
NTAPI
RtlFindFirstRunClear (
    PRTL_BITMAP BitMapHeader,
    PULONG StartingIndex
    );

//
//  The following macro returns the value of the bit stored within the
//  bitmap at the specified location.  If the bit is set a value of 1 is
//  returned otherwise a value of 0 is returned.
//
//      ULONG
//      RtlCheckBit (
//          PRTL_BITMAP BitMapHeader,
//          ULONG BitPosition
//          );
//
//
//  To implement CheckBit the macro retrieves the longword containing the
//  bit in question, shifts the longword to get the bit in question into the
//  low order bit position and masks out all other bits.
//

#define RtlCheckBit(BMH,BP) ((((BMH)->Buffer[(BP) / 32]) >> ((BP) % 32)) & 0x1)

//
//  The following two procedures return to the caller the total number of
//  clear or set bits within the specified bitmap.
//

NTSYSAPI
ULONG
NTAPI
RtlNumberOfClearBits (
    PRTL_BITMAP BitMapHeader
    );

NTSYSAPI
ULONG
NTAPI
RtlNumberOfSetBits (
    PRTL_BITMAP BitMapHeader
    );

//
//  The following two procedures return to the caller a boolean value
//  indicating if the specified range of bits are all clear or set.
//

NTSYSAPI
BOOLEAN
NTAPI
RtlAreBitsClear (
    PRTL_BITMAP BitMapHeader,
    ULONG StartingIndex,
    ULONG Length
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlAreBitsSet (
    PRTL_BITMAP BitMapHeader,
    ULONG StartingIndex,
    ULONG Length
    );

NTSYSAPI
ULONG
NTAPI
RtlFindNextForwardRunClear (
    IN PRTL_BITMAP BitMapHeader,
    IN ULONG FromIndex,
    IN PULONG StartingRunIndex
    );

NTSYSAPI
ULONG
NTAPI
RtlFindLastBackwardRunClear (
    IN PRTL_BITMAP BitMapHeader,
    IN ULONG FromIndex,
    IN PULONG StartingRunIndex
    );

//
//  The following two procedures return to the caller a value indicating
//  the position within a ULONGLONG of the most or least significant non-zero
//  bit.  A value of zero results in a return value of -1.
//

NTSYSAPI
CCHAR
NTAPI
RtlFindLeastSignificantBit (
    IN ULONGLONG Set
    );

NTSYSAPI
CCHAR
NTAPI
RtlFindMostSignificantBit (
    IN ULONGLONG Set
    );

// end_nthal end_ntifs end_ntddk end_wdm

// begin_ntifs
//
//  Security ID RTL routine definitions
//


NTSYSAPI
BOOLEAN
NTAPI
RtlValidSid (
    PSID Sid
    );


NTSYSAPI
BOOLEAN
NTAPI
RtlEqualSid (
    PSID Sid1,
    PSID Sid2
    );


NTSYSAPI
BOOLEAN
NTAPI
RtlEqualPrefixSid (
    PSID Sid1,
    PSID Sid2
    );


NTSYSAPI
ULONG
NTAPI
RtlLengthRequiredSid (
    ULONG SubAuthorityCount
    );


NTSYSAPI
PVOID
NTAPI
RtlFreeSid(
    IN PSID Sid
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlAllocateAndInitializeSid(
    IN PSID_IDENTIFIER_AUTHORITY IdentifierAuthority,
    IN UCHAR SubAuthorityCount,
    IN ULONG SubAuthority0,
    IN ULONG SubAuthority1,
    IN ULONG SubAuthority2,
    IN ULONG SubAuthority3,
    IN ULONG SubAuthority4,
    IN ULONG SubAuthority5,
    IN ULONG SubAuthority6,
    IN ULONG SubAuthority7,
    OUT PSID *Sid
    );


NTSYSAPI                                            // ntifs
NTSTATUS                                            // ntifs
NTAPI                                               // ntifs
RtlInitializeSid (                                  // ntifs
    PSID Sid,                                       // ntifs
    PSID_IDENTIFIER_AUTHORITY IdentifierAuthority,  // ntifs
    UCHAR SubAuthorityCount                         // ntifs
    );                                              // ntifs

NTSYSAPI
PSID_IDENTIFIER_AUTHORITY
NTAPI
RtlIdentifierAuthoritySid (
    PSID Sid
    );

NTSYSAPI                                            // ntifs
PULONG                                              // ntifs
NTAPI                                               // ntifs
RtlSubAuthoritySid (                                // ntifs
    PSID Sid,                                       // ntifs
    ULONG SubAuthority                              // ntifs
    );                                              // ntifs

NTSYSAPI
PUCHAR
NTAPI
RtlSubAuthorityCountSid (
    PSID Sid
    );

// begin_ntifs
NTSYSAPI
ULONG
NTAPI
RtlLengthSid (
    PSID Sid
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlCopySid (
    ULONG DestinationSidLength,
    PSID DestinationSid,
    PSID SourceSid
    );

// end_ntifs
NTSYSAPI
NTSTATUS
NTAPI
RtlCopySidAndAttributesArray (
    ULONG ArrayLength,
    PSID_AND_ATTRIBUTES Source,
    ULONG TargetSidBufferSize,
    PSID_AND_ATTRIBUTES TargetArrayElement,
    PSID TargetSid,
    PSID *NextTargetSid,
    PULONG RemainingTargetSidSize
    );


NTSYSAPI
NTSTATUS
NTAPI
RtlLengthSidAsUnicodeString(
    PSID Sid,
    PULONG StringLength
    );

//
// XONLINE
//
#if 0
NTSYSAPI
NTSTATUS
NTAPI
RtlConvertSidToUnicodeString(
    PUNICODE_STRING UnicodeString,
    PSID Sid,
    BOOLEAN AllocateDestinationString
    );
#endif 0
//
// end XONLINE
//


//
// LUID RTL routine definitions
//

// begin_ntddk begin_ntifs

//
// BOOLEAN
// RtlEqualLuid(
//      PLUID L1,
//      PLUID L2
//      );

#define RtlEqualLuid(L1, L2) (((L1)->LowPart == (L2)->LowPart) && \
                              ((L1)->HighPart  == (L2)->HighPart))

//
// BOOLEAN
// RtlIsZeroLuid(
//      PLUID L1
//      );
//
#define RtlIsZeroLuid(L1) ((BOOLEAN) (((L1)->LowPart | (L1)->HighPart) == 0))


#if !defined(MIDL_PASS)

FORCEINLINE LUID
NTAPI
RtlConvertLongToLuid(
    LONG Long
    )
{
    LUID TempLuid;
    LARGE_INTEGER TempLi;

    TempLi.QuadPart = Long;
    TempLuid.LowPart = TempLi.LowPart;
    TempLuid.HighPart = TempLi.HighPart;
    return(TempLuid);
}

FORCEINLINE
LUID
NTAPI
RtlConvertUlongToLuid(
    ULONG Ulong
    )
{
    LUID TempLuid;

    TempLuid.LowPart = Ulong;
    TempLuid.HighPart = 0;
    return(TempLuid);
}
#endif

// end_ntddk

NTSYSAPI
VOID
NTAPI
RtlCopyLuid (
    PLUID DestinationLuid,
    PLUID SourceLuid
    );

// end_ntifs

NTSYSAPI
VOID
NTAPI
RtlCopyLuidAndAttributesArray (
    ULONG ArrayLength,
    PLUID_AND_ATTRIBUTES Source,
    PLUID_AND_ATTRIBUTES Target
    );


//
//  ACCESS_MASK RTL routine definitions
//


NTSYSAPI
BOOLEAN
NTAPI
RtlAreAllAccessesGranted(
    ACCESS_MASK GrantedAccess,
    ACCESS_MASK DesiredAccess
    );


NTSYSAPI
BOOLEAN
NTAPI
RtlAreAnyAccessesGranted(
    ACCESS_MASK GrantedAccess,
    ACCESS_MASK DesiredAccess
    );

// begin_ntddk begin_ntifs

NTSYSAPI
VOID
NTAPI
RtlMapGenericMask(
    PACCESS_MASK AccessMask,
    PGENERIC_MAPPING GenericMapping
    );
// end_ntddk end_ntifs


//
//  ACL RTL routine definitions
//

NTSYSAPI
BOOLEAN
NTAPI
RtlValidAcl (
    PACL Acl
    );

NTSYSAPI                                        // ntifs
NTSTATUS                                        // ntifs
NTAPI                                           // ntifs
RtlCreateAcl (                                  // ntifs
    PACL Acl,                                   // ntifs
    ULONG AclLength,                            // ntifs
    ULONG AclRevision                           // ntifs
    );                                          // ntifs

NTSYSAPI
NTSTATUS
NTAPI
RtlQueryInformationAcl (
    PACL Acl,
    PVOID AclInformation,
    ULONG AclInformationLength,
    ACL_INFORMATION_CLASS AclInformationClass
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlSetInformationAcl (
    PACL Acl,
    PVOID AclInformation,
    ULONG AclInformationLength,
    ACL_INFORMATION_CLASS AclInformationClass
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlAddAce (
    PACL Acl,
    ULONG AceRevision,
    ULONG StartingAceIndex,
    PVOID AceList,
    ULONG AceListLength
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlDeleteAce (
    PACL Acl,
    ULONG AceIndex
    );

// begin_ntifs

NTSYSAPI
NTSTATUS
NTAPI
RtlGetAce (
    PACL Acl,
    ULONG AceIndex,
    PVOID *Ace
    );


NTSYSAPI
NTSTATUS
NTAPI
RtlAddAccessAllowedAce (
    PACL Acl,
    ULONG AceRevision,
    ACCESS_MASK AccessMask,
    PSID Sid
    );

// end_ntifs

NTSYSAPI
NTSTATUS
NTAPI
RtlAddAccessAllowedAceEx (
    PACL Acl,
    ULONG AceRevision,
    ULONG AceFlags,
    ACCESS_MASK AccessMask,
    PSID Sid
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlAddAccessDeniedAce (
    PACL Acl,
    ULONG AceRevision,
    ACCESS_MASK AccessMask,
    PSID Sid
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlAddAccessDeniedAceEx (
    PACL Acl,
    ULONG AceRevision,
    ULONG AceFlags,
    ACCESS_MASK AccessMask,
    PSID Sid
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlAddAuditAccessAce (
    PACL Acl,
    ULONG AceRevision,
    ACCESS_MASK AccessMask,
    PSID Sid,
    BOOLEAN AuditSuccess,
    BOOLEAN AuditFailure
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlAddAuditAccessAceEx (
    PACL Acl,
    ULONG AceRevision,
    ULONG AceFlags,
    ACCESS_MASK AccessMask,
    PSID Sid,
    BOOLEAN AuditSuccess,
    BOOLEAN AuditFailure
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlAddAccessAllowedObjectAce (
    IN OUT PACL Acl,
    IN ULONG AceRevision,
    IN ULONG AceFlags,
    IN ACCESS_MASK AccessMask,
    IN GUID *ObjectTypeGuid OPTIONAL,
    IN GUID *InheritedObjectTypeGuid OPTIONAL,
    IN PSID Sid
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlAddAccessDeniedObjectAce (
    IN OUT PACL Acl,
    IN ULONG AceRevision,
    IN ULONG AceFlags,
    IN ACCESS_MASK AccessMask,
    IN GUID *ObjectTypeGuid OPTIONAL,
    IN GUID *InheritedObjectTypeGuid OPTIONAL,
    IN PSID Sid
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlAddAuditAccessObjectAce (
    IN OUT PACL Acl,
    IN ULONG AceRevision,
    IN ULONG AceFlags,
    IN ACCESS_MASK AccessMask,
    IN GUID *ObjectTypeGuid OPTIONAL,
    IN GUID *InheritedObjectTypeGuid OPTIONAL,
    IN PSID Sid,
    BOOLEAN AuditSuccess,
    BOOLEAN AuditFailure
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlFirstFreeAce (
    PACL Acl,
    PVOID *FirstFree
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlAddCompoundAce (
    IN PACL Acl,
    IN ULONG AceRevision,
    IN UCHAR AceType,
    IN ACCESS_MASK AccessMask,
    IN PSID ServerSid,
    IN PSID ClientSid
    );


// begin_wdm begin_ntddk begin_ntifs
//
//  SecurityDescriptor RTL routine definitions
//

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateSecurityDescriptor (
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    ULONG Revision
    );

// end_wdm end_ntddk

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateSecurityDescriptorRelative (
    PISECURITY_DESCRIPTOR_RELATIVE SecurityDescriptor,
    ULONG Revision
    );

// begin_wdm begin_ntddk

NTSYSAPI
BOOLEAN
NTAPI
RtlValidSecurityDescriptor (
    PSECURITY_DESCRIPTOR SecurityDescriptor
    );


NTSYSAPI
ULONG
NTAPI
RtlLengthSecurityDescriptor (
    PSECURITY_DESCRIPTOR SecurityDescriptor
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlValidRelativeSecurityDescriptor (
    IN PSECURITY_DESCRIPTOR SecurityDescriptorInput,
    IN ULONG SecurityDescriptorLength,
    IN SECURITY_INFORMATION RequiredInformation
    );

// end_wdm end_ntddk end_ntifs

NTSYSAPI
NTSTATUS
NTAPI
RtlGetControlSecurityDescriptor (
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    PSECURITY_DESCRIPTOR_CONTROL Control,
    PULONG Revision
    );


NTSYSAPI
NTSTATUS
NTAPI
RtlSetControlSecurityDescriptor (
     IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
     IN SECURITY_DESCRIPTOR_CONTROL ControlBitsOfInterest,
     IN SECURITY_DESCRIPTOR_CONTROL ControlBitsToSet
     );

NTSYSAPI
NTSTATUS
NTAPI
RtlSetAttributesSecurityDescriptor(
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN SECURITY_DESCRIPTOR_CONTROL Control,
    IN OUT PULONG Revision
    );

// begin_wdm begin_ntddk begin_ntifs

NTSYSAPI
NTSTATUS
NTAPI
RtlSetDaclSecurityDescriptor (
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    BOOLEAN DaclPresent,
    PACL Dacl,
    BOOLEAN DaclDefaulted
    );

// end_wdm end_ntddk

NTSYSAPI
NTSTATUS
NTAPI
RtlGetDaclSecurityDescriptor (
    IN  PSECURITY_DESCRIPTOR SecurityDescriptor,
    OUT PBOOLEAN DaclPresent,
    OUT PACL *Dacl,
    OUT PBOOLEAN DaclDefaulted
    );
// end_ntifs

NTSYSAPI
BOOLEAN
NTAPI
RtlGetSecurityDescriptorRMControl(
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    OUT PUCHAR RMControl
    );

NTSYSAPI
VOID
NTAPI
RtlSetSecurityDescriptorRMControl(
    IN OUT PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN PUCHAR RMControl OPTIONAL
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlSetSaclSecurityDescriptor (
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    BOOLEAN SaclPresent,
    PACL Sacl,
    BOOLEAN SaclDefaulted
    );


NTSYSAPI
NTSTATUS
NTAPI
RtlGetSaclSecurityDescriptor (
    IN  PSECURITY_DESCRIPTOR SecurityDescriptor,
    OUT PBOOLEAN SaclPresent,
    OUT PACL *Sacl,
    OUT PBOOLEAN SaclDefaulted
    );


NTSYSAPI                                        // ntifs
NTSTATUS                                        // ntifs
NTAPI                                           // ntifs
RtlSetOwnerSecurityDescriptor (                 // ntifs
    PSECURITY_DESCRIPTOR SecurityDescriptor,    // ntifs
    PSID Owner,                                 // ntifs
    BOOLEAN OwnerDefaulted                      // ntifs
    );                                          // ntifs



NTSYSAPI                                            // ntifs
NTSTATUS                                            // ntifs
NTAPI                                               // ntifs
RtlGetOwnerSecurityDescriptor (                     // ntifs
    IN  PSECURITY_DESCRIPTOR SecurityDescriptor,    // ntifs
    OUT PSID *Owner,                                // ntifs
    OUT PBOOLEAN OwnerDefaulted                     // ntifs
    );                                              // ntifs



NTSYSAPI
NTSTATUS
NTAPI
RtlSetGroupSecurityDescriptor (
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    PSID Group,
    BOOLEAN GroupDefaulted
    );


NTSYSAPI
NTSTATUS
NTAPI
RtlGetGroupSecurityDescriptor (
    IN  PSECURITY_DESCRIPTOR SecurityDescriptor,
    OUT PSID *Group,
    OUT PBOOLEAN GroupDefaulted
    );


NTSYSAPI
NTSTATUS
NTAPI
RtlMakeSelfRelativeSD(
    IN  PSECURITY_DESCRIPTOR AbsoluteSecurityDescriptor,
    OUT PSECURITY_DESCRIPTOR SelfRelativeSecurityDescriptor,
    OUT PULONG BufferLength
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlAbsoluteToSelfRelativeSD(
    PSECURITY_DESCRIPTOR AbsoluteSecurityDescriptor,
    PSECURITY_DESCRIPTOR SelfRelativeSecurityDescriptor,
    PULONG BufferLength
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlSelfRelativeToAbsoluteSD(
    PSECURITY_DESCRIPTOR SelfRelativeSecurityDescriptor,
    PSECURITY_DESCRIPTOR AbsoluteSecurityDescriptor,
    PULONG AbsoluteSecurityDescriptorSize,
    PACL Dacl,
    PULONG DaclSize,
    PACL Sacl,
    PULONG SaclSize,
    PSID Owner,
    PULONG OwnerSize,
    PSID PrimaryGroup,
    PULONG PrimaryGroupSize
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlSelfRelativeToAbsoluteSD2(
    PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor,
    PULONG               pBufferSize
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlNewSecurityGrantedAccess(
    ACCESS_MASK DesiredAccess,
    PPRIVILEGE_SET Privileges,
    PULONG Length,
    HANDLE Token,
    PGENERIC_MAPPING GenericMapping,
    PACCESS_MASK RemainingDesiredAccess
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlMapSecurityErrorToNtStatus(
    SECURITY_STATUS Error
    );


NTSYSAPI
NTSTATUS
NTAPI
RtlImpersonateSelf(
    IN SECURITY_IMPERSONATION_LEVEL ImpersonationLevel
    );


NTSYSAPI
NTSTATUS
NTAPI
RtlAdjustPrivilege(
    ULONG Privilege,
    BOOLEAN Enable,
    BOOLEAN Client,
    PBOOLEAN WasEnabled
    );



NTSYSAPI
VOID
NTAPI
RtlRunEncodeUnicodeString(
    PUCHAR          Seed        OPTIONAL,
    PUNICODE_STRING String
    );


NTSYSAPI
VOID
NTAPI
RtlRunDecodeUnicodeString(
    UCHAR           Seed,
    PUNICODE_STRING String
    );


NTSYSAPI
VOID
NTAPI
RtlEraseUnicodeString(
    PUNICODE_STRING String
    );

//
//  Macro to make a known ACE type ready for applying to a specific object type.
//  This is done by mapping any generic access types, and clearing
//  the special access types field.
//
//  This routine should only be used on DSA define ACEs.
//
//  Parameters:
//
//      Ace - Points to an ACE to be applied.  Only ACEs that are not
//          InheritOnly are mapped.
//
//      Mapping - Points to a generic mapping array for the type of
//           object the ACE is being applied to.
//

                //
                // Clear invalid bits.  Note that ACCESS_SYSTEM_SECURITY is
                // valid in SACLs, but not in DACLs.  So, leave it in audit and
                // alarm ACEs, but clear it in access allowed and denied ACEs.
                //

#define RtlApplyAceToObject(Ace,Mapping) \
            if (!FlagOn((Ace)->AceFlags, INHERIT_ONLY_ACE) ) { \
                RtlApplyGenericMask( Ace, &((PKNOWN_ACE)(Ace))->Mask, Mapping ); \
            }

// Same as above, but don't modify the mask in the ACE itself.
#define RtlApplyGenericMask(Ace, Mask, Mapping) {                                                  \
                RtlMapGenericMask( (Mask), (Mapping));  \
                                                                                            \
                if ( (((PKNOWN_ACE)(Ace))->Header.AceType == ACCESS_ALLOWED_ACE_TYPE) ||    \
                     (((PKNOWN_ACE)(Ace))->Header.AceType == ACCESS_DENIED_ACE_TYPE)  ||    \
                     (((PKNOWN_ACE)(Ace))->Header.AceType == ACCESS_ALLOWED_COMPOUND_ACE_TYPE)  ||    \
                     (((PKNOWN_ACE)(Ace))->Header.AceType == ACCESS_ALLOWED_OBJECT_ACE_TYPE)  ||    \
                     (((PKNOWN_ACE)(Ace))->Header.AceType == ACCESS_DENIED_OBJECT_ACE_TYPE)  ) {   \
                    *(Mask) &= (Mapping)->GenericAll;                     \
                } else {                                                                    \
                    *(Mask) &= ((Mapping)->GenericAll |                   \
                                                  ACCESS_SYSTEM_SECURITY);                  \
                }                                                                           \
            }

//
// Service to get the primary domain name/sid of the local machine
// Callable only from user mode.
//

//NTSYSAPI
NTSTATUS
NTAPI
RtlGetPrimaryDomain(
    IN  ULONG            SidLength,
    OUT PBOOLEAN         PrimaryDomainPresent,
    OUT PUNICODE_STRING  PrimaryDomainName,
    OUT PUSHORT          RequiredNameLength,
    OUT PSID             PrimaryDomainSid OPTIONAL,
    OUT PULONG           RequiredSidLength
    );

//!!!!!!!!!!!!!!!  Temporary user mode Registry system services  !!!!!!//
//                                                                     //
//  These services will be eliminted when BryanWi implements the real  //
//  registry object.                                                   //
                                                                       //
NTSTATUS                                                               //
RtlpNtOpenKey(                                                         //
    PHANDLE KeyHandle,                                                 //
    ACCESS_MASK DesiredAccess,                                         //
    POBJECT_ATTRIBUTES ObjectAttributes,                               //
    ULONG Options                                                      //
    );                                                                 //
                                                                       //
NTSTATUS                                                               //
RtlpNtCreateKey(                                                       //
    PHANDLE KeyHandle,                                                 //
    ACCESS_MASK DesiredAccess,                                         //
    POBJECT_ATTRIBUTES ObjectAttributes,                               //
    ULONG Options,                                                     //
    PUNICODE_STRING Provider,                                          //
    PULONG Disposition                                                 //
    );                                                                 //
                                                                       //
NTSTATUS                                                               //
RtlpNtEnumerateSubKey(                                                 //
    HANDLE KeyHandle,                                                  //
    PUNICODE_STRING SubKeyName,                                        //
    ULONG Index,                                                       //
    PLARGE_INTEGER LastWriteTime                                       //
    );                                                                 //
                                                                       //
NTSTATUS                                                               //
RtlpNtQueryValueKey(                                                   //
    HANDLE KeyHandle,                                                  //
    PULONG KeyValueType,                                               //
    PVOID KeyValue,                                                    //
    PULONG KeyValueLength,                                             //
    PLARGE_INTEGER LastWriteTime                                       //
    );                                                                 //
                                                                       //
NTSTATUS                                                               //
RtlpNtSetValueKey(                                                     //
    HANDLE KeyHandle,                                                  //
    ULONG KeyValueType,                                                //
    PVOID KeyValue,                                                    //
    ULONG KeyValueLength                                               //
    );                                                                 //
                                                                       //
NTSTATUS                                                               //
RtlpNtMakeTemporaryKey(                                                //
    HANDLE KeyHandle                                                   //
    );                                                                 //
                                                                       //
/////////////////////////////////////////////////////////////////////////


//
// Extract the SIDs from a compound ACE.
//

#define RtlCompoundAceServerSid( Ace ) ((PSID)&((PKNOWN_COMPOUND_ACE)(Ace))->SidStart)

#define RtlCompoundAceClientSid( Ace ) ((PSID)(((ULONG_PTR)(&((PKNOWN_COMPOUND_ACE)(Ace))->SidStart))+RtlLengthSid( RtlCompoundAceServerSid((Ace)))))



// begin_winnt

//
// XONLINE
//
#if 0
typedef struct _MESSAGE_RESOURCE_ENTRY {
    USHORT Length;
    USHORT Flags;
    UCHAR Text[ 1 ];
} MESSAGE_RESOURCE_ENTRY, *PMESSAGE_RESOURCE_ENTRY;

#define MESSAGE_RESOURCE_UNICODE 0x0001

typedef struct _MESSAGE_RESOURCE_BLOCK {
    ULONG LowId;
    ULONG HighId;
    ULONG OffsetToEntries;
} MESSAGE_RESOURCE_BLOCK, *PMESSAGE_RESOURCE_BLOCK;

typedef struct _MESSAGE_RESOURCE_DATA {
    ULONG NumberOfBlocks;
    MESSAGE_RESOURCE_BLOCK Blocks[ 1 ];
} MESSAGE_RESOURCE_DATA, *PMESSAGE_RESOURCE_DATA;
#endif
//
// end XONLINE
//

// end_winnt

NTSYSAPI
NTSTATUS
NTAPI
RtlFindMessage(
    PVOID DllHandle,
    ULONG MessageTableId,
    ULONG MessageLanguageId,
    ULONG MessageId,
    PMESSAGE_RESOURCE_ENTRY *MessageEntry
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlFormatMessage(
    IN PWSTR MessageFormat,
    IN ULONG MaximumWidth OPTIONAL,
    IN BOOLEAN IgnoreInserts,
    IN BOOLEAN ArgumentsAreAnsi,
    IN BOOLEAN ArgumentsAreAnArray,
    IN va_list *Arguments,
    OUT PWSTR Buffer,
    IN ULONG Length,
    OUT PULONG ReturnLength OPTIONAL
    );


//
// Services providing a simple transaction capability for operations on
// the registration database.
//


typedef enum _RTL_RXACT_OPERATION {
    RtlRXactOperationDelete = 1,        // Causes sub-key to be deleted
    RtlRXactOperationSetValue,          // Sets sub-key value (creates key(s) if necessary)
    RtlRXactOperationDelAttribute,
    RtlRXactOperationSetAttribute
} RTL_RXACT_OPERATION, *PRTL_RXACT_OPERATION;


typedef struct _RTL_RXACT_LOG {
    ULONG OperationCount;
    ULONG LogSize;                   // Includes sizeof( LOG_HEADER )
    ULONG LogSizeInUse;

#if defined(_WIN64)

    ULONG Alignment;

#endif

//    UCHAR LogData[ ANYSIZE_ARRAY ]
} RTL_RXACT_LOG, *PRTL_RXACT_LOG;

#ifdef _MAC
#pragma warning( disable : 4121)
#endif

typedef struct _RTL_RXACT_CONTEXT {
    HANDLE RootRegistryKey;
    HANDLE RXactKey;
    BOOLEAN HandlesValid;             // Handles found in Log entries are legit
    PRTL_RXACT_LOG RXactLog;
} RTL_RXACT_CONTEXT, *PRTL_RXACT_CONTEXT;


#ifdef _MAC
#pragma warning( default : 4121 )
#endif


NTSYSAPI
NTSTATUS
NTAPI
RtlInitializeRXact(
    IN HANDLE RootRegistryKey,
    IN BOOLEAN CommitIfNecessary,
    OUT PRTL_RXACT_CONTEXT *RXactContext
    );


NTSYSAPI
NTSTATUS
NTAPI
RtlStartRXact(
    IN PRTL_RXACT_CONTEXT RXactContext
    );


NTSYSAPI
NTSTATUS
NTAPI
RtlAbortRXact(
    IN PRTL_RXACT_CONTEXT RXactContext
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlAddAttributeActionToRXact(
    IN PRTL_RXACT_CONTEXT RXactContext,
    IN RTL_RXACT_OPERATION Operation,
    IN PUNICODE_STRING SubKeyName,
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING AttributeName,
    IN ULONG NewValueType,
    IN PVOID NewValue,
    IN ULONG NewValueLength
    );


NTSYSAPI
NTSTATUS
NTAPI
RtlAddActionToRXact(
    IN PRTL_RXACT_CONTEXT RXactContext,
    IN RTL_RXACT_OPERATION Operation,
    IN PUNICODE_STRING SubKeyName,
    IN ULONG NewKeyValueType,
    IN PVOID NewKeyValue OPTIONAL,
    IN ULONG NewKeyValueLength
    );


NTSYSAPI
NTSTATUS
NTAPI
RtlApplyRXact(
    IN PRTL_RXACT_CONTEXT RXactContext
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlApplyRXactNoFlush(
    IN PRTL_RXACT_CONTEXT RXactContext
    );



//
// Routine for converting NT status codes to DOS/OS|2 equivalents.
//

// begin_ntifs

//
// XONLINE
//
#if 0
NTSYSAPI
ULONG
NTAPI
RtlNtStatusToDosError (
   NTSTATUS Status
   );
#endif
//
// end XONLINE
//

NTSYSAPI
ULONG
NTAPI
RtlNtStatusToDosErrorNoTeb (
   NTSTATUS Status
   );


NTSYSAPI
NTSTATUS
NTAPI
RtlCustomCPToUnicodeN(
    IN PCPTABLEINFO CustomCP,
    OUT PWCH UnicodeString,
    IN ULONG MaxBytesInUnicodeString,
    OUT PULONG BytesInUnicodeString OPTIONAL,
    IN PCH CustomCPString,
    IN ULONG BytesInCustomCPString
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlUnicodeToCustomCPN(
    IN PCPTABLEINFO CustomCP,
    OUT PCH CustomCPString,
    IN ULONG MaxBytesInCustomCPString,
    OUT PULONG BytesInCustomCPString OPTIONAL,
    IN PWCH UnicodeString,
    IN ULONG BytesInUnicodeString
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlUpcaseUnicodeToCustomCPN(
    IN PCPTABLEINFO CustomCP,
    OUT PCH CustomCPString,
    IN ULONG MaxBytesInCustomCPString,
    OUT PULONG BytesInCustomCPString OPTIONAL,
    IN PWCH UnicodeString,
    IN ULONG BytesInUnicodeString
    );

NTSYSAPI
VOID
NTAPI
RtlInitCodePageTable(
    IN PUSHORT TableBase,
    OUT PCPTABLEINFO CodePageTable
    );

// end_ntifs

NTSYSAPI
VOID
NTAPI
RtlInitNlsTables(
    IN PUSHORT AnsiNlsBase,
    IN PUSHORT OemNlsBase,
    IN PUSHORT LanguageNlsBase,
    OUT PNLSTABLEINFO TableInfo
    );

NTSYSAPI
VOID
NTAPI
RtlResetRtlTranslations(
    PNLSTABLEINFO TableInfo
    );


NTSYSAPI
VOID
NTAPI
RtlGetDefaultCodePage(
    OUT PUSHORT AnsiCodePage,
    OUT PUSHORT OemCodePage
    );

// begin_ntddk begin_nthal

//
// Range list package
//

typedef struct _RTL_RANGE {

    //
    // The start of the range
    //
    ULONGLONG Start;    // Read only

    //
    // The end of the range
    //
    ULONGLONG End;      // Read only

    //
    // Data the user passed in when they created the range
    //
    PVOID UserData;     // Read/Write

    //
    // The owner of the range
    //
    PVOID Owner;        // Read/Write

    //
    // User defined flags the user specified when they created the range
    //
    UCHAR Attributes;    // Read/Write

    //
    // Flags (RTL_RANGE_*)
    //
    UCHAR Flags;       // Read only

} RTL_RANGE, *PRTL_RANGE;


#define RTL_RANGE_SHARED    0x01
#define RTL_RANGE_CONFLICT  0x02

typedef struct _RTL_RANGE_LIST {

    //
    // The list of ranges
    //
    LIST_ENTRY ListHead;

    //
    // These always come in useful
    //
    ULONG Flags;        // use RANGE_LIST_FLAG_*

    //
    // The number of entries in the list
    //
    ULONG Count;

    //
    // Every time an add/delete operation is performed on the list this is
    // incremented.  It is checked during iteration to ensure that the list
    // hasn't changed between GetFirst/GetNext or GetNext/GetNext calls
    //
    ULONG Stamp;

} RTL_RANGE_LIST, *PRTL_RANGE_LIST;

typedef struct _RANGE_LIST_ITERATOR {

    PLIST_ENTRY RangeListHead;
    PLIST_ENTRY MergedHead;
    PVOID Current;
    ULONG Stamp;

} RTL_RANGE_LIST_ITERATOR, *PRTL_RANGE_LIST_ITERATOR;

// end_ntddk end_nthal

VOID
NTAPI
RtlInitializeRangeListPackage(
    VOID
    );

// begin_ntddk begin_nthal

NTSYSAPI
VOID
NTAPI
RtlInitializeRangeList(
    IN OUT PRTL_RANGE_LIST RangeList
    );

NTSYSAPI
VOID
NTAPI
RtlFreeRangeList(
    IN PRTL_RANGE_LIST RangeList
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlCopyRangeList(
    OUT PRTL_RANGE_LIST CopyRangeList,
    IN PRTL_RANGE_LIST RangeList
    );

#define RTL_RANGE_LIST_ADD_IF_CONFLICT      0x00000001
#define RTL_RANGE_LIST_ADD_SHARED           0x00000002

NTSYSAPI
NTSTATUS
NTAPI
RtlAddRange(
    IN OUT PRTL_RANGE_LIST RangeList,
    IN ULONGLONG Start,
    IN ULONGLONG End,
    IN UCHAR Attributes,
    IN ULONG Flags,
    IN PVOID UserData,  OPTIONAL
    IN PVOID Owner      OPTIONAL
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlDeleteRange(
    IN OUT PRTL_RANGE_LIST RangeList,
    IN ULONGLONG Start,
    IN ULONGLONG End,
    IN PVOID Owner
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlDeleteOwnersRanges(
    IN OUT PRTL_RANGE_LIST RangeList,
    IN PVOID Owner
    );

#define RTL_RANGE_LIST_SHARED_OK           0x00000001
#define RTL_RANGE_LIST_NULL_CONFLICT_OK    0x00000002

typedef
BOOLEAN
(*PRTL_CONFLICT_RANGE_CALLBACK) (
    IN PVOID Context,
    IN PRTL_RANGE Range
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlFindRange(
    IN PRTL_RANGE_LIST RangeList,
    IN ULONGLONG Minimum,
    IN ULONGLONG Maximum,
    IN ULONG Length,
    IN ULONG Alignment,
    IN ULONG Flags,
    IN UCHAR AttributeAvailableMask,
    IN PVOID Context OPTIONAL,
    IN PRTL_CONFLICT_RANGE_CALLBACK Callback OPTIONAL,
    OUT PULONGLONG Start
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlIsRangeAvailable(
    IN PRTL_RANGE_LIST RangeList,
    IN ULONGLONG Start,
    IN ULONGLONG End,
    IN ULONG Flags,
    IN UCHAR AttributeAvailableMask,
    IN PVOID Context OPTIONAL,
    IN PRTL_CONFLICT_RANGE_CALLBACK Callback OPTIONAL,
    OUT PBOOLEAN Available
    );

#define FOR_ALL_RANGES(RangeList, Iterator, Current)            \
    for (RtlGetFirstRange((RangeList), (Iterator), &(Current)); \
         (Current) != NULL;                                     \
         RtlGetNextRange((Iterator), &(Current), TRUE)          \
         )

#define FOR_ALL_RANGES_BACKWARDS(RangeList, Iterator, Current)  \
    for (RtlGetLastRange((RangeList), (Iterator), &(Current));  \
         (Current) != NULL;                                     \
         RtlGetNextRange((Iterator), &(Current), FALSE)         \
         )

NTSYSAPI
NTSTATUS
NTAPI
RtlGetFirstRange(
    IN PRTL_RANGE_LIST RangeList,
    OUT PRTL_RANGE_LIST_ITERATOR Iterator,
    OUT PRTL_RANGE *Range
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlGetLastRange(
    IN PRTL_RANGE_LIST RangeList,
    OUT PRTL_RANGE_LIST_ITERATOR Iterator,
    OUT PRTL_RANGE *Range
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlGetNextRange(
    IN OUT PRTL_RANGE_LIST_ITERATOR Iterator,
    OUT PRTL_RANGE *Range,
    IN BOOLEAN MoveForwards
    );

#define RTL_RANGE_LIST_MERGE_IF_CONFLICT    RTL_RANGE_LIST_ADD_IF_CONFLICT

NTSYSAPI
NTSTATUS
NTAPI
RtlMergeRangeLists(
    OUT PRTL_RANGE_LIST MergedRangeList,
    IN PRTL_RANGE_LIST RangeList1,
    IN PRTL_RANGE_LIST RangeList2,
    IN ULONG Flags
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlInvertRangeList(
    OUT PRTL_RANGE_LIST InvertedRangeList,
    IN PRTL_RANGE_LIST RangeList
    );

// end_nthal

// begin_wdm

//
// Byte swap routines.  These are used to convert from little-endian to
// big-endian and vice-versa.
//

#if (defined(_M_IX86) && (_MSC_FULL_VER > 13009037)) || ((defined(_M_AMD64) || defined(_M_IA64)) && (_MSC_FULL_VER > 13009175))
#ifdef __cplusplus
extern "C" {
#endif
unsigned short __cdecl _byteswap_ushort(unsigned short);
unsigned long  __cdecl _byteswap_ulong (unsigned long);
unsigned __int64 __cdecl _byteswap_uint64(unsigned __int64);
#ifdef __cplusplus
}
#endif
#pragma intrinsic(_byteswap_ushort)
#pragma intrinsic(_byteswap_ulong)
#pragma intrinsic(_byteswap_uint64)

#define RtlUshortByteSwap(_x)    _byteswap_ushort((USHORT)(_x))
#define RtlUlongByteSwap(_x)     _byteswap_ulong((_x))
#define RtlUlonglongByteSwap(_x) _byteswap_uint64((_x))
#else
USHORT
FASTCALL
RtlUshortByteSwap(
    IN USHORT Source
    );

ULONG
FASTCALL
RtlUlongByteSwap(
    IN ULONG Source
    );

ULONGLONG
FASTCALL
RtlUlonglongByteSwap(
    IN ULONGLONG Source
    );
#endif

// end_wdm

// begin_ntifs

//
// Routine for converting from a volume device object to a DOS name.
//

NTSYSAPI
NTSTATUS
NTAPI
RtlVolumeDeviceToDosName(
    IN  PVOID           VolumeDeviceObject,
    OUT PUNICODE_STRING DosName
    );

// end_ntifs end_ntddk

// begin_ntifs

//
// Routine for verifying or creating the "System Volume Information"
// folder on NTFS volumes.
//

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateSystemVolumeInformationFolder(
    IN  PUNICODE_STRING VolumeRootPath
    );

#define RTL_SYSTEM_VOLUME_INFORMATION_FOLDER    L"System Volume Information"

// end_ntifs

//
// XONLINE
//
#if 0
// begin_winnt begin_ntddk begin_ntifs
typedef struct _OSVERSIONINFOA {
    ULONG dwOSVersionInfoSize;
    ULONG dwMajorVersion;
    ULONG dwMinorVersion;
    ULONG dwBuildNumber;
    ULONG dwPlatformId;
    CHAR   szCSDVersion[ 128 ];     // Maintenance string for PSS usage
} OSVERSIONINFOA, *POSVERSIONINFOA, *LPOSVERSIONINFOA;

typedef struct _OSVERSIONINFOW {
    ULONG dwOSVersionInfoSize;
    ULONG dwMajorVersion;
    ULONG dwMinorVersion;
    ULONG dwBuildNumber;
    ULONG dwPlatformId;
    WCHAR  szCSDVersion[ 128 ];     // Maintenance string for PSS usage
} OSVERSIONINFOW, *POSVERSIONINFOW, *LPOSVERSIONINFOW, RTL_OSVERSIONINFOW, *PRTL_OSVERSIONINFOW;
#ifdef UNICODE
typedef OSVERSIONINFOW OSVERSIONINFO;
typedef POSVERSIONINFOW POSVERSIONINFO;
typedef LPOSVERSIONINFOW LPOSVERSIONINFO;
#else
typedef OSVERSIONINFOA OSVERSIONINFO;
typedef POSVERSIONINFOA POSVERSIONINFO;
typedef LPOSVERSIONINFOA LPOSVERSIONINFO;
#endif // UNICODE

typedef struct _OSVERSIONINFOEXA {
    ULONG dwOSVersionInfoSize;
    ULONG dwMajorVersion;
    ULONG dwMinorVersion;
    ULONG dwBuildNumber;
    ULONG dwPlatformId;
    CHAR   szCSDVersion[ 128 ];     // Maintenance string for PSS usage
    USHORT wServicePackMajor;
    USHORT wServicePackMinor;
    USHORT wSuiteMask;
    UCHAR wProductType;
    UCHAR wReserved;
} OSVERSIONINFOEXA, *POSVERSIONINFOEXA, *LPOSVERSIONINFOEXA;
typedef struct _OSVERSIONINFOEXW {
    ULONG dwOSVersionInfoSize;
    ULONG dwMajorVersion;
    ULONG dwMinorVersion;
    ULONG dwBuildNumber;
    ULONG dwPlatformId;
    WCHAR  szCSDVersion[ 128 ];     // Maintenance string for PSS usage
    USHORT wServicePackMajor;
    USHORT wServicePackMinor;
    USHORT wSuiteMask;
    UCHAR wProductType;
    UCHAR wReserved;
} OSVERSIONINFOEXW, *POSVERSIONINFOEXW, *LPOSVERSIONINFOEXW, RTL_OSVERSIONINFOEXW, *PRTL_OSVERSIONINFOEXW;
#ifdef UNICODE
typedef OSVERSIONINFOEXW OSVERSIONINFOEX;
typedef POSVERSIONINFOEXW POSVERSIONINFOEX;
typedef LPOSVERSIONINFOEXW LPOSVERSIONINFOEX;
#else
typedef OSVERSIONINFOEXA OSVERSIONINFOEX;
typedef POSVERSIONINFOEXA POSVERSIONINFOEX;
typedef LPOSVERSIONINFOEXA LPOSVERSIONINFOEX;
#endif // UNICODE
#endif
//
// end XONLINE
//

//
// RtlVerifyVersionInfo() conditions
//

#define VER_EQUAL                       1
#define VER_GREATER                     2
#define VER_GREATER_EQUAL               3
#define VER_LESS                        4
#define VER_LESS_EQUAL                  5
#define VER_AND                         6
#define VER_OR                          7

#define VER_CONDITION_MASK              7
#define VER_NUM_BITS_PER_CONDITION_MASK 3

//
// RtlVerifyVersionInfo() type mask bits
//

#define VER_MINORVERSION                0x0000001
#define VER_MAJORVERSION                0x0000002
#define VER_BUILDNUMBER                 0x0000004
#define VER_PLATFORMID                  0x0000008
#define VER_SERVICEPACKMINOR            0x0000010
#define VER_SERVICEPACKMAJOR            0x0000020
#define VER_SUITENAME                   0x0000040
#define VER_PRODUCT_TYPE                0x0000080

//
// RtlVerifyVersionInfo() os product type values
//

#define VER_NT_WORKSTATION              0x0000001
#define VER_NT_DOMAIN_CONTROLLER        0x0000002
#define VER_NT_SERVER                   0x0000003

//
// dwPlatformId defines:
//

#define VER_PLATFORM_WIN32s             0
#define VER_PLATFORM_WIN32_WINDOWS      1
#define VER_PLATFORM_WIN32_NT           2


//
//
// VerifyVersionInfo() macro to set the condition mask
//
// For documentation sakes here's the old version of the macro that got
// changed to call an API
// #define VER_SET_CONDITION(_m_,_t_,_c_)  _m_=(_m_|(_c_<<(1<<_t_)))
//

#define VER_SET_CONDITION(_m_,_t_,_c_)  \
        ((_m_)=VerSetConditionMask((_m_),(_t_),(_c_)))

//
// XONLINE
//
#if 0
ULONGLONG
NTAPI
VerSetConditionMask(
        IN  ULONGLONG   ConditionMask,
        IN  ULONG   TypeMask,
        IN  UCHAR   Condition
        );
#endif
//
// end XONLINE
//

//
// end_winnt
//

NTSYSAPI
NTSTATUS
RtlGetVersion(
    OUT PRTL_OSVERSIONINFOW lpVersionInformation
    );

NTSYSAPI
NTSTATUS
RtlVerifyVersionInfo(
    IN PRTL_OSVERSIONINFOEXW VersionInfo,
    IN ULONG TypeMask,
    IN ULONGLONG  ConditionMask
    );

//
// end_ntddk end_ntifs
//

typedef
NTSTATUS
(*PRTL_SECURE_MEMORY_CACHE_CALLBACK) (
    IN PVOID Addr,
    IN SIZE_T Range
    );

NTSTATUS
RtlRegisterSecureMemoryCacheCallback(
    IN PRTL_SECURE_MEMORY_CACHE_CALLBACK CallBack
    );

BOOLEAN
RtlFlushSecureMemoryCache(
    PVOID   lpAddr,
    SIZE_T  size
    );


ULONG32
RtlComputeCrc32(
    IN ULONG32 PartialCrc,
    IN PVOID Buffer,
    IN ULONG Length
    );

PPEB
RtlGetCurrentPeb (
    VOID
    );

ULONG
FASTCALL
RtlInterlockedSetClearBits (
    IN OUT PULONG Flags,
    IN ULONG sFlag,
    IN ULONG cFlag
    );

// begin_ntddk begin_ntifs
//
// Interlocked bit manipulation interfaces
//

#define RtlInterlockedSetBits(Flags, Flag) \
    InterlockedOr((PLONG)(Flags), Flag)

#define RtlInterlockedAndBits(Flags, Flag) \
    InterlockedAnd((PLONG)(Flags), Flag)

#define RtlInterlockedClearBits(Flags, Flag) \
    RtlInterlockedAndBits(Flags, ~(Flag))

#define RtlInterlockedXorBits(Flags, Flag) \
    InterlockedXor(Flags, Flag)

#define RtlInterlockedSetBitsDiscardReturn(Flags, Flag) \
    (VOID) RtlInterlockedSetBits(Flags, Flag)

#define RtlInterlockedAndBitsDiscardReturn(Flags, Flag) \
    (VOID) RtlInterlockedAndBits(Flags, Flag)

#define RtlInterlockedClearBitsDiscardReturn(Flags, Flag) \
    RtlInterlockedAndBitsDiscardReturn(Flags, ~(Flag))

// end_ntddk end_ntifs

//#include "ntrtlstringandbuffer.h"
//#include "ntrtlpath.h"

NTSTATUS
NTAPI
RtlGetLastNtStatus(
    VOID
    );

NTSYSAPI
LONG
NTAPI
RtlGetLastWin32Error(
    VOID
    );

NTSYSAPI
VOID
NTAPI
RtlSetLastWin32ErrorAndNtStatusFromNtStatus(
    NTSTATUS Status
    );

NTSYSAPI
VOID
NTAPI
RtlSetLastWin32Error(
    LONG Win32Error
    );

//
// This differs from RtlSetLastWin32Error in that.
//  - it is a different function, so breakpoints on RtlSetLastWin32Error won't fire when you call it
//  - #if DBG, it only writes if the current value is unequal, so data breakpoints won't fire as much
//
NTSYSAPI
VOID
NTAPI
RtlRestoreLastWin32Error(
    LONG Win32Error
    );

//
// Routines to manipulate boot status data.
//

typedef enum {
    RtlBsdItemVersionNumber = 0x00,
    RtlBsdItemProductType,
    RtlBsdItemAabEnabled,
    RtlBsdItemAabTimeout,
    RtlBsdItemBootGood,
    RtlBsdItemBootShutdown,
    RtlBsdItemMax
} RTL_BSD_ITEM_TYPE, *PRTL_BSD_ITEM_TYPE;

NTSYSAPI
NTSTATUS
NTAPI
RtlGetSetBootStatusData(
    IN HANDLE Handle,
    IN BOOLEAN Get,
    IN RTL_BSD_ITEM_TYPE DataItem,
    IN PVOID DataBuffer,
    IN ULONG DataBufferLength,
    OUT PULONG ByteRead OPTIONAL
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlLockBootStatusData(
    OUT PHANDLE BootStatusDataHandle
    );

NTSYSAPI
VOID
NTAPI
RtlUnlockBootStatusData(
    IN HANDLE BootStatusDataHandle
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateBootStatusDataFile(
    VOID
    );


#define RTL_ERRORMODE_FAILCRITICALERRORS (0x0010)

#if !defined(MIDL_PASS) && !defined(SORTPP_PASS)

FORCEINLINE
BOOLEAN
RtlUnsignedAddWithCarryOut32(
    unsigned __int32 *pc,
    unsigned __int32 a,
    unsigned __int32 b
    )
{
    unsigned __int32 c;

    c = a + b;
    *pc = c;
    return (c >= a && c >= b) ? 0 : 1;
}

FORCEINLINE
BOOLEAN
RtlUnsignedAddWithCarryOut64(
    unsigned __int64 *pc,
    unsigned __int64 a,
    unsigned __int64 b
    )
{
    unsigned __int64 c;

    c = a + b;
    *pc = c;
    return (c >= a && c >= b) ? 0 : 1;
}

FORCEINLINE
BOOLEAN
RtlSignedAddWithOverflowOut32(
    __int32 *pc,
    __int32 a,
    __int32 b
    )
{
    __int32 c;

    c = a + b;
    *pc = c;

    //
    // negative + positive -> no overflow
    // positive + negative -> no overflow
    // positive + positive -> overflow if result is not positive
    // negative + negative -> overflow if result is not negative
    //
    // aka -- no overflow if result's sign is the same as either input's sign.
    //
    return (((c < 0) == (a < 0)) || ((c < 0) == (b < 0))) ? 0 : 1;
}

FORCEINLINE
BOOLEAN
RtlSignedAddWithOverflowOut64(
    __int64 *pc,
    __int64 a,
    __int64 b
    )
{
    __int64 c;

    c = a + b;
    *pc = c;

    return (((c < 0) == (a < 0)) || ((c < 0) == (b < 0))) ? 0 : 1;
}

#define RTLP_ADD_WITH_CARRY_OUT(FunctionName, Type, BaseFunction, BaseType) \
FORCEINLINE \
BOOLEAN \
FunctionName( \
    Type *pc, \
    Type a, \
    Type b \
    ) \
{ \
    return BaseFunction((BaseType*)pc, a, b); \
}

#define RTLP_ADD_WITH_OVERFLOW_OUT RTLP_ADD_WITH_CARRY_OUT

#define RTLP_ADD_WITH_CARRY_OUT_UNSIGNED32(FunctionName, Type) \
    RTLP_ADD_WITH_CARRY_OUT(FunctionName, Type, RtlUnsignedAddWithCarryOut32, unsigned __int32)

#define RTLP_ADD_WITH_CARRY_OUT_UNSIGNED64(FunctionName, Type) \
    RTLP_ADD_WITH_CARRY_OUT(FunctionName, Type, RtlUnsignedAddWithCarryOut64, unsigned __int64)

#define RTLP_ADD_WITH_OVERFLOW_OUT_SIGNED32(FunctionName, Type) \
    RTLP_ADD_WITH_OVERFLOW_OUT(FunctionName, Type, RtlSignedAddWithOverflowOut32, __int32)

#define RTLP_ADD_WITH_OVERFLOW_OUT_SIGNED64(FunctionName, Type) \
    RTLP_ADD_WITH_OVERFLOW_OUT(FunctionName, Type, RtlSignedAddWithOverflowOut64, __int64)

#if !defined(_WIN64)
#define RTLP_ADD_WITH_CARRY_OUT_UNSIGNED_PTR(FunctionName, Type)    RTLP_ADD_WITH_CARRY_OUT_UNSIGNED32(FunctionName, Type)
#define RTLP_ADD_WITH_OVERFLOW_OUT_SIGNED_PTR(FunctionName, Type)   RTLP_ADD_WITH_OVERFLOW_OUT_SIGNED32(FunctionName, Type)
#else
#define RTLP_ADD_WITH_CARRY_OUT_UNSIGNED_PTR(FunctionName, Type)    RTLP_ADD_WITH_CARRY_OUT_UNSIGNED64(FunctionName, Type)
#define RTLP_ADD_WITH_OVERFLOW_OUT_SIGNED_PTR(FunctionName, Type)   RTLP_ADD_WITH_OVERFLOW_OUT_SIGNED64(FunctionName, Type)
#endif

RTLP_ADD_WITH_CARRY_OUT_UNSIGNED32(RtlAddWithCarryOutUint, unsigned int) /* aka UINT */
RTLP_ADD_WITH_CARRY_OUT_UNSIGNED32(RtlAddWithCarryOutUint32, UINT32)
RTLP_ADD_WITH_CARRY_OUT_UNSIGNED32(RtlAddWithCarryOutUlong, ULONG)
RTLP_ADD_WITH_CARRY_OUT_UNSIGNED32(RtlAddWithCarryOutUlong32, ULONG32)
RTLP_ADD_WITH_CARRY_OUT_UNSIGNED32(RtlAddWithCarryOutDword, unsigned long) /* aka DWORD */
RTLP_ADD_WITH_CARRY_OUT_UNSIGNED32(RtlAddWithCarryOutDword32, DWORD32)
RTLP_ADD_WITH_CARRY_OUT_UNSIGNED64(RtlAddWithCarryOutUint64, UINT64)
RTLP_ADD_WITH_CARRY_OUT_UNSIGNED64(RtlAddWithCarryOutUlong64, ULONG64)
RTLP_ADD_WITH_CARRY_OUT_UNSIGNED64(RtlAddWithCarryOutDword64, DWORD64)
RTLP_ADD_WITH_CARRY_OUT_UNSIGNED64(RtlAddWithCarryOutUlonglong, ULONGLONG)
RTLP_ADD_WITH_OVERFLOW_OUT_SIGNED32(RtlAddWithOverflowOutInt, int) /* aka INT */
RTLP_ADD_WITH_OVERFLOW_OUT_SIGNED32(RtlAddWithOverflowOutInt32, INT32)
RTLP_ADD_WITH_OVERFLOW_OUT_SIGNED32(RtlAddWithOverflowOutLong, LONG)
RTLP_ADD_WITH_OVERFLOW_OUT_SIGNED32(RtlAddWithOverflowOutLong32, LONG32)
RTLP_ADD_WITH_OVERFLOW_OUT_SIGNED64(RtlAddWithOverflowOutInt64, INT64)
RTLP_ADD_WITH_OVERFLOW_OUT_SIGNED64(RtlAddWithOverflowOutLong64, LONG64)
RTLP_ADD_WITH_OVERFLOW_OUT_SIGNED64(RtlAddWithOverflowOutLongLong, LONGLONG)

RTLP_ADD_WITH_CARRY_OUT_UNSIGNED_PTR(RtlAddWithCarryOutUintPtr, UINT_PTR)
RTLP_ADD_WITH_CARRY_OUT_UNSIGNED_PTR(RtlAddWithCarryOutUlongPtr, ULONG_PTR)
RTLP_ADD_WITH_CARRY_OUT_UNSIGNED_PTR(RtlAddWithCarryOutDwordPtr, DWORD_PTR)
RTLP_ADD_WITH_CARRY_OUT_UNSIGNED_PTR(RtlAddWithCarryOutSizet, SIZE_T)

RTLP_ADD_WITH_OVERFLOW_OUT_SIGNED_PTR(RtlAddWithOverflowOutIntPtr, INT_PTR)
RTLP_ADD_WITH_OVERFLOW_OUT_SIGNED_PTR(RtlAddWithOverflowOutLongPtr, LONG_PTR)
RTLP_ADD_WITH_OVERFLOW_OUT_SIGNED_PTR(RtlAddWithOverflowOutSsizet, SSIZE_T)

#undef RTLP_ADD_WITH_CARRY_OUT
#undef RTLP_ADD_WITH_OVERFLOW_OUT
#undef RTLP_ADD_WITH_CARRY_OUT_UNSIGNED32
#undef RTLP_ADD_WITH_CARRY_OUT_UNSIGNED64
#undef RTLP_ADD_WITH_CARRY_OUT_UNSIGNED_PTR
#undef RTLP_ADD_WITH_OVERFLOW_OUT_SIGNED32
#undef RTLP_ADD_WITH_OVERFLOW_OUT_SIGNED64
#undef RTLP_ADD_WITH_OVERFLOW_OUT_SIGNED_PTR

#endif // !defined(MIDL_PASS) && !defined(SORTPP_PASS)

//
// Get information from the correct TEB
//

#if defined(BUILD_WOW6432)
#define RtlIsImpersonating() (NtCurrentTeb64()->IsImpersonating ? TRUE : FALSE)
#else
#define RtlIsImpersonating() (NtCurrentTeb()->IsImpersonating ? TRUE : FALSE)
#endif

#ifdef __cplusplus
}       // extern "C"
#endif

#if defined (_MSC_VER) && ( _MSC_VER >= 800 )
#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4001)
#pragma warning(default:4201)
#pragma warning(default:4214)
#endif
#endif

// begin_ntddk begin_wdm begin_nthal begin_ntifs begin_ntndis
//
// Component name filter id enumeration and levels.
//

#define DPFLTR_ERROR_LEVEL 0
#define DPFLTR_WARNING_LEVEL 1
#define DPFLTR_TRACE_LEVEL 2
#define DPFLTR_INFO_LEVEL 3
#define DPFLTR_MASK 0x80000000

typedef enum _DPFLTR_TYPE {
    DPFLTR_SYSTEM_ID = 0,
    DPFLTR_SMSS_ID = 1,
    DPFLTR_SETUP_ID = 2,
    DPFLTR_NTFS_ID = 3,
    DPFLTR_FSTUB_ID = 4,
    DPFLTR_CRASHDUMP_ID = 5,
    DPFLTR_CDAUDIO_ID = 6,
    DPFLTR_CDROM_ID = 7,
    DPFLTR_CLASSPNP_ID = 8,
    DPFLTR_DISK_ID = 9,
    DPFLTR_REDBOOK_ID = 10,
    DPFLTR_STORPROP_ID = 11,
    DPFLTR_SCSIPORT_ID = 12,
    DPFLTR_SCSIMINIPORT_ID = 13,
    DPFLTR_CONFIG_ID = 14,
    DPFLTR_I8042PRT_ID = 15,
    DPFLTR_SERMOUSE_ID = 16,
    DPFLTR_LSERMOUS_ID = 17,
    DPFLTR_KBDHID_ID = 18,
    DPFLTR_MOUHID_ID = 19,
    DPFLTR_KBDCLASS_ID = 20,
    DPFLTR_MOUCLASS_ID = 21,
    DPFLTR_TWOTRACK_ID = 22,
    DPFLTR_WMILIB_ID = 23,
    DPFLTR_ACPI_ID = 24,
    DPFLTR_AMLI_ID = 25,
    DPFLTR_HALIA64_ID = 26,
    DPFLTR_VIDEO_ID = 27,
    DPFLTR_SVCHOST_ID = 28,
    DPFLTR_VIDEOPRT_ID = 29,
    DPFLTR_TCPIP_ID = 30,
    DPFLTR_DMSYNTH_ID = 31,
    DPFLTR_NTOSPNP_ID = 32,
    DPFLTR_FASTFAT_ID = 33,
    DPFLTR_SAMSS_ID = 34,
    DPFLTR_PNPMGR_ID = 35,
    DPFLTR_NETAPI_ID = 36,
    DPFLTR_SCSERVER_ID = 37,
    DPFLTR_SCCLIENT_ID = 38,
    DPFLTR_SERIAL_ID = 39,
    DPFLTR_SERENUM_ID = 40,
    DPFLTR_UHCD_ID = 41,
    DPFLTR_RPCPROXY_ID = 42,
    DPFLTR_AUTOCHK_ID = 43,
    DPFLTR_DCOMSS_ID = 44,
    DPFLTR_UNIMODEM_ID = 45,
    DPFLTR_SIS_ID = 46,
    DPFLTR_FLTMGR_ID = 47,
    DPFLTR_WMICORE_ID = 48,
    DPFLTR_BURNENG_ID = 49,
    DPFLTR_IMAPI_ID = 50,
    DPFLTR_SXS_ID = 51,
    DPFLTR_FUSION_ID = 52,
    DPFLTR_IDLETASK_ID = 53,
    DPFLTR_SOFTPCI_ID = 54,
    DPFLTR_TAPE_ID = 55,
    DPFLTR_MCHGR_ID = 56,
    DPFLTR_IDEP_ID = 57,
    DPFLTR_PCIIDE_ID = 58,
    DPFLTR_FLOPPY_ID = 59,
    DPFLTR_FDC_ID = 60,
    DPFLTR_TERMSRV_ID = 61,
    DPFLTR_W32TIME_ID = 62,
    DPFLTR_PREFETCHER_ID = 63,
    DPFLTR_RSFILTER_ID = 64,
    DPFLTR_FCPORT_ID = 65,
    DPFLTR_PCI_ID = 66,
    DPFLTR_DMIO_ID = 67,
    DPFLTR_DMCONFIG_ID = 68,
    DPFLTR_DMADMIN_ID = 69,
    DPFLTR_WSOCKTRANSPORT_ID = 70,
    DPFLTR_VSS_ID = 71,
    DPFLTR_PNPMEM_ID = 72,
    DPFLTR_PROCESSOR_ID = 73,
    DPFLTR_DMSERVER_ID = 74,
    DPFLTR_SR_ID = 75,
    DPFLTR_INFINIBAND_ID = 76,
    DPFLTR_IHVDRIVER_ID = 77,
    DPFLTR_IHVVIDEO_ID = 78,
    DPFLTR_IHVAUDIO_ID = 79,
    DPFLTR_IHVNETWORK_ID = 80,
    DPFLTR_IHVSTREAMING_ID = 81,
    DPFLTR_IHVBUS_ID = 82,
    DPFLTR_HPS_ID = 83,
    DPFLTR_RTLTHREADPOOL_ID = 84,
    DPFLTR_LDR_ID = 85,
    DPFLTR_TCPIP6_ID = 86,
    DPFLTR_ISAPNP_ID = 87,
    DPFLTR_SHPC_ID = 88,
    DPFLTR_STORPORT_ID = 89,
    DPFLTR_STORMINIPORT_ID = 90,
    DPFLTR_PRINTSPOOLER_ID = 91,
    DPFLTR_VSSDYNDISK_ID = 92,
    DPFLTR_VERIFIER_ID = 93,
    DPFLTR_VDS_ID = 94,
    DPFLTR_VDSBAS_ID = 95,
    DPFLTR_VDSDYNDR_ID = 96,
    DPFLTR_VDSUTIL_ID = 97,
    DPFLTR_DFRGIFC_ID = 98,
    DPFLTR_ENDOFTABLE_ID
} DPFLTR_TYPE;

// end_ntddk end_wdm end_nthal end_ntifs end_ntndis
#endif // _NTRTL_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\pubinc\kerbalerts.h ===
//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//


//
// MessageId: EVCAT_CORE
//
// MessageText:
//
//  KDC Core
//
#define EVCAT_CORE                       0x00000001L

//
// MessageId: EVCAT_PROVIDER
//
// MessageText:
//
//  KDC Provider
//
#define EVCAT_PROVIDER                   0x00000002L

//
// MessageId: PPKDC_STARTED
//
// MessageText:
//
//  KDC Service started successfully
//
#define PPKDC_STARTED                    0x40000064L

//
// MessageId: PPPROVIDER_LOADED
//
// MessageText:
//
//  Passport Provider loaded successfully
//
#define PPPROVIDER_LOADED                0x40000065L

//
// MessageId: PPPROVIDER_UNLOADED
//
// MessageText:
//
//  Passport Provider unloaded
//
#define PPPROVIDER_UNLOADED              0x40000066L

//
// MessageId: FAILED_TO_LOAD_PPPROVIDER
//
// MessageText:
//
//  Failed to load Passport provider
//
#define FAILED_TO_LOAD_PPPROVIDER        0x40000067L

//
// MessageId: PPKDC_FAILED
//
// MessageText:
//
//  KDC Service failed
//
#define PPKDC_FAILED                     0xC0000068L

//
// MessageId: PPKDC_STOPPED
//
// MessageText:
//
//  KDC Service was stopped
//
#define PPKDC_STOPPED                    0xC0000069L

//
// MessageId: PROVIDER_LOADED
//
// MessageText:
//
//  Provider in (%1) was loaded successfully
//
#define PROVIDER_LOADED                  0xC000006AL

//
// MessageId: PROVIDER_LOAD_FAILED
//
// MessageText:
//
//  Couldn't load provider in (%1) 
//   //
#define PROVIDER_LOAD_FAILED             0xC000006BL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\pubinc\pacext.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001
//
//  File:       pacext.h
//
//  Contents:   PAC structures
//
//  Classes:
//
//  Functions:
//
//  History:    23-July-2001    JBrezak
//
//----------------------------------------------------------------------------

//
// GUID for the PAC info structure (Data is a PSAMPR_USER_ALL_INFORMATION)
//
#ifndef __PACEXT_H__
#define __PACEXT_H__

#ifdef DEFINE_GUIDS
    CONST GUID Kdb_PacUserInfoId = { // 73ccf8d4-7365-4925-aae2-b0a21825
        0x73ccf8d4,
        0x7365,
        0x4925,
        {0xaa, 0xe2, 0xb0, 0xa2, 0x18, 0x25, 0xad, 0xdb}
        };
#else
     extern CONST GUID Kdb_PacUserInfoId;
#endif

typedef enum {
    CT_Unknown,
    CT_Password,
    CT_RandomKey,
    CT_Certificate,
    CT_PIN,
    CT_SID,
    CT_RawPassport,
    CT_EncryptedPassport
    } CREDTYPE;

typedef enum {
    ID_PUID
    } IDTYPE;

typedef enum {
    IA_USER = 0,
    IA_MACHINE
    } IDATTRIBUTE;

typedef struct _IDENTITY {
    DWORD       LengthOfIdentity;   // Length of IDENDITIY structure
    DWORD       IdentityAttributes; // IA_USER or IA_MACHINE
    IDTYPE      IdentityType;
    CREDTYPE    CredentialIdType;
    BYTE        Identity[ANYSIZE_ARRAY];
    BYTE        CredentialIdentity[ANYSIZE_ARRAY];  // Present only if CREDTYPE==SID
} IDENTITY, *PIDENTITY;
typedef const IDENTITY  *PCIDENTITY;

//  compound identity struct
typedef struct _COMPOUND_IDENTITY {
    USHORT          NumberOfIdentities;
    IDENTITY        Identities[ANYSIZE_ARRAY];
} COMPOUND_IDENTITY, *PCOMPOUND_IDENTITY;
typedef const COMPOUND_IDENTITY *PCCOMPOUND_IDENTITY;

#define XBOX_IDENTITY_MAX_USERS 4

// Xbox Identity structure
#include <pshpack1.h>
typedef struct _XBOX_IDENTITY {
    ULONGLONG   MachineIdentity;
    ULONGLONG   UserIdentity[XBOX_IDENTITY_MAX_USERS];
    UCHAR       MachineIdentityCredential;
    UCHAR       UserIdentityCredential[XBOX_IDENTITY_MAX_USERS];
} XBOX_IDENTITY, *PXBOX_IDENTITY;
#include <poppack.h>
typedef const XBOX_IDENTITY *PCXBOX_IDENTITY;

#define MAX_COMPOUND_IDENTITY 4

#endif //__PACEXT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\pubinc\kerbtrans.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001-2002
//
//  File:       kerbtrans.h
//
//  Contents:   KERB_MESSAGE_BUFFER structure. Transport related definitions
//        that are used in both the transport and core.
//
//  Classes:
//
//  Functions:
//
//  History:    6-Jan-2002    kokwaic
//
//----------------------------------------------------------------------------
#ifndef __KERBTRANS_H__
#define __KERBTRANS_H__

typedef struct _KERB_MESSAGE_BUFFER {
    ULONG BufferSize;
    PUCHAR Buffer;
} KERB_MESSAGE_BUFFER, *PKERB_MESSAGE_BUFFER;

#define KERB_MAX_KDC_REQUEST_SIZE       4000
#define KERB_KDC_PORT                   88
#define KERB_KPASSWD_PORT               464

//
//  ATQ configuration parameters.
//  -1 implies default should be used.
//
#define ATQ_CONFIG_PARM_DEFAULT    ((DWORD)-1)
typedef struct 
{
    DWORD   dwThreads;              //defaults to 128 threads
    DWORD   dwConcurrentThreads;    //defaults to 0; system decides.
    DWORD   dwsecThreadTimeOut;     //defaults to 12 hours
    DWORD   dwMinKBTimeOut;         //defaults to 1 KB
}ATQ_CONFIG_PARM;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\rtl\pacint.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 2001
//
// File:        pacint.hxx
//
// Contents:    internal structures and definitions for encoding PACs
//
//
// History:     31-Aug-2001   JBrezak   Created
//
//------------------------------------------------------------------------

#ifndef _PACINT_H_
#define _PACINT_H_

typedef struct _PAC_BUFFER_STATE {
    PBYTE   BufferPointer;
    ULONG   BufferSize;
} PAC_BUFFER_STATE, *PPAC_BUFFER_STATE;

VOID NTAPI
PacAllocFcn(
    IN OUT  PVOID pvState,
    OUT PCHAR * ppbOut,
    IN PUINT32 pulSize
    );

VOID NTAPI
PacWriteFcn(
    IN OUT PVOID pvState,
    OUT PCHAR pbOut,
    IN UINT32 ulSize
    );

VOID NTAPI
PacReadFcn(
    IN OUT PVOID pvState,
    OUT PCHAR * ppbOut,
    IN OUT PUINT32 pulSize
    );

NTSTATUS
PAC_EncodeValidationInformation(
    IN PPAC_NETLOGON_VALIDATION_SAM_INFO3 ValidationInfo,
    OUT PBYTE * EncodedData,
    OUT PULONG DataSize
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\rtl\pacfcn.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1996
//
// File:        pacfcn.cxx
//
// Contents:    Common PAC functions
//
// Description:
//
//
// History:     23-Jan-96   MikeSw      Created
//
//------------------------------------------------------------------------

#include "rtlp.h"


//+-------------------------------------------------------------------------
//
//  Function:   Helper Functions for NDR encoding data types
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID NTAPI
PacAllocFcn(
    IN OUT  PVOID pvState,
    OUT PCHAR * ppbOut,
    IN PUINT32 pulSize
    )
{
    PPAC_BUFFER_STATE state = (PPAC_BUFFER_STATE) pvState;

    //
    // MIDL pickling calls this routine with the size of the object
    // obtained by _GetSize(). This routine must return a buffer in
    // ppbOut with at least *pulSize bytes.
    //

    DsysAssert( state->BufferPointer != NULL );
    DsysAssert( state->BufferSize >= *pulSize );

    *ppbOut = (char*)state->BufferPointer;
    state->BufferPointer += *pulSize;
    state->BufferSize -= *pulSize;
}

VOID NTAPI
PacWriteFcn(
    IN OUT PVOID pvState,
    OUT PCHAR pbOut,
    IN UINT32 ulSize
    )
{
    //
    // Since the data was pickled directly to the target buffer, don't
    // do anything here.
    //
}

VOID NTAPI
PacReadFcn(
    IN OUT PVOID pvState,
    OUT PCHAR * ppbOut,
    IN OUT PUINT32 pulSize
    )
{
    PPAC_BUFFER_STATE state = (PPAC_BUFFER_STATE) pvState;

    //
    // MIDL pickling calls this routine with the size to read.
    // This routine must return a buffer in ppbOut which contains the
    // encoded data.
    //

    DsysAssert( state->BufferPointer != NULL );
    DsysAssert( state->BufferSize >= *pulSize );

    *ppbOut = (char*)state->BufferPointer;
    state->BufferPointer += *pulSize;
    state->BufferSize -= *pulSize;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\rtl\pac.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1996
//
// File:        pac.cxx
//
// Contents:    Implementation of routines to manipulate new PACs
//
// Description:
//
//
// History:     23-Jan-96   MikeSw      Created
//
//------------------------------------------------------------------------

#include "rtlp.h"


//+-------------------------------------------------------------------------
//
//  Function:   PAC_EncodeValidationInformation
//
//  Synopsis:   NDR encodes the validation information
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
PAC_EncodeValidationInformation(
    IN PPAC_NETLOGON_VALIDATION_SAM_INFO3 ValidationInfo,
    OUT PBYTE * EncodedData,
    OUT PULONG DataSize
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    handle_t PickleHandle = 0;
    PAC_BUFFER_STATE BufferState = {0};
    ULONG EncodingStatus = 0;
    PUCHAR OutputBuffer = NULL;
    ULONG OutputSize = 0;


    EncodingStatus = MesEncodeIncrementalHandleCreate(
                        &BufferState,
                        PacAllocFcn,
                        PacWriteFcn,
                        &PickleHandle
                        );
    if (EncodingStatus != 0)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Calculate the size of the required buffer
    //

    OutputSize = (ULONG) PPAC_IDL_VALIDATION_INFO_AlignSize(
                                        PickleHandle,
                                        &ValidationInfo
                                        );

    OutputBuffer = (PBYTE) MIDL_user_allocate(OutputSize);
    if (OutputBuffer == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    BufferState.BufferSize = OutputSize;
    BufferState.BufferPointer = OutputBuffer;

    //
    // Now encode the structure
    //

    MesIncrementalHandleReset(
        PickleHandle,
        NULL,
        NULL,
        NULL,
        NULL,
        MES_ENCODE
        );

    PPAC_IDL_VALIDATION_INFO_Encode(
        PickleHandle,
        &ValidationInfo
        );

    *EncodedData = OutputBuffer;
    *DataSize = OutputSize;
    OutputBuffer = NULL;

Cleanup:
    if (OutputBuffer != NULL)
    {
        MIDL_user_free(OutputBuffer);
    }
    if (PickleHandle != NULL)
    {
        MesHandleFree(PickleHandle);
    }

    return(Status);
}



//+-------------------------------------------------------------------------
//
//  Function:   PAC_DecodeValidationInformation
//
//  Synopsis:   NDR decodes the validation information
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
PAC_DecodeValidationInformation(
    IN PBYTE EncodedData,
    IN ULONG DataSize,
    OUT PPAC_NETLOGON_VALIDATION_SAM_INFO3 * ValidationInfo
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    handle_t PickleHandle = 0;
    PAC_BUFFER_STATE BufferState = {0};
    ULONG EncodingStatus = 0;

    DsysAssert(ROUND_UP_POINTER(EncodedData,8) == (PVOID) EncodedData);

    EncodingStatus = MesDecodeIncrementalHandleCreate(
                        &BufferState,
                        PacReadFcn,
                        &PickleHandle
                        );
    if (EncodingStatus != 0)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    BufferState.BufferSize = DataSize;
    BufferState.BufferPointer = EncodedData;
    __try {
        PPAC_IDL_VALIDATION_INFO_Decode(
            PickleHandle,
            ValidationInfo
            );
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

Cleanup:
    if (PickleHandle != NULL)
    {
        MesHandleFree(PickleHandle);
    }

    return(Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   PAC_EncodeCredentialData
//
//  Synopsis:   NDR encodes the credential data
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
PAC_EncodeCredentialData(
    IN PSECPKG_SUPPLEMENTAL_CRED_ARRAY CredentialData,
    OUT PBYTE * EncodedData,
    OUT PULONG DataSize
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    handle_t PickleHandle = 0;
    PAC_BUFFER_STATE BufferState = {0};
    ULONG EncodingStatus = 0;
    PUCHAR OutputBuffer = NULL;
    ULONG OutputSize = 0;


    EncodingStatus = MesEncodeIncrementalHandleCreate(
                        &BufferState,
                        PacAllocFcn,
                        PacWriteFcn,
                        &PickleHandle
                        );
    if (EncodingStatus != 0)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Calculate the size of the required buffer
    //

    OutputSize = (ULONG) PPAC_IDL_CREDENTIAL_DATA_AlignSize(
                                        PickleHandle,
                                        &CredentialData
                                        );

    OutputBuffer = (PBYTE) MIDL_user_allocate(OutputSize);
    if (OutputBuffer == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    BufferState.BufferSize = OutputSize;
    BufferState.BufferPointer = OutputBuffer;

    //
    // Now encode the structure
    //

    MesIncrementalHandleReset(
        PickleHandle,
        NULL,
        NULL,
        NULL,
        NULL,
        MES_ENCODE
        );

    PPAC_IDL_CREDENTIAL_DATA_Encode(
        PickleHandle,
        &CredentialData
        );

    *EncodedData = OutputBuffer;
    *DataSize = OutputSize;
    OutputBuffer = NULL;

Cleanup:
    if (OutputBuffer != NULL)
    {
        MIDL_user_free(OutputBuffer);
    }
    if (PickleHandle != NULL)
    {
        MesHandleFree(PickleHandle);
    }

    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   PAC_DecodeCredentialData
//
//  Synopsis:   NDR decodes the validation information
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
PAC_DecodeCredentialData(
    IN PBYTE EncodedData,
    IN ULONG DataSize,
    OUT PSECPKG_SUPPLEMENTAL_CRED_ARRAY * CredentialData
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    handle_t PickleHandle = 0;
    PAC_BUFFER_STATE BufferState = {0};
    ULONG EncodingStatus = 0;

    DsysAssert(ROUND_UP_POINTER(EncodedData,8) == (PVOID) EncodedData);

    EncodingStatus = MesDecodeIncrementalHandleCreate(
                        &BufferState,
                        PacReadFcn,
                        &PickleHandle
                        );
    if (EncodingStatus != 0)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    BufferState.BufferSize = DataSize;
    BufferState.BufferPointer = EncodedData;
    __try {
        PPAC_IDL_CREDENTIAL_DATA_Decode(
            PickleHandle,
            CredentialData
            );
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

Cleanup:
    if (PickleHandle != NULL)
    {
        MesHandleFree(PickleHandle);
    }

    return(Status);
}

//+---------------------------------------------------------------------------
//
//  Function:   PAC_GetSize
//
//  Synopsis:   Determines the number of bytes required to marshal the
//              given PAC.
//
//  Arguments:
//
//  History:    24-May-95   SuChang     Created
//
//  Notes:
//
//----------------------------------------------------------------------------
ULONG
PAC_GetSize( IN  PACTYPE  *pPac )
{
    ULONG cbSize = 0;

    if (pPac != NULL)
    {
        cbSize += sizeof( PACTYPE );
        cbSize += (pPac->cBuffers - ANYSIZE_ARRAY) * sizeof(PAC_INFO_BUFFER);
        cbSize = ROUND_UP_COUNT( cbSize, ALIGN_QUAD );
        for (ULONG i = 0; i < pPac->cBuffers; i++ )
        {
            cbSize += ROUND_UP_COUNT(pPac->Buffers[i].cbBufferSize, ALIGN_QUAD);
        }
    }

    return (cbSize);
}


//+---------------------------------------------------------------------------
//
//  Function:   PAC_Marshal
//
//  Synopsis:   Marshals the given PAC into the provided buffer.
//
//  Arguments:
//
//  History:    24-May-95   SuChang     Created
//
//  Notes:      This assumes the PAC is the same form as created
//              by PAC_Init. See header description of the PAC
//              structure.
//
//              Returns the number of bytes used or 0 if an error
//              occurred.
//
//----------------------------------------------------------------------------

ULONG
PAC_Marshal( IN  PACTYPE   *pPac,
             IN  ULONG      cbBuffer,
             OUT PBYTE      pBufferOut)
{
    DsysAssert( pPac != NULL && pBufferOut != NULL );
    if ( (pPac == NULL) || (pBufferOut == NULL ) )
    {
        return 0;
    }
    
    ULONG PacLen = PAC_GetSize( pPac );

    if (cbBuffer < PacLen)
    {
        return 0;
    }

    //
    // Copy into pBufferOut and then change the pointers of each
    // PAC_INFO_BUFFER to be offsets from pPac.
    //

    CopyMemory( pBufferOut, pPac, PacLen );

    PPACTYPE pPacTemp = (PPACTYPE) pBufferOut;

    for (ULONG i = 0; i < pPacTemp->cBuffers; i++ )
    {
        pPacTemp->Buffers[i].Offset = (ULONG) (pPacTemp->Buffers[i].Data -
                                             (PBYTE)pPac);
    }

    return PacLen;
}


//+---------------------------------------------------------------------------
//
//  Function:   PAC_UnMarshal
//
//  Synopsis:   Does in place unmarshalling of the marshalled PAC.
//
//  Arguments:
//
//  History:    24-May-95   SuChang     Created
//
//  Notes:      Does in place unmarshalling. No new memory is allocated.
//
//              This assumes the PAC is the same form as created
//              by PAC_Init. See header description of the PAC
//              structure.
//
//----------------------------------------------------------------------------

ULONG
PAC_UnMarshal(
    IN PPACTYPE pPac,
    IN ULONG cbSize
    )
{
    ULONG i;
    ULONG cbUnmarshalled = 0;
    PBYTE pEnd = (PBYTE)pPac + cbSize;
    PBYTE pBufferAddress;

    DsysAssert( pPac != NULL );
    if (pPac ==NULL)
    {
        return (0);
    }

    //
    // Do a validation loop. Make sure that the offsets are
    // correct. We don't want to do this validation inside the modification
    // loop because it wouldn't be nice to change the buffer if it weren't
    // valid.
    //

    if ((pPac->cBuffers * sizeof(PAC_INFO_BUFFER) + sizeof(PACTYPE)) > cbSize)
    {
        return(0);
    }

    if (pPac->Version != PAC_VERSION)
    {
        return(0);
    }
    for (i = 0; i < pPac->cBuffers; i++)
    {
        pBufferAddress = (ULONG)pPac->Buffers[i].Offset + (PBYTE)pPac;

        if ( (pBufferAddress >= pEnd ) || (pBufferAddress < (PBYTE) pPac) ||
             (pBufferAddress + pPac->Buffers[i].cbBufferSize > pEnd))
        {
            //
            // Invalid offset or length
            //
            return (0);
        }
    }

    for (i = 0; i < pPac->cBuffers; i++ )
    {
        cbUnmarshalled += pPac->Buffers[i].cbBufferSize;
        pPac->Buffers[i].Data = pPac->Buffers[i].Offset +
                                    (PBYTE)pPac;
    }

    return (cbUnmarshalled);
}

//+---------------------------------------------------------------------------
//
//  Function:   PAC_ReMarshal
//
//  Synopsis:   Does in place re-marshalling of an un-marshalled PAC.
//
//  Arguments:
//
//  History:    24-May-95   SuChang     Created
//
//  Notes:      Does in place re-marshalling. No new memory is allocated.
//
//              This assumes the PAC is the same form as created
//              by PAC_UnMarshal. See header description of the PAC
//              structure.
//
//----------------------------------------------------------------------------

BOOLEAN
PAC_ReMarshal( IN PPACTYPE  pPac,
               IN ULONG cbSize )
{
    ULONG Offset;
    ULONG i;

    //
    // Do a validation loop. Make sure that the offsets are
    // correct. We don't want to do this validation inside the modification
    // loop because it wouldn't be nice to change the buffer if it weren't
    // valid.
    //

    for (i = 0; i < pPac->cBuffers; i++ )
    {
        Offset = (ULONG) (pPac->Buffers[i].Data - (PBYTE) pPac);
        if ( Offset >= cbSize )
        {
            //
            // Invalid offset or length
            //

            return (FALSE);
        }
        pPac->Buffers[i].Offset = Offset;
    }

    return (TRUE);
}


//+-------------------------------------------------------------------------
//
//  Function:   PAC_MarshallValidationInfo
//
//  Synopsis:   marshals a KERB_PAC_USER_ALL_INFORMAION struct
//
//  Effects:    allocates memory with MIDL_user_allocate
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
PAC_MarshallValidationInfo
(
    IN PKERB_PAC_USER_ALL_INFORMATION UserAll,
    IN PUNICODE_STRING LogonDomainName,
    IN PUNICODE_STRING LogonServer,
    IN BOOLEAN IncludeUserParms,
    IN BOOLEAN NetworkProfile,
    OUT PBYTE * ValidationInfo,
    OUT PULONG ValidationInfoSize
    )
{
    PAC_NETLOGON_VALIDATION_SAM_INFO3 ValidationSam = {0};
    PPAC_NETLOGON_SID_AND_ATTRIBUTES MarshalledSids = NULL;
    SID ServerSid =  {SID_REVISION, 1, SECURITY_NT_AUTHORITY, SECURITY_SERVER_LOGON_RID };
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG Index;

    //
    // Allocate a return buffer for validation information.
    //  (Return less information for a network logon)
    //  (Return UserParameters for a MNS logon)
    //

    //
    // Set the UF_SMARTCARD_REQUIRED flag
    //
    if ((UserAll->UserAccountControl & USER_SMARTCARD_REQUIRED) != 0)
    {
        ValidationSam.UserFlags |= UF_SMARTCARD_REQUIRED;
    }


    //
    // Copy the scalars to the validation buffer.
    //

    NEW_TO_COMPAT_LARGE_INTEGER(UserAll->LastLogon, ValidationSam.LogonTime);

    //
    // BUG 455821: need logoff time & kickoff time
    //
#ifdef notdef
    NEW_TO_COMPAT_LARGE_INTEGER( LogoffTime, ValidationSam.LogoffTime );
    NEW_TO_COMPAT_LARGE_INTEGER( KickoffTime, ValidationSam.KickOffTime );
#else
    ValidationSam.LogoffTime.LowPart = 0xffffffff;
    ValidationSam.LogoffTime.HighPart = 0x7fffffff;
    ValidationSam.KickOffTime.LowPart = 0xffffffff;
    ValidationSam.KickOffTime.HighPart = 0x7fffffff;
#endif

    NEW_TO_COMPAT_LARGE_INTEGER(UserAll->PasswordLastSet, ValidationSam.PasswordLastSet);
    NEW_TO_COMPAT_LARGE_INTEGER(UserAll->PasswordCanChange, ValidationSam.PasswordCanChange);
    NEW_TO_COMPAT_LARGE_INTEGER(UserAll->PasswordMustChange, ValidationSam.PasswordMustChange);

    ValidationSam.LogonCount = UserAll->LogonCount;
    ValidationSam.BadPasswordCount = UserAll->BadPasswordCount;
    ValidationSam.UserId = UserAll->UserId;
    ValidationSam.PrimaryGroupId = UserAll->PrimaryGroupId;

    ValidationSam.GroupCount = 0;
    ValidationSam.GroupIds = NULL;


    ValidationSam.ExpansionRoom[SAMINFO_USER_ACCOUNT_CONTROL] = UserAll->UserAccountControl;
    //
    // If the client asked for extra information, return that
    // we support it
    //

    ValidationSam.UserFlags |= LOGON_EXTRA_SIDS;

    //
    // Copy ULONG aligned data to the validation buffer.
    //

    if (UserAll->GroupCount != 0)
    {

        ValidationSam.SidCount = UserAll->GroupCount;
        MarshalledSids = (PPAC_NETLOGON_SID_AND_ATTRIBUTES) MIDL_user_allocate(UserAll->GroupCount * sizeof(PAC_NETLOGON_SID_AND_ATTRIBUTES));
        if (MarshalledSids == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        ValidationSam.ExtraSids = MarshalledSids;
        Index = 0;

        if (ARGUMENT_PRESENT(UserAll->Groups))
        {
            //
            // Now marshall each sid into the buffer
            //

            C_ASSERT(sizeof(SID_AND_ATTRIBUTES) == sizeof(PAC_NETLOGON_SID_AND_ATTRIBUTES));

            memcpy(
                &MarshalledSids[Index],
                UserAll->Groups,
                UserAll->GroupCount * sizeof(SID_AND_ATTRIBUTES)
                );
            Index += UserAll->GroupCount;
        }

        //
        // Add in special sids for domain controllers
        //

        if ((UserAll->UserAccountControl & USER_SERVER_TRUST_ACCOUNT) != 0)
        {
            //
            // Add in the constant server logon sid
            //

            MarshalledSids[Index].Attributes = SE_GROUP_MANDATORY |
                                               SE_GROUP_ENABLED |
                                               SE_GROUP_ENABLED_BY_DEFAULT;


            MarshalledSids[Index].Sid = &ServerSid;
            Index++;


        }
    }


    ValidationSam.LogonDomainId = UserAll->RealmSid;

    //
    // Copy WCHAR aligned data to the validation buffer.
    //  (Return less information for a network logon)
    //


    if ( ! NetworkProfile ) {

        ValidationSam.EffectiveName = UserAll->UserName;
        ValidationSam.FullName = UserAll->FullName;
        ValidationSam.LogonScript = UserAll->ScriptPath;

        ValidationSam.ProfilePath = UserAll->ProfilePath;

        ValidationSam.HomeDirectory = UserAll->HomeDirectory;

        ValidationSam.HomeDirectoryDrive = UserAll->HomeDirectoryDrive;

    }

    ValidationSam.LogonServer = *LogonServer;


    ValidationSam.LogonDomainName = *LogonDomainName;


    //
    // Kludge: Pass back UserParameters in HomeDirectoryDrive since we
    // can't change the NETLOGON_VALIDATION_SAM_INFO2 structure between
    // releases NT 1.0 and NT 1.0A. HomeDirectoryDrive was NULL for release 1.0A
    // so we'll use that field.
    //

    if ( IncludeUserParms && NetworkProfile ) {
        ValidationSam.HomeDirectoryDrive = *(PUNICODE_STRING)&UserAll->Parameters;
    }

    Status = PAC_EncodeValidationInformation(
                &ValidationSam,
                ValidationInfo,
                ValidationInfoSize
                );

Cleanup:

    if (MarshalledSids != NULL)
    {
        MIDL_user_free(MarshalledSids);
    }
    return(Status);

}

//+-------------------------------------------------------------------------
//
//  Function:   PAC_UnmarshallValidationInfo
//
//  Synopsis:   un marshals a NETLOGON_VALIDATION_SAM_INFO3
//
//  Effects:    resets offset to be pointers
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
PAC_UnmarshallValidationInfo(
    OUT PPAC_NETLOGON_VALIDATION_SAM_INFO3 * ValidationInfo,
    IN PBYTE MarshalledInfo,
    IN ULONG ValidationInfoSize
    )
{
    NTSTATUS Status;

    *ValidationInfo = NULL;
    Status = PAC_DecodeValidationInformation(
                MarshalledInfo,
                ValidationInfoSize,
                ValidationInfo
                );
    return(Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   PAC_BuildCredentials
//
//  Synopsis:   Builds the buffer containing supplemental credentials for
//              the pac.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
PAC_BuildCredentials(
    IN PKERB_PAC_USER_ALL_INFORMATION UserAll,
    OUT PBYTE * Credentials,
    OUT PULONG CredentialSize
    )
{
    PSECPKG_SUPPLEMENTAL_CRED_ARRAY PacCreds = NULL;
    PMSV1_0_SUPPLEMENTAL_CREDENTIAL MsvCredentials;
    PUCHAR Where;
    ULONG CredSize;
    NTSTATUS Status = STATUS_SUCCESS;

    *Credentials = NULL;

    //
    // The size of the credentials is the overhead for the structures
    // plus the name "msv1_0"
    //

    CredSize = sizeof(SECPKG_SUPPLEMENTAL_CRED_ARRAY) +
                     sizeof(SECPKG_SUPPLEMENTAL_CRED) +
                     sizeof(MSV1_0_SUPPLEMENTAL_CREDENTIAL) +
                     NTLMSP_NAME_SIZE;
    PacCreds = (PSECPKG_SUPPLEMENTAL_CRED_ARRAY) MIDL_user_allocate(CredSize);
    if (PacCreds == NULL)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }


    //
    // Build the PAC credential
    //

    Where = (PBYTE) PacCreds;

    PacCreds->CredentialCount = 1;

    Where += sizeof(SECPKG_SUPPLEMENTAL_CRED_ARRAY) + sizeof(SECPKG_SUPPLEMENTAL_CRED) - (ANYSIZE_ARRAY * sizeof(SECPKG_SUPPLEMENTAL_CRED));

    //
    // Build the secpkg creds
    //

    memcpy(
        Where,
        NTLMSP_NAME,
        NTLMSP_NAME_SIZE
        );

    PacCreds->Credentials[0].PackageName.Buffer = (LPWSTR) Where;
    Where += ROUND_UP_COUNT(NTLMSP_NAME_SIZE,sizeof(ULONG));

    PacCreds->Credentials[0].PackageName.Length = (USHORT) NTLMSP_NAME_SIZE;
    PacCreds->Credentials[0].PackageName.MaximumLength = (USHORT) NTLMSP_NAME_SIZE;
    PacCreds->Credentials[0].CredentialSize = sizeof(MSV1_0_SUPPLEMENTAL_CREDENTIAL);
    PacCreds->Credentials[0].Credentials = Where;

    MsvCredentials = (PMSV1_0_SUPPLEMENTAL_CREDENTIAL) Where;
    Where += sizeof(MSV1_0_SUPPLEMENTAL_CREDENTIAL);

    ZeroMemory(
        MsvCredentials,
        sizeof(MSV1_0_SUPPLEMENTAL_CREDENTIAL)
        );

    MsvCredentials->Version = MSV1_0_CRED_VERSION;

    if (UserAll->NtPasswordPresent)
    {
        DsysAssert(UserAll->NtOwfPassword.Length == MSV1_0_OWF_PASSWORD_LENGTH);
        MsvCredentials->Flags |= MSV1_0_CRED_NT_PRESENT;
        memcpy(
            MsvCredentials->NtPassword,
            UserAll->NtOwfPassword.Buffer,
            UserAll->NtOwfPassword.Length
            );
    }
    if (UserAll->LmPasswordPresent)
    {
        DsysAssert(UserAll->LmOwfPassword.Length == MSV1_0_OWF_PASSWORD_LENGTH);
        MsvCredentials->Flags |= MSV1_0_CRED_LM_PRESENT;
        memcpy(
            MsvCredentials->LmPassword,
            UserAll->LmOwfPassword.Buffer,
            UserAll->LmOwfPassword.Length
            );
    }

    Status = PAC_EncodeCredentialData(
                PacCreds,
                Credentials,
                CredentialSize
                );

    if (PacCreds != NULL)
    {
        MIDL_user_free(PacCreds);
    }
    return(Status);

}


//+-------------------------------------------------------------------------
//
//  Function:   PAC_UnmarshallCredentials
//
//  Synopsis:   un marshals a SECPKG_SUPPLEMENTAL_CRED_ARRAY
//
//  Effects:    resets offset to be pointers
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
PAC_UnmarshallCredentials(
    OUT PSECPKG_SUPPLEMENTAL_CRED_ARRAY * Credentials,
    IN PBYTE MarshalledInfo,
    OUT ULONG CredentialInfoSize
    )
{
    NTSTATUS Status;

    *Credentials = NULL;
    Status = PAC_DecodeCredentialData(
                MarshalledInfo,
                CredentialInfoSize,
                Credentials
                );
    return(Status);
}


//+---------------------------------------------------------------------------
//
//  Function:   PAC_Init
//
//  Synopsis:   Construct the PAC from the passed in sections
//
//  Arguments:  
//
//  Notes:
//
//----------------------------------------------------------------------------

NTSTATUS
PAC_Init(
    IN  ULONG SignatureSize,
    IN  ULONG DataBufferCount,
    IN  PPAC_INFO_BUFFER * DataBuffers,
    OUT PPACTYPE * ppPac
    )
{
    ULONG cbBytes = 0;
    ULONG cPacBuffers = 0;
    PPACTYPE pNewPac = NULL;
    ULONG iBuffer = 0;
    PBYTE pDataStore;
    ULONG Index;
    NTSTATUS Status = STATUS_SUCCESS;

    *ppPac = NULL;

    //
    // Count up the data sizes for the DataBuffers
    //

    for (Index = 0; Index < DataBufferCount ; Index++ )
    {
        cbBytes += ROUND_UP_COUNT(DataBuffers[Index]->cbBufferSize, ALIGN_QUAD);
        cPacBuffers++;
    }

    //
    // If signature size is non-zero, add in space for signature.
    //

    if (SignatureSize != 0)
    {
        cPacBuffers += 1;
        cbBytes += 1 * (ROUND_UP_COUNT(PAC_SIGNATURE_SIZE(SignatureSize), ALIGN_QUAD));
    }

    //
    // We need space for the PAC structure itself. Because the PAC_INFO_BUFFER
    // is defined to be an array, a sizeof(PAC) already includes the
    // size of ANYSIZE_ARRAY PAC_INFO_BUFFERs so we can subtract some bytes off.
    //

    cbBytes += sizeof(PACTYPE) +
               (cPacBuffers - ANYSIZE_ARRAY) * sizeof(PAC_INFO_BUFFER);
    cbBytes = ROUND_UP_COUNT(cbBytes, ALIGN_QUAD);

    pNewPac = (PPACTYPE) MIDL_user_allocate(cbBytes);

    if (pNewPac == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    ZeroMemory(pNewPac, cbBytes);

    pNewPac->Version = PAC_VERSION;
    pNewPac->cBuffers = cPacBuffers;

    //
    // Store data in such a way that the variable length data of
    // PAC_INFO_BUFFER are at the end of all the PAC info buffers.
    //

    pDataStore = (PBYTE)&(pNewPac->Buffers[pNewPac->cBuffers]);
    pDataStore = (PBYTE) ROUND_UP_POINTER(pDataStore, ALIGN_QUAD);

    //
    // Store the PAC data
    //

    for (Index = 0; Index < DataBufferCount ; Index++ )
    {
        pNewPac->Buffers[iBuffer].ulType = DataBuffers[Index]->ulType;
        pNewPac->Buffers[iBuffer].cbBufferSize = DataBuffers[Index]->cbBufferSize;
        pNewPac->Buffers[iBuffer].Data = pDataStore;

        CopyMemory(
            pDataStore,
            DataBuffers[Index]->Data,
            DataBuffers[Index]->cbBufferSize
            );

        pDataStore += pNewPac->Buffers[iBuffer].cbBufferSize;
        pDataStore = (PBYTE) ROUND_UP_POINTER( pDataStore, ALIGN_QUAD );
        iBuffer ++;
    }

    //
    // Store the signatures
    //

    if (SignatureSize != 0)
    {
        pNewPac->Buffers[iBuffer].ulType = PAC_PRIVSVR_CHECKSUM;
        pNewPac->Buffers[iBuffer].cbBufferSize = PAC_SIGNATURE_SIZE(SignatureSize);
        pNewPac->Buffers[iBuffer].Data = pDataStore;
        pDataStore += ROUND_UP_COUNT(PAC_SIGNATURE_SIZE(SignatureSize), ALIGN_QUAD);
        iBuffer ++;
    }

    *ppPac = pNewPac;
    pNewPac = NULL;

Cleanup:
    if (pNewPac != NULL)
    {
        MIDL_user_free(pNewPac);
    }

    return(Status);
}

//+---------------------------------------------------------------------------
//
//  Function:   PAC_Find
//
//  Synopsis:   Finds a type of PAC info buffer in the given PAC.
//              If pElem is NULL, the first buffer found matching the
//              specified type is returned. Otherwise, the next buffer
//              after pElem found matching that type is returned.
//
//  Arguments:
//
//  History:    01-June-95   SuChang     Created
//
//  Notes:
//
//----------------------------------------------------------------------------

PPAC_INFO_BUFFER
PAC_Find(
    IN  PPACTYPE     pPac,
    IN  ULONG        ulType,
    IN  PPAC_INFO_BUFFER pElem
    )
{
    PAC_INFO_BUFFER *pTemp = NULL, *pEnd;

    if (pPac)
    {
        pEnd = &(pPac->Buffers[pPac->cBuffers]);
        if (pElem)
        {
            pTemp = pElem + 1;
        }
        else
        {
            pTemp = &(pPac->Buffers[0]);
        }

        while ( pTemp < pEnd && pTemp->ulType != ulType )
        {
            pTemp++;
        }

        if (pTemp >= pEnd)
        {
            // element not found in the PAC
            pTemp = NULL;
        }
    }

    return (pTemp);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\pubinc\kerbhelper.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    kerbhelper.h

Abstract:

    This module supplements the definitions in kerbinterface.h
    for provider implementations.

Revision History:

--*/
#ifndef __KERBHELPER_H__
#define __KERBHELPER_H__

//  for logon struct decl
#include <pacpat.hxx>
#include <pacuall.h>
#include <pacext.h>

//
// Type Tags for the PAC_INFO_BUFFER that specify one of the three
// structures below.
//
#ifndef PAC_SERVER_CHECKSUM
#define PAC_SERVER_CHECKSUM             0x06   // Signature by server
#define PAC_PRIVSVR_CHECKSUM            0x07   // Signature by privsvr
#endif //PAC_SERVER_CHECKSUM

#define KDC_EXT_MAIN "KdcExtMain"

extern "C"
typedef NTSTATUS (*KDC_EXT_MAIN_FN) (
    IN DWORD Reason,     // DLL_PROCESS_ATTACH || DLL_PROCESS_DETACH
    IN IKdcCore *piKdcCore
    );


//
//  ctxt interfaces. Define some useful interfaces that can be implemented
//  by extensions or providers
//
#define DEFINE_KDC_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
        EXTERN_C const GUID DECLSPEC_SELECTANY name \
                = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }
DEFINE_KDC_GUID(IID_IKDBLogonInfo, 0x9cf673e9,
            0xda5a, 0x4552,
            0xb1, 0xaf, 0xc4, 0x62, 0x7d, 0xb8, 0x76, 0xb2);
struct IKDBLogonInfo
{
    //  this is not allocating ...
    virtual NTSTATUS __stdcall GetWindowsLogonInfo(
                          const KERB_PAC_USER_ALL_INFORMATION**) = 0;
    virtual NTSTATUS __stdcall GetIdentityInfo(const IDENTITY**) = 0;

    // Provide a hook to sent the credential type
    virtual NTSTATUS __stdcall SetCredentialType(CREDTYPE credType) = 0;
};

//
//  allows retrieval of PA identities
//
DEFINE_KDC_GUID(IID_IPAIdentity, 0xde21c3d1,
            0x66cd, 0x493c,
            0xae, 0x0e, 0xcc, 0xb6, 0x7d, 0xe6, 0xdc, 0x56);
struct IPAIdentity
{
    //  get count if logon infos present in the compound identity
    virtual ULONG __stdcall GetNumLogonInfos() = 0;
    //  get the compound identity itself
    virtual NTSTATUS __stdcall GetCompoundIdentity(const COMPOUND_IDENTITY**) = 0;
    //  get the xbox identity itself
    virtual NTSTATUS __stdcall GetXboxIdentity(const XBOX_IDENTITY**) = 0;
    //  get session keys for all Tgts
    virtual NTSTATUS __stdcall GetTgtKeys(
                                    PULONG pcKeys,
                                    const KERB_ENCRYPTION_KEY **pKeys) = 0;
};

//
//  specifies what portions of the PAC are to be returned
//
DEFINE_KDC_GUID(IID_IPAPacReqEx, 0x30f5a9b0,
            0xc6f4, 0x4cdd,
            0x94, 0x73, 0x9b, 0x04, 0x11, 0x62, 0x9c, 0x22);
struct IPAPacReqEx
{
    //  not allocating. The info is maintained by the interface
    //  and released when it goes away
    virtual NTSTATUS __stdcall GetRequestedPacSections(ULONG& cSections, PULONG& pulSections) = 0;
    //
    // allows provs to query for specific PAC sections
    //
    virtual BOOL __stdcall IsPacSectionRequested(ULONG ulSectionId) = 0;
    //  is PAC requested at all
    virtual BOOL    __stdcall IsPacRequested() = 0;
};

//
//  query auth data for raw PAC sections
//
DEFINE_KDC_GUID(IID_IADPacSection, 0x443576a3,
                0x0833, 0x493a,
                0xac, 0x07, 0x3e, 0x4e, 0x1, 0xbb, 0x9, 0x11);
struct IADPacSection
{
    virtual NTSTATUS __stdcall GetPacSection(ULONG ulSectId,
                                             const PAC_INFO_BUFFER **ppPacBuf) = 0;
};

//
//  interface to query a timestamp
//
DEFINE_KDC_GUID(IID_IKDCTimeStamp, 0xe7e280bc,
                0x939b, 0x49e5,
                0xa4, 0xa3, 0xde, 0x3e, 0x7d, 0x5b, 0x14, 0xd8);
struct IKDCTimeStamp
{
    virtual LARGE_INTEGER __stdcall GetTimeStamp() = 0;
};


// 
// If the principal support multiple keys, it must implement IKerbPrincipalWithMultipleKeys.
// If Kerberos fail to decrypt the encrypted timestamp pre-auth, it will give a 
// change to the principal to try a different key by calling NextKey.
//

/* 9de0f44e-b53a-4c06-b040-a3769e7308e4 */
DEFINE_KDC_GUID(IID_IKDCPrincipalWithMultipleKeys, 0x9de0f44e,
                0xb53a, 0x4c06,
                0xb0, 0x40, 0xa3, 0x76, 0x9e, 0x73, 0x08, 0xe4);
struct IKDCPrincipalWithMultipleKeys
{
    // If there is another key available for decryption, returns TRUE.
    virtual BOOL __stdcall NextKey() = 0;
};

//
//  For the provider to register.
//
NTSTATUS WINAPI KdcRegisterProvider(
    IN  IKdbProvider    *pIKdbProvider
    );

NTSTATUS WINAPI KdcRegisterPAHandlerFactory(
        IN  IPAHandlerFactory   *pIPAHandlerFactory   // factory to create the IPAHandler
    );

NTSTATUS WINAPI KdcRegisterADHandlerFactory(
        IN  IADHandlerFactory   *pIADHandlerFactory   // factory to create the IADHandler
    );

NTSTATUS WINAPI KdcRegisterPACHandler(
        IN  IPACHandler  *pIPACHandler
    );

//
// Get hold of the IKdbProvider interface
// Used by extension that needs IKerbPrincipal functionality
//
IKdbProvider* KdcGetProvider(PUNICODE_STRING pustrRealm);

//
// Allows provider to grab the default IKerbCrypt implementation
// from the core.  This is normally done at KdcExtMain when the provider
// is starting up.
//
IKerbCrypt *__stdcall KdcGetICrypt(void);

NTSTATUS __stdcall KdcCreatePAHandlerInstance(
        IN  PADATA_TYPE     PAType,
        OUT IPAHandler   ** ppIPAHandler);

NTSTATUS __stdcall KdcCreateADHandlerInstance(
        IN  ADDATA_TYPE     ADType,
        OUT IADHandler   ** ppIADHandler);

#endif //__KERBHELPER_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\pubinc\kerbinterface.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    kerbinterface.h

Abstract:

    This module defines the Kerberos provider interfaces.
    With these interfaces, a KDC can be programmatically be divided into two
    modules: core and provider(s.)  While the core handles the protocol by
    assembling and disassembling of incoming packets from the ATQ, invoking the
    different methods defined by the interfaces to
        - locate principals
        - checks and builds both pre-auth and auth data,
    and providing default implementations for cryptos, memory management and
    logging functionalities, the provider's main responsibilities are to
        - look up principals
        - retrieve keys/pwds from the DB and provide encryption and decryption
        - optionally canonicalize principal names
        - optionally do referrals

    The core is wrapped by a service.  The service is nothing more than a shell to load
    and unload the core.  The core in turns reads the registry value
        HKLM\CCS\Services\KDC\Providers for all the providers.  If none is present, the
    sample provider (together with this SDK) is loaded.

    Each provider is expected to provide the entry point KdcExtMain.  This is invoked
    after the provider is loaded.  The provider should take this opportunity to perform
    initializations.

Revision History:

--*/
#ifndef __KDC_INTERFACE_H__
#define __KDC_INTERFACE_H__

//
//  Interfaces to be implemented by KDC providers. These interfaces are
//  invoked by the KDC core.
//

//
//  Notes:
//  1.  OUT parameters should not be freed when the returned pointer points at const data.
//  2.  The Release method does not imply ref-counting.
//

//
//  forward declarations
//
struct IKerbRequest;
struct IKerbPrincipal;
struct IPAHandler;
struct IADHandler;
struct IPACHandler;
struct ITixHandler;
struct IFiltHandler;
struct IKerbTransport;
struct IKerbTransportData;
struct IKerbCrypt;

typedef struct IKerbRequest     *PIKerbRequest;
typedef struct IKerbPrincipal   *PIKerbPrincipal;
typedef struct IPAHandler       *PIPAHandler;
typedef struct IADHandler       *PIADHandler;
typedef struct IPACHandler      *PIPACHandler;
typedef struct ITixHandler      *PITixHandler;
typedef struct IFiltHandler     *PIFiltHandler;
typedef struct IKerbCrypt       *PIKerbCrypt;

//
//  type definitions shared b/n core and providers&handlers
//
typedef ULONG   ETYPE;
typedef ETYPE * PETYPE;

typedef ULONG   CTYPE;
typedef CTYPE * PCTYPE;

typedef ULONG   SALTFLAGS;

typedef ULONG   CRYPTATT;
typedef CRYPTATT * PCRYPTATT;

#define CRYPTATT_USE_PRINCIPAL_NAME       0x00000001L
#define CRYPTATT_EXPORT_STRENGTH          0x00000002L
#define CRYPTATT_INTEGRITY_PROTECTED      0x00000004L

//
//  kdc core shared structs and data types
//
#ifndef _KERB_INTERNAL_NAME_
#define _KERB_INTERNAL_NAME_

#define MAX_NAME_ELEMENTS 20

typedef struct _KERB_INTERNAL_NAME {
    SHORT NameType;
    USHORT NameCount;
    UNICODE_STRING Names[ANYSIZE_ARRAY];
} KERB_INTERNAL_NAME, *PKERB_INTERNAL_NAME;
#endif
#define KERB_INTERNAL_NAME_SIZE(NameCount)\
    (sizeof(KERB_INTERNAL_NAME) + ((NameCount) - ANYSIZE_ARRAY) *\
    sizeof(UNICODE_STRING))

#ifndef _KERB_ACCOUNT_TYPE_DEFINED_
#define _KERB_ACCOUNT_TYPE_DEFINED_
typedef enum _KERB_ACCOUNT_TYPE {
    UserAccount,
    MachineAccount,
    DomainTrustAccount,
    UnknownAccount
} KERB_ACCOUNT_TYPE, *PKERB_ACCOUNT_TYPE;
#endif

typedef ASN1int32_t PADATA_TYPE;
typedef ASN1int32_t ADDATA_TYPE;

//
//  KDC policy struct
//
struct KDC_POLICY_VALUES
{
    LARGE_INTEGER   TimeSkew;
};

//
//  The IKerbCrypt interface abstracts the current functionalities present in kdccrypt.dll.
//  With this abstraction, a provider can supply an implementation if the default
//  (kdccrypt.dll) one is not desired.
//
//  This is a stateless interface
//

struct IKerbCrypt
{
    virtual NTSTATUS __stdcall GetKeySize(
            IN  ETYPE       Etype,
            OUT ULONG       *pcbKey
    ) = 0;

    //
    //  To get the encryption types supported by this implementation.
    //  The returned array of ETypes should not be freed by the caller.
    //
    virtual NTSTATUS __stdcall GetEtypes(
                OUT ETYPE const           **ppEtypes,
                OUT PULONG                  pcEtypes
    ) = 0;

    virtual KERBERR __stdcall GetAttributes(
                IN  ETYPE                   Etype,
                OUT PCRYPTATT               Attributes
    ) = 0;

    //
    //  To determine the size of encrypted data for a given buffer size.
    //
    virtual KERBERR __stdcall GetCiphertextSize(
                IN  ETYPE                   Etype,
                IN  ULONG                   cbIn,
                OUT PULONG                  pcbOut
    ) = 0;

    //
    //  The caller would have determined what key type and key value before
    //  invoking this function to encrypt a buffer.  The encryption type
    //  is specified together the the key in pKey.
    //
    virtual KERBERR __stdcall Encrypt(
                IN  PKERB_ENCRYPTION_KEY    pKey,
                IN  ULONG                   ulKeyVersion,
                IN  SALTFLAGS               saltflags,
                IN  PBYTE                   pbIn,
                IN  ULONG                   cbIn,
                OUT PKERB_ENCRYPTED_DATA    pData
    ) = 0;

    virtual KERBERR __stdcall Decrypt(
                IN  const KERB_ENCRYPTED_DATA * pData,
                IN  const KERB_ENCRYPTION_KEY * pKey,
                IN  SALTFLAGS saltflags,
                OUT PBYTE pbOut,
                OUT PULONG pcbOut
    ) = 0;

    //
    //  Make a (random) key of the requested etype.  This is usually
    //  used to generate session keys.
    //  The caller should use FreeKey to free the *ppKey when done.
    //
    virtual KERBERR __stdcall MakeKey(
                IN  ETYPE                   Etype,
                OUT KERB_ENCRYPTION_KEY   **ppKey
    ) = 0;

    virtual void __stdcall FreeKey(
                IN  PKERB_ENCRYPTION_KEY    pKey
    ) = 0;

    //
    //  For a checksum type, determine the returned signature/checksum.
    //
    virtual NTSTATUS __stdcall GetChecksumSize(
                IN  CTYPE                   Ctype,
                OUT PULONG                  pcbOut
    ) = 0;

    //
    //  Do the checksum on a list of buffers using an optional key.
    //  pbVerify and cbVerify can be used to compare with the resulting checksum
    //  returning the result in pfVerified.
    //
    virtual NTSTATUS __stdcall Checksum(
                IN  CTYPE                   Ctype,
                IN  SALTFLAGS               saltflags,
                IN  PKERB_ENCRYPTION_KEY    pKey,         // OPTIONAL
                IN  PBYTE                  *rgpbBuffers,
                IN  ULONG                  *rgcbBuffers,
                IN  ULONG                   cBuffers,
                IN  PBYTE                   pbVerify,     // OPTIONAL
                IN  ULONG                   cbVerify,     // OPTIONAL
                OUT PBYTE                   pbChecksum,   // OPTIONAL
                OUT PULONG                  pcbChecksum,  // OPTIONAL
                OUT PBOOLEAN                pfVerified    // OPTIONAL
    ) = 0;

    //
    //  Hashes a given string for an encryption type.  This can be used to derive
    //  keys from passwords for different encryption types.
    //
    virtual KERBERR __stdcall HashString(
                IN  ETYPE                   Etype,
                IN  PUNICODE_STRING         String,
                OUT PBYTE                   pbOut,
                OUT PULONG                  pcbOut
    ) = 0;
};

//
//    TBD: to remove but this clashes with kdckdb.h which is required in the core in pre-compile header.
//
#ifndef DEF_KDC_AUDIT_EVENT
#define DEF_KDC_AUDIT_EVENT
//
// Per KDB audit log function - optional
//
typedef enum
{
    AsTicket = 0,
    AsFailure,
    PreauthFailure,
    TgsSuccess,
    TgsFailure,
    TicketRenewSuccess,
    TgsTicketRequest
} KDC_AUDIT_EVENT, *PKDC_AUDIT_EVENT;
#endif //DEF_KDC_AUDIT_EVENT

#ifndef DEF_KERB_PERF_COUNTER
#define DEF_KERB_PERF_COUNTER
typedef enum {
    KerbKdcAsReqCounter = 0,
    KerbKdcAsReferralCounter,
    KerbKdcTgsReqCounter,
    KerbKdcTgsReferralCounter,
    KerbKdcTgsS4U2SelfCounter,
    KerbKdcTgsS4U2ProxyCounter
} KERB_PERF_COUNTER;
#endif //DEF_KERB_PERF_COUNTER

//
//  Options that could be requested by Kerb clients in either AS-REQ or TGS-REQ
//
typedef ULONG   KDC_OPTIONS;
//#define                     KERB_KDC_OPTIONS_reserved 0x80000000
//#define                     KERB_KDC_OPTIONS_forwardable 0x40000000
//#define                     KERB_KDC_OPTIONS_forwarded 0x20000000
//#define                     KERB_KDC_OPTIONS_proxiable 0x10000000
//#define                     KERB_KDC_OPTIONS_proxy 0x08000000
//#define                     KERB_KDC_OPTIONS_postdated 0x02000000
//#define                     KERB_KDC_OPTIONS_allow_postdate 0x04000000
//#define                     KERB_KDC_OPTIONS_unused7 0x01000000
//#define                     KERB_KDC_OPTIONS_renewable 0x00800000
//#define                     KERB_KDC_OPTIONS_unused9 0x00400000
//#define                     KERB_KDC_OPTIONS_name_canonicalize 0x00010000
//#define                     KERB_KDC_OPTIONS_cname_in_addl_tkt 0x00020000
//#define                     KERB_KDC_OPTIONS_cname_in_pa_data  0x00040000
//#define                     KERB_KDC_OPTIONS_renewable_ok 0x00000010
//#define                     KERB_KDC_OPTIONS_enc_tkt_in_skey 0x00000008
//#define                     KERB_KDC_OPTIONS_renew 0x00000002
//#define                     KERB_KDC_OPTIONS_validate 0x00000001
//#define                     KERB_AP_OPTIONS_reserved 0x80000000
//#define                     KERB_AP_OPTIONS_use_session_key 0x40000000
//#define                     KERB_AP_OPTIONS_mutual_required 0x20000000
//#define                     KERB_AP_OPTIONS_reserved1 0x00000001
typedef struct sockaddr *PSOCKADDR;
struct IAudit
{
    virtual NTSTATUS __stdcall Audit(
                IN KDC_AUDIT_EVENT      AuditId,
                IN PIKerbRequest             pIKerbRequest,
                IN PSOCKADDR                ClientAddress,
                IN PKERBERR                    pExtError,
                IN PULONG                       pKdcOptions,
                IN PKERB_CRYPT_LIST      EncryptionType,
                IN PULONG                       pulPreauthType
    ) = 0;
};

struct IPerfctr
{
    virtual NTSTATUS __stdcall Increment(
                IN KERB_PERF_COUNTER Counter
                ) = 0;
};

//
//
//
typedef ULONG   GET_PRINC_FLAGS;

//
//  GETPRINCFLAGS: These are flags that the core uses when it asks the provider to
//  retrieve a principal
//

#define KDC_KDB_GET_PRINC_CLIENT                0x00000001      // This principal is a Client princ
#define KDC_KDB_GET_PRINC_SERVER                0x00000002      // This principal is a Server princ
#define KDC_KDB_GET_PRINC_FOLLOW_REFERRALS      0x00000004      // Tells the provider to attempt referrals if KDC_KDB_GET_PRINC_CANONICALIZE is also set
#define KDC_KDB_GET_PRINC_TRUST_INBOUND         0x00000008      // indicates name need not be outbound trust only
#define KDC_KDB_GET_PRINC_CANONICALIZE          0x00000010      // indicates that the client said this princ should be canonicalized or referrals be done.
#define KDC_KDB_GET_PRINC_MAPPING               0x00000020      // Client princ that is mapped to the requested identity (called during PAC mapping)

//
//    To remove once collision is fixed
//
#ifndef DEF_KERB_SERVICE_ID
#define DEF_KERB_SERVICE_ID
//
// Shorthand for service making a particular function call.
// Enables provider to know of the type of request.
//
typedef enum {
    KerbAs = 0,
    KerbTgs,
    KerbAp,
    KerbChangePassword,
    KerbSetPassword,
} KERB_SERVICE_ID;
#endif //DEF_KERB_SERVICE_ID

//
//  Provider flags
//
// Can generate referrals to other realms
#define KERB_KDB_REALM_REFERRAL 0x00000001
// Realm capable of producing data for a PAC
#define KERB_KDB_REALM_DOES_PAC 0x00000002

//
//  This interface allows the provider to tell the core:
//      - the realms that it handles,
//      - the interfaces that it wants to use - override implementations by the core
//      - what it can do (using flags)
//      - the provider to do "per-request" initializations and clean up.
//
//  It also enables the core to locate a principal with optional referral if the principal
//  cannot be found.
//
struct IKdbProvider
{
    //
    //  Allow querying of interfaces for IID_IKerbCrypt, IID_ILog
    //
    virtual HRESULT __stdcall QueryInterface(REFIID, PVOID*)
    {
        return  E_NOINTERFACE;
    }

    //
    //  Allow the core to figure out what provider for a request.
    //  The core could use copies of them together with other realms
    //  from different providers in a hashing table to speed up the search
    //  for providers using realm names.
    //
    virtual NTSTATUS __stdcall GetRealms(
        OUT ULONG           *pcrealms,
        OUT LPCWSTR const **prgpwszRealms
    ) = 0;

    //
    //  This can be useful when we have a need to do housekeeping before
    //  the start and end of processing for each request, e.g.,
    //  read TLS.  Note that this can only be invoked after the core has determined
    //  which provider to use based on the realm.  This implies that the core must
    //  already received enough data over the wire, decrypted the ASM encoding far
    //  enough to get to the realm in the REQ.
    //
    virtual NTSTATUS __stdcall DoRequestInitialization(void)
    {
        return STATUS_SUCCESS;
    };

    //
    //  This is the counterpart to DoRequestInitialization.
    //
    virtual NTSTATUS __stdcall DoRequestTermination(void)
    {
        return STATUS_SUCCESS;
    };

    //
    //  This signals to the provider to finish up its processing, and it will
    //  be unloaded.  No more processing will be required after this point.
    //
    virtual void __stdcall Release(void)
    {
        return;
    }

    //
    //  This is called by the core to get the cryptos that the provider can choose
    //  to implement.
    //
    virtual NTSTATUS __stdcall GetIKerbCrypt(
                OUT IKerbCrypt **ppIKerbCrypt)
    {
        *ppIKerbCrypt = NULL;
        return STATUS_NOT_IMPLEMENTED;
    };

    //
    //  This is called by the core to get the audit interface that the provider must
    //  implement in order to enable auditing.
    //
    virtual IAudit * __stdcall GetIAudit()
    {
        return NULL;
    };

    //
    //  This is called by the core to get the perf counter interface that the 
    //  provider must implement in order to enable perf counters.
    //  
    virtual IPerfctr * __stdcall GetIPerfctr()
    {
        return NULL;
    };
    
    //
    //  Asks the provider to locate a principal.
    //
    //  For client principals (in AS-REQ), a referral is only done if
    //      KDC_KDB_GET_PRINC_CANONICALIZE bit is set,
    //      KDC_KDB_GET_PRINC_FOLLOW_REFERRAL bit is set,
    //      the KDC can do a referral.
    //  In such a situation, *ppustrReferralRealm is the referral realm and
    //  the returned code is KDC_ERR_WRONG_REALM.  If a referral was not asked or
    //  cannot be made, KDC_ERR_C_PRINCIPAL_UNKNOWN is returned.
    //
    //  For server principals, a referral is only done if
    //      KDC_KDB_GET_PRINC_CANONICALIZE bit is set,
    //      the KDC can do a referral.
    //  In such a situation, *ppustrReferralRealm is NOT used. Instead the returned
    //  *ppIPrincipal is the referred principal and the returned code is KDC_ERR_NONE.
    //  The return *ppIPrincipal should be used to generate the cross realm TGT.
    //  If a referral was not asked or cannot be made, KDC_ERR_S_PRINCIPAL_UNKNOWN
    //  is returned.
    //
    //  The returned principal should be freed with IKerbPrincipal::Release( ).
    //
    virtual KERBERR __stdcall GetPrincipal(
        IN  GET_PRINC_FLAGS      getprincflags,
        IN  PKERB_INTERNAL_NAME  pkinName,
        IN  LPCWSTR              pcwszRealm,
        IN  IKerbRequest        *pIKerbRequest,
        OUT PIKerbPrincipal     *ppIPrincipal,
        OUT PKERB_EXT_ERROR pExtendedError,
        OUT OPTIONAL PUNICODE_STRING     *ppustrReferralRealm
    ) = 0;

    //
    //  get provider flags
    //
    virtual ULONG __stdcall Flags()
    {
        return  0;
    }

    //
    //  get provider's KDC policy
    //
    virtual const KDC_POLICY_VALUES* __stdcall GetKdcPolicy()
    {
        //  default implementation for providers which do not
        //  have their own policy. default policy is 5 min time skew
        static KDC_POLICY_VALUES sPolicy;
        sPolicy.TimeSkew.QuadPart = (LONGLONG)10000000 * 60 * 5;
        return  &sPolicy;
    }

    //
    //  Finished up work synchronously because the provider is getting unloaded.
    //
    virtual void __stdcall Unload()
    {
        return;
    }
};


typedef ULONG   SALTFLAGS;
typedef ULONG   CHKSUM_HANDLE;
typedef ULONG   PRINC_FLAGS;


//
//  PRINC_FLAGS: principal flags.
//
#define KERB_KDB_DISALLOW_POSTDATED     0x00000001  // tells the core that tkt for this principal should not be postdated
#define KERB_KDB_DISALLOW_FORWARDABLE   0x00000002
#define KERB_KDB_DISALLOW_RENEWABLE     0x00000004
#define KERB_KDB_DISALLOW_PROXIABLE     0x00000008
#define KERB_KDB_REQUIRE_USER2USER      0x00000010
#define KERB_KDB_DISALLOW_S4U2PROXY     0x00000020
#define KERB_KDB_DISALLOW_ALL_TIX       0x00000040
#define KERB_KDB_REQUIRES_PRE_AUTH      0x00000080
#define KERB_KDB_REQUIRES_PWCHANGE      0x00000100
#define KERB_KDB_DISALLOW_SVR           0x00000200
#define KERB_KDB_OK_AS_DELEGATE         0x00000400

#ifndef KERB_KDB_TIME_NEVER
//
//  for account expiration
//
#define KERB_KDB_TIME_NEVER (ULONG)(-1)
#endif


//
// No Key version (common for session keys)
//
#ifndef KERB_NO_KEY_VERSION
//
//  GetKeyVersion()
//
#define KERB_NO_KEY_VERSION     0
#endif

//
//  This interface represents either a client or server principal.  Its attributes are described
//  using PRINC_FLAGS bits.
//
//  The core uses IKdbProvider::GetPrincipal( ) to locate the principal and an instance of
//  IKerbPrincipal is returned.
//
struct IKerbPrincipal
{
    //
    //  Return type is void to indicate that ref-counting is not mandatory.
    //
    virtual void __stdcall Release(void) = 0;

    //
    //  Get principal name and realm
    //
    virtual const KERB_INTERNAL_NAME  * __stdcall GetName() = 0;
    virtual const UNICODE_STRING * __stdcall GetRealm() = 0;

    //
    //  If KDC_KDB_GET_PRINC_CANONICALIZE was set in IKdbProvider::GetPrincipal( ),
    //  this method would have the canonical name.
    //
    virtual KERB_INTERNAL_NAME  * __stdcall GetCanonicalName() = 0;

    //
    //  Get attribute (bits) for this principal.
    //
    virtual PRINC_FLAGS GetPrincFlags(void) = 0;

    //
    //  Principal's expiry, lifespan and max time for ticket renewal
    //
    virtual LARGE_INTEGER __stdcall Expiration()
    {
        LARGE_INTEGER ret;
        ret.QuadPart = KERB_KDB_TIME_NEVER;
        return  ret;
    };

    virtual LARGE_INTEGER __stdcall MaxLifeTime()
    {
        LARGE_INTEGER ret;
        ret.QuadPart = KERB_KDB_TIME_NEVER;
        return  ret;
    };

    virtual LARGE_INTEGER __stdcall MaxRenewTime()
    {
        LARGE_INTEGER ret;
        ret.QuadPart = KERB_KDB_TIME_NEVER;
        return  ret;
    };

    virtual BOOL __stdcall IsPacRequested() = 0;

    //
    //  Allows the core to encrypt/decrypt or generate signatures/checksums
    //  for buffers.
    //
    //  Note that no keys are passed in.  The keys are encapsulated in this
    //  IKerbPrincipal.  The core tells the provider what encryption type
    //  to use so that the provider can select the right key for the operation.
    //
    virtual KERBERR __stdcall GetCiphertextSize(
                IN  PKERB_CRYPT_LIST     pEtypes,
                IN  ULONG                cbIn,
                OUT PULONG               pcbOut
    ) = 0;

    virtual KERBERR __stdcall Encrypt(
                IN  PKERB_CRYPT_LIST     pEtypes,
                IN  SALTFLAGS            saltflags,
                IN  PBYTE                pbIn,
                IN  ULONG                cbIn,
                OUT PKERB_ENCRYPTED_DATA pData,
                OUT PKERB_EXT_ERROR     pExtendedError
    ) = 0;

    //
    //  This method MUST return KDC_ERR_ETYPE_NOTSUPP if no key was found. This is used in
    //  the PA handler for checking encrypted time.
    //
    virtual KERBERR __stdcall Decrypt(
                IN  const KERB_CRYPT_LIST *  pEtypes,
                IN  SALTFLAGS saltflags,
                IN  const KERB_ENCRYPTED_DATA * pData,
                OUT PBYTE pbOut,
                OUT PULONG pcbOut,
                OUT OPTIONAL PETYPE pEtype,
                OUT PKERB_EXT_ERROR pExtendedError
    ) = 0;

    virtual NTSTATUS __stdcall GetChecksumSize(
                IN  CTYPE                Ctype,
                OUT PULONG               pcbOut
    ) = 0;

    virtual NTSTATUS __stdcall Checksum(
                IN  CTYPE                Ctype,
                IN  SALTFLAGS            saltflags,
                IN  PKERB_CRYPT_LIST     pEtypes,
                IN  PBYTE               *rgpbBuffers,
                IN  ULONG               *rgcbBuffers,
                IN  ULONG                cBuffers,
                IN  PBYTE                pbVerify,     // OPTIONAL
                IN  ULONG                cbVerify,     // OPTIONAL
                OUT PBYTE                pbChecksum,   // OPTIONAL
                OUT PULONG               pcbChecksum,  // OPTIONAL
                OUT PBOOLEAN             pfVerified,    // OPTIONAL
                OUT PKERB_EXT_ERROR     pExtendedError
    ) = 0;

    //
    //  Get all the encryption types that this principal supports. Frequently,
    //  this translates to the etypes supported by the provider.
    //
    virtual NTSTATUS __stdcall GetEtypes(
                OUT const ETYPE **ppEtypes,
                OUT PULONG       pcEtypes
    ) = 0;

    //
    //  Find etype that this principal has key for.  The requested pEtypes are in
    //  preferred order and as such, the provider should always use the top
    //  most etype whenever possible.
    //
    //  For providers that derive keys for different etypes from a master key, then this
    //  would be finding the most preferred encryption type supported by the provider.
    //
    //  The corresponding salt is also returned.
    //
    virtual KERBERR __stdcall GetEtypeMatch(
                IN  PKERB_CRYPT_LIST   pEtypes,
                OUT PKERB_ETYPE_INFO   *ppEtypeInfo
    ) = 0;

    //
    //  Key version to put in the ticket
    //
    virtual ULONG  __stdcall GetKeyVersion()
    {
        return KERB_NO_KEY_VERSION;
    }


#ifdef IMPL_PWSALT_PAHANDLER
    //
    //    Needs further investigation on getting the salt for the first common
    //    enc. type.  This is in because the code for generating the PwSalt is
    //    there and it uses this method.
    //
    virtual KERBERR _stdcall GetSaltForFirstCommonEtype(
        IN  OPTIONAL PKERB_CRYPT_LIST    petypelist,
        OUT UNICODE_STRING const       * pustrSaltUsed
    ) = 0;
#endif

    //
    //  The core will use QueryInterface with guids for IID_IKDBLogonInfo
    //  to get at data required to build a PAC.  This is the only interface
    //  required.
    //
    virtual HRESULT __stdcall QueryInterface(REFIID intf, PVOID *ppv)
    {
        UNREFERENCED_PARAMETER (intf);
        UNREFERENCED_PARAMETER (ppv);
        return  E_NOINTERFACE;
    }

    //
    //  Allows the core to get the provider responsible for this principal.
    //
    virtual IKdbProvider * __stdcall GetIKdbProvider(void) = 0;

    //
    //  Enables the core to tell the provider that the authentication for this principal
    //  is considered successful (eg. the PA-ENC-TIMESTAMP was successful).  The provider
    //  could use this to update its database for the last logon time.
    //
    virtual KERBERR __stdcall LogLogon(
        IN  IKerbRequest    *pIKerbRequest,
        IN  FILETIME    ft)
    {
        UNREFERENCED_PARAMETER (pIKerbRequest);
        UNREFERENCED_PARAMETER (ft);
        return KDC_ERR_NONE;
    }

    //
    //  TODO kokwaic 10/13/01
    //  A counter part to LogLogon or change LogLogon for failure cases.
    //


    //
    //  Allows core to tell the provider to update its keys.
    //
    //  TODO    kokwaic 10/13/01
    //  Does the core use this or handle the change password part of the protocol
    //
    virtual KERBERR __stdcall UpdateKeys(
        IN  PKERB_KEY_DATA pKeyData)
    {
        UNREFERENCED_PARAMETER (pKeyData);
        return KDC_ERR_NONE;
    }

};
typedef IKdbProvider* PIKdbProvider;


//
//  IPAHandler allows providers to write handlers to handle non-core pre-auth data.  The PA handlers
//  provided by the core uses the same interface to handle:
//      PA-ENC-TIMESTAMP    pre-authenticates a client by encrypting time stamp in client's key
//      PA-TGS-REQ          contains the [cross-realm] TGT and authenticator
//      PA-PW-SALT          tells client what salt to use to decrypt AS-REP if the no pre-auth was done.
//      PA-ETYPE-INFO       tells client encryption types supported by KDC if pre-auth fails
//      PA-PAC-REQUEST-EX   tells the KDC what section of the PAC should be generated.
//      PA-PK-AS-REQ        pre-authenticates with PKINIT
//      PA-PK-AS-REP        (to do PKINIT pre-authentication but to deal with a W2K client bug.)
//
//  PA handlers implemented by the provider must be registered with KdcRegisterPAHandlerFactory( ) that
//  requires the provider to provider IPAHandlerFactory be given by the provider to the core so that
//  the PA handlers can be instantiated.
//
//  The IPAHandler has a method to return the PA-type it handles and 3 main methods - Get, Check and
//  ReturnToClient.  Not all 3 need to be implemented by the provider.  The core groups calls one method for all
//  PA handlers at a time.  The Check( ) methods are called when the core requires the incoming pre-auth
//  data be validated.  The ReturnToClient( ) methods are called towards the end of the request processing when the
//  pre-auth for the REPLY needs to be generated.
//
//  The Get( ) methods are only invoked when there is insufficient pre-authentication in the request, ie when
//  the core needs to tell the client of the encryption types.
//
//  QueryInterface( ) enables the core or the provider to subsequently retrieve data extracted during
//  the Check( ) which parses the incoming pre-auth data.  The interfaces returned from QI depend on
//  the PA handler.  For example, the PA handler for PA-PAC-REQUEST-EX supports IPAPacReqEx that
//  returns the sections requested by the client.  Thus, when the PAC is getting built, the PAC handler
//  would request for this interface from this PA handler.
//
//  TODO: do we remove this section if this becomes an SDK
//  Another example is the PA-WITH-IDENTITY that is implemented by the Passport provider.  This PA handler
//  parses the TGTs contained in the incoming pre-auth data, and provides IPAIdentity for these data
//  to be retrieved when the PAC is generated.
//
//  There are 2 methods on the IKerbRequest that allows the core or provider to retrieve the relevant
//  interfaces or PA handlers: GetPAHandler(refiid, ) and GetPAHandler(PA-type,)
//
//  These additional interfaces are defined in kerbhelper.h
//

struct IPAHandler
{
    //
    //  The derived class will not override the base implementation if the class is stateless/static
    //
    virtual void __stdcall Release(void)
    {
        return;
    };

    //
    //  To get at the data access interfaces.
    //  The caller should not delete nor release the acquired interface.  This
    //  returned interface is part of a handler object.
    //
    virtual HRESULT __stdcall QueryInterface(REFIID intf, PVOID *ppv)
    {
        UNREFERENCED_PARAMETER (intf);
        UNREFERENCED_PARAMETER (ppv);
        return  E_NOINTERFACE;
    }

    //
    //  What PA data type does this handler process.
    //
    virtual ULONG GetPAType(void) = 0;

    //
    //  TODO: This one may not be needed. Used only when list of supported etypes
    //  is built. May use the output from Check for the same purpose
    //
    virtual KERBERR __stdcall Get(
        IN  IKerbRequest        *pIKerbRequest,
        OUT PKERB_PA_DATA_LIST  *ppPADataList)
    {
        UNREFERENCED_PARAMETER (pIKerbRequest);
        UNREFERENCED_PARAMETER (ppPADataList);
        return KDC_ERR_NONE;
    };

    virtual KERBERR __stdcall Check(
        IN  IKerbRequest                *pIKerbRequest,
        IN  PKERB_PA_DATA_LIST          pPreAuthData,
        OUT PKERB_ENCRYPTION_KEY         pEncryptionKey,
        OUT PKERB_PA_DATA_LIST          *ppOutPadata,
        OUT BOOLEAN*                    pbSufficient,
        OUT PKERB_EXT_ERROR     pExtendedError)
    {
        UNREFERENCED_PARAMETER (pIKerbRequest);
        UNREFERENCED_PARAMETER (pPreAuthData);
        UNREFERENCED_PARAMETER (pEncryptionKey);
        UNREFERENCED_PARAMETER (ppOutPadata);
        UNREFERENCED_PARAMETER (pbSufficient);
        UNREFERENCED_PARAMETER (pExtendedError);
        return KDC_ERR_NONE;
    };

    virtual KERBERR __stdcall ReturnToClient(
        IN  IKerbRequest        *pIKerbRequest,
        OUT PKERB_PA_DATA_LIST  *ppOutPadata)
    {
        UNREFERENCED_PARAMETER (pIKerbRequest);
        UNREFERENCED_PARAMETER (ppOutPadata);
        return KDC_ERR_NONE;
    };
};


//
//  PAC: This is a blob kept in the IF-RELEVANT of the authorization data, and
//  contains different sections for windows logon, PUIDs, client info and signatures.
//

#ifndef _PAC_INFO_BUFFER_
#define _PAC_INFO_BUFFER_
typedef struct _PAC_INFO_BUFFER {
    ULONG ulType;
    ULONG cbBufferSize;
    union {
        PBYTE Data;
        ULONG64 Offset;
    };
} PAC_INFO_BUFFER, *PPAC_INFO_BUFFER;
#endif

//
//  Authorization data are present in TKT, authenticator (not used in the protocol) and REQ.  Currently, only
//  the auth-data in the TKT is used: the TKT in the pre-auth data in the incoming REQ, and the resulting TKT.
//
//  AD handlers can be registered by the provider to allow the core to parse the auth-data using Check( ), or
//  generate the auth-data using AddToTicket.
//
//  The core currently only uses the AD handler to crack and generate the PAC - the PAC sits in the IF-RELEVANT
//  section of the auth-data.
//
//  QueryInterface is used to provide interfaces relevant to the AD handler.  For example, the AD handler for the
//  PAC provides IADPacSection to allow the provider to find the relevant section in the PAC.
//
//  Like the PA handlers, the core or the provider can locate the AD handler based on the refiid using
//  IKerbRequest::GetADHandler(refiid,)
//
struct IADHandler
{
    virtual void Release(void)
    {
        return;
    };

    virtual HRESULT __stdcall QueryInterface(REFIID intf, PVOID *ppv)
    {
        UNREFERENCED_PARAMETER (intf);
        UNREFERENCED_PARAMETER (ppv);
        return  E_NOINTERFACE;
    }

    //
    //  optional get AD type. Used to query AD handlers by type
    //
    virtual ULONG   __stdcall GetADType()
    {
        return  0;
    }

    virtual KERBERR __stdcall Check(
        IN  IKerbRequest    *pIKerbRequest,
        // Tgt server principal.
        IN  IKerbPrincipal  *piTgt,
        IN  PKERB_AUTHORIZATION_DATA pAuthData,
        OUT PKERB_EXT_ERROR pExtendedError)
    {
        UNREFERENCED_PARAMETER (piTgt);
        UNREFERENCED_PARAMETER (pIKerbRequest);
        UNREFERENCED_PARAMETER (pAuthData);
        UNREFERENCED_PARAMETER (pExtendedError);
        return KDC_ERR_NONE;
    };

    virtual KERBERR __stdcall AddToTicket(
        IN  IKerbRequest                *pIKerbRequest,
        OUT PKERB_AUTHORIZATION_DATA    *ppAuthData,
        OUT PKERB_EXT_ERROR pExtendedError)
    {
        UNREFERENCED_PARAMETER (pIKerbRequest);
        UNREFERENCED_PARAMETER (ppAuthData);
        UNREFERENCED_PARAMETER (pExtendedError);
        return KDC_ERR_NONE;
    };
};


//
//  This is specific to the generation of the different sections for the PAC, namely:
//      - Windows logon info
//      - PUIDs
//      - ClientInfo
//      - Passport profile (TBD)
//
//  The AD handler for the PAC invokes the relevant PAC handlers based on the values
//  in PA-PAC-REQUEST-EX.
//
struct IPACHandler
{
    virtual void Release(void)
    {
        return;
    };

    virtual HRESULT __stdcall QueryInterface(REFIID intf, PVOID *ppv)
    {
        UNREFERENCED_PARAMETER (intf);
        UNREFERENCED_PARAMETER (ppv);
        return  E_NOINTERFACE;
    }

    virtual ULONG GetPacType(void) = 0;

    virtual KERBERR __stdcall Build(
        IN  IKerbRequest     *pIKerbRequest,
        IN  BOOLEAN          fUpdatePac,
        OUT PPAC_INFO_BUFFER *ppPacInfo,
        OUT NTSTATUS         *pNTStatus)
    {
        UNREFERENCED_PARAMETER (pIKerbRequest);
        UNREFERENCED_PARAMETER (fUpdatePac);
        UNREFERENCED_PARAMETER (ppPacInfo);
        UNREFERENCED_PARAMETER (pNTStatus);
        return KDC_ERR_NONE;
    };
};


//
//  Each I*Handler class has its IHandlerFactory.  This is used by IKerbRequest to instantiate the handler.
//
struct IPAHandlerFactory
{
    virtual void Release(void)
    {
        return;
    };
    virtual NTSTATUS __stdcall CreateInstance(
        IN  IKerbRequest *pIKerbRequest,     //it might be helpful to pass IKerbRequest along
        OUT IPAHandler **ppIPAHandler
    ) = 0;
};

struct IADHandlerFactory
{
    virtual void Release(void)
    {
        return;
    };
    virtual NTSTATUS __stdcall CreateInstance(
        IN  IKerbRequest    *pIKerbRequest,
        OUT IADHandler     **ppIADHandler
    ) = 0;
};

struct IPACHandlerFactory
{
    virtual void Release(void)
    {
        return;
    };
    virtual NTSTATUS __stdcall CreateInstance(
        IN  IKerbRequest    *pIKerbRequest,
        OUT IPACHandler    **ppIPACHandler
    ) = 0;
};

#ifdef  KERB_TRANSPORTS_DONE
//
//  TODO: Incomplete
//  Transport: to deal with transports other than ATQ.
//
typedef KERBERR (NTAPI *PFN_ENDPOINT)(IKerbTransportData *pIKerbTransportData);

struct IKerbTransport
{
    virtual ~IKerbTransport();
    virtual NTSTATUS __stdcall Register(IN  PFN_ENDPOINT);
    virtual NTSTATUS __stdcall Initialize(void);
    virtual NTSTATUS __stdcall Shutdown(void);
};


struct IKerbTransportData
{
    virtual ~IKerbTransportData();
    virtual NTSTATUS __stdcall Read(
        IN  PBYTE   pb,
        IN  ULONG   cb,
        OUT ULONG   *pcbRead) = 0;

    virtual NTSTATUS __stdcall Write(
        IN  PBYTE   pb,
        IN  ULONG   cb,
        OUT ULONG   *pcbWritten) = 0;

    virtual NTSTATUS __stdcall GetAddr(
        IN  BOOL        fLocal,     //FALSE for Remote socket addr.
        OUT PSOCKADDR   pSockAddr);

    virtual NTSTATUS __stdcall Flush(void) = 0;
};

#endif

//-------------------------------------------------------------------------------------
//              R e s i d e s   i n   t h e   c o r e
//-------------------------------------------------------------------------------------

//
//  Types of handlers for parsing and constructing PA-Data, AuthData, PAC,
//  ticket extensions and filters.
//
typedef enum
{
    eHandlerType_PA,
    eHandlerType_AD,
    eHandlerType_PAC,
    eHandlerType_TIX,
    eHandlerType_FILTER,
    eHandlerType_count
} ENUM_HANDLER_TYPE;
//  KDC core interface exports are declared in kdccoore
//  a struct contains all func ptrs exposed by the core to the providers
//  and handlers
#include <kdccore.hxx>


//
//  IKerbRequest is implemented in the KDC core.
//  It represents an AS or TGS request and the methods invoke the interfaces
//  to create the ticket, response and error messages.  This interface is invoked
//  by the "transport" or transport wrapper.
//
//  The goal is to encapsulate data that proliferate as arguments in the core code.
//  However, caution is exercised while making the args. as access methods on IKerbRequest.
//  We want to have balance between readability by removing the args. and readability
//  as to how args are used by the core functions.
//
struct IKerbRequest
{
public:
    //
    //  Handlers will use this method to get "data access" interfaces from other
    //  handlers.
    //
    virtual NTSTATUS __stdcall GetPAHandler(REFIID intf, PVOID *ppv) = 0;
    virtual NTSTATUS __stdcall GetPAHandler(ULONG ulPATyupe, PIPAHandler *ppv) = 0;
    virtual NTSTATUS __stdcall GetADHandler(REFIID intf, PVOID *ppv) = 0;
//    virtual NTSTATUS __stdcall GetADHandler(ULONG ulADType, PIPAHandler *ppv)
    virtual NTSTATUS __stdcall GetPACHandler(ULONG ulPacType, PIPACHandler *ppv) = 0;

    //
    //  Callbacks from the provider or handlers for info.
    //  To be added as needed
    //

    virtual PIKerbPrincipal GetIPrincClient(void) = 0;

    //
    //  This could be the requested service known to this KDC or it could be
    //  a service realm for a referral ticket
    //
    virtual PIKerbPrincipal GetIPrincService(void) = 0;

    //
    //  Encryption types preferred - stated in the request.
    //
    virtual PKERB_CRYPT_LIST GetEncryptionTypes(void) = 0;
    virtual const KERB_ENCRYPTION_KEY* __stdcall GetSessionKey() = 0;
    virtual KERB_SERVICE_ID GetServId(void) = 0;

    //
    //  In an AS request, this is the TGT that is being constructed (represents server info.)
    //  In a TGS request, this is incoming TGT (client info.)
    //
    virtual const KERB_ENCRYPTED_TICKET * __stdcall GetTgt(void) = 0;

    //  get authenticator for TGS request
    virtual const KERB_AUTHENTICATOR *  __stdcall  GetAuthenticator() = 0;

    //  get the request body
    virtual  const KERB_KDC_REQUEST* __stdcall GetKdcRequest() = 0;
    
    //  get the client address
    virtual  const SOCKADDR* __stdcall GetClientAddress() = 0;

    //  get the elapsed time for this request
    virtual const DWORD __stdcall GetElapsedTimeInMs() = 0;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\rtl\pacndr_s_stub.c ===
#include <krbprgma.h>
#include "pacndr_s.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\rtl\pacndr_c_stub.c ===
#include <krbprgma.h>
#include "pacndr_c.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\rtl\rtlp.h ===
#pragma once

#include "krbprgma.h"
#include <secpch2.hxx>
#include <lmcons.h>
#include <secint.h>
#include <sectrace.hxx>
#include <tostring.hxx>
#include <lmaccess.h>
#include <midles.h>
#include <pacndr.h>
//#include <samrpc.h>
//#include <samisrv.h>
//#include <logonmsv.h>
#include <pac.hxx>
#include "pacint.h"
//#include <paccvt.hxx>
#include <pacpat.hxx>
#include "align.h"
#include "general_stubs.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\rtl\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_secmisc_none_12.4.56.0_none_af6ce5a666a0fe47
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_secmisc_no-public-key_12.4.56.0_x-ww_97262c33
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=secmisc
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_secmisc_no-public-key_12.4.56.0_x-ww_97262c33
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_secmisc_no-public-key_12.4.56.0_x-ww_97262c33.manifest
XP_MANIFEST_PATH=manifests\x86_secmisc_no-public-key_12.4.56.0_x-ww_97262c33.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_secmisc_no-public-key_12.4.56.0_x-ww_97262c33.cat
XP_CATALOG_PATH=manifests\x86_secmisc_no-public-key_12.4.56.0_x-ww_97262c33.cat
XP_PAYLOAD_PATH=x86_secmisc_no-public-key_12.4.56.0_x-ww_97262c33
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=secmisc,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\rtl\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_secmisc_none_12.4.56.0_none_af6ce5a666a0fe47
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_secmisc_no-public-key_12.4.56.0_x-ww_97262c33
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=secmisc
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_secmisc_no-public-key_12.4.56.0_x-ww_97262c33
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_secmisc_no-public-key_12.4.56.0_x-ww_97262c33.manifest
XP_MANIFEST_PATH=manifests\x86_secmisc_no-public-key_12.4.56.0_x-ww_97262c33.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_secmisc_no-public-key_12.4.56.0_x-ww_97262c33.cat
XP_CATALOG_PATH=manifests\x86_secmisc_no-public-key_12.4.56.0_x-ww_97262c33.cat
XP_PAYLOAD_PATH=x86_secmisc_no-public-key_12.4.56.0_x-ww_97262c33
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=secmisc,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\sclogon\sclogonp.h ===
#pragma once


#define WIN32_NO_STATUS
#include <winternl.h>
#undef WIN32_NO_STATUS
#include <windows.h>
#include <ntstatus.h>
typedef NTSTATUS * PNTSTATUS;
#define _NTDEF_
#include <ntsecapi.h>
#undef _NTDEF_
#include <subauth.h>
#include <wincrypt.h>

#include "general_stubs.h"

#include <winscard.h>
#include <wincrypt.h>
#include <softpub.h>
#include <stddef.h>
#include <crtdbg.h>
#include "sclogon.h"
#include "unicodes.h"
#include <stdlib.h>
#include <stdio.h>
#include <time.h>
#include <tchar.h>
#include <sha.h>
#include <sclmsg.h>
#include <assert.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\sclogon\unicodes.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    unicodes

Abstract:

    This module implements the CUnicodeString class.  This class allows a string
    to automatically convert between PUNICODE_STRING, LPCSTR, and LPCWSTR.

Author:

    Doug Barlow (dbarlow) 11/6/1997

Environment:

    Win32, C++

Notes:

    ?Notes?

--*/

#include "sclogonp.h"


//
// Piddly routines.
//

CUnicodeString::CUnicodeString(
    void)
{
    m_szAnsi = NULL;
    m_wszUnicode = NULL;
    m_fFlags = fBothGood;
}

CUnicodeString::CUnicodeString(
    LPCSTR sz)
{
    m_szAnsi = NULL;
    m_wszUnicode = NULL;
    m_fFlags = fBothGood;
    Set(sz);
}

CUnicodeString::CUnicodeString(
    LPCWSTR wsz)
{
    m_szAnsi = NULL;
    m_wszUnicode = NULL;
    m_fFlags = fBothGood;
    Set(wsz);
}

CUnicodeString::CUnicodeString(
    PUNICODE_STRING pus)
{
    m_szAnsi = NULL;
    m_wszUnicode = NULL;
    m_fFlags = fBothGood;
    Set(pus);
}

CUnicodeString::~CUnicodeString()
{
    if (NULL != m_szAnsi)
    {
        memset(m_szAnsi, 0, lstrlenA(m_szAnsi));
        LocalFree(m_szAnsi);
    }
    if (NULL != m_wszUnicode)
    {
        memset(m_wszUnicode, 0, lstrlenW(m_wszUnicode)*sizeof(WCHAR));
        LocalFree(m_wszUnicode);
    }
}

PUNICODE_STRING
CUnicodeString::Set(
    PUNICODE_STRING pus)
{
    if (NULL != m_szAnsi)
    {
        LocalFree(m_szAnsi);
        m_szAnsi = NULL;
    }
    if (NULL != m_wszUnicode)
    {
        LocalFree(m_wszUnicode);
        m_wszUnicode = NULL;
    }
    m_fFlags = fNoneGood;
    if (pus != NULL)
    {
        m_wszUnicode = (LPWSTR)LocalAlloc(LPTR, pus->Length + sizeof(WCHAR));
        if (m_wszUnicode != NULL)
        {
            CopyMemory(
                m_wszUnicode,
                pus->Buffer,
                pus->Length
                );
            m_wszUnicode[pus->Length/sizeof(WCHAR)] = L'\0';
            m_fFlags = fUnicodeGood;
        }
    }
    return pus;
}


/*++

Set:

    These methods initialize the object to a given string.

Arguments:

    sz - Supplies an ANSI string with which to initialize the object.

    wsz - Supplies a UNICODE string with which to initialize the object.

    pus - Supplies a pointer to a UNICODE_STRING structure from which to
        initialize the object.

Return Value:

    The same value as was provided.

Author:

    Doug Barlow (dbarlow) 11/6/1997

--*/

LPCSTR
CUnicodeString::Set(
    LPCSTR sz)
{
    if (NULL != m_wszUnicode)
    {
        LocalFree(m_wszUnicode);
        m_wszUnicode = NULL;
    }
    if (NULL != m_szAnsi)
        LocalFree(m_szAnsi);
    m_fFlags = fNoneGood;

    m_szAnsi = (LPSTR)LocalAlloc(LPTR, (lstrlenA(sz) + 1) * sizeof(CHAR));
    if (NULL != m_szAnsi)
    {
        lstrcpyA(m_szAnsi, sz);
        m_fFlags = fAnsiGood;
    }
    return m_szAnsi;
}

LPCWSTR
CUnicodeString::Set(
    LPCWSTR wsz)
{
    if (NULL != m_szAnsi)
    {
        LocalFree(m_szAnsi);
        m_szAnsi = NULL;
    }
    if (NULL != m_wszUnicode)
        LocalFree(m_wszUnicode);
    m_fFlags = fNoneGood;
    m_wszUnicode = (LPWSTR)LocalAlloc(LPTR, (lstrlenW(wsz) + 1) * sizeof(WCHAR));
    if (m_wszUnicode != NULL)
    {
        lstrcpyW(m_wszUnicode, wsz);
        m_fFlags = fUnicodeGood;
    }
    return m_wszUnicode;
}

CUnicodeString::operator PUNICODE_STRING(
    void)
{
    m_us.Buffer = (LPWSTR)Unicode();
    m_us.Length = m_us.MaximumLength = (USHORT)(lstrlenW(m_us.Buffer) * sizeof(WCHAR));
    return &m_us;
}


/*++

Unicode:

    This method ensures that the object has a valaid internal UNICODE
    representation.

Arguments:

    None

Return Value:

    The represented string, in UNICODE format.

Author:

    Doug Barlow (dbarlow) 11/6/1997

--*/

LPCWSTR
CUnicodeString::Unicode(
    void)
{
    int length;


    //
    // See what data we've got, and if any conversion is necessary.
    //

    switch (m_fFlags)
    {
    case fAnsiGood:
        // The ANSI value is good.  Convert it to Unicode.
        _ASSERTE(NULL != m_szAnsi);
        length =
            MultiByteToWideChar(
                GetACP(),
                MB_PRECOMPOSED,
                m_szAnsi,
                -1,
                NULL,
                0);
        if (NULL != m_wszUnicode)
        {
            LocalFree(m_wszUnicode);
        }
        if (0 != length)
        {
            m_wszUnicode = (LPWSTR)LocalAlloc(LPTR, (length + 1) * sizeof(WCHAR));
            if (m_wszUnicode == NULL)
            {
                break;
            }
            length =
                MultiByteToWideChar(
                    GetACP(),
                    MB_PRECOMPOSED,
                    m_szAnsi,
                    -1,
                    m_wszUnicode,
                    length);
            m_wszUnicode[length] = 0;
        }
        else
        {
            m_wszUnicode = NULL;
        }
        m_fFlags = fBothGood;
        break;

    case fUnicodeGood:
    case fBothGood:
        // The Unicode value is good.  Just return that.
        break;

    case fNoneGood:
    default:
        // Internal error.
        _ASSERT(FALSE);
        break;
    }
    return m_wszUnicode;
}


/*++

Ansi:

    This method ensures that the object has a valaid internal ANSI
    representation.

Arguments:

    None

Return Value:

    The represented string, in ANSI format.

Author:

    Doug Barlow (dbarlow) 11/6/1997

--*/

LPCSTR
CUnicodeString::Ansi(
    void)
{
    int length;


    //
    // See what data we've got, and if any conversion is necessary.
    //

    switch (m_fFlags)
    {
    case fUnicodeGood:
        // The Unicode buffer is good.  Convert it to ANSI.
        length =
            WideCharToMultiByte(
                GetACP(),
                0,
                m_wszUnicode,
                -1,
                NULL,
                0,
                NULL,
                NULL);
        if (NULL != m_szAnsi)
        {
            LocalFree(m_szAnsi);
        }

        if (0 != length)
        {
            m_szAnsi = (LPSTR)LocalAlloc(LPTR, (length + 1) * sizeof(CHAR));
            if (m_szAnsi == NULL)
            {
                break;
            }
            length =
                WideCharToMultiByte(
                    GetACP(),
                    0,
                    m_wszUnicode,
                    -1,
                    m_szAnsi,
                    length,
                    NULL,
                    NULL);
            m_szAnsi[length] = 0;
        }
        else
        {
            m_szAnsi = NULL;
        }
        m_fFlags = fBothGood;
        break;

    case fAnsiGood:
    case fBothGood:
        // The ANSI buffer is good.  We'll return that.
        break;

    case fNoneGood:
    default:
        // An internal error.
        _ASSERT(FALSE);
        break;
    }
    return m_szAnsi;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\sclogon\sclogon.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    ScLogon

Abstract:

    This module provides helper functions for use by winlogon (GINA, Kerberos)

Author:

    Amanda Matlosz (amatlosz) 10/22/1997

Environment:

    Win32, C++ w/ Exceptions

Notes:

        03-11-98 Wrap calls to GetLastError() to workaround bug where LastErr gets
                        clobbered.  Added event logging to make logon smoother.

                04-02-98 Removed all references to WinVerifyTrust; this is something
                                                Kerberos itself is responsible for.
--*/

/////////////////////////////////////////////////////////////////////////////
//
// Includes

#include "sclogonp.h"


#ifndef KP_KEYEXCHANGE_PIN
#define KP_KEYEXCHANGE_PIN 32
#else
#if 32 != KP_KEYEXCHANGE_PIN
#error Invalid KP_KEYEXCHANGE_PIN assumption
#endif
#endif
#ifndef CRYPT_SILENT
#define CRYPT_SILENT 0x40
#else
#if 0x40 != CRYPT_SILENT
#error Duplicate CRYPT_SILENT definition
#endif
#endif
#ifndef SCARD_PROVIDER_CSP
#define SCARD_PROVIDER_CSP 2
#else
#if 2 != SCARD_PROVIDER_CSP
#error Invalid SCARD_PROVIDER_CSP definition
#endif
#endif

// TODO: The following logging is still proving useful.
// TODO: leave in for B3: integrate more tightly w/ winlogon/kerberos ??
#include <sclmsg.h>

// A Global class used to maintain internal state.
class CSCLogonInit
{
public:
    // Runs at image creation
    CSCLogonInit(
        BOOL *pfResult)
    {
        m_hCrypt = NULL;
        *pfResult = TRUE;
    };

    // Runs at image termination
    ~CSCLogonInit()
    {
        Release();
    };

    // Cleans up current state.
    void
    Release(
        void)
    {
        if (NULL != m_hCrypt)
        {
            CryptReleaseContext(m_hCrypt, 0);
            m_hCrypt = NULL;
        }
    }

    // Relinquish control of the crypto context.
    HCRYPTPROV
    RelinquishCryptCtx(
        LogonInfo* pLogon)
    {
        HCRYPTPROV hProv;

        hProv = CryptCtx(pLogon);
        m_hCrypt = NULL;
        return hProv;
    };

    // Get the crypto context, creating it if it's not there.
    HCRYPTPROV
    CryptCtx(
        LogonInfo* pLogon)
    {
        HCRYPTPROV hProv;
        LPCTSTR szRdr = NULL;
        LPCTSTR szCntr = NULL;
        LPTSTR szFQCN = NULL;
        LONG lLen = 0;

        if (NULL == m_hCrypt)
        {
            BOOL fSts;

            // Prepare FullyQualifiedContainerName for CryptAcCntx call

            szRdr = GetReaderName((LPBYTE)pLogon);
            szCntr = GetContainerName((LPBYTE)pLogon);

            lLen = (lstrlen(szRdr) + lstrlen(szCntr) + 10)*sizeof(TCHAR);
            szFQCN = (LPTSTR)LocalAlloc(LPTR, lLen);
            if (NULL != szFQCN)
            {
                wsprintf(szFQCN, TEXT("\\\\.\\%s\\%s"), szRdr, szCntr);

                fSts = CryptAcquireContext(
                    &m_hCrypt,
                    szFQCN,
                    GetCSPName((LPBYTE)pLogon),
                    PROV_RSA_FULL,  // ?TODO? from pbLogonInfo
                    CRYPT_SILENT | CRYPT_MACHINE_KEYSET
                    );

                LocalFree(szFQCN);
            }
            else
            {
                fSts = FALSE;
            }
        }
        hProv = m_hCrypt;
        return hProv;
    }

protected:
    HCRYPTPROV m_hCrypt;
};

NTSTATUS ScNtStatusTranslation(NTSTATUS NtErr, DWORD *pdwErr)
{
    //
    // Convert the error back to a Win32 error
    //
    switch (NtErr)
    {
    case STATUS_INVALID_PARAMETER:
        *pdwErr = ERROR_INVALID_DATA;
        break;

    case STATUS_SMARTCARD_SUBSYSTEM_FAILURE:
            // A Cryptxxx API just failed
        *pdwErr = GetLastError();
        switch (*pdwErr)
        {
        case SCARD_W_WRONG_CHV:
        case SCARD_E_INVALID_CHV:
            NtErr = STATUS_SMARTCARD_WRONG_PIN;
            break;

        case SCARD_W_CHV_BLOCKED:
            NtErr = STATUS_SMARTCARD_CARD_BLOCKED;
            break;

        case SCARD_W_REMOVED_CARD:
        case SCARD_E_NO_SMARTCARD:
            NtErr = STATUS_SMARTCARD_NO_CARD;
            break;

        case NTE_BAD_KEYSET:
        case NTE_KEYSET_NOT_DEF:
            NtErr = STATUS_SMARTCARD_NO_KEY_CONTAINER;
            break;

        case SCARD_E_NO_SUCH_CERTIFICATE:
        case SCARD_E_CERTIFICATE_UNAVAILABLE:
            NtErr = STATUS_SMARTCARD_NO_CERTIFICATE;
            break;

        case NTE_NO_KEY:
            NtErr = STATUS_SMARTCARD_NO_KEYSET;
            break;

        case SCARD_E_TIMEOUT:
        case SCARD_F_COMM_ERROR:
        case SCARD_E_COMM_DATA_LOST:
            NtErr = STATUS_SMARTCARD_IO_ERROR;
            break;

        case NTE_SILENT_CONTEXT:
            NtErr = STATUS_SMARTCARD_SILENT_CONTEXT;
            break;

        //default:
            // Nothing, leave NtErr unchanged
        }
        break;

    case STATUS_INSUFFICIENT_RESOURCES:
    case STATUS_NO_MEMORY:
        *pdwErr = ERROR_OUTOFMEMORY;
        break;

    case STATUS_BUFFER_TOO_SMALL:
        *pdwErr = SEC_E_BUFFER_TOO_SMALL;
        break;

    default:
        *pdwErr = SCARD_E_UNEXPECTED;
    }

    return NtErr;
}

// For tracing errors in ScHelper*

NTSTATUS LogEvent(NTSTATUS NtErr, DWORD dwEventID)
{
    DWORD dwErr;
    //
    // Convert the error back to a Win32 error
    //
    NtErr = ScNtStatusTranslation(NtErr, &dwErr);

    if (0 == dwErr)
    {
        return NtErr;
    }

    //
    // Initialize log as necessary
    //
    HKEY    hKey;
    DWORD   disp;

    long err = RegCreateKeyEx(
        HKEY_LOCAL_MACHINE,
        TEXT("System\\CurrentControlSet\\Services\\EventLog\\Application\\Smart Card Logon"),
        0,
        TEXT(""),
        REG_OPTION_NON_VOLATILE,
        KEY_WRITE,
        NULL,
        &hKey,
        &disp
        );

    if (ERROR_SUCCESS != err)
    {
        return NtErr;
    }

    if (disp == REG_CREATED_NEW_KEY)
    {
        PBYTE l_szModulePath = (PBYTE)TEXT("%SystemRoot%\\System32\\kerberos.dll");
        ULONG l_uLen = (_tcslen((LPCTSTR)l_szModulePath) + 1)*sizeof(TCHAR);

        RegSetValueEx(
            hKey,
            TEXT("EventMessageFile"),
            0,
            REG_EXPAND_SZ,
            l_szModulePath,
            l_uLen
            );

        disp = (DWORD)(
            EVENTLOG_ERROR_TYPE |
            EVENTLOG_WARNING_TYPE |
            EVENTLOG_INFORMATION_TYPE
            );

        RegSetValueEx(
            hKey,
            TEXT("TypesSupported"),
            0,
            REG_DWORD,
            (PBYTE) &disp,
            sizeof(DWORD)
            );
    }

    RegCloseKey(hKey);

    HANDLE hEventSource = RegisterEventSource(
        NULL,
        TEXT("Smart Card Logon")
        );

    if (NULL != hEventSource)
    {
        DWORD dwLen = 0;
        LPTSTR szErrorString = NULL;
        TCHAR szBuffer[2+8+1];  // Enough for "0x????????"

        dwLen = FormatMessage(
                FORMAT_MESSAGE_ALLOCATE_BUFFER
                | FORMAT_MESSAGE_FROM_SYSTEM,
                NULL,
                dwErr,
                LANG_NEUTRAL,
                (LPTSTR)&szErrorString,
                0,
                NULL);

        if (dwLen == 0)
        {
            _stprintf(szBuffer, _T("0x%08lX"), dwErr);
            szErrorString = szBuffer;
        }

        ReportEvent(
            hEventSource,
            EVENTLOG_ERROR_TYPE,
            0,              // event category
            dwEventID,      // event identifier // resourceID for the messagetable entry...
            NULL,           // user security identifier (optional)
            1,              // number of strings to merge with message
            sizeof(long),   // size of binary data, in bytes
            (LPCTSTR*)&szErrorString,   // array of strings to merge with message
            (LPVOID)&dwErr   // address of binary data
            );

        DeregisterEventSource(hEventSource);

        if ((NULL != szErrorString) && (szErrorString != szBuffer))
        {
            LocalFree((LPVOID)szErrorString);
        }

    }

    return NtErr;
}


//////////////////////////////////////////////////////////////////////////////
//
// Structs



//////////////////////////////////////////////////////////////////////////////
//
// Functions
//

// Internal helpers: called by the ScLogon APIs to perform certain tedious work

/*++

GetReaderName:
GetCardName:
GetContainerName:
GetCSPName:

  : Intended for accessing the LogonInformation glob

Author:

        Amanda Matlosz

Note:

  Some of these are made available to outside callers; see sclogon.h

--*/

extern "C"
PBYTE
WINAPI
ScBuildLogonInfo(
    LPCTSTR szCard,
    LPCTSTR szReader,
    LPCTSTR szContainer,
    LPCTSTR szCSP)
{
    // No assumptions are made regarding the values of the incoming parameters;
    // At this point, it is legal for them all to be empty.
    // It is also possible that NULL values are being passed in -- if this is the case,
    // they must be replaced with empty strings.

    LPCTSTR szCardI = TEXT("");
    LPCTSTR szReaderI = TEXT("");
    LPCTSTR szContainerI = TEXT("");
    LPCTSTR szCSPI = TEXT("");

    if (NULL != szCard)
    {
        szCardI = szCard;
    }
    if (NULL != szReader)
    {
        szReaderI = szReader;
    }
    if (NULL != szContainer)
    {
        szContainerI = szContainer;
    }
    if (NULL != szCSP)
    {
        szCSPI = szCSP;
    }


    //
    // Build the LogonInfo glob using strings (or empty strings)
    //

    DWORD cbLi = offsetof(LogonInfo, bBuffer)
                 + (lstrlen(szCardI) + 1) * sizeof(TCHAR)
                 + (lstrlen(szReaderI) + 1) * sizeof(TCHAR)
                 + (lstrlen(szContainerI) + 1) * sizeof(TCHAR)
                 + (lstrlen(szCSPI) + 1) * sizeof(TCHAR);
    LogonInfo* pLI = (LogonInfo*)LocalAlloc(LPTR, cbLi);

    if (NULL == pLI)
    {
        return NULL;
    }

    pLI->ContextInformation = NULL;
    pLI->dwLogonInfoLen = cbLi;
    LPTSTR pBuffer = pLI->bBuffer;

    pLI->nCardNameOffset = 0;
    lstrcpy(pBuffer, szCardI);
    pBuffer += (lstrlen(szCardI)+1);

    pLI->nReaderNameOffset = (ULONG) (pBuffer-pLI->bBuffer);
    lstrcpy(pBuffer, szReaderI);
    pBuffer += (lstrlen(szReaderI)+1);

    pLI->nContainerNameOffset = (ULONG) (pBuffer-pLI->bBuffer);
    lstrcpy(pBuffer, szContainerI);
    pBuffer += (lstrlen(szContainerI)+1);

    pLI->nCSPNameOffset = (ULONG) (pBuffer-pLI->bBuffer);
    lstrcpy(pBuffer, szCSPI);
    pBuffer += (lstrlen(szCSPI)+1);

    _ASSERTE(cbLi == (DWORD)((LPBYTE)pBuffer - (LPBYTE)pLI));
    return (PBYTE)pLI;
}


LPCTSTR WINAPI GetReaderName(PBYTE pbLogonInfo)
{
    LogonInfo* pLI = (LogonInfo*)pbLogonInfo;

    if (NULL == pLI)
    {
        return NULL;
    }
    return &pLI->bBuffer[pLI->nReaderNameOffset];
};

LPCTSTR WINAPI GetCardName(PBYTE pbLogonInfo)
{
    LogonInfo* pLI = (LogonInfo*)pbLogonInfo;

    if (NULL == pLI)
    {
        return NULL;
    }
    return &pLI->bBuffer[pLI->nCardNameOffset];
};

LPCTSTR WINAPI GetContainerName(PBYTE pbLogonInfo)
{
    LogonInfo* pLI = (LogonInfo*)pbLogonInfo;

    if (NULL == pLI)
    {
        return NULL;
    }
    return &pLI->bBuffer[pLI->nContainerNameOffset];
};

LPCTSTR WINAPI GetCSPName(PBYTE pbLogonInfo)
{
    LogonInfo* pLI = (LogonInfo*)pbLogonInfo;

    if (NULL == pLI)
    {
        return NULL;
    }
    return &pLI->bBuffer[pLI->nCSPNameOffset];
};

/*++
BuildCertContext:

  Generates a certificate context with (static) keyprov info suitable for
  CertStore-based operations.

        If the PIN is provided, it is assumed the hProv (if provided) has not had the
        PIN parameter set...



Arguments:

    hProv -- must be a valid HCRYPTPROV

    pucPIN -- may be empty; used to set the PIN for hProv

    pbCert -- assumed to be a valid certificate; must not be NULL
    dwCertLen

    CertificateContext -- pointer to a pointer to the resultant CertContext

Return Value:

        NTSTATUS indicating STATUS_SUCCESS or error (see winerror.h or scarderr.h)

Author:

        Amanda Matlosz

Note:

--*/
NTSTATUS
BuildCertContext(
    IN HCRYPTPROV hProv,
    IN PUNICODE_STRING pucPIN,
    IN PBYTE pbCert,
    IN DWORD dwCertLen,
    OUT PCCERT_CONTEXT *CertificateContext
    )
{
    NTSTATUS lResult = STATUS_SUCCESS;
    BOOL fSts = FALSE;

    CRYPT_KEY_PROV_INFO KeyProvInfo;
    LPSTR szContainerName = NULL;
    LPSTR szProvName = NULL;
    CUnicodeString wszContainerName, wszProvName;
    DWORD cbContainerName, cbProvName;

    //
    // Check params
    //
    if ((NULL == hProv) || (NULL == pbCert || 0 == dwCertLen))
    {
        assert(FALSE);
        lResult = STATUS_INVALID_PARAMETER;
        goto ErrorExit;
    }

    //
    // Convert the certificate into a Cert Context.
    //
    *CertificateContext = CertCreateCertificateContext(
                    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                    pbCert,
                    dwCertLen);
    if (NULL == *CertificateContext)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

    //
    //  Associate cryptprovider w/ the private key property of this cert
    //

    //  ... need the container name

    fSts = CryptGetProvParam(
            hProv,
            PP_CONTAINER,
            NULL,     // out
            &cbContainerName,   // in/out
            0);
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }
    szContainerName = (LPSTR)LocalAlloc(LPTR, cbContainerName);
    if (NULL == szContainerName)
    {
        lResult = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorExit;
    }
    fSts = CryptGetProvParam(
            hProv,
            PP_CONTAINER,
            (PBYTE)szContainerName,     // out
            &cbContainerName,   // in/out
            0);
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }
    wszContainerName = szContainerName;

    //  ... need the provider name

    fSts = CryptGetProvParam(
            hProv,
            PP_NAME,
            NULL,     // out
            &cbProvName,   // in/out
            0);
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }
    szProvName = (LPSTR)LocalAlloc(LPTR, cbProvName);
    if (NULL == szProvName)
    {
        lResult = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorExit;
    }
    fSts = CryptGetProvParam(
            hProv,
            PP_NAME,
            (PBYTE)szProvName,     // out
            &cbProvName,   // in/out
            0);
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }
    wszProvName = szProvName;

    //
    // Set the cert context properties to reflect the prov info
    //

    KeyProvInfo.pwszContainerName = (LPWSTR)(LPCWSTR)wszContainerName;
    KeyProvInfo.pwszProvName = (LPWSTR)(LPCWSTR)wszProvName;
    KeyProvInfo.dwProvType = PROV_RSA_FULL;
    KeyProvInfo.dwFlags = CERT_SET_KEY_CONTEXT_PROP_ID;
    KeyProvInfo.cProvParam = 0;
    KeyProvInfo.rgProvParam = NULL;
    KeyProvInfo.dwKeySpec = AT_KEYEXCHANGE;
    KeyProvInfo.dwFlags |= CERT_SET_KEY_CONTEXT_PROP_ID;

    fSts = CertSetCertificateContextProperty(
                *CertificateContext,
                CERT_KEY_PROV_INFO_PROP_ID,
                0,
                (void *)&KeyProvInfo);
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;

        // the cert's been incorrectly created -- scrap it.
        CertFreeCertificateContext(*CertificateContext);
        *CertificateContext = NULL;

        goto ErrorExit;
    }

    CERT_KEY_CONTEXT certKeyContext;
    certKeyContext.cbSize = sizeof(CERT_KEY_CONTEXT);
    certKeyContext.hCryptProv = hProv;
    certKeyContext.dwKeySpec = KeyProvInfo.dwKeySpec;

    fSts = CertSetCertificateContextProperty(
                *CertificateContext,
                CERT_KEY_CONTEXT_PROP_ID,
                CERT_STORE_NO_CRYPT_RELEASE_FLAG,
                (void *)&certKeyContext);
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;

        // the cert's been incorrectly created -- scrap it.
        CertFreeCertificateContext(*CertificateContext);
        *CertificateContext = NULL;

        goto ErrorExit;
    }

ErrorExit:

    if(NULL != szContainerName)
    {
        LocalFree(szContainerName);
        szContainerName = NULL;
    }
    if(NULL != szProvName)
    {
        LocalFree(szProvName);
        szProvName = NULL;
    }

    if (!NT_SUCCESS(lResult))
    {
        lResult = LogEvent(lResult, (DWORD)EVENT_ID_BUILDCC);
    }

    return lResult;
}


///////////////////////////////////////////////////////////////////////////////
//
// ScLogon APIs
//


/*++

ScHelperInitializeContext:

        Prepares contextual information to be used by LSA while handling this
        smart card session.

Arguments:

        None.

Return Value:

        None

Author:

        Richard Ward

Note:

        Used by LSA.

--*/
NTSTATUS WINAPI
ScHelperInitializeContext(
    IN OUT PBYTE pbLogonInfo,
    IN ULONG cbLogonInfo
    )
{
    ULONG AllowedSize;

    LogonInfo *pLI = (LogonInfo *)pbLogonInfo;
    if ((cbLogonInfo < sizeof(ULONG)) ||
        (cbLogonInfo != pLI->dwLogonInfoLen))
    {
        return(STATUS_INVALID_PARAMETER);
    }

    AllowedSize = (cbLogonInfo - sizeof(LogonInfo) ) / sizeof(TCHAR) + sizeof(DWORD) ;
    //
    // Verify the other fields of the logon info
    //
    if ((pLI->nCardNameOffset > pLI->nReaderNameOffset) ||
        (pLI->bBuffer[pLI->nReaderNameOffset-1] != TEXT('\0')))
    {
        return(STATUS_INVALID_PARAMETER);
    }
    if ((pLI->nReaderNameOffset > pLI->nContainerNameOffset) ||
        (pLI->bBuffer[pLI->nContainerNameOffset-1] != TEXT('\0')))
    {
        return(STATUS_INVALID_PARAMETER);
    }
    if ((pLI->nContainerNameOffset > pLI->nCSPNameOffset) ||
        (pLI->bBuffer[pLI->nCSPNameOffset-1] != TEXT('\0')))
    {
        return(STATUS_INVALID_PARAMETER);
    }
    if ((pLI->nCSPNameOffset > AllowedSize) ||
        (pLI->bBuffer[AllowedSize-1] != TEXT('\0')))
    {
        return(STATUS_INVALID_PARAMETER);
    }


    _ASSERTE(pLI->ContextInformation == NULL);

    BOOL fResult = 0;
    pLI->ContextInformation = new CSCLogonInit(&fResult);
    if (pLI->ContextInformation == NULL)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }
    else
    {
        if (!fResult)
        {
            delete pLI->ContextInformation;
            pLI->ContextInformation = NULL;
            return(STATUS_INSUFFICIENT_RESOURCES);
        }
    }

    return(STATUS_SUCCESS);
}

/*++

ScHelperRelease:

        Releases contextual information used by LSA while handling this
        smart card session.

Arguments:

        None.

Return Value:

        None

Author:

        Richard Ward

Note:

        Used by LSA.

--*/
VOID WINAPI
ScHelperRelease(
    IN OUT PBYTE pbLogonInfo
    )
{
    _ASSERTE(NULL != pbLogonInfo);
    LogonInfo *pLI = (LogonInfo *)pbLogonInfo;
    CSCLogonInit * LogonInit = (CSCLogonInit *) pLI->ContextInformation;

    if (LogonInit != NULL)
    {
        LogonInit->Release();
        delete LogonInit;
        pLI->ContextInformation = NULL;
    }
}


/*++

ScHelperGetCertFromLogonInfo:

        Returns a CertificateContext for the cert on the card specified by the
        LogonInfo.  Creates the cert context by calling BuildCertContext,
        which generates a certificate context with (static) keyprov info
        suitable for CertStore-based operations.

Arguments:

        pucPIN may need the PIN to get a cert off certain SCs

Return Value:

        None

Author:

        Amanda Matlosz

Note:

        Used by LSA.

--*/
NTSTATUS WINAPI
ScHelperGetCertFromLogonInfo(
    IN PBYTE pbLogonInfo,
    IN PUNICODE_STRING pucPIN,
    OUT PCCERT_CONTEXT *CertificateContext
    )
{
    _ASSERTE(NULL != pbLogonInfo);
    LogonInfo *pLI = (LogonInfo *)pbLogonInfo;
    CSCLogonInit * LogonInit = (CSCLogonInit *) pLI->ContextInformation;
    BOOL fSts;
    NTSTATUS lResult = STATUS_SUCCESS;
    PCCERT_CONTEXT pCertCtx = NULL;
    HCRYPTPROV hProv = NULL;
    HCRYPTKEY hKey = NULL;
    LPBYTE pbCert = NULL;
    DWORD cbCertLen;

    //
    // Make sure we've got a Crypto Provider up and running.
    //
    hProv = LogonInit->CryptCtx(pLI);
    if (NULL == hProv)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

    //
    // Get the key handle.
    //
    fSts = CryptGetUserKey(
                hProv,
                AT_KEYEXCHANGE,
                &hKey);
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }


    //
    // Upload the certificate.
    //

    fSts = CryptGetKeyParam(
                hKey,
                KP_CERTIFICATE,
                NULL,
                &cbCertLen,
                0);
    if (!fSts)
    {
        DWORD dwGLE = GetLastError();

        if (ERROR_MORE_DATA != dwGLE)
        {
            if (NTE_NOT_FOUND == dwGLE)
            {
                SetLastError(SCARD_E_NO_SUCH_CERTIFICATE);
            }
            lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
            goto ErrorExit;
        }
    }

    pbCert = (LPBYTE)LocalAlloc(LPTR, cbCertLen);
    if (NULL == pbCert)
    {
        lResult = STATUS_NO_MEMORY;
        goto ErrorExit;
    }
    fSts = CryptGetKeyParam(
                hKey,
                KP_CERTIFICATE,
                pbCert,
                &cbCertLen,
                0);
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

    lResult = BuildCertContext(
        hProv,
        pucPIN,
        pbCert,
        cbCertLen,
        &pCertCtx);
    if (NT_SUCCESS(lResult))
        hProv = NULL;

    //
    // Clean up and return.
    //

ErrorExit:
    *CertificateContext = pCertCtx;

        // Do this early so GetLastError is not clobbered
    if (!NT_SUCCESS(lResult))
    {
        lResult = LogEvent(lResult, (DWORD)EVENT_ID_GETCERT);
    }

    if (NULL != hKey)
    {
        CryptDestroyKey(hKey);
    }
    if (NULL != hProv)
    {
        CryptReleaseContext(hProv, 0);
    }
    if (NULL != pbCert)
    {
        LocalFree(pbCert);
    }

    return lResult;
}

/*++

ScHelperGetProvParam:

        This API wraps the CryptGetProvParam routine for use with a smart card.
Arguments:

        pucPIN supplies a Unicode string containing the card's PIN.


        pbLogonInfo supplies the information required to identify the card, csp,
                etc.  It cannot be NULL.

        The other parameters are identical to CryptGetProvParam


Return Value:

    A STATUS_SUCECSS for success, or an error
--*/

NTSTATUS WINAPI
ScHelperGetProvParam(
    IN PUNICODE_STRING pucPIN,
    IN PBYTE pbLogonInfo,
    IN HCRYPTPROV hProv,
    DWORD dwParam,
    BYTE*pbData,
    DWORD *pdwDataLen,
    DWORD dwFlags
    )
{
    LogonInfo *pLI;
    CSCLogonInit *LogonInit;
    NTSTATUS lResult = STATUS_SUCCESS;
    HCRYPTPROV h = NULL;
    BOOL fSts;

    if (hProv != NULL)
    {
        h = hProv;
    }
    else
    {
        pLI = (LogonInfo *) pbLogonInfo;
        LogonInit = (CSCLogonInit *) pLI->ContextInformation;

        h = LogonInit->CryptCtx(pLI);
        if (NULL == h)
        {
            return LogEvent(STATUS_SMARTCARD_SUBSYSTEM_FAILURE, (DWORD)EVENT_ID_GETPROVPARAM);
        }
    }

    fSts = CryptGetProvParam(
            h,
            dwParam,
            pbData,
            pdwDataLen,
            dwFlags
            );

    if (!fSts)
    {
        if (GetLastError() == ERROR_NO_MORE_ITEMS)
        {
            return (STATUS_NO_MORE_ENTRIES);
        }
        else
        {
            return LogEvent(STATUS_SMARTCARD_SUBSYSTEM_FAILURE, (DWORD)EVENT_ID_GETPROVPARAM);
        }
    }

    return(STATUS_SUCCESS);
}


/*++

ScHelperVerifyCard:

        This API provides an easy way to verify the integrity of the card
        identified by pbLogonInfo (ie, that it has the private key associated
        w/ the public key contained in the certificate it returned via
        ScHelperGetCertFromLogonInfo) and, in so doing, authenticates the user
                to the card.

Arguments:

        pucPIN supplies a Unicode string containing the card's PIN.

        CertificateContext supplies the cert context received via
                ScHelperGetCertFromLogonInfo.

        hCertStore supplies the handle of a cert store which contains a CTL to
                use during certificate verification, or NULL to use the system default
                store.

        pbLogonInfo supplies the information required to identify the card, csp,
                etc.  It cannot be NULL.


Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    STATUS_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.
--*/

NTSTATUS WINAPI
ScHelperVerifyCard(
    IN PUNICODE_STRING pucPIN,
    IN PCCERT_CONTEXT CertificateContext,
    IN HCERTSTORE hCertStore,
    IN PBYTE pbLogonInfo
    )
{
    _ASSERTE(NULL != pbLogonInfo);

    LogonInfo *pLI = (LogonInfo *)pbLogonInfo;
    CSCLogonInit * LogonInit = (CSCLogonInit *) pLI->ContextInformation;
    NTSTATUS lResult = STATUS_SUCCESS;
    HCRYPTHASH hHash = NULL;
    HCRYPTPROV hProv = NULL;
    HCRYPTKEY hKey = NULL;
    PBYTE pbBlob = NULL;
    ULONG ulBlobLen = 32;
    PBYTE pbSignature = NULL;
    ULONG ulSigLen = 0;
    BOOL fSts;

    //
    // Make sure we've got a Crypto Provider up and running.
    //

    hProv = LogonInit->CryptCtx(pLI);
    if (NULL == hProv)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

    //
    // Generate a random key blob as the message to sign
    //

    pbBlob = (LPBYTE)LocalAlloc(LPTR, ulBlobLen);
    if (NULL == pbBlob)
    {
        lResult = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorExit;
    }

    fSts = CryptGenRandom(hProv, ulBlobLen, pbBlob);

    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

    //
    // The card signs a hash of the message...
    //

    lResult = ScHelperSignMessage(
                pucPIN,
                pbLogonInfo,
                NULL,
                CALG_MD5,
                pbBlob,
                ulBlobLen,
                pbSignature,
                &ulSigLen);

    if (STATUS_BUFFER_TOO_SMALL != lResult)
    {
        goto ErrorExit;
    }

    pbSignature = (LPBYTE)LocalAlloc(LPTR, ulSigLen);

    if (NULL == pbSignature)
    {
        lResult = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorExit;
    }

    lResult = ScHelperSignMessage(
                pucPIN,
                pbLogonInfo,
                NULL,
                CALG_MD5,
                pbBlob,
                ulBlobLen,
                pbSignature,
                &ulSigLen);

    if (!NT_SUCCESS(lResult))
    {
        goto ErrorExit;
    }

    //
    // Verify the signature is correct
    //

    lResult = ScHelperVerifyMessage(
                pbLogonInfo,
                NULL,
                CertificateContext,
                CALG_MD5,
                pbBlob,
                ulBlobLen,
                pbSignature,
                ulSigLen);

    //
    // Clean up and return.
    //

ErrorExit:

        // Do this early so GetLastError is not clobbered
    if (!NT_SUCCESS(lResult))
    {
        lResult = LogEvent(lResult, (DWORD)EVENT_ID_VERIFYCARD);
    }

    if (NULL != hKey)
    {
        CryptDestroyKey(hKey);
    }
    if (NULL != pbSignature)
    {
        LocalFree(pbSignature);
    }
    if (NULL != pbBlob)
    {
            LocalFree(pbBlob);
    }

    return lResult;
}


NTSTATUS WINAPI
ScHelperGenRandBits(
    IN PBYTE pbLogonInfo,
    IN OUT ScHelper_RandomCredBits* psc_rcb
)
{
    _ASSERTE(NULL != pbLogonInfo);

    LogonInfo *pLI = (LogonInfo *)pbLogonInfo;
    CSCLogonInit * LogonInit = (CSCLogonInit *) pLI->ContextInformation;
    NTSTATUS lResult = STATUS_SUCCESS;
    HCRYPTPROV hProv = NULL;
    BOOL fSts = FALSE;

    //
    // Make sure we've got a Crypto Provider up and running.
    //

    hProv = LogonInit->CryptCtx(pLI);
    if (NULL == hProv)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

    memset(psc_rcb, 0, sizeof(*psc_rcb));
    fSts = CryptGenRandom(hProv, 32, psc_rcb->bR1);

    if (fSts)
    {
        fSts = CryptGenRandom(hProv, 32, psc_rcb->bR2);
    }

    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
    }

ErrorExit:

    if (!NT_SUCCESS(lResult))
    {
        lResult = LogEvent(lResult, (DWORD)EVENT_ID_GENRANDBITS);
    }

    return lResult;
}


/*++

ScHelperCreateCredKeys:

    This routine (called by ScHelperVerifyCardAndCreds and
    ScHelperEncryptCredentials) munges a R1 and R2 to derive symmetric keys
    for encrypting and decrypting KDC creds, and or genearting an HMAC.

Arguments:

        pucPIN supplies a Unicode string containing the card's PIN.

        pbLogonInfo supplies the information required to identify the card, csp,
                etc.  It cannot be NULL.

        psc_rcb supplies the R1 and R2, previously generated by a call to
                ScHelperGenRandBits.

        phHmacKey recieves the generated HMAC key.

        phRc4Key receives the generated RC4 key.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    STATUS_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Remarks:

    You may supply a value of NULL to EncryptedData to receive only the
    required size of the EncryptedData buffer.

Author:

    Amanda Matlosz (amatlosz) 6/23/1999

--*/

NTSTATUS WINAPI
ScHelperCreateCredKeys(
    IN PUNICODE_STRING pucPIN,
    IN PBYTE pbLogonInfo,
    IN ScHelper_RandomCredBits* psc_rcb,
    IN OUT HCRYPTKEY* phHmacKey,
    IN OUT HCRYPTKEY* phRc4Key,
    IN OUT HCRYPTPROV* phProv
)
{
    NTSTATUS lResult = STATUS_SUCCESS;
    HCRYPTHASH hHash = NULL;
    HCRYPTPROV hProv = NULL;
    PBYTE pbR1Sig = NULL;
    DWORD dwR1SigLen = 0;
    HCRYPTHASH hKHash = NULL;
    LogonInfo *pLI = (LogonInfo *)pbLogonInfo;
    CUnicodeString szPin(pucPIN);
    BOOL fSts = FALSE;
    *phProv = NULL;

    // check params

    if (NULL == psc_rcb || NULL == phHmacKey || NULL == phRc4Key)
    {
        return(STATUS_INVALID_PARAMETER);
    }

    // Get hProv for smart card

    if (NULL != pucPIN)
    {
        if (!szPin.Valid())
        {
            return(STATUS_INSUFFICIENT_RESOURCES);
        }
    }

    CSCLogonInit * LogonInit = (CSCLogonInit *) pLI->ContextInformation;
    hProv = LogonInit->CryptCtx(pLI);
    if (NULL == hProv)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

    // Sign R1 w/ smart card

    fSts = CryptCreateHash(
        hProv,
        CALG_SHA1,
        NULL,
        NULL,
        &hHash);
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

    fSts = CryptHashData(
                hHash,
                psc_rcb->bR1,
                32, // TODO: const
                0);
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

    //
    // Declare the PIN.
    //

    if (NULL != pucPIN)
    {
        fSts = CryptSetProvParam(
                hProv,
                PP_KEYEXCHANGE_PIN,
                (LPBYTE)((LPCSTR)szPin),
                0);
        if (!fSts)
        {
            lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
            goto ErrorExit;
        }
    }

    fSts = CryptSignHash(
        hHash,
        AT_KEYEXCHANGE,
        NULL,
        0,
        NULL,
        &dwR1SigLen);
//  if (fSts || ERROR_MORE_DATA != GetLastError())
    if (0 >= dwR1SigLen)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

    pbR1Sig = (LPBYTE)LocalAlloc(LPTR, dwR1SigLen);

    if (NULL == pbR1Sig)
    {
        lResult = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorExit;
    }

    fSts = CryptSignHash(
        hHash,
        AT_KEYEXCHANGE,
        NULL,
        0,
        pbR1Sig,
        &dwR1SigLen);
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

    // TODO: sigR1 is the key to hash R2 with;
    // for now, just hash 'em together; use generic CSP
    fSts = CryptAcquireContext(
        phProv,
        NULL,
        NULL,
        PROV_RSA_FULL,
        CRYPT_VERIFYCONTEXT
        );
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

    fSts = CryptCreateHash(
        *phProv,
        CALG_SHA1,
        NULL,
        NULL,
        &hKHash
        );
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

    fSts = CryptHashData(
        hKHash,
        pbR1Sig,
        dwR1SigLen,
        NULL
        );
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

    fSts = CryptHashData(
        hKHash,
        psc_rcb->bR2,
        32, // TODO: use a const
        NULL
        );
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

    // create the rc4 key for the cred&hmac encryption

    fSts = CryptDeriveKey(
        *phProv,
        CALG_RC4, // stream cipher,
        hKHash,
        NULL,
        phRc4Key
        );
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

    // create the key for the HMAC from the hash of R1&2

    fSts = CryptDeriveKey(
        *phProv,
        CALG_RC2,
        hKHash,
        NULL,
        phHmacKey
        );
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

ErrorExit:

    //
    // cleanup
    //

    if (NULL != hHash)
    {
        CryptDestroyHash(hHash);
    }

    if (NULL != hKHash)
    {
        CryptDestroyHash(hKHash);
    }

    if (NULL != pbR1Sig)
    {
        LocalFree(pbR1Sig);
    }

    return lResult;
}


NTSTATUS WINAPI
ScHelperCreateCredHMAC(
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hHmacKey,
    IN PBYTE CleartextData,
    IN ULONG CleartextDataSize,
    IN OUT PBYTE* ppbHmac,
    IN OUT DWORD* pdwHmacLen
)
{
    NTSTATUS lResult = STATUS_SUCCESS;
    HCRYPTHASH hHMAC = NULL;
    HMAC_INFO hmac_info;
    BOOL fSts = FALSE;

    fSts = CryptCreateHash(
        hProv,
        CALG_HMAC,
        hHmacKey,
        NULL,
        &hHMAC
        );
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

    memset(&hmac_info, 0, sizeof(HMAC_INFO));
    hmac_info.HashAlgid = CALG_SHA1;

    fSts = CryptSetHashParam(
        hHMAC,
        HP_HMAC_INFO,
        (PBYTE)&hmac_info,
        NULL
        );
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

    fSts = CryptHashData(
        hHMAC,
        CleartextData,
        CleartextDataSize,
        NULL);
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

    fSts = CryptGetHashParam(
        hHMAC,
        HP_HASHVAL,
        *ppbHmac,
        pdwHmacLen,
        NULL
        );
    if (0 >= *pdwHmacLen)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

    *ppbHmac = (PBYTE)LocalAlloc(LPTR, *pdwHmacLen);

    if (NULL == *ppbHmac)
    {
        lResult = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorExit;
    }

    fSts = CryptGetHashParam(
        hHMAC,
        HP_HASHVAL,
        *ppbHmac,
        pdwHmacLen,
        NULL
        );
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

ErrorExit:

    if (NULL != hHMAC)
    {
        CryptDestroyHash(hHMAC);
    }

    return lResult;
}

/*++

ScHelperVerifyCardAndCreds:

    This routine combines Card Verification and Credential Decryption.

Arguments:

        pucPIN supplies a Unicode string containing the card's PIN.

        CertificateContext supplies the cert context received via
                ScHelperGetCertFromLogonInfo.

        hCertStore supplies the handle of a cert store which contains a CTL to
                use during certificate verification, or NULL to use the system
                default store.

        pbLogonInfo supplies the information required to identify the card, csp,
                etc.  It cannot be NULL.

        EncryptedData receives the encrypted credential blob.

        EncryptedDataSize supplies the size of the EncryptedData buffer in
            bytes, and receives the actual size of the encrypted blob.

        CleartextData supplies a credential blob to be encrypted.

        CleartextDataSize supplies the size of the blob, in bytes.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    STATUS_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Remarks:

    You may supply a value of NULL to EncryptedData to receive only the
    required size of the EncryptedData buffer.

Author:

    Doug Barlow (dbarlow) 5/24/1999

--*/

NTSTATUS WINAPI
ScHelperVerifyCardAndCreds(
    IN PUNICODE_STRING pucPIN,
    IN PCCERT_CONTEXT CertificateContext,
    IN HCERTSTORE hCertStore,
    IN PBYTE pbLogonInfo,
    IN PBYTE EncryptedData,
    IN ULONG EncryptedDataSize,
    OUT OPTIONAL PBYTE CleartextData,
    OUT PULONG CleartextDataSize
    )
{
    NTSTATUS lResult = STATUS_SUCCESS;

    // Verify the Card

    lResult = ScHelperVerifyCard(
                pucPIN,
                CertificateContext,
                hCertStore,
                pbLogonInfo);

    // Decrypt the Creds

    if (NT_SUCCESS(lResult))
    {
        lResult = ScHelperDecryptCredentials(
                pucPIN,
                CertificateContext,
                hCertStore,
                pbLogonInfo,
                EncryptedData,
                EncryptedDataSize,
                CleartextData,
                CleartextDataSize);
    }

    return lResult;
}




/*++

ScHelperDecryptCredentials:

    This routine decrypts an encrypted credential blob.

Arguments:

        pucPIN supplies a Unicode string containing the card's PIN.

        CertificateContext supplies the cert context received via
                ScHelperGetCertFromLogonInfo.

        hCertStore supplies the handle of a cert store which contains a CTL to
                use during certificate verification, or NULL to use the system
                default store.

        EncryptedData supplies the encrypted credential blob.

        EncryptedDataSize supplies the length of the encrypted credential blob,
            in bytes.

        CleartextData receives the decrypted credential blob.

        CleartextDataSize supplies the length of the CleartextData buffer, and
            receives the actual length of returned decrypted credential blob.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    STATUS_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Remarks:

    You may supply a value of NULL to CleartextData to receive only the
    required size of the buffer in CleartextDataSize.


Author:

    Doug Barlow (dbarlow) 5/24/1999

--*/

NTSTATUS WINAPI
ScHelperDecryptCredentials(
    IN PUNICODE_STRING pucPIN,
    IN PCCERT_CONTEXT CertificateContext,
    IN HCERTSTORE hCertStore,
    IN PBYTE pbLogonInfo,
    IN PBYTE EncryptedData,
    IN ULONG EncryptedDataSize,
    OUT OPTIONAL PBYTE CleartextData,
    OUT PULONG CleartextDataSize)
{
    NTSTATUS lResult = STATUS_SUCCESS;
    PBYTE pbCredBlob = NULL;
    DWORD dwCredBlobSize = 0;
    PBYTE pbHmac = NULL;        // the HMAC stored with the cred blob
    DWORD dwHmacSize = NULL;    // size of HMAC stored with cred blob
    PBYTE pbNewHmac = NULL;     // HMAC generated from cred blob for verify
    DWORD dwNewHmacSize = 0;    // size of gen'd HMAC
    PBYTE pb = NULL;
    DWORD dw = 0;
    PBYTE pbPlainCred = NULL;
    DWORD dwPlainCredSize = 0;
    HCRYPTKEY hHmacKey = NULL;
    HCRYPTKEY hRc4Key = NULL;
    HCRYPTPROV hGenProv = NULL;
    BOOL fSts = FALSE;


    // pull the SCH_RCB out of the EncryptedData blob
    ScHelper_RandomCredBits* psch_rcb = (ScHelper_RandomCredBits*)EncryptedData;
    // and build a private copy of the blob itself
    dwCredBlobSize = EncryptedDataSize - sizeof(ScHelper_RandomCredBits);
    pbCredBlob = (PBYTE)LocalAlloc(LPTR, dwCredBlobSize);
    if (NULL == pbCredBlob)
    {
        lResult = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorExit;
    }
    pb = EncryptedData + sizeof(ScHelper_RandomCredBits);
    CopyMemory(pbCredBlob, pb, dwCredBlobSize);


    //
    // Fetch the keys we need to decrypt & verify the cred blob
    //

    lResult = ScHelperCreateCredKeys(
                pucPIN,
                pbLogonInfo,
                psch_rcb,
                &hHmacKey,
                &hRc4Key,
                &hGenProv
                );
    if (!NT_SUCCESS(lResult))
    {
        goto ErrorExit;
    }


    //
    // Decrypt the cred blob
    //

    fSts = CryptDecrypt(
        hRc4Key,
        NULL,
        TRUE,
        NULL,
        pbCredBlob,
        &dwCredBlobSize);
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

    //
    // pull the HMAC out & verify it
    //

    dwHmacSize = (DWORD)*pbCredBlob;
    pbHmac = pbCredBlob + sizeof(DWORD);
    pbPlainCred = pbCredBlob + dwHmacSize + sizeof(DWORD);
    dwPlainCredSize = dwCredBlobSize - dwHmacSize - sizeof(DWORD);


    lResult = ScHelperCreateCredHMAC(
        hGenProv,
        hHmacKey,
        pbPlainCred,
        dwPlainCredSize,
        &pbNewHmac,
        &dwNewHmacSize);
    if (!NT_SUCCESS(lResult))
    {
        goto ErrorExit;
    }


    lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
    if (dwNewHmacSize == dwHmacSize)
    {
        for (dw = 0;
            (dw < dwNewHmacSize) && ((BYTE)*(pbHmac+dw)==(BYTE)*(pbNewHmac+dw));
            dw++);
        if (dwNewHmacSize == dw)
        {
            // verification succeeded!
            lResult = STATUS_SUCCESS;
        }
    }
    if (!NT_SUCCESS(lResult))
    {
        goto ErrorExit;
    }


    //
    // return the decrypted blob or just its length, as necessary
    //

    if ((NULL != CleartextData) && (0 < *CleartextDataSize))
    {
        if (*CleartextDataSize >= dwPlainCredSize)
        {
            CopyMemory(CleartextData, pbPlainCred, dwPlainCredSize);
        }
        else
            lResult = STATUS_BUFFER_TOO_SMALL;
    }
    else
    {
        lResult = STATUS_BUFFER_TOO_SMALL;
    }
    *CleartextDataSize = dwPlainCredSize;

    //
    // Cleanup and return
    //
ErrorExit:

    if (NULL != pbNewHmac)
    {
        LocalFree(pbNewHmac);
    }

    if (NULL != hHmacKey)
    {
        CryptDestroyKey(hHmacKey);
    }

    if (NULL != hRc4Key)
    {
        CryptDestroyKey(hRc4Key);
    }

    if (NULL != hGenProv)
    {
        CryptReleaseContext(hGenProv, NULL);
    }

    return lResult;
}


/*++

ScHelperEncryptCredentials:

    This routine encrypts a credential blob.

Arguments:

        pucPIN supplies a Unicode string containing the card's PIN.

        CertificateContext supplies the cert context received via
                ScHelperGetCertFromLogonInfo.

        hCertStore supplies the handle of a cert store which contains a CTL to
                use during certificate verification, or NULL to use the system
                default store.

        CleartextData supplies the cleartext credential blob.

        CleartextDataSize supplies the length of the cleartext credential blob,
            in bytes.

        EncryptedData receives the encrypted credential blob.

        EncryptedDataSize supplies the length of the EncryptedData buffer, and
            receives the actual length of returned encrypted credential blob.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    STATUS_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Remarks:

    You may supply a value of NULL to EncryptedData to receive only the
    required size of the buffer in EncryptedDataSize.


Author:

    Doug Barlow (dbarlow) 5/24/1999

--*/


NTSTATUS WINAPI
ScHelperEncryptCredentials(
    IN PUNICODE_STRING pucPIN,
    IN PCCERT_CONTEXT CertificateContext,
    IN HCERTSTORE hCertStore,
    IN ScHelper_RandomCredBits* psch_rcb,
    IN PBYTE pbLogonInfo,
    IN PBYTE CleartextData,
    IN ULONG CleartextDataSize,
    OUT OPTIONAL PBYTE EncryptedData,
    OUT PULONG EncryptedDataSize)
{
    NTSTATUS lResult = STATUS_SUCCESS;

    HCRYPTPROV hProv = NULL;
    BOOL fSts;
    LogonInfo *pLI = (LogonInfo *)pbLogonInfo;
    ULONG SignedEncryptedCredSize = 0;
    PBYTE SignedEncryptedCred = NULL; // encrypted cred&sig, !including R1+R2
    HCRYPTKEY hHmacKey = NULL;
    HCRYPTKEY hRc4Key = NULL;
    PBYTE pbHmac = NULL;
    DWORD dwHmacLen = 0;
    PBYTE pbCredsAndHmac  = NULL;
    DWORD dwCredsAndHmacLen = 0;
    DWORD dwEncryptedCredSize = 0;
    PBYTE pb = NULL;

    // parameter checking?


    //
    // do stuff to determine size required for SignedEncryptedCred
    //

    if (NULL == EncryptedData)
    {
        //
        // If the caller has explicitly made the call as a "size query," 
        // attempt to compute the resulting ciphertext size more 
        // efficiently, by not using the private key.
        //
        // ASSUME: The HMAC is SHA1 and the cipher is RC4.
        //

        *EncryptedDataSize = sizeof(DWORD) + CleartextDataSize + 
            A_SHA_DIGEST_LEN + sizeof(ScHelper_RandomCredBits);
        lResult = STATUS_BUFFER_TOO_SMALL;
        goto ErrorExit;
    }

    lResult = ScHelperCreateCredKeys(
                pucPIN,
                pbLogonInfo,
                psch_rcb,
                &hHmacKey,
                &hRc4Key,
                &hProv
                );
    if (!NT_SUCCESS(lResult))
    {
        goto ErrorExit;
    }

    // HMAC creds
    lResult = ScHelperCreateCredHMAC(
        hProv,
        hHmacKey,
        CleartextData,
        CleartextDataSize,
        &pbHmac,
        &dwHmacLen);
    if (!NT_SUCCESS(lResult))
    {
        goto ErrorExit;
    }


    // make a buffer with creds and HMAC

    pbCredsAndHmac = NULL;
    dwCredsAndHmacLen = dwHmacLen + CleartextDataSize + sizeof(DWORD);
    pbCredsAndHmac = (PBYTE)LocalAlloc(LPTR, dwCredsAndHmacLen);
    if (NULL == pbCredsAndHmac)
    {
        lResult = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorExit;
    }
    pb = pbCredsAndHmac;
    CopyMemory(pb, &dwHmacLen, sizeof(DWORD));
    pb += sizeof(DWORD);
    CopyMemory(pb, pbHmac, dwHmacLen);
    pb += dwHmacLen;
    CopyMemory(pb, CleartextData, CleartextDataSize);

    // Encrypt creds+HMAC
    dwEncryptedCredSize = dwCredsAndHmacLen;

    // After CryptEncrypt, dwCredsAndHmacLen describes the length of the data
    // to encrypt and dwEncryptedCredSize describes the req'd buffer length

    // TODO: VERIFY THE HANDLING OF dwEncryptedCredSize and dwCresAndHmacLen

    fSts = CryptEncrypt(
        hRc4Key,
        NULL,
        TRUE,
        NULL,
        pbCredsAndHmac,
        &dwEncryptedCredSize,
        dwCredsAndHmacLen
        );
    if (!fSts)
    {
        if (GetLastError() != ERROR_MORE_DATA)
        {
            lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
            goto ErrorExit;
        }
    }

    //
    // Create the final blob for return, or inform user of size, as necessary
    //

    if ((NULL != EncryptedData) && (0 < *EncryptedDataSize))
    {

        if (*EncryptedDataSize >= dwEncryptedCredSize + sizeof(ScHelper_RandomCredBits))
        {
            // the user gave us enough space for the whole thing.

            // if the previous CryptEncrypt failed with ERROR_MORE_DATA
            // we can now do something about it...
            if (!fSts)
            {
                // resize pbCredsAndHmac
                LocalFree(pbCredsAndHmac);
                pbCredsAndHmac = (PBYTE)LocalAlloc(LPTR, dwCredsAndHmacLen);
                if (NULL == pbCredsAndHmac)
                {
                    lResult = STATUS_INSUFFICIENT_RESOURCES;
                    goto ErrorExit;
                }
                // reset pbCredsAndHmac
                pb = pbCredsAndHmac;
                CopyMemory(pb, &dwHmacLen, sizeof(DWORD));
                pb += sizeof(DWORD);
                CopyMemory(pb, pbHmac, dwHmacLen);
                pb += dwHmacLen;
                CopyMemory(pb, CleartextData, CleartextDataSize);
                // re-encrypt CredsAndHmac
                fSts = CryptEncrypt(
                    hRc4Key,
                    NULL,
                    TRUE,
                    NULL,
                    pbCredsAndHmac,
                    &dwCredsAndHmacLen, // length of data
                    dwEncryptedCredSize // length of buffer
                    );
                if (!fSts)
                {
                    lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
                    goto ErrorExit;
                }
            }

            pb = EncryptedData;

            CopyMemory(pb, (PBYTE)psch_rcb, sizeof(ScHelper_RandomCredBits));
            pb += sizeof(ScHelper_RandomCredBits);
            CopyMemory(pb, pbCredsAndHmac, dwCredsAndHmacLen);

        }
        else
        {
            lResult = STATUS_BUFFER_TOO_SMALL;
        }
    }
    else
    {
        lResult = STATUS_BUFFER_TOO_SMALL;
    }
    *EncryptedDataSize = dwEncryptedCredSize + sizeof(ScHelper_RandomCredBits);

ErrorExit:

    // clean up!

    if (NULL != pbCredsAndHmac)
    {
        LocalFree(pbCredsAndHmac);
    }

    if (NULL != pbHmac)
    {
        LocalFree(pbHmac);
    }

    if (NULL != hRc4Key)
    {
        CryptDestroyKey(hRc4Key);
    }

    if (NULL != hHmacKey)
    {
        CryptDestroyKey(hHmacKey);
    }

    if (NULL != hProv)
    {
        CryptReleaseContext(hProv, NULL);
    }

    return lResult;
}


/*++

ScHelperSignMessage:

        ScHelperSignMessage() needs the logoninfo and PIN in order to find the card
        that will do the signing...

Arguments:

        pucPIN may need the PIN to get a cert off certain SCs

Return Value:

        "success" or "failure"

Author:

        Amanda Matlosz

Note:

        Used by LSA.

--*/
NTSTATUS WINAPI
ScHelperSignMessage(
    IN PUNICODE_STRING pucPIN,
    IN OPTIONAL PBYTE pbLogonInfo,
    IN OPTIONAL HCRYPTPROV Provider,
    IN ULONG Algorithm,
    IN PBYTE Buffer,
    IN ULONG BufferLength,
    OUT PBYTE Signature,
    OUT PULONG SignatureLength
    )
{
    NTSTATUS lResult = STATUS_SUCCESS;
    HCRYPTHASH hHash = NULL;
    HCRYPTPROV hProv = NULL;
    LogonInfo *pLI = (LogonInfo *)pbLogonInfo;
    CUnicodeString szPin(pucPIN);
    BOOL fSts;

    //
    // Make sure we've got a Crypto Provider up and running.
    //

    if (ARGUMENT_PRESENT(Provider))
    {
        hProv = Provider;
    }
    else
    {
        if (NULL != pucPIN)
        {
            if (!szPin.Valid())
            {
                return(STATUS_INSUFFICIENT_RESOURCES);
            }
        }


        CSCLogonInit * LogonInit = (CSCLogonInit *) pLI->ContextInformation;
        hProv = LogonInit->CryptCtx(pLI);
        if (NULL == hProv)
        {
            lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
            goto ErrorExit;
        }
    }

    //
    // We'll need a hash handle, too.
    //

    fSts = CryptCreateHash(
            hProv,
            Algorithm,
            NULL, // HCRYPTKEY (used for keyed algs, like block ciphers
            0,  // reserved for future use
            &hHash);

    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }


    //
    // Hash the input data.
    //

    fSts = CryptHashData(
                hHash,
                Buffer,
                BufferLength,
                0);
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }


    if (!ARGUMENT_PRESENT(Provider))
    {
        //
        // Declare the PIN.
        //

        if (NULL != pucPIN)
        {
            fSts = CryptSetProvParam(
                    hProv,
                    PP_KEYEXCHANGE_PIN,
                    (LPBYTE)((LPCSTR)szPin),
                    0);
            if (!fSts)
            {
                lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
                goto ErrorExit;
            }
        }
    }

    //
    // OK, sign it with the exchange key from the smart card or the supplied signature key. ????
    //

    fSts = CryptSignHash(
                hHash,
                AT_KEYEXCHANGE,
                NULL,
                0,
                Signature,
                SignatureLength);
    if (!fSts)
    {
        if (GetLastError() == ERROR_MORE_DATA)
        {
            lResult = STATUS_BUFFER_TOO_SMALL;
        }
        else
        {
            lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        }
    }

    //
    // All done, clean up and return.
    //

ErrorExit:
        // Do this early so GetLastError is not clobbered
    if (!NT_SUCCESS(lResult))
    {
        lResult = LogEvent(
            lResult,
            (DWORD)((ARGUMENT_PRESENT(Provider))?EVENT_ID_SIGNMSG_NOSC:EVENT_ID_SIGNMSG)
            );
    }

    if (NULL != hHash)
    {
        CryptDestroyHash(hHash);
    }

    return lResult;
}


/*++

ScHelperVerifyMessage:

// ScHelperVerifyMessage() returns STATUS_SUCCESS if the signature provided is
// the hash of the buffer encrypted by the owner of the cert.

Arguments:

        pucPIN may need the PIN to get a cert off certain SCs

Return Value:

        "success" or "failure"

Author:

        Amanda Matlosz

Note:

        Used by LSA.

--*/
NTSTATUS WINAPI
ScHelperVerifyMessage(
    IN OPTIONAL PBYTE pbLogonInfo,
    IN OPTIONAL HCRYPTPROV Provider,
    IN PCCERT_CONTEXT CertificateContext,
    IN ULONG Algorithm,
    IN PBYTE Buffer,
    IN ULONG BufferLength,
    IN PBYTE Signature,
    IN ULONG SignatureLength
    )
{
    HCRYPTPROV hProv = NULL;
    HCRYPTKEY hKey = NULL;
    HCRYPTHASH hHash = NULL;
    PCERT_PUBLIC_KEY_INFO pInfo = NULL;
    BOOL fSts;
    NTSTATUS lResult = STATUS_SUCCESS;
    LogonInfo *pLI = (LogonInfo *)pbLogonInfo;


    //
    // Make sure we've got a Crypto Provider up and running.
    //

    if (ARGUMENT_PRESENT(Provider))
    {
        hProv = Provider;
    }
    else
    {
        CSCLogonInit * LogonInit = (CSCLogonInit *) pLI->ContextInformation;
        hProv = LogonInit->CryptCtx(pLI);
        if (NULL == hProv)
        {
            lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
            goto ErrorExit;
        }
    }

    //
    // Convert the certificate handle into a Public Key handle.
    //

    fSts = CryptImportPublicKeyInfo(
                hProv,
                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                &CertificateContext->pCertInfo->SubjectPublicKeyInfo,
                &hKey);
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }


    //
    // We'll need a hash handle, too.
    //

    fSts = CryptCreateHash(
                hProv,
                Algorithm,
                NULL, // HCRYPTKEY (used for keyed algs, like block ciphers
                0,  // reserved for future use
                &hHash);

    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }


    //
    // Hash the input data.
    //

    fSts = CryptHashData(
                hHash,
                Buffer,
                BufferLength,
                0);
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }


    //
    // So is this signature any good?
    //

    fSts = CryptVerifySignature(
                hHash,
                Signature,
                SignatureLength,
                hKey,
                NULL,
                0);
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }


    //
    // All done, clean up and return.
    //

ErrorExit:
        // Do this early so GetLastError is not clobbered
    if (!NT_SUCCESS(lResult))
    {
        lResult = LogEvent(
            lResult,
            (DWORD)((ARGUMENT_PRESENT(Provider))?EVENT_ID_VERIFYMSG_NOSC:EVENT_ID_VERIFYMSG)
            );
    }

    if (NULL != hHash)
    {
        CryptDestroyHash(hHash);
    }
    if (NULL != hKey)
    {
        CryptDestroyKey(hKey);
    }

    return lResult;
}

/*++

ScHelperSignPkcsMessage:

        ScHelperSignMessage() needs the logoninfo and PIN in order to find the card
        that will do the signing...

Arguments:

        pucPIN may need the PIN to get a cert off certain SCs

Return Value:

        "success" or "failure"

Author:

        Amanda Matlosz

Note:

        Used by LSA.

--*/
NTSTATUS WINAPI
ScHelperSignPkcsMessage(
    IN OPTIONAL PUNICODE_STRING pucPIN,
    IN OPTIONAL PBYTE pbLogonInfo,
    IN OPTIONAL HCRYPTPROV Provider,
    IN PCCERT_CONTEXT Certificate,
    IN PCRYPT_ALGORITHM_IDENTIFIER Algorithm,
    IN DWORD dwSignMessageFlags,
    IN PBYTE Buffer,
    IN ULONG BufferLength,
    OUT OPTIONAL PBYTE SignedBuffer,
    OUT OPTIONAL PULONG SignedBufferLength
    )
{
    NTSTATUS lResult = STATUS_SUCCESS;
    HCRYPTPROV hProv = NULL;
    BOOL fSts;
    LogonInfo *pLI = (LogonInfo *)pbLogonInfo;
    CRYPT_SIGN_MESSAGE_PARA Parameter = {0};
    CUnicodeString szPin(pucPIN);
    const BYTE * BufferArray = Buffer;

    if (NULL != pucPIN)
    {
        if (!szPin.Valid())
        {
            return(STATUS_INSUFFICIENT_RESOURCES);
        }
    }

    //
    // Make sure we've got a Crypto Provider up and running.
    //

    if (ARGUMENT_PRESENT(Provider))
    {
        hProv = Provider;
    }
    else
    {
        CSCLogonInit * LogonInit = (CSCLogonInit *) pLI->ContextInformation;
        hProv = LogonInit->CryptCtx(pLI);
        if (NULL == hProv)
        {
            lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
            goto ErrorExit;
        }

        //
        // Declare the PIN.
        //

        if (NULL != pucPIN)
        {
            fSts = CryptSetProvParam(
                    hProv,
                    PP_KEYEXCHANGE_PIN,
                    (LPBYTE)((LPCSTR)szPin),
                    0);
            if (!fSts)
            {
                lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
                goto ErrorExit;
            }
        }
    }


    //
    // Sign the message
    //

    Parameter.cbSize = sizeof(CRYPT_SIGN_MESSAGE_PARA);
    Parameter.dwMsgEncodingType = PKCS_7_ASN_ENCODING | X509_ASN_ENCODING;
    Parameter.pSigningCert = Certificate;
    Parameter.HashAlgorithm = *Algorithm;
    Parameter.cMsgCert = 1;
    Parameter.rgpMsgCert = &Certificate;
    Parameter.dwFlags = dwSignMessageFlags;


    fSts = CryptSignMessage(
            &Parameter,
            FALSE,              // no detached signature
            1,                  // one buffer to sign
            &BufferArray,
            &BufferLength,
            SignedBuffer,
            SignedBufferLength);

    if (!fSts)
    {
        switch (GetLastError())
        {
        case ERROR_MORE_DATA:
            lResult = STATUS_BUFFER_TOO_SMALL;
            break;
        case NTE_SILENT_CONTEXT:
            lResult = STATUS_SMARTCARD_SILENT_CONTEXT;
            break;
        default:
            lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        }

        goto ErrorExit;
    }


    //
    // All done, clean up and return.
    //

ErrorExit:

    if (!NT_SUCCESS(lResult))
    {
        lResult = LogEvent(lResult, (DWORD)EVENT_ID_SIGNMSG);
    }

    return lResult;
}


/*++

ScHelperVerifyPkcsMessage:

// ScHelperVerifyMessage() returns STATUS_SUCCESS if the signature provided is
// the hash of the buffer encrypted by the owner of the cert.

Arguments:

        pucPIN may need the PIN to get a cert off certain SCs

Return Value:

        "success" or "failure"

Author:

        Amanda Matlosz

Note:

        Used by LSA.

--*/
NTSTATUS WINAPI
ScHelperVerifyPkcsMessage(
    IN OPTIONAL PBYTE pbLogonInfo,
    IN OPTIONAL HCRYPTPROV Provider,
    IN PBYTE Buffer,
    IN ULONG BufferLength,
    OUT OPTIONAL PBYTE DecodedBuffer,
    OUT OPTIONAL PULONG DecodedBufferLength,
    OUT OPTIONAL PCCERT_CONTEXT * CertificateContext
    )
{
    CRYPT_VERIFY_MESSAGE_PARA Parameter = {0};
    BOOL fSts;
    NTSTATUS lResult = STATUS_SUCCESS;

    Parameter.cbSize = sizeof(CRYPT_VERIFY_MESSAGE_PARA);
    Parameter.dwMsgAndCertEncodingType = PKCS_7_ASN_ENCODING | X509_ASN_ENCODING;
    Parameter.hCryptProv = NULL;

    //
    // Indicate that we want to get the certificate from the message
    // cert store.
    //

    Parameter.pfnGetSignerCertificate = NULL;
    fSts = CryptVerifyMessageSignature(
                &Parameter,
                0,              // only check first signer
                Buffer,
                BufferLength,
                DecodedBuffer,
                DecodedBufferLength,
                CertificateContext
                );

    if (!fSts)
    {
        if (GetLastError() == ERROR_MORE_DATA)
        {
            lResult = STATUS_BUFFER_TOO_SMALL;
        }
        else
        {
            lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        }
        goto ErrorExit;
    }


    //
    // All done, clean up and return.
    //

ErrorExit:

    if (!NT_SUCCESS(lResult))
    {
        lResult = LogEvent(lResult, (DWORD)EVENT_ID_VERIFYMSG);

    }

    return lResult;
}

/*++

ScHelperEncryptMessage:

    Encrypts a message with the public key associated w/ the provided
        certificate.  The resultant encoding is PKCS-7 compliant.

Arguments:

        pucPIN may need the PIN to get a cert off certain SCs

Return Value:

        "success" or "failure"

Author:

    Amanda Matlosz (AMatlosz) 1-06-98

Note:

        Either pbLogonInfo or Provided must be set; if both are set,
        Provider is used.

        Algorithm expects a CRYPT_ALGORITHM_IDENTIFIER cai;
        If there are no parameters to the alg, cai.Parameters.cbData *must* be 0;

        CALG_RC4, no parameters:
                cai.pszObjId = szOID_RSA_RC4;
                cai.Parameters.cbData = 0;

        Used by LSA.

--*/
NTSTATUS WINAPI
ScHelperEncryptMessage(
    IN OPTIONAL PBYTE pbLogonInfo,
    IN OPTIONAL HCRYPTPROV Provider,
    IN PCCERT_CONTEXT CertificateContext,
    IN PCRYPT_ALGORITHM_IDENTIFIER Algorithm,
    IN PBYTE Buffer,                        // The data to encrypt
    IN ULONG BufferLength,                  // The length of that data
    OUT PBYTE CipherText,                   // Receives the formatted CipherText
    IN PULONG pCipherLength                 // Supplies size of CipherText buffer
    )                                       // Receives length of actual CipherText
{
    NTSTATUS lResult = STATUS_SUCCESS;
    HCRYPTPROV hProv = NULL;
    BOOL fSts;
    LogonInfo *pLI = (LogonInfo *)pbLogonInfo;
    CRYPT_ENCRYPT_MESSAGE_PARA EncryptPara;
    DWORD cbEncryptParaSize = 0;

    //
    // Make sure we've got a Crypto Provider up and running.
    //

    if (ARGUMENT_PRESENT(Provider))
    {
        hProv = Provider;
    }
    else
    {
        CSCLogonInit * LogonInit = (CSCLogonInit *) pLI->ContextInformation;
        hProv = LogonInit->CryptCtx(pLI);
        if (NULL == hProv)
        {
            lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
            goto ErrorExit;
        }
    }


    //
    // Encrypt the message
    //

    cbEncryptParaSize = sizeof(EncryptPara);
    memset(&EncryptPara, 0, cbEncryptParaSize);
    EncryptPara.cbSize = cbEncryptParaSize;
    EncryptPara.dwMsgEncodingType = PKCS_7_ASN_ENCODING | X509_ASN_ENCODING;
    EncryptPara.hCryptProv = hProv;
    EncryptPara.ContentEncryptionAlgorithm = *Algorithm;

    fSts = CryptEncryptMessage(
            &EncryptPara,
            1,
            &CertificateContext,
            Buffer,
            BufferLength,
            CipherText,
            pCipherLength);

    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

ErrorExit:

    if (!NT_SUCCESS(lResult))
    {
        lResult = LogEvent(
            lResult,
            (DWORD)((ARGUMENT_PRESENT(Provider))?EVENT_ID_ENCMSG_NOSC:EVENT_ID_ENCMSG)
            );
    }

    return lResult;
}


/*++

ScHelperDecryptMessage :

    Deciphers a PKCS-7 encoded message with the private key associated
        w/ the provided certificate.

Arguments:

        Either pbLogonInfo or Provider must be set; if both are set,
        Provider is used.


Return Value:

        "success" or "failure"

Author:

    Amanda Matlosz (AMatlosz) 1-06-98

Note:

        ** CertificateContext subtleties: **

        CryptDecryptMessage takes as a parameter a pointer to a certificate store;
        it will use the first appropriate certificate context it finds in that
        store to perform the decryption.  In order to make this call, we create a
        CertificateStore in memory, and add the provided CertificateContext to it.

        CertAddCertificateContextToStore actually places a copy of the certificate
        context in the store.  In so doing, it strips off any properties that are
        not permanent -- if a HCRYPTPROV is associated with the KeyContext of the
        source CertificateContext, it will NOT be associated with the KeyContext
        of the cert context in the store.

        Although this is appropriate behavior in most cases, we need that property
        to be kept intact when dealing with Smart Card CSPs (to avoid surprise
        "Insert PIN" dialogs), so after adding the CertificateContext to the store,
        we turn around and get the CERT_KEY_CONTEXT_PROP_ID from the source
        certcontext and (re)set it on the certcontext in the memory store.

        ** Algorithm notes: **

        Algorithm expects a CRYPT_ALGORITHM_IDENTIFIER cai;
        If there are no parameters to the alg, cai.Parameters.cbData *must* be 0;

        for example: CALG_RC4, no parameters:
                cai.pszObjId = szOID_RSA_RC4;
                cai.Parameters.cbData = 0;

        Used by LSA.

--*/
NTSTATUS WINAPI
ScHelperDecryptMessage(
    IN PUNICODE_STRING pucPIN,
    IN OPTIONAL PBYTE pbLogonInfo,
    IN OPTIONAL HCRYPTPROV Provider,
    IN PCCERT_CONTEXT CertificateContext,
    IN PBYTE CipherText,        // Supplies formatted CipherText
    IN ULONG CipherLength,      // Supplies the length of the CiperText
    OUT PBYTE ClearText,        // Receives decrypted message
    IN OUT PULONG pClearLength  // Supplies length of buffer, receives actual length
    )
{
    NTSTATUS lResult = STATUS_SUCCESS;
    HCRYPTPROV hProv = NULL;
    PCCERT_CONTEXT pStoreCertContext = NULL;
    HCERTSTORE hCertStore = NULL;
    LogonInfo *pLI = (LogonInfo *)pbLogonInfo;
    CUnicodeString szPin(pucPIN);
    CERT_KEY_CONTEXT CertKeyContext;
    DWORD cbData = sizeof(CERT_KEY_CONTEXT); // PhilH swears this will not grow!
    BOOL fSts;

    //
    // Make sure we've got a Crypto Provider up and running.
    //

    if (ARGUMENT_PRESENT(Provider))
    {
        hProv = Provider;
    }
    else
    {
        if (NULL != pucPIN)
        {
            if (!szPin.Valid())
            {
                return(STATUS_INSUFFICIENT_RESOURCES);
            }
        }


        CSCLogonInit * LogonInit = (CSCLogonInit *) pLI->ContextInformation;
        hProv = LogonInit->CryptCtx(pLI);
        if (NULL == hProv)
        {
            lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
            goto ErrorExit;
        }

        //
        // Declare the PIN.
        //

        if (NULL != pucPIN )
        {
            fSts = CryptSetProvParam(
                    hProv,
                    PP_KEYEXCHANGE_PIN,
                    (LPBYTE)((LPCSTR)szPin),
                    0);
            if (!fSts)
            {
                lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
                goto ErrorExit;
            }
        }
    }

    //
    // Open a temporary certstore to hold this certcontext
    //

    hCertStore = CertOpenStore(
                            CERT_STORE_PROV_MEMORY,
                            0, // not applicable
                            hProv,
                            CERT_STORE_NO_CRYPT_RELEASE_FLAG, // auto-release hProv NOT OK
                            NULL);

    if (NULL == hCertStore)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

    fSts = CertAddCertificateContextToStore(
            hCertStore,
            CertificateContext,
            CERT_STORE_ADD_ALWAYS,
            &pStoreCertContext);

    //
    // NOW WE NEED TO RESET THE KEY CONTEXT PROPERTY ON THIS CERTCONTEXT
        // IN THE MEMORY STORE (see function header/notes) AS APPROPRIATE
        //
        // ie, IFF the certcontext we were give has the key_context property,
        // reset it (and fail if the resetting doesn't work)
        //
    fSts = CertGetCertificateContextProperty(
                CertificateContext,
                CERT_KEY_CONTEXT_PROP_ID,
                (void *)&CertKeyContext,
                &cbData);

        if (TRUE == fSts)
        {
                fSts = CertSetCertificateContextProperty(
                                        pStoreCertContext,
                                        CERT_KEY_CONTEXT_PROP_ID,
                                        CERT_STORE_NO_CRYPT_RELEASE_FLAG, // no auto-release hProv!
                                        (void *)&CertKeyContext);

                if (!fSts)
                {
                        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
                        goto ErrorExit;
                }
        }

    //
    // Decrypt the message
    //

    CRYPT_DECRYPT_MESSAGE_PARA DecryptPara;
    DecryptPara.cbSize = sizeof(DecryptPara);
    DecryptPara.dwMsgAndCertEncodingType = X509_ASN_ENCODING | PKCS_7_ASN_ENCODING;
    DecryptPara.cCertStore = 1;
    DecryptPara.rghCertStore = &hCertStore;

    fSts = CryptDecryptMessage(
            &DecryptPara,
            CipherText,
            CipherLength,
            ClearText,
            pClearLength,
            NULL);

    if (!fSts)
    {
        if (GetLastError() == ERROR_MORE_DATA)
        {
            lResult = STATUS_BUFFER_TOO_SMALL;
        }
        else
        {
            lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        }
        goto ErrorExit;
    }

ErrorExit:

        // Do this early so GetLastError is not clobbered
    if (!NT_SUCCESS(lResult))
    {
        lResult = LogEvent(
            lResult,
            (DWORD)((ARGUMENT_PRESENT(Provider))?EVENT_ID_DECMSG_NOSC:EVENT_ID_DECMSG)
            );
    }

    if (hCertStore != NULL)
    {
        fSts = CertCloseStore(hCertStore, CERT_CLOSE_STORE_FORCE_FLAG);
        if (!fSts)
        {
            if (!NT_SUCCESS(lResult))
                lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        }
    }

    return lResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\sclogon\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_sclogon_none_12.4.56.0_none_ee20bfa619ac5a87
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_sclogon_no-public-key_12.4.56.0_x-ww_c8549749
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=sclogon
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_sclogon_no-public-key_12.4.56.0_x-ww_c8549749
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_sclogon_no-public-key_12.4.56.0_x-ww_c8549749.manifest
XP_MANIFEST_PATH=manifests\x86_sclogon_no-public-key_12.4.56.0_x-ww_c8549749.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_sclogon_no-public-key_12.4.56.0_x-ww_c8549749.cat
XP_CATALOG_PATH=manifests\x86_sclogon_no-public-key_12.4.56.0_x-ww_c8549749.cat
XP_PAYLOAD_PATH=x86_sclogon_no-public-key_12.4.56.0_x-ww_c8549749
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=sclogon,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\sclogon\obj\i386\sclmsg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       sclmsg.mc
//
//--------------------------------------------------------------------------
// scl.mc
//
//   Event messages for the Smart Card Resource Manager
//
//   03-11-98 - AMatlosz Created.
//
// ==============
// Event Messages
// ==============
//
//
// SCLogon stuff...
//
//
//  Values are 32 bit values laid out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#define FACILITY_SYSTEM                  0x0
#define FACILITY_SMARTCARD               0x1


//
// Define the severity codes
//


//
// MessageId: EVENT_ID_SCINSERT
//
// MessageText:
//
// An error occurred on smart card insertion: %1
//
#define EVENT_ID_SCINSERT                0x00000001L

//
// MessageId: EVENT_ID_SCREM
//
// MessageText:
//
// An error occurred on smart card removal: %1
//
#define EVENT_ID_SCREM                   0x00000002L

//
// MessageId: EVENT_ID_WATCHSAS
//
// MessageText:
//
// An error occurred while watching for smart card SAS events: %1
//
#define EVENT_ID_WATCHSAS                0x00000003L

//
// MessageId: EVENT_ID_WATCHREM
//
// MessageText:
//
// An error occurred while watching for smart card removal events: %1
//
#define EVENT_ID_WATCHREM                0x00000004L

//
// MessageId: EVENT_ID_GETCERT
//
// MessageText:
//
// An error occurred while retrieving a digital certificate from the inserted smart card. %1
//
#define EVENT_ID_GETCERT                 0x00010005L

//
// MessageId: EVENT_ID_VERIFYCARD
//
// MessageText:
//
// An error occurred in while attempting to verify the inserted smart card: %1
//
#define EVENT_ID_VERIFYCARD              0x00010006L

//
// MessageId: EVENT_ID_SIGNMSG
//
// MessageText:
//
// An error occurred while signing a message using the inserted smart card: %1
//
#define EVENT_ID_SIGNMSG                 0x00010007L

//
// MessageId: EVENT_ID_VERIFYMSG
//
// MessageText:
//
// An error occurred while verifying a signed message using the inserted smart card: %1
//
#define EVENT_ID_VERIFYMSG               0x00010008L

//
// MessageId: EVENT_ID_VERIFYCERT
//
// MessageText:
//
// An error occurred while verifying the digital certificate retrieved from the inserted smart card: %1
//
#define EVENT_ID_VERIFYCERT              0x00010009L

//
// MessageId: EVENT_ID_ENCMSG
//
// MessageText:
//
// An error occurred while encrypting a message using the inserted smart card: %1
//
#define EVENT_ID_ENCMSG                  0x0001000AL

//
// MessageId: EVENT_ID_DECMSG
//
// MessageText:
//
// An error occurred while decrypting a message using the inserted smart card: %1
//
#define EVENT_ID_DECMSG                  0x0001000BL

//
// MessageId: EVENT_ID_BUILDCC
//
// MessageText:
//
// An error occurred while building a certificate context: %1
//
#define EVENT_ID_BUILDCC                 0x0001000CL

//
// MessageId: EVENT_ID_INITIALIZE
//
// MessageText:
//
// An error occurred while initializing the smart card logon library: %1
//
#define EVENT_ID_INITIALIZE              0x0000000DL

//
// MessageId: EVENT_ID_SIGNMSG_NOSC
//
// MessageText:
//
// An error occurred while signing a message: %1
//
#define EVENT_ID_SIGNMSG_NOSC            0x0001000EL

//
// MessageId: EVENT_ID_VERIFYMSG_NOSC
//
// MessageText:
//
// An error occurred while verifying a signed message: %1
//
#define EVENT_ID_VERIFYMSG_NOSC          0x0001000FL

//
// MessageId: EVENT_ID_ENCMSG_NOSC
//
// MessageText:
//
// An error occurred while encrypting a message: %1
//
#define EVENT_ID_ENCMSG_NOSC             0x00010010L

//
// MessageId: EVENT_ID_DECMSG_NOSC
//
// MessageText:
//
// An error occurred while decrypting a message: %1
//
#define EVENT_ID_DECMSG_NOSC             0x00010011L

//
// MessageId: EVENT_ID_GETPROVPARAM
//
// MessageText:
//
// An error occurred while getting some provider parameter: %1
//
#define EVENT_ID_GETPROVPARAM            0x00010012L

//
// MessageId: EVENT_ID_GENRANDBITS
//
// MessageText:
//
// An error occurred while generating a random number: %1
//
#define EVENT_ID_GENRANDBITS             0x00010013L
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\sclogon\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_sclogon_none_12.4.56.0_none_ee20bfa619ac5a87
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_sclogon_no-public-key_12.4.56.0_x-ww_c8549749
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=sclogon
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_sclogon_no-public-key_12.4.56.0_x-ww_c8549749
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_sclogon_no-public-key_12.4.56.0_x-ww_c8549749.manifest
XP_MANIFEST_PATH=manifests\x86_sclogon_no-public-key_12.4.56.0_x-ww_c8549749.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_sclogon_no-public-key_12.4.56.0_x-ww_c8549749.cat
XP_CATALOG_PATH=manifests\x86_sclogon_no-public-key_12.4.56.0_x-ww_c8549749.cat
XP_PAYLOAD_PATH=x86_sclogon_no-public-key_12.4.56.0_x-ww_c8549749
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=sclogon,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\sclogon\unicodes.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    unicodes

Abstract:

    This header file describes the CUnicodeString class, useful for converting
    string types.

Author:

    Doug Barlow (dbarlow) 11/6/1997

Environment:

    Win32, C++

Notes:

    ?Notes?

--*/

#ifndef _UNICODES_H_
#define _UNICODES_H_

//
//==============================================================================
//
//  CUnicodeString
//

class CUnicodeString
{
public:

    //  Constructors & Destructor
    CUnicodeString(void);
    CUnicodeString(LPCSTR sz);
    CUnicodeString(LPCWSTR wsz);
    CUnicodeString(PUNICODE_STRING pus);
    ~CUnicodeString();

    //  Properties
    //  Methods
    LPCSTR  Set(LPCSTR sz);
    LPCWSTR Set(LPCWSTR wsz);
    PUNICODE_STRING Set(PUNICODE_STRING pus);
    BOOL Valid(void)
    {
        if (m_fFlags == fNoneGood)
        {
            return(FALSE);
        }
        else
        {
            return(TRUE);
        }
    }

    //  Operators
    LPCSTR operator=(LPCSTR sz)
    { return Set(sz); };
    LPCWSTR operator=(LPCWSTR wsz)
    { return Set(wsz); };
    PUNICODE_STRING operator=(PUNICODE_STRING pus)
    { return Set(pus);};
    operator LPCSTR(void)
    { return Ansi(); };
    operator LPCWSTR(void)
    { return Unicode(); };
    operator PUNICODE_STRING(void);

protected:
    //  Properties
    UNICODE_STRING m_us;
    LPSTR m_szAnsi;
    LPWSTR m_wszUnicode;
    enum {
        fNoneGood = 0,
        fAnsiGood = 1,
        fUnicodeGood = 2,
        fBothGood = 3
    } m_fFlags;

    //  Methods
    LPCWSTR Unicode(void);      // Return the text as a Unicode string.
    LPCSTR Ansi(void);          // Return the text as an Ansi string.
};

#endif // _UNICODES_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\sclogon\objd\i386\sclmsg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       sclmsg.mc
//
//--------------------------------------------------------------------------
// scl.mc
//
//   Event messages for the Smart Card Resource Manager
//
//   03-11-98 - AMatlosz Created.
//
// ==============
// Event Messages
// ==============
//
//
// SCLogon stuff...
//
//
//  Values are 32 bit values laid out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#define FACILITY_SYSTEM                  0x0
#define FACILITY_SMARTCARD               0x1


//
// Define the severity codes
//


//
// MessageId: EVENT_ID_SCINSERT
//
// MessageText:
//
// An error occurred on smart card insertion: %1
//
#define EVENT_ID_SCINSERT                0x00000001L

//
// MessageId: EVENT_ID_SCREM
//
// MessageText:
//
// An error occurred on smart card removal: %1
//
#define EVENT_ID_SCREM                   0x00000002L

//
// MessageId: EVENT_ID_WATCHSAS
//
// MessageText:
//
// An error occurred while watching for smart card SAS events: %1
//
#define EVENT_ID_WATCHSAS                0x00000003L

//
// MessageId: EVENT_ID_WATCHREM
//
// MessageText:
//
// An error occurred while watching for smart card removal events: %1
//
#define EVENT_ID_WATCHREM                0x00000004L

//
// MessageId: EVENT_ID_GETCERT
//
// MessageText:
//
// An error occurred while retrieving a digital certificate from the inserted smart card. %1
//
#define EVENT_ID_GETCERT                 0x00010005L

//
// MessageId: EVENT_ID_VERIFYCARD
//
// MessageText:
//
// An error occurred in while attempting to verify the inserted smart card: %1
//
#define EVENT_ID_VERIFYCARD              0x00010006L

//
// MessageId: EVENT_ID_SIGNMSG
//
// MessageText:
//
// An error occurred while signing a message using the inserted smart card: %1
//
#define EVENT_ID_SIGNMSG                 0x00010007L

//
// MessageId: EVENT_ID_VERIFYMSG
//
// MessageText:
//
// An error occurred while verifying a signed message using the inserted smart card: %1
//
#define EVENT_ID_VERIFYMSG               0x00010008L

//
// MessageId: EVENT_ID_VERIFYCERT
//
// MessageText:
//
// An error occurred while verifying the digital certificate retrieved from the inserted smart card: %1
//
#define EVENT_ID_VERIFYCERT              0x00010009L

//
// MessageId: EVENT_ID_ENCMSG
//
// MessageText:
//
// An error occurred while encrypting a message using the inserted smart card: %1
//
#define EVENT_ID_ENCMSG                  0x0001000AL

//
// MessageId: EVENT_ID_DECMSG
//
// MessageText:
//
// An error occurred while decrypting a message using the inserted smart card: %1
//
#define EVENT_ID_DECMSG                  0x0001000BL

//
// MessageId: EVENT_ID_BUILDCC
//
// MessageText:
//
// An error occurred while building a certificate context: %1
//
#define EVENT_ID_BUILDCC                 0x0001000CL

//
// MessageId: EVENT_ID_INITIALIZE
//
// MessageText:
//
// An error occurred while initializing the smart card logon library: %1
//
#define EVENT_ID_INITIALIZE              0x0000000DL

//
// MessageId: EVENT_ID_SIGNMSG_NOSC
//
// MessageText:
//
// An error occurred while signing a message: %1
//
#define EVENT_ID_SIGNMSG_NOSC            0x0001000EL

//
// MessageId: EVENT_ID_VERIFYMSG_NOSC
//
// MessageText:
//
// An error occurred while verifying a signed message: %1
//
#define EVENT_ID_VERIFYMSG_NOSC          0x0001000FL

//
// MessageId: EVENT_ID_ENCMSG_NOSC
//
// MessageText:
//
// An error occurred while encrypting a message: %1
//
#define EVENT_ID_ENCMSG_NOSC             0x00010010L

//
// MessageId: EVENT_ID_DECMSG_NOSC
//
// MessageText:
//
// An error occurred while decrypting a message: %1
//
#define EVENT_ID_DECMSG_NOSC             0x00010011L

//
// MessageId: EVENT_ID_GETPROVPARAM
//
// MessageText:
//
// An error occurred while getting some provider parameter: %1
//
#define EVENT_ID_GETPROVPARAM            0x00010012L

//
// MessageId: EVENT_ID_GENRANDBITS
//
// MessageText:
//
// An error occurred while generating a random number: %1
//
#define EVENT_ID_GENRANDBITS             0x00010013L
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\server\authdata.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001
//
//  File:       authdata.cxx
//
//  Contents:   KDC Internal Authdata types
//
//  Classes:
//
//  Functions:
//
//  History:    19-July-2001    JBrezak
//              16-Sept-2001    Updated for the new interface
//
//----------------------------------------------------------------------------

#include "kdcsvr.hxx"

#include "fileno.h"
#define FILENO FILENO_GETAS
#define KDC_PAC_CHECKSUM        KERB_CHECKSUM_HMAC_MD5


//
// Authdata handler for Win2000 PAC
//

class CADWin2000PAC : public IADHandler, public IADPacSection
{
public:
    CADWin2000PAC() : m_pPacAuth(NULL),
                      m_piPacReq(NULL),
                      m_piCrypt(NULL)
    {
        //  get crypt interface here ....
        //  this can never be NULL
        m_piCrypt = KdcGetICrypt();
    }
    //  cleanup state
    ~CADWin2000PAC()
    {
        MIDL_user_free(m_pPacAuth);
    }
    //  IADHandler implementation
    virtual KERBERR __stdcall Check(
        IN  IKerbRequest    *pIKerbRequest,
        // Tgt server principal.
        IN  IKerbPrincipal  *piTgt,
        IN  PKERB_AUTHORIZATION_DATA pAuthData,
        OUT PKERB_EXT_ERROR pExtendedError);

    virtual KERBERR __stdcall AddToTicket(
        IN  IKerbRequest                *pIKerbRequest,
        OUT PKERB_AUTHORIZATION_DATA    *ppAuthData,
        OUT PKERB_EXT_ERROR pExtendedError);
    virtual ULONG   __stdcall GetADType()
    {
        return  KERB_AUTH_DATA_PAC;
    }
    //  no ref counting. caller is done
    virtual void Release(void)
    {
        delete  this;
    }
    //
    //  support interface returnin raw PAC sections
    //
    virtual HRESULT __stdcall QueryInterface(REFIID intf, PVOID *ppv)
    {
        if (IsEqualGUID(intf, IID_IADPacSection))
        {
            *ppv = (PVOID*)((IADPacSection*)this);
            return  S_OK;
        }
        return  E_NOINTERFACE;
    }

    //  IADPacSection impl
    NTSTATUS __stdcall GetPacSection(ULONG ulPacSection,
                                     const PAC_INFO_BUFFER **pBuf);

private:
    //  keep Pac that came with request
    PPACTYPE m_pPacAuth;
    //  interface for requested PAC sections
    IPAPacReqEx *m_piPacReq;
    //  crypt interface used
    PIKerbCrypt m_piCrypt;

    //  private handler methods
    KERBERR
    KdcVerifyPacSignature(
        IN IKerbRequest   *pReq,
        IN PIKerbPrincipal TgtInfo,
        IN ULONG PacSize,
        IN PUCHAR PacData,
        OUT PKERB_EXT_ERROR pExtendedError
        );
    KERBERR
    KdcSupplyPacAuthData(IN PIKerbRequest piReq,
                         IN PIKerbPrincipal piUser,
                         IN PIKerbPrincipal piTgt,
                         IN PKERB_AUTHORIZATION_DATA OrgIfRelevant,
                         OUT PKERB_AUTHORIZATION_DATA * ppAuthData,
                         OUT PKERB_EXT_ERROR pExtendedError);
    KERBERR
    KdcBuildPac(IN PIKerbRequest   piReq,
                IN PIKerbPrincipal UserInfo,
                IN BOOLEAN IsUpdate,
                IN ULONG SignatureSize,
                OUT PPACTYPE *Pac,
                OUT NTSTATUS *pStatus);
    KERBERR
    GetPacInfo(IN PIKerbRequest            piReq,
               IN PIKerbPrincipal          User,
               IN BOOLEAN                  IsUpdate,
               OUT PPAC_INFO_BUFFER        *pPacData,
               OUT PNTSTATUS                pStatus,
               IN PIPACHandler              piHandler);

};

//
//  Local helpers
//
KERBERR
KdcInsertPacIntoAuthData(
    IN PKERB_AUTHORIZATION_DATA OrgIfRelevant,
    IN PKERB_AUTHORIZATION_DATA PacAuthData,
    IN OUT PKERB_AUTHORIZATION_DATA * UpdatedAuthData
    );
KERBERR
KerbRemovePacFromAuthData(
    IN OUT PKERB_AUTHORIZATION_DATA *AuthData,
    OUT    PKERB_AUTHORIZATION_DATA *IfRelevantReturn
    );
KERBERR
KdcSignPac(
    IN PIKerbRequest piReq,
    IN PIKerbPrincipal piUser,
    IN OPTIONAL PIKerbPrincipal piServ,
    IN OUT PUCHAR *PacData,
    IN OUT PULONG PacSize,
    OUT PKERB_EXT_ERROR pExtendedError
    );

KERBERR
KdcCheckAuthData(
    IN PIKerbPrincipal          TgtInfo,
    IN CKerbRequest             *pReq,
    IN PKERB_AUTHORIZATION_DATA AuthData,
    OUT PKERB_EXT_ERROR pExtendedError
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    TRACER(L"KdcCheckAuthData", (PVOID *) &KerbErr);
    IADHandler **ppiAD = pReq->m_ppiADHandlers;
    ULONG cHandlers = KdcADHandlerFactoryList.cElem;

    while(cHandlers-- && *ppiAD)
    {
        //  all handlers perform the check on all auth data
        //  it is up to the handler to locate their auth data
        KerbErr = (*ppiAD)->Check(
                      pReq,
                      TgtInfo,
                      AuthData,
                      pExtendedError
                      );

        if (!KERB_SUCCESS(KerbErr))
        {
            break;
        }
        ppiAD++;
    }

    return(KerbErr);
}



KERBERR
KdcReturnAuthData(
    IN CKerbRequest              *pReq,
    OUT PKERB_AUTHORIZATION_DATA *AuthData,
    OUT PKERB_EXT_ERROR pExtendedError
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    IADHandler **ppiAD = pReq->m_ppiADHandlers;
    ULONG cHandlers = KdcADHandlerFactoryList.cElem;

    TRACER(L"KdcReturnAuthData", (PVOID *) &KerbErr);

    while(cHandlers-- && *ppiAD)
    {
        //  all handlers perform the check on all auth data
        //  it is up to the handler to locate their auth data
        KerbErr = (*ppiAD)->AddToTicket(
                      pReq,
                      AuthData,
                      pExtendedError
                      );
        if (!KERB_SUCCESS(KerbErr))
        {
            break;
        }
        ppiAD++;
    }

    return(KerbErr);
}


//
//  AD factory
//
class CADWin2000PACFactory : public IADHandlerFactory
{
public:
    virtual NTSTATUS __stdcall CreateInstance(
        IN  IKerbRequest    *pIKerbRequest,
        OUT IADHandler     **ppIADHandler)
    {
        //  new and release can be used since these are local allocs
        *ppIADHandler = new CADWin2000PAC;
        if (*ppIADHandler == NULL)
            return  STATUS_NO_MEMORY;
        //  any initialization ???

        return  STATUS_SUCCESS;
    }

}g_ADW2KFactory;

NTSTATUS
KdcInitializeInternalADHandlers(
    VOID
    )
{

    return KdcRegisterADHandlerFactory(&g_ADW2KFactory);
}

//
//  auth data handlers
//
//
//  check auth data
//
KERBERR __stdcall CADWin2000PAC::Check(
        PIKerbRequest       pReq,
        // Tgt server principal.
        IN  IKerbPrincipal  *piTgt,
        IN  PKERB_AUTHORIZATION_DATA pAuthData,
        OUT PKERB_EXT_ERROR pExtendedError)
{
    KERBERR KerbErr = KDC_ERR_NONE;
    TRACER(L"CADWin2000PAC::Check", (PVOID *) &KerbErr);
    const KERB_AUTHORIZATION_DATA * PacAuthData = NULL;
    PKERB_IF_RELEVANT_AUTH_DATA * IfRelevantData = NULL;

    //  get PAC request interface
    NTSTATUS Status = pReq->GetPAHandler(IID_IPAPacReqEx, (PVOID*)&m_piPacReq);
    if (!NT_SUCCESS(Status))
    {
        //  BUGBUG todo: log/trace. This should not happen ever!
        DsysAssert(FALSE);
        return  KRB_ERR_GENERIC;
    }

    //
    // Locate the PAC in the authdata and retrieve useful context
    //
    if (pAuthData != NULL)
    {

        //
        // Get the PAC from the source ticket's authdata
        //

        KerbErr = KerbGetPacFromAuthData(
                     pAuthData,
                     &IfRelevantData,
                     &PacAuthData
                     );

        if (!KERB_SUCCESS(KerbErr) || PacAuthData == NULL)
        {
            DebugLog((DEB_ERROR,"KLIN(%x) Failed to extract pac from auth data: 0x%x\n",
                      KLIN(FILENO, __LINE__),
                      KerbErr));
            goto Cleanup;
        }
        //
        //  Now verify the existing signature
        //  with Tgt key
        //
        KerbErr = KdcVerifyPacSignature(
                     pReq,
                     piTgt,
                     PacAuthData->value.auth_data.length,
                     PacAuthData->value.auth_data.value,
                     pExtendedError
                     );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }


#if 0
        //
        // Perform SID filtering if necessary
        //
        KerbErr = KdcCheckPacForSidFiltering(
                     OldServerInfo,
                     &PacAuthData->value.auth_data.value,
                     (PULONG) &PacAuthData->value.auth_data.length
                     );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }
#endif
        //
        //  delete any previous state
        //
        if (m_pPacAuth)
        {
            MIDL_user_free(m_pPacAuth);
            m_pPacAuth = NULL;
        }

        //
        // Save the PAC sections
        //
        m_pPacAuth = (PPACTYPE) MIDL_user_allocate
            (PacAuthData->value.auth_data.length);
        if (m_pPacAuth == NULL)
        {
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }


        memcpy(
            m_pPacAuth,
            PacAuthData->value.auth_data.value,
            PacAuthData->value.auth_data.length
            );


        if (PAC_UnMarshal(
                m_pPacAuth,
                PacAuthData->value.auth_data.length
            ) == 0)
        {
            D_DebugLog((DEB_ERROR,"Failed to unmarshal pac\n"));
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }
        D_DebugLog((DEB_TRACE, "Got pac from auth data\n"));



    }


Cleanup:
    if (IfRelevantData)
    {
        KerbFreeData(PKERB_IF_RELEVANT_AUTH_DATA_PDU,
                     IfRelevantData);
    }

    return(KerbErr);
}

//+-------------------------------------------------------------------------
//
//  Function:   KdcVerifyPacSignature
//
//  Synopsis:   Verifies a PAC by checksumming it and comparing the result
//              with the server checksum. In addition, if the pac wasn't
//              created by another realm (server ticket info is not
//              an interdomain account) verify the KDC signature on the
//              pac.
//
//  Effects:
//
//  Arguments:  ServerInfo - Ticket info for the server, used
//                      for the initial signature
//              Pac - An unmarshalled PAC.
//
//  Requires:
//
//  Returns:
//
//  Notes:      ServerInfo contains the TGT. The code checks the name is indeed
//              krbtgt.
//              Note that the server signature and the KDC signature are the same
//              only server signature is checked.
//
//
//--------------------------------------------------------------------------

KERBERR
CADWin2000PAC::KdcVerifyPacSignature(
    IN IKerbRequest   *pReq,
    IN PIKerbPrincipal TgtInfo,
    IN ULONG PacSize,
    IN PUCHAR PacData,
    OUT PKERB_EXT_ERROR pExtendedError
    )
{
    NTSTATUS Status;
    KERBERR KerbErr = KDC_ERR_NONE;
    TRACER(L"CADWin2000PAC::KdcVerifyPacSignature", (PVOID *) &KerbErr);
    PPAC_INFO_BUFFER PrivSvrBuffer;
    PPAC_SIGNATURE_DATA PrivSvrSignature;
    UCHAR LocalPrivSvrChecksum[20];
    PPACTYPE Pac;
    BOOLEAN fVerified = FALSE;

    TRACE(KDC, KdcVerifyPacSignature, DEB_FUNCTION);

    //
    //  only tgt accepted
    //
    if (!KdcIsKrbtgt(TgtInfo->GetName()))
    {
        KerbErr = KDC_ERR_SERVER_NOMATCH;
        goto Cleanup;
    }

    Pac = (PPACTYPE) PacData;

    if (PAC_UnMarshal(Pac, PacSize) == 0)
    {
        D_DebugLog((DEB_ERROR,"Failed to unmarshal pac\n"));
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }


    //
    // Locate server signature, copy the checksum, and zero the value
    // so the checksum won't include the old checksums.
    //
    PrivSvrBuffer = PAC_Find(Pac, PAC_PRIVSVR_CHECKSUM, NULL );
    if ((PrivSvrBuffer == NULL) || (PrivSvrBuffer->cbBufferSize < PAC_SIGNATURE_SIZE(0)))
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    PrivSvrSignature = (PPAC_SIGNATURE_DATA) PrivSvrBuffer->Data;

    if (sizeof(LocalPrivSvrChecksum) < PAC_CHECKSUM_SIZE(PrivSvrBuffer->cbBufferSize))
    {
        //  pretty unlikely but just in case ...
        DsysAssert(FALSE);
        KerbErr = KRB_ERR_GENERIC;
        goto    Cleanup;
    }
    memcpy(
        LocalPrivSvrChecksum,
        PrivSvrSignature->Signature,
        PAC_CHECKSUM_SIZE(PrivSvrBuffer->cbBufferSize)
        );

    ZeroMemory(
        PrivSvrSignature->Signature,
        PAC_CHECKSUM_SIZE(PrivSvrBuffer->cbBufferSize)
        );

    //
    // Remarshal the pac so we can checksum it.
    //

    if (!PAC_ReMarshal(Pac, PacSize))
    {
        DsysAssert(!"PAC_Remarshal Failed");
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    //
    // Now compute the signatures on the PAC. First we compute the checksum
    // of the validation information using the tgt's key.
    //
    Status = TgtInfo->Checksum(PrivSvrSignature->SignatureType,
                              KERB_NON_KERB_CKSUM_SALT,
                              pReq->GetEncryptionTypes(),
                              &PacData,
                              &PacSize,
                              1,
                              //    chksum buffer to verify against
                              PrivSvrSignature->Signature,
                              PAC_CHECKSUM_SIZE(PrivSvrBuffer->cbBufferSize),
                              NULL, // don't need the actual chksum
                              NULL,
                              &fVerified,
                              pExtendedError);
    // @@@ uhh, if you really want to verify the checksum, !fVerified would be a good 
    // thing to check. Not doing that now as it breaks the STF tests.
    if (!NT_SUCCESS(Status))
    {
        //  checksumming failed
        if (Status == STATUS_NOT_FOUND)
        {
            KerbErr = KDC_ERR_ETYPE_NOTSUPP;
        }
        else
        {
            //  should we check for a specific errcode here?
            DebugLog((DEB_ERROR, "Pac was modified - server checksum doesn't match\n"));
            KerbErr = KRB_AP_ERR_MODIFIED;
        }
    }


Cleanup:

    if (KerbErr == KRB_AP_ERR_MODIFIED)
    {
        UNICODE_STRING AccountString = {0};
        LPWSTR AccountName = NULL;

        //
        // if the allocation fails don't log the name (leave it NULL)
        //

        if (KERB_SUCCESS(KerbConvertKdcNameToString(
                             &AccountString,
                             TgtInfo->GetName(),
                             TgtInfo->GetRealm())))
        {
            AccountName = (LPWSTR) MIDL_user_allocate(AccountString.Length + sizeof(WCHAR));

            if (NULL != AccountName)
            {
                memcpy(
                    AccountName,
                    AccountString.Buffer,
                    AccountString.Length
                    );
                AccountName[AccountString.Length - 1] = L'\0';
            }
        }

        KdbReportEventW(
            IEvent::ERROR_TYPE,
            KDCEVENT_PAC_VERIFICATION_FAILURE,
            sizeof(ULONG),
            &KerbErr,
            1,
            AccountName == NULL ? L"Failed allocation" : AccountName
            );

        if (NULL != AccountName)
        {
            MIDL_user_free(AccountName);
        }
        KerbFreeString(&AccountString);
    }



    return(KerbErr);
}

//
//  add auth data
//
KERBERR __stdcall CADWin2000PAC::AddToTicket(
        IN  IKerbRequest                *piReq,
        IN OUT PKERB_AUTHORIZATION_DATA    *ppAuthData,
        OUT PKERB_EXT_ERROR pExtendedError)
{
    KERBERR KerbErr = KDC_ERR_NONE;
    PKERB_AUTHORIZATION_DATA    OrgIfRelevant = NULL;
    PIKerbPrincipal piUser = NULL;

    TRACER(L"CADWin2000PAC::AddToTicket", (PVOID *) &KerbErr);

    //
    // Build a PAC -    AS: if preauthenticated and DontIncludePac
    //                  TGS: if present on input and not DontIncludePac or
    //                       not present and there is a client name mapping
    //                       in cname of request.
    //
    if (!m_piPacReq)
    {
        //
        //  get PAC request interface
        //
        NTSTATUS Status = piReq->GetPAHandler(IID_IPAPacReqEx, (PVOID*)&m_piPacReq);
        if (!NT_SUCCESS(Status))
        {
            //  BUGBUG todo: log/trace. This should not happen ever!
            TRACE_FILELINE(TRACE_VERB,
                    (FILE_AND_LINE, L"Failed to get PAHandler: 0x%x", Status));
            DsysAssert(FALSE);
            return  KRB_ERR_GENERIC;
        }
    }

    if(piReq->GetServId() == KerbTgs)
    {
        //  remove PAC from the output data
        KerbErr = KerbRemovePacFromAuthData(ppAuthData, &OrgIfRelevant);
    }

    if (!m_piPacReq->IsPacRequested())
    {
        return  KDC_ERR_NONE;
    }

    // Check with the principal to see if we should return a PAC
    piUser = piReq->GetIPrincClient();
    if (piUser != NULL && piUser->IsPacRequested() == FALSE) 
    {
        return  KDC_ERR_NONE;
    }

    KerbErr = KdcSupplyPacAuthData(
                 piReq,
                 piUser,
                 piReq->GetIPrincService(),
                 OrgIfRelevant,
                 ppAuthData,
                 pExtendedError
                 );

    if (!KERB_SUCCESS(KerbErr))
    {
        TRACE_FILELINE(TRACE_VERB,
                    (FILE_AND_LINE, L"Failed to get packauth data: 0x%x", KerbErr));
        D_DebugLog((DEB_ERROR,"KLIN(%x) Failed to get pac auth data : 0x%x\n",
                    KLIN(FILENO,__LINE__), KerbErr));
        goto Cleanup;
    }

Cleanup:
    KerbFreeAuthData(OrgIfRelevant);

    return KerbErr;
}


//+---------------------------------------------------------------------------
//
//  Name:       KdcSupplyPacAuthData
//
//  Synopsis:   Creates a PAC for the specified client, encrypts it with the
//              server's key, and packs it into a KERB_AUTHORIZATON_DATA
//
//  Arguments:  UserInfo - Information about user
//              GroupMembership - Users group memberships
//              ServerKey - Key of server, used for signing
//              CredentialKey - if present & valid, used to encrypt supp. creds
//              AddResourceGroups - if TRUE, resources groups will be included
//              EncryptedTicket - Optional ticke to tie PAC to
//              PacAuthData - Receives a KERB_AUTHORIZATION_DATA of type
//                      KERB_AUTH_DATA_PAC, containing a PAC.
//
//  Notes:      PacAuthData should be freed with KerbFreeAuthorizationData.
//
//+---------------------------------------------------------------------------
KERBERR
CADWin2000PAC::KdcSupplyPacAuthData(
    IN PIKerbRequest piReq,
    IN PIKerbPrincipal piUser,
    IN PIKerbPrincipal piServ,
    IN PKERB_AUTHORIZATION_DATA OrgIfRelevant,
    IN OUT PKERB_AUTHORIZATION_DATA * ppAuthData,
    OUT PKERB_EXT_ERROR pExtendedError
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    PPACTYPE pNewPac = NULL;
    KERB_AUTHORIZATION_DATA AuthorizationData = {0};
    ULONG PacSize;
    ULONG  cbCheckSize = 0;
    NTSTATUS Status = STATUS_SUCCESS;

    TRACER(L"CADWin2000PAC::KdcSupplyPacAuthData", (PVOID *) &KerbErr);

    Status = m_piCrypt->GetChecksumSize((CTYPE)KDC_PAC_CHECKSUM, &cbCheckSize);
    if (!NT_SUCCESS(Status))
    {
        KerbErr = KDC_ERR_ETYPE_NOTSUPP;
        FILL_EXT_ERROR(pExtendedError, Status, FILENO, __LINE__);
        goto Cleanup;
    }

    KerbErr = KdcBuildPac(
                 piReq,
                 piUser,
                 piReq->GetServId() == KerbTgs,
                 cbCheckSize,            // leave space for signature
                 &pNewPac,
                 &Status);

    if (!KERB_SUCCESS(KerbErr))
    {
        TRACE_FILELINE(TRACE_VERB,
                    (FILE_AND_LINE, L"GetPAC: Can't get PAC or supp creds: 0x%x", KerbErr));
        D_DebugLog(( DEB_WARN,
            "GetPAC: Can't get PAC or supp creds: 0x%x \n", KerbErr ));

        goto Cleanup;
    }

    //
    //  The PAC is going to be double-encrypted.  This is done by having the
    //  PAC in an EncryptedData, and having that EncryptedData in a AuthData
    //  as part of an AuthDataList (along with the rest of the supp creds).
    //  Finally, the entire list is encrypted.
    //
    //      KERB_AUTHORIZATION_DATA containing {
    //              PAC
    //
    //      }
    //

    //
    // First build inner encrypted data
    //

    PacSize = PAC_GetSize(pNewPac);

    //
    //  What if there is nothing to build ?
    //

    if (PacSize == 0)
    {
        goto Cleanup;
    }

    AuthorizationData.value.auth_data_type = KERB_AUTH_DATA_PAC;
    AuthorizationData.value.auth_data.length = PacSize;
    AuthorizationData.value.auth_data.value = (PUCHAR) MIDL_user_allocate(PacSize);
    if (AuthorizationData.value.auth_data.value == NULL)
    {
        TRACE_FILELINE(TRACE_VERB,
                    (FILE_AND_LINE, L"MIDL_user_allocate failed"));
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    PAC_Marshal(pNewPac, PacSize, AuthorizationData.value.auth_data.value);

    //
    // Compute the signatures
    //

    KerbErr = KdcSignPac(
                piReq,
                piUser,
                piServ,
                &AuthorizationData.value.auth_data.value,
                (PULONG) &AuthorizationData.value.auth_data.length,
                pExtendedError
                );

    if (!KERB_SUCCESS(KerbErr))
    {

        TRACE_FILELINE(TRACE_VERB,
                    (FILE_AND_LINE, L"Failed to sign PAC: 0x%x", KerbErr));
        goto Cleanup;
    }

    //
    // Create the auth data to return
    //

    KerbErr = KdcInsertPacIntoAuthData(
                    OrgIfRelevant,
                    &AuthorizationData,
                    ppAuthData
                    );

    if (!KERB_SUCCESS(KerbErr))
    {
        TRACE_FILELINE(TRACE_VERB,
                    (FILE_AND_LINE, L"Failed to insert pac into new auth data: 0x%x", KerbErr));
        DebugLog((DEB_ERROR,"Failed to insert pac into new auth data: 0x%x\n",
            KerbErr));
        goto Cleanup;
    }

Cleanup:

    if (AuthorizationData.value.auth_data.value != NULL)
    {
        MIDL_user_free(AuthorizationData.value.auth_data.value);
    }

    if (pNewPac != NULL)
    {
        MIDL_user_free(pNewPac);
    }

    return(KerbErr);

}



//+---------------------------------------------------------------------------
//
//  Name:       KdcBuildPac
//
//  Synopsis:
//
//  Arguments:
//
//  Notes:      This will call the Pac handlers with any previous PAC contents
//              from the ReqContext. The Handlers determine what to do with
//              their existing sections.
//              Note this code assumes internal Core structs are known.
//              To get rid of this dependency, IKerbRequest needs to expose
//              enumeration methods for PAC handlers
//
//+---------------------------------------------------------------------------

KERBERR
CADWin2000PAC::KdcBuildPac(
    IN PIKerbRequest   piReq,
    IN PIKerbPrincipal UserInfo,
    IN BOOLEAN IsUpdate,
    IN ULONG SignatureSize,
    OUT PPACTYPE *Pac,
    OUT NTSTATUS *pStatus
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    NTSTATUS Status;
    PPACTYPE NewPac = NULL;
    PPAC_INFO_BUFFER *PacInfo;
    ULONG NumberOfPacHandlers;
    ULONG PacInfoCount = 0, cPAPacCount = 0;

    TRACE(KDC, KdcBuildPac, DEB_FUNCTION);
    TRACER(L"CADWin2000PAC::KdcBuildPac", (PVOID *) &KerbErr);

    //
    // There are no logon_info PAC structures in the Xbox World
    // 

    cPAPacCount = 0;

    //
    // If no PAC handlers, no PAC and nothing to do
    //

    NumberOfPacHandlers = g_KdcPacHandlerList.cElem;
    if (0 == NumberOfPacHandlers)
    {
        return (KerbErr);
    }

    //
    // Allocate a place to hold the Pac info buffers
    //

    PacInfo = (PPAC_INFO_BUFFER *) MIDL_user_allocate(
        (NumberOfPacHandlers + cPAPacCount) *sizeof(PPAC_INFO_BUFFER)
        );
    if (NULL == PacInfo)
    {
        return (KRB_ERR_GENERIC);
    }

    ZeroMemory(
        PacInfo,
        ((NumberOfPacHandlers + cPAPacCount) * sizeof(PPAC_INFO_BUFFER))
        );

    *Pac = NULL;

    //
    //
    //  Call the Pac handlers to build a PAC
    //  iterate using the internal struct directly
    //  todo: add PAC enum interfaces to IKerbRequest
    //
    g_KdcPacHandlerList.Lock.ReadLock();
    for (PLIST_ENTRY ListEntry = g_KdcPacHandlerList.Head.Flink;
         ListEntry && (ListEntry != &g_KdcPacHandlerList.Head);
         ListEntry = ListEntry->Flink)
    {
        PKDC_LIST_ENTRY HandlerEntry =
            (PKDC_LIST_ENTRY)
            CONTAINING_RECORD(ListEntry, KDC_LIST_ENTRY, Next);

        // Called holding PAC lock
        KerbErr = GetPacInfo(
            piReq,
            UserInfo,
            IsUpdate,
            //  outgoing PAC
            &PacInfo[PacInfoCount],
            pStatus,
            (IPACHandler*)HandlerEntry->pData
            );
        if (!KERB_SUCCESS(KerbErr))
        {
            break;
        }
        if (PacInfo[PacInfoCount])
        {
            //  increment the count only if we got PAC info
            PacInfoCount++;
        }
    }
    g_KdcPacHandlerList.Lock.ReadUnlock();

    //  post-Process PA-With identity pac section
    //  the PAC handler does not know how to assign new pac sections
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    //
    // Construct the PAC structure
    //

    if (PacInfoCount == 0)
    {
        //
        // No PAC to build; don't return an empty one
        //
        goto Cleanup;
    }

    //  before initilizing the pac, Make sure the extra PAC sections
    //  immediately follow the sections associated with handlers
    //
    if (PacInfoCount < NumberOfPacHandlers)
    {
        //  if a PAC handler did not provide data,
        //  shift all remaining extra PACs
        for (ULONG iPac = 0; iPac < cPAPacCount; iPac++)
        {
            PacInfo[PacInfoCount + iPac] = PacInfo[NumberOfPacHandlers + iPac];
        }
    }

    Status = PAC_Init(
        SignatureSize,
        PacInfoCount + cPAPacCount,
        PacInfo,
        &NewPac
        );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to init pac: 0x%x\n",Status));
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    *Pac = NewPac;
    NewPac = NULL;

Cleanup:

    if (PacInfo)
    {
        while (PacInfoCount > 0)
        {
            if (PacInfo[--PacInfoCount] != NULL)
            {
                MIDL_user_free(PacInfo[PacInfoCount]);
            }
        }

        MIDL_user_free(PacInfo);
    }

    if (NewPac != NULL)
    {
        MIDL_user_free(NewPac);
    }

    return(KerbErr);
}


//+-------------------------------------------------------------------------
//
//  method:   GetPacInfo
//
//  Synopsis:   Sets up the call for the Pac build handlers
//
//  Effects:
//
//  Arguments:  piReq - kerb request intf
//              User  - user principal interface
//              IsUpdate  - is the PAC being updated
//              PacData - address of the PAC section being updated
//              piHandler - intf pointer for the PAC handler
//
//  Requires:
//
//  Returns:
//
//  Notes:      If PAC sections are to be filtered, it is handled here based
//              on the PA-PAC-REQUEST options.
//
//
//--------------------------------------------------------------------------
KERBERR
CADWin2000PAC::GetPacInfo(
    IN PIKerbRequest            piReq,
    IN PIKerbPrincipal          User,
    IN BOOLEAN                  IsUpdate,
    OUT PPAC_INFO_BUFFER        *pPacData,
    OUT PNTSTATUS               pStatus,
    IN PIPACHandler             piHandler
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    TRACER(L"CADWin2000PAC::GetPacInfo", (PVOID *) &KerbErr);
    PPAC_INFO_BUFFER PrevPacInfo = NULL, CopyPacInfo;

    //
    // Check if this PAC section is requested
    //
//    if (!m_piPacReq->IsPacSectionRequested(piHandler->GetPacType()))
//    {
//        //  PAC is not requested with exception of compound identity
//        goto Cleanup;
//    }

    //
    // If previous PAC_INFO for this handler, pass it along
    //

    if (m_pPacAuth)
    {
        //
        //  loop thru the PAC sections instead of calling PAC_Find
        //  we need to accomodate the extra logon info pac sections
        //  which are served by the same logon info handler
        //
        PrevPacInfo = &m_pPacAuth->Buffers[0];
        ULONG iPac;
        for (iPac = 0; iPac < m_pPacAuth->cBuffers; iPac++, PrevPacInfo++)
        {
            ULONG   ulType = PrevPacInfo->ulType;
            if (ulType == piHandler->GetPacType())
            {
                break;
            }
        }

        if (iPac < m_pPacAuth->cBuffers)
        {
            //
            // Copy the data and sent it along. This is freed later
            //

            CopyPacInfo = (PPAC_INFO_BUFFER) MIDL_user_allocate(
                PrevPacInfo->cbBufferSize + sizeof(PAC_INFO_BUFFER)
                );
            if (NULL == CopyPacInfo) 
            {
                KerbErr = KRB_ERR_GENERIC;
                goto    Cleanup;
            }

            CopyPacInfo->Data         = (PBYTE) (CopyPacInfo + 1);
            CopyPacInfo->cbBufferSize = PrevPacInfo->cbBufferSize;
            CopyPacInfo->ulType       = PrevPacInfo->ulType;

            memcpy(
                CopyPacInfo->Data,
                PrevPacInfo->Data,
                PrevPacInfo->cbBufferSize
                );

            *pPacData = CopyPacInfo;
        }
    }

    //
    // Call the build handler
    //
    KerbErr = piHandler->Build(
        piReq,
        IsUpdate,
        pPacData,
        pStatus
        );

Cleanup:
    return KerbErr;
}


//+-------------------------------------------------------------------------
//
//  Function:   KdcInsertPacIntoAuthData
//
//  Synopsis:   Inserts the PAC into the auth data in the two places
//              it lives - in the IF_RELEVANT portion & in the outer body
//
//  Effects:
//
//  Arguments:  OrgIfRelevant   - IfRelevant data present in the original
//                                ticket minus the PAC
//              PacAuthData     - Pac Auth data
//              UpdatedAuthData - Auth data to update
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KdcInsertPacIntoAuthData(
    IN PKERB_AUTHORIZATION_DATA OrgIfRelevant,
    IN PKERB_AUTHORIZATION_DATA PacAuthData,
    IN OUT PKERB_AUTHORIZATION_DATA * UpdatedAuthData
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    TRACER(L"KdcInsertPacIntoAuthData", (PVOID *) &KerbErr);
    PKERB_AUTHORIZATION_DATA LocalAuthData = NULL;
    PKERB_AUTHORIZATION_DATA LocalIfRelevantData = NULL;
    PKERB_AUTHORIZATION_DATA NewIfRelevantData = NULL;
    KERB_AUTHORIZATION_DATA TempPacData = {0};
    KERB_AUTHORIZATION_DATA TempOldPac = {0};

    if (UpdatedAuthData == NULL)
    {
        return  KRB_ERR_GENERIC;
    }

    NewIfRelevantData = (PKERB_AUTHORIZATION_DATA) MIDL_user_allocate(sizeof(KERB_AUTHORIZATION_DATA));
    if (NewIfRelevantData == NULL)
    {
        return  KRB_ERR_GENERIC;
    }

    ZeroMemory(
        NewIfRelevantData,
        sizeof(KERB_AUTHORIZATION_DATA)
        );

    //
    // First build the IfRelevantData
    //
    // The general idea is to replace, in line, the relevant authorization
    // data. This means (a) putting it into the IfRelevantData or making
    // the IfRelevantData be PacAuthData, and (b) putting it into AuthData
    // as well as changing the IfRelevant portions of that data
    //

    if (OrgIfRelevant != NULL)
    {
        LocalAuthData = const_cast<KERB_AUTHORIZATION_DATA*>(
                            KerbFindAuthDataEntry(
                                KERB_AUTH_DATA_PAC,
                                OrgIfRelevant
                                ));

        if (LocalAuthData == NULL)
        {
            LocalIfRelevantData = PacAuthData;
            PacAuthData->next = OrgIfRelevant;
        }
        else
        {
            //
            // Replace the pac in the if-relevant list with the
            // new one.
            //

            TempOldPac = *LocalAuthData;
            LocalAuthData->value.auth_data.value = PacAuthData->value.auth_data.value;
            LocalAuthData->value.auth_data.length = PacAuthData->value.auth_data.length;

            LocalIfRelevantData = OrgIfRelevant;
        }
    }
    else
    {
        //
        // build a new if-relevant data
        //

        TempPacData = *PacAuthData;
        TempPacData.next = NULL;
        LocalIfRelevantData = &TempPacData;
    }

    //
    // Build a local if-relevant auth data
    //

    KerbErr = KerbPackData(
                  &LocalIfRelevantData,
                  PKERB_IF_RELEVANT_AUTH_DATA_PDU,
                  (PULONG) &NewIfRelevantData->value.auth_data.length,
                  &NewIfRelevantData->value.auth_data.value
                  );

    //
    // fixup the old if-relevant list, if necessary
    //

    if (TempOldPac.value.auth_data.value != NULL)
    {
        *LocalAuthData = TempOldPac;
    }

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    NewIfRelevantData->value.auth_data_type = KERB_AUTH_DATA_IF_RELEVANT;


    //
    // form the list
    //
    NewIfRelevantData->next = *UpdatedAuthData;
    *UpdatedAuthData = NewIfRelevantData;

    //  clear the ptr so it does not get freed
    NewIfRelevantData = NULL;

Cleanup:


    if (NewIfRelevantData != NULL)
    {
        KerbFreeAuthData(NewIfRelevantData);
    }

    return KerbErr;
}


//+-------------------------------------------------------------------------
//
//  Function:   KdcSignPac
//
//  Synopsis:   Signs a PAC by first checksumming it with the
//              server's key and then signing that with the KDC key.
//
//  Effects:    Modifies the server sig & privsvr sig fields of the PAC
//
//  Arguments:  ServerKey - used for server signature
//              KdcKey - used for Kdc signature. If not present, the tgt for
//                      the realm will be looked up and the KDC_PAC_KEYTYPE
//                      will be used.
//              PacData - An marshalled PAC.
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
KERBERR
KdcSignPac(
    IN PIKerbRequest piReq,
    IN PIKerbPrincipal piUser,
    IN OPTIONAL PIKerbPrincipal piServ,
    IN OUT PUCHAR *PacData,
    IN OUT PULONG PacSize,
    OUT PKERB_EXT_ERROR pExtendedError
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    KERBERR KerbErr = KDC_ERR_NONE;
    PPAC_INFO_BUFFER PrivSvrBuffer;
    PPAC_SIGNATURE_DATA PrivSvrSignature;
    PPACTYPE Pac;
    ULONG LocalPacSize;
    //  depending on the request, interpret the
    //  principals. in AS req. Tgt is the service, otherwise
    //  it is  the client
    PIKerbPrincipal piTgt = piReq->GetServId() == KerbTgs ?
        piUser : piServ;

    TRACER(L"KdcSignPac", (PVOID *) &KerbErr);

    //
    // Unmarshal the PAC in place so we can locate the signature buffers
    //

    Pac = (PPACTYPE) *PacData;
    LocalPacSize = *PacSize;
    if (PAC_UnMarshal(Pac, LocalPacSize) == 0)
    {
        D_DebugLog((DEB_ERROR,"Failed to unmarshal pac\n"));
        KerbErr = KRB_ERR_GENERIC;
        TRACE_FILELINE(TRACE_VERB,
                    (FILE_AND_LINE, L"Failed to unmarshal pac: 0x%x", KerbErr));
        goto Cleanup;
    }


    //
    // Locate the signature buffers so the signature fields can be zeroed out
    // before computing the checksum.
    //

    PrivSvrBuffer = PAC_Find(Pac, PAC_PRIVSVR_CHECKSUM, NULL );
    DsysAssert(PrivSvrBuffer != NULL);
    if (PrivSvrBuffer == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    PrivSvrSignature = (PPAC_SIGNATURE_DATA) PrivSvrBuffer->Data;
    PrivSvrSignature->SignatureType = (ULONG) KDC_PAC_CHECKSUM;

    ZeroMemory(
        PrivSvrSignature->Signature,
        PAC_CHECKSUM_SIZE(PrivSvrBuffer->cbBufferSize)
        );

    //
    // Now remarshall the PAC to compute the checksum.
    //

    if (!PAC_ReMarshal(Pac, LocalPacSize))
    {
        DsysAssert(!"PAC_Remarshal Failed");
        KerbErr = KRB_ERR_GENERIC;
        TRACE_FILELINE(TRACE_VERB,
                    (FILE_AND_LINE, L"PAC_Remarshal Failed: 0x%x", KerbErr));
        goto Cleanup;
    }

    //
    // Compute the checksum of the server checksum using the KDC account.
    //

    if (piTgt)
    {
        ULONG cbSize = PAC_CHECKSUM_SIZE(PrivSvrBuffer->cbBufferSize);
        Status = piTgt->Checksum( (CTYPE)KDC_PAC_CHECKSUM,
                                  KERB_NON_KERB_CKSUM_SALT,
                                  piReq->GetEncryptionTypes(),
                                  (PBYTE*)&Pac,
                                  &LocalPacSize,
                                  1,    // 1 buf
                                  NULL, // nothing to verify
                                  NULL,
                                  // again: should not allocate!
                                  PrivSvrSignature->Signature,
                                  &cbSize,
                                  NULL,
                                  pExtendedError);

        if (!NT_SUCCESS(Status))
        {
            KerbErr = KRB_ERR_GENERIC;
            TRACE_FILELINE(TRACE_VERB,
                    (FILE_AND_LINE, L"Failed to compute checksum: 0x%x", Status));
            goto Cleanup;
        }
    }

    if (*PacData != (PBYTE) Pac)
    {
        MIDL_user_free(*PacData);
        *PacData = (PBYTE) Pac;
        *PacSize = LocalPacSize;
    }

Cleanup:

    return(KerbErr);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbRemovePacFromAuthData
//
//  Synopsis:   Remove the PAC from the auth data list
//
//  Effects:
//
//  Arguments:  AuthData    -   [in/out] auth data to process
//              IfRelevantReturn -  [out]
//          ifrelevant data containing auth data different than pac
//
//  Requires:
//
//  Returns:
//
//  Notes:  PAC is removed from all if-relevant data. The first If-relevant
//          data containing something other than PAC is returned.
//          the caller is responsible for freeing the returned data
//
//          More if-relevant data elements containing a PAC are unlinked alltogether
//
//
//--------------------------------------------------------------------------

KERBERR
KerbRemovePacFromAuthData(
    IN OUT PKERB_AUTHORIZATION_DATA *AuthData,
    OUT    PKERB_AUTHORIZATION_DATA *IfRelevantReturn
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    TRACER(L"KerbRemovePacFromAuthData", (PVOID *) &KerbErr);
    PKERB_AUTHORIZATION_DATA RelevantAuthData = NULL;
    PKERB_AUTHORIZATION_DATA PrevAuthData = NULL;

    if (IfRelevantReturn != NULL)
    {
        *IfRelevantReturn = NULL;
    }


    RelevantAuthData = *AuthData;

    //  default return if all nodes get unlinked
    *AuthData = NULL;

    //
    // Loop searching for if-relevantor pac data
    //
    while (RelevantAuthData != NULL)
    {
        PKERB_IF_RELEVANT_AUTH_DATA * IfRelevantData = NULL;
        const KERB_AUTHORIZATION_DATA * PacAuthData = NULL;
        if (RelevantAuthData->value.auth_data_type == KERB_AUTH_DATA_IF_RELEVANT)
        {
            //  process if relevant
            //
            // Unpack it
            //

            KerbErr = KerbUnpackData(
                        RelevantAuthData->value.auth_data.value,
                        RelevantAuthData->value.auth_data.length,
                        PKERB_IF_RELEVANT_AUTH_DATA_PDU,
                        (PVOID *) &IfRelevantData
                        );

            if (KERB_SUCCESS(KerbErr))
            {
                //
                // Look for the PAC in the if-relevant data
                //

                PacAuthData = KerbFindAuthDataEntry(
                                  KERB_AUTH_DATA_PAC,
                                  *IfRelevantData
                                  );
            }
            else
            {
                //
                // We don't mind if we couldn't unpack it.
                // Tickets do not always have PAC information.
                //

                KerbErr = KDC_ERR_NONE;
            }

            if (PacAuthData != NULL)
            {
                if (IfRelevantReturn != NULL &&
                    *IfRelevantReturn == NULL &&
                    (*IfRelevantData)->next != NULL)
                {
                    //  if we have not stored if-relevant AND
                    //  the if-relevant entry containing the PAC has other entries
                    //  preserve the rest of the entries
                    KerbErr = KerbCopyAndAppendAuthData(IfRelevantReturn,
                                                        *IfRelevantData);

                    //  and remove the PAC from the data that was copied
                    if (KERB_SUCCESS(KerbErr))
                    {
                        KerbErr = KerbRemovePacFromAuthData(IfRelevantReturn, NULL);
                    }

                    if (!KERB_SUCCESS(KerbErr)){
                        goto    Cleanup;
                    }
                }

                //  the unpacked struct
                KerbFreeData(
                    PKERB_IF_RELEVANT_AUTH_DATA_PDU,
                    IfRelevantData
                    );

                //
                // Unlink the if-relevant and free it
                //
                if (PrevAuthData != NULL)
                {
                    //  element in the middle
                    PrevAuthData->next = RelevantAuthData->next;
                    RelevantAuthData->next = NULL;
                    KerbFreeAuthData(RelevantAuthData);
                    RelevantAuthData = PrevAuthData->next;
                }
                else
                {
                    //  first element
                    PrevAuthData = RelevantAuthData->next;
                    RelevantAuthData->next = NULL;
                    KerbFreeAuthData(RelevantAuthData);
                    RelevantAuthData = PrevAuthData;
                    PrevAuthData = NULL;
                }


                continue;
            }
            else if (IfRelevantData)
            {

                //  just free the unpacked struct and go on
                KerbFreeData(
                    PKERB_IF_RELEVANT_AUTH_DATA_PDU,
                    IfRelevantData
                    );
            }

        }
        else if (RelevantAuthData->value.auth_data_type == KERB_AUTH_DATA_PAC)
        {
            //  old style auth data
            //
            // Unlink the pac authdata (if not part of the if-relevant)
            //
            // NOTE: Prior to Win2000 Beta3

            if (PrevAuthData != NULL)
            {
                //  element in the middle
                PrevAuthData->next = RelevantAuthData->next;
                RelevantAuthData->next = NULL;
                KerbFreeAuthData(RelevantAuthData);
                RelevantAuthData = PrevAuthData->next;
            }
            else
            {
                //  first element
                PrevAuthData = RelevantAuthData->next;
                RelevantAuthData->next = NULL;
                KerbFreeAuthData(RelevantAuthData);
                RelevantAuthData = PrevAuthData;
                PrevAuthData = NULL;
            }


            continue;
        }

        //  neiter relevant with pac nor pac were found - preserve the auth data
        //  if not initialized
        if (*AuthData == NULL)
        {
            *AuthData = RelevantAuthData;
        }

        //  move to the next
        PrevAuthData = RelevantAuthData;
        RelevantAuthData = RelevantAuthData->next;
    }


Cleanup:
    if (!KERB_SUCCESS(KerbErr) &&
        IfRelevantReturn)
    {
        KerbFreeAuthData(*IfRelevantReturn);
    }

    return(KerbErr);
}

//
//  create a handler instance outside the context of the request
//
NTSTATUS
__stdcall
KdcCreateADHandlerInstance(
    IN  ADDATA_TYPE     ADType,
    OUT IADHandler   ** ppIADHandler
    )
{
    PLIST_ENTRY ListEntry;
    NTSTATUS    Status = STATUS_NOT_FOUND;
    TRACER(L"KdcCreateADHandlerInstance", (PVOID *) &Status);
    KdcADHandlerFactoryList.Lock.ReadLock();
    for (ListEntry = KdcADHandlerFactoryList.Head.Flink;
         ListEntry && (ListEntry != &KdcADHandlerFactoryList.Head);
         ListEntry = ListEntry->Flink)
    {
        //  real ugly. create an instance, check the type
        //  and if no match, release the instance
        //  fortuately we have just 1 handler
        IADHandler  *piAD;
        PKDC_LIST_ENTRY pHandlerEntry =
            (PKDC_LIST_ENTRY) CONTAINING_RECORD(ListEntry, KDC_LIST_ENTRY, Next);

        Status = ((IADHandlerFactory*)pHandlerEntry->pData)->
                CreateInstance(NULL, &piAD);
        if (Status != STATUS_SUCCESS)
            break;
        if (piAD->GetADType() == (ULONG)ADType)
        {
            *ppIADHandler = piAD;
            break;
        }
        //  no match ...
        piAD->Release();
        Status = STATUS_NOT_FOUND;
    }
    KdcADHandlerFactoryList.Lock.ReadUnlock();

    return  Status;
}

//
//  IADPacSection method impl.
//  search for the request pac section and return it
//  to the caller
//
NTSTATUS
__stdcall
CADWin2000PAC::GetPacSection(
    IN ULONG ulPacSection,
    OUT const PAC_INFO_BUFFER **ppRetBuf
    )
{
    if (m_pPacAuth)
    {
        PPAC_INFO_BUFFER pBuf = PAC_Find(m_pPacAuth, ulPacSection, NULL);
        if (pBuf)
        {
            *ppRetBuf = pBuf;
            return  STATUS_SUCCESS;
        }
    }
    return  STATUS_NOT_FOUND;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\server\authdata.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001
//
//  File:       authdata.h
//
//  Contents:   KDC authdata function interfaces
//
//  Classes:
//
//  Functions:
//
//  History:    19-July-2001    JBrezak
//              12-Sept-2001    yordanr - modified for new interface
//
//----------------------------------------------------------------------------

#ifndef _AUTHDATA_H_
#define _AUTHDATA_H_

KERBERR
KdcCheckAuthData(
    IN PIKerbPrincipal          pTgtInfo,
    IN CKerbRequest             *pReq,
    IN PKERB_AUTHORIZATION_DATA AuthData,
    OUT PKERB_EXT_ERROR pExtendedError);


KERBERR
KdcReturnAuthData(
    IN CKerbRequest              *pReq,
    OUT PKERB_AUTHORIZATION_DATA *AuthData,
    OUT PKERB_EXT_ERROR pExtendedError
    );


NTSTATUS
KdcInitializeInternalADHandlers(
    VOID
    );

typedef KERBERR (*KDC_AD_ITERATE_FN) (
    IN PIKdbProvider            piKdb,
    IN KERB_SERVICE_ID          Service,
    IN PIKerbPrincipal              ClientInfo,
    IN PIKerbPrincipal              ServerInfo,
    IN PKERB_KDC_REQUEST_BODY   RequestBody,
    IN CONST ULONG              PreAuthType,
    IN PKERB_ENCRYPTION_KEY     SessionKey,
    IN OUT PKERB_ENCRYPTED_TICKET EncryptedTicket,
    OUT PKERB_EXT_ERROR         ExtendedError,
    IN  CKerbRequest*            pKerbReq,
    IN PIADHandler              Handler,
    IN OUT PVOID                Data
    );

KERBERR
KdcIterateAuthDataHandler(
    IN PIKdbProvider            piKdb,
    IN KERB_SERVICE_ID          Service,
    IN PIKerbPrincipal              ClientInfo,
    IN PIKerbPrincipal              ServerInfo,
    IN PKERB_KDC_REQUEST_BODY   RequestBody,
    IN CONST ULONG              PreAuthType,
    IN PKERB_ENCRYPTION_KEY     SessionKey,
    IN OUT PKERB_ENCRYPTED_TICKET EncryptedTicket,
    OUT PKERB_EXT_ERROR         ExtendedError,
    IN  CKerbRequest*            pKerbReq,
    IN KDC_AD_ITERATE_FN        Func,
    IN OUT PVOID                Data
    );

#endif // _AUTHDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\server\debug.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       debug.cxx
//
//  Contents:   Debug definitions that shouldn't be necessary
//              in the retail build.
//
//  History:    19-Nov-92 WadeR     Created
//
//  Notes:      If you change or add a debug level, also fix debug.hxx
//              This is only compiled if DBG > 0
//
//--------------------------------------------------------------------------


#include "kdcsvr.hxx"
#include "debug.hxx"
#include <tostring.hxx>



//
// The "#pragma hdrstop" causes the preprocessor to forget any "#if"s
// is is processing.  Therefore you can't have it inside an "#if" block.
// So the includes will always compile, and the rest of this code becomes
// conditional.
//


#include <stddef.h>


//
// Variables for heap checking and used by sectrace.hxx:
//

// Set following to HEAP_CHECK_ON_ENTER | HEAP_CHECK_ON_EXIT for heap checking.
DWORD dwHeapChecking = 0;

// This keeps a registry key handle to the HKLM\System\CCSet\Control\LSA\
// Kerberoskey
HKEY hKerbParams = NULL; 
HANDLE hKerbWait = NULL;

//
// Tons and tons of global data to get debugging params from the ini file.
//
// Note: For every trace bit, there must be a label in this array matching
//       that trace bit and only that trace bit.  There can be other labels
//       matching combinations of trace bits.
//

DEBUG_KEY   KdcDebugKeys[] = {  {DEB_ERROR,     "Error"},
                                {DEB_WARN,      "Warning"},
                                {DEB_TRACE,     "Trace"},
                                {DEB_T_KDC,     "Kdc"},
                                {DEB_T_TICKETS, "Tickets"},
                                {DEB_T_DOMAIN,  "Domain"},
                                {DEB_T_SOCK,    "Sock"},
                                {DEB_T_TRANSIT, "Transit"},
                                {DEB_T_PERF_STATS, "Perf"},
                                {DEB_T_PKI, "PKI"},
                                {0, NULL},
                            };



DEFINE_DEBUG2(KDC);
extern DWORD KSuppInfoLevel; // needed to adjust values for common2 dir


////////////////////////////////////////////////////////////////////
//
//  Name:       KerbGetKerbRegParams
//
//  Synopsis:   Gets the debug paramaters from the registry 
//
//  Arguments:  HKEY to HKLM/System/CCS/LSA/Kerberos
//
//  Notes:      Sets KDCInfolevel for debug spew
//
void
KerbGetKerbRegParams(HKEY ParamKey)
{

    DWORD       cbType, tmpInfoLevel = KDCInfoLevel, cbSize = sizeof(DWORD);
    DWORD       dwErr;
 
    dwErr = RegQueryValueExW(
        ParamKey,
        WSZ_DEBUGLEVEL,
        NULL,
        &cbType,
        (LPBYTE)&tmpInfoLevel,
        &cbSize      
        );
    if (dwErr != ERROR_SUCCESS)
    {
        if (dwErr ==  ERROR_FILE_NOT_FOUND)
        {
            // no registry value is present, don't want info
            // so reset to defaults


            // NOTE:  Since SCLogon sux so badly, we're going to log all PKI events for now.
            // FESTER:  Pull for server B3.


#if DBG

            KSuppInfoLevel = KDCInfoLevel = DEB_ERROR | DEB_T_PKI;
            
#else // fre
            KSuppInfoLevel = KDCInfoLevel = DEB_T_PKI;
#endif
        }else{
            DebugLog((DEB_WARN, "Failed to query DebugLevel: 0x%x\n", dwErr));        
        }      

        
    }

    // TBD:  Validate flags?
                      
    KSuppInfoLevel = KDCInfoLevel = tmpInfoLevel;
    
    return;
}

//
// Tempo?
//
/*void FillExtError(PKERB_EXT_ERROR p,NTSTATUS s,ULONG f,ULONG l) 
{                                                               
   if (EXT_ERROR_ON(KDCInfoLevel))                                                  \
   {                                                            
      p->status = s;                                            
      p->klininfo = KLIN(f,l);                                  
   }                                                            
                                                                
   sprintf(xx, "XX File-%i, Line-%i", f,l);                   
   OutputDebugStringA(xx);                                      
                                                                 
} */



////////////////////////////////////////////////////////////////////
//
//  Name:       KerbWatchKerbParamKey
//
//  Synopsis:   Sets RegNotifyChangeKeyValue() on param key, initializes
//              debug level, then utilizes thread pool to wait on
//              changes to this registry key.  Enables dynamic debug
//              level changes, as this function will also be callback
//              if registry key modified.
//
//  Arguments:  pCtxt is actually a HANDLE to an event.  This event
//              will be triggered when key is modified.
//
//  Notes:      .
//
VOID
NTAPI
KerbWatchKerbParamKey(PVOID    pCtxt,
                  BOOLEAN  fWaitStatus)
{
       
    NTSTATUS    Status;
    LONG        lRes = ERROR_SUCCESS;
   
    if (NULL == hKerbParams)  // first time we've been called.
    {
        lRes = RegOpenKeyExW(
                    HKEY_LOCAL_MACHINE,
                    L"System\\CurrentControlSet\\Services\\Kdc\\Parameters",
                    0,
                    KEY_READ,
                    &hKerbParams);
 
        if (ERROR_SUCCESS != lRes)
        {
            DebugLog((DEB_WARN,"Failed to open kerberos key: 0x%x\n", lRes));
            goto Reregister;
        }
    }

    if (NULL != hKerbWait) 
    {
        Status = UnregisterWait(hKerbWait);
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_WARN, "Failed to Deregister wait on registry key: 0x%x\n", Status));
            goto Reregister;
        }

    }

    lRes = RegNotifyChangeKeyValue(
                hKerbParams,
                FALSE,
                REG_NOTIFY_CHANGE_LAST_SET,
                (HANDLE) pCtxt,
                TRUE);

    if (ERROR_SUCCESS != lRes) 
    {
        DebugLog((DEB_ERROR,"Debug RegNotify setup failed: 0x%x\n", lRes));
        // we're tanked now. No further notifications, so get this one
    }
                   
    KerbGetKerbRegParams(hKerbParams);
    
Reregister:
    
    Status = RegisterWaitForSingleObject(&hKerbWait,
                             (HANDLE) pCtxt,
                             KerbWatchKerbParamKey,
                             (HANDLE) pCtxt,
                             INFINITE,
                             WT_EXECUTEONLYONCE);
}

////////////////////////////////////////////////////////////////////
//
//  Name:       WaitKerbCleanup
//
//  Synopsis:   Cleans up for KerbWatchKerbParamKey
//
//  Arguments:  <none>
//
//  Notes:      .
//
VOID 
WaitKerbCleanup(HANDLE hEvent)
{
    NTSTATUS    Status = STATUS_SUCCESS;

    if (NULL != hKerbWait) {
        Status = UnregisterWait(hKerbWait);
        hKerbWait = NULL;
    }

    if (NT_SUCCESS(Status) && NULL != hEvent) {
        CloseHandle(hEvent);
        hEvent = NULL;
    }
}
        


////////////////////////////////////////////////////////////////////
//
//  Name:       GetDebugParams
//
//  Synopsis:   Gets the debug paramaters from the ini file.
//
//  Arguments:  <none>
//
//  Notes:      .
//
void
GetDebugParams()
{
    KDCInitDebug(KdcDebugKeys);
}


#if DBG
//+---------------------------------------------------------------------------
//
//  Function:   PrintIntervalTime
//
//  Synopsis:   
//
//  Arguments:  [DebugFlag] -- 
//              [Message]   -- 
//              [Interval]  -- 
//
//  Returns:    
//
//  Notes:      
//
//----------------------------------------------------------------------------

void 
PrintIntervalTime (
    ULONG DebugFlag,
    LPSTR Message,
    PLARGE_INTEGER Interval )
{
    LONGLONG llTime = Interval->QuadPart;
    LONG lSeconds = (LONG) ( llTime / 10000000 );
    LONG lMinutes = ( lSeconds / 60 ) % 60;
    LONG lHours = ( lSeconds / 3600 );
    DebugLog(( DebugFlag, "%s %d:%2.2d:%2.2d \n", Message, lHours, lMinutes, lSeconds % 60 ));
}

//+---------------------------------------------------------------------------
//
//  Function:   PrintTime
//
//  Synopsis:   
//
//  Arguments:  [DebugFlag] -- 
//              [Message]   -- 
//              [Time]      -- 
//
//  Returns:    
//
//  Notes:      
//
//----------------------------------------------------------------------------

void 
PrintTime (
    ULONG DebugFlag,
    LPSTR Message,
    PLARGE_INTEGER Time )
{
    SYSTEMTIME st;

    FileTimeToSystemTime ( (PFILETIME) Time, & st );
    DebugLog((DebugFlag, "%s %d-%d-%d %d:%2.2d:%2.2d\n", Message, st.wMonth, st.wDay, st.wYear,
                st.wHour, st.wMinute, st.wSecond ));
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\server\kdb.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001
//
//  File:       kdb.cxx
//
//  Contents:   KDB Support functions
//
//  Classes:
//
//  Functions:
//
//  History:    21-June-2001    JBrezak
//              11-Sept-2001    yordanr - change to use new interfaces
//
//----------------------------------------------------------------------------

#include "kdcsvr.hxx"

#include "traceinterface.hxx"
#include "fileno.h"
#define FILENO FILENO_KDC

// Global table of KDB functions - Only modified at startup/shutdown

CKerbList ProvidersList;

PIKdbProvider KdbReferralRealm = NULL;
UNICODE_STRING KrbtgtName = {0};        // "krbtgt"

NTSTATUS WINAPI KdcRegisterProvider(
    IN  IKdbProvider    *piKdbProvider
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    TRACER(L"KdcRegisterProvider", (PVOID *) &Status);

    if (piKdbProvider == NULL)
        return  STATUS_INVALID_PARAMETER;
    //  note the core does not set prov's tgt name ...

    //  see if it's a referral realm
    if (piKdbProvider->Flags() & KERB_KDB_REALM_REFERRAL)
    {
        if (KdbReferralRealm)
        {
            Status = STATUS_DOMAIN_EXISTS;
            return Status;
        }
        else
        {
            KdbReferralRealm = piKdbProvider;
        }
    }

    //  alloc a new list entry
    PKDC_LIST_ENTRY pNewEntry = (PKDC_LIST_ENTRY)MIDL_user_allocate(sizeof(KDC_LIST_ENTRY));
    if (pNewEntry == NULL)
    {
        Status = STATUS_NO_MEMORY;
        return  Status;
    }

    //  and initialize
    pNewEntry->pData = (PVOID)piKdbProvider;
    //  insert in prov list
    ProvidersList.InsertElement(&pNewEntry->Next);

    return  Status;
}


//
//  walk the providers to find one supporting the
//  requested realm
//
KERBERR
KdbRealmLocate(
    IN OPTIONAL PUNICODE_STRING Realm,
    OUT PIKdbProvider *ppiKdb
    )
{
    KERBERR KerbErr = KDC_ERR_WRONG_REALM;
    TRACER(L"KdbRealmLocate", (PVOID *) &KerbErr);

    PLIST_ENTRY ListEntry;
    PKDC_LIST_ENTRY KdbProvider = NULL;

    *ppiKdb = NULL;

    if (Realm != NULL)
    {
        ProvidersList.Lock.ReadLock();

        for (ListEntry = ProvidersList.Head.Flink;
             ListEntry && (ListEntry != &ProvidersList.Head);
             ListEntry = ListEntry->Flink)
        {
            KdbProvider = (PKDC_LIST_ENTRY)
                CONTAINING_RECORD(ListEntry, KDC_LIST_ENTRY, Next);
            ULONG cRealms = 0;
            LPCWSTR const *ppcwszRealms;
            if (((PIKdbProvider)
                KdbProvider->pData)->GetRealms(&cRealms,
                                                &ppcwszRealms) !=
                                                    STATUS_SUCCESS)
            {
                //  BUGBUG todo: log/trace prov could not return realms
                KerbErr = KRB_ERR_GENERIC;
                break;
            }
            while(cRealms--)
            {
                //  case insensitive?
                if (_wcsicmp(ppcwszRealms[cRealms], Realm->Buffer) == 0)
                {
                    *ppiKdb = (PIKdbProvider)KdbProvider->pData;
                    KerbErr = KDC_ERR_NONE;
                    break;
                }
            }
            if (*ppiKdb)
                break;
        }
        ProvidersList.Lock.ReadUnlock();
    }

    // No specific realm found, use the first one that supports referrals
    if (!KERB_SUCCESS(KerbErr) && KdbReferralRealm)
    {
        *ppiKdb = KdbReferralRealm;
        KerbErr = KDC_ERR_NONE;
    }

    return KerbErr;
}

//
//  kerbinterface uses slightly different signature
//
IKdbProvider* KdcGetProvider(PUNICODE_STRING pustrRealm)
{
    IKdbProvider *piKdb = NULL;
    KdbRealmLocate(pustrRealm, &piKdb);
    return  piKdb;
}


//
//  BUGBUG todo: fix these thru ILog etc interfaces
//  these will be
//

NTSTATUS
KdbAuditEvent(
    IN PIKdbProvider       KdbHandle,      // Realm handle
    IN KDC_AUDIT_EVENT  AuditId,
    IN PIKerbRequest  pIKerbRequest,
    IN PKERBERR         KerbStatus,
    IN PULONG           KdcOptions,
    IN PKERB_CRYPT_LIST EncryptionType,
    IN PULONG           PreauthType,
    IN PSOCKADDR        ClientAddress
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    TRACER(L"KdbAuditEvent", (PVOID *)&Status);
    IAudit *pIAudit = KdbHandle ? KdbHandle->GetIAudit() : NULL;
    if (pIAudit == NULL) {
        Status = STATUS_NOT_IMPLEMENTED;
        goto Exit;
        }
    Status = pIAudit->Audit(
                    AuditId,
                    pIKerbRequest,
                    ClientAddress,
                    KerbStatus,
                    KdcOptions,
                    EncryptionType,
                    PreauthType
                    );
Exit:
    return Status;
}

//
//  Increment the perf counter 
//
NTSTATUS
KdbPerfCount(
    IN PIKdbProvider       KdbHandle,      // Realm handle
    IN KERB_PERF_COUNTER   counter
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    TRACER(L"KdbPerfCount", (PVOID *)&Status);
    
    IPerfctr *pIPerfctr = KdbHandle ? KdbHandle->GetIPerfctr() : NULL;
    if (pIPerfctr == NULL) {
        Status = STATUS_NOT_IMPLEMENTED;
        goto Exit;
        }
    Status = pIPerfctr->Increment(
                    counter
                    );
Exit:
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\server\gettgs.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2001.
//
//  File:       gettgs.cxx
//
//  Contents:   GetTGSTicket and support functions
//
//  Classes:
//
//  Functions:
//
//  History:    04-Mar-94   wader   Created
//              16-Sept-2001 yordanr modified for new interfaces
//
//----------------------------------------------------------------------------
#include "kdcsvr.hxx"
//#include "kdctrace.h"
#include <tostring.hxx>
#include "traceinterface.hxx"

#include "fileno.h"


#define FILENO  FILENO_GETTGS

extern LARGE_INTEGER tsInfinity;
extern LONG lInfinity;

UNICODE_STRING KdcNullString = {0,0,NULL};

//----------------------------------------------------------------
//
//  Name:       KdcInsertAuthorizationData
//
//  Synopsis:   Inserts auth data into a newly created ticket.
//
//  Arguments:
//              IN piKdb        - Provider Interface
//              IN RequestBody  - TGS request
//              IN SourceTicket - Source ticket - TGT
//              IN ServiceInfo  - Target service principal
//              IN TgtInfo      - TGT principal
//              IN TargetServiceKey - unused
//              IN pKdcReq      -   KDC request
//              OUT FinalTicket - Ticket to insert Auth data into
//              OUT pExtendedError - extended err info
//
//  Notes:      This copies the authorization data from the source ticket
//              to the destiation ticket, and adds the authorization data
//              passed in.  It is called by GetTGSTicket.
//
//              This assumes that pedAuthData is an encrypted
//              KERB_AUTHORIZATION_DATA.
//              It will copy all the elements of that list to the new ticket.
//              If pedAuthData is not supplied (or is empty), and there is
//              auth data in the source ticket, it is copied to the new
//              ticket.  If no source ticket, and no auth data is passed
//              in, nothing is done.
//
//----------------------------------------------------------------

KERBERR
KdcInsertAuthorizationData(
    IN PIKdbProvider piKdb,
    IN PKERB_KDC_REQUEST_BODY RequestBody,
    IN OPTIONAL PKERB_ENCRYPTED_TICKET SourceTicket,
    IN OPTIONAL PIKerbPrincipal ServiceInfo,
    IN OPTIONAL PIKerbPrincipal TgtInfo,
    IN OPTIONAL PKERB_ENCRYPTION_KEY TargetServiceKey,
    IN OUT CKerbRequest* pKdcReq,
    OUT PKERB_ENCRYPTED_TICKET FinalTicket,
    OUT PKERB_EXT_ERROR pExtendedError
    )
{
    PKERB_AUTHORIZATION_DATA SourceAuthData = NULL;
    PKERB_AUTHORIZATION_DATA FinalAuthData = NULL;
    KERBERR KerbErr = KDC_ERR_NONE;
    //NTSTATUS    Status = STATUS_SUCCESS;
    PKERB_AUTHORIZATION_DATA_LIST * TempAuthData = NULL;
    PKERB_AUTHORIZATION_DATA SuppliedAuthData = NULL;
    PKERB_ENCRYPTED_DATA EncryptedAuthData = NULL;
    TRACER(L"KdcInsertAuthorizationData", (PVOID *) &KerbErr);

    D_DebugLog(( DEB_T_TICKETS, "Inserting authorization data into ticket.\n" ));

    //
    // First try to decrypt the supplied authorization data
    // from the TGS request
    //

    if (RequestBody->bit_mask & enc_authorization_data_present)
    {
        EncryptedAuthData = &RequestBody->enc_authorization_data;

        KerbErr = KerbDecryptDataEx(
                      EncryptedAuthData,
                      &SourceTicket->key,
                      KERB_NON_KERB_SALT,         // WAS BUG: wrong salt, removed per MikeSw
                      &EncryptedAuthData->cipher_text.length,
                      EncryptedAuthData->cipher_text.value
                      );

        if (!KERB_SUCCESS(KerbErr))
        {
            TRACE_FILELINE(TRACE_VERB,
                    (FILE_AND_LINE, L"Failed to decrypt encrypted auth data: 0x%x", KerbErr));
            DebugLog((DEB_WARN,
                      "KLIN(%x) Failed to decrypt encrypted auth data: 0x%x\n",
                      KLIN(FILENO, __LINE__),
                      KerbErr));
            goto Cleanup;
        }

        //
        // Now decode user supplied authdata
        //

        KerbErr = KerbUnpackData(
            EncryptedAuthData->cipher_text.value,
            EncryptedAuthData->cipher_text.length,
            PKERB_AUTHORIZATION_DATA_LIST_PDU,
            (PVOID *) &TempAuthData
            );

        if (!KERB_SUCCESS(KerbErr))
        {
            TRACE_FILELINE(TRACE_VERB,
                    (FILE_AND_LINE, L"Failed to unpack auth data: 0x%x", KerbErr));
            goto Cleanup;
        }
        if (TempAuthData != NULL)
        {
            SuppliedAuthData = *TempAuthData;
        }
    }

    //
    // Check for authdata in the source ticket (TGT)
    //

    if (SourceTicket->bit_mask & KERB_ENCRYPTED_TICKET_authorization_data_present)
    {
        DsysAssert(SourceTicket->KERB_ENCRYPTED_TICKET_authorization_data != NULL);
        SourceAuthData = SourceTicket->KERB_ENCRYPTED_TICKET_authorization_data;
    }


    //
    // Copy source authdata (from TGT)
    //

    if (SourceAuthData != NULL)
    {
        KerbErr = KerbCopyAndAppendAuthData(
            &FinalAuthData,
            SourceAuthData
            );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }
    }

    //
    // Copy supplied authdata (from TGS-REQ)
    //

    if (SuppliedAuthData != NULL)
    {
        KerbErr = KerbCopyAndAppendAuthData(
            &FinalAuthData,
            SuppliedAuthData
            );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }
    }

    //
    // Call authdata return handlers
    //

    KerbErr = KdcReturnAuthData(
                 pKdcReq,
                 &FinalAuthData,
                 pExtendedError);

    if (!KERB_SUCCESS(KerbErr))
    {
        TRACE_FILELINE(TRACE_VERB,
                    (FILE_AND_LINE, L"Failed to return auth data: 0x%x", KerbErr));
        goto Cleanup;
    }


    //
    // setup ticket to return the data
    //
    if (FinalAuthData != NULL)
    {
        FinalTicket->bit_mask |= KERB_ENCRYPTED_TICKET_authorization_data_present;
        FinalTicket->KERB_ENCRYPTED_TICKET_authorization_data = FinalAuthData;
        FinalAuthData = NULL;
    }

    KerbErr = KDC_ERR_NONE;

 Cleanup:

    KerbFreeAuthData(
        FinalAuthData
        );

    if (TempAuthData != NULL)
    {
        KerbFreeData(
            PKERB_AUTHORIZATION_DATA_LIST_PDU,
            TempAuthData
            );
    }

    return(KerbErr);
}


//+---------------------------------------------------------------------------
//
//  Function:   BuildTicketTGS
//
//  Synopsis:   Builds (most of) a TGS ticket
//
//  Arguments:
//              IN piKdb          - provider interface
//              IN ServiceInfo    - service principal
//              IN RequestBody    - The request causing this ticket to be built
//              IN SourceTicke    - The TGT used to make this request
//              IN Referral       - TRUE if this is an inter-realm referral ticke
//              IN S4UClientName  - S4U client
//              INS4UClientRealm  - S4U Realm
//              IN pReq           - kerb request info
//              OUT NewTicket - The new ticket built here.
//              IN OUT pExtendedError
//
//
//  History:    24-May-93   WadeR   Created
//              16-Sept-201 yordanr modified for new interface
//
//  Notes:      see 3.3.3, A.6 of the Kerberos V5 R5.2 spec
//
//----------------------------------------------------------------------------


KERBERR
BuildTicketTGS(
    IN PIKdbProvider piKdb,
    IN PIKerbPrincipal           ServiceInfo,
    IN PKERB_KDC_REQUEST_BODY    RequestBody,
    IN PKERB_TICKET              SourceTicket,
    IN BOOLEAN                   Referral,
    IN OPTIONAL PKERB_INTERNAL_NAME S4UClientName,
    IN OPTIONAL PUNICODE_STRING S4UClientRealm,
    IN CKerbRequest             *pReq,
    OUT PKERB_TICKET             NewTicket,
    IN OUT PKERB_EXT_ERROR       ExtendedError
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    KERB_TICKET OutputTicket;
    PKERB_ENCRYPTED_TICKET EncryptedTicket;
    PKERB_ENCRYPTED_TICKET SourceEncryptPart;
    LARGE_INTEGER TicketLifespan;
    LARGE_INTEGER TicketRenewspan;
    UNICODE_STRING NewTransitedInfo = {0,0,NULL};
    UNICODE_STRING ClientRealm = {0,0,NULL};
    UNICODE_STRING TransitedRealm = {0,0,NULL};
    UNICODE_STRING OldTransitedInfo = {0,0,NULL};
    STRING OldTransitedString;
    ULONG KdcOptions = 0;
    ULONG TicketFlags = 0;
    ULONG SourceTicketFlags = 0;
    PKERB_HOST_ADDRESSES Addresses = NULL;

    TRACER(L"BuildTicketTGS", (PVOID *) &KerbErr);

    D_DebugLog(( DEB_T_TICKETS, "Building a TGS ticket\n" ));

    SourceEncryptPart = (PKERB_ENCRYPTED_TICKET) SourceTicket->encrypted_part.cipher_text.value;
    OutputTicket = *NewTicket;
    EncryptedTicket = (PKERB_ENCRYPTED_TICKET) OutputTicket.encrypted_part.cipher_text.value;

    KdcOptions = KerbConvertFlagsToUlong( &RequestBody->kdc_options );

    //
    // Determine ticket lifetime
    //
    TicketLifespan = ServiceInfo->MaxLifeTime();
    TicketRenewspan = ServiceInfo->MaxRenewTime();

    KerbErr = KdcBuildTicketTimesAndFlags(
                0,                      // no client policy
                ServiceInfo->GetPrincFlags(),
                piKdb->GetKdcPolicy(),
                &TicketLifespan,
                &TicketRenewspan,
                NULL,                   // no acct expiry.
                RequestBody,
                SourceEncryptPart,
                EncryptedTicket,
                ExtendedError
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        D_DebugLog((DEB_ERROR,"KLIN(%x) Failed to build ticket times and flags: 0x%x\n",
            KLIN(FILENO, __LINE__), KerbErr));
        goto Cleanup;
    }

    TicketFlags = KerbConvertFlagsToUlong( &EncryptedTicket->flags );
    SourceTicketFlags = KerbConvertFlagsToUlong( &SourceEncryptPart->flags );

    KerbErr = KerbMakeKey(
                pReq->GetCommonEType(),
                &EncryptedTicket->key
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }


    OldTransitedString.Buffer = (PCHAR) SourceEncryptPart->transited.contents.value;
    OldTransitedString.Length = OldTransitedString.MaximumLength = (USHORT) SourceEncryptPart->transited.contents.length;


    //
    // Fill in the service names
    //

    if (Referral)
    {

        //
        // For referral tickets we put a the name
        //   "krbtgt/remoterealm@localrealm"
        //

        KerbErr = KerbConvertKdcNameToPrincipalName(
                    &OutputTicket.server_name,
                    ServiceInfo->GetName()
                    );

        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }


        //
        // If we got here on a referral ticket and are generating one
        // and the referral ticket we received was not from the client's
        // realm, add in the transited information.
        //

        if (!KerbCompareRealmNames(
                &SourceEncryptPart->client_realm,
                &SourceTicket->realm))
        {


            KerbErr = KerbStringToUnicodeString(
                        &OldTransitedInfo,
                        &OldTransitedString
                        );

            if (!KERB_SUCCESS(KerbErr))
            {
                goto Cleanup;
            }

            KerbErr = KerbConvertRealmToUnicodeString(
                        &TransitedRealm,
                        &SourceTicket->realm
                        );

            if (!KERB_SUCCESS(KerbErr))
            {
                goto Cleanup;
            }

            KerbErr = KerbConvertRealmToUnicodeString(
                        &ClientRealm,
                        &SourceEncryptPart->client_realm
                        );

            if (!KERB_SUCCESS(KerbErr))
            {
                goto Cleanup;
            }

            KerbErr = KdcInsertTransitedRealm(
                        &NewTransitedInfo,
                        &OldTransitedInfo,
                        &ClientRealm,
                        &TransitedRealm,
                        //  realm is in the request
                        pReq->GetRequestRealm()
                        );

            if (!KERB_SUCCESS(KerbErr))
            {
                goto Cleanup;
            }
        }

        KerbErr = KerbConvertUnicodeStringToRealm(
                     &OutputTicket.realm,
                     ServiceInfo->GetRealm()
                     );

        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }

    }
    else
    {

        //
        // If the client didn't request name canonicalization, use the
        // name supplied by the client
        //

        if ((KdcOptions & KERB_KDC_OPTIONS_name_canonicalize) != 0)
        {
            if (KdcIsKrbtgt(ServiceInfo->GetName()))
            {
                PKERB_INTERNAL_NAME TempServiceName = NULL;
                NTSTATUS Status;

                //
                //  Get TGT name from realm
                //

                Status = KerbBuildFullServiceKdcName(
                             pReq->GetRequestRealm(),
                             &KrbtgtName,
                             KRB_NT_SRV_INST,
                             &TempServiceName);

//                Status = KdcRealmGetKrbTgtName(KdbHandle, &TempServiceName);

                if (!NT_SUCCESS(Status))
                {
                    KerbErr = KRB_ERR_GENERIC;
                    goto Cleanup;
                }

                KerbErr = KerbConvertKdcNameToPrincipalName(
                            &OutputTicket.server_name,
                            TempServiceName
                            );

                KerbFreeKdcName(&TempServiceName);

            }
            else

            //
            //  if NC is requested, use the name from the principal interface
            //
            {
                KerbErr = KerbConvertKdcNameToPrincipalName(
                            &OutputTicket.server_name,
                            ServiceInfo->GetName()
                            );
            }
        }
        else
        {

            KerbErr = KerbDuplicatePrincipalName(
                        &OutputTicket.server_name,
                        &RequestBody->KERB_KDC_REQUEST_BODY_server_name
                        );
        }

        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }


        KerbErr = KerbDuplicateRealm(
                     &OutputTicket.realm,
                     RequestBody->realm
                     );

        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }

    }

    //
    // Copy all the other strings over
    //

    EncryptedTicket->client_realm = SourceEncryptPart->client_realm;


    //
    // S4U dance...  Get the client name and realm from
    //
    if (ARGUMENT_PRESENT(S4UClientName) &&
        ARGUMENT_PRESENT(S4UClientRealm) &&
        !Referral)
    {
        KerbErr = KerbConvertKdcNameToPrincipalName(
                        &EncryptedTicket->client_name,
                        S4UClientName
                        );

        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }

        KerbErr = KerbConvertUnicodeStringToRealm(
                    &EncryptedTicket->client_realm,
                    S4UClientRealm
                    );

        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }

    }
    else
    {
        KerbErr = KerbDuplicatePrincipalName(
                    &EncryptedTicket->client_name,
                    &SourceEncryptPart->client_name
                    );

        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }

        EncryptedTicket->client_realm = SourceEncryptPart->client_realm;

    }


    //
    // Insert transited realms, if present
    //

    if (NewTransitedInfo.Length != 0)
    {
        STRING TempString;
        KerbErr = KerbUnicodeStringToKerbString(
                    &TempString,
                    &NewTransitedInfo
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }
        EncryptedTicket->transited.transited_type = DOMAIN_X500_COMPRESS;
        EncryptedTicket->transited.contents.value = (PUCHAR) TempString.Buffer;
        EncryptedTicket->transited.contents.length = (int) TempString.Length;

    }
    else
    {

        EncryptedTicket->transited.transited_type = DOMAIN_X500_COMPRESS;
        EncryptedTicket->transited.contents.value = (PUCHAR) MIDL_user_allocate(OldTransitedString.Length);
        if (EncryptedTicket->transited.contents.value == NULL)
        {
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }
        EncryptedTicket->transited.contents.length = (int) OldTransitedString.Length;
        memcpy(
            EncryptedTicket->transited.contents.value,
            OldTransitedString.Buffer,
            OldTransitedString.Length
            );

    }

    //
    // Insert the client addresses. We only update them if the new ticket
    // is forwarded of proxied and the source ticket was forwardable or proxiable
    // - else we copy the old ones
    //

    if ((((TicketFlags & KERB_TICKET_FLAGS_forwarded) != 0) &&
         ((SourceTicketFlags & KERB_TICKET_FLAGS_forwardable) != 0)) ||
        (((TicketFlags & KERB_TICKET_FLAGS_proxy) != 0) &&
         ((SourceTicketFlags & KERB_TICKET_FLAGS_proxiable) != 0)))
    {
        if ((RequestBody->bit_mask & addresses_present) != 0)
        {
            Addresses = RequestBody->addresses;
        }
    }
    else
    {
        if ((SourceEncryptPart->bit_mask & KERB_ENCRYPTED_TICKET_client_addresses_present) != 0)
        {
            Addresses = SourceEncryptPart->KERB_ENCRYPTED_TICKET_client_addresses;
        }
    }

    if (Addresses != NULL)
    {
        EncryptedTicket->KERB_ENCRYPTED_TICKET_client_addresses = Addresses;
        EncryptedTicket->bit_mask |= KERB_ENCRYPTED_TICKET_client_addresses_present;
    }
    else
    {
        EncryptedTicket->KERB_ENCRYPTED_TICKET_client_addresses = NULL;
        EncryptedTicket->bit_mask &= ~KERB_ENCRYPTED_TICKET_client_addresses_present;
    }

    //
    // The authorization data will be added by the caller, so set it
    // to NULL here.
    //

    EncryptedTicket->KERB_ENCRYPTED_TICKET_authorization_data = NULL;


    OutputTicket.ticket_version = KERBEROS_VERSION;
    *NewTicket = OutputTicket;

Cleanup:
    if (!KERB_SUCCESS(KerbErr))
    {
        KdcFreeInternalTicket(&OutputTicket);
    }

    KerbFreeString(&NewTransitedInfo);
    KerbFreeString(&OldTransitedInfo);
    KerbFreeString(&ClientRealm);
    KerbFreeString(&TransitedRealm);
    return(KerbErr);
}

//+-------------------------------------------------------------------------
//
//  Function:   KdcBuildReferralInfo
//
//  Synopsis:   Builds the referral information to return to the client.
//              We only return the realm name and no server name
//
//  Effects:
//
//  Arguments:  ReferralRealm - realm to refer client to
//              ReferralInfo - recevies encoded referral info
//
//  Requires:
//
//  Returns:    KDC_ERR_NONE        success
//              KDC_ERR_GENERIC     out of memory
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KdcBuildReferralInfo(
    IN const UNICODE_STRING * ReferralRealm,
    OUT PKERB_PA_DATA_LIST *ReferralInfo
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    PKERB_PA_DATA_LIST ListElem = NULL;
    KERB_PA_SERV_REFERRAL ReferralData = {0};
    TRACER(L"KdcBuildReferralInfo", (PVOID *) &KerbErr);

    //
    // Fill in the unencoded structure.
    //

    KerbErr = KerbConvertUnicodeStringToRealm(
                  &ReferralData.referred_server_realm,
                  ReferralRealm
                  );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    ListElem = (PKERB_PA_DATA_LIST) MIDL_user_allocate(sizeof(KERB_PA_DATA_LIST));
    if (ListElem == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }
    ZeroMemory(ListElem, sizeof(KERB_PA_DATA_LIST));

    ListElem->value.preauth_data_type = KRB5_PADATA_REFERRAL_INFO;

    KerbErr = KerbPackData(
                  &ReferralData,
                  KERB_PA_SERV_REFERRAL_PDU,
                  (PULONG) &ListElem->value.preauth_data.length,
                  &ListElem->value.preauth_data.value
                  );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    *ReferralInfo = ListElem;
    ListElem = NULL;

Cleanup:
    if (ListElem != NULL)
    {
        if (ListElem->value.preauth_data.value != NULL)
        {
            KdcFreeEncodedData(ListElem->value.preauth_data.value);
        }
        MIDL_user_free(ListElem);
    }

    KerbFreeRealm(&ReferralData.referred_server_realm);

    return KerbErr;
}


//--------------------------------------------------------------------
//
//  Name:       KdcGetReferralTicket
//
//  Synopsis:   Find a trust to a realm that may have this service
//
//  Arguments:
//              IN piKdb          - provider interface
//              IN Referral realm - realm name
//              OUT ServiceInfo   - realm principal
//              OUT pExtendedError
//
//  Notes:
//
//
//--------------------------------------------------------------------

KERBERR
KdcGetReferralTicket(
    IN PIKdbProvider piKdb,
    IN const UNICODE_STRING * ReferralRealm,
    OUT PIKerbPrincipal *ServiceInfo,
    OUT PKERB_EXT_ERROR pExtendedError
    )
{
    KERBERR KerbErr = KDC_ERR_S_PRINCIPAL_UNKNOWN;
    NTSTATUS Status;
    PKERB_INTERNAL_NAME CrossRealmTgtName = NULL;
    TRACER(L"KdcGetReferralTicket", (PVOID *) &KerbErr);

    Status = KerbBuildFullServiceKdcName(
                  ReferralRealm,
                  &KrbtgtName,
                  KRB_NT_SRV_INST,
                  &CrossRealmTgtName
                  );

    if (!NT_SUCCESS(Status))
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    KerbErr = piKdb->GetPrincipal(
                  KDC_KDB_GET_PRINC_SERVER,
                  CrossRealmTgtName,
                  NULL,
                  NULL,  // may need to carry IKerbRequest
                  ServiceInfo,
                  pExtendedError,
                  NULL
                  );

    KerbFreeKdcName(&CrossRealmTgtName);

Cleanup:

    return KerbErr;
}


//--------------------------------------------------------------------
//
//  Name:       I_RenewTicket
//
//  Synopsis:   Renews an internal ticket.
//
//  Arguments:  IN piKdb         - provider interface
//              IN SourceTicket - Source ticket for this request
//              IN ServiceName - Name of service for ticket
//              IN ServiceInfo - service principal
//              IN RequestBody - Body of ticket request
//              IN pKerbReq    - Request info
//              OUT CommonEType - Receives common encryption type for service ticket
//              OUT NewTicket - Receives new ticket
//              OUT pExtendedError -
//
//  Notes:      Validates the ticket, gets the service's current key,
//              and builds the reply.
//
//
//--------------------------------------------------------------------


KERBERR
I_RenewTicket(
    IN PIKdbProvider piKdb,
    IN PKERB_TICKET SourceTicket,
    IN PKERB_INTERNAL_NAME ServiceName,
    IN PIKerbPrincipal ServiceInfo,
    IN PKERB_KDC_REQUEST_BODY RequestBody,
    IN CKerbRequest *pKerbReq,
    OUT PULONG CommonEType,
    OUT PKERB_TICKET NewTicket,
    OUT PKERB_EXT_ERROR pExtendedError
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    PKERB_ENCRYPTED_TICKET SourceEncryptPart =
        (PKERB_ENCRYPTED_TICKET)
            SourceTicket->encrypted_part.cipher_text.value;
    PKERB_ENCRYPTED_TICKET NewEncryptPart =
        (PKERB_ENCRYPTED_TICKET)
            NewTicket->encrypted_part.cipher_text.value;
//    PKERB_KEY_DATA ServerKey;
    BOOLEAN NamesEqual = FALSE;

    TRACER(L"I_RenewTicket", (PVOID *) &KerbErr);



    D_DebugLog(( DEB_TRACE, "Trying to renew a ticket to "));
    D_KerbPrintKdcName(DEB_TRACE, ServiceName );


    //
    // Make sure the original is renewable.
    //

    if ((KerbConvertFlagsToUlong(&SourceEncryptPart->flags) & KERB_TICKET_FLAGS_renewable) == 0)
    {
        D_DebugLog((DEB_WARN, "KLIN(%x) Attempt made to renew non-renewable ticket\n",
            KLIN(FILENO, __LINE__)));
        KerbErr = KDC_ERR_BADOPTION;
        goto Cleanup;
    }

    //
    // Make sure the source ticket service equals the service from the ticket info
    //

    KerbErr = KerbCompareKdcNameToPrincipalName(
                &SourceTicket->server_name,
                ServiceName,
                &NamesEqual
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    if (!NamesEqual)
    {
        //
        // Make sure we the renewed ticket is for the same service as the original.
        //
        FILL_EXT_ERROR(pExtendedError, STATUS_KDC_INVALID_REQUEST, FILENO, __LINE__);

        KerbErr = KDC_ERR_BADOPTION;
        goto Cleanup;
    }

    //
    // Build the renewal ticket
    //

    KerbErr = BuildTicketTGS(
                piKdb,
                ServiceInfo,
                RequestBody,
                SourceTicket,
                FALSE,          // not referral
                NULL,           // not doing s4u
                NULL,           // not doing s4u
                pKerbReq,
                NewTicket,
                pExtendedError
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        D_DebugLog((DEB_ERROR,
            "KLIN(%x) Failed to build TGS ticket for renewal: 0x%x\n",
            KLIN(FILENO, __LINE__), KerbErr));
        goto Cleanup;
    }


    //
    // BuildTicket puts a random session key in the ticket,
    // so replace it with the one from the source ticket.
    //

    KerbFreeKey(
        &NewEncryptPart->key
        );

    KerbErr = KerbDuplicateKey(
                &NewEncryptPart->key,
                &SourceEncryptPart->key
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }


    //
    // Insert the auth data into the new ticket.
    //

    //
    // BUG 455049: if the service password changes, this will cause problems
    // because we don't resign the pac.
    //


    KerbErr = KdcInsertAuthorizationData(
                piKdb,
                RequestBody,
                SourceEncryptPart,
                ServiceInfo,
                NULL,   // oldkey
                NULL,   // newkey
                pKerbReq,
                NewEncryptPart,
                pExtendedError
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"KLIN(%x) Failed to insert authorization data: 0x%x\n",
            KLIN(FILENO, __LINE__), KerbErr));
        goto Cleanup;
    }

Cleanup:

    if (!KERB_SUCCESS(KerbErr))
    {
        KdcFreeInternalTicket(
            NewTicket
            );
    }

    return(KerbErr);

}

//--------------------------------------------------------------------
//
//  Name:       I_Validate
//
//  Synopsis:   Validates a post-dated ticket so that it can be used.
//              This is not implemented.
//
//  Arguments:  IN piKdb            - provider interface
//              IN SourceTicket     - ticket to be validated
//              IN ServiceName      - unused
//              IN ClientRealm      - LSA only
//              IN RequestBody      - holds nonce for new ticket
//              IN pKdcReq
//              OUT CommonEType
//              OUT NewTicket       - new ticket
//              OUT pExtendedError
//
//  Notes:      See 3.3 of the Kerberos V5 R5.2 spec
//              yordanr - these needs more detailed comments
//
//--------------------------------------------------------------------


KERBERR
I_Validate(
    IN PIKdbProvider piKdb,
    IN PKERB_TICKET SourceTicket,
    IN PKERB_INTERNAL_NAME ServiceName,
    IN PUNICODE_STRING ClientRealm,
    IN PKERB_KDC_REQUEST_BODY RequestBody,
    IN CKerbRequest *pKdcReq,
    OUT PULONG CommonEType,
    OUT PKERB_TICKET NewTicket,
    OUT PKERB_EXT_ERROR pExtendedError
    )
{
    return(KRB_ERR_GENERIC);
#ifdef notdef
    TRACER(L"I_Validate", (PVOID *) &KerbErr);

    HRESULT hr;
    const KDC_POLICY_VALUES *pPolicy = piKdc->GetKdcPolicy();

    D_DebugLog(( DEB_TRACE, "Trying to validate a ticket to '%ws' for '%ws'...\n",
                pkitSourceTicket->ServerName.accsid.pwszDisplayName,
                pkitSourceTicket->kitEncryptPart.Principal.accsid.pwszDisplayName ));
    PrintRequest( DEB_T_TICKETS, pktrRequest );
    PrintTicket( DEB_T_TICKETS, "Ticket to validate:", pkitSourceTicket );


    if ( (pkitSourceTicket->kitEncryptPart.fTicketFlags &
            (KERBFLAG_POSTDATED | KERBFLAG_INVALID))
         != (KERBFLAG_POSTDATED | KERBFLAG_INVALID) )
    {
        hr = KDC_E_BADOPTION;
    }
    else if (_wcsicmp(pkitSourceTicket->ServerName.accsid.pwszDisplayName,
                     pasService->pwszDisplayName) != 0)
    {
        hr = KDC_E_BADOPTION;
    }
    else
    {
        TimeStamp tsNow, tsMinus, tsPlus;
        GetCurrentTimeStamp( &tsNow );
        tsMinus = tsNow - pPolicy->TimeSkew;
        tsPlus = tsNow + pPolicy->TimeSkew;
        PrintTime(DEB_TRACE, "Current time: ", tsNow );
        PrintTime(DEB_TRACE, "Past time: ", tsMinus );
        PrintTime(DEB_TRACE, "Future time: ", tsPlus );

        if (pkitSourceTicket->kitEncryptPart.tsStartTime > tsPlus )
            hr = KRB_E_TKT_NYV;
        else if (pkitSourceTicket->kitEncryptPart.tsEndTime < tsMinus )
            hr = KRB_E_TKT_EXPIRED;
        else
        {

            *pkitTicket = *pkitSourceTicket;
            pkitTicket->kitEncryptPart.fTicketFlags &= (~KERBFLAG_INVALID);
            hr = S_OK;
        }
    }
    return(hr);
#endif // notdef
}



//--------------------------------------------------------------------
//
//  Name:       I_GetTGSTicket
//
//  Synopsis:   Gets an internal ticket using a KDC ticket (TGT).
//
//  Arguments:  IN piKdb        - provider interface
//              IN SourceTicket - TGT for the client
//              IN ClientName   - client requesting a tkt
//              IN ServiceName  - Service to get a ticket to
//              IN ServiceRealm - realm of the service
//              IN RequestBody  - Body of KDC request message
//              IN ApServiceInfo - Ticket info for the service of the
//                      source ticket
//              IN TicketEncryptionKey - If present, then this is a
//                      enc_tkt_in_skey request and the PAC should be
//                      encrypted with this key.
//              OUT RetServiceInfo - target service principal
//              IN  pKerbReq    - request info
//              OUT Ticket      - Receives newly created ticket
//              OUT ReplyPaData - Contains any PA data to put in the reply
//              OUT pExtendedError
//
//  Notes:      See GetTGSTicket.
//
//
//--------------------------------------------------------------------


KERBERR
I_GetTGSTicket(
    IN PIKdbProvider piKdb,
    IN PKERB_TICKET SourceTicket,
    IN PKERB_INTERNAL_NAME ClientName,
    IN PKERB_INTERNAL_NAME ServiceName,
    IN const UNICODE_STRING * ServiceRealm,
    IN PKERB_KDC_REQUEST_BODY RequestBody,
    IN PIKerbPrincipal ApServiceInfo,                   // i.e. krbtgt
    IN OPTIONAL PKERB_ENCRYPTION_KEY TicketEncryptionKey,
    OUT PIKerbPrincipal *RetServiceInfo,
    IN CKerbRequest *pKerbReq,
    OUT PULONG CommonEType,
    OUT PKERB_TICKET Ticket,
    OUT PKERB_PA_DATA_LIST * ReplyPaData,
    OUT PKERB_EXT_ERROR pExtendedError
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    NTSTATUS    Status = STATUS_SUCCESS;
    UNICODE_STRING LocalServiceName;
    BOOLEAN Referral = FALSE;
    KERB_ENCRYPTED_TICKET EncryptedTicket = {0};
    PKERB_ENCRYPTED_TICKET OutputEncryptedTicket = NULL;
    PKERB_ENCRYPTED_TICKET SourceEncryptPart = NULL;
    KERB_TICKET NewTicket = {0};
//    PKERB_KEY_DATA ServerKey = NULL;
//    PKERB_ENCRYPTION_KEY OldServerKey;
    PIKerbPrincipal ServiceInfo = NULL;
    ULONG NameFlags = 0;
    ULONG KdcOptions = 0;
    TRACER(L"I_GetTGSTicket", (PVOID *) &KerbErr);


    //
    // Store away the encrypted ticket from the output ticket to
    // assign it at the end.
    //
    SourceEncryptPart = (PKERB_ENCRYPTED_TICKET) SourceTicket->encrypted_part.cipher_text.value;
    OutputEncryptedTicket = (PKERB_ENCRYPTED_TICKET) Ticket->encrypted_part.cipher_text.value;

    NewTicket.encrypted_part.cipher_text.value = (PUCHAR) &EncryptedTicket;

    //
    // Copy the space for flags from the real destination.
    //

    EncryptedTicket.flags = OutputEncryptedTicket->flags;

    LocalServiceName.Buffer = NULL;

    D_DebugLog(( DEB_TRACE, "Trying to build a new ticket to "));
    D_KerbPrintKdcName( DEB_TRACE, ServiceName );


    KdcOptions = KerbConvertFlagsToUlong( &RequestBody->kdc_options );
    if (KdcOptions & (KERB_KDC_OPTIONS_unused7 |
                        KERB_KDC_OPTIONS_reserved |
                        KERB_KDC_OPTIONS_unused9) )
    {
        DebugLog(( DEB_ERROR,"KLIN(%x) Bad options in TGS request: 0x%x\n",
            KLIN(FILENO, __LINE__), KdcOptions ));
        KerbErr = KDC_ERR_BADOPTION;
        goto Cleanup;
    }

    //
    // Check if the client said to canonicalize the name
    //

    //if ((KdcOptions & KERB_KDC_OPTIONS_name_canonicalize) != 0)
    {
        NameFlags |= KDC_KDB_GET_PRINC_CANONICALIZE;
    }


    //
    // Verify this account is allowed to issue tickets.
    //

    if (!KdcIsKrbtgt(ApServiceInfo->GetName()))
    {
        D_DebugLog((DEB_ERROR,"Trying to make a TGS request with a ticket to\n"));
        KerbPrintKdcName(DEB_ERROR, ApServiceInfo->GetName());

        KerbErr = KRB_AP_ERR_NOT_US;
        goto Cleanup;
    }

    //
    // Get the requested target principal
    //

    KerbErr = piKdb->GetPrincipal(
                 NameFlags | KDC_KDB_GET_PRINC_SERVER |
                        KDC_KDB_GET_PRINC_FOLLOW_REFERRALS,
                 ServiceName,
                 ServiceRealm->Buffer,
                 pKerbReq,
                 &ServiceInfo,                 // ServiceName
                 pExtendedError,
                 NULL
                 );

    //
    // If the KDB cannot provide a principal, try to create
    // a referral as long as the request indicates that
    // a referral will be accepted.
    //
    if ((KerbErr == KDC_ERR_S_PRINCIPAL_UNKNOWN) &&
        (ServiceRealm == NULL) &&
        ((KdcOptions & KERB_KDC_OPTIONS_name_canonicalize) != 0))
    {

        //
        // See if we can manufacture a referral
        //

        KerbErr = KdcGetReferralTicket(
                     piKdb,
                     ServiceRealm,
                     &ServiceInfo,
                     pExtendedError
                     );
    }

    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_WARN,"KLIN(%x) Failed to find target in requested realm ", KLIN(FILENO, __LINE__)));
        KerbPrintKdcName(DEB_WARN,ServiceName);
        DebugLog((DEB_WARN,"\t 0x%x\n",KerbErr));
        goto Cleanup;
    }

    DsysAssert(ServiceInfo != NULL);
    pKerbReq->m_piServerPrincipal = ServiceInfo;
    //  here we can also recalculate the etype
    const ETYPE*    pETypes = NULL;
    ULONG   cEtypes = 0;
    ServiceInfo->GetEtypes(&pETypes, &cEtypes);
    Status = KerbFindCommonEType(RequestBody->encryption_type,
                                 cEtypes,
                                 pETypes,
                                 CommonEType);
    if (!NT_SUCCESS(Status))
    {
        //  no etype match
        KerbErr = KDC_ERR_ETYPE_NOTSUPP;
        goto    Cleanup;
    }

    if ((!KdcIsKrbtgt(ServiceInfo->GetName())) &&
        ((ServiceInfo->GetPrincFlags() & KERB_KDB_DISALLOW_ALL_TIX) != 0))
    {
        KerbErr = KDC_ERR_CLIENT_REVOKED;
        D_DebugLog((DEB_WARN,"KLIN(%x) Failed to normalize, account is disabled ",
                    KLIN(FILENO, __LINE__)));
        KerbPrintKdcName(DEB_WARN, ServiceName);
        D_DebugLog((DEB_WARN,"\t 0x%x\n",KerbErr));
        FILL_EXT_ERROR(pExtendedError, STATUS_ACCOUNT_DISABLED, FILENO, __LINE__);
        goto Cleanup;
    }

    //
    // If we got back a krbtgt but didn't request one, then this is a referral
    //

    if (KdcIsKrbtgt(ServiceInfo->GetName()) &&
        !KdcIsKrbtgt(ServiceName))
    {
        //  hmmm what kind of assignment should we do here?
        ServiceRealm = ServiceInfo->GetRealm();
        Referral = TRUE;
    }

    //
    // Check KDB ticket restrictions - unless you are requesting a ticket
    // to yourself.
    //

    if (!KerbEqualKdcNames(ClientName, ServiceName))
    {
        if (ServiceInfo->GetPrincFlags() & KERB_KDB_DISALLOW_SVR)
        {
            KerbErr = KDC_ERR_SVC_UNAVAILABLE;

            DebugLog((DEB_ERROR,"KLIN(%x) Service principal not allowed ",
                      KLIN(FILENO,__LINE__), KerbErr ));
            KerbPrintKdcName(DEB_ERROR, ServiceName);
            goto Cleanup;
        }

        if (ServiceInfo->GetPrincFlags() & KERB_KDB_REQUIRE_USER2USER)
        {
            KerbErr = KDC_ERR_MUST_USE_USER2USER;

            DebugLog((DEB_ERROR,"KLIN(%x) Service principal requires user2user ",
                      KLIN(FILENO,__LINE__), KerbErr ));
            KerbPrintKdcName(DEB_ERROR, ServiceName);
            goto Cleanup;
        }
    }

    //
    // If this isn't an interdomain trust account, go ahead and issue a normal
    // ticket.
    //

    if (!KdcIsKrbtgt(ServiceInfo->GetName()))
    {
        //
        // Check whether service is interactive, 'cause you can't
        // get a ticket to an interactive service.
        //
        KerbErr = BuildTicketTGS(
                    piKdb,
                    ServiceInfo,
                    RequestBody,
                    SourceTicket,
                    Referral,
                    NULL,
                    NULL,
                    pKerbReq,
                    &NewTicket,
                    pExtendedError
                    );

        if (!KERB_SUCCESS(KerbErr))
        {
            D_DebugLog((DEB_ERROR,"KLIN(%x) Failed to build TGS ticket for %wZ : 0x%x\n",
                    KLIN(FILENO, __LINE__), &LocalServiceName, KerbErr ));
            goto Cleanup;
        }
    }
    else
    {
        //
        // Need to build a referal ticket.
        //

        D_DebugLog(( DEB_T_KDC, "GetTGSTicket: referring to domain "));
        KerbPrintKdcName(
            DEB_WARN,
            ServiceInfo->GetName()
            );

        //
        // build the tgs
        //
        KerbErr = BuildTicketTGS(
                    piKdb,
                    ServiceInfo,
                    RequestBody,
                    SourceTicket,
                    TRUE,
                    NULL,  // not doing s4u
                    NULL,  // not doing s4u
                    pKerbReq,
                    &NewTicket,
                    pExtendedError
                    );

        if (!KERB_SUCCESS(KerbErr))
        {
            D_DebugLog((DEB_ERROR,"KLIN(%x) Failed to build TGS ticket 0x%x for: ",
                    KLIN(FILENO, __LINE__), KerbErr ));
            D_KerbPrintKdcName(
                DEB_ERROR,
                ApServiceInfo->GetName()
                );

            goto Cleanup;
        }


        //
        // If this is a referral, return the target realm
        //

        if (Referral && ((KdcOptions & KERB_KDC_OPTIONS_name_canonicalize) != 0))
        {

            D_DebugLog((DEB_TRACE,"Building referral info for realm %wZ\n",
                        ServiceRealm ));

            KerbErr = KdcBuildReferralInfo(
                        ServiceRealm,
                        ReplyPaData
                        );

            if (!KERB_SUCCESS(KerbErr))
            {
                goto Cleanup;
            }
        }

    }

    //
    // Insert the auth data into the new ticket.
    //

    KerbErr = KdcInsertAuthorizationData(
                piKdb,
                RequestBody,
                (PKERB_ENCRYPTED_TICKET) SourceTicket->encrypted_part.cipher_text.value,
                ServiceInfo,
                ApServiceInfo,
                // only possibility is the ticket key. If it's NULL
                //  the API should use the server key
                TicketEncryptionKey,
                pKerbReq,
                &EncryptedTicket,
                pExtendedError
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"KLIN(%x) Failed to insert authorization data: 0x%x\n",
            KLIN(FILENO, __LINE__), KerbErr));
        goto Cleanup;
    }

    *Ticket = NewTicket;
    *OutputEncryptedTicket = EncryptedTicket;
    Ticket->encrypted_part.cipher_text.value = (PUCHAR) OutputEncryptedTicket;

    *RetServiceInfo = ServiceInfo;
    ServiceInfo = NULL;

    if (Referral)
        KdbPerfCount(piKdb, KerbKdcTgsReferralCounter);

Cleanup:

    //
    //  only release if ownership has not been taken
    //
    if (ServiceInfo && !pKerbReq->m_piServerPrincipal)
        ServiceInfo->Release();

    if (!KERB_SUCCESS(KerbErr))
    {
        KdcFreeInternalTicket(
            &NewTicket
            );
    }

    return(KerbErr);
}




//+-------------------------------------------------------------------------
//
//  Function:   KerbUnpackAdditionalTickets
//
//  Synopsis:   Unpacks the AdditionalTickets field of a KDC request
//              and (a) verifies that the ticket is TGT for this realm
//              and (b) the ticket is encrypted with the corret key and
//              (c) the ticket is valid
//
//  Effects:    allocate output ticket
//
//  Arguments:  IN piKdb      - provider
//              IN KdcOptions - request flags
//              IN TicketList - tickets to unpack
//              OUT U2UTicket - resulting U2U ticket
//              IN pKerbReq   - request info
//
//  Requires:
//
//  Returns:
//
//  Notes:      there can only be one additional ticket
//
//
//--------------------------------------------------------------------------


KERBERR
KdcUnpackAdditionalTickets(
    IN PIKdbProvider piKdb,
    IN ULONG KdcOptions,
    IN PKERB_TICKET_LIST TicketList,
    OUT PKERB_ENCRYPTED_TICKET * U2UTicket,
    IN  CKerbRequest *pKerbReq,
    OUT PKERB_EXT_ERROR pExtendedError
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
//    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_ENCRYPTED_TICKET EncryptedTicket = NULL;
    UNICODE_STRING ServerNames[1] = {0};
//    PKERB_ENCRYPTION_KEY EncryptionKey = NULL;
    PKERB_TICKET Ticket;
    KERB_REALM LocalRealm = NULL;
    PIKerbPrincipal KrbtgtInfo = NULL;
    TRACER(L"KdcUnpackAdditionalTickets", (PVOID *) &KerbErr);

    *U2UTicket = NULL;

    //
    // Verify that there is a ticket & that there is only one ticket
    //

    if (TicketList == NULL)
    {
        D_DebugLog((DEB_ERROR,"KLIN(%x) Trying to unpack null ticket\n",
                  KLIN(FILENO, __LINE__)));
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }


    //
    // Handle User2User additional ticket
    //

    if ((KdcOptions & KERB_KDC_OPTIONS_enc_tkt_in_skey) != 0)
    {

        //
        // Ticket is encrypted in the KRBTGT key
        //

        //  BUGBUG todo: check that logic!!!
        //  krbtgt should be already known, why get it again???
        //  let's assume KerbTgt is kept in ClientPrincipal in KerbRequest
        KrbtgtInfo = pKerbReq->GetIPrincClient();
        Ticket = &TicketList->value;

        //
        // Verify the ticket, first with the normal password list
        //


        KerbErr = KerbConvertKdcNameToString(
                      &ServerNames[0],
                      KrbtgtInfo->GetName(),
                      NULL
                      );

        if (!KERB_SUCCESS(KerbErr))
        {
            goto    Cleanup;
        }

        //
        // NOTE: we only allow additional tickets from our realm. This
        // means cross-realm TGTs can't be used as additional tickets.
        //

        KerbErr = KerbVerifyTicket(
                     pKerbReq,
                     Ticket,
                     1,
                     ServerNames,
                     // hmm ... this could be multiple realms
                     KrbtgtInfo->GetRealm(),
                     KrbtgtInfo,
                     // pass the enc. type along with principal
                     // actually assume the etype is the same as the request
                     // match. there's no reason to be otherwise for tickets
                     // coming from the same client
                  //   Ticket->encrypted_part.encryption_type,
                     &piKdb->GetKdcPolicy()->TimeSkew,
                     &EncryptedTicket,
                     pExtendedError
                     );

        if (!KERB_SUCCESS(KerbErr))
        {
            DebugLog((DEB_ERROR,"KLIN(%x) Failed to verify additional ticket: 0x%x\n",
                      KLIN(FILENO, __LINE__),KerbErr));
            goto Cleanup;
        }

        //  hmm again this needs to be changed for multiple realms support!
        //  most likely the realm has to come from the req.

        KerbErr = 